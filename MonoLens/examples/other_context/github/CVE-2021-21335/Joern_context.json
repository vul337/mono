{
    "cve_id": "CVE-2021-21335",
    "cwe_id": "CWE-287",
    "commit_url": "https://github.com/stnoonan/spnego-http-auth-nginx-module/commit/a06f9efca373e25328b1c53639a48decd0854570",
    "patch_names": [
        {
            "func_name": "ngx_http_auth_spnego_handler",
            "file_path": "ngx_http_auth_spnego_module.c"
        }
    ],
    "before_context": [
        {
            "file_path": "ngx_http_auth_spnego_module.c",
            "patch": [
                {
                    "func_name": "ngx_http_auth_spnego_handler",
                    "patch": "--- func_before\n+++ func_after\n@@ -48,7 +48,7 @@\n             /* If basic auth is enabled and basic creds are supplied\n              * attempt basic auth.  If we attempt basic auth, we do\n              * not fall through to real SPNEGO */\n-            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n+            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                 spnego_debug0(\"Basic auth failed\");\n                 if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                     spnego_debug0(\"Error setting headers\");"
                }
            ],
            "related_methods_ngx_http_auth_spnego_module_c": [
                "ngx_http_auth_spnego_handler spnego_debug3 spnego_debug0 ngx_http_get_module_loc_conf ngx_http_get_module_ctx ngx_http_auth_spnego_token ngx_http_set_ctx ngx_log_debug3 spnego_debug1 ngx_log_debug0 ngx_http_auth_spnego_headers ngx_palloc ngx_http_auth_basic_user ngx_http_auth_spnego_auth_user_gss ngx_log_debug1 ngx_spnego_authorized_principal ngx_http_auth_spnego_basic ngx_http_auth_spnego_headers_basic_only"
            ],
            "bfs_ngx_http_auth_spnego_module_c": {
                "calleeMethods": [
                    [
                        "<empty>",
                        "<operator>.equals",
                        "<operator>.equals",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "ngx_http_get_module_ctx",
                        "ngx_http_get_module_ctx",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.addressOf",
                        "<operator>.addressOf",
                        "",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "spnego_debug1",
                        "ngx_http_auth_spnego_module.c:48:49:spnego_debug1:2",
                        "#define spnego_debug1(msg, one) ngx_log_debug1(\\ /* <=== ngx_http_auth_spnego_module.c:48:49:spnego_debug1:2 */ \n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one)",
                        2
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "ngx_spnego_authorized_principal",
                        "ngx_spnego_authorized_principal",
                        "    static bool /* <=== ngx_spnego_authorized_principal */ \nngx_spnego_authorized_principal(\n        ngx_http_request_t * r,\n        ngx_str_t *princ,\n        ngx_http_auth_spnego_loc_conf_t *alcf)\n{\n    if (NGX_CONF_UNSET_PTR == alcf->auth_princs) {\n        return true;\n    }\n    size_t ii = 0;\n    ngx_str_t *auth_princs = alcf->auth_princs->elts;\n    spnego_debug1(\"Testing against %d auth princs\", alcf->auth_princs->nelts);\n    for (; ii < alcf->auth_princs->nelts; ++ii) {\n        if (auth_princs[ii].len != princ->len) {\n            continue;\n        }\n        if (ngx_strncmp(auth_princs[ii].data, princ->data, princ->len) == 0) {\n            spnego_debug2(\"Authorized user %.*s\", princ->len, princ->data);\n            return true;\n        }\n    }\n    return false;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "ngx_http_get_module_loc_conf",
                        "ngx_http_get_module_loc_conf",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.fieldAccess",
                        "<operator>.fieldAccess",
                        "",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "ngx_http_auth_spnego_basic",
                        "ngx_http_auth_spnego_basic",
                        "    ngx_int_t /* <=== ngx_http_auth_spnego_basic */ \nngx_http_auth_spnego_basic(\n        ngx_http_request_t * r,\n        ngx_http_auth_spnego_ctx_t * ctx,\n        ngx_http_auth_spnego_loc_conf_t * alcf)\n{\n    ngx_str_t host_name;\n    ngx_str_t service;\n    ngx_str_t user;\n    user.data = NULL;\n    ngx_str_t new_user;\n    ngx_int_t ret = NGX_DECLINED;\n\n    krb5_context kcontext = NULL;\n    krb5_error_code code;\n    krb5_principal client = NULL;\n    krb5_principal server = NULL;\n    krb5_creds creds;\n    krb5_get_init_creds_opt *gic_options = NULL;\n    int kret = 0;\n    char *name = NULL;\n    char *p = NULL;\n\n    code = krb5_init_context(&kcontext);\n    if (code) {\n        spnego_debug0(\"Kerberos error: Cannot initialize kerberos context\");\n        return NGX_ERROR;\n    }\n\n    host_name = r->headers_in.host->value;\n    service.len = alcf->srvcname.len + alcf->realm.len + 3;\n\n    if (ngx_strchr(alcf->srvcname.data, '/')) {\n        service.data = ngx_palloc(r->pool, service.len);\n        if (NULL == service.data) {\n            spnego_error(NGX_ERROR);\n        }\n\n        ngx_snprintf(service.data, service.len, \"%V@%V%Z\",\n                &alcf->srvcname, &alcf->realm);\n    } else {\n        service.len += host_name.len;\n        service.data = ngx_palloc(r->pool, service.len);\n        if (NULL == service.data) {\n            spnego_error(NGX_ERROR);\n        }\n\n        ngx_snprintf(service.data, service.len, \"%V/%V@%V%Z\",\n                &alcf->srvcname, &host_name, &alcf->realm);\n    }\n\n    kret = krb5_parse_name(kcontext, (const char *) service.data, &server);\n\n    if (kret) {\n        spnego_log_error(\"Kerberos error:  Unable to parse service name\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    code = krb5_unparse_name(kcontext, server, &name);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Cannot unparse servicename\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    free(name);\n    name = NULL;\n\n    p = ngx_strchr(r->headers_in.user.data, '@');\n    user.len = r->headers_in.user.len + 1;\n    if (NULL == p) {\n        if (alcf->force_realm && alcf->realm.len && alcf->realm.data ) {\n            user.len += alcf->realm.len + 1; /* +1 for @ */\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V@%V%Z\", &r->headers_in.user,\n                    &alcf->realm);\n        } else {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\", &r->headers_in.user);\n        }\n    } else {\n        if (alcf->realm.len && alcf->realm.data && ngx_strncmp(p + 1,\n                    alcf->realm.data, alcf->realm.len) == 0) {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\",\n                    &r->headers_in.user);\n            if (alcf->fqun == 0) {\n                /*\n                 * Specified realm is identical to configured realm.\n                 * Truncate $remote_user to strip @REALM.\n                 */\n                r->headers_in.user.len -= alcf->realm.len + 1;\n            }\n        } else if (alcf->force_realm) {\n            *p = '\\0';\n            user.len = ngx_strlen(r->headers_in.user.data) + 1;\n            if (alcf->realm.len && alcf->realm.data)\n                user.len += alcf->realm.len + 1;\n            user.data = ngx_pcalloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            if (alcf->realm.len && alcf->realm.data)\n                ngx_snprintf(user.data, user.len, \"%s@%V%Z\",\n                        r->headers_in.user.data, &alcf->realm);\n            else\n                ngx_snprintf(user.data, user.len, \"%s%Z\",\n                        r->headers_in.user.data);\n            /*\n             * Rewrite $remote_user with the forced realm.\n             * If the forced realm is shorter than the\n             * specified realm, we can reuse the original\n             * buffer.\n             */\n            if (r->headers_in.user.len >= user.len - 1)\n                r->headers_in.user.len = user.len - 1;\n            else {\n                new_user.len = user.len - 1;\n                new_user.data = ngx_palloc(r->pool, new_user.len);\n                if (NULL == new_user.data) {\n                    spnego_log_error(\"Not enough memory\");\n                    spnego_error(NGX_ERROR);\n                }\n                ngx_pfree(r->pool, r->headers_in.user.data);\n                r->headers_in.user.data = new_user.data;\n                r->headers_in.user.len = new_user.len;\n            }\n            ngx_memcpy(r->headers_in.user.data, user.data,\n                    r->headers_in.user.len);\n        } else {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\", &r->headers_in.user);\n        }\n    }\n\n    spnego_debug1(\"Attempting authentication with principal %s\",\n            (const char *)user.data);\n\n    code = krb5_parse_name(kcontext, (const char *) user.data, &client);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Unable to parse username\");\n        spnego_debug1(\"username is %s.\", (const char *) user.data);\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    code = krb5_unparse_name(kcontext, client, &name);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Cannot unparse username\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    krb5_get_init_creds_opt_alloc(kcontext, &gic_options);\n\n    code = krb5_get_init_creds_password(kcontext, &creds, client,\n                (char *) r->headers_in.passwd.data,\n                NULL, NULL, 0, NULL, gic_options);\n\n    krb5_free_cred_contents(kcontext, &creds);\n\n    if (code) {\n        spnego_log_error(\"Kerberos error: Credentials failed\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_DECLINED);\n    }\n\n    /* Try to add the system realm to $remote_user if needed. */\n    if (alcf->fqun && !ngx_strchr(r->headers_in.user.data, '@')) {\n#ifdef krb5_princ_realm\n        /*\n         * MIT does not have krb5_principal_get_realm() but its\n         * krb5_princ_realm() is a macro that effectively points\n         * to a char *.\n         */\n        const char *realm = krb5_princ_realm(kcontext, client)->data;\n#else\n        const char *realm = krb5_principal_get_realm(kcontext, client);\n#endif\n        if (realm) {\n            new_user.len = r->headers_in.user.len + 1 + ngx_strlen(realm);\n            new_user.data = ngx_palloc(r->pool, new_user.len);\n            if (NULL == new_user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(new_user.data, new_user.len, \"%V@%s\",\n                    &r->headers_in.user, realm);\n            ngx_pfree(r->pool, r->headers_in.user.data);\n            r->headers_in.user.data = new_user.data;\n            r->headers_in.user.len = new_user.len;\n        }\n    }\n\n    spnego_debug1(\"Setting $remote_user to %V\", &r->headers_in.user);\n    if (ngx_http_auth_spnego_set_bogus_authorization(r) != NGX_OK)\n        spnego_log_error(\"Failed to set $remote_user\");\n\n    spnego_debug0(\"ngx_http_auth_spnego_basic: returning NGX_OK\");\n\n    ret = NGX_OK;\n\nend:\n    if (name)\n        free(name);\n    if (client)\n        krb5_free_principal(kcontext, client);\n    if (server)\n        krb5_free_principal(kcontext, server);\n    if (service.data)\n        ngx_pfree(r->pool, service.data);\n    if (user.data)\n        ngx_pfree(r->pool, user.data);\n\n    krb5_get_init_creds_opt_free(kcontext, gic_options);\n\n    krb5_free_context(kcontext);\n\n    return ret;\n}",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "spnego_debug3",
                        "ngx_http_auth_spnego_module.c:52:53:spnego_debug3:4",
                        "#define spnego_debug3(msg, one, two, three) ngx_log_debug3(\\ /* <=== ngx_http_auth_spnego_module.c:52:53:spnego_debug3:4 */ \n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one, two, three)",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "ngx_http_auth_spnego_headers_basic_only",
                        "ngx_http_auth_spnego_headers_basic_only",
                        "static ngx_int_t /* <=== ngx_http_auth_spnego_headers_basic_only */ \nngx_http_auth_spnego_headers_basic_only(\n    ngx_http_request_t *r,\n    ngx_http_auth_spnego_ctx_t *ctx,\n    ngx_http_auth_spnego_loc_conf_t *alcf)\n{\n    ngx_str_t value = ngx_null_string;\n    value.len = sizeof(\"Basic realm=\\\"\\\"\") - 1 + alcf->realm.len;\n    value.data = ngx_pcalloc(r->pool, value.len);\n    if (NULL == value.data) {\n        return NGX_ERROR;\n    }\n    ngx_snprintf(value.data, value.len, \"Basic realm=\\\"%V\\\"\",\n            &alcf->realm);\n    r->headers_out.www_authenticate =\n        ngx_list_push(&r->headers_out.headers);\n    if (NULL == r->headers_out.www_authenticate) {\n        return NGX_ERROR;\n    }\n\n    r->headers_out.www_authenticate->hash = 1;\n    r->headers_out.www_authenticate->key.len = sizeof(\"WWW-Authenticate\") - 1;\n    r->headers_out.www_authenticate->key.data = (u_char *) \"WWW-Authenticate\";\n    r->headers_out.www_authenticate->value.len = value.len;\n    r->headers_out.www_authenticate->value.data = value.data;\n\n    ctx->head = 1;\n\n    return NGX_OK;\n}",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "spnego_debug2",
                        "ngx_http_auth_spnego_module.c:50:51:spnego_debug2:3",
                        "#define spnego_debug2(msg, one, two) ngx_log_debug2(\\ /* <=== ngx_http_auth_spnego_module.c:50:51:spnego_debug2:3 */ \n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one, two)",
                        2
                    ],
                    [
                        "<empty>",
                        "ngx_http_auth_basic_user",
                        "ngx_http_auth_basic_user",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.notEquals",
                        "<operator>.notEquals",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.sizeOf",
                        "<operator>.sizeOf",
                        "",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "spnego_log_krb5_error",
                        "ngx_http_auth_spnego_module.c:41:44:spnego_log_krb5_error:2",
                        "#define spnego_log_krb5_error(context,code) {\\ /* <=== ngx_http_auth_spnego_module.c:41:44:spnego_log_krb5_error:2 */ \n    const char* ___kerror = krb5_get_error_message(context, code);\\\n    spnego_debug2(\"Kerberos error: %d, %s\", code , ___kerror);\\\n    krb5_free_error_message( context, ___kerror  ); }",
                        2
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "spnego_error",
                        "ngx_http_auth_spnego_module.c:45:45:spnego_error:1",
                        "#define spnego_error(code) ret = code; goto end /* <=== ngx_http_auth_spnego_module.c:45:45:spnego_error:1 */ ",
                        2
                    ],
                    [
                        "<empty>",
                        "ngx_palloc",
                        "ngx_palloc",
                        "",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "spnego_debug0",
                        "ngx_http_auth_spnego_module.c:46:47:spnego_debug0:1",
                        "#define spnego_debug0(msg) ngx_log_debug0(\\ /* <=== ngx_http_auth_spnego_module.c:46:47:spnego_debug0:1 */ \n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg)",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "ngx_http_auth_spnego_set_bogus_authorization",
                        "ngx_http_auth_spnego_set_bogus_authorization",
                        "    ngx_int_t /* <=== ngx_http_auth_spnego_set_bogus_authorization */ \nngx_http_auth_spnego_set_bogus_authorization(\n        ngx_http_request_t *r)\n{\n    const char *bogus_passwd = \"bogus_auth_gss_passwd\";\n    ngx_str_t plain, encoded, final;\n\n    if (r->headers_in.user.len == 0) {\n        spnego_debug0(\"ngx_http_auth_spnego_set_bogus_authorization: no user NGX_DECLINED\");\n        return NGX_DECLINED;\n    }\n\n    /* +1 because of the \":\" in \"user:password\" */\n    plain.len = r->headers_in.user.len + ngx_strlen(bogus_passwd) + 1;\n    plain.data = ngx_pnalloc(r->pool, plain.len);\n    if (NULL == plain.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_snprintf(plain.data, plain.len, \"%V:%s\",\n            &r->headers_in.user, bogus_passwd);\n\n    encoded.len = ngx_base64_encoded_length(plain.len);\n    encoded.data = ngx_pnalloc(r->pool, encoded.len);\n    if (NULL == encoded.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_encode_base64(&encoded, &plain);\n\n    final.len = sizeof(\"Basic \") + encoded.len - 1;\n    final.data = ngx_pnalloc(r->pool, final.len);\n    if (NULL == final.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_snprintf(final.data, final.len, \"Basic %V\", &encoded);\n\n    /* WARNING clobbering authorization header value */\n    r->headers_in.authorization->value.len = final.len;\n    r->headers_in.authorization->value.data = final.data;\n\n    spnego_debug0(\"ngx_http_auth_spnego_set_bogus_authorization: bogus user set\");\n    return NGX_OK;\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalNot",
                        "<operator>.logicalNot",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.assignment",
                        "<operator>.assignment",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalAnd",
                        "<operator>.logicalAnd",
                        "",
                        1
                    ],
                    [
                        "ngx_http_auth_spnego_module.c",
                        "spnego_log_error",
                        "ngx_http_auth_spnego_module.c:54:55:spnego_log_error:2",
                        "#define spnego_log_error(fmt, args...) ngx_log_error(\\ /* <=== ngx_http_auth_spnego_module.c:54:55:spnego_log_error:2 */ \n        NGX_LOG_ERR, r->connection->log, 0, fmt, ##args)",
                        2
                    ],
                    [
                        "<empty>",
                        "ngx_log_debug0",
                        "ngx_log_debug0",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.indirectFieldAccess",
                        "<operator>.indirectFieldAccess",
                        "",
                        1
                    ]
                ],
                "globalVars": [],
                "importContext": [
                    "#include <ngx_config.h>",
                    "#include <ngx_core.h>",
                    "#include <ngx_http.h>",
                    "#include <stdbool.h>",
                    "#include <gssapi/gssapi.h>",
                    "#include <gssapi/gssapi_krb5.h>",
                    "#include <krb5.h>"
                ],
                "typeDefs": [
                    [
                        "typedef struct {\n    ngx_flag_t protect;\n    ngx_str_t realm;\n    ngx_str_t keytab;\n    ngx_str_t srvcname;\n    ngx_flag_t fqun;\n    ngx_flag_t force_realm;\n    ngx_flag_t allow_basic;\n    ngx_array_t *auth_princs;\n    ngx_flag_t map_to_local;\n}",
                        "ngx_http_auth_spnego_loc_conf_t"
                    ],
                    [
                        "typedef struct {\n    ngx_str_t token; /* decoded Negotiate token */\n    ngx_int_t head; /* non-zero flag if headers set */\n    ngx_int_t ret; /* current return code */\n    ngx_str_t token_out_b64; /* base64 encoded output tokent */\n}",
                        "ngx_http_auth_spnego_ctx_t"
                    ]
                ],
                "visitedLines": [
                    [
                        1048,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        998,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1010,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1011,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1020,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1046,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1052,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1055,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1026,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1006,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1049,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1013,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1041,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1018,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1042,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1047,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1012,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1023,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1036,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1056,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1019,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1040,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1057,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1000,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1060,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1031,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1050,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        996,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1017,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1004,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1061,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1038,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ],
                    [
                        1039,
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ]
                ],
                "visitedParams": [
                    [
                        "ngx_http_request_t * r",
                        "ngx_http_auth_spnego_handler",
                        "ngx_http_auth_spnego_module.c"
                    ]
                ],
                "vulnerableMethods": [
                    [
                        "ngx_http_auth_spnego_module.c",
                        "ngx_http_auth_spnego_handler",
                        "    static ngx_int_t /* <=== ngx_http_auth_spnego_handler */ \nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\"SSO auth handling IN: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\"Found token and head, returning %d\", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\"User header set\");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\"Begin auth\");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\"Detect basic auth\");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\"Basic auth credentials supplied by client\");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\"Basic auth failed\");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\"Error setting headers\");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\"User not authorized\");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\"Basic auth succeeded\");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\"Detect SPNEGO token\");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\"Client sent a reasonable Negotiate header\");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\"Error setting headers\");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\"User not authorized\");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\"GSSAPI auth succeeded\");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\"Error setting headers\");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\"SSO auth handling OUT: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}",
                        996
                    ]
                ]
            }
        }
    ],
    "file_cache_in_old_repos": [
        "ngx_http_auth_spnego_module.c",
        "<includes>",
        "<unknown>"
    ]
}