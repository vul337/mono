{
    "cve_id": "CVE-2019-15165",
    "cwe_id": "CWE-770",
    "commit_url": "https://github.com/the-tcpdump-group/libpcap/commit/87d6bef033062f969e70fa40c43dfd945d5a20ab",
    "patch_names": [
        {
            "func_name": "read_bytes",
            "file_path": "sf-pcapng.c"
        },
        {
            "func_name": "pcap_ng_check_header",
            "file_path": "sf-pcapng.c"
        },
        {
            "func_name": "pcap_ng_check_header",
            "file_path": "sf-pcapng.c"
        }
    ],
    "before_context": [
        {
            "file_path": "sf-pcapng.c",
            "patch": [
                {
                    "func_name": "read_bytes",
                    "patch": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \t\t\tif (amt_read == 0 && !fail_on_eof)\n \t\t\t\treturn (0);\t/* EOF */\n \t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n+\t\t\t    \"truncated pcapng dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n \t\t\t    bytes_to_read, amt_read);\n \t\t}\n \t\treturn (-1);"
                },
                {
                    "func_name": "pcap_ng_check_header",
                    "patch": "--- func_before\n+++ func_after\n@@ -94,25 +94,19 @@\n \t/*\n \t * Check the sanity of the total length.\n \t */\n-\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\n+\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n+            (total_length > BT_SHB_INSANE_MAX)) {\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t    \"Section Header Block in pcapng dump file has a length of %u < %\" PRIsize,\n-\t\t    total_length,\n-\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n+\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n+                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n+                              total_length,\n+                              BT_SHB_INSANE_MAX);\n+\n \t\t*err = 1;\n \t\treturn (NULL);\n \t}\n \n-\t/*\n-\t * Make sure it's not too big.\n-\t */\n-\tif (total_length > INITIAL_MAX_BLOCKSIZE) {\n-\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t    \"pcapng block size %u > maximum %u\",\n-\t\t    total_length, INITIAL_MAX_BLOCKSIZE);\n-\t\t*err = 1;\n-\t\treturn (NULL);\n-\t}\n+\n \n \t/*\n \t * OK, this is a good pcapng file."
                },
                {
                    "func_name": "pcap_ng_check_header",
                    "patch": "--- func_before\n+++ func_after\n@@ -97,10 +97,10 @@\n \tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n             (total_length > BT_SHB_INSANE_MAX)) {\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n-                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n-                              total_length,\n-                              BT_SHB_INSANE_MAX);\n+\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%u_ < %u (BT_SHB_INSANE_MAX)\",\n+\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n+\t\t    total_length,\n+\t\t    BT_SHB_INSANE_MAX);\n \n \t\t*err = 1;\n \t\treturn (NULL);"
                }
            ],
            "related_methods_sf-pcapng_c": [
                "pcap_ng_check_header memcpy free fread pcap_open_offline_common malloc INITIAL_MAX_BLOCKSIZE linktype_to_dlt pcap_adjust_snapshot BT_SHB BYTE_ORDER_MAGIC pcap_snprintf read_bytes MAX_BLOCKSIZE_FOR_SNAPLEN ferror SWAPLONG SWAPSHORT read_block max_snaplen_for_dlt pcap_fmt_errmsg_for_errno PCAP_NG_VERSION_MAJOR PCAP_NG_VERSION_MINOR BT_IDB BT_EPB BT_SPB BT_PB get_from_block_data add_interface"
            ],
            "bfs_sf-pcapng_c": {
                "calleeMethods": [
                    [
                        "sf-pcapng.c",
                        "BT_PB",
                        "sf-pcapng.c:165:165:BT_PB:0",
                        "#define BT_PB\t\t\t0x00000002 /* <=== sf-pcapng.c:165:165:BT_PB:0 */ ",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "get_optvalue_from_block_data",
                        "get_optvalue_from_block_data",
                        "static void * /* <=== get_optvalue_from_block_data */ \nget_optvalue_from_block_data(struct block_cursor *cursor,\n    struct option_header *opthdr, char *errbuf)\n{\n\tsize_t padded_option_len;\n\tvoid *optvalue;\n\n\t/* Pad option length to 4-byte boundary */\n\tpadded_option_len = opthdr->option_length;\n\tpadded_option_len = ((padded_option_len + 3)/4)*4;\n\n\toptvalue = get_from_block_data(cursor, padded_option_len, errbuf);\n\tif (optvalue == NULL) {\n\t\t/*\n\t\t * Option value is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\treturn (optvalue);\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.equals",
                        "<operator>.equals",
                        "",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "BYTE_ORDER_MAGIC",
                        "sf-pcapng.c:100:100:BYTE_ORDER_MAGIC:0",
                        "#define BYTE_ORDER_MAGIC\t0x1A2B3C4D /* <=== sf-pcapng.c:100:100:BYTE_ORDER_MAGIC:0 */ ",
                        1
                    ],
                    [
                        "<empty>",
                        "malloc",
                        "malloc",
                        "",
                        1
                    ],
                    [
                        "pcap-common.c",
                        "LINKTYPE_MATCHING_MAX",
                        "pcap-common.c:1118:1118:LINKTYPE_MATCHING_MAX:0",
                        "#define LINKTYPE_MATCHING_MAX\t276\t\t/* highest value in the \"matching\" range */ /* <=== pcap-common.c:1118:1118:LINKTYPE_MATCHING_MAX:0 */ ",
                        2
                    ],
                    [
                        "sf-pcapng.c",
                        "BT_EPB",
                        "sf-pcapng.c:141:141:BT_EPB:0",
                        "#define BT_EPB\t\t\t0x00000006 /* <=== sf-pcapng.c:141:141:BT_EPB:0 */ ",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "OPT_ENDOFOPT",
                        "sf-pcapng.c:68:68:OPT_ENDOFOPT:0",
                        "#define OPT_ENDOFOPT\t0\t/* end of options */ /* <=== sf-pcapng.c:68:68:OPT_ENDOFOPT:0 */ ",
                        3
                    ],
                    [
                        "sf-pcapng.c",
                        "IF_TSRESOL",
                        "sf-pcapng.c:131:131:IF_TSRESOL:0",
                        "#define IF_TSRESOL\t9\t/* interface's time stamp resolution */ /* <=== sf-pcapng.c:131:131:IF_TSRESOL:0 */ ",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.or",
                        "<operator>.or",
                        "",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "process_idb_options",
                        "process_idb_options",
                        "static int /* <=== process_idb_options */ \nprocess_idb_options(pcap_t *p, struct block_cursor *cursor, uint64_t *tsresol,\n    uint64_t *tsoffset, int *is_binary, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\tvoid *optvalue;\n\tint saw_tsresol, saw_tsoffset;\n\tuint8_t tsresol_opt;\n\tu_int i;\n\n\tsaw_tsresol = 0;\n\tsaw_tsoffset = 0;\n\twhile (cursor->data_remaining != 0) {\n\t\t/*\n\t\t * Get the option header.\n\t\t */\n\t\topthdr = get_opthdr_from_block_data(p, cursor, errbuf);\n\t\tif (opthdr == NULL) {\n\t\t\t/*\n\t\t\t * Option header is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Get option value.\n\t\t */\n\t\toptvalue = get_optvalue_from_block_data(cursor, opthdr,\n\t\t    errbuf);\n\t\tif (optvalue == NULL) {\n\t\t\t/*\n\t\t\t * Option value is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\tswitch (opthdr->option_code) {\n\n\t\tcase OPT_ENDOFOPT:\n\t\t\tif (opthdr->option_length != 0) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has opt_endofopt option with length %u != 0\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase IF_TSRESOL:\n\t\t\tif (opthdr->option_length != 1) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsresol option with length %u != 1\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsresol) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsresol option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsresol = 1;\n\t\t\tmemcpy(&tsresol_opt, optvalue, sizeof(tsresol_opt));\n\t\t\tif (tsresol_opt & 0x80) {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 2.\n\t\t\t\t */\n\t\t\t\tuint8_t tsresol_shift = (tsresol_opt & 0x7F);\n\n\t\t\t\tif (tsresol_shift > 63) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value.\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 2^-%u is too high\",\n\t\t\t\t\t    tsresol_shift);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 1;\n\t\t\t\t*tsresol = ((uint64_t)1) << tsresol_shift;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 10.\n\t\t\t\t */\n\t\t\t\tif (tsresol_opt > 19) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value (the\n\t\t\t\t\t * largest power of 10 that fits\n\t\t\t\t\t * in a 64-bit value is 10^19, as\n\t\t\t\t\t * the largest 64-bit unsigned\n\t\t\t\t\t * value is ~1.8*10^19).\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 10^-%u is too high\",\n\t\t\t\t\t    tsresol_opt);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 0;\n\t\t\t\t*tsresol = 1;\n\t\t\t\tfor (i = 0; i < tsresol_opt; i++)\n\t\t\t\t\t*tsresol *= 10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IF_TSOFFSET:\n\t\t\tif (opthdr->option_length != 8) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsoffset option with length %u != 8\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsoffset) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsoffset option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsoffset = 1;\n\t\t\tmemcpy(tsoffset, optvalue, sizeof(*tsoffset));\n\t\t\tif (p->swapped)\n\t\t\t\t*tsoffset = SWAPLL(*tsoffset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn (0);\n}",
                        2
                    ],
                    [
                        "sf-pcapng.c",
                        "BT_SHB",
                        "sf-pcapng.c:87:87:BT_SHB:0",
                        "#define BT_SHB\t\t\t0x0A0D0D0A /* <=== sf-pcapng.c:87:87:BT_SHB:0 */ ",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "BT_SPB",
                        "sf-pcapng.c:155:155:BT_SPB:0",
                        "#define BT_SPB\t\t\t0x00000003 /* <=== sf-pcapng.c:155:155:BT_SPB:0 */ ",
                        1
                    ],
                    [
                        "pcap-common.c",
                        "LINKTYPE_MATCHING_MIN",
                        "pcap-common.c:161:161:LINKTYPE_MATCHING_MIN:0",
                        "#define LINKTYPE_MATCHING_MIN\t104\t\t/* lowest value in the \"matching\" range */ /* <=== pcap-common.c:161:161:LINKTYPE_MATCHING_MIN:0 */ ",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.fieldAccess",
                        "<operator>.fieldAccess",
                        "",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "INITIAL_MAX_BLOCKSIZE",
                        "sf-pcapng.c:237:237:INITIAL_MAX_BLOCKSIZE:0",
                        "#define INITIAL_MAX_BLOCKSIZE\t(16*1024*1024) /* <=== sf-pcapng.c:237:237:INITIAL_MAX_BLOCKSIZE:0 */ ",
                        1
                    ],
                    [
                        "pcap.c",
                        "pcap_strerror",
                        "pcap_strerror",
                        "const char * /* <=== pcap_strerror */ \npcap_strerror(int errnum)\n{\n#ifdef HAVE_STRERROR\n#ifdef _WIN32\n\tstatic char errbuf[PCAP_ERRBUF_SIZE];\n\terrno_t err = strerror_s(errbuf, PCAP_ERRBUF_SIZE, errnum);\n\n\tif (err != 0) /* err = 0 if successful */\n\t\tpcap_strlcpy(errbuf, \"strerror_s() error\", PCAP_ERRBUF_SIZE);\n\treturn (errbuf);\n#else\n\treturn (strerror(errnum));\n#endif /* _WIN32 */\n#else\n\textern int sys_nerr;\n\textern const char *const sys_errlist[];\n\tstatic char errbuf[PCAP_ERRBUF_SIZE];\n\n\tif ((unsigned int)errnum < sys_nerr)\n\t\treturn ((char *)sys_errlist[errnum]);\n\t(void)pcap_snprintf(errbuf, sizeof errbuf, \"Unknown error: %d\", errnum);\n\treturn (errbuf);\n#endif\n}",
                        3
                    ],
                    [
                        "pcap.c",
                        "PCAP_T_ALIGNED_SIZE",
                        "pcap.c:2250:2250:PCAP_T_ALIGNED_SIZE:0",
                        "#define PCAP_T_ALIGNED_SIZE\t((sizeof(pcap_t) + 7U) & ~0x7U) /* <=== pcap.c:2250:2250:PCAP_T_ALIGNED_SIZE:0 */ ",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.arithmeticShiftRight",
                        "<operator>.arithmeticShiftRight",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.notEquals",
                        "<operator>.notEquals",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.sizeOf",
                        "<operator>.sizeOf",
                        "",
                        1
                    ],
                    [
                        "missing/snprintf.c",
                        "xyzprintf",
                        "xyzprintf",
                        "static int /* <=== xyzprintf */ \nxyzprintf (struct state *state, const char *char_format, va_list ap)\n{\n  const unsigned char *format = (const unsigned char *)char_format;\n  unsigned char c;\n\n  while((c = *format++)) {\n    if (c == '%') {\n      int flags      = 0;\n      int width      = 0;\n      int prec       = -1;\n      int long_flag  = 0;\n      int short_flag = 0;\n\n      /* flags */\n      while((c = *format++)){\n\tif(c == '-')\n\t  flags |= minus_flag;\n\telse if(c == '+')\n\t  flags |= plus_flag;\n\telse if(c == ' ')\n\t  flags |= space_flag;\n\telse if(c == '#')\n\t  flags |= alternate_flag;\n\telse if(c == '0')\n\t  flags |= zero_flag;\n\telse\n\t  break;\n      }\n\n      if((flags & space_flag) && (flags & plus_flag))\n\tflags ^= space_flag;\n\n      if((flags & minus_flag) && (flags & zero_flag))\n\tflags ^= zero_flag;\n\n      /* width */\n      if (isdigit(c))\n\tdo {\n\t  width = width * 10 + c - '0';\n\t  c = *format++;\n\t} while(isdigit(c));\n      else if(c == '*') {\n\twidth = va_arg(ap, int);\n\tc = *format++;\n      }\n\n      /* precision */\n      if (c == '.') {\n\tprec = 0;\n\tc = *format++;\n\tif (isdigit(c))\n\t  do {\n\t    prec = prec * 10 + c - '0';\n\t    c = *format++;\n\t  } while(isdigit(c));\n\telse if (c == '*') {\n\t  prec = va_arg(ap, int);\n\t  c = *format++;\n\t}\n      }\n\n      /* size */\n\n      if (c == 'h') {\n\tshort_flag = 1;\n\tc = *format++;\n      } else if (c == 'l') {\n\tlong_flag = 1;\n\tc = *format++;\n      }\n\n      switch (c) {\n      case 'c' :\n\tif(append_char(state, va_arg(ap, int), width, flags))\n\t  return -1;\n\tbreak;\n      case 's' :\n\tif (append_string(state,\n\t\t\t  va_arg(ap, unsigned char*),\n\t\t\t  width,\n\t\t\t  prec,\n\t\t\t  flags))\n\t  return -1;\n\tbreak;\n      case 'd' :\n      case 'i' : {\n\tlong arg;\n\tunsigned long num;\n\tint minusp = 0;\n\n\tPARSE_INT_FORMAT(arg, ap, signed);\n\n\tif (arg < 0) {\n\t  minusp = 1;\n\t  num = -arg;\n\t} else\n\t  num = arg;\n\n\tif (append_number (state, num, 10, \"0123456789\",\n\t\t\t   width, prec, flags, minusp))\n\t  return -1;\n\tbreak;\n      }\n      case 'u' : {\n\tunsigned long arg;\n\n\tPARSE_INT_FORMAT(arg, ap, unsigned);\n\n\tif (append_number (state, arg, 10, \"0123456789\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'o' : {\n\tunsigned long arg;\n\n\tPARSE_INT_FORMAT(arg, ap, unsigned);\n\n\tif (append_number (state, arg, 010, \"01234567\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'x' : {\n\tunsigned long arg;\n\n\tPARSE_INT_FORMAT(arg, ap, unsigned);\n\n\tif (append_number (state, arg, 0x10, \"0123456789abcdef\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'X' :{\n\tunsigned long arg;\n\n\tPARSE_INT_FORMAT(arg, ap, unsigned);\n\n\tif (append_number (state, arg, 0x10, \"0123456789ABCDEF\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'p' : {\n\tunsigned long arg = (unsigned long)va_arg(ap, void*);\n\n\tif (append_number (state, arg, 0x10, \"0123456789ABCDEF\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'n' : {\n\tint *arg = va_arg(ap, int*);\n\t*arg = state->s - state->str;\n\tbreak;\n      }\n      case '\\0' :\n\t  --format;\n\t  /* FALLTHROUGH */\n      case '%' :\n\tif ((*state->append_char)(state, c))\n\t  return -1;\n\tbreak;\n      default :\n\tif (   (*state->append_char)(state, '%')\n\t    || (*state->append_char)(state, c))\n\t  return -1;\n\tbreak;\n      }\n    } else\n      if ((*state->append_char) (state, c))\n\treturn -1;\n  }\n  return 0;\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.multiplication",
                        "<operator>.multiplication",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.and",
                        "<operator>.and",
                        "",
                        1
                    ],
                    [
                        "pcap-common.h",
                        "SWAPLONG",
                        "pcap-common.h:37:41:SWAPLONG:1",
                        "#define\tSWAPLONG(y) \\ /* <=== pcap-common.h:37:41:SWAPLONG:1 */ \n    (((((u_int)(y))&0xff)<<24) | \\\n     ((((u_int)(y))&0xff00)<<8) | \\\n     ((((u_int)(y))&0xff0000)>>8) | \\\n     ((((u_int)(y))>>24)&0xff))",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalNot",
                        "<operator>.logicalNot",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.cast",
                        "<operator>.cast",
                        "",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "MAX_BLOCKSIZE_FOR_SNAPLEN",
                        "sf-pcapng.c:244:248:MAX_BLOCKSIZE_FOR_SNAPLEN:1",
                        "#define MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen) \\ /* <=== sf-pcapng.c:244:248:MAX_BLOCKSIZE_FOR_SNAPLEN:1 */ \n\t(sizeof (struct block_header) + \\\n\t sizeof (struct enhanced_packet_block) + \\\n\t (max_snaplen) + 131072 + \\\n\t sizeof (struct block_trailer))",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalAnd",
                        "<operator>.logicalAnd",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.greaterThan",
                        "<operator>.greaterThan",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "free",
                        "free",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.indirectFieldAccess",
                        "<operator>.indirectFieldAccess",
                        "",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "add_interface",
                        "add_interface",
                        "static int /* <=== add_interface */ \nadd_interface(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tuint64_t tsresol;\n\tuint64_t tsoffset;\n\tint is_binary;\n\n\tps = p->priv;\n\n\t/*\n\t * Count this interface.\n\t */\n\tps->ifcount++;\n\n\t/*\n\t * Grow the array of per-interface information as necessary.\n\t */\n\tif (ps->ifcount > ps->ifaces_size) {\n\t\t/*\n\t\t * We need to grow the array.\n\t\t */\n\t\tbpf_u_int32 new_ifaces_size;\n\t\tstruct pcap_ng_if *new_ifaces;\n\n\t\tif (ps->ifaces_size == 0) {\n\t\t\t/*\n\t\t\t * It's currently empty.\n\t\t\t *\n\t\t\t * (The Clang static analyzer doesn't do enough,\n\t\t\t * err, umm, dataflow *analysis* to realize that\n\t\t\t * ps->ifaces_size == 0 if ps->ifaces == NULL,\n\t\t\t * and so complains about a possible zero argument\n\t\t\t * to realloc(), so we check for the former\n\t\t\t * condition to shut it up.\n\t\t\t *\n\t\t\t * However, it doesn't complain that one of the\n\t\t\t * multiplications below could overflow, which is\n\t\t\t * a real, albeit extremely unlikely, problem (you'd\n\t\t\t * need a pcapng file with tens of millions of\n\t\t\t * interfaces).)\n\t\t\t */\n\t\t\tnew_ifaces_size = 1;\n\t\t\tnew_ifaces = malloc(sizeof (struct pcap_ng_if));\n\t\t} else {\n\t\t\t/*\n\t\t\t * It's not currently empty; double its size.\n\t\t\t * (Perhaps overkill once we have a lot of interfaces.)\n\t\t\t *\n\t\t\t * Check for overflow if we double it.\n\t\t\t */\n\t\t\tif (ps->ifaces_size * 2 < ps->ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * The maximum number of interfaces before\n\t\t\t\t * ps->ifaces_size overflows is the largest\n\t\t\t\t * possible 32-bit power of 2, as we do\n\t\t\t\t * size doubling.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0x80000000U);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ps->ifaces_size * 2 doesn't overflow, so it's\n\t\t\t * safe to multiply.\n\t\t\t */\n\t\t\tnew_ifaces_size = ps->ifaces_size * 2;\n\n\t\t\t/*\n\t\t\t * Now make sure that's not so big that it overflows\n\t\t\t * if we multiply by sizeof (struct pcap_ng_if).\n\t\t\t *\n\t\t\t * That can happen on 32-bit platforms, with a 32-bit\n\t\t\t * size_t; it shouldn't happen on 64-bit platforms,\n\t\t\t * with a 64-bit size_t, as new_ifaces_size is\n\t\t\t * 32 bits.\n\t\t\t */\n\t\t\tif (new_ifaces_size * sizeof (struct pcap_ng_if) < new_ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * As this fails only with 32-bit size_t,\n\t\t\t\t * the multiplication was 32x32->32, and\n\t\t\t\t * the largest 32-bit value that can safely\n\t\t\t\t * be multiplied by sizeof (struct pcap_ng_if)\n\t\t\t\t * without overflow is the largest 32-bit\n\t\t\t\t * (unsigned) value divided by\n\t\t\t\t * sizeof (struct pcap_ng_if).\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0xFFFFFFFFU / ((u_int)sizeof (struct pcap_ng_if)));\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tnew_ifaces = realloc(ps->ifaces, new_ifaces_size * sizeof (struct pcap_ng_if));\n\t\t}\n\t\tif (new_ifaces == NULL) {\n\t\t\t/*\n\t\t\t * We ran out of memory.\n\t\t\t * Give up.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"out of memory for per-interface information (%u interfaces)\",\n\t\t\t    ps->ifcount);\n\t\t\treturn (0);\n\t\t}\n\t\tps->ifaces_size = new_ifaces_size;\n\t\tps->ifaces = new_ifaces;\n\t}\n\n\t/*\n\t * Set the default time stamp resolution and offset.\n\t */\n\ttsresol = 1000000;\t/* microsecond resolution */\n\tis_binary = 0;\t\t/* which is a power of 10 */\n\ttsoffset = 0;\t\t/* absolute timestamps */\n\n\t/*\n\t * Now look for various time stamp options, so we know\n\t * how to interpret the time stamps for this interface.\n\t */\n\tif (process_idb_options(p, cursor, &tsresol, &tsoffset, &is_binary,\n\t    errbuf) == -1)\n\t\treturn (0);\n\n\tps->ifaces[ps->ifcount - 1].tsresol = tsresol;\n\tps->ifaces[ps->ifcount - 1].tsoffset = tsoffset;\n\n\t/*\n\t * Determine whether we're scaling up or down or not\n\t * at all for this interface.\n\t */\n\tif (tsresol == ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is the resolution the user wants,\n\t\t * so we don't have to do scaling.\n\t\t */\n\t\tps->ifaces[ps->ifcount - 1].scale_type = PASS_THROUGH;\n\t} else if (tsresol > ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is greater than what the user wants,\n\t\t * so we have to scale the timestamps down.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = tsresol/ps->user_tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_DEC;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The resolution is less than what the user wants,\n\t\t * so we have to scale the timestamps up.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = ps->user_tsresol/tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_DEC;\n\t\t}\n\t}\n\treturn (1);\n}",
                        1
                    ],
                    [
                        "fmtutils.c",
                        "pcap_fmt_errmsg_for_errno",
                        "pcap_fmt_errmsg_for_errno",
                        "void /* <=== pcap_fmt_errmsg_for_errno */ \npcap_fmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,\n    const char *fmt, ...)\n{\n\tva_list ap;\n\tsize_t msglen;\n\tchar *p;\n\tsize_t errbuflen_remaining;\n\n\tva_start(ap, fmt);\n\tpcap_vsnprintf(errbuf, errbuflen, fmt, ap);\n\tva_end(ap);\n\tmsglen = strlen(errbuf);\n\n\t/*\n\t * Do we have enough space to append \": \"?\n\t * Including the terminating '\\0', that's 3 bytes.\n\t */\n\tif (msglen + 3 > errbuflen) {\n\t\t/* No - just give them what we've produced. */\n\t\treturn;\n\t}\n\tp = errbuf + msglen;\n\terrbuflen_remaining = errbuflen - msglen;\n\t*p++ = ':';\n\t*p++ = ' ';\n\t*p = '\\0';\n\tmsglen += 2;\n\terrbuflen_remaining -= 2;\n\n\t/*\n\t * Now append the string for the error code.\n\t */\n#if defined(HAVE_STRERROR_S)\n\t/*\n\t * We have a Windows-style strerror_s().\n\t */\n\terrno_t err = strerror_s(p, errbuflen_remaining, errnum);\n\tif (err != 0) {\n\t\t/*\n\t\t * It doesn't appear to be documented anywhere obvious\n\t\t * what the error returns from strerror_s().\n\t\t */\n\t\tpcap_snprintf(p, errbuflen_remaining, \"Error %d\", errnum);\n\t}\n#elif defined(HAVE_GNU_STRERROR_R)\n\t/*\n\t * We have a GNU-style strerror_r(), which is *not* guaranteed to\n\t * do anything to the buffer handed to it, and which returns a\n\t * pointer to the error string, which may or may not be in\n\t * the buffer.\n\t *\n\t * It is, however, guaranteed to succeed.\n\t */\n\tchar strerror_buf[PCAP_ERRBUF_SIZE];\n\tchar *errstring = strerror_r(errnum, strerror_buf, PCAP_ERRBUF_SIZE);\n\tpcap_snprintf(p, errbuflen_remaining, \"%s\", errstring);\n#elif defined(HAVE_POSIX_STRERROR_R)\n\t/*\n\t * We have a POSIX-style strerror_r(), which is guaranteed to fill\n\t * in the buffer, but is not guaranteed to succeed.\n\t */\n\tint err = strerror_r(errnum, p, errbuflen_remaining);\n\tif (err == EINVAL) {\n\t\t/*\n\t\t * UNIX 03 says this isn't guaranteed to produce a\n\t\t * fallback error message.\n\t\t */\n\t\tpcap_snprintf(p, errbuflen_remaining, \"Unknown error: %d\",\n\t\t    errnum);\n\t} else if (err == ERANGE) {\n\t\t/*\n\t\t * UNIX 03 says this isn't guaranteed to produce a\n\t\t * fallback error message.\n\t\t */\n\t\tpcap_snprintf(p, errbuflen_remaining,\n\t\t    \"Message for error %d is too long\", errnum);\n\t}\n#else\n\t/*\n\t * We have neither strerror_s() nor strerror_r(), so we're\n\t * stuck with using pcap_strerror().\n\t */\n\tpcap_snprintf(p, errbuflen_remaining, \"%s\", pcap_strerror(errnum));\n#endif\n}",
                        2
                    ],
                    [
                        "sf-pcapng.c",
                        "PCAP_NG_VERSION_MAJOR",
                        "sf-pcapng.c:106:106:PCAP_NG_VERSION_MAJOR:0",
                        "#define PCAP_NG_VERSION_MAJOR\t1 /* <=== sf-pcapng.c:106:106:PCAP_NG_VERSION_MAJOR:0 */ ",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.lessThan",
                        "<operator>.lessThan",
                        "",
                        1
                    ],
                    [
                        "missing/snprintf.c",
                        "pcap_snprintf",
                        "pcap_snprintf",
                        "int /* <=== pcap_snprintf */ \npcap_snprintf (char *str, size_t sz, const char *format, ...)\n{\n  va_list args;\n  int ret;\n\n  va_start(args, format);\n  ret = pcap_vsnprintf (str, sz, format, args);\n\n#ifdef PARANOIA\n  {\n    int ret2;\n    char *tmp;\n\n    tmp = malloc (sz);\n    if (tmp == NULL)\n      abort ();\n\n    ret2 = pcap_vsprintf (tmp, format, args);\n    if (ret != ret2 || strcmp(str, tmp))\n      abort ();\n    free (tmp);\n  }\n#endif\n\n  va_end(args);\n  return ret;\n}",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "IF_TSOFFSET",
                        "sf-pcapng.c:136:136:IF_TSOFFSET:0",
                        "#define IF_TSOFFSET\t14\t/* time stamp offset for this interface */ /* <=== sf-pcapng.c:136:136:IF_TSOFFSET:0 */ ",
                        3
                    ],
                    [
                        "pcap-int.h",
                        "MAXIMUM_SNAPLEN",
                        "pcap-int.h:98:98:MAXIMUM_SNAPLEN:0",
                        "#define MAXIMUM_SNAPLEN\t\t262144 /* <=== pcap-int.h:98:98:MAXIMUM_SNAPLEN:0 */ ",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.addressOf",
                        "<operator>.addressOf",
                        "",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "read_block",
                        "read_block",
                        "static int /* <=== read_block */ \nread_block(FILE *fp, pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_header bhdr;\n\tstruct block_trailer *btrlr;\n\tu_char *bdata;\n\tsize_t data_remaining;\n\n\tps = p->priv;\n\n\tstatus = read_bytes(fp, &bhdr, sizeof(bhdr), 0, errbuf);\n\tif (status <= 0)\n\t\treturn (status);\t/* error or EOF */\n\n\tif (p->swapped) {\n\t\tbhdr.block_type = SWAPLONG(bhdr.block_type);\n\t\tbhdr.total_length = SWAPLONG(bhdr.total_length);\n\t}\n\n\t/*\n\t * Is this block \"too small\" - i.e., is it shorter than a block\n\t * header plus a block trailer?\n\t */\n\tif (bhdr.total_length < sizeof(struct block_header) +\n\t    sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u < %\" PRIsize,\n\t\t    bhdr.total_length,\n\t\t    sizeof(struct block_header) + sizeof(struct block_trailer));\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the block total length a multiple of 4?\n\t */\n\tif ((bhdr.total_length % 4) != 0) {\n\t\t/*\n\t\t * No.  Report that as an error.\n\t\t */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u that is not a multiple of 4\" PRIsize,\n\t\t    bhdr.total_length);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the buffer big enough?\n\t */\n\tif (p->bufsize < bhdr.total_length) {\n\t\t/*\n\t\t * No - make it big enough, unless it's too big, in\n\t\t * which case we fail.\n\t\t */\n\t\tvoid *bigger_buffer;\n\n\t\tif (bhdr.total_length > ps->max_blocksize) {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"pcapng block size %u > maximum %u\", bhdr.total_length,\n\t\t\t    ps->max_blocksize);\n\t\t\treturn (-1);\n\t\t}\n\t\tbigger_buffer = realloc(p->buffer, bhdr.total_length);\n\t\tif (bigger_buffer == NULL) {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\t\treturn (-1);\n\t\t}\n\t\tp->buffer = bigger_buffer;\n\t}\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the block.\n\t */\n\tmemcpy(p->buffer, &bhdr, sizeof(bhdr));\n\tbdata = (u_char *)p->buffer + sizeof(bhdr);\n\tdata_remaining = bhdr.total_length - sizeof(bhdr);\n\tif (read_bytes(fp, bdata, data_remaining, 1, errbuf) == -1)\n\t\treturn (-1);\n\n\t/*\n\t * Get the block size from the trailer.\n\t */\n\tbtrlr = (struct block_trailer *)(bdata + data_remaining - sizeof (struct block_trailer));\n\tif (p->swapped)\n\t\tbtrlr->total_length = SWAPLONG(btrlr->total_length);\n\n\t/*\n\t * Is the total length from the trailer the same as the total\n\t * length from the header?\n\t */\n\tif (bhdr.total_length != btrlr->total_length) {\n\t\t/*\n\t\t * No.\n\t\t */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block total length in header and trailer don't match\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Initialize the cursor.\n\t */\n\tcursor->data = bdata;\n\tcursor->data_remaining = data_remaining - sizeof(struct block_trailer);\n\tcursor->block_type = bhdr.block_type;\n\treturn (1);\n}",
                        1
                    ],
                    [
                        "pcap-common.c",
                        "LINKTYPE_PKTAP",
                        "pcap-common.c:1015:1015:LINKTYPE_PKTAP:0",
                        "#define LINKTYPE_PKTAP\t\t258 /* <=== pcap-common.c:1015:1015:LINKTYPE_PKTAP:0 */ ",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.addition",
                        "<operator>.addition",
                        "",
                        1
                    ],
                    [
                        "pcap-common.c",
                        "max_snaplen_for_dlt",
                        "max_snaplen_for_dlt",
                        "u_int /* <=== max_snaplen_for_dlt */ \nmax_snaplen_for_dlt(int dlt)\n{\n\tswitch (dlt) {\n\n\tcase DLT_DBUS:\n\t\treturn 128*1024*1024;\n\n\tcase DLT_USBPCAP:\n\t\treturn 1024*1024;\n\n\tdefault:\n\t\treturn MAXIMUM_SNAPLEN;\n\t}\n}",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "get_from_block_data",
                        "get_from_block_data",
                        "static void * /* <=== get_from_block_data */ \nget_from_block_data(struct block_cursor *cursor, size_t chunk_size,\n    char *errbuf)\n{\n\tvoid *data;\n\n\t/*\n\t * Make sure we have the specified amount of data remaining in\n\t * the block data.\n\t */\n\tif (cursor->data_remaining < chunk_size) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block of type %u in pcapng dump file is too short\",\n\t\t    cursor->block_type);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Return the current pointer, and skip past the chunk.\n\t */\n\tdata = cursor->data;\n\tcursor->data += chunk_size;\n\tcursor->data_remaining -= chunk_size;\n\treturn (data);\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.shiftLeft",
                        "<operator>.shiftLeft",
                        "",
                        1
                    ],
                    [
                        "lbl/os-sunos4.h",
                        "fread",
                        "fread",
                        "u_int\tfread(void *, u_int, u_int, FILE *); /* <=== fread */ ",
                        1
                    ],
                    [
                        "pcap-common.c",
                        "LINKTYPE_PFSYNC",
                        "pcap-common.c:919:919:LINKTYPE_PFSYNC:0",
                        "#define LINKTYPE_PFSYNC\t\t246 /* <=== pcap-common.c:919:919:LINKTYPE_PFSYNC:0 */ ",
                        2
                    ],
                    [
                        "pcap-common.c",
                        "linktype_to_dlt",
                        "linktype_to_dlt",
                        "int /* <=== linktype_to_dlt */ \nlinktype_to_dlt(int linktype)\n{\n\tint i;\n\n\t/*\n\t * LINKTYPEs in the matching range that *don't*\n\t * have the same value as the corresponding DLTs\n\t * because, for some reason, not all OSes have the\n\t * same value for that DLT.\n\t */\n\tif (linktype == LINKTYPE_PFSYNC)\n\t\treturn (DLT_PFSYNC);\n\tif (linktype == LINKTYPE_PKTAP)\n\t\treturn (DLT_PKTAP);\n\n\t/*\n\t * For all other values in the matching range, the LINKTYPE\n\t * value is the same as the DLT value.\n\t */\n\tif (linktype >= LINKTYPE_MATCHING_MIN &&\n\t    linktype <= LINKTYPE_MATCHING_MAX)\n\t\treturn (linktype);\n\n\t/*\n\t * Map the values outside that range.\n\t */\n\tfor (i = 0; map[i].linktype != -1; i++) {\n\t\tif (map[i].linktype == linktype)\n\t\t\treturn (map[i].dlt);\n\t}\n\n\t/*\n\t * If we don't have an entry for this LINKTYPE, return\n\t * the link type value; it may be a DLT from an older\n\t * version of libpcap.\n\t */\n\treturn linktype;\n}",
                        1
                    ],
                    [
                        "savefile.c",
                        "pcap_adjust_snapshot",
                        "pcap_adjust_snapshot",
                        "bpf_u_int32 /* <=== pcap_adjust_snapshot */ \npcap_adjust_snapshot(bpf_u_int32 linktype, bpf_u_int32 snaplen)\n{\n\tif (snaplen == 0 || snaplen > INT_MAX) {\n\t\t/*\n\t\t * Bogus snapshot length; use the maximum for this\n\t\t * link-layer type as a fallback.\n\t\t *\n\t\t * XXX - we don't clamp snapshot lengths that are\n\t\t * <= INT_MAX but > max_snaplen_for_dlt(linktype),\n\t\t * so a capture file could cause us to allocate\n\t\t * a Really Big Buffer.\n\t\t */\n\t\tsnaplen = max_snaplen_for_dlt(linktype);\n\t}\n\treturn snaplen;\n}",
                        1
                    ],
                    [
                        "pcap.c",
                        "pcap_open_offline_common",
                        "pcap_open_offline_common",
                        "pcap_t * /* <=== pcap_open_offline_common */ \npcap_open_offline_common(char *ebuf, size_t size)\n{\n\tpcap_t *p;\n\n\tp = pcap_alloc_pcap_t(ebuf, size);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;\n\n\treturn (p);\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.assignment",
                        "<operator>.assignment",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.indirection",
                        "<operator>.indirection",
                        "",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "PCAP_NG_VERSION_MINOR",
                        "sf-pcapng.c:107:107:PCAP_NG_VERSION_MINOR:0",
                        "#define PCAP_NG_VERSION_MINOR\t0 /* <=== sf-pcapng.c:107:107:PCAP_NG_VERSION_MINOR:0 */ ",
                        1
                    ],
                    [
                        "pcap-common.h",
                        "SWAPSHORT",
                        "pcap-common.h:42:44:SWAPSHORT:1",
                        "#define\tSWAPSHORT(y) \\ /* <=== pcap-common.h:42:44:SWAPSHORT:1 */ \n     ((u_short)(((((u_int)(y))&0xff)<<8) | \\\n                ((((u_int)(y))&0xff00)>>8)))",
                        1
                    ],
                    [
                        "missing/snprintf.c",
                        "pcap_vsnprintf",
                        "pcap_vsnprintf",
                        "int /* <=== pcap_vsnprintf */ \npcap_vsnprintf (char *str, size_t sz, const char *format, va_list args)\n{\n  struct state state;\n  int ret;\n  unsigned char *ustr = (unsigned char *)str;\n\n  state.max_sz = 0;\n  state.sz     = sz;\n  state.str    = ustr;\n  state.s      = ustr;\n  state.theend = ustr + sz - 1;\n  state.append_char = sn_append_char;\n  state.reserve     = sn_reserve;\n\n  ret = xyzprintf (&state, format, args);\n  *state.s = '\\0';\n  if (ret)\n    return sz;\n  else\n    return state.s - state.str;\n}",
                        2
                    ],
                    [
                        "sf-pcapng.c",
                        "get_opthdr_from_block_data",
                        "get_opthdr_from_block_data",
                        "static struct option_header * /* <=== get_opthdr_from_block_data */ \nget_opthdr_from_block_data(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\n\topthdr = get_from_block_data(cursor, sizeof(*opthdr), errbuf);\n\tif (opthdr == NULL) {\n\t\t/*\n\t\t * Option header is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Byte-swap it if necessary.\n\t */\n\tif (p->swapped) {\n\t\topthdr->option_code = SWAPSHORT(opthdr->option_code);\n\t\topthdr->option_length = SWAPSHORT(opthdr->option_length);\n\t}\n\n\treturn (opthdr);\n}",
                        3
                    ],
                    [
                        "pcap.c",
                        "pcap_alloc_pcap_t",
                        "pcap_alloc_pcap_t",
                        "static pcap_t * /* <=== pcap_alloc_pcap_t */ \npcap_alloc_pcap_t(char *ebuf, size_t size)\n{\n\tchar *chunk;\n\tpcap_t *p;\n\n\t/*\n\t * Allocate a chunk of memory big enough for a pcap_t\n\t * plus a structure following it of size \"size\".  The\n\t * structure following it is a private data structure\n\t * for the routines that handle this pcap_t.\n\t *\n\t * The structure following it must be aligned on\n\t * the appropriate alignment boundary for this platform.\n\t * We align on an 8-byte boundary as that's probably what\n\t * at least some platforms do, even with 32-bit integers,\n\t * and because we can't be sure that some values won't\n\t * require 8-byte alignment even on platforms with 32-bit\n\t * integers.\n\t */\n#define PCAP_T_ALIGNED_SIZE\t((sizeof(pcap_t) + 7U) & ~0x7U)\n\tchunk = malloc(PCAP_T_ALIGNED_SIZE + size);\n\tif (chunk == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\tmemset(chunk, 0, PCAP_T_ALIGNED_SIZE + size);\n\n\t/*\n\t * Get a pointer to the pcap_t at the beginning.\n\t */\n\tp = (pcap_t *)chunk;\n\n#ifdef _WIN32\n\tp->handle = INVALID_HANDLE_VALUE;\t/* not opened yet */\n#else /* _WIN32 */\n\tp->fd = -1;\t/* not opened yet */\n#ifndef MSDOS\n\tp->selectable_fd = -1;\n\tp->required_select_timeout = NULL;\n#endif /* MSDOS */\n#endif /* _WIN32 */\n\n\tif (size == 0) {\n\t\t/* No private data was requested. */\n\t\tp->priv = NULL;\n\t} else {\n\t\t/*\n\t\t * Set the pointer to the private data; that's the structure\n\t\t * of size \"size\" following the pcap_t.\n\t\t */\n\t\tp->priv = (void *)(chunk + PCAP_T_ALIGNED_SIZE);\n\t}\n\n\treturn (p);\n}",
                        2
                    ],
                    [
                        "sf-pcapng.c",
                        "read_bytes",
                        "read_bytes",
                        "static int /* <=== read_bytes */ \nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.subtraction",
                        "<operator>.subtraction",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.minus",
                        "<operator>.minus",
                        "",
                        1
                    ],
                    [
                        "sf-pcapng.c",
                        "BT_IDB",
                        "sf-pcapng.c:112:112:BT_IDB:0",
                        "#define BT_IDB\t\t\t0x00000001 /* <=== sf-pcapng.c:112:112:BT_IDB:0 */ ",
                        1
                    ],
                    [
                        "pcap-int.h",
                        "SWAPLL",
                        "pcap-int.h:63:70:SWAPLL:1",
                        "#define SWAPLL(ull)  ((ull & 0xff00000000000000ULL) >> 56) | \\ /* <=== pcap-int.h:63:70:SWAPLL:1 */ \n                      ((ull & 0x00ff000000000000ULL) >> 40) | \\\n                      ((ull & 0x0000ff0000000000ULL) >> 24) | \\\n                      ((ull & 0x000000ff00000000ULL) >> 8)  | \\\n                      ((ull & 0x00000000ff000000ULL) << 8)  | \\\n                      ((ull & 0x0000000000ff0000ULL) << 24) | \\\n                      ((ull & 0x000000000000ff00ULL) << 40) | \\\n                      ((ull & 0x00000000000000ffULL) << 56)",
                        3
                    ]
                ],
                "globalVars": [],
                "importContext": [
                    "#include <config.h>",
                    "#include <pcap/pcap-inttypes.h>",
                    "#include <errno.h>",
                    "#include <memory.h>",
                    "#include <stdio.h>",
                    "#include <stdlib.h>",
                    "#include <string.h>",
                    "#include \"pcap-int.h\"",
                    "#include \"pcap-common.h\"",
                    "#include \"os-proto.h\"",
                    "#include \"sf-pcapng.h\""
                ],
                "typeDefs": [
                    [
                        "struct block_trailer {\n\tbpf_u_int32\ttotal_length;\n}",
                        "block_trailer"
                    ],
                    [
                        "struct block_header {\n\tbpf_u_int32\tblock_type;\n\tbpf_u_int32\ttotal_length;\n}",
                        "block_header"
                    ],
                    [
                        "struct enhanced_packet_block {\n\tbpf_u_int32\tinterface_id;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n}",
                        "enhanced_packet_block"
                    ],
                    [
                        "struct block_cursor {\n\tu_char\t\t*data;\n\tsize_t\t\tdata_remaining;\n\tbpf_u_int32\tblock_type;\n}",
                        "block_cursor"
                    ],
                    [
                        "typedef unsigned char uint8_t;",
                        "uint8_t"
                    ],
                    [
                        "struct pcap_ng_sf {\n\tuint64_t user_tsresol;\t\t/* time stamp resolution requested by the user */\n\tu_int max_blocksize;\t\t/* don't grow buffer size past this */\n\tbpf_u_int32 ifcount;\t\t/* number of interfaces seen in this capture */\n\tbpf_u_int32 ifaces_size;\t/* size of array below */\n\tstruct pcap_ng_if *ifaces;\t/* array of interface information */\n}",
                        "pcap_ng_sf"
                    ],
                    [
                        "typedef unsigned long bpf_u_int32;",
                        "bpf_u_int32"
                    ],
                    [
                        "typedef struct pcap pcap_t;",
                        "pcap_t"
                    ],
                    [
                        "struct section_header_block {\n\tbpf_u_int32\tbyte_order_magic;\n\tu_short\t\tmajor_version;\n\tu_short\t\tminor_version;\n\tuint64_t\tsection_length;\n\t/* followed by options and trailer */\n}",
                        "section_header_block"
                    ],
                    [
                        "struct interface_description_block {\n\tu_short\t\tlinktype;\n\tu_short\t\treserved;\n\tbpf_u_int32\tsnaplen;\n\t/* followed by options and trailer */\n}",
                        "interface_description_block"
                    ]
                ],
                "visitedLines": [
                    [
                        948,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        955,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        954,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        999,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        938,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        910,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        872,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        765,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        962,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        884,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        950,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        902,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        853,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        933,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1061,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1051,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        939,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        889,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        913,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        890,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        974,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        864,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        908,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1037,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1010,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        963,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        978,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1001,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        871,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        935,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1018,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        883,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1070,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1038,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1009,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        949,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        846,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        830,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1031,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        936,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        815,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        909,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        972,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1053,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        953,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        932,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        977,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        876,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        789,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        783,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        941,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        875,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1016,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        873,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1017,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        996,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        934,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1071,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        931,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        790,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1008,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1003,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        907,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        992,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        844,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        901,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        895,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        859,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1073,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        886,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        973,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        971,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        906,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        958,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        947,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        995,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        865,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1063,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        983,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        951,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1069,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1064,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1050,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        764,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        970,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        874,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        993,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        887,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1052,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        814,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        937,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1060,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        829,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1024,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        845,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        763,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1030,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1029,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        952,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1072,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        898,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        1066,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        897,
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ]
                ],
                "visitedParams": [
                    [
                        "int *err",
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        "const uint8_t *magic",
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        "char *errbuf",
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ],
                    [
                        "FILE *fp",
                        "pcap_ng_check_header",
                        "sf-pcapng.c"
                    ]
                ],
                "vulnerableMethods": [
                    [
                        "sf-pcapng.c",
                        "pcap_ng_check_header",
                        "pcap_t * /* <=== pcap_ng_check_header */ \npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has a length of %u < %\" PRIsize,\n\t\t    total_length,\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Make sure it's not too big.\n\t */\n\tif (total_length > INITIAL_MAX_BLOCKSIZE) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"pcapng block size %u > maximum %u\",\n\t\t    total_length, INITIAL_MAX_BLOCKSIZE);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}",
                        763
                    ]
                ]
            }
        }
    ],
    "file_cache_in_old_repos": [
        "bpf_dump.c",
        "bpf_filter.c",
        "bpf_image.c",
        "cmake/have_siocglifconf.c",
        "dlpisubs.c",
        "etherent.c",
        "fad-getad.c",
        "fad-gifc.c",
        "fad-glifc.c",
        "fmtutils.c",
        "gencode.c",
        "missing/asprintf.c",
        "missing/getopt.c",
        "missing/snprintf.c",
        "missing/strlcat.c",
        "missing/strlcpy.c",
        "missing/strtok_r.c",
        "missing/win_asprintf.c",
        "missing/win_snprintf.c",
        "msdos/bin2c.c",
        "msdos/pktdrvr.c",
        "nametoaddr.c",
        "optimize.c",
        "pcap-bpf.c",
        "pcap-bt-linux.c",
        "pcap-bt-monitor-linux.c",
        "pcap-common.c",
        "pcap-dag.c",
        "pcap-dbus.c",
        "pcap-dlpi.c",
        "pcap-dos.c",
        "pcap-enet.c",
        "pcap-libdlpi.c",
        "pcap-linux.c",
        "pcap-netfilter-linux.c",
        "pcap-netmap.c",
        "pcap-new.c",
        "pcap-nit.c",
        "pcap-npf.c",
        "pcap-null.c",
        "pcap-pf.c",
        "pcap-rdmasniff.c",
        "pcap-rpcap.c",
        "pcap-septel.c",
        "pcap-sita.c",
        "pcap-snf.c",
        "pcap-snit.c",
        "pcap-snoop.c",
        "pcap-tc.c",
        "pcap-usb-linux.c",
        "pcap.c",
        "rpcap-protocol.c",
        "rpcapd/daemon.c",
        "rpcapd/fileconf.c",
        "rpcapd/log.c",
        "rpcapd/rpcapd.c",
        "rpcapd/win32-svc.c",
        "savefile.c",
        "sf-pcap.c",
        "sf-pcapng.c",
        "sockutils.c",
        "testprogs/can_set_rfmon_test.c",
        "testprogs/capturetest.c",
        "testprogs/filtertest.c",
        "testprogs/findalldevstest.c",
        "testprogs/opentest.c",
        "testprogs/pcap_compile_test.c",
        "testprogs/reactivatetest.c",
        "testprogs/selpolltest.c",
        "testprogs/threadsignaltest.c",
        "testprogs/valgrindtest.c",
        "arcnet.h",
        "atmuni31.h",
        "diag-control.h",
        "dlpisubs.h",
        "ethertype.h",
        "extract.h",
        "fmtutils.h",
        "ftmacros.h",
        "gencode.h",
        "ieee80211.h",
        "lbl/os-aix4.h",
        "lbl/os-aix7.h",
        "lbl/os-hpux11.h",
        "lbl/os-osf4.h",
        "lbl/os-osf5.h",
        "lbl/os-solaris2.h",
        "lbl/os-sunos4.h",
        "lbl/os-ultrix4.h",
        "llc.h",
        "missing/getopt.h",
        "msdos/pktdrvr.h",
        "nametoaddr.h",
        "nlpid.h",
        "optimize.h",
        "pcap-bpf.h",
        "pcap-bt-linux.h",
        "pcap-bt-monitor-linux.h",
        "pcap-common.h",
        "pcap-dag.h",
        "pcap-dbus.h",
        "pcap-dos.h",
        "pcap-int.h",
        "pcap-namedb.h",
        "pcap-netfilter-linux.h",
        "pcap-netmap.h",
        "pcap-rdmasniff.h",
        "pcap-rpcap-int.h",
        "pcap-rpcap.h",
        "pcap-septel.h",
        "pcap-sita.h",
        "pcap-snf.h",
        "pcap-tc.h",
        "pcap-types.h",
        "pcap-usb-linux.h",
        "pcap.h",
        "pcap/bluetooth.h",
        "pcap/bpf.h",
        "pcap/can_socketcan.h",
        "pcap/compiler-tests.h",
        "pcap/dlt.h",
        "pcap/funcattrs.h",
        "pcap/ipnet.h",
        "pcap/namedb.h",
        "pcap/nflog.h",
        "pcap/pcap-inttypes.h",
        "pcap/pcap.h",
        "pcap/sll.h",
        "pcap/socket.h",
        "pcap/usb.h",
        "pcap/vlan.h",
        "portability.h",
        "ppp.h",
        "rpcap-protocol.h",
        "rpcapd/config_params.h",
        "rpcapd/daemon.h",
        "rpcapd/fileconf.h",
        "rpcapd/log.h",
        "rpcapd/rpcapd.h",
        "rpcapd/win32-svc.h",
        "sf-pcap.h",
        "sf-pcapng.h",
        "sockutils.h",
        "sunatmpos.h",
        "testprogs/unix.h",
        "varattrs.h",
        "<includes>",
        "<unknown>"
    ]
}