{
    "cve_id": "CVE-2022-27418",
    "cwe_id": "CWE-787",
    "commit_url": "https://github.com/appneta/tcpreplay/commit/e2ac765a25e902728b6d4a825358aa536e6668c2",
    "patch_names": [
        {
            "func_name": "fix_ipv6_checksums",
            "file_path": "src/tcpedit/edit_packet.c"
        },
        {
            "func_name": "fix_ipv4_checksums",
            "file_path": "src/tcpedit/edit_packet.c"
        },
        {
            "func_name": "ipv6_header_length",
            "file_path": "src/tcpedit/edit_packet.c"
        },
        {
            "func_name": "tcpedit_packet",
            "file_path": "src/tcpedit/tcpedit.c"
        },
        {
            "func_name": "main",
            "file_path": "src/tcprewrite.c"
        }
    ],
    "before_context": [
        {
            "file_path": "src/tcpedit/edit_packet.c",
            "patch": [
                {
                    "func_name": "fix_ipv6_checksums",
                    "patch": "--- func_before\n+++ func_after\n@@ -1,12 +1,13 @@\n int\n-fix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv6_hdr_t *ip6_hdr)\n+fix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n+                   ipv6_hdr_t *ip6_hdr, const size_t l2len)\n {\n     int ret = 0;\n     assert(tcpedit);\n     assert(pkthdr);\n     assert(ip6_hdr);\n \n-    if (pkthdr->caplen < sizeof(*ip6_hdr)) {\n+    if (pkthdr->caplen < (sizeof(*ip6_hdr) + l2len)) {\n         tcpedit_setwarn(tcpedit, \"caplen too small to read IPv6 header: %u\",\n                 pkthdr->caplen);\n         return TCPEDIT_WARN;\n@@ -20,10 +21,11 @@\n \n     /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n     if (pkthdr->caplen == pkthdr->len) {\n-        if (ip6_hdr->ip_len < ipv6_header_length(ip6_hdr, pkthdr->len)) {\n-            tcpedit_setwarn(tcpedit, \"Unable to checksum IPv6 packet with invalid length %u\",\n-                    ip6_hdr->ip_len);\n-            return TCPEDIT_WARN;\n+        int ip6_len = ipv6_header_length(ip6_hdr, pkthdr->len, l2len);\n+        if (ip6_hdr->ip_len < ip6_len) {\n+            tcpedit_seterr(tcpedit, \"Unable to checksum IPv6 packet with invalid length %u\",\n+                        ip6_hdr->ip_len);\n+            return TCPEDIT_ERROR;\n         }\n         ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,\n             htons(ip6_hdr->ip_len));"
                },
                {
                    "func_name": "fix_ipv4_checksums",
                    "patch": "--- func_before\n+++ func_after\n@@ -1,12 +1,13 @@\n int\n-fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr)\n+fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n+                   ipv4_hdr_t *ip_hdr, const size_t l2len)\n {\n     int ret1 = 0, ret2 = 0, ip_len;\n     assert(tcpedit);\n     assert(pkthdr);\n     assert(ip_hdr);\n \n-    if (pkthdr->caplen < sizeof(*ip_hdr)) {\n+    if (pkthdr->caplen < (sizeof(*ip_hdr) + l2len)) {\n         tcpedit_setwarn(tcpedit, \"caplen too small to read IPv4 header: %u\",\n                 pkthdr->caplen);\n         return TCPEDIT_WARN;\n@@ -17,18 +18,24 @@\n         return TCPEDIT_ERROR;\n     }\n \n+    ip_len = (int)ntohs(ip_hdr->ip_len);\n     /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n     if (pkthdr->caplen == pkthdr->len &&\n             (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {\n-        ip_len = (int)ntohs(ip_hdr->ip_len);\n-        ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p,\n-                ip_len - (ip_hdr->ip_hl << 2));\n+        if (ip_len != (int)(pkthdr->caplen - l2len)) {\n+            tcpedit_seterr(tcpedit,\n+                           \"caplen minus L2 length %u does IPv4 header length %u\",\n+                           pkthdr->caplen - l2len,\n+                           ip_len);\n+            return TCPEDIT_ERROR;\n+        }\n+        ret1 = do_checksum(tcpedit, (u_char*)ip_hdr, ip_hdr->ip_p,\n+                           ip_len - (ip_hdr->ip_hl << 2));\n         if (ret1 < 0)\n             return TCPEDIT_ERROR;\n     }\n     \n     /* calc IP checksum */\n-    ip_len = (int)ntohs(ip_hdr->ip_len);\n     ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);\n     if (ret2 < 0)\n         return TCPEDIT_ERROR;"
                },
                {
                    "func_name": "ipv6_header_length",
                    "patch": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int\n-ipv6_header_length(ipv6_hdr_t const * ip6_hdr, int pkt_len)\n+ipv6_header_length(ipv6_hdr_t const * ip6_hdr, const size_t pkt_len,\n+                   const size_t l2len)\n {\n     struct tcpr_ipv6_ext_hdr_base const * nhdr;\n     uint8_t next_header;\n@@ -8,8 +9,7 @@\n     offset = sizeof(*ip6_hdr);\n     next_header = ip6_hdr->ip_nh;\n \n-    while (sizeof(*nhdr) + offset < (size_t)pkt_len)\n-    {\n+    while (sizeof(*nhdr) + offset + l2len < (size_t)pkt_len) {\n         if (next_header != TCPR_IPV6_NH_HBH\n                 && next_header != TCPR_IPV6_NH_ROUTING\n                 && next_header != TCPR_IPV6_NH_FRAGMENT) {"
                }
            ],
            "related_methods_edit_packet_c": [
                "fix_ipv4_checksums assert do_checksum TCPEDIT_OK tcpedit_setwarn tcpedit_seterr ntohs TCPEDIT_WARN TCPEDIT_ERROR __tcpedit_seterr htons",
                "ipv6_header_length ",
                "fix_ipv6_checksums assert TCPEDIT_OK tcpedit_setwarn tcpedit_seterr TCPEDIT_WARN TCPEDIT_ERROR do_checksum __tcpedit_seterr ipv6_header_length htons"
            ],
            "bfs_edit_packet_c": {
                "calleeMethods": [
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_PROTO_ISL",
                        "src/tcpedit/tcpr.h:1160:1160:TCPR_PROTO_ISL:0",
                        "",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.equals",
                        "<operator>.equals",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_IPV6_NH_HBH",
                        "src/tcpedit/tcpr.h:865:865:TCPR_IPV6_NH_HBH:0",
                        "",
                        1
                    ],
                    [
                        "src/common/get.c",
                        "get_ipv6_next",
                        "get_ipv6_next",
                        "void * /* <=== get_ipv6_next */ \nget_ipv6_next(struct tcpr_ipv6_ext_hdr_base *exthdr, const int len)\n{\n    int extlen = 0;\n    int maxlen;\n    void *ptr;\n    assert(exthdr);\n\n    maxlen = *((int*)((u_char *)exthdr + len));\n\n    dbgx(3, \"Jumping to next IPv6 header.  Processing 0x%02x\", exthdr->ip_nh);\n    switch (exthdr->ip_nh) {\n    /* no further processing */\n    case TCPR_IPV6_NH_NO_NEXT:\n    case TCPR_IPV6_NH_ESP:\n        dbg(3, \"No-Next or ESP... can't go any further...\");\n        return NULL;\n        break;\n\n    /*\n     * fragment header is fixed size \n     * FIXME: Frag header has further ext headers (has a ip_nh field)\n     * but I don't support it because there's never a full L4 + payload beyond.\n     */\n    case TCPR_IPV6_NH_FRAGMENT:\n        dbg(3, \"Looks like were a fragment header. Returning some frag'd data.\");\n        ptr = (void *)((u_char *)exthdr + sizeof(struct tcpr_ipv6_frag_hdr));\n        if (*(int*)ptr > maxlen)\n            return NULL;\n        return ptr;\n        break;\n\n    /* all the rest require us to go deeper using the ip_len field */\n    case TCPR_IPV6_NH_IPV6:\n    case TCPR_IPV6_NH_ROUTING:\n    case TCPR_IPV6_NH_DESTOPTS:\n    case TCPR_IPV6_NH_HBH:\n    case TCPR_IPV6_NH_AH:\n        extlen = IPV6_EXTLEN_TO_BYTES(exthdr->ip_len);\n        dbgx(3, \"Looks like we're an ext header (0x%hhx).  Jumping %u bytes\"\n               \" to the next\", exthdr->ip_nh, extlen);\n        ptr = (void *)((u_char *)exthdr + extlen);\n        if (*(int*)ptr > maxlen)\n            return NULL;\n        return ptr;\n        break;\n\n    default:\n        dbg(3, \"Must not be a v6 extension header... returning self\");\n        return (void *)exthdr;\n        break;\n    }\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "htons",
                        "htons",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.or",
                        "<operator>.or",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_ICMP6",
                        "src/tcpedit/tcpr.h:879:879:IPPROTO_ICMP6:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_OSPF_LSA",
                        "src/tcpedit/tcpr.h:1183:1183:IPPROTO_OSPF_LSA:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/tcpedit.c",
                        "__tcpedit_seterr",
                        "__tcpedit_seterr",
                        "void /* <=== __tcpedit_seterr */ \n__tcpedit_seterr(tcpedit_t *tcpedit, const char *func, const int line, const char *file, const char *fmt, ...)\n{\n    va_list ap;\n    char errormsg[TCPEDIT_ERRSTR_LEN - 32];\n    \n    assert(tcpedit);\n\n    va_start(ap, fmt);\n    if (fmt != NULL) {\n        (void)vsnprintf(errormsg, sizeof(errormsg), fmt, ap);\n    }\n\n    va_end(ap);\n    \n    snprintf(tcpedit->runtime.errstr, sizeof(tcpedit->runtime.errstr),\n             \"From %s:%s() line %d:\\n%s\",\n             file, func, line, errormsg);\n}",
                        1
                    ],
                    [
                        "src/common/get.c",
                        "get_ipv6_l4proto",
                        "get_ipv6_l4proto",
                        "uint8_t  /* <=== get_ipv6_l4proto */ \nget_ipv6_l4proto(const ipv6_hdr_t *ip6_hdr, const int l3len)\n{\n    u_char *ptr = (u_char *)ip6_hdr + TCPR_IPV6_H; /* jump to the end of the IPv6 header */\n    uint8_t proto;\n    struct tcpr_ipv6_ext_hdr_base *exthdr = NULL;\n\n    assert(ip6_hdr);\n\n    proto = ip6_hdr->ip_nh;\n    int l4len = l3len - TCPR_IPV6_H;\n    if (l4len < 0)\n        return proto;\n\n    while (TRUE) {\n        dbgx(3, \"Processing next proto 0x%02X\", proto);\n        switch (proto) {\n            /* no further processing for IPV6 types with nothing beyond them */\n            case TCPR_IPV6_NH_FRAGMENT:\n            case TCPR_IPV6_NH_ESP:\n                dbg(3, \"No-Next or ESP... can't go any further...\");\n                return proto;\n                break;\n\n            /* recurse */\n            case TCPR_IPV6_NH_IPV6:\n                dbg(3, \"Recursing due to v6 in v6\");\n                return get_ipv6_l4proto((ipv6_hdr_t *)ptr, l4len);\n                break;\n\n            /* loop again */\n            case TCPR_IPV6_NH_AH:\n            case TCPR_IPV6_NH_ROUTING:\n            case TCPR_IPV6_NH_DESTOPTS:\n            case TCPR_IPV6_NH_HBH:\n                dbgx(3, \"Jumping to next extension header (0x%hhx)\", proto);\n                exthdr = get_ipv6_next((struct tcpr_ipv6_ext_hdr_base *)ptr,\n                        l4len);\n                if (exthdr == NULL)\n                    return proto;\n                proto = exthdr->ip_nh;\n                l4len -= (u_char *)exthdr - ptr;\n                ptr = (u_char *)exthdr;\n                break;\n\n            /* should be TCP, UDP or the like */\n            default:\n                dbgx(3, \"Selecting next L4 Proto as: 0x%02x\", proto);\n                return proto;\n        } /* switch */\n    } /* while */\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IP_MF",
                        "src/tcpedit/tcpr.h:739:739:IP_MF:0",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpedit_types.h",
                        "TCPEDIT_OK",
                        "src/tcpedit/tcpedit_types.h:34:34:TCPEDIT_OK:0",
                        "#define TCPEDIT_OK      0 /* <=== src/tcpedit/tcpedit_types.h:34:34:TCPEDIT_OK:0 */ ",
                        1
                    ],
                    [
                        "<empty>",
                        "ntohs",
                        "ntohs",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "ipv6_header_length",
                        "ipv6_header_length",
                        "static int /* <=== ipv6_header_length */ \nipv6_header_length(ipv6_hdr_t const * ip6_hdr, int pkt_len)\n{\n    struct tcpr_ipv6_ext_hdr_base const * nhdr;\n    uint8_t next_header;\n    int offset;\n\n    offset = sizeof(*ip6_hdr);\n    next_header = ip6_hdr->ip_nh;\n\n    while (sizeof(*nhdr) + offset < (size_t)pkt_len)\n    {\n        if (next_header != TCPR_IPV6_NH_HBH\n                && next_header != TCPR_IPV6_NH_ROUTING\n                && next_header != TCPR_IPV6_NH_FRAGMENT) {\n            return offset;\n        }\n\n        nhdr = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)ip6_hdr) + offset);\n        next_header = nhdr->ip_nh;\n        offset += ((nhdr->ip_len + 1) << 3);\n    }\n\n    return -1;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IP_OFFMASK",
                        "src/tcpedit/tcpr.h:742:742:IP_OFFMASK:0",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.notEquals",
                        "<operator>.notEquals",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.sizeOf",
                        "<operator>.sizeOf",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpedit_types.h",
                        "TCPEDIT_WARN",
                        "src/tcpedit/tcpedit_types.h:35:35:TCPEDIT_WARN:0",
                        "#define TCPEDIT_WARN    1 /* <=== src/tcpedit/tcpedit_types.h:35:35:TCPEDIT_WARN:0 */ ",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.and",
                        "<operator>.and",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.cast",
                        "<operator>.cast",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalAnd",
                        "<operator>.logicalAnd",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.indirectFieldAccess",
                        "<operator>.indirectFieldAccess",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.lessThan",
                        "<operator>.lessThan",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_IPV6_H",
                        "src/tcpedit/tcpr.h:100:100:TCPR_IPV6_H:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/common/err.h",
                        "dbgx",
                        "src/tcpedit/common/err.h:110:110:dbgx:3",
                        "",
                        2
                    ],
                    [
                        "src/common/get.c",
                        "get_layer4_v6",
                        "get_layer4_v6",
                        "void * /* <=== get_layer4_v6 */ \nget_layer4_v6(const ipv6_hdr_t *ip6_hdr, const int l3len)\n{\n    struct tcpr_ipv6_ext_hdr_base *next, *exthdr;\n    bool done = false;\n    uint32_t maxlen;\n    uint8_t proto;\n    int min_len;\n\n    assert(ip6_hdr);\n\n    min_len = TCPR_IPV6_H + sizeof(struct tcpr_ipv6_ext_hdr_base);\n    if (l3len < min_len)\n        return NULL;\n\n    /* jump to the end of the IPv6 header */\n    next = (struct tcpr_ipv6_ext_hdr_base *)((u_char *)ip6_hdr + TCPR_IPV6_H);\n    proto = ip6_hdr->ip_nh;\n\n    while (!done) {\n        dbgx(3, \"Processing proto: 0x%hx\", (uint16_t)proto);\n\n        switch (proto) {\n        /* recurse due to v6-in-v6, need to recast next as an IPv6 Header */\n        case TCPR_IPV6_NH_IPV6:\n            dbg(3, \"recursing due to v6-in-v6\");\n            next = get_layer4_v6((ipv6_hdr_t *)next, l3len - min_len);\n            break;\n\n        /* loop again */\n        case TCPR_IPV6_NH_AH:\n        case TCPR_IPV6_NH_ROUTING:\n        case TCPR_IPV6_NH_DESTOPTS:\n        case TCPR_IPV6_NH_HBH:\n            dbgx(3, \"Going deeper due to extension header 0x%02X\", proto);\n            maxlen = l3len - (int)((u_char *)ip6_hdr - (u_char *)next);\n            exthdr = get_ipv6_next(next, maxlen);\n            if (exthdr == NULL) {\n                done = true;\n                break;\n            }\n            proto = exthdr->ip_nh;\n            next = exthdr;\n            break;\n\n        /*\n         * Can't handle.  Unparsable IPv6 fragment/encrypted data\n         */\n        case TCPR_IPV6_NH_FRAGMENT:\n        case TCPR_IPV6_NH_ESP:\n            next = NULL;\n            done = true;\n            break;\n\n        /*\n         * no further processing, either TCP, UDP, ICMP, etc...\n         */\n        default:\n            if (proto != ip6_hdr->ip_nh) {\n                dbgx(3, \"Returning byte offset of this ext header: %u\", \n                        IPV6_EXTLEN_TO_BYTES(next->ip_len));\n                next =  (void *)((u_char *)next + IPV6_EXTLEN_TO_BYTES(next->ip_len));\n            } else {\n                dbgx(3, \"%s\", \"Returning end of IPv6 Header\");\n            }\n\n            done = true;\n        } /* switch */\n    } /* while */\n\n    if (!next || (u_char*)next > (u_char*)ip6_hdr + l3len)\n        return NULL;\n\n    return next;\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpedit.h",
                        "tcpedit_seterr",
                        "src/tcpedit/tcpedit.h:73:73:tcpedit_seterr:3",
                        "#define tcpedit_seterr(x, y, ...) __tcpedit_seterr(x, __FUNCTION__, __LINE__, __FILE__, y, __VA_ARGS__) /* <=== src/tcpedit/tcpedit.h:73:73:tcpedit_seterr:3 */ ",
                        1
                    ],
                    [
                        "src/tcpedit/checksum.h",
                        "CHECKSUM_CARRY",
                        "src/tcpedit/checksum.h:24:25:CHECKSUM_CARRY:1",
                        "#define CHECKSUM_CARRY(x) \\ /* <=== src/tcpedit/checksum.h:24:25:CHECKSUM_CARRY:1 */ \n    (x = (x >> 16) + (x & 0xffff), (~(x + (x >> 16)) & 0xffff))",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_OSPF",
                        "src/tcpedit/tcpr.h:1181:1181:IPPROTO_OSPF:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_PROTO_CDP",
                        "src/tcpedit/tcpr.h:336:336:TCPR_PROTO_CDP:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/tcpedit_types.h",
                        "TCPEDIT_ERRSTR_LEN",
                        "src/tcpedit/tcpedit_types.h:63:63:TCPEDIT_ERRSTR_LEN:0",
                        "#define TCPEDIT_ERRSTR_LEN 1024 /* <=== src/tcpedit/tcpedit_types.h:63:63:TCPEDIT_ERRSTR_LEN:0 */ ",
                        2
                    ],
                    [
                        "src/tcpedit/checksum.c",
                        "do_checksum_math",
                        "do_checksum_math<duplicate>0",
                        "static int /* <=== do_checksum_math<duplicate>0 */ \ndo_checksum_math(uint16_t *data, int len)\n{\n    int sum = 0;\n    union {\n        uint16_t s;\n        uint8_t b[2];\n    } pad;\n\n    while (len > 1) {\n        sum += *data++;\n        len -= 2;\n    }\n\n    if (len == 1) {\n        pad.b[0] = *(uint8_t *)data;\n        pad.b[1] = 0;\n        sum += pad.s;\n    }\n\n    return (sum);\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_IPV6_NH_FRAGMENT",
                        "src/tcpedit/tcpr.h:823:823:TCPR_IPV6_NH_FRAGMENT:0",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_IPV6_NH_ROUTING",
                        "src/tcpedit/tcpr.h:837:837:TCPR_IPV6_NH_ROUTING:0",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.addition",
                        "<operator>.addition",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.assignmentPlus",
                        "<operator>.assignmentPlus",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/checksum.c",
                        "do_checksum",
                        "do_checksum",
                        "int /* <=== do_checksum */ \ndo_checksum(tcpedit_t *tcpedit, uint8_t *data, int proto, int len) {\n    ipv4_hdr_t *ipv4;\n    ipv6_hdr_t *ipv6;\n    tcp_hdr_t *tcp;\n    udp_hdr_t *udp;\n    icmpv4_hdr_t *icmp;\n    icmpv6_hdr_t *icmp6;\n    u_char *layer;\n    int ip_hl;\n    int sum;\n\n    sum = 0;\n    ipv4 = NULL;\n    ipv6 = NULL;\n    assert(data);\n\n    if (!data || len <= 0) {\n        tcpedit_seterr(tcpedit, \"%s\", \"length of data must be > 0\");\n        return TCPEDIT_ERROR;\n    }\n\n    ipv4 = (ipv4_hdr_t *)data;\n    if (ipv4->ip_v == 6) {\n        ipv6 = (ipv6_hdr_t *)data;\n        ipv4 = NULL;\n\n        proto = get_ipv6_l4proto(ipv6, len + sizeof(ipv6_hdr_t));\n        dbgx(3, \"layer4 proto is 0x%hx\", (uint16_t)proto);\n\n        layer = (u_char*)get_layer4_v6(ipv6, len + sizeof(ipv6_hdr_t));\n        if (!layer) {\n            tcpedit_setwarn(tcpedit, \"%s\", \"Packet to short for checksum\");\n            return TCPEDIT_WARN;\n        }\n\n        ip_hl = layer - (u_char*)data;\n        dbgx(3, \"ip_hl proto is 0x%d\", ip_hl);\n\n        len -= (ip_hl - TCPR_IPV6_H);\n    } else {\n        ip_hl = ipv4->ip_hl << 2;\n    }\n\n    switch (proto) {\n        case IPPROTO_TCP:\n            if (len < (int)sizeof(tcp_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum TCP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n\n            tcp = (tcp_hdr_t *)(data + ip_hl);\n#ifdef STUPID_SOLARIS_CHECKSUM_BUG\n            tcp->th_sum = tcp->th_off << 2;\n            return (TCPEDIT_OK);\n#endif\n            tcp->th_sum = 0;\n\n            /* Note, we do both src & dst IP's at the same time, that's why the\n             * length is 2x a single IP\n             */\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n            } else {\n                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_TCP + len);\n            sum += do_checksum_math((uint16_t *)tcp, len);\n            tcp->th_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_UDP:\n            if (len < (int)sizeof(udp_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum UDP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            udp = (udp_hdr_t *)(data + ip_hl);\n            /* No need to recalculate UDP checksums if already 0 */\n            if (udp->uh_sum == 0)\n                break;\n            udp->uh_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n            } else {\n                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_UDP + len);\n            sum += do_checksum_math((uint16_t *)udp, len);\n            udp->uh_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_ICMP:\n            if (len < (int)sizeof(icmpv4_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum ICMP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            icmp = (icmpv4_hdr_t *)(data + ip_hl);\n            icmp->icmp_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n                icmp->icmp_sum = CHECKSUM_CARRY(sum);\n            }\n            sum += do_checksum_math((uint16_t *)icmp, len);\n            icmp->icmp_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_ICMP6:\n            if (len < (int)sizeof(icmpv6_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum ICMP6 with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            icmp6 = (icmpv6_hdr_t *)(data + ip_hl);\n            icmp6->icmp_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((u_int16_t *)&ipv6->ip_src, 32);\n            }\n            sum += ntohs(IPPROTO_ICMP6 + len);\n            sum += do_checksum_math((u_int16_t *)icmp6, len);\n            icmp6->icmp_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_IP:\n            if (ipv4) {\n                ipv4->ip_sum = 0;\n                sum = do_checksum_math((uint16_t *)data, ip_hl);\n                ipv4->ip_sum = CHECKSUM_CARRY(sum);\n            }\n            break;\n\n        case IPPROTO_IGMP:\n        case IPPROTO_GRE:\n        case IPPROTO_OSPF:\n        case IPPROTO_OSPF_LSA:\n        case IPPROTO_VRRP:\n        case TCPR_PROTO_CDP:\n        case TCPR_PROTO_ISL:\n        default:\n            tcpedit_setwarn(tcpedit, \"Unsupported protocol for checksum: 0x%x\", proto);\n            return TCPEDIT_WARN;\n    }\n\n    return TCPEDIT_OK;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalOr",
                        "<operator>.logicalOr",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.shiftLeft",
                        "<operator>.shiftLeft",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_VRRP",
                        "src/tcpedit/tcpr.h:1707:1707:IPPROTO_VRRP:0",
                        "",
                        2
                    ],
                    [
                        "src/common/common/err.h",
                        "dbgx",
                        "src/common/common/err.h:110:110:dbgx:3",
                        "",
                        3
                    ],
                    [
                        "<empty>",
                        "assert",
                        "assert",
                        "",
                        1
                    ],
                    [
                        "src/common/common/err.h",
                        "dbg",
                        "src/common/common/err.h:109:109:dbg:2",
                        "",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.assignment",
                        "<operator>.assignment",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.indirection",
                        "<operator>.indirection",
                        "",
                        1
                    ],
                    [
                        "libopts/compat/snprintf.c",
                        "vsnprintf",
                        "vsnprintf",
                        "static int /* <=== vsnprintf */ \nvsnprintf( char *str, size_t n, char const *fmt, va_list ap )\n{\n#ifdef VSPRINTF_CHARSTAR\n    return (strlen(vsprintf(str, fmt, ap)));\n#else\n    return (vsprintf(str, fmt, ap));\n#endif\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpedit_types.h",
                        "TCPEDIT_ERROR",
                        "src/tcpedit/tcpedit_types.h:33:33:TCPEDIT_ERROR:0",
                        "#define TCPEDIT_ERROR  -1 /* <=== src/tcpedit/tcpedit_types.h:33:33:TCPEDIT_ERROR:0 */ ",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_GRE",
                        "src/tcpedit/tcpr.h:685:685:IPPROTO_GRE:0",
                        "",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.subtraction",
                        "<operator>.subtraction",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.minus",
                        "<operator>.minus",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpedit.c",
                        "tcpedit_setwarn",
                        "tcpedit_setwarn",
                        "void /* <=== tcpedit_setwarn */ \ntcpedit_setwarn(tcpedit_t *tcpedit, const char *fmt, ...)\n{\n    va_list ap;\n    assert(tcpedit);\n\n    va_start(ap, fmt);\n    if (fmt != NULL)\n        (void)vsnprintf(tcpedit->runtime.warnstr,\n                        sizeof(tcpedit->runtime.warnstr), fmt, ap);\n\n    va_end(ap);\n        \n}",
                        1
                    ]
                ],
                "globalVars": [],
                "importContext": [
                    "#include \"config.h\"",
                    "#include \"defines.h\"",
                    "#include \"common.h\"",
                    "#include \"tcpedit.h\"",
                    "#include \"edit_packet.h\"",
                    "#include \"checksum.h\"",
                    "#include \"incremental_checksum.h\"",
                    "#include \"lib/sll.h\"",
                    "#include \"dlt.h\"",
                    "#include <string.h>",
                    "#include <stdlib.h>",
                    "#include <sys/types.h>",
                    "#include <sys/socket.h>",
                    "#include <netinet/in.h>",
                    "#include <arpa/inet.h>"
                ],
                "typeDefs": [
                    [
                        "struct pcap_pkthdr",
                        "pcap_pkthdr"
                    ],
                    [
                        "typedef unsigned char         uint8_t;",
                        "uint8_t"
                    ],
                    [
                        "struct tcpr_ipv6_ext_hdr_base\n{\n    uint8_t ip_nh;          /* next header */\n    uint8_t ip_len;         /* length of header in 8 octet units (sans 1st) */\n    /* some more bytes are always here, but we don't know what kind */\n}",
                        "tcpr_ipv6_ext_hdr_base"
                    ],
                    [
                        "typedef struct {\n    bool validated;  /* have we run tcpedit_validate()? */\n    struct tcpeditdlt_s *dlt_ctx;\n    \n    /* runtime variables, don't mess with these */\n    tcpedit_runtime_t runtime;\n    \n    /* skip rewriting IP/MAC's which are broadcast or multicast? */\n    bool skip_broadcast;\n\n    /* pad or truncate packets */\n    tcpedit_fixlen fixlen;\n    tcpedit_direction editdir;\n\n    /* rewrite ip? */\n    bool rewrite_ip;\n\n    /* rewrite TCP seq/ack numbers? */\n    u_int32_t tcp_sequence_enable;\n    u_int32_t tcp_sequence_adjust;\n    \n    /* fix IP/TCP/UDP checksums */\n    bool fixcsum;\n\n    /* remove ethernet FCS */\n    bool efcs;\n\n    tcpedit_ttl_mode ttl_mode;\n    u_int8_t ttl_value;\n\n    /* TOS/DiffServ/ECN, -1 is disabled, else copy value */\n    int tos;\n    \n    /* IPv6 FlowLabel, -1 is disabled, else copy value */\n    int flowlabel;\n    \n    /* IPv6 TClass, -1 is disabled, else copy value */\n    int tclass;\n    \n    /* rewrite end-point IP addresses between cidrmap1 & c...",
                        "tcpedit_t"
                    ]
                ],
                "visitedLines": [
                    [
                        105,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        155,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        69,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        117,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        124,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        127,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        64,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        114,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        104,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        58,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        144,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        107,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        90,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        154,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        133,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        138,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        83,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        160,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        84,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        59,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        151,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        136,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        118,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        67,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        130,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        109,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        167,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        80,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        95,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        68,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        61,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        91,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        131,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        141,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        165,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        119,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        111,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        116,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        145,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        79,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        108,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        63,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        164,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        112,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        123,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        73,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        139,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        74,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        122,
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        66,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        62,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        81,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        153,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        89,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        134,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        152,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        140,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        97,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        147,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        135,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        94,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        159,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        88,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        72,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        82,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        78,
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        157,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        146,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        158,
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ]
                ],
                "visitedParams": [
                    [
                        "ipv6_hdr_t *ip6_hdr",
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        "struct pcap_pkthdr *pkthdr",
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        "tcpedit_t *tcpedit",
                        "fix_ipv6_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        "struct pcap_pkthdr *pkthdr",
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        "tcpedit_t *tcpedit",
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        "ipv6_hdr_t const * ip6_hdr",
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        "ipv4_hdr_t *ip_hdr",
                        "fix_ipv4_checksums",
                        "src/tcpedit/edit_packet.c"
                    ],
                    [
                        "int pkt_len",
                        "ipv6_header_length",
                        "src/tcpedit/edit_packet.c"
                    ]
                ],
                "vulnerableMethods": [
                    [
                        "src/tcpedit/edit_packet.c",
                        "fix_ipv4_checksums",
                        "int /* <=== fix_ipv4_checksums */ \nfix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr)\n{\n    int ret1 = 0, ret2 = 0, ip_len;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip_hdr);\n\n    if (pkthdr->caplen < sizeof(*ip_hdr)) {\n        tcpedit_setwarn(tcpedit, \"caplen too small to read IPv4 header: %u\",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    if (ip_hdr->ip_v != 4) {\n        tcpedit_seterr(tcpedit, \"Invalid packet: Expected IPv4 packet: got %u\", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len &&\n            (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {\n        ip_len = (int)ntohs(ip_hdr->ip_len);\n        ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p,\n                ip_len - (ip_hdr->ip_hl << 2));\n        if (ret1 < 0)\n            return TCPEDIT_ERROR;\n    }\n    \n    /* calc IP checksum */\n    ip_len = (int)ntohs(ip_hdr->ip_len);\n    ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);\n    if (ret2 < 0)\n        return TCPEDIT_ERROR;\n\n    /* what do we return? */\n    if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n    \n    return TCPEDIT_OK;\n}",
                        58
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "ipv6_header_length",
                        "static int /* <=== ipv6_header_length */ \nipv6_header_length(ipv6_hdr_t const * ip6_hdr, int pkt_len)\n{\n    struct tcpr_ipv6_ext_hdr_base const * nhdr;\n    uint8_t next_header;\n    int offset;\n\n    offset = sizeof(*ip6_hdr);\n    next_header = ip6_hdr->ip_nh;\n\n    while (sizeof(*nhdr) + offset < (size_t)pkt_len)\n    {\n        if (next_header != TCPR_IPV6_NH_HBH\n                && next_header != TCPR_IPV6_NH_ROUTING\n                && next_header != TCPR_IPV6_NH_FRAGMENT) {\n            return offset;\n        }\n\n        nhdr = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)ip6_hdr) + offset);\n        next_header = nhdr->ip_nh;\n        offset += ((nhdr->ip_len + 1) << 3);\n    }\n\n    return -1;\n}",
                        104
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "fix_ipv6_checksums",
                        "int /* <=== fix_ipv6_checksums */ \nfix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv6_hdr_t *ip6_hdr)\n{\n    int ret = 0;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip6_hdr);\n\n    if (pkthdr->caplen < sizeof(*ip6_hdr)) {\n        tcpedit_setwarn(tcpedit, \"caplen too small to read IPv6 header: %u\",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    ipv4_hdr_t *ip_hdr = (ipv4_hdr_t*)ip6_hdr;\n    if (ip_hdr->ip_v != 6) {\n        tcpedit_seterr(tcpedit, \"Invalid packet: Expected IPv6 packet: got %u\", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len) {\n        if (ip6_hdr->ip_len < ipv6_header_length(ip6_hdr, pkthdr->len)) {\n            tcpedit_setwarn(tcpedit, \"Unable to checksum IPv6 packet with invalid length %u\",\n                    ip6_hdr->ip_len);\n            return TCPEDIT_WARN;\n        }\n        ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,\n            htons(ip6_hdr->ip_len));\n        if (ret < 0)\n            return TCPEDIT_ERROR;\n    }\n\n    /* what do we return? */\n    if (ret == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n\n    return TCPEDIT_OK;\n}",
                        130
                    ]
                ]
            }
        },
        {
            "file_path": "src/tcpedit/tcpedit.c",
            "patch": [
                {
                    "func_name": "tcpedit_packet",
                    "patch": "--- func_before\n+++ func_after\n@@ -278,10 +278,10 @@\n     if ((tcpedit->fixcsum || needtorecalc)) {\n         if (ip_hdr != NULL) {\n             dbgx(3, \"doing IPv4 checksum: needtorecalc=%d\", needtorecalc);\n-            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr);\n+            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr, l2len);\n         } else if (ip6_hdr != NULL) {\n             dbgx(3, \"doing IPv6 checksum: needtorecalc=%d\", needtorecalc);\n-            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr);\n+            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr, l2len);\n         } else {\n             dbgx(3, \"checksum not performed: needtorecalc=%d\", needtorecalc);\n             retval = TCPEDIT_OK;"
                }
            ],
            "related_methods_tcpedit_c": [
                "tcpedit_packet assert dbgx tcpedit_dlt_merge_l3data tcpedit_dlt_src tcpedit_dlt_dst tcpedit_dlt_l2len ntohs htons tcpedit_dlt_proto tcpedit_geterr TCPEDIT_SOFT_ERROR tcpedit_dlt_process get_layer4_v4 rewrite_ipv4_ttl fuzzing tcpedit_seterr tcpedit_dlt_l3data csum_replace2 rewrite_ipv4_tcp_sequence TCPEDIT_ERROR untrunc_packet fix_ipv4_checksums __tcpedit_seterr get_layer4_v6 rewrite_ipv6_hlim rewrite_ipv4_ports memcpy rewrite_ipv6_tcp_sequence rewrite_ipv4l3 randomize_ipv4 TCPEDIT_WARN warnx htonl fix_ipv6_checksums tcpedit_getwarn ntohl TCPEDIT_OK rewrite_ipv6_ports rewrite_ipv6l3 randomize_ipv6 rewrite_iparp randomize_iparp"
            ],
            "bfs_tcpedit_c": {
                "calleeMethods": [
                    [
                        "src/tcpedit/tcpedit/tcpr.h",
                        "ETHERTYPE_IP",
                        "src/tcpedit/tcpedit/tcpr.h:538:538:ETHERTYPE_IP:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/checksum.c",
                        "do_checksum",
                        "do_checksum",
                        "int /* <=== do_checksum */ \ndo_checksum(tcpedit_t *tcpedit, uint8_t *data, int proto, int len) {\n    ipv4_hdr_t *ipv4;\n    ipv6_hdr_t *ipv6;\n    tcp_hdr_t *tcp;\n    udp_hdr_t *udp;\n    icmpv4_hdr_t *icmp;\n    icmpv6_hdr_t *icmp6;\n    u_char *layer;\n    int ip_hl;\n    int sum;\n\n    sum = 0;\n    ipv4 = NULL;\n    ipv6 = NULL;\n    assert(data);\n\n    if (!data || len <= 0) {\n        tcpedit_seterr(tcpedit, \"%s\", \"length of data must be > 0\");\n        return TCPEDIT_ERROR;\n    }\n\n    ipv4 = (ipv4_hdr_t *)data;\n    if (ipv4->ip_v == 6) {\n        ipv6 = (ipv6_hdr_t *)data;\n        ipv4 = NULL;\n\n        proto = get_ipv6_l4proto(ipv6, len + sizeof(ipv6_hdr_t));\n        dbgx(3, \"layer4 proto is 0x%hx\", (uint16_t)proto);\n\n        layer = (u_char*)get_layer4_v6(ipv6, len + sizeof(ipv6_hdr_t));\n        if (!layer) {\n            tcpedit_setwarn(tcpedit, \"%s\", \"Packet to short for checksum\");\n            return TCPEDIT_WARN;\n        }\n\n        ip_hl = layer - (u_char*)data;\n        dbgx(3, \"ip_hl proto is 0x%d\", ip_hl);\n\n        len -= (ip_hl - TCPR_IPV6_H);\n    } else {\n        ip_hl = ipv4->ip_hl << 2;\n    }\n\n    switch (proto) {\n        case IPPROTO_TCP:\n            if (len < (int)sizeof(tcp_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum TCP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n\n            tcp = (tcp_hdr_t *)(data + ip_hl);\n#ifdef STUPID_SOLARIS_CHECKSUM_BUG\n            tcp->th_sum = tcp->th_off << 2;\n            return (TCPEDIT_OK);\n#endif\n            tcp->th_sum = 0;\n\n            /* Note, we do both src & dst IP's at the same time, that's why the\n             * length is 2x a single IP\n             */\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n            } else {\n                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_TCP + len);\n            sum += do_checksum_math((uint16_t *)tcp, len);\n            tcp->th_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_UDP:\n            if (len < (int)sizeof(udp_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum UDP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            udp = (udp_hdr_t *)(data + ip_hl);\n            /* No need to recalculate UDP checksums if already 0 */\n            if (udp->uh_sum == 0)\n                break;\n            udp->uh_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n            } else {\n                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_UDP + len);\n            sum += do_checksum_math((uint16_t *)udp, len);\n            udp->uh_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_ICMP:\n            if (len < (int)sizeof(icmpv4_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum ICMP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            icmp = (icmpv4_hdr_t *)(data + ip_hl);\n            icmp->icmp_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n                icmp->icmp_sum = CHECKSUM_CARRY(sum);\n            }\n            sum += do_checksum_math((uint16_t *)icmp, len);\n            icmp->icmp_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_ICMP6:\n            if (len < (int)sizeof(icmpv6_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum ICMP6 with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            icmp6 = (icmpv6_hdr_t *)(data + ip_hl);\n            icmp6->icmp_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((u_int16_t *)&ipv6->ip_src, 32);\n            }\n            sum += ntohs(IPPROTO_ICMP6 + len);\n            sum += do_checksum_math((u_int16_t *)icmp6, len);\n            icmp6->icmp_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_IP:\n            if (ipv4) {\n                ipv4->ip_sum = 0;\n                sum = do_checksum_math((uint16_t *)data, ip_hl);\n                ipv4->ip_sum = CHECKSUM_CARRY(sum);\n            }\n            break;\n\n        case IPPROTO_IGMP:\n        case IPPROTO_GRE:\n        case IPPROTO_OSPF:\n        case IPPROTO_OSPF_LSA:\n        case IPPROTO_VRRP:\n        case TCPR_PROTO_CDP:\n        case TCPR_PROTO_ISL:\n        default:\n            tcpedit_setwarn(tcpedit, \"Unsupported protocol for checksum: 0x%x\", proto);\n            return TCPEDIT_WARN;\n    }\n\n    return TCPEDIT_OK;\n}",
                        2
                    ],
                    [
                        "src/common/cidr.c",
                        "ip_in_cidr",
                        "ip_in_cidr",
                        "int /* <=== ip_in_cidr */ \nip_in_cidr(const tcpr_cidr_t * mycidr, const unsigned long ip)\n{\n    unsigned long ipaddr = 0, network = 0, mask = 0;\n    int ret = 0;\n#ifdef DEBUG\n    char netstr[20];\n#endif\n    \n    if (mycidr->family != AF_INET)\n        return 0;\n\n    /* always return 1 if 0.0.0.0/0 */\n    if (mycidr->masklen == 0 && mycidr->u.network == 0)\n        return 1;\n\n    mask = ~0;                  /* turn on all the bits */\n\n    /* shift over by the correct number of bits */\n    mask = mask << (32 - mycidr->masklen);\n\n    /* apply the mask to the network and ip */\n    ipaddr = ntohl(ip) & mask;\n\n    network = htonl(mycidr->u.network) & mask;\n\n\n#ifdef DEBUG\n    /* copy this for debug purposes, since it's not re-entrant */\n    strlcpy(netstr, get_addr2name4(mycidr->u.network, RESOLVE), 20);\n#endif\n\n    /* if they're the same, then ip is in network */\n    if (network == ipaddr) {\n#ifdef DEBUG\n        dbgx(1, \"The ip %s is inside of %s/%d\",\n            get_addr2name4(ip, RESOLVE), netstr, mycidr->masklen);\n#endif\n        ret = 1;\n    } else {\n#ifdef DEBUG\n        dbgx(1, \"The ip %s is not inside of %s/%d\",\n            get_addr2name4(ip, RESOLVE), netstr, mycidr->masklen);\n#endif\n        ret = 0;\n    }\n    return ret;\n\n}",
                        2
                    ],
                    [
                        "src/tcpedit/plugins/common/err.h",
                        "warnx",
                        "src/tcpedit/plugins/common/err.h:114:114:warnx:2",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/portmap.c",
                        "rewrite_ipv6_ports",
                        "rewrite_ipv6_ports",
                        "int /* <=== rewrite_ipv6_ports */ \nrewrite_ipv6_ports(tcpedit_t *tcpedit, ipv6_hdr_t **ip6_hdr, const int l3len)\n{\n    assert(tcpedit);\n    u_char *l4;\n\n    if (*ip6_hdr == NULL || ip6_hdr == NULL) {\n        tcpedit_seterr(tcpedit, \"rewrite_ipv6_ports: NULL IPv6 header: l3 len=%d\",\n                l3len);\n        return TCPEDIT_ERROR;\n    } else if ((*ip6_hdr)->ip_nh == IPPROTO_TCP || (*ip6_hdr)->ip_nh == IPPROTO_UDP) {\n        l4 = get_layer4_v6(*ip6_hdr, l3len);\n        if (l4)\n            return rewrite_ports(tcpedit, (*ip6_hdr)->ip_nh, l4,\n                    l3len - (l4 - (u_char*)*ip6_hdr));\n\n        tcpedit_setwarn(tcpedit, \"Unable to rewrite ports on IPv6 header: l3 len=%d\",\n                l3len);\n        return TCPEDIT_WARN;\n    }\n\n    return 0;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "ETHERTYPE_ARP",
                        "src/tcpedit/tcpr.h:541:541:ETHERTYPE_ARP:0",
                        "",
                        1
                    ],
                    [
                        "src/common/common/err.h",
                        "dbgx",
                        "src/common/common/err.h:110:110:dbgx:3",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/tcpedit/tcpr.h",
                        "ETHERTYPE_IP6",
                        "src/tcpedit/tcpedit/tcpr.h:559:559:ETHERTYPE_IP6:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "ipv6_addr_csum_replace",
                        "ipv6_addr_csum_replace",
                        "static void ipv6_addr_csum_replace(ipv6_hdr_t *ip6_hdr, /* <=== ipv6_addr_csum_replace */ \n        struct tcpr_in6_addr *old_ip, struct tcpr_in6_addr *new_ip,\n        const int l3len)\n{\n    uint8_t *l4, protocol;\n    int len = l3len;\n\n    assert(ip6_hdr);\n\n    if ((size_t)len < sizeof(*ip6_hdr))\n        return;\n\n    protocol = get_ipv6_l4proto(ip6_hdr, len);\n    switch (protocol) {\n    case IPPROTO_UDP:\n        l4 = get_layer4_v6(ip6_hdr, len);\n        len -= sizeof(*ip6_hdr);\n        len -= TCPR_UDP_H;\n        break;\n\n    case IPPROTO_TCP:\n        l4 = get_layer4_v6(ip6_hdr, len);\n        len -= sizeof(*ip6_hdr);\n        len -= TCPR_TCP_H;\n        break;\n\n    default:\n        l4 = NULL;\n    }\n\n    if (!l4 || len < 0)\n        return;\n\n    ipv6_l34_csum_replace(l4, protocol, (uint32_t*)old_ip, (uint32_t*)new_ip);\n}",
                        2
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "randomize_ipv4",
                        "randomize_ipv4",
                        "int /* <=== randomize_ipv4 */ \nrandomize_ipv4(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, \n        u_char *pktdata, ipv4_hdr_t *ip_hdr, const int l3len)\n{\n#ifdef DEBUG\n    char srcip[16], dstip[16];\n#endif\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(pktdata);\n    assert(ip_hdr);\n\n#ifdef DEBUG\n    strlcpy(srcip, get_addr2name4(ip_hdr->ip_src.s_addr, RESOLVE), 16);\n    strlcpy(dstip, get_addr2name4(ip_hdr->ip_dst.s_addr, RESOLVE), 16);\n#endif\n\n    /* randomize IP addresses based on the value of random */\n    dbgx(1, \"Old Src IP: %s\\tOld Dst IP: %s\", srcip, dstip);\n\n    if (l3len < (int)ip_hdr->ip_hl << 2) {\n        tcpedit_seterr(tcpedit, \"Unable to randomize IP header due to packet capture snap length %u\",\n                pkthdr->caplen);\n        return TCPEDIT_ERROR;\n    }\n\n    /* don't rewrite broadcast addresses */\n    if ((tcpedit->skip_broadcast && is_unicast_ipv4(tcpedit, (u_int32_t)ip_hdr->ip_dst.s_addr)) \n            || !tcpedit->skip_broadcast) {\n        uint32_t old_ip = ip_hdr->ip_dst.s_addr;\n        ip_hdr->ip_dst.s_addr = randomize_ipv4_addr(tcpedit, ip_hdr->ip_dst.s_addr);\n        ipv4_addr_csum_replace(ip_hdr, old_ip, ip_hdr->ip_dst.s_addr, l3len);\n    }\n    \n    if ((tcpedit->skip_broadcast && is_unicast_ipv4(tcpedit, (u_int32_t)ip_hdr->ip_src.s_addr))\n            || !tcpedit->skip_broadcast) {\n        uint32_t old_ip = ip_hdr->ip_src.s_addr;\n        ip_hdr->ip_src.s_addr = randomize_ipv4_addr(tcpedit, ip_hdr->ip_src.s_addr);\n        ipv4_addr_csum_replace(ip_hdr, old_ip, ip_hdr->ip_src.s_addr, l3len);\n    }\n\n#ifdef DEBUG    \n    strlcpy(srcip, get_addr2name4(ip_hdr->ip_src.s_addr, RESOLVE), 16);\n    strlcpy(dstip, get_addr2name4(ip_hdr->ip_dst.s_addr, RESOLVE), 16);\n#endif\n\n    dbgx(1, \"New Src IP: %s\\tNew Dst IP: %s\\n\", srcip, dstip);\n\n    return 0;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.indirectIndexAccess",
                        "<operator>.indirectIndexAccess",
                        "",
                        1
                    ],
                    [
                        "src/common/get.c",
                        "get_l2len",
                        "get_l2len",
                        "int /* <=== get_l2len */ \nget_l2len(const u_char *pktdata, const int datalen, const int datalink)\n{\n    uint16_t _U_ protocol;\n    uint32_t _U_ l2offset;\n    uint32_t _U_ vlan_offset;\n    uint32_t l2len = 0;\n\n    int res = get_l2len_protocol(pktdata,\n                                 datalen,\n                                 datalink,\n                                 &protocol,\n                                 &l2len,\n                                 &l2offset,\n                                 &vlan_offset);\n\n    if (res == -1)\n        return 0;\n\n    return l2len;\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_ICMP6",
                        "src/tcpedit/tcpr.h:879:879:IPPROTO_ICMP6:0",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/tcpedit_types.h",
                        "TCPEDIT_WARN",
                        "src/tcpedit/tcpedit_types.h:35:35:TCPEDIT_WARN:0",
                        "#define TCPEDIT_WARN    1 /* <=== src/tcpedit/tcpedit_types.h:35:35:TCPEDIT_WARN:0 */ ",
                        1
                    ],
                    [
                        "src/tcpedit/tcpedit/tcpedit.h",
                        "tcpedit_seterr",
                        "src/tcpedit/tcpedit/tcpedit.h:73:73:tcpedit_seterr:3",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/common/err.h",
                        "warnx",
                        "src/tcpedit/common/err.h:114:114:warnx:2",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.and",
                        "<operator>.and",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/tcpedit_types.h",
                        "TCPEDIT_WARN",
                        "src/tcpedit/plugins/tcpedit_types.h:35:35:TCPEDIT_WARN:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/checksum.h",
                        "CHECKSUM_CARRY",
                        "src/tcpedit/checksum.h:24:25:CHECKSUM_CARRY:1",
                        "#define CHECKSUM_CARRY(x) \\ /* <=== src/tcpedit/checksum.h:24:25:CHECKSUM_CARRY:1 */ \n    (x = (x >> 16) + (x & 0xffff), (~(x + (x >> 16)) & 0xffff))",
                        3
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_OSPF",
                        "src/tcpedit/tcpr.h:1181:1181:IPPROTO_OSPF:0",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_PROTO_ISL",
                        "src/tcpedit/tcpr.h:1160:1160:TCPR_PROTO_ISL:0",
                        "",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalAnd",
                        "<operator>.logicalAnd",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/common/err.h",
                        "dbgx",
                        "src/tcpedit/common/err.h:110:110:dbgx:3",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "rewrite_ipv4_ttl",
                        "rewrite_ipv4_ttl",
                        "int /* <=== rewrite_ipv4_ttl */ \nrewrite_ipv4_ttl(tcpedit_t *tcpedit, ipv4_hdr_t *ip_hdr)\n{\n    volatile uint16_t oldval, newval;\n\n    assert(tcpedit);\n\n    /* make sure there's something to edit */\n    if (ip_hdr == NULL || tcpedit->ttl_mode == false)\n        return(0);\n        \n    oldval = (uint16_t)ip_hdr->ip_ttl;\n    switch(tcpedit->ttl_mode) {\n    case TCPEDIT_TTL_MODE_SET:\n        if (ip_hdr->ip_ttl == tcpedit->ttl_value)\n            return 0;           /* no change required */\n        ip_hdr->ip_ttl = tcpedit->ttl_value;\n        break;\n    case TCPEDIT_TTL_MODE_ADD:\n        if (((int)ip_hdr->ip_ttl + tcpedit->ttl_value) > 255) {\n            ip_hdr->ip_ttl = 255;\n        } else {\n            ip_hdr->ip_ttl += tcpedit->ttl_value;\n        }\n        break;\n    case TCPEDIT_TTL_MODE_SUB:\n        if (ip_hdr->ip_ttl <= tcpedit->ttl_value) {\n            ip_hdr->ip_ttl = 1;\n        } else {\n            ip_hdr->ip_ttl -= tcpedit->ttl_value;\n        }\n        break;\n    default:\n        errx(1, \"invalid ttl_mode: %d\", tcpedit->ttl_mode);\n    }\n\n    newval = (uint16_t)ip_hdr->ip_ttl;\n    csum_replace2(&ip_hdr->ip_sum, oldval, newval);\n\n    return 0;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/tcpedit_types.h",
                        "TCPEDIT_SOFT_ERROR",
                        "src/tcpedit/plugins/tcpedit_types.h:32:32:TCPEDIT_SOFT_ERROR:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "ipv6_header_length",
                        "ipv6_header_length",
                        "static int /* <=== ipv6_header_length */ \nipv6_header_length(ipv6_hdr_t const * ip6_hdr, int pkt_len)\n{\n    struct tcpr_ipv6_ext_hdr_base const * nhdr;\n    uint8_t next_header;\n    int offset;\n\n    offset = sizeof(*ip6_hdr);\n    next_header = ip6_hdr->ip_nh;\n\n    while (sizeof(*nhdr) + offset < (size_t)pkt_len)\n    {\n        if (next_header != TCPR_IPV6_NH_HBH\n                && next_header != TCPR_IPV6_NH_ROUTING\n                && next_header != TCPR_IPV6_NH_FRAGMENT) {\n            return offset;\n        }\n\n        nhdr = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)ip6_hdr) + offset);\n        next_header = nhdr->ip_nh;\n        offset += ((nhdr->ip_len + 1) << 3);\n    }\n\n    return -1;\n}",
                        2
                    ],
                    [
                        "src/common/get.c",
                        "get_l2len_protocol",
                        "get_l2len_protocol",
                        "int get_l2len_protocol(const u_char *pktdata, /* <=== get_l2len_protocol */ \n                       const uint32_t datalen,\n                       const int datalink,\n                       uint16_t *protocol,\n                       uint32_t *l2len,\n                       uint32_t *l2offset,\n                       uint32_t *vlan_offset)\n{\n    assert(protocol);\n    assert(l2len);\n    assert(l2offset);\n    assert(vlan_offset);\n\n    if (!pktdata || !datalen) {\n        errx(-1, \"get_l2len_protocol: invalid L2 parameters: pktdata=0x%p len=%d\",\n             pktdata,\n             datalen);\n        return -1;\n    }\n\n    *protocol = 0;\n    *l2len = 0;\n    *l2offset = 0;\n    *vlan_offset = 0;\n\n    switch (datalink) {\n    case DLT_RAW:\n        if (datalen == 0)\n            return -1;\n\n        if ((pktdata[0] >> 4) == 4)\n            *protocol = ETHERTYPE_IP;\n        else if ((pktdata[0] >> 4) == 6)\n            *protocol = ETHERTYPE_IP6;\n        break;\n    case DLT_JUNIPER_ETHER:\n        if (datalen < 4)\n            return -1;\n\n        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {\n            warnx(\"No Magic Number found during protocol lookup: %s (0x%x)\",\n                  pcap_datalink_val_to_description(datalink),\n                  datalink);\n            return -1;\n        }\n\n        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {\n            if (datalen < 6)\n                return -1;\n\n            *l2offset = ntohs(*((uint16_t*)&pktdata[4]));\n            *l2offset += 6; /* MGC + flags + ext_total_len */\n        } else {\n            *l2offset = 4; /* MGC + flags (no header extensions) */\n        }\n\n        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {\n            /* no L2 header present - *l2offset is actually IP offset */\n            uint32_t ip_hdr_offset = *l2offset;\n            if (datalen < ip_hdr_offset + 1)\n                return -1;\n\n            if ((pktdata[ip_hdr_offset] >> 4) == 4)\n                *protocol = ETHERTYPE_IP;\n            else if ((pktdata[ip_hdr_offset] >> 4) == 6)\n                *protocol = ETHERTYPE_IP6;\n\n            return 0;\n        }\n\n        /* fall through */\n    case DLT_EN10MB:\n    {\n        eth_hdr_t *eth_hdr = (eth_hdr_t*)(pktdata + *l2offset);\n        uint32_t l2_net_off = sizeof(*eth_hdr) + *l2offset;\n        uint16_t ether_type = ntohs(eth_hdr->ether_type);\n\n        if (datalen <= l2_net_off)\n            return -1;\n\n        if (parse_metadata(pktdata,\n                           datalen,\n                           &ether_type,\n                           &l2_net_off,\n                           l2offset,\n                           vlan_offset))\n            return -1;\n\n        if (datalen < l2_net_off)\n            return -1;\n\n        *l2len = l2_net_off;\n        if (ether_type > 1500) {\n            /* Ethernet II frame - return in host order */\n            *protocol = ether_type;\n        } else {\n            /* 803.3 frame */\n            if ((pktdata[l2_net_off] >> 4) == 4)\n                *protocol = ETHERTYPE_IP;\n            else if ((pktdata[l2_net_off] >> 4) == 6)\n                *protocol = ETHERTYPE_IP6;\n            else\n                /* unsupported 802.3 protocol */\n                return -1;\n        }\n        break;\n    }\n    case DLT_PPP_SERIAL:\n        if ((size_t)datalen < sizeof(struct tcpr_pppserial_hdr))\n            return -1;\n\n        struct tcpr_pppserial_hdr *ppp = (struct tcpr_pppserial_hdr*)pktdata;\n        *l2len = sizeof(*ppp);\n        if (ntohs(ppp->protocol) == 0x0021)\n            *protocol = ETHERTYPE_IP;\n        else\n            *protocol = ntohs(ppp->protocol);\n\n        break;\n    case DLT_C_HDLC:\n        if (datalen < CISCO_HDLC_LEN)\n            return -1;\n\n        hdlc_hdr_t *hdlc_hdr = (hdlc_hdr_t*)pktdata;\n        *l2len = sizeof(*hdlc_hdr);\n        *protocol = ntohs(hdlc_hdr->protocol);\n        break;\n    case DLT_LINUX_SLL:\n        if (datalen < SLL_HDR_LEN)\n            return -1;\n\n        sll_hdr_t *sll_hdr = (sll_hdr_t*)pktdata;\n        *l2len = sizeof(*sll_hdr);\n        *protocol = ntohs(sll_hdr->sll_protocol);\n        break;\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\",\n             pcap_datalink_val_to_description(datalink),\n             datalink);\n    }\n\n    return 0;\n}",
                        3
                    ],
                    [
                        "src/common/cidr.c",
                        "ip6_addr_is_unspec",
                        "ip6_addr_is_unspec",
                        "static int /* <=== ip6_addr_is_unspec */ \nip6_addr_is_unspec(const struct tcpr_in6_addr *addr)\n{\n    return addr->tcpr_s6_addr32[0] == 0 && addr->tcpr_s6_addr32[1] == 0 &&\n      addr->tcpr_s6_addr32[2] == 0 && addr->tcpr_s6_addr32[3] == 0;\n}",
                        3
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "fix_ipv4_checksums",
                        "fix_ipv4_checksums",
                        "int /* <=== fix_ipv4_checksums */ \nfix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr)\n{\n    int ret1 = 0, ret2 = 0, ip_len;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip_hdr);\n\n    if (pkthdr->caplen < sizeof(*ip_hdr)) {\n        tcpedit_setwarn(tcpedit, \"caplen too small to read IPv4 header: %u\",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    if (ip_hdr->ip_v != 4) {\n        tcpedit_seterr(tcpedit, \"Invalid packet: Expected IPv4 packet: got %u\", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len &&\n            (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {\n        ip_len = (int)ntohs(ip_hdr->ip_len);\n        ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p,\n                ip_len - (ip_hdr->ip_hl << 2));\n        if (ret1 < 0)\n            return TCPEDIT_ERROR;\n    }\n    \n    /* calc IP checksum */\n    ip_len = (int)ntohs(ip_hdr->ip_len);\n    ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);\n    if (ret2 < 0)\n        return TCPEDIT_ERROR;\n\n    /* what do we return? */\n    if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n    \n    return TCPEDIT_OK;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "rewrite_ipv6_hlim",
                        "rewrite_ipv6_hlim",
                        "int /* <=== rewrite_ipv6_hlim */ \nrewrite_ipv6_hlim(tcpedit_t *tcpedit, ipv6_hdr_t *ip6_hdr)\n{\n    assert(tcpedit);\n\n    /* make sure there's something to edit */\n    if (ip6_hdr == NULL || tcpedit->ttl_mode == TCPEDIT_TTL_MODE_OFF)\n        return(0);\n\n    switch(tcpedit->ttl_mode) {\n    case TCPEDIT_TTL_MODE_SET:\n        if (ip6_hdr->ip_hl == tcpedit->ttl_value)\n            return(0);           /* no change required */\n        ip6_hdr->ip_hl = tcpedit->ttl_value;\n        break;\n    case TCPEDIT_TTL_MODE_ADD:\n        if (((int)ip6_hdr->ip_hl + tcpedit->ttl_value) > 255) {\n            ip6_hdr->ip_hl = 255;\n        } else {\n            ip6_hdr->ip_hl += tcpedit->ttl_value;\n        }\n        break;\n    case TCPEDIT_TTL_MODE_SUB:\n        if (ip6_hdr->ip_hl <= tcpedit->ttl_value) {\n            ip6_hdr->ip_hl = 1;\n        } else {\n            ip6_hdr->ip_hl -= tcpedit->ttl_value;\n        }\n        break;\n    default:\n        errx(1, \"invalid ttl_mode: %d\", tcpedit->ttl_mode);\n    }\n    return 0;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "is_unicast_ipv4",
                        "is_unicast_ipv4",
                        "static int /* <=== is_unicast_ipv4 */ \nis_unicast_ipv4(tcpedit_t *tcpedit, uint32_t ip)\n{\n    assert(tcpedit);\n   \n    /* multicast/broadcast is 224.0.0.0 to 239.255.255.255 */\n    if ((ntohl(ip) & 0xf0000000) == 0xe0000000)\n        return 0;\n        \n    return 1;\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_IPV6_H",
                        "src/tcpedit/tcpr.h:100:100:TCPR_IPV6_H:0",
                        "",
                        3
                    ],
                    [
                        "src/common/cidr.c",
                        "ip6_in_cidr",
                        "ip6_in_cidr",
                        "int /* <=== ip6_in_cidr */ \nip6_in_cidr(const tcpr_cidr_t * mycidr, const struct tcpr_in6_addr *addr)\n{\n    int ret = 0;\n#ifdef DEBUG\n    char netstr[INET6_ADDRSTRLEN];\n#endif\n    uint32_t i, j, k;\n\n    if (mycidr->family != AF_INET6)\n        return 0;\n\n    /* always return 1 if ::/0 */\n    if (mycidr->masklen == 0 && ip6_addr_is_unspec(addr))\n        return 1;\n\n    j = mycidr->masklen / 8;\n\n    for (i = 0; i < j; i++) {\n        if (addr->tcpr_s6_addr[i] != mycidr->u.network6.tcpr_s6_addr[i]) {\n            ret = 0;\n            goto out;\n        }\n    }\n    \n    if ((k = mycidr->masklen % 8) == 0) {\n        ret = 1;\n        goto out;\n    }\n\n    k = (uint32_t)~0 << (8 - k);\n    i = addr->tcpr_s6_addr[j] & k;\n    j = mycidr->u.network6.tcpr_s6_addr[j] & k;\n    ret = i == j;\nout:\n\n#ifdef DEBUG\n    /* copy this for debug purposes, since it's not re-entrant */\n    strlcpy(netstr, get_addr2name6(&mycidr->u.network6, RESOLVE), INET6_ADDRSTRLEN);\n#endif\n\n    /* if they're the same, then ip is in network */\n    if (ret) {\n#ifdef DEBUG\n        dbgx(1, \"The ip %s is inside of %s/%d\",\n            get_addr2name6(addr, RESOLVE), netstr, mycidr->masklen);\n#endif\n    } else {\n#ifdef DEBUG\n        dbgx(1, \"The ip %s is not inside of %s/%d\",\n            get_addr2name6(addr, RESOLVE), netstr, mycidr->masklen);\n#endif\n    }\n    return ret;\n\n}",
                        2
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "untrunc_packet",
                        "untrunc_packet",
                        "int /* <=== untrunc_packet */ \nuntrunc_packet(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, \n        u_char **pktdata, ipv4_hdr_t *ip_hdr, ipv6_hdr_t *ip6_hdr)\n{\n    int l2len;\n    int chksum = 1;\n    u_char *packet;\n    udp_hdr_t *udp_hdr;\n    u_char *dataptr = NULL;\n\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(pktdata);\n\n    packet = *pktdata;\n    assert(packet);\n\n    /* if actual len == cap len or there's no IP header, don't do anything */\n    if ((pkthdr->caplen == pkthdr->len) || (ip_hdr == NULL && ip6_hdr == NULL)) {\n        /* unless we're in MTU truncate mode */\n        if (! tcpedit->mtu_truncate)\n            return(0);\n    }\n    \n    if ((l2len = layer2len(tcpedit, packet, pkthdr->caplen)) < 0) {\n        tcpedit_seterr(tcpedit, \"Non-sensical layer 2 length: %d\", l2len);\n        return -1;\n    }\n\n    /*\n     * cannot checksum fragments, but we can do some\n     * work on UDP fragments. Setting checksum to 0\n     * means checksum will be ignored.\n     */\n    if (ip_hdr) {\n        if ((htons(ip_hdr->ip_off) & IP_OFFMASK) != 0) {\n            chksum = 0;\n        } else if (ip_hdr->ip_p == IPPROTO_UDP &&\n                (htons(ip_hdr->ip_off) & IP_MF) != 0) {\n            dataptr = (u_char*)ip_hdr;\n            dataptr += ip_hdr->ip_hl << 2;\n            udp_hdr = (udp_hdr_t*)dataptr;\n            udp_hdr->uh_sum = 0;\n            chksum = 0;\n        }\n    }\n\n    /* Pad packet or truncate it */\n    if (tcpedit->fixlen == TCPEDIT_FIXLEN_PAD) {\n        /*\n         * this should be an unnecessary check\n           * but I've gotten a report that sometimes the caplen > len\n           * which seems like a corrupted pcap\n           */\n        if (pkthdr->len > pkthdr->caplen) {\n            packet = safe_realloc(packet, pkthdr->len + PACKET_HEADROOM);\n            memset(packet + pkthdr->caplen, '\\0', pkthdr->len - pkthdr->caplen);\n            pkthdr->caplen = pkthdr->len;\n        } else if (pkthdr->len < pkthdr->caplen) {\n            /* i guess this is necessary if we've got a bogus pcap */\n            //ip_hdr->ip_len = htons(pkthdr->caplen - l2len);\n            tcpedit_seterr(tcpedit, \"%s\", \"WTF?  Why is your packet larger then the capture len?\");\n            chksum = -1;\n            goto done;\n        }\n    }\n    else if (tcpedit->fixlen == TCPEDIT_FIXLEN_TRUNC) {\n        if (ip_hdr && pkthdr->len != pkthdr->caplen)\n            ip_hdr->ip_len = htons(pkthdr->caplen - l2len);\n        pkthdr->len = pkthdr->caplen;\n    }\n    else if (tcpedit->mtu_truncate) {\n        if (pkthdr->len > (uint32_t)(tcpedit->mtu + l2len)) {\n            /* first truncate the packet */\n            pkthdr->len = pkthdr->caplen = l2len + tcpedit->mtu;\n            \n            /* if ip_hdr exists, update the length */\n            if (ip_hdr != NULL) {\n                ip_hdr->ip_len = htons(tcpedit->mtu);\n            } else if (ip6_hdr != NULL) {\n                ip6_hdr->ip_len = htons(tcpedit->mtu - sizeof(*ip6_hdr));\n            } else {\n                 /* for non-IP frames, don't try to fix checksums */  \n                chksum = 0;\n                goto done;\n            }\n        }\n    }\n    else {\n        tcpedit_seterr(tcpedit, \"Invalid fixlen value: 0x%x\", tcpedit->fixlen);\n        chksum = -1;\n        goto done;\n    }\n\ndone:\n    *pktdata = packet;\n    return chksum;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/portmap.c",
                        "rewrite_ports",
                        "rewrite_ports",
                        "static int /* <=== rewrite_ports */ \nrewrite_ports(tcpedit_t *tcpedit, u_char protocol, u_char *layer4,\n        const int l4len)\n{\n    tcp_hdr_t *tcp_hdr = NULL;\n    udp_hdr_t *udp_hdr = NULL;\n    volatile uint16_t newport;\n    tcpedit_portmap_t *portmap;\n\n    assert(tcpedit);\n    assert(tcpedit->portmap);\n    portmap = tcpedit->portmap;\n\n    if (protocol == IPPROTO_TCP) {\n        if (l4len < (int)sizeof(tcp_hdr_t)) {\n            tcpedit_setwarn(tcpedit, \"caplen to small to set TCP port: l4 len=%d\",\n                    l4len);\n            return TCPEDIT_WARN;\n        }\n\n        tcp_hdr = (tcp_hdr_t *)layer4;\n\n        /* check if we need to remap the destination port */\n        newport = map_port(portmap, tcp_hdr->th_dport);\n        if (newport != tcp_hdr->th_dport) {\n            csum_replace2(&tcp_hdr->th_sum, tcp_hdr->th_dport, newport);\n            tcp_hdr->th_dport = newport;\n        }\n\n        /* check if we need to remap the source port */\n        newport = map_port(portmap, tcp_hdr->th_sport);\n        if (newport != tcp_hdr->th_sport) {\n            csum_replace2(&tcp_hdr->th_sum, tcp_hdr->th_sport, newport);\n            tcp_hdr->th_sport = newport;\n        }\n    } else if (protocol == IPPROTO_UDP) {\n        if (l4len < (int)sizeof(udp_hdr_t)) {\n            tcpedit_setwarn(tcpedit, \"caplen to small to set UDP port: l4 len=%d\",\n                    l4len);\n            return TCPEDIT_WARN;\n        }\n\n        udp_hdr = (udp_hdr_t *)layer4;\n\n        /* check if we need to remap the destination port */\n        newport = map_port(portmap, udp_hdr->uh_dport);\n        if (newport != udp_hdr->uh_dport) {\n            if (udp_hdr->uh_sum) {\n                csum_replace2(&udp_hdr->uh_sum, udp_hdr->uh_dport, newport);\n            }\n\n            udp_hdr->uh_dport = newport;\n        }\n\n        /* check if we need to remap the source port */\n        newport = map_port(portmap, udp_hdr->uh_sport);\n        if (newport != udp_hdr->uh_sport) {\n            if (udp_hdr->uh_sum) {\n                csum_replace2(&udp_hdr->uh_sum, udp_hdr->uh_sport, newport);\n            }\n\n            udp_hdr->uh_sport = newport;\n        }\n    }\n\n    return 0;\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.addressOf",
                        "<operator>.addressOf",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/common/err.h",
                        "warn",
                        "src/tcpedit/common/err.h:112:112:warn:1",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "remap_ipv4",
                        "remap_ipv4",
                        "static uint32_t /* <=== remap_ipv4 */ \nremap_ipv4(tcpedit_t *tcpedit, tcpr_cidr_t *cidr, const uint32_t original)\n{\n    uint32_t ipaddr = 0, network = 0, mask = 0, result = 0;\n\n    assert(tcpedit);\n    assert(cidr);\n    \n    if (cidr->family != AF_INET) {\n        return 0;\n    }\n\n    /* don't rewrite broadcast addresses */\n    if (tcpedit->skip_broadcast && !is_unicast_ipv4(tcpedit, original))\n        return original;\n\n    mask = 0xffffffff; /* turn on all the bits */\n\n    /* shift over by correct # of bits */\n    mask = mask << (32 - cidr->masklen);\n\n    /* apply the mask to the network */\n    network = htonl(cidr->u.network) & mask;\n\n    /* apply the reverse of the mask to the IP */\n    mask = mask ^ 0xffffffff;\n    ipaddr = ntohl(original) & mask;\n\n    /* merge the network portion and ip portions */\n    result = network ^ ipaddr;\n    \n    /* return the result in network byte order */\n    return(htonl(result));\n}",
                        2
                    ],
                    [
                        "src/tcpedit/incremental_checksum.h",
                        "csum_replace2",
                        "csum_replace2",
                        "static inline void csum_replace2(__sum16 *sum, __be16 from, __be16 to) /* <=== csum_replace2 */ \n{\n    *sum = ~csum16_add(csum16_sub(~(*sum), from), to);\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "ARPOP_REPLY",
                        "src/tcpedit/tcpr.h:241:241:ARPOP_REPLY:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_TCP_H",
                        "src/tcpedit/tcpr.h:136:136:TCPR_TCP_H:0",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/fuzzing.c",
                        "fuzz_get_sgt_size",
                        "fuzz_get_sgt_size",
                        "static inline int /* <=== fuzz_get_sgt_size */ \nfuzz_get_sgt_size(uint32_t r, uint32_t caplen)\n{\n    if (0 == caplen)\n        return 0;\n\n    if (caplen <= SGT_MAX_SIZE)\n        /* packet too small, fuzzing only one byte */\n        return 1;\n\n    /* return random value between 1 and SGT_MAX_SIZE */\n    return (1 + (r % (SGT_MAX_SIZE - 1)));\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.assignmentPlus",
                        "<operator>.assignmentPlus",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalOr",
                        "<operator>.logicalOr",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.shiftLeft",
                        "<operator>.shiftLeft",
                        "",
                        1
                    ],
                    [
                        "src/common/common/err.h",
                        "dbg",
                        "src/common/common/err.h:109:109:dbg:2",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/fuzzing.c",
                        "fuzzing",
                        "fuzzing",
                        "int /* <=== fuzzing */ \nfuzzing(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n        u_char **pktdata)\n{\n    int packet_changed = 0;\n    uint32_t r, s;\n    uint16_t l2proto;\n    uint8_t l4proto;\n    u_char *packet, *l3data, *l4data;\n    tcpeditdlt_plugin_t *plugin;\n    int l2len, l4len;\n    tcpeditdlt_t *ctx;\n\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(*pktdata);\n\n    if (!fuzz_running)\n        goto done;\n\n    assert(fuzz_factor);\n\n    /*\n     * Determine if this is one of the packets that is going to be altered.\n     * No fuzzing for the other 7 out of 8 packets\n     */\n    r = tcpr_random(&fuzz_seed);\n    if ((r % fuzz_factor) != 0)\n        goto done;\n\n    /* initializations */\n    ctx = tcpedit->dlt_ctx;\n    packet = *pktdata;\n    plugin = tcpedit->dlt_ctx->encoder;\n    l2len = plugin->plugin_l2len(ctx, packet, pkthdr->caplen);\n    l2proto = ntohs(plugin->plugin_proto(ctx, packet, pkthdr->caplen));\n    if (l2len == -1 || (int)pkthdr->caplen < l2len)\n        goto done;\n\n    /*\n     * Get a pointer to the network layer\n     *\n     * Note that this pointer may be in a working buffer and not on directly\n     * to '*pktdata'. All alterations are done in this buffer, which later\n     * will be copied back to '*pktdata', if necessary\n     */\n    l3data = plugin->plugin_get_layer3(ctx, packet, pkthdr->caplen);\n    if (!l3data)\n        goto done;\n\n    l4len = pkthdr->caplen - l2len;\n    switch (l2proto) {\n    case (ETHERTYPE_IP):\n    {\n        l4data = get_layer4_v4((ipv4_hdr_t*)l3data, pkthdr->caplen - l2len);\n        if (!l4data)\n            goto done;\n\n        l4proto = ((ipv4_hdr_t *)l3data)->ip_p;\n        break;\n    }\n    case (ETHERTYPE_IP6): {\n        l4data = get_layer4_v6((ipv6_hdr_t*)l3data, pkthdr->caplen - l2len);\n        if (!l4data)\n            goto done;\n\n        l4proto = ((ipv6_hdr_t *)l3data)->ip_nh;\n        break;\n    }\n    default:\n        /* apply fuzzing on unknown packet types */\n       l4data = l3data;\n       l4proto = IPPROTO_RAW;\n\n    }\n\n    /* adjust payload length based on layer 3 protocol */\n    switch (l4proto) {\n    case IPPROTO_TCP:\n        l4len -= sizeof(tcp_hdr_t);\n        break;\n    case IPPROTO_UDP:\n        l4len -= sizeof(udp_hdr_t);\n        break;\n    }\n\n    if (l4len <= 1)\n        goto done;\n\n    /* add some additional randomization */\n    r ^= r >> 16;\n\n    s = r % FUZZING_TOTAL_ACTION_NUMBER;\n\n    dbgx(3, \"packet fuzzed : %d\", s);\n    switch (s) {\n    case FUZZING_DROP_PACKET:\n    {\n        /* simulate dropping the packet */\n        if (fuzz_reduce_packet_size(tcpedit, pkthdr, 0) < 0)\n            /* could not change packet size, so packet left unchanged */\n            goto done;\n\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_REDUCE_SIZE:\n    {\n        /* reduce packet size */\n        uint32_t new_len = (r % ((l4len) - 1)) + 1;\n        if (fuzz_reduce_packet_size(tcpedit, pkthdr, new_len) < 0)\n            /* could not change packet size, so packet left unchanged */\n            goto done;\n\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_CHANGE_START_ZERO:\n    {\n        /* fuzz random-size segment at the beginning of the packet with 0x00 */\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len);\n        memset(l4data, 0x00, sgt_size);\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_CHANGE_START_RANDOM:\n    {\n        /*\n         * fuzz random-size segment at the beginning of the packet payload\n         * with random bytes\n         */\n        size_t i;\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len);\n        if (!sgt_size)\n            goto done;\n\n        for (i = 0; i < sgt_size; i++)\n            l4data[i] = l4data[i] ^ (u_char)(r >> 4);\n\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_CHANGE_START_FF:\n    {\n        /*\n         * fuzz random-size segment at the beginning of the packet\n         * payload with 0xff\n         */\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len);\n        if (!sgt_size)\n            goto done;\n\n        memset(l4data, 0xff, sgt_size);\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_CHANGE_MID_ZERO:\n    {\n        /* fuzz random-size segment inside the packet payload with 0x00 */\n        uint32_t offset = ((r >> 16) % (l4len - 1)) + 1;\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len - offset);\n        if (!sgt_size)\n            goto done;\n\n        memset(l4data + offset, 0x00, sgt_size);\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_CHANGE_MID_FF:\n    {\n        /* fuzz random-size segment inside the packet payload with 0xff */\n        uint32_t offset = ((r >> 16) % (l4len - 1)) + 1;\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len - offset);\n        if (!sgt_size)\n            goto done;\n\n        memset(l4data + offset, 0xff, sgt_size);\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_CHANGE_END_ZERO:\n    {\n        /* fuzz random-sized segment at the end of the packet payload with 0x00 */\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len);\n        if (!sgt_size)\n            goto done;\n\n        memset(l4data + l4len - sgt_size, 0x00, sgt_size);\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_CHANGE_END_RANDOM:\n    {\n        /* fuzz random-sized segment at the end of the packet with random Bytes */\n        int i;\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len);\n        if (!sgt_size)\n            goto done;\n\n        for (i = (l4len - sgt_size); i < l4len; i++)\n            l4data[i] = l4data[i] ^ (u_char)(r >> 4);\n\n        packet_changed = 1;\n        break;\n    }\n    case FUZZING_CHANGE_END_FF:\n    {\n        /* fuzz random-sized segment at the end of the packet with 0xff00 */\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len);\n        if (!sgt_size)\n            goto done;\n\n        memset(l4data + l4len - sgt_size, 0xff, sgt_size);\n        packet_changed = 1;\n        break;\n    }\n\n    case FUZZING_CHANGE_MID_RANDOM:\n    {\n        /* fuzz random-size segment inside the packet with random Bytes */\n        size_t i;\n        uint32_t offset = ((r >> 16) % (l4len - 1)) + 1;\n        uint32_t sgt_size = fuzz_get_sgt_size(r, l4len - offset);\n        if (!sgt_size)\n            goto done;\n\n        for (i = offset; i < offset + sgt_size; i++)\n            l4data[i] = l4data[i] ^ (u_char)(r >> 4);\n\n        packet_changed = 1;\n        break;\n    }\n    default:\n        assert(false);\n    }\n\n    /* in cases where 'l3data' is a working buffer, copy it back to '*pkthdr' */\n    plugin->plugin_merge_layer3(ctx,\n                                packet,\n                                pkthdr->caplen,\n                                (l2proto == ETHERTYPE_IP) ? l4data : NULL,\n                                (l2proto == ETHERTYPE_IP6) ? l4data : NULL);\n\ndone:\n    return packet_changed;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "rewrite_iparp",
                        "rewrite_iparp",
                        "int /* <=== rewrite_iparp */ \nrewrite_iparp(tcpedit_t *tcpedit, arp_hdr_t *arp_hdr, int cache_mode)\n{\n    u_char *add_hdr = NULL;\n    uint32_t *ip1 = NULL, *ip2 = NULL;\n    uint32_t newip = 0;\n    tcpr_cidrmap_t *cidrmap1 = NULL, *cidrmap2 = NULL;\n    int didsrc = 0, diddst = 0, loop = 1;\n#ifdef FORCE_ALIGN\n    uint32_t iptemp;\n#endif\n\n    assert(tcpedit);\n    assert(arp_hdr);\n\n   /* figure out what mapping to use */\n    if (cache_mode == TCPR_DIR_C2S) {\n        cidrmap1 = tcpedit->cidrmap1;\n        cidrmap2 = tcpedit->cidrmap2;\n    } else if (cache_mode == TCPR_DIR_S2C) {\n        cidrmap1 = tcpedit->cidrmap2;\n        cidrmap2 = tcpedit->cidrmap1;\n    }\n\n    /* anything to rewrite? */\n    if (cidrmap1 == NULL || cidrmap2 == NULL)\n        return(0);\n\n    /*\n     * must be IPv4 and request or reply \n     * Do other op codes use the same subheader stub?\n     * If so we won't need to check the op code.\n     */\n    if ((ntohs(arp_hdr->ar_pro) == ETHERTYPE_IP) &&\n        ((ntohs(arp_hdr->ar_op) == ARPOP_REQUEST) ||\n         (ntohs(arp_hdr->ar_op) == ARPOP_REPLY)))\n        {\n        /* jump to the addresses */\n        add_hdr = (u_char *)arp_hdr;\n        add_hdr += sizeof(arp_hdr_t) + arp_hdr->ar_hln;\n        ip1 = (uint32_t *)add_hdr;\n        add_hdr += arp_hdr->ar_pln + arp_hdr->ar_hln;\n#ifdef FORCE_ALIGN\n        /* copy IP2 to a temporary buffer for processing */\n        memcpy(&iptemp, add_hdr, sizeof(uint32_t));\n        ip2 = &iptemp;\n#else\n        ip2 = (uint32_t *)add_hdr;\n#endif\n        \n\n        /* loop through the cidrmap to rewrite */\n        do {\n            /* arp request ? */\n            if (ntohs(arp_hdr->ar_op) == ARPOP_REQUEST) {\n                if ((!diddst) && ip_in_cidr(cidrmap2->from, *ip1)) {\n                    newip = remap_ipv4(tcpedit, cidrmap2->to, *ip1);\n                    memcpy(ip1, &newip, 4);\n                    diddst = 1;\n                }\n                if ((!didsrc) && ip_in_cidr(cidrmap1->from, *ip2)) {\n                    newip = remap_ipv4(tcpedit, cidrmap1->to, *ip2);\n                    memcpy(ip2, &newip, 4);\n                    didsrc = 1;\n                }\n            } \n            /* else it's an arp reply */\n            else {\n                if ((!diddst) && ip_in_cidr(cidrmap2->from, *ip2)) {\n                    newip = remap_ipv4(tcpedit, cidrmap2->to, *ip2);\n                    memcpy(ip2, &newip, 4);\n                    diddst = 1;\n                }\n                if ((!didsrc) && ip_in_cidr(cidrmap1->from, *ip1)) {\n                    newip = remap_ipv4(tcpedit, cidrmap1->to, *ip1);\n                    memcpy(ip1, &newip, 4);\n                    didsrc = 1;\n                }\n            }\n\n#ifdef FORCE_ALIGN\n            /* copy temporary IP to IP2 location in buffer */\n            memcpy(add_hdr, &iptemp, sizeof(uint32_t));\n#endif\n\n            /*\n             * loop while we haven't modified both src/dst AND\n             * at least one of the cidr maps have a next pointer\n             */\n            if ((! (diddst && didsrc)) &&\n                (! ((cidrmap1->next == NULL) && (cidrmap2->next == NULL)))) {\n                \n                /* increment our ptr's if possible */\n                if (cidrmap1->next != NULL)\n                    cidrmap1 = cidrmap1->next;\n                \n                if (cidrmap2->next != NULL)\n                    cidrmap2 = cidrmap2->next;\n                \n            } else {\n                loop = 0;\n            }\n\n        } while (loop);\n        \n    } else {\n        warn(\"ARP packet isn't for IPv4!  Can't rewrite IP's\");\n    }\n\n    return(didsrc + diddst);\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.assignment",
                        "<operator>.assignment",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_process",
                        "tcpedit_dlt_process",
                        "int /* <=== tcpedit_dlt_process */ \ntcpedit_dlt_process(tcpeditdlt_t *ctx, u_char **packet, int pktlen, tcpr_dir_t direction)\n{\n    int rcode;\n    \n    assert(ctx);\n    assert(packet);\n    assert(direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C || direction == TCPR_DIR_NOSEND);\n    \n    /* nothing to do here */\n    if (direction == TCPR_DIR_NOSEND)\n        return pktlen;\n    \n    /* decode packet */    \n    if ((rcode = tcpedit_dlt_decode(ctx, *packet, pktlen)) == TCPEDIT_ERROR) {\n        return TCPEDIT_ERROR;\n    } else if (rcode == TCPEDIT_WARN) {\n        warnx(\"Warning decoding packet: %s\", tcpedit_getwarn(ctx->tcpedit));\n    } else if (rcode == TCPEDIT_SOFT_ERROR) {\n        return rcode; /* can't edit the packet */\n    }\n    \n    /* encode packet */\n    if ((rcode = tcpedit_dlt_encode(ctx, *packet, pktlen, direction)) == TCPEDIT_ERROR) {\n        return TCPEDIT_ERROR;\n    } else if (rcode == TCPEDIT_WARN) {\n        warnx(\"Warning encoding packet: %s\", tcpedit_getwarn(ctx->tcpedit));\n    }\n       \n    return rcode;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.indirection",
                        "<operator>.indirection",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_UDP_H",
                        "src/tcpedit/tcpr.h:137:137:TCPR_UDP_H:0",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "ipv4_addr_csum_replace",
                        "ipv4_addr_csum_replace",
                        "static void ipv4_addr_csum_replace(ipv4_hdr_t *ip_hdr, uint32_t old_ip, /* <=== ipv4_addr_csum_replace */ \n        uint32_t new_ip, const int l3len)\n{\n    uint8_t *l4, protocol;\n    int len = l3len;\n\n    assert(ip_hdr);\n\n    if ((size_t)len < sizeof(*ip_hdr))\n        return;\n\n    ipv4_l34_csum_replace((uint8_t*)ip_hdr, IPPROTO_IP, old_ip, new_ip);\n\n    protocol = ip_hdr->ip_p;\n    switch (protocol) {\n    case IPPROTO_UDP:\n        l4 = get_layer4_v4(ip_hdr, len);\n        len -= ip_hdr->ip_hl << 2;\n        len -= TCPR_UDP_H;\n        break;\n\n    case IPPROTO_TCP:\n        l4 = get_layer4_v4(ip_hdr, len);\n        len -= ip_hdr->ip_hl << 2;\n        len -= TCPR_TCP_H;\n        break;\n\n    default:\n        l4 = NULL;\n    }\n\n    if (!l4 || len < 0)\n        return;\n\n    /* if this is a fragment, don't attempt to checksum the Layer4 header */\n    if ((htons(ip_hdr->ip_off) & IP_OFFMASK) == 0)\n        ipv4_l34_csum_replace(l4, protocol, old_ip, new_ip);\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "ARPOP_REQUEST",
                        "src/tcpedit/tcpr.h:240:240:ARPOP_REQUEST:0",
                        "",
                        2
                    ],
                    [
                        "src/common/get.c",
                        "get_layer4_v4",
                        "get_layer4_v4",
                        "void * /* <=== get_layer4_v4 */ \nget_layer4_v4(const ipv4_hdr_t *ip_hdr, const int l3len)\n{\n    void *ptr;\n\n    assert(ip_hdr);\n\n    ptr = (u_char *)ip_hdr + (ip_hdr->ip_hl << 2);\n    /* make sure we don't jump over the end of the buffer */\n    if ((u_char *)ptr > ((u_char *)ip_hdr + l3len))\n        return NULL;\n\n    return ((void *)ptr);\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.subtraction",
                        "<operator>.subtraction",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "ipv6_l34_csum_replace",
                        "ipv6_l34_csum_replace",
                        "static void ipv6_l34_csum_replace(uint8_t *data, uint8_t protocol, /* <=== ipv6_l34_csum_replace */ \n        uint32_t *old, uint32_t *new)\n{\n    tcp_hdr_t *tcp_hdr;\n    udp_hdr_t *udp_hdr;\n    icmpv4_hdr_t *icmp;\n    icmpv6_hdr_t *icmp6;\n\n    assert(data);\n\n    switch (protocol) {\n\n    case IPPROTO_TCP:\n        tcp_hdr = (tcp_hdr_t *)data;\n        csum_replace16(&tcp_hdr->th_sum, old, new);\n        break;\n\n    case IPPROTO_UDP:\n        udp_hdr = (udp_hdr_t *)data;\n        if (udp_hdr->uh_sum)\n            csum_replace16(&udp_hdr->uh_sum, old, new);\n        break;\n\n    case IPPROTO_ICMP:\n        icmp = (icmpv4_hdr_t *)data;\n        csum_replace16(&icmp->icmp_sum, old, new);\n        break;\n\n    case IPPROTO_ICMP6:\n        icmp6 = (icmpv6_hdr_t *)data;\n        csum_replace16(&icmp6->icmp_sum, old, new);\n        break;\n\n    default:\n        assert(false);\n    }\n\n}",
                        3
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "fix_ipv6_checksums",
                        "fix_ipv6_checksums",
                        "int /* <=== fix_ipv6_checksums */ \nfix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv6_hdr_t *ip6_hdr)\n{\n    int ret = 0;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip6_hdr);\n\n    if (pkthdr->caplen < sizeof(*ip6_hdr)) {\n        tcpedit_setwarn(tcpedit, \"caplen too small to read IPv6 header: %u\",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    ipv4_hdr_t *ip_hdr = (ipv4_hdr_t*)ip6_hdr;\n    if (ip_hdr->ip_v != 6) {\n        tcpedit_seterr(tcpedit, \"Invalid packet: Expected IPv6 packet: got %u\", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len) {\n        if (ip6_hdr->ip_len < ipv6_header_length(ip6_hdr, pkthdr->len)) {\n            tcpedit_setwarn(tcpedit, \"Unable to checksum IPv6 packet with invalid length %u\",\n                    ip6_hdr->ip_len);\n            return TCPEDIT_WARN;\n        }\n        ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,\n            htons(ip6_hdr->ip_len));\n        if (ret < 0)\n            return TCPEDIT_ERROR;\n    }\n\n    /* what do we return? */\n    if (ret == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n\n    return TCPEDIT_OK;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.equals",
                        "<operator>.equals",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_IPV6_NH_ROUTING",
                        "src/tcpedit/tcpr.h:837:837:TCPR_IPV6_NH_ROUTING:0",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/tcpedit.h",
                        "tcpedit_seterr",
                        "src/tcpedit/tcpedit.h:73:73:tcpedit_seterr:3",
                        "#define tcpedit_seterr(x, y, ...) __tcpedit_seterr(x, __FUNCTION__, __LINE__, __FILE__, y, __VA_ARGS__) /* <=== src/tcpedit/tcpedit.h:73:73:tcpedit_seterr:3 */ ",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_GRE",
                        "src/tcpedit/tcpr.h:685:685:IPPROTO_GRE:0",
                        "",
                        3
                    ],
                    [
                        "<empty>",
                        "htons",
                        "htons",
                        "",
                        1
                    ],
                    [
                        "src/common/get.c",
                        "get_ipv6_next",
                        "get_ipv6_next",
                        "void * /* <=== get_ipv6_next */ \nget_ipv6_next(struct tcpr_ipv6_ext_hdr_base *exthdr, const int len)\n{\n    int extlen = 0;\n    int maxlen;\n    void *ptr;\n    assert(exthdr);\n\n    maxlen = *((int*)((u_char *)exthdr + len));\n\n    dbgx(3, \"Jumping to next IPv6 header.  Processing 0x%02x\", exthdr->ip_nh);\n    switch (exthdr->ip_nh) {\n    /* no further processing */\n    case TCPR_IPV6_NH_NO_NEXT:\n    case TCPR_IPV6_NH_ESP:\n        dbg(3, \"No-Next or ESP... can't go any further...\");\n        return NULL;\n        break;\n\n    /*\n     * fragment header is fixed size \n     * FIXME: Frag header has further ext headers (has a ip_nh field)\n     * but I don't support it because there's never a full L4 + payload beyond.\n     */\n    case TCPR_IPV6_NH_FRAGMENT:\n        dbg(3, \"Looks like were a fragment header. Returning some frag'd data.\");\n        ptr = (void *)((u_char *)exthdr + sizeof(struct tcpr_ipv6_frag_hdr));\n        if (*(int*)ptr > maxlen)\n            return NULL;\n        return ptr;\n        break;\n\n    /* all the rest require us to go deeper using the ip_len field */\n    case TCPR_IPV6_NH_IPV6:\n    case TCPR_IPV6_NH_ROUTING:\n    case TCPR_IPV6_NH_DESTOPTS:\n    case TCPR_IPV6_NH_HBH:\n    case TCPR_IPV6_NH_AH:\n        extlen = IPV6_EXTLEN_TO_BYTES(exthdr->ip_len);\n        dbgx(3, \"Looks like we're an ext header (0x%hhx).  Jumping %u bytes\"\n               \" to the next\", exthdr->ip_nh, extlen);\n        ptr = (void *)((u_char *)exthdr + extlen);\n        if (*(int*)ptr > maxlen)\n            return NULL;\n        return ptr;\n        break;\n\n    default:\n        dbg(3, \"Must not be a v6 extension header... returning self\");\n        return (void *)exthdr;\n        break;\n    }\n}",
                        2
                    ],
                    [
                        "src/common/utils.c",
                        "tcpr_random",
                        "tcpr_random",
                        "uint32_t tcpr_random(uint32_t *seed) /* <=== tcpr_random */ \n{\n  unsigned int next = *seed;\n  int result;\n\n  next *= 1103515245;\n  next += 12345;\n  result = (unsigned int) (next / 65536) % 2048;\n\n  next *= 1103515245;\n  next += 12345;\n  result <<= 10;\n  result ^= (unsigned int) (next / 65536) % 1024;\n\n  next *= 1103515245;\n  next += 12345;\n  result <<= 10;\n  result ^= (unsigned int) (next / 65536) % 1024;\n\n  *seed = next;\n\n  return result;\n}",
                        2
                    ],
                    [
                        "src/tcpedit/common/utils.h",
                        "safe_realloc",
                        "src/tcpedit/common/utils.h:58:58:safe_realloc:2",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/plugins/dlt_utils.c",
                        "tcpedit_dlt_getplugin",
                        "tcpedit_dlt_getplugin",
                        "tcpeditdlt_plugin_t * /* <=== tcpedit_dlt_getplugin */ \ntcpedit_dlt_getplugin(tcpeditdlt_t *ctx, int dlt)\n{\n    tcpeditdlt_plugin_t *ptr;\n    \n    assert(ctx);\n\n    ptr = ctx->plugins;\n    if (ptr == NULL)\n        return NULL;\n    \n    while (ptr->dlt != dlt && ptr->next != NULL) {\n        ptr = ptr->next;\n    }\n    \n    if (ptr->dlt == dlt)\n        return ptr;\n        \n    return NULL;\n}",
                        2
                    ],
                    [
                        "libopts/compat/snprintf.c",
                        "vsnprintf",
                        "vsnprintf",
                        "static int /* <=== vsnprintf */ \nvsnprintf( char *str, size_t n, char const *fmt, va_list ap )\n{\n#ifdef VSPRINTF_CHARSTAR\n    return (strlen(vsprintf(str, fmt, ap)));\n#else\n    return (vsprintf(str, fmt, ap));\n#endif\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.fieldAccess",
                        "<operator>.fieldAccess",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpedit_types.h",
                        "TCPEDIT_OK",
                        "src/tcpedit/tcpedit_types.h:34:34:TCPEDIT_OK:0",
                        "#define TCPEDIT_OK      0 /* <=== src/tcpedit/tcpedit_types.h:34:34:TCPEDIT_OK:0 */ ",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_dst",
                        "tcpedit_dlt_dst",
                        "int  /* <=== tcpedit_dlt_dst */ \ntcpedit_dlt_dst(tcpeditdlt_t *ctx)\n{\n   assert(ctx);\n   return ctx->encoder->dlt; \n}",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_IPV6_NH_FRAGMENT",
                        "src/tcpedit/tcpr.h:823:823:TCPR_IPV6_NH_FRAGMENT:0",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_l3data",
                        "tcpedit_dlt_l3data",
                        "u_char * /* <=== tcpedit_dlt_l3data */ \ntcpedit_dlt_l3data(tcpeditdlt_t *ctx, int dlt, u_char *packet, const int pktlen)\n{\n    tcpeditdlt_plugin_t *plugin;\n    u_char *res;\n\n    assert(ctx);\n    assert(dlt >= 0);\n    assert(packet);\n        \n    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt)) == NULL) {\n        tcpedit_seterr(ctx->tcpedit, \"Unable to find plugin for DLT 0x%04x\", dlt);\n        return NULL;\n    }\n\n    res = plugin->plugin_get_layer3(ctx, packet, pktlen);\n    if (res == NULL)\n        tcpedit_seterr(ctx->tcpedit, \"Packet length %d is to short to contain a layer 3 header for DLT 0x%04x\",\n                pktlen, dlt);\n\n    return res;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "randomize_iparp",
                        "randomize_iparp",
                        "int  /* <=== randomize_iparp */ \nrandomize_iparp(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, \n        u_char *pktdata, int datalink, const int l3len)\n{\n    arp_hdr_t *arp_hdr ;\n    int l2len;\n#ifdef FORCE_ALIGN\n    uint32_t iptemp;\n#endif\n\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(pktdata);\n\n    if (l3len < (int)sizeof(arp_hdr_t)) {\n        tcpedit_seterr(tcpedit, \"Unable to randomize ARP packet due to packet capture snap length %u\",\n                pkthdr->caplen);\n        return TCPEDIT_ERROR;\n    }\n\n    l2len = get_l2len(pktdata, pkthdr->caplen, datalink);\n\n    arp_hdr = (arp_hdr_t *)(pktdata + l2len);\n\n    /*\n     * only rewrite IP addresses from REPLY/REQUEST's\n     */\n    if ((ntohs(arp_hdr->ar_pro) == ETHERTYPE_IP) &&\n            ((ntohs(arp_hdr->ar_op) == ARPOP_REQUEST) ||\n                    (ntohs(arp_hdr->ar_op) == ARPOP_REPLY))) {\n        /* jump to the addresses */\n        uint32_t *ip;\n        u_char *add_hdr = ((u_char *)arp_hdr) + sizeof(arp_hdr_t) +\n                arp_hdr->ar_hln;\n\n#ifdef FORCE_ALIGN\n        /* copy IP to a temporary buffer for processing */\n        memcpy(&iptemp, add_hdr, sizeof(uint32_t));\n        ip = &iptemp;\n#else\n        ip = (uint32_t *)add_hdr;\n#endif\n        *ip = randomize_ipv4_addr(tcpedit, *ip);\n#ifdef FORCE_ALIGN\n        memcpy(add_hdr, &iptemp, sizeof(uint32_t));\n#endif\n\n        add_hdr += arp_hdr->ar_pln + arp_hdr->ar_hln;\n#ifdef FORCE_ALIGN\n        /* copy IP2 to a temporary buffer for processing */\n        memcpy(&iptemp, add_hdr, sizeof(uint32_t));\n        ip = &iptemp;\n#else\n        ip = (uint32_t *)add_hdr;\n#endif\n        *ip = randomize_ipv4_addr(tcpedit, *ip);\n#ifdef FORCE_ALIGN\n        memcpy(add_hdr, &iptemp, sizeof(uint32_t));\n#endif\n    }\n\n    return 1; /* yes we changed the packet */\n}",
                        1
                    ],
                    [
                        "src/tcpedit/dlt.c",
                        "layer2len",
                        "layer2len",
                        "int /* <=== layer2len */ \nlayer2len(tcpedit_t *tcpedit, u_char *packet, uint32_t caplen)\n{\n    assert(tcpedit);\n    assert(tcpedit->dlt_ctx);\n    assert(tcpedit->dlt_ctx->encoder);\n\n    return tcpedit->dlt_ctx->encoder->plugin_l2len(tcpedit->dlt_ctx,\n                                                   packet,\n                                                   caplen);\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.notEquals",
                        "<operator>.notEquals",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.sizeOf",
                        "<operator>.sizeOf",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_l2len",
                        "tcpedit_dlt_l2len",
                        "int /* <=== tcpedit_dlt_l2len */ \ntcpedit_dlt_l2len(tcpeditdlt_t *ctx, int dlt, const u_char *packet, const int pktlen)\n{\n    tcpeditdlt_plugin_t *plugin;\n    int res;\n\n    assert(ctx);\n    assert(dlt >= 0);\n    assert(packet);\n    \n    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt)) == NULL) {\n        tcpedit_seterr(ctx->tcpedit, \"Unable to find plugin for DLT 0x%04x\", dlt);\n        return -1;        \n    }\n\n    res = plugin->plugin_l2len(ctx, packet, pktlen);\n    if (res == -1) {\n        tcpedit_seterr(ctx->tcpedit, \"Packet length %d is to short to contain a layer 2 header for DLT 0x%04x\",\n                pktlen, dlt);\n        return -1;\n    }\n\n    return res;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "ntohl",
                        "ntohl",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "htonl",
                        "htonl",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/fuzzing.c",
                        "fuzz_reduce_packet_size",
                        "fuzz_reduce_packet_size",
                        "static inline int /* <=== fuzz_reduce_packet_size */ \nfuzz_reduce_packet_size(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n        uint32_t new_len)\n{\n    if (pkthdr->len < pkthdr->caplen) {\n        tcpedit_seterr(tcpedit, \"Packet length %u smaller than capture length %u\",\n                pkthdr->len, pkthdr->caplen);\n        return -1;\n    }\n\n    if (new_len > pkthdr->caplen) {\n        tcpedit_seterr(tcpedit, \"Cannot fuzz packet of capture length %u to length %u\",\n                pkthdr->caplen, new_len);\n        return -1;\n    }\n\n    if (new_len == pkthdr->caplen) {\n        return 0;\n    }\n\n    pkthdr->len = new_len;\n    pkthdr->caplen = pkthdr->len;\n\n    /* do not fix lengths in ip/tcp/udp layers.\n     * fixlen option already does so, and can be called with fuzzing option. */\n\n    return 1;\n}",
                        2
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_decode",
                        "tcpedit_dlt_decode",
                        "int  /* <=== tcpedit_dlt_decode */ \ntcpedit_dlt_decode(tcpeditdlt_t *ctx, const u_char *packet, const int pktlen)\n{\n    return ctx->decoder->plugin_decode(ctx, packet, pktlen);\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalNot",
                        "<operator>.logicalNot",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.cast",
                        "<operator>.cast",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/tcpedit.h",
                        "tcpedit_seterr",
                        "src/tcpedit/plugins/tcpedit.h:73:73:tcpedit_seterr:3",
                        "",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.greaterThan",
                        "<operator>.greaterThan",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/tcpedit_types.h",
                        "TCPEDIT_ERROR",
                        "src/tcpedit/plugins/tcpedit_types.h:33:33:TCPEDIT_ERROR:0",
                        "",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.postIncrement",
                        "<operator>.postIncrement",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.indirectFieldAccess",
                        "<operator>.indirectFieldAccess",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "rewrite_ipv4l3",
                        "rewrite_ipv4l3",
                        "int /* <=== rewrite_ipv4l3 */ \nrewrite_ipv4l3(tcpedit_t *tcpedit, ipv4_hdr_t *ip_hdr, tcpr_dir_t direction,\n        int len)\n{\n    tcpr_cidrmap_t *cidrmap1 = NULL, *cidrmap2 = NULL;\n    int didsrc = 0, diddst = 0, loop = 1;\n    tcpr_cidrmap_t *ipmap;\n\n    assert(tcpedit);\n    assert(ip_hdr);\n\n    /* first check the src/dst IP maps */\n    ipmap = tcpedit->srcipmap;\n    while (ipmap != NULL) {\n        if (ip_in_cidr(ipmap->from, ip_hdr->ip_src.s_addr)) {\n            uint32_t old_ip = ip_hdr->ip_src.s_addr;\n            ip_hdr->ip_src.s_addr = remap_ipv4(tcpedit, ipmap->to, ip_hdr->ip_src.s_addr);\n            ipv4_addr_csum_replace(ip_hdr, old_ip, ip_hdr->ip_src.s_addr, len);\n            dbgx(2, \"Remapped src addr to: %s\", get_addr2name4(ip_hdr->ip_src.s_addr, RESOLVE));\n            break;\n        }\n        ipmap = ipmap->next;\n    }\n\n    ipmap = tcpedit->dstipmap;\n    while (ipmap != NULL) {\n        if (ip_in_cidr(ipmap->from, ip_hdr->ip_dst.s_addr)) {\n            uint32_t old_ip = ip_hdr->ip_dst.s_addr;\n            ip_hdr->ip_dst.s_addr = remap_ipv4(tcpedit, ipmap->to, ip_hdr->ip_dst.s_addr);\n            ipv4_addr_csum_replace(ip_hdr, old_ip, ip_hdr->ip_dst.s_addr, len);\n            dbgx(2, \"Remapped dst addr to: %s\", get_addr2name4(ip_hdr->ip_dst.s_addr, RESOLVE));\n            break;\n        }\n        ipmap = ipmap->next;\n    }\n\n    /* anything else to rewrite? */\n    if (tcpedit->cidrmap1 == NULL)\n        return(0);\n\n    /* don't play with the main pointers */\n    if (direction == TCPR_DIR_C2S) {\n        cidrmap1 = tcpedit->cidrmap1;\n        cidrmap2 = tcpedit->cidrmap2;\n    } else {\n        cidrmap1 = tcpedit->cidrmap2;\n        cidrmap2 = tcpedit->cidrmap1;\n    }\n    \n\n    /* loop through the cidrmap to rewrite */\n    do {\n        if ((! diddst) && ip_in_cidr(cidrmap2->from, ip_hdr->ip_dst.s_addr)) {\n            uint32_t old_ip = ip_hdr->ip_dst.s_addr;\n            ip_hdr->ip_dst.s_addr = remap_ipv4(tcpedit, cidrmap2->to, ip_hdr->ip_dst.s_addr);\n            ipv4_addr_csum_replace(ip_hdr, old_ip, ip_hdr->ip_dst.s_addr, len);\n            dbgx(2, \"Remapped dst addr to: %s\", get_addr2name4(ip_hdr->ip_dst.s_addr, RESOLVE));\n            diddst = 1;\n        }\n        if ((! didsrc) && ip_in_cidr(cidrmap1->from, ip_hdr->ip_src.s_addr)) {\n            uint32_t old_ip = ip_hdr->ip_src.s_addr;\n            ip_hdr->ip_src.s_addr = remap_ipv4(tcpedit, cidrmap1->to, ip_hdr->ip_src.s_addr);\n            ipv4_addr_csum_replace(ip_hdr, old_ip, ip_hdr->ip_src.s_addr, len);\n            dbgx(2, \"Remapped src addr to: %s\", get_addr2name4(ip_hdr->ip_src.s_addr, RESOLVE));\n            didsrc = 1;\n        }\n\n        /*\n         * loop while we haven't modified both src/dst AND\n         * at least one of the cidr maps have a next pointer\n         */\n        if ((! (diddst && didsrc)) &&\n            (! ((cidrmap1->next == NULL) && (cidrmap2->next == NULL)))) {\n\n            /* increment our ptr's if possible */\n            if (cidrmap1->next != NULL)\n                cidrmap1 = cidrmap1->next;\n\n            if (cidrmap2->next != NULL)\n                cidrmap2 = cidrmap2->next;\n\n        } else {\n            loop = 0;\n        }\n\n        /* Later on we should support various IP protocols which embed\n         * the IP address in the application layer.  Things like\n         * DNS and FTP.\n         */\n\n    } while (loop);\n\n    /* return how many changes we require checksum updates (none) */\n    return 0;\n}",
                        1
                    ],
                    [
                        "src/common/get.c",
                        "get_ipv6_l4proto",
                        "get_ipv6_l4proto",
                        "uint8_t  /* <=== get_ipv6_l4proto */ \nget_ipv6_l4proto(const ipv6_hdr_t *ip6_hdr, const int l3len)\n{\n    u_char *ptr = (u_char *)ip6_hdr + TCPR_IPV6_H; /* jump to the end of the IPv6 header */\n    uint8_t proto;\n    struct tcpr_ipv6_ext_hdr_base *exthdr = NULL;\n\n    assert(ip6_hdr);\n\n    proto = ip6_hdr->ip_nh;\n    int l4len = l3len - TCPR_IPV6_H;\n    if (l4len < 0)\n        return proto;\n\n    while (TRUE) {\n        dbgx(3, \"Processing next proto 0x%02X\", proto);\n        switch (proto) {\n            /* no further processing for IPV6 types with nothing beyond them */\n            case TCPR_IPV6_NH_FRAGMENT:\n            case TCPR_IPV6_NH_ESP:\n                dbg(3, \"No-Next or ESP... can't go any further...\");\n                return proto;\n                break;\n\n            /* recurse */\n            case TCPR_IPV6_NH_IPV6:\n                dbg(3, \"Recursing due to v6 in v6\");\n                return get_ipv6_l4proto((ipv6_hdr_t *)ptr, l4len);\n                break;\n\n            /* loop again */\n            case TCPR_IPV6_NH_AH:\n            case TCPR_IPV6_NH_ROUTING:\n            case TCPR_IPV6_NH_DESTOPTS:\n            case TCPR_IPV6_NH_HBH:\n                dbgx(3, \"Jumping to next extension header (0x%hhx)\", proto);\n                exthdr = get_ipv6_next((struct tcpr_ipv6_ext_hdr_base *)ptr,\n                        l4len);\n                if (exthdr == NULL)\n                    return proto;\n                proto = exthdr->ip_nh;\n                l4len -= (u_char *)exthdr - ptr;\n                ptr = (u_char *)exthdr;\n                break;\n\n            /* should be TCP, UDP or the like */\n            default:\n                dbgx(3, \"Selecting next L4 Proto as: 0x%02x\", proto);\n                return proto;\n        } /* switch */\n    } /* while */\n}",
                        3
                    ],
                    [
                        "src/tcpedit/portmap.c",
                        "map_port",
                        "map_port",
                        "long /* <=== map_port */ \nmap_port(tcpedit_portmap_t *portmap_data, long port)\n{\n    tcpedit_portmap_t *portmap_ptr;\n    long newport;\n\n    assert(portmap_data);\n\n    portmap_ptr = portmap_data;\n    newport = port;\n\n    /* step through the nodes, resetting newport if a match is found */\n    while (portmap_ptr != NULL) {\n        if (portmap_ptr->from == port)\n            newport = portmap_ptr->to;\n\n        portmap_ptr = portmap_ptr->next;\n    }\n\n    return(newport);\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.lessThan",
                        "<operator>.lessThan",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_proto",
                        "tcpedit_dlt_proto",
                        "int /* <=== tcpedit_dlt_proto */ \ntcpedit_dlt_proto(tcpeditdlt_t *ctx, int dlt, const u_char *packet, const int pktlen)\n{\n    tcpeditdlt_plugin_t *plugin;\n\n    assert(ctx);\n    assert(dlt >= 0);\n    assert(packet);\n\n    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt)) == NULL) {\n        tcpedit_seterr(ctx->tcpedit, \"Unable to find plugin for DLT 0x%04x\", dlt);\n        return -1;\n    }\n    \n    return plugin->plugin_proto(ctx, packet, pktlen);\n}",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_PROTO_CDP",
                        "src/tcpedit/tcpr.h:336:336:TCPR_PROTO_CDP:0",
                        "",
                        3
                    ],
                    [
                        "<empty>",
                        "fprintf",
                        "fprintf",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "remap_ipv6",
                        "remap_ipv6",
                        "static int /* <=== remap_ipv6 */ \nremap_ipv6(tcpedit_t *tcpedit, tcpr_cidr_t *cidr, struct tcpr_in6_addr *addr)\n{\n    uint32_t i, j, k;\n\n    assert(tcpedit);\n    assert(cidr);\n\n    if (cidr->family != AF_INET6) {\n        return 0;\n    }\n\n    /* don't rewrite broadcast addresses */\n    if (tcpedit->skip_broadcast && is_multicast_ipv6(tcpedit, addr))\n        return 0;\n\n    j = cidr->masklen / 8;\n\n    for (i = 0; i < j; i++)\n        addr->tcpr_s6_addr[i] = cidr->u.network6.tcpr_s6_addr[i];\n\n    if ((k = cidr->masklen % 8) == 0)\n        return 1;\n\n    k = (uint32_t)~0 << (8 - k);\n    i = addr->tcpr_s6_addr[i] & k;\n\n    addr->tcpr_s6_addr[i] = (cidr->u.network6.tcpr_s6_addr[j] & (0xff << (8 - k))) |\n      (addr->tcpr_s6_addr[i] & (0xff >> k));\n\n    return 1;\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_OSPF_LSA",
                        "src/tcpedit/tcpr.h:1183:1183:IPPROTO_OSPF_LSA:0",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "is_multicast_ipv6",
                        "is_multicast_ipv6",
                        "static int /* <=== is_multicast_ipv6 */ \nis_multicast_ipv6(tcpedit_t *tcpedit, struct tcpr_in6_addr *addr)\n{\n    assert(tcpedit);\n\n    if (addr->tcpr_s6_addr[0] == 0xff)\n        return 1;\n\n    return 0;\n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpedit.c",
                        "__tcpedit_seterr",
                        "__tcpedit_seterr",
                        "void /* <=== __tcpedit_seterr */ \n__tcpedit_seterr(tcpedit_t *tcpedit, const char *func, const int line, const char *file, const char *fmt, ...)\n{\n    va_list ap;\n    char errormsg[TCPEDIT_ERRSTR_LEN - 32];\n    \n    assert(tcpedit);\n\n    va_start(ap, fmt);\n    if (fmt != NULL) {\n        (void)vsnprintf(errormsg, sizeof(errormsg), fmt, ap);\n    }\n\n    va_end(ap);\n    \n    snprintf(tcpedit->runtime.errstr, sizeof(tcpedit->runtime.errstr),\n             \"From %s:%s() line %d:\\n%s\",\n             file, func, line, errormsg);\n}",
                        2
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "randomize_ipv6_addr",
                        "randomize_ipv6_addr",
                        "static void /* <=== randomize_ipv6_addr */ \nrandomize_ipv6_addr(tcpedit_t *tcpedit, struct tcpr_in6_addr *addr)\n{\n    uint32_t *p;\n    int i;\n    u_char was_multicast;\n\n    assert(tcpedit);\n\n    p = &addr->__u6_addr.__u6_addr32[0];\n\n    was_multicast = is_multicast_ipv6(tcpedit, addr);\n\n    for (i = 0; i < 4; ++i) {\n        p[i] = ((p[i] ^ htonl(tcpedit->seed)) - (p[i] & htonl(tcpedit->seed)));\n    }\n\n    if (was_multicast) {\n        addr->tcpr_s6_addr[0] = 0xff;\n    } else if (is_multicast_ipv6(tcpedit, addr)) {\n        addr->tcpr_s6_addr[0] = 0xaa;\n    }\n}",
                        2
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_src",
                        "tcpedit_dlt_src",
                        "int  /* <=== tcpedit_dlt_src */ \ntcpedit_dlt_src(tcpeditdlt_t *ctx)\n{\n    assert(ctx);\n    return ctx->decoder->dlt;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/tcpedit.c",
                        "tcpedit_getwarn",
                        "tcpedit_getwarn",
                        "char * /* <=== tcpedit_getwarn */ \ntcpedit_getwarn(tcpedit_t *tcpedit)\n{\n    assert(tcpedit);\n\n    return tcpedit->runtime.warnstr;\n}",
                        1
                    ],
                    [
                        "src/common/utils.c",
                        "_our_safe_realloc",
                        "_our_safe_realloc",
                        "void * /* <=== _our_safe_realloc */ \n_our_safe_realloc(void *ptr, size_t len, const char *funcname, const int line, const char *file)\n{\n\n    if ((ptr = realloc(ptr, len)) == NULL) {\n        fprintf(stderr, \"ERROR: in %s:%s() line %d: Unable to remalloc() buffer to %zu bytes\", file, funcname, line, len);\n        exit(-1);\n    }\n\n    dbgx(5, \"Remalloc'd buffer to %zu bytes in %s:%s() line %d\", len, file, funcname, line);\n\n    return ptr;\n}",
                        2
                    ],
                    [
                        "src/tcpedit/common/err.h",
                        "errx",
                        "src/tcpedit/common/err.h:122:126:errx:3",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "rewrite_ipv6l3",
                        "rewrite_ipv6l3",
                        "int /* <=== rewrite_ipv6l3 */ \nrewrite_ipv6l3(tcpedit_t *tcpedit, ipv6_hdr_t *ip6_hdr, tcpr_dir_t direction,\n        int l3len)\n{\n    tcpr_cidrmap_t *cidrmap1 = NULL, *cidrmap2 = NULL;\n    int didsrc = 0, diddst = 0, loop = 1;\n    tcpr_cidrmap_t *ipmap;\n\n    assert(tcpedit);\n    assert(ip6_hdr);\n\n    /* first check the src/dst IP maps */\n    ipmap = tcpedit->srcipmap;\n    while (ipmap != NULL) {\n        if (ip6_in_cidr(ipmap->from, &ip6_hdr->ip_src)) {\n            struct tcpr_in6_addr old_ip6;\n            memcpy(&old_ip6, &ip6_hdr->ip_src, sizeof(old_ip6));\n            remap_ipv6(tcpedit, ipmap->to, &ip6_hdr->ip_src);\n            ipv6_addr_csum_replace(ip6_hdr, &old_ip6, &ip6_hdr->ip_src, l3len);\n            dbgx(2, \"Remapped src addr to: %s\", get_addr2name6(&ip6_hdr->ip_src, RESOLVE));\n            break;\n        }\n        ipmap = ipmap->next;\n    }\n\n    ipmap = tcpedit->dstipmap;\n    while (ipmap != NULL) {\n        if (ip6_in_cidr(ipmap->from, &ip6_hdr->ip_dst)) {\n            struct tcpr_in6_addr old_ip6;\n            memcpy(&old_ip6, &ip6_hdr->ip_dst, sizeof(old_ip6));\n            remap_ipv6(tcpedit, ipmap->to, &ip6_hdr->ip_dst);\n            ipv6_addr_csum_replace(ip6_hdr, &old_ip6, &ip6_hdr->ip_dst, l3len);\n            dbgx(2, \"Remapped dst addr to: %s\", get_addr2name6(&ip6_hdr->ip_dst, RESOLVE));\n            break;\n        }\n        ipmap = ipmap->next;\n    }\n\n    /* anything else to rewrite? */\n    if (tcpedit->cidrmap1 == NULL)\n        return(0);\n\n    /* don't play with the main pointers */\n    if (direction == TCPR_DIR_C2S) {\n        cidrmap1 = tcpedit->cidrmap1;\n        cidrmap2 = tcpedit->cidrmap2;\n    } else {\n        cidrmap1 = tcpedit->cidrmap2;\n        cidrmap2 = tcpedit->cidrmap1;\n    }\n\n\n    /* loop through the cidrmap to rewrite */\n    do {\n        if ((! diddst) && ip6_in_cidr(cidrmap2->from, &ip6_hdr->ip_dst)) {\n            struct tcpr_in6_addr old_ip6;\n            memcpy(&old_ip6, &ip6_hdr->ip_dst, sizeof(old_ip6));\n            remap_ipv6(tcpedit, cidrmap2->to, &ip6_hdr->ip_dst);\n            ipv6_addr_csum_replace(ip6_hdr, &old_ip6, &ip6_hdr->ip_dst, l3len);\n            dbgx(2, \"Remapped dst addr to: %s\", get_addr2name6(&ip6_hdr->ip_dst, RESOLVE));\n            diddst = 1;\n        }\n        if ((! didsrc) && ip6_in_cidr(cidrmap1->from, &ip6_hdr->ip_src)) {\n            struct tcpr_in6_addr old_ip6;\n            memcpy(&old_ip6, &ip6_hdr->ip_src, sizeof(old_ip6));\n            remap_ipv6(tcpedit, cidrmap1->to, &ip6_hdr->ip_src);\n            ipv6_addr_csum_replace(ip6_hdr, &old_ip6, &ip6_hdr->ip_src, l3len);\n            dbgx(2, \"Remapped src addr to: %s\", get_addr2name6(&ip6_hdr->ip_src, RESOLVE));\n            didsrc = 1;\n        }\n\n        /*\n         * loop while we haven't modified both src/dst AND\n         * at least one of the cidr maps have a next pointer\n         */\n        if ((! (diddst && didsrc)) &&\n            (! ((cidrmap1->next == NULL) && (cidrmap2->next == NULL)))) {\n\n            /* increment our ptr's if possible */\n            if (cidrmap1->next != NULL)\n                cidrmap1 = cidrmap1->next;\n\n            if (cidrmap2->next != NULL)\n                cidrmap2 = cidrmap2->next;\n\n        } else {\n            loop = 0;\n        }\n\n        /* Later on we should support various IP protocols which embed\n         * the IP address in the application layer.  Things like\n         * DNS and FTP.\n         */\n\n    } while (loop);\n\n    /* return how many changes we made (none) */\n    return 0;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_merge_l3data",
                        "tcpedit_dlt_merge_l3data",
                        "u_char * /* <=== tcpedit_dlt_merge_l3data */ \ntcpedit_dlt_merge_l3data(tcpeditdlt_t *ctx, \n                         int dlt, \n                         u_char *packet, \n                         const int pktlen, \n                         u_char *ipv4_data,\n                         u_char *ipv6_data)\n{\n    tcpeditdlt_plugin_t *plugin;\n    u_char *res;\n\n    assert(ctx);\n    assert(dlt >= 0);\n    assert(packet);\n\n    if (ipv4_data == NULL && ipv6_data == NULL)\n        return packet;\n        \n    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt)) == NULL) {\n        tcpedit_seterr(ctx->tcpedit, \"Unable to find plugin for DLT 0x%04x\", dlt);\n        return NULL;\n    }\n\n    res = plugin->plugin_merge_layer3(ctx, packet, pktlen, ipv4_data, ipv6_data);\n    if (res == NULL)\n        tcpedit_seterr(ctx->tcpedit, \"Packet length %d is to short for layer 3 merge for DLT 0x%04x\",\n                pktlen, dlt);\n\n    return res;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/plugins/dlt_plugins.c",
                        "tcpedit_dlt_encode",
                        "tcpedit_dlt_encode",
                        "int  /* <=== tcpedit_dlt_encode */ \ntcpedit_dlt_encode(tcpeditdlt_t* ctx, u_char *packet, int pktlen, tcpr_dir_t direction)\n{\n    return ctx->encoder->plugin_encode(ctx, packet, pktlen, direction);\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.addition",
                        "<operator>.addition",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpedit.c",
                        "tcpedit_setwarn",
                        "tcpedit_setwarn",
                        "void /* <=== tcpedit_setwarn */ \ntcpedit_setwarn(tcpedit_t *tcpedit, const char *fmt, ...)\n{\n    va_list ap;\n    assert(tcpedit);\n\n    va_start(ap, fmt);\n    if (fmt != NULL)\n        (void)vsnprintf(tcpedit->runtime.warnstr,\n                        sizeof(tcpedit->runtime.warnstr), fmt, ap);\n\n    va_end(ap);\n        \n}",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IP_OFFMASK",
                        "src/tcpedit/tcpr.h:742:742:IP_OFFMASK:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IP_MF",
                        "src/tcpedit/tcpr.h:739:739:IP_MF:0",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "ETHERTYPE_IP6",
                        "src/tcpedit/tcpr.h:559:559:ETHERTYPE_IP6:0",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/incremental_checksum.h",
                        "csum16_sub",
                        "csum16_sub",
                        "static inline __sum16 csum16_sub(__sum16 csum, __be16 addend) /* <=== csum16_sub */ \n{\n    return csum16_add(csum, ~addend);\n}",
                        3
                    ],
                    [
                        "src/tcpedit/tcpedit/common/err.h",
                        "dbgx",
                        "src/tcpedit/tcpedit/common/err.h:110:110:dbgx:3",
                        "",
                        2
                    ],
                    [
                        "src/tcpedit/portmap.c",
                        "rewrite_ipv4_ports",
                        "rewrite_ipv4_ports",
                        "int /* <=== rewrite_ipv4_ports */ \nrewrite_ipv4_ports(tcpedit_t *tcpedit, ipv4_hdr_t **ip_hdr, const int l3len)\n{\n    assert(tcpedit);\n    u_char *l4;\n\n    if (*ip_hdr == NULL || ip_hdr == NULL) {\n        tcpedit_seterr(tcpedit, \"rewrite_ipv4_ports: NULL IP header: l3 len=%d\",\n                l3len);\n        return TCPEDIT_ERROR;\n    } else if ((*ip_hdr)->ip_p == IPPROTO_TCP || (*ip_hdr)->ip_p == IPPROTO_UDP) {\n        l4 = get_layer4_v4(*ip_hdr, l3len);\n        if (l4)\n            return rewrite_ports(tcpedit, (*ip_hdr)->ip_p, l4,\n                    l3len - (l4 - (u_char*)*ip_hdr));\n\n        tcpedit_setwarn(tcpedit, \"Unable to rewrite ports on IP header: l3 len=%d\",\n                l3len);\n        return TCPEDIT_WARN;\n    }\n\n    return 0;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/incremental_checksum.h",
                        "csum16_add",
                        "csum16_add",
                        "static inline __sum16 csum16_add(__sum16 csum, __be16 addend) /* <=== csum16_add */ \n{\n    uint16_t res = (uint16_t)csum;\n\n    res += (uint16_t)addend;\n    return (__sum16)(res + (res < (uint16_t)addend));\n}",
                        3
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "randomize_ipv4_addr",
                        "randomize_ipv4_addr",
                        "static uint32_t /* <=== randomize_ipv4_addr */ \nrandomize_ipv4_addr(tcpedit_t *tcpedit, uint32_t ip)\n{\n    assert(tcpedit);\n\n    /* don't rewrite broadcast addresses */\n    if (tcpedit->skip_broadcast && !is_unicast_ipv4(tcpedit, ip))\n        return ip;\n\n    return ((ip ^ htonl(tcpedit->seed)) - (ip & htonl(tcpedit->seed)));\n}",
                        2
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "ipv4_l34_csum_replace",
                        "ipv4_l34_csum_replace",
                        "static void ipv4_l34_csum_replace(uint8_t *data, uint8_t protocol, /* <=== ipv4_l34_csum_replace */ \n        uint32_t old, uint32_t new)\n{\n    ipv4_hdr_t *ipv4;\n    tcp_hdr_t *tcp_hdr;\n    udp_hdr_t *udp_hdr;\n\n    assert(data);\n\n    switch (protocol) {\n    case IPPROTO_IP:\n        ipv4 = (ipv4_hdr_t *)data;\n        csum_replace4(&ipv4->ip_sum, old, new);\n        break;\n\n    case IPPROTO_TCP:\n        tcp_hdr = (tcp_hdr_t *)data;\n        csum_replace4(&tcp_hdr->th_sum, old, new);\n        break;\n\n    case IPPROTO_UDP:\n        udp_hdr = (udp_hdr_t *)data;\n        if (udp_hdr->uh_sum)\n            csum_replace4(&udp_hdr->uh_sum, old, new);\n        break;\n\n    default:\n        assert(false);\n    }\n\n}",
                        3
                    ],
                    [
                        "src/tcpedit/edit_packet.c",
                        "randomize_ipv6",
                        "randomize_ipv6",
                        "int /* <=== randomize_ipv6 */ \nrandomize_ipv6(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n        u_char *pktdata, ipv6_hdr_t *ip6_hdr, const int l3len)\n{\n#ifdef DEBUG\n    char srcip[INET6_ADDRSTRLEN], dstip[INET6_ADDRSTRLEN];\n#endif\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(pktdata);\n    assert(ip6_hdr);\n\n#ifdef DEBUG\n    strlcpy(srcip, get_addr2name6(&ip6_hdr->ip_src, RESOLVE), INET6_ADDRSTRLEN);\n    strlcpy(dstip, get_addr2name6(&ip6_hdr->ip_dst, RESOLVE), INET6_ADDRSTRLEN);\n#endif\n\n    /* randomize IP addresses based on the value of random */\n    dbgx(1, \"Old Src IP: %s\\tOld Dst IP: %s\", srcip, dstip);\n    if (l3len < (int)sizeof(ipv6_hdr_t)) {\n        tcpedit_seterr(tcpedit, \"Unable to randomize IPv6 header due to packet capture snap length %u\",\n                pkthdr->caplen);\n        return TCPEDIT_ERROR;\n    }\n\n    /* don't rewrite broadcast addresses */\n    if ((tcpedit->skip_broadcast && !is_multicast_ipv6(tcpedit, &ip6_hdr->ip_dst))\n            || !tcpedit->skip_broadcast) {\n        struct tcpr_in6_addr old_ip6;\n        memcpy(&old_ip6, &ip6_hdr->ip_dst, sizeof(old_ip6));\n        randomize_ipv6_addr(tcpedit, &ip6_hdr->ip_dst);\n        ipv6_addr_csum_replace(ip6_hdr, &old_ip6, &ip6_hdr->ip_dst, l3len);\n    }\n\n    if ((tcpedit->skip_broadcast && !is_multicast_ipv6(tcpedit, &ip6_hdr->ip_src))\n            || !tcpedit->skip_broadcast) {\n        struct tcpr_in6_addr old_ip6;\n        memcpy(&old_ip6, &ip6_hdr->ip_src, sizeof(old_ip6));\n        randomize_ipv6_addr(tcpedit, &ip6_hdr->ip_src);\n        ipv6_addr_csum_replace(ip6_hdr, &old_ip6, &ip6_hdr->ip_src, l3len);\n    }\n\n#ifdef DEBUG\n    strlcpy(srcip, get_addr2name6(&ip6_hdr->ip_src, RESOLVE), INET6_ADDRSTRLEN);\n    strlcpy(dstip, get_addr2name6(&ip6_hdr->ip_dst, RESOLVE), INET6_ADDRSTRLEN);\n#endif\n\n    dbgx(1, \"New Src IP: %s\\tNew Dst IP: %s\\n\", srcip, dstip);\n\n    return 0;\n}",
                        1
                    ],
                    [
                        "src/tcpedit/tcpedit_types.h",
                        "TCPEDIT_ERRSTR_LEN",
                        "src/tcpedit/tcpedit_types.h:63:63:TCPEDIT_ERRSTR_LEN:0",
                        "#define TCPEDIT_ERRSTR_LEN 1024 /* <=== src/tcpedit/tcpedit_types.h:63:63:TCPEDIT_ERRSTR_LEN:0 */ ",
                        3
                    ],
                    [
                        "src/tcpedit/fuzzing.c",
                        "SGT_MAX_SIZE",
                        "src/tcpedit/fuzzing.c:28:28:SGT_MAX_SIZE:0",
                        "#define SGT_MAX_SIZE 16 /* <=== src/tcpedit/fuzzing.c:28:28:SGT_MAX_SIZE:0 */ ",
                        3
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "IPPROTO_VRRP",
                        "src/tcpedit/tcpr.h:1707:1707:IPPROTO_VRRP:0",
                        "",
                        3
                    ],
                    [
                        "src/tcpedit/tcpedit_types.h",
                        "TCPEDIT_ERROR",
                        "src/tcpedit/tcpedit_types.h:33:33:TCPEDIT_ERROR:0",
                        "#define TCPEDIT_ERROR  -1 /* <=== src/tcpedit/tcpedit_types.h:33:33:TCPEDIT_ERROR:0 */ ",
                        1
                    ],
                    [
                        "src/tcpedit/checksum.c",
                        "do_checksum_math",
                        "do_checksum_math<duplicate>0",
                        "static int /* <=== do_checksum_math<duplicate>0 */ \ndo_checksum_math(uint16_t *data, int len)\n{\n    int sum = 0;\n    union {\n        uint16_t s;\n        uint8_t b[2];\n    } pad;\n\n    while (len > 1) {\n        sum += *data++;\n        len -= 2;\n    }\n\n    if (len == 1) {\n        pad.b[0] = *(uint8_t *)data;\n        pad.b[1] = 0;\n        sum += pad.s;\n    }\n\n    return (sum);\n}",
                        3
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "TCPR_IPV6_NH_HBH",
                        "src/tcpedit/tcpr.h:865:865:TCPR_IPV6_NH_HBH:0",
                        "",
                        3
                    ],
                    [
                        "src/common/get.c",
                        "get_layer4_v6",
                        "get_layer4_v6",
                        "void * /* <=== get_layer4_v6 */ \nget_layer4_v6(const ipv6_hdr_t *ip6_hdr, const int l3len)\n{\n    struct tcpr_ipv6_ext_hdr_base *next, *exthdr;\n    bool done = false;\n    uint32_t maxlen;\n    uint8_t proto;\n    int min_len;\n\n    assert(ip6_hdr);\n\n    min_len = TCPR_IPV6_H + sizeof(struct tcpr_ipv6_ext_hdr_base);\n    if (l3len < min_len)\n        return NULL;\n\n    /* jump to the end of the IPv6 header */\n    next = (struct tcpr_ipv6_ext_hdr_base *)((u_char *)ip6_hdr + TCPR_IPV6_H);\n    proto = ip6_hdr->ip_nh;\n\n    while (!done) {\n        dbgx(3, \"Processing proto: 0x%hx\", (uint16_t)proto);\n\n        switch (proto) {\n        /* recurse due to v6-in-v6, need to recast next as an IPv6 Header */\n        case TCPR_IPV6_NH_IPV6:\n            dbg(3, \"recursing due to v6-in-v6\");\n            next = get_layer4_v6((ipv6_hdr_t *)next, l3len - min_len);\n            break;\n\n        /* loop again */\n        case TCPR_IPV6_NH_AH:\n        case TCPR_IPV6_NH_ROUTING:\n        case TCPR_IPV6_NH_DESTOPTS:\n        case TCPR_IPV6_NH_HBH:\n            dbgx(3, \"Going deeper due to extension header 0x%02X\", proto);\n            maxlen = l3len - (int)((u_char *)ip6_hdr - (u_char *)next);\n            exthdr = get_ipv6_next(next, maxlen);\n            if (exthdr == NULL) {\n                done = true;\n                break;\n            }\n            proto = exthdr->ip_nh;\n            next = exthdr;\n            break;\n\n        /*\n         * Can't handle.  Unparsable IPv6 fragment/encrypted data\n         */\n        case TCPR_IPV6_NH_FRAGMENT:\n        case TCPR_IPV6_NH_ESP:\n            next = NULL;\n            done = true;\n            break;\n\n        /*\n         * no further processing, either TCP, UDP, ICMP, etc...\n         */\n        default:\n            if (proto != ip6_hdr->ip_nh) {\n                dbgx(3, \"Returning byte offset of this ext header: %u\", \n                        IPV6_EXTLEN_TO_BYTES(next->ip_len));\n                next =  (void *)((u_char *)next + IPV6_EXTLEN_TO_BYTES(next->ip_len));\n            } else {\n                dbgx(3, \"%s\", \"Returning end of IPv6 Header\");\n            }\n\n            done = true;\n        } /* switch */\n    } /* while */\n\n    if (!next || (u_char*)next > (u_char*)ip6_hdr + l3len)\n        return NULL;\n\n    return next;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.minus",
                        "<operator>.minus",
                        "",
                        1
                    ],
                    [
                        "src/tcpedit/tcpr.h",
                        "ETHERTYPE_IP",
                        "src/tcpedit/tcpr.h:538:538:ETHERTYPE_IP:0",
                        "",
                        1
                    ]
                ],
                "globalVars": [],
                "importContext": [
                    "#include \"config.h\"",
                    "#include \"defines.h\"",
                    "#include <ctype.h>",
                    "#include <fcntl.h>",
                    "#include <stdio.h>",
                    "#include <stdlib.h>",
                    "#include <string.h>",
                    "#include <sys/types.h>",
                    "#include <unistd.h>",
                    "#include <stdarg.h>",
                    "#include \"tcpedit_stub.h\"",
                    "#include \"portmap.h\"",
                    "#include \"common.h\"",
                    "#include \"incremental_checksum.h\"",
                    "#include \"edit_packet.h\"",
                    "#include \"parse_args.h\"",
                    "#include \"fuzzing.h\"",
                    "#include \"rewrite_sequence.h\"",
                    "#include \"lib/sll.h\"",
                    "#include \"dlt.h\""
                ],
                "typeDefs": [
                    [
                        "struct pcap_pkthdr",
                        "pcap_pkthdr"
                    ],
                    [
                        "typedef enum tcpr_dir_e tcpr_dir_t;",
                        "tcpr_dir_t"
                    ],
                    [
                        "typedef struct {\n    bool validated;  /* have we run tcpedit_validate()? */\n    struct tcpeditdlt_s *dlt_ctx;\n    \n    /* runtime variables, don't mess with these */\n    tcpedit_runtime_t runtime;\n    \n    /* skip rewriting IP/MAC's which are broadcast or multicast? */\n    bool skip_broadcast;\n\n    /* pad or truncate packets */\n    tcpedit_fixlen fixlen;\n    tcpedit_direction editdir;\n\n    /* rewrite ip? */\n    bool rewrite_ip;\n\n    /* rewrite TCP seq/ack numbers? */\n    u_int32_t tcp_sequence_enable;\n    u_int32_t tcp_sequence_adjust;\n    \n    /* fix IP/TCP/UDP checksums */\n    bool fixcsum;\n\n    /* remove ethernet FCS */\n    bool efcs;\n\n    tcpedit_ttl_mode ttl_mode;\n    u_int8_t ttl_value;\n\n    /* TOS/DiffServ/ECN, -1 is disabled, else copy value */\n    int tos;\n    \n    /* IPv6 FlowLabel, -1 is disabled, else copy value */\n    int flowlabel;\n    \n    /* IPv6 TClass, -1 is disabled, else copy value */\n    int tclass;\n    \n    /* rewrite end-point IP addresses between cidrmap1 & c...",
                        "tcpedit_t"
                    ]
                ],
                "visitedLines": [
                    [
                        287,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        199,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        373,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        385,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        380,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        119,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        222,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        178,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        177,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        274,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        230,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        87,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        270,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        217,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        145,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        85,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        232,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        267,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        311,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        379,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        107,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        352,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        238,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        234,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        346,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        382,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        364,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        126,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        154,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        335,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        123,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        381,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        101,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        152,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        209,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        261,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        102,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        265,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        131,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        362,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        243,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        291,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        137,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        84,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        361,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        288,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        256,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        306,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        253,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        341,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        314,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        372,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        227,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        296,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        223,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        319,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        103,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        210,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        259,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        185,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        312,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        276,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        132,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        118,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        275,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        83,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        318,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        281,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        386,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        198,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        334,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        285,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        340,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        384,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        347,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        282,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        128,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        324,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        365,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        305,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        368,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        164,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        98,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        194,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        157,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        195,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        269,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        371,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        248,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        188,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        369,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        360,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        353,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        303,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        167,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        348,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        297,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        239,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        153,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        120,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        156,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        231,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        260,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        237,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        337,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        100,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        349,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        339,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        173,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        130,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        245,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        158,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        331,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        299,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        307,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        105,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        218,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        221,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        99,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        309,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        333,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        343,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        268,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        250,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        214,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        363,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        174,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        266,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        366,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        374,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        278,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        134,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        378,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        310,
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ]
                ],
                "visitedParams": [
                    [
                        "struct pcap_pkthdr **pkthdr",
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        "u_char **pktdata",
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        "tcpedit_t *tcpedit",
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ],
                    [
                        "tcpr_dir_t direction",
                        "tcpedit_packet",
                        "src/tcpedit/tcpedit.c"
                    ]
                ],
                "vulnerableMethods": [
                    [
                        "src/tcpedit/tcpedit.c",
                        "tcpedit_packet",
                        "int /* <=== tcpedit_packet */ \ntcpedit_packet(tcpedit_t *tcpedit, struct pcap_pkthdr **pkthdr,\n        u_char **pktdata, tcpr_dir_t direction)\n{\n    bool fuzz_once = tcpedit->fuzz_seed != 0;\n    ipv4_hdr_t *ip_hdr;\n    ipv6_hdr_t *ip6_hdr;\n    arp_hdr_t *arp_hdr;\n    int l2len, l2proto, retval;\n    int dst_dlt, src_dlt, pktlen, lendiff;\n    int ipflags, tclass;\n    int needtorecalc;           /* did the packet change? if so, checksum */\n    u_char *packet;\n\n\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(*pkthdr);\n    assert(pktdata);\n    assert(*pktdata);\n    assert(tcpedit->validated);\n\n    packet = *pktdata;\n\n    tcpedit->runtime.packetnum++;\n\n    dbgx(3, \"packet \" COUNTER_SPEC \" caplen %d\", \n            tcpedit->runtime.packetnum, (*pkthdr)->caplen);\n\n    /*\n     * remove the Ethernet FCS (checksum)?\n     * note that this feature requires the end user to be smart and\n     * only set this flag IFF the pcap has the FCS.  If not, then they\n     * just removed 2 bytes of ACTUAL PACKET DATA.  Sucks to be them.\n     */\n    if (tcpedit->efcs > 0 &&(*pkthdr)->len > 4) {\n        if ((*pkthdr)->caplen == (*pkthdr)->len) {\n            (*pkthdr)->caplen -= 4;\n        }\n\n        (*pkthdr)->len -= 4;\n    }\n\n    src_dlt = tcpedit_dlt_src(tcpedit->dlt_ctx);\n    \n    needtorecalc = 0;\nagain:\n    ip_hdr = NULL;\n    ip6_hdr = NULL;\n    arp_hdr = NULL;\n    retval = 0;\n    ipflags = 0;\n    tclass = 0;\n    /* not everything has a L3 header, so check for errors.  returns proto in network byte order */\n    if ((l2proto = tcpedit_dlt_proto(tcpedit->dlt_ctx, src_dlt, packet, (*pkthdr)->caplen)) < 0) {\n        dbgx(2, \"Packet has no L3+ header: %s\", tcpedit_geterr(tcpedit));\n        return TCPEDIT_SOFT_ERROR;\n    } else {\n        dbgx(2, \"Layer 3 protocol type is: 0x%04x\", ntohs(l2proto));\n    }\n        \n    /* rewrite Layer 2 */\n    if ((pktlen = tcpedit_dlt_process(tcpedit->dlt_ctx, pktdata, (*pkthdr)->caplen, direction)) < 0) {\n        /* unable to edit packet, most likely 802.11 management or data QoS frame */\n        dbgx(3, \"Failed to edit DLT: %s\", tcpedit_geterr(tcpedit));\n        return TCPEDIT_SOFT_ERROR;\n    }\n\n    /* update our packet lengths (real/captured) based on L2 length changes */\n    lendiff = pktlen - (*pkthdr)->caplen;\n    (*pkthdr)->caplen += lendiff;\n    (*pkthdr)->len += lendiff;\n    \n    dst_dlt = tcpedit_dlt_dst(tcpedit->dlt_ctx);\n    l2len = tcpedit_dlt_l2len(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n    if (l2len == -1)\n        return TCPEDIT_SOFT_ERROR;\n\n    dbgx(2, \"dst_dlt = %04x\\tsrc_dlt = %04x\\tproto = %04x\\tl2len = %d\", dst_dlt, src_dlt, ntohs(l2proto), l2len);\n\n    /* does packet have an IP header?  if so set our pointer to it */\n    if (l2proto == htons(ETHERTYPE_IP)) {\n        u_char *p;\n\n        if ((*pkthdr)->caplen < l2len + sizeof(*ip_hdr)) {\n            tcpedit_seterr(tcpedit, \"Packet length %d is too short to contain a layer IP header for DLT 0x%04x\",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        ip_hdr = (ipv4_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n        if (ip_hdr == NULL)\n            return TCPEDIT_SOFT_ERROR;\n\n        p = get_layer4_v4(ip_hdr, (*pkthdr)->caplen - l2len);\n        if (!p) {\n            tcpedit_seterr(tcpedit, \"Packet length %d is too short to contain a layer %d byte IP header for DLT 0x%04x\",\n                    pktlen, ip_hdr->ip_hl << 2,  dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        dbgx(3, \"Packet has an IPv4 header: 0x%p...\", ip_hdr);\n    } else if (l2proto == htons(ETHERTYPE_IP6)) {\n        u_char *p;\n\n        if ((*pkthdr)->caplen < l2len + sizeof(*ip6_hdr)) {\n            tcpedit_seterr(tcpedit, \"Packet length %d is too short to contain a layer IPv6 header for DLT 0x%04x\",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        ip6_hdr = (ipv6_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n        if (ip6_hdr == NULL)\n            return TCPEDIT_SOFT_ERROR;\n\n        p = get_layer4_v6(ip6_hdr, (*pkthdr)->caplen - l2len);\n        if (!p) {\n            tcpedit_seterr(tcpedit, \"Packet length %d is too short to contain an IPv6 header for DLT 0x%04x\",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        dbgx(3, \"Packet has an IPv6 header: 0x%p...\", ip6_hdr);\n    } else {\n        dbgx(3, \"Packet isn't IPv4 or IPv6: 0x%04x\", l2proto);\n        /* non-IP packets have a NULL ip_hdr struct */\n        ip_hdr = NULL;\n        ip6_hdr = NULL;\n    }\n\n    /* The following edits only apply for IPv4 */\n    if (ip_hdr != NULL) {\n\n        /* set TOS ? */\n        if (tcpedit->tos > -1) {\n            volatile uint16_t oldval = *((uint16_t*)ip_hdr);\n            volatile uint16_t newval;\n\n            ip_hdr->ip_tos = tcpedit->tos;\n            newval = *((uint16_t*)ip_hdr);\n            csum_replace2(&ip_hdr->ip_sum, oldval, newval);\n        }\n\n        /* rewrite the TTL */\n        needtorecalc += rewrite_ipv4_ttl(tcpedit, ip_hdr);\n\n        /* rewrite TCP/UDP ports */\n        if (tcpedit->portmap != NULL) {\n            if ((retval = rewrite_ipv4_ports(tcpedit, &ip_hdr,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        if (tcpedit->tcp_sequence_enable)\n            rewrite_ipv4_tcp_sequence(tcpedit, &ip_hdr,\n                    (*pkthdr)->caplen - l2len);\n    }\n\n    /* IPv6 edits */\n    else if (ip6_hdr != NULL) {\n        /* rewrite the hop limit */\n        needtorecalc += rewrite_ipv6_hlim(tcpedit, ip6_hdr);\n\n        /* set traffic class? */\n        if (tcpedit->tclass > -1) {\n            /* calculate the bits */\n            tclass = tcpedit->tclass << 20;\n            \n            /* convert our 4 bytes to an int */\n            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);\n            \n            /* strip out the old tclass bits */\n            ipflags = ntohl(ipflags) & 0xf00fffff;\n\n            /* add the tclass bits back */\n            ipflags += tclass; \n            ipflags = htonl(ipflags);\n            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);\n        }\n\n        /* set the flow label? */\n        if (tcpedit->flowlabel > -1) {\n            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);\n            ipflags = ntohl(ipflags) & 0xfff00000;\n            ipflags += tcpedit->flowlabel;\n            ipflags = htonl(ipflags);\n            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);\n        }\n\n        /* rewrite TCP/UDP ports */\n        if (tcpedit->portmap != NULL) {\n            if ((retval = rewrite_ipv6_ports(tcpedit, &ip6_hdr,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        if (tcpedit->tcp_sequence_enable)\n            rewrite_ipv6_tcp_sequence(tcpedit, &ip6_hdr, (*pkthdr)->caplen - l2len);\n    }\n\n    if (fuzz_once) {\n        fuzz_once = false;\n        retval = fuzzing(tcpedit, *pkthdr, pktdata);\n        if (retval < 0) {\n            return TCPEDIT_ERROR;\n        }\n        needtorecalc += retval;\n        goto again;\n    }\n\n    /* (Un)truncate or MTU truncate packet? */\n    if (tcpedit->fixlen || tcpedit->mtu_truncate) {\n        if ((retval = untrunc_packet(tcpedit, *pkthdr, pktdata, ip_hdr, ip6_hdr)) < 0)\n            return TCPEDIT_ERROR;\n        needtorecalc += retval;\n    }\n    \n    /* rewrite IP addresses in IPv4/IPv6 or ARP */\n    if (tcpedit->rewrite_ip) {\n        /* IP packets */\n        if (ip_hdr != NULL) {\n            if ((retval = rewrite_ipv4l3(tcpedit, ip_hdr, direction,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        } else if (ip6_hdr != NULL) {\n            if ((retval = rewrite_ipv6l3(tcpedit, ip6_hdr, direction,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        /* ARP packets */\n        else if (l2proto == htons(ETHERTYPE_ARP)) {\n            arp_hdr = (arp_hdr_t *)&(packet[l2len]);\n            /* unlike, rewrite_ipl3, we don't care if the packet changed\n             * because we never need to recalc the checksums for an ARP\n             * packet.  So ignore the return value\n             */\n            if (rewrite_iparp(tcpedit, arp_hdr, direction) < 0)\n                return TCPEDIT_ERROR;\n        }\n    }\n\n\n    /* do we need to spoof the src/dst IP address in IPv4 or ARP? */\n    if (tcpedit->seed) {\n        /* IPv4 Packets */\n        if (ip_hdr != NULL) {\n            if ((retval = randomize_ipv4(tcpedit, *pkthdr, packet, \n                    ip_hdr, (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n\n        } else if (ip6_hdr != NULL) {\n            if ((retval = randomize_ipv6(tcpedit, *pkthdr, packet,\n                    ip6_hdr, (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n\n        /* ARP packets */\n        } else if (l2proto == htons(ETHERTYPE_ARP)) {\n            if (direction == TCPR_DIR_C2S) {\n                if (randomize_iparp(tcpedit, *pkthdr, packet, \n                        tcpedit->runtime.dlt1, (*pkthdr)->caplen - l2len) < 0)\n                    return TCPEDIT_ERROR;\n            } else {\n                if (randomize_iparp(tcpedit, *pkthdr, packet, \n                        tcpedit->runtime.dlt2, (*pkthdr)->caplen - l2len) < 0)\n                    return TCPEDIT_ERROR;\n            }\n        }\n    }\n\n    /* do we need to fix checksums? -- must always do this last! */\n    if ((tcpedit->fixcsum || needtorecalc)) {\n        if (ip_hdr != NULL) {\n            dbgx(3, \"doing IPv4 checksum: needtorecalc=%d\", needtorecalc);\n            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr);\n        } else if (ip6_hdr != NULL) {\n            dbgx(3, \"doing IPv6 checksum: needtorecalc=%d\", needtorecalc);\n            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr);\n        } else {\n            dbgx(3, \"checksum not performed: needtorecalc=%d\", needtorecalc);\n            retval = TCPEDIT_OK;\n        }\n        if (retval < 0) {\n            return TCPEDIT_ERROR;\n        } else if (retval == TCPEDIT_WARN) {\n            warnx(\"%s\", tcpedit_getwarn(tcpedit));\n        }\n    }\n\n    tcpedit_dlt_merge_l3data(tcpedit->dlt_ctx,\n                             dst_dlt, packet,\n                             (*pkthdr)->caplen,\n                             (u_char*)ip_hdr,\n                             (u_char*)ip6_hdr);\n\n    tcpedit->runtime.total_bytes += (*pkthdr)->caplen;\n    tcpedit->runtime.pkts_edited ++;\n    return retval;\n}",
                        83
                    ]
                ]
            }
        },
        {
            "file_path": "src/tcprewrite.c",
            "patch": [
                {
                    "func_name": "main",
                    "patch": "--- func_before\n+++ func_after\n@@ -18,22 +18,26 @@\n \n     /* init tcpedit context */\n     if (tcpedit_init(&tcpedit, pcap_datalink(options.pin)) < 0) {\n-        errx(-1, \"Error initializing tcpedit: %s\", tcpedit_geterr(tcpedit));\n+        err_no_exitx(\"Error initializing tcpedit: %s\", tcpedit_geterr(tcpedit));\n+        tcpedit_close(&tcpedit);\n+        exit(-1);\n     }\n \n     /* parse the tcpedit args */\n     rcode = tcpedit_post_args(tcpedit);\n     if (rcode < 0) {\n+        err_no_exitx(\"Unable to parse args: %s\", tcpedit_geterr(tcpedit));\n         tcpedit_close(&tcpedit);\n-        errx(-1, \"Unable to parse args: %s\", tcpedit_geterr(tcpedit));\n+        exit(-1);\n     } else if (rcode == 1) {\n         warnx(\"%s\", tcpedit_geterr(tcpedit));\n     }\n \n     if (tcpedit_validate(tcpedit) < 0) {\n+        err_no_exitx(\"Unable to edit packets given options:\\n%s\",\n+                tcpedit_geterr(tcpedit));\n         tcpedit_close(&tcpedit);\n-        errx(-1, \"Unable to edit packets given options:\\n%s\",\n-                tcpedit_geterr(tcpedit));\n+        exit(-1);\n     }\n \n     /* fuzzing init */\n@@ -54,8 +58,9 @@\n #ifdef ENABLE_FRAGROUTE\n     if (options.fragroute_args) {\n         if ((options.frag_ctx = fragroute_init(65535, pcap_datalink(dlt_pcap), options.fragroute_args, ebuf)) == NULL) {\n+            err_no_exitx(\"%s\", ebuf);\n             tcpedit_close(&tcpedit);\n-            errx(-1, \"%s\", ebuf);\n+            exit(-1);\n         }\n     }\n #endif\n@@ -67,16 +72,18 @@\n #endif\n \n     if ((options.pout = pcap_dump_open(dlt_pcap, options.outfile)) == NULL) {\n+        err_no_exitx(\"Unable to open output pcap file: %s\", pcap_geterr(dlt_pcap));\n         tcpedit_close(&tcpedit);\n-        errx(-1, \"Unable to open output pcap file: %s\", pcap_geterr(dlt_pcap));\n+        exit(-1);\n     }\n \n     pcap_close(dlt_pcap);\n \n     /* rewrite packets */\n     if (rewrite_packets(tcpedit, options.pin, options.pout) == TCPEDIT_ERROR) {\n+        err_no_exitx(\"Error rewriting packets: %s\", tcpedit_geterr(tcpedit));\n         tcpedit_close(&tcpedit);\n-        errx(-1, \"Error rewriting packets: %s\", tcpedit_geterr(tcpedit));\n+        exit(-1);\n     }\n \n     /* clean up after ourselves */"
                }
            ],
            "related_methods_tcprewrite_c": [
                "rewrite_packets dbgx memcpy safe_pcap_next safe_malloc errx TCPEDIT_ERROR pcap_dump _our_safe_pcap_next check_cache tcpedit_packet _our_safe_malloc HAVE_OPT fprintf fflush exit TCPEDIT_SOFT_ERROR"
            ],
            "bfs_tcprewrite_c": {
                "calleeMethods": [],
                "globalVars": [],
                "importContext": [
                    "#include \"config.h\"",
                    "#include \"defines.h\"",
                    "#include \"common.h\"",
                    "#include <ctype.h>",
                    "#include <fcntl.h>",
                    "#include <stdio.h>",
                    "#include <stdlib.h>",
                    "#include <string.h>",
                    "#include <sys/types.h>",
                    "#include <unistd.h>",
                    "#include <errno.h>",
                    "#include \"tcprewrite.h\"",
                    "#include \"tcprewrite_opts.h\"",
                    "#include \"tcpedit/tcpedit.h\"",
                    "#include \"tcpedit/fuzzing.h\""
                ],
                "typeDefs": [],
                "visitedLines": [],
                "visitedParams": [],
                "vulnerableMethods": [
                    [
                        "src/tcprewrite.c",
                        "rewrite_packets",
                        "int /* <=== rewrite_packets */ \nrewrite_packets(tcpedit_t *tcpedit, pcap_t *pin, pcap_dumper_t *pout)\n{\n    tcpr_dir_t cache_result = TCPR_DIR_C2S;     /* default to primary */\n    struct pcap_pkthdr pkthdr, *pkthdr_ptr;     /* packet header */\n    const u_char *pktconst = NULL;              /* packet from libpcap */\n    u_char **pktdata = NULL;\n    static u_char *pktdata_buff;\n    static char *frag = NULL;\n    COUNTER packetnum = 0;\n    int rcode;\n#ifdef ENABLE_FRAGROUTE\n    int frag_len, proto;\n#endif\n\n    pkthdr_ptr = &pkthdr;\n\n    if (pktdata_buff == NULL)\n        pktdata_buff = (u_char *)safe_malloc(MAXPACKET);\n\n    pktdata = &pktdata_buff;\n\n    if (frag == NULL)\n        frag = (char *)safe_malloc(MAXPACKET);\n\n    /* MAIN LOOP \n     * Keep sending while we have packets or until\n     * we've sent enough packets\n     */\n    while ((pktconst = safe_pcap_next(pin, pkthdr_ptr)) != NULL) {\n        packetnum++;\n        dbgx(2, \"packet \" COUNTER_SPEC \" caplen %d\", packetnum, pkthdr.caplen);\n\n        if (pkthdr.caplen > MAX_SNAPLEN)\n            errx(-1, \"Frame too big, caplen %d exceeds %d\", pkthdr.caplen, MAX_SNAPLEN);\n        /* \n         * copy over the packet so we can pad it out if necessary and\n         * because pcap_next() returns a const ptr\n         */\n        memcpy(*pktdata, pktconst, pkthdr.caplen);\n\n        /* Dual nic processing? */\n        if (options.cachedata != NULL) {\n            cache_result = check_cache(options.cachedata, packetnum);\n        }\n\n        /* sometimes we should not send the packet, in such cases\n         * no point in editing this packet at all, just write it to the\n         * output file (note, we can't just remove it, or the tcpprep cache\n         * file will loose it's indexing\n         */\n\n        if (cache_result == TCPR_DIR_NOSEND)\n            goto WRITE_PACKET; /* still need to write it so cache stays in sync */\n\n        if ((rcode = tcpedit_packet(tcpedit, &pkthdr_ptr, pktdata, cache_result)) == TCPEDIT_ERROR) {\n            return rcode;\n        } else if ((rcode == TCPEDIT_SOFT_ERROR) && HAVE_OPT(SKIP_SOFT_ERRORS)) {\n            /* don't write packet */\n            dbgx(1, \"Packet \" COUNTER_SPEC \" is suppressed from being written due to soft errors\", packetnum);\n            continue;\n        }\n\n#ifdef ENABLE_VERBOSE\n        if (options.verbose)\n            tcpdump_print(&tcpdump, pkthdr_ptr, *pktdata);\n#endif\n\nWRITE_PACKET:\n#ifdef ENABLE_FRAGROUTE\n        if (options.frag_ctx == NULL) {\n            /* write the packet when there's no fragrouting to be done */\n            if (pkthdr_ptr->caplen)\n                pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n        } else {\n            /* get the L3 protocol of the packet */\n            proto = tcpedit_l3proto(tcpedit, AFTER_PROCESS, *pktdata, pkthdr_ptr->caplen);\n\n            /* packet is IPv4/IPv6 AND needs to be fragmented */\n            if ((proto ==  ETHERTYPE_IP || proto == ETHERTYPE_IP6) &&\n                    ((options.fragroute_dir == FRAGROUTE_DIR_BOTH) ||\n                    (cache_result == TCPR_DIR_C2S && options.fragroute_dir == FRAGROUTE_DIR_C2S) ||\n                    (cache_result == TCPR_DIR_S2C && options.fragroute_dir == FRAGROUTE_DIR_S2C))) {\n#ifdef DEBUG\n                int i = 0;\n#endif\n                if (fragroute_process(options.frag_ctx, *pktdata, pkthdr_ptr->caplen) < 0)\n                    errx(-1, \"Error processing packet via fragroute: %s\", options.frag_ctx->errbuf);\n\n                while ((frag_len = fragroute_getfragment(options.frag_ctx, &frag)) > 0) {\n                    /* frags get the same timestamp as the original packet */\n                    dbgx(1, \"processing packet \" COUNTER_SPEC \" frag: %u (%d)\", packetnum, i++, frag_len);\n                    pkthdr_ptr->caplen = frag_len;\n                    pkthdr_ptr->len = frag_len;\n                    if (pkthdr_ptr->caplen)\n                        pcap_dump((u_char *)pout, pkthdr_ptr, (u_char *)frag);\n                }\n            } else {\n                /* write the packet without fragroute */\n                if (pkthdr_ptr->caplen)\n                    pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n            }\n        }\n#else\n    /* write the packet when there's no fragrouting to be done */\n    if (pkthdr_ptr->caplen)\n        pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n\n#endif\n    } /* while() */\n    return 0;\n}",
                        242
                    ]
                ]
            }
        }
    ],
    "file_cache_in_old_repos": [
        "lib/strlcat.c",
        "lib/strlcpy.c",
        "libopts/alias.c",
        "libopts/ao-strs.c",
        "libopts/autoopts.c",
        "libopts/boolean.c",
        "libopts/check.c",
        "libopts/compat/pathfind.c",
        "libopts/compat/snprintf.c",
        "libopts/compat/strchr.c",
        "libopts/compat/strdup.c",
        "libopts/configfile.c",
        "libopts/cook.c",
        "libopts/enum.c",
        "libopts/env.c",
        "libopts/file.c",
        "libopts/find.c",
        "libopts/genshell.c",
        "libopts/init.c",
        "libopts/libopts.c",
        "libopts/load.c",
        "libopts/makeshell.c",
        "libopts/nested.c",
        "libopts/numeric.c",
        "libopts/option-value-type.c",
        "libopts/option-xat-attribute.c",
        "libopts/parse-duration.c",
        "libopts/pgusage.c",
        "libopts/putshell.c",
        "libopts/reset.c",
        "libopts/restore.c",
        "libopts/save.c",
        "libopts/sort.c",
        "libopts/stack.c",
        "libopts/streqvcmp.c",
        "libopts/text_mmap.c",
        "libopts/time.c",
        "libopts/tokenize.c",
        "libopts/usage.c",
        "libopts/version.c",
        "src/bridge.c",
        "src/common/cache.c",
        "src/common/cidr.c",
        "src/common/dlt_names.c",
        "src/common/err.c",
        "src/common/fakepcap.c",
        "src/common/fakepcapnav.c",
        "src/common/fakepoll.c",
        "src/common/flows.c",
        "src/common/get.c",
        "src/common/interface.c",
        "src/common/list.c",
        "src/common/mac.c",
        "src/common/netmap.c",
        "src/common/sendpacket.c",
        "src/common/services.c",
        "src/common/tcpdump.c",
        "src/common/timer.c",
        "src/common/txring.c",
        "src/common/utils.c",
        "src/common/xX.c",
        "src/fragroute/argv.c",
        "src/fragroute/bget.c",
        "src/fragroute/fragroute.c",
        "src/fragroute/iputil.c",
        "src/fragroute/mod.c",
        "src/fragroute/mod_delay.c",
        "src/fragroute/mod_drop.c",
        "src/fragroute/mod_dup.c",
        "src/fragroute/mod_echo.c",
        "src/fragroute/mod_ip6_opt.c",
        "src/fragroute/mod_ip6_qos.c",
        "src/fragroute/mod_ip_chaff.c",
        "src/fragroute/mod_ip_frag.c",
        "src/fragroute/mod_ip_opt.c",
        "src/fragroute/mod_ip_tos.c",
        "src/fragroute/mod_ip_ttl.c",
        "src/fragroute/mod_order.c",
        "src/fragroute/mod_print.c",
        "src/fragroute/mod_tcp_chaff.c",
        "src/fragroute/mod_tcp_opt.c",
        "src/fragroute/mod_tcp_seg.c",
        "src/fragroute/pkt.c",
        "src/fragroute/randutil.c",
        "src/replay.c",
        "src/send_packets.c",
        "src/signal_handler.c",
        "src/sleep.c",
        "src/tcpbridge.c",
        "src/tcpcapinfo.c",
        "src/tcpedit/checksum.c",
        "src/tcpedit/dlt.c",
        "src/tcpedit/edit_packet.c",
        "src/tcpedit/fuzzing.c",
        "src/tcpedit/incremental_checksum.c",
        "src/tcpedit/parse_args.c",
        "src/tcpedit/plugins/dlt_en10mb/en10mb.c",
        "src/tcpedit/plugins/dlt_en10mb/en10mb_api.c",
        "src/tcpedit/plugins/dlt_hdlc/hdlc.c",
        "src/tcpedit/plugins/dlt_hdlc/hdlc_api.c",
        "src/tcpedit/plugins/dlt_ieee80211/ieee80211.c",
        "src/tcpedit/plugins/dlt_ieee80211/ieee80211_hdr.c",
        "src/tcpedit/plugins/dlt_jnpr_ether/jnpr_ether.c",
        "src/tcpedit/plugins/dlt_jnpr_ether/jnpr_ether_api.c",
        "src/tcpedit/plugins/dlt_linuxsll/linuxsll.c",
        "src/tcpedit/plugins/dlt_loop/loop.c",
        "src/tcpedit/plugins/dlt_null/null.c",
        "src/tcpedit/plugins/dlt_plugins.c",
        "src/tcpedit/plugins/dlt_pppserial/pppserial.c",
        "src/tcpedit/plugins/dlt_pppserial/pppserial_api.c",
        "src/tcpedit/plugins/dlt_radiotap/radiotap.c",
        "src/tcpedit/plugins/dlt_raw/raw.c",
        "src/tcpedit/plugins/dlt_user/user.c",
        "src/tcpedit/plugins/dlt_user/user_api.c",
        "src/tcpedit/plugins/dlt_utils.c",
        "src/tcpedit/plugins/ethernet.c",
        "src/tcpedit/portmap.c",
        "src/tcpedit/rewrite_sequence.c",
        "src/tcpedit/tcpedit.c",
        "src/tcpedit/tcpedit_api.c",
        "src/tcpliveplay.c",
        "src/tcpprep.c",
        "src/tcpprep_api.c",
        "src/tcpreplay.c",
        "src/tcpreplay_api.c",
        "src/tcprewrite.c",
        "src/tree.c",
        "lib/queue.h",
        "lib/sll.h",
        "lib/strlcpy.h",
        "lib/tree.h",
        "libopts/ag-char-map.h",
        "libopts/ao-strs.h",
        "libopts/autoopts.h",
        "libopts/autoopts/options.h",
        "libopts/autoopts/project.h",
        "libopts/autoopts/usage-txt.h",
        "libopts/compat/_Noreturn.h",
        "libopts/compat/compat.h",
        "libopts/compat/windows-config.h",
        "libopts/genshell.h",
        "libopts/gettext.h",
        "libopts/intprops.h",
        "libopts/option-value-type.h",
        "libopts/option-xat-attribute.h",
        "libopts/parse-duration.h",
        "libopts/proto.h",
        "libopts/stdnoreturn.in.h",
        "src/bridge.h",
        "src/common.h",
        "src/common/cache.h",
        "src/common/cidr.h",
        "src/common/dlt_names.h",
        "src/common/err.h",
        "src/common/fakepcap.h",
        "src/common/fakepcapnav.h",
        "src/common/fakepoll.h",
        "src/common/flows.h",
        "src/common/get.h",
        "src/common/interface.h",
        "src/common/list.h",
        "src/common/mac.h",
        "src/common/netmap.h",
        "src/common/pcap_dlt.h",
        "src/common/sendpacket.h",
        "src/common/services.h",
        "src/common/tcpdump.h",
        "src/common/timer.h",
        "src/common/txring.h",
        "src/common/utils.h",
        "src/common/xX.h",
        "src/fragroute/argv.h",
        "src/fragroute/bget.h",
        "src/fragroute/fragroute.h",
        "src/fragroute/iputil.h",
        "src/fragroute/mod.h",
        "src/fragroute/pkt.h",
        "src/fragroute/randutil.h",
        "src/msvc_inttypes.h",
        "src/msvc_stdint.h",
        "src/replay.h",
        "src/send_packets.h",
        "src/signal_handler.h",
        "src/sleep.h",
        "src/tcpbridge.h",
        "src/tcpedit/checksum.h",
        "src/tcpedit/dlt.h",
        "src/tcpedit/edit_packet.h",
        "src/tcpedit/fuzzing.h",
        "src/tcpedit/incremental_checksum.h",
        "src/tcpedit/parse_args.h",
        "src/tcpedit/plugins.h",
        "src/tcpedit/plugins/dlt_en10mb/en10mb.h",
        "src/tcpedit/plugins/dlt_en10mb/en10mb_api.h",
        "src/tcpedit/plugins/dlt_en10mb/en10mb_types.h",
        "src/tcpedit/plugins/dlt_hdlc/hdlc.h",
        "src/tcpedit/plugins/dlt_hdlc/hdlc_api.h",
        "src/tcpedit/plugins/dlt_hdlc/hdlc_types.h",
        "src/tcpedit/plugins/dlt_ieee80211/ieee80211.h",
        "src/tcpedit/plugins/dlt_ieee80211/ieee80211_hdr.h",
        "src/tcpedit/plugins/dlt_ieee80211/ieee80211_types.h",
        "src/tcpedit/plugins/dlt_jnpr_ether/jnpr_ether.h",
        "src/tcpedit/plugins/dlt_jnpr_ether/jnpr_ether_api.h",
        "src/tcpedit/plugins/dlt_jnpr_ether/jnpr_ether_types.h",
        "src/tcpedit/plugins/dlt_linuxsll/linuxsll.h",
        "src/tcpedit/plugins/dlt_linuxsll/linuxsll_types.h",
        "src/tcpedit/plugins/dlt_loop/loop.h",
        "src/tcpedit/plugins/dlt_null/null.h",
        "src/tcpedit/plugins/dlt_pppserial/pppserial.h",
        "src/tcpedit/plugins/dlt_pppserial/pppserial_api.h",
        "src/tcpedit/plugins/dlt_pppserial/pppserial_types.h",
        "src/tcpedit/plugins/dlt_radiotap/radiotap.h",
        "src/tcpedit/plugins/dlt_raw/raw.h",
        "src/tcpedit/plugins/dlt_template/plugin.h",
        "src/tcpedit/plugins/dlt_template/plugin_api.h",
        "src/tcpedit/plugins/dlt_template/plugin_types.h",
        "src/tcpedit/plugins/dlt_user/user.h",
        "src/tcpedit/plugins/dlt_user/user_api.h",
        "src/tcpedit/plugins/dlt_user/user_types.h",
        "src/tcpedit/plugins/dlt_utils.h",
        "src/tcpedit/plugins/ethernet.h",
        "src/tcpedit/plugins_api.h",
        "src/tcpedit/plugins_types.h",
        "src/tcpedit/portmap.h",
        "src/tcpedit/rewrite_sequence.h",
        "src/tcpedit/tcpedit.h",
        "src/tcpedit/tcpedit_api.h",
        "src/tcpedit/tcpedit_types.h",
        "src/tcpliveplay.h",
        "src/tcpprep.h",
        "src/tcpprep_api.h",
        "src/tcpr.h",
        "src/tcpreplay.h",
        "src/tcpreplay_api.h",
        "src/tcprewrite.h",
        "src/timestamp_trace.h",
        "src/tree.h",
        "<includes>",
        "<unknown>"
    ]
}