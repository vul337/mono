{
    "cve_id": "CVE-2021-35938",
    "cwe_id": "CWE-59",
    "commit_url": "https://github.com/rpm-software-management/rpm/commit/25a435e90844ea98fe5eb7bef22c1aecf3a9c033",
    "patch_names": [
        {
            "func_name": "rpmPackageFilesInstall",
            "file_path": "lib/fsm.c"
        }
    ],
    "before_context": [
        {
            "file_path": "lib/fsm.c",
            "patch": [
                {
                    "func_name": "rpmPackageFilesInstall",
                    "patch": "--- func_before\n+++ func_after\n@@ -146,6 +146,14 @@\n                     rc = RPMERR_UNKNOWN_FILETYPE;\n             }\n \n+\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {\n+\t\t/* Only follow safe symlinks, and never on temporary files */\n+\t\tfd = fsmOpenat(di.dirfd, fp->fpath,\n+\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);\n+\t\tif (fd < 0)\n+\t\t    rc = RPMERR_OPEN_FAILED;\n+\t    }\n+\n setmeta:\n \t    if (!rc && fp->setmeta) {\n \t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,"
                }
            ],
            "related_methods_fsm_c": [
                "rpmPackageFilesInstall rasprintf rpmswAdd Fclose free rpmtePayload rpmteGetFileStates rpmtsPlugins rpmfilesFC xcalloc rpmfilesIter rpmfiFree fsmIter fsmIterFini rpmtsOp fdOp rpmtsGetTid setFileState fsmDebug rpmtsFlags XFA_SKIPPING fsmFsPath rpmfiStat rpmfiNext rpmfiFFlags XFA_CREATING rpmfiArchiveHasContent rpmpluginsCallFsmFilePost S_ISDIR rpmpluginsCallFsmFilePre S_ISREG xstrdup rpmpsmNotify ensureDir rpmfsGetAction rpmfiFMode rpmlog fsmClose rpmfiArchiveTell rpmfiDN fsmBackup fsmSetmeta fsmCommit fsmRemove fsmStat fsmMkfile fsmVerify S_ISLNK fsmMkdir S_ISFIFO fsmSymlink rpmfiFLink fsmMkfifo S_ISSOCK S_ISCHR S_ISBLK fsmMknod IS_DEV_LOG rstreqn strlen"
            ],
            "bfs_fsm_c": {
                "calleeMethods": [
                    [
                        "<empty>",
                        "<operator>.not",
                        "<operator>.not",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmIter",
                        "fsmIter",
                        "static rpmfi fsmIter(FD_t payload, rpmfiles files, rpmFileIter iter, void *data) /* <=== fsmIter */ \n{\n    rpmfi fi;\n    if (payload)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, iter);\n    if (fi && data)\n\trpmfiSetOnChdir(fi, onChdir, data);\n    return fi;\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfnFC",
                        "rpmfnFC",
                        "static rpm_count_t rpmfnFC(rpmfn fndata) /* <=== rpmfnFC */ \n{\n    return (fndata != NULL) ? fndata->fc :0;\n}",
                        2
                    ],
                    [
                        "rpmio/rpmlog.c",
                        "rpmlog",
                        "rpmlog",
                        "void rpmlog (int code, const char *fmt, ...) /* <=== rpmlog */ \n{\n    int saved_errno = errno;\n    unsigned pri = RPMLOG_PRI(code);\n    unsigned mask = RPMLOG_MASK(pri);\n    int saverec = (pri <= RPMLOG_WARNING);\n    va_list ap;\n    int n;\n\n    if ((mask & rpmlogSetMask(0)) == 0)\n\tgoto exit;\n\n    va_start(ap, fmt);\n    n = vsnprintf(NULL, 0, fmt, ap);\n    va_end(ap);\n\n    if (n >= -1) {\n\tstruct rpmlogRec_s rec;\n\tsize_t nb = n + 1;\n\tchar *msg = xmalloc(nb);\n\n\tva_start(ap, fmt);\n\tn = vsnprintf(msg, nb, fmt, ap);\n\tva_end(ap);\n\n\trec.code = code;\n\trec.pri = pri;\n\trec.message = msg;\n\n\tdolog(&rec, saverec);\n\n\tfree(msg);\n    }\nexit:\n    errno = saved_errno;\n}",
                        1
                    ],
                    [
                        "rpmio/rpmlog.c",
                        "dolog",
                        "dolog",
                        "static void dolog(struct rpmlogRec_s *rec, int saverec) /* <=== dolog */ \n{\n    static pthread_mutex_t serialize = PTHREAD_MUTEX_INITIALIZER;\n\n    int cbrc = RPMLOG_DEFAULT;\n    int needexit = 0;\n    FILE *clog = NULL;\n    rpmlogCallbackData *cbdata = NULL;\n    rpmlogCallback cbfunc = NULL;\n    rpmlogCtx ctx = rpmlogCtxAcquire(saverec);\n\n    if (ctx == NULL)\n\treturn;\n\n    /* Save copy of all messages at warning (or below == \"more important\"). */\n    if (saverec) {\n\tctx->recs = xrealloc(ctx->recs, (ctx->nrecs+2) * sizeof(*ctx->recs));\n\tctx->recs[ctx->nrecs].code = rec->code;\n\tctx->recs[ctx->nrecs].pri = rec->pri;\n\tctx->recs[ctx->nrecs].message = xstrdup(rec->message);\n\tctx->recs[ctx->nrecs+1].code = 0;\n\tctx->recs[ctx->nrecs+1].message = NULL;\n\tctx->nrecs++;\n\tctx->nrecsPri[rec->pri]++;\n    }\n    cbfunc = ctx->cbfunc;\n    cbdata = ctx->cbdata;\n    clog = ctx->stdlog;\n\n    /* Free the context for callback and actual log output */\n    ctx = rpmlogCtxRelease(ctx);\n\n    /* Always serialize callback and output to avoid interleaved messages. */\n    if (pthread_mutex_lock(&serialize) == 0) {\n\tif (cbfunc) {\n\t    cbrc = cbfunc(rec, cbdata);\n\t    needexit += cbrc & RPMLOG_EXIT;\n\t}\n\n\tif (cbrc & RPMLOG_DEFAULT) {\n\t    cbrc = rpmlogDefault(clog, rec);\n\t    needexit += cbrc & RPMLOG_EXIT;\n\t}\n\tpthread_mutex_unlock(&serialize);\n    }\n    \n    if (needexit)\n\texit(EXIT_FAILURE);\n\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.greaterEqualsThan",
                        "<operator>.greaterEqualsThan",
                        "",
                        1
                    ],
                    [
                        "rpmio/system.h",
                        "xstrdup",
                        "rpmio/system.h:71:71:xstrdup:1",
                        "",
                        3
                    ],
                    [
                        "rpmio/rpmmalloc.c",
                        "vmefail",
                        "vmefail",
                        "static void *vmefail(size_t size) /* <=== vmefail */ \n{\n    void *val = failfunc ? (*failfunc)(size, failfunc_data) : NULL;\n    if (val == NULL) {\n\tfprintf(stderr, _(\"memory alloc (%u bytes) returned NULL.\\n\"),\n\t\t(unsigned)size);\n\texit(EXIT_FAILURE);\n    }\n    return val;\t\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiLink",
                        "rpmfiLink",
                        "rpmfi rpmfiLink(rpmfi fi) /* <=== rpmfiLink */ \n{\n    if (fi)\n\tfi->nrefs++;\n    return fi;\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFFlags",
                        "rpmfilesFFlags",
                        "rpmfileAttrs rpmfilesFFlags(rpmfiles fi, int ix) /* <=== rpmfilesFFlags */ \n{\n    rpmfileAttrs FFlags = 0;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->fflags != NULL)\n\t    FFlags = fi->fflags[ix];\n    }\n    return FFlags;\n}",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "fsmMkdir",
                        "fsmMkdir",
                        "static int fsmMkdir(int dirfd, const char *path, mode_t mode) /* <=== fsmMkdir */ \n{\n    int rc = mkdirat(dirfd, path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n\t       dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "XFA_CREATING",
                        "XFA_CREATING",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmDebug",
                        "fsmDebug",
                        "static void fsmDebug(const char *fpath, rpmFileAction action, /* <=== fsmDebug */ \n\t\t     const struct stat *st)\n{\n    rpmlog(RPMLOG_DEBUG, \"%-10s %06o%3d (%4d,%4d)%6d %s\\n\",\n\t   fileActionString(action), (int)st->st_mode,\n\t   (int)st->st_nlink, (int)st->st_uid,\n\t   (int)st->st_gid, (int)st->st_size,\n\t    (fpath ? fpath : \"\"));\n}",
                        1
                    ],
                    [
                        "rpmio/macro.c",
                        "rpmExpandNumeric",
                        "rpmExpandNumeric",
                        "int /* <=== rpmExpandNumeric */ \nrpmExpandNumeric(const char *arg)\n{\n    char *val;\n    int rc;\n\n    if (arg == NULL)\n\treturn 0;\n\n    val = rpmExpand(arg, NULL);\n    if (!(val && *val != '%'))\n\trc = 0;\n    else if (*val == 'Y' || *val == 'y')\n\trc = 1;\n    else if (*val == 'N' || *val == 'n')\n\trc = 0;\n    else {\n\tchar *end;\n\trc = strtol(val, &end, 0);\n\tif (!(end && *end == '\\0'))\n\t    rc = 0;\n    }\n    free(val);\n\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/rpmts.c",
                        "rpmtsPlugins",
                        "rpmtsPlugins",
                        "rpmPlugins rpmtsPlugins(rpmts ts) /* <=== rpmtsPlugins */ \n{\n    rpmPlugins plugins = NULL;\n\n    if (ts != NULL) {\n\tif (ts->plugins == NULL)\n\t    ts->plugins = rpmpluginsNew(ts);\n\tplugins = ts->plugins;\n    }\n    return plugins;\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesIter",
                        "rpmfilesIter",
                        "rpmfi rpmfilesIter(rpmfiles files, int itype) /* <=== rpmfilesIter */ \n{\n    /* standalone iterators need to bump our refcount */\n    return initIter(files, itype, 1);\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFLinks",
                        "rpmfilesFLinks",
                        "uint32_t rpmfilesFLinks(rpmfiles fi, int ix, const int ** files) /* <=== rpmfilesFLinks */ \n{\n    uint32_t nlink = 0;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tnlink = 1;\n\tif (fi->nlinks) {\n\t    struct hardlinks_s ** hardlinks = NULL;\n\t    nlinkHashGetEntry(fi->nlinks, ix, &hardlinks, NULL, NULL);\n\t    if (hardlinks) {\n\t\tnlink = hardlinks[0]->nlink;\n\t\tif (files) {\n\t\t    *files = hardlinks[0]->files;\n\t\t}\n\t    } else if (files){\n\t\t*files = NULL;\n\t    }\n\t}\n    }\n    return nlink;\n}",
                        3
                    ],
                    [
                        "rpmio/rpmstring.h",
                        "rstreq",
                        "rstreq",
                        "static inline int rstreq(const char *s1, const char *s2) /* <=== rstreq */ \n{\n    return (strcmp(s1, s2) == 0);\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiArchiveTell",
                        "rpmfiArchiveTell",
                        "rpm_loff_t rpmfiArchiveTell(rpmfi fi) /* <=== rpmfiArchiveTell */ \n{\n    if (fi == NULL || fi->archive == NULL)\n\treturn 0;\n    return (rpm_loff_t) rpmcpioTell(fi->archive);\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFree",
                        "rpmfiFree",
                        "rpmfi rpmfiFree(rpmfi fi) /* <=== rpmfiFree */ \n{\n    if (fi == NULL) return NULL;\n\n    if (fi->nrefs > 1)\n\treturn rpmfiUnlink(fi);\n\n    fi->files = rpmfilesFree(fi->files);\n    fi->fn = _free(fi->fn);\n    fi->ofn = _free(fi->ofn);\n    fi->found = _free(fi->found);\n    fi->archive = rpmcpioFree(fi->archive);\n\n    free(fi);\n    return NULL;\n}",
                        2
                    ],
                    [
                        "lib/cpio.c",
                        "rpmcpioOpen",
                        "rpmcpioOpen",
                        "rpmcpio_t rpmcpioOpen(FD_t fd, char mode) /* <=== rpmcpioOpen */ \n{\n    if ((mode & O_ACCMODE) != O_RDONLY &&\n        (mode & O_ACCMODE) != O_WRONLY)\n        return NULL;\n\n    rpmcpio_t cpio = xcalloc(1, sizeof(*cpio));\n    cpio->fd = fdLink(fd);\n    cpio->mode = mode;\n    cpio->offset = 0;\n    return cpio;\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.indirectIndexAccess",
                        "<operator>.indirectIndexAccess",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "S_ISCHR",
                        "S_ISCHR",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFCaps",
                        "rpmfiFCaps",
                        "RPMFI_ITERFUNC(const char *, FCaps, i) /* <=== rpmfiFCaps */ ",
                        2
                    ],
                    [
                        "<empty>",
                        "S_ISLNK",
                        "S_ISLNK",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmUnpack",
                        "fsmUnpack",
                        "static int fsmUnpack(rpmfi fi, int fdno, rpmpsm psm, int nodigest) /* <=== fsmUnpack */ \n{\n    FD_t fd = fdDup(fdno);\n    int rc = rpmfiArchiveReadToFilePsm(fi, fd, nodigest, psm);\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s %\" PRIu64 \" bytes [%d]) %s\\n\", __func__,\n\t       rpmfiFN(fi), rpmfiFSize(fi), Fileno(fd),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    Fclose(fd);\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/psm.c",
                        "rpmpsmNotify",
                        "rpmpsmNotify",
                        "void rpmpsmNotify(rpmpsm psm, int what, rpm_loff_t amount) /* <=== rpmpsmNotify */ \n{\n    if (psm) {\n\tint changed = 0;\n\tif (amount > psm->total)\n\t    amount = psm->total;\n\tif (amount > psm->amount) {\n\t    psm->amount = amount;\n\t    changed = 1;\n\t}\n\tif (what && what != psm->what) {\n\t    psm->what = what;\n\t    changed = 1;\n\t}\n\tif (changed) {\n\t   rpmtsNotify(psm->ts, psm->te, psm->what, psm->amount, psm->total);\n\t}\n    }\n}",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmFsPath",
                        "fsmFsPath",
                        "static char * fsmFsPath(rpmfi fi, const char * suffix) /* <=== fsmFsPath */ \n{\n    return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : \"\", NULL);\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiDN",
                        "rpmfiDN",
                        "RPMFI_ITERFUNC(const char *, DN, j) /* <=== rpmfiDN */ ",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.and",
                        "<operator>.and",
                        "",
                        1
                    ],
                    [
                        "lib/header.c",
                        "headerFree",
                        "headerFree",
                        "Header headerFree(Header h) /* <=== headerFree */ \n{\n    (void) headerUnlink(h);\n\n    if (h == NULL || h->nrefs > 0)\n\treturn NULL;\n\n    if (h->index) {\n\tindexEntry entry = h->index;\n\tint i;\n\tfor (i = 0; i < h->indexUsed; i++, entry++) {\n\t    if ((h->flags & HEADERFLAG_ALLOCATED) && ENTRY_IS_REGION(entry)) {\n\t\tif (entry->length > 0) {\n\t\t    int32_t * ei = entry->data;\n\t\t    if ((ei - 2) == h->blob) h->blob = _free(h->blob);\n\t\t    entry->data = NULL;\n\t\t}\n\t    } else if (!ENTRY_IN_REGION(entry)) {\n\t\tentry->data = _free(entry->data);\n\t    }\n\t    entry->data = NULL;\n\t}\n\th->index = _free(h->index);\n    }\n\n    h = _free(h);\n    return NULL;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmStat",
                        "fsmStat",
                        "static int fsmStat(int dirfd, const char *path, int dolstat, struct stat *sb) /* <=== fsmStat */ \n{\n    int flags = dolstat ? AT_SYMLINK_NOFOLLOW : 0;\n    int rc = fstatat(dirfd, path, sb, flags);\n\n    if (_fsm_debug && rc && errno != ENOENT)\n        rpmlog(RPMLOG_DEBUG, \" %8s (%d %s, ost) %s\\n\",\n               __func__,\n               dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0) {\n        rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_LSTAT_FAILED);\n\t/* Ensure consistent struct content on failure */\n        memset(sb, 0, sizeof(*sb));\n    }\n    return rc;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalAnd",
                        "<operator>.logicalAnd",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmRemove",
                        "fsmRemove",
                        "static int fsmRemove(int dirfd, const char *path, mode_t mode) /* <=== fsmRemove */ \n{\n    return S_ISDIR(mode) ? fsmRmdir(dirfd, path) : fsmUnlink(dirfd, path);\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFree",
                        "rpmfilesFree",
                        "rpmfiles rpmfilesFree(rpmfiles fi) /* <=== rpmfilesFree */ \n{\n    if (fi == NULL) return NULL;\n\n    if (fi->nrefs > 1)\n\treturn rpmfilesUnlink(fi);\n\n    if (rpmfilesFC(fi) > 0) {\n\tif (fi->ofndata != &fi->fndata) {\n\t    rpmfnClear(fi->ofndata);\n\t    free(fi->ofndata);\n\t}\n\trpmfnClear(&fi->fndata);\n\n\tfi->flinks = _free(fi->flinks);\n\tfi->flangs = _free(fi->flangs);\n\tfi->digests = _free(fi->digests);\n\tfi->signatures = _free(fi->signatures);\n\tfi->signatureoffs = _free(fi->signatureoffs);\n\tfi->veritysigs = _free(fi->veritysigs);\n\tfi->fcaps = _free(fi->fcaps);\n\n\tfi->cdict = _free(fi->cdict);\n\n\tfi->fuser = _free(fi->fuser);\n\tfi->fgroup = _free(fi->fgroup);\n\n\tfi->fstates = _free(fi->fstates);\n\tfi->fps = _free(fi->fps);\n\n\t/* these point to header memory if KEEPHEADER is used, dont free */\n\tif (!(fi->fiflags & RPMFI_KEEPHEADER) && fi->h == NULL) {\n\t    fi->fmtimes = _free(fi->fmtimes);\n\t    fi->fmodes = _free(fi->fmodes);\n\t    fi->fflags = _free(fi->fflags);\n\t    fi->vflags = _free(fi->vflags);\n\t    fi->fsizes = _free(fi->fsizes);\n\t    fi->lfsizes = _free(fi->lfsizes);\n\t    fi->frdevs = _free(fi->frdevs);\n\t    fi->finodes = _free(fi->finodes);\n\n\t    fi->fcolors = _free(fi->fcolors);\n\t    fi->fcdictx = _free(fi->fcdictx);\n\t    fi->ddict = _free(fi->ddict);\n\t    fi->fddictx = _free(fi->fddictx);\n\t    fi->fddictn = _free(fi->fddictn);\n\n\t}\n    }\n\n    fi->replacedSizes = _free(fi->replacedSizes);\n    fi->replacedLSizes = _free(fi->replacedLSizes);\n\n    fi->h = headerFree(fi->h);\n    fi->pool = rpmstrPoolFree(fi->pool);\n\n    fi->nlinks = nlinkHashFree(fi->nlinks);\n\n    (void) rpmfilesUnlink(fi);\n    memset(fi, 0, sizeof(*fi));\t\t/* XXX trash and burn */\n    fi = _free(fi);\n\n    return NULL;\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFLinks",
                        "rpmfiFLinks",
                        "uint32_t rpmfiFLinks(rpmfi fi, const int ** files) /* <=== rpmfiFLinks */ \n{\n    return rpmfilesFLinks(fi ? fi->files : NULL, fi ? fi->i : -1, files);\n}",
                        2
                    ],
                    [
                        "lib/rpmfs.c",
                        "rpmfsGetAction",
                        "rpmfsGetAction",
                        "rpmFileAction rpmfsGetAction(rpmfs fs, unsigned int ix) /* <=== rpmfsGetAction */ \n{\n    rpmFileAction action;\n    if (fs && fs->actions != NULL && ix < fs->fc) {\n\taction = fs->actions[ix];\n    } else {\n\taction = FA_UNKNOWN;\n    }\n    return action;\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiArchiveReadToFilePsm",
                        "rpmfiArchiveReadToFilePsm",
                        "int rpmfiArchiveReadToFilePsm(rpmfi fi, FD_t fd, int nodigest, rpmpsm psm) /* <=== rpmfiArchiveReadToFilePsm */ \n{\n    if (fi == NULL || fi->archive == NULL || fd == NULL)\n\treturn -1;\n\n    rpm_loff_t left = rpmfiFSize(fi);\n    const unsigned char * fidigest = NULL;\n    pgpHashAlgo digestalgo = 0;\n    int rc = 0;\n    char buf[BUFSIZ*4];\n\n    if (!nodigest) {\n\tdigestalgo = rpmfiDigestAlgo(fi);\n\tfidigest = rpmfilesFDigest(fi->files, rpmfiFX(fi), NULL, NULL);\n\tfdInitDigest(fd, digestalgo, 0);\n    }\n\n    while (left) {\n\tsize_t len;\n\tlen = (left > sizeof(buf) ? sizeof(buf) : left);\n\tif (rpmcpioRead(fi->archive, buf, len) != len) {\n\t    rc = RPMERR_READ_FAILED;\n\t    goto exit;\n\t}\n\tif ((Fwrite(buf, sizeof(*buf), len, fd) != len) || Ferror(fd)) {\n\t    rc = RPMERR_WRITE_FAILED;\n\t    goto exit;\n\t}\n\n\trpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tleft -= len;\n    }\n\n    if (!nodigest) {\n\tvoid * digest = NULL;\n\n\t(void) Fflush(fd);\n\tfdFiniDigest(fd, digestalgo, &digest, NULL, 0);\n\n\tif (digest != NULL && fidigest != NULL) {\n\t    size_t diglen = rpmDigestLength(digestalgo);\n\t    if (memcmp(digest, fidigest, diglen)) {\n\t\trc = RPMERR_DIGEST_MISMATCH;\n\n\t\t/* ...but in old packages, empty files have zeros for digest */\n\t\tif (rpmfiFSize(fi) == 0 && digestalgo == PGPHASHALGO_MD5) {\n\t\t    uint8_t zeros[diglen];\n\t\t    memset(&zeros, 0, diglen);\n\t\t    if (memcmp(zeros, fidigest, diglen) == 0)\n\t\t\trc = 0;\n\t\t}\n\t    }\n\t} else {\n\t    rc = RPMERR_DIGEST_MISMATCH;\n\t}\n\tfree(digest);\n    }\n\nexit:\n    return rc;\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesBN",
                        "rpmfilesBN",
                        "const char * rpmfilesBN(rpmfiles fi, int ix) /* <=== rpmfilesBN */ \n{\n    return (fi != NULL) ? rpmfnBN(fi->pool, &fi->fndata, ix) : NULL;\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFMode",
                        "rpmfilesFMode",
                        "rpm_mode_t rpmfilesFMode(rpmfiles fi, int ix) /* <=== rpmfilesFMode */ \n{\n    rpm_mode_t fmode = 0;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->fmodes != NULL)\n\t    fmode = fi->fmodes[ix];\n    }\n    return fmode;\n}",
                        2
                    ],
                    [
                        "lib/rpmplugins.c",
                        "rpmpluginsNew",
                        "rpmpluginsNew",
                        "rpmPlugins rpmpluginsNew(rpmts ts) /* <=== rpmpluginsNew */ \n{\n    rpmPlugins plugins = xcalloc(1, sizeof(*plugins));\n    plugins->ts = ts;\n    return plugins;\n}",
                        2
                    ],
                    [
                        "lib/rpmug.c",
                        "rpmugUid",
                        "rpmugUid",
                        "int rpmugUid(const char * thisUname, uid_t * uid) /* <=== rpmugUid */ \n{\n    static char * lastUname = NULL;\n    static size_t lastUnameLen = 0;\n    static size_t lastUnameAlloced;\n    static uid_t lastUid;\n    struct passwd * pwent;\n    size_t thisUnameLen;\n\n    if (!thisUname) {\n\tlastUnameLen = 0;\n\treturn -1;\n    } else if (rstreq(thisUname, UID_0_USER)) {\n\t*uid = 0;\n\treturn 0;\n    }\n\n    thisUnameLen = strlen(thisUname);\n    if (lastUname == NULL || thisUnameLen != lastUnameLen ||\n\t!rstreq(thisUname, lastUname))\n    {\n\tif (lastUnameAlloced < thisUnameLen + 1) {\n\t    lastUnameAlloced = thisUnameLen + 10;\n\t    lastUname = xrealloc(lastUname, lastUnameAlloced);\t/* XXX memory leak */\n\t}\n\tstrcpy(lastUname, thisUname);\n\n\tpwent = getpwnam(thisUname);\n\tif (pwent == NULL) {\n\t    /* FIX: shrug */\n\t    endpwent();\n\t    pwent = getpwnam(thisUname);\n\t    if (pwent == NULL) return -1;\n\t}\n\n\tlastUid = pwent->pw_uid;\n    }\n\n    *uid = lastUid;\n\n    return 0;\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesLink",
                        "rpmfilesLink",
                        "rpmfiles rpmfilesLink(rpmfiles fi) /* <=== rpmfilesLink */ \n{\n    if (fi)\n\tfi->nrefs++;\n    return fi;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmChown",
                        "fsmChown",
                        "static int fsmChown(int fd, int dirfd, const char *path, mode_t mode, uid_t uid, gid_t gid) /* <=== fsmChown */ \n{\n    int rc;\n    struct stat st;\n\n    if (fd >= 0) {\n\trc = fchown(fd, uid, gid);\n\tif (rc < 0) {\n\t    if (fstat(fd, &st) == 0 && (st.st_uid == uid && st.st_gid == gid)) {\n\t\trc = 0;\n\t    }\n\t}\n    } else {\n\tint flags = S_ISLNK(mode) ? AT_SYMLINK_NOFOLLOW : 0;\n\trc = fchownat(dirfd, path, uid, gid, flags);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstatat(dirfd, path, &st, flags) == 0 &&\n\t\t    (st.st_uid == uid && st.st_gid == gid)) {\n\t\trc = 0;\n\t    }\n\t}\n    }\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, %d, %d) %s\\n\", __func__,\n\t       fd, dirfd, path, (int)uid, (int)gid,\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    if (rc < 0)\trc = RPMERR_CHOWN_FAILED;\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/rpmplugins.c",
                        "rpmpluginsCallFsmFilePre",
                        "rpmpluginsCallFsmFilePre",
                        "rpmRC rpmpluginsCallFsmFilePre(rpmPlugins plugins, rpmfi fi, const char *path, /* <=== rpmpluginsCallFsmFilePre */ \n\t\t\t       mode_t file_mode, rpmFsmOp op)\n{\n    plugin_fsm_file_pre_func hookFunc;\n    int i;\n    rpmRC rc = RPMRC_OK;\n\n    for (i = 0; i < plugins->count; i++) {\n\trpmPlugin plugin = plugins->plugins[i];\n\tRPMPLUGINS_SET_HOOK_FUNC(fsm_file_pre);\n\tif (hookFunc && hookFunc(plugin, fi, path, file_mode, op) == RPMRC_FAIL) {\n\t    rpmlog(RPMLOG_ERR, \"Plugin %s: hook fsm_file_pre failed\\n\", plugin->name);\n\t    rc = RPMRC_FAIL;\n\t}\n    }\n\n    return rc;\n}",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmSymlink",
                        "fsmSymlink",
                        "static int fsmSymlink(const char *opath, int dirfd, const char *path) /* <=== fsmSymlink */ \n{\n    int rc = symlinkat(opath, dirfd, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %d %s) %s\\n\", __func__,\n\t       opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_SYMLINK_FAILED;\n    return rc;\n}",
                        1
                    ],
                    [
                        "lib/rpmte.c",
                        "rpmteGetFileStates",
                        "rpmteGetFileStates",
                        "rpmfs rpmteGetFileStates(rpmte te) /* <=== rpmteGetFileStates */ \n{\n    return te->fs;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.addressOf",
                        "<operator>.addressOf",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "_dirPerms",
                        "lib/fsm.c:41:41:_dirPerms:0",
                        "#define _dirPerms 0755 /* <=== lib/fsm.c:41:41:_dirPerms:0 */ ",
                        2
                    ],
                    [
                        "rpmio/rpmstring.c",
                        "rstrscat",
                        "rstrscat",
                        "char *rstrscat(char **dest, const char *arg, ...) /* <=== rstrscat */ \n{\n    va_list ap;\n    size_t arg_size, dst_size;\n    const char *s;\n    char *dst, *p;\n\n    dst = dest ? *dest : NULL;\n\n    if ( arg == NULL ) {\n        return dst;\n    }\n\n    va_start(ap, arg);\n    for (arg_size=0, s=arg; s; s = va_arg(ap, const char *))\n        arg_size += strlen(s);\n    va_end(ap);\n\n    dst_size = dst ? strlen(dst) : 0;\n    dst = xrealloc(dst, dst_size+arg_size+1);    /* include '\\0' */\n    p = &dst[dst_size];\n\n    va_start(ap, arg);\n    for (s = arg; s; s = va_arg(ap, const char *)) {\n        size_t size = strlen(s);\n        memmove(p, s, size);\n        p += size;\n    }\n    va_end(ap);\n    *p = '\\0';\n\n    if ( dest ) {\n        *dest = dst;\n    }\n\n    return dst;\n}",
                        2
                    ],
                    [
                        "rpmio/system.h",
                        "xrealloc",
                        "rpmio/system.h:69:69:xrealloc:2",
                        "",
                        3
                    ],
                    [
                        "<empty>",
                        "strlen",
                        "strlen",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFLink",
                        "rpmfiFLink",
                        "RPMFI_ITERFUNC(const char *, FLink, i) /* <=== rpmfiFLink */ ",
                        1
                    ],
                    [
                        "rpmio/rpmstring.h",
                        "rstreqn",
                        "rstreqn",
                        "static inline int rstreqn(const char *s1, const char *s2, size_t n) /* <=== rstreqn */ \n{\n    return (strncmp(s1, s2, n) == 0);\n}",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmVerify",
                        "fsmVerify",
                        "static int fsmVerify(int dirfd, const char *path, rpmfi fi) /* <=== fsmVerify */ \n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(dirfd, path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(dirfd, path, dirfd, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(dirfd, rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(dirfd, path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == dsb.st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(dirfd, path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalOr",
                        "<operator>.logicalOr",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "S_ISREG",
                        "S_ISREG",
                        "",
                        1
                    ],
                    [
                        "lib/rpmte.c",
                        "rpmteKey",
                        "rpmteKey",
                        "fnpyKey rpmteKey(rpmte te) /* <=== rpmteKey */ \n{\n    return (te != NULL ? te->key : NULL);\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmIterFini",
                        "fsmIterFini",
                        "static rpmfi fsmIterFini(rpmfi fi, struct diriter_s *di) /* <=== fsmIterFini */ \n{\n    close(di->dirfd);\n    di->dirfd = -1;\n    return rpmfiFree(fi);\n}",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmRmdir",
                        "fsmRmdir",
                        "static int fsmRmdir(int dirfd, const char *path) /* <=== fsmRmdir */ \n{\n    int rc = unlinkat(dirfd, path, AT_REMOVEDIR);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s) %s\\n\", __func__,\n\t       dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFC",
                        "rpmfilesFC",
                        "rpm_count_t rpmfilesFC(rpmfiles fi) /* <=== rpmfilesFC */ \n{\n    return (fi != NULL ? rpmfnFC(&fi->fndata) : 0);\n}",
                        1
                    ],
                    [
                        "rpmio/rpmlog.c",
                        "rpmlogCtxAcquire",
                        "rpmlogCtxAcquire",
                        "static rpmlogCtx rpmlogCtxAcquire(int write) /* <=== rpmlogCtxAcquire */ \n{\n    static struct rpmlogCtx_s _globalCtx = { PTHREAD_RWLOCK_INITIALIZER,\n\t\t\t\t\t     RPMLOG_UPTO(RPMLOG_NOTICE),\n\t\t\t\t\t     0, {0}, NULL, NULL, NULL, NULL };\n    rpmlogCtx ctx = &_globalCtx;\n    int xx;\n\n    /* XXX Silently failing is bad, but we can't very well use log here... */\n    if (write)\n\txx = pthread_rwlock_wrlock(&ctx->lock);\n    else\n\txx = pthread_rwlock_rdlock(&ctx->lock);\n\n    return (xx == 0) ? ctx : NULL;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmClose",
                        "fsmClose",
                        "static int fsmClose(int *wfdp) /* <=== fsmClose */ \n{\n    int rc = 0;\n    if (wfdp && *wfdp >= 0) {\n\tint myerrno = errno;\n\tstatic int oneshot = 0;\n\tstatic int flush_io = 0;\n\tint fdno = *wfdp;\n\n\tif (!oneshot) {\n\t    flush_io = (rpmExpandNumeric(\"%{?_flush_io}\") > 0);\n\t    oneshot = 1;\n\t}\n\tif (flush_io) {\n\t    fsync(fdno);\n\t}\n\tif (close(fdno))\n\t    rc = RPMERR_CLOSE_FAILED;\n\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s ([%d]) %s\\n\", __func__,\n\t\t   fdno, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\t*wfdp = -1;\n\terrno = myerrno;\n    }\n    return rc;\n}",
                        1
                    ],
                    [
                        "lib/system.h",
                        "_free",
                        "lib/system.h:72:72:_free:1",
                        "",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.assignment",
                        "<operator>.assignment",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmBackup",
                        "fsmBackup",
                        "static int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action) /* <=== fsmBackup */ \n{\n    int rc = 0;\n    const char *suffix = NULL;\n\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(dirfd, opath, dirfd, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmOpen",
                        "fsmOpen",
                        "static int fsmOpen(int *wfdp, int dirfd, const char *dest) /* <=== fsmOpen */ \n{\n    int rc = 0;\n    /* Create the file with 0200 permissions (write by owner). */\n    int fd = openat(dirfd, dest, O_WRONLY|O_EXCL|O_CREAT, 0200);\n\n    if (fd < 0)\n\trc = RPMERR_OPEN_FAILED;\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s [%d]) %s\\n\", __func__,\n\t       dest, fd, (rc < 0 ? strerror(errno) : \"\"));\n    }\n    *wfdp = fd;\n\n    return rc;\n}",
                        2
                    ],
                    [
                        "rpmio/rpmmalloc.c",
                        "rmalloc",
                        "rmalloc",
                        "void * rmalloc (size_t size) /* <=== rmalloc */ \n{\n    register void *value;\n    if (size == 0) size++;\n    value = malloc (size);\n    if (value == NULL)\n\tvalue = vmefail(size);\n    return value;\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiNewArchiveReader",
                        "rpmfiNewArchiveReader",
                        "rpmfi rpmfiNewArchiveReader(FD_t fd, rpmfiles files, int itype) /* <=== rpmfiNewArchiveReader */ \n{\n    rpmcpio_t archive = rpmcpioOpen(fd, O_RDONLY);\n    rpmfi fi = NULL;\n    if (archive && itype >= RPMFI_ITER_READ_ARCHIVE) {\n\tfi = rpmfilesIter(files, itype);\n    }\n    if (fi) {\n\tfi->archive = archive;\n    } else {\n\trpmcpioFree(archive);\n    }\n    return fi;\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.indirection",
                        "<operator>.indirection",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFMode",
                        "rpmfiFMode",
                        "RPMFI_ITERFUNC(rpm_mode_t, FMode, i) /* <=== rpmfiFMode */ ",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.subtraction",
                        "<operator>.subtraction",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.conditional",
                        "<operator>.conditional",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmReadLink",
                        "fsmReadLink",
                        "static int fsmReadLink(const char *path, /* <=== fsmReadLink */ \n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}",
                        2
                    ],
                    [
                        "rpmio/rpmio.c",
                        "fdDup",
                        "fdDup",
                        "FD_t fdDup(int fdno) /* <=== fdDup */ \n{\n    FD_t fd;\n    int nfdno;\n\n    if ((nfdno = dup(fdno)) < 0)\n\treturn NULL;\n    fd = fdNew(nfdno, NULL);\nDBGIO(fd, (stderr, \"==> fdDup(%d) fd %p %s\\n\", fdno, (fd ? fd : NULL), fdbg(fd)));\n    return fd;\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesStat",
                        "rpmfilesStat",
                        "int rpmfilesStat(rpmfiles fi, int ix, int flags, struct stat *sb) /* <=== rpmfilesStat */ \n{\n    int rc = -1;\n    if (fi && sb) {\n\t/* XXX FIXME define proper flags with sane semantics... */\n\tint warn = flags & 0x1;\n\tconst char *user = rpmfilesFUser(fi, ix);\n\tconst char *group = rpmfilesFGroup(fi, ix);\n\n\tmemset(sb, 0, sizeof(*sb));\n\tsb->st_nlink = rpmfilesFLinks(fi, ix, NULL);\n\tsb->st_ino = rpmfilesFInode(fi, ix);\n\tsb->st_rdev = rpmfilesFRdev(fi, ix);\n\tsb->st_mode = rpmfilesFMode(fi, ix);\n\tsb->st_mtime = rpmfilesFMtime(fi, ix);\n\n\t/* Only regular files and symlinks have a size */\n\tif (S_ISREG(sb->st_mode) || S_ISLNK(sb->st_mode))\n\t    sb->st_size = rpmfilesFSize(fi, ix);\n\n\tif (user && rpmugUid(user, &sb->st_uid)) {\n\t    if (warn)\n\t\trpmlog(RPMLOG_WARNING,\n\t\t\t_(\"user %s does not exist - using %s\\n\"), user, UID_0_USER);\n\t    sb->st_mode &= ~S_ISUID;\t  /* turn off suid bit */\n\t}\n\n\tif (group && rpmugGid(group, &sb->st_gid)) {\n\t    if (warn)\n\t\trpmlog(RPMLOG_WARNING,\n\t\t\t_(\"group %s does not exist - using %s\\n\"), group, GID_0_GROUP);\n\t    sb->st_mode &= ~S_ISGID;\t/* turn off sgid bit */\n\t}\n\n\trc = 0;\n    }\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiArchiveHasContent",
                        "rpmfiArchiveHasContent",
                        "int rpmfiArchiveHasContent(rpmfi fi) /* <=== rpmfiArchiveHasContent */ \n{\n    int res = 0;\n    if (fi && S_ISREG(rpmfiFMode(fi))) {\n\tconst int * links;\n\tint nlink = rpmfiFLinks(fi, &links);\n\tif (nlink > 1) {\n\t    if (fi->next == iterReadArchiveNext ||\n\t\tfi->next == iterReadArchiveNextOmitHardlinks) {\n\t\tres = rpmfiFX(fi) == links[nlink-1];\n\t    } else if (fi->next == iterReadArchiveNextContentFirst) {\n\t\tres = rpmfiFX(fi) == links[0];\n\t    }\n\t} else {\n\t    res = 1;\n\t}\n    }\n    return res;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.equals",
                        "<operator>.equals",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiUnlink",
                        "rpmfiUnlink",
                        "static rpmfi rpmfiUnlink(rpmfi fi) /* <=== rpmfiUnlink */ \n{\n    if (fi)\n\tfi->nrefs--;\n    return NULL;\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFRdev",
                        "rpmfiFRdev",
                        "RPMFI_ITERFUNC(rpm_rdev_t, FRdev, i) /* <=== rpmfiFRdev */ ",
                        2
                    ],
                    [
                        "<empty>",
                        "XFA_SKIPPING",
                        "XFA_SKIPPING",
                        "",
                        1
                    ],
                    [
                        "rpmio/rpmio.c",
                        "Fclose",
                        "Fclose",
                        "int Fclose(FD_t fd) /* <=== Fclose */ \n{\n    int rc = 0, ec = 0;\n\n    if (fd == NULL)\n\treturn -1;\n\n    fd = fdLink(fd);\n    fdstat_enter(fd, FDSTAT_CLOSE);\n    for (FDSTACK_t fps = fd->fps; fps != NULL; fps = fdPop(fd)) {\n\tif (fps->fdno >= 0) {\n\t    fdio_close_function_t _close = FDIOVEC(fps, close);\n\t    rc = _close ? _close(fps) : -2;\n\n\t    if (ec == 0 && rc)\n\t\tec = rc;\n\t}\n\n\t/* Debugging stats for compresed types */\n\tif ((_rpmio_debug || rpmIsDebug()) && fps->fdno == -1)\n\t    fdstat_print(fd, fps->io->ioname, stderr);\n\n\t/* Leave freeing the last one after stats */\n\tif (fps->prev == NULL)\n\t    break;\n    }\n    fdstat_exit(fd, FDSTAT_CLOSE, rc);\n    DBGIO(fd, (stderr, \"==>\\tFclose(%p) rc %lx %s\\n\",\n\t  (fd ? fd : NULL), (unsigned long)rc, fdbg(fd)));\n    fdPop(fd);\n\n    fdFree(fd);\n    return ec;\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "S_ISDIR",
                        "S_ISDIR",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "IS_DEV_LOG",
                        "lib/fsm.c:666:670:IS_DEV_LOG:1",
                        "#define\tIS_DEV_LOG(_x)\t\\ /* <=== lib/fsm.c:666:670:IS_DEV_LOG:1 */ \n\t((_x) != NULL && strlen(_x) >= (sizeof(\"/dev/log\")-1) && \\\n\trstreqn((_x), \"/dev/log\", sizeof(\"/dev/log\")-1) && \\\n\t((_x)[sizeof(\"/dev/log\")-1] == '\\0' || \\\n\t (_x)[sizeof(\"/dev/log\")-1] == ';'))",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFN",
                        "rpmfilesFN",
                        "char * rpmfilesFN(rpmfiles fi, int ix) /* <=== rpmfilesFN */ \n{\n    return (fi != NULL) ? rpmfnFN(fi->pool, &fi->fndata, ix) : NULL;\n}",
                        3
                    ],
                    [
                        "lib/cpio.c",
                        "rpmcpioFree",
                        "rpmcpioFree",
                        "rpmcpio_t rpmcpioFree(rpmcpio_t cpio) /* <=== rpmcpioFree */ \n{\n    if (cpio) {\n\tif (cpio->fd)\n\t    (void) rpmcpioClose(cpio);\n\tfree(cpio);\n    }\n    return NULL;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "SUFFIX_RPMNEW",
                        "lib/fsm.c:38:38:SUFFIX_RPMNEW:0",
                        "#define\tSUFFIX_RPMNEW\t\".rpmnew\" /* <=== lib/fsm.c:38:38:SUFFIX_RPMNEW:0 */ ",
                        2
                    ],
                    [
                        "rpmio/macro.c",
                        "rpmExpand",
                        "rpmExpand",
                        "char *  /* <=== rpmExpand */ \nrpmExpand(const char *arg, ...)\n{\n    size_t blen = 0;\n    char *buf = NULL, *ret = NULL;\n    char *pe;\n    const char *s;\n    va_list ap;\n    rpmMacroContext mc;\n\n    if (arg == NULL) {\n\tret = xstrdup(\"\");\n\tgoto exit;\n    }\n\n    /* precalculate unexpanded size */\n    va_start(ap, arg);\n    for (s = arg; s != NULL; s = va_arg(ap, const char *))\n\tblen += strlen(s);\n    va_end(ap);\n\n    buf = xmalloc(blen + 1);\n    buf[0] = '\\0';\n\n    va_start(ap, arg);\n    for (pe = buf, s = arg; s != NULL; s = va_arg(ap, const char *))\n\tpe = stpcpy(pe, s);\n    va_end(ap);\n\n    mc = rpmmctxAcquire(NULL);\n    (void) doExpandMacros(mc, buf, 0, &ret);\n    rpmmctxRelease(mc);\n\n    free(buf);\nexit:\n    return ret;\n}",
                        3
                    ],
                    [
                        "lib/rpmts.c",
                        "rpmtsFlags",
                        "rpmtsFlags",
                        "rpmtransFlags rpmtsFlags(rpmts ts) /* <=== rpmtsFlags */ \n{\n    return (ts != NULL ? ts->transFlags : 0);\n}",
                        1
                    ],
                    [
                        "rpmio/rpmlog.c",
                        "rpmlogDefault",
                        "rpmlogDefault",
                        "static int rpmlogDefault(FILE *stdlog, rpmlogRec rec) /* <=== rpmlogDefault */ \n{\n    FILE *msgout = (stdlog ? stdlog : stderr);\n    static __thread int color = -1;\n    const char * colorOn = NULL;\n\n    if (color < 0)\n\tcolor = getColorConfig();\n\n    if (color == COLOR_ALWAYS ||\n\t    (color == COLOR_AUTO && isatty(fileno(msgout))))\n\tcolorOn = rpmlogLevelColor(rec->pri);\n\n    switch (rec->pri) {\n    case RPMLOG_INFO:\n    case RPMLOG_NOTICE:\n\tmsgout = (stdlog ? stdlog : stdout);\n\tbreak;\n    case RPMLOG_EMERG:\n    case RPMLOG_ALERT:\n    case RPMLOG_CRIT:\n    case RPMLOG_ERR:\n    case RPMLOG_WARNING:\n    case RPMLOG_DEBUG:\n\tif (colorOn && *colorOn)\n\t    if (fputs(rpmlogLevelColor(rec->pri), msgout) == EOF)\n\t\tlogerror();\n\tbreak;\n    default:\n\tbreak;\n    }\n\n    if (fputs(rpmlogLevelPrefix(rec->pri), msgout) == EOF)\n\tlogerror();\n\n    switch (rec->pri) {\n    case RPMLOG_INFO:\n    case RPMLOG_NOTICE:\n\tbreak;\n    case RPMLOG_EMERG:\n    case RPMLOG_ALERT:\n    case RPMLOG_CRIT:\n    case RPMLOG_ERR:\n    case RPMLOG_WARNING:\n\tif (colorOn && *colorOn) {\n\t    if (fputs(ANSI_COLOR_RESET, msgout) == EOF)\n\t\tlogerror();\n\t    if (fputs(ANSI_COLOR_BOLD, msgout) == EOF)\n\t\tlogerror();\n\t}\n    case RPMLOG_DEBUG:\n    default:\n\tbreak;\n    }\n\n    if (rec->message)\n\tif (fputs(rec->message, msgout) == EOF)\n\t    logerror();\n\n    switch (rec->pri) {\n    case RPMLOG_INFO:\n    case RPMLOG_NOTICE:\n\tbreak;\n    case RPMLOG_EMERG:\n    case RPMLOG_ALERT:\n    case RPMLOG_CRIT:\n    case RPMLOG_ERR:\n    case RPMLOG_WARNING:\n    case RPMLOG_DEBUG:\n\tif (colorOn && *colorOn)\n\t    if (fputs(ANSI_COLOR_RESET, msgout) == EOF)\n\t\tlogerror();\n\tbreak;\n    default:\n\tbreak;\n    }\n\n    if (fflush(msgout) == EOF)\n\tlogerror();\n\n    return (rec->pri <= RPMLOG_CRIT ? RPMLOG_EXIT : 0);\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "<operator>.fieldAccess",
                        "<operator>.fieldAccess",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmMknod",
                        "fsmMknod",
                        "static int fsmMknod(int dirfd, const char *path, mode_t mode, dev_t dev) /* <=== fsmMknod */ \n{\n    /* FIX: check S_IFIFO or dev != 0 */\n    int rc = mknodat(dirfd, path, (mode & ~07777), dev);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%o, 0x%x) %s\\n\",\n\t       __func__, dirfd, path, (unsigned)(mode & ~07777),\n\t       (unsigned)dev, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKNOD_FAILED;\n\n    return rc;\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFX",
                        "rpmfiFX",
                        "int rpmfiFX(rpmfi fi) /* <=== rpmfiFX */ \n{\n    return (fi != NULL ? fi->i : -1);\n}",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "fsmUtime",
                        "fsmUtime",
                        "static int fsmUtime(int fd, int dirfd, const char *path, mode_t mode, time_t mtime) /* <=== fsmUtime */ \n{\n    int rc = 0;\n    struct timespec stamps[2] = {\n\t{ .tv_sec = mtime, .tv_nsec = 0 },\n\t{ .tv_sec = mtime, .tv_nsec = 0 },\n    };\n\n    if (fd >= 0)\n\trc = futimens(fd, stamps);\n    else\n\trc = utimensat(dirfd, path, stamps, AT_SYMLINK_NOFOLLOW);\n    \n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, 0x%x) %s\\n\", __func__,\n\t       fd, dirfd, path, (unsigned)mtime, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_UTIME_FAILED;\n    /* ...but utime error is not critical for directories */\n    if (rc && S_ISDIR(mode))\n\trc = 0;\n    return rc;\n}",
                        2
                    ],
                    [
                        "rpmio/rpmmalloc.c",
                        "rstrdup",
                        "rstrdup",
                        "char * rstrdup (const char *str) /* <=== rstrdup */ \n{\n    return rstrndup(str, strlen(str));\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFSize",
                        "rpmfilesFSize",
                        "rpm_loff_t rpmfilesFSize(rpmfiles fi, int ix) /* <=== rpmfilesFSize */ \n{\n    rpm_loff_t fsize = 0;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->fsizes != NULL)\n\t    fsize = fi->fsizes[ix];\n\telse if (fi->lfsizes != NULL)\n\t    fsize = fi->lfsizes[ix];\n    }\n    return fsize;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "removeSBITS",
                        "removeSBITS",
                        "static void removeSBITS(const char *path) /* <=== removeSBITS */ \n{\n    struct stat stb;\n    if (lstat(path, &stb) == 0 && S_ISREG(stb.st_mode)) {\n\tif ((stb.st_mode & 06000) != 0) {\n\t    (void) chmod(path, stb.st_mode & 0777);\n\t}\n#if WITH_CAP\n\tif (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\t    (void) cap_set_file(path, NULL);\n\t}\n#endif\n    }\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmUnlink",
                        "fsmUnlink",
                        "static int fsmUnlink(int dirfd, const char *path) /* <=== fsmUnlink */ \n{\n    int rc = 0;\n    removeSBITS(path);\n    rc = unlinkat(dirfd, path, 0);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s) %s\\n\", __func__,\n\t       dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_UNLINK_FAILED);\n    return rc;\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.notEquals",
                        "<operator>.notEquals",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.sizeOf",
                        "<operator>.sizeOf",
                        "",
                        1
                    ],
                    [
                        "lib/rpmplugins.c",
                        "rpmpluginsCallFsmFilePost",
                        "rpmpluginsCallFsmFilePost",
                        "rpmRC rpmpluginsCallFsmFilePost(rpmPlugins plugins, rpmfi fi, const char *path, /* <=== rpmpluginsCallFsmFilePost */ \n                                mode_t file_mode, rpmFsmOp op, int res)\n{\n    plugin_fsm_file_post_func hookFunc;\n    int i;\n    rpmRC rc = RPMRC_OK;\n\n    for (i = 0; i < plugins->count; i++) {\n\trpmPlugin plugin = plugins->plugins[i];\n\tRPMPLUGINS_SET_HOOK_FUNC(fsm_file_post);\n\tif (hookFunc && hookFunc(plugin, fi, path, file_mode, op, res) == RPMRC_FAIL) {\n\t    rpmlog(RPMLOG_WARNING, \"Plugin %s: hook fsm_file_post failed\\n\", plugin->name);\n\t}\n    }\n\n    return rc;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "S_ISSOCK",
                        "S_ISSOCK",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFCaps",
                        "rpmfilesFCaps",
                        "const char * rpmfilesFCaps(rpmfiles fi, int ix) /* <=== rpmfilesFCaps */ \n{\n    const char *fcaps = NULL;\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tfcaps = fi->fcaps ? fi->fcaps[ix] : \"\";\n    }\n    return fcaps;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmChmod",
                        "fsmChmod",
                        "static int fsmChmod(int fd, int dirfd, const char *path, mode_t mode) /* <=== fsmChmod */ \n{\n    mode_t fmode = (mode & 07777);\n    int rc;\n    if (fd >= 0) {\n\trc = fchmod(fd, fmode);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstat(fd, &st) == 0 && (st.st_mode & 07777) == fmode) {\n\t\trc = 0;\n\t    }\n\t}\n    } else {\n\trc = fchmodat(dirfd, path, fmode, 0);\n\tif (rc < 0) {\n\t    struct stat st;\n\t    if (fstatat(dirfd, path, &st, AT_SYMLINK_NOFOLLOW) == 0 &&\n\t\t    (st.st_mode & 07777) == fmode) {\n\t\trc = 0;\n\t    }\n\t}\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, 0%04o) %s\\n\", __func__,\n\t       fd, dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHMOD_FAILED;\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFMtime",
                        "rpmfilesFMtime",
                        "rpm_time_t rpmfilesFMtime(rpmfiles fi, int ix) /* <=== rpmfilesFMtime */ \n{\n    rpm_time_t fmtime = 0;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->fmtimes != NULL)\n\t    fmtime = fi->fmtimes[ix];\n    }\n    return fmtime;\n}",
                        3
                    ],
                    [
                        "lib/rpmts.c",
                        "rpmtsNotify",
                        "rpmtsNotify",
                        "void * rpmtsNotify(rpmts ts, rpmte te, /* <=== rpmtsNotify */ \n\t\trpmCallbackType what, rpm_loff_t amount, rpm_loff_t total)\n{\n    void * ptr = NULL;\n    if (ts && ts->notify) {\n\tvoid *arg = NULL;\n\tHeader h = NULL;\n\tfnpyKey cbkey = NULL;\n\tif (te) {\n\t    if (ts->notifyStyle == 0) {\n\t\th = rpmteHeader(te);\n\t\targ = h;\n\t    } else {\n\t\targ = te;\n\t    }\n\t    cbkey = rpmteKey(te);\n\t}\n\tptr = ts->notify(arg, what, amount, total, cbkey, ts->notifyData);\n\n\tif (h) {\n\t    headerFree(h); /* undo rpmteHeader() ref */\n\t}\n    }\n    return ptr;\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.logicalNot",
                        "<operator>.logicalNot",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.cast",
                        "<operator>.cast",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.arrayInitializer",
                        "<operator>.arrayInitializer",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmLink",
                        "fsmLink",
                        "static int fsmLink(int odirfd, const char *opath, int dirfd, const char *path) /* <=== fsmLink */ \n{\n    int rc = linkat(odirfd, opath, dirfd, path, 0);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, %d %s) %s\\n\", __func__,\n\t       odirfd, opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_LINK_FAILED;\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/system.h",
                        "_",
                        "lib/system.h:98:98:_:1",
                        "",
                        2
                    ],
                    [
                        "lib/rpmte.c",
                        "rpmteHeader",
                        "rpmteHeader",
                        "Header rpmteHeader(rpmte te) /* <=== rpmteHeader */ \n{\n    return (te != NULL && te->h != NULL ? headerLink(te->h) : NULL);\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiSetOnChdir",
                        "rpmfiSetOnChdir",
                        "int rpmfiSetOnChdir(rpmfi fi, rpmfiChdirCb cb, void *data) /* <=== rpmfiSetOnChdir */ \n{\n    int rc = -1;\n    if (fi != NULL) {\n\tfi->onChdir = cb;\n\tfi->onChdirData = data;\n\trc = 0;\n    }\n    return rc;\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.greaterThan",
                        "<operator>.greaterThan",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesDI",
                        "rpmfilesDI",
                        "int rpmfilesDI(rpmfiles fi, int ix) /* <=== rpmfilesDI */ \n{\n    return (fi != NULL) ? rpmfnDI(&fi->fndata, ix) : -1;\n}",
                        3
                    ],
                    [
                        "lib/cpio.c",
                        "rpmcpioTell",
                        "rpmcpioTell",
                        "off_t rpmcpioTell(rpmcpio_t cpio) /* <=== rpmcpioTell */ \n{\n    return cpio->offset;\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.indirectFieldAccess",
                        "<operator>.indirectFieldAccess",
                        "",
                        1
                    ],
                    [
                        "lib/system.h",
                        "xstrdup",
                        "lib/system.h:71:71:xstrdup:1",
                        "",
                        1
                    ],
                    [
                        "lib/rpmplugins.c",
                        "rpmpluginsCallFsmFilePrepare",
                        "rpmpluginsCallFsmFilePrepare",
                        "rpmRC rpmpluginsCallFsmFilePrepare(rpmPlugins plugins, rpmfi fi, /* <=== rpmpluginsCallFsmFilePrepare */ \n\t\t\t\t   const char *path, const char *dest,\n\t\t\t\t   mode_t file_mode, rpmFsmOp op)\n{\n    plugin_fsm_file_prepare_func hookFunc;\n    int i;\n    rpmRC rc = RPMRC_OK;\n\n    for (i = 0; i < plugins->count; i++) {\n\trpmPlugin plugin = plugins->plugins[i];\n\tRPMPLUGINS_SET_HOOK_FUNC(fsm_file_prepare);\n\tif (hookFunc && hookFunc(plugin, fi, path, dest, file_mode, op) == RPMRC_FAIL) {\n\t    rpmlog(RPMLOG_ERR, \"Plugin %s: hook fsm_file_prepare failed\\n\", plugin->name);\n\t    rc = RPMRC_FAIL;\n\t}\n    }\n\n    return rc;\n}",
                        2
                    ],
                    [
                        "<empty>",
                        "<operator>.lessThan",
                        "<operator>.lessThan",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFN",
                        "rpmfiFN",
                        "const char * rpmfiFN(rpmfi fi) /* <=== rpmfiFN */ \n{\n    const char *fn = \"\"; /* preserve behavior on errors */\n    if (fi != NULL) {\n\tfree(fi->fn);\n\tfi->fn = rpmfilesFN(fi->files, fi->i);\n\tif (fi->fn != NULL)\n\t    fn = fi->fn;\n    }\n    return fn;\n}",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "fsmCommit",
                        "fsmCommit",
                        "static int fsmCommit(int dirfd, char **path, rpmfi fi, rpmFileAction action, const char *suffix) /* <=== fsmCommit */ \n{\n    int rc = 0;\n\n    /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\t/* Construct final destination path (nsuffix is usually NULL) */\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\n\t/* Rename temporary to final file name if needed. */\n\tif (dest != *path) {\n\t    rc = fsmRename(dirfd, *path, dirfd, dest);\n\t    if (!rc) {\n\t\tif (nsuffix) {\n\t\t    char * opath = fsmFsPath(fi, NULL);\n\t\t    rpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t\t   opath, dest);\n\t\t    free(opath);\n\t\t}\n\t\tfree(*path);\n\t\t*path = dest;\n\t    }\n\t}\n    }\n\n    return rc;\n}",
                        1
                    ],
                    [
                        "rpmio/rpmmalloc.c",
                        "rcalloc",
                        "rcalloc",
                        "void * rcalloc (size_t nmemb, size_t size) /* <=== rcalloc */ \n{\n    register void *value;\n    if (size == 0) size++;\n    if (nmemb == 0) nmemb++;\n    value = calloc (nmemb, size);\n    if (value == NULL)\n\tvalue = vmefail(size);\n    return value;\n}",
                        3
                    ],
                    [
                        "rpmio/rpmmalloc.c",
                        "rrealloc",
                        "rrealloc",
                        "void * rrealloc (void *ptr, size_t size) /* <=== rrealloc */ \n{\n    register void *value;\n    if (size == 0) size++;\n    value = realloc (ptr, size);\n    if (value == NULL)\n\tvalue = vmefail(size);\n    return value;\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "<operators>.assignmentOr",
                        "<operators>.assignmentOr",
                        "",
                        1
                    ],
                    [
                        "<empty>",
                        "S_ISFIFO",
                        "S_ISFIFO",
                        "",
                        1
                    ],
                    [
                        "lib/fsm.c",
                        "fsmRename",
                        "fsmRename",
                        "static int fsmRename(int odirfd, const char *opath, int dirfd, const char *path) /* <=== fsmRename */ \n{\n    removeSBITS(path);\n    int rc = renameat(odirfd, opath, dirfd, path);\n#if defined(ETXTBSY) && defined(__HPUX__)\n    /* XXX HP-UX (and other os'es) don't permit rename to busy files. */\n    if (rc && errno == ETXTBSY) {\n\tchar *rmpath = NULL;\n\trstrscat(&rmpath, path, \"-RPMDELETE\", NULL);\n\t/* Rename within the original directory */\n\trc = renameat(odirfd, path, odirfd, rmpath);\n\tif (!rc) rc = renameat(odirfd, opath, dirfd, path);\n\tfree(rmpath);\n    }\n#endif\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, %d %s) %s\\n\", __func__,\n\t       odirfd, opath, dirfd, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == EISDIR ? RPMERR_EXIST_AS_DIR : RPMERR_RENAME_FAILED);\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/rpmplugins.c",
                        "RPMPLUGINS_SET_HOOK_FUNC",
                        "lib/rpmplugins.c:209:215:RPMPLUGINS_SET_HOOK_FUNC:1",
                        "#define RPMPLUGINS_SET_HOOK_FUNC(hook) \\ /* <=== lib/rpmplugins.c:209:215:RPMPLUGINS_SET_HOOK_FUNC:1 */ \n\trpmPluginHooks hooks = (plugin != NULL) ? plugin->hooks : NULL; \\\n\thookFunc = (hooks != NULL) ? hooks->hook : NULL; \\\n\tif (hookFunc) { \\\n\t    rpmlog(RPMLOG_DEBUG, \"Plugin: calling hook %s in %s plugin\\n\", \\\n\t\t   STR(hook), plugin->name); \\\n\t}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFFlags",
                        "rpmfiFFlags",
                        "RPMFI_ITERFUNC(rpmfileAttrs, FFlags, i) /* <=== rpmfiFFlags */ ",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFRdev",
                        "rpmfilesFRdev",
                        "rpm_rdev_t rpmfilesFRdev(rpmfiles fi, int ix) /* <=== rpmfilesFRdev */ \n{\n    rpm_rdev_t frdev = 0;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->frdevs != NULL)\n\t    frdev = fi->frdevs[ix];\n    }\n    return frdev;\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "initIter",
                        "initIter",
                        "static rpmfi initIter(rpmfiles files, int itype, int link) /* <=== initIter */ \n{\n    rpmfi fi = NULL;\n\n    if (files && itype>=0 && itype<=RPMFILEITERMAX) {\n\tfi = xcalloc(1, sizeof(*fi)); \n\tfi->i = -1;\n\tfi->j = -1;\n\tfi->files = link ? rpmfilesLink(files) : files;\n\tfi->next = nextfuncs[itype];\n\tif (itype == RPMFI_ITER_BACK) {\n\t    fi->i = rpmfilesFC(fi->files);\n\t} else if (itype >=RPMFI_ITER_READ_ARCHIVE\n\t    && itype <= RPMFI_ITER_READ_ARCHIVE_OMIT_HARDLINKS) {\n\n\t    fi->found = xcalloc(1, (rpmfiFC(fi)>>3) + 1);\n\t}\n\trpmfiLink(fi);\n    }\n    return fi;\n}",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "SUFFIX_RPMSAVE",
                        "lib/fsm.c:37:37:SUFFIX_RPMSAVE:0",
                        "#define\tSUFFIX_RPMSAVE\t\".rpmsave\" /* <=== lib/fsm.c:37:37:SUFFIX_RPMSAVE:0 */ ",
                        2
                    ],
                    [
                        "rpmio/rpmmalloc.c",
                        "rfree",
                        "rfree",
                        "void * rfree (void *ptr) /* <=== rfree */ \n{\n    free(ptr);\n    return NULL;\n}",
                        3
                    ],
                    [
                        "rpmio/rpmstrpool.c",
                        "rpmstrPoolStr",
                        "rpmstrPoolStr",
                        "const char * rpmstrPoolStr(rpmstrPool pool, rpmsid sid) /* <=== rpmstrPoolStr */ \n{\n    const char *s = NULL;\n    if (pool) {\n\tpoolLock(pool, 0);\n\ts = id2str(pool, sid);\n\tpoolUnlock(pool);\n    }\n    return s;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fileActionString",
                        "fileActionString",
                        "static const char * fileActionString(rpmFileAction a) /* <=== fileActionString */ \n{\n    switch (a) {\n    case FA_UNKNOWN:\treturn \"unknown\";\n    case FA_CREATE:\treturn \"create\";\n    case FA_BACKUP:\treturn \"backup\";\n    case FA_SAVE:\treturn \"save\";\n    case FA_SKIP:\treturn \"skip\";\n    case FA_ALTNAME:\treturn \"altname\";\n    case FA_ERASE:\treturn \"erase\";\n    case FA_SKIPNSTATE: return \"skipnstate\";\n    case FA_SKIPNETSHARED: return \"skipnetshared\";\n    case FA_SKIPCOLOR:\treturn \"skipcolor\";\n    case FA_TOUCH:     return \"touch\";\n    default:\t\treturn \"???\";\n    }\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesDN",
                        "rpmfilesDN",
                        "const char * rpmfilesDN(rpmfiles fi, int jx) /* <=== rpmfilesDN */ \n{\n    return (fi != NULL) ? rpmfnDN(fi->pool, &fi->fndata, jx) : NULL;\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiBN",
                        "rpmfiBN",
                        "RPMFI_ITERFUNC(const char *, BN, i) /* <=== rpmfiBN */ ",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFLink",
                        "rpmfilesFLink",
                        "const char * rpmfilesFLink(rpmfiles fi, int ix) /* <=== rpmfilesFLink */ \n{\n    const char * flink = NULL;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->flinks != NULL)\n\t    flink = rpmstrPoolStr(fi->pool, fi->flinks[ix]);\n    }\n    return flink;\n}",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "SUFFIX_RPMORIG",
                        "lib/fsm.c:36:36:SUFFIX_RPMORIG:0",
                        "#define\tSUFFIX_RPMORIG\t\".rpmorig\" /* <=== lib/fsm.c:36:36:SUFFIX_RPMORIG:0 */ ",
                        2
                    ],
                    [
                        "<empty>",
                        "<operators>.assignmentAnd",
                        "<operators>.assignmentAnd",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFGroup",
                        "rpmfilesFGroup",
                        "const char * rpmfilesFGroup(rpmfiles fi, int ix) /* <=== rpmfilesFGroup */ \n{\n    const char * fgroup = NULL;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->fgroup != NULL)\n\t    fgroup = rpmstrPoolStr(fi->pool, fi->fgroup[ix]);\n    }\n    return fgroup;\n}",
                        3
                    ],
                    [
                        "<empty>",
                        "S_ISBLK",
                        "S_ISBLK",
                        "",
                        1
                    ],
                    [
                        "rpmio/rpmmalloc.c",
                        "rstrndup",
                        "rstrndup",
                        "char * rstrndup(const char *str, size_t n) /* <=== rstrndup */ \n{\n    size_t size = n + 1;\n    char *newstr = (char *) malloc (size);\n    if (newstr == NULL)\n\tnewstr = (char *) vmefail(size);\n    strncpy(newstr, str, n);\n    newstr[n] = '\\0';\n    return newstr;\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfnDN",
                        "rpmfnDN",
                        "static const char * rpmfnDN(rpmstrPool pool, rpmfn fndata, int ix) /* <=== rpmfnDN */ \n{\n    return rpmstrPoolStr(pool, rpmfnDNId(fndata, ix));\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFInode",
                        "rpmfilesFInode",
                        "rpm_ino_t rpmfilesFInode(rpmfiles fi, int ix) /* <=== rpmfilesFInode */ \n{\n    rpm_ino_t finode = 0;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->finodes != NULL)\n\t    finode = fi->finodes[ix];\n    }\n    return finode;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmSetmeta",
                        "fsmSetmeta",
                        "static int fsmSetmeta(int fd, int dirfd, const char *path, /* <=== fsmSetmeta */ \n\t\t      rpmfi fi, rpmPlugins plugins,\n\t\t      rpmFileAction action, const struct stat * st,\n\t\t      int nofcaps)\n{\n    int rc = 0;\n    const char *dest = rpmfiFN(fi);\n\n    if (!rc && !getuid()) {\n\trc = fsmChown(fd, dirfd, path, st->st_mode, st->st_uid, st->st_gid);\n    }\n    if (!rc && !S_ISLNK(st->st_mode)) {\n\trc = fsmChmod(fd, dirfd, path, st->st_mode);\n    }\n    /* Set file capabilities (if enabled) */\n    if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {\n\trc = fsmSetFCaps(fd, dirfd, path, rpmfiFCaps(fi));\n    }\n    if (!rc) {\n\trc = fsmUtime(fd, dirfd, path, st->st_mode, rpmfiFMtime(fi));\n    }\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, fi,\n\t\t\t\t\t  path, dest,\n\t\t\t\t\t  st->st_mode, action);\n    }\n\n    return rc;\n}",
                        1
                    ],
                    [
                        "rpmio/rpmlog.c",
                        "rpmlogCtxRelease",
                        "rpmlogCtxRelease",
                        "static rpmlogCtx rpmlogCtxRelease(rpmlogCtx ctx) /* <=== rpmlogCtxRelease */ \n{\n    if (ctx)\n\tpthread_rwlock_unlock(&ctx->lock);\n    return NULL;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmMkfile",
                        "fsmMkfile",
                        "static int fsmMkfile(int dirfd, rpmfi fi, struct filedata_s *fp, rpmfiles files, /* <=== fsmMkfile */ \n\t\t     rpmpsm psm, int nodigest,\n\t\t     struct filedata_s ** firstlink, int *firstlinkfile,\n\t\t     int *fdp)\n{\n    int rc = 0;\n    int fd = -1;\n\n    if (*firstlink == NULL) {\n\t/* First encounter, open file for writing */\n\trc = fsmOpen(&fd, dirfd, fp->fpath);\n\t/* If it's a part of a hardlinked set, the content may come later */\n\tif (fp->sb.st_nlink > 1) {\n\t    *firstlink = fp;\n\t    *firstlinkfile = fd;\n\t}\n    } else {\n\t/* Create hard links for others and avoid redundant metadata setting */\n\tif (*firstlink != fp) {\n\t    rc = fsmLink(dirfd, (*firstlink)->fpath, dirfd, fp->fpath);\n\t}\n\tfd = *firstlinkfile;\n    }\n\n    /* If the file has content, unpack it */\n    if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = fsmUnpack(fi, fd, psm, nodigest);\n\t/* Last file of hardlink set, ensure metadata gets set */\n\tif (*firstlink) {\n\t    fp->setmeta = 1;\n\t    *firstlink = NULL;\n\t    *firstlinkfile = -1;\n\t}\n    }\n    *fdp = fd;\n\n    return rc;\n}",
                        1
                    ],
                    [
                        "rpmio/rpmlog.c",
                        "rpmlogSetMask",
                        "rpmlogSetMask",
                        "int rpmlogSetMask (int mask) /* <=== rpmlogSetMask */ \n{\n    rpmlogCtx ctx = rpmlogCtxAcquire(mask ? 1 : 0);\n\n    int omask = -1;\n    if (ctx) {\n\tomask = ctx->mask;\n\tif (mask)\n\t    ctx->mask = mask;\n    }\n\n    rpmlogCtxRelease(ctx);\n    return omask;\n}",
                        2
                    ],
                    [
                        "lib/rpmug.c",
                        "rpmugGid",
                        "rpmugGid",
                        "int rpmugGid(const char * thisGname, gid_t * gid) /* <=== rpmugGid */ \n{\n    static char * lastGname = NULL;\n    static size_t lastGnameLen = 0;\n    static size_t lastGnameAlloced;\n    static gid_t lastGid;\n    size_t thisGnameLen;\n    struct group * grent;\n\n    if (thisGname == NULL) {\n\tlastGnameLen = 0;\n\treturn -1;\n    } else if (rstreq(thisGname, GID_0_GROUP)) {\n\t*gid = 0;\n\treturn 0;\n    }\n\n    thisGnameLen = strlen(thisGname);\n    if (lastGname == NULL || thisGnameLen != lastGnameLen ||\n\t!rstreq(thisGname, lastGname))\n    {\n\tif (lastGnameAlloced < thisGnameLen + 1) {\n\t    lastGnameAlloced = thisGnameLen + 10;\n\t    lastGname = xrealloc(lastGname, lastGnameAlloced);\t/* XXX memory leak */\n\t}\n\tstrcpy(lastGname, thisGname);\n\n\tgrent = getgrnam(thisGname);\n\tif (grent == NULL) {\n\t    /* FIX: shrug */\n\t    endgrent();\n\t    grent = getgrnam(thisGname);\n\t    if (grent == NULL) {\n\t\treturn -1;\n\t    }\n\t}\n\tlastGid = grent->gr_gid;\n    }\n\n    *gid = lastGid;\n\n    return 0;\n}",
                        3
                    ],
                    [
                        "rpmio/system.h",
                        "xmalloc",
                        "rpmio/system.h:66:66:xmalloc:1",
                        "",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "fsmDoMkDir",
                        "fsmDoMkDir",
                        "static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn, /* <=== fsmDoMkDir */ \n\t\t\tint owned, mode_t mode)\n{\n    int rc;\n    rpmFsmOp op = (FA_CREATE);\n    if (!owned)\n\top |= FAF_UNOWNED;\n\n    /* Run fsm file pre hook for all plugins */\n    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n    if (!rc)\n\trc = fsmMkdir(dirfd, dn, mode);\n\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);\n    }\n\n    /* Run fsm file post hook for all plugins */\n    rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n    if (!rc) {\n\trpmlog(RPMLOG_DEBUG,\n\t\t\"%s directory created with perms %04o\\n\",\n\t\tdn, (unsigned)(mode & 07777));\n    }\n\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "fsmSetFCaps",
                        "fsmSetFCaps",
                        "static int fsmSetFCaps(int fd, int dirfd, const char *path, const char *captxt) /* <=== fsmSetFCaps */ \n{\n    int rc = 0;\n\n#if WITH_CAP\n    if (captxt && *captxt != '\\0') {\n\tcap_t fcaps = cap_from_text(captxt);\n\n\tif (fd >= 0) {\n\t    if (fcaps == NULL || cap_set_fd(fd, fcaps))\n\t\trc = RPMERR_SETCAP_FAILED;\n\t} else {\n\t    if (fcaps == NULL || cap_set_fileat(dirfd, path, fcaps))\n\t\trc = RPMERR_SETCAP_FAILED;\n\t}\n\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s (%d - %d %s, %s) %s\\n\", __func__,\n\t\t   fd, dirfd, path, captxt, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\tcap_free(fcaps);\n    } \n#endif\n    return rc;\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFMtime",
                        "rpmfiFMtime",
                        "RPMFI_ITERFUNC(rpm_time_t, FMtime, i) /* <=== rpmfiFMtime */ ",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "fsmOpenat",
                        "fsmOpenat",
                        "static int fsmOpenat(int dirfd, const char *path, int flags) /* <=== fsmOpenat */ \n{\n    struct stat lsb, sb;\n    int sflags = flags | O_NOFOLLOW;\n    int fd = openat(dirfd, path, sflags);\n\n    /*\n     * Only ever follow symlinks by root or target owner. Since we can't\n     * open the symlink itself, the order matters: we stat the link *after*\n     * opening the target, and if the link ownership changed between the calls\n     * it could've only been the link owner or root.\n     */\n    if (fd < 0 && errno == ELOOP && flags != sflags) {\n\tint ffd = openat(dirfd, path, flags);\n\tif (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n\t    if (fstat(ffd, &sb) == 0) {\n\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n\t\t    fd = ffd;\n\t\t} else {\n\t\t    close(ffd);\n\t\t}\n\t    }\n\t}\n    }\n    return fd;\n}",
                        2
                    ],
                    [
                        "lib/fsm.c",
                        "ensureDir",
                        "ensureDir<duplicate>0",
                        "static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create, /* <=== ensureDir<duplicate>0 */ \n\t\t    int quiet, int *dirfdp)\n{\n    char *path = xstrdup(p);\n    char *dp = path;\n    char *sp = NULL, *bn;\n    int oflags = O_RDONLY;\n    int rc = 0;\n\n    if (*dirfdp >= 0)\n\treturn rc;\n\n    int dirfd = fsmOpenat(-1, \"/\", oflags);\n    int fd = dirfd; /* special case of \"/\" */\n\n    while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {\n\tstruct stat sb;\n\tfd = fsmOpenat(dirfd, bn, oflags);\n\n\tif (fd < 0 && errno == ENOENT && create) {\n\t    mode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t    rc = fsmDoMkDir(plugins, dirfd, bn, owned, mode);\n\t    if (!rc)\n\t\tfd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);\n\t}\n\n\tif (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {\n\t    rc = RPMERR_ENOTDIR;\n\t    break;\n\t}\n\n\tclose(dirfd);\n\tif (fd >= 0) {\n\t    dirfd = fd;\n\t} else {\n\t    if (!quiet) {\n\t\trpmlog(RPMLOG_ERR, _(\"failed to open dir %s of %s: %s\\n\"),\n\t\t\tbn, p, strerror(errno));\n\t    }\n\t    rc = RPMERR_OPEN_FAILED;\n\t    break;\n\t}\n\n\tdp = NULL;\n    }\n\n    if (rc) {\n\tclose(fd);\n\tclose(dirfd);\n\tdirfd = -1;\n    } else {\n\trc = 0;\n    }\n    *dirfdp = dirfd;\n\n    free(path);\n    return rc;\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfilesFUser",
                        "rpmfilesFUser",
                        "const char * rpmfilesFUser(rpmfiles fi, int ix) /* <=== rpmfilesFUser */ \n{\n    const char * fuser = NULL;\n\n    if (fi != NULL && ix >= 0 && ix < rpmfilesFC(fi)) {\n\tif (fi->fuser != NULL)\n\t    fuser = rpmstrPoolStr(fi->pool, fi->fuser[ix]);\n    }\n    return fuser;\n}",
                        3
                    ],
                    [
                        "lib/fsm.c",
                        "fsmMkfifo",
                        "fsmMkfifo",
                        "static int fsmMkfifo(int dirfd, const char *path, mode_t mode) /* <=== fsmMkfifo */ \n{\n    int rc = mkfifoat(dirfd, path, (mode & 07777));\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\",\n\t       __func__, dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKFIFO_FAILED;\n\n    return rc;\n}",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiFC",
                        "rpmfiFC",
                        "rpm_count_t rpmfiFC(rpmfi fi) /* <=== rpmfiFC */ \n{\n    return (fi != NULL ? rpmfilesFC(fi->files) : 0);\n}",
                        3
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiNext",
                        "rpmfiNext",
                        "int rpmfiNext(rpmfi fi) /* <=== rpmfiNext */ \n{\n    int next = -1;\n    if (fi != NULL) {\n\tdo {\n\t    next = fi->next(fi);\n\t} while (next == RPMERR_ITER_SKIP);\n\n\tif (next >= 0)\n\t    next = rpmfiSetFX(fi, next);\n    }\n    return next;\n}",
                        1
                    ],
                    [
                        "<empty>",
                        "<operator>.minus",
                        "<operator>.minus",
                        "",
                        1
                    ],
                    [
                        "lib/system.h",
                        "xcalloc",
                        "lib/system.h:68:68:xcalloc:2",
                        "",
                        1
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiSetFX",
                        "rpmfiSetFX",
                        "int rpmfiSetFX(rpmfi fi, int fx) /* <=== rpmfiSetFX */ \n{\n    int i = -1;\n\n    if (fi != NULL && fx >= 0 && fx < rpmfilesFC(fi->files)) {\n\tint dx = fi->j;\n\ti = fi->i;\n\tfi->i = fx;\n\tfi->j = rpmfilesDI(fi->files, fi->i);\n\ti = fi->i;\n\n\tif (fi->j != dx && fi->onChdir) {\n\t    int chrc = fi->onChdir(fi, fi->onChdirData);\n\t    if (chrc < 0)\n\t\ti = chrc;\n\t}\n    }\n    return i;\n}",
                        2
                    ],
                    [
                        "lib/rpmfi.c",
                        "rpmfiStat",
                        "rpmfiStat",
                        "int rpmfiStat(rpmfi fi, int flags, struct stat *sb) /* <=== rpmfiStat */ \n{\n    int rc = -1;\n    if (fi != NULL) {\n\trc = rpmfilesStat(fi->files, fi->i, flags, sb);\n\t/* In archives, hardlinked files are empty except for the last one */\n\tif (rc == 0 && fi->archive && sb->st_nlink > 1) {\n\t    const int *links = NULL;\n\t    if (rpmfiFLinks(fi, &links) && links[sb->st_nlink-1] != fi->i)\n\t\tsb->st_size = 0;\n\t}\n    }\n    return rc;\n}",
                        1
                    ]
                ],
                "globalVars": [],
                "importContext": [
                    "#include \"system.h\"",
                    "#include <inttypes.h>",
                    "#include <utime.h>",
                    "#include <errno.h>",
                    "#include <fcntl.h>",
                    "#include <sys/capability.h>",
                    "#include <rpm/rpmte.h>",
                    "#include <rpm/rpmts.h>",
                    "#include <rpm/rpmlog.h>",
                    "#include <rpm/rpmmacro.h>",
                    "#include \"rpmio/rpmio_internal.h\"",
                    "#include \"lib/fsm.h\"",
                    "#include \"lib/rpmte_internal.h\"",
                    "#include \"lib/rpmfi_internal.h\"",
                    "#include \"lib/rpmplugins.h\"",
                    "#include \"lib/rpmug.h\"",
                    "#include \"debug.h\""
                ],
                "typeDefs": [
                    [
                        "typedef struct rpmte_s * rpmte;",
                        "rpmte"
                    ],
                    [
                        "typedef struct rpmfs_s * rpmfs;",
                        "rpmfs"
                    ],
                    [
                        "typedef struct rpmfi_s * rpmfi;",
                        "rpmfi"
                    ],
                    [
                        "struct filedata_s {\n    int stage;\n    int setmeta;\n    int skip;\n    rpmFileAction action;\n    const char *suffix;\n    char *fpath;\n    struct stat sb;\n}",
                        "filedata_s"
                    ],
                    [
                        "struct diriter_s {\n    int dirfd;\n}",
                        "diriter_s"
                    ],
                    [
                        "struct rpmfs_s {\n    unsigned int fc;\n\n    rpm_fstate_t * states;\n    rpmFileAction * actions;\t/*!< File disposition(s). */\n\n    sharedFileInfo replaced;\t/*!< (TR_ADDED) to be replaced files in the rpmdb */\n    int numReplaced;\n    int allocatedReplaced;\n}",
                        "rpmfs_s"
                    ],
                    [
                        "typedef struct _FD_s * FD_t;",
                        "FD_t"
                    ],
                    [
                        "struct stat",
                        "stat"
                    ],
                    [
                        "typedef struct rpmts_s * rpmts;",
                        "rpmts"
                    ],
                    [
                        "typedef struct rpmPlugins_s * rpmPlugins;",
                        "rpmPlugins"
                    ],
                    [
                        "typedef struct rpmpsm_s * rpmpsm;",
                        "rpmpsm"
                    ],
                    [
                        "typedef struct rpmfiles_s * rpmfiles;",
                        "rpmfiles"
                    ]
                ],
                "visitedLines": [
                    [
                        995,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        989,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1001,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        971,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1029,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        905,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1054,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        956,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1009,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        997,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        962,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1068,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1042,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1026,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        961,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1008,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1023,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        860,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        870,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1014,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        876,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        848,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        978,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        914,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        883,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        906,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1051,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        871,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        925,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        924,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1013,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1069,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1018,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        926,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        897,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1039,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        952,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        959,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        932,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        966,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        964,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        917,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1019,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        973,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        982,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        875,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        920,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1017,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        937,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        856,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1064,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1032,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        939,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        921,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        984,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        887,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        949,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        918,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        864,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        967,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        851,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1035,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        972,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        880,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1021,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1006,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        850,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        996,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        889,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        990,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        877,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1011,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        854,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        868,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        861,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        873,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        859,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        951,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        853,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        915,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1027,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1047,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        975,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        941,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        994,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        886,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        874,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        899,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        852,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        869,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        944,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        858,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        980,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        867,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        948,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1046,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        857,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        849,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1033,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        930,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1038,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1030,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        896,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        884,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1005,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1000,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        846,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1071,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        977,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1022,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        845,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        855,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        985,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        965,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1055,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        1048,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        950,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        936,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        969,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        931,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        981,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        960,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        893,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        968,
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ]
                ],
                "visitedParams": [
                    [
                        "rpmte te",
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        "rpmts ts",
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        "rpmfiles files",
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ],
                    [
                        "rpmpsm psm",
                        "rpmPackageFilesInstall",
                        "lib/fsm.c"
                    ]
                ],
                "vulnerableMethods": [
                    [
                        "lib/fsm.c",
                        "rpmPackageFilesInstall",
                        "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files, /* <=== rpmPackageFilesInstall */ \n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
                        845
                    ]
                ]
            }
        }
    ],
    "file_cache_in_old_repos": [
        "build/build.c",
        "build/files.c",
        "build/misc.c",
        "build/pack.c",
        "build/parseChangelog.c",
        "build/parseDescription.c",
        "build/parseFiles.c",
        "build/parseList.c",
        "build/parsePolicies.c",
        "build/parsePreamble.c",
        "build/parsePrep.c",
        "build/parseReqs.c",
        "build/parseScript.c",
        "build/parseSimpleScript.c",
        "build/parseSpec.c",
        "build/policies.c",
        "build/reqprov.c",
        "build/rpmfc.c",
        "build/spec.c",
        "build/speclua.c",
        "cliutils.c",
        "lib/backend/bdb_ro.c",
        "lib/backend/dbi.c",
        "lib/backend/dbiset.c",
        "lib/backend/dummydb.c",
        "lib/backend/ndb/glue.c",
        "lib/backend/ndb/rpmidx.c",
        "lib/backend/ndb/rpmpkg.c",
        "lib/backend/ndb/rpmxdb.c",
        "lib/backend/sqlite.c",
        "lib/cpio.c",
        "lib/depends.c",
        "lib/formats.c",
        "lib/fprint.c",
        "lib/fsm.c",
        "lib/header.c",
        "lib/headerfmt.c",
        "lib/headerutil.c",
        "lib/manifest.c",
        "lib/order.c",
        "lib/package.c",
        "lib/poptALL.c",
        "lib/poptI.c",
        "lib/poptQV.c",
        "lib/psm.c",
        "lib/query.c",
        "lib/relocation.c",
        "lib/rpmal.c",
        "lib/rpmchecksig.c",
        "lib/rpmchroot.c",
        "lib/rpmdb.c",
        "lib/rpmds.c",
        "lib/rpmfi.c",
        "lib/rpmfs.c",
        "lib/rpmgi.c",
        "lib/rpminstall.c",
        "lib/rpmlead.c",
        "lib/rpmlock.c",
        "lib/rpmplugins.c",
        "lib/rpmprob.c",
        "lib/rpmps.c",
        "lib/rpmrc.c",
        "lib/rpmscript.c",
        "lib/rpmtd.c",
        "lib/rpmte.c",
        "lib/rpmtriggers.c",
        "lib/rpmts.c",
        "lib/rpmug.c",
        "lib/rpmvs.c",
        "lib/signature.c",
        "lib/tagexts.c",
        "lib/tagname.c",
        "lib/transaction.c",
        "lib/verify.c",
        "luaext/lposix.c",
        "luaext/modemuncher.c",
        "misc/fnmatch.c",
        "misc/fts.c",
        "misc/stpcpy.c",
        "misc/stpncpy.c",
        "plugins/audit.c",
        "plugins/dbus_announce.c",
        "plugins/fapolicyd.c",
        "plugins/fsverity.c",
        "plugins/ima.c",
        "plugins/prioreset.c",
        "plugins/selinux.c",
        "plugins/syslog.c",
        "plugins/systemd_inhibit.c",
        "python/header-py.c",
        "python/rpmarchive-py.c",
        "python/rpmds-py.c",
        "python/rpmfd-py.c",
        "python/rpmfi-py.c",
        "python/rpmfiles-py.c",
        "python/rpmii-py.c",
        "python/rpmkeyring-py.c",
        "python/rpmmacro-py.c",
        "python/rpmmi-py.c",
        "python/rpmmodule.c",
        "python/rpmps-py.c",
        "python/rpmstrpool-py.c",
        "python/rpmtd-py.c",
        "python/rpmte-py.c",
        "python/rpmts-py.c",
        "python/rpmver-py.c",
        "python/spec-py.c",
        "rpm.c",
        "rpm2archive.c",
        "rpm2cpio.c",
        "rpmbuild.c",
        "rpmdb.c",
        "rpmio/argv.c",
        "rpmio/base64.c",
        "rpmio/digest.c",
        "rpmio/digest_libgcrypt.c",
        "rpmio/digest_openssl.c",
        "rpmio/expression.c",
        "rpmio/macro.c",
        "rpmio/rgetopt.c",
        "rpmio/rpmfileutil.c",
        "rpmio/rpmglob.c",
        "rpmio/rpmhook.c",
        "rpmio/rpmio.c",
        "rpmio/rpmkeyring.c",
        "rpmio/rpmlog.c",
        "rpmio/rpmlua.c",
        "rpmio/rpmmalloc.c",
        "rpmio/rpmpgp.c",
        "rpmio/rpmsq.c",
        "rpmio/rpmstring.c",
        "rpmio/rpmstrpool.c",
        "rpmio/rpmsw.c",
        "rpmio/rpmver.c",
        "rpmio/rpmvercmp.c",
        "rpmio/url.c",
        "rpmkeys.c",
        "rpmsign.c",
        "rpmspec.c",
        "sign/rpmgensig.c",
        "sign/rpmsignfiles.c",
        "sign/rpmsignverity.c",
        "tools/elfdeps.c",
        "tools/rpmdeps.c",
        "tools/rpmgraph.c",
        "tools/rpmlua.c",
        "build/rpmbuild.h",
        "build/rpmbuild_internal.h",
        "build/rpmbuild_misc.h",
        "build/rpmfc.h",
        "build/rpmspec.h",
        "cliutils.h",
        "debug.h",
        "docs/librpm/Doxyheader.h",
        "lib/backend/dbi.h",
        "lib/backend/dbiset.h",
        "lib/backend/ndb/rpmidx.h",
        "lib/backend/ndb/rpmpkg.h",
        "lib/backend/ndb/rpmxdb.h",
        "lib/cpio.h",
        "lib/fprint.h",
        "lib/fsm.h",
        "lib/header.h",
        "lib/header_internal.h",
        "lib/manifest.h",
        "lib/misc.h",
        "lib/rpmal.h",
        "lib/rpmarchive.h",
        "lib/rpmcallback.h",
        "lib/rpmchroot.h",
        "lib/rpmcli.h",
        "lib/rpmdb.h",
        "lib/rpmdb_internal.h",
        "lib/rpmds.h",
        "lib/rpmds_internal.h",
        "lib/rpmfi.h",
        "lib/rpmfi_internal.h",
        "lib/rpmfiles.h",
        "lib/rpmfs.h",
        "lib/rpmgi.h",
        "lib/rpmlead.h",
        "lib/rpmlib.h",
        "lib/rpmlock.h",
        "lib/rpmplugin.h",
        "lib/rpmplugins.h",
        "lib/rpmpol.h",
        "lib/rpmprob.h",
        "lib/rpmps.h",
        "lib/rpmscript.h",
        "lib/rpmtag.h",
        "lib/rpmtd.h",
        "lib/rpmte.h",
        "lib/rpmte_internal.h",
        "lib/rpmtriggers.h",
        "lib/rpmts.h",
        "lib/rpmts_internal.h",
        "lib/rpmtypes.h",
        "lib/rpmug.h",
        "lib/rpmvs.h",
        "lib/signature.h",
        "luaext/lposix.h",
        "misc/fnmatch.h",
        "misc/rpmfts.h",
        "python/header-py.h",
        "python/rpmarchive-py.h",
        "python/rpmds-py.h",
        "python/rpmfd-py.h",
        "python/rpmfi-py.h",
        "python/rpmfiles-py.h",
        "python/rpmii-py.h",
        "python/rpmkeyring-py.h",
        "python/rpmmacro-py.h",
        "python/rpmmi-py.h",
        "python/rpmps-py.h",
        "python/rpmstrpool-py.h",
        "python/rpmsystem-py.h",
        "python/rpmtd-py.h",
        "python/rpmte-py.h",
        "python/rpmts-py.h",
        "python/rpmver-py.h",
        "python/spec-py.h",
        "rpmio/argv.h",
        "rpmio/digest.h",
        "rpmio/rpmbase64.h",
        "rpmio/rpmfileutil.h",
        "rpmio/rpmhook.h",
        "rpmio/rpmio.h",
        "rpmio/rpmio_internal.h",
        "rpmio/rpmkeyring.h",
        "rpmio/rpmlog.h",
        "rpmio/rpmlua.h",
        "rpmio/rpmmacro.h",
        "rpmio/rpmmacro_internal.h",
        "rpmio/rpmpgp.h",
        "rpmio/rpmsq.h",
        "rpmio/rpmstring.h",
        "rpmio/rpmstrpool.h",
        "rpmio/rpmsw.h",
        "rpmio/rpmurl.h",
        "rpmio/rpmutil.h",
        "rpmio/rpmver.h",
        "sign/rpmsign.h",
        "sign/rpmsignfiles.h",
        "sign/rpmsignverity.h",
        "system.h",
        "<includes>",
        "<unknown>"
    ]
}