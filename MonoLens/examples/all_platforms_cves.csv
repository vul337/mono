id,platform,cve_id,cwe_id,language,description,commit_url,commit_msg,other_information,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,github,CVE-2019-15165,CWE-770,c_cpp,sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.,https://github.com/the-tcpdump-group/libpcap/commit/87d6bef033062f969e70fa40c43dfd945d5a20ab,do sanity checks on PHB header length before allocating memory. There was no fault; but doing the check results in a more consistent error,no more info,3,"[{""func_name"": ""read_bytes"", ""file_path"": ""sf-pcapng.c"", ""func_code"": ""static int\nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""truncated dump file; tried to read %\"" PRIsize \"" bytes, only got %\"" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}"", ""target"": 1}, {""func_name"": ""pcap_ng_check_header"", ""file_path"": ""sf-pcapng.c"", ""func_code"": ""pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \""not pcapng\"".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \""not pcapng\"".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""Section Header Block in pcapng dump file has a length of %u < %\"" PRIsize,\n\t\t    total_length,\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Make sure it's not too big.\n\t */\n\tif (total_length > INITIAL_MAX_BLOCKSIZE) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""pcapng block size %u > maximum %u\"",\n\t\t    total_length, INITIAL_MAX_BLOCKSIZE);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""unknown time stamp resolution %u\"", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""out of memory\"");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""unsupported pcapng savefile version %u.%u\"",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""the capture file has no Interface Description Blocks\"");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""the capture file has a packet block before any Interface Description Blocks\"");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}"", ""target"": 0}, {""func_name"": ""pcap_ng_check_header"", ""file_path"": ""sf-pcapng.c"", ""func_code"": ""pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \""not pcapng\"".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \""not pcapng\"".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""Section Header Block in pcapng dump file has invalid length %\"" PRIsize \"" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\"",\n                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n                              total_length,\n                              BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""unknown time stamp resolution %u\"", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""out of memory\"");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""unsupported pcapng savefile version %u.%u\"",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""the capture file has no Interface Description Blocks\"");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""the capture file has a packet block before any Interface Description Blocks\"");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}"", ""target"": 2}]","[{""func_name"": ""read_bytes"", ""file_path"": ""sf-pcapng.c"", ""func_code"": ""static int\nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""truncated pcapng dump file; tried to read %\"" PRIsize \"" bytes, only got %\"" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}""}, {""func_name"": ""pcap_ng_check_header"", ""file_path"": ""sf-pcapng.c"", ""func_code"": ""pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \""not pcapng\"".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \""not pcapng\"".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""Section Header Block in pcapng dump file has invalid length %\"" PRIsize \"" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\"",\n                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n                              total_length,\n                              BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""unknown time stamp resolution %u\"", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""out of memory\"");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""unsupported pcapng savefile version %u.%u\"",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""the capture file has no Interface Description Blocks\"");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""the capture file has a packet block before any Interface Description Blocks\"");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}""}, {""func_name"": ""pcap_ng_check_header"", ""file_path"": ""sf-pcapng.c"", ""func_code"": ""pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \""not pcapng\"".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \""error reading dump file\"");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \""not pcapng\"".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""Section Header Block in pcapng dump file has invalid length %\"" PRIsize \"" < _%u_ < %u (BT_SHB_INSANE_MAX)\"",\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n\t\t    total_length,\n\t\t    BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""unknown time stamp resolution %u\"", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""out of memory\"");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""unsupported pcapng savefile version %u.%u\"",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""the capture file has no Interface Description Blocks\"");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \""the capture file has a packet block before any Interface Description Blocks\"");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}""}]","{""value"": 4, ""code"": 2}","[{""source"": ""value_info(file:sf-pcapng.c, value:total_length)"", ""result"": {""value_trace"": [{""full_code"": ""total_length = SWAPLONG(total_length)"", ""line"": 853, ""func_name"": ""pcap_ng_check_header""}], ""struct_var"": ""total_length"", ""struct_type"": ""bpf_u_int32"", ""struct_definition"": ""typedef unsigned long bpf_u_int32;\n\ntypedef\tu_int bpf_u_int32;\n\ntypedef\tu_int bpf_u_int32;""}}, {""source"": ""code_info(file:sf-pcapng.c, lines:843-863)"", ""result"": ""\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \""Section Header Block in pcapng dump file has a length of %u < %\"" PRIsize,\n\t\t    total_length,\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n\t\t*err = 1;\n""}, {""source"": ""code_info(file:sf-pcapng.c, lines:843-853)"", ""result"": ""\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n""}, {""source"": ""value_info(file:sf-pcapng.c, value:total_length)"", ""result"": {""value_trace"": [{""full_code"": ""total_length = SWAPLONG(total_length)"", ""line"": 853, ""func_name"": ""pcap_ng_check_header""}], ""struct_var"": ""total_length"", ""struct_type"": ""bpf_u_int32"", ""struct_definition"": ""typedef unsigned long bpf_u_int32;\n\ntypedef\tu_int bpf_u_int32;\n\ntypedef\tu_int bpf_u_int32;""}}, {""source"": ""value_info(file:sf-pcapng.c, value:total_length)"", ""result"": {""value_trace"": [{""full_code"": ""total_length = SWAPLONG(total_length)"", ""line"": 853, ""func_name"": ""pcap_ng_check_header""}], ""struct_var"": ""total_length"", ""struct_type"": ""bpf_u_int32"", ""struct_definition"": ""typedef unsigned long bpf_u_int32;\n\ntypedef\tu_int bpf_u_int32;\n\ntypedef\tu_int bpf_u_int32;""}}, {""source"": ""value_info(file:sf-pcapng.c, value:total_length)"", ""result"": {""value_trace"": [{""full_code"": ""total_length = SWAPLONG(total_length)"", ""line"": 853, ""func_name"": ""pcap_ng_check_header""}], ""struct_var"": ""total_length"", ""struct_type"": ""bpf_u_int32"", ""struct_definition"": ""typedef unsigned long bpf_u_int32;\n\ntypedef\tu_int bpf_u_int32;\n\ntypedef\tu_int bpf_u_int32;""}}]",sf-pcapng.c: 'total_length' is read from input file via fread() (lines 800-842) → swapped via SWAPLONG (sf-pcapng.c:853) → insufficient upper bound validation before memory allocation. Patch adds BT_SHB_INSANE_MAX check (sf-pcapng.c:857-863) to mitigate.,0.95,./other_context/github/CVE-2019-15165
2,github,CVE-2022-27418,CWE-787,c_cpp,Tcpreplay v4.4.1 has a heap-based buffer overflow in do_checksum_math at /tcpedit/checksum.c.,https://github.com/appneta/tcpreplay/commit/e2ac765a25e902728b6d4a825358aa536e6668c2,Bug #703 safeguard against corrupt packet lengths in checksum functions,N/A,5,"[{""func_name"": ""fix_ipv6_checksums"", ""file_path"": ""src/tcpedit/edit_packet.c"", ""func_code"": ""int\nfix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv6_hdr_t *ip6_hdr)\n{\n    int ret = 0;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip6_hdr);\n\n    if (pkthdr->caplen < sizeof(*ip6_hdr)) {\n        tcpedit_setwarn(tcpedit, \""caplen too small to read IPv6 header: %u\"",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    ipv4_hdr_t *ip_hdr = (ipv4_hdr_t*)ip6_hdr;\n    if (ip_hdr->ip_v != 6) {\n        tcpedit_seterr(tcpedit, \""Invalid packet: Expected IPv6 packet: got %u\"", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len) {\n        if (ip6_hdr->ip_len < ipv6_header_length(ip6_hdr, pkthdr->len)) {\n            tcpedit_setwarn(tcpedit, \""Unable to checksum IPv6 packet with invalid length %u\"",\n                    ip6_hdr->ip_len);\n            return TCPEDIT_WARN;\n        }\n        ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,\n            htons(ip6_hdr->ip_len));\n        if (ret < 0)\n            return TCPEDIT_ERROR;\n    }\n\n    /* what do we return? */\n    if (ret == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n\n    return TCPEDIT_OK;\n}"", ""target"": 0}, {""func_name"": ""fix_ipv4_checksums"", ""file_path"": ""src/tcpedit/edit_packet.c"", ""func_code"": ""int\nfix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr)\n{\n    int ret1 = 0, ret2 = 0, ip_len;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip_hdr);\n\n    if (pkthdr->caplen < sizeof(*ip_hdr)) {\n        tcpedit_setwarn(tcpedit, \""caplen too small to read IPv4 header: %u\"",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    if (ip_hdr->ip_v != 4) {\n        tcpedit_seterr(tcpedit, \""Invalid packet: Expected IPv4 packet: got %u\"", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len &&\n            (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {\n        ip_len = (int)ntohs(ip_hdr->ip_len);\n        ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p,\n                ip_len - (ip_hdr->ip_hl << 2));\n        if (ret1 < 0)\n            return TCPEDIT_ERROR;\n    }\n    \n    /* calc IP checksum */\n    ip_len = (int)ntohs(ip_hdr->ip_len);\n    ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);\n    if (ret2 < 0)\n        return TCPEDIT_ERROR;\n\n    /* what do we return? */\n    if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n    \n    return TCPEDIT_OK;\n}"", ""target"": 0}, {""func_name"": ""ipv6_header_length"", ""file_path"": ""src/tcpedit/edit_packet.c"", ""func_code"": ""static int\nipv6_header_length(ipv6_hdr_t const * ip6_hdr, int pkt_len)\n{\n    struct tcpr_ipv6_ext_hdr_base const * nhdr;\n    uint8_t next_header;\n    int offset;\n\n    offset = sizeof(*ip6_hdr);\n    next_header = ip6_hdr->ip_nh;\n\n    while (sizeof(*nhdr) + offset < (size_t)pkt_len)\n    {\n        if (next_header != TCPR_IPV6_NH_HBH\n                && next_header != TCPR_IPV6_NH_ROUTING\n                && next_header != TCPR_IPV6_NH_FRAGMENT) {\n            return offset;\n        }\n\n        nhdr = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)ip6_hdr) + offset);\n        next_header = nhdr->ip_nh;\n        offset += ((nhdr->ip_len + 1) << 3);\n    }\n\n    return -1;\n}"", ""target"": 0}, {""func_name"": ""tcpedit_packet"", ""file_path"": ""src/tcpedit/tcpedit.c"", ""func_code"": ""int\ntcpedit_packet(tcpedit_t *tcpedit, struct pcap_pkthdr **pkthdr,\n        u_char **pktdata, tcpr_dir_t direction)\n{\n    bool fuzz_once = tcpedit->fuzz_seed != 0;\n    ipv4_hdr_t *ip_hdr;\n    ipv6_hdr_t *ip6_hdr;\n    arp_hdr_t *arp_hdr;\n    int l2len, l2proto, retval;\n    int dst_dlt, src_dlt, pktlen, lendiff;\n    int ipflags, tclass;\n    int needtorecalc;           /* did the packet change? if so, checksum */\n    u_char *packet;\n\n\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(*pkthdr);\n    assert(pktdata);\n    assert(*pktdata);\n    assert(tcpedit->validated);\n\n    packet = *pktdata;\n\n    tcpedit->runtime.packetnum++;\n\n    dbgx(3, \""packet \"" COUNTER_SPEC \"" caplen %d\"", \n            tcpedit->runtime.packetnum, (*pkthdr)->caplen);\n\n    /*\n     * remove the Ethernet FCS (checksum)?\n     * note that this feature requires the end user to be smart and\n     * only set this flag IFF the pcap has the FCS.  If not, then they\n     * just removed 2 bytes of ACTUAL PACKET DATA.  Sucks to be them.\n     */\n    if (tcpedit->efcs > 0 &&(*pkthdr)->len > 4) {\n        if ((*pkthdr)->caplen == (*pkthdr)->len) {\n            (*pkthdr)->caplen -= 4;\n        }\n\n        (*pkthdr)->len -= 4;\n    }\n\n    src_dlt = tcpedit_dlt_src(tcpedit->dlt_ctx);\n    \n    needtorecalc = 0;\nagain:\n    ip_hdr = NULL;\n    ip6_hdr = NULL;\n    arp_hdr = NULL;\n    retval = 0;\n    ipflags = 0;\n    tclass = 0;\n    /* not everything has a L3 header, so check for errors.  returns proto in network byte order */\n    if ((l2proto = tcpedit_dlt_proto(tcpedit->dlt_ctx, src_dlt, packet, (*pkthdr)->caplen)) < 0) {\n        dbgx(2, \""Packet has no L3+ header: %s\"", tcpedit_geterr(tcpedit));\n        return TCPEDIT_SOFT_ERROR;\n    } else {\n        dbgx(2, \""Layer 3 protocol type is: 0x%04x\"", ntohs(l2proto));\n    }\n        \n    /* rewrite Layer 2 */\n    if ((pktlen = tcpedit_dlt_process(tcpedit->dlt_ctx, pktdata, (*pkthdr)->caplen, direction)) < 0) {\n        /* unable to edit packet, most likely 802.11 management or data QoS frame */\n        dbgx(3, \""Failed to edit DLT: %s\"", tcpedit_geterr(tcpedit));\n        return TCPEDIT_SOFT_ERROR;\n    }\n\n    /* update our packet lengths (real/captured) based on L2 length changes */\n    lendiff = pktlen - (*pkthdr)->caplen;\n    (*pkthdr)->caplen += lendiff;\n    (*pkthdr)->len += lendiff;\n    \n    dst_dlt = tcpedit_dlt_dst(tcpedit->dlt_ctx);\n    l2len = tcpedit_dlt_l2len(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n    if (l2len == -1)\n        return TCPEDIT_SOFT_ERROR;\n\n    dbgx(2, \""dst_dlt = %04x\\tsrc_dlt = %04x\\tproto = %04x\\tl2len = %d\"", dst_dlt, src_dlt, ntohs(l2proto), l2len);\n\n    /* does packet have an IP header?  if so set our pointer to it */\n    if (l2proto == htons(ETHERTYPE_IP)) {\n        u_char *p;\n\n        if ((*pkthdr)->caplen < l2len + sizeof(*ip_hdr)) {\n            tcpedit_seterr(tcpedit, \""Packet length %d is too short to contain a layer IP header for DLT 0x%04x\"",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        ip_hdr = (ipv4_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n        if (ip_hdr == NULL)\n            return TCPEDIT_SOFT_ERROR;\n\n        p = get_layer4_v4(ip_hdr, (*pkthdr)->caplen - l2len);\n        if (!p) {\n            tcpedit_seterr(tcpedit, \""Packet length %d is too short to contain a layer %d byte IP header for DLT 0x%04x\"",\n                    pktlen, ip_hdr->ip_hl << 2,  dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        dbgx(3, \""Packet has an IPv4 header: 0x%p...\"", ip_hdr);\n    } else if (l2proto == htons(ETHERTYPE_IP6)) {\n        u_char *p;\n\n        if ((*pkthdr)->caplen < l2len + sizeof(*ip6_hdr)) {\n            tcpedit_seterr(tcpedit, \""Packet length %d is too short to contain a layer IPv6 header for DLT 0x%04x\"",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        ip6_hdr = (ipv6_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n        if (ip6_hdr == NULL)\n            return TCPEDIT_SOFT_ERROR;\n\n        p = get_layer4_v6(ip6_hdr, (*pkthdr)->caplen - l2len);\n        if (!p) {\n            tcpedit_seterr(tcpedit, \""Packet length %d is too short to contain an IPv6 header for DLT 0x%04x\"",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        dbgx(3, \""Packet has an IPv6 header: 0x%p...\"", ip6_hdr);\n    } else {\n        dbgx(3, \""Packet isn't IPv4 or IPv6: 0x%04x\"", l2proto);\n        /* non-IP packets have a NULL ip_hdr struct */\n        ip_hdr = NULL;\n        ip6_hdr = NULL;\n    }\n\n    /* The following edits only apply for IPv4 */\n    if (ip_hdr != NULL) {\n\n        /* set TOS ? */\n        if (tcpedit->tos > -1) {\n            volatile uint16_t oldval = *((uint16_t*)ip_hdr);\n            volatile uint16_t newval;\n\n            ip_hdr->ip_tos = tcpedit->tos;\n            newval = *((uint16_t*)ip_hdr);\n            csum_replace2(&ip_hdr->ip_sum, oldval, newval);\n        }\n\n        /* rewrite the TTL */\n        needtorecalc += rewrite_ipv4_ttl(tcpedit, ip_hdr);\n\n        /* rewrite TCP/UDP ports */\n        if (tcpedit->portmap != NULL) {\n            if ((retval = rewrite_ipv4_ports(tcpedit, &ip_hdr,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        if (tcpedit->tcp_sequence_enable)\n            rewrite_ipv4_tcp_sequence(tcpedit, &ip_hdr,\n                    (*pkthdr)->caplen - l2len);\n    }\n\n    /* IPv6 edits */\n    else if (ip6_hdr != NULL) {\n        /* rewrite the hop limit */\n        needtorecalc += rewrite_ipv6_hlim(tcpedit, ip6_hdr);\n\n        /* set traffic class? */\n        if (tcpedit->tclass > -1) {\n            /* calculate the bits */\n            tclass = tcpedit->tclass << 20;\n            \n            /* convert our 4 bytes to an int */\n            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);\n            \n            /* strip out the old tclass bits */\n            ipflags = ntohl(ipflags) & 0xf00fffff;\n\n            /* add the tclass bits back */\n            ipflags += tclass; \n            ipflags = htonl(ipflags);\n            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);\n        }\n\n        /* set the flow label? */\n        if (tcpedit->flowlabel > -1) {\n            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);\n            ipflags = ntohl(ipflags) & 0xfff00000;\n            ipflags += tcpedit->flowlabel;\n            ipflags = htonl(ipflags);\n            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);\n        }\n\n        /* rewrite TCP/UDP ports */\n        if (tcpedit->portmap != NULL) {\n            if ((retval = rewrite_ipv6_ports(tcpedit, &ip6_hdr,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        if (tcpedit->tcp_sequence_enable)\n            rewrite_ipv6_tcp_sequence(tcpedit, &ip6_hdr, (*pkthdr)->caplen - l2len);\n    }\n\n    if (fuzz_once) {\n        fuzz_once = false;\n        retval = fuzzing(tcpedit, *pkthdr, pktdata);\n        if (retval < 0) {\n            return TCPEDIT_ERROR;\n        }\n        needtorecalc += retval;\n        goto again;\n    }\n\n    /* (Un)truncate or MTU truncate packet? */\n    if (tcpedit->fixlen || tcpedit->mtu_truncate) {\n        if ((retval = untrunc_packet(tcpedit, *pkthdr, pktdata, ip_hdr, ip6_hdr)) < 0)\n            return TCPEDIT_ERROR;\n        needtorecalc += retval;\n    }\n    \n    /* rewrite IP addresses in IPv4/IPv6 or ARP */\n    if (tcpedit->rewrite_ip) {\n        /* IP packets */\n        if (ip_hdr != NULL) {\n            if ((retval = rewrite_ipv4l3(tcpedit, ip_hdr, direction,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        } else if (ip6_hdr != NULL) {\n            if ((retval = rewrite_ipv6l3(tcpedit, ip6_hdr, direction,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        /* ARP packets */\n        else if (l2proto == htons(ETHERTYPE_ARP)) {\n            arp_hdr = (arp_hdr_t *)&(packet[l2len]);\n            /* unlike, rewrite_ipl3, we don't care if the packet changed\n             * because we never need to recalc the checksums for an ARP\n             * packet.  So ignore the return value\n             */\n            if (rewrite_iparp(tcpedit, arp_hdr, direction) < 0)\n                return TCPEDIT_ERROR;\n        }\n    }\n\n\n    /* do we need to spoof the src/dst IP address in IPv4 or ARP? */\n    if (tcpedit->seed) {\n        /* IPv4 Packets */\n        if (ip_hdr != NULL) {\n            if ((retval = randomize_ipv4(tcpedit, *pkthdr, packet, \n                    ip_hdr, (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n\n        } else if (ip6_hdr != NULL) {\n            if ((retval = randomize_ipv6(tcpedit, *pkthdr, packet,\n                    ip6_hdr, (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n\n        /* ARP packets */\n        } else if (l2proto == htons(ETHERTYPE_ARP)) {\n            if (direction == TCPR_DIR_C2S) {\n                if (randomize_iparp(tcpedit, *pkthdr, packet, \n                        tcpedit->runtime.dlt1, (*pkthdr)->caplen - l2len) < 0)\n                    return TCPEDIT_ERROR;\n            } else {\n                if (randomize_iparp(tcpedit, *pkthdr, packet, \n                        tcpedit->runtime.dlt2, (*pkthdr)->caplen - l2len) < 0)\n                    return TCPEDIT_ERROR;\n            }\n        }\n    }\n\n    /* do we need to fix checksums? -- must always do this last! */\n    if ((tcpedit->fixcsum || needtorecalc)) {\n        if (ip_hdr != NULL) {\n            dbgx(3, \""doing IPv4 checksum: needtorecalc=%d\"", needtorecalc);\n            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr);\n        } else if (ip6_hdr != NULL) {\n            dbgx(3, \""doing IPv6 checksum: needtorecalc=%d\"", needtorecalc);\n            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr);\n        } else {\n            dbgx(3, \""checksum not performed: needtorecalc=%d\"", needtorecalc);\n            retval = TCPEDIT_OK;\n        }\n        if (retval < 0) {\n            return TCPEDIT_ERROR;\n        } else if (retval == TCPEDIT_WARN) {\n            warnx(\""%s\"", tcpedit_getwarn(tcpedit));\n        }\n    }\n\n    tcpedit_dlt_merge_l3data(tcpedit->dlt_ctx,\n                             dst_dlt, packet,\n                             (*pkthdr)->caplen,\n                             (u_char*)ip_hdr,\n                             (u_char*)ip6_hdr);\n\n    tcpedit->runtime.total_bytes += (*pkthdr)->caplen;\n    tcpedit->runtime.pkts_edited ++;\n    return retval;\n}"", ""target"": 0}, {""func_name"": ""main"", ""file_path"": ""src/tcprewrite.c"", ""func_code"": ""int \nmain(int argc, char *argv[])\n{\n    int optct, rcode;\n    pcap_t *dlt_pcap;\n#ifdef ENABLE_FRAGROUTE\n    char ebuf[FRAGROUTE_ERRBUF_LEN];\n#endif\n    tcprewrite_init();\n\n    /* call autoopts to process arguments */\n    optct = optionProcess(&tcprewriteOptions, argc, argv);\n    argc -= optct;\n    argv += optct;\n\n    /* parse the tcprewrite args */\n    post_args(argc, argv);\n\n    /* init tcpedit context */\n    if (tcpedit_init(&tcpedit, pcap_datalink(options.pin)) < 0) {\n        errx(-1, \""Error initializing tcpedit: %s\"", tcpedit_geterr(tcpedit));\n    }\n\n    /* parse the tcpedit args */\n    rcode = tcpedit_post_args(tcpedit);\n    if (rcode < 0) {\n        tcpedit_close(&tcpedit);\n        errx(-1, \""Unable to parse args: %s\"", tcpedit_geterr(tcpedit));\n    } else if (rcode == 1) {\n        warnx(\""%s\"", tcpedit_geterr(tcpedit));\n    }\n\n    if (tcpedit_validate(tcpedit) < 0) {\n        tcpedit_close(&tcpedit);\n        errx(-1, \""Unable to edit packets given options:\\n%s\"",\n                tcpedit_geterr(tcpedit));\n    }\n\n    /* fuzzing init */\n    fuzzing_init(tcpedit->fuzz_seed, tcpedit->fuzz_factor);\n\n   /* open up the output file */\n    options.outfile = safe_strdup(OPT_ARG(OUTFILE));\n    dbgx(1, \""Rewriting DLT to %s\"",\n            pcap_datalink_val_to_name(tcpedit_get_output_dlt(tcpedit)));\n    if ((dlt_pcap = pcap_open_dead(tcpedit_get_output_dlt(tcpedit), 65535)) == NULL) {\n        tcpedit_close(&tcpedit);\n        err(-1, \""Unable to open dead pcap handle.\"");\n    }\n\n    dbgx(1, \""DLT of dlt_pcap is %s\"",\n        pcap_datalink_val_to_name(pcap_datalink(dlt_pcap)));\n\n#ifdef ENABLE_FRAGROUTE\n    if (options.fragroute_args) {\n        if ((options.frag_ctx = fragroute_init(65535, pcap_datalink(dlt_pcap), options.fragroute_args, ebuf)) == NULL) {\n            tcpedit_close(&tcpedit);\n            errx(-1, \""%s\"", ebuf);\n        }\n    }\n#endif\n\n#ifdef ENABLE_VERBOSE\n    if (options.verbose) {\n        tcpdump_open(&tcpdump, dlt_pcap);\n    }\n#endif\n\n    if ((options.pout = pcap_dump_open(dlt_pcap, options.outfile)) == NULL) {\n        tcpedit_close(&tcpedit);\n        errx(-1, \""Unable to open output pcap file: %s\"", pcap_geterr(dlt_pcap));\n    }\n\n    pcap_close(dlt_pcap);\n\n    /* rewrite packets */\n    if (rewrite_packets(tcpedit, options.pin, options.pout) == TCPEDIT_ERROR) {\n        tcpedit_close(&tcpedit);\n        errx(-1, \""Error rewriting packets: %s\"", tcpedit_geterr(tcpedit));\n    }\n\n    /* clean up after ourselves */\n    pcap_dump_close(options.pout);\n    pcap_close(options.pin);\n    tcpedit_close(&tcpedit);\n\n#ifdef ENABLE_VERBOSE\n    tcpdump_close(&tcpdump);\n#endif\n\n#ifdef ENABLE_FRAGROUTE\n    if (options.frag_ctx) {\n        fragroute_close(options.frag_ctx);\n    }\n#endif\n\n#ifdef ENABLE_DMALLOC\n    dmalloc_shutdown();\n#endif\n\n    restore_stdin();\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""fix_ipv6_checksums"", ""file_path"": ""src/tcpedit/edit_packet.c"", ""func_code"": ""int\nfix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n                   ipv6_hdr_t *ip6_hdr, const size_t l2len)\n{\n    int ret = 0;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip6_hdr);\n\n    if (pkthdr->caplen < (sizeof(*ip6_hdr) + l2len)) {\n        tcpedit_setwarn(tcpedit, \""caplen too small to read IPv6 header: %u\"",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    ipv4_hdr_t *ip_hdr = (ipv4_hdr_t*)ip6_hdr;\n    if (ip_hdr->ip_v != 6) {\n        tcpedit_seterr(tcpedit, \""Invalid packet: Expected IPv6 packet: got %u\"", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len) {\n        int ip6_len = ipv6_header_length(ip6_hdr, pkthdr->len, l2len);\n        if (ip6_hdr->ip_len < ip6_len) {\n            tcpedit_seterr(tcpedit, \""Unable to checksum IPv6 packet with invalid length %u\"",\n                        ip6_hdr->ip_len);\n            return TCPEDIT_ERROR;\n        }\n        ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,\n            htons(ip6_hdr->ip_len));\n        if (ret < 0)\n            return TCPEDIT_ERROR;\n    }\n\n    /* what do we return? */\n    if (ret == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n\n    return TCPEDIT_OK;\n}""}, {""func_name"": ""fix_ipv4_checksums"", ""file_path"": ""src/tcpedit/edit_packet.c"", ""func_code"": ""int\nfix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n                   ipv4_hdr_t *ip_hdr, const size_t l2len)\n{\n    int ret1 = 0, ret2 = 0, ip_len;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip_hdr);\n\n    if (pkthdr->caplen < (sizeof(*ip_hdr) + l2len)) {\n        tcpedit_setwarn(tcpedit, \""caplen too small to read IPv4 header: %u\"",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    if (ip_hdr->ip_v != 4) {\n        tcpedit_seterr(tcpedit, \""Invalid packet: Expected IPv4 packet: got %u\"", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    ip_len = (int)ntohs(ip_hdr->ip_len);\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len &&\n            (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {\n        if (ip_len != (int)(pkthdr->caplen - l2len)) {\n            tcpedit_seterr(tcpedit,\n                           \""caplen minus L2 length %u does IPv4 header length %u\"",\n                           pkthdr->caplen - l2len,\n                           ip_len);\n            return TCPEDIT_ERROR;\n        }\n        ret1 = do_checksum(tcpedit, (u_char*)ip_hdr, ip_hdr->ip_p,\n                           ip_len - (ip_hdr->ip_hl << 2));\n        if (ret1 < 0)\n            return TCPEDIT_ERROR;\n    }\n    \n    /* calc IP checksum */\n    ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);\n    if (ret2 < 0)\n        return TCPEDIT_ERROR;\n\n    /* what do we return? */\n    if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n    \n    return TCPEDIT_OK;\n}""}, {""func_name"": ""ipv6_header_length"", ""file_path"": ""src/tcpedit/edit_packet.c"", ""func_code"": ""static int\nipv6_header_length(ipv6_hdr_t const * ip6_hdr, const size_t pkt_len,\n                   const size_t l2len)\n{\n    struct tcpr_ipv6_ext_hdr_base const * nhdr;\n    uint8_t next_header;\n    int offset;\n\n    offset = sizeof(*ip6_hdr);\n    next_header = ip6_hdr->ip_nh;\n\n    while (sizeof(*nhdr) + offset + l2len < (size_t)pkt_len) {\n        if (next_header != TCPR_IPV6_NH_HBH\n                && next_header != TCPR_IPV6_NH_ROUTING\n                && next_header != TCPR_IPV6_NH_FRAGMENT) {\n            return offset;\n        }\n\n        nhdr = (struct tcpr_ipv6_ext_hdr_base const *) (((uint8_t const *)ip6_hdr) + offset);\n        next_header = nhdr->ip_nh;\n        offset += ((nhdr->ip_len + 1) << 3);\n    }\n\n    return -1;\n}""}, {""func_name"": ""tcpedit_packet"", ""file_path"": ""src/tcpedit/tcpedit.c"", ""func_code"": ""int\ntcpedit_packet(tcpedit_t *tcpedit, struct pcap_pkthdr **pkthdr,\n        u_char **pktdata, tcpr_dir_t direction)\n{\n    bool fuzz_once = tcpedit->fuzz_seed != 0;\n    ipv4_hdr_t *ip_hdr;\n    ipv6_hdr_t *ip6_hdr;\n    arp_hdr_t *arp_hdr;\n    int l2len, l2proto, retval;\n    int dst_dlt, src_dlt, pktlen, lendiff;\n    int ipflags, tclass;\n    int needtorecalc;           /* did the packet change? if so, checksum */\n    u_char *packet;\n\n\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(*pkthdr);\n    assert(pktdata);\n    assert(*pktdata);\n    assert(tcpedit->validated);\n\n    packet = *pktdata;\n\n    tcpedit->runtime.packetnum++;\n\n    dbgx(3, \""packet \"" COUNTER_SPEC \"" caplen %d\"", \n            tcpedit->runtime.packetnum, (*pkthdr)->caplen);\n\n    /*\n     * remove the Ethernet FCS (checksum)?\n     * note that this feature requires the end user to be smart and\n     * only set this flag IFF the pcap has the FCS.  If not, then they\n     * just removed 2 bytes of ACTUAL PACKET DATA.  Sucks to be them.\n     */\n    if (tcpedit->efcs > 0 &&(*pkthdr)->len > 4) {\n        if ((*pkthdr)->caplen == (*pkthdr)->len) {\n            (*pkthdr)->caplen -= 4;\n        }\n\n        (*pkthdr)->len -= 4;\n    }\n\n    src_dlt = tcpedit_dlt_src(tcpedit->dlt_ctx);\n    \n    needtorecalc = 0;\nagain:\n    ip_hdr = NULL;\n    ip6_hdr = NULL;\n    arp_hdr = NULL;\n    retval = 0;\n    ipflags = 0;\n    tclass = 0;\n    /* not everything has a L3 header, so check for errors.  returns proto in network byte order */\n    if ((l2proto = tcpedit_dlt_proto(tcpedit->dlt_ctx, src_dlt, packet, (*pkthdr)->caplen)) < 0) {\n        dbgx(2, \""Packet has no L3+ header: %s\"", tcpedit_geterr(tcpedit));\n        return TCPEDIT_SOFT_ERROR;\n    } else {\n        dbgx(2, \""Layer 3 protocol type is: 0x%04x\"", ntohs(l2proto));\n    }\n        \n    /* rewrite Layer 2 */\n    if ((pktlen = tcpedit_dlt_process(tcpedit->dlt_ctx, pktdata, (*pkthdr)->caplen, direction)) < 0) {\n        /* unable to edit packet, most likely 802.11 management or data QoS frame */\n        dbgx(3, \""Failed to edit DLT: %s\"", tcpedit_geterr(tcpedit));\n        return TCPEDIT_SOFT_ERROR;\n    }\n\n    /* update our packet lengths (real/captured) based on L2 length changes */\n    lendiff = pktlen - (*pkthdr)->caplen;\n    (*pkthdr)->caplen += lendiff;\n    (*pkthdr)->len += lendiff;\n    \n    dst_dlt = tcpedit_dlt_dst(tcpedit->dlt_ctx);\n    l2len = tcpedit_dlt_l2len(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n    if (l2len == -1)\n        return TCPEDIT_SOFT_ERROR;\n\n    dbgx(2, \""dst_dlt = %04x\\tsrc_dlt = %04x\\tproto = %04x\\tl2len = %d\"", dst_dlt, src_dlt, ntohs(l2proto), l2len);\n\n    /* does packet have an IP header?  if so set our pointer to it */\n    if (l2proto == htons(ETHERTYPE_IP)) {\n        u_char *p;\n\n        if ((*pkthdr)->caplen < l2len + sizeof(*ip_hdr)) {\n            tcpedit_seterr(tcpedit, \""Packet length %d is too short to contain a layer IP header for DLT 0x%04x\"",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        ip_hdr = (ipv4_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n        if (ip_hdr == NULL)\n            return TCPEDIT_SOFT_ERROR;\n\n        p = get_layer4_v4(ip_hdr, (*pkthdr)->caplen - l2len);\n        if (!p) {\n            tcpedit_seterr(tcpedit, \""Packet length %d is too short to contain a layer %d byte IP header for DLT 0x%04x\"",\n                    pktlen, ip_hdr->ip_hl << 2,  dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        dbgx(3, \""Packet has an IPv4 header: 0x%p...\"", ip_hdr);\n    } else if (l2proto == htons(ETHERTYPE_IP6)) {\n        u_char *p;\n\n        if ((*pkthdr)->caplen < l2len + sizeof(*ip6_hdr)) {\n            tcpedit_seterr(tcpedit, \""Packet length %d is too short to contain a layer IPv6 header for DLT 0x%04x\"",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        ip6_hdr = (ipv6_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n        if (ip6_hdr == NULL)\n            return TCPEDIT_SOFT_ERROR;\n\n        p = get_layer4_v6(ip6_hdr, (*pkthdr)->caplen - l2len);\n        if (!p) {\n            tcpedit_seterr(tcpedit, \""Packet length %d is too short to contain an IPv6 header for DLT 0x%04x\"",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        dbgx(3, \""Packet has an IPv6 header: 0x%p...\"", ip6_hdr);\n    } else {\n        dbgx(3, \""Packet isn't IPv4 or IPv6: 0x%04x\"", l2proto);\n        /* non-IP packets have a NULL ip_hdr struct */\n        ip_hdr = NULL;\n        ip6_hdr = NULL;\n    }\n\n    /* The following edits only apply for IPv4 */\n    if (ip_hdr != NULL) {\n\n        /* set TOS ? */\n        if (tcpedit->tos > -1) {\n            volatile uint16_t oldval = *((uint16_t*)ip_hdr);\n            volatile uint16_t newval;\n\n            ip_hdr->ip_tos = tcpedit->tos;\n            newval = *((uint16_t*)ip_hdr);\n            csum_replace2(&ip_hdr->ip_sum, oldval, newval);\n        }\n\n        /* rewrite the TTL */\n        needtorecalc += rewrite_ipv4_ttl(tcpedit, ip_hdr);\n\n        /* rewrite TCP/UDP ports */\n        if (tcpedit->portmap != NULL) {\n            if ((retval = rewrite_ipv4_ports(tcpedit, &ip_hdr,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        if (tcpedit->tcp_sequence_enable)\n            rewrite_ipv4_tcp_sequence(tcpedit, &ip_hdr,\n                    (*pkthdr)->caplen - l2len);\n    }\n\n    /* IPv6 edits */\n    else if (ip6_hdr != NULL) {\n        /* rewrite the hop limit */\n        needtorecalc += rewrite_ipv6_hlim(tcpedit, ip6_hdr);\n\n        /* set traffic class? */\n        if (tcpedit->tclass > -1) {\n            /* calculate the bits */\n            tclass = tcpedit->tclass << 20;\n            \n            /* convert our 4 bytes to an int */\n            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);\n            \n            /* strip out the old tclass bits */\n            ipflags = ntohl(ipflags) & 0xf00fffff;\n\n            /* add the tclass bits back */\n            ipflags += tclass; \n            ipflags = htonl(ipflags);\n            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);\n        }\n\n        /* set the flow label? */\n        if (tcpedit->flowlabel > -1) {\n            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);\n            ipflags = ntohl(ipflags) & 0xfff00000;\n            ipflags += tcpedit->flowlabel;\n            ipflags = htonl(ipflags);\n            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);\n        }\n\n        /* rewrite TCP/UDP ports */\n        if (tcpedit->portmap != NULL) {\n            if ((retval = rewrite_ipv6_ports(tcpedit, &ip6_hdr,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        if (tcpedit->tcp_sequence_enable)\n            rewrite_ipv6_tcp_sequence(tcpedit, &ip6_hdr, (*pkthdr)->caplen - l2len);\n    }\n\n    if (fuzz_once) {\n        fuzz_once = false;\n        retval = fuzzing(tcpedit, *pkthdr, pktdata);\n        if (retval < 0) {\n            return TCPEDIT_ERROR;\n        }\n        needtorecalc += retval;\n        goto again;\n    }\n\n    /* (Un)truncate or MTU truncate packet? */\n    if (tcpedit->fixlen || tcpedit->mtu_truncate) {\n        if ((retval = untrunc_packet(tcpedit, *pkthdr, pktdata, ip_hdr, ip6_hdr)) < 0)\n            return TCPEDIT_ERROR;\n        needtorecalc += retval;\n    }\n    \n    /* rewrite IP addresses in IPv4/IPv6 or ARP */\n    if (tcpedit->rewrite_ip) {\n        /* IP packets */\n        if (ip_hdr != NULL) {\n            if ((retval = rewrite_ipv4l3(tcpedit, ip_hdr, direction,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        } else if (ip6_hdr != NULL) {\n            if ((retval = rewrite_ipv6l3(tcpedit, ip6_hdr, direction,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        /* ARP packets */\n        else if (l2proto == htons(ETHERTYPE_ARP)) {\n            arp_hdr = (arp_hdr_t *)&(packet[l2len]);\n            /* unlike, rewrite_ipl3, we don't care if the packet changed\n             * because we never need to recalc the checksums for an ARP\n             * packet.  So ignore the return value\n             */\n            if (rewrite_iparp(tcpedit, arp_hdr, direction) < 0)\n                return TCPEDIT_ERROR;\n        }\n    }\n\n\n    /* do we need to spoof the src/dst IP address in IPv4 or ARP? */\n    if (tcpedit->seed) {\n        /* IPv4 Packets */\n        if (ip_hdr != NULL) {\n            if ((retval = randomize_ipv4(tcpedit, *pkthdr, packet, \n                    ip_hdr, (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n\n        } else if (ip6_hdr != NULL) {\n            if ((retval = randomize_ipv6(tcpedit, *pkthdr, packet,\n                    ip6_hdr, (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n\n        /* ARP packets */\n        } else if (l2proto == htons(ETHERTYPE_ARP)) {\n            if (direction == TCPR_DIR_C2S) {\n                if (randomize_iparp(tcpedit, *pkthdr, packet, \n                        tcpedit->runtime.dlt1, (*pkthdr)->caplen - l2len) < 0)\n                    return TCPEDIT_ERROR;\n            } else {\n                if (randomize_iparp(tcpedit, *pkthdr, packet, \n                        tcpedit->runtime.dlt2, (*pkthdr)->caplen - l2len) < 0)\n                    return TCPEDIT_ERROR;\n            }\n        }\n    }\n\n    /* do we need to fix checksums? -- must always do this last! */\n    if ((tcpedit->fixcsum || needtorecalc)) {\n        if (ip_hdr != NULL) {\n            dbgx(3, \""doing IPv4 checksum: needtorecalc=%d\"", needtorecalc);\n            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr, l2len);\n        } else if (ip6_hdr != NULL) {\n            dbgx(3, \""doing IPv6 checksum: needtorecalc=%d\"", needtorecalc);\n            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr, l2len);\n        } else {\n            dbgx(3, \""checksum not performed: needtorecalc=%d\"", needtorecalc);\n            retval = TCPEDIT_OK;\n        }\n        if (retval < 0) {\n            return TCPEDIT_ERROR;\n        } else if (retval == TCPEDIT_WARN) {\n            warnx(\""%s\"", tcpedit_getwarn(tcpedit));\n        }\n    }\n\n    tcpedit_dlt_merge_l3data(tcpedit->dlt_ctx,\n                             dst_dlt, packet,\n                             (*pkthdr)->caplen,\n                             (u_char*)ip_hdr,\n                             (u_char*)ip6_hdr);\n\n    tcpedit->runtime.total_bytes += (*pkthdr)->caplen;\n    tcpedit->runtime.pkts_edited ++;\n    return retval;\n}""}, {""func_name"": ""main"", ""file_path"": ""src/tcprewrite.c"", ""func_code"": ""int \nmain(int argc, char *argv[])\n{\n    int optct, rcode;\n    pcap_t *dlt_pcap;\n#ifdef ENABLE_FRAGROUTE\n    char ebuf[FRAGROUTE_ERRBUF_LEN];\n#endif\n    tcprewrite_init();\n\n    /* call autoopts to process arguments */\n    optct = optionProcess(&tcprewriteOptions, argc, argv);\n    argc -= optct;\n    argv += optct;\n\n    /* parse the tcprewrite args */\n    post_args(argc, argv);\n\n    /* init tcpedit context */\n    if (tcpedit_init(&tcpedit, pcap_datalink(options.pin)) < 0) {\n        err_no_exitx(\""Error initializing tcpedit: %s\"", tcpedit_geterr(tcpedit));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    }\n\n    /* parse the tcpedit args */\n    rcode = tcpedit_post_args(tcpedit);\n    if (rcode < 0) {\n        err_no_exitx(\""Unable to parse args: %s\"", tcpedit_geterr(tcpedit));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    } else if (rcode == 1) {\n        warnx(\""%s\"", tcpedit_geterr(tcpedit));\n    }\n\n    if (tcpedit_validate(tcpedit) < 0) {\n        err_no_exitx(\""Unable to edit packets given options:\\n%s\"",\n                tcpedit_geterr(tcpedit));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    }\n\n    /* fuzzing init */\n    fuzzing_init(tcpedit->fuzz_seed, tcpedit->fuzz_factor);\n\n   /* open up the output file */\n    options.outfile = safe_strdup(OPT_ARG(OUTFILE));\n    dbgx(1, \""Rewriting DLT to %s\"",\n            pcap_datalink_val_to_name(tcpedit_get_output_dlt(tcpedit)));\n    if ((dlt_pcap = pcap_open_dead(tcpedit_get_output_dlt(tcpedit), 65535)) == NULL) {\n        tcpedit_close(&tcpedit);\n        err(-1, \""Unable to open dead pcap handle.\"");\n    }\n\n    dbgx(1, \""DLT of dlt_pcap is %s\"",\n        pcap_datalink_val_to_name(pcap_datalink(dlt_pcap)));\n\n#ifdef ENABLE_FRAGROUTE\n    if (options.fragroute_args) {\n        if ((options.frag_ctx = fragroute_init(65535, pcap_datalink(dlt_pcap), options.fragroute_args, ebuf)) == NULL) {\n            err_no_exitx(\""%s\"", ebuf);\n            tcpedit_close(&tcpedit);\n            exit(-1);\n        }\n    }\n#endif\n\n#ifdef ENABLE_VERBOSE\n    if (options.verbose) {\n        tcpdump_open(&tcpdump, dlt_pcap);\n    }\n#endif\n\n    if ((options.pout = pcap_dump_open(dlt_pcap, options.outfile)) == NULL) {\n        err_no_exitx(\""Unable to open output pcap file: %s\"", pcap_geterr(dlt_pcap));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    }\n\n    pcap_close(dlt_pcap);\n\n    /* rewrite packets */\n    if (rewrite_packets(tcpedit, options.pin, options.pout) == TCPEDIT_ERROR) {\n        err_no_exitx(\""Error rewriting packets: %s\"", tcpedit_geterr(tcpedit));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    }\n\n    /* clean up after ourselves */\n    pcap_dump_close(options.pout);\n    pcap_close(options.pin);\n    tcpedit_close(&tcpedit);\n\n#ifdef ENABLE_VERBOSE\n    tcpdump_close(&tcpdump);\n#endif\n\n#ifdef ENABLE_FRAGROUTE\n    if (options.frag_ctx) {\n        fragroute_close(options.frag_ctx);\n    }\n#endif\n\n#ifdef ENABLE_DMALLOC\n    dmalloc_shutdown();\n#endif\n\n    restore_stdin();\n    return 0;\n}""}]",{},[],"src/tcpedit/edit_packet.c:75-76: fix_ipv4_checksums checks if ip_len matches caplen - l2len. If not, returns error. src/tcpedit/edit_packet.c:132: fix_ipv6_checksums checks if caplen includes l2len. If not, returns error. src/tcpedit/edit_packet.c:150: fix_ipv6_checksums calls do_checksum with ip6_hdr->ip_len as length parameter. src/tcpedit/edit_packet.c:75: fix_ipv4_checksums calls do_checksum with ip_len as length parameter. src/tcpedit/checksum.c:do_checksum uses the provided len parameter to calculate checksums for protocols (TCP/UDP/ICMP). src/tcpedit/checksum.c:do_checksum_math processes data in 16-bit chunks for the given len. If len exceeds available data, it reads beyond the buffer, causing a heap-based buffer overflow.",0.95,./other_context/github/CVE-2022-27418
3,github,CVE-2011-3619,CWE-20,c_cpp,"The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 3.0 does not properly handle invalid parameters, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact by writing to a /proc/#####/attr/current file.",https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865,AppArmor: fix oops in apparmor_setprocattr\n\nWhen invalid parameters are passed to apparmor_setprocattr a NULL deref\noops occurs when it tries to record an audit message. This is because\nit is passing NULL for the profile parameter for aa_audit. But aa_audit\nnow requires that the profile passed is not NULL.\n\nFix this by passing the current profile on the task that is trying to\nsetprocattr.\n\nSigned-off-by: Kees Cook <kees@ubuntu.com>\nSigned-off-by: John Johansen <john.johansen@canonical.com>\nCc: stable@kernel.org\nSigned-off-by: James Morris <jmorris@namei.org>,no more info,1,"[{""func_name"": ""apparmor_setprocattr"", ""file_path"": ""security/apparmor/lsm.c"", ""func_code"": ""static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \"" \"");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \""current\"") == 0) {\n\t\tif (strcmp(command, \""changehat\"") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \""permhat\"") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \""changeprofile\"") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \""permprofile\"") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \""permipc\"") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \""exec\"") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\t/* only support the \""current\"" and \""exec\"" process attributes */\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}"", ""target"": 0}]","[{""func_name"": ""apparmor_setprocattr"", ""file_path"": ""security/apparmor/lsm.c"", ""func_code"": ""static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \"" \"");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \""current\"") == 0) {\n\t\tif (strcmp(command, \""changehat\"") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \""permhat\"") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \""changeprofile\"") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \""permprofile\"") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \""permipc\"") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED,\n\t\t\t\t\t__aa_current_profile(), GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \""exec\"") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\t/* only support the \""current\"" and \""exec\"" process attributes */\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}""}]",{},[],"The vulnerability is triggered when userspace writes invalid data to /proc/#####/attr/current (UNCERTIFIED: per vulnerability description and code context in security/apparmor/lsm.c:593). In apparmor_setprocattr (security/apparmor/lsm.c:593), invalid 'name' values bypass validation (e.g., 'name' not 'current' or 'exec') and reach an error handling block. The error handler calls aa_audit with NULL as the profile parameter (security/apparmor/lsm.c:593), which now requires a non-NULL profile, causing a NULL dereference (OOPS). The patch replaces NULL with __aa_current_profile(), ensuring a valid profile is passed to aa_audit, preventing the crash.",0.95,./other_context/github/CVE-2011-3619
4,github,CVE-2021-21335,CWE-287,c_cpp,"In the SPNEGO HTTP Authentication Module for nginx (spnego-http-auth-nginx-module) before version 1.1.1 basic Authentication can be bypassed using a malformed username. This affects users of spnego-http-auth-nginx-module that have enabled basic authentication. This is fixed in version 1.1.1 of spnego-http-auth-nginx-module. As a workaround, one may disable basic authentication.",https://github.com/stnoonan/spnego-http-auth-nginx-module/commit/a06f9efca373e25328b1c53639a48decd0854570,"Check basic auth result against != NGX_OK rather than == NGX_DECLINED\n\nThis corrects the error handling case when ngx_http_auth_spnego_basic is called with a bad configuration or bad username. These cases return NGX_ERROR, which allowed basic auth to proceed.\r\n\r\nThanks to Prakapovich Pavel aka Flyguy.by for pointing this out.",no more info,1,"[{""func_name"": ""ngx_http_auth_spnego_handler"", ""file_path"": ""ngx_http_auth_spnego_module.c"", ""func_code"": ""static ngx_int_t\nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\""SSO auth handling IN: token.len=%d, head=%d, ret=%d\"",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\""Found token and head, returning %d\"", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\""User header set\"");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\""Begin auth\"");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\""Detect basic auth\"");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\""Basic auth credentials supplied by client\"");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\""Basic auth failed\"");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\""Error setting headers\"");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\""User not authorized\"");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\""Basic auth succeeded\"");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\""Detect SPNEGO token\"");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\""Client sent a reasonable Negotiate header\"");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\""GSSAPI failed\"");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\""GSSAPI failed\"");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\""Error setting headers\"");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\""User not authorized\"");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\""GSSAPI auth succeeded\"");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\""Error setting headers\"");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\""SSO auth handling OUT: token.len=%d, head=%d, ret=%d\"",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}"", ""target"": 0}]","[{""func_name"": ""ngx_http_auth_spnego_handler"", ""file_path"": ""ngx_http_auth_spnego_module.c"", ""func_code"": ""static ngx_int_t\nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\""SSO auth handling IN: token.len=%d, head=%d, ret=%d\"",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\""Found token and head, returning %d\"", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\""User header set\"");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\""Begin auth\"");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\""Detect basic auth\"");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\""Basic auth credentials supplied by client\"");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\""Basic auth failed\"");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\""Error setting headers\"");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\""User not authorized\"");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\""Basic auth succeeded\"");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\""Detect SPNEGO token\"");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\""Client sent a reasonable Negotiate header\"");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\""GSSAPI failed\"");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\""GSSAPI failed\"");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\""Error setting headers\"");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\""User not authorized\"");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\""GSSAPI auth succeeded\"");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\""Error setting headers\"");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\""SSO auth handling OUT: token.len=%d, head=%d, ret=%d\"",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}""}]",{},[],"In ngx_http_auth_spnego_handler (ngx_http_auth_spnego_module.c:1044), the return value of ngx_http_auth_spnego_basic was incorrectly checked against NGX_DECLINED. This allowed NGX_ERROR returns (e.g., from malformed usernames) to be treated as successful. The function ngx_http_auth_spnego_basic (ngx_http_auth_spnego_module.c:494-733) returns NGX_ERROR for errors like invalid Kerberos credentials or memory allocation failures. The original condition (== NGX_DECLINED) failed to catch these errors, which the patch (NGX_OK != ...) now addresses.",0.95,./other_context/github/CVE-2021-21335
5,github,CVE-2021-35938,CWE-59,c_cpp,A symbolic link issue was found in rpm. It occurs when rpm sets the desired permissions and credentials after installing a file. A local unprivileged user could use this flaw to exchange the original file with a symbolic link to a security-critical file and escalate their privileges on the system. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.,https://github.com/rpm-software-management/rpm/commit/25a435e90844ea98fe5eb7bef22c1aecf3a9c033,"Set file metadata via fd-based ops for everything but symlinks\n\nRegular file ops are fd-based already, for the rest we need to open them\nmanually. Files with temporary suffix must never be followed, for\ndirectories (and pre-existing FA_TOUCHed files) use the rpm symlink\n""root or target owner allowed"" rule wrt following.\n\nThis mostly fixes CVE-2021-35938, but as we're not yet using dirfd-based\noperatiosn for everything there are corner cases left undone. And then\nthere's the plugin API which needs updating for all this.",N/A,1,"[{""func_name"": ""rpmPackageFilesInstall"", ""file_path"": ""lib/fsm.c"", ""func_code"": ""int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \"";%08x\"", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \""file %s vanished unexpectedly\\n\"",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}"", ""target"": 0}]","[{""func_name"": ""rpmPackageFilesInstall"", ""file_path"": ""lib/fsm.c"", ""func_code"": ""int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \"";%08x\"", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \""file %s vanished unexpectedly\\n\"",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\n\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {\n\t\t/* Only follow safe symlinks, and never on temporary files */\n\t\tfd = fsmOpenat(di.dirfd, fp->fpath,\n\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);\n\t\tif (fd < 0)\n\t\t    rc = RPMERR_OPEN_FAILED;\n\t    }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}""}]","{""function"": 1, ""code"": 1, ""value"": 1}","[{""source"": ""func_info(file:fsm.c, func:fsmSetmeta)"", ""result"": [{""code"": ""static int fsmSetmeta(int fd, int dirfd, const char *path,\n\t\t      rpmfi fi, rpmPlugins plugins,\n\t\t      rpmFileAction action, const struct stat * st,\n\t\t      int nofcaps)\n{\n    int rc = 0;\n    const char *dest = rpmfiFN(fi);\n\n    if (!rc && !getuid()) {\n\trc = fsmChown(fd, dirfd, path, st->st_mode, st->st_uid, st->st_gid);\n    }\n    if (!rc && !S_ISLNK(st->st_mode)) {\n\trc = fsmChmod(fd, dirfd, path, st->st_mode);\n    }\n    /* Set file capabilities (if enabled) */\n    if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {\n\trc = fsmSetFCaps(fd, dirfd, path, rpmfiFCaps(fi));\n    }\n    if (!rc) {\n\trc = fsmUtime(fd, dirfd, path, st->st_mode, rpmfiFMtime(fi));\n    }\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, fi,\n\t\t\t\t\t  path, dest,\n\t\t\t\t\t  st->st_mode, action);\n    }\n\n    return rc;\n}"", ""start_line"": 706, ""end_line"": 734, ""full_name"": ""fsmSetmeta"", ""file_path"": ""lib/fsm.c""}]}, {""source"": ""code_info(file:fsm.c, lines:1000-1050)"", ""result"": ""\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n""}, {""source"": ""value_info(file:fsm.c, value:fp->setmeta)"", ""result"": {""value_trace"": [{""full_code"": ""fp->setmeta = 1"", ""line"": 222, ""func_name"": ""fsmMkfile""}, {""full_code"": ""fp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH)"", ""line"": 883, ""func_name"": ""rpmPackageFilesInstall""}], ""struct_var"": ""fp"", ""struct_type"": null, ""struct_definition"": null}}]","lib/fsm.c:991-999 opens non-symlink files with AT_SYMLINK_NOFOLLOW, passing the fd to fsmSetmeta (lib/fsm.c:706-734). fsmSetmeta applies metadata via fd-based helpers: fsmChown (lib/fsm.c:524-554) uses fchown(2), fsmChmod (lib/fsm.c:556-584) uses fchmod(2), fsmSetFCaps (lib/fsm.c:106-130) uses cap_set_fd(3), and fsmUtime (lib/fsm.c:586-607) uses futimens(2). All avoid symlink following by operating on the fd directly.",0.95,./other_context/github/CVE-2021-35938
6,github,CVE-2013-7026,CWE-362,c_cpp,Multiple race conditions in ipc/shm.c in the Linux kernel before 3.12.2 allow local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted application that uses shmctl IPC_RMID operations in conjunction with other shm system calls.,https://github.com/torvalds/linux/commit/a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1,"ipc,shm: fix shm_file deletion races\n\nWhen IPC_RMID races with other shm operations there's potential for\nuse-after-free of the shm object's associated file (shm_file).\n\nHere's the race before this patch:\n\n  TASK 1                     TASK 2\n  ------                     ------\n  shm_rmid()\n    ipc_lock_object()\n                             shmctl()\n                             shp = shm_obtain_object_check()\n\n    shm_destroy()\n      shum_unlock()\n      fput(shp->shm_file)\n                             ipc_lock_object()\n                             shmem_lock(shp->shm_file)\n                             <OOPS>\n\nThe oops is caused because shm_destroy() calls fput() after dropping the\nipc_lock.  fput() clears the file's f_inode, f_path.dentry, and\nf_path.mnt, which causes various NULL pointer references in task 2.  I\nreliably see the oops in task 2 if with shmlock, shmu\n\nThis patch fixes the races by:\n1) set shm_file=NULL in shm_destroy() while holding ipc_object_lock().\n2) modify at risk operations to check shm_file while holding\n   ipc_object_lock().\n\nExample workloads, which each trigger oops...\n\nWorkload 1:\n  while true; do\n    id=$(shmget 1 4096)\n    shm_rmid $id &\n    shmlock $id &\n    wait\n  done\n\n  The oops stack shows accessing NULL f_inode due to racing fput:\n    _raw_spin_lock\n    shmem_lock\n    SyS_shmctl\n\nWorkload 2:\n  while true; do\n    id=$(shmget 1 4096)\n    shmat $id 4096 &\n    shm_rmid $id &\n    wait\n  done\n\n  The oops stack is similar to workload 1 due to NULL f_inode:\n    touch_atime\n    shmem_mmap\n    shm_mmap\n    mmap_region\n    do_mmap_pgoff\n    do_shmat\n    SyS_shmat\n\nWorkload 3:\n  while true; do\n    id=$(shmget 1 4096)\n    shmlock $id\n    shm_rmid $id &\n    shmunlock $id &\n    wait\n  done\n\n  The oops stack shows second fput tripping on an NULL f_inode.  The\n  first fput() completed via from shm_destroy(), but a racing thread did\n  a get_file() and queued this fput():\n    locks_remove_flock\n    __fput\n    ____fput\n    task_work_run\n    do_notify_resume\n    int_signal\n\nFixes: c2c737a0461e (""ipc,shm: shorten critical region for shmat"")\nFixes: 2caacaa82a51 (""ipc,shm: shorten critical region for shmctl"")\nSigned-off-by: Greg Thelen <gthelen@google.com>\nCc: Davidlohr Bueso <davidlohr@hp.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Manfred Spraul <manfred@colorfullife.com>\nCc: <stable@vger.kernel.org>  # 3.10.17+ 3.11.6+\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",no more info,2,"[{""func_name"": ""do_shmat"", ""file_path"": ""ipc/shm.c"", ""func_code"": ""long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n\t      unsigned long shmlba)\n{\n\tstruct shmid_kernel *shp;\n\tunsigned long addr;\n\tunsigned long size;\n\tstruct file * file;\n\tint    err;\n\tunsigned long flags;\n\tunsigned long prot;\n\tint acc_mode;\n\tstruct ipc_namespace *ns;\n\tstruct shm_file_data *sfd;\n\tstruct path path;\n\tfmode_t f_mode;\n\tunsigned long populate = 0;\n\n\terr = -EINVAL;\n\tif (shmid < 0)\n\t\tgoto out;\n\telse if ((addr = (ulong)shmaddr)) {\n\t\tif (addr & (shmlba - 1)) {\n\t\t\tif (shmflg & SHM_RND)\n\t\t\t\taddr &= ~(shmlba - 1);\t   /* round down */\n\t\t\telse\n#ifndef __ARCH_FORCE_SHMLBA\n\t\t\t\tif (addr & ~PAGE_MASK)\n#endif\n\t\t\t\t\tgoto out;\n\t\t}\n\t\tflags = MAP_SHARED | MAP_FIXED;\n\t} else {\n\t\tif ((shmflg & SHM_REMAP))\n\t\t\tgoto out;\n\n\t\tflags = MAP_SHARED;\n\t}\n\n\tif (shmflg & SHM_RDONLY) {\n\t\tprot = PROT_READ;\n\t\tacc_mode = S_IRUGO;\n\t\tf_mode = FMODE_READ;\n\t} else {\n\t\tprot = PROT_READ | PROT_WRITE;\n\t\tacc_mode = S_IRUGO | S_IWUGO;\n\t\tf_mode = FMODE_READ | FMODE_WRITE;\n\t}\n\tif (shmflg & SHM_EXEC) {\n\t\tprot |= PROT_EXEC;\n\t\tacc_mode |= S_IXUGO;\n\t}\n\n\t/*\n\t * We cannot rely on the fs check since SYSV IPC does have an\n\t * additional creator id...\n\t */\n\tns = current->nsproxy->ipc_ns;\n\trcu_read_lock();\n\tshp = shm_obtain_object_check(ns, shmid);\n\tif (IS_ERR(shp)) {\n\t\terr = PTR_ERR(shp);\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &shp->shm_perm, acc_mode))\n\t\tgoto out_unlock;\n\n\terr = security_shm_shmat(shp, shmaddr, shmflg);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&shp->shm_perm);\n\tpath = shp->shm_file->f_path;\n\tpath_get(&path);\n\tshp->shm_nattch++;\n\tsize = i_size_read(path.dentry->d_inode);\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\n\terr = -ENOMEM;\n\tsfd = kzalloc(sizeof(*sfd), GFP_KERNEL);\n\tif (!sfd) {\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile = alloc_file(&path, f_mode,\n\t\t\t  is_file_hugepages(shp->shm_file) ?\n\t\t\t\t&shm_file_operations_huge :\n\t\t\t\t&shm_file_operations);\n\terr = PTR_ERR(file);\n\tif (IS_ERR(file)) {\n\t\tkfree(sfd);\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile->private_data = sfd;\n\tfile->f_mapping = shp->shm_file->f_mapping;\n\tsfd->id = shp->shm_perm.id;\n\tsfd->ns = get_ipc_ns(ns);\n\tsfd->file = shp->shm_file;\n\tsfd->vm_ops = NULL;\n\n\terr = security_mmap_file(file, prot, flags);\n\tif (err)\n\t\tgoto out_fput;\n\n\tdown_write(&current->mm->mmap_sem);\n\tif (addr && !(shmflg & SHM_REMAP)) {\n\t\terr = -EINVAL;\n\t\tif (find_vma_intersection(current->mm, addr, addr + size))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t * If shm segment goes below stack, make sure there is some\n\t\t * space left for the stack to grow (at least 4 pages).\n\t\t */\n\t\tif (addr < current->mm->start_stack &&\n\t\t    addr > current->mm->start_stack - size - PAGE_SIZE * 5)\n\t\t\tgoto invalid;\n\t}\n\n\taddr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &populate);\n\t*raddr = addr;\n\terr = 0;\n\tif (IS_ERR_VALUE(addr))\n\t\terr = (long)addr;\ninvalid:\n\tup_write(&current->mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(addr, populate);\n\nout_fput:\n\tfput(file);\n\nout_nattch:\n\tdown_write(&shm_ids(ns).rwsem);\n\tshp = shm_lock(ns, shmid);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(ns, shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}"", ""target"": 0}, {""func_name"": ""shm_destroy"", ""file_path"": ""ipc/shm.c"", ""func_code"": ""static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}"", ""target"": 0}]","[{""func_name"": ""do_shmat"", ""file_path"": ""ipc/shm.c"", ""func_code"": ""long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n\t      unsigned long shmlba)\n{\n\tstruct shmid_kernel *shp;\n\tunsigned long addr;\n\tunsigned long size;\n\tstruct file * file;\n\tint    err;\n\tunsigned long flags;\n\tunsigned long prot;\n\tint acc_mode;\n\tstruct ipc_namespace *ns;\n\tstruct shm_file_data *sfd;\n\tstruct path path;\n\tfmode_t f_mode;\n\tunsigned long populate = 0;\n\n\terr = -EINVAL;\n\tif (shmid < 0)\n\t\tgoto out;\n\telse if ((addr = (ulong)shmaddr)) {\n\t\tif (addr & (shmlba - 1)) {\n\t\t\tif (shmflg & SHM_RND)\n\t\t\t\taddr &= ~(shmlba - 1);\t   /* round down */\n\t\t\telse\n#ifndef __ARCH_FORCE_SHMLBA\n\t\t\t\tif (addr & ~PAGE_MASK)\n#endif\n\t\t\t\t\tgoto out;\n\t\t}\n\t\tflags = MAP_SHARED | MAP_FIXED;\n\t} else {\n\t\tif ((shmflg & SHM_REMAP))\n\t\t\tgoto out;\n\n\t\tflags = MAP_SHARED;\n\t}\n\n\tif (shmflg & SHM_RDONLY) {\n\t\tprot = PROT_READ;\n\t\tacc_mode = S_IRUGO;\n\t\tf_mode = FMODE_READ;\n\t} else {\n\t\tprot = PROT_READ | PROT_WRITE;\n\t\tacc_mode = S_IRUGO | S_IWUGO;\n\t\tf_mode = FMODE_READ | FMODE_WRITE;\n\t}\n\tif (shmflg & SHM_EXEC) {\n\t\tprot |= PROT_EXEC;\n\t\tacc_mode |= S_IXUGO;\n\t}\n\n\t/*\n\t * We cannot rely on the fs check since SYSV IPC does have an\n\t * additional creator id...\n\t */\n\tns = current->nsproxy->ipc_ns;\n\trcu_read_lock();\n\tshp = shm_obtain_object_check(ns, shmid);\n\tif (IS_ERR(shp)) {\n\t\terr = PTR_ERR(shp);\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &shp->shm_perm, acc_mode))\n\t\tgoto out_unlock;\n\n\terr = security_shm_shmat(shp, shmaddr, shmflg);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&shp->shm_perm);\n\n\t/* check if shm_destroy() is tearing down shp */\n\tif (shp->shm_file == NULL) {\n\t\tipc_unlock_object(&shp->shm_perm);\n\t\terr = -EIDRM;\n\t\tgoto out_unlock;\n\t}\n\n\tpath = shp->shm_file->f_path;\n\tpath_get(&path);\n\tshp->shm_nattch++;\n\tsize = i_size_read(path.dentry->d_inode);\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\n\terr = -ENOMEM;\n\tsfd = kzalloc(sizeof(*sfd), GFP_KERNEL);\n\tif (!sfd) {\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile = alloc_file(&path, f_mode,\n\t\t\t  is_file_hugepages(shp->shm_file) ?\n\t\t\t\t&shm_file_operations_huge :\n\t\t\t\t&shm_file_operations);\n\terr = PTR_ERR(file);\n\tif (IS_ERR(file)) {\n\t\tkfree(sfd);\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile->private_data = sfd;\n\tfile->f_mapping = shp->shm_file->f_mapping;\n\tsfd->id = shp->shm_perm.id;\n\tsfd->ns = get_ipc_ns(ns);\n\tsfd->file = shp->shm_file;\n\tsfd->vm_ops = NULL;\n\n\terr = security_mmap_file(file, prot, flags);\n\tif (err)\n\t\tgoto out_fput;\n\n\tdown_write(&current->mm->mmap_sem);\n\tif (addr && !(shmflg & SHM_REMAP)) {\n\t\terr = -EINVAL;\n\t\tif (find_vma_intersection(current->mm, addr, addr + size))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t * If shm segment goes below stack, make sure there is some\n\t\t * space left for the stack to grow (at least 4 pages).\n\t\t */\n\t\tif (addr < current->mm->start_stack &&\n\t\t    addr > current->mm->start_stack - size - PAGE_SIZE * 5)\n\t\t\tgoto invalid;\n\t}\n\n\taddr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &populate);\n\t*raddr = addr;\n\terr = 0;\n\tif (IS_ERR_VALUE(addr))\n\t\terr = (long)addr;\ninvalid:\n\tup_write(&current->mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(addr, populate);\n\nout_fput:\n\tfput(file);\n\nout_nattch:\n\tdown_write(&shm_ids(ns).rwsem);\n\tshp = shm_lock(ns, shmid);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(ns, shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}""}, {""func_name"": ""shm_destroy"", ""file_path"": ""ipc/shm.c"", ""func_code"": ""static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tstruct file *shm_file;\n\n\tshm_file = shp->shm_file;\n\tshp->shm_file = NULL;\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shm_file))\n\t\tshmem_lock(shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shm_file)->i_size, shp->mlock_user);\n\tfput(shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}""}]",{},[],"The race occurs when Task 1 calls IPC_RMID (via shm_rmid()) and Task 2 calls shmctl/shmat concurrently. In the original code:\n1. Task 1: shm_destroy() drops ipc_lock before calling fput(shp->shm_file) (ipc/shm.c:shm_destroy()@209-217 in pre-patch code, now corrected to set shp->shm_file=NULL under lock).\n2. Task 2: shmat() or shmctl() accesses shp->shm_file without holding ipc_lock, leading to use-after-free (ipc/shm.c:do_shmat()@71-79 in pre-patch code, now fixed with NULL check under lock).\n\nThe patch ensures shm_file is nulled under ipc_lock (ipc/shm.c:shm_destroy()@209-211) and checks shm_file under the same lock in do_shmat (ipc/shm.c:do_shmat()@71-79). This eliminates the race window.",1.0,./other_context/github/CVE-2013-7026
7,github,CVE-2020-36321,CWE-22,java,"Improper URL validation in development mode handler in com.vaadin:flow-server versions 2.0.0 through 2.4.1 (Vaadin 14.0.0 through 14.4.2), and 3.0 prior to 5.0 (Vaadin 15 prior to 18) allows attacker to request arbitrary files stored outside of intended frontend resources folder.",https://github.com/vaadin/flow/commit/e0dcaf86b63dbcab3adbbe107d1c49d490ead8eb,Update the path pattern to block slash-dot-dot either,N/A,5,"[{""func_name"": ""isPathUnsafe"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/HandlerHelper.java"", ""func_code"": ""public static boolean isPathUnsafe(String path) {\n        // Check that the path does not have '/../', '\\..\\', %5C..%5C, or\n        // %2F..%2F\n        try {\n            path = URLDecoder.decode(path, StandardCharsets.UTF_8.name());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\""An error occurred during decoding URL.\"",\n                    e);\n        }\n        return PARENT_DIRECTORY_REGEX.matcher(path).find();\n    }"", ""target"": 0}, {""func_name"": ""serveDevModeRequest"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/DevModeHandler.java"", ""func_code"": ""public boolean serveDevModeRequest(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n        // Do not serve requests if dev server starting or failed to start.\n        if (isDevServerFailedToStart.get() || !devServerStartFuture.isDone()) {\n            return false;\n        }\n        // Since we have 'publicPath=/VAADIN/' in webpack config,\n        // a valid request for webpack-dev-server should start with '/VAADIN/'\n        String requestFilename = request.getPathInfo();\n\n        if (HandlerHelper.isPathUnsafe(requestFilename)) {\n            getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,\n                    requestFilename);\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n\n        HttpURLConnection connection = prepareConnection(requestFilename,\n                request.getMethod());\n\n        // Copies all the headers from the original request\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String header = headerNames.nextElement();\n            connection.setRequestProperty(header,\n                    // Exclude keep-alive\n                    \""Connect\"".equals(header) ? \""close\""\n                            : request.getHeader(header));\n        }\n\n        // Send the request\n        getLogger().debug(\""Requesting resource to webpack {}\"",\n                connection.getURL());\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HTTP_NOT_FOUND) {\n            getLogger().debug(\""Resource not served by webpack {}\"",\n                    requestFilename);\n            // webpack cannot access the resource, return false so as flow can\n            // handle it\n            return false;\n        }\n        getLogger().debug(\""Served resource by webpack: {} {}\"", responseCode,\n                requestFilename);\n\n        // Copies response headers\n        connection.getHeaderFields().forEach((header, values) -> {\n            if (header != null) {\n                response.addHeader(header, values.get(0));\n            }\n        });\n\n        if (responseCode == HTTP_OK) {\n            // Copies response payload\n            writeStream(response.getOutputStream(),\n                    connection.getInputStream());\n        } else if (responseCode < 400) {\n            response.setStatus(responseCode);\n        } else {\n            // Copies response code\n            response.sendError(responseCode);\n        }\n\n        // Close request to avoid issues in CI and Chrome\n        response.getOutputStream().close();\n\n        return true;\n    }"", ""target"": 0}, {""func_name"": ""serveStaticResource"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/StaticFileServer.java"", ""func_code"": ""@Override\n    public boolean serveStaticResource(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n\n        String filenameWithPath = getRequestFilename(request);\n        if (HandlerHelper.isPathUnsafe(filenameWithPath)) {\n            getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,\n                    filenameWithPath);\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n\n        URL resourceUrl = null;\n        if (isAllowedVAADINBuildUrl(filenameWithPath)) {\n            resourceUrl = servletService.getClassLoader()\n                    .getResource(\""META-INF\"" + filenameWithPath);\n        }\n        if (resourceUrl == null) {\n            resourceUrl = servletService.getStaticResource(filenameWithPath);\n        }\n        if (resourceUrl == null && shouldFixIncorrectWebjarPaths()\n                && isIncorrectWebjarPath(filenameWithPath)) {\n            // Flow issue #4601\n            resourceUrl = servletService.getStaticResource(\n                    fixIncorrectWebjarPath(filenameWithPath));\n        }\n\n        if (resourceUrl == null) {\n            // Not found in webcontent or in META-INF/resources in some JAR\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return true;\n        }\n\n        // There is a resource!\n\n        // Intentionally writing cache headers also for 304 responses\n        writeCacheHeaders(filenameWithPath, response);\n\n        long timestamp = writeModificationTimestamp(resourceUrl, request,\n                response);\n        if (browserHasNewestVersion(request, timestamp)) {\n            // Browser is up to date, nothing further to do than set the\n            // response code\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n        responseWriter.writeResponseContents(filenameWithPath, resourceUrl,\n                request, response);\n        return true;\n    }"", ""target"": 0}, {""func_name"": ""serveDevModeRequest"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/DevModeHandler.java"", ""func_code"": ""public boolean serveDevModeRequest(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n        // Do not serve requests if dev server starting or failed to start.\n        if (isDevServerFailedToStart.get() || !devServerStartFuture.isDone()) {\n            return false;\n        }\n        // Since we have 'publicPath=/VAADIN/' in webpack config,\n        // a valid request for webpack-dev-server should start with '/VAADIN/'\n        String requestFilename = request.getPathInfo();\n\n        HttpURLConnection connection = prepareConnection(requestFilename,\n                request.getMethod());\n\n        // Copies all the headers from the original request\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String header = headerNames.nextElement();\n            connection.setRequestProperty(header,\n                    // Exclude keep-alive\n                    \""Connect\"".equals(header) ? \""close\""\n                            : request.getHeader(header));\n        }\n\n        // Send the request\n        getLogger().debug(\""Requesting resource to webpack {}\"",\n                connection.getURL());\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HTTP_NOT_FOUND) {\n            getLogger().debug(\""Resource not served by webpack {}\"",\n                    requestFilename);\n            // webpack cannot access the resource, return false so as flow can\n            // handle it\n            return false;\n        }\n        getLogger().debug(\""Served resource by webpack: {} {}\"", responseCode,\n                requestFilename);\n\n        // Copies response headers\n        connection.getHeaderFields().forEach((header, values) -> {\n            if (header != null) {\n                response.addHeader(header, values.get(0));\n            }\n        });\n\n        if (responseCode == HTTP_OK) {\n            // Copies response payload\n            writeStream(response.getOutputStream(),\n                    connection.getInputStream());\n        } else if (responseCode < 400) {\n            response.setStatus(responseCode);\n        } else {\n            // Copies response code\n            response.sendError(responseCode);\n        }\n\n        // Close request to avoid issues in CI and Chrome\n        response.getOutputStream().close();\n\n        return true;\n    }"", ""target"": 0}, {""func_name"": ""serveStaticResource"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/StaticFileServer.java"", ""func_code"": ""@Override\n    public boolean serveStaticResource(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n\n        String filenameWithPath = getRequestFilename(request);\n        if (!isPathSafe(filenameWithPath)) {\n            getLogger().info(\""Blocked attempt to access file: {}\"",\n                    filenameWithPath);\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n\n        URL resourceUrl = null;\n        if (isAllowedVAADINBuildUrl(filenameWithPath)) {\n            resourceUrl = servletService.getClassLoader()\n                    .getResource(\""META-INF\"" + filenameWithPath);\n        }\n        if (resourceUrl == null) {\n            resourceUrl = servletService.getStaticResource(filenameWithPath);\n        }\n        if (resourceUrl == null && shouldFixIncorrectWebjarPaths()\n                && isIncorrectWebjarPath(filenameWithPath)) {\n            // Flow issue #4601\n            resourceUrl = servletService.getStaticResource(\n                    fixIncorrectWebjarPath(filenameWithPath));\n        }\n\n        if (resourceUrl == null) {\n            // Not found in webcontent or in META-INF/resources in some JAR\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return true;\n        }\n\n        // There is a resource!\n\n        // Intentionally writing cache headers also for 304 responses\n        writeCacheHeaders(filenameWithPath, response);\n\n        long timestamp = writeModificationTimestamp(resourceUrl, request,\n                response);\n        if (browserHasNewestVersion(request, timestamp)) {\n            // Browser is up to date, nothing further to do than set the\n            // response code\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n        responseWriter.writeResponseContents(filenameWithPath, resourceUrl,\n                request, response);\n        return true;\n    }"", ""target"": 0}]","[{""func_name"": ""isPathUnsafe"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/HandlerHelper.java"", ""func_code"": ""public static boolean isPathUnsafe(String path) {\n        // Check that the path does not have '/../', '\\..\\', %5C..%5C,\n        // %2F..%2F, nor '/..', '\\..', %5C.., %2F..\n        try {\n            path = URLDecoder.decode(path, StandardCharsets.UTF_8.name());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\""An error occurred during decoding URL.\"",\n                    e);\n        }\n        return PARENT_DIRECTORY_REGEX.matcher(path).find();\n    }""}, {""func_name"": ""serveDevModeRequest"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/DevModeHandler.java"", ""func_code"": ""public boolean serveDevModeRequest(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n        // Do not serve requests if dev server starting or failed to start.\n        if (isDevServerFailedToStart.get() || !devServerStartFuture.isDone()) {\n            return false;\n        }\n        // Since we have 'publicPath=/VAADIN/' in webpack config,\n        // a valid request for webpack-dev-server should start with '/VAADIN/'\n        String requestFilename = request.getPathInfo();\n\n        if (HandlerHelper.isPathUnsafe(requestFilename)) {\n            getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,\n                    requestFilename);\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return true;\n        }\n\n        HttpURLConnection connection = prepareConnection(requestFilename,\n                request.getMethod());\n\n        // Copies all the headers from the original request\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String header = headerNames.nextElement();\n            connection.setRequestProperty(header,\n                    // Exclude keep-alive\n                    \""Connect\"".equals(header) ? \""close\""\n                            : request.getHeader(header));\n        }\n\n        // Send the request\n        getLogger().debug(\""Requesting resource to webpack {}\"",\n                connection.getURL());\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HTTP_NOT_FOUND) {\n            getLogger().debug(\""Resource not served by webpack {}\"",\n                    requestFilename);\n            // webpack cannot access the resource, return false so as flow can\n            // handle it\n            return false;\n        }\n        getLogger().debug(\""Served resource by webpack: {} {}\"", responseCode,\n                requestFilename);\n\n        // Copies response headers\n        connection.getHeaderFields().forEach((header, values) -> {\n            if (header != null) {\n                response.addHeader(header, values.get(0));\n            }\n        });\n\n        if (responseCode == HTTP_OK) {\n            // Copies response payload\n            writeStream(response.getOutputStream(),\n                    connection.getInputStream());\n        } else if (responseCode < 400) {\n            response.setStatus(responseCode);\n        } else {\n            // Copies response code\n            response.sendError(responseCode);\n        }\n\n        // Close request to avoid issues in CI and Chrome\n        response.getOutputStream().close();\n\n        return true;\n    }""}, {""func_name"": ""serveStaticResource"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/StaticFileServer.java"", ""func_code"": ""@Override\n    public boolean serveStaticResource(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n\n        String filenameWithPath = getRequestFilename(request);\n        if (HandlerHelper.isPathUnsafe(filenameWithPath)) {\n            getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,\n                    filenameWithPath);\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return true;\n        }\n\n        URL resourceUrl = null;\n        if (isAllowedVAADINBuildUrl(filenameWithPath)) {\n            resourceUrl = servletService.getClassLoader()\n                    .getResource(\""META-INF\"" + filenameWithPath);\n        }\n        if (resourceUrl == null) {\n            resourceUrl = servletService.getStaticResource(filenameWithPath);\n        }\n        if (resourceUrl == null && shouldFixIncorrectWebjarPaths()\n                && isIncorrectWebjarPath(filenameWithPath)) {\n            // Flow issue #4601\n            resourceUrl = servletService.getStaticResource(\n                    fixIncorrectWebjarPath(filenameWithPath));\n        }\n\n        if (resourceUrl == null) {\n            // Not found in webcontent or in META-INF/resources in some JAR\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return true;\n        }\n\n        // There is a resource!\n\n        // Intentionally writing cache headers also for 304 responses\n        writeCacheHeaders(filenameWithPath, response);\n\n        long timestamp = writeModificationTimestamp(resourceUrl, request,\n                response);\n        if (browserHasNewestVersion(request, timestamp)) {\n            // Browser is up to date, nothing further to do than set the\n            // response code\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n        responseWriter.writeResponseContents(filenameWithPath, resourceUrl,\n                request, response);\n        return true;\n    }""}, {""func_name"": ""serveDevModeRequest"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/DevModeHandler.java"", ""func_code"": ""public boolean serveDevModeRequest(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n        // Do not serve requests if dev server starting or failed to start.\n        if (isDevServerFailedToStart.get() || !devServerStartFuture.isDone()) {\n            return false;\n        }\n        // Since we have 'publicPath=/VAADIN/' in webpack config,\n        // a valid request for webpack-dev-server should start with '/VAADIN/'\n        String requestFilename = request.getPathInfo();\n\n        if (HandlerHelper.isPathUnsafe(requestFilename)) {\n            getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,\n                    requestFilename);\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n\n        HttpURLConnection connection = prepareConnection(requestFilename,\n                request.getMethod());\n\n        // Copies all the headers from the original request\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String header = headerNames.nextElement();\n            connection.setRequestProperty(header,\n                    // Exclude keep-alive\n                    \""Connect\"".equals(header) ? \""close\""\n                            : request.getHeader(header));\n        }\n\n        // Send the request\n        getLogger().debug(\""Requesting resource to webpack {}\"",\n                connection.getURL());\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HTTP_NOT_FOUND) {\n            getLogger().debug(\""Resource not served by webpack {}\"",\n                    requestFilename);\n            // webpack cannot access the resource, return false so as flow can\n            // handle it\n            return false;\n        }\n        getLogger().debug(\""Served resource by webpack: {} {}\"", responseCode,\n                requestFilename);\n\n        // Copies response headers\n        connection.getHeaderFields().forEach((header, values) -> {\n            if (header != null) {\n                response.addHeader(header, values.get(0));\n            }\n        });\n\n        if (responseCode == HTTP_OK) {\n            // Copies response payload\n            writeStream(response.getOutputStream(),\n                    connection.getInputStream());\n        } else if (responseCode < 400) {\n            response.setStatus(responseCode);\n        } else {\n            // Copies response code\n            response.sendError(responseCode);\n        }\n\n        // Close request to avoid issues in CI and Chrome\n        response.getOutputStream().close();\n\n        return true;\n    }""}, {""func_name"": ""serveStaticResource"", ""file_path"": ""flow-server/src/main/java/com/vaadin/flow/server/StaticFileServer.java"", ""func_code"": ""@Override\n    public boolean serveStaticResource(HttpServletRequest request,\n            HttpServletResponse response) throws IOException {\n\n        String filenameWithPath = getRequestFilename(request);\n        if (HandlerHelper.isPathUnsafe(filenameWithPath)) {\n            getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,\n                    filenameWithPath);\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n\n        URL resourceUrl = null;\n        if (isAllowedVAADINBuildUrl(filenameWithPath)) {\n            resourceUrl = servletService.getClassLoader()\n                    .getResource(\""META-INF\"" + filenameWithPath);\n        }\n        if (resourceUrl == null) {\n            resourceUrl = servletService.getStaticResource(filenameWithPath);\n        }\n        if (resourceUrl == null && shouldFixIncorrectWebjarPaths()\n                && isIncorrectWebjarPath(filenameWithPath)) {\n            // Flow issue #4601\n            resourceUrl = servletService.getStaticResource(\n                    fixIncorrectWebjarPath(filenameWithPath));\n        }\n\n        if (resourceUrl == null) {\n            // Not found in webcontent or in META-INF/resources in some JAR\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return true;\n        }\n\n        // There is a resource!\n\n        // Intentionally writing cache headers also for 304 responses\n        writeCacheHeaders(filenameWithPath, response);\n\n        long timestamp = writeModificationTimestamp(resourceUrl, request,\n                response);\n        if (browserHasNewestVersion(request, timestamp)) {\n            // Browser is up to date, nothing further to do than set the\n            // response code\n            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            return true;\n        }\n        responseWriter.writeResponseContents(filenameWithPath, resourceUrl,\n                request, response);\n        return true;\n    }""}]",{},[],"Insufficient regex coverage in HandlerHelper.isPathUnsafe() for minimal path traversal patterns like '/..' (instead of '/../'). The original implementation checked for '/../' but not '/..', allowing attackers to bypass validation by omitting the trailing slash. The patch explicitly blocks these patterns via updated regex in HandlerHelper.java:202-204.",0.95,./other_context/github/CVE-2020-36321
