[
  {
    "cve_id": "CVE-2019-6498",
    "cwe_ids": [
      "CWE-125"
    ],
    "cvss_vector": "AV:A/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "description": "GattLib 0.2 has a stack-based buffer over-read in gattlib_connect in dbus/gattlib.c because strncpy is misused.",
    "commit_msg": "Fix stack-based bufferoverflow\n\nFix: #81\nFix: #82",
    "commit_hash": "42cf4e63ee7f0eb830644ea37c37a2a9e256befd",
    "git_url": "https://github.com/labapart/gattlib/commit/42cf4e63ee7f0eb830644ea37c37a2a9e256befd",
    "raw_repo": "./storage/result/Part2_result/github/CVE-2019-6498/old_repos/labapart-gattlib_5a31a00",
    "before_cpg_file": "./storage/result/Part2_result/github/CVE-2019-6498/Joern_files/cpgs/cpg.bin",
    "before_cpg_file_cache": [
      "bluez/bluez4/attrib/att.c",
      "bluez/bluez4/attrib/gatt.c",
      "bluez/bluez4/attrib/gattrib.c",
      "bluez/bluez4/btio/btio.c",
      "bluez/bluez4/lib/bluetooth.c",
      "bluez/bluez4/lib/hci.c",
      "bluez/bluez4/lib/sdp.c",
      "bluez/bluez4/lib/uuid.c",
      "bluez/bluez4/src/log.c",
      "bluez/bluez5/attrib/att.c",
      "bluez/bluez5/attrib/gatt.c",
      "bluez/bluez5/attrib/gattrib.c",
      "bluez/bluez5/btio/btio.c",
      "bluez/bluez5/lib/bluetooth.c",
      "bluez/bluez5/lib/hci.c",
      "bluez/bluez5/lib/sdp.c",
      "bluez/bluez5/lib/uuid.c",
      "bluez/bluez5/src/log.c",
      "bluez/bluez5/src/shared/ad.c",
      "bluez/bluez5/src/shared/att.c",
      "bluez/bluez5/src/shared/btsnoop.c",
      "bluez/bluez5/src/shared/crypto.c",
      "bluez/bluez5/src/shared/ecc.c",
      "bluez/bluez5/src/shared/gap.c",
      "bluez/bluez5/src/shared/gatt-client.c",
      "bluez/bluez5/src/shared/gatt-db.c",
      "bluez/bluez5/src/shared/gatt-helpers.c",
      "bluez/bluez5/src/shared/gatt-server.c",
      "bluez/bluez5/src/shared/hci-crypto.c",
      "bluez/bluez5/src/shared/hci.c",
      "bluez/bluez5/src/shared/hfp.c",
      "bluez/bluez5/src/shared/io-glib.c",
      "bluez/bluez5/src/shared/mainloop.c",
      "bluez/bluez5/src/shared/mgmt.c",
      "bluez/bluez5/src/shared/pcap.c",
      "bluez/bluez5/src/shared/queue.c",
      "bluez/bluez5/src/shared/ringbuf.c",
      "bluez/bluez5/src/shared/tester.c",
      "bluez/bluez5/src/shared/timeout-glib.c",
      "bluez/bluez5/src/shared/timeout-mainloop.c",
      "bluez/bluez5/src/shared/uhid.c",
      "bluez/bluez5/src/shared/util.c",
      "bluez/gattlib_adapter.c",
      "bluez/gattlib_connect.c",
      "bluez/gattlib_discover.c",
      "bluez/gattlib_read_write.c",
      "dbus/bluez5/lib/uuid.c",
      "dbus/gattlib.c",
      "examples/ble_scan/ble_scan.c",
      "examples/discover/discover.c",
      "examples/gatttool/gatttool.c",
      "examples/gatttool/interactive.c",
      "examples/gatttool/utils.c",
      "examples/nordic_uart/nordic_uart.c",
      "examples/notification/notification.c",
      "examples/read_write/read_write.c",
      "gattlib_common.c",
      "bluez/bluez4/attrib/att.h",
      "bluez/bluez4/attrib/gatt.h",
      "bluez/bluez4/attrib/gattrib.h",
      "bluez/bluez4/btio/btio.h",
      "bluez/bluez4/lib/bluetooth.h",
      "bluez/bluez4/lib/hci.h",
      "bluez/bluez4/lib/hci_lib.h",
      "bluez/bluez4/lib/l2cap.h",
      "bluez/bluez4/lib/sdp.h",
      "bluez/bluez4/lib/sdp_lib.h",
      "bluez/bluez4/lib/uuid.h",
      "bluez/bluez4/src/log.h",
      "bluez/bluez5/attrib/att-database.h",
      "bluez/bluez5/attrib/att.h",
      "bluez/bluez5/attrib/gatt-service.h",
      "bluez/bluez5/attrib/gatt.h",
      "bluez/bluez5/attrib/gattrib.h",
      "bluez/bluez5/attrib/gatttool.h",
      "bluez/bluez5/btio/btio.h",
      "bluez/bluez5/lib/a2mp.h",
      "bluez/bluez5/lib/amp.h",
      "bluez/bluez5/lib/bluetooth.h",
      "bluez/bluez5/lib/bnep.h",
      "bluez/bluez5/lib/cmtp.h",
      "bluez/bluez5/lib/hci.h",
      "bluez/bluez5/lib/hci_lib.h",
      "bluez/bluez5/lib/hidp.h",
      "bluez/bluez5/lib/l2cap.h",
      "bluez/bluez5/lib/mgmt.h",
      "bluez/bluez5/lib/rfcomm.h",
      "bluez/bluez5/lib/sco.h",
      "bluez/bluez5/lib/sdp.h",
      "bluez/bluez5/lib/sdp_lib.h",
      "bluez/bluez5/lib/uuid.h",
      "bluez/bluez5/monitor/bt.h",
      "bluez/bluez5/profiles/input/uhid_copy.h",
      "bluez/bluez5/src/eir.h",
      "bluez/bluez5/src/log.h",
      "bluez/bluez5/src/shared/ad.h",
      "bluez/bluez5/src/shared/att-types.h",
      "bluez/bluez5/src/shared/att.h",
      "bluez/bluez5/src/shared/btsnoop.h",
      "bluez/bluez5/src/shared/crypto.h",
      "bluez/bluez5/src/shared/ecc.h",
      "bluez/bluez5/src/shared/gap.h",
      "bluez/bluez5/src/shared/gatt-client.h",
      "bluez/bluez5/src/shared/gatt-db.h",
      "bluez/bluez5/src/shared/gatt-helpers.h",
      "bluez/bluez5/src/shared/gatt-server.h",
      "bluez/bluez5/src/shared/hci-crypto.h",
      "bluez/bluez5/src/shared/hci.h",
      "bluez/bluez5/src/shared/hfp.h",
      "bluez/bluez5/src/shared/io.h",
      "bluez/bluez5/src/shared/mainloop.h",
      "bluez/bluez5/src/shared/mgmt.h",
      "bluez/bluez5/src/shared/pcap.h",
      "bluez/bluez5/src/shared/queue.h",
      "bluez/bluez5/src/shared/ringbuf.h",
      "bluez/bluez5/src/shared/tester.h",
      "bluez/bluez5/src/shared/timeout.h",
      "bluez/bluez5/src/shared/tty.h",
      "bluez/bluez5/src/shared/uhid.h",
      "bluez/bluez5/src/shared/util.h",
      "bluez/gattlib_internal.h",
      "dbus/bluez5/lib/uuid.h",
      "dbus/gattlib_internal.h",
      "examples/gatttool/gatttool.h",
      "include/gattlib.h",
      "<includes>",
      "<unknown>"
    ],
    "before_context": {
      "calleeMethods": [
        [
          "<empty>",
          "org_bluez_device1_get_gatt_services",
          "org_bluez_device1_get_gatt_services",
          "",
          1
        ],
        [
          "<empty>",
          "<operator>.indirectFieldAccess",
          "<operator>.indirectFieldAccess",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "rfcomm_connect",
          "rfcomm_connect",
          "static int rfcomm_connect(int sock, const bdaddr_t *dst, uint8_t channel) /* <=== rfcomm_connect */ \n{\n\tint err;\n\tstruct sockaddr_rc addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.rc_family = AF_BLUETOOTH;\n\tbacpy(&addr.rc_bdaddr, dst);\n\taddr.rc_channel = channel;\n\n\terr = connect(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (err < 0 && !(errno == EAGAIN || errno == EINPROGRESS))\n\t\treturn -errno;\n\n\treturn 0;\n}",
          2
        ],
        [
          "<empty>",
          "<operator>.fieldAccess",
          "<operator>.fieldAccess",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/hci.c",
          "hci_devinfo",
          "hci_devinfo",
          "int hci_devinfo(int dev_id, struct hci_dev_info *di) /* <=== hci_devinfo */ \n{\n\tint dd, err, ret;\n\n\tdd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);\n\tif (dd < 0)\n\t\treturn dd;\n\n\tmemset(di, 0, sizeof(struct hci_dev_info));\n\n\tdi->dev_id = dev_id;\n\tret = ioctl(dd, HCIGETDEVINFO, (void *) di);\n\n\terr = errno;\n\tclose(dd);\n\terrno = err;\n\n\treturn ret;\n}",
          2
        ],
        [
          "bluez/bluez4/lib/bluetooth.h",
          "AF_BLUETOOTH",
          "bluez/bluez4/lib/bluetooth.h:41:41:AF_BLUETOOTH:0",
          "#define AF_BLUETOOTH\t31 /* <=== bluez/bluez4/lib/bluetooth.h:41:41:AF_BLUETOOTH:0 */ ",
          3
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "ERROR_FAILED",
          "bluez/bluez4/btio/btio.c:46:48:ERROR_FAILED:3",
          "#define ERROR_FAILED(gerr, str, err) \\ /* <=== bluez/bluez4/btio/btio.c:46:48:ERROR_FAILED:3 */ \n\t\tg_set_error(gerr, BT_IO_ERROR, BT_IO_ERROR_FAILED, \\\n\t\t\t\tstr \": %s (%d)\", strerror(err), err)",
          3
        ],
        [
          "<empty>",
          "pthread_create",
          "pthread_create",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "create_io",
          "create_io",
          "static GIOChannel *create_io(BtIOType type, gboolean server, /* <=== create_io */ \n\t\t\t\t\tstruct set_opts *opts, GError **err)\n{\n\tint sock;\n\tGIOChannel *io;\n\n\tswitch (type) {\n\tcase BT_IO_L2RAW:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(RAW, L2CAP)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (l2cap_bind(sock, &opts->src, server ? opts->psm : 0,\n\t\t\t\t\t\t\topts->cid, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!l2cap_set(sock, opts->sec_level, 0, 0, 0, -1, -1, 0, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tcase BT_IO_L2CAP:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(SEQPACKET, L2CAP)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (l2cap_bind(sock, &opts->src, server ? opts->psm : 0,\n\t\t\t\t\t\t\topts->cid, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!l2cap_set(sock, opts->sec_level, opts->imtu, opts->omtu,\n\t\t\t\topts->mode, opts->master, opts->flushable,\n\t\t\t\topts->priority, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tcase BT_IO_L2ERTM:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(STREAM, L2CAP)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (l2cap_bind(sock, &opts->src, server ? opts->psm : 0,\n\t\t\t\t\t\t\topts->cid, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!l2cap_set(sock, opts->sec_level, opts->imtu, opts->omtu,\n\t\t\t\topts->mode, opts->master, opts->flushable,\n\t\t\t\topts->priority, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tcase BT_IO_RFCOMM:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(STREAM, RFCOMM)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (rfcomm_bind(sock, &opts->src,\n\t\t\t\t\tserver ? opts->channel : 0, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!rfcomm_set(sock, opts->sec_level, opts->master, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tcase BT_IO_SCO:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_SCO);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(SEQPACKET, SCO)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (sco_bind(sock, &opts->src, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!sco_set(sock, opts->mtu, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tdefault:\n\t\tg_set_error(err, BT_IO_ERROR, BT_IO_ERROR_INVALID_ARGS,\n\t\t\t\t\"Unknown BtIO type %d\", type);\n\t\treturn NULL;\n\t}\n\n\tio = g_io_channel_unix_new(sock);\n\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\tg_io_channel_set_flags(io, G_IO_FLAG_NONBLOCK, NULL);\n\n\treturn io;\n\nfailed:\n\tclose(sock);\n\n\treturn NULL;\n}",
          2
        ],
        [
          "bluez/bluez4/lib/bluetooth.c",
          "bachk",
          "bachk",
          "int bachk(const char *str) /* <=== bachk */ \n{\n\tif (!str)\n\t\treturn -1;\n\n\tif (strlen(str) != 17)\n\t\treturn -1;\n\n\twhile (*str) {\n\t\tif (!isxdigit(*str++))\n\t\t\treturn -1;\n\n\t\tif (!isxdigit(*str++))\n\t\t\treturn -1;\n\n\t\tif (*str == 0)\n\t\t\tbreak;\n\n\t\tif (*str++ != ':')\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          2
        ],
        [
          "<empty>",
          "<operator>.logicalOr",
          "<operator>.logicalOr",
          "",
          1
        ],
        [
          "<empty>",
          "org_bluez_gatt_service1_get_primary",
          "org_bluez_gatt_service1_get_primary",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "bt_io_connect",
          "bt_io_connect",
          "GIOChannel *bt_io_connect(BtIOType type, BtIOConnect connect, /* <=== bt_io_connect */ \n\t\t\t\tgpointer user_data, GDestroyNotify destroy,\n\t\t\t\tGError **gerr, BtIOOption opt1, ...)\n{\n\tGIOChannel *io;\n\tva_list args;\n\tstruct set_opts opts;\n\tint err, sock;\n\tgboolean ret;\n\n\tva_start(args, opt1);\n\tret = parse_set_opts(&opts, gerr, opt1, args);\n\tva_end(args);\n\n\tif (ret == FALSE)\n\t\treturn NULL;\n\n\tio = create_io(type, FALSE, &opts, gerr);\n\tif (io == NULL)\n\t\treturn NULL;\n\n\tsock = g_io_channel_unix_get_fd(io);\n\n\tswitch (type) {\n\tcase BT_IO_L2RAW:\n\t\terr = l2cap_connect(sock, &opts.dst, opts.dst_type, 0,\n\t\t\t\t\t\t\t\topts.cid, opts.timeout);\n\t\tbreak;\n\tcase BT_IO_L2CAP:\n\tcase BT_IO_L2ERTM:\n\t\terr = l2cap_connect(sock, &opts.dst, opts.dst_type,\n\t\t\t\t\t\t\topts.psm, opts.cid, opts.timeout);\n\t\tbreak;\n\tcase BT_IO_RFCOMM:\n\t\terr = rfcomm_connect(sock, &opts.dst, opts.channel);\n\t\tbreak;\n\tcase BT_IO_SCO:\n\t\terr = sco_connect(sock, &opts.dst);\n\t\tbreak;\n\tdefault:\n\t\tg_set_error(gerr, BT_IO_ERROR, BT_IO_ERROR_INVALID_ARGS,\n\t\t\t\t\t\t\"Unknown BtIO type %d\", type);\n\t\treturn NULL;\n\t}\n\n\tif (err < 0) {\n\t\tg_set_error(gerr, BT_IO_ERROR, BT_IO_ERROR_CONNECT_FAILED,\n\t\t\t\t\"connect: %s (%d)\", strerror(-err), -err);\n\t\tg_io_channel_unref(io);\n\t\treturn NULL;\n\t}\n\n\tconnect_add(io, connect, user_data, destroy);\n\n\treturn io;\n}",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "DEFAULT_DEFER_TIMEOUT",
          "bluez/bluez4/btio/btio.c:50:50:DEFAULT_DEFER_TIMEOUT:0",
          "#define DEFAULT_DEFER_TIMEOUT 30 /* <=== bluez/bluez4/btio/btio.c:50:50:DEFAULT_DEFER_TIMEOUT:0 */ ",
          3
        ],
        [
          "<empty>",
          "g_error_free",
          "g_error_free",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/bluetooth.c",
          "str2ba",
          "str2ba",
          "int str2ba(const char *str, bdaddr_t *ba) /* <=== str2ba */ \n{\n\tbdaddr_t b;\n\tint i;\n\n\tif (bachk(str) < 0) {\n\t\tmemset(ba, 0, sizeof(*ba));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 6; i++, str += 3)\n\t\tb.b[i] = strtol(str, NULL, 16);\n\n\tbaswap(ba, &b);\n\n\treturn 0;\n}",
          1
        ],
        [
          "bluez/bluez4/lib/uuid.c",
          "is_uuid16",
          "is_uuid16",
          "static inline int is_uuid16(const char *string) /* <=== is_uuid16 */ \n{\n\treturn (strlen(string) == 4 || strlen(string) == 6);\n}",
          3
        ],
        [
          "<empty>",
          "org_bluez_gatt_service1_proxy_new_for_bus_sync",
          "org_bluez_gatt_service1_proxy_new_for_bus_sync",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/uuid.c",
          "is_uuid32",
          "is_uuid32",
          "static inline int is_uuid32(const char *string) /* <=== is_uuid32 */ \n{\n\treturn (strlen(string) == 8 || strlen(string) == 10);\n}",
          3
        ],
        [
          "<empty>",
          "atoi",
          "atoi",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/gattlib.h",
          "BDADDR_BREDR",
          "bluez/bluez4/btio/gattlib.h:42:42:BDADDR_BREDR:0",
          "",
          3
        ],
        [
          "<empty>",
          "<operator>.addressOf",
          "<operator>.addressOf",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/uuid.c",
          "is_uuid128",
          "is_uuid128",
          "static inline int is_uuid128(const char *string) /* <=== is_uuid128 */ \n{\n\treturn (strlen(string) == 36 &&\n\t\t\tstring[8] == '-' &&\n\t\t\tstring[13] == '-' &&\n\t\t\tstring[18] == '-' &&\n\t\t\tstring[23] == '-');\n}",
          3
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "l2cap_connect",
          "l2cap_connect",
          "static int l2cap_connect(int sock, const bdaddr_t *dst, uint8_t dst_type, /* <=== l2cap_connect */ \n\t\t\t\t\t\tuint16_t psm, uint16_t cid, uint16_t timeout)\n{\n\tint err;\n\tstruct sockaddr_l2 addr;\n\n\tif (timeout > 0) {\n\t\tstruct timeval timeval;\n\t\ttimeval.tv_sec = timeout;\n\t\ttimeval.tv_usec = 0;\n\n\t\tif (setsockopt (sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeval, sizeof(timeval)) < 0) {\n\t\t\tfprintf(stderr, \"l2cap_connect: Failed to setsockopt for receive timeout.\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (setsockopt (sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeval, sizeof(timeval)) < 0) {\n\t\t\tfprintf(stderr, \"l2cap_connect: Failed to setsockopt for sending timeout.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.l2_family = AF_BLUETOOTH;\n\tbacpy(&addr.l2_bdaddr, dst);\n\tif (cid)\n\t\taddr.l2_cid = htobs(cid);\n\telse\n\t\taddr.l2_psm = htobs(psm);\n\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(4, 100)\n\tif (dst_type != BDADDR_BREDR) {\n\t\tfprintf(stderr, \"Require Bluez >= 4.100 to support BLE connections.\\n\");\n\t\treturn -1;\n\t}\n#else\n\taddr.l2_bdaddr_type = dst_type;\n#endif\n\n\terr = connect(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (err < 0 && !(errno == EAGAIN || errno == EINPROGRESS))\n\t\treturn -errno;\n\n\treturn 0;\n}",
          2
        ],
        [
          "bluez/gattlib.h",
          "BDADDR_LE_PUBLIC",
          "bluez/gattlib.h:43:43:BDADDR_LE_PUBLIC:0",
          "",
          1
        ],
        [
          "bluez/gattlib_connect.c",
          "CONNECTION_TIMEOUT",
          "bluez/gattlib_connect.c:39:39:CONNECTION_TIMEOUT:0",
          "#define CONNECTION_TIMEOUT    2 /* <=== bluez/gattlib_connect.c:39:39:CONNECTION_TIMEOUT:0 */ ",
          1
        ],
        [
          "bluez/bluez4/lib/bluetooth.h",
          "bacpy",
          "bacpy",
          "static inline void bacpy(bdaddr_t *dst, const bdaddr_t *src) /* <=== bacpy */ \n{\n\tmemcpy(dst, src, sizeof(bdaddr_t));\n}",
          1
        ],
        [
          "bluez/bluez4/lib/uuid.c",
          "bt_string_to_uuid32",
          "bt_string_to_uuid32",
          "static int bt_string_to_uuid32(bt_uuid_t *uuid, const char *string) /* <=== bt_string_to_uuid32 */ \n{\n\tuint32_t u32;\n\tchar *endptr = NULL;\n\n\tu32 = strtol(string, &endptr, 16);\n\tif (endptr && *endptr == '\\0') {\n\t\tbt_uuid32_create(uuid, u32);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}",
          3
        ],
        [
          "<empty>",
          "<operator>.notEquals",
          "<operator>.notEquals",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "connect_add",
          "connect_add",
          "static void connect_add(GIOChannel *io, BtIOConnect connect, /* <=== connect_add */ \n\t\t\t\tgpointer user_data, GDestroyNotify destroy)\n{\n\tstruct connect *conn;\n\tGIOCondition cond;\n\n\tconn = g_new0(struct connect, 1);\n\tconn->connect = connect;\n\tconn->user_data = user_data;\n\tconn->destroy = destroy;\n\n\tcond = G_IO_OUT | G_IO_ERR | G_IO_HUP | G_IO_NVAL;\n\tconn->source = gattlib_watch_connection_full(io, cond, connect_cb, conn,\n\t\t\t\t\t(GDestroyNotify) connect_remove);\n}",
          2
        ],
        [
          "bluez/gattlib_connect.c",
          "gattlib_watch_connection_full",
          "gattlib_watch_connection_full",
          "GSource* gattlib_watch_connection_full(GIOChannel* io, GIOCondition condition, /* <=== gattlib_watch_connection_full */ \n\t\t\t\t\t\t\t\t GIOFunc func, gpointer user_data, GDestroyNotify notify)\n{\n    // Create a main loop source\n\tGSource *source = g_io_create_watch (io, condition);\n\tassert(source != NULL);\n\n\tg_source_set_callback (source, (GSourceFunc)func, user_data, notify);\n\n    // Attaches it to the main loop context\n\tguint id = g_source_attach(source, g_gattlib_thread.loop_context);\n\tg_source_unref (source);\n\tassert(id != 0);\n\n\treturn source;\n}",
          3
        ],
        [
          "bluez/bluez4/lib/bluetooth.h",
          "BTPROTO_HCI",
          "bluez/bluez4/lib/bluetooth.h:46:46:BTPROTO_HCI:0",
          "#define BTPROTO_HCI\t1 /* <=== bluez/bluez4/lib/bluetooth.h:46:46:BTPROTO_HCI:0 */ ",
          3
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "sco_connect",
          "sco_connect",
          "static int sco_connect(int sock, const bdaddr_t *dst) /* <=== sco_connect */ \n{\n\tstruct sockaddr_sco addr;\n\tint err;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sco_family = AF_BLUETOOTH;\n\tbacpy(&addr.sco_bdaddr, dst);\n\n\terr = connect(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (err < 0 && !(errno == EAGAIN || errno == EINPROGRESS))\n\t\treturn -errno;\n\n\treturn 0;\n}",
          2
        ],
        [
          "<empty>",
          "<operator>.assignment",
          "<operator>.assignment",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "l2cap_bind",
          "l2cap_bind",
          "static int l2cap_bind(int sock, const bdaddr_t *src, uint16_t psm, /* <=== l2cap_bind */ \n\t\t\t\t\t\tuint16_t cid, GError **err)\n{\n\tstruct sockaddr_l2 addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.l2_family = AF_BLUETOOTH;\n\tbacpy(&addr.l2_bdaddr, src);\n\n\tif (cid)\n\t\taddr.l2_cid = htobs(cid);\n\telse\n\t\taddr.l2_psm = htobs(psm);\n\n\tif (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tint error = -errno;\n\t\tERROR_FAILED(err, \"l2cap_bind\", errno);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          3
        ],
        [
          "<empty>",
          "g_object_unref",
          "g_object_unref",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/hci.c",
          "hci_devba",
          "hci_devba",
          "int hci_devba(int dev_id, bdaddr_t *bdaddr) /* <=== hci_devba */ \n{\n\tstruct hci_dev_info di;\n\n\tmemset(&di, 0, sizeof(di));\n\n\tif (hci_devinfo(dev_id, &di))\n\t\treturn -1;\n\n\tif (!hci_test_bit(HCI_UP, &di.flags)) {\n\t\terrno = ENETDOWN;\n\t\treturn -1;\n\t}\n\n\tbacpy(bdaddr, &di.bdaddr);\n\n\treturn 0;\n}",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "l2cap_set",
          "l2cap_set",
          "static gboolean l2cap_set(int sock, int sec_level, uint16_t imtu, /* <=== l2cap_set */ \n\t\t\t\tuint16_t omtu, uint8_t mode, int master,\n\t\t\t\tint flushable, uint32_t priority, GError **err)\n{\n\tif (imtu || omtu || mode) {\n\t\tstruct l2cap_options l2o;\n\t\tsocklen_t len;\n\n\t\tmemset(&l2o, 0, sizeof(l2o));\n\t\tlen = sizeof(l2o);\n\t\tif (getsockopt(sock, SOL_L2CAP, L2CAP_OPTIONS, &l2o,\n\t\t\t\t\t\t\t\t&len) < 0) {\n\t\t\tERROR_FAILED(err, \"getsockopt(L2CAP_OPTIONS)\", errno);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (imtu)\n\t\t\tl2o.imtu = imtu;\n\t\tif (omtu)\n\t\t\tl2o.omtu = omtu;\n\t\tif (mode)\n\t\t\tl2o.mode = mode;\n\n\t\tif (setsockopt(sock, SOL_L2CAP, L2CAP_OPTIONS, &l2o,\n\t\t\t\t\t\t\tsizeof(l2o)) < 0) {\n\t\t\tERROR_FAILED(err, \"setsockopt(L2CAP_OPTIONS)\", errno);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (master >= 0 && l2cap_set_master(sock, master) < 0) {\n\t\tERROR_FAILED(err, \"l2cap_set_master\", errno);\n\t\treturn FALSE;\n\t}\n\n\tif (flushable >= 0 && l2cap_set_flushable(sock, flushable) < 0) {\n\t\tERROR_FAILED(err, \"l2cap_set_flushable\", errno);\n\t\treturn FALSE;\n\t}\n\n\tif (priority > 0 && set_priority(sock, priority) < 0) {\n\t\tERROR_FAILED(err, \"set_priority\", errno);\n\t\treturn FALSE;\n\t}\n\n\tif (sec_level && !set_sec_level(sock, BT_IO_L2CAP, sec_level, err))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}",
          3
        ],
        [
          "<empty>",
          "<operator>.logicalNot",
          "<operator>.logicalNot",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "rfcomm_bind",
          "rfcomm_bind",
          "static int rfcomm_bind(int sock, /* <=== rfcomm_bind */ \n\t\tconst bdaddr_t *src, uint8_t channel, GError **err)\n{\n\tstruct sockaddr_rc addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.rc_family = AF_BLUETOOTH;\n\tbacpy(&addr.rc_bdaddr, src);\n\taddr.rc_channel = channel;\n\n\tif (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tint error = -errno;\n\t\tERROR_FAILED(err, \"rfcomm_bind\", errno);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          3
        ],
        [
          "examples/gatttool/gatttool.c",
          "bt_uuid_to_uuid",
          "bt_uuid_to_uuid",
          "static void bt_uuid_to_uuid(bt_uuid_t* bt_uuid, uuid_t* uuid) { /* <=== bt_uuid_to_uuid */ \n\tmemcpy(&uuid->value, &bt_uuid->value, sizeof(uuid->value));\n\tif (bt_uuid->type == BT_UUID16) {\n\t\tuuid->type = SDP_UUID16;\n\t} else if (bt_uuid->type == BT_UUID32) {\n\t\tuuid->type = SDP_UUID32;\n\t} else if (bt_uuid->type == BT_UUID128) {\n\t\tuuid->type = SDP_UUID128;\n\t} else {\n\t\tuuid->type = SDP_UUID_UNSPEC;\n\t}\n}",
          2
        ],
        [
          "bluez/att.h",
          "ATT_CID",
          "bluez/att.h:92:92:ATT_CID:0",
          "",
          1
        ],
        [
          "<empty>",
          "calloc",
          "calloc",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/bluetooth.c",
          "baswap",
          "baswap",
          "void baswap(bdaddr_t *dst, const bdaddr_t *src) /* <=== baswap */ \n{\n\tregister unsigned char *d = (unsigned char *) dst;\n\tregister const unsigned char *s = (const unsigned char *) src;\n\tregister int i;\n\n\tfor (i = 0; i < 6; i++)\n\t\td[i] = s[5-i];\n}",
          2
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "parse_set_opts",
          "parse_set_opts",
          "static gboolean parse_set_opts(struct set_opts *opts, GError **err, /* <=== parse_set_opts */ \n\t\t\t\t\t\tBtIOOption opt1, va_list args)\n{\n\tBtIOOption opt = opt1;\n\tconst char *str;\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\t/* Set defaults */\n\topts->defer = DEFAULT_DEFER_TIMEOUT;\n\topts->master = -1;\n\topts->mode = L2CAP_MODE_BASIC;\n\topts->flushable = -1;\n\topts->priority = 0;\n\topts->dst_type = BDADDR_BREDR;\n\topts->timeout = 0;\n\n\twhile (opt != BT_IO_OPT_INVALID) {\n\t\tswitch (opt) {\n\t\tcase BT_IO_OPT_SOURCE:\n\t\t\tstr = va_arg(args, const char *);\n\t\t\tstr2ba(str, &opts->src);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_SOURCE_BDADDR:\n\t\t\tbacpy(&opts->src, va_arg(args, const bdaddr_t *));\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_DEST:\n\t\t\tstr2ba(va_arg(args, const char *), &opts->dst);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_DEST_BDADDR:\n\t\t\tbacpy(&opts->dst, va_arg(args, const bdaddr_t *));\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_DEST_TYPE:\n\t\t\topts->dst_type = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_DEFER_TIMEOUT:\n\t\t\topts->defer = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_SEC_LEVEL:\n\t\t\topts->sec_level = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_CHANNEL:\n\t\t\topts->channel = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_PSM:\n\t\t\topts->psm = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_CID:\n\t\t\topts->cid = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_MTU:\n\t\t\topts->mtu = va_arg(args, int);\n\t\t\topts->imtu = opts->mtu;\n\t\t\topts->omtu = opts->mtu;\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_OMTU:\n\t\t\topts->omtu = va_arg(args, int);\n\t\t\tif (!opts->mtu)\n\t\t\t\topts->mtu = opts->omtu;\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_IMTU:\n\t\t\topts->imtu = va_arg(args, int);\n\t\t\tif (!opts->mtu)\n\t\t\t\topts->mtu = opts->imtu;\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_MASTER:\n\t\t\topts->master = va_arg(args, gboolean);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_MODE:\n\t\t\topts->mode = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_FLUSHABLE:\n\t\t\topts->flushable = va_arg(args, gboolean);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_PRIORITY:\n\t\t\topts->priority = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_TIMEOUT:\n\t\t\topts->timeout = va_arg(args, int);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_set_error(err, BT_IO_ERROR, BT_IO_ERROR_INVALID_ARGS,\n\t\t\t\t\t\"Unknown option %d\", opt);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\topt = va_arg(args, int);\n\t}\n\n\treturn TRUE;\n}",
          2
        ],
        [
          "<empty>",
          "<operator>.indirection",
          "<operator>.indirection",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "sco_set",
          "sco_set",
          "static gboolean sco_set(int sock, uint16_t mtu, GError **err) /* <=== sco_set */ \n{\n\tstruct sco_options sco_opt;\n\tsocklen_t len;\n\n\tif (!mtu)\n\t\treturn TRUE;\n\n\tlen = sizeof(sco_opt);\n\tmemset(&sco_opt, 0, len);\n\tif (getsockopt(sock, SOL_SCO, SCO_OPTIONS, &sco_opt, &len) < 0) {\n\t\tERROR_FAILED(err, \"getsockopt(SCO_OPTIONS)\", errno);\n\t\treturn FALSE;\n\t}\n\n\tsco_opt.mtu = mtu;\n\tif (setsockopt(sock, SOL_SCO, SCO_OPTIONS, &sco_opt,\n\t\t\t\t\t\tsizeof(sco_opt)) < 0) {\n\t\tERROR_FAILED(err, \"setsockopt(SCO_OPTIONS)\", errno);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
          3
        ],
        [
          "<empty>",
          "org_bluez_gatt_service1_get_uuid",
          "org_bluez_gatt_service1_get_uuid",
          "",
          1
        ],
        [
          "<empty>",
          "malloc",
          "malloc",
          "",
          1
        ],
        [
          "<empty>",
          "<operator>.indirectIndexAccess",
          "<operator>.indirectIndexAccess",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/hci_lib.h",
          "hci_test_bit",
          "hci_test_bit",
          "static inline int hci_test_bit(int nr, void *addr) /* <=== hci_test_bit */ \n{\n\treturn *((uint32_t *) addr + (nr >> 5)) & (1 << (nr & 31));\n}",
          2
        ],
        [
          "bluez/bluez4/lib/uuid.c",
          "bt_string_to_uuid",
          "bt_string_to_uuid",
          "int bt_string_to_uuid(bt_uuid_t *uuid, const char *string) /* <=== bt_string_to_uuid */ \n{\n\tif (is_uuid128(string))\n\t\treturn bt_string_to_uuid128(uuid, string);\n\telse if (is_uuid32(string))\n\t\treturn bt_string_to_uuid32(uuid, string);\n\telse if (is_uuid16(string))\n\t\treturn bt_string_to_uuid16(uuid, string);\n\n\treturn -EINVAL;\n}",
          2
        ],
        [
          "<empty>",
          "<operator>.equals",
          "<operator>.equals",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "rfcomm_set",
          "rfcomm_set",
          "static gboolean rfcomm_set(int sock, int sec_level, int master, GError **err) /* <=== rfcomm_set */ \n{\n\tif (sec_level && !set_sec_level(sock, BT_IO_RFCOMM, sec_level, err))\n\t\treturn FALSE;\n\n\tif (master >= 0 && rfcomm_set_master(sock, master) < 0) {\n\t\tERROR_FAILED(err, \"rfcomm_set_master\", errno);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
          3
        ],
        [
          "<empty>",
          "<operator>.multiplication",
          "<operator>.multiplication",
          "",
          1
        ],
        [
          "<empty>",
          "fprintf",
          "fprintf",
          "",
          1
        ],
        [
          "dbus/bluez5/lib/uuid.h",
          "MAX_LEN_UUID_STR",
          "dbus/bluez5/lib/uuid.h:165:165:MAX_LEN_UUID_STR:0",
          "#define MAX_LEN_UUID_STR 37 /* <=== dbus/bluez5/lib/uuid.h:165:165:MAX_LEN_UUID_STR:0 */ ",
          1
        ],
        [
          "<empty>",
          "<operator>.addition",
          "<operator>.addition",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/uuid.c",
          "bt_string_to_uuid16",
          "bt_string_to_uuid16",
          "static int bt_string_to_uuid16(bt_uuid_t *uuid, const char *string) /* <=== bt_string_to_uuid16 */ \n{\n\tuint16_t u16;\n\tchar *endptr = NULL;\n\n\tu16 = strtol(string, &endptr, 16);\n\tif (endptr && *endptr == '\\0') {\n\t\tbt_uuid16_create(uuid, u16);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}",
          3
        ],
        [
          "bluez/bluez4/btio/btio.h",
          "BT_IO_ERROR",
          "bluez/bluez4/btio/btio.h:37:37:BT_IO_ERROR:0",
          "#define BT_IO_ERROR bt_io_error_quark() /* <=== bluez/bluez4/btio/btio.h:37:37:BT_IO_ERROR:0 */ ",
          2
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "bt_io_error_quark",
          "bt_io_error_quark",
          "GQuark bt_io_error_quark(void) /* <=== bt_io_error_quark */ \n{\n\treturn g_quark_from_static_string(\"bt-io-error-quark\");\n}",
          2
        ],
        [
          "<empty>",
          "strncmp",
          "strncmp",
          "",
          1
        ],
        [
          "<empty>",
          "<operator>.postIncrement",
          "<operator>.postIncrement",
          "",
          1
        ],
        [
          "<empty>",
          "printf",
          "printf",
          "",
          1
        ],
        [
          "bluez/bluez4/lib/uuid.c",
          "bt_string_to_uuid128",
          "bt_string_to_uuid128",
          "static int bt_string_to_uuid128(bt_uuid_t *uuid, const char *string) /* <=== bt_string_to_uuid128 */ \n{\n\tuint32_t data0, data4;\n\tuint16_t data1, data2, data3, data5;\n\tuint128_t n128, u128;\n\tuint8_t *val = (uint8_t *) &n128;\n\n\tif (sscanf(string, \"%08x-%04hx-%04hx-%04hx-%08x%04hx\",\n\t\t\t\t&data0, &data1, &data2,\n\t\t\t\t&data3, &data4, &data5) != 6)\n\t\treturn -EINVAL;\n\n\tdata0 = htonl(data0);\n\tdata1 = htons(data1);\n\tdata2 = htons(data2);\n\tdata3 = htons(data3);\n\tdata4 = htonl(data4);\n\tdata5 = htons(data5);\n\n\tmemcpy(&val[0], &data0, 4);\n\tmemcpy(&val[4], &data1, 2);\n\tmemcpy(&val[6], &data2, 2);\n\tmemcpy(&val[8], &data3, 2);\n\tmemcpy(&val[10], &data4, 4);\n\tmemcpy(&val[14], &data5, 2);\n\n\tntoh128(&n128, &u128);\n\n\tbt_uuid128_create(uuid, u128);\n\n\treturn 0;\n}",
          3
        ],
        [
          "<empty>",
          "<operator>.logicalAnd",
          "<operator>.logicalAnd",
          "",
          1
        ],
        [
          "gattlib_common.c",
          "gattlib_string_to_uuid",
          "gattlib_string_to_uuid",
          "int gattlib_string_to_uuid(const char *str, size_t n, uuid_t *uuid) { /* <=== gattlib_string_to_uuid */ \n\tbt_uuid_t bt_uuid;\n\n\tint ret = bt_string_to_uuid(&bt_uuid, str);\n\tif (ret == 0) {\n\t\tbt_uuid_to_uuid(&bt_uuid, uuid);\n\t}\n\n\treturn ret;\n}",
          1
        ],
        [
          "<empty>",
          "<operator>.sizeOf",
          "<operator>.sizeOf",
          "",
          1
        ],
        [
          "<empty>",
          "strerror",
          "strerror",
          "",
          1
        ],
        [
          "bluez/gattlib.h",
          "BDADDR_LE_RANDOM",
          "bluez/gattlib.h:44:44:BDADDR_LE_RANDOM:0",
          "",
          1
        ],
        [
          "bluez/bluez4/btio/btio.c",
          "sco_bind",
          "sco_bind",
          "static int sco_bind(int sock, const bdaddr_t *src, GError **err) /* <=== sco_bind */ \n{\n\tstruct sockaddr_sco addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sco_family = AF_BLUETOOTH;\n\tbacpy(&addr.sco_bdaddr, src);\n\n\tif (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tint error = -errno;\n\t\tERROR_FAILED(err, \"sco_bind\", errno);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          3
        ],
        [
          "<empty>",
          "free",
          "free",
          "",
          1
        ],
        [
          "<empty>",
          "g_main_loop_is_running",
          "g_main_loop_is_running",
          "",
          1
        ],
        [
          "<empty>",
          "usleep",
          "usleep",
          "",
          1
        ]
      ],
      "typeDefs": [
        [
          "typedef struct {\n\tGIOChannel*               io;\n\tGAttrib*                  attrib;\n\n\t// We keep a list of characteristics to make the correspondence handle/UUID.\n\tgattlib_characteristic_t* characteristics;\n\tint                       characteristic_count;\n}",
          "gattlib_context_t"
        ],
        [
          "typedef struct {\n\tuint16_t  attr_handle_start;\n\tuint16_t  attr_handle_end;\n\tuuid_t    uuid;\n}",
          "gattlib_primary_service_t"
        ],
        [
          "struct gattlib_thread_t",
          "gattlib_thread_t"
        ],
        [
          "typedef struct {\n\tuint8_t b[6];\n} __attribute__((packed))",
          "bdaddr_t"
        ],
        [
          "typedef struct _gatt_connection_t {\n\tvoid* context;\n\n\tgattlib_event_handler_t notification_handler;\n\tvoid* notification_user_data;\n\n\tgattlib_event_handler_t indication_handler;\n\tvoid* indication_user_data;\n} gatt_connection_t;",
          "gatt_connection_t"
        ],
        [
          "typedef struct {\n\tgatt_connection_t* conn;\n\tgatt_connect_cb_t  connect_cb;\n\tint                connected;\n\tint                timeout;\n\tGError*            error;\n    void*              user_data;\n}",
          "io_connect_arg_t"
        ],
        [
          "typedef enum {\n\tBT_IO_SEC_SDP = 0,\n\tBT_IO_SEC_LOW,\n\tBT_IO_SEC_MEDIUM,\n\tBT_IO_SEC_HIGH,\n}",
          "BtIOSecLevel"
        ]
      ],
      "globalVars": [],
      "importContext": [
        "#include <stdbool.h>",
        "#include \"gattlib_internal.h\"",
        "#include <stdlib.h>",
        "#include <assert.h>",
        "#include \"gattrib.h\"",
        "#include \"hci_lib.h\"",
        "#include \"btio.h\"",
        "#include \"att.h\"",
        "#include \"hci.h\"",
        "#include <bluetooth/bluetooth.h>",
        "#include <glib.h>",
        "#include <pthread.h>",
        "#include <unistd.h>"
      ],
      "vulnerableMethods": [
        [
          "dbus/gattlib.c",
          "gattlib_discover_primary",
          "int gattlib_discover_primary(gatt_connection_t* connection, gattlib_primary_service_t** services, int* services_count) { /* <=== gattlib_discover_primary<duplicate>0 */ \n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezDevice1* device = conn_context->device;\n\tconst gchar* const* service_str;\n\tGError *error = NULL;\n\n\tconst gchar* const* service_strs = org_bluez_device1_get_gatt_services(device);\n\n\tif (service_strs == NULL) {\n\t\t*services       = NULL;\n\t\t*services_count = 0;\n\t\treturn 0;\n\t}\n\n\t// Maximum number of primary services\n\tint count_max = 0, count = 0;\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\tcount_max++;\n\t}\n\n\tgattlib_primary_service_t* primary_services = malloc(count_max * sizeof(gattlib_primary_service_t));\n\tif (primary_services == NULL) {\n\t\treturn 1;\n\t}\n\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\t*service_str,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", *service_str);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (org_bluez_gatt_service1_get_primary(service_proxy)) {\n\t\t\tprimary_services[count].attr_handle_start = 0;\n\t\t\tprimary_services[count].attr_handle_end   = 0;\n\n\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\torg_bluez_gatt_service1_get_uuid(service_proxy),\n\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t&primary_services[count].uuid);\n\t\t\tcount++;\n\t\t}\n\n\t\tg_object_unref(service_proxy);\n\t}\n\n\t*services       = primary_services;\n\t*services_count = count;\n\treturn 0;\n}",
          314
        ],
        [
          "bluez/gattlib_connect.c",
          "initialize_gattlib_connection",
          "static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst, /* <=== initialize_gattlib_connection */ \n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\tstr2ba(dst, &dba);\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3))\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\telse\n\t\t\tstr2ba(src, &sba);\n\t} else\n\t\tbacpy(&sba, BDADDR_ANY);\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}",
          180
        ],
        [
          "dbus/gattlib.c",
          "gattlib_discover_primary",
          "int gattlib_discover_primary(gatt_connection_t* connection, gattlib_primary_service_t** services, int* services_count) { /* <=== gattlib_discover_primary<duplicate>1 */ \n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezDevice1* device = conn_context->device;\n\tconst gchar* const* service_str;\n\tGError *error = NULL;\n\n\tconst gchar* const* service_strs = org_bluez_device1_get_uuids(device);\n\n\tif (service_strs == NULL) {\n\t\t*services       = NULL;\n\t\t*services_count = 0;\n\t\treturn 0;\n\t}\n\n\t// Maximum number of primary services\n\tint count_max = 0, count = 0;\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\tcount_max++;\n\t}\n\n\tgattlib_primary_service_t* primary_services = malloc(count_max * sizeof(gattlib_primary_service_t));\n\tif (primary_services == NULL) {\n\t\treturn 1;\n\t}\n\n\tGDBusObjectManager *device_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn 1;\n\t}\n\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGList *l;\n\tfor (l = objects; l != NULL; l = l->next)  {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattService1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", object_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ensure the service is attached to this device\n\t\tif (strcmp(conn_context->device_object_path, org_bluez_gatt_service1_get_device(service_proxy))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (org_bluez_gatt_service1_get_primary(service_proxy)) {\n\t\t\tprimary_services[count].attr_handle_start = 0;\n\t\t\tprimary_services[count].attr_handle_end   = 0;\n\n\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\torg_bluez_gatt_service1_get_uuid(service_proxy),\n\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t&primary_services[count].uuid);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\tg_object_unref(device_manager);\n\n\t*services       = primary_services;\n\t*services_count = count;\n\treturn 0;\n}",
          372
        ]
      ],
      "visitedLines": {
        "dbus/gattlib.c": [
          314,
          315,
          316,
          318,
          320,
          322,
          329,
          330,
          331,
          334,
          335,
          339,
          340,
          341,
          342,
          343,
          344,
          345,
          346,
          347,
          348,
          349,
          353,
          354,
          355,
          357,
          358,
          359,
          360,
          361,
          364,
          368
        ],
        "bluez/gattlib_connect.c": [
          180,
          185,
          186,
          189,
          193,
          194,
          195,
          196,
          200,
          201,
          205,
          209,
          210,
          211,
          213,
          216,
          217,
          218,
          220,
          222,
          225,
          226,
          229,
          230,
          233,
          234,
          235,
          238,
          239,
          240,
          243,
          246,
          247,
          248,
          249,
          250,
          252,
          253,
          257,
          258,
          262,
          263,
          264,
          265,
          266,
          267,
          269,
          273,
          274,
          278,
          279,
          280,
          281,
          282,
          283,
          286,
          287,
          288,
          289,
          290,
          291,
          293
        ]
      },
      "visitedParams": {
        "dbus/gattlib.c": [
          "gatt_connection_t* connection"
        ]
      }
    }
  },
  {
    "id": 0,
    "func_name": "gattlib_connect",
    "file_path": "dbus/gattlib.c",
    "patch": "--- func_before\n+++ func_after\n@@ -343,7 +343,7 @@\n {\n \tGError *error = NULL;\n \tconst char* adapter_name;\n-\tchar device_address_str[20];\n+\tchar device_address_str[20 + 1];\n \tchar object_path[100];\n \tint i;\n \n@@ -360,6 +360,9 @@\n \t\t\tdevice_address_str[i] = '_';\n \t\t}\n \t}\n+\n+\t// Force a null-terminated character\n+\tdevice_address_str[20] = '\\0';\n \n \t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n \tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);",
    "diff_line_info": {
      "deleted_lines": [
        "\tchar device_address_str[20];"
      ],
      "added_lines": [
        "\tchar device_address_str[20 + 1];",
        "",
        "\t// Force a null-terminated character",
        "\tdevice_address_str[20] = '\\0';"
      ]
    },
    "func_before": "gatt_connection_t *gattlib_connect(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu)\n{\n\tGError *error = NULL;\n\tconst char* adapter_name;\n\tchar device_address_str[20];\n\tchar object_path[100];\n\tint i;\n\n\tif (src) {\n\t\tadapter_name = src;\n\t} else {\n\t\tadapter_name = \"hci0\";\n\t}\n\n\t// Transform string from 'DA:94:40:95:E0:87' to 'dev_DA_94_40_95_E0_87'\n\tstrncpy(device_address_str, dst, sizeof(device_address_str));\n\tfor (i = 0; i < strlen(device_address_str); i++) {\n\t\tif (device_address_str[i] == ':') {\n\t\t\tdevice_address_str[i] = '_';\n\t\t}\n\t}\n\n\t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n\tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* connection = calloc(sizeof(gatt_connection_t), 1);\n\tif (connection == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tconnection->context = conn_context;\n\t}\n\n\tOrgBluezDevice1* device = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL,\n\t\t\t&error);\n\tif (device == NULL) {\n\t\tgoto FREE_CONNECTION;\n\t} else {\n\t\tconn_context->device = device;\n\t\tconn_context->device_object_path = strdup(object_path);\n\t}\n\n\terror = NULL;\n\torg_bluez_device1_call_connect_sync(device, NULL, &error);\n\tif (error) {\n\t\tprintf(\"Device connected error: %s\\n\", error->message);\n\t\tgoto FREE_DEVICE;\n\t}\n\n\t// Wait for the property 'UUIDs' to be changed. We assume 'org.bluez.GattService1\n\t// and 'org.bluez.GattCharacteristic1' to be advertised at that moment.\n\tGMainLoop *loop = g_main_loop_new(NULL, 0);\n\n\t// Register a handle for notification\n\tg_signal_connect(device,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (on_handle_device_property_change),\n\t\tloop);\n\n\tg_timeout_add_seconds (CONNECT_TIMEOUT, stop_scan_func, loop);\n\tg_main_loop_run(loop);\n\tg_main_loop_unref(loop);\n\n\treturn connection;\n\nFREE_DEVICE:\n\tfree(conn_context->device_object_path);\n\tg_object_unref(conn_context->device);\n\nFREE_CONNECTION:\n\tfree(connection);\n\treturn NULL;\n}",
    "func_after": "gatt_connection_t *gattlib_connect(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu)\n{\n\tGError *error = NULL;\n\tconst char* adapter_name;\n\tchar device_address_str[20 + 1];\n\tchar object_path[100];\n\tint i;\n\n\tif (src) {\n\t\tadapter_name = src;\n\t} else {\n\t\tadapter_name = \"hci0\";\n\t}\n\n\t// Transform string from 'DA:94:40:95:E0:87' to 'dev_DA_94_40_95_E0_87'\n\tstrncpy(device_address_str, dst, sizeof(device_address_str));\n\tfor (i = 0; i < strlen(device_address_str); i++) {\n\t\tif (device_address_str[i] == ':') {\n\t\t\tdevice_address_str[i] = '_';\n\t\t}\n\t}\n\n\t// Force a null-terminated character\n\tdevice_address_str[20] = '\\0';\n\n\t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n\tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* connection = calloc(sizeof(gatt_connection_t), 1);\n\tif (connection == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tconnection->context = conn_context;\n\t}\n\n\tOrgBluezDevice1* device = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL,\n\t\t\t&error);\n\tif (device == NULL) {\n\t\tgoto FREE_CONNECTION;\n\t} else {\n\t\tconn_context->device = device;\n\t\tconn_context->device_object_path = strdup(object_path);\n\t}\n\n\terror = NULL;\n\torg_bluez_device1_call_connect_sync(device, NULL, &error);\n\tif (error) {\n\t\tprintf(\"Device connected error: %s\\n\", error->message);\n\t\tgoto FREE_DEVICE;\n\t}\n\n\t// Wait for the property 'UUIDs' to be changed. We assume 'org.bluez.GattService1\n\t// and 'org.bluez.GattCharacteristic1' to be advertised at that moment.\n\tGMainLoop *loop = g_main_loop_new(NULL, 0);\n\n\t// Register a handle for notification\n\tg_signal_connect(device,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (on_handle_device_property_change),\n\t\tloop);\n\n\tg_timeout_add_seconds (CONNECT_TIMEOUT, stop_scan_func, loop);\n\tg_main_loop_run(loop);\n\tg_main_loop_unref(loop);\n\n\treturn connection;\n\nFREE_DEVICE:\n\tfree(conn_context->device_object_path);\n\tg_object_unref(conn_context->device);\n\nFREE_CONNECTION:\n\tfree(connection);\n\treturn NULL;\n}",
    "Bug Filter": "Security Vulnerability Fix",
    "Bug Filter Confidence": 1.0,
    "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
  },
  {
    "id": 1,
    "func_name": "initialize_gattlib_connection",
    "file_path": "bluez/gattlib_connect.c",
    "patch": "--- func_before\n+++ func_after\n@@ -185,6 +185,9 @@\n {\n \tbdaddr_t sba, dba;\n \tGError *err = NULL;\n+\tint ret;\n+\n+\tio_connect_arg->error = NULL;\n \n \t/* Check if the GattLib thread has been started */\n \tif (g_gattlib_thread.ref == 0) {\n@@ -211,16 +214,27 @@\n \t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n \t\treturn NULL;\n \t}\n-\tstr2ba(dst, &dba);\n+\n+\tret = str2ba(dst, &dba);\n+\tif (ret != 0) {\n+\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);\n+\t\treturn NULL;\n+\t}\n \n \t/* Local adapter */\n \tif (src != NULL) {\n-\t\tif (!strncmp(src, \"hci\", 3))\n+\t\tif (!strncmp(src, \"hci\", 3)) {\n \t\t\thci_devba(atoi(src + 3), &sba);\n-\t\telse\n-\t\t\tstr2ba(src, &sba);\n-\t} else\n+\t\t} else {\n+\t\t\tret = str2ba(src, &sba);\n+\t\t\tif (ret != 0) {\n+\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);\n+\t\t\t\treturn NULL;\n+\t\t\t}\n+\t\t}\n+\t} else {\n \t\tbacpy(&sba, BDADDR_ANY);\n+\t}\n \n \t/* Not used for BR/EDR */\n \tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {",
    "diff_line_info": {
      "deleted_lines": [
        "\tstr2ba(dst, &dba);",
        "\t\tif (!strncmp(src, \"hci\", 3))",
        "\t\telse",
        "\t\t\tstr2ba(src, &sba);",
        "\t} else"
      ],
      "added_lines": [
        "\tint ret;",
        "",
        "\tio_connect_arg->error = NULL;",
        "",
        "\tret = str2ba(dst, &dba);",
        "\tif (ret != 0) {",
        "\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);",
        "\t\treturn NULL;",
        "\t}",
        "\t\tif (!strncmp(src, \"hci\", 3)) {",
        "\t\t} else {",
        "\t\t\tret = str2ba(src, &sba);",
        "\t\t\tif (ret != 0) {",
        "\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);",
        "\t\t\t\treturn NULL;",
        "\t\t\t}",
        "\t\t}",
        "\t} else {",
        "\t}"
      ]
    },
    "func_before": "static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst,\n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\tstr2ba(dst, &dba);\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3))\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\telse\n\t\t\tstr2ba(src, &sba);\n\t} else\n\t\tbacpy(&sba, BDADDR_ANY);\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}",
    "func_after": "static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst,\n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\tint ret;\n\n\tio_connect_arg->error = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = str2ba(dst, &dba);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);\n\t\treturn NULL;\n\t}\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3)) {\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\t} else {\n\t\t\tret = str2ba(src, &sba);\n\t\t\tif (ret != 0) {\n\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbacpy(&sba, BDADDR_ANY);\n\t}\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}",
    "Bug Filter": "Security Vulnerability Fix",
    "Bug Filter Confidence": 0.95,
    "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe changes address a buffer overflow by adding checks for input validation, which aligns with the commit message indicating a security fix."
  }
]