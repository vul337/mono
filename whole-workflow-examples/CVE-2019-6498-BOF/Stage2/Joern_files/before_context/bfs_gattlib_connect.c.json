{
  "calleeMethods": [["<empty>", "<operator>.equals", "<operator>.equals", "", 1], ["<empty>", "g_main_loop_is_running", "g_main_loop_is_running", "", 1], ["bluez/bluez4/lib/bluetooth.h", "AF_BLUETOOTH", "bluez/bluez4/lib/bluetooth.h:41:41:AF_BLUETOOTH:0", "#define AF_BLUETOOTH\t31 /* <=== bluez/bluez4/lib/bluetooth.h:41:41:AF_BLUETOOTH:0 */ ", 3], ["bluez/bluez4/btio/btio.c", "sco_connect", "sco_connect", "static int sco_connect(int sock, const bdaddr_t *dst) /* <=== sco_connect */ \n{\n\tstruct sockaddr_sco addr;\n\tint err;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sco_family = AF_BLUETOOTH;\n\tbacpy(&addr.sco_bdaddr, dst);\n\n\terr = connect(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (err < 0 && !(errno == EAGAIN || errno == EINPROGRESS))\n\t\treturn -errno;\n\n\treturn 0;\n}", 2], ["bluez/bluez4/lib/bluetooth.h", "bacpy", "bacpy", "static inline void bacpy(bdaddr_t *dst, const bdaddr_t *src) /* <=== bacpy */ \n{\n\tmemcpy(dst, src, sizeof(bdaddr_t));\n}", 1], ["bluez/bluez4/lib/bluetooth.h", "BTPROTO_HCI", "bluez/bluez4/lib/bluetooth.h:46:46:BTPROTO_HCI:0", "#define BTPROTO_HCI\t1 /* <=== bluez/bluez4/lib/bluetooth.h:46:46:BTPROTO_HCI:0 */ ", 3], ["bluez/bluez4/btio/btio.c", "parse_set_opts", "parse_set_opts", "static gboolean parse_set_opts(struct set_opts *opts, GError **err, /* <=== parse_set_opts */ \n\t\t\t\t\t\tBtIOOption opt1, va_list args)\n{\n\tBtIOOption opt = opt1;\n\tconst char *str;\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\t/* Set defaults */\n\topts->defer = DEFAULT_DEFER_TIMEOUT;\n\topts->master = -1;\n\topts->mode = L2CAP_MODE_BASIC;\n\topts->flushable = -1;\n\topts->priority = 0;\n\topts->dst_type = BDADDR_BREDR;\n\topts->timeout = 0;\n\n\twhile (opt != BT_IO_OPT_INVALID) {\n\t\tswitch (opt) {\n\t\tcase BT_IO_OPT_SOURCE:\n\t\t\tstr = va_arg(args, const char *);\n\t\t\tstr2ba(str, &opts->src);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_SOURCE_BDADDR:\n\t\t\tbacpy(&opts->src, va_arg(args, const bdaddr_t *));\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_DEST:\n\t\t\tstr2ba(va_arg(args, const char *), &opts->dst);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_DEST_BDADDR:\n\t\t\tbacpy(&opts->dst, va_arg(args, const bdaddr_t *));\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_DEST_TYPE:\n\t\t\topts->dst_type = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_DEFER_TIMEOUT:\n\t\t\topts->defer = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_SEC_LEVEL:\n\t\t\topts->sec_level = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_CHANNEL:\n\t\t\topts->channel = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_PSM:\n\t\t\topts->psm = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_CID:\n\t\t\topts->cid = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_MTU:\n\t\t\topts->mtu = va_arg(args, int);\n\t\t\topts->imtu = opts->mtu;\n\t\t\topts->omtu = opts->mtu;\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_OMTU:\n\t\t\topts->omtu = va_arg(args, int);\n\t\t\tif (!opts->mtu)\n\t\t\t\topts->mtu = opts->omtu;\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_IMTU:\n\t\t\topts->imtu = va_arg(args, int);\n\t\t\tif (!opts->mtu)\n\t\t\t\topts->mtu = opts->imtu;\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_MASTER:\n\t\t\topts->master = va_arg(args, gboolean);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_MODE:\n\t\t\topts->mode = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_FLUSHABLE:\n\t\t\topts->flushable = va_arg(args, gboolean);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_PRIORITY:\n\t\t\topts->priority = va_arg(args, int);\n\t\t\tbreak;\n\t\tcase BT_IO_OPT_TIMEOUT:\n\t\t\topts->timeout = va_arg(args, int);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_set_error(err, BT_IO_ERROR, BT_IO_ERROR_INVALID_ARGS,\n\t\t\t\t\t\"Unknown option %d\", opt);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\topt = va_arg(args, int);\n\t}\n\n\treturn TRUE;\n}", 2], ["bluez/bluez4/btio/btio.c", "bt_io_error_quark", "bt_io_error_quark", "GQuark bt_io_error_quark(void) /* <=== bt_io_error_quark */ \n{\n\treturn g_quark_from_static_string(\"bt-io-error-quark\");\n}", 2], ["bluez/bluez4/lib/bluetooth.c", "str2ba", "str2ba", "int str2ba(const char *str, bdaddr_t *ba) /* <=== str2ba */ \n{\n\tbdaddr_t b;\n\tint i;\n\n\tif (bachk(str) < 0) {\n\t\tmemset(ba, 0, sizeof(*ba));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 6; i++, str += 3)\n\t\tb.b[i] = strtol(str, NULL, 16);\n\n\tbaswap(ba, &b);\n\n\treturn 0;\n}", 1], ["bluez/bluez4/btio/btio.c", "create_io", "create_io", "static GIOChannel *create_io(BtIOType type, gboolean server, /* <=== create_io */ \n\t\t\t\t\tstruct set_opts *opts, GError **err)\n{\n\tint sock;\n\tGIOChannel *io;\n\n\tswitch (type) {\n\tcase BT_IO_L2RAW:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(RAW, L2CAP)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (l2cap_bind(sock, &opts->src, server ? opts->psm : 0,\n\t\t\t\t\t\t\topts->cid, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!l2cap_set(sock, opts->sec_level, 0, 0, 0, -1, -1, 0, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tcase BT_IO_L2CAP:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(SEQPACKET, L2CAP)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (l2cap_bind(sock, &opts->src, server ? opts->psm : 0,\n\t\t\t\t\t\t\topts->cid, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!l2cap_set(sock, opts->sec_level, opts->imtu, opts->omtu,\n\t\t\t\topts->mode, opts->master, opts->flushable,\n\t\t\t\topts->priority, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tcase BT_IO_L2ERTM:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(STREAM, L2CAP)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (l2cap_bind(sock, &opts->src, server ? opts->psm : 0,\n\t\t\t\t\t\t\topts->cid, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!l2cap_set(sock, opts->sec_level, opts->imtu, opts->omtu,\n\t\t\t\topts->mode, opts->master, opts->flushable,\n\t\t\t\topts->priority, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tcase BT_IO_RFCOMM:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(STREAM, RFCOMM)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (rfcomm_bind(sock, &opts->src,\n\t\t\t\t\tserver ? opts->channel : 0, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!rfcomm_set(sock, opts->sec_level, opts->master, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tcase BT_IO_SCO:\n\t\tsock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_SCO);\n\t\tif (sock < 0) {\n\t\t\tERROR_FAILED(err, \"socket(SEQPACKET, SCO)\", errno);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (sco_bind(sock, &opts->src, err) < 0)\n\t\t\tgoto failed;\n\t\tif (!sco_set(sock, opts->mtu, err))\n\t\t\tgoto failed;\n\t\tbreak;\n\tdefault:\n\t\tg_set_error(err, BT_IO_ERROR, BT_IO_ERROR_INVALID_ARGS,\n\t\t\t\t\"Unknown BtIO type %d\", type);\n\t\treturn NULL;\n\t}\n\n\tio = g_io_channel_unix_new(sock);\n\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\tg_io_channel_set_flags(io, G_IO_FLAG_NONBLOCK, NULL);\n\n\treturn io;\n\nfailed:\n\tclose(sock);\n\n\treturn NULL;\n}", 2], ["bluez/bluez4/btio/btio.c", "l2cap_set", "l2cap_set", "static gboolean l2cap_set(int sock, int sec_level, uint16_t imtu, /* <=== l2cap_set */ \n\t\t\t\tuint16_t omtu, uint8_t mode, int master,\n\t\t\t\tint flushable, uint32_t priority, GError **err)\n{\n\tif (imtu || omtu || mode) {\n\t\tstruct l2cap_options l2o;\n\t\tsocklen_t len;\n\n\t\tmemset(&l2o, 0, sizeof(l2o));\n\t\tlen = sizeof(l2o);\n\t\tif (getsockopt(sock, SOL_L2CAP, L2CAP_OPTIONS, &l2o,\n\t\t\t\t\t\t\t\t&len) < 0) {\n\t\t\tERROR_FAILED(err, \"getsockopt(L2CAP_OPTIONS)\", errno);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (imtu)\n\t\t\tl2o.imtu = imtu;\n\t\tif (omtu)\n\t\t\tl2o.omtu = omtu;\n\t\tif (mode)\n\t\t\tl2o.mode = mode;\n\n\t\tif (setsockopt(sock, SOL_L2CAP, L2CAP_OPTIONS, &l2o,\n\t\t\t\t\t\t\tsizeof(l2o)) < 0) {\n\t\t\tERROR_FAILED(err, \"setsockopt(L2CAP_OPTIONS)\", errno);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (master >= 0 && l2cap_set_master(sock, master) < 0) {\n\t\tERROR_FAILED(err, \"l2cap_set_master\", errno);\n\t\treturn FALSE;\n\t}\n\n\tif (flushable >= 0 && l2cap_set_flushable(sock, flushable) < 0) {\n\t\tERROR_FAILED(err, \"l2cap_set_flushable\", errno);\n\t\treturn FALSE;\n\t}\n\n\tif (priority > 0 && set_priority(sock, priority) < 0) {\n\t\tERROR_FAILED(err, \"set_priority\", errno);\n\t\treturn FALSE;\n\t}\n\n\tif (sec_level && !set_sec_level(sock, BT_IO_L2CAP, sec_level, err))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}", 3], ["bluez/bluez4/btio/btio.c", "l2cap_connect", "l2cap_connect", "static int l2cap_connect(int sock, const bdaddr_t *dst, uint8_t dst_type, /* <=== l2cap_connect */ \n\t\t\t\t\t\tuint16_t psm, uint16_t cid, uint16_t timeout)\n{\n\tint err;\n\tstruct sockaddr_l2 addr;\n\n\tif (timeout > 0) {\n\t\tstruct timeval timeval;\n\t\ttimeval.tv_sec = timeout;\n\t\ttimeval.tv_usec = 0;\n\n\t\tif (setsockopt (sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeval, sizeof(timeval)) < 0) {\n\t\t\tfprintf(stderr, \"l2cap_connect: Failed to setsockopt for receive timeout.\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (setsockopt (sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeval, sizeof(timeval)) < 0) {\n\t\t\tfprintf(stderr, \"l2cap_connect: Failed to setsockopt for sending timeout.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.l2_family = AF_BLUETOOTH;\n\tbacpy(&addr.l2_bdaddr, dst);\n\tif (cid)\n\t\taddr.l2_cid = htobs(cid);\n\telse\n\t\taddr.l2_psm = htobs(psm);\n\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(4, 100)\n\tif (dst_type != BDADDR_BREDR) {\n\t\tfprintf(stderr, \"Require Bluez >= 4.100 to support BLE connections.\\n\");\n\t\treturn -1;\n\t}\n#else\n\taddr.l2_bdaddr_type = dst_type;\n#endif\n\n\terr = connect(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (err < 0 && !(errno == EAGAIN || errno == EINPROGRESS))\n\t\treturn -errno;\n\n\treturn 0;\n}", 2], ["bluez/bluez4/lib/hci.c", "hci_devinfo", "hci_devinfo", "int hci_devinfo(int dev_id, struct hci_dev_info *di) /* <=== hci_devinfo */ \n{\n\tint dd, err, ret;\n\n\tdd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);\n\tif (dd < 0)\n\t\treturn dd;\n\n\tmemset(di, 0, sizeof(struct hci_dev_info));\n\n\tdi->dev_id = dev_id;\n\tret = ioctl(dd, HCIGETDEVINFO, (void *) di);\n\n\terr = errno;\n\tclose(dd);\n\terrno = err;\n\n\treturn ret;\n}", 2], ["bluez/bluez4/btio/btio.c", "ERROR_FAILED", "bluez/bluez4/btio/btio.c:46:48:ERROR_FAILED:3", "#define ERROR_FAILED(gerr, str, err) \\ /* <=== bluez/bluez4/btio/btio.c:46:48:ERROR_FAILED:3 */ \n\t\tg_set_error(gerr, BT_IO_ERROR, BT_IO_ERROR_FAILED, \\\n\t\t\t\tstr \": %s (%d)\", strerror(err), err)", 3], ["bluez/bluez4/btio/btio.c", "DEFAULT_DEFER_TIMEOUT", "bluez/bluez4/btio/btio.c:50:50:DEFAULT_DEFER_TIMEOUT:0", "#define DEFAULT_DEFER_TIMEOUT 30 /* <=== bluez/bluez4/btio/btio.c:50:50:DEFAULT_DEFER_TIMEOUT:0 */ ", 3], ["<empty>", "<operator>.fieldAccess", "<operator>.fieldAccess", "", 1], ["bluez/gattlib_connect.c", "gattlib_watch_connection_full", "gattlib_watch_connection_full", "GSource* gattlib_watch_connection_full(GIOChannel* io, GIOCondition condition, /* <=== gattlib_watch_connection_full */ \n\t\t\t\t\t\t\t\t GIOFunc func, gpointer user_data, GDestroyNotify notify)\n{\n    // Create a main loop source\n\tGSource *source = g_io_create_watch (io, condition);\n\tassert(source != NULL);\n\n\tg_source_set_callback (source, (GSourceFunc)func, user_data, notify);\n\n    // Attaches it to the main loop context\n\tguint id = g_source_attach(source, g_gattlib_thread.loop_context);\n\tg_source_unref (source);\n\tassert(id != 0);\n\n\treturn source;\n}", 3], ["<empty>", "strerror", "strerror", "", 1], ["bluez/bluez4/lib/hci_lib.h", "hci_test_bit", "hci_test_bit", "static inline int hci_test_bit(int nr, void *addr) /* <=== hci_test_bit */ \n{\n\treturn *((uint32_t *) addr + (nr >> 5)) & (1 << (nr & 31));\n}", 2], ["<empty>", "<operator>.notEquals", "<operator>.notEquals", "", 1], ["bluez/gattlib.h", "BDADDR_LE_RANDOM", "bluez/gattlib.h:44:44:BDADDR_LE_RANDOM:0", "", 1], ["<empty>", "<operator>.sizeOf", "<operator>.sizeOf", "", 1], ["bluez/att.h", "ATT_CID", "bluez/att.h:92:92:ATT_CID:0", "", 1], ["bluez/bluez4/btio/btio.c", "sco_bind", "sco_bind", "static int sco_bind(int sock, const bdaddr_t *src, GError **err) /* <=== sco_bind */ \n{\n\tstruct sockaddr_sco addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sco_family = AF_BLUETOOTH;\n\tbacpy(&addr.sco_bdaddr, src);\n\n\tif (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tint error = -errno;\n\t\tERROR_FAILED(err, \"sco_bind\", errno);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}", 3], ["bluez/bluez4/btio/btio.c", "bt_io_connect", "bt_io_connect", "GIOChannel *bt_io_connect(BtIOType type, BtIOConnect connect, /* <=== bt_io_connect */ \n\t\t\t\tgpointer user_data, GDestroyNotify destroy,\n\t\t\t\tGError **gerr, BtIOOption opt1, ...)\n{\n\tGIOChannel *io;\n\tva_list args;\n\tstruct set_opts opts;\n\tint err, sock;\n\tgboolean ret;\n\n\tva_start(args, opt1);\n\tret = parse_set_opts(&opts, gerr, opt1, args);\n\tva_end(args);\n\n\tif (ret == FALSE)\n\t\treturn NULL;\n\n\tio = create_io(type, FALSE, &opts, gerr);\n\tif (io == NULL)\n\t\treturn NULL;\n\n\tsock = g_io_channel_unix_get_fd(io);\n\n\tswitch (type) {\n\tcase BT_IO_L2RAW:\n\t\terr = l2cap_connect(sock, &opts.dst, opts.dst_type, 0,\n\t\t\t\t\t\t\t\topts.cid, opts.timeout);\n\t\tbreak;\n\tcase BT_IO_L2CAP:\n\tcase BT_IO_L2ERTM:\n\t\terr = l2cap_connect(sock, &opts.dst, opts.dst_type,\n\t\t\t\t\t\t\topts.psm, opts.cid, opts.timeout);\n\t\tbreak;\n\tcase BT_IO_RFCOMM:\n\t\terr = rfcomm_connect(sock, &opts.dst, opts.channel);\n\t\tbreak;\n\tcase BT_IO_SCO:\n\t\terr = sco_connect(sock, &opts.dst);\n\t\tbreak;\n\tdefault:\n\t\tg_set_error(gerr, BT_IO_ERROR, BT_IO_ERROR_INVALID_ARGS,\n\t\t\t\t\t\t\"Unknown BtIO type %d\", type);\n\t\treturn NULL;\n\t}\n\n\tif (err < 0) {\n\t\tg_set_error(gerr, BT_IO_ERROR, BT_IO_ERROR_CONNECT_FAILED,\n\t\t\t\t\"connect: %s (%d)\", strerror(-err), -err);\n\t\tg_io_channel_unref(io);\n\t\treturn NULL;\n\t}\n\n\tconnect_add(io, connect, user_data, destroy);\n\n\treturn io;\n}", 1], ["bluez/gattlib.h", "BDADDR_LE_PUBLIC", "bluez/gattlib.h:43:43:BDADDR_LE_PUBLIC:0", "", 1], ["<empty>", "calloc", "calloc", "", 1], ["<empty>", "<operator>.logicalNot", "<operator>.logicalNot", "", 1], ["<empty>", "<operator>.logicalAnd", "<operator>.logicalAnd", "", 1], ["<empty>", "<operator>.postIncrement", "<operator>.postIncrement", "", 1], ["<empty>", "free", "free", "", 1], ["<empty>", "<operator>.indirectFieldAccess", "<operator>.indirectFieldAccess", "", 1], ["bluez/bluez4/btio/btio.h", "BT_IO_ERROR", "bluez/bluez4/btio/btio.h:37:37:BT_IO_ERROR:0", "#define BT_IO_ERROR bt_io_error_quark() /* <=== bluez/bluez4/btio/btio.h:37:37:BT_IO_ERROR:0 */ ", 2], ["bluez/bluez4/btio/btio.c", "connect_add", "connect_add", "static void connect_add(GIOChannel *io, BtIOConnect connect, /* <=== connect_add */ \n\t\t\t\tgpointer user_data, GDestroyNotify destroy)\n{\n\tstruct connect *conn;\n\tGIOCondition cond;\n\n\tconn = g_new0(struct connect, 1);\n\tconn->connect = connect;\n\tconn->user_data = user_data;\n\tconn->destroy = destroy;\n\n\tcond = G_IO_OUT | G_IO_ERR | G_IO_HUP | G_IO_NVAL;\n\tconn->source = gattlib_watch_connection_full(io, cond, connect_cb, conn,\n\t\t\t\t\t(GDestroyNotify) connect_remove);\n}", 2], ["bluez/bluez4/btio/btio.c", "l2cap_bind", "l2cap_bind", "static int l2cap_bind(int sock, const bdaddr_t *src, uint16_t psm, /* <=== l2cap_bind */ \n\t\t\t\t\t\tuint16_t cid, GError **err)\n{\n\tstruct sockaddr_l2 addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.l2_family = AF_BLUETOOTH;\n\tbacpy(&addr.l2_bdaddr, src);\n\n\tif (cid)\n\t\taddr.l2_cid = htobs(cid);\n\telse\n\t\taddr.l2_psm = htobs(psm);\n\n\tif (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tint error = -errno;\n\t\tERROR_FAILED(err, \"l2cap_bind\", errno);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}", 3], ["<empty>", "g_error_free", "g_error_free", "", 1], ["<empty>", "strncmp", "strncmp", "", 1], ["<empty>", "usleep", "usleep", "", 1], ["<empty>", "fprintf", "fprintf", "", 1], ["bluez/bluez4/lib/bluetooth.c", "bachk", "bachk", "int bachk(const char *str) /* <=== bachk */ \n{\n\tif (!str)\n\t\treturn -1;\n\n\tif (strlen(str) != 17)\n\t\treturn -1;\n\n\twhile (*str) {\n\t\tif (!isxdigit(*str++))\n\t\t\treturn -1;\n\n\t\tif (!isxdigit(*str++))\n\t\t\treturn -1;\n\n\t\tif (*str == 0)\n\t\t\tbreak;\n\n\t\tif (*str++ != ':')\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}", 2], ["bluez/gattlib_connect.c", "CONNECTION_TIMEOUT", "bluez/gattlib_connect.c:39:39:CONNECTION_TIMEOUT:0", "#define CONNECTION_TIMEOUT    2 /* <=== bluez/gattlib_connect.c:39:39:CONNECTION_TIMEOUT:0 */ ", 1], ["<empty>", "<operator>.addressOf", "<operator>.addressOf", "", 1], ["bluez/bluez4/btio/btio.c", "rfcomm_connect", "rfcomm_connect", "static int rfcomm_connect(int sock, const bdaddr_t *dst, uint8_t channel) /* <=== rfcomm_connect */ \n{\n\tint err;\n\tstruct sockaddr_rc addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.rc_family = AF_BLUETOOTH;\n\tbacpy(&addr.rc_bdaddr, dst);\n\taddr.rc_channel = channel;\n\n\terr = connect(sock, (struct sockaddr *) &addr, sizeof(addr));\n\tif (err < 0 && !(errno == EAGAIN || errno == EINPROGRESS))\n\t\treturn -errno;\n\n\treturn 0;\n}", 2], ["bluez/bluez4/btio/btio.c", "rfcomm_set", "rfcomm_set", "static gboolean rfcomm_set(int sock, int sec_level, int master, GError **err) /* <=== rfcomm_set */ \n{\n\tif (sec_level && !set_sec_level(sock, BT_IO_RFCOMM, sec_level, err))\n\t\treturn FALSE;\n\n\tif (master >= 0 && rfcomm_set_master(sock, master) < 0) {\n\t\tERROR_FAILED(err, \"rfcomm_set_master\", errno);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", 3], ["bluez/bluez4/btio/btio.c", "sco_set", "sco_set", "static gboolean sco_set(int sock, uint16_t mtu, GError **err) /* <=== sco_set */ \n{\n\tstruct sco_options sco_opt;\n\tsocklen_t len;\n\n\tif (!mtu)\n\t\treturn TRUE;\n\n\tlen = sizeof(sco_opt);\n\tmemset(&sco_opt, 0, len);\n\tif (getsockopt(sock, SOL_SCO, SCO_OPTIONS, &sco_opt, &len) < 0) {\n\t\tERROR_FAILED(err, \"getsockopt(SCO_OPTIONS)\", errno);\n\t\treturn FALSE;\n\t}\n\n\tsco_opt.mtu = mtu;\n\tif (setsockopt(sock, SOL_SCO, SCO_OPTIONS, &sco_opt,\n\t\t\t\t\t\tsizeof(sco_opt)) < 0) {\n\t\tERROR_FAILED(err, \"setsockopt(SCO_OPTIONS)\", errno);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", 3], ["bluez/bluez4/lib/hci.c", "hci_devba", "hci_devba", "int hci_devba(int dev_id, bdaddr_t *bdaddr) /* <=== hci_devba */ \n{\n\tstruct hci_dev_info di;\n\n\tmemset(&di, 0, sizeof(di));\n\n\tif (hci_devinfo(dev_id, &di))\n\t\treturn -1;\n\n\tif (!hci_test_bit(HCI_UP, &di.flags)) {\n\t\terrno = ENETDOWN;\n\t\treturn -1;\n\t}\n\n\tbacpy(bdaddr, &di.bdaddr);\n\n\treturn 0;\n}", 1], ["<empty>", "<operator>.addition", "<operator>.addition", "", 1], ["<empty>", "<operator>.logicalOr", "<operator>.logicalOr", "", 1], ["bluez/bluez4/btio/gattlib.h", "BDADDR_BREDR", "bluez/bluez4/btio/gattlib.h:42:42:BDADDR_BREDR:0", "", 3], ["bluez/bluez4/btio/btio.c", "rfcomm_bind", "rfcomm_bind", "static int rfcomm_bind(int sock, /* <=== rfcomm_bind */ \n\t\tconst bdaddr_t *src, uint8_t channel, GError **err)\n{\n\tstruct sockaddr_rc addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.rc_family = AF_BLUETOOTH;\n\tbacpy(&addr.rc_bdaddr, src);\n\taddr.rc_channel = channel;\n\n\tif (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tint error = -errno;\n\t\tERROR_FAILED(err, \"rfcomm_bind\", errno);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}", 3], ["<empty>", "<operator>.assignment", "<operator>.assignment", "", 1], ["<empty>", "pthread_create", "pthread_create", "", 1], ["<empty>", "atoi", "atoi", "", 1], ["bluez/bluez4/lib/bluetooth.c", "baswap", "baswap", "void baswap(bdaddr_t *dst, const bdaddr_t *src) /* <=== baswap */ \n{\n\tregister unsigned char *d = (unsigned char *) dst;\n\tregister const unsigned char *s = (const unsigned char *) src;\n\tregister int i;\n\n\tfor (i = 0; i < 6; i++)\n\t\td[i] = s[5-i];\n}", 2]],
  "globalVars": [],
  "importContext": ["#include <assert.h>", "#include <pthread.h>", "#include <stdlib.h>", "#include <unistd.h>", "#include <bluetooth/bluetooth.h>", "#include \"gattlib_internal.h\"", "#include \"att.h\"", "#include \"btio.h\"", "#include \"gattrib.h\"", "#include \"hci.h\"", "#include \"hci_lib.h\""],
  "typeDefs": [["typedef struct {\n\tuint8_t b[6];\n} __attribute__((packed))", "bdaddr_t"], ["typedef struct _gatt_connection_t {\n\tvoid* context;\n\n\tgattlib_event_handler_t notification_handler;\n\tvoid* notification_user_data;\n\n\tgattlib_event_handler_t indication_handler;\n\tvoid* indication_user_data;\n} gatt_connection_t;", "gatt_connection_t"], ["struct gattlib_thread_t", "gattlib_thread_t"], ["typedef struct {\n\tgatt_connection_t* conn;\n\tgatt_connect_cb_t  connect_cb;\n\tint                connected;\n\tint                timeout;\n\tGError*            error;\n    void*              user_data;\n}", "io_connect_arg_t"], ["typedef struct {\n\tGIOChannel*               io;\n\tGAttrib*                  attrib;\n\n\t// We keep a list of characteristics to make the correspondence handle/UUID.\n\tgattlib_characteristic_t* characteristics;\n\tint                       characteristic_count;\n}", "gattlib_context_t"], ["typedef enum {\n\tBT_IO_SEC_SDP = 0,\n\tBT_IO_SEC_LOW,\n\tBT_IO_SEC_MEDIUM,\n\tBT_IO_SEC_HIGH,\n}", "BtIOSecLevel"]],
  "visitedLines": [[265, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [290, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [246, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [220, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [257, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [234, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [287, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [278, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [213, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [288, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [267, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [200, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [253, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [218, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [293, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [185, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [194, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [258, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [189, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [289, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [235, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [233, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [247, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [211, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [209, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [252, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [226, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [225, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [248, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [210, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [196, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [216, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [229, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [180, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [186, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [264, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [266, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [238, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [286, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [230, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [279, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [205, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [193, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [262, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [250, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [273, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [240, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [217, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [195, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [282, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [274, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [269, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [291, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [239, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [280, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [201, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [249, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [222, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [281, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [283, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [243, "initialize_gattlib_connection", "bluez/gattlib_connect.c"], [263, "initialize_gattlib_connection", "bluez/gattlib_connect.c"]],
  "visitedParams": [],
  "vulnerableMethods": [["bluez/gattlib_connect.c", "initialize_gattlib_connection", "static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst, /* <=== initialize_gattlib_connection */ \n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\tstr2ba(dst, &dba);\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3))\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\telse\n\t\t\tstr2ba(src, &sba);\n\t} else\n\t\tbacpy(&sba, BDADDR_ANY);\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}", 180]]
}