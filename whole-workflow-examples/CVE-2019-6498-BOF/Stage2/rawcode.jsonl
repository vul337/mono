{"patches_id": 1, "files_id": 0, "file_name": "bluez-gattlib_connect.c", "language": "c", "raw_url": "https://github.com/labapart/gattlib/raw/42cf4e63ee7f0eb830644ea37c37a2a9e256befd/bluez%2Fgattlib_connect.c", "file_path": "storage/result/Part2_result/github/CVE-2019-6498/patch_after/bluez-gattlib_connect.c", "raw_code": "/*\n *\n *  GattLib - GATT Library\n *\n *  Copyright (C) 2016-2019 Olivier Martin <olivier@labapart.org>\n *\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <assert.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <bluetooth/bluetooth.h>\n\n#include \"gattlib_internal.h\"\n\n#include \"att.h\"\n#include \"btio.h\"\n#include \"gattrib.h\"\n#include \"hci.h\"\n#include \"hci_lib.h\"\n\n#define CONNECTION_TIMEOUT    2\n\nstruct gattlib_thread_t g_gattlib_thread = { 0 };\n\ntypedef struct {\n\tgatt_connection_t* conn;\n\tgatt_connect_cb_t  connect_cb;\n\tint                connected;\n\tint                timeout;\n\tGError*            error;\n    void*              user_data;\n} io_connect_arg_t;\n\nstatic void events_handler(const uint8_t *pdu, uint16_t len, gpointer user_data) {\n\tgatt_connection_t *conn = user_data;\n\tuint8_t opdu[ATT_MAX_MTU];\n\tuint16_t handle, olen = 0;\n\tuuid_t uuid = {};\n\n#if BLUEZ_VERSION_MAJOR == 4\n\thandle = att_get_u16(&pdu[1]);\n#else\n\thandle = get_le16(&pdu[1]);\n#endif\n\n\tint ret = get_uuid_from_handle(conn, handle, &uuid);\n\tif (ret) {\n\t\treturn;\n\t}\n\n\tswitch (pdu[0]) {\n\tcase ATT_OP_HANDLE_NOTIFY:\n\t\tif (conn->notification_handler) {\n\t\t\tconn->notification_handler(&uuid, &pdu[3], len - 3, conn->notification_user_data);\n\t\t}\n\t\tbreak;\n\tcase ATT_OP_HANDLE_IND:\n\t\tif (conn->indication_handler) {\n\t\t\tconn->indication_handler(&uuid, &pdu[3], len - 3, conn->indication_user_data);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tg_print(\"Invalid opcode\\n\");\n\t\treturn;\n\t}\n\n\tif (pdu[0] == ATT_OP_HANDLE_NOTIFY)\n\t\treturn;\n\n\tolen = enc_confirmation(opdu, sizeof(opdu));\n\n\tif (olen > 0) {\n\t\tgattlib_context_t* conn_context = conn->context;\n\t\tg_attrib_send(conn_context->attrib, 0,\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\topdu[0],\n#endif\n\t\t\t\topdu, olen, NULL, NULL, NULL);\n\t}\n}\n\nstatic gboolean io_listen_cb(gpointer user_data) {\n\tgatt_connection_t *conn = user_data;\n\tgattlib_context_t* conn_context = conn->context;\n\n\tg_attrib_register(conn_context->attrib, ATT_OP_HANDLE_NOTIFY,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\tGATTRIB_ALL_HANDLES,\n#endif\n\t\t\tevents_handler, conn, NULL);\n\tg_attrib_register(conn_context->attrib, ATT_OP_HANDLE_IND,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\tGATTRIB_ALL_HANDLES,\n#endif\n\t\t\tevents_handler, conn, NULL);\n\n\treturn FALSE;\n}\n\nstatic void io_connect_cb(GIOChannel *io, GError *err, gpointer user_data) {\n\tio_connect_arg_t* io_connect_arg = user_data;\n\n\tif (err) {\n\t\tio_connect_arg->error = err;\n\n\t\t// Call callback if defined\n        if (io_connect_arg->connect_cb) {\n            io_connect_arg->connect_cb(NULL, io_connect_arg->user_data);\n\t\t}\n    } else {\n\t\tgattlib_context_t* conn_context = io_connect_arg->conn->context;\n\n#if BLUEZ_VERSION_MAJOR == 4\n\t\tconn_context->attrib = g_attrib_new(io);\n#else\n\t\tconn_context->attrib = g_attrib_new(io, BT_ATT_DEFAULT_LE_MTU, false);\n#endif\n\n\t\t//\n\t\t// Register the listener callback\n        //\n\t\tGSource *source = g_idle_source_new ();\n\t\tassert(source != NULL);\n\n\t\tg_source_set_callback(source, io_listen_cb, io_connect_arg->conn, NULL);\n\n\t\t// Attaches the listener to the main loop context\n\t\tguint id = g_source_attach(source, g_gattlib_thread.loop_context);\n\t\tg_source_unref (source);\n\t\tassert(id != 0);\n\n\t\t//\n\t\t// Save list of characteristics to do the correspondence handle/UUID\n        //\n\t\tgattlib_discover_char(io_connect_arg->conn, &conn_context->characteristics, &conn_context->characteristic_count);\n\n\t\t//\n\t\t// Call callback if defined\n\t\t//\n        if (io_connect_arg->connect_cb) {\n            io_connect_arg->connect_cb(io_connect_arg->conn, io_connect_arg->user_data);\n\t\t}\n\n\t\tio_connect_arg->connected = TRUE;\n\t}\n\tif (io_connect_arg->connect_cb) {\n\t\tfree(io_connect_arg);\n\t}\n}\n\nstatic void *connection_thread(void* arg) {\n\tstruct gattlib_thread_t* loop_thread = arg;\n\n\tloop_thread->loop_context = g_main_context_new();\n\tloop_thread->loop = g_main_loop_new(loop_thread->loop_context, TRUE);\n\n\tg_main_loop_run(loop_thread->loop);\n\tg_main_loop_unref(loop_thread->loop);\n\tassert(0);\n}\n\nstatic gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst,\n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\tint ret;\n\n\tio_connect_arg->error = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = str2ba(dst, &dba);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);\n\t\treturn NULL;\n\t}\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3)) {\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\t} else {\n\t\t\tret = str2ba(src, &sba);\n\t\t\tif (ret != 0) {\n\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbacpy(&sba, BDADDR_ANY);\n\t}\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}\n\nstatic BtIOSecLevel get_bt_io_sec_level(gattlib_bt_sec_level_t sec_level) {\n\tswitch(sec_level) {\n\tcase BT_SEC_SDP:\n\t\treturn BT_IO_SEC_SDP;\n\tcase BT_SEC_LOW:\n\t\treturn BT_IO_SEC_LOW;\n\tcase BT_SEC_MEDIUM:\n\t\treturn BT_IO_SEC_MEDIUM;\n\tcase BT_SEC_HIGH:\n\t\treturn BT_IO_SEC_HIGH;\n\tdefault:\n\t\treturn BT_IO_SEC_SDP;\n\t}\n}\n\ngatt_connection_t *gattlib_connect_async(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu,\n                gatt_connect_cb_t connect_cb, void* data)\n{\n\tio_connect_arg_t* io_connect_arg = malloc(sizeof(io_connect_arg_t));\n    io_connect_arg->user_data = data;\n\tBtIOSecLevel bt_io_sec_level = get_bt_io_sec_level(sec_level);\n\n\treturn initialize_gattlib_connection(src, dst, dest_type, bt_io_sec_level,\n\t\t\tpsm, mtu, connect_cb, io_connect_arg);\n}\n\nstatic gboolean connection_timeout(gpointer user_data) {\n\tio_connect_arg_t* io_connect_arg = user_data;\n\n\tio_connect_arg->timeout = TRUE;\n\n\treturn FALSE;\n}\n\n/**\n * @param src\t\tLocal Adaptater interface\n * @param dst\t\tRemote Bluetooth address\n * @param dst_type\tSet LE address type (either BDADDR_LE_PUBLIC or BDADDR_LE_RANDOM)\n * @param sec_level\tSet security level (either BT_IO_SEC_LOW, BT_IO_SEC_MEDIUM, BT_IO_SEC_HIGH)\n * @param psm       Specify the PSM for GATT/ATT over BR/EDR\n * @param mtu       Specify the MTU size\n */\ngatt_connection_t *gattlib_connect(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu)\n{\n\tBtIOSecLevel bt_io_sec_level = get_bt_io_sec_level(sec_level);\n\tio_connect_arg_t io_connect_arg;\n    GSource* timeout;\n\tgatt_connection_t *conn = initialize_gattlib_connection(src, dst, dest_type, bt_io_sec_level,\n\t\t\tpsm, mtu, NULL, &io_connect_arg);\n\tif (conn == NULL) {\n\t\tif (io_connect_arg.error) {\n\t\t\tfprintf(stderr, \"Error: gattlib_connect - initialization error:%s\\n\", io_connect_arg.error->message);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Error: gattlib_connect - initialization\\n\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t// Timeout of 'CONNECTION_TIMEOUT+4' seconds\n\ttimeout = gattlib_timeout_add_seconds(CONNECTION_TIMEOUT + 4, connection_timeout, &io_connect_arg);\n\n\t// Wait for the connection to be done\n\twhile ((io_connect_arg.connected == FALSE) && (io_connect_arg.timeout == FALSE)) {\n\t\tg_main_context_iteration(g_gattlib_thread.loop_context, FALSE);\n    }\n\t// Disconnect the timeout source\n\tg_source_destroy(timeout);\n\n\tif (io_connect_arg.timeout) {\n\t\treturn NULL;\n\t}\n\n\tif (io_connect_arg.error) {\n\t\tfprintf(stderr, \"gattlib_connect - connection error:%s\\n\", io_connect_arg.error->message);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}\n\nint gattlib_disconnect(gatt_connection_t* connection) {\n\tgattlib_context_t* conn_context = connection->context;\n\n#if BLUEZ_VERSION_MAJOR == 4\n\t// Stop the I/O Channel\n\tGIOStatus status = g_io_channel_shutdown(conn_context->io, FALSE, NULL);\n\tassert(status == G_IO_STATUS_NORMAL);\n\tg_io_channel_unref(conn_context->io);\n#endif\n\n\tg_attrib_unref(conn_context->attrib);\n\n\tfree(conn_context->characteristics);\n\tfree(connection->context);\n\tfree(connection);\n\n\t//TODO: Add a mutex around this code to avoid a race condition\n\t/* Decrease the reference counter of the loop */\n\tg_gattlib_thread.ref--;\n\t/* Check if we are the last one */\n\tif (g_gattlib_thread.ref == 0) {\n\t\tg_main_loop_quit(g_gattlib_thread.loop);\n\t\tg_main_loop_unref(g_gattlib_thread.loop);\n\t\tg_main_context_unref(g_gattlib_thread.loop_context);\n\n\t\t// Detach the thread\n\t\tpthread_detach(g_gattlib_thread.thread);\n\t}\n\n\treturn 0;\n}\n\nGSource* gattlib_watch_connection_full(GIOChannel* io, GIOCondition condition,\n\t\t\t\t\t\t\t\t GIOFunc func, gpointer user_data, GDestroyNotify notify)\n{\n    // Create a main loop source\n\tGSource *source = g_io_create_watch (io, condition);\n\tassert(source != NULL);\n\n\tg_source_set_callback (source, (GSourceFunc)func, user_data, notify);\n\n    // Attaches it to the main loop context\n\tguint id = g_source_attach(source, g_gattlib_thread.loop_context);\n\tg_source_unref (source);\n\tassert(id != 0);\n\n\treturn source;\n}\n\nGSource* gattlib_timeout_add_seconds(guint interval, GSourceFunc function, gpointer data) {\n\tGSource *source = g_timeout_source_new_seconds(interval);\n\tassert(source != NULL);\n\n\tg_source_set_callback(source, function, data, NULL);\n\n\t// Attaches it to the main loop context\n\tguint id = g_source_attach(source, g_gattlib_thread.loop_context);\n\tg_source_unref (source);\n\tassert(id != 0);\n\n\treturn source;\n}\n\nint get_uuid_from_handle(gatt_connection_t* connection, uint16_t handle, uuid_t* uuid) {\n\tgattlib_context_t* conn_context = connection->context;\n\tint i;\n\n\tfor (i = 0; i < conn_context->characteristic_count; i++) {\n\t\tif (conn_context->characteristics[i].value_handle == handle) {\n\t\t\tmemcpy(uuid, &conn_context->characteristics[i].uuid, sizeof(uuid_t));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint get_handle_from_uuid(gatt_connection_t* connection, const uuid_t* uuid, uint16_t* handle) {\n\tgattlib_context_t* conn_context = connection->context;\n\tint i;\n\n\tfor (i = 0; i < conn_context->characteristic_count; i++) {\n\t\tif (gattlib_uuid_cmp(&conn_context->characteristics[i].uuid, uuid) == 0) {\n\t\t\t*handle = conn_context->characteristics[i].value_handle;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n", "raw_code_before": "/*\n *\n *  GattLib - GATT Library\n *\n *  Copyright (C) 2016-2017 Olivier Martin <olivier@labapart.org>\n *\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <assert.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <bluetooth/bluetooth.h>\n\n#include \"gattlib_internal.h\"\n\n#include \"att.h\"\n#include \"btio.h\"\n#include \"gattrib.h\"\n#include \"hci.h\"\n#include \"hci_lib.h\"\n\n#define CONNECTION_TIMEOUT    2\n\nstruct gattlib_thread_t g_gattlib_thread = { 0 };\n\ntypedef struct {\n\tgatt_connection_t* conn;\n\tgatt_connect_cb_t  connect_cb;\n\tint                connected;\n\tint                timeout;\n\tGError*            error;\n    void*              user_data;\n} io_connect_arg_t;\n\nstatic void events_handler(const uint8_t *pdu, uint16_t len, gpointer user_data) {\n\tgatt_connection_t *conn = user_data;\n\tuint8_t opdu[ATT_MAX_MTU];\n\tuint16_t handle, olen = 0;\n\tuuid_t uuid = {};\n\n#if BLUEZ_VERSION_MAJOR == 4\n\thandle = att_get_u16(&pdu[1]);\n#else\n\thandle = get_le16(&pdu[1]);\n#endif\n\n\tint ret = get_uuid_from_handle(conn, handle, &uuid);\n\tif (ret) {\n\t\treturn;\n\t}\n\n\tswitch (pdu[0]) {\n\tcase ATT_OP_HANDLE_NOTIFY:\n\t\tif (conn->notification_handler) {\n\t\t\tconn->notification_handler(&uuid, &pdu[3], len - 3, conn->notification_user_data);\n\t\t}\n\t\tbreak;\n\tcase ATT_OP_HANDLE_IND:\n\t\tif (conn->indication_handler) {\n\t\t\tconn->indication_handler(&uuid, &pdu[3], len - 3, conn->indication_user_data);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tg_print(\"Invalid opcode\\n\");\n\t\treturn;\n\t}\n\n\tif (pdu[0] == ATT_OP_HANDLE_NOTIFY)\n\t\treturn;\n\n\tolen = enc_confirmation(opdu, sizeof(opdu));\n\n\tif (olen > 0) {\n\t\tgattlib_context_t* conn_context = conn->context;\n\t\tg_attrib_send(conn_context->attrib, 0,\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\topdu[0],\n#endif\n\t\t\t\topdu, olen, NULL, NULL, NULL);\n\t}\n}\n\nstatic gboolean io_listen_cb(gpointer user_data) {\n\tgatt_connection_t *conn = user_data;\n\tgattlib_context_t* conn_context = conn->context;\n\n\tg_attrib_register(conn_context->attrib, ATT_OP_HANDLE_NOTIFY,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\tGATTRIB_ALL_HANDLES,\n#endif\n\t\t\tevents_handler, conn, NULL);\n\tg_attrib_register(conn_context->attrib, ATT_OP_HANDLE_IND,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\tGATTRIB_ALL_HANDLES,\n#endif\n\t\t\tevents_handler, conn, NULL);\n\n\treturn FALSE;\n}\n\nstatic void io_connect_cb(GIOChannel *io, GError *err, gpointer user_data) {\n\tio_connect_arg_t* io_connect_arg = user_data;\n\n\tif (err) {\n\t\tio_connect_arg->error = err;\n\n\t\t// Call callback if defined\n        if (io_connect_arg->connect_cb) {\n            io_connect_arg->connect_cb(NULL, io_connect_arg->user_data);\n\t\t}\n    } else {\n\t\tgattlib_context_t* conn_context = io_connect_arg->conn->context;\n\n#if BLUEZ_VERSION_MAJOR == 4\n\t\tconn_context->attrib = g_attrib_new(io);\n#else\n\t\tconn_context->attrib = g_attrib_new(io, BT_ATT_DEFAULT_LE_MTU, false);\n#endif\n\n\t\t//\n\t\t// Register the listener callback\n        //\n\t\tGSource *source = g_idle_source_new ();\n\t\tassert(source != NULL);\n\n\t\tg_source_set_callback(source, io_listen_cb, io_connect_arg->conn, NULL);\n\n\t\t// Attaches the listener to the main loop context\n\t\tguint id = g_source_attach(source, g_gattlib_thread.loop_context);\n\t\tg_source_unref (source);\n\t\tassert(id != 0);\n\n\t\t//\n\t\t// Save list of characteristics to do the correspondence handle/UUID\n        //\n\t\tgattlib_discover_char(io_connect_arg->conn, &conn_context->characteristics, &conn_context->characteristic_count);\n\n\t\t//\n\t\t// Call callback if defined\n\t\t//\n        if (io_connect_arg->connect_cb) {\n            io_connect_arg->connect_cb(io_connect_arg->conn, io_connect_arg->user_data);\n\t\t}\n\n\t\tio_connect_arg->connected = TRUE;\n\t}\n\tif (io_connect_arg->connect_cb) {\n\t\tfree(io_connect_arg);\n\t}\n}\n\nstatic void *connection_thread(void* arg) {\n\tstruct gattlib_thread_t* loop_thread = arg;\n\n\tloop_thread->loop_context = g_main_context_new();\n\tloop_thread->loop = g_main_loop_new(loop_thread->loop_context, TRUE);\n\n\tg_main_loop_run(loop_thread->loop);\n\tg_main_loop_unref(loop_thread->loop);\n\tassert(0);\n}\n\nstatic gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst,\n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\tstr2ba(dst, &dba);\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3))\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\telse\n\t\t\tstr2ba(src, &sba);\n\t} else\n\t\tbacpy(&sba, BDADDR_ANY);\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}\n\nstatic BtIOSecLevel get_bt_io_sec_level(gattlib_bt_sec_level_t sec_level) {\n\tswitch(sec_level) {\n\tcase BT_SEC_SDP:\n\t\treturn BT_IO_SEC_SDP;\n\tcase BT_SEC_LOW:\n\t\treturn BT_IO_SEC_LOW;\n\tcase BT_SEC_MEDIUM:\n\t\treturn BT_IO_SEC_MEDIUM;\n\tcase BT_SEC_HIGH:\n\t\treturn BT_IO_SEC_HIGH;\n\tdefault:\n\t\treturn BT_IO_SEC_SDP;\n\t}\n}\n\ngatt_connection_t *gattlib_connect_async(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu,\n                gatt_connect_cb_t connect_cb, void* data)\n{\n\tio_connect_arg_t* io_connect_arg = malloc(sizeof(io_connect_arg_t));\n    io_connect_arg->user_data = data;\n\tBtIOSecLevel bt_io_sec_level = get_bt_io_sec_level(sec_level);\n\n\treturn initialize_gattlib_connection(src, dst, dest_type, bt_io_sec_level,\n\t\t\tpsm, mtu, connect_cb, io_connect_arg);\n}\n\nstatic gboolean connection_timeout(gpointer user_data) {\n\tio_connect_arg_t* io_connect_arg = user_data;\n\n\tio_connect_arg->timeout = TRUE;\n\n\treturn FALSE;\n}\n\n/**\n * @param src\t\tLocal Adaptater interface\n * @param dst\t\tRemote Bluetooth address\n * @param dst_type\tSet LE address type (either BDADDR_LE_PUBLIC or BDADDR_LE_RANDOM)\n * @param sec_level\tSet security level (either BT_IO_SEC_LOW, BT_IO_SEC_MEDIUM, BT_IO_SEC_HIGH)\n * @param psm       Specify the PSM for GATT/ATT over BR/EDR\n * @param mtu       Specify the MTU size\n */\ngatt_connection_t *gattlib_connect(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu)\n{\n\tBtIOSecLevel bt_io_sec_level = get_bt_io_sec_level(sec_level);\n\tio_connect_arg_t io_connect_arg;\n    GSource* timeout;\n\tgatt_connection_t *conn = initialize_gattlib_connection(src, dst, dest_type, bt_io_sec_level,\n\t\t\tpsm, mtu, NULL, &io_connect_arg);\n\tif (conn == NULL) {\n\t\tif (io_connect_arg.error) {\n\t\t\tfprintf(stderr, \"Error: gattlib_connect - initialization error:%s\\n\", io_connect_arg.error->message);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Error: gattlib_connect - initialization\\n\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t// Timeout of 'CONNECTION_TIMEOUT+4' seconds\n\ttimeout = gattlib_timeout_add_seconds(CONNECTION_TIMEOUT + 4, connection_timeout, &io_connect_arg);\n\n\t// Wait for the connection to be done\n\twhile ((io_connect_arg.connected == FALSE) && (io_connect_arg.timeout == FALSE)) {\n\t\tg_main_context_iteration(g_gattlib_thread.loop_context, FALSE);\n    }\n\t// Disconnect the timeout source\n\tg_source_destroy(timeout);\n\n\tif (io_connect_arg.timeout) {\n\t\treturn NULL;\n\t}\n\n\tif (io_connect_arg.error) {\n\t\tfprintf(stderr, \"gattlib_connect - connection error:%s\\n\", io_connect_arg.error->message);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}\n\nint gattlib_disconnect(gatt_connection_t* connection) {\n\tgattlib_context_t* conn_context = connection->context;\n\n#if BLUEZ_VERSION_MAJOR == 4\n\t// Stop the I/O Channel\n\tGIOStatus status = g_io_channel_shutdown(conn_context->io, FALSE, NULL);\n\tassert(status == G_IO_STATUS_NORMAL);\n\tg_io_channel_unref(conn_context->io);\n#endif\n\n\tg_attrib_unref(conn_context->attrib);\n\n\tfree(conn_context->characteristics);\n\tfree(connection->context);\n\tfree(connection);\n\n\t//TODO: Add a mutex around this code to avoid a race condition\n\t/* Decrease the reference counter of the loop */\n\tg_gattlib_thread.ref--;\n\t/* Check if we are the last one */\n\tif (g_gattlib_thread.ref == 0) {\n\t\tg_main_loop_quit(g_gattlib_thread.loop);\n\t\tg_main_loop_unref(g_gattlib_thread.loop);\n\t\tg_main_context_unref(g_gattlib_thread.loop_context);\n\n\t\t// Detach the thread\n\t\tpthread_detach(g_gattlib_thread.thread);\n\t}\n\n\treturn 0;\n}\n\nGSource* gattlib_watch_connection_full(GIOChannel* io, GIOCondition condition,\n\t\t\t\t\t\t\t\t GIOFunc func, gpointer user_data, GDestroyNotify notify)\n{\n    // Create a main loop source\n\tGSource *source = g_io_create_watch (io, condition);\n\tassert(source != NULL);\n\n\tg_source_set_callback (source, (GSourceFunc)func, user_data, notify);\n\n    // Attaches it to the main loop context\n\tguint id = g_source_attach(source, g_gattlib_thread.loop_context);\n\tg_source_unref (source);\n\tassert(id != 0);\n\n\treturn source;\n}\n\nGSource* gattlib_timeout_add_seconds(guint interval, GSourceFunc function, gpointer data) {\n\tGSource *source = g_timeout_source_new_seconds(interval);\n\tassert(source != NULL);\n\n\tg_source_set_callback(source, function, data, NULL);\n\n\t// Attaches it to the main loop context\n\tguint id = g_source_attach(source, g_gattlib_thread.loop_context);\n\tg_source_unref (source);\n\tassert(id != 0);\n\n\treturn source;\n}\n\nint get_uuid_from_handle(gatt_connection_t* connection, uint16_t handle, uuid_t* uuid) {\n\tgattlib_context_t* conn_context = connection->context;\n\tint i;\n\n\tfor (i = 0; i < conn_context->characteristic_count; i++) {\n\t\tif (conn_context->characteristics[i].value_handle == handle) {\n\t\t\tmemcpy(uuid, &conn_context->characteristics[i].uuid, sizeof(uuid_t));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint get_handle_from_uuid(gatt_connection_t* connection, const uuid_t* uuid, uint16_t* handle) {\n\tgattlib_context_t* conn_context = connection->context;\n\tint i;\n\n\tfor (i = 0; i < conn_context->characteristic_count; i++) {\n\t\tif (gattlib_uuid_cmp(&conn_context->characteristics[i].uuid, uuid) == 0) {\n\t\t\t*handle = conn_context->characteristics[i].value_handle;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n", "patch": "@@ -2,7 +2,7 @@\n  *\n  *  GattLib - GATT Library\n  *\n- *  Copyright (C) 2016-2017 Olivier Martin <olivier@labapart.org>\n+ *  Copyright (C) 2016-2019 Olivier Martin <olivier@labapart.org>\n  *\n  *\n  *  This program is free software; you can redistribute it and/or modify\n@@ -184,6 +184,9 @@ static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const\n {\n \tbdaddr_t sba, dba;\n \tGError *err = NULL;\n+\tint ret;\n+\n+\tio_connect_arg->error = NULL;\n \n \t/* Check if the GattLib thread has been started */\n \tif (g_gattlib_thread.ref == 0) {\n@@ -210,16 +213,27 @@ static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const\n \t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n \t\treturn NULL;\n \t}\n-\tstr2ba(dst, &dba);\n+\n+\tret = str2ba(dst, &dba);\n+\tif (ret != 0) {\n+\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);\n+\t\treturn NULL;\n+\t}\n \n \t/* Local adapter */\n \tif (src != NULL) {\n-\t\tif (!strncmp(src, \"hci\", 3))\n+\t\tif (!strncmp(src, \"hci\", 3)) {\n \t\t\thci_devba(atoi(src + 3), &sba);\n-\t\telse\n-\t\t\tstr2ba(src, &sba);\n-\t} else\n+\t\t} else {\n+\t\t\tret = str2ba(src, &sba);\n+\t\t\tif (ret != 0) {\n+\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);\n+\t\t\t\treturn NULL;\n+\t\t\t}\n+\t\t}\n+\t} else {\n \t\tbacpy(&sba, BDADDR_ANY);\n+\t}\n \n \t/* Not used for BR/EDR */\n \tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {"}
{"patches_id": 2, "files_id": 1, "file_name": "dbus-gattlib.c", "language": "c", "raw_url": "https://github.com/labapart/gattlib/raw/42cf4e63ee7f0eb830644ea37c37a2a9e256befd/dbus%2Fgattlib.c", "file_path": "storage/result/Part2_result/github/CVE-2019-6498/patch_after/dbus-gattlib.c", "raw_code": "/*\n *\n *  GattLib - GATT Library\n *\n *  Copyright (C) 2016-2019 Olivier Martin <olivier@labapart.org>\n *\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <glib.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"gattlib_internal.h\"\n\n#define CONNECT_TIMEOUT  4\n\nint gattlib_adapter_open(const char* adapter_name, void** adapter) {\n\tchar object_path[20];\n\tOrgBluezAdapter1 *adapter_proxy;\n\tGError *error = NULL;\n\n\tif (adapter_name) {\n\t\tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s\", adapter_name);\n\t} else {\n\t\tstrncpy(object_path, \"/org/bluez/hci0\", sizeof(object_path));\n\t}\n\n\tadapter_proxy = org_bluez_adapter1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL, &error);\n\tif (adapter_proxy == NULL) {\n\t\tprintf(\"Failed to get adapter %s\\n\", object_path);\n\t\treturn 1;\n\t}\n\n\t// Ensure the adapter is powered on\n\torg_bluez_adapter1_set_powered(adapter_proxy, TRUE);\n\n\t*adapter = adapter_proxy;\n\treturn 0;\n}\n\nstatic gboolean stop_scan_func(gpointer data) {\n\tg_main_loop_quit(data);\n\treturn FALSE;\n}\n\nvoid on_dbus_object_added(GDBusObjectManager *device_manager,\n                     GDBusObject        *object,\n                     gpointer            user_data)\n{\n\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.Device1\");\n\tif (!interface) {\n\t\treturn;\n\t}\n\n    GError *error = NULL;\n\tOrgBluezDevice1* device1 = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL,\n\t\t\t&error);\n\n\tif (device1) {\n\t\tgattlib_discovered_device_t discovered_device_cb = user_data;\n\n\t\tdiscovered_device_cb(\n\t\t\torg_bluez_device1_get_address(device1),\n\t\t\torg_bluez_device1_get_name(device1));\n\t\tg_object_unref(device1);\n\t}\n}\n\nint gattlib_adapter_scan_enable(void* adapter, gattlib_discovered_device_t discovered_device_cb, int timeout) {\n\tGDBusObjectManager *device_manager;\n\tGError *error = NULL;\n\n\torg_bluez_adapter1_call_start_discovery_sync((OrgBluezAdapter1*)adapter, NULL, &error);\n\n\t//\n\t// Get notification when objects are removed from the Bluez ObjectManager.\n\t// We should get notified when the connection is lost with the target to allow\n\t// us to advertise us again\n\t//\n\tdevice_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn 1;\n\t}\n\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGList *l;\n\tfor (l = objects; l != NULL; l = l->next)  {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.Device1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tOrgBluezDevice1* device1 = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\n\t\tif (device1) {\n\t\t\tdiscovered_device_cb(\n\t\t\t\torg_bluez_device1_get_address(device1),\n\t\t\t\torg_bluez_device1_get_name(device1));\n\t\t\tg_object_unref(device1);\n\t\t}\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\n\tg_signal_connect (G_DBUS_OBJECT_MANAGER(device_manager),\n\t                    \"object-added\",\n\t                    G_CALLBACK (on_dbus_object_added),\n\t                    discovered_device_cb);\n\n\t// Run Glib loop for 'timeout' seconds\n\tGMainLoop *loop = g_main_loop_new(NULL, 0);\n\tg_timeout_add_seconds (timeout, stop_scan_func, loop);\n\tg_main_loop_run(loop);\n\tg_main_loop_unref(loop);\n\n\tg_object_unref(device_manager);\n\treturn 0;\n}\n\nint gattlib_adapter_scan_disable(void* adapter) {\n\tGError *error = NULL;\n\n\torg_bluez_adapter1_call_stop_discovery_sync((OrgBluezAdapter1*)adapter, NULL, &error);\n\treturn 0;\n}\n\nint gattlib_adapter_close(void* adapter) {\n\tg_object_unref(adapter);\n\treturn 0;\n}\n\ngboolean on_handle_device_property_change(\n\t    OrgBluezGattCharacteristic1 *object,\n\t    GVariant *arg_changed_properties,\n\t    const gchar *const *arg_invalidated_properties,\n\t    gpointer user_data)\n{\n\tGMainLoop *loop = user_data;\n\n\t// Retrieve 'Value' from 'arg_changed_properties'\n\tif (g_variant_n_children (arg_changed_properties) > 0) {\n\t\tGVariantIter *iter;\n\t\tconst gchar *key;\n\t\tGVariant *value;\n\n\t\tg_variant_get (arg_changed_properties, \"a{sv}\", &iter);\n\t\twhile (g_variant_iter_loop (iter, \"{&sv}\", &key, &value)) {\n\t\t\tif (strcmp(key, \"UUIDs\") == 0) {\n\t\t\t\tg_main_loop_quit(loop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/**\n * @param src\t\tLocal Adaptater interface\n * @param dst\t\tRemote Bluetooth address\n * @param dst_type\tSet LE address type (either BDADDR_LE_PUBLIC or BDADDR_LE_RANDOM)\n * @param sec_level\tSet security level (either BT_IO_SEC_LOW, BT_IO_SEC_MEDIUM, BT_IO_SEC_HIGH)\n * @param psm       Specify the PSM for GATT/ATT over BR/EDR\n * @param mtu       Specify the MTU size\n */\ngatt_connection_t *gattlib_connect(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu)\n{\n\tGError *error = NULL;\n\tconst char* adapter_name;\n\tchar device_address_str[20 + 1];\n\tchar object_path[100];\n\tint i;\n\n\tif (src) {\n\t\tadapter_name = src;\n\t} else {\n\t\tadapter_name = \"hci0\";\n\t}\n\n\t// Transform string from 'DA:94:40:95:E0:87' to 'dev_DA_94_40_95_E0_87'\n\tstrncpy(device_address_str, dst, sizeof(device_address_str));\n\tfor (i = 0; i < strlen(device_address_str); i++) {\n\t\tif (device_address_str[i] == ':') {\n\t\t\tdevice_address_str[i] = '_';\n\t\t}\n\t}\n\n\t// Force a null-terminated character\n\tdevice_address_str[20] = '\\0';\n\n\t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n\tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* connection = calloc(sizeof(gatt_connection_t), 1);\n\tif (connection == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tconnection->context = conn_context;\n\t}\n\n\tOrgBluezDevice1* device = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL,\n\t\t\t&error);\n\tif (device == NULL) {\n\t\tgoto FREE_CONNECTION;\n\t} else {\n\t\tconn_context->device = device;\n\t\tconn_context->device_object_path = strdup(object_path);\n\t}\n\n\terror = NULL;\n\torg_bluez_device1_call_connect_sync(device, NULL, &error);\n\tif (error) {\n\t\tprintf(\"Device connected error: %s\\n\", error->message);\n\t\tgoto FREE_DEVICE;\n\t}\n\n\t// Wait for the property 'UUIDs' to be changed. We assume 'org.bluez.GattService1\n\t// and 'org.bluez.GattCharacteristic1' to be advertised at that moment.\n\tGMainLoop *loop = g_main_loop_new(NULL, 0);\n\n\t// Register a handle for notification\n\tg_signal_connect(device,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (on_handle_device_property_change),\n\t\tloop);\n\n\tg_timeout_add_seconds (CONNECT_TIMEOUT, stop_scan_func, loop);\n\tg_main_loop_run(loop);\n\tg_main_loop_unref(loop);\n\n\treturn connection;\n\nFREE_DEVICE:\n\tfree(conn_context->device_object_path);\n\tg_object_unref(conn_context->device);\n\nFREE_CONNECTION:\n\tfree(connection);\n\treturn NULL;\n}\n\ngatt_connection_t *gattlib_connect_async(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu,\n\t\t\t\tgatt_connect_cb_t connect_cb, void* data)\n{\n\treturn NULL;\n}\n\nint gattlib_disconnect(gatt_connection_t* connection) {\n\tgattlib_context_t* conn_context = connection->context;\n\tGError *error = NULL;\n\n\torg_bluez_device1_call_disconnect_sync(conn_context->device, NULL, &error);\n\n\tfree(conn_context->device_object_path);\n\tg_object_unref(conn_context->device);\n\n\tfree(connection->context);\n\tfree(connection);\n\treturn 0;\n}\n\n// Bluez was using org.bluez.Device1.GattServices until 5.37 to expose the list of available GATT Services\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 38)\nint gattlib_discover_primary(gatt_connection_t* connection, gattlib_primary_service_t** services, int* services_count) {\n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezDevice1* device = conn_context->device;\n\tconst gchar* const* service_str;\n\tGError *error = NULL;\n\n\tconst gchar* const* service_strs = org_bluez_device1_get_gatt_services(device);\n\n\tif (service_strs == NULL) {\n\t\t*services       = NULL;\n\t\t*services_count = 0;\n\t\treturn 0;\n\t}\n\n\t// Maximum number of primary services\n\tint count_max = 0, count = 0;\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\tcount_max++;\n\t}\n\n\tgattlib_primary_service_t* primary_services = malloc(count_max * sizeof(gattlib_primary_service_t));\n\tif (primary_services == NULL) {\n\t\treturn 1;\n\t}\n\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\t*service_str,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", *service_str);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (org_bluez_gatt_service1_get_primary(service_proxy)) {\n\t\t\tprimary_services[count].attr_handle_start = 0;\n\t\t\tprimary_services[count].attr_handle_end   = 0;\n\n\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\torg_bluez_gatt_service1_get_uuid(service_proxy),\n\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t&primary_services[count].uuid);\n\t\t\tcount++;\n\t\t}\n\n\t\tg_object_unref(service_proxy);\n\t}\n\n\t*services       = primary_services;\n\t*services_count = count;\n\treturn 0;\n}\n#else\nint gattlib_discover_primary(gatt_connection_t* connection, gattlib_primary_service_t** services, int* services_count) {\n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezDevice1* device = conn_context->device;\n\tconst gchar* const* service_str;\n\tGError *error = NULL;\n\n\tconst gchar* const* service_strs = org_bluez_device1_get_uuids(device);\n\n\tif (service_strs == NULL) {\n\t\t*services       = NULL;\n\t\t*services_count = 0;\n\t\treturn 0;\n\t}\n\n\t// Maximum number of primary services\n\tint count_max = 0, count = 0;\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\tcount_max++;\n\t}\n\n\tgattlib_primary_service_t* primary_services = malloc(count_max * sizeof(gattlib_primary_service_t));\n\tif (primary_services == NULL) {\n\t\treturn 1;\n\t}\n\n\tGDBusObjectManager *device_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn 1;\n\t}\n\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGList *l;\n\tfor (l = objects; l != NULL; l = l->next)  {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattService1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", object_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ensure the service is attached to this device\n\t\tif (strcmp(conn_context->device_object_path, org_bluez_gatt_service1_get_device(service_proxy))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (org_bluez_gatt_service1_get_primary(service_proxy)) {\n\t\t\tprimary_services[count].attr_handle_start = 0;\n\t\t\tprimary_services[count].attr_handle_end   = 0;\n\n\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\torg_bluez_gatt_service1_get_uuid(service_proxy),\n\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t&primary_services[count].uuid);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\tg_object_unref(device_manager);\n\n\t*services       = primary_services;\n\t*services_count = count;\n\treturn 0;\n}\n#endif\n\nint gattlib_discover_char_range(gatt_connection_t* connection, int start, int end, gattlib_characteristic_t** characteristics, int* characteristics_count) {\n\treturn -1;\n}\n\n// Bluez was using org.bluez.Device1.GattServices until 5.37 to expose the list of available GATT Services\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 38)\nint gattlib_discover_char(gatt_connection_t* connection, gattlib_characteristic_t** characteristics, int* characteristic_count) {\n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezDevice1* device = conn_context->device;\n\tGError *error = NULL;\n\n\tconst gchar* const* service_strs = org_bluez_device1_get_gatt_services(device);\n\tconst gchar* const* service_str;\n\tconst gchar* const* characteristic_strs;\n\tconst gchar* const* characteristic_str;\n\n\tif (service_strs == NULL) {\n\t\treturn 2;\n\t}\n\n\t// Maximum number of primary services\n\tint count_max = 0, count = 0;\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\t*service_str,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open services '%s'.\\n\", *service_str);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcharacteristic_strs = org_bluez_gatt_service1_get_characteristics(service_proxy);\n\t\tif (characteristic_strs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (characteristic_str = characteristic_strs; *characteristic_str != NULL; characteristic_str++) {\n\t\t\tcount_max++;\n\t\t}\n\t\tg_object_unref(service_proxy);\n\t}\n\n\n\tgattlib_characteristic_t* characteristic_list = malloc(count_max * sizeof(gattlib_characteristic_t));\n\tif (characteristic_list == NULL) {\n\t\treturn 1;\n\t}\n\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\t*service_str,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", *service_str);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcharacteristic_strs = org_bluez_gatt_service1_get_characteristics(service_proxy);\n\t\tif (characteristic_strs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (characteristic_str = characteristic_strs; *characteristic_str != NULL; characteristic_str++) {\n\t\t\tOrgBluezGattCharacteristic1 *characteristic_proxy = org_bluez_gatt_characteristic1_proxy_new_for_bus_sync(\n\t\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\t\"org.bluez\",\n\t\t\t\t\t*characteristic_str,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&error);\n\t\t\tif (characteristic_proxy == NULL) {\n\t\t\t\tprintf(\"Failed to open characteristic '%s'.\\n\", *characteristic_str);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcharacteristic_list[count].handle       = 0;\n\t\t\t\tcharacteristic_list[count].value_handle = 0;\n\n\t\t\t\tconst gchar *const * flags = org_bluez_gatt_characteristic1_get_flags(characteristic_proxy);\n\t\t\t\tfor (; *flags != NULL; flags++) {\n\t\t\t\t\tif (strcmp(*flags,\"broadcast\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_BROADCAST;\n\t\t\t\t\t} else if (strcmp(*flags,\"read\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_READ;\n\t\t\t\t\t} else if (strcmp(*flags,\"write\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_WRITE;\n\t\t\t\t\t} else if (strcmp(*flags,\"write-without-response\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_WRITE_WITHOUT_RESP;\n\t\t\t\t\t} else if (strcmp(*flags,\"notify\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_NOTIFY;\n\t\t\t\t\t} else if (strcmp(*flags,\"indicate\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_INDICATE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\t\torg_bluez_gatt_characteristic1_get_uuid(characteristic_proxy),\n\t\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t\t&characteristic_list[count].uuid);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tg_object_unref(characteristic_proxy);\n\t\t}\n\t\tg_object_unref(service_proxy);\n\t}\n\n\t*characteristics      = characteristic_list;\n\t*characteristic_count = count;\n\treturn 0;\n}\n#else\nstatic void add_characteristics_from_service(GDBusObjectManager *device_manager, const char* service_object_path, gattlib_characteristic_t* characteristic_list, int* count) {\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGError *error = NULL;\n\tGList *l;\n\n\tfor (l = objects; l != NULL; l = l->next) {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattCharacteristic1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tOrgBluezGattCharacteristic1* characteristic = org_bluez_gatt_characteristic1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (characteristic == NULL) {\n\t\t\tprintf(\"Failed to open characteristic '%s'.\\n\", object_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(org_bluez_gatt_characteristic1_get_service(characteristic), service_object_path)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tcharacteristic_list[*count].handle       = 0;\n\t\t\tcharacteristic_list[*count].value_handle = 0;\n\n\t\t\tconst gchar *const * flags = org_bluez_gatt_characteristic1_get_flags(characteristic);\n\t\t\tfor (; *flags != NULL; flags++) {\n\t\t\t\tif (strcmp(*flags,\"broadcast\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_BROADCAST;\n\t\t\t\t} else if (strcmp(*flags,\"read\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_READ;\n\t\t\t\t} else if (strcmp(*flags,\"write\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_WRITE;\n\t\t\t\t} else if (strcmp(*flags,\"write-without-response\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_WRITE_WITHOUT_RESP;\n\t\t\t\t} else if (strcmp(*flags,\"notify\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_NOTIFY;\n\t\t\t\t} else if (strcmp(*flags,\"indicate\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_INDICATE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\torg_bluez_gatt_characteristic1_get_uuid(characteristic),\n\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t&characteristic_list[*count].uuid);\n\t\t\t*count = *count + 1;\n\t\t}\n\t}\n}\n\nint gattlib_discover_char(gatt_connection_t* connection, gattlib_characteristic_t** characteristics, int* characteristic_count) {\n\tgattlib_context_t* conn_context = connection->context;\n\tGError *error = NULL;\n\tGList *l;\n\n\t// Get list of services\n\tGDBusObjectManager *device_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn 1;\n\t}\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\n\t// Count the maximum number of characteristic to allocate the array (we count all the characterstic for all devices)\n\tint count_max = 0, count = 0;\n\tfor (l = objects; l != NULL; l = l->next) {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattCharacteristic1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount_max++;\n\t}\n\n\tgattlib_characteristic_t* characteristic_list = malloc(count_max * sizeof(gattlib_characteristic_t));\n\tif (characteristic_list == NULL) {\n\t\treturn 1;\n\t}\n\n\t// List all services for this device\n\tfor (l = objects; l != NULL; l = l->next) {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattService1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", object_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ensure the service is attached to this device\n\t\tconst char* service_object_path = org_bluez_gatt_service1_get_device(service_proxy);\n\t\tif (strcmp(conn_context->device_object_path, service_object_path)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Add all characteristics attached to this service\n\t\tadd_characteristics_from_service(device_manager, object_path, characteristic_list, &count);\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\tg_object_unref(device_manager);\n\n\t*characteristics      = characteristic_list;\n\t*characteristic_count = count;\n\treturn 0;\n}\n#endif\n\nstatic OrgBluezGattCharacteristic1 *get_characteristic_from_uuid(gatt_connection_t* connection, const uuid_t* uuid) {\n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezGattCharacteristic1 *characteristic = NULL;\n\tGError *error = NULL;\n\n\tGDBusObjectManager *device_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn NULL;\n\t}\n\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGList *l;\n\tfor (l = objects; l != NULL; l = l->next)  {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattCharacteristic1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tcharacteristic = org_bluez_gatt_characteristic1_proxy_new_for_bus_sync (\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (characteristic) {\n\t\t\tuuid_t characteristic_uuid;\n\t\t\tconst gchar *characteristic_uuid_str = org_bluez_gatt_characteristic1_get_uuid(characteristic);\n\n\t\t\tgattlib_string_to_uuid(characteristic_uuid_str, strlen(characteristic_uuid_str) + 1, &characteristic_uuid);\n\t\t\tif (gattlib_uuid_cmp(uuid, &characteristic_uuid) == 0) {\n\t\t\t\t// We found the right characteristic, now we check if it's the right device.\n\n\t\t\t\terror = NULL;\n\t\t\t\tOrgBluezGattService1* service = org_bluez_gatt_service1_proxy_new_for_bus_sync (\n\t\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\t\"org.bluez\",\n\t\t\t\t\torg_bluez_gatt_characteristic1_get_service(characteristic),\n\t\t\t\t\tNULL,\n\t\t\t\t\t&error);\n\n\t\t\t\tif (service) {\n\t\t\t\t\tconst bool found = !strcmp(conn_context->device_object_path, org_bluez_gatt_service1_get_device(service));\n\n\t\t\t\t\tg_object_unref(service);\n\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tg_object_unref(characteristic);\n\t\t}\n\n\t\t// Ensure we set 'characteristic' back to NULL\n\t\tcharacteristic = NULL;\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\tg_object_unref(device_manager);\n\treturn characteristic;\n}\n\nint gattlib_discover_desc_range(gatt_connection_t* connection, int start, int end, gattlib_descriptor_t** descriptors, int* descriptor_count) {\n\treturn -1;\n}\n\nint gattlib_discover_desc(gatt_connection_t* connection, gattlib_descriptor_t** descriptors, int* descriptor_count) {\n\treturn -1;\n}\n\nint gattlib_read_char_by_uuid(gatt_connection_t* connection, uuid_t* uuid, void* buffer, size_t* buffer_len) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\tGVariant *out_value;\n\tGError *error = NULL;\n\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 40)\n\torg_bluez_gatt_characteristic1_call_read_value_sync(\n\t\tcharacteristic, &out_value, NULL, &error);\n#else\n\tGVariantBuilder *options =  g_variant_builder_new(G_VARIANT_TYPE(\"a{sv}\"));\n\torg_bluez_gatt_characteristic1_call_read_value_sync(\n\t\tcharacteristic, g_variant_builder_end(options), &out_value, NULL, &error);\n\tg_variant_builder_unref(options);\n#endif\n\tif (error != NULL) {\n\t\treturn -1;\n\t}\n\n\tgsize n_elements = 0;\n\tgconstpointer const_buffer = g_variant_get_fixed_array(out_value, &n_elements, sizeof(guchar));\n\tif (const_buffer) {\n\t\tn_elements = MIN(n_elements, *buffer_len);\n\t\tmemcpy(buffer, const_buffer, n_elements);\n\t}\n\n\t*buffer_len = n_elements;\n\n\tg_object_unref(characteristic);\n\n#if BLUEZ_VERSION >= BLUEZ_VERSIONS(5, 40)\n\t//g_variant_unref(in_params); See: https://github.com/labapart/gattlib/issues/28#issuecomment-311486629\n#endif\n\treturn 0;\n}\n\nint gattlib_read_char_by_uuid_async(gatt_connection_t* connection, uuid_t* uuid, gatt_read_cb_t gatt_read_cb) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\tGVariant *out_value;\n\tGError *error = NULL;\n\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 40)\n\torg_bluez_gatt_characteristic1_call_read_value_sync(\n\t\tcharacteristic, &out_value, NULL, &error);\n#else\n\tGVariantBuilder *options =  g_variant_builder_new(G_VARIANT_TYPE(\"a{sv}\"));\n\torg_bluez_gatt_characteristic1_call_read_value_sync(\n\t\tcharacteristic, g_variant_builder_end(options), &out_value, NULL, &error);\n\tg_variant_builder_unref(options);\n#endif\n\tif (error != NULL) {\n\t\treturn -1;\n\t}\n\n\tgsize n_elements;\n\tgconstpointer const_buffer = g_variant_get_fixed_array(out_value, &n_elements, sizeof(guchar));\n\tif (const_buffer) {\n\t\tgatt_read_cb(const_buffer, n_elements);\n\t}\n\n\tg_object_unref(characteristic);\n\n#if BLUEZ_VERSION >= BLUEZ_VERSIONS(5, 40)\n\t//g_variant_unref(in_params); See: https://github.com/labapart/gattlib/issues/28#issuecomment-311486629\n#endif\n\treturn 0;\n}\n\nint gattlib_write_char_by_uuid(gatt_connection_t* connection, uuid_t* uuid, const void* buffer, size_t buffer_len) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\tGVariant *value = g_variant_new_from_data(G_VARIANT_TYPE (\"ay\"), buffer, buffer_len, TRUE, NULL, NULL);\n\tGError *error = NULL;\n\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 40)\n\torg_bluez_gatt_characteristic1_call_write_value_sync(characteristic, value, NULL, &error);\n#else\n\tGVariantBuilder *options =  g_variant_builder_new(G_VARIANT_TYPE(\"a{sv}\"));\n\torg_bluez_gatt_characteristic1_call_write_value_sync(characteristic, value, g_variant_builder_end(options), NULL, &error);\n\tg_variant_builder_unref(options);\n#endif\n\tif (error != NULL) {\n\t\treturn -1;\n\t}\n\n\tg_object_unref(characteristic);\n#if BLUEZ_VERSION >= BLUEZ_VERSIONS(5, 40)\n\t//g_variant_unref(in_params); See: https://github.com/labapart/gattlib/issues/28#issuecomment-311486629\n#endif\n\treturn 0;\n}\n\nint gattlib_write_char_by_handle(gatt_connection_t* connection, uint16_t handle, const void* buffer, size_t buffer_len) {\n\treturn -1;\n}\n\ngboolean on_handle_characteristic_property_change(\n\t    OrgBluezGattCharacteristic1 *object,\n\t    GVariant *arg_changed_properties,\n\t    const gchar *const *arg_invalidated_properties,\n\t    gpointer user_data)\n{\n\tgatt_connection_t* connection = user_data;\n\n\tif (connection->notification_handler) {\n\t\t// Retrieve 'Value' from 'arg_changed_properties'\n\t\tif (g_variant_n_children (arg_changed_properties) > 0) {\n\t\t\tGVariantIter *iter;\n\t\t\tconst gchar *key;\n\t\t\tGVariant *value;\n\n\t\t\tg_variant_get (arg_changed_properties, \"a{sv}\", &iter);\n\t\t\twhile (g_variant_iter_loop (iter, \"{&sv}\", &key, &value)) {\n\t\t\t\tif (strcmp(key, \"Value\") == 0) {\n\t\t\t\t\tuuid_t uuid;\n\t\t\t\t\tsize_t data_length;\n\t\t\t\t\tconst uint8_t* data = g_variant_get_fixed_array(value, &data_length, sizeof(guchar));\n\n\t\t\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\t\t\torg_bluez_gatt_characteristic1_get_uuid(object),\n\t\t\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t\t\t&uuid);\n\n\t\t\t\t\tconnection->notification_handler(&uuid, data, data_length, connection->notification_user_data);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nint gattlib_notification_start(gatt_connection_t* connection, const uuid_t* uuid) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\t// Register a handle for notification\n\tg_signal_connect(characteristic,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (on_handle_characteristic_property_change),\n\t\tconnection);\n\n\tGError *error = NULL;\n\torg_bluez_gatt_characteristic1_call_start_notify_sync(characteristic, NULL, &error);\n\n\tif (error) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint gattlib_notification_stop(gatt_connection_t* connection, const uuid_t* uuid) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\tGError *error = NULL;\n\torg_bluez_gatt_characteristic1_call_stop_notify_sync(\n\t\tcharacteristic, NULL, &error);\n\n\tif (error) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n", "raw_code_before": "/*\n *\n *  GattLib - GATT Library\n *\n *  Copyright (C) 2016-2017 Olivier Martin <olivier@labapart.org>\n *\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <glib.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"gattlib_internal.h\"\n\n#define CONNECT_TIMEOUT  4\n\nint gattlib_adapter_open(const char* adapter_name, void** adapter) {\n\tchar object_path[20];\n\tOrgBluezAdapter1 *adapter_proxy;\n\tGError *error = NULL;\n\n\tif (adapter_name) {\n\t\tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s\", adapter_name);\n\t} else {\n\t\tstrncpy(object_path, \"/org/bluez/hci0\", sizeof(object_path));\n\t}\n\n\tadapter_proxy = org_bluez_adapter1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL, &error);\n\tif (adapter_proxy == NULL) {\n\t\tprintf(\"Failed to get adapter %s\\n\", object_path);\n\t\treturn 1;\n\t}\n\n\t// Ensure the adapter is powered on\n\torg_bluez_adapter1_set_powered(adapter_proxy, TRUE);\n\n\t*adapter = adapter_proxy;\n\treturn 0;\n}\n\nstatic gboolean stop_scan_func(gpointer data) {\n\tg_main_loop_quit(data);\n\treturn FALSE;\n}\n\nvoid on_dbus_object_added(GDBusObjectManager *device_manager,\n                     GDBusObject        *object,\n                     gpointer            user_data)\n{\n\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.Device1\");\n\tif (!interface) {\n\t\treturn;\n\t}\n\n    GError *error = NULL;\n\tOrgBluezDevice1* device1 = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL,\n\t\t\t&error);\n\n\tif (device1) {\n\t\tgattlib_discovered_device_t discovered_device_cb = user_data;\n\n\t\tdiscovered_device_cb(\n\t\t\torg_bluez_device1_get_address(device1),\n\t\t\torg_bluez_device1_get_name(device1));\n\t\tg_object_unref(device1);\n\t}\n}\n\nint gattlib_adapter_scan_enable(void* adapter, gattlib_discovered_device_t discovered_device_cb, int timeout) {\n\tGDBusObjectManager *device_manager;\n\tGError *error = NULL;\n\n\torg_bluez_adapter1_call_start_discovery_sync((OrgBluezAdapter1*)adapter, NULL, &error);\n\n\t//\n\t// Get notification when objects are removed from the Bluez ObjectManager.\n\t// We should get notified when the connection is lost with the target to allow\n\t// us to advertise us again\n\t//\n\tdevice_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn 1;\n\t}\n\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGList *l;\n\tfor (l = objects; l != NULL; l = l->next)  {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.Device1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tOrgBluezDevice1* device1 = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\n\t\tif (device1) {\n\t\t\tdiscovered_device_cb(\n\t\t\t\torg_bluez_device1_get_address(device1),\n\t\t\t\torg_bluez_device1_get_name(device1));\n\t\t\tg_object_unref(device1);\n\t\t}\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\n\tg_signal_connect (G_DBUS_OBJECT_MANAGER(device_manager),\n\t                    \"object-added\",\n\t                    G_CALLBACK (on_dbus_object_added),\n\t                    discovered_device_cb);\n\n\t// Run Glib loop for 'timeout' seconds\n\tGMainLoop *loop = g_main_loop_new(NULL, 0);\n\tg_timeout_add_seconds (timeout, stop_scan_func, loop);\n\tg_main_loop_run(loop);\n\tg_main_loop_unref(loop);\n\n\tg_object_unref(device_manager);\n\treturn 0;\n}\n\nint gattlib_adapter_scan_disable(void* adapter) {\n\tGError *error = NULL;\n\n\torg_bluez_adapter1_call_stop_discovery_sync((OrgBluezAdapter1*)adapter, NULL, &error);\n\treturn 0;\n}\n\nint gattlib_adapter_close(void* adapter) {\n\tg_object_unref(adapter);\n\treturn 0;\n}\n\ngboolean on_handle_device_property_change(\n\t    OrgBluezGattCharacteristic1 *object,\n\t    GVariant *arg_changed_properties,\n\t    const gchar *const *arg_invalidated_properties,\n\t    gpointer user_data)\n{\n\tGMainLoop *loop = user_data;\n\n\t// Retrieve 'Value' from 'arg_changed_properties'\n\tif (g_variant_n_children (arg_changed_properties) > 0) {\n\t\tGVariantIter *iter;\n\t\tconst gchar *key;\n\t\tGVariant *value;\n\n\t\tg_variant_get (arg_changed_properties, \"a{sv}\", &iter);\n\t\twhile (g_variant_iter_loop (iter, \"{&sv}\", &key, &value)) {\n\t\t\tif (strcmp(key, \"UUIDs\") == 0) {\n\t\t\t\tg_main_loop_quit(loop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/**\n * @param src\t\tLocal Adaptater interface\n * @param dst\t\tRemote Bluetooth address\n * @param dst_type\tSet LE address type (either BDADDR_LE_PUBLIC or BDADDR_LE_RANDOM)\n * @param sec_level\tSet security level (either BT_IO_SEC_LOW, BT_IO_SEC_MEDIUM, BT_IO_SEC_HIGH)\n * @param psm       Specify the PSM for GATT/ATT over BR/EDR\n * @param mtu       Specify the MTU size\n */\ngatt_connection_t *gattlib_connect(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu)\n{\n\tGError *error = NULL;\n\tconst char* adapter_name;\n\tchar device_address_str[20];\n\tchar object_path[100];\n\tint i;\n\n\tif (src) {\n\t\tadapter_name = src;\n\t} else {\n\t\tadapter_name = \"hci0\";\n\t}\n\n\t// Transform string from 'DA:94:40:95:E0:87' to 'dev_DA_94_40_95_E0_87'\n\tstrncpy(device_address_str, dst, sizeof(device_address_str));\n\tfor (i = 0; i < strlen(device_address_str); i++) {\n\t\tif (device_address_str[i] == ':') {\n\t\t\tdevice_address_str[i] = '_';\n\t\t}\n\t}\n\n\t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n\tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* connection = calloc(sizeof(gatt_connection_t), 1);\n\tif (connection == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tconnection->context = conn_context;\n\t}\n\n\tOrgBluezDevice1* device = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL,\n\t\t\t&error);\n\tif (device == NULL) {\n\t\tgoto FREE_CONNECTION;\n\t} else {\n\t\tconn_context->device = device;\n\t\tconn_context->device_object_path = strdup(object_path);\n\t}\n\n\terror = NULL;\n\torg_bluez_device1_call_connect_sync(device, NULL, &error);\n\tif (error) {\n\t\tprintf(\"Device connected error: %s\\n\", error->message);\n\t\tgoto FREE_DEVICE;\n\t}\n\n\t// Wait for the property 'UUIDs' to be changed. We assume 'org.bluez.GattService1\n\t// and 'org.bluez.GattCharacteristic1' to be advertised at that moment.\n\tGMainLoop *loop = g_main_loop_new(NULL, 0);\n\n\t// Register a handle for notification\n\tg_signal_connect(device,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (on_handle_device_property_change),\n\t\tloop);\n\n\tg_timeout_add_seconds (CONNECT_TIMEOUT, stop_scan_func, loop);\n\tg_main_loop_run(loop);\n\tg_main_loop_unref(loop);\n\n\treturn connection;\n\nFREE_DEVICE:\n\tfree(conn_context->device_object_path);\n\tg_object_unref(conn_context->device);\n\nFREE_CONNECTION:\n\tfree(connection);\n\treturn NULL;\n}\n\ngatt_connection_t *gattlib_connect_async(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu,\n\t\t\t\tgatt_connect_cb_t connect_cb, void* data)\n{\n\treturn NULL;\n}\n\nint gattlib_disconnect(gatt_connection_t* connection) {\n\tgattlib_context_t* conn_context = connection->context;\n\tGError *error = NULL;\n\n\torg_bluez_device1_call_disconnect_sync(conn_context->device, NULL, &error);\n\n\tfree(conn_context->device_object_path);\n\tg_object_unref(conn_context->device);\n\n\tfree(connection->context);\n\tfree(connection);\n\treturn 0;\n}\n\n// Bluez was using org.bluez.Device1.GattServices until 5.37 to expose the list of available GATT Services\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 38)\nint gattlib_discover_primary(gatt_connection_t* connection, gattlib_primary_service_t** services, int* services_count) {\n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezDevice1* device = conn_context->device;\n\tconst gchar* const* service_str;\n\tGError *error = NULL;\n\n\tconst gchar* const* service_strs = org_bluez_device1_get_gatt_services(device);\n\n\tif (service_strs == NULL) {\n\t\t*services       = NULL;\n\t\t*services_count = 0;\n\t\treturn 0;\n\t}\n\n\t// Maximum number of primary services\n\tint count_max = 0, count = 0;\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\tcount_max++;\n\t}\n\n\tgattlib_primary_service_t* primary_services = malloc(count_max * sizeof(gattlib_primary_service_t));\n\tif (primary_services == NULL) {\n\t\treturn 1;\n\t}\n\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\t*service_str,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", *service_str);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (org_bluez_gatt_service1_get_primary(service_proxy)) {\n\t\t\tprimary_services[count].attr_handle_start = 0;\n\t\t\tprimary_services[count].attr_handle_end   = 0;\n\n\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\torg_bluez_gatt_service1_get_uuid(service_proxy),\n\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t&primary_services[count].uuid);\n\t\t\tcount++;\n\t\t}\n\n\t\tg_object_unref(service_proxy);\n\t}\n\n\t*services       = primary_services;\n\t*services_count = count;\n\treturn 0;\n}\n#else\nint gattlib_discover_primary(gatt_connection_t* connection, gattlib_primary_service_t** services, int* services_count) {\n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezDevice1* device = conn_context->device;\n\tconst gchar* const* service_str;\n\tGError *error = NULL;\n\n\tconst gchar* const* service_strs = org_bluez_device1_get_uuids(device);\n\n\tif (service_strs == NULL) {\n\t\t*services       = NULL;\n\t\t*services_count = 0;\n\t\treturn 0;\n\t}\n\n\t// Maximum number of primary services\n\tint count_max = 0, count = 0;\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\tcount_max++;\n\t}\n\n\tgattlib_primary_service_t* primary_services = malloc(count_max * sizeof(gattlib_primary_service_t));\n\tif (primary_services == NULL) {\n\t\treturn 1;\n\t}\n\n\tGDBusObjectManager *device_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn 1;\n\t}\n\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGList *l;\n\tfor (l = objects; l != NULL; l = l->next)  {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattService1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", object_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ensure the service is attached to this device\n\t\tif (strcmp(conn_context->device_object_path, org_bluez_gatt_service1_get_device(service_proxy))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (org_bluez_gatt_service1_get_primary(service_proxy)) {\n\t\t\tprimary_services[count].attr_handle_start = 0;\n\t\t\tprimary_services[count].attr_handle_end   = 0;\n\n\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\torg_bluez_gatt_service1_get_uuid(service_proxy),\n\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t&primary_services[count].uuid);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\tg_object_unref(device_manager);\n\n\t*services       = primary_services;\n\t*services_count = count;\n\treturn 0;\n}\n#endif\n\nint gattlib_discover_char_range(gatt_connection_t* connection, int start, int end, gattlib_characteristic_t** characteristics, int* characteristics_count) {\n\treturn -1;\n}\n\n// Bluez was using org.bluez.Device1.GattServices until 5.37 to expose the list of available GATT Services\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 38)\nint gattlib_discover_char(gatt_connection_t* connection, gattlib_characteristic_t** characteristics, int* characteristic_count) {\n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezDevice1* device = conn_context->device;\n\tGError *error = NULL;\n\n\tconst gchar* const* service_strs = org_bluez_device1_get_gatt_services(device);\n\tconst gchar* const* service_str;\n\tconst gchar* const* characteristic_strs;\n\tconst gchar* const* characteristic_str;\n\n\tif (service_strs == NULL) {\n\t\treturn 2;\n\t}\n\n\t// Maximum number of primary services\n\tint count_max = 0, count = 0;\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\t*service_str,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open services '%s'.\\n\", *service_str);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcharacteristic_strs = org_bluez_gatt_service1_get_characteristics(service_proxy);\n\t\tif (characteristic_strs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (characteristic_str = characteristic_strs; *characteristic_str != NULL; characteristic_str++) {\n\t\t\tcount_max++;\n\t\t}\n\t\tg_object_unref(service_proxy);\n\t}\n\n\n\tgattlib_characteristic_t* characteristic_list = malloc(count_max * sizeof(gattlib_characteristic_t));\n\tif (characteristic_list == NULL) {\n\t\treturn 1;\n\t}\n\n\tfor (service_str = service_strs; *service_str != NULL; service_str++) {\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\t*service_str,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", *service_str);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcharacteristic_strs = org_bluez_gatt_service1_get_characteristics(service_proxy);\n\t\tif (characteristic_strs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (characteristic_str = characteristic_strs; *characteristic_str != NULL; characteristic_str++) {\n\t\t\tOrgBluezGattCharacteristic1 *characteristic_proxy = org_bluez_gatt_characteristic1_proxy_new_for_bus_sync(\n\t\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\t\"org.bluez\",\n\t\t\t\t\t*characteristic_str,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&error);\n\t\t\tif (characteristic_proxy == NULL) {\n\t\t\t\tprintf(\"Failed to open characteristic '%s'.\\n\", *characteristic_str);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcharacteristic_list[count].handle       = 0;\n\t\t\t\tcharacteristic_list[count].value_handle = 0;\n\n\t\t\t\tconst gchar *const * flags = org_bluez_gatt_characteristic1_get_flags(characteristic_proxy);\n\t\t\t\tfor (; *flags != NULL; flags++) {\n\t\t\t\t\tif (strcmp(*flags,\"broadcast\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_BROADCAST;\n\t\t\t\t\t} else if (strcmp(*flags,\"read\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_READ;\n\t\t\t\t\t} else if (strcmp(*flags,\"write\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_WRITE;\n\t\t\t\t\t} else if (strcmp(*flags,\"write-without-response\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_WRITE_WITHOUT_RESP;\n\t\t\t\t\t} else if (strcmp(*flags,\"notify\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_NOTIFY;\n\t\t\t\t\t} else if (strcmp(*flags,\"indicate\") == 0) {\n\t\t\t\t\t\tcharacteristic_list[count].properties |= GATTLIB_CHARACTERISTIC_INDICATE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\t\torg_bluez_gatt_characteristic1_get_uuid(characteristic_proxy),\n\t\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t\t&characteristic_list[count].uuid);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tg_object_unref(characteristic_proxy);\n\t\t}\n\t\tg_object_unref(service_proxy);\n\t}\n\n\t*characteristics      = characteristic_list;\n\t*characteristic_count = count;\n\treturn 0;\n}\n#else\nstatic void add_characteristics_from_service(GDBusObjectManager *device_manager, const char* service_object_path, gattlib_characteristic_t* characteristic_list, int* count) {\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGError *error = NULL;\n\tGList *l;\n\n\tfor (l = objects; l != NULL; l = l->next) {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattCharacteristic1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tOrgBluezGattCharacteristic1* characteristic = org_bluez_gatt_characteristic1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (characteristic == NULL) {\n\t\t\tprintf(\"Failed to open characteristic '%s'.\\n\", object_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(org_bluez_gatt_characteristic1_get_service(characteristic), service_object_path)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tcharacteristic_list[*count].handle       = 0;\n\t\t\tcharacteristic_list[*count].value_handle = 0;\n\n\t\t\tconst gchar *const * flags = org_bluez_gatt_characteristic1_get_flags(characteristic);\n\t\t\tfor (; *flags != NULL; flags++) {\n\t\t\t\tif (strcmp(*flags,\"broadcast\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_BROADCAST;\n\t\t\t\t} else if (strcmp(*flags,\"read\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_READ;\n\t\t\t\t} else if (strcmp(*flags,\"write\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_WRITE;\n\t\t\t\t} else if (strcmp(*flags,\"write-without-response\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_WRITE_WITHOUT_RESP;\n\t\t\t\t} else if (strcmp(*flags,\"notify\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_NOTIFY;\n\t\t\t\t} else if (strcmp(*flags,\"indicate\") == 0) {\n\t\t\t\t\tcharacteristic_list[*count].properties |= GATTLIB_CHARACTERISTIC_INDICATE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\torg_bluez_gatt_characteristic1_get_uuid(characteristic),\n\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t&characteristic_list[*count].uuid);\n\t\t\t*count = *count + 1;\n\t\t}\n\t}\n}\n\nint gattlib_discover_char(gatt_connection_t* connection, gattlib_characteristic_t** characteristics, int* characteristic_count) {\n\tgattlib_context_t* conn_context = connection->context;\n\tGError *error = NULL;\n\tGList *l;\n\n\t// Get list of services\n\tGDBusObjectManager *device_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn 1;\n\t}\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\n\t// Count the maximum number of characteristic to allocate the array (we count all the characterstic for all devices)\n\tint count_max = 0, count = 0;\n\tfor (l = objects; l != NULL; l = l->next) {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattCharacteristic1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount_max++;\n\t}\n\n\tgattlib_characteristic_t* characteristic_list = malloc(count_max * sizeof(gattlib_characteristic_t));\n\tif (characteristic_list == NULL) {\n\t\treturn 1;\n\t}\n\n\t// List all services for this device\n\tfor (l = objects; l != NULL; l = l->next) {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattService1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tOrgBluezGattService1* service_proxy = org_bluez_gatt_service1_proxy_new_for_bus_sync(\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (service_proxy == NULL) {\n\t\t\tprintf(\"Failed to open service '%s'.\\n\", object_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ensure the service is attached to this device\n\t\tconst char* service_object_path = org_bluez_gatt_service1_get_device(service_proxy);\n\t\tif (strcmp(conn_context->device_object_path, service_object_path)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Add all characteristics attached to this service\n\t\tadd_characteristics_from_service(device_manager, object_path, characteristic_list, &count);\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\tg_object_unref(device_manager);\n\n\t*characteristics      = characteristic_list;\n\t*characteristic_count = count;\n\treturn 0;\n}\n#endif\n\nstatic OrgBluezGattCharacteristic1 *get_characteristic_from_uuid(gatt_connection_t* connection, const uuid_t* uuid) {\n\tgattlib_context_t* conn_context = connection->context;\n\tOrgBluezGattCharacteristic1 *characteristic = NULL;\n\tGError *error = NULL;\n\n\tGDBusObjectManager *device_manager = g_dbus_object_manager_client_new_for_bus_sync (\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\t\"/\",\n\t\t\tNULL, NULL, NULL, NULL,\n\t\t\t&error);\n\tif (device_manager == NULL) {\n\t\tputs(\"Failed to get Bluez Device Manager.\");\n\t\treturn NULL;\n\t}\n\n\tGList *objects = g_dbus_object_manager_get_objects(device_manager);\n\tGList *l;\n\tfor (l = objects; l != NULL; l = l->next)  {\n\t\tGDBusObject *object = l->data;\n\t\tconst char* object_path = g_dbus_object_get_object_path(G_DBUS_OBJECT(object));\n\n\t\tGDBusInterface *interface = g_dbus_object_manager_get_interface(device_manager, object_path, \"org.bluez.GattCharacteristic1\");\n\t\tif (!interface) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = NULL;\n\t\tcharacteristic = org_bluez_gatt_characteristic1_proxy_new_for_bus_sync (\n\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\"org.bluez\",\n\t\t\t\tobject_path,\n\t\t\t\tNULL,\n\t\t\t\t&error);\n\t\tif (characteristic) {\n\t\t\tuuid_t characteristic_uuid;\n\t\t\tconst gchar *characteristic_uuid_str = org_bluez_gatt_characteristic1_get_uuid(characteristic);\n\n\t\t\tgattlib_string_to_uuid(characteristic_uuid_str, strlen(characteristic_uuid_str) + 1, &characteristic_uuid);\n\t\t\tif (gattlib_uuid_cmp(uuid, &characteristic_uuid) == 0) {\n\t\t\t\t// We found the right characteristic, now we check if it's the right device.\n\n\t\t\t\terror = NULL;\n\t\t\t\tOrgBluezGattService1* service = org_bluez_gatt_service1_proxy_new_for_bus_sync (\n\t\t\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\t\t\"org.bluez\",\n\t\t\t\t\torg_bluez_gatt_characteristic1_get_service(characteristic),\n\t\t\t\t\tNULL,\n\t\t\t\t\t&error);\n\n\t\t\t\tif (service) {\n\t\t\t\t\tconst bool found = !strcmp(conn_context->device_object_path, org_bluez_gatt_service1_get_device(service));\n\n\t\t\t\t\tg_object_unref(service);\n\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tg_object_unref(characteristic);\n\t\t}\n\n\t\t// Ensure we set 'characteristic' back to NULL\n\t\tcharacteristic = NULL;\n\t}\n\n\tg_list_free_full(objects, g_object_unref);\n\tg_object_unref(device_manager);\n\treturn characteristic;\n}\n\nint gattlib_discover_desc_range(gatt_connection_t* connection, int start, int end, gattlib_descriptor_t** descriptors, int* descriptor_count) {\n\treturn -1;\n}\n\nint gattlib_discover_desc(gatt_connection_t* connection, gattlib_descriptor_t** descriptors, int* descriptor_count) {\n\treturn -1;\n}\n\nint gattlib_read_char_by_uuid(gatt_connection_t* connection, uuid_t* uuid, void* buffer, size_t* buffer_len) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\tGVariant *out_value;\n\tGError *error = NULL;\n\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 40)\n\torg_bluez_gatt_characteristic1_call_read_value_sync(\n\t\tcharacteristic, &out_value, NULL, &error);\n#else\n\tGVariantBuilder *options =  g_variant_builder_new(G_VARIANT_TYPE(\"a{sv}\"));\n\torg_bluez_gatt_characteristic1_call_read_value_sync(\n\t\tcharacteristic, g_variant_builder_end(options), &out_value, NULL, &error);\n\tg_variant_builder_unref(options);\n#endif\n\tif (error != NULL) {\n\t\treturn -1;\n\t}\n\n\tgsize n_elements = 0;\n\tgconstpointer const_buffer = g_variant_get_fixed_array(out_value, &n_elements, sizeof(guchar));\n\tif (const_buffer) {\n\t\tn_elements = MIN(n_elements, *buffer_len);\n\t\tmemcpy(buffer, const_buffer, n_elements);\n\t}\n\n\t*buffer_len = n_elements;\n\n\tg_object_unref(characteristic);\n\n#if BLUEZ_VERSION >= BLUEZ_VERSIONS(5, 40)\n\t//g_variant_unref(in_params); See: https://github.com/labapart/gattlib/issues/28#issuecomment-311486629\n#endif\n\treturn 0;\n}\n\nint gattlib_read_char_by_uuid_async(gatt_connection_t* connection, uuid_t* uuid, gatt_read_cb_t gatt_read_cb) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\tGVariant *out_value;\n\tGError *error = NULL;\n\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 40)\n\torg_bluez_gatt_characteristic1_call_read_value_sync(\n\t\tcharacteristic, &out_value, NULL, &error);\n#else\n\tGVariantBuilder *options =  g_variant_builder_new(G_VARIANT_TYPE(\"a{sv}\"));\n\torg_bluez_gatt_characteristic1_call_read_value_sync(\n\t\tcharacteristic, g_variant_builder_end(options), &out_value, NULL, &error);\n\tg_variant_builder_unref(options);\n#endif\n\tif (error != NULL) {\n\t\treturn -1;\n\t}\n\n\tgsize n_elements;\n\tgconstpointer const_buffer = g_variant_get_fixed_array(out_value, &n_elements, sizeof(guchar));\n\tif (const_buffer) {\n\t\tgatt_read_cb(const_buffer, n_elements);\n\t}\n\n\tg_object_unref(characteristic);\n\n#if BLUEZ_VERSION >= BLUEZ_VERSIONS(5, 40)\n\t//g_variant_unref(in_params); See: https://github.com/labapart/gattlib/issues/28#issuecomment-311486629\n#endif\n\treturn 0;\n}\n\nint gattlib_write_char_by_uuid(gatt_connection_t* connection, uuid_t* uuid, const void* buffer, size_t buffer_len) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\tGVariant *value = g_variant_new_from_data(G_VARIANT_TYPE (\"ay\"), buffer, buffer_len, TRUE, NULL, NULL);\n\tGError *error = NULL;\n\n#if BLUEZ_VERSION < BLUEZ_VERSIONS(5, 40)\n\torg_bluez_gatt_characteristic1_call_write_value_sync(characteristic, value, NULL, &error);\n#else\n\tGVariantBuilder *options =  g_variant_builder_new(G_VARIANT_TYPE(\"a{sv}\"));\n\torg_bluez_gatt_characteristic1_call_write_value_sync(characteristic, value, g_variant_builder_end(options), NULL, &error);\n\tg_variant_builder_unref(options);\n#endif\n\tif (error != NULL) {\n\t\treturn -1;\n\t}\n\n\tg_object_unref(characteristic);\n#if BLUEZ_VERSION >= BLUEZ_VERSIONS(5, 40)\n\t//g_variant_unref(in_params); See: https://github.com/labapart/gattlib/issues/28#issuecomment-311486629\n#endif\n\treturn 0;\n}\n\nint gattlib_write_char_by_handle(gatt_connection_t* connection, uint16_t handle, const void* buffer, size_t buffer_len) {\n\treturn -1;\n}\n\ngboolean on_handle_characteristic_property_change(\n\t    OrgBluezGattCharacteristic1 *object,\n\t    GVariant *arg_changed_properties,\n\t    const gchar *const *arg_invalidated_properties,\n\t    gpointer user_data)\n{\n\tgatt_connection_t* connection = user_data;\n\n\tif (connection->notification_handler) {\n\t\t// Retrieve 'Value' from 'arg_changed_properties'\n\t\tif (g_variant_n_children (arg_changed_properties) > 0) {\n\t\t\tGVariantIter *iter;\n\t\t\tconst gchar *key;\n\t\t\tGVariant *value;\n\n\t\t\tg_variant_get (arg_changed_properties, \"a{sv}\", &iter);\n\t\t\twhile (g_variant_iter_loop (iter, \"{&sv}\", &key, &value)) {\n\t\t\t\tif (strcmp(key, \"Value\") == 0) {\n\t\t\t\t\tuuid_t uuid;\n\t\t\t\t\tsize_t data_length;\n\t\t\t\t\tconst uint8_t* data = g_variant_get_fixed_array(value, &data_length, sizeof(guchar));\n\n\t\t\t\t\tgattlib_string_to_uuid(\n\t\t\t\t\t\t\torg_bluez_gatt_characteristic1_get_uuid(object),\n\t\t\t\t\t\t\tMAX_LEN_UUID_STR + 1,\n\t\t\t\t\t\t\t&uuid);\n\n\t\t\t\t\tconnection->notification_handler(&uuid, data, data_length, connection->notification_user_data);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nint gattlib_notification_start(gatt_connection_t* connection, const uuid_t* uuid) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\t// Register a handle for notification\n\tg_signal_connect(characteristic,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (on_handle_characteristic_property_change),\n\t\tconnection);\n\n\tGError *error = NULL;\n\torg_bluez_gatt_characteristic1_call_start_notify_sync(characteristic, NULL, &error);\n\n\tif (error) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint gattlib_notification_stop(gatt_connection_t* connection, const uuid_t* uuid) {\n\tOrgBluezGattCharacteristic1 *characteristic = get_characteristic_from_uuid(connection, uuid);\n\tif (characteristic == NULL) {\n\t\treturn -1;\n\t}\n\n\tGError *error = NULL;\n\torg_bluez_gatt_characteristic1_call_stop_notify_sync(\n\t\tcharacteristic, NULL, &error);\n\n\tif (error) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n", "patch": "@@ -2,7 +2,7 @@\n  *\n  *  GattLib - GATT Library\n  *\n- *  Copyright (C) 2016-2017 Olivier Martin <olivier@labapart.org>\n+ *  Copyright (C) 2016-2019 Olivier Martin <olivier@labapart.org>\n  *\n  *\n  *  This program is free software; you can redistribute it and/or modify\n@@ -209,7 +209,7 @@ gatt_connection_t *gattlib_connect(const char *src, const char *dst,\n {\n \tGError *error = NULL;\n \tconst char* adapter_name;\n-\tchar device_address_str[20];\n+\tchar device_address_str[20 + 1];\n \tchar object_path[100];\n \tint i;\n \n@@ -227,6 +227,9 @@ gatt_connection_t *gattlib_connect(const char *src, const char *dst,\n \t\t}\n \t}\n \n+\t// Force a null-terminated character\n+\tdevice_address_str[20] = '\\0';\n+\n \t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n \tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);\n "}
