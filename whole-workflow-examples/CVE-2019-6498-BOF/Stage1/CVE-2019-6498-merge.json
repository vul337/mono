{
  "stats": {
    "cve_id": "CVE-2019-6498",
    "language": "c_cpp",
    "sec_vul": {
      "num": 2,
      "no_more_info": [],
      "main_dir": [
        "CVE-2019-6498_part1.json",
        "CVE-2019-6498_0_part1.json"
      ]
    },
    "non_sec_vul": {
      "num": 0,
      "types": {}
    }
  },
  "raw_data": {
    "CVE-2019-6498_part1": {
      "cve_id": "CVE-2019-6498",
      "cwe_ids": [
        "CWE-125"
      ],
      "cvss_vector": "AV:A/AC:L/Au:N/C:P/I:P/A:P",
      "cvss_is_v3": false,
      "repo_name": "labapart/gattlib",
      "commit_msg": "Fix stack-based bufferoverflow\n\nFix: #81\nFix: #82",
      "commit_hash": "42cf4e63ee7f0eb830644ea37c37a2a9e256befd",
      "git_url": "https://github.com/labapart/gattlib/commit/42cf4e63ee7f0eb830644ea37c37a2a9e256befd",
      "file_path": "dbus/gattlib.c",
      "func_name": "gattlib_connect",
      "func_before": "gatt_connection_t *gattlib_connect(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu)\n{\n\tGError *error = NULL;\n\tconst char* adapter_name;\n\tchar device_address_str[20];\n\tchar object_path[100];\n\tint i;\n\n\tif (src) {\n\t\tadapter_name = src;\n\t} else {\n\t\tadapter_name = \"hci0\";\n\t}\n\n\t// Transform string from 'DA:94:40:95:E0:87' to 'dev_DA_94_40_95_E0_87'\n\tstrncpy(device_address_str, dst, sizeof(device_address_str));\n\tfor (i = 0; i < strlen(device_address_str); i++) {\n\t\tif (device_address_str[i] == ':') {\n\t\t\tdevice_address_str[i] = '_';\n\t\t}\n\t}\n\n\t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n\tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* connection = calloc(sizeof(gatt_connection_t), 1);\n\tif (connection == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tconnection->context = conn_context;\n\t}\n\n\tOrgBluezDevice1* device = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL,\n\t\t\t&error);\n\tif (device == NULL) {\n\t\tgoto FREE_CONNECTION;\n\t} else {\n\t\tconn_context->device = device;\n\t\tconn_context->device_object_path = strdup(object_path);\n\t}\n\n\terror = NULL;\n\torg_bluez_device1_call_connect_sync(device, NULL, &error);\n\tif (error) {\n\t\tprintf(\"Device connected error: %s\\n\", error->message);\n\t\tgoto FREE_DEVICE;\n\t}\n\n\t// Wait for the property 'UUIDs' to be changed. We assume 'org.bluez.GattService1\n\t// and 'org.bluez.GattCharacteristic1' to be advertised at that moment.\n\tGMainLoop *loop = g_main_loop_new(NULL, 0);\n\n\t// Register a handle for notification\n\tg_signal_connect(device,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (on_handle_device_property_change),\n\t\tloop);\n\n\tg_timeout_add_seconds (CONNECT_TIMEOUT, stop_scan_func, loop);\n\tg_main_loop_run(loop);\n\tg_main_loop_unref(loop);\n\n\treturn connection;\n\nFREE_DEVICE:\n\tfree(conn_context->device_object_path);\n\tg_object_unref(conn_context->device);\n\nFREE_CONNECTION:\n\tfree(connection);\n\treturn NULL;\n}",
      "abstract_func_before": "gatt_connection_t *gattlib_connect(const char *VAR_0, const char *VAR_1,\n\t\t\t\tuint8_t VAR_2, gattlib_bt_sec_level_t VAR_3, int VAR_4, int VAR_5)\n{\n\tGError *VAR_6 = NULL;\n\tconst char* VAR_7;\n\tchar VAR_8[20];\n\tchar VAR_9[100];\n\tint VAR_10;\n\n\tif (VAR_0) {\n\t\tVAR_7 = VAR_0;\n\t} else {\n\t\tVAR_7 = \"hci0\";\n\t}\n\n\t/* COMMENT_0 */\n\tstrncpy(VAR_8, VAR_1, sizeof(VAR_8));\n\tfor (VAR_10 = 0; VAR_10 < strlen(VAR_8); VAR_10++) {\n\t\tif (VAR_8[VAR_10] == ':') {\n\t\t\tVAR_8[VAR_10] = '_';\n\t\t}\n\t}\n\n\t/* COMMENT_1 */\n\tsnprintf(VAR_9, sizeof(VAR_9), \"/org/bluez/%s/dev_%s\", VAR_7, VAR_8);\n\n\tgattlib_context_t* VAR_11 = calloc(sizeof(gattlib_context_t), 1);\n\tif (VAR_11 == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* VAR_12 = calloc(sizeof(gatt_connection_t), 1);\n\tif (VAR_12 == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tVAR_12->context = VAR_11;\n\t}\n\n\tOrgBluezDevice1* VAR_13 = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tVAR_14,\n\t\t\tVAR_15,\n\t\t\t\"org.bluez\",\n\t\t\tVAR_9,\n\t\t\tNULL,\n\t\t\t&VAR_6);\n\tif (VAR_13 == NULL) {\n\t\tgoto FREE_CONNECTION;\n\t} else {\n\t\tVAR_11->device = VAR_13;\n\t\tVAR_11->device_object_path = strdup(VAR_9);\n\t}\n\n\tVAR_6 = NULL;\n\torg_bluez_device1_call_connect_sync(VAR_13, NULL, &VAR_6);\n\tif (VAR_6) {\n\t\tprintf(\"Device connected error: %s\\n\", VAR_6->message);\n\t\tgoto FREE_DEVICE;\n\t}\n\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\tGMainLoop *VAR_16 = g_main_loop_new(NULL, 0);\n\n\t/* COMMENT_4 */\n\tg_signal_connect(VAR_13,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (VAR_17),\n\t\tVAR_16);\n\n\tg_timeout_add_seconds (VAR_18, VAR_19, VAR_16);\n\tg_main_loop_run(VAR_16);\n\tg_main_loop_unref(VAR_16);\n\n\treturn VAR_12;\n\nFREE_DEVICE:\n\tfree(VAR_11->device_object_path);\n\tg_object_unref(VAR_11->device);\n\nFREE_CONNECTION:\n\tfree(VAR_12);\n\treturn NULL;\n}",
      "func_graph_path_before": "labapart/gattlib/42cf4e63ee7f0eb830644ea37c37a2a9e256befd/gattlib.c/vul/before/0.json",
      "func": "gatt_connection_t *gattlib_connect(const char *src, const char *dst,\n\t\t\t\tuint8_t dest_type, gattlib_bt_sec_level_t sec_level, int psm, int mtu)\n{\n\tGError *error = NULL;\n\tconst char* adapter_name;\n\tchar device_address_str[20 + 1];\n\tchar object_path[100];\n\tint i;\n\n\tif (src) {\n\t\tadapter_name = src;\n\t} else {\n\t\tadapter_name = \"hci0\";\n\t}\n\n\t// Transform string from 'DA:94:40:95:E0:87' to 'dev_DA_94_40_95_E0_87'\n\tstrncpy(device_address_str, dst, sizeof(device_address_str));\n\tfor (i = 0; i < strlen(device_address_str); i++) {\n\t\tif (device_address_str[i] == ':') {\n\t\t\tdevice_address_str[i] = '_';\n\t\t}\n\t}\n\n\t// Force a null-terminated character\n\tdevice_address_str[20] = '\\0';\n\n\t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n\tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* connection = calloc(sizeof(gatt_connection_t), 1);\n\tif (connection == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tconnection->context = conn_context;\n\t}\n\n\tOrgBluezDevice1* device = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tG_BUS_TYPE_SYSTEM,\n\t\t\tG_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,\n\t\t\t\"org.bluez\",\n\t\t\tobject_path,\n\t\t\tNULL,\n\t\t\t&error);\n\tif (device == NULL) {\n\t\tgoto FREE_CONNECTION;\n\t} else {\n\t\tconn_context->device = device;\n\t\tconn_context->device_object_path = strdup(object_path);\n\t}\n\n\terror = NULL;\n\torg_bluez_device1_call_connect_sync(device, NULL, &error);\n\tif (error) {\n\t\tprintf(\"Device connected error: %s\\n\", error->message);\n\t\tgoto FREE_DEVICE;\n\t}\n\n\t// Wait for the property 'UUIDs' to be changed. We assume 'org.bluez.GattService1\n\t// and 'org.bluez.GattCharacteristic1' to be advertised at that moment.\n\tGMainLoop *loop = g_main_loop_new(NULL, 0);\n\n\t// Register a handle for notification\n\tg_signal_connect(device,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (on_handle_device_property_change),\n\t\tloop);\n\n\tg_timeout_add_seconds (CONNECT_TIMEOUT, stop_scan_func, loop);\n\tg_main_loop_run(loop);\n\tg_main_loop_unref(loop);\n\n\treturn connection;\n\nFREE_DEVICE:\n\tfree(conn_context->device_object_path);\n\tg_object_unref(conn_context->device);\n\nFREE_CONNECTION:\n\tfree(connection);\n\treturn NULL;\n}",
      "abstract_func": "gatt_connection_t *gattlib_connect(const char *VAR_0, const char *VAR_1,\n\t\t\t\tuint8_t VAR_2, gattlib_bt_sec_level_t VAR_3, int VAR_4, int VAR_5)\n{\n\tGError *VAR_6 = NULL;\n\tconst char* VAR_7;\n\tchar VAR_8[20 + 1];\n\tchar VAR_9[100];\n\tint VAR_10;\n\n\tif (VAR_0) {\n\t\tVAR_7 = VAR_0;\n\t} else {\n\t\tVAR_7 = \"hci0\";\n\t}\n\n\t/* COMMENT_0 */\n\tstrncpy(VAR_8, VAR_1, sizeof(VAR_8));\n\tfor (VAR_10 = 0; VAR_10 < strlen(VAR_8); VAR_10++) {\n\t\tif (VAR_8[VAR_10] == ':') {\n\t\t\tVAR_8[VAR_10] = '_';\n\t\t}\n\t}\n\n\t/* COMMENT_1 */\n\tVAR_8[20] = '\\0';\n\n\t/* COMMENT_2 */\n\tsnprintf(VAR_9, sizeof(VAR_9), \"/org/bluez/%s/dev_%s\", VAR_7, VAR_8);\n\n\tgattlib_context_t* VAR_11 = calloc(sizeof(gattlib_context_t), 1);\n\tif (VAR_11 == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* VAR_12 = calloc(sizeof(gatt_connection_t), 1);\n\tif (VAR_12 == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tVAR_12->context = VAR_11;\n\t}\n\n\tOrgBluezDevice1* VAR_13 = org_bluez_device1_proxy_new_for_bus_sync(\n\t\t\tVAR_14,\n\t\t\tVAR_15,\n\t\t\t\"org.bluez\",\n\t\t\tVAR_9,\n\t\t\tNULL,\n\t\t\t&VAR_6);\n\tif (VAR_13 == NULL) {\n\t\tgoto FREE_CONNECTION;\n\t} else {\n\t\tVAR_11->device = VAR_13;\n\t\tVAR_11->device_object_path = strdup(VAR_9);\n\t}\n\n\tVAR_6 = NULL;\n\torg_bluez_device1_call_connect_sync(VAR_13, NULL, &VAR_6);\n\tif (VAR_6) {\n\t\tprintf(\"Device connected error: %s\\n\", VAR_6->message);\n\t\tgoto FREE_DEVICE;\n\t}\n\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\tGMainLoop *VAR_16 = g_main_loop_new(NULL, 0);\n\n\t/* COMMENT_5 */\n\tg_signal_connect(VAR_13,\n\t\t\"g-properties-changed\",\n\t\tG_CALLBACK (VAR_17),\n\t\tVAR_16);\n\n\tg_timeout_add_seconds (VAR_18, VAR_19, VAR_16);\n\tg_main_loop_run(VAR_16);\n\tg_main_loop_unref(VAR_16);\n\n\treturn VAR_12;\n\nFREE_DEVICE:\n\tfree(VAR_11->device_object_path);\n\tg_object_unref(VAR_11->device);\n\nFREE_CONNECTION:\n\tfree(VAR_12);\n\treturn NULL;\n}",
      "func_graph_path": "labapart/gattlib/42cf4e63ee7f0eb830644ea37c37a2a9e256befd/gattlib.c/vul/after/0.json",
      "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n \tGError *error = NULL;\n \tconst char* adapter_name;\n-\tchar device_address_str[20];\n+\tchar device_address_str[20 + 1];\n \tchar object_path[100];\n \tint i;\n \n@@ -20,6 +20,9 @@\n \t\t\tdevice_address_str[i] = '_';\n \t\t}\n \t}\n+\n+\t// Force a null-terminated character\n+\tdevice_address_str[20] = '\\0';\n \n \t// Generate object path like: /org/bluez/hci0/dev_DA_94_40_95_E0_87\n \tsnprintf(object_path, sizeof(object_path), \"/org/bluez/%s/dev_%s\", adapter_name, device_address_str);",
      "diff_line_info": {
        "deleted_lines": [
          "\tchar device_address_str[20];"
        ],
        "added_lines": [
          "\tchar device_address_str[20 + 1];",
          "",
          "\t// Force a null-terminated character",
          "\tdevice_address_str[20] = '\\0';"
        ]
      },
      "is_vul": true,
      "pr_url": "https://github.com/labapart/gattlib/pull/86",
      "description": "Fix: #81\r\nFix: #82 : Hi Team,\nSummary\nWhile fuzzing gattlib using clang 6.0 with ASAN a stack-based buffer-overflow was observed in gattlib.c and discover.c\n",
      "Bug Filter": "Security Vulnerability Fix",
      "Bug Filter Confidence": 1.0,
      "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
    },
    "CVE-2019-6498_0_part1": {
      "cve_id": "CVE-2019-6498",
      "cwe_ids": [
        "CWE-125"
      ],
      "cvss_vector": "AV:A/AC:L/Au:N/C:P/I:P/A:P",
      "cvss_is_v3": false,
      "repo_name": "labapart/gattlib",
      "commit_msg": "Fix stack-based bufferoverflow\n\nFix: #81\nFix: #82",
      "commit_hash": "42cf4e63ee7f0eb830644ea37c37a2a9e256befd",
      "git_url": "https://github.com/labapart/gattlib/commit/42cf4e63ee7f0eb830644ea37c37a2a9e256befd",
      "file_path": "bluez/gattlib_connect.c",
      "func_name": "initialize_gattlib_connection",
      "func_before": "static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst,\n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\tstr2ba(dst, &dba);\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3))\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\telse\n\t\t\tstr2ba(src, &sba);\n\t} else\n\t\tbacpy(&sba, BDADDR_ANY);\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}",
      "abstract_func_before": "static gatt_connection_t *initialize_gattlib_connection(const gchar *VAR_0, const gchar *VAR_1,\n\t\tuint8_t VAR_2, BtIOSecLevel VAR_3, int VAR_4, int VAR_5,\n\t\tgatt_connect_cb_t VAR_6,\n\t\tio_connect_arg_t* VAR_7)\n{\n\tbdaddr_t VAR_8, VAR_9;\n\tGError *VAR_10 = NULL;\n\n\t/* COMMENT_0 */\n\tif (VAR_11.ref == 0) {\n\t\t/* COMMENT_1 */\n\n\t\t/* COMMENT_2 */\n\t\tint VAR_12 = pthread_create(&VAR_11.thread, NULL, &VAR_13, &VAR_11);\n\t\tif (VAR_12 != 0) {\n\t\t\tfprintf(VAR_14, \"Cannot create connection thread: %s\", strerror(VAR_12));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* COMMENT_3 */\n\t\twhile (!VAR_11.loop || !g_main_loop_is_running (VAR_11.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* COMMENT_4 */\n\t\tVAR_11.ref++;\n\t}\n\n\t/* COMMENT_5 */\n\tif (VAR_1 == NULL) {\n\t\tfprintf(VAR_14, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\tstr2ba(VAR_1, &VAR_9);\n\n\t/* COMMENT_6 */\n\tif (VAR_0 != NULL) {\n\t\tif (!strncmp(VAR_0, \"hci\", 3))\n\t\t\thci_devba(atoi(VAR_0 + 3), &VAR_8);\n\t\telse\n\t\t\tstr2ba(VAR_0, &VAR_8);\n\t} else\n\t\tbacpy(&VAR_8, VAR_15);\n\n\t/* COMMENT_7 */\n\tif ((VAR_2 != VAR_16) && (VAR_2 != VAR_17)) {\n\t\treturn NULL;\n\t}\n\n\tif ((VAR_3 != VAR_18) && (VAR_3 != VAR_19) && (VAR_3 != VAR_20)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* VAR_21 = calloc(sizeof(gattlib_context_t), 1);\n\tif (VAR_21 == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* VAR_22 = calloc(sizeof(gatt_connection_t), 1);\n\tif (VAR_22 == NULL) {\n\t\treturn NULL;\n\t}\n\n\tVAR_22->context = VAR_21;\n\n    /* COMMENT_8 */\n\tVAR_7->conn       = VAR_22;\n\tVAR_7->connect_cb = VAR_6;\n\tVAR_7->connected  = FALSE;\n\tVAR_7->timeout    = FALSE;\n\tVAR_7->error      = NULL;\n\n\tif (VAR_4 == 0) {\n\t\tVAR_21->io = bt_io_connect(\n#if VAR_23 == 4\n\t\t\t\tVAR_24,\n#endif\n\t\t\t\tVAR_25, VAR_7, NULL, &VAR_10,\n\t\t\t\tVAR_26, &VAR_8,\n#if VAR_23 == 5\n\t\t\t\tVAR_27, VAR_16,\n#endif\n\t\t\t\tVAR_28, &VAR_9,\n\t\t\t\tVAR_29, VAR_2,\n\t\t\t\tVAR_30, VAR_31,\n\t\t\t\tVAR_32, VAR_3,\n\t\t\t\tVAR_33, VAR_34,\n\t\t\t\tVAR_35);\n\t} else {\n\t\tVAR_21->io = bt_io_connect(\n#if VAR_23 == 4\n\t\t\t\tVAR_24,\n#endif\n\t\t\t\tVAR_25, VAR_7, NULL, &VAR_10,\n\t\t\t\tVAR_26, &VAR_8,\n#if VAR_23 == 5\n\t\t\t\tVAR_27, VAR_16,\n#endif\n\t\t\t\tVAR_28, &VAR_9,\n\t\t\t\tVAR_36, VAR_4,\n\t\t\t\tVAR_37, VAR_5,\n\t\t\t\tVAR_32, VAR_3,\n\t\t\t\tVAR_33, VAR_34,\n\t\t\t\tVAR_35);\n\t}\n\n\tif (VAR_10) {\n\t\tfprintf(VAR_14, \"%s\\n\", VAR_10->message);\n\t\tg_error_free(VAR_10);\n\t\tfree(VAR_21);\n\t\tfree(VAR_22);\n\t\treturn NULL;\n\t} else {\n\t\treturn VAR_22;\n\t}\n}",
      "func_graph_path_before": "labapart/gattlib/42cf4e63ee7f0eb830644ea37c37a2a9e256befd/gattlib_connect.c/vul/before/0.json",
      "func": "static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst,\n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\tint ret;\n\n\tio_connect_arg->error = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = str2ba(dst, &dba);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);\n\t\treturn NULL;\n\t}\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3)) {\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\t} else {\n\t\t\tret = str2ba(src, &sba);\n\t\t\tif (ret != 0) {\n\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbacpy(&sba, BDADDR_ANY);\n\t}\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}",
      "abstract_func": "static gatt_connection_t *initialize_gattlib_connection(const gchar *VAR_0, const gchar *VAR_1,\n\t\tuint8_t VAR_2, BtIOSecLevel VAR_3, int VAR_4, int VAR_5,\n\t\tgatt_connect_cb_t VAR_6,\n\t\tio_connect_arg_t* VAR_7)\n{\n\tbdaddr_t VAR_8, VAR_9;\n\tGError *VAR_10 = NULL;\n\tint VAR_11;\n\n\tVAR_7->error = NULL;\n\n\t/* COMMENT_0 */\n\tif (VAR_12.ref == 0) {\n\t\t/* COMMENT_1 */\n\n\t\t/* COMMENT_2 */\n\t\tint VAR_13 = pthread_create(&VAR_12.thread, NULL, &VAR_14, &VAR_12);\n\t\tif (VAR_13 != 0) {\n\t\t\tfprintf(VAR_15, \"Cannot create connection thread: %s\", strerror(VAR_13));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* COMMENT_3 */\n\t\twhile (!VAR_12.loop || !g_main_loop_is_running (VAR_12.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* COMMENT_4 */\n\t\tVAR_12.ref++;\n\t}\n\n\t/* COMMENT_5 */\n\tif (VAR_1 == NULL) {\n\t\tfprintf(VAR_15, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\n\tVAR_11 = str2ba(VAR_1, &VAR_9);\n\tif (VAR_11 != 0) {\n\t\tfprintf(VAR_15, \"Destination address '%s' is not valid.\\n\", VAR_1);\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_6 */\n\tif (VAR_0 != NULL) {\n\t\tif (!strncmp(VAR_0, \"hci\", 3)) {\n\t\t\thci_devba(atoi(VAR_0 + 3), &VAR_8);\n\t\t} else {\n\t\t\tVAR_11 = str2ba(VAR_0, &VAR_8);\n\t\t\tif (VAR_11 != 0) {\n\t\t\t\tfprintf(VAR_15, \"Source address '%s' is not valid.\\n\", VAR_0);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbacpy(&VAR_8, VAR_16);\n\t}\n\n\t/* COMMENT_7 */\n\tif ((VAR_2 != VAR_17) && (VAR_2 != VAR_18)) {\n\t\treturn NULL;\n\t}\n\n\tif ((VAR_3 != VAR_19) && (VAR_3 != VAR_20) && (VAR_3 != VAR_21)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* VAR_22 = calloc(sizeof(gattlib_context_t), 1);\n\tif (VAR_22 == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* VAR_23 = calloc(sizeof(gatt_connection_t), 1);\n\tif (VAR_23 == NULL) {\n\t\treturn NULL;\n\t}\n\n\tVAR_23->context = VAR_22;\n\n    /* COMMENT_8 */\n\tVAR_7->conn       = VAR_23;\n\tVAR_7->connect_cb = VAR_6;\n\tVAR_7->connected  = FALSE;\n\tVAR_7->timeout    = FALSE;\n\tVAR_7->error      = NULL;\n\n\tif (VAR_4 == 0) {\n\t\tVAR_22->io = bt_io_connect(\n#if VAR_24 == 4\n\t\t\t\tVAR_25,\n#endif\n\t\t\t\tVAR_26, VAR_7, NULL, &VAR_10,\n\t\t\t\tVAR_27, &VAR_8,\n#if VAR_24 == 5\n\t\t\t\tVAR_28, VAR_17,\n#endif\n\t\t\t\tVAR_29, &VAR_9,\n\t\t\t\tVAR_30, VAR_2,\n\t\t\t\tVAR_31, VAR_32,\n\t\t\t\tVAR_33, VAR_3,\n\t\t\t\tVAR_34, VAR_35,\n\t\t\t\tVAR_36);\n\t} else {\n\t\tVAR_22->io = bt_io_connect(\n#if VAR_24 == 4\n\t\t\t\tVAR_25,\n#endif\n\t\t\t\tVAR_26, VAR_7, NULL, &VAR_10,\n\t\t\t\tVAR_27, &VAR_8,\n#if VAR_24 == 5\n\t\t\t\tVAR_28, VAR_17,\n#endif\n\t\t\t\tVAR_29, &VAR_9,\n\t\t\t\tVAR_37, VAR_4,\n\t\t\t\tVAR_38, VAR_5,\n\t\t\t\tVAR_33, VAR_3,\n\t\t\t\tVAR_34, VAR_35,\n\t\t\t\tVAR_36);\n\t}\n\n\tif (VAR_10) {\n\t\tfprintf(VAR_15, \"%s\\n\", VAR_10->message);\n\t\tg_error_free(VAR_10);\n\t\tfree(VAR_22);\n\t\tfree(VAR_23);\n\t\treturn NULL;\n\t} else {\n\t\treturn VAR_23;\n\t}\n}",
      "func_graph_path": "labapart/gattlib/42cf4e63ee7f0eb830644ea37c37a2a9e256befd/gattlib_connect.c/vul/after/0.json",
      "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,9 @@\n {\n \tbdaddr_t sba, dba;\n \tGError *err = NULL;\n+\tint ret;\n+\n+\tio_connect_arg->error = NULL;\n \n \t/* Check if the GattLib thread has been started */\n \tif (g_gattlib_thread.ref == 0) {\n@@ -31,16 +34,27 @@\n \t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n \t\treturn NULL;\n \t}\n-\tstr2ba(dst, &dba);\n+\n+\tret = str2ba(dst, &dba);\n+\tif (ret != 0) {\n+\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);\n+\t\treturn NULL;\n+\t}\n \n \t/* Local adapter */\n \tif (src != NULL) {\n-\t\tif (!strncmp(src, \"hci\", 3))\n+\t\tif (!strncmp(src, \"hci\", 3)) {\n \t\t\thci_devba(atoi(src + 3), &sba);\n-\t\telse\n-\t\t\tstr2ba(src, &sba);\n-\t} else\n+\t\t} else {\n+\t\t\tret = str2ba(src, &sba);\n+\t\t\tif (ret != 0) {\n+\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);\n+\t\t\t\treturn NULL;\n+\t\t\t}\n+\t\t}\n+\t} else {\n \t\tbacpy(&sba, BDADDR_ANY);\n+\t}\n \n \t/* Not used for BR/EDR */\n \tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {",
      "diff_line_info": {
        "deleted_lines": [
          "\tstr2ba(dst, &dba);",
          "\t\tif (!strncmp(src, \"hci\", 3))",
          "\t\telse",
          "\t\t\tstr2ba(src, &sba);",
          "\t} else"
        ],
        "added_lines": [
          "\tint ret;",
          "",
          "\tio_connect_arg->error = NULL;",
          "",
          "\tret = str2ba(dst, &dba);",
          "\tif (ret != 0) {",
          "\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);",
          "\t\treturn NULL;",
          "\t}",
          "\t\tif (!strncmp(src, \"hci\", 3)) {",
          "\t\t} else {",
          "\t\t\tret = str2ba(src, &sba);",
          "\t\t\tif (ret != 0) {",
          "\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);",
          "\t\t\t\treturn NULL;",
          "\t\t\t}",
          "\t\t}",
          "\t} else {",
          "\t}"
        ]
      },
      "is_vul": true,
      "pr_url": "https://github.com/labapart/gattlib/pull/86",
      "description": "Fix: #81\r\nFix: #82 : Hi Team,\nSummary\nWhile fuzzing gattlib using clang 6.0 with ASAN a stack-based buffer-overflow was observed in gattlib.c and discover.c\n",
      "Bug Filter": "Security Vulnerability Fix",
      "Bug Filter Confidence": 0.95,
      "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe changes address a buffer overflow by adding checks for input validation, which aligns with the commit message indicating a security fix."
    }
  }
}