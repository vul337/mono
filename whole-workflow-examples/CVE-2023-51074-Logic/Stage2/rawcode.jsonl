{"patches_id": 1, "files_id": 0, "file_name": "json-path-src-main-java-com-jayway-jsonpath-internal-path-PathCompiler.java", "language": "java", "raw_url": "https://github.com/json-path/JsonPath/raw/f49ff25e3bad8c8a0c853058181f2c00b5beb305/json-path%2Fsrc%2Fmain%2Fjava%2Fcom%2Fjayway%2Fjsonpath%2Finternal%2Fpath%2FPathCompiler.java", "file_path": "storage/result/Part2_result/github/CVE-2023-51074/patch_after/json-path-src-main-java-com-jayway-jsonpath-internal-path-PathCompiler.java", "raw_code": "package com.jayway.jsonpath.internal.path;\n\nimport com.jayway.jsonpath.InvalidPathException;\nimport com.jayway.jsonpath.Predicate;\nimport com.jayway.jsonpath.internal.CharacterIndex;\nimport com.jayway.jsonpath.internal.Path;\nimport com.jayway.jsonpath.internal.Utils;\nimport com.jayway.jsonpath.internal.filter.FilterCompiler;\nimport com.jayway.jsonpath.internal.function.ParamType;\nimport com.jayway.jsonpath.internal.function.Parameter;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport static java.lang.Character.isDigit;\nimport static java.util.Arrays.asList;\n\npublic class PathCompiler {\n\n    private static final char DOC_CONTEXT = '$';\n    private static final char EVAL_CONTEXT = '@';\n\n    private static final char OPEN_SQUARE_BRACKET = '[';\n    private static final char CLOSE_SQUARE_BRACKET = ']';\n    private static final char OPEN_PARENTHESIS = '(';\n    private static final char CLOSE_PARENTHESIS = ')';\n    private static final char OPEN_BRACE = '{';\n    private static final char CLOSE_BRACE = '}';\n\n    private static final char WILDCARD = '*';\n    private static final char PERIOD = '.';\n    private static final char SPACE = ' ';\n    private static final char TAB = '\\t';\n    private static final char CR = '\\r';\n    private static final char LF = '\\n';\n    private static final char BEGIN_FILTER = '?';\n    private static final char COMMA = ',';\n    private static final char SPLIT = ':';\n    private static final char MINUS = '-';\n    private static final char SINGLE_QUOTE = '\\'';\n    private static final char DOUBLE_QUOTE = '\"';\n\n    private final LinkedList<Predicate> filterStack;\n    private final CharacterIndex path;\n\n    private PathCompiler(String path, LinkedList<Predicate> filterStack){\n        this(new CharacterIndex(path), filterStack);\n    }\n\n    private PathCompiler(CharacterIndex path, LinkedList<Predicate> filterStack){\n        this.filterStack = filterStack;\n        this.path = path;\n    }\n\n    private Path compile() {\n        RootPathToken root = readContextToken();\n        return new CompiledPath(root, root.getPathFragment().equals(\"$\"));\n    }\n\n    public static Path compile(String path, final Predicate... filters) {\n        try {\n            CharacterIndex ci = new CharacterIndex(path);\n            ci.trim();\n\n            if(!( ci.charAt(0) == DOC_CONTEXT)  && !( ci.charAt(0) == EVAL_CONTEXT)){\n                ci = new CharacterIndex(\"$.\" + path);\n                ci.trim();\n            }\n            if(ci.lastCharIs('.')){\n                fail(\"Path must not end with a '.' or '..'\");\n            }\n            LinkedList<Predicate> filterStack = new LinkedList<Predicate>(asList(filters));\n            return new PathCompiler(ci, filterStack).compile();\n        } catch (Exception e) {\n            InvalidPathException ipe;\n            if (e instanceof InvalidPathException) {\n                ipe = (InvalidPathException) e;\n            } else {\n                ipe = new InvalidPathException(e);\n            }\n            throw ipe;\n        }\n    }\n\n    private void readWhitespace() {\n        while (path.inBounds()) {\n            char c = path.currentChar();\n            if (!isWhitespace(c)) {\n                break;\n            }\n            path.incrementPosition(1);\n        }\n    }\n\n    private Boolean isPathContext(char c) {\n        return (c == DOC_CONTEXT || c == EVAL_CONTEXT);\n    }\n\n    //[$ | @]\n    private RootPathToken readContextToken() {\n\n        readWhitespace();\n\n        if (!isPathContext(path.currentChar())) {\n            throw new InvalidPathException(\"Path must start with '$' or '@'\");\n        }\n\n        RootPathToken pathToken = PathTokenFactory.createRootPathToken(path.currentChar());\n\n        if (path.currentIsTail()) {\n            return pathToken;\n        }\n\n        path.incrementPosition(1);\n\n        if(path.currentChar() != PERIOD && path.currentChar() != OPEN_SQUARE_BRACKET){\n            fail(\"Illegal character at position \" + path.position() + \" expected '.' or '['\");\n        }\n\n        PathTokenAppender appender = pathToken.getPathTokenAppender();\n        readNextToken(appender);\n\n        return pathToken;\n    }\n\n    //\n    //\n    //\n    private boolean readNextToken(PathTokenAppender appender) {\n\n        char c = path.currentChar();\n\n        switch (c) {\n            case OPEN_SQUARE_BRACKET:\n                if (!readBracketPropertyToken(appender) && !readArrayToken(appender) && !readWildCardToken(appender)\n                    && !readFilterToken(appender) && !readPlaceholderToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position() + \". Expected ?, ', 0-9, * \");\n                }\n                return true;\n            case PERIOD:\n                if (!readDotToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n            case WILDCARD:\n                if (!readWildCardToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n            default:\n                if (!readPropertyOrFunctionToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n        }\n    }\n\n    //\n    // . and ..\n    //\n    private boolean readDotToken(PathTokenAppender appender) {\n        if (path.currentCharIs(PERIOD) && path.nextCharIs(PERIOD)) {\n            appender.appendPathToken(PathTokenFactory.crateScanToken());\n            path.incrementPosition(2);\n        } else if (!path.hasMoreCharacters()) {\n            throw new InvalidPathException(\"Path must not end with a '.\");\n        } else {\n            path.incrementPosition(1);\n        }\n        if(path.currentCharIs(PERIOD)){\n            throw new InvalidPathException(\"Character '.' on position \" + path.position() + \" is not valid.\");\n        }\n        return readNextToken(appender);\n    }\n\n    //\n    // fooBar or fooBar()\n    //\n    private boolean readPropertyOrFunctionToken(PathTokenAppender appender) {\n        if (path.currentCharIs(OPEN_SQUARE_BRACKET) || path.currentCharIs(WILDCARD) || path.currentCharIs(PERIOD) || path.currentCharIs(SPACE)) {\n            return false;\n        }\n        int startPosition = path.position();\n        int readPosition = startPosition;\n        int endPosition = 0;\n\n        boolean isFunction = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n            if (c == SPACE) {\n                throw new InvalidPathException(\"Use bracket notion ['my prop'] if your property contains blank characters. position: \" + path.position());\n            }\n            else if (c == PERIOD || c == OPEN_SQUARE_BRACKET) {\n                endPosition = readPosition;\n                break;\n            }\n            else if (c == OPEN_PARENTHESIS) {\n                isFunction = true;\n                endPosition = readPosition;\n                break;\n            }\n            readPosition++;\n        }\n        if (endPosition == 0) {\n            endPosition = path.length();\n        }\n\n\n        List<Parameter> functionParameters = null;\n        if (isFunction) {\n            int parenthesis_count = 1;\n            for(int i = readPosition + 1; i < path.length(); i++){\n                if (path.charAt(i) == CLOSE_PARENTHESIS)\n                    parenthesis_count--;\n                else if (path.charAt(i) == OPEN_PARENTHESIS)\n                    parenthesis_count++;\n                if (parenthesis_count == 0)\n                    break;\n            }\n\n            if (parenthesis_count != 0){\n                String functionName = path.subSequence(startPosition, endPosition).toString();\n                throw new InvalidPathException(\"Arguments to function: '\" + functionName + \"' are not closed properly.\");\n            }\n\n            if (path.inBounds(readPosition+1)) {\n                // read the next token to determine if we have a simple no-args function call\n                char c = path.charAt(readPosition + 1);\n                if (c != CLOSE_PARENTHESIS) {\n                    path.setPosition(endPosition+1);\n                    // parse the arguments of the function - arguments that are inner queries or JSON document(s)\n                    String functionName = path.subSequence(startPosition, endPosition).toString();\n                    functionParameters = parseFunctionParameters(functionName);\n                } else {\n                    path.setPosition(readPosition + 1);\n                }\n            }\n            else {\n                path.setPosition(readPosition);\n            }\n        }\n        else {\n            path.setPosition(endPosition);\n        }\n\n        String property = path.subSequence(startPosition, endPosition).toString();\n        if(isFunction){\n            appender.appendPathToken(PathTokenFactory.createFunctionPathToken(property, functionParameters));\n        } else {\n            appender.appendPathToken(PathTokenFactory.createSinglePropertyPathToken(property, SINGLE_QUOTE));\n        }\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    /**\n     * Parse the parameters of a function call, either the caller has supplied JSON data, or the caller has supplied\n     * another path expression which must be evaluated and in turn invoked against the root document.  In this tokenizer\n     * we're only concerned with parsing the path thus the output of this function is a list of parameters with the Path\n     * set if the parameter is an expression.  If the parameter is a JSON document then the value of the cachedValue is\n     * set on the object.\n     *\n     * Sequence for parsing out the parameters:\n     *\n     * This code has its own tokenizer - it does some rudimentary level of lexing in that it can distinguish between JSON block parameters\n     * and sub-JSON blocks - it effectively regex's out the parameters into string blocks that can then be passed along to the appropriate parser.\n     * Since sub-jsonpath expressions can themselves contain other function calls this routine needs to be sensitive to token counting to\n     * determine the boundaries.  Since the Path parser isn't aware of JSON processing this uber routine is needed.\n     *\n     * Parameters are separated by COMMAs ','\n     *\n     * <pre>\n     * doc = {\"numbers\": [1,2,3,4,5,6,7,8,9,10]}\n     *\n     * $.sum({10}, $.numbers.avg())\n     * </pre>\n     *\n     * The above is a valid function call, we're first summing 10 + avg of 1...10 (5.5) so the total should be 15.5\n     *\n     * @return\n     *      An ordered list of parameters that are to processed via the function.  Typically functions either process\n     *      an array of values and/or can consume parameters in addition to the values provided from the consumption of\n     *      an array.\n     */\n    private List<Parameter> parseFunctionParameters(String funcName) {\n        ParamType type = null;\n\n        // Parenthesis starts at 1 since we're marking the start of a function call, the close paren will denote the\n        // last parameter boundary\n        int groupParen = 1, groupBracket = 0, groupBrace = 0, groupQuote = 0;\n        boolean endOfStream = false;\n        char priorChar = 0;\n        List<Parameter> parameters = new ArrayList<Parameter>();\n        StringBuilder parameter = new StringBuilder();\n        while (path.inBounds() && !endOfStream) {\n            char c = path.currentChar();\n            path.incrementPosition(1);\n\n            // we're at the start of the stream, and don't know what type of parameter we have\n            if (type == null) {\n                if (isWhitespace(c)) {\n                    continue;\n                }\n\n                if (c == OPEN_BRACE || isDigit(c) || DOUBLE_QUOTE == c || MINUS == c) {\n                    type = ParamType.JSON;\n                }\n                else if (isPathContext(c)) {\n                    type = ParamType.PATH; // read until we reach a terminating comma and we've reset grouping to zero\n                }\n            }\n\n            switch (c) {\n                case DOUBLE_QUOTE:\n                    if (priorChar != '\\\\' && groupQuote > 0) {\n                        groupQuote--;\n                    }\n                    else {\n                        groupQuote++;\n                    }\n                    break;\n                case OPEN_PARENTHESIS:\n                    groupParen++;\n                    break;\n                case OPEN_BRACE:\n                    groupBrace++;\n                    break;\n                case OPEN_SQUARE_BRACKET:\n                    groupBracket++;\n                    break;\n\n                case CLOSE_BRACE:\n                    if (0 == groupBrace) {\n                        throw new InvalidPathException(\"Unexpected close brace '}' at character position: \" + path.position());\n                    }\n                    groupBrace--;\n                    break;\n                case CLOSE_SQUARE_BRACKET:\n                    if (0 == groupBracket) {\n                        throw new InvalidPathException(\"Unexpected close bracket ']' at character position: \" + path.position());\n                    }\n                    groupBracket--;\n                    break;\n\n                // In either the close paren case where we have zero paren groups left, capture the parameter, or where\n                // we've encountered a COMMA do the same\n                case CLOSE_PARENTHESIS:\n                    groupParen--;\n                    //CS304 Issue link: https://github.com/json-path/JsonPath/issues/620\n                    if (0 > groupParen || priorChar == '(') {\n                        parameter.append(c);\n                    }\n                case COMMA:\n                    // In this state we've reach the end of a function parameter and we can pass along the parameter string\n                    // to the parser\n                    if ((0 == groupQuote && 0 == groupBrace && 0 == groupBracket\n                            && ((0 == groupParen && CLOSE_PARENTHESIS == c) || 1 == groupParen))) {\n                        endOfStream = (0 == groupParen);\n\n                        if (null != type) {\n                            Parameter param = null;\n                            switch (type) {\n                                case JSON:\n                                    // parse the json and set the value\n                                    param = new Parameter(parameter.toString());\n                                    break;\n                                case PATH:\n                                    LinkedList<Predicate> predicates = new LinkedList<>();\n                                    PathCompiler compiler = new PathCompiler(parameter.toString(), predicates);\n                                    param = new Parameter(compiler.compile());\n                                    break;\n                            }\n                            if (null != param) {\n                                parameters.add(param);\n                            }\n                            parameter.delete(0, parameter.length());\n                            type = null;\n                        }\n                    }\n                    break;\n            }\n\n            if (type != null && !(c == COMMA && 0 == groupBrace && 0 == groupBracket && 1 == groupParen)) {\n                parameter.append(c);\n            }\n            priorChar = c;\n        }\n        if (0 != groupBrace || 0 != groupParen || 0 != groupBracket) {\n            throw new InvalidPathException(\"Arguments to function: '\" + funcName + \"' are not closed properly.\");\n        }\n        return parameters;\n    }\n\n    private boolean isWhitespace(char c) {\n        return (c == SPACE || c == TAB || c == LF || c == CR);\n    }\n\n    //\n    // [?], [?,?, ..]\n    //\n    private boolean readPlaceholderToken(PathTokenAppender appender) {\n\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        int questionmarkIndex = path.indexOfNextSignificantChar(BEGIN_FILTER);\n        if (questionmarkIndex == -1) {\n            return false;\n        }\n        char nextSignificantChar = path.nextSignificantChar(questionmarkIndex);\n        if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n            return false;\n        }\n\n        int expressionBeginIndex = path.position() + 1;\n        int expressionEndIndex = path.nextIndexOf(expressionBeginIndex, CLOSE_SQUARE_BRACKET);\n\n        if (expressionEndIndex == -1) {\n            return false;\n        }\n\n        String expression = path.subSequence(expressionBeginIndex, expressionEndIndex).toString();\n\n        String[] tokens = expression.split(\",\");\n\n        if (filterStack.size() < tokens.length) {\n            throw new InvalidPathException(\"Not enough predicates supplied for filter [\" + expression + \"] at position \" + path.position());\n        }\n\n        Collection<Predicate> predicates = new ArrayList<Predicate>();\n        for (String token : tokens) {\n            token = token != null ? token.trim() : null;\n            if (!\"?\".equals(token == null ? \"\" : token)) {\n                throw new InvalidPathException(\"Expected '?' but found \" + token);\n            }\n            predicates.add(filterStack.pop());\n        }\n\n        appender.appendPathToken(PathTokenFactory.createPredicatePathToken(predicates));\n\n        path.setPosition(expressionEndIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    //\n    // [?(...)]\n    //\n    private boolean readFilterToken(PathTokenAppender appender) {\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET) && !path.nextSignificantCharIs(BEGIN_FILTER)) {\n            return false;\n        }\n\n        int openStatementBracketIndex = path.position();\n        int questionMarkIndex = path.indexOfNextSignificantChar(BEGIN_FILTER);\n        if (questionMarkIndex == -1) {\n            return false;\n        }\n        int openBracketIndex = path.indexOfNextSignificantChar(questionMarkIndex, OPEN_PARENTHESIS);\n        if (openBracketIndex == -1) {\n            return false;\n        }\n        int closeBracketIndex = path.indexOfClosingBracket(openBracketIndex, true, true);\n        if (closeBracketIndex == -1) {\n            return false;\n        }\n        if (!path.nextSignificantCharIs(closeBracketIndex, CLOSE_SQUARE_BRACKET)) {\n            return false;\n        }\n        int closeStatementBracketIndex = path.indexOfNextSignificantChar(closeBracketIndex, CLOSE_SQUARE_BRACKET);\n\n        String criteria = path.subSequence(openStatementBracketIndex, closeStatementBracketIndex + 1).toString();\n\n\n        Predicate predicate = FilterCompiler.compile(criteria);\n        appender.appendPathToken(PathTokenFactory.createPredicatePathToken(predicate));\n\n        path.setPosition(closeStatementBracketIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n\n    }\n\n    //\n    // [*]\n    // *\n    //\n    private boolean readWildCardToken(PathTokenAppender appender) {\n\n        boolean inBracket = path.currentCharIs(OPEN_SQUARE_BRACKET);\n\n        if (inBracket && !path.nextSignificantCharIs(WILDCARD)) {\n            return false;\n        }\n        if (!path.currentCharIs(WILDCARD) && path.isOutOfBounds(path.position() + 1)) {\n            return false;\n        }\n        if (inBracket) {\n            int wildCardIndex = path.indexOfNextSignificantChar(WILDCARD);\n            if (!path.nextSignificantCharIs(wildCardIndex, CLOSE_SQUARE_BRACKET)) {\n                int offset = wildCardIndex + 1;\n                throw new InvalidPathException(\"Expected wildcard token to end with ']' on position \" + offset);\n            }\n            int bracketCloseIndex = path.indexOfNextSignificantChar(wildCardIndex, CLOSE_SQUARE_BRACKET);\n            path.setPosition(bracketCloseIndex + 1);\n        } else {\n            path.incrementPosition(1);\n        }\n\n        appender.appendPathToken(PathTokenFactory.createWildCardPathToken());\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    //\n    // [1], [1,2, n], [1:], [1:2], [:2]\n    //\n    private boolean readArrayToken(PathTokenAppender appender) {\n\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char nextSignificantChar = path.nextSignificantChar();\n        if (!isDigit(nextSignificantChar) && nextSignificantChar != MINUS && nextSignificantChar != SPLIT) {\n            return false;\n        }\n\n        int expressionBeginIndex = path.position() + 1;\n        int expressionEndIndex = path.nextIndexOf(expressionBeginIndex, CLOSE_SQUARE_BRACKET);\n\n        if (expressionEndIndex == -1) {\n            return false;\n        }\n\n        String expression = path.subSequence(expressionBeginIndex, expressionEndIndex).toString().trim();\n\n        if (\"*\".equals(expression)) {\n            return false;\n        }\n\n        //check valid chars\n        for (int i = 0; i < expression.length(); i++) {\n            char c = expression.charAt(i);\n            if (!isDigit(c) && c != COMMA && c != MINUS && c != SPLIT && c != SPACE) {\n                return false;\n            }\n        }\n\n        boolean isSliceOperation = expression.contains(\":\");\n\n        if (isSliceOperation) {\n            ArraySliceOperation arraySliceOperation = ArraySliceOperation.parse(expression);\n            appender.appendPathToken(PathTokenFactory.createSliceArrayPathToken(arraySliceOperation));\n        } else {\n            ArrayIndexOperation arrayIndexOperation = ArrayIndexOperation.parse(expression);\n            appender.appendPathToken(PathTokenFactory.createIndexArrayPathToken(arrayIndexOperation));\n        }\n\n        path.setPosition(expressionEndIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    //\n    // ['foo']\n    //\n    private boolean readBracketPropertyToken(PathTokenAppender appender) {\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n        if(endBracketIndex == -1) {\n            fail(\"Property has not been closed - missing closing ]\");\n        }\n        endBracketIndex++;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    public static boolean fail(String message) {\n        throw new InvalidPathException(message);\n    }\n}\n", "raw_code_before": "package com.jayway.jsonpath.internal.path;\n\nimport com.jayway.jsonpath.InvalidPathException;\nimport com.jayway.jsonpath.Predicate;\nimport com.jayway.jsonpath.internal.CharacterIndex;\nimport com.jayway.jsonpath.internal.Path;\nimport com.jayway.jsonpath.internal.Utils;\nimport com.jayway.jsonpath.internal.filter.FilterCompiler;\nimport com.jayway.jsonpath.internal.function.ParamType;\nimport com.jayway.jsonpath.internal.function.Parameter;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport static java.lang.Character.isDigit;\nimport static java.util.Arrays.asList;\n\npublic class PathCompiler {\n\n    private static final char DOC_CONTEXT = '$';\n    private static final char EVAL_CONTEXT = '@';\n\n    private static final char OPEN_SQUARE_BRACKET = '[';\n    private static final char CLOSE_SQUARE_BRACKET = ']';\n    private static final char OPEN_PARENTHESIS = '(';\n    private static final char CLOSE_PARENTHESIS = ')';\n    private static final char OPEN_BRACE = '{';\n    private static final char CLOSE_BRACE = '}';\n\n    private static final char WILDCARD = '*';\n    private static final char PERIOD = '.';\n    private static final char SPACE = ' ';\n    private static final char TAB = '\\t';\n    private static final char CR = '\\r';\n    private static final char LF = '\\n';\n    private static final char BEGIN_FILTER = '?';\n    private static final char COMMA = ',';\n    private static final char SPLIT = ':';\n    private static final char MINUS = '-';\n    private static final char SINGLE_QUOTE = '\\'';\n    private static final char DOUBLE_QUOTE = '\"';\n\n    private final LinkedList<Predicate> filterStack;\n    private final CharacterIndex path;\n\n    private PathCompiler(String path, LinkedList<Predicate> filterStack){\n        this(new CharacterIndex(path), filterStack);\n    }\n\n    private PathCompiler(CharacterIndex path, LinkedList<Predicate> filterStack){\n        this.filterStack = filterStack;\n        this.path = path;\n    }\n\n    private Path compile() {\n        RootPathToken root = readContextToken();\n        return new CompiledPath(root, root.getPathFragment().equals(\"$\"));\n    }\n\n    public static Path compile(String path, final Predicate... filters) {\n        try {\n            CharacterIndex ci = new CharacterIndex(path);\n            ci.trim();\n\n            if(!( ci.charAt(0) == DOC_CONTEXT)  && !( ci.charAt(0) == EVAL_CONTEXT)){\n                ci = new CharacterIndex(\"$.\" + path);\n                ci.trim();\n            }\n            if(ci.lastCharIs('.')){\n                fail(\"Path must not end with a '.' or '..'\");\n            }\n            LinkedList<Predicate> filterStack = new LinkedList<Predicate>(asList(filters));\n            return new PathCompiler(ci, filterStack).compile();\n        } catch (Exception e) {\n            InvalidPathException ipe;\n            if (e instanceof InvalidPathException) {\n                ipe = (InvalidPathException) e;\n            } else {\n                ipe = new InvalidPathException(e);\n            }\n            throw ipe;\n        }\n    }\n\n    private void readWhitespace() {\n        while (path.inBounds()) {\n            char c = path.currentChar();\n            if (!isWhitespace(c)) {\n                break;\n            }\n            path.incrementPosition(1);\n        }\n    }\n\n    private Boolean isPathContext(char c) {\n        return (c == DOC_CONTEXT || c == EVAL_CONTEXT);\n    }\n\n    //[$ | @]\n    private RootPathToken readContextToken() {\n\n        readWhitespace();\n\n        if (!isPathContext(path.currentChar())) {\n            throw new InvalidPathException(\"Path must start with '$' or '@'\");\n        }\n\n        RootPathToken pathToken = PathTokenFactory.createRootPathToken(path.currentChar());\n\n        if (path.currentIsTail()) {\n            return pathToken;\n        }\n\n        path.incrementPosition(1);\n\n        if(path.currentChar() != PERIOD && path.currentChar() != OPEN_SQUARE_BRACKET){\n            fail(\"Illegal character at position \" + path.position() + \" expected '.' or '['\");\n        }\n\n        PathTokenAppender appender = pathToken.getPathTokenAppender();\n        readNextToken(appender);\n\n        return pathToken;\n    }\n\n    //\n    //\n    //\n    private boolean readNextToken(PathTokenAppender appender) {\n\n        char c = path.currentChar();\n\n        switch (c) {\n            case OPEN_SQUARE_BRACKET:\n                if (!readBracketPropertyToken(appender) && !readArrayToken(appender) && !readWildCardToken(appender)\n                    && !readFilterToken(appender) && !readPlaceholderToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position() + \". Expected ?, ', 0-9, * \");\n                }\n                return true;\n            case PERIOD:\n                if (!readDotToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n            case WILDCARD:\n                if (!readWildCardToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n            default:\n                if (!readPropertyOrFunctionToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n        }\n    }\n\n    //\n    // . and ..\n    //\n    private boolean readDotToken(PathTokenAppender appender) {\n        if (path.currentCharIs(PERIOD) && path.nextCharIs(PERIOD)) {\n            appender.appendPathToken(PathTokenFactory.crateScanToken());\n            path.incrementPosition(2);\n        } else if (!path.hasMoreCharacters()) {\n            throw new InvalidPathException(\"Path must not end with a '.\");\n        } else {\n            path.incrementPosition(1);\n        }\n        if(path.currentCharIs(PERIOD)){\n            throw new InvalidPathException(\"Character '.' on position \" + path.position() + \" is not valid.\");\n        }\n        return readNextToken(appender);\n    }\n\n    //\n    // fooBar or fooBar()\n    //\n    private boolean readPropertyOrFunctionToken(PathTokenAppender appender) {\n        if (path.currentCharIs(OPEN_SQUARE_BRACKET) || path.currentCharIs(WILDCARD) || path.currentCharIs(PERIOD) || path.currentCharIs(SPACE)) {\n            return false;\n        }\n        int startPosition = path.position();\n        int readPosition = startPosition;\n        int endPosition = 0;\n\n        boolean isFunction = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n            if (c == SPACE) {\n                throw new InvalidPathException(\"Use bracket notion ['my prop'] if your property contains blank characters. position: \" + path.position());\n            }\n            else if (c == PERIOD || c == OPEN_SQUARE_BRACKET) {\n                endPosition = readPosition;\n                break;\n            }\n            else if (c == OPEN_PARENTHESIS) {\n                isFunction = true;\n                endPosition = readPosition;\n                break;\n            }\n            readPosition++;\n        }\n        if (endPosition == 0) {\n            endPosition = path.length();\n        }\n\n\n        List<Parameter> functionParameters = null;\n        if (isFunction) {\n            int parenthesis_count = 1;\n            for(int i = readPosition + 1; i < path.length(); i++){\n                if (path.charAt(i) == CLOSE_PARENTHESIS)\n                    parenthesis_count--;\n                else if (path.charAt(i) == OPEN_PARENTHESIS)\n                    parenthesis_count++;\n                if (parenthesis_count == 0)\n                    break;\n            }\n\n            if (parenthesis_count != 0){\n                String functionName = path.subSequence(startPosition, endPosition).toString();\n                throw new InvalidPathException(\"Arguments to function: '\" + functionName + \"' are not closed properly.\");\n            }\n\n            if (path.inBounds(readPosition+1)) {\n                // read the next token to determine if we have a simple no-args function call\n                char c = path.charAt(readPosition + 1);\n                if (c != CLOSE_PARENTHESIS) {\n                    path.setPosition(endPosition+1);\n                    // parse the arguments of the function - arguments that are inner queries or JSON document(s)\n                    String functionName = path.subSequence(startPosition, endPosition).toString();\n                    functionParameters = parseFunctionParameters(functionName);\n                } else {\n                    path.setPosition(readPosition + 1);\n                }\n            }\n            else {\n                path.setPosition(readPosition);\n            }\n        }\n        else {\n            path.setPosition(endPosition);\n        }\n\n        String property = path.subSequence(startPosition, endPosition).toString();\n        if(isFunction){\n            appender.appendPathToken(PathTokenFactory.createFunctionPathToken(property, functionParameters));\n        } else {\n            appender.appendPathToken(PathTokenFactory.createSinglePropertyPathToken(property, SINGLE_QUOTE));\n        }\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    /**\n     * Parse the parameters of a function call, either the caller has supplied JSON data, or the caller has supplied\n     * another path expression which must be evaluated and in turn invoked against the root document.  In this tokenizer\n     * we're only concerned with parsing the path thus the output of this function is a list of parameters with the Path\n     * set if the parameter is an expression.  If the parameter is a JSON document then the value of the cachedValue is\n     * set on the object.\n     *\n     * Sequence for parsing out the parameters:\n     *\n     * This code has its own tokenizer - it does some rudimentary level of lexing in that it can distinguish between JSON block parameters\n     * and sub-JSON blocks - it effectively regex's out the parameters into string blocks that can then be passed along to the appropriate parser.\n     * Since sub-jsonpath expressions can themselves contain other function calls this routine needs to be sensitive to token counting to\n     * determine the boundaries.  Since the Path parser isn't aware of JSON processing this uber routine is needed.\n     *\n     * Parameters are separated by COMMAs ','\n     *\n     * <pre>\n     * doc = {\"numbers\": [1,2,3,4,5,6,7,8,9,10]}\n     *\n     * $.sum({10}, $.numbers.avg())\n     * </pre>\n     *\n     * The above is a valid function call, we're first summing 10 + avg of 1...10 (5.5) so the total should be 15.5\n     *\n     * @return\n     *      An ordered list of parameters that are to processed via the function.  Typically functions either process\n     *      an array of values and/or can consume parameters in addition to the values provided from the consumption of\n     *      an array.\n     */\n    private List<Parameter> parseFunctionParameters(String funcName) {\n        ParamType type = null;\n\n        // Parenthesis starts at 1 since we're marking the start of a function call, the close paren will denote the\n        // last parameter boundary\n        int groupParen = 1, groupBracket = 0, groupBrace = 0, groupQuote = 0;\n        boolean endOfStream = false;\n        char priorChar = 0;\n        List<Parameter> parameters = new ArrayList<Parameter>();\n        StringBuilder parameter = new StringBuilder();\n        while (path.inBounds() && !endOfStream) {\n            char c = path.currentChar();\n            path.incrementPosition(1);\n\n            // we're at the start of the stream, and don't know what type of parameter we have\n            if (type == null) {\n                if (isWhitespace(c)) {\n                    continue;\n                }\n\n                if (c == OPEN_BRACE || isDigit(c) || DOUBLE_QUOTE == c || MINUS == c) {\n                    type = ParamType.JSON;\n                }\n                else if (isPathContext(c)) {\n                    type = ParamType.PATH; // read until we reach a terminating comma and we've reset grouping to zero\n                }\n            }\n\n            switch (c) {\n                case DOUBLE_QUOTE:\n                    if (priorChar != '\\\\' && groupQuote > 0) {\n                        groupQuote--;\n                    }\n                    else {\n                        groupQuote++;\n                    }\n                    break;\n                case OPEN_PARENTHESIS:\n                    groupParen++;\n                    break;\n                case OPEN_BRACE:\n                    groupBrace++;\n                    break;\n                case OPEN_SQUARE_BRACKET:\n                    groupBracket++;\n                    break;\n\n                case CLOSE_BRACE:\n                    if (0 == groupBrace) {\n                        throw new InvalidPathException(\"Unexpected close brace '}' at character position: \" + path.position());\n                    }\n                    groupBrace--;\n                    break;\n                case CLOSE_SQUARE_BRACKET:\n                    if (0 == groupBracket) {\n                        throw new InvalidPathException(\"Unexpected close bracket ']' at character position: \" + path.position());\n                    }\n                    groupBracket--;\n                    break;\n\n                // In either the close paren case where we have zero paren groups left, capture the parameter, or where\n                // we've encountered a COMMA do the same\n                case CLOSE_PARENTHESIS:\n                    groupParen--;\n                    //CS304 Issue link: https://github.com/json-path/JsonPath/issues/620\n                    if (0 > groupParen || priorChar == '(') {\n                        parameter.append(c);\n                    }\n                case COMMA:\n                    // In this state we've reach the end of a function parameter and we can pass along the parameter string\n                    // to the parser\n                    if ((0 == groupQuote && 0 == groupBrace && 0 == groupBracket\n                            && ((0 == groupParen && CLOSE_PARENTHESIS == c) || 1 == groupParen))) {\n                        endOfStream = (0 == groupParen);\n\n                        if (null != type) {\n                            Parameter param = null;\n                            switch (type) {\n                                case JSON:\n                                    // parse the json and set the value\n                                    param = new Parameter(parameter.toString());\n                                    break;\n                                case PATH:\n                                    LinkedList<Predicate> predicates = new LinkedList<>();\n                                    PathCompiler compiler = new PathCompiler(parameter.toString(), predicates);\n                                    param = new Parameter(compiler.compile());\n                                    break;\n                            }\n                            if (null != param) {\n                                parameters.add(param);\n                            }\n                            parameter.delete(0, parameter.length());\n                            type = null;\n                        }\n                    }\n                    break;\n            }\n\n            if (type != null && !(c == COMMA && 0 == groupBrace && 0 == groupBracket && 1 == groupParen)) {\n                parameter.append(c);\n            }\n            priorChar = c;\n        }\n        if (0 != groupBrace || 0 != groupParen || 0 != groupBracket) {\n            throw new InvalidPathException(\"Arguments to function: '\" + funcName + \"' are not closed properly.\");\n        }\n        return parameters;\n    }\n\n    private boolean isWhitespace(char c) {\n        return (c == SPACE || c == TAB || c == LF || c == CR);\n    }\n\n    //\n    // [?], [?,?, ..]\n    //\n    private boolean readPlaceholderToken(PathTokenAppender appender) {\n\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        int questionmarkIndex = path.indexOfNextSignificantChar(BEGIN_FILTER);\n        if (questionmarkIndex == -1) {\n            return false;\n        }\n        char nextSignificantChar = path.nextSignificantChar(questionmarkIndex);\n        if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n            return false;\n        }\n\n        int expressionBeginIndex = path.position() + 1;\n        int expressionEndIndex = path.nextIndexOf(expressionBeginIndex, CLOSE_SQUARE_BRACKET);\n\n        if (expressionEndIndex == -1) {\n            return false;\n        }\n\n        String expression = path.subSequence(expressionBeginIndex, expressionEndIndex).toString();\n\n        String[] tokens = expression.split(\",\");\n\n        if (filterStack.size() < tokens.length) {\n            throw new InvalidPathException(\"Not enough predicates supplied for filter [\" + expression + \"] at position \" + path.position());\n        }\n\n        Collection<Predicate> predicates = new ArrayList<Predicate>();\n        for (String token : tokens) {\n            token = token != null ? token.trim() : null;\n            if (!\"?\".equals(token == null ? \"\" : token)) {\n                throw new InvalidPathException(\"Expected '?' but found \" + token);\n            }\n            predicates.add(filterStack.pop());\n        }\n\n        appender.appendPathToken(PathTokenFactory.createPredicatePathToken(predicates));\n\n        path.setPosition(expressionEndIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    //\n    // [?(...)]\n    //\n    private boolean readFilterToken(PathTokenAppender appender) {\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET) && !path.nextSignificantCharIs(BEGIN_FILTER)) {\n            return false;\n        }\n\n        int openStatementBracketIndex = path.position();\n        int questionMarkIndex = path.indexOfNextSignificantChar(BEGIN_FILTER);\n        if (questionMarkIndex == -1) {\n            return false;\n        }\n        int openBracketIndex = path.indexOfNextSignificantChar(questionMarkIndex, OPEN_PARENTHESIS);\n        if (openBracketIndex == -1) {\n            return false;\n        }\n        int closeBracketIndex = path.indexOfClosingBracket(openBracketIndex, true, true);\n        if (closeBracketIndex == -1) {\n            return false;\n        }\n        if (!path.nextSignificantCharIs(closeBracketIndex, CLOSE_SQUARE_BRACKET)) {\n            return false;\n        }\n        int closeStatementBracketIndex = path.indexOfNextSignificantChar(closeBracketIndex, CLOSE_SQUARE_BRACKET);\n\n        String criteria = path.subSequence(openStatementBracketIndex, closeStatementBracketIndex + 1).toString();\n\n\n        Predicate predicate = FilterCompiler.compile(criteria);\n        appender.appendPathToken(PathTokenFactory.createPredicatePathToken(predicate));\n\n        path.setPosition(closeStatementBracketIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n\n    }\n\n    //\n    // [*]\n    // *\n    //\n    private boolean readWildCardToken(PathTokenAppender appender) {\n\n        boolean inBracket = path.currentCharIs(OPEN_SQUARE_BRACKET);\n\n        if (inBracket && !path.nextSignificantCharIs(WILDCARD)) {\n            return false;\n        }\n        if (!path.currentCharIs(WILDCARD) && path.isOutOfBounds(path.position() + 1)) {\n            return false;\n        }\n        if (inBracket) {\n            int wildCardIndex = path.indexOfNextSignificantChar(WILDCARD);\n            if (!path.nextSignificantCharIs(wildCardIndex, CLOSE_SQUARE_BRACKET)) {\n                int offset = wildCardIndex + 1;\n                throw new InvalidPathException(\"Expected wildcard token to end with ']' on position \" + offset);\n            }\n            int bracketCloseIndex = path.indexOfNextSignificantChar(wildCardIndex, CLOSE_SQUARE_BRACKET);\n            path.setPosition(bracketCloseIndex + 1);\n        } else {\n            path.incrementPosition(1);\n        }\n\n        appender.appendPathToken(PathTokenFactory.createWildCardPathToken());\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    //\n    // [1], [1,2, n], [1:], [1:2], [:2]\n    //\n    private boolean readArrayToken(PathTokenAppender appender) {\n\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char nextSignificantChar = path.nextSignificantChar();\n        if (!isDigit(nextSignificantChar) && nextSignificantChar != MINUS && nextSignificantChar != SPLIT) {\n            return false;\n        }\n\n        int expressionBeginIndex = path.position() + 1;\n        int expressionEndIndex = path.nextIndexOf(expressionBeginIndex, CLOSE_SQUARE_BRACKET);\n\n        if (expressionEndIndex == -1) {\n            return false;\n        }\n\n        String expression = path.subSequence(expressionBeginIndex, expressionEndIndex).toString().trim();\n\n        if (\"*\".equals(expression)) {\n            return false;\n        }\n\n        //check valid chars\n        for (int i = 0; i < expression.length(); i++) {\n            char c = expression.charAt(i);\n            if (!isDigit(c) && c != COMMA && c != MINUS && c != SPLIT && c != SPACE) {\n                return false;\n            }\n        }\n\n        boolean isSliceOperation = expression.contains(\":\");\n\n        if (isSliceOperation) {\n            ArraySliceOperation arraySliceOperation = ArraySliceOperation.parse(expression);\n            appender.appendPathToken(PathTokenFactory.createSliceArrayPathToken(arraySliceOperation));\n        } else {\n            ArrayIndexOperation arrayIndexOperation = ArrayIndexOperation.parse(expression);\n            appender.appendPathToken(PathTokenFactory.createIndexArrayPathToken(arrayIndexOperation));\n        }\n\n        path.setPosition(expressionEndIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    //\n    // ['foo']\n    //\n    private boolean readBracketPropertyToken(PathTokenAppender appender) {\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET) + 1;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }\n\n    public static boolean fail(String message) {\n        throw new InvalidPathException(message);\n    }\n}\n", "patch": "@@ -625,7 +625,11 @@ private boolean readBracketPropertyToken(PathTokenAppender appender) {\n             fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n         }\n \n-        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET) + 1;\n+        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n+        if(endBracketIndex == -1) {\n+            fail(\"Property has not been closed - missing closing ]\");\n+        }\n+        endBracketIndex++;\n \n         path.setPosition(endBracketIndex);\n "}
