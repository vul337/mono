[
  {
    "cve_id": "CVE-2023-51074",
    "cwe_ids": [
      "CWE-Other"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cvss_is_v3": true,
    "description": "json-path v2.8.0 was discovered to contain a stack overflow due to Infinite recursive call",
    "commit_msg": "Check for the existence of the next significant bracket",
    "commit_hash": "f49ff25e3bad8c8a0c853058181f2c00b5beb305",
    "git_url": "https://github.com/json-path/JsonPath/commit/f49ff25e3bad8c8a0c853058181f2c00b5beb305",
    "raw_repo": "old_repos/json-path-JsonPath_f49ff25",
    "before_cpg_file": "Joern_files/cpgs/cpg.bin",
    "before_cpg_file_cache": [
      "json-path-assert/src/main/java/com/jayway/jsonassert/JsonAssert.java",
      "json-path-assert/src/main/java/com/jayway/jsonassert/JsonAsserter.java",
      "json-path-assert/src/main/java/com/jayway/jsonassert/impl/JsonAsserterImpl.java",
      "json-path-assert/src/main/java/com/jayway/jsonassert/impl/matcher/CollectionMatcher.java",
      "json-path-assert/src/main/java/com/jayway/jsonassert/impl/matcher/IsCollectionWithSize.java",
      "json-path-assert/src/main/java/com/jayway/jsonassert/impl/matcher/IsEmptyCollection.java",
      "json-path-assert/src/main/java/com/jayway/jsonassert/impl/matcher/IsMapContainingKey.java",
      "json-path-assert/src/main/java/com/jayway/jsonassert/impl/matcher/IsMapContainingValue.java",
      "json-path-assert/src/main/java/com/jayway/jsonassert/impl/matcher/MapTypeSafeMatcher.java",
      "json-path-assert/src/main/java/com/jayway/jsonpath/matchers/IsJson.java",
      "json-path-assert/src/main/java/com/jayway/jsonpath/matchers/JsonPathMatchers.java",
      "json-path-assert/src/main/java/com/jayway/jsonpath/matchers/WithJsonPath.java",
      "json-path-assert/src/main/java/com/jayway/jsonpath/matchers/WithoutJsonPath.java",
      "json-path-web-test/src/main/java/com/jayway/jsonpath/web/bench/Bench.java",
      "json-path-web-test/src/main/java/com/jayway/jsonpath/web/bench/Result.java",
      "json-path-web-test/src/main/java/com/jayway/jsonpath/web/boot/Main.java",
      "json-path-web-test/src/main/java/com/jayway/jsonpath/web/resource/ApiResource.java",
      "json-path/src/main/java/com/jayway/jsonpath/Configuration.java",
      "json-path/src/main/java/com/jayway/jsonpath/Criteria.java",
      "json-path/src/main/java/com/jayway/jsonpath/DocumentContext.java",
      "json-path/src/main/java/com/jayway/jsonpath/EvaluationListener.java",
      "json-path/src/main/java/com/jayway/jsonpath/Filter.java",
      "json-path/src/main/java/com/jayway/jsonpath/InvalidCriteriaException.java",
      "json-path/src/main/java/com/jayway/jsonpath/InvalidJsonException.java",
      "json-path/src/main/java/com/jayway/jsonpath/InvalidModificationException.java",
      "json-path/src/main/java/com/jayway/jsonpath/InvalidPathException.java",
      "json-path/src/main/java/com/jayway/jsonpath/JsonPath.java",
      "json-path/src/main/java/com/jayway/jsonpath/JsonPathException.java",
      "json-path/src/main/java/com/jayway/jsonpath/MapFunction.java",
      "json-path/src/main/java/com/jayway/jsonpath/Option.java",
      "json-path/src/main/java/com/jayway/jsonpath/ParseContext.java",
      "json-path/src/main/java/com/jayway/jsonpath/PathNotFoundException.java",
      "json-path/src/main/java/com/jayway/jsonpath/Predicate.java",
      "json-path/src/main/java/com/jayway/jsonpath/ReadContext.java",
      "json-path/src/main/java/com/jayway/jsonpath/TypeRef.java",
      "json-path/src/main/java/com/jayway/jsonpath/ValueCompareException.java",
      "json-path/src/main/java/com/jayway/jsonpath/WriteContext.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/DefaultsImpl.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/EvaluationAbortException.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/EvaluationContext.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/JsonContext.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/JsonFormatter.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/ParseContextImpl.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/Path.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/PathRef.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/Evaluator.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/EvaluatorFactory.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/ExpressionNode.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/FilterCompiler.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/LogicalExpressionNode.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/LogicalOperator.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/PatternFlag.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/RelationalExpressionNode.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/RelationalOperator.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/ValueNode.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/filter/ValueNodes.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/ParamType.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/Parameter.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/PassthruPathFunction.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/PathFunction.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/PathFunctionFactory.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/json/Append.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/json/KeySetFunction.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/latebinding/ILateBindingValue.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/latebinding/JsonLateBindingValue.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/latebinding/PathLateBindingValue.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/numeric/AbstractAggregation.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/numeric/Average.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/numeric/Max.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/numeric/Min.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/numeric/StandardDeviation.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/numeric/Sum.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/sequence/AbstractSequenceAggregation.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/sequence/First.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/sequence/Index.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/sequence/Last.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/text/Concatenate.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/function/text/Length.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/ArrayIndexOperation.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/ArrayIndexToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/ArrayPathToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/ArraySliceOperation.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/ArraySliceToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/CompiledPath.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/EvaluationContextImpl.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/FunctionPathToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenAppender.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/PredicateContextImpl.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/PredicatePathToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/PropertyPathToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/RootPathToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/ScanPathToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/internal/path/WildcardPathToken.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/cache/Cache.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/cache/CacheProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/cache/LRUCache.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/cache/NOOPCache.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/AbstractJsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/GsonJsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/JacksonJsonNodeJsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/JacksonJsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/JakartaJsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/JettisonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/JsonOrgJsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/JsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/JsonSmartJsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/json/TapestryJsonProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/mapper/GsonMappingProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/mapper/JacksonMappingProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/mapper/JakartaMappingProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/mapper/JsonOrgMappingProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/mapper/JsonSmartMappingProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/mapper/MappingException.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/mapper/MappingProvider.java",
      "json-path/src/main/java/com/jayway/jsonpath/spi/mapper/TapestryMappingProvider.java",
      "<unknown>"
    ],
    "before_context": {
      "calleeMethods": [
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "currentIsTail",
          "com.jayway.jsonpath.internal.CharacterIndex.currentIsTail:boolean()",
          "    public boolean currentIsTail() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.currentIsTail:boolean() */ \n        return position >= endPosition;\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "incrementPosition",
          "com.jayway.jsonpath.internal.CharacterIndex.incrementPosition:int(int)",
          "    public int incrementPosition(int charCount) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.incrementPosition:int(int) */ \n        return setPosition(position + charCount);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
          "createPropertyPathToken",
          "com.jayway.jsonpath.internal.path.PathTokenFactory.createPropertyPathToken:com.jayway.jsonpath.internal.path.PathToken(java.util.List,char)",
          "    public static PathToken createPropertyPathToken(List<String> properties, char stringDelimiter) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createPropertyPathToken:com.jayway.jsonpath.internal.path.PathToken(java.util.List,char) */ \n        return new PropertyPathToken(properties, stringDelimiter);\n    }",
          3
        ],
        [
          "<empty>",
          "<operator>.assignment",
          "<operator>.assignment",
          "",
          1
        ],
        [
          "<empty>",
          "<operator>.logicalNot",
          "<operator>.logicalNot",
          "",
          1
        ],
        [
          "<empty>",
          "<operator>.fieldAccess",
          "<operator>.fieldAccess",
          "",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "nextIndexOf",
          "com.jayway.jsonpath.internal.CharacterIndex.nextIndexOf:int(int,char)",
          "    public int nextIndexOf(int startPosition, char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextIndexOf:int(int,char) */ \n        int readPosition = startPosition;\n        while (!isOutOfBounds(readPosition)) {\n            if (charAt(readPosition) == c) {\n                return readPosition;\n            }\n            readPosition++;\n        }\n        return -1;\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "indexOfNextSignificantChar",
          "com.jayway.jsonpath.internal.CharacterIndex.indexOfNextSignificantChar:int(int,char)",
          "    public int indexOfNextSignificantChar(int startPosition, char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.indexOfNextSignificantChar:int(int,char) */ \n        int readPosition = startPosition + 1;\n        while (!isOutOfBounds(readPosition) && charAt(readPosition) == SPACE) {\n            readPosition++;\n        }\n        if (charAt(readPosition) == c) {\n            return readPosition;\n        } else {\n            return -1;\n        }\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "currentChar",
          "com.jayway.jsonpath.internal.CharacterIndex.currentChar:char()",
          "    public char currentChar() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.currentChar:char() */ \n        return charSequence.charAt(position);\n    }",
          2
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/JsonPathException.java",
          "<init>",
          "com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.String)",
          "    public JsonPathException(String message) { /* <=== com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.String) */ \n        super(message);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "nextSignificantChar",
          "com.jayway.jsonpath.internal.CharacterIndex.nextSignificantChar:char()",
          "    public char nextSignificantChar() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextSignificantChar:char() */ \n        return nextSignificantChar(position);\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "isOutOfBounds",
          "com.jayway.jsonpath.internal.CharacterIndex.isOutOfBounds:boolean(int)",
          "    public boolean isOutOfBounds(int idx) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.isOutOfBounds:boolean(int) */ \n        return !inBounds(idx);\n    }",
          2
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
          "createPredicatePathToken",
          "com.jayway.jsonpath.internal.path.PathTokenFactory.createPredicatePathToken:com.jayway.jsonpath.internal.path.PathToken(java.util.Collection)",
          "    public static PathToken createPredicatePathToken(Collection<Predicate> predicates) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createPredicatePathToken:com.jayway.jsonpath.internal.path.PathToken(java.util.Collection) */ \n        return new PredicatePathToken(predicates);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "parseFunctionParameters",
          "com.jayway.jsonpath.internal.path.PathCompiler.parseFunctionParameters:java.util.List(java.lang.String)",
          "    private List<Parameter> parseFunctionParameters(String funcName) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.parseFunctionParameters:java.util.List(java.lang.String) */ \n        ParamType type = null;\n\n        // Parenthesis starts at 1 since we're marking the start of a function call, the close paren will denote the\n        // last parameter boundary\n        int groupParen = 1, groupBracket = 0, groupBrace = 0, groupQuote = 0;\n        boolean endOfStream = false;\n        char priorChar = 0;\n        List<Parameter> parameters = new ArrayList<Parameter>();\n        StringBuilder parameter = new StringBuilder();\n        while (path.inBounds() && !endOfStream) {\n            char c = path.currentChar();\n            path.incrementPosition(1);\n\n            // we're at the start of the stream, and don't know what type of parameter we have\n            if (type == null) {\n                if (isWhitespace(c)) {\n                    continue;\n                }\n\n                if (c == OPEN_BRACE || isDigit(c) || DOUBLE_QUOTE == c || MINUS == c) {\n                    type = ParamType.JSON;\n                }\n                else if (isPathContext(c)) {\n                    type = ParamType.PATH; // read until we reach a terminating comma and we've reset grouping to zero\n                }\n            }\n\n            switch (c) {\n                case DOUBLE_QUOTE:\n                    if (priorChar != '\\\\' && groupQuote > 0) {\n                        groupQuote--;\n                    }\n                    else {\n                        groupQuote++;\n                    }\n                    break;\n                case OPEN_PARENTHESIS:\n                    groupParen++;\n                    break;\n                case OPEN_BRACE:\n                    groupBrace++;\n                    break;\n                case OPEN_SQUARE_BRACKET:\n                    groupBracket++;\n                    break;\n\n                case CLOSE_BRACE:\n                    if (0 == groupBrace) {\n                        throw new InvalidPathException(\"Unexpected close brace '}' at character position: \" + path.position());\n                    }\n                    groupBrace--;\n                    break;\n                case CLOSE_SQUARE_BRACKET:\n                    if (0 == groupBracket) {\n                        throw new InvalidPathException(\"Unexpected close bracket ']' at character position: \" + path.position());\n                    }\n                    groupBracket--;\n                    break;\n\n                // In either the close paren case where we have zero paren groups left, capture the parameter, or where\n                // we've encountered a COMMA do the same\n                case CLOSE_PARENTHESIS:\n                    groupParen--;\n                    //CS304 Issue link: https://github.com/json-path/JsonPath/issues/620\n                    if (0 > groupParen || priorChar == '(') {\n                        parameter.append(c);\n                    }\n                case COMMA:\n                    // In this state we've reach the end of a function parameter and we can pass along the parameter string\n                    // to the parser\n                    if ((0 == groupQuote && 0 == groupBrace && 0 == groupBracket\n                            && ((0 == groupParen && CLOSE_PARENTHESIS == c) || 1 == groupParen))) {\n                        endOfStream = (0 == groupParen);\n\n                        if (null != type) {\n                            Parameter param = null;\n                            switch (type) {\n                                case JSON:\n                                    // parse the json and set the value\n                                    param = new Parameter(parameter.toString());\n                                    break;\n                                case PATH:\n                                    LinkedList<Predicate> predicates = new LinkedList<>();\n                                    PathCompiler compiler = new PathCompiler(parameter.toString(), predicates);\n                                    param = new Parameter(compiler.compile());\n                                    break;\n                            }\n                            if (null != param) {\n                                parameters.add(param);\n                            }\n                            parameter.delete(0, parameter.length());\n                            type = null;\n                        }\n                    }\n                    break;\n            }\n\n            if (type != null && !(c == COMMA && 0 == groupBrace && 0 == groupBracket && 1 == groupParen)) {\n                parameter.append(c);\n            }\n            priorChar = c;\n        }\n        if (0 != groupBrace || 0 != groupParen || 0 != groupBracket) {\n            throw new InvalidPathException(\"Arguments to function: '\" + funcName + \"' are not closed properly.\");\n        }\n        return parameters;\n    }",
          3
        ],
        [
          "<empty>",
          "<operator>.postIncrement",
          "<operator>.postIncrement",
          "",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "hasMoreCharacters",
          "com.jayway.jsonpath.internal.CharacterIndex.hasMoreCharacters:boolean()",
          "    public boolean hasMoreCharacters() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.hasMoreCharacters:boolean() */ \n        return inBounds(position + 1);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readFilterToken",
          "com.jayway.jsonpath.internal.path.PathCompiler.readFilterToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)",
          "    private boolean readFilterToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readFilterToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET) && !path.nextSignificantCharIs(BEGIN_FILTER)) {\n            return false;\n        }\n\n        int openStatementBracketIndex = path.position();\n        int questionMarkIndex = path.indexOfNextSignificantChar(BEGIN_FILTER);\n        if (questionMarkIndex == -1) {\n            return false;\n        }\n        int openBracketIndex = path.indexOfNextSignificantChar(questionMarkIndex, OPEN_PARENTHESIS);\n        if (openBracketIndex == -1) {\n            return false;\n        }\n        int closeBracketIndex = path.indexOfClosingBracket(openBracketIndex, true, true);\n        if (closeBracketIndex == -1) {\n            return false;\n        }\n        if (!path.nextSignificantCharIs(closeBracketIndex, CLOSE_SQUARE_BRACKET)) {\n            return false;\n        }\n        int closeStatementBracketIndex = path.indexOfNextSignificantChar(closeBracketIndex, CLOSE_SQUARE_BRACKET);\n\n        String criteria = path.subSequence(openStatementBracketIndex, closeStatementBracketIndex + 1).toString();\n\n\n        Predicate predicate = FilterCompiler.compile(criteria);\n        appender.appendPathToken(PathTokenFactory.createPredicatePathToken(predicate));\n\n        path.setPosition(closeStatementBracketIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n\n    }",
          2
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
          "createFunctionPathToken",
          "com.jayway.jsonpath.internal.path.PathTokenFactory.createFunctionPathToken:com.jayway.jsonpath.internal.path.PathToken(java.lang.String,java.util.List)",
          "    public static PathToken createFunctionPathToken(String function, List<Parameter> parameters) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createFunctionPathToken:com.jayway.jsonpath.internal.path.PathToken(java.lang.String,java.util.List) */ \n        return new FunctionPathToken(function, parameters);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/ArrayIndexOperation.java",
          "parse",
          "com.jayway.jsonpath.internal.path.ArrayIndexOperation.parse:com.jayway.jsonpath.internal.path.ArrayIndexOperation(java.lang.String)",
          "    public static ArrayIndexOperation parse(String operation) { /* <=== com.jayway.jsonpath.internal.path.ArrayIndexOperation.parse:com.jayway.jsonpath.internal.path.ArrayIndexOperation(java.lang.String) */ \n        //check valid chars\n        for (int i = 0; i < operation.length(); i++) {\n            char c = operation.charAt(i);\n            if (!isDigit(c) && c != ',' && c != ' ' && c != '-') {\n                throw new InvalidPathException(\"Failed to parse ArrayIndexOperation: \" + operation);\n            }\n        }\n        String[] tokens = COMMA.split(operation, -1);\n\n        List<Integer> tempIndexes = new ArrayList<Integer>(tokens.length);\n        for (String token : tokens) {\n            tempIndexes.add(parseInteger(token));\n        }\n\n        return new ArrayIndexOperation(tempIndexes);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java",
          "unescape",
          "com.jayway.jsonpath.internal.Utils.unescape:java.lang.String(java.lang.String)",
          "    public static String unescape(String str) { /* <=== com.jayway.jsonpath.internal.Utils.unescape:java.lang.String(java.lang.String) */ \n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        StringWriter writer = new StringWriter(len);\n        StringBuilder unicode = new StringBuilder(4);\n        boolean hadSlash = false;\n        boolean inUnicode = false;\n        for (int i = 0; i < len; i++) {\n            char ch = str.charAt(i);\n            if (inUnicode) {\n                unicode.append(ch);\n                if (unicode.length() == 4) {\n                    try {\n                        int value = Integer.parseInt(unicode.toString(), 16);\n                        writer.write((char) value);\n                        unicode.setLength(0);\n                        inUnicode = false;\n                        hadSlash = false;\n                    } catch (NumberFormatException nfe) {\n                        throw new JsonPathException(\"Unable to parse unicode value: \" + unicode, nfe);\n                    }\n                }\n                continue;\n            }\n            if (hadSlash) {\n                hadSlash = false;\n                switch (ch) {\n                    case '\\\\':\n                        writer.write('\\\\');\n                        break;\n                    case '\\'':\n                        writer.write('\\'');\n                        break;\n                    case '\\\"':\n                        writer.write('\"');\n                        break;\n                    case 'r':\n                        writer.write('\\r');\n                        break;\n                    case 'f':\n                        writer.write('\\f');\n                        break;\n                    case 't':\n                        writer.write('\\t');\n                        break;\n                    case 'n':\n                        writer.write('\\n');\n                        break;\n                    case 'b':\n                        writer.write('\\b');\n                        break;\n                    case 'u':\n                    {\n                        inUnicode = true;\n                        break;\n                    }\n                    default :\n                        writer.write(ch);\n                        break;\n                }\n                continue;\n            } else if (ch == '\\\\') {\n                hadSlash = true;\n                continue;\n            }\n            writer.write(ch);\n        }\n        if (hadSlash) {\n            writer.write('\\\\');\n        }\n        return writer.toString();\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "indexOfClosingBracket",
          "com.jayway.jsonpath.internal.CharacterIndex.indexOfClosingBracket:int(int,boolean,boolean)",
          "    public int indexOfClosingBracket(int startPosition, boolean skipStrings, boolean skipRegex) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.indexOfClosingBracket:int(int,boolean,boolean) */ \n        return indexOfMatchingCloseChar(startPosition, OPEN_PARENTHESIS, CLOSE_PARENTHESIS, skipStrings, skipRegex);\n    }",
          3
        ],
        [
          "<empty>",
          "<operator>.equals",
          "<operator>.equals",
          "",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "subSequence",
          "com.jayway.jsonpath.internal.CharacterIndex.subSequence:java.lang.CharSequence(int,int)",
          "    public CharSequence subSequence(int start, int end) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.subSequence:java.lang.CharSequence(int,int) */ \n        return charSequence.subSequence(start, end);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readBracketPropertyToken",
          "com.jayway.jsonpath.internal.path.PathCompiler.readBracketPropertyToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)",
          "    private boolean readBracketPropertyToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readBracketPropertyToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n        if(endBracketIndex == -1) {\n            fail(\"Property has not been closed - missing closing ]\");\n        }\n        endBracketIndex++;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
          2
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "setPosition",
          "com.jayway.jsonpath.internal.CharacterIndex.setPosition:int(int)",
          "    public int setPosition(int newPosition) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.setPosition:int(int) */ \n        //position = min(newPosition, charSequence.length() - 1);\n        position = newPosition;\n        return position;\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/RootPathToken.java",
          "appendPathToken",
          "com.jayway.jsonpath.internal.path.RootPathToken.getPathTokenAppender.PathTokenAppender$0.appendPathToken:com.jayway.jsonpath.internal.path.PathTokenAppender(com.jayway.jsonpath.internal.path.PathToken)",
          "            @Override /* <=== com.jayway.jsonpath.internal.path.RootPathToken.getPathTokenAppender.PathTokenAppender$0.appendPathToken:com.jayway.jsonpath.internal.path.PathTokenAppender(com.jayway.jsonpath.internal.path.PathToken) */ \n            public PathTokenAppender appendPathToken(PathToken next) {\n                append(next);\n                return this;\n            }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readDotToken",
          "com.jayway.jsonpath.internal.path.PathCompiler.readDotToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)",
          "    private boolean readDotToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readDotToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (path.currentCharIs(PERIOD) && path.nextCharIs(PERIOD)) {\n            appender.appendPathToken(PathTokenFactory.crateScanToken());\n            path.incrementPosition(2);\n        } else if (!path.hasMoreCharacters()) {\n            throw new InvalidPathException(\"Path must not end with a '.\");\n        } else {\n            path.incrementPosition(1);\n        }\n        if(path.currentCharIs(PERIOD)){\n            throw new InvalidPathException(\"Character '.' on position \" + path.position() + \" is not valid.\");\n        }\n        return readNextToken(appender);\n    }",
          2
        ],
        [
          "<empty>",
          "<operator>.addition",
          "<operator>.addition",
          "",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/ArraySliceOperation.java",
          "parse",
          "com.jayway.jsonpath.internal.path.ArraySliceOperation.parse:com.jayway.jsonpath.internal.path.ArraySliceOperation(java.lang.String)",
          "    public static ArraySliceOperation parse(String operation){ /* <=== com.jayway.jsonpath.internal.path.ArraySliceOperation.parse:com.jayway.jsonpath.internal.path.ArraySliceOperation(java.lang.String) */ \n        //check valid chars\n        for (int i = 0; i < operation.length(); i++) {\n            char c = operation.charAt(i);\n            if( !isDigit(c)  && c != '-' && c != ':'){\n                throw new InvalidPathException(\"Failed to parse SliceOperation: \" + operation);\n            }\n        }\n        String[] tokens = operation.split(\":\");\n\n        Integer tempFrom = tryRead(tokens, 0);\n        Integer tempTo = tryRead(tokens, 1);\n        Operation tempOperation;\n\n        if (tempFrom != null && tempTo == null) {\n            tempOperation = Operation.SLICE_FROM;\n        } else if (tempFrom != null) {\n            tempOperation = Operation.SLICE_BETWEEN;\n        } else if (tempTo != null) {\n            tempOperation = Operation.SLICE_TO;\n        } else {\n            throw new InvalidPathException(\"Failed to parse SliceOperation: \" + operation);\n        }\n\n        return new ArraySliceOperation(tempFrom, tempTo, tempOperation);\n    }",
          3
        ],
        [
          "<empty>",
          "<operator>.notEquals",
          "<operator>.notEquals",
          "",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "charAt",
          "com.jayway.jsonpath.internal.CharacterIndex.charAt:char(int)",
          "    public char charAt(int idx) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.charAt:char(int) */ \n        return charSequence.charAt(idx);\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "length",
          "com.jayway.jsonpath.internal.CharacterIndex.length:int()",
          "    public int length() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.length:int() */ \n        return endPosition + 1;\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
          "createIndexArrayPathToken",
          "com.jayway.jsonpath.internal.path.PathTokenFactory.createIndexArrayPathToken:com.jayway.jsonpath.internal.path.PathToken(com.jayway.jsonpath.internal.path.ArrayIndexOperation)",
          "    public static PathToken createIndexArrayPathToken(final ArrayIndexOperation arrayIndexOperation) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createIndexArrayPathToken:com.jayway.jsonpath.internal.path.PathToken(com.jayway.jsonpath.internal.path.ArrayIndexOperation) */ \n        return new ArrayIndexToken(arrayIndexOperation);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/JsonPathException.java",
          "<init>",
          "com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.Throwable)",
          "    public JsonPathException(Throwable cause) { /* <=== com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.Throwable) */ \n        super(cause);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
          "createSliceArrayPathToken",
          "com.jayway.jsonpath.internal.path.PathTokenFactory.createSliceArrayPathToken:com.jayway.jsonpath.internal.path.PathToken(com.jayway.jsonpath.internal.path.ArraySliceOperation)",
          "    public static PathToken createSliceArrayPathToken(final ArraySliceOperation arraySliceOperation) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createSliceArrayPathToken:com.jayway.jsonpath.internal.path.PathToken(com.jayway.jsonpath.internal.path.ArraySliceOperation) */ \n        return new ArraySliceToken(arraySliceOperation);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readPropertyOrFunctionToken",
          "com.jayway.jsonpath.internal.path.PathCompiler.readPropertyOrFunctionToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)",
          "    private boolean readPropertyOrFunctionToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readPropertyOrFunctionToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (path.currentCharIs(OPEN_SQUARE_BRACKET) || path.currentCharIs(WILDCARD) || path.currentCharIs(PERIOD) || path.currentCharIs(SPACE)) {\n            return false;\n        }\n        int startPosition = path.position();\n        int readPosition = startPosition;\n        int endPosition = 0;\n\n        boolean isFunction = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n            if (c == SPACE) {\n                throw new InvalidPathException(\"Use bracket notion ['my prop'] if your property contains blank characters. position: \" + path.position());\n            }\n            else if (c == PERIOD || c == OPEN_SQUARE_BRACKET) {\n                endPosition = readPosition;\n                break;\n            }\n            else if (c == OPEN_PARENTHESIS) {\n                isFunction = true;\n                endPosition = readPosition;\n                break;\n            }\n            readPosition++;\n        }\n        if (endPosition == 0) {\n            endPosition = path.length();\n        }\n\n\n        List<Parameter> functionParameters = null;\n        if (isFunction) {\n            int parenthesis_count = 1;\n            for(int i = readPosition + 1; i < path.length(); i++){\n                if (path.charAt(i) == CLOSE_PARENTHESIS)\n                    parenthesis_count--;\n                else if (path.charAt(i) == OPEN_PARENTHESIS)\n                    parenthesis_count++;\n                if (parenthesis_count == 0)\n                    break;\n            }\n\n            if (parenthesis_count != 0){\n                String functionName = path.subSequence(startPosition, endPosition).toString();\n                throw new InvalidPathException(\"Arguments to function: '\" + functionName + \"' are not closed properly.\");\n            }\n\n            if (path.inBounds(readPosition+1)) {\n                // read the next token to determine if we have a simple no-args function call\n                char c = path.charAt(readPosition + 1);\n                if (c != CLOSE_PARENTHESIS) {\n                    path.setPosition(endPosition+1);\n                    // parse the arguments of the function - arguments that are inner queries or JSON document(s)\n                    String functionName = path.subSequence(startPosition, endPosition).toString();\n                    functionParameters = parseFunctionParameters(functionName);\n                } else {\n                    path.setPosition(readPosition + 1);\n                }\n            }\n            else {\n                path.setPosition(readPosition);\n            }\n        }\n        else {\n            path.setPosition(endPosition);\n        }\n\n        String property = path.subSequence(startPosition, endPosition).toString();\n        if(isFunction){\n            appender.appendPathToken(PathTokenFactory.createFunctionPathToken(property, functionParameters));\n        } else {\n            appender.appendPathToken(PathTokenFactory.createSinglePropertyPathToken(property, SINGLE_QUOTE));\n        }\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
          2
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "nextSignificantCharIs",
          "com.jayway.jsonpath.internal.CharacterIndex.nextSignificantCharIs:boolean(int,char)",
          "    public boolean nextSignificantCharIs(int startPosition, char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextSignificantCharIs:boolean(int,char) */ \n        int readPosition = startPosition + 1;\n        while (!isOutOfBounds(readPosition) && charAt(readPosition) == SPACE) {\n            readPosition++;\n        }\n        return !isOutOfBounds(readPosition) && charAt(readPosition) == c;\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readNextToken",
          "com.jayway.jsonpath.internal.path.PathCompiler.readNextToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)",
          "    private boolean readNextToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readNextToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n\n        char c = path.currentChar();\n\n        switch (c) {\n            case OPEN_SQUARE_BRACKET:\n                if (!readBracketPropertyToken(appender) && !readArrayToken(appender) && !readWildCardToken(appender)\n                    && !readFilterToken(appender) && !readPlaceholderToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position() + \". Expected ?, ', 0-9, * \");\n                }\n                return true;\n            case PERIOD:\n                if (!readDotToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n            case WILDCARD:\n                if (!readWildCardToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n            default:\n                if (!readPropertyOrFunctionToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n        }\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "nextCharIs",
          "com.jayway.jsonpath.internal.CharacterIndex.nextCharIs:boolean(char)",
          "    public boolean nextCharIs(char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextCharIs:boolean(char) */ \n        return inBounds(position + 1) && (charSequence.charAt(position + 1) == c);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "position",
          "com.jayway.jsonpath.internal.CharacterIndex.position:int()",
          "    public int position(){ /* <=== com.jayway.jsonpath.internal.CharacterIndex.position:int() */ \n        return position;\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/InvalidPathException.java",
          "<init>",
          "com.jayway.jsonpath.InvalidPathException.<init>:void(java.lang.String)",
          "    public InvalidPathException(String message) { /* <=== com.jayway.jsonpath.InvalidPathException.<init>:void(java.lang.String) */ \n        super(message);\n    }",
          2
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "nextSignificantCharIs",
          "com.jayway.jsonpath.internal.CharacterIndex.nextSignificantCharIs:boolean(char)",
          "    public boolean nextSignificantCharIs(char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextSignificantCharIs:boolean(char) */ \n        return nextSignificantCharIs(position, c);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "nextSignificantChar",
          "com.jayway.jsonpath.internal.CharacterIndex.nextSignificantChar:char(int)",
          "    public char nextSignificantChar(int startPosition) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextSignificantChar:char(int) */ \n        int readPosition = startPosition + 1;\n        while (!isOutOfBounds(readPosition) && charAt(readPosition) == SPACE) {\n            readPosition++;\n        }\n        if (!isOutOfBounds(readPosition)) {\n            return charAt(readPosition);\n        } else {\n            return ' ';\n        }\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readPlaceholderToken",
          "com.jayway.jsonpath.internal.path.PathCompiler.readPlaceholderToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)",
          "    private boolean readPlaceholderToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readPlaceholderToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        int questionmarkIndex = path.indexOfNextSignificantChar(BEGIN_FILTER);\n        if (questionmarkIndex == -1) {\n            return false;\n        }\n        char nextSignificantChar = path.nextSignificantChar(questionmarkIndex);\n        if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n            return false;\n        }\n\n        int expressionBeginIndex = path.position() + 1;\n        int expressionEndIndex = path.nextIndexOf(expressionBeginIndex, CLOSE_SQUARE_BRACKET);\n\n        if (expressionEndIndex == -1) {\n            return false;\n        }\n\n        String expression = path.subSequence(expressionBeginIndex, expressionEndIndex).toString();\n\n        String[] tokens = expression.split(\",\");\n\n        if (filterStack.size() < tokens.length) {\n            throw new InvalidPathException(\"Not enough predicates supplied for filter [\" + expression + \"] at position \" + path.position());\n        }\n\n        Collection<Predicate> predicates = new ArrayList<Predicate>();\n        for (String token : tokens) {\n            token = token != null ? token.trim() : null;\n            if (!\"?\".equals(token == null ? \"\" : token)) {\n                throw new InvalidPathException(\"Expected '?' but found \" + token);\n            }\n            predicates.add(filterStack.pop());\n        }\n\n        appender.appendPathToken(PathTokenFactory.createPredicatePathToken(predicates));\n\n        path.setPosition(expressionEndIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
          2
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readArrayToken",
          "com.jayway.jsonpath.internal.path.PathCompiler.readArrayToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)",
          "    private boolean readArrayToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readArrayToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char nextSignificantChar = path.nextSignificantChar();\n        if (!isDigit(nextSignificantChar) && nextSignificantChar != MINUS && nextSignificantChar != SPLIT) {\n            return false;\n        }\n\n        int expressionBeginIndex = path.position() + 1;\n        int expressionEndIndex = path.nextIndexOf(expressionBeginIndex, CLOSE_SQUARE_BRACKET);\n\n        if (expressionEndIndex == -1) {\n            return false;\n        }\n\n        String expression = path.subSequence(expressionBeginIndex, expressionEndIndex).toString().trim();\n\n        if (\"*\".equals(expression)) {\n            return false;\n        }\n\n        //check valid chars\n        for (int i = 0; i < expression.length(); i++) {\n            char c = expression.charAt(i);\n            if (!isDigit(c) && c != COMMA && c != MINUS && c != SPLIT && c != SPACE) {\n                return false;\n            }\n        }\n\n        boolean isSliceOperation = expression.contains(\":\");\n\n        if (isSliceOperation) {\n            ArraySliceOperation arraySliceOperation = ArraySliceOperation.parse(expression);\n            appender.appendPathToken(PathTokenFactory.createSliceArrayPathToken(arraySliceOperation));\n        } else {\n            ArrayIndexOperation arrayIndexOperation = ArrayIndexOperation.parse(expression);\n            appender.appendPathToken(PathTokenFactory.createIndexArrayPathToken(arrayIndexOperation));\n        }\n\n        path.setPosition(expressionEndIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
          2
        ],
        [
          "<empty>",
          "<operator>.logicalAnd",
          "<operator>.logicalAnd",
          "",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/JsonPathException.java",
          "<init>",
          "com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.String,java.lang.Throwable)",
          "    public JsonPathException(String message, Throwable cause) { /* <=== com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.String,java.lang.Throwable) */ \n        super(message, cause);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
          "crateScanToken",
          "com.jayway.jsonpath.internal.path.PathTokenFactory.crateScanToken:com.jayway.jsonpath.internal.path.PathToken()",
          "    public static PathToken crateScanToken() { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.crateScanToken:com.jayway.jsonpath.internal.path.PathToken() */ \n        return new ScanPathToken();\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenAppender.java",
          "appendPathToken",
          "com.jayway.jsonpath.internal.path.PathTokenAppender.appendPathToken:com.jayway.jsonpath.internal.path.PathTokenAppender(com.jayway.jsonpath.internal.path.PathToken)",
          "    PathTokenAppender appendPathToken(PathToken next); /* <=== com.jayway.jsonpath.internal.path.PathTokenAppender.appendPathToken:com.jayway.jsonpath.internal.path.PathTokenAppender(com.jayway.jsonpath.internal.path.PathToken) */ ",
          3
        ],
        [
          "<empty>",
          "<operator>.minus",
          "<operator>.minus",
          "",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/filter/FilterCompiler.java",
          "compile",
          "com.jayway.jsonpath.internal.filter.FilterCompiler.compile:com.jayway.jsonpath.Filter(java.lang.String)",
          "    public static Filter compile(String filterString) { /* <=== com.jayway.jsonpath.internal.filter.FilterCompiler.compile:com.jayway.jsonpath.Filter(java.lang.String) */ \n        FilterCompiler compiler = new FilterCompiler(filterString);\n        return new CompiledFilter(compiler.compile());\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readWildCardToken",
          "com.jayway.jsonpath.internal.path.PathCompiler.readWildCardToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)",
          "    private boolean readWildCardToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readWildCardToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n\n        boolean inBracket = path.currentCharIs(OPEN_SQUARE_BRACKET);\n\n        if (inBracket && !path.nextSignificantCharIs(WILDCARD)) {\n            return false;\n        }\n        if (!path.currentCharIs(WILDCARD) && path.isOutOfBounds(path.position() + 1)) {\n            return false;\n        }\n        if (inBracket) {\n            int wildCardIndex = path.indexOfNextSignificantChar(WILDCARD);\n            if (!path.nextSignificantCharIs(wildCardIndex, CLOSE_SQUARE_BRACKET)) {\n                int offset = wildCardIndex + 1;\n                throw new InvalidPathException(\"Expected wildcard token to end with ']' on position \" + offset);\n            }\n            int bracketCloseIndex = path.indexOfNextSignificantChar(wildCardIndex, CLOSE_SQUARE_BRACKET);\n            path.setPosition(bracketCloseIndex + 1);\n        } else {\n            path.incrementPosition(1);\n        }\n\n        appender.appendPathToken(PathTokenFactory.createWildCardPathToken());\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
          2
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "currentCharIs",
          "com.jayway.jsonpath.internal.CharacterIndex.currentCharIs:boolean(char)",
          "    public boolean currentCharIs(char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.currentCharIs:boolean(char) */ \n        return (charSequence.charAt(position) == c);\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java",
          "inBounds",
          "com.jayway.jsonpath.internal.CharacterIndex.inBounds:boolean(int)",
          "    public boolean inBounds(int idx) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.inBounds:boolean(int) */ \n        return (idx >= 0) && (idx <= endPosition);\n    }",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
          "createWildCardPathToken",
          "com.jayway.jsonpath.internal.path.PathTokenFactory.createWildCardPathToken:com.jayway.jsonpath.internal.path.PathToken()",
          "    public static PathToken createWildCardPathToken() { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createWildCardPathToken:com.jayway.jsonpath.internal.path.PathToken() */ \n        return new WildcardPathToken();\n    }",
          3
        ],
        [
          "<empty>",
          "<operator>.logicalOr",
          "<operator>.logicalOr",
          "",
          1
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java",
          "createSinglePropertyPathToken",
          "com.jayway.jsonpath.internal.path.PathTokenFactory.createSinglePropertyPathToken:com.jayway.jsonpath.internal.path.PathToken(java.lang.String,char)",
          "    public static PathToken createSinglePropertyPathToken(String property, char stringDelimiter) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createSinglePropertyPathToken:com.jayway.jsonpath.internal.path.PathToken(java.lang.String,char) */ \n        return new PropertyPathToken(singletonList(property), stringDelimiter);\n    }",
          3
        ],
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "fail",
          "com.jayway.jsonpath.internal.path.PathCompiler.fail:boolean(java.lang.String)",
          "    public static boolean fail(String message) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.fail:boolean(java.lang.String) */ \n        throw new InvalidPathException(message);\n    }",
          1
        ]
      ],
      "typeDefs": [
        [
          "public class PathCompiler",
          "PathCompiler"
        ],
        [
          "public class CharacterIndex",
          "CharacterIndex"
        ],
        [
          "public interface PathTokenAppender",
          "PathTokenAppender"
        ]
      ],
      "globalVars": [],
      "importContext": [],
      "vulnerableMethods": [
        [
          "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
          "readBracketPropertyToken",
          "    private boolean readBracketPropertyToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readBracketPropertyToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n        if(endBracketIndex == -1) {\n            fail(\"Property has not been closed - missing closing ]\");\n        }\n        endBracketIndex++;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
          570
        ]
      ],
      "visitedLines": {
        "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java": [
          570,
          571,
          574,
          575,
          581,
          582,
          583,
          584,
          588,
          589,
          591,
          593,
          595,
          600,
          601,
          602,
          603,
          604,
          606,
          607,
          609,
          611,
          612,
          615,
          616,
          617,
          621,
          628,
          629,
          630,
          632,
          634,
          638
        ]
      },
      "visitedParams": {
        "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java": [
          "this"
        ]
      }
    }
  },
  {
    "id": 0,
    "func_name": "readBracketPropertyToken",
    "file_path": "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
    "patch": "--- func_before\n+++ func_after\n@@ -626,7 +626,11 @@\n             fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n         }\n \n-        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET) + 1;\n+        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n+        if(endBracketIndex == -1) {\n+            fail(\"Property has not been closed - missing closing ]\");\n+        }\n+        endBracketIndex++;\n \n         path.setPosition(endBracketIndex);\n ",
    "diff_line_info": {
      "deleted_lines": [
        "        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET) + 1;"
      ],
      "added_lines": [
        "        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);",
        "        if(endBracketIndex == -1) {",
        "            fail(\"Property has not been closed - missing closing ]\");",
        "        }",
        "        endBracketIndex++;"
      ]
    },
    "func_before": "private boolean readBracketPropertyToken(PathTokenAppender appender) {\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET) + 1;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
    "func_after": "private boolean readBracketPropertyToken(PathTokenAppender appender) {\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n        if(endBracketIndex == -1) {\n            fail(\"Property has not been closed - missing closing ]\");\n        }\n        endBracketIndex++;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
    "Bug Filter": "Security Vulnerability Fix",
    "Bug Filter Confidence": 0.95,
    "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95",
    "start_line": 570
  }
]