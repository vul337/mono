{
  "calleeMethods": [["<empty>", "<operator>.equals", "<operator>.equals", "", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "charAt", "com.jayway.jsonpath.internal.CharacterIndex.charAt:char(int)", "    public char charAt(int idx) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.charAt:char(int) */ \n        return charSequence.charAt(idx);\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "nextCharIs", "com.jayway.jsonpath.internal.CharacterIndex.nextCharIs:boolean(char)", "    public boolean nextCharIs(char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextCharIs:boolean(char) */ \n        return inBounds(position + 1) && (charSequence.charAt(position + 1) == c);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/JsonPathException.java", "<init>", "com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.String,java.lang.Throwable)", "    public JsonPathException(String message, Throwable cause) { /* <=== com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.String,java.lang.Throwable) */ \n        super(message, cause);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "indexOfClosingBracket", "com.jayway.jsonpath.internal.CharacterIndex.indexOfClosingBracket:int(int,boolean,boolean)", "    public int indexOfClosingBracket(int startPosition, boolean skipStrings, boolean skipRegex) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.indexOfClosingBracket:int(int,boolean,boolean) */ \n        return indexOfMatchingCloseChar(startPosition, OPEN_PARENTHESIS, CLOSE_PARENTHESIS, skipStrings, skipRegex);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java", "createFunctionPathToken", "com.jayway.jsonpath.internal.path.PathTokenFactory.createFunctionPathToken:com.jayway.jsonpath.internal.path.PathToken(java.lang.String,java.util.List)", "    public static PathToken createFunctionPathToken(String function, List<Parameter> parameters) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createFunctionPathToken:com.jayway.jsonpath.internal.path.PathToken(java.lang.String,java.util.List) */ \n        return new FunctionPathToken(function, parameters);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "currentIsTail", "com.jayway.jsonpath.internal.CharacterIndex.currentIsTail:boolean()", "    public boolean currentIsTail() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.currentIsTail:boolean() */ \n        return position >= endPosition;\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "parseFunctionParameters", "com.jayway.jsonpath.internal.path.PathCompiler.parseFunctionParameters:java.util.List(java.lang.String)", "    private List<Parameter> parseFunctionParameters(String funcName) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.parseFunctionParameters:java.util.List(java.lang.String) */ \n        ParamType type = null;\n\n        // Parenthesis starts at 1 since we're marking the start of a function call, the close paren will denote the\n        // last parameter boundary\n        int groupParen = 1, groupBracket = 0, groupBrace = 0, groupQuote = 0;\n        boolean endOfStream = false;\n        char priorChar = 0;\n        List<Parameter> parameters = new ArrayList<Parameter>();\n        StringBuilder parameter = new StringBuilder();\n        while (path.inBounds() && !endOfStream) {\n            char c = path.currentChar();\n            path.incrementPosition(1);\n\n            // we're at the start of the stream, and don't know what type of parameter we have\n            if (type == null) {\n                if (isWhitespace(c)) {\n                    continue;\n                }\n\n                if (c == OPEN_BRACE || isDigit(c) || DOUBLE_QUOTE == c || MINUS == c) {\n                    type = ParamType.JSON;\n                }\n                else if (isPathContext(c)) {\n                    type = ParamType.PATH; // read until we reach a terminating comma and we've reset grouping to zero\n                }\n            }\n\n            switch (c) {\n                case DOUBLE_QUOTE:\n                    if (priorChar != '\\\\' && groupQuote > 0) {\n                        groupQuote--;\n                    }\n                    else {\n                        groupQuote++;\n                    }\n                    break;\n                case OPEN_PARENTHESIS:\n                    groupParen++;\n                    break;\n                case OPEN_BRACE:\n                    groupBrace++;\n                    break;\n                case OPEN_SQUARE_BRACKET:\n                    groupBracket++;\n                    break;\n\n                case CLOSE_BRACE:\n                    if (0 == groupBrace) {\n                        throw new InvalidPathException(\"Unexpected close brace '}' at character position: \" + path.position());\n                    }\n                    groupBrace--;\n                    break;\n                case CLOSE_SQUARE_BRACKET:\n                    if (0 == groupBracket) {\n                        throw new InvalidPathException(\"Unexpected close bracket ']' at character position: \" + path.position());\n                    }\n                    groupBracket--;\n                    break;\n\n                // In either the close paren case where we have zero paren groups left, capture the parameter, or where\n                // we've encountered a COMMA do the same\n                case CLOSE_PARENTHESIS:\n                    groupParen--;\n                    //CS304 Issue link: https://github.com/json-path/JsonPath/issues/620\n                    if (0 > groupParen || priorChar == '(') {\n                        parameter.append(c);\n                    }\n                case COMMA:\n                    // In this state we've reach the end of a function parameter and we can pass along the parameter string\n                    // to the parser\n                    if ((0 == groupQuote && 0 == groupBrace && 0 == groupBracket\n                            && ((0 == groupParen && CLOSE_PARENTHESIS == c) || 1 == groupParen))) {\n                        endOfStream = (0 == groupParen);\n\n                        if (null != type) {\n                            Parameter param = null;\n                            switch (type) {\n                                case JSON:\n                                    // parse the json and set the value\n                                    param = new Parameter(parameter.toString());\n                                    break;\n                                case PATH:\n                                    LinkedList<Predicate> predicates = new LinkedList<>();\n                                    PathCompiler compiler = new PathCompiler(parameter.toString(), predicates);\n                                    param = new Parameter(compiler.compile());\n                                    break;\n                            }\n                            if (null != param) {\n                                parameters.add(param);\n                            }\n                            parameter.delete(0, parameter.length());\n                            type = null;\n                        }\n                    }\n                    break;\n            }\n\n            if (type != null && !(c == COMMA && 0 == groupBrace && 0 == groupBracket && 1 == groupParen)) {\n                parameter.append(c);\n            }\n            priorChar = c;\n        }\n        if (0 != groupBrace || 0 != groupParen || 0 != groupBracket) {\n            throw new InvalidPathException(\"Arguments to function: '\" + funcName + \"' are not closed properly.\");\n        }\n        return parameters;\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readDotToken", "com.jayway.jsonpath.internal.path.PathCompiler.readDotToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)", "    private boolean readDotToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readDotToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (path.currentCharIs(PERIOD) && path.nextCharIs(PERIOD)) {\n            appender.appendPathToken(PathTokenFactory.crateScanToken());\n            path.incrementPosition(2);\n        } else if (!path.hasMoreCharacters()) {\n            throw new InvalidPathException(\"Path must not end with a '.\");\n        } else {\n            path.incrementPosition(1);\n        }\n        if(path.currentCharIs(PERIOD)){\n            throw new InvalidPathException(\"Character '.' on position \" + path.position() + \" is not valid.\");\n        }\n        return readNextToken(appender);\n    }", 2], ["<empty>", "<operator>.fieldAccess", "<operator>.fieldAccess", "", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java", "createPropertyPathToken", "com.jayway.jsonpath.internal.path.PathTokenFactory.createPropertyPathToken:com.jayway.jsonpath.internal.path.PathToken(java.util.List,char)", "    public static PathToken createPropertyPathToken(List<String> properties, char stringDelimiter) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createPropertyPathToken:com.jayway.jsonpath.internal.path.PathToken(java.util.List,char) */ \n        return new PropertyPathToken(properties, stringDelimiter);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readNextToken", "com.jayway.jsonpath.internal.path.PathCompiler.readNextToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)", "    private boolean readNextToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readNextToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n\n        char c = path.currentChar();\n\n        switch (c) {\n            case OPEN_SQUARE_BRACKET:\n                if (!readBracketPropertyToken(appender) && !readArrayToken(appender) && !readWildCardToken(appender)\n                    && !readFilterToken(appender) && !readPlaceholderToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position() + \". Expected ?, ', 0-9, * \");\n                }\n                return true;\n            case PERIOD:\n                if (!readDotToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n            case WILDCARD:\n                if (!readWildCardToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n            default:\n                if (!readPropertyOrFunctionToken(appender)) {\n                    fail(\"Could not parse token starting at position \" + path.position());\n                }\n                return true;\n        }\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "subSequence", "com.jayway.jsonpath.internal.CharacterIndex.subSequence:java.lang.CharSequence(int,int)", "    public CharSequence subSequence(int start, int end) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.subSequence:java.lang.CharSequence(int,int) */ \n        return charSequence.subSequence(start, end);\n    }", 3], ["<empty>", "<operator>.notEquals", "<operator>.notEquals", "", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "nextSignificantChar", "com.jayway.jsonpath.internal.CharacterIndex.nextSignificantChar:char()", "    public char nextSignificantChar() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextSignificantChar:char() */ \n        return nextSignificantChar(position);\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readArrayToken", "com.jayway.jsonpath.internal.path.PathCompiler.readArrayToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)", "    private boolean readArrayToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readArrayToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char nextSignificantChar = path.nextSignificantChar();\n        if (!isDigit(nextSignificantChar) && nextSignificantChar != MINUS && nextSignificantChar != SPLIT) {\n            return false;\n        }\n\n        int expressionBeginIndex = path.position() + 1;\n        int expressionEndIndex = path.nextIndexOf(expressionBeginIndex, CLOSE_SQUARE_BRACKET);\n\n        if (expressionEndIndex == -1) {\n            return false;\n        }\n\n        String expression = path.subSequence(expressionBeginIndex, expressionEndIndex).toString().trim();\n\n        if (\"*\".equals(expression)) {\n            return false;\n        }\n\n        //check valid chars\n        for (int i = 0; i < expression.length(); i++) {\n            char c = expression.charAt(i);\n            if (!isDigit(c) && c != COMMA && c != MINUS && c != SPLIT && c != SPACE) {\n                return false;\n            }\n        }\n\n        boolean isSliceOperation = expression.contains(\":\");\n\n        if (isSliceOperation) {\n            ArraySliceOperation arraySliceOperation = ArraySliceOperation.parse(expression);\n            appender.appendPathToken(PathTokenFactory.createSliceArrayPathToken(arraySliceOperation));\n        } else {\n            ArrayIndexOperation arrayIndexOperation = ArrayIndexOperation.parse(expression);\n            appender.appendPathToken(PathTokenFactory.createIndexArrayPathToken(arrayIndexOperation));\n        }\n\n        path.setPosition(expressionEndIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n    }", 2], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readPlaceholderToken", "com.jayway.jsonpath.internal.path.PathCompiler.readPlaceholderToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)", "    private boolean readPlaceholderToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readPlaceholderToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        int questionmarkIndex = path.indexOfNextSignificantChar(BEGIN_FILTER);\n        if (questionmarkIndex == -1) {\n            return false;\n        }\n        char nextSignificantChar = path.nextSignificantChar(questionmarkIndex);\n        if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n            return false;\n        }\n\n        int expressionBeginIndex = path.position() + 1;\n        int expressionEndIndex = path.nextIndexOf(expressionBeginIndex, CLOSE_SQUARE_BRACKET);\n\n        if (expressionEndIndex == -1) {\n            return false;\n        }\n\n        String expression = path.subSequence(expressionBeginIndex, expressionEndIndex).toString();\n\n        String[] tokens = expression.split(\",\");\n\n        if (filterStack.size() < tokens.length) {\n            throw new InvalidPathException(\"Not enough predicates supplied for filter [\" + expression + \"] at position \" + path.position());\n        }\n\n        Collection<Predicate> predicates = new ArrayList<Predicate>();\n        for (String token : tokens) {\n            token = token != null ? token.trim() : null;\n            if (!\"?\".equals(token == null ? \"\" : token)) {\n                throw new InvalidPathException(\"Expected '?' but found \" + token);\n            }\n            predicates.add(filterStack.pop());\n        }\n\n        appender.appendPathToken(PathTokenFactory.createPredicatePathToken(predicates));\n\n        path.setPosition(expressionEndIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n    }", 2], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readBracketPropertyToken", "com.jayway.jsonpath.internal.path.PathCompiler.readBracketPropertyToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)", "    private boolean readBracketPropertyToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readBracketPropertyToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n        if(endBracketIndex == -1) {\n            fail(\"Property has not been closed - missing closing ]\");\n        }\n        endBracketIndex++;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }", 2], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readPropertyOrFunctionToken", "com.jayway.jsonpath.internal.path.PathCompiler.readPropertyOrFunctionToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)", "    private boolean readPropertyOrFunctionToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readPropertyOrFunctionToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (path.currentCharIs(OPEN_SQUARE_BRACKET) || path.currentCharIs(WILDCARD) || path.currentCharIs(PERIOD) || path.currentCharIs(SPACE)) {\n            return false;\n        }\n        int startPosition = path.position();\n        int readPosition = startPosition;\n        int endPosition = 0;\n\n        boolean isFunction = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n            if (c == SPACE) {\n                throw new InvalidPathException(\"Use bracket notion ['my prop'] if your property contains blank characters. position: \" + path.position());\n            }\n            else if (c == PERIOD || c == OPEN_SQUARE_BRACKET) {\n                endPosition = readPosition;\n                break;\n            }\n            else if (c == OPEN_PARENTHESIS) {\n                isFunction = true;\n                endPosition = readPosition;\n                break;\n            }\n            readPosition++;\n        }\n        if (endPosition == 0) {\n            endPosition = path.length();\n        }\n\n\n        List<Parameter> functionParameters = null;\n        if (isFunction) {\n            int parenthesis_count = 1;\n            for(int i = readPosition + 1; i < path.length(); i++){\n                if (path.charAt(i) == CLOSE_PARENTHESIS)\n                    parenthesis_count--;\n                else if (path.charAt(i) == OPEN_PARENTHESIS)\n                    parenthesis_count++;\n                if (parenthesis_count == 0)\n                    break;\n            }\n\n            if (parenthesis_count != 0){\n                String functionName = path.subSequence(startPosition, endPosition).toString();\n                throw new InvalidPathException(\"Arguments to function: '\" + functionName + \"' are not closed properly.\");\n            }\n\n            if (path.inBounds(readPosition+1)) {\n                // read the next token to determine if we have a simple no-args function call\n                char c = path.charAt(readPosition + 1);\n                if (c != CLOSE_PARENTHESIS) {\n                    path.setPosition(endPosition+1);\n                    // parse the arguments of the function - arguments that are inner queries or JSON document(s)\n                    String functionName = path.subSequence(startPosition, endPosition).toString();\n                    functionParameters = parseFunctionParameters(functionName);\n                } else {\n                    path.setPosition(readPosition + 1);\n                }\n            }\n            else {\n                path.setPosition(readPosition);\n            }\n        }\n        else {\n            path.setPosition(endPosition);\n        }\n\n        String property = path.subSequence(startPosition, endPosition).toString();\n        if(isFunction){\n            appender.appendPathToken(PathTokenFactory.createFunctionPathToken(property, functionParameters));\n        } else {\n            appender.appendPathToken(PathTokenFactory.createSinglePropertyPathToken(property, SINGLE_QUOTE));\n        }\n\n        return path.currentIsTail() || readNextToken(appender);\n    }", 2], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "currentChar", "com.jayway.jsonpath.internal.CharacterIndex.currentChar:char()", "    public char currentChar() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.currentChar:char() */ \n        return charSequence.charAt(position);\n    }", 2], ["<empty>", "<operator>.logicalNot", "<operator>.logicalNot", "", 1], ["<empty>", "<operator>.logicalAnd", "<operator>.logicalAnd", "", 1], ["<empty>", "<operator>.postIncrement", "<operator>.postIncrement", "", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/Utils.java", "unescape", "com.jayway.jsonpath.internal.Utils.unescape:java.lang.String(java.lang.String)", "    public static String unescape(String str) { /* <=== com.jayway.jsonpath.internal.Utils.unescape:java.lang.String(java.lang.String) */ \n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        StringWriter writer = new StringWriter(len);\n        StringBuilder unicode = new StringBuilder(4);\n        boolean hadSlash = false;\n        boolean inUnicode = false;\n        for (int i = 0; i < len; i++) {\n            char ch = str.charAt(i);\n            if (inUnicode) {\n                unicode.append(ch);\n                if (unicode.length() == 4) {\n                    try {\n                        int value = Integer.parseInt(unicode.toString(), 16);\n                        writer.write((char) value);\n                        unicode.setLength(0);\n                        inUnicode = false;\n                        hadSlash = false;\n                    } catch (NumberFormatException nfe) {\n                        throw new JsonPathException(\"Unable to parse unicode value: \" + unicode, nfe);\n                    }\n                }\n                continue;\n            }\n            if (hadSlash) {\n                hadSlash = false;\n                switch (ch) {\n                    case '\\\\':\n                        writer.write('\\\\');\n                        break;\n                    case '\\'':\n                        writer.write('\\'');\n                        break;\n                    case '\\\"':\n                        writer.write('\"');\n                        break;\n                    case 'r':\n                        writer.write('\\r');\n                        break;\n                    case 'f':\n                        writer.write('\\f');\n                        break;\n                    case 't':\n                        writer.write('\\t');\n                        break;\n                    case 'n':\n                        writer.write('\\n');\n                        break;\n                    case 'b':\n                        writer.write('\\b');\n                        break;\n                    case 'u':\n                    {\n                        inUnicode = true;\n                        break;\n                    }\n                    default :\n                        writer.write(ch);\n                        break;\n                }\n                continue;\n            } else if (ch == '\\\\') {\n                hadSlash = true;\n                continue;\n            }\n            writer.write(ch);\n        }\n        if (hadSlash) {\n            writer.write('\\\\');\n        }\n        return writer.toString();\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "position", "com.jayway.jsonpath.internal.CharacterIndex.position:int()", "    public int position(){ /* <=== com.jayway.jsonpath.internal.CharacterIndex.position:int() */ \n        return position;\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "currentCharIs", "com.jayway.jsonpath.internal.CharacterIndex.currentCharIs:boolean(char)", "    public boolean currentCharIs(char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.currentCharIs:boolean(char) */ \n        return (charSequence.charAt(position) == c);\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/ArraySliceOperation.java", "parse", "com.jayway.jsonpath.internal.path.ArraySliceOperation.parse:com.jayway.jsonpath.internal.path.ArraySliceOperation(java.lang.String)", "    public static ArraySliceOperation parse(String operation){ /* <=== com.jayway.jsonpath.internal.path.ArraySliceOperation.parse:com.jayway.jsonpath.internal.path.ArraySliceOperation(java.lang.String) */ \n        //check valid chars\n        for (int i = 0; i < operation.length(); i++) {\n            char c = operation.charAt(i);\n            if( !isDigit(c)  && c != '-' && c != ':'){\n                throw new InvalidPathException(\"Failed to parse SliceOperation: \" + operation);\n            }\n        }\n        String[] tokens = operation.split(\":\");\n\n        Integer tempFrom = tryRead(tokens, 0);\n        Integer tempTo = tryRead(tokens, 1);\n        Operation tempOperation;\n\n        if (tempFrom != null && tempTo == null) {\n            tempOperation = Operation.SLICE_FROM;\n        } else if (tempFrom != null) {\n            tempOperation = Operation.SLICE_BETWEEN;\n        } else if (tempTo != null) {\n            tempOperation = Operation.SLICE_TO;\n        } else {\n            throw new InvalidPathException(\"Failed to parse SliceOperation: \" + operation);\n        }\n\n        return new ArraySliceOperation(tempFrom, tempTo, tempOperation);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/InvalidPathException.java", "<init>", "com.jayway.jsonpath.InvalidPathException.<init>:void(java.lang.String)", "    public InvalidPathException(String message) { /* <=== com.jayway.jsonpath.InvalidPathException.<init>:void(java.lang.String) */ \n        super(message);\n    }", 2], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/ArrayIndexOperation.java", "parse", "com.jayway.jsonpath.internal.path.ArrayIndexOperation.parse:com.jayway.jsonpath.internal.path.ArrayIndexOperation(java.lang.String)", "    public static ArrayIndexOperation parse(String operation) { /* <=== com.jayway.jsonpath.internal.path.ArrayIndexOperation.parse:com.jayway.jsonpath.internal.path.ArrayIndexOperation(java.lang.String) */ \n        //check valid chars\n        for (int i = 0; i < operation.length(); i++) {\n            char c = operation.charAt(i);\n            if (!isDigit(c) && c != ',' && c != ' ' && c != '-') {\n                throw new InvalidPathException(\"Failed to parse ArrayIndexOperation: \" + operation);\n            }\n        }\n        String[] tokens = COMMA.split(operation, -1);\n\n        List<Integer> tempIndexes = new ArrayList<Integer>(tokens.length);\n        for (String token : tokens) {\n            tempIndexes.add(parseInteger(token));\n        }\n\n        return new ArrayIndexOperation(tempIndexes);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenAppender.java", "appendPathToken", "com.jayway.jsonpath.internal.path.PathTokenAppender.appendPathToken:com.jayway.jsonpath.internal.path.PathTokenAppender(com.jayway.jsonpath.internal.path.PathToken)", "    PathTokenAppender appendPathToken(PathToken next); /* <=== com.jayway.jsonpath.internal.path.PathTokenAppender.appendPathToken:com.jayway.jsonpath.internal.path.PathTokenAppender(com.jayway.jsonpath.internal.path.PathToken) */ ", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "nextSignificantCharIs", "com.jayway.jsonpath.internal.CharacterIndex.nextSignificantCharIs:boolean(char)", "    public boolean nextSignificantCharIs(char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextSignificantCharIs:boolean(char) */ \n        return nextSignificantCharIs(position, c);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java", "createSinglePropertyPathToken", "com.jayway.jsonpath.internal.path.PathTokenFactory.createSinglePropertyPathToken:com.jayway.jsonpath.internal.path.PathToken(java.lang.String,char)", "    public static PathToken createSinglePropertyPathToken(String property, char stringDelimiter) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createSinglePropertyPathToken:com.jayway.jsonpath.internal.path.PathToken(java.lang.String,char) */ \n        return new PropertyPathToken(singletonList(property), stringDelimiter);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/JsonPathException.java", "<init>", "com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.Throwable)", "    public JsonPathException(Throwable cause) { /* <=== com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.Throwable) */ \n        super(cause);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "hasMoreCharacters", "com.jayway.jsonpath.internal.CharacterIndex.hasMoreCharacters:boolean()", "    public boolean hasMoreCharacters() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.hasMoreCharacters:boolean() */ \n        return inBounds(position + 1);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "indexOfNextSignificantChar", "com.jayway.jsonpath.internal.CharacterIndex.indexOfNextSignificantChar:int(int,char)", "    public int indexOfNextSignificantChar(int startPosition, char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.indexOfNextSignificantChar:int(int,char) */ \n        int readPosition = startPosition + 1;\n        while (!isOutOfBounds(readPosition) && charAt(readPosition) == SPACE) {\n            readPosition++;\n        }\n        if (charAt(readPosition) == c) {\n            return readPosition;\n        } else {\n            return -1;\n        }\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readFilterToken", "com.jayway.jsonpath.internal.path.PathCompiler.readFilterToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)", "    private boolean readFilterToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readFilterToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET) && !path.nextSignificantCharIs(BEGIN_FILTER)) {\n            return false;\n        }\n\n        int openStatementBracketIndex = path.position();\n        int questionMarkIndex = path.indexOfNextSignificantChar(BEGIN_FILTER);\n        if (questionMarkIndex == -1) {\n            return false;\n        }\n        int openBracketIndex = path.indexOfNextSignificantChar(questionMarkIndex, OPEN_PARENTHESIS);\n        if (openBracketIndex == -1) {\n            return false;\n        }\n        int closeBracketIndex = path.indexOfClosingBracket(openBracketIndex, true, true);\n        if (closeBracketIndex == -1) {\n            return false;\n        }\n        if (!path.nextSignificantCharIs(closeBracketIndex, CLOSE_SQUARE_BRACKET)) {\n            return false;\n        }\n        int closeStatementBracketIndex = path.indexOfNextSignificantChar(closeBracketIndex, CLOSE_SQUARE_BRACKET);\n\n        String criteria = path.subSequence(openStatementBracketIndex, closeStatementBracketIndex + 1).toString();\n\n\n        Predicate predicate = FilterCompiler.compile(criteria);\n        appender.appendPathToken(PathTokenFactory.createPredicatePathToken(predicate));\n\n        path.setPosition(closeStatementBracketIndex + 1);\n\n        return path.currentIsTail() || readNextToken(appender);\n\n    }", 2], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "nextSignificantCharIs", "com.jayway.jsonpath.internal.CharacterIndex.nextSignificantCharIs:boolean(int,char)", "    public boolean nextSignificantCharIs(int startPosition, char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextSignificantCharIs:boolean(int,char) */ \n        int readPosition = startPosition + 1;\n        while (!isOutOfBounds(readPosition) && charAt(readPosition) == SPACE) {\n            readPosition++;\n        }\n        return !isOutOfBounds(readPosition) && charAt(readPosition) == c;\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/filter/FilterCompiler.java", "compile", "com.jayway.jsonpath.internal.filter.FilterCompiler.compile:com.jayway.jsonpath.Filter(java.lang.String)", "    public static Filter compile(String filterString) { /* <=== com.jayway.jsonpath.internal.filter.FilterCompiler.compile:com.jayway.jsonpath.Filter(java.lang.String) */ \n        FilterCompiler compiler = new FilterCompiler(filterString);\n        return new CompiledFilter(compiler.compile());\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java", "createPredicatePathToken", "com.jayway.jsonpath.internal.path.PathTokenFactory.createPredicatePathToken:com.jayway.jsonpath.internal.path.PathToken(java.util.Collection)", "    public static PathToken createPredicatePathToken(Collection<Predicate> predicates) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createPredicatePathToken:com.jayway.jsonpath.internal.path.PathToken(java.util.Collection) */ \n        return new PredicatePathToken(predicates);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "nextSignificantChar", "com.jayway.jsonpath.internal.CharacterIndex.nextSignificantChar:char(int)", "    public char nextSignificantChar(int startPosition) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextSignificantChar:char(int) */ \n        int readPosition = startPosition + 1;\n        while (!isOutOfBounds(readPosition) && charAt(readPosition) == SPACE) {\n            readPosition++;\n        }\n        if (!isOutOfBounds(readPosition)) {\n            return charAt(readPosition);\n        } else {\n            return ' ';\n        }\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readWildCardToken", "com.jayway.jsonpath.internal.path.PathCompiler.readWildCardToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender)", "    private boolean readWildCardToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readWildCardToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n\n        boolean inBracket = path.currentCharIs(OPEN_SQUARE_BRACKET);\n\n        if (inBracket && !path.nextSignificantCharIs(WILDCARD)) {\n            return false;\n        }\n        if (!path.currentCharIs(WILDCARD) && path.isOutOfBounds(path.position() + 1)) {\n            return false;\n        }\n        if (inBracket) {\n            int wildCardIndex = path.indexOfNextSignificantChar(WILDCARD);\n            if (!path.nextSignificantCharIs(wildCardIndex, CLOSE_SQUARE_BRACKET)) {\n                int offset = wildCardIndex + 1;\n                throw new InvalidPathException(\"Expected wildcard token to end with ']' on position \" + offset);\n            }\n            int bracketCloseIndex = path.indexOfNextSignificantChar(wildCardIndex, CLOSE_SQUARE_BRACKET);\n            path.setPosition(bracketCloseIndex + 1);\n        } else {\n            path.incrementPosition(1);\n        }\n\n        appender.appendPathToken(PathTokenFactory.createWildCardPathToken());\n\n        return path.currentIsTail() || readNextToken(appender);\n    }", 2], ["<empty>", "<operator>.addition", "<operator>.addition", "", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java", "createIndexArrayPathToken", "com.jayway.jsonpath.internal.path.PathTokenFactory.createIndexArrayPathToken:com.jayway.jsonpath.internal.path.PathToken(com.jayway.jsonpath.internal.path.ArrayIndexOperation)", "    public static PathToken createIndexArrayPathToken(final ArrayIndexOperation arrayIndexOperation) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createIndexArrayPathToken:com.jayway.jsonpath.internal.path.PathToken(com.jayway.jsonpath.internal.path.ArrayIndexOperation) */ \n        return new ArrayIndexToken(arrayIndexOperation);\n    }", 3], ["<empty>", "<operator>.logicalOr", "<operator>.logicalOr", "", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/RootPathToken.java", "appendPathToken", "com.jayway.jsonpath.internal.path.RootPathToken.getPathTokenAppender.PathTokenAppender$0.appendPathToken:com.jayway.jsonpath.internal.path.PathTokenAppender(com.jayway.jsonpath.internal.path.PathToken)", "            @Override /* <=== com.jayway.jsonpath.internal.path.RootPathToken.getPathTokenAppender.PathTokenAppender$0.appendPathToken:com.jayway.jsonpath.internal.path.PathTokenAppender(com.jayway.jsonpath.internal.path.PathToken) */ \n            public PathTokenAppender appendPathToken(PathToken next) {\n                append(next);\n                return this;\n            }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "setPosition", "com.jayway.jsonpath.internal.CharacterIndex.setPosition:int(int)", "    public int setPosition(int newPosition) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.setPosition:int(int) */ \n        //position = min(newPosition, charSequence.length() - 1);\n        position = newPosition;\n        return position;\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java", "createWildCardPathToken", "com.jayway.jsonpath.internal.path.PathTokenFactory.createWildCardPathToken:com.jayway.jsonpath.internal.path.PathToken()", "    public static PathToken createWildCardPathToken() { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createWildCardPathToken:com.jayway.jsonpath.internal.path.PathToken() */ \n        return new WildcardPathToken();\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java", "createSliceArrayPathToken", "com.jayway.jsonpath.internal.path.PathTokenFactory.createSliceArrayPathToken:com.jayway.jsonpath.internal.path.PathToken(com.jayway.jsonpath.internal.path.ArraySliceOperation)", "    public static PathToken createSliceArrayPathToken(final ArraySliceOperation arraySliceOperation) { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.createSliceArrayPathToken:com.jayway.jsonpath.internal.path.PathToken(com.jayway.jsonpath.internal.path.ArraySliceOperation) */ \n        return new ArraySliceToken(arraySliceOperation);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "length", "com.jayway.jsonpath.internal.CharacterIndex.length:int()", "    public int length() { /* <=== com.jayway.jsonpath.internal.CharacterIndex.length:int() */ \n        return endPosition + 1;\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "incrementPosition", "com.jayway.jsonpath.internal.CharacterIndex.incrementPosition:int(int)", "    public int incrementPosition(int charCount) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.incrementPosition:int(int) */ \n        return setPosition(position + charCount);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "nextIndexOf", "com.jayway.jsonpath.internal.CharacterIndex.nextIndexOf:int(int,char)", "    public int nextIndexOf(int startPosition, char c) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.nextIndexOf:int(int,char) */ \n        int readPosition = startPosition;\n        while (!isOutOfBounds(readPosition)) {\n            if (charAt(readPosition) == c) {\n                return readPosition;\n            }\n            readPosition++;\n        }\n        return -1;\n    }", 3], ["<empty>", "<operator>.assignment", "<operator>.assignment", "", 1], ["json-path/src/main/java/com/jayway/jsonpath/JsonPathException.java", "<init>", "com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.String)", "    public JsonPathException(String message) { /* <=== com.jayway.jsonpath.JsonPathException.<init>:void(java.lang.String) */ \n        super(message);\n    }", 3], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "inBounds", "com.jayway.jsonpath.internal.CharacterIndex.inBounds:boolean(int)", "    public boolean inBounds(int idx) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.inBounds:boolean(int) */ \n        return (idx >= 0) && (idx <= endPosition);\n    }", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/CharacterIndex.java", "isOutOfBounds", "com.jayway.jsonpath.internal.CharacterIndex.isOutOfBounds:boolean(int)", "    public boolean isOutOfBounds(int idx) { /* <=== com.jayway.jsonpath.internal.CharacterIndex.isOutOfBounds:boolean(int) */ \n        return !inBounds(idx);\n    }", 2], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathTokenFactory.java", "crateScanToken", "com.jayway.jsonpath.internal.path.PathTokenFactory.crateScanToken:com.jayway.jsonpath.internal.path.PathToken()", "    public static PathToken crateScanToken() { /* <=== com.jayway.jsonpath.internal.path.PathTokenFactory.crateScanToken:com.jayway.jsonpath.internal.path.PathToken() */ \n        return new ScanPathToken();\n    }", 3], ["<empty>", "<operator>.minus", "<operator>.minus", "", 1], ["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "fail", "com.jayway.jsonpath.internal.path.PathCompiler.fail:boolean(java.lang.String)", "    public static boolean fail(String message) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.fail:boolean(java.lang.String) */ \n        throw new InvalidPathException(message);\n    }", 1]],
  "globalVars": [],
  "importContext": [],
  "typeDefs": [["public interface PathTokenAppender", "PathTokenAppender"], ["public class PathCompiler", "PathCompiler"], ["public class CharacterIndex", "CharacterIndex"]],
  "visitedLines": [[638, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [593, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [571, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [574, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [581, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [606, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [611, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [615, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [607, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [612, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [621, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [589, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [617, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [584, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [583, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [575, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [609, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [628, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [588, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [602, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [616, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [629, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [595, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [604, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [634, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [570, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [582, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [591, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [603, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [630, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [601, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [600, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"], [632, "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"]],
  "visitedParams": [["this", "readBracketPropertyToken", "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java"]],
  "vulnerableMethods": [["json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java", "readBracketPropertyToken", "    private boolean readBracketPropertyToken(PathTokenAppender appender) { /* <=== com.jayway.jsonpath.internal.path.PathCompiler.readBracketPropertyToken:boolean(com.jayway.jsonpath.internal.path.PathTokenAppender) */ \n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n        if(endBracketIndex == -1) {\n            fail(\"Property has not been closed - missing closing ]\");\n        }\n        endBracketIndex++;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }", 570]]
}