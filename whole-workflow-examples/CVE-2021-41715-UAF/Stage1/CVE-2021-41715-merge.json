{
  "stats": {
    "cve_id": "CVE-2021-41715",
    "language": "c_cpp",
    "sec_vul": {
      "num": 1,
      "no_more_info": [],
      "main_dir": [
        "CVE-2021-41715_part1.json"
      ]
    },
    "non_sec_vul": {
      "num": 0,
      "types": {}
    }
  },
  "raw_data": {
    "CVE-2021-41715_part1": {
      "cve_id": "CVE-2021-41715",
      "cwe_ids": [
        "CWE-416"
      ],
      "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
      "cvss_is_v3": false,
      "repo_name": "libsixel",
      "commit_msg": "sixel_encoder_prepare_palette: kill use-after-free\n\nThe only place sixel_encoder_prepare_palette() is called\nfrom is sixel_encoder_encode_frame(). If we have a\nSIXEL_FAILED result inside the former, we unref the palette,\npotentially freeing it. We then goto the error path for\nsixel_encoder_encode_frame(), where we unref it again, in a\nclassic double-free. Remove the internal unref. As noted,\nthis is a single call site, so removing the unref can't\ncause a memory leak.\n\nCloses #27, reported by a4865g (\"WuLearn\").",
      "commit_hash": "d299d67c532a5133a57aade5c35ff8e612c73dd8",
      "git_url": "https://github.com/libsixel/libsixel/commit/d299d67c532a5133a57aade5c35ff8e612c73dd8",
      "file_path": "src/encoder.c",
      "func_name": "sixel_encoder_prepare_palette",
      "func_before": "static SIXELSTATUS\nsixel_encoder_prepare_palette(\n    sixel_encoder_t *encoder,  /* encoder object */\n    sixel_frame_t   *frame,    /* input frame object */\n    sixel_dither_t  **dither)  /* dither object to be created from the frame */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int histogram_colors;\n\n    switch (encoder->color_option) {\n    case SIXEL_COLOR_OPTION_HIGHCOLOR:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_dither_new(dither, (-1), encoder->allocator);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MONOCHROME:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_monochrome_palette(dither, encoder->finvert);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MAPFILE:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_specified_palette(dither, encoder);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_BUILTIN:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_builtin_palette(dither, encoder->builtin_palette);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_DEFAULT:\n    default:\n        break;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_PALETTE) {\n        if (!sixel_frame_get_palette(frame)) {\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        status = sixel_dither_new(dither, sixel_frame_get_ncolors(frame),\n                                  encoder->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        sixel_dither_set_palette(*dither, sixel_frame_get_palette(frame));\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        if (sixel_frame_get_transparent(frame) != (-1)) {\n            sixel_dither_set_transparent(*dither, sixel_frame_get_transparent(frame));\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        goto end;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_GRAYSCALE) {\n        switch (sixel_frame_get_pixelformat(frame)) {\n        case SIXEL_PIXELFORMAT_G1:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n            break;\n        case SIXEL_PIXELFORMAT_G2:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G2);\n            break;\n        case SIXEL_PIXELFORMAT_G4:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G4);\n            break;\n        case SIXEL_PIXELFORMAT_G8:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G8);\n            break;\n        default:\n            *dither = NULL;\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        status = SIXEL_OK;\n        goto end;\n    }\n\n    if (encoder->dither_cache) {\n        sixel_dither_unref(encoder->dither_cache);\n    }\n    status = sixel_dither_new(dither, encoder->reqcolors, encoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_dither_initialize(*dither,\n                                     sixel_frame_get_pixels(frame),\n                                     sixel_frame_get_width(frame),\n                                     sixel_frame_get_height(frame),\n                                     sixel_frame_get_pixelformat(frame),\n                                     encoder->method_for_largest,\n                                     encoder->method_for_rep,\n                                     encoder->quality_mode);\n    if (SIXEL_FAILED(status)) {\n        sixel_dither_unref(*dither);\n        goto end;\n    }\n\n    histogram_colors = sixel_dither_get_num_of_histogram_colors(*dither);\n    if (histogram_colors <= encoder->reqcolors) {\n        encoder->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n    }\n    sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}",
      "abstract_func_before": "static SIXELSTATUS\nsixel_encoder_prepare_palette(\n    sixel_encoder_t *VAR_0,  /* COMMENT_0 */\n    sixel_frame_t   *VAR_1,    /* COMMENT_1 */\n    sixel_dither_t  **VAR_2)  /* COMMENT_2 */\n{\n    SIXELSTATUS VAR_3 = VAR_4;\n    int VAR_5;\n\n    switch (VAR_0->color_option) {\n    case VAR_6:\n        if (VAR_0->dither_cache) {\n            *VAR_2 = VAR_0->dither_cache;\n            VAR_3 = VAR_7;\n        } else {\n            VAR_3 = sixel_dither_new(VAR_2, (-1), VAR_0->allocator);\n        }\n        goto end;\n    case VAR_8:\n        if (VAR_0->dither_cache) {\n            *VAR_2 = VAR_0->dither_cache;\n            VAR_3 = VAR_7;\n        } else {\n            VAR_3 = sixel_prepare_monochrome_palette(VAR_2, VAR_0->finvert);\n        }\n        goto end;\n    case VAR_9:\n        if (VAR_0->dither_cache) {\n            *VAR_2 = VAR_0->dither_cache;\n            VAR_3 = VAR_7;\n        } else {\n            VAR_3 = sixel_prepare_specified_palette(VAR_2, VAR_0);\n        }\n        goto end;\n    case VAR_10:\n        if (VAR_0->dither_cache) {\n            *VAR_2 = VAR_0->dither_cache;\n            VAR_3 = VAR_7;\n        } else {\n            VAR_3 = sixel_prepare_builtin_palette(VAR_2, VAR_0->builtin_palette);\n        }\n        goto end;\n    case VAR_11:\n    default:\n        break;\n    }\n\n    if (sixel_frame_get_pixelformat(VAR_1) & VAR_12) {\n        if (!sixel_frame_get_palette(VAR_1)) {\n            VAR_3 = VAR_13;\n            goto end;\n        }\n        VAR_3 = sixel_dither_new(VAR_2, sixel_frame_get_ncolors(VAR_1),\n                                  VAR_0->allocator);\n        if (SIXEL_FAILED(VAR_3)) {\n            goto end;\n        }\n        sixel_dither_set_palette(*VAR_2, sixel_frame_get_palette(VAR_1));\n        sixel_dither_set_pixelformat(*VAR_2, sixel_frame_get_pixelformat(VAR_1));\n        if (sixel_frame_get_transparent(VAR_1) != (-1)) {\n            sixel_dither_set_transparent(*VAR_2, sixel_frame_get_transparent(VAR_1));\n        }\n        if (*VAR_2 && VAR_0->dither_cache) {\n            sixel_dither_unref(VAR_0->dither_cache);\n        }\n        goto end;\n    }\n\n    if (sixel_frame_get_pixelformat(VAR_1) & VAR_14) {\n        switch (sixel_frame_get_pixelformat(VAR_1)) {\n        case VAR_15:\n            *VAR_2 = sixel_dither_get(VAR_16);\n            break;\n        case VAR_17:\n            *VAR_2 = sixel_dither_get(VAR_18);\n            break;\n        case VAR_19:\n            *VAR_2 = sixel_dither_get(VAR_20);\n            break;\n        case VAR_21:\n            *VAR_2 = sixel_dither_get(VAR_22);\n            break;\n        default:\n            *VAR_2 = NULL;\n            VAR_3 = VAR_13;\n            goto end;\n        }\n        if (*VAR_2 && VAR_0->dither_cache) {\n            sixel_dither_unref(VAR_0->dither_cache);\n        }\n        sixel_dither_set_pixelformat(*VAR_2, sixel_frame_get_pixelformat(VAR_1));\n        VAR_3 = VAR_7;\n        goto end;\n    }\n\n    if (VAR_0->dither_cache) {\n        sixel_dither_unref(VAR_0->dither_cache);\n    }\n    VAR_3 = sixel_dither_new(VAR_2, VAR_0->reqcolors, VAR_0->allocator);\n    if (SIXEL_FAILED(VAR_3)) {\n        goto end;\n    }\n\n    VAR_3 = sixel_dither_initialize(*VAR_2,\n                                     sixel_frame_get_pixels(VAR_1),\n                                     sixel_frame_get_width(VAR_1),\n                                     sixel_frame_get_height(VAR_1),\n                                     sixel_frame_get_pixelformat(VAR_1),\n                                     VAR_0->method_for_largest,\n                                     VAR_0->method_for_rep,\n                                     VAR_0->quality_mode);\n    if (SIXEL_FAILED(VAR_3)) {\n        sixel_dither_unref(*VAR_2);\n        goto end;\n    }\n\n    VAR_5 = sixel_dither_get_num_of_histogram_colors(*VAR_2);\n    if (VAR_5 <= VAR_0->reqcolors) {\n        VAR_0->method_for_diffuse = VAR_23;\n    }\n    sixel_dither_set_pixelformat(*VAR_2, sixel_frame_get_pixelformat(VAR_1));\n\n    VAR_3 = VAR_7;\n\nend:\n    return VAR_3;\n}",
      "func_graph_path_before": "libsixel/d299d67c532a5133a57aade5c35ff8e612c73dd8/encoder.c/vul/before/0.json",
      "func": "static SIXELSTATUS\nsixel_encoder_prepare_palette(\n    sixel_encoder_t *encoder,  /* encoder object */\n    sixel_frame_t   *frame,    /* input frame object */\n    sixel_dither_t  **dither)  /* dither object to be created from the frame */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int histogram_colors;\n\n    switch (encoder->color_option) {\n    case SIXEL_COLOR_OPTION_HIGHCOLOR:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_dither_new(dither, (-1), encoder->allocator);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MONOCHROME:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_monochrome_palette(dither, encoder->finvert);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MAPFILE:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_specified_palette(dither, encoder);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_BUILTIN:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_builtin_palette(dither, encoder->builtin_palette);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_DEFAULT:\n    default:\n        break;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_PALETTE) {\n        if (!sixel_frame_get_palette(frame)) {\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        status = sixel_dither_new(dither, sixel_frame_get_ncolors(frame),\n                                  encoder->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        sixel_dither_set_palette(*dither, sixel_frame_get_palette(frame));\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        if (sixel_frame_get_transparent(frame) != (-1)) {\n            sixel_dither_set_transparent(*dither, sixel_frame_get_transparent(frame));\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        goto end;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_GRAYSCALE) {\n        switch (sixel_frame_get_pixelformat(frame)) {\n        case SIXEL_PIXELFORMAT_G1:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n            break;\n        case SIXEL_PIXELFORMAT_G2:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G2);\n            break;\n        case SIXEL_PIXELFORMAT_G4:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G4);\n            break;\n        case SIXEL_PIXELFORMAT_G8:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G8);\n            break;\n        default:\n            *dither = NULL;\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        status = SIXEL_OK;\n        goto end;\n    }\n\n    if (encoder->dither_cache) {\n        sixel_dither_unref(encoder->dither_cache);\n    }\n    status = sixel_dither_new(dither, encoder->reqcolors, encoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_dither_initialize(*dither,\n                                     sixel_frame_get_pixels(frame),\n                                     sixel_frame_get_width(frame),\n                                     sixel_frame_get_height(frame),\n                                     sixel_frame_get_pixelformat(frame),\n                                     encoder->method_for_largest,\n                                     encoder->method_for_rep,\n                                     encoder->quality_mode);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    histogram_colors = sixel_dither_get_num_of_histogram_colors(*dither);\n    if (histogram_colors <= encoder->reqcolors) {\n        encoder->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n    }\n    sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}",
      "abstract_func": "static SIXELSTATUS\nsixel_encoder_prepare_palette(\n    sixel_encoder_t *VAR_0,  /* COMMENT_0 */\n    sixel_frame_t   *VAR_1,    /* COMMENT_1 */\n    sixel_dither_t  **VAR_2)  /* COMMENT_2 */\n{\n    SIXELSTATUS VAR_3 = VAR_4;\n    int VAR_5;\n\n    switch (VAR_0->color_option) {\n    case VAR_6:\n        if (VAR_0->dither_cache) {\n            *VAR_2 = VAR_0->dither_cache;\n            VAR_3 = VAR_7;\n        } else {\n            VAR_3 = sixel_dither_new(VAR_2, (-1), VAR_0->allocator);\n        }\n        goto end;\n    case VAR_8:\n        if (VAR_0->dither_cache) {\n            *VAR_2 = VAR_0->dither_cache;\n            VAR_3 = VAR_7;\n        } else {\n            VAR_3 = sixel_prepare_monochrome_palette(VAR_2, VAR_0->finvert);\n        }\n        goto end;\n    case VAR_9:\n        if (VAR_0->dither_cache) {\n            *VAR_2 = VAR_0->dither_cache;\n            VAR_3 = VAR_7;\n        } else {\n            VAR_3 = sixel_prepare_specified_palette(VAR_2, VAR_0);\n        }\n        goto end;\n    case VAR_10:\n        if (VAR_0->dither_cache) {\n            *VAR_2 = VAR_0->dither_cache;\n            VAR_3 = VAR_7;\n        } else {\n            VAR_3 = sixel_prepare_builtin_palette(VAR_2, VAR_0->builtin_palette);\n        }\n        goto end;\n    case VAR_11:\n    default:\n        break;\n    }\n\n    if (sixel_frame_get_pixelformat(VAR_1) & VAR_12) {\n        if (!sixel_frame_get_palette(VAR_1)) {\n            VAR_3 = VAR_13;\n            goto end;\n        }\n        VAR_3 = sixel_dither_new(VAR_2, sixel_frame_get_ncolors(VAR_1),\n                                  VAR_0->allocator);\n        if (SIXEL_FAILED(VAR_3)) {\n            goto end;\n        }\n        sixel_dither_set_palette(*VAR_2, sixel_frame_get_palette(VAR_1));\n        sixel_dither_set_pixelformat(*VAR_2, sixel_frame_get_pixelformat(VAR_1));\n        if (sixel_frame_get_transparent(VAR_1) != (-1)) {\n            sixel_dither_set_transparent(*VAR_2, sixel_frame_get_transparent(VAR_1));\n        }\n        if (*VAR_2 && VAR_0->dither_cache) {\n            sixel_dither_unref(VAR_0->dither_cache);\n        }\n        goto end;\n    }\n\n    if (sixel_frame_get_pixelformat(VAR_1) & VAR_14) {\n        switch (sixel_frame_get_pixelformat(VAR_1)) {\n        case VAR_15:\n            *VAR_2 = sixel_dither_get(VAR_16);\n            break;\n        case VAR_17:\n            *VAR_2 = sixel_dither_get(VAR_18);\n            break;\n        case VAR_19:\n            *VAR_2 = sixel_dither_get(VAR_20);\n            break;\n        case VAR_21:\n            *VAR_2 = sixel_dither_get(VAR_22);\n            break;\n        default:\n            *VAR_2 = NULL;\n            VAR_3 = VAR_13;\n            goto end;\n        }\n        if (*VAR_2 && VAR_0->dither_cache) {\n            sixel_dither_unref(VAR_0->dither_cache);\n        }\n        sixel_dither_set_pixelformat(*VAR_2, sixel_frame_get_pixelformat(VAR_1));\n        VAR_3 = VAR_7;\n        goto end;\n    }\n\n    if (VAR_0->dither_cache) {\n        sixel_dither_unref(VAR_0->dither_cache);\n    }\n    VAR_3 = sixel_dither_new(VAR_2, VAR_0->reqcolors, VAR_0->allocator);\n    if (SIXEL_FAILED(VAR_3)) {\n        goto end;\n    }\n\n    VAR_3 = sixel_dither_initialize(*VAR_2,\n                                     sixel_frame_get_pixels(VAR_1),\n                                     sixel_frame_get_width(VAR_1),\n                                     sixel_frame_get_height(VAR_1),\n                                     sixel_frame_get_pixelformat(VAR_1),\n                                     VAR_0->method_for_largest,\n                                     VAR_0->method_for_rep,\n                                     VAR_0->quality_mode);\n    if (SIXEL_FAILED(VAR_3)) {\n        goto end;\n    }\n\n    VAR_5 = sixel_dither_get_num_of_histogram_colors(*VAR_2);\n    if (VAR_5 <= VAR_0->reqcolors) {\n        VAR_0->method_for_diffuse = VAR_23;\n    }\n    sixel_dither_set_pixelformat(*VAR_2, sixel_frame_get_pixelformat(VAR_1));\n\n    VAR_3 = VAR_7;\n\nend:\n    return VAR_3;\n}",
      "func_graph_path": "libsixel/d299d67c532a5133a57aade5c35ff8e612c73dd8/encoder.c/vul/after/0.json",
      "diff_func": "--- func_before\n+++ func_after\n@@ -110,7 +110,6 @@\n                                      encoder->method_for_rep,\n                                      encoder->quality_mode);\n     if (SIXEL_FAILED(status)) {\n-        sixel_dither_unref(*dither);\n         goto end;\n     }\n ",
      "diff_line_info": {
        "deleted_lines": [
          "        sixel_dither_unref(*dither);"
        ],
        "added_lines": []
      },
      "is_vul": true,
      "pr_url": "https://github.com/libsixel/libsixel/pull/28",
      "description": "The only place sixel_encoder_prepare_palette() is called from is sixel_encoder_encode_frame(). If we have a SIXEL_FAILED result inside the former, we unref the palette, potentially freeing it. We then goto the error path for\r\nsixel_encoder_encode_frame(), where we unref it again, in a classic double-free. Remove the internal unref. As noted,\r\nthis is a single call site, so removing the unref can't cause a memory leak.\r\n\r\nCloses #27, reported by a4865g (\"WuLearn\").",
      "Bug Filter": "Security Vulnerability Fix",
      "Bug Filter Confidence": 1.0,
      "Bug Filter Response": "The patch addresses a double-free issue, which is a security vulnerability. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
    }
  }
}