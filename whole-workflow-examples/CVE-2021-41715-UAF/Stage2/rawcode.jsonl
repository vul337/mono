{"patches_id": 1, "files_id": 0, "file_name": "src-encoder.c", "language": "c", "raw_url": "https://github.com/libsixel/libsixel/raw/d299d67c532a5133a57aade5c35ff8e612c73dd8/src%2Fencoder.c", "file_path": "storage/result/Part2_result/github/CVE-2021-41715/patch_after/src-encoder.c", "raw_code": "/*\n * Copyright (c) 2021 libsixel developers. See `AUTHORS`.\n * Copyright (c) 2014-2019 Hayaki Saito\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n# include <stdio.h>\n# include <stdlib.h>\n# include <stdarg.h>\n#include <string.h>\n# include <unistd.h>\n# include <sys/unistd.h>\n# include <sys/types.h>\n# include <time.h>\n# include <sys/time.h>\n# include <inttypes.h>\n# include <errno.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n\n#include <sixel.h>\n#include \"tty.h\"\n#include \"encoder.h\"\n#include \"rgblookup.h\"\n\n\nstatic char *\narg_strdup(\n    char const          /* in */ *s,          /* source buffer */\n    sixel_allocator_t   /* in */ *allocator)  /* allocator object for\n                                                 destination buffer */\n{\n    char *p;\n\n    p = (char *)sixel_allocator_malloc(allocator, strlen(s) + 1);\n    if (p) {\n        strcpy(p, s);\n    }\n    return p;\n}\n\n\n/* An clone function of XColorSpec() of xlib */\nstatic SIXELSTATUS\nsixel_parse_x_colorspec(\n    unsigned char       /* out */ **bgcolor,     /* destination buffer */\n    char const          /* in */  *s,            /* source buffer */\n    sixel_allocator_t   /* in */  *allocator)    /* allocator object for\n                                                    destination buffer */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    char *p;\n    unsigned char components[3];\n    int component_index = 0;\n    unsigned long v;\n    char *endptr;\n    char *buf = NULL;\n    struct color const *pcolor;\n\n    /* from rgb_lookup.h generated by gpref */\n    pcolor = lookup_rgb(s, strlen(s));\n    if (pcolor) {\n        *bgcolor = (unsigned char *)sixel_allocator_malloc(allocator, 3);\n        if (*bgcolor == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        (*bgcolor)[0] = pcolor->r;\n        (*bgcolor)[1] = pcolor->g;\n        (*bgcolor)[2] = pcolor->b;\n    } else if (s[0] == 'r' && s[1] == 'g' && s[2] == 'b' && s[3] == ':') {\n        p = buf = arg_strdup(s + 4, allocator);\n        if (buf == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        while (*p) {\n            v = 0;\n            for (endptr = p; endptr - p <= 12; ++endptr) {\n                if (*endptr >= '0' && *endptr <= '9') {\n                    v = (v << 4) | (unsigned long)(*endptr - '0');\n                } else if (*endptr >= 'a' && *endptr <= 'f') {\n                    v = (v << 4) | (unsigned long)(*endptr - 'a' + 10);\n                } else if (*endptr >= 'A' && *endptr <= 'F') {\n                    v = (v << 4) | (unsigned long)(*endptr - 'A' + 10);\n                } else {\n                    break;\n                }\n            }\n            if (endptr - p == 0) {\n                break;\n            }\n            if (endptr - p > 4) {\n                break;\n            }\n            v = v << ((4 - (endptr - p)) * 4) >> 8;\n            components[component_index++] = (unsigned char)v;\n            p = endptr;\n            if (component_index == 3) {\n                break;\n            }\n            if (*p == '\\0') {\n                break;\n            }\n            if (*p != '/') {\n                break;\n            }\n            ++p;\n        }\n        if (component_index != 3 || *p != '\\0' || *p == '/') {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        *bgcolor = (unsigned char *)sixel_allocator_malloc(allocator, 3);\n        if (*bgcolor == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        (*bgcolor)[0] = components[0];\n        (*bgcolor)[1] = components[1];\n        (*bgcolor)[2] = components[2];\n    } else if (*s == '#') {\n        buf = arg_strdup(s + 1, allocator);\n        if (buf == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        for (p = endptr = buf; endptr - p <= 12; ++endptr) {\n            if (*endptr >= '0' && *endptr <= '9') {\n                *endptr -= '0';\n            } else if (*endptr >= 'a' && *endptr <= 'f') {\n                *endptr -= 'a' - 10;\n            } else if (*endptr >= 'A' && *endptr <= 'F') {\n                *endptr -= 'A' - 10;\n            } else if (*endptr == '\\0') {\n                break;\n            } else {\n                status = SIXEL_BAD_ARGUMENT;\n                goto end;\n            }\n        }\n        if (endptr - p > 12) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        *bgcolor = (unsigned char *)sixel_allocator_malloc(allocator, 3);\n        if (*bgcolor == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        switch (endptr - p) {\n        case 3:\n            (*bgcolor)[0] = (unsigned char)(p[0] << 4);\n            (*bgcolor)[1] = (unsigned char)(p[1] << 4);\n            (*bgcolor)[2] = (unsigned char)(p[2] << 4);\n            break;\n        case 6:\n            (*bgcolor)[0] = (unsigned char)(p[0] << 4 | p[1]);\n            (*bgcolor)[1] = (unsigned char)(p[2] << 4 | p[3]);\n            (*bgcolor)[2] = (unsigned char)(p[4] << 4 | p[4]);\n            break;\n        case 9:\n            (*bgcolor)[0] = (unsigned char)(p[0] << 4 | p[1]);\n            (*bgcolor)[1] = (unsigned char)(p[3] << 4 | p[4]);\n            (*bgcolor)[2] = (unsigned char)(p[6] << 4 | p[7]);\n            break;\n        case 12:\n            (*bgcolor)[0] = (unsigned char)(p[0] << 4 | p[1]);\n            (*bgcolor)[1] = (unsigned char)(p[4] << 4 | p[5]);\n            (*bgcolor)[2] = (unsigned char)(p[8] << 4 | p[9]);\n            break;\n        default:\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n    } else {\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    sixel_allocator_free(allocator, buf);\n\n    return status;\n}\n\n\n/* generic writer function for passing to sixel_output_new() */\nstatic int\nsixel_write_callback(char *data, int size, void *priv)\n{\n    int result;\n\n#if defined(__MINGW64__)\n    result = write(*(int *)priv, data, (unsigned int)size);\n#else\n    result = write(*(int *)priv, data, (size_t)size);\n#endif\n\n    return result;\n}\n\n\n/* the writer function with hex-encoding for passing to sixel_output_new() */\nstatic int\nsixel_hex_write_callback(\n    char    /* in */ *data,\n    int     /* in */ size,\n    void    /* in */ *priv)\n{\n    char hex[SIXEL_OUTPUT_PACKET_SIZE * 2];\n    int i;\n    int j;\n    int result;\n\n    for (i = j = 0; i < size; ++i, ++j) {\n        hex[j] = (data[i] >> 4) & 0xf;\n        hex[j] += (hex[j] < 10 ? '0': ('a' - 10));\n        hex[++j] = data[i] & 0xf;\n        hex[j] += (hex[j] < 10 ? '0': ('a' - 10));\n    }\n\n#if defined(__MINGW64__)\n    result = write(*(int *)priv, hex, (unsigned int)(size * 2));\n#else\n    result = write(*(int *)priv, hex, (size_t)(size * 2));\n#endif\n\n    return result;\n}\n\n\n/* returns monochrome dithering context object */\nstatic SIXELSTATUS\nsixel_prepare_monochrome_palette(\n    sixel_dither_t  /* out */ **dither,\n     int            /* in */  finvert)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    if (finvert) {\n        *dither = sixel_dither_get(SIXEL_BUILTIN_MONO_LIGHT);\n    } else {\n        *dither = sixel_dither_get(SIXEL_BUILTIN_MONO_DARK);\n    }\n    if (*dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_prepare_monochrome_palette: sixel_dither_get() failed.\");\n        status = SIXEL_RUNTIME_ERROR;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* returns dithering context object with specified builtin palette */\nstatic SIXELSTATUS\nsixel_prepare_builtin_palette(\n    sixel_dither_t /* out */ **dither,\n    int            /* in */  builtin_palette)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    *dither = sixel_dither_get(builtin_palette);\n    if (*dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_prepare_builtin_palette: sixel_dither_get() failed.\");\n        status = SIXEL_RUNTIME_ERROR;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\ntypedef struct sixel_callback_context_for_mapfile {\n    int reqcolors;\n    sixel_dither_t *dither;\n    sixel_allocator_t *allocator;\n} sixel_callback_context_for_mapfile_t;\n\n\n/* callback function for sixel_helper_load_image_file() */\nstatic SIXELSTATUS\nload_image_callback_for_palette(\n    sixel_frame_t   /* in */    *frame, /* frame object from image loader */\n    void            /* in */    *data)  /* private data */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_callback_context_for_mapfile_t *callback_context;\n\n    /* get callback context object from the private data */\n    callback_context = (sixel_callback_context_for_mapfile_t *)data;\n\n    switch (sixel_frame_get_pixelformat(frame)) {\n    case SIXEL_PIXELFORMAT_PAL1:\n    case SIXEL_PIXELFORMAT_PAL2:\n    case SIXEL_PIXELFORMAT_PAL4:\n    case SIXEL_PIXELFORMAT_PAL8:\n        if (sixel_frame_get_palette(frame) == NULL) {\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        /* create new dither object */\n        status = sixel_dither_new(\n            &callback_context->dither,\n            sixel_frame_get_ncolors(frame),\n            callback_context->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        /* use palette which is extracted from the image */\n        sixel_dither_set_palette(callback_context->dither,\n                                 sixel_frame_get_palette(frame));\n        /* success */\n        status = SIXEL_OK;\n        break;\n    case SIXEL_PIXELFORMAT_G1:\n        /* use 1bpp grayscale builtin palette */\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n        /* success */\n        status = SIXEL_OK;\n        break;\n    case SIXEL_PIXELFORMAT_G2:\n        /* use 2bpp grayscale builtin palette */\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G2);\n        /* success */\n        status = SIXEL_OK;\n        break;\n    case SIXEL_PIXELFORMAT_G4:\n        /* use 4bpp grayscale builtin palette */\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G4);\n        /* success */\n        status = SIXEL_OK;\n        break;\n    case SIXEL_PIXELFORMAT_G8:\n        /* use 8bpp grayscale builtin palette */\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G8);\n        /* success */\n        status = SIXEL_OK;\n        break;\n    default:\n        /* create new dither object */\n        status = sixel_dither_new(\n            &callback_context->dither,\n            callback_context->reqcolors,\n            callback_context->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        /* create adaptive palette from given frame object */\n        status = sixel_dither_initialize(callback_context->dither,\n                                         sixel_frame_get_pixels(frame),\n                                         sixel_frame_get_width(frame),\n                                         sixel_frame_get_height(frame),\n                                         sixel_frame_get_pixelformat(frame),\n                                         SIXEL_LARGE_NORM,\n                                         SIXEL_REP_CENTER_BOX,\n                                         SIXEL_QUALITY_HIGH);\n        if (SIXEL_FAILED(status)) {\n            sixel_dither_unref(callback_context->dither);\n            goto end;\n        }\n\n        /* success */\n        status = SIXEL_OK;\n\n        break;\n    }\n\nend:\n    return status;\n}\n\n\n/* create palette from specified map file */\nstatic SIXELSTATUS\nsixel_prepare_specified_palette(\n    sixel_dither_t  /* out */   **dither,\n    sixel_encoder_t /* in */    *encoder)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_callback_context_for_mapfile_t callback_context;\n\n    callback_context.reqcolors = encoder->reqcolors;\n    callback_context.dither = NULL;\n    callback_context.allocator = encoder->allocator;\n\n    status = sixel_helper_load_image_file(encoder->mapfile,\n                                          1,   /* fstatic */\n                                          1,   /* fuse_palette */\n                                          SIXEL_PALETTE_MAX, /* reqcolors */\n                                          encoder->bgcolor,\n                                          SIXEL_LOOP_DISABLE,\n                                          load_image_callback_for_palette,\n                                          encoder->finsecure,\n                                          encoder->cancel_flag,\n                                          &callback_context,\n                                          encoder->allocator);\n    if (status != SIXEL_OK) {\n        return status;\n    }\n\n    *dither = callback_context.dither;\n\n    return status;\n}\n\n\n/* create dither object from a frame */\nstatic SIXELSTATUS\nsixel_encoder_prepare_palette(\n    sixel_encoder_t *encoder,  /* encoder object */\n    sixel_frame_t   *frame,    /* input frame object */\n    sixel_dither_t  **dither)  /* dither object to be created from the frame */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int histogram_colors;\n\n    switch (encoder->color_option) {\n    case SIXEL_COLOR_OPTION_HIGHCOLOR:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_dither_new(dither, (-1), encoder->allocator);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MONOCHROME:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_monochrome_palette(dither, encoder->finvert);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MAPFILE:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_specified_palette(dither, encoder);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_BUILTIN:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_builtin_palette(dither, encoder->builtin_palette);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_DEFAULT:\n    default:\n        break;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_PALETTE) {\n        if (!sixel_frame_get_palette(frame)) {\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        status = sixel_dither_new(dither, sixel_frame_get_ncolors(frame),\n                                  encoder->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        sixel_dither_set_palette(*dither, sixel_frame_get_palette(frame));\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        if (sixel_frame_get_transparent(frame) != (-1)) {\n            sixel_dither_set_transparent(*dither, sixel_frame_get_transparent(frame));\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        goto end;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_GRAYSCALE) {\n        switch (sixel_frame_get_pixelformat(frame)) {\n        case SIXEL_PIXELFORMAT_G1:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n            break;\n        case SIXEL_PIXELFORMAT_G2:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G2);\n            break;\n        case SIXEL_PIXELFORMAT_G4:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G4);\n            break;\n        case SIXEL_PIXELFORMAT_G8:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G8);\n            break;\n        default:\n            *dither = NULL;\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        status = SIXEL_OK;\n        goto end;\n    }\n\n    if (encoder->dither_cache) {\n        sixel_dither_unref(encoder->dither_cache);\n    }\n    status = sixel_dither_new(dither, encoder->reqcolors, encoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_dither_initialize(*dither,\n                                     sixel_frame_get_pixels(frame),\n                                     sixel_frame_get_width(frame),\n                                     sixel_frame_get_height(frame),\n                                     sixel_frame_get_pixelformat(frame),\n                                     encoder->method_for_largest,\n                                     encoder->method_for_rep,\n                                     encoder->quality_mode);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    histogram_colors = sixel_dither_get_num_of_histogram_colors(*dither);\n    if (histogram_colors <= encoder->reqcolors) {\n        encoder->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n    }\n    sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* resize a frame with settings of specified encoder object */\nstatic SIXELSTATUS\nsixel_encoder_do_resize(\n    sixel_encoder_t /* in */    *encoder,   /* encoder object */\n    sixel_frame_t   /* in */    *frame)     /* frame object to be resized */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int src_width;\n    int src_height;\n    int dst_width;\n    int dst_height;\n\n    /* get frame width and height */\n    src_width = sixel_frame_get_width(frame);\n    src_height = sixel_frame_get_height(frame);\n\n    /* settings around scaling */\n    dst_width = encoder->pixelwidth;    /* may be -1 (default) */\n    dst_height = encoder->pixelheight;  /* may be -1 (default) */\n\n    /* if the encoder has percentwidth or percentheight property,\n       convert them to pixelwidth / pixelheight */\n    if (encoder->percentwidth > 0) {\n        dst_width = src_width * encoder->percentwidth / 100;\n    }\n    if (encoder->percentheight > 0) {\n        dst_height = src_height * encoder->percentheight / 100;\n    }\n\n    /* if only either width or height is set, set also the other\n       to retain frame aspect ratio */\n    if (encoder->pixelwidth > 0 && dst_height <= 0) {\n        dst_height = src_height * encoder->pixelwidth / src_width;\n    }\n    if (encoder->pixelheight > 0 && dst_width <= 0) {\n        dst_width = src_width * encoder->pixelheight / src_height;\n    }\n\n    /* do resize */\n    if (dst_width > 0 && dst_height > 0) {\n        status = sixel_frame_resize(frame, dst_width, dst_height,\n                                    encoder->method_for_resampling);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    /* success */\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* clip a frame with settings of specified encoder object */\nstatic SIXELSTATUS\nsixel_encoder_do_clip(\n    sixel_encoder_t /* in */    *encoder,   /* encoder object */\n    sixel_frame_t   /* in */    *frame)     /* frame object to be resized */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int src_width;\n    int src_height;\n    int clip_x;\n    int clip_y;\n    int clip_w;\n    int clip_h;\n\n    /* get frame width and height */\n    src_width = sixel_frame_get_width(frame);\n    src_height = sixel_frame_get_height(frame);\n\n    /* settings around clipping */\n    clip_x = encoder->clipx;\n    clip_y = encoder->clipy;\n    clip_w = encoder->clipwidth;\n    clip_h = encoder->clipheight;\n\n    /* adjust clipping width with comparing it to frame width */\n    if (clip_w + clip_x > src_width) {\n        if (clip_x > src_width) {\n            clip_w = 0;\n        } else {\n            clip_w = src_width - clip_x;\n        }\n    }\n\n    /* adjust clipping height with comparing it to frame height */\n    if (clip_h + clip_y > src_height) {\n        if (clip_y > src_height) {\n            clip_h = 0;\n        } else {\n            clip_h = src_height - clip_y;\n        }\n    }\n\n    /* do clipping */\n    if (clip_w > 0 && clip_h > 0) {\n        status = sixel_frame_clip(frame, clip_x, clip_y, clip_w, clip_h);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    /* success */\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\nstatic void\nsixel_debug_print_palette(\n    sixel_dither_t /* in */ *dither /* dithering object */\n)\n{\n    unsigned char *palette;\n    int i;\n\n    palette = sixel_dither_get_palette(dither);\n    fprintf(stderr, \"palette:\\n\");\n    for (i = 0; i < sixel_dither_get_num_of_palette_colors(dither); ++i) {\n        fprintf(stderr, \"%d: #%02x%02x%02x\\n\", i,\n                palette[i * 3 + 1],\n                palette[i * 3 + 2],\n                palette[i * 3 + 3]);\n    }\n}\n\n\nstatic SIXELSTATUS\nsixel_encoder_output_without_macro(\n    sixel_frame_t       /* in */ *frame,\n    sixel_dither_t      /* in */ *dither,\n    sixel_output_t      /* in */ *output,\n    sixel_encoder_t     /* in */ *encoder)\n{\n    SIXELSTATUS status = SIXEL_OK;\n    static unsigned char *p;\n    int depth;\n    enum { message_buffer_size = 256 };\n    char message[message_buffer_size];\n    int nwrite;\n    int dulation;\n    int delay;\n    int lag = 0;\n    struct timespec tv;\n    clock_t start;\n    unsigned char *pixbuf;\n    int width;\n    int height;\n    int pixelformat;\n    size_t size;\n\n    if (encoder == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_encoder_output_without_macro: encoder object is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (encoder->color_option == SIXEL_COLOR_OPTION_DEFAULT) {\n        sixel_dither_set_optimize_palette(dither, 1);\n    }\n\n    pixelformat = sixel_frame_get_pixelformat(frame);\n    depth = sixel_helper_compute_depth(pixelformat);\n    if (depth < 0) {\n        status = SIXEL_LOGIC_ERROR;\n        nwrite = sprintf(message,\n                         \"sixel_encoder_output_without_macro: \"\n                         \"sixel_helper_compute_depth(%08x) failed.\",\n                         pixelformat);\n        if (nwrite > 0) {\n            sixel_helper_set_additional_message(message);\n        }\n        goto end;\n    }\n\n    width = sixel_frame_get_width(frame);\n    height = sixel_frame_get_height(frame);\n    size = (size_t)(width * height * depth);\n    p = (unsigned char *)sixel_allocator_malloc(encoder->allocator, size);\n    if (p == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_encoder_output_without_macro: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n    start = clock();\n    delay = sixel_frame_get_delay(frame);\n    if (delay > 0 && !encoder->fignore_delay) {\n        dulation = (int)((clock() - start) * 1000 * 1000 / CLOCKS_PER_SEC) - (int)lag;\n        lag = 0;\n        if (dulation < 10000 * delay) {\n            tv.tv_sec = 0;\n            tv.tv_nsec = (long)((10000 * delay - dulation) * 1000);\n            nanosleep(&tv, NULL);\n        } else {\n            lag = (int)(10000 * delay - dulation);\n        }\n    }\n\n    pixbuf = sixel_frame_get_pixels(frame);\n    memcpy(p, pixbuf, (size_t)(width * height * depth));\n\n    if (encoder->cancel_flag && *encoder->cancel_flag) {\n        goto end;\n    }\n\n    status = sixel_encode(p, width, height, depth, dither, output);\n    if (status != SIXEL_OK) {\n        goto end;\n    }\n\nend:\n    sixel_allocator_free(encoder->allocator, p);\n\n    return status;\n}\n\n\nstatic SIXELSTATUS\nsixel_encoder_output_with_macro(\n    sixel_frame_t   /* in */ *frame,\n    sixel_dither_t  /* in */ *dither,\n    sixel_output_t  /* in */ *output,\n    sixel_encoder_t /* in */ *encoder)\n{\n    SIXELSTATUS status = SIXEL_OK;\n    enum { message_buffer_size = 256 };\n    char buffer[message_buffer_size];\n    int nwrite;\n    int dulation;\n    int lag = 0;\n    struct timespec tv;\n    clock_t start;\n    unsigned char *pixbuf;\n    int width;\n    int height;\n    int delay;\n\n    start = clock();\n    if (sixel_frame_get_loop_no(frame) == 0) {\n        if (encoder->macro_number >= 0) {\n            nwrite = sprintf(buffer, \"\\033P%d;0;1!z\", encoder->macro_number);\n        } else {\n            nwrite = sprintf(buffer, \"\\033P%d;0;1!z\", sixel_frame_get_frame_no(frame));\n        }\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sprintf() failed.\");\n            goto end;\n        }\n        nwrite = sixel_write_callback(buffer, (int)strlen(buffer), &encoder->outfd);\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sixel_write_callback() failed.\");\n            goto end;\n        }\n\n        pixbuf = sixel_frame_get_pixels(frame),\n        width = sixel_frame_get_width(frame),\n        height = sixel_frame_get_height(frame),\n        status = sixel_encode(pixbuf, width, height, /* unused */ 3, dither, output);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        nwrite = sixel_write_callback(\"\\033\\\\\", 2, &encoder->outfd);\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sixel_write_callback() failed.\");\n            goto end;\n        }\n    }\n    if (encoder->macro_number < 0) {\n        nwrite = sprintf(buffer, \"\\033[%d*z\", sixel_frame_get_frame_no(frame));\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sprintf() failed.\");\n        }\n        nwrite = sixel_write_callback(buffer, (int)strlen(buffer), &encoder->outfd);\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sixel_write_callback() failed.\");\n            goto end;\n        }\n        delay = sixel_frame_get_delay(frame);\n        if (delay > 0 && !encoder->fignore_delay) {\n            dulation = (int)((clock() - start) * 1000 * 1000 / CLOCKS_PER_SEC) - (int)lag;\n            lag = 0;\n            if (dulation < 10000 * delay) {\n                tv.tv_sec = 0;\n                tv.tv_nsec = (long)((10000 * delay - dulation) * 1000);\n                nanosleep(&tv, NULL);\n            } else {\n                lag = (int)(10000 * delay - dulation);\n            }\n        }\n    }\n\nend:\n    return status;\n}\n\n\nstatic SIXELSTATUS\nsixel_encoder_encode_frame(\n    sixel_encoder_t *encoder,\n    sixel_frame_t   *frame,\n    sixel_output_t  *output)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_dither_t *dither = NULL;\n    int height;\n    int is_animation = 0;\n    int nwrite;\n\n    /* evaluate -w, -h, and -c option: crop/scale input source */\n    if (encoder->clipfirst) {\n        /* clipping */\n        status = sixel_encoder_do_clip(encoder, frame);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        /* scaling */\n        status = sixel_encoder_do_resize(encoder, frame);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    } else {\n        /* scaling */\n        status = sixel_encoder_do_resize(encoder, frame);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        /* clipping */\n        status = sixel_encoder_do_clip(encoder, frame);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    /* prepare dither context */\n    status = sixel_encoder_prepare_palette(encoder, frame, &dither);\n    if (status != SIXEL_OK) {\n        goto end;\n    }\n\n    if (encoder->dither_cache != NULL) {\n        encoder->dither_cache = dither;\n        sixel_dither_ref(dither);\n    }\n\n    /* evaluate -v option: print palette */\n    if (encoder->verbose) {\n        if ((sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_PALETTE)) {\n            sixel_debug_print_palette(dither);\n        }\n    }\n\n    /* evaluate -d option: set method for diffusion */\n    sixel_dither_set_diffusion_type(dither, encoder->method_for_diffuse);\n\n    /* evaluate -C option: set complexion score */\n    if (encoder->complexion > 1) {\n        sixel_dither_set_complexion_score(dither, encoder->complexion);\n    }\n\n    if (output) {\n        sixel_output_ref(output);\n    } else {\n        /* create output context */\n        if (encoder->fuse_macro || encoder->macro_number >= 0) {\n            /* -u or -n option */\n            status = sixel_output_new(&output,\n                                      sixel_hex_write_callback,\n                                      &encoder->outfd,\n                                      encoder->allocator);\n        } else {\n            status = sixel_output_new(&output,\n                                      sixel_write_callback,\n                                      &encoder->outfd,\n                                      encoder->allocator);\n        }\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    sixel_output_set_8bit_availability(output, encoder->f8bit);\n    sixel_output_set_gri_arg_limit(output, encoder->has_gri_arg_limit);\n    sixel_output_set_palette_type(output, encoder->palette_type);\n    sixel_output_set_penetrate_multiplexer(\n        output, encoder->penetrate_multiplexer);\n    sixel_output_set_encode_policy(output, encoder->encode_policy);\n    sixel_output_set_ormode(output, encoder->ormode);\n\n    if (sixel_frame_get_multiframe(frame) && !encoder->fstatic) {\n        if (sixel_frame_get_loop_no(frame) != 0 || sixel_frame_get_frame_no(frame) != 0) {\n            is_animation = 1;\n        }\n        height = sixel_frame_get_height(frame);\n        (void) sixel_tty_scroll(sixel_write_callback, encoder->outfd, height, is_animation);\n    }\n\n    if (encoder->cancel_flag && *encoder->cancel_flag) {\n        status = SIXEL_INTERRUPTED;\n        goto end;\n    }\n\n    /* output sixel: junction of multi-frame processing strategy */\n    if (encoder->fuse_macro) {  /* -u option */\n        /* use macro */\n        status = sixel_encoder_output_with_macro(frame, dither, output, encoder);\n    } else if (encoder->macro_number >= 0) { /* -n option */\n        /* use macro */\n        status = sixel_encoder_output_with_macro(frame, dither, output, encoder);\n    } else {\n        /* do not use macro */\n        status = sixel_encoder_output_without_macro(frame, dither, output, encoder);\n    }\n\n    if (encoder->cancel_flag && *encoder->cancel_flag) {\n        nwrite = sixel_write_callback(\"\\x18\\033\\\\\", 3, &encoder->outfd);\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"load_image_callback: sixel_write_callback() failed.\");\n            goto end;\n        }\n        status = SIXEL_INTERRUPTED;\n    }\n\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\nend:\n    if (output) {\n        sixel_output_unref(output);\n    }\n    if (dither) {\n        sixel_dither_unref(dither);\n    }\n\n    return status;\n}\n\n\n/* create encoder object */\nSIXELAPI SIXELSTATUS\nsixel_encoder_new(\n    sixel_encoder_t     /* out */ **ppencoder, /* encoder object to be created */\n    sixel_allocator_t   /* in */  *allocator)  /* allocator, null if you use\n                                                  default allocator */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    char const *env_default_bgcolor;\n    char const *env_default_ncolors;\n    int ncolors;\n\n    if (allocator == NULL) {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    *ppencoder\n        = (sixel_encoder_t *)sixel_allocator_malloc(allocator,\n                                                    sizeof(sixel_encoder_t));\n    if (*ppencoder == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_encoder_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        sixel_allocator_unref(allocator);\n        goto end;\n    }\n\n    (*ppencoder)->ref                   = 1;\n    (*ppencoder)->reqcolors             = (-1);\n    (*ppencoder)->mapfile               = NULL;\n    (*ppencoder)->color_option          = SIXEL_COLOR_OPTION_DEFAULT;\n    (*ppencoder)->builtin_palette       = 0;\n    (*ppencoder)->method_for_diffuse    = SIXEL_DIFFUSE_AUTO;\n    (*ppencoder)->method_for_largest    = SIXEL_LARGE_AUTO;\n    (*ppencoder)->method_for_rep        = SIXEL_REP_AUTO;\n    (*ppencoder)->quality_mode          = SIXEL_QUALITY_AUTO;\n    (*ppencoder)->method_for_resampling = SIXEL_RES_BILINEAR;\n    (*ppencoder)->loop_mode             = SIXEL_LOOP_AUTO;\n    (*ppencoder)->palette_type          = SIXEL_PALETTETYPE_AUTO;\n    (*ppencoder)->f8bit                 = 0;\n    (*ppencoder)->has_gri_arg_limit     = 0;\n    (*ppencoder)->finvert               = 0;\n    (*ppencoder)->fuse_macro            = 0;\n    (*ppencoder)->fignore_delay         = 0;\n    (*ppencoder)->complexion            = 1;\n    (*ppencoder)->fstatic               = 0;\n    (*ppencoder)->pixelwidth            = (-1);\n    (*ppencoder)->pixelheight           = (-1);\n    (*ppencoder)->percentwidth          = (-1);\n    (*ppencoder)->percentheight         = (-1);\n    (*ppencoder)->clipx                 = 0;\n    (*ppencoder)->clipy                 = 0;\n    (*ppencoder)->clipwidth             = 0;\n    (*ppencoder)->clipheight            = 0;\n    (*ppencoder)->clipfirst             = 0;\n    (*ppencoder)->macro_number          = (-1);\n    (*ppencoder)->verbose               = 0;\n    (*ppencoder)->penetrate_multiplexer = 0;\n    (*ppencoder)->encode_policy         = SIXEL_ENCODEPOLICY_AUTO;\n    (*ppencoder)->ormode                = 0;\n    (*ppencoder)->pipe_mode             = 0;\n    (*ppencoder)->bgcolor               = NULL;\n    (*ppencoder)->outfd                 = STDOUT_FILENO;\n    (*ppencoder)->finsecure             = 0;\n    (*ppencoder)->cancel_flag           = NULL;\n    (*ppencoder)->dither_cache          = NULL;\n    (*ppencoder)->allocator             = allocator;\n\n    /* evaluate environment variable ${SIXEL_BGCOLOR} */\n    env_default_bgcolor = getenv(\"SIXEL_BGCOLOR\");\n    if (env_default_bgcolor) {\n        status = sixel_parse_x_colorspec(&(*ppencoder)->bgcolor,\n                                         env_default_bgcolor,\n                                         allocator);\n        if (SIXEL_FAILED(status)) {\n            goto error;\n        }\n    }\n\n    /* evaluate environment variable ${SIXEL_COLORS} */\n    env_default_ncolors = getenv(\"SIXEL_COLORS\");\n    if (env_default_ncolors) {\n        ncolors = atoi(env_default_ncolors); /* may overflow */\n        if (ncolors > 1 && ncolors <= SIXEL_PALETTE_MAX) {\n            (*ppencoder)->reqcolors = ncolors;\n        }\n    }\n\n    /* success */\n    status = SIXEL_OK;\n\n    goto end;\n\nerror:\n    sixel_allocator_free(allocator, *ppencoder);\n    sixel_allocator_unref(allocator);\n    *ppencoder = NULL;\n\nend:\n    return status;\n}\n\n\n/* create encoder object (deprecated version) */\nSIXELAPI /* deprecated */ sixel_encoder_t *\nsixel_encoder_create(void)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_encoder_t *encoder = NULL;\n\n    status = sixel_encoder_new(&encoder, NULL);\n    if (SIXEL_FAILED(status)) {\n        return NULL;\n    }\n\n    return encoder;\n}\n\n\n/* destroy encoder object */\nstatic void\nsixel_encoder_destroy(sixel_encoder_t *encoder)\n{\n    sixel_allocator_t *allocator;\n\n    if (encoder) {\n        allocator = encoder->allocator;\n        sixel_allocator_free(allocator, encoder->mapfile);\n        sixel_allocator_free(allocator, encoder->bgcolor);\n        sixel_dither_unref(encoder->dither_cache);\n        if (encoder->outfd\n            && encoder->outfd != STDOUT_FILENO\n            && encoder->outfd != STDERR_FILENO) {\n            close(encoder->outfd);\n        }\n        sixel_allocator_free(allocator, encoder);\n        sixel_allocator_unref(allocator);\n    }\n}\n\n\n/* increase reference count of encoder object (thread-unsafe) */\nSIXELAPI void\nsixel_encoder_ref(sixel_encoder_t *encoder)\n{\n    /* TODO: be thread safe */\n    ++encoder->ref;\n}\n\n\n/* decrease reference count of encoder object (thread-unsafe) */\nSIXELAPI void\nsixel_encoder_unref(sixel_encoder_t *encoder)\n{\n    /* TODO: be thread safe */\n    if (encoder != NULL && --encoder->ref == 0) {\n        sixel_encoder_destroy(encoder);\n    }\n}\n\n\n/* set cancel state flag to encoder object */\nSIXELAPI SIXELSTATUS\nsixel_encoder_set_cancel_flag(\n    sixel_encoder_t /* in */ *encoder,\n    int             /* in */ *cancel_flag\n)\n{\n    SIXELSTATUS status = SIXEL_OK;\n\n    encoder->cancel_flag = cancel_flag;\n\n    return status;\n}\n\n\n/* set an option flag to encoder object */\nSIXELAPI SIXELSTATUS\nsixel_encoder_setopt(\n    sixel_encoder_t /* in */ *encoder,\n    int             /* in */ arg,\n    char const      /* in */ *value)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int number;\n    int parsed;\n    char unit[32];\n\n    sixel_encoder_ref(encoder);\n\n    switch(arg) {\n    case SIXEL_OPTFLAG_OUTFILE:  /* o */\n        if (*value == '\\0') {\n            sixel_helper_set_additional_message(\n                \"no file name specified.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (strcmp(value, \"-\") != 0) {\n            if (encoder->outfd && encoder->outfd != STDOUT_FILENO) {\n                close(encoder->outfd);\n            }\n            encoder->outfd = open(value,\n                                  O_RDWR|O_CREAT|O_TRUNC,\n                                  S_IRUSR|S_IWUSR);\n        }\n        break;\n    case SIXEL_OPTFLAG_7BIT_MODE:  /* 7 */\n        encoder->f8bit = 0;\n        break;\n    case SIXEL_OPTFLAG_8BIT_MODE:  /* 8 */\n        encoder->f8bit = 1;\n        break;\n    case SIXEL_OPTFLAG_HAS_GRI_ARG_LIMIT:  /* R */\n        encoder->has_gri_arg_limit = 1;\n        break;\n    case SIXEL_OPTFLAG_COLORS:  /* p */\n        encoder->reqcolors = atoi(value);\n        break;\n    case SIXEL_OPTFLAG_MAPFILE:  /* m */\n        if (encoder->mapfile) {\n            sixel_allocator_free(encoder->allocator, encoder->mapfile);\n        }\n        encoder->mapfile = arg_strdup(value, encoder->allocator);\n        if (encoder->mapfile == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_setopt: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        encoder->color_option = SIXEL_COLOR_OPTION_MAPFILE;\n        break;\n    case SIXEL_OPTFLAG_MONOCHROME:  /* e */\n        encoder->color_option = SIXEL_COLOR_OPTION_MONOCHROME;\n        break;\n    case SIXEL_OPTFLAG_HIGH_COLOR:  /* I */\n        encoder->color_option = SIXEL_COLOR_OPTION_HIGHCOLOR;\n        break;\n    case SIXEL_OPTFLAG_BUILTIN_PALETTE:  /* b */\n        if (strcmp(value, \"xterm16\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_XTERM16;\n        } else if (strcmp(value, \"xterm256\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_XTERM256;\n        } else if (strcmp(value, \"vt340mono\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_VT340_MONO;\n        } else if (strcmp(value, \"vt340color\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_VT340_COLOR;\n        } else if (strcmp(value, \"gray1\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_G1;\n        } else if (strcmp(value, \"gray2\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_G2;\n        } else if (strcmp(value, \"gray4\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_G4;\n        } else if (strcmp(value, \"gray8\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_G8;\n        } else {\n            sixel_helper_set_additional_message(\n                    \"cannot parse builtin palette option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        encoder->color_option = SIXEL_COLOR_OPTION_BUILTIN;\n        break;\n    case SIXEL_OPTFLAG_DIFFUSION:  /* d */\n        /* parse --diffusion option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_AUTO;\n        } else if (strcmp(value, \"none\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n        } else if (strcmp(value, \"fs\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_FS;\n        } else if (strcmp(value, \"atkinson\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_ATKINSON;\n        } else if (strcmp(value, \"jajuni\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_JAJUNI;\n        } else if (strcmp(value, \"stucki\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_STUCKI;\n        } else if (strcmp(value, \"burkes\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_BURKES;\n        } else if (strcmp(value, \"a_dither\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_A_DITHER;\n        } else if (strcmp(value, \"x_dither\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_X_DITHER;\n        } else {\n            sixel_helper_set_additional_message(\n                \"specified diffusion method is not supported.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_FIND_LARGEST:  /* f */\n        /* parse --find-largest option */\n        if (value) {\n            if (strcmp(value, \"auto\") == 0) {\n                encoder->method_for_largest = SIXEL_LARGE_AUTO;\n            } else if (strcmp(value, \"norm\") == 0) {\n                encoder->method_for_largest = SIXEL_LARGE_NORM;\n            } else if (strcmp(value, \"lum\") == 0) {\n                encoder->method_for_largest = SIXEL_LARGE_LUM;\n            } else {\n                sixel_helper_set_additional_message(\n                    \"specified finding method is not supported.\");\n                status = SIXEL_BAD_ARGUMENT;\n                goto end;\n            }\n        }\n        break;\n    case SIXEL_OPTFLAG_SELECT_COLOR:  /* s */\n        /* parse --select-color option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->method_for_rep = SIXEL_REP_AUTO;\n        } else if (strcmp(value, \"center\") == 0) {\n            encoder->method_for_rep = SIXEL_REP_CENTER_BOX;\n        } else if (strcmp(value, \"average\") == 0) {\n            encoder->method_for_rep = SIXEL_REP_AVERAGE_COLORS;\n        } else if ((strcmp(value, \"histogram\") == 0) ||\n                   (strcmp(value, \"histgram\") == 0)) {\n            encoder->method_for_rep = SIXEL_REP_AVERAGE_PIXELS;\n        } else {\n            sixel_helper_set_additional_message(\n                \"specified finding method is not supported.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_CROP:  /* c */\n        number = sscanf(value, \"%dx%d+%d+%d\",\n                        &encoder->clipwidth, &encoder->clipheight,\n                        &encoder->clipx, &encoder->clipy);\n        if (number != 4) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (encoder->clipwidth <= 0 || encoder->clipheight <= 0) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (encoder->clipx < 0 || encoder->clipy < 0) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        encoder->clipfirst = 0;\n        break;\n    case SIXEL_OPTFLAG_WIDTH:  /* w */\n        parsed = sscanf(value, \"%d%2s\", &number, unit);\n        if (parsed == 2 && strcmp(unit, \"%\") == 0) {\n            encoder->pixelwidth = (-1);\n            encoder->percentwidth = number;\n        } else if (parsed == 1 || (parsed == 2 && strcmp(unit, \"px\") == 0)) {\n            encoder->pixelwidth = number;\n            encoder->percentwidth = (-1);\n        } else if (strcmp(value, \"auto\") == 0) {\n            encoder->pixelwidth = (-1);\n            encoder->percentwidth = (-1);\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse -w/--width option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (encoder->clipwidth) {\n            encoder->clipfirst = 1;\n        }\n        break;\n    case SIXEL_OPTFLAG_HEIGHT:  /* h */\n        parsed = sscanf(value, \"%d%2s\", &number, unit);\n        if (parsed == 2 && strcmp(unit, \"%\") == 0) {\n            encoder->pixelheight = (-1);\n            encoder->percentheight = number;\n        } else if (parsed == 1 || (parsed == 2 && strcmp(unit, \"px\") == 0)) {\n            encoder->pixelheight = number;\n            encoder->percentheight = (-1);\n        } else if (strcmp(value, \"auto\") == 0) {\n            encoder->pixelheight = (-1);\n            encoder->percentheight = (-1);\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse -h/--height option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (encoder->clipheight) {\n            encoder->clipfirst = 1;\n        }\n        break;\n    case SIXEL_OPTFLAG_RESAMPLING:  /* r */\n        /* parse --resampling option */\n        if (strcmp(value, \"nearest\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_NEAREST;\n        } else if (strcmp(value, \"gaussian\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_GAUSSIAN;\n        } else if (strcmp(value, \"hanning\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_HANNING;\n        } else if (strcmp(value, \"hamming\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_HAMMING;\n        } else if (strcmp(value, \"bilinear\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_BILINEAR;\n        } else if (strcmp(value, \"welsh\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_WELSH;\n        } else if (strcmp(value, \"bicubic\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_BICUBIC;\n        } else if (strcmp(value, \"lanczos2\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_LANCZOS2;\n        } else if (strcmp(value, \"lanczos3\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_LANCZOS3;\n        } else if (strcmp(value, \"lanczos4\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_LANCZOS4;\n        } else {\n            sixel_helper_set_additional_message(\n                \"specified desampling method is not supported.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_QUALITY:  /* q */\n        /* parse --quality option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->quality_mode = SIXEL_QUALITY_AUTO;\n        } else if (strcmp(value, \"high\") == 0) {\n            encoder->quality_mode = SIXEL_QUALITY_HIGH;\n        } else if (strcmp(value, \"low\") == 0) {\n            encoder->quality_mode = SIXEL_QUALITY_LOW;\n        } else if (strcmp(value, \"full\") == 0) {\n            encoder->quality_mode = SIXEL_QUALITY_FULL;\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse quality option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_LOOPMODE:  /* l */\n        /* parse --loop-control option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->loop_mode = SIXEL_LOOP_AUTO;\n        } else if (strcmp(value, \"force\") == 0) {\n            encoder->loop_mode = SIXEL_LOOP_FORCE;\n        } else if (strcmp(value, \"disable\") == 0) {\n            encoder->loop_mode = SIXEL_LOOP_DISABLE;\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse loop-control option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_PALETTE_TYPE:  /* t */\n        /* parse --palette-type option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->palette_type = SIXEL_PALETTETYPE_AUTO;\n        } else if (strcmp(value, \"hls\") == 0) {\n            encoder->palette_type = SIXEL_PALETTETYPE_HLS;\n        } else if (strcmp(value, \"rgb\") == 0) {\n            encoder->palette_type = SIXEL_PALETTETYPE_RGB;\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse palette type option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_BGCOLOR:  /* B */\n        /* parse --bgcolor option */\n        if (encoder->bgcolor) {\n            sixel_allocator_free(encoder->allocator, encoder->bgcolor);\n        }\n        status = sixel_parse_x_colorspec(&encoder->bgcolor,\n                                         value,\n                                         encoder->allocator);\n        if (SIXEL_FAILED(status)) {\n            sixel_helper_set_additional_message(\n                \"cannot parse bgcolor option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_INSECURE:  /* k */\n        encoder->finsecure = 1;\n        break;\n    case SIXEL_OPTFLAG_INVERT:  /* i */\n        encoder->finvert = 1;\n        break;\n    case SIXEL_OPTFLAG_USE_MACRO:  /* u */\n        encoder->fuse_macro = 1;\n        break;\n    case SIXEL_OPTFLAG_MACRO_NUMBER:  /* n */\n        encoder->macro_number = atoi(value);\n        if (encoder->macro_number < 0) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_IGNORE_DELAY:  /* g */\n        encoder->fignore_delay = 1;\n        break;\n    case SIXEL_OPTFLAG_VERBOSE:  /* v */\n        encoder->verbose = 1;\n        break;\n    case SIXEL_OPTFLAG_STATIC:  /* S */\n        encoder->fstatic = 1;\n        break;\n    case SIXEL_OPTFLAG_PENETRATE:  /* P */\n        encoder->penetrate_multiplexer = 1;\n        break;\n    case SIXEL_OPTFLAG_ENCODE_POLICY:  /* E */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->encode_policy = SIXEL_ENCODEPOLICY_AUTO;\n        } else if (strcmp(value, \"fast\") == 0) {\n            encoder->encode_policy = SIXEL_ENCODEPOLICY_FAST;\n        } else if (strcmp(value, \"size\") == 0) {\n            encoder->encode_policy = SIXEL_ENCODEPOLICY_SIZE;\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse encode policy option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_ORMODE:  /* O */\n        encoder->ormode = 1;\n        break;\n    case SIXEL_OPTFLAG_COMPLEXION_SCORE:  /* C */\n        encoder->complexion = atoi(value);\n        if (encoder->complexion < 1) {\n            sixel_helper_set_additional_message(\n                \"complexion parameter must be 1 or more.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_PIPE_MODE:  /* D */\n        encoder->pipe_mode = 1;\n        break;\n    case '?':  /* unknown option */\n    default:\n        /* exit if unknown options are specified */\n        sixel_helper_set_additional_message(\n            \"unknown option is specified.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    /* detects arguments conflictions */\n    if (encoder->reqcolors != (-1)) {\n        switch (encoder->color_option) {\n        case SIXEL_COLOR_OPTION_MAPFILE:\n            sixel_helper_set_additional_message(\n                \"option -p, --colors conflicts with -m, --mapfile.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        case SIXEL_COLOR_OPTION_MONOCHROME:\n            sixel_helper_set_additional_message(\n                \"option -e, --monochrome conflicts with -p, --colors.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        case SIXEL_COLOR_OPTION_HIGHCOLOR:\n            sixel_helper_set_additional_message(\n                \"option -p, --colors conflicts with -I, --high-color.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        case SIXEL_COLOR_OPTION_BUILTIN:\n            sixel_helper_set_additional_message(\n                \"option -p, --colors conflicts with -b, --builtin-palette.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        default:\n            break;\n        }\n    }\n\n    /* 8bit output option(-8) conflicts width GNU Screen integration(-P) */\n    if (encoder->f8bit && encoder->penetrate_multiplexer) {\n        sixel_helper_set_additional_message(\n            \"option -8 --8bit-mode conflicts\"\n            \" with -P, --penetrate.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    sixel_encoder_unref(encoder);\n\n    return status;\n}\n\n\n/* called when image loader component load a image frame */\nstatic SIXELSTATUS\nload_image_callback(sixel_frame_t *frame, void *data)\n{\n    return sixel_encoder_encode_frame((sixel_encoder_t *)data, frame, NULL);\n}\n\n\n/* load source data from specified file and encode it to SIXEL format\n * output to encoder->outfd */\nSIXELAPI SIXELSTATUS\nsixel_encoder_encode(\n    sixel_encoder_t *encoder,   /* encoder object */\n    char const      *filename)  /* input filename */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int fuse_palette = 1;\n\n    if (encoder == NULL) {\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n        encoder = sixel_encoder_create();\n#  pragma GCC diagnostic pop\n        if (encoder == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_encode: sixel_encoder_create() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n    } else {\n        sixel_encoder_ref(encoder);\n    }\n\n    /* if required color is not set, set the max value */\n    if (encoder->reqcolors == (-1)) {\n        encoder->reqcolors = SIXEL_PALETTE_MAX;\n    }\n\n    /* if required color is less then 2, set the min value */\n    if (encoder->reqcolors < 2) {\n        encoder->reqcolors = SIXEL_PALETTE_MIN;\n    }\n\n    /* if color space option is not set, choose RGB color space */\n    if (encoder->palette_type == SIXEL_PALETTETYPE_AUTO) {\n        encoder->palette_type = SIXEL_PALETTETYPE_RGB;\n    }\n\n    /* if color option is not default value, prohibit to read\n       the file as a paletted image */\n    if (encoder->color_option != SIXEL_COLOR_OPTION_DEFAULT) {\n        fuse_palette = 0;\n    }\n\n    /* if scaling options are set, prohibit to read the file as\n       a paletted image */\n    if (encoder->percentwidth > 0 ||\n        encoder->percentheight > 0 ||\n        encoder->pixelwidth > 0 ||\n        encoder->pixelheight > 0) {\n        fuse_palette = 0;\n    }\n\nreload:\n    status = sixel_helper_load_image_file(filename,\n                                          encoder->fstatic,\n                                          fuse_palette,\n                                          encoder->reqcolors,\n                                          encoder->bgcolor,\n                                          encoder->loop_mode,\n                                          load_image_callback,\n                                          encoder->finsecure,\n                                          encoder->cancel_flag,\n                                          (void *)encoder,\n                                          encoder->allocator);\n    if (status != SIXEL_OK) {\n        goto end;\n    }\n\n    if (encoder->pipe_mode) {\n#if HAVE_CLEARERR\n        clearerr(stdin);\n#endif  /* HAVE_FSEEK */\n        while (encoder->cancel_flag && !*encoder->cancel_flag) {\n            status = sixel_tty_wait_stdin(1000000);\n            if (SIXEL_FAILED(status)) {\n                goto end;\n            }\n            if (status != SIXEL_OK) {\n                break;\n            }\n        }\n        if (!encoder->cancel_flag || !*encoder->cancel_flag) {\n            goto reload;\n        }\n    }\n\n    /* the status may not be SIXEL_OK */\n\nend:\n    sixel_encoder_unref(encoder);\n\n    return status;\n}\n\n\n/* encode specified pixel data to SIXEL format\n * output to encoder->outfd */\nSIXELAPI SIXELSTATUS\nsixel_encoder_encode_bytes(\n    sixel_encoder_t     /* in */    *encoder,\n    unsigned char       /* in */    *bytes,\n    int                 /* in */    width,\n    int                 /* in */    height,\n    int                 /* in */    pixelformat,\n    unsigned char       /* in */    *palette,\n    int                 /* in */    ncolors)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_frame_t *frame;\n\n    if (encoder == NULL || bytes == NULL) {\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    status = sixel_frame_new(&frame, encoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_frame_init(frame, bytes, width, height,\n                              pixelformat, palette, ncolors);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_encoder_encode_frame(encoder, frame, NULL);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n#if HAVE_TESTS\nstatic int\ntest1(void)\n{\n    int nret = EXIT_FAILURE;\n    sixel_encoder_t *encoder = NULL;\n\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    encoder = sixel_encoder_create();\n#  pragma GCC diagnostic pop\n    if (encoder == NULL) {\n        goto error;\n    }\n    sixel_encoder_ref(encoder);\n    sixel_encoder_unref(encoder);\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_encoder_unref(encoder);\n    return nret;\n}\n\n\nstatic int\ntest2(void)\n{\n    int nret = EXIT_FAILURE;\n    SIXELSTATUS status;\n    sixel_encoder_t *encoder = NULL;\n    sixel_frame_t *frame = NULL;\n    unsigned char *buffer;\n    int height = 0;\n    int is_animation = 0;\n\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    encoder = sixel_encoder_create();\n#  pragma GCC diagnostic pop\n    if (encoder == NULL) {\n        goto error;\n    }\n\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    frame = sixel_frame_create();\n#  pragma GCC diagnostic pop\n    if (encoder == NULL) {\n        goto error;\n    }\n\n    buffer = (unsigned char *)sixel_allocator_malloc(encoder->allocator, 3);\n    if (buffer == NULL) {\n        goto error;\n    }\n    status = sixel_frame_init(frame, buffer, 1, 1,\n                              SIXEL_PIXELFORMAT_RGB888,\n                              NULL, 0);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    if (sixel_frame_get_loop_no(frame) != 0 || sixel_frame_get_frame_no(frame) != 0) {\n        is_animation = 1;\n    }\n\n    height = sixel_frame_get_height(frame);\n\n    status = sixel_tty_scroll(sixel_write_callback, encoder->outfd, height, is_animation);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_encoder_unref(encoder);\n    sixel_frame_unref(frame);\n    return nret;\n}\n\n\nstatic int\ntest3(void)\n{\n    int nret = EXIT_FAILURE;\n    int result;\n\n    result = sixel_tty_wait_stdin(1000);\n    if (result != 0) {\n        goto error;\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    return nret;\n}\n\n\nstatic int\ntest4(void)\n{\n    int nret = EXIT_FAILURE;\n    sixel_encoder_t *encoder = NULL;\n    SIXELSTATUS status;\n\n# pragma GCC diagnostic push\n# pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    encoder = sixel_encoder_create();\n# pragma GCC diagnostic pop\n    if (encoder == NULL) {\n        goto error;\n    }\n\n    status = sixel_encoder_setopt(encoder,\n                                  SIXEL_OPTFLAG_LOOPMODE,\n                                  \"force\");\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    status = sixel_encoder_setopt(encoder,\n                                  SIXEL_OPTFLAG_PIPE_MODE,\n                                  \"force\");\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_encoder_unref(encoder);\n    return nret;\n}\n\n\nstatic int\ntest5(void)\n{\n    int nret = EXIT_FAILURE;\n    sixel_encoder_t *encoder = NULL;\n    sixel_allocator_t *allocator = NULL;\n    SIXELSTATUS status;\n\n    status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    status = sixel_encoder_new(&encoder, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    sixel_encoder_ref(encoder);\n    sixel_encoder_unref(encoder);\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_encoder_unref(encoder);\n    return nret;\n}\n\n\nSIXELAPI int\nsixel_encoder_tests_main(void)\n{\n    int nret = EXIT_FAILURE;\n    size_t i;\n    typedef int (* testcase)(void);\n\n    static testcase const testcases[] = {\n        test1,\n        test2,\n        test3,\n        test4,\n        test5\n    };\n\n    for (i = 0; i < sizeof(testcases) / sizeof(testcase); ++i) {\n        nret = testcases[i]();\n        if (nret != EXIT_SUCCESS) {\n            goto error;\n        }\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    return nret;\n}\n#endif  /* HAVE_TESTS */\n\n\n/* emacs Local Variables:      */\n/* emacs mode: c               */\n/* emacs tab-width: 4          */\n/* emacs indent-tabs-mode: nil */\n/* emacs c-basic-offset: 4     */\n/* emacs End:                  */\n/* vim: set expandtab ts=4 : */\n/* EOF */\n", "raw_code_before": "/*\n * Copyright (c) 2021 libsixel developers. See `AUTHORS`.\n * Copyright (c) 2014-2019 Hayaki Saito\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n# include <stdio.h>\n# include <stdlib.h>\n# include <stdarg.h>\n#include <string.h>\n# include <unistd.h>\n# include <sys/unistd.h>\n# include <sys/types.h>\n# include <time.h>\n# include <sys/time.h>\n# include <inttypes.h>\n# include <errno.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n\n#include <sixel.h>\n#include \"tty.h\"\n#include \"encoder.h\"\n#include \"rgblookup.h\"\n\n\nstatic char *\narg_strdup(\n    char const          /* in */ *s,          /* source buffer */\n    sixel_allocator_t   /* in */ *allocator)  /* allocator object for\n                                                 destination buffer */\n{\n    char *p;\n\n    p = (char *)sixel_allocator_malloc(allocator, strlen(s) + 1);\n    if (p) {\n        strcpy(p, s);\n    }\n    return p;\n}\n\n\n/* An clone function of XColorSpec() of xlib */\nstatic SIXELSTATUS\nsixel_parse_x_colorspec(\n    unsigned char       /* out */ **bgcolor,     /* destination buffer */\n    char const          /* in */  *s,            /* source buffer */\n    sixel_allocator_t   /* in */  *allocator)    /* allocator object for\n                                                    destination buffer */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    char *p;\n    unsigned char components[3];\n    int component_index = 0;\n    unsigned long v;\n    char *endptr;\n    char *buf = NULL;\n    struct color const *pcolor;\n\n    /* from rgb_lookup.h generated by gpref */\n    pcolor = lookup_rgb(s, strlen(s));\n    if (pcolor) {\n        *bgcolor = (unsigned char *)sixel_allocator_malloc(allocator, 3);\n        if (*bgcolor == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        (*bgcolor)[0] = pcolor->r;\n        (*bgcolor)[1] = pcolor->g;\n        (*bgcolor)[2] = pcolor->b;\n    } else if (s[0] == 'r' && s[1] == 'g' && s[2] == 'b' && s[3] == ':') {\n        p = buf = arg_strdup(s + 4, allocator);\n        if (buf == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        while (*p) {\n            v = 0;\n            for (endptr = p; endptr - p <= 12; ++endptr) {\n                if (*endptr >= '0' && *endptr <= '9') {\n                    v = (v << 4) | (unsigned long)(*endptr - '0');\n                } else if (*endptr >= 'a' && *endptr <= 'f') {\n                    v = (v << 4) | (unsigned long)(*endptr - 'a' + 10);\n                } else if (*endptr >= 'A' && *endptr <= 'F') {\n                    v = (v << 4) | (unsigned long)(*endptr - 'A' + 10);\n                } else {\n                    break;\n                }\n            }\n            if (endptr - p == 0) {\n                break;\n            }\n            if (endptr - p > 4) {\n                break;\n            }\n            v = v << ((4 - (endptr - p)) * 4) >> 8;\n            components[component_index++] = (unsigned char)v;\n            p = endptr;\n            if (component_index == 3) {\n                break;\n            }\n            if (*p == '\\0') {\n                break;\n            }\n            if (*p != '/') {\n                break;\n            }\n            ++p;\n        }\n        if (component_index != 3 || *p != '\\0' || *p == '/') {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        *bgcolor = (unsigned char *)sixel_allocator_malloc(allocator, 3);\n        if (*bgcolor == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        (*bgcolor)[0] = components[0];\n        (*bgcolor)[1] = components[1];\n        (*bgcolor)[2] = components[2];\n    } else if (*s == '#') {\n        buf = arg_strdup(s + 1, allocator);\n        if (buf == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        for (p = endptr = buf; endptr - p <= 12; ++endptr) {\n            if (*endptr >= '0' && *endptr <= '9') {\n                *endptr -= '0';\n            } else if (*endptr >= 'a' && *endptr <= 'f') {\n                *endptr -= 'a' - 10;\n            } else if (*endptr >= 'A' && *endptr <= 'F') {\n                *endptr -= 'A' - 10;\n            } else if (*endptr == '\\0') {\n                break;\n            } else {\n                status = SIXEL_BAD_ARGUMENT;\n                goto end;\n            }\n        }\n        if (endptr - p > 12) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        *bgcolor = (unsigned char *)sixel_allocator_malloc(allocator, 3);\n        if (*bgcolor == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_parse_x_colorspec: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        switch (endptr - p) {\n        case 3:\n            (*bgcolor)[0] = (unsigned char)(p[0] << 4);\n            (*bgcolor)[1] = (unsigned char)(p[1] << 4);\n            (*bgcolor)[2] = (unsigned char)(p[2] << 4);\n            break;\n        case 6:\n            (*bgcolor)[0] = (unsigned char)(p[0] << 4 | p[1]);\n            (*bgcolor)[1] = (unsigned char)(p[2] << 4 | p[3]);\n            (*bgcolor)[2] = (unsigned char)(p[4] << 4 | p[4]);\n            break;\n        case 9:\n            (*bgcolor)[0] = (unsigned char)(p[0] << 4 | p[1]);\n            (*bgcolor)[1] = (unsigned char)(p[3] << 4 | p[4]);\n            (*bgcolor)[2] = (unsigned char)(p[6] << 4 | p[7]);\n            break;\n        case 12:\n            (*bgcolor)[0] = (unsigned char)(p[0] << 4 | p[1]);\n            (*bgcolor)[1] = (unsigned char)(p[4] << 4 | p[5]);\n            (*bgcolor)[2] = (unsigned char)(p[8] << 4 | p[9]);\n            break;\n        default:\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n    } else {\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    sixel_allocator_free(allocator, buf);\n\n    return status;\n}\n\n\n/* generic writer function for passing to sixel_output_new() */\nstatic int\nsixel_write_callback(char *data, int size, void *priv)\n{\n    int result;\n\n#if defined(__MINGW64__)\n    result = write(*(int *)priv, data, (unsigned int)size);\n#else\n    result = write(*(int *)priv, data, (size_t)size);\n#endif\n\n    return result;\n}\n\n\n/* the writer function with hex-encoding for passing to sixel_output_new() */\nstatic int\nsixel_hex_write_callback(\n    char    /* in */ *data,\n    int     /* in */ size,\n    void    /* in */ *priv)\n{\n    char hex[SIXEL_OUTPUT_PACKET_SIZE * 2];\n    int i;\n    int j;\n    int result;\n\n    for (i = j = 0; i < size; ++i, ++j) {\n        hex[j] = (data[i] >> 4) & 0xf;\n        hex[j] += (hex[j] < 10 ? '0': ('a' - 10));\n        hex[++j] = data[i] & 0xf;\n        hex[j] += (hex[j] < 10 ? '0': ('a' - 10));\n    }\n\n#if defined(__MINGW64__)\n    result = write(*(int *)priv, hex, (unsigned int)(size * 2));\n#else\n    result = write(*(int *)priv, hex, (size_t)(size * 2));\n#endif\n\n    return result;\n}\n\n\n/* returns monochrome dithering context object */\nstatic SIXELSTATUS\nsixel_prepare_monochrome_palette(\n    sixel_dither_t  /* out */ **dither,\n     int            /* in */  finvert)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    if (finvert) {\n        *dither = sixel_dither_get(SIXEL_BUILTIN_MONO_LIGHT);\n    } else {\n        *dither = sixel_dither_get(SIXEL_BUILTIN_MONO_DARK);\n    }\n    if (*dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_prepare_monochrome_palette: sixel_dither_get() failed.\");\n        status = SIXEL_RUNTIME_ERROR;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* returns dithering context object with specified builtin palette */\nstatic SIXELSTATUS\nsixel_prepare_builtin_palette(\n    sixel_dither_t /* out */ **dither,\n    int            /* in */  builtin_palette)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    *dither = sixel_dither_get(builtin_palette);\n    if (*dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_prepare_builtin_palette: sixel_dither_get() failed.\");\n        status = SIXEL_RUNTIME_ERROR;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\ntypedef struct sixel_callback_context_for_mapfile {\n    int reqcolors;\n    sixel_dither_t *dither;\n    sixel_allocator_t *allocator;\n} sixel_callback_context_for_mapfile_t;\n\n\n/* callback function for sixel_helper_load_image_file() */\nstatic SIXELSTATUS\nload_image_callback_for_palette(\n    sixel_frame_t   /* in */    *frame, /* frame object from image loader */\n    void            /* in */    *data)  /* private data */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_callback_context_for_mapfile_t *callback_context;\n\n    /* get callback context object from the private data */\n    callback_context = (sixel_callback_context_for_mapfile_t *)data;\n\n    switch (sixel_frame_get_pixelformat(frame)) {\n    case SIXEL_PIXELFORMAT_PAL1:\n    case SIXEL_PIXELFORMAT_PAL2:\n    case SIXEL_PIXELFORMAT_PAL4:\n    case SIXEL_PIXELFORMAT_PAL8:\n        if (sixel_frame_get_palette(frame) == NULL) {\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        /* create new dither object */\n        status = sixel_dither_new(\n            &callback_context->dither,\n            sixel_frame_get_ncolors(frame),\n            callback_context->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        /* use palette which is extracted from the image */\n        sixel_dither_set_palette(callback_context->dither,\n                                 sixel_frame_get_palette(frame));\n        /* success */\n        status = SIXEL_OK;\n        break;\n    case SIXEL_PIXELFORMAT_G1:\n        /* use 1bpp grayscale builtin palette */\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n        /* success */\n        status = SIXEL_OK;\n        break;\n    case SIXEL_PIXELFORMAT_G2:\n        /* use 2bpp grayscale builtin palette */\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G2);\n        /* success */\n        status = SIXEL_OK;\n        break;\n    case SIXEL_PIXELFORMAT_G4:\n        /* use 4bpp grayscale builtin palette */\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G4);\n        /* success */\n        status = SIXEL_OK;\n        break;\n    case SIXEL_PIXELFORMAT_G8:\n        /* use 8bpp grayscale builtin palette */\n        callback_context->dither = sixel_dither_get(SIXEL_BUILTIN_G8);\n        /* success */\n        status = SIXEL_OK;\n        break;\n    default:\n        /* create new dither object */\n        status = sixel_dither_new(\n            &callback_context->dither,\n            callback_context->reqcolors,\n            callback_context->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        /* create adaptive palette from given frame object */\n        status = sixel_dither_initialize(callback_context->dither,\n                                         sixel_frame_get_pixels(frame),\n                                         sixel_frame_get_width(frame),\n                                         sixel_frame_get_height(frame),\n                                         sixel_frame_get_pixelformat(frame),\n                                         SIXEL_LARGE_NORM,\n                                         SIXEL_REP_CENTER_BOX,\n                                         SIXEL_QUALITY_HIGH);\n        if (SIXEL_FAILED(status)) {\n            sixel_dither_unref(callback_context->dither);\n            goto end;\n        }\n\n        /* success */\n        status = SIXEL_OK;\n\n        break;\n    }\n\nend:\n    return status;\n}\n\n\n/* create palette from specified map file */\nstatic SIXELSTATUS\nsixel_prepare_specified_palette(\n    sixel_dither_t  /* out */   **dither,\n    sixel_encoder_t /* in */    *encoder)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_callback_context_for_mapfile_t callback_context;\n\n    callback_context.reqcolors = encoder->reqcolors;\n    callback_context.dither = NULL;\n    callback_context.allocator = encoder->allocator;\n\n    status = sixel_helper_load_image_file(encoder->mapfile,\n                                          1,   /* fstatic */\n                                          1,   /* fuse_palette */\n                                          SIXEL_PALETTE_MAX, /* reqcolors */\n                                          encoder->bgcolor,\n                                          SIXEL_LOOP_DISABLE,\n                                          load_image_callback_for_palette,\n                                          encoder->finsecure,\n                                          encoder->cancel_flag,\n                                          &callback_context,\n                                          encoder->allocator);\n    if (status != SIXEL_OK) {\n        return status;\n    }\n\n    *dither = callback_context.dither;\n\n    return status;\n}\n\n\n/* create dither object from a frame */\nstatic SIXELSTATUS\nsixel_encoder_prepare_palette(\n    sixel_encoder_t *encoder,  /* encoder object */\n    sixel_frame_t   *frame,    /* input frame object */\n    sixel_dither_t  **dither)  /* dither object to be created from the frame */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int histogram_colors;\n\n    switch (encoder->color_option) {\n    case SIXEL_COLOR_OPTION_HIGHCOLOR:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_dither_new(dither, (-1), encoder->allocator);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MONOCHROME:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_monochrome_palette(dither, encoder->finvert);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MAPFILE:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_specified_palette(dither, encoder);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_BUILTIN:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_builtin_palette(dither, encoder->builtin_palette);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_DEFAULT:\n    default:\n        break;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_PALETTE) {\n        if (!sixel_frame_get_palette(frame)) {\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        status = sixel_dither_new(dither, sixel_frame_get_ncolors(frame),\n                                  encoder->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        sixel_dither_set_palette(*dither, sixel_frame_get_palette(frame));\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        if (sixel_frame_get_transparent(frame) != (-1)) {\n            sixel_dither_set_transparent(*dither, sixel_frame_get_transparent(frame));\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        goto end;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_GRAYSCALE) {\n        switch (sixel_frame_get_pixelformat(frame)) {\n        case SIXEL_PIXELFORMAT_G1:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n            break;\n        case SIXEL_PIXELFORMAT_G2:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G2);\n            break;\n        case SIXEL_PIXELFORMAT_G4:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G4);\n            break;\n        case SIXEL_PIXELFORMAT_G8:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G8);\n            break;\n        default:\n            *dither = NULL;\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        status = SIXEL_OK;\n        goto end;\n    }\n\n    if (encoder->dither_cache) {\n        sixel_dither_unref(encoder->dither_cache);\n    }\n    status = sixel_dither_new(dither, encoder->reqcolors, encoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_dither_initialize(*dither,\n                                     sixel_frame_get_pixels(frame),\n                                     sixel_frame_get_width(frame),\n                                     sixel_frame_get_height(frame),\n                                     sixel_frame_get_pixelformat(frame),\n                                     encoder->method_for_largest,\n                                     encoder->method_for_rep,\n                                     encoder->quality_mode);\n    if (SIXEL_FAILED(status)) {\n        sixel_dither_unref(*dither);\n        goto end;\n    }\n\n    histogram_colors = sixel_dither_get_num_of_histogram_colors(*dither);\n    if (histogram_colors <= encoder->reqcolors) {\n        encoder->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n    }\n    sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* resize a frame with settings of specified encoder object */\nstatic SIXELSTATUS\nsixel_encoder_do_resize(\n    sixel_encoder_t /* in */    *encoder,   /* encoder object */\n    sixel_frame_t   /* in */    *frame)     /* frame object to be resized */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int src_width;\n    int src_height;\n    int dst_width;\n    int dst_height;\n\n    /* get frame width and height */\n    src_width = sixel_frame_get_width(frame);\n    src_height = sixel_frame_get_height(frame);\n\n    /* settings around scaling */\n    dst_width = encoder->pixelwidth;    /* may be -1 (default) */\n    dst_height = encoder->pixelheight;  /* may be -1 (default) */\n\n    /* if the encoder has percentwidth or percentheight property,\n       convert them to pixelwidth / pixelheight */\n    if (encoder->percentwidth > 0) {\n        dst_width = src_width * encoder->percentwidth / 100;\n    }\n    if (encoder->percentheight > 0) {\n        dst_height = src_height * encoder->percentheight / 100;\n    }\n\n    /* if only either width or height is set, set also the other\n       to retain frame aspect ratio */\n    if (encoder->pixelwidth > 0 && dst_height <= 0) {\n        dst_height = src_height * encoder->pixelwidth / src_width;\n    }\n    if (encoder->pixelheight > 0 && dst_width <= 0) {\n        dst_width = src_width * encoder->pixelheight / src_height;\n    }\n\n    /* do resize */\n    if (dst_width > 0 && dst_height > 0) {\n        status = sixel_frame_resize(frame, dst_width, dst_height,\n                                    encoder->method_for_resampling);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    /* success */\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* clip a frame with settings of specified encoder object */\nstatic SIXELSTATUS\nsixel_encoder_do_clip(\n    sixel_encoder_t /* in */    *encoder,   /* encoder object */\n    sixel_frame_t   /* in */    *frame)     /* frame object to be resized */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int src_width;\n    int src_height;\n    int clip_x;\n    int clip_y;\n    int clip_w;\n    int clip_h;\n\n    /* get frame width and height */\n    src_width = sixel_frame_get_width(frame);\n    src_height = sixel_frame_get_height(frame);\n\n    /* settings around clipping */\n    clip_x = encoder->clipx;\n    clip_y = encoder->clipy;\n    clip_w = encoder->clipwidth;\n    clip_h = encoder->clipheight;\n\n    /* adjust clipping width with comparing it to frame width */\n    if (clip_w + clip_x > src_width) {\n        if (clip_x > src_width) {\n            clip_w = 0;\n        } else {\n            clip_w = src_width - clip_x;\n        }\n    }\n\n    /* adjust clipping height with comparing it to frame height */\n    if (clip_h + clip_y > src_height) {\n        if (clip_y > src_height) {\n            clip_h = 0;\n        } else {\n            clip_h = src_height - clip_y;\n        }\n    }\n\n    /* do clipping */\n    if (clip_w > 0 && clip_h > 0) {\n        status = sixel_frame_clip(frame, clip_x, clip_y, clip_w, clip_h);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    /* success */\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\nstatic void\nsixel_debug_print_palette(\n    sixel_dither_t /* in */ *dither /* dithering object */\n)\n{\n    unsigned char *palette;\n    int i;\n\n    palette = sixel_dither_get_palette(dither);\n    fprintf(stderr, \"palette:\\n\");\n    for (i = 0; i < sixel_dither_get_num_of_palette_colors(dither); ++i) {\n        fprintf(stderr, \"%d: #%02x%02x%02x\\n\", i,\n                palette[i * 3 + 1],\n                palette[i * 3 + 2],\n                palette[i * 3 + 3]);\n    }\n}\n\n\nstatic SIXELSTATUS\nsixel_encoder_output_without_macro(\n    sixel_frame_t       /* in */ *frame,\n    sixel_dither_t      /* in */ *dither,\n    sixel_output_t      /* in */ *output,\n    sixel_encoder_t     /* in */ *encoder)\n{\n    SIXELSTATUS status = SIXEL_OK;\n    static unsigned char *p;\n    int depth;\n    enum { message_buffer_size = 256 };\n    char message[message_buffer_size];\n    int nwrite;\n    int dulation;\n    int delay;\n    int lag = 0;\n    struct timespec tv;\n    clock_t start;\n    unsigned char *pixbuf;\n    int width;\n    int height;\n    int pixelformat;\n    size_t size;\n\n    if (encoder == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_encoder_output_without_macro: encoder object is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (encoder->color_option == SIXEL_COLOR_OPTION_DEFAULT) {\n        sixel_dither_set_optimize_palette(dither, 1);\n    }\n\n    pixelformat = sixel_frame_get_pixelformat(frame);\n    depth = sixel_helper_compute_depth(pixelformat);\n    if (depth < 0) {\n        status = SIXEL_LOGIC_ERROR;\n        nwrite = sprintf(message,\n                         \"sixel_encoder_output_without_macro: \"\n                         \"sixel_helper_compute_depth(%08x) failed.\",\n                         pixelformat);\n        if (nwrite > 0) {\n            sixel_helper_set_additional_message(message);\n        }\n        goto end;\n    }\n\n    width = sixel_frame_get_width(frame);\n    height = sixel_frame_get_height(frame);\n    size = (size_t)(width * height * depth);\n    p = (unsigned char *)sixel_allocator_malloc(encoder->allocator, size);\n    if (p == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_encoder_output_without_macro: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n    start = clock();\n    delay = sixel_frame_get_delay(frame);\n    if (delay > 0 && !encoder->fignore_delay) {\n        dulation = (int)((clock() - start) * 1000 * 1000 / CLOCKS_PER_SEC) - (int)lag;\n        lag = 0;\n        if (dulation < 10000 * delay) {\n            tv.tv_sec = 0;\n            tv.tv_nsec = (long)((10000 * delay - dulation) * 1000);\n            nanosleep(&tv, NULL);\n        } else {\n            lag = (int)(10000 * delay - dulation);\n        }\n    }\n\n    pixbuf = sixel_frame_get_pixels(frame);\n    memcpy(p, pixbuf, (size_t)(width * height * depth));\n\n    if (encoder->cancel_flag && *encoder->cancel_flag) {\n        goto end;\n    }\n\n    status = sixel_encode(p, width, height, depth, dither, output);\n    if (status != SIXEL_OK) {\n        goto end;\n    }\n\nend:\n    sixel_allocator_free(encoder->allocator, p);\n\n    return status;\n}\n\n\nstatic SIXELSTATUS\nsixel_encoder_output_with_macro(\n    sixel_frame_t   /* in */ *frame,\n    sixel_dither_t  /* in */ *dither,\n    sixel_output_t  /* in */ *output,\n    sixel_encoder_t /* in */ *encoder)\n{\n    SIXELSTATUS status = SIXEL_OK;\n    enum { message_buffer_size = 256 };\n    char buffer[message_buffer_size];\n    int nwrite;\n    int dulation;\n    int lag = 0;\n    struct timespec tv;\n    clock_t start;\n    unsigned char *pixbuf;\n    int width;\n    int height;\n    int delay;\n\n    start = clock();\n    if (sixel_frame_get_loop_no(frame) == 0) {\n        if (encoder->macro_number >= 0) {\n            nwrite = sprintf(buffer, \"\\033P%d;0;1!z\", encoder->macro_number);\n        } else {\n            nwrite = sprintf(buffer, \"\\033P%d;0;1!z\", sixel_frame_get_frame_no(frame));\n        }\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sprintf() failed.\");\n            goto end;\n        }\n        nwrite = sixel_write_callback(buffer, (int)strlen(buffer), &encoder->outfd);\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sixel_write_callback() failed.\");\n            goto end;\n        }\n\n        pixbuf = sixel_frame_get_pixels(frame),\n        width = sixel_frame_get_width(frame),\n        height = sixel_frame_get_height(frame),\n        status = sixel_encode(pixbuf, width, height, /* unused */ 3, dither, output);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        nwrite = sixel_write_callback(\"\\033\\\\\", 2, &encoder->outfd);\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sixel_write_callback() failed.\");\n            goto end;\n        }\n    }\n    if (encoder->macro_number < 0) {\n        nwrite = sprintf(buffer, \"\\033[%d*z\", sixel_frame_get_frame_no(frame));\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sprintf() failed.\");\n        }\n        nwrite = sixel_write_callback(buffer, (int)strlen(buffer), &encoder->outfd);\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_output_with_macro: sixel_write_callback() failed.\");\n            goto end;\n        }\n        delay = sixel_frame_get_delay(frame);\n        if (delay > 0 && !encoder->fignore_delay) {\n            dulation = (int)((clock() - start) * 1000 * 1000 / CLOCKS_PER_SEC) - (int)lag;\n            lag = 0;\n            if (dulation < 10000 * delay) {\n                tv.tv_sec = 0;\n                tv.tv_nsec = (long)((10000 * delay - dulation) * 1000);\n                nanosleep(&tv, NULL);\n            } else {\n                lag = (int)(10000 * delay - dulation);\n            }\n        }\n    }\n\nend:\n    return status;\n}\n\n\nstatic SIXELSTATUS\nsixel_encoder_encode_frame(\n    sixel_encoder_t *encoder,\n    sixel_frame_t   *frame,\n    sixel_output_t  *output)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_dither_t *dither = NULL;\n    int height;\n    int is_animation = 0;\n    int nwrite;\n\n    /* evaluate -w, -h, and -c option: crop/scale input source */\n    if (encoder->clipfirst) {\n        /* clipping */\n        status = sixel_encoder_do_clip(encoder, frame);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        /* scaling */\n        status = sixel_encoder_do_resize(encoder, frame);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    } else {\n        /* scaling */\n        status = sixel_encoder_do_resize(encoder, frame);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n\n        /* clipping */\n        status = sixel_encoder_do_clip(encoder, frame);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    /* prepare dither context */\n    status = sixel_encoder_prepare_palette(encoder, frame, &dither);\n    if (status != SIXEL_OK) {\n        goto end;\n    }\n\n    if (encoder->dither_cache != NULL) {\n        encoder->dither_cache = dither;\n        sixel_dither_ref(dither);\n    }\n\n    /* evaluate -v option: print palette */\n    if (encoder->verbose) {\n        if ((sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_PALETTE)) {\n            sixel_debug_print_palette(dither);\n        }\n    }\n\n    /* evaluate -d option: set method for diffusion */\n    sixel_dither_set_diffusion_type(dither, encoder->method_for_diffuse);\n\n    /* evaluate -C option: set complexion score */\n    if (encoder->complexion > 1) {\n        sixel_dither_set_complexion_score(dither, encoder->complexion);\n    }\n\n    if (output) {\n        sixel_output_ref(output);\n    } else {\n        /* create output context */\n        if (encoder->fuse_macro || encoder->macro_number >= 0) {\n            /* -u or -n option */\n            status = sixel_output_new(&output,\n                                      sixel_hex_write_callback,\n                                      &encoder->outfd,\n                                      encoder->allocator);\n        } else {\n            status = sixel_output_new(&output,\n                                      sixel_write_callback,\n                                      &encoder->outfd,\n                                      encoder->allocator);\n        }\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    sixel_output_set_8bit_availability(output, encoder->f8bit);\n    sixel_output_set_gri_arg_limit(output, encoder->has_gri_arg_limit);\n    sixel_output_set_palette_type(output, encoder->palette_type);\n    sixel_output_set_penetrate_multiplexer(\n        output, encoder->penetrate_multiplexer);\n    sixel_output_set_encode_policy(output, encoder->encode_policy);\n    sixel_output_set_ormode(output, encoder->ormode);\n\n    if (sixel_frame_get_multiframe(frame) && !encoder->fstatic) {\n        if (sixel_frame_get_loop_no(frame) != 0 || sixel_frame_get_frame_no(frame) != 0) {\n            is_animation = 1;\n        }\n        height = sixel_frame_get_height(frame);\n        (void) sixel_tty_scroll(sixel_write_callback, encoder->outfd, height, is_animation);\n    }\n\n    if (encoder->cancel_flag && *encoder->cancel_flag) {\n        status = SIXEL_INTERRUPTED;\n        goto end;\n    }\n\n    /* output sixel: junction of multi-frame processing strategy */\n    if (encoder->fuse_macro) {  /* -u option */\n        /* use macro */\n        status = sixel_encoder_output_with_macro(frame, dither, output, encoder);\n    } else if (encoder->macro_number >= 0) { /* -n option */\n        /* use macro */\n        status = sixel_encoder_output_with_macro(frame, dither, output, encoder);\n    } else {\n        /* do not use macro */\n        status = sixel_encoder_output_without_macro(frame, dither, output, encoder);\n    }\n\n    if (encoder->cancel_flag && *encoder->cancel_flag) {\n        nwrite = sixel_write_callback(\"\\x18\\033\\\\\", 3, &encoder->outfd);\n        if (nwrite < 0) {\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            sixel_helper_set_additional_message(\n                \"load_image_callback: sixel_write_callback() failed.\");\n            goto end;\n        }\n        status = SIXEL_INTERRUPTED;\n    }\n\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\nend:\n    if (output) {\n        sixel_output_unref(output);\n    }\n    if (dither) {\n        sixel_dither_unref(dither);\n    }\n\n    return status;\n}\n\n\n/* create encoder object */\nSIXELAPI SIXELSTATUS\nsixel_encoder_new(\n    sixel_encoder_t     /* out */ **ppencoder, /* encoder object to be created */\n    sixel_allocator_t   /* in */  *allocator)  /* allocator, null if you use\n                                                  default allocator */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    char const *env_default_bgcolor;\n    char const *env_default_ncolors;\n    int ncolors;\n\n    if (allocator == NULL) {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    *ppencoder\n        = (sixel_encoder_t *)sixel_allocator_malloc(allocator,\n                                                    sizeof(sixel_encoder_t));\n    if (*ppencoder == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_encoder_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        sixel_allocator_unref(allocator);\n        goto end;\n    }\n\n    (*ppencoder)->ref                   = 1;\n    (*ppencoder)->reqcolors             = (-1);\n    (*ppencoder)->mapfile               = NULL;\n    (*ppencoder)->color_option          = SIXEL_COLOR_OPTION_DEFAULT;\n    (*ppencoder)->builtin_palette       = 0;\n    (*ppencoder)->method_for_diffuse    = SIXEL_DIFFUSE_AUTO;\n    (*ppencoder)->method_for_largest    = SIXEL_LARGE_AUTO;\n    (*ppencoder)->method_for_rep        = SIXEL_REP_AUTO;\n    (*ppencoder)->quality_mode          = SIXEL_QUALITY_AUTO;\n    (*ppencoder)->method_for_resampling = SIXEL_RES_BILINEAR;\n    (*ppencoder)->loop_mode             = SIXEL_LOOP_AUTO;\n    (*ppencoder)->palette_type          = SIXEL_PALETTETYPE_AUTO;\n    (*ppencoder)->f8bit                 = 0;\n    (*ppencoder)->has_gri_arg_limit     = 0;\n    (*ppencoder)->finvert               = 0;\n    (*ppencoder)->fuse_macro            = 0;\n    (*ppencoder)->fignore_delay         = 0;\n    (*ppencoder)->complexion            = 1;\n    (*ppencoder)->fstatic               = 0;\n    (*ppencoder)->pixelwidth            = (-1);\n    (*ppencoder)->pixelheight           = (-1);\n    (*ppencoder)->percentwidth          = (-1);\n    (*ppencoder)->percentheight         = (-1);\n    (*ppencoder)->clipx                 = 0;\n    (*ppencoder)->clipy                 = 0;\n    (*ppencoder)->clipwidth             = 0;\n    (*ppencoder)->clipheight            = 0;\n    (*ppencoder)->clipfirst             = 0;\n    (*ppencoder)->macro_number          = (-1);\n    (*ppencoder)->verbose               = 0;\n    (*ppencoder)->penetrate_multiplexer = 0;\n    (*ppencoder)->encode_policy         = SIXEL_ENCODEPOLICY_AUTO;\n    (*ppencoder)->ormode                = 0;\n    (*ppencoder)->pipe_mode             = 0;\n    (*ppencoder)->bgcolor               = NULL;\n    (*ppencoder)->outfd                 = STDOUT_FILENO;\n    (*ppencoder)->finsecure             = 0;\n    (*ppencoder)->cancel_flag           = NULL;\n    (*ppencoder)->dither_cache          = NULL;\n    (*ppencoder)->allocator             = allocator;\n\n    /* evaluate environment variable ${SIXEL_BGCOLOR} */\n    env_default_bgcolor = getenv(\"SIXEL_BGCOLOR\");\n    if (env_default_bgcolor) {\n        status = sixel_parse_x_colorspec(&(*ppencoder)->bgcolor,\n                                         env_default_bgcolor,\n                                         allocator);\n        if (SIXEL_FAILED(status)) {\n            goto error;\n        }\n    }\n\n    /* evaluate environment variable ${SIXEL_COLORS} */\n    env_default_ncolors = getenv(\"SIXEL_COLORS\");\n    if (env_default_ncolors) {\n        ncolors = atoi(env_default_ncolors); /* may overflow */\n        if (ncolors > 1 && ncolors <= SIXEL_PALETTE_MAX) {\n            (*ppencoder)->reqcolors = ncolors;\n        }\n    }\n\n    /* success */\n    status = SIXEL_OK;\n\n    goto end;\n\nerror:\n    sixel_allocator_free(allocator, *ppencoder);\n    sixel_allocator_unref(allocator);\n    *ppencoder = NULL;\n\nend:\n    return status;\n}\n\n\n/* create encoder object (deprecated version) */\nSIXELAPI /* deprecated */ sixel_encoder_t *\nsixel_encoder_create(void)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_encoder_t *encoder = NULL;\n\n    status = sixel_encoder_new(&encoder, NULL);\n    if (SIXEL_FAILED(status)) {\n        return NULL;\n    }\n\n    return encoder;\n}\n\n\n/* destroy encoder object */\nstatic void\nsixel_encoder_destroy(sixel_encoder_t *encoder)\n{\n    sixel_allocator_t *allocator;\n\n    if (encoder) {\n        allocator = encoder->allocator;\n        sixel_allocator_free(allocator, encoder->mapfile);\n        sixel_allocator_free(allocator, encoder->bgcolor);\n        sixel_dither_unref(encoder->dither_cache);\n        if (encoder->outfd\n            && encoder->outfd != STDOUT_FILENO\n            && encoder->outfd != STDERR_FILENO) {\n            close(encoder->outfd);\n        }\n        sixel_allocator_free(allocator, encoder);\n        sixel_allocator_unref(allocator);\n    }\n}\n\n\n/* increase reference count of encoder object (thread-unsafe) */\nSIXELAPI void\nsixel_encoder_ref(sixel_encoder_t *encoder)\n{\n    /* TODO: be thread safe */\n    ++encoder->ref;\n}\n\n\n/* decrease reference count of encoder object (thread-unsafe) */\nSIXELAPI void\nsixel_encoder_unref(sixel_encoder_t *encoder)\n{\n    /* TODO: be thread safe */\n    if (encoder != NULL && --encoder->ref == 0) {\n        sixel_encoder_destroy(encoder);\n    }\n}\n\n\n/* set cancel state flag to encoder object */\nSIXELAPI SIXELSTATUS\nsixel_encoder_set_cancel_flag(\n    sixel_encoder_t /* in */ *encoder,\n    int             /* in */ *cancel_flag\n)\n{\n    SIXELSTATUS status = SIXEL_OK;\n\n    encoder->cancel_flag = cancel_flag;\n\n    return status;\n}\n\n\n/* set an option flag to encoder object */\nSIXELAPI SIXELSTATUS\nsixel_encoder_setopt(\n    sixel_encoder_t /* in */ *encoder,\n    int             /* in */ arg,\n    char const      /* in */ *value)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int number;\n    int parsed;\n    char unit[32];\n\n    sixel_encoder_ref(encoder);\n\n    switch(arg) {\n    case SIXEL_OPTFLAG_OUTFILE:  /* o */\n        if (*value == '\\0') {\n            sixel_helper_set_additional_message(\n                \"no file name specified.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (strcmp(value, \"-\") != 0) {\n            if (encoder->outfd && encoder->outfd != STDOUT_FILENO) {\n                close(encoder->outfd);\n            }\n            encoder->outfd = open(value,\n                                  O_RDWR|O_CREAT|O_TRUNC,\n                                  S_IRUSR|S_IWUSR);\n        }\n        break;\n    case SIXEL_OPTFLAG_7BIT_MODE:  /* 7 */\n        encoder->f8bit = 0;\n        break;\n    case SIXEL_OPTFLAG_8BIT_MODE:  /* 8 */\n        encoder->f8bit = 1;\n        break;\n    case SIXEL_OPTFLAG_HAS_GRI_ARG_LIMIT:  /* R */\n        encoder->has_gri_arg_limit = 1;\n        break;\n    case SIXEL_OPTFLAG_COLORS:  /* p */\n        encoder->reqcolors = atoi(value);\n        break;\n    case SIXEL_OPTFLAG_MAPFILE:  /* m */\n        if (encoder->mapfile) {\n            sixel_allocator_free(encoder->allocator, encoder->mapfile);\n        }\n        encoder->mapfile = arg_strdup(value, encoder->allocator);\n        if (encoder->mapfile == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_setopt: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        encoder->color_option = SIXEL_COLOR_OPTION_MAPFILE;\n        break;\n    case SIXEL_OPTFLAG_MONOCHROME:  /* e */\n        encoder->color_option = SIXEL_COLOR_OPTION_MONOCHROME;\n        break;\n    case SIXEL_OPTFLAG_HIGH_COLOR:  /* I */\n        encoder->color_option = SIXEL_COLOR_OPTION_HIGHCOLOR;\n        break;\n    case SIXEL_OPTFLAG_BUILTIN_PALETTE:  /* b */\n        if (strcmp(value, \"xterm16\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_XTERM16;\n        } else if (strcmp(value, \"xterm256\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_XTERM256;\n        } else if (strcmp(value, \"vt340mono\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_VT340_MONO;\n        } else if (strcmp(value, \"vt340color\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_VT340_COLOR;\n        } else if (strcmp(value, \"gray1\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_G1;\n        } else if (strcmp(value, \"gray2\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_G2;\n        } else if (strcmp(value, \"gray4\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_G4;\n        } else if (strcmp(value, \"gray8\") == 0) {\n            encoder->builtin_palette = SIXEL_BUILTIN_G8;\n        } else {\n            sixel_helper_set_additional_message(\n                    \"cannot parse builtin palette option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        encoder->color_option = SIXEL_COLOR_OPTION_BUILTIN;\n        break;\n    case SIXEL_OPTFLAG_DIFFUSION:  /* d */\n        /* parse --diffusion option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_AUTO;\n        } else if (strcmp(value, \"none\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n        } else if (strcmp(value, \"fs\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_FS;\n        } else if (strcmp(value, \"atkinson\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_ATKINSON;\n        } else if (strcmp(value, \"jajuni\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_JAJUNI;\n        } else if (strcmp(value, \"stucki\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_STUCKI;\n        } else if (strcmp(value, \"burkes\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_BURKES;\n        } else if (strcmp(value, \"a_dither\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_A_DITHER;\n        } else if (strcmp(value, \"x_dither\") == 0) {\n            encoder->method_for_diffuse = SIXEL_DIFFUSE_X_DITHER;\n        } else {\n            sixel_helper_set_additional_message(\n                \"specified diffusion method is not supported.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_FIND_LARGEST:  /* f */\n        /* parse --find-largest option */\n        if (value) {\n            if (strcmp(value, \"auto\") == 0) {\n                encoder->method_for_largest = SIXEL_LARGE_AUTO;\n            } else if (strcmp(value, \"norm\") == 0) {\n                encoder->method_for_largest = SIXEL_LARGE_NORM;\n            } else if (strcmp(value, \"lum\") == 0) {\n                encoder->method_for_largest = SIXEL_LARGE_LUM;\n            } else {\n                sixel_helper_set_additional_message(\n                    \"specified finding method is not supported.\");\n                status = SIXEL_BAD_ARGUMENT;\n                goto end;\n            }\n        }\n        break;\n    case SIXEL_OPTFLAG_SELECT_COLOR:  /* s */\n        /* parse --select-color option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->method_for_rep = SIXEL_REP_AUTO;\n        } else if (strcmp(value, \"center\") == 0) {\n            encoder->method_for_rep = SIXEL_REP_CENTER_BOX;\n        } else if (strcmp(value, \"average\") == 0) {\n            encoder->method_for_rep = SIXEL_REP_AVERAGE_COLORS;\n        } else if ((strcmp(value, \"histogram\") == 0) ||\n                   (strcmp(value, \"histgram\") == 0)) {\n            encoder->method_for_rep = SIXEL_REP_AVERAGE_PIXELS;\n        } else {\n            sixel_helper_set_additional_message(\n                \"specified finding method is not supported.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_CROP:  /* c */\n        number = sscanf(value, \"%dx%d+%d+%d\",\n                        &encoder->clipwidth, &encoder->clipheight,\n                        &encoder->clipx, &encoder->clipy);\n        if (number != 4) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (encoder->clipwidth <= 0 || encoder->clipheight <= 0) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (encoder->clipx < 0 || encoder->clipy < 0) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        encoder->clipfirst = 0;\n        break;\n    case SIXEL_OPTFLAG_WIDTH:  /* w */\n        parsed = sscanf(value, \"%d%2s\", &number, unit);\n        if (parsed == 2 && strcmp(unit, \"%\") == 0) {\n            encoder->pixelwidth = (-1);\n            encoder->percentwidth = number;\n        } else if (parsed == 1 || (parsed == 2 && strcmp(unit, \"px\") == 0)) {\n            encoder->pixelwidth = number;\n            encoder->percentwidth = (-1);\n        } else if (strcmp(value, \"auto\") == 0) {\n            encoder->pixelwidth = (-1);\n            encoder->percentwidth = (-1);\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse -w/--width option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (encoder->clipwidth) {\n            encoder->clipfirst = 1;\n        }\n        break;\n    case SIXEL_OPTFLAG_HEIGHT:  /* h */\n        parsed = sscanf(value, \"%d%2s\", &number, unit);\n        if (parsed == 2 && strcmp(unit, \"%\") == 0) {\n            encoder->pixelheight = (-1);\n            encoder->percentheight = number;\n        } else if (parsed == 1 || (parsed == 2 && strcmp(unit, \"px\") == 0)) {\n            encoder->pixelheight = number;\n            encoder->percentheight = (-1);\n        } else if (strcmp(value, \"auto\") == 0) {\n            encoder->pixelheight = (-1);\n            encoder->percentheight = (-1);\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse -h/--height option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        if (encoder->clipheight) {\n            encoder->clipfirst = 1;\n        }\n        break;\n    case SIXEL_OPTFLAG_RESAMPLING:  /* r */\n        /* parse --resampling option */\n        if (strcmp(value, \"nearest\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_NEAREST;\n        } else if (strcmp(value, \"gaussian\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_GAUSSIAN;\n        } else if (strcmp(value, \"hanning\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_HANNING;\n        } else if (strcmp(value, \"hamming\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_HAMMING;\n        } else if (strcmp(value, \"bilinear\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_BILINEAR;\n        } else if (strcmp(value, \"welsh\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_WELSH;\n        } else if (strcmp(value, \"bicubic\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_BICUBIC;\n        } else if (strcmp(value, \"lanczos2\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_LANCZOS2;\n        } else if (strcmp(value, \"lanczos3\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_LANCZOS3;\n        } else if (strcmp(value, \"lanczos4\") == 0) {\n            encoder->method_for_resampling = SIXEL_RES_LANCZOS4;\n        } else {\n            sixel_helper_set_additional_message(\n                \"specified desampling method is not supported.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_QUALITY:  /* q */\n        /* parse --quality option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->quality_mode = SIXEL_QUALITY_AUTO;\n        } else if (strcmp(value, \"high\") == 0) {\n            encoder->quality_mode = SIXEL_QUALITY_HIGH;\n        } else if (strcmp(value, \"low\") == 0) {\n            encoder->quality_mode = SIXEL_QUALITY_LOW;\n        } else if (strcmp(value, \"full\") == 0) {\n            encoder->quality_mode = SIXEL_QUALITY_FULL;\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse quality option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_LOOPMODE:  /* l */\n        /* parse --loop-control option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->loop_mode = SIXEL_LOOP_AUTO;\n        } else if (strcmp(value, \"force\") == 0) {\n            encoder->loop_mode = SIXEL_LOOP_FORCE;\n        } else if (strcmp(value, \"disable\") == 0) {\n            encoder->loop_mode = SIXEL_LOOP_DISABLE;\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse loop-control option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_PALETTE_TYPE:  /* t */\n        /* parse --palette-type option */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->palette_type = SIXEL_PALETTETYPE_AUTO;\n        } else if (strcmp(value, \"hls\") == 0) {\n            encoder->palette_type = SIXEL_PALETTETYPE_HLS;\n        } else if (strcmp(value, \"rgb\") == 0) {\n            encoder->palette_type = SIXEL_PALETTETYPE_RGB;\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse palette type option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_BGCOLOR:  /* B */\n        /* parse --bgcolor option */\n        if (encoder->bgcolor) {\n            sixel_allocator_free(encoder->allocator, encoder->bgcolor);\n        }\n        status = sixel_parse_x_colorspec(&encoder->bgcolor,\n                                         value,\n                                         encoder->allocator);\n        if (SIXEL_FAILED(status)) {\n            sixel_helper_set_additional_message(\n                \"cannot parse bgcolor option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_INSECURE:  /* k */\n        encoder->finsecure = 1;\n        break;\n    case SIXEL_OPTFLAG_INVERT:  /* i */\n        encoder->finvert = 1;\n        break;\n    case SIXEL_OPTFLAG_USE_MACRO:  /* u */\n        encoder->fuse_macro = 1;\n        break;\n    case SIXEL_OPTFLAG_MACRO_NUMBER:  /* n */\n        encoder->macro_number = atoi(value);\n        if (encoder->macro_number < 0) {\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_IGNORE_DELAY:  /* g */\n        encoder->fignore_delay = 1;\n        break;\n    case SIXEL_OPTFLAG_VERBOSE:  /* v */\n        encoder->verbose = 1;\n        break;\n    case SIXEL_OPTFLAG_STATIC:  /* S */\n        encoder->fstatic = 1;\n        break;\n    case SIXEL_OPTFLAG_PENETRATE:  /* P */\n        encoder->penetrate_multiplexer = 1;\n        break;\n    case SIXEL_OPTFLAG_ENCODE_POLICY:  /* E */\n        if (strcmp(value, \"auto\") == 0) {\n            encoder->encode_policy = SIXEL_ENCODEPOLICY_AUTO;\n        } else if (strcmp(value, \"fast\") == 0) {\n            encoder->encode_policy = SIXEL_ENCODEPOLICY_FAST;\n        } else if (strcmp(value, \"size\") == 0) {\n            encoder->encode_policy = SIXEL_ENCODEPOLICY_SIZE;\n        } else {\n            sixel_helper_set_additional_message(\n                \"cannot parse encode policy option.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_ORMODE:  /* O */\n        encoder->ormode = 1;\n        break;\n    case SIXEL_OPTFLAG_COMPLEXION_SCORE:  /* C */\n        encoder->complexion = atoi(value);\n        if (encoder->complexion < 1) {\n            sixel_helper_set_additional_message(\n                \"complexion parameter must be 1 or more.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        }\n        break;\n    case SIXEL_OPTFLAG_PIPE_MODE:  /* D */\n        encoder->pipe_mode = 1;\n        break;\n    case '?':  /* unknown option */\n    default:\n        /* exit if unknown options are specified */\n        sixel_helper_set_additional_message(\n            \"unknown option is specified.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    /* detects arguments conflictions */\n    if (encoder->reqcolors != (-1)) {\n        switch (encoder->color_option) {\n        case SIXEL_COLOR_OPTION_MAPFILE:\n            sixel_helper_set_additional_message(\n                \"option -p, --colors conflicts with -m, --mapfile.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        case SIXEL_COLOR_OPTION_MONOCHROME:\n            sixel_helper_set_additional_message(\n                \"option -e, --monochrome conflicts with -p, --colors.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        case SIXEL_COLOR_OPTION_HIGHCOLOR:\n            sixel_helper_set_additional_message(\n                \"option -p, --colors conflicts with -I, --high-color.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        case SIXEL_COLOR_OPTION_BUILTIN:\n            sixel_helper_set_additional_message(\n                \"option -p, --colors conflicts with -b, --builtin-palette.\");\n            status = SIXEL_BAD_ARGUMENT;\n            goto end;\n        default:\n            break;\n        }\n    }\n\n    /* 8bit output option(-8) conflicts width GNU Screen integration(-P) */\n    if (encoder->f8bit && encoder->penetrate_multiplexer) {\n        sixel_helper_set_additional_message(\n            \"option -8 --8bit-mode conflicts\"\n            \" with -P, --penetrate.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    sixel_encoder_unref(encoder);\n\n    return status;\n}\n\n\n/* called when image loader component load a image frame */\nstatic SIXELSTATUS\nload_image_callback(sixel_frame_t *frame, void *data)\n{\n    return sixel_encoder_encode_frame((sixel_encoder_t *)data, frame, NULL);\n}\n\n\n/* load source data from specified file and encode it to SIXEL format\n * output to encoder->outfd */\nSIXELAPI SIXELSTATUS\nsixel_encoder_encode(\n    sixel_encoder_t *encoder,   /* encoder object */\n    char const      *filename)  /* input filename */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int fuse_palette = 1;\n\n    if (encoder == NULL) {\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n        encoder = sixel_encoder_create();\n#  pragma GCC diagnostic pop\n        if (encoder == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_encoder_encode: sixel_encoder_create() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n    } else {\n        sixel_encoder_ref(encoder);\n    }\n\n    /* if required color is not set, set the max value */\n    if (encoder->reqcolors == (-1)) {\n        encoder->reqcolors = SIXEL_PALETTE_MAX;\n    }\n\n    /* if required color is less then 2, set the min value */\n    if (encoder->reqcolors < 2) {\n        encoder->reqcolors = SIXEL_PALETTE_MIN;\n    }\n\n    /* if color space option is not set, choose RGB color space */\n    if (encoder->palette_type == SIXEL_PALETTETYPE_AUTO) {\n        encoder->palette_type = SIXEL_PALETTETYPE_RGB;\n    }\n\n    /* if color option is not default value, prohibit to read\n       the file as a paletted image */\n    if (encoder->color_option != SIXEL_COLOR_OPTION_DEFAULT) {\n        fuse_palette = 0;\n    }\n\n    /* if scaling options are set, prohibit to read the file as\n       a paletted image */\n    if (encoder->percentwidth > 0 ||\n        encoder->percentheight > 0 ||\n        encoder->pixelwidth > 0 ||\n        encoder->pixelheight > 0) {\n        fuse_palette = 0;\n    }\n\nreload:\n    status = sixel_helper_load_image_file(filename,\n                                          encoder->fstatic,\n                                          fuse_palette,\n                                          encoder->reqcolors,\n                                          encoder->bgcolor,\n                                          encoder->loop_mode,\n                                          load_image_callback,\n                                          encoder->finsecure,\n                                          encoder->cancel_flag,\n                                          (void *)encoder,\n                                          encoder->allocator);\n    if (status != SIXEL_OK) {\n        goto end;\n    }\n\n    if (encoder->pipe_mode) {\n#if HAVE_CLEARERR\n        clearerr(stdin);\n#endif  /* HAVE_FSEEK */\n        while (encoder->cancel_flag && !*encoder->cancel_flag) {\n            status = sixel_tty_wait_stdin(1000000);\n            if (SIXEL_FAILED(status)) {\n                goto end;\n            }\n            if (status != SIXEL_OK) {\n                break;\n            }\n        }\n        if (!encoder->cancel_flag || !*encoder->cancel_flag) {\n            goto reload;\n        }\n    }\n\n    /* the status may not be SIXEL_OK */\n\nend:\n    sixel_encoder_unref(encoder);\n\n    return status;\n}\n\n\n/* encode specified pixel data to SIXEL format\n * output to encoder->outfd */\nSIXELAPI SIXELSTATUS\nsixel_encoder_encode_bytes(\n    sixel_encoder_t     /* in */    *encoder,\n    unsigned char       /* in */    *bytes,\n    int                 /* in */    width,\n    int                 /* in */    height,\n    int                 /* in */    pixelformat,\n    unsigned char       /* in */    *palette,\n    int                 /* in */    ncolors)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_frame_t *frame;\n\n    if (encoder == NULL || bytes == NULL) {\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    status = sixel_frame_new(&frame, encoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_frame_init(frame, bytes, width, height,\n                              pixelformat, palette, ncolors);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_encoder_encode_frame(encoder, frame, NULL);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n#if HAVE_TESTS\nstatic int\ntest1(void)\n{\n    int nret = EXIT_FAILURE;\n    sixel_encoder_t *encoder = NULL;\n\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    encoder = sixel_encoder_create();\n#  pragma GCC diagnostic pop\n    if (encoder == NULL) {\n        goto error;\n    }\n    sixel_encoder_ref(encoder);\n    sixel_encoder_unref(encoder);\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_encoder_unref(encoder);\n    return nret;\n}\n\n\nstatic int\ntest2(void)\n{\n    int nret = EXIT_FAILURE;\n    SIXELSTATUS status;\n    sixel_encoder_t *encoder = NULL;\n    sixel_frame_t *frame = NULL;\n    unsigned char *buffer;\n    int height = 0;\n    int is_animation = 0;\n\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    encoder = sixel_encoder_create();\n#  pragma GCC diagnostic pop\n    if (encoder == NULL) {\n        goto error;\n    }\n\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    frame = sixel_frame_create();\n#  pragma GCC diagnostic pop\n    if (encoder == NULL) {\n        goto error;\n    }\n\n    buffer = (unsigned char *)sixel_allocator_malloc(encoder->allocator, 3);\n    if (buffer == NULL) {\n        goto error;\n    }\n    status = sixel_frame_init(frame, buffer, 1, 1,\n                              SIXEL_PIXELFORMAT_RGB888,\n                              NULL, 0);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    if (sixel_frame_get_loop_no(frame) != 0 || sixel_frame_get_frame_no(frame) != 0) {\n        is_animation = 1;\n    }\n\n    height = sixel_frame_get_height(frame);\n\n    status = sixel_tty_scroll(sixel_write_callback, encoder->outfd, height, is_animation);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_encoder_unref(encoder);\n    sixel_frame_unref(frame);\n    return nret;\n}\n\n\nstatic int\ntest3(void)\n{\n    int nret = EXIT_FAILURE;\n    int result;\n\n    result = sixel_tty_wait_stdin(1000);\n    if (result != 0) {\n        goto error;\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    return nret;\n}\n\n\nstatic int\ntest4(void)\n{\n    int nret = EXIT_FAILURE;\n    sixel_encoder_t *encoder = NULL;\n    SIXELSTATUS status;\n\n# pragma GCC diagnostic push\n# pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    encoder = sixel_encoder_create();\n# pragma GCC diagnostic pop\n    if (encoder == NULL) {\n        goto error;\n    }\n\n    status = sixel_encoder_setopt(encoder,\n                                  SIXEL_OPTFLAG_LOOPMODE,\n                                  \"force\");\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    status = sixel_encoder_setopt(encoder,\n                                  SIXEL_OPTFLAG_PIPE_MODE,\n                                  \"force\");\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_encoder_unref(encoder);\n    return nret;\n}\n\n\nstatic int\ntest5(void)\n{\n    int nret = EXIT_FAILURE;\n    sixel_encoder_t *encoder = NULL;\n    sixel_allocator_t *allocator = NULL;\n    SIXELSTATUS status;\n\n    status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    status = sixel_encoder_new(&encoder, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    sixel_encoder_ref(encoder);\n    sixel_encoder_unref(encoder);\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_encoder_unref(encoder);\n    return nret;\n}\n\n\nSIXELAPI int\nsixel_encoder_tests_main(void)\n{\n    int nret = EXIT_FAILURE;\n    size_t i;\n    typedef int (* testcase)(void);\n\n    static testcase const testcases[] = {\n        test1,\n        test2,\n        test3,\n        test4,\n        test5\n    };\n\n    for (i = 0; i < sizeof(testcases) / sizeof(testcase); ++i) {\n        nret = testcases[i]();\n        if (nret != EXIT_SUCCESS) {\n            goto error;\n        }\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    return nret;\n}\n#endif  /* HAVE_TESTS */\n\n\n/* emacs Local Variables:      */\n/* emacs mode: c               */\n/* emacs tab-width: 4          */\n/* emacs indent-tabs-mode: nil */\n/* emacs c-basic-offset: 4     */\n/* emacs End:                  */\n/* vim: set expandtab ts=4 : */\n/* EOF */\n", "patch": "@@ -560,7 +560,6 @@ sixel_encoder_prepare_palette(\n                                      encoder->method_for_rep,\n                                      encoder->quality_mode);\n     if (SIXEL_FAILED(status)) {\n-        sixel_dither_unref(*dither);\n         goto end;\n     }\n "}
