{
  "calleeMethods": [["src/dither.c", "sixel_dither_set_method_for_largest", "sixel_dither_set_method_for_largest", "static void /* <=== sixel_dither_set_method_for_largest */ \nsixel_dither_set_method_for_largest(\n    sixel_dither_t  /* in */ *dither,\n    int             /* in */ method_for_largest)\n{\n    if (method_for_largest == SIXEL_LARGE_AUTO) {\n        method_for_largest = SIXEL_LARGE_NORM;\n    }\n    dither->method_for_largest = method_for_largest;\n}", 2], ["<empty>", "<operator>.lessEqualsThan", "<operator>.lessEqualsThan", "", 1], ["src/dither.c", "sixel_dither_unref", "sixel_dither_unref", "SIXELAPI void /* <=== sixel_dither_unref */ \nsixel_dither_unref(\n    sixel_dither_t  /* in */ *dither)\n{\n    /* TODO: be thread safe */\n    if (dither != NULL && --dither->ref == 0) {\n        sixel_dither_destroy(dither);\n    }\n}", 1], ["src/pixelformat.c", "sixel_helper_compute_depth", "sixel_helper_compute_depth", "SIXELAPI int /* <=== sixel_helper_compute_depth */ \nsixel_helper_compute_depth(int pixelformat)\n{\n    int depth = (-1);  /* unknown */\n\n    switch (pixelformat) {\n    case SIXEL_PIXELFORMAT_ARGB8888:\n    case SIXEL_PIXELFORMAT_RGBA8888:\n    case SIXEL_PIXELFORMAT_ABGR8888:\n    case SIXEL_PIXELFORMAT_BGRA8888:\n        depth = 4;\n        break;\n    case SIXEL_PIXELFORMAT_RGB888:\n    case SIXEL_PIXELFORMAT_BGR888:\n        depth = 3;\n        break;\n    case SIXEL_PIXELFORMAT_RGB555:\n    case SIXEL_PIXELFORMAT_RGB565:\n    case SIXEL_PIXELFORMAT_BGR555:\n    case SIXEL_PIXELFORMAT_BGR565:\n    case SIXEL_PIXELFORMAT_AG88:\n    case SIXEL_PIXELFORMAT_GA88:\n        depth = 2;\n        break;\n    case SIXEL_PIXELFORMAT_G1:\n    case SIXEL_PIXELFORMAT_G2:\n    case SIXEL_PIXELFORMAT_G4:\n    case SIXEL_PIXELFORMAT_G8:\n    case SIXEL_PIXELFORMAT_PAL1:\n    case SIXEL_PIXELFORMAT_PAL2:\n    case SIXEL_PIXELFORMAT_PAL4:\n    case SIXEL_PIXELFORMAT_PAL8:\n        depth = 1;\n        break;\n    default:\n        break;\n    }\n\n    return depth;\n}", 3], ["src/frame.c", "sixel_frame_get_pixels", "sixel_frame_get_pixels", "SIXELAPI unsigned char * /* <=== sixel_frame_get_pixels */ \nsixel_frame_get_pixels(sixel_frame_t /* in */ *frame)  /* frame object */\n{\n    return frame->pixels;\n}", 1], ["src/allocator.c", "sixel_allocator_malloc", "sixel_allocator_malloc", "SIXELAPI void * /* <=== sixel_allocator_malloc */ \nsixel_allocator_malloc(\n    sixel_allocator_t   /* in */ *allocator,  /* allocator object */\n    size_t              /* in */ n)           /* allocation size */\n{\n    /* precondition */\n    assert(allocator);\n    assert(allocator->fn_malloc);\n\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n\n    return allocator->fn_malloc(n);\n}", 2], ["<empty>", "SIXEL_FAILED", "SIXEL_FAILED", "", 1], ["src/frame.c", "sixel_frame_get_width", "sixel_frame_get_width", "SIXELAPI int /* <=== sixel_frame_get_width */ \nsixel_frame_get_width(sixel_frame_t /* in */ *frame)  /* frame object */\n{\n    return frame->width;\n}", 1], ["src/quant.c", "quant_trace", "quant_trace", "static inline void quant_trace(FILE *f, ...) { (void) f; } /* <=== quant_trace */ ", 3], ["src/allocator.c", "sixel_allocator_free", "sixel_allocator_free", "SIXELAPI void /* <=== sixel_allocator_free */ \nsixel_allocator_free(\n    sixel_allocator_t   /* in */ *allocator,  /* allocator object */\n    void                /* in */ *p)          /* existing buffer to be freed */\n{\n    /* precondition */\n    assert(allocator);\n    assert(allocator->fn_free);\n\n    allocator->fn_free(p);\n}", 3], ["src/quant.c", "computeColorMapFromInput", "computeColorMapFromInput", "static int /* <=== computeColorMapFromInput */ \ncomputeColorMapFromInput(unsigned char const *data,\n                         unsigned int const length,\n                         unsigned int const depth,\n                         unsigned int const reqColors,\n                         int const methodForLargest,\n                         int const methodForRep,\n                         int const qualityMode,\n                         tupletable2 * const colormapP,\n                         unsigned int *origcolors,\n                         sixel_allocator_t *allocator)\n{\n/*----------------------------------------------------------------------------\n   Produce a colormap containing the best colors to represent the\n   image stream in file 'ifP'.  Figure it out using the median cut\n   technique.\n\n   The colormap will have 'reqcolors' or fewer colors in it, unless\n   'allcolors' is true, in which case it will have all the colors that\n   are in the input.\n\n   The colormap has the same maxval as the input.\n\n   Put the colormap in newly allocated storage as a tupletable2\n   and return its address as *colormapP.  Return the number of colors in\n   it as *colorsP and its maxval as *colormapMaxvalP.\n\n   Return the characteristics of the input file as\n   *formatP and *freqPamP.  (This information is not really\n   relevant to our colormap mission; just a fringe benefit).\n-----------------------------------------------------------------------------*/\n    SIXELSTATUS status = SIXEL_FALSE;\n    tupletable2 colorfreqtable = {0, NULL};\n    unsigned int i;\n    unsigned int n;\n\n    status = computeHistogram(data, length, depth,\n                              &colorfreqtable, qualityMode, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n    if (origcolors) {\n        *origcolors = colorfreqtable.size;\n    }\n\n    if (colorfreqtable.size <= reqColors) {\n        quant_trace(stderr,\n                    \"Image already has few enough colors (<=%d).  \"\n                    \"Keeping same colors.\\n\", reqColors);\n        /* *colormapP = colorfreqtable; */\n        colormapP->size = colorfreqtable.size;\n        status = alloctupletable(&colormapP->table, depth, colorfreqtable.size, allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        for (i = 0; i < colorfreqtable.size; ++i) {\n            colormapP->table[i]->value = colorfreqtable.table[i]->value;\n            for (n = 0; n < depth; ++n) {\n                colormapP->table[i]->tuple[n] = colorfreqtable.table[i]->tuple[n];\n            }\n        }\n    } else {\n        quant_trace(stderr, \"choosing %d colors...\\n\", reqColors);\n        status = mediancut(colorfreqtable, depth, reqColors,\n                           methodForLargest, methodForRep, colormapP, allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        quant_trace(stderr, \"%d colors are choosed.\\n\", colorfreqtable.size);\n    }\n\n    status = SIXEL_OK;\n\nend:\n    sixel_allocator_free(allocator, colorfreqtable.table);\n    return status;\n}", 3], ["src/dither.c", "sixel_dither_new", "sixel_dither_new", "sixel_dither_new( /* <=== sixel_dither_new */ \n    sixel_dither_t    /* out */ **ppdither, /* dither object to be created */\n    int               /* in */  ncolors,    /* required colors */\n    sixel_allocator_t /* in */  *allocator) /* allocator, null if you use\n                                               default allocator */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    size_t headsize;\n    size_t datasize;\n    size_t wholesize;\n    int quality_mode;\n\n    /* ensure given pointer is not null */\n    if (ppdither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: ppdither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (allocator == NULL) {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            *ppdither = NULL;\n            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = SIXEL_PALETTE_MAX;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            status = SIXEL_BAD_INPUT;\n            goto end;\n        } else if (ncolors < 1) {\n            status = SIXEL_BAD_INPUT;\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: palette colors must be more than 0\");\n            goto end;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    (*ppdither)->ref = 1;\n    (*ppdither)->palette = (unsigned char*)(*ppdither + 1);\n    (*ppdither)->cachetable = NULL;\n    (*ppdither)->reqcolors = ncolors;\n    (*ppdither)->ncolors = ncolors;\n    (*ppdither)->origcolors = (-1);\n    (*ppdither)->keycolor = (-1);\n    (*ppdither)->optimized = 0;\n    (*ppdither)->optimize_palette = 0;\n    (*ppdither)->complexion = 1;\n    (*ppdither)->bodyonly = 0;\n    (*ppdither)->method_for_largest = SIXEL_LARGE_NORM;\n    (*ppdither)->method_for_rep = SIXEL_REP_CENTER_BOX;\n    (*ppdither)->method_for_diffuse = SIXEL_DIFFUSE_FS;\n    (*ppdither)->quality_mode = quality_mode;\n    (*ppdither)->pixelformat = SIXEL_PIXELFORMAT_RGB888;\n    (*ppdither)->allocator = allocator;\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}", 1], ["src/dither.c", "sixel_dither_initialize", "sixel_dither_initialize", "sixel_dither_initialize( /* <=== sixel_dither_initialize */ \n    sixel_dither_t  /* in */ *dither,\n    unsigned char   /* in */ *data,\n    int             /* in */ width,\n    int             /* in */ height,\n    int             /* in */ pixelformat,\n    int             /* in */ method_for_largest,\n    int             /* in */ method_for_rep,\n    int             /* in */ quality_mode)\n{\n    unsigned char *buf = NULL;\n    unsigned char *normalized_pixels = NULL;\n    unsigned char *input_pixels;\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    /* ensure dither object is not null */\n    if (dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: dither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    /* increment ref count */\n    sixel_dither_ref(dither);\n\n    sixel_dither_set_pixelformat(dither, pixelformat);\n\n    switch (pixelformat) {\n    case SIXEL_PIXELFORMAT_RGB888:\n        input_pixels = data;\n        break;\n    default:\n        /* normalize pixelformat */\n        normalized_pixels\n            = (unsigned char *)sixel_allocator_malloc(dither->allocator, (size_t)(width * height * 3));\n        if (normalized_pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_dither_initialize: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n\n        status = sixel_helper_normalize_pixelformat(\n            normalized_pixels,\n            &pixelformat,\n            data,\n            pixelformat,\n            width,\n            height);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        input_pixels = normalized_pixels;\n        break;\n    }\n\n    sixel_dither_set_method_for_largest(dither, method_for_largest);\n    sixel_dither_set_method_for_rep(dither, method_for_rep);\n    sixel_dither_set_quality_mode(dither, quality_mode);\n\n    status = sixel_quant_make_palette(&buf,\n                                      input_pixels,\n                                      (unsigned int)(width * height * 3),\n                                      SIXEL_PIXELFORMAT_RGB888,\n                                      (unsigned int)dither->reqcolors,\n                                      (unsigned int *)&dither->ncolors,\n                                      (unsigned int *)&dither->origcolors,\n                                      dither->method_for_largest,\n                                      dither->method_for_rep,\n                                      dither->quality_mode,\n                                      dither->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n    memcpy(dither->palette, buf, (size_t)(dither->ncolors * 3));\n\n    dither->optimized = 1;\n    if (dither->origcolors <= dither->ncolors) {\n        dither->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n    }\n\n    sixel_quant_free_palette(buf, dither->allocator);\n    status = SIXEL_OK;\n\nend:\n    free(normalized_pixels);\n\n    /* decrement ref count */\n    sixel_dither_unref(dither);\n\n    return status;\n}", 1], ["src/dither.c", "sixel_dither_set_pixelformat", "sixel_dither_set_pixelformat", "SIXELAPI void /* <=== sixel_dither_set_pixelformat */ \nsixel_dither_set_pixelformat(\n    sixel_dither_t /* in */ *dither,     /* dither context object */\n    int            /* in */ pixelformat) /* one of enum pixelFormat */\n{\n    dither->pixelformat = pixelformat;\n}", 1], ["src/dither.c", "sixel_dither_ref", "sixel_dither_ref", "SIXELAPI void /* <=== sixel_dither_ref */ \nsixel_dither_ref(\n    sixel_dither_t  /* in */ *dither)\n{\n    /* TODO: be thread safe */\n    ++dither->ref;\n}", 2], ["src/pixelformat.c", "sixel_helper_normalize_pixelformat", "sixel_helper_normalize_pixelformat", "sixel_helper_normalize_pixelformat( /* <=== sixel_helper_normalize_pixelformat */ \n    unsigned char       /* out */ *dst,             /* destination buffer */\n    int                 /* out */ *dst_pixelformat, /* converted pixelformat */\n    unsigned char const /* in */  *src,             /* source pixels */\n    int                 /* in */  src_pixelformat,  /* format of source image */\n    int                 /* in */  width,            /* width of source image */\n    int                 /* in */  height)           /* height of source image */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    switch (src_pixelformat) {\n    case SIXEL_PIXELFORMAT_G8:\n        expand_rgb(dst, src, width, height, src_pixelformat, 1);\n        *dst_pixelformat = SIXEL_PIXELFORMAT_RGB888;\n        break;\n    case SIXEL_PIXELFORMAT_RGB565:\n    case SIXEL_PIXELFORMAT_RGB555:\n    case SIXEL_PIXELFORMAT_BGR565:\n    case SIXEL_PIXELFORMAT_BGR555:\n    case SIXEL_PIXELFORMAT_GA88:\n    case SIXEL_PIXELFORMAT_AG88:\n        expand_rgb(dst, src, width, height, src_pixelformat, 2);\n        *dst_pixelformat = SIXEL_PIXELFORMAT_RGB888;\n        break;\n    case SIXEL_PIXELFORMAT_RGB888:\n    case SIXEL_PIXELFORMAT_BGR888:\n        expand_rgb(dst, src, width, height, src_pixelformat, 3);\n        *dst_pixelformat = SIXEL_PIXELFORMAT_RGB888;\n        break;\n    case SIXEL_PIXELFORMAT_RGBA8888:\n    case SIXEL_PIXELFORMAT_ARGB8888:\n    case SIXEL_PIXELFORMAT_BGRA8888:\n    case SIXEL_PIXELFORMAT_ABGR8888:\n        expand_rgb(dst, src, width, height, src_pixelformat, 4);\n        *dst_pixelformat = SIXEL_PIXELFORMAT_RGB888;\n        break;\n    case SIXEL_PIXELFORMAT_PAL1:\n    case SIXEL_PIXELFORMAT_PAL2:\n    case SIXEL_PIXELFORMAT_PAL4:\n        *dst_pixelformat = SIXEL_PIXELFORMAT_PAL8;\n        status = expand_palette(dst, src, width, height, src_pixelformat);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        break;\n    case SIXEL_PIXELFORMAT_G1:\n    case SIXEL_PIXELFORMAT_G2:\n    case SIXEL_PIXELFORMAT_G4:\n        *dst_pixelformat = SIXEL_PIXELFORMAT_G8;\n        status = expand_palette(dst, src, width, height, src_pixelformat);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        break;\n    case SIXEL_PIXELFORMAT_PAL8:\n        memcpy(dst, src, (size_t)(width * height));\n        *dst_pixelformat = src_pixelformat;\n        break;\n    default:\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}", 2], ["src/status.c", "sixel_helper_set_additional_message", "sixel_helper_set_additional_message", "SIXELAPI void /* <=== sixel_helper_set_additional_message */ \nsixel_helper_set_additional_message(\n    const char      /* in */  *message         /* error message */\n)\n{\n    size_t len;\n\n    if (message == 0)\n        return;\n    len = strlen(message);\n    memcpy(g_buffer, message, len < sizeof(g_buffer) ? len: sizeof(g_buffer) - 1);\n    g_buffer[sizeof(g_buffer) - 1] = 0;\n}", 2], ["src/dither.c", "sixel_dither_get_num_of_histogram_colors", "sixel_dither_get_num_of_histogram_colors", "SIXELAPI int /* <=== sixel_dither_get_num_of_histogram_colors */ \nsixel_dither_get_num_of_histogram_colors(\n    sixel_dither_t /* in */ *dither)  /* dither context object */\n{\n    return dither->origcolors;\n}", 1], ["src/allocator.c", "sixel_allocator_unref", "sixel_allocator_unref", "SIXELAPI void /* <=== sixel_allocator_unref */ \nsixel_allocator_unref(\n    sixel_allocator_t /* in */ *allocator)  /* allocator object to be unreference */\n{\n    /* TODO: be thread safe */\n    if (allocator) {\n        assert(allocator->ref > 0);\n        --allocator->ref;\n        if (allocator->ref == 0) {\n            sixel_allocator_destroy(allocator);\n        }\n    }\n}", 2], ["src/allocator.c", "sixel_allocator_ref", "sixel_allocator_ref", "SIXELAPI void /* <=== sixel_allocator_ref */ \nsixel_allocator_ref(\n    sixel_allocator_t /* in */ *allocator)  /* allocator object to be\n                                               increment reference counter */\n{\n    /* precondition */\n    assert(allocator);\n\n    /* TODO: be thread safe */\n    ++allocator->ref;\n}", 2], ["src/quant.c", "sixel_quant_make_palette", "sixel_quant_make_palette", "SIXELSTATUS /* <=== sixel_quant_make_palette */ \nsixel_quant_make_palette(\n    unsigned char          /* out */ **result,\n    unsigned char const    /* in */  *data,\n    unsigned int           /* in */  length,\n    int                    /* in */  pixelformat,\n    unsigned int           /* in */  reqcolors,\n    unsigned int           /* in */  *ncolors,\n    unsigned int           /* in */  *origcolors,\n    int                    /* in */  methodForLargest,\n    int                    /* in */  methodForRep,\n    int                    /* in */  qualityMode,\n    sixel_allocator_t      /* in */  *allocator)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned int i;\n    unsigned int n;\n    int ret;\n    tupletable2 colormap;\n    unsigned int depth;\n    int result_depth;\n\n    result_depth = sixel_helper_compute_depth(pixelformat);\n    if (result_depth <= 0) {\n        *result = NULL;\n        goto end;\n    }\n\n    depth = (unsigned int)result_depth;\n\n    ret = computeColorMapFromInput(data, length, depth,\n                                   reqcolors, methodForLargest,\n                                   methodForRep, qualityMode,\n                                   &colormap, origcolors, allocator);\n    if (ret != 0) {\n        *result = NULL;\n        goto end;\n    }\n    *ncolors = colormap.size;\n    quant_trace(stderr, \"tupletable size: %d\\n\", *ncolors);\n    *result = (unsigned char *)sixel_allocator_malloc(allocator, *ncolors * depth);\n    for (i = 0; i < *ncolors; i++) {\n        for (n = 0; n < depth; ++n) {\n            (*result)[i * depth + n] = colormap.table[i]->tuple[n];\n        }\n    }\n\n    sixel_allocator_free(allocator, colormap.table);\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}", 2], ["src/dither.c", "sixel_dither_set_quality_mode", "sixel_dither_set_quality_mode", "static void /* <=== sixel_dither_set_quality_mode */ \nsixel_dither_set_quality_mode(\n    sixel_dither_t  /* in */  *dither,\n    int             /* in */  quality_mode)\n{\n    if (quality_mode == SIXEL_QUALITY_AUTO) {\n        if (dither->ncolors <= 8) {\n            quality_mode = SIXEL_QUALITY_HIGH;\n        } else {\n            quality_mode = SIXEL_QUALITY_LOW;\n        }\n    }\n    dither->quality_mode = quality_mode;\n}", 2], ["src/frame.c", "sixel_frame_get_height", "sixel_frame_get_height", "SIXELAPI int /* <=== sixel_frame_get_height */ \nsixel_frame_get_height(sixel_frame_t /* in */ *frame)  /* frame object */\n{\n    return frame->height;\n}", 1], ["src/allocator.c", "sixel_allocator_new", "sixel_allocator_new", "SIXELSTATUS /* <=== sixel_allocator_new */ \nsixel_allocator_new(\n    sixel_allocator_t   /* out */ **ppallocator,  /* allocator object to be created */\n    sixel_malloc_t      /* in */  fn_malloc,      /* custom malloc() function */\n    sixel_calloc_t      /* in */  fn_calloc,      /* custom calloc() function */\n    sixel_realloc_t     /* in */  fn_realloc,     /* custom realloc() function */\n    sixel_free_t        /* in */  fn_free)        /* custom free() function */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    if (ppallocator == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_new: given argument ppallocator is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (fn_malloc == NULL) {\n        fn_malloc = malloc;\n    }\n\n    if (fn_calloc == NULL) {\n        fn_calloc = calloc;\n    }\n\n    if (fn_realloc == NULL) {\n        fn_realloc = realloc;\n    }\n\n    if (fn_free == NULL) {\n        fn_free = free;\n    }\n\n    *ppallocator = fn_malloc(sizeof(sixel_allocator_t));\n    if (*ppallocator == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_new: fn_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    (*ppallocator)->ref         = 1;\n    (*ppallocator)->fn_malloc   = fn_malloc;\n    (*ppallocator)->fn_calloc   = fn_calloc;\n    (*ppallocator)->fn_realloc  = fn_realloc;\n    (*ppallocator)->fn_free     = fn_free;\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}", 2], ["src/frame.c", "sixel_frame_get_pixelformat", "sixel_frame_get_pixelformat", "SIXELAPI int /* <=== sixel_frame_get_pixelformat */ \nsixel_frame_get_pixelformat(sixel_frame_t /* in */ *frame)  /* frame object */\n{\n    return frame->pixelformat;\n}", 1], ["<empty>", "<operator>.and", "<operator>.and", "", 1], ["<empty>", "<operator>.assignment", "<operator>.assignment", "", 1], ["src/dither.c", "sixel_dither_set_method_for_rep", "sixel_dither_set_method_for_rep", "static void /* <=== sixel_dither_set_method_for_rep */ \nsixel_dither_set_method_for_rep(\n    sixel_dither_t  /* in */ *dither,\n    int             /* in */ method_for_rep)\n{\n    if (method_for_rep == SIXEL_REP_AUTO) {\n        method_for_rep = SIXEL_REP_CENTER_BOX;\n    }\n    dither->method_for_rep = method_for_rep;\n}", 2], ["<empty>", "<operator>.indirection", "<operator>.indirection", "", 1], ["src/allocator.c", "sixel_allocator_destroy", "sixel_allocator_destroy", "static void /* <=== sixel_allocator_destroy */ \nsixel_allocator_destroy(\n    sixel_allocator_t /* in */ *allocator)  /* allocator object to\n                                               be destroyed */\n{\n    /* precondition */\n    assert(allocator);\n    assert(allocator->fn_free);\n\n    allocator->fn_free(allocator);\n}", 3], ["<empty>", "<operator>.indirectFieldAccess", "<operator>.indirectFieldAccess", "", 1], ["src/pixelformat.c", "expand_rgb", "expand_rgb", "static void /* <=== expand_rgb */ \nexpand_rgb(unsigned char *dst,\n           unsigned char const *src,\n           int width, int height,\n           int pixelformat, int depth)\n{\n    int x;\n    int y;\n    int dst_offset;\n    int src_offset;\n    unsigned char r, g, b;\n\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++) {\n            src_offset = depth * (y * width + x);\n            dst_offset = 3 * (y * width + x);\n            get_rgb(src + src_offset, pixelformat, depth, &r, &g, &b);\n\n            *(dst + dst_offset + 0) = r;\n            *(dst + dst_offset + 1) = g;\n            *(dst + dst_offset + 2) = b;\n        }\n    }\n}", 3], ["src/dither.c", "sixel_dither_destroy", "sixel_dither_destroy", "SIXELAPI void /* <=== sixel_dither_destroy */ \nsixel_dither_destroy(\n    sixel_dither_t  /* in */ *dither)\n{\n    sixel_allocator_t *allocator;\n\n    if (dither) {\n        allocator = dither->allocator;\n        sixel_allocator_free(allocator, dither->cachetable);\n        dither->cachetable = NULL;\n        sixel_allocator_free(allocator, dither);\n        sixel_allocator_unref(allocator);\n    }\n}", 2], ["src/pixelformat.c", "expand_palette", "expand_palette", "static SIXELSTATUS /* <=== expand_palette */ \nexpand_palette(unsigned char *dst, unsigned char const *src,\n               int width, int height, int const pixelformat)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int x;\n    int y;\n    int i;\n    int bpp;  /* bit per plane */\n\n    switch (pixelformat) {\n    case SIXEL_PIXELFORMAT_PAL1:\n    case SIXEL_PIXELFORMAT_G1:\n        bpp = 1;\n        break;\n    case SIXEL_PIXELFORMAT_PAL2:\n    case SIXEL_PIXELFORMAT_G2:\n        bpp = 2;\n        break;\n    case SIXEL_PIXELFORMAT_PAL4:\n    case SIXEL_PIXELFORMAT_G4:\n        bpp = 4;\n        break;\n    case SIXEL_PIXELFORMAT_PAL8:\n    case SIXEL_PIXELFORMAT_G8:\n        for (i = 0; i < width * height; ++i, ++src) {\n            *dst++ = *src;\n        }\n        status = SIXEL_OK;\n        goto end;\n    default:\n        status = SIXEL_BAD_ARGUMENT;\n        sixel_helper_set_additional_message(\n            \"expand_palette: invalid pixelformat.\");\n        goto end;\n    }\n\n#if HAVE_DEBUG\n    fprintf(stderr, \"expanding PAL%d to PAL8...\\n\", bpp);\n#endif\n\n    for (y = 0; y < height; ++y) {\n        for (x = 0; x < width * bpp / 8; ++x) {\n            for (i = 0; i < 8 / bpp; ++i) {\n                *dst++ = *src >> (8 / bpp - 1 - i) * bpp & ((1 << bpp) - 1);\n            }\n            src++;\n        }\n        x = width - x * 8 / bpp;\n        if (x > 0) {\n            for (i = 0; i < x; ++i) {\n                *dst++ = *src >> (8 - (i + 1) * bpp) & ((1 << bpp) - 1);\n            }\n            src++;\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}", 3], ["src/quant.c", "sixel_quant_free_palette", "sixel_quant_free_palette", "void /* <=== sixel_quant_free_palette */ \nsixel_quant_free_palette(\n    unsigned char       /* in */ *data,\n    sixel_allocator_t   /* in */ *allocator)\n{\n    sixel_allocator_free(allocator, data);\n}", 2]],
  "globalVars": [],
  "importContext": ["#include \"config.h\"", "# include <stdio.h>", "# include <stdlib.h>", "# include <stdarg.h>", "#include <string.h>", "# include <unistd.h>", "# include <sys/unistd.h>", "# include <sys/types.h>", "# include <time.h>", "# include <sys/time.h>", "# include <inttypes.h>", "# include <errno.h>", "# include <sys/stat.h>", "# include <fcntl.h>", "#include <sixel.h>", "#include \"tty.h\"", "#include \"encoder.h\"", "#include \"rgblookup.h\""],
  "typeDefs": [],
  "visitedLines": [[550, "sixel_encoder_prepare_palette", "src/encoder.c"], [549, "sixel_encoder_prepare_palette", "src/encoder.c"], [569, "sixel_encoder_prepare_palette", "src/encoder.c"], [559, "sixel_encoder_prepare_palette", "src/encoder.c"], [547, "sixel_encoder_prepare_palette", "src/encoder.c"], [454, "sixel_encoder_prepare_palette", "src/encoder.c"], [561, "sixel_encoder_prepare_palette", "src/encoder.c"], [451, "sixel_encoder_prepare_palette", "src/encoder.c"], [567, "sixel_encoder_prepare_palette", "src/encoder.c"], [571, "sixel_encoder_prepare_palette", "src/encoder.c"], [562, "sixel_encoder_prepare_palette", "src/encoder.c"], [555, "sixel_encoder_prepare_palette", "src/encoder.c"], [455, "sixel_encoder_prepare_palette", "src/encoder.c"], [556, "sixel_encoder_prepare_palette", "src/encoder.c"], [560, "sixel_encoder_prepare_palette", "src/encoder.c"], [554, "sixel_encoder_prepare_palette", "src/encoder.c"], [557, "sixel_encoder_prepare_palette", "src/encoder.c"], [546, "sixel_encoder_prepare_palette", "src/encoder.c"], [573, "sixel_encoder_prepare_palette", "src/encoder.c"], [498, "sixel_encoder_prepare_palette", "src/encoder.c"], [558, "sixel_encoder_prepare_palette", "src/encoder.c"], [460, "sixel_encoder_prepare_palette", "src/encoder.c"], [576, "sixel_encoder_prepare_palette", "src/encoder.c"], [563, "sixel_encoder_prepare_palette", "src/encoder.c"], [519, "sixel_encoder_prepare_palette", "src/encoder.c"], [568, "sixel_encoder_prepare_palette", "src/encoder.c"], [453, "sixel_encoder_prepare_palette", "src/encoder.c"]],
  "visitedParams": [["sixel_frame_t   *frame", "sixel_encoder_prepare_palette", "src/encoder.c"], ["sixel_encoder_t *encoder", "sixel_encoder_prepare_palette", "src/encoder.c"], ["sixel_dither_t  **dither", "sixel_encoder_prepare_palette", "src/encoder.c"]],
  "vulnerableMethods": [["src/encoder.c", "sixel_encoder_prepare_palette", "static SIXELSTATUS /* <=== sixel_encoder_prepare_palette */ \nsixel_encoder_prepare_palette(\n    sixel_encoder_t *encoder,  /* encoder object */\n    sixel_frame_t   *frame,    /* input frame object */\n    sixel_dither_t  **dither)  /* dither object to be created from the frame */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int histogram_colors;\n\n    switch (encoder->color_option) {\n    case SIXEL_COLOR_OPTION_HIGHCOLOR:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_dither_new(dither, (-1), encoder->allocator);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MONOCHROME:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_monochrome_palette(dither, encoder->finvert);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_MAPFILE:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_specified_palette(dither, encoder);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_BUILTIN:\n        if (encoder->dither_cache) {\n            *dither = encoder->dither_cache;\n            status = SIXEL_OK;\n        } else {\n            status = sixel_prepare_builtin_palette(dither, encoder->builtin_palette);\n        }\n        goto end;\n    case SIXEL_COLOR_OPTION_DEFAULT:\n    default:\n        break;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_PALETTE) {\n        if (!sixel_frame_get_palette(frame)) {\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        status = sixel_dither_new(dither, sixel_frame_get_ncolors(frame),\n                                  encoder->allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        sixel_dither_set_palette(*dither, sixel_frame_get_palette(frame));\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        if (sixel_frame_get_transparent(frame) != (-1)) {\n            sixel_dither_set_transparent(*dither, sixel_frame_get_transparent(frame));\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        goto end;\n    }\n\n    if (sixel_frame_get_pixelformat(frame) & SIXEL_FORMATTYPE_GRAYSCALE) {\n        switch (sixel_frame_get_pixelformat(frame)) {\n        case SIXEL_PIXELFORMAT_G1:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G1);\n            break;\n        case SIXEL_PIXELFORMAT_G2:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G2);\n            break;\n        case SIXEL_PIXELFORMAT_G4:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G4);\n            break;\n        case SIXEL_PIXELFORMAT_G8:\n            *dither = sixel_dither_get(SIXEL_BUILTIN_G8);\n            break;\n        default:\n            *dither = NULL;\n            status = SIXEL_LOGIC_ERROR;\n            goto end;\n        }\n        if (*dither && encoder->dither_cache) {\n            sixel_dither_unref(encoder->dither_cache);\n        }\n        sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n        status = SIXEL_OK;\n        goto end;\n    }\n\n    if (encoder->dither_cache) {\n        sixel_dither_unref(encoder->dither_cache);\n    }\n    status = sixel_dither_new(dither, encoder->reqcolors, encoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_dither_initialize(*dither,\n                                     sixel_frame_get_pixels(frame),\n                                     sixel_frame_get_width(frame),\n                                     sixel_frame_get_height(frame),\n                                     sixel_frame_get_pixelformat(frame),\n                                     encoder->method_for_largest,\n                                     encoder->method_for_rep,\n                                     encoder->quality_mode);\n    if (SIXEL_FAILED(status)) {\n        sixel_dither_unref(*dither);\n        goto end;\n    }\n\n    histogram_colors = sixel_dither_get_num_of_histogram_colors(*dither);\n    if (histogram_colors <= encoder->reqcolors) {\n        encoder->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n    }\n    sixel_dither_set_pixelformat(*dither, sixel_frame_get_pixelformat(frame));\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}", 451]]
}