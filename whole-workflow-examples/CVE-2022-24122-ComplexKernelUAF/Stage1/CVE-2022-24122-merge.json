{
  "stats": {
    "cve_id": "CVE-2022-24122",
    "language": "c_cpp",
    "sec_vul": {
      "num": 2,
      "no_more_info": [
        "CVE-2022-24122_0_part1.json",
        "CVE-2022-24122_part1.json"
      ],
      "main_dir": []
    },
    "non_sec_vul": {
      "num": 0,
      "types": {
        "type_2": {
          "num": 0,
          "no_more_info": [
            
          ],
          "main_dir": []
        }
      }
    }
  },
  "raw_data": {
    "CVE-2022-24122_part1": {
      "cve_id": "CVE-2022-24122",
      "cwe_ids": [
        "CWE-416"
      ],
      "cvss_vector": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
      "cvss_is_v3": false,
      "repo_name": "torvalds/linux",
      "commit_msg": "ucount:  Make get_ucount a safe get_user replacement\n\nWhen the ucount code was refactored to create get_ucount it was missed\nthat some of the contexts in which a rlimit is kept elevated can be\nthe only reference to the user/ucount in the system.\n\nOrdinary ucount references exist in places that also have a reference\nto the user namspace, but in POSIX message queues, the SysV shm code,\nand the SIGPENDING code there is no independent user namespace\nreference.\n\nInspection of the the user_namespace show no instance of circular\nreferences between struct ucounts and the user_namespace.  So\nhold a reference from struct ucount to i's user_namespace to\nresolve this problem.\n\nLink: https://lore.kernel.org/lkml/YZV7Z+yXbsx9p3JN@fixkernel.com/\nReported-by: Qian Cai <quic_qiancai@quicinc.com>\nReported-by: Mathias Krause <minipli@grsecurity.net>\nTested-by: Mathias Krause <minipli@grsecurity.net>\nReviewed-by: Mathias Krause <minipli@grsecurity.net>\nReviewed-by: Alexey Gladkov <legion@kernel.org>\nFixes: d64696905554 (\"Reimplement RLIMIT_SIGPENDING on top of ucounts\")\nFixes: 6e52a9f0532f (\"Reimplement RLIMIT_MSGQUEUE on top of ucounts\")\nFixes: d7c9e99aee48 (\"Reimplement RLIMIT_MEMLOCK on top of ucounts\")\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
      "commit_hash": "f9d87929d451d3e649699d0f1d74f71f77ad38f5",
      "git_url": "https://github.com/torvalds/linux/commit/f9d87929d451d3e649699d0f1d74f71f77ad38f5",
      "file_path": "kernel/ucount.c",
      "func_name": "put_ucounts",
      "func_before": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
      "abstract_func_before": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long VAR_0;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &VAR_1, VAR_0)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&VAR_1, VAR_0);\n\t\tkfree(ucounts);\n\t}\n}",
      "func_graph_path_before": "torvalds/linux/f9d87929d451d3e649699d0f1d74f71f77ad38f5/ucount.c/vul/before/0.json",
      "func": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tput_user_ns(ucounts->ns);\n\t\tkfree(ucounts);\n\t}\n}",
      "abstract_func": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long VAR_0;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &VAR_1, VAR_0)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&VAR_1, VAR_0);\n\t\tput_user_ns(ucounts->ns);\n\t\tkfree(ucounts);\n\t}\n}",
      "func_graph_path": "torvalds/linux/f9d87929d451d3e649699d0f1d74f71f77ad38f5/ucount.c/vul/after/0.json",
      "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,7 @@\n \tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n \t\thlist_del_init(&ucounts->node);\n \t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n+\t\tput_user_ns(ucounts->ns);\n \t\tkfree(ucounts);\n \t}\n }",
      "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
          "\t\tput_user_ns(ucounts->ns);"
        ]
      },
      "is_vul": true,
      "pr_url": null,
      "description": "https://lore.kernel.org/lkml/YZV7Z+yXbsx9p3JN@fixkernel.com/:Hi there, I can still reproduce this quickly on today's linux-next and all\nthe way back to 5.15-rc6 by running a syscall fuzzer for a while. The trace\npoints out to this line,\nfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\nIt looks KASAN indicated that that 'ns' had already been freed. Is that\npossible or perhaps this is more of refcount issue? ",
      "Bug Filter": "Security Vulnerability Fix",
      "Bug Filter Confidence": 0.9,
      "Bug Filter Response": "Final Classification: Security Vulnerability Fix \nConfidence: 0.9 "
    },
    "CVE-2022-24122_0_part1": {
      "cve_id": "CVE-2022-24122",
      "cwe_ids": [
        "CWE-416"
      ],
      "cvss_vector": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
      "cvss_is_v3": false,
      "repo_name": "torvalds/linux",
      "commit_msg": "ucount:  Make get_ucount a safe get_user replacement\n\nWhen the ucount code was refactored to create get_ucount it was missed\nthat some of the contexts in which a rlimit is kept elevated can be\nthe only reference to the user/ucount in the system.\n\nOrdinary ucount references exist in places that also have a reference\nto the user namspace, but in POSIX message queues, the SysV shm code,\nand the SIGPENDING code there is no independent user namespace\nreference.\n\nInspection of the the user_namespace show no instance of circular\nreferences between struct ucounts and the user_namespace.  So\nhold a reference from struct ucount to i's user_namespace to\nresolve this problem.\n\nLink: https://lore.kernel.org/lkml/YZV7Z+yXbsx9p3JN@fixkernel.com/\nReported-by: Qian Cai <quic_qiancai@quicinc.com>\nReported-by: Mathias Krause <minipli@grsecurity.net>\nTested-by: Mathias Krause <minipli@grsecurity.net>\nReviewed-by: Mathias Krause <minipli@grsecurity.net>\nReviewed-by: Alexey Gladkov <legion@kernel.org>\nFixes: d64696905554 (\"Reimplement RLIMIT_SIGPENDING on top of ucounts\")\nFixes: 6e52a9f0532f (\"Reimplement RLIMIT_MSGQUEUE on top of ucounts\")\nFixes: d7c9e99aee48 (\"Reimplement RLIMIT_MEMLOCK on top of ucounts\")\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
      "commit_hash": "f9d87929d451d3e649699d0f1d74f71f77ad38f5",
      "git_url": "https://github.com/torvalds/linux/commit/f9d87929d451d3e649699d0f1d74f71f77ad38f5",
      "file_path": "kernel/ucount.c",
      "func_name": "alloc_ucounts",
      "func_before": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}",
      "abstract_func_before": "struct ucounts *alloc_ucounts(struct user_namespace *VAR_0, kuid_t VAR_1)\n{\n\tstruct hlist_head *VAR_2 = ucounts_hashentry(VAR_0, VAR_1);\n\tstruct ucounts *ucounts, *VAR_3;\n\tbool VAR_4;\n\n\tspin_lock_irq(&VAR_5);\n\tucounts = find_ucounts(VAR_0, VAR_1, VAR_2);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&VAR_5);\n\n\t\tVAR_3 = kzalloc(sizeof(*VAR_3), VAR_6);\n\t\tif (!VAR_3)\n\t\t\treturn NULL;\n\n\t\tVAR_3->ns = VAR_0;\n\t\tVAR_3->uid = VAR_1;\n\t\tatomic_set(&VAR_3->count, 1);\n\n\t\tspin_lock_irq(&VAR_5);\n\t\tucounts = find_ucounts(VAR_0, VAR_1, VAR_2);\n\t\tif (ucounts) {\n\t\t\tkfree(VAR_3);\n\t\t} else {\n\t\t\thlist_add_head(&VAR_3->node, VAR_2);\n\t\t\tspin_unlock_irq(&VAR_5);\n\t\t\treturn VAR_3;\n\t\t}\n\t}\n\tVAR_4 = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&VAR_5);\n\tif (VAR_4) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}",
      "func_graph_path_before": "torvalds/linux/f9d87929d451d3e649699d0f1d74f71f77ad38f5/ucount.c/vul/before/1.json",
      "func": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tget_user_ns(new->ns);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}",
      "abstract_func": "struct ucounts *alloc_ucounts(struct user_namespace *VAR_0, kuid_t VAR_1)\n{\n\tstruct hlist_head *VAR_2 = ucounts_hashentry(VAR_0, VAR_1);\n\tstruct ucounts *ucounts, *VAR_3;\n\tbool VAR_4;\n\n\tspin_lock_irq(&VAR_5);\n\tucounts = find_ucounts(VAR_0, VAR_1, VAR_2);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&VAR_5);\n\n\t\tVAR_3 = kzalloc(sizeof(*VAR_3), VAR_6);\n\t\tif (!VAR_3)\n\t\t\treturn NULL;\n\n\t\tVAR_3->ns = VAR_0;\n\t\tVAR_3->uid = VAR_1;\n\t\tatomic_set(&VAR_3->count, 1);\n\n\t\tspin_lock_irq(&VAR_5);\n\t\tucounts = find_ucounts(VAR_0, VAR_1, VAR_2);\n\t\tif (ucounts) {\n\t\t\tkfree(VAR_3);\n\t\t} else {\n\t\t\thlist_add_head(&VAR_3->node, VAR_2);\n\t\t\tget_user_ns(VAR_3->ns);\n\t\t\tspin_unlock_irq(&VAR_5);\n\t\t\treturn VAR_3;\n\t\t}\n\t}\n\tVAR_4 = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&VAR_5);\n\tif (VAR_4) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}",
      "func_graph_path": "torvalds/linux/f9d87929d451d3e649699d0f1d74f71f77ad38f5/ucount.c/vul/after/1.json",
      "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,7 @@\n \t\t\tkfree(new);\n \t\t} else {\n \t\t\thlist_add_head(&new->node, hashent);\n+\t\t\tget_user_ns(new->ns);\n \t\t\tspin_unlock_irq(&ucounts_lock);\n \t\t\treturn new;\n \t\t}",
      "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
          "\t\t\tget_user_ns(new->ns);"
        ]
      },
      "is_vul": true,
      "pr_url": null,
      "description": "https://lore.kernel.org/lkml/YZV7Z+yXbsx9p3JN@fixkernel.com/:Hi there, I can still reproduce this quickly on today's linux-next and all\nthe way back to 5.15-rc6 by running a syscall fuzzer for a while. The trace\npoints out to this line,\nfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\nIt looks KASAN indicated that that 'ns' had already been freed. Is that\npossible or perhaps this is more of refcount issue? ",
      "Bug Filter": "Security Vulnerability Fix",
      "Bug Filter Confidence": 0.9,
      "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message indicates a refactoring to prevent dangling references, which can lead to security issues.\n2. **Consistency Check:** The code adds get_user_ns, which aligns with the message about handling references safely.\n3. **Purpose Evaluation:** The change addresses memory management, a common security concern.\n4. **Security Assessment:** Fixing reference counts prevents use-after-free, a security vulnerability.\n5. **Confidence:** High due to clear intent and alignment of code and message.\n\nFinal Classification: **Security Vulnerability Fix**; Confidence: **0.9**"
    }
  }
}