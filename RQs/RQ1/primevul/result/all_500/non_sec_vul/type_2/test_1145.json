{
  "id": 1145,
  "language": "h",
  "cwe": "",
  "commit_url": "https://github.com/chipcraft-ic/toolchain-component-linux/commit/175e476b8cdf2a4de7432583b49c871345e4f8a1",
  "commit_sha": "175e476b8cdf2a4de7432583b49c871345e4f8a1",
  "commit_msg": "netfilter: x_tables: Use correct memory barriers.\n\nWhen a new table value was assigned, it was followed by a write memory\nbarrier. This ensured that all writes before this point would complete\nbefore any writes after this point. However, to determine whether the\nrules are unused, the sequence counter is read. To ensure that all\nwrites have been done before these reads, a full memory barrier is\nneeded, not just a write memory barrier. The same argument applies when\nincrementing the counter, before the rules are read.\n\nChanging to using smp_mb() instead of smp_wmb() fixes the kernel panic\nreported in cc00bcaa5899 (which is still present), while still\nmaintaining the same speed of replacing tables.\n\nThe smb_mb() barriers potentially slow the packet path, however testing\nhas shown no measurable change in performance on a 4-core MIPS64\nplatform.\n\nFixes: 7f5c6d4f665b (\"netfilter: get rid of atomic ops in fast path\")\nSigned-off-by: Mark Tomlinson <mark.tomlinson@alliedtelesis.co.nz>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "include/linux/netfilter/x_tables.h",
  "func_name": "",
  "raw_func_from_json": "static inline unsigned int xt_write_recseq_begin(void)\n{\n\tunsigned int addend;\n\n\t/*\n\t * Low order bit of sequence is set if we already\n\t * called xt_write_recseq_begin().\n\t */\n\taddend = (__this_cpu_read(xt_recseq.sequence) + 1) & 1;\n\n\t/*\n\t * This is kind of a write_seqcount_begin(), but addend is 0 or 1\n\t * We dont check addend value to avoid a test and conditional jump,\n\t * since addend is most likely 1\n\t */\n\t__this_cpu_add(xt_recseq.sequence, addend);\n\tsmp_wmb();\n\n\treturn addend;\n}",
  "diff_func": "@@ -376,7 +376,7 @@ static inline unsigned int xt_write_recseq_begin(void)\n \t * since addend is most likely 1\n \t */\n \t__this_cpu_add(xt_recseq.sequence, addend);\n-\tsmp_wmb();\n+\tsmp_mb();\n \n \treturn addend;\n }",
  "func": "static inline unsigned int xt_write_recseq_begin(void)\n{\n\tunsigned int addend;\n\n\t/*\n\t * Low order bit of sequence is set if we already\n\t * called xt_write_recseq_begin().\n\t */\n\taddend = (__this_cpu_read(xt_recseq.sequence) + 1) & 1;\n\n\t/*\n\t * This is kind of a write_seqcount_begin(), but addend is 0 or 1\n\t * We dont check addend value to avoid a test and conditional jump,\n\t * since addend is most likely 1\n\t */\n\t__this_cpu_add(xt_recseq.sequence, addend);\n\tsmp_wmb();\n\n\treturn addend;\n}",
  "project": "linux",
  "hash": 232020585500958649681254539026636886974,
  "size": 20,
  "commit_id": "175e476b8cdf2a4de7432583b49c871345e4f8a1",
  "message": "netfilter: x_tables: Use correct memory barriers.\n\nWhen a new table value was assigned, it was followed by a write memory\nbarrier. This ensured that all writes before this point would complete\nbefore any writes after this point. However, to determine whether the\nrules are unused, the sequence counter is read. To ensure that all\nwrites have been done before these reads, a full memory barrier is\nneeded, not just a write memory barrier. The same argument applies when\nincrementing the counter, before the rules are read.\n\nChanging to using smp_mb() instead of smp_wmb() fixes the kernel panic\nreported in cc00bcaa5899 (which is still present), while still\nmaintaining the same speed of replacing tables.\n\nThe smb_mb() barriers potentially slow the packet path, however testing\nhas shown no measurable change in performance on a 4-core MIPS64\nplatform.\n\nFixes: 7f5c6d4f665b (\"netfilter: get rid of atomic ops in fast path\")\nSigned-off-by: Mark Tomlinson <mark.tomlinson@alliedtelesis.co.nz>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
  "target": 1,
  "dataset": "other",
  "idx": 215034,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a kernel panic caused by incorrect memory barriers, improving system stability. It doesn't resolve a security vulnerability but fixes a critical bug.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.95"
}