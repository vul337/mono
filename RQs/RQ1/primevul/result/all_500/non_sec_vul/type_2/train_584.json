{
  "id": 584,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/ljalves/linux_media/commit/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4",
  "commit_sha": "8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4",
  "commit_msg": "sctp: fix race on protocol/netns initialization\n\nConsider sctp module is unloaded and is being requested because an user\nis creating a sctp socket.\n\nDuring initialization, sctp will add the new protocol type and then\ninitialize pernet subsys:\n\n        status = sctp_v4_protosw_init();\n        if (status)\n                goto err_protosw_init;\n\n        status = sctp_v6_protosw_init();\n        if (status)\n                goto err_v6_protosw_init;\n\n        status = register_pernet_subsys(&sctp_net_ops);\n\nThe problem is that after those calls to sctp_v{4,6}_protosw_init(), it\nis possible for userspace to create SCTP sockets like if the module is\nalready fully loaded. If that happens, one of the possible effects is\nthat we will have readers for net->sctp.local_addr_list list earlier\nthan expected and sctp_net_init() does not take precautions while\ndealing with that list, leading to a potential panic but not limited to\nthat, as sctp_sock_init() will copy a bunch of blank/partially\ninitialized values from net->sctp.\n\nThe race happens like this:\n\n     CPU 0                           |  CPU 1\n  socket()                           |\n   __sock_create                     | socket()\n    inet_create                      |  __sock_create\n     list_for_each_entry_rcu(        |\n        answer, &inetsw[sock->type], |\n        list) {                      |   inet_create\n      /* no hits */                  |\n     if (unlikely(err)) {            |\n      ...                            |\n      request_module()               |\n      /* socket creation is blocked  |\n       * the module is fully loaded  |\n       */                            |\n       sctp_init                     |\n        sctp_v4_protosw_init         |\n         inet_register_protosw       |\n          list_add_rcu(&p->list,     |\n                       last_perm);   |\n                                     |  list_for_each_entry_rcu(\n                                     |     answer, &inetsw[sock->type],\n        sctp_v6_protosw_init         |     list) {\n                                     |     /* hit, so assumes protocol\n                                     |      * is already loaded\n                                     |      */\n                                     |  /* socket creation continues\n                                     |   * before netns is initialized\n                                     |   */\n        register_pernet_subsys       |\n\nSimply inverting the initialization order between\nregister_pernet_subsys() and sctp_v4_protosw_init() is not possible\nbecause register_pernet_subsys() will create a control sctp socket, so\nthe protocol must be already visible by then. Deferring the socket\ncreation to a work-queue is not good specially because we loose the\nability to handle its errors.\n\nSo, as suggested by Vlad, the fix is to split netns initialization in\ntwo moments: defaults and control socket, so that the defaults are\nalready loaded by when we register the protocol, while control socket\ninitialization is kept at the same moment it is today.\n\nFixes: 4db67e808640 (\"sctp: Make the address lists per network namespace\")\nSigned-off-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/sctp/protocol.c",
  "func_name": "",
  "raw_func_from_json": "static __init int sctp_init(void)\n{\n\tint i;\n\tint status = -EINVAL;\n\tunsigned long goal;\n\tunsigned long limit;\n\tint max_share;\n\tint order;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t/* Allocate bind_bucket and chunk caches. */\n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create(\"sctp_bind_bucket\",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create(\"sctp_chunk\",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t/* Implementation specific variables. */\n\n\t/* Initialize default stream count setup information. */\n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t/* Initialize handle used for association ids. */\n\tidr_init(&sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold*/\n\tlimit = (sysctl_sctp_mem[1]) << (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = SK_MEM_QUANTUM; /* give each asoc 1 page min */\n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t/* Size and allocate the association hash table.\n\t * The methodology is similar to that of the tcp hash tables.\n\t */\n\tif (totalram_pages >= (128 * 1024))\n\t\tgoal = totalram_pages >> (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = totalram_pages >> (24 - PAGE_SHIFT);\n\n\tfor (order = 0; (1UL << order) < goal; order++)\n\t\t;\n\n\tdo {\n\t\tsctp_assoc_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_hashbucket);\n\t\tif ((sctp_assoc_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_assoc_hashtable = (struct sctp_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_assoc_hashtable && --order > 0);\n\tif (!sctp_assoc_hashtable) {\n\t\tpr_err(\"Failed association hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ahash_alloc;\n\t}\n\tfor (i = 0; i < sctp_assoc_hashsize; i++) {\n\t\trwlock_init(&sctp_assoc_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_assoc_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the endpoint hash table.  */\n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc(64 * sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err(\"Failed endpoint_hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i < sctp_ep_hashsize; i++) {\n\t\trwlock_init(&sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_ep_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the SCTP port hash table.  */\n\tdo {\n\t\tsctp_port_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_bind_hashbucket);\n\t\tif ((sctp_port_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable && --order > 0);\n\tif (!sctp_port_hashtable) {\n\t\tpr_err(\"Failed bind hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\tfor (i = 0; i < sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);\n\t}\n\n\tpr_info(\"Hash tables configured (established %d bind %d)\\n\",\n\t\tsctp_assoc_hashsize, sctp_port_hashsize);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&sctp_address_families);\n \tsctp_v4_pf_init();\n \tsctp_v6_pf_init();\n \n\tstatus = sctp_v4_protosw_init();\n \n \tif (status)\n \t\tgoto err_protosw_init;\n \n \tstatus = sctp_v6_protosw_init();\n \tif (status)\n \t\tgoto err_v6_protosw_init;\n \n\tstatus = register_pernet_subsys(&sctp_net_ops);\n \tif (status)\n\t\tgoto err_register_pernet_subsys;\n \n \tstatus = sctp_v4_add_protocol();\n \tif (status)\n\t\tgoto err_add_protocol;\n\n\t/* Register SCTP with inet6 layer.  */\n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\nout:\n\treturn status;\n err_v6_add_protocol:\n \tsctp_v4_del_protocol();\n err_add_protocol:\n\tunregister_pernet_subsys(&sctp_net_ops);\nerr_register_pernet_subsys:\n \tsctp_v6_protosw_exit();\n err_v6_protosw_init:\n \tsctp_v4_protosw_exit();\n err_protosw_init:\n \tsctp_v4_pf_exit();\n \tsctp_v6_pf_exit();\n \tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\nerr_ahash_alloc:\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}\n",
  "diff_func": "@@ -1186,7 +1186,7 @@ static void sctp_v4_del_protocol(void)\n \tunregister_inetaddr_notifier(&sctp_inetaddr_notifier);\n }\n \n-static int __net_init sctp_net_init(struct net *net)\n+static int __net_init sctp_defaults_init(struct net *net)\n {\n \tint status;\n \n@@ -1279,12 +1279,6 @@ static int __net_init sctp_net_init(struct net *net)\n \n \tsctp_dbg_objcnt_init(net);\n \n-\t/* Initialize the control inode/socket for handling OOTB packets.  */\n-\tif ((status = sctp_ctl_sock_init(net))) {\n-\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n-\t\tgoto err_ctl_sock_init;\n-\t}\n-\n \t/* Initialize the local address list. */\n \tINIT_LIST_HEAD(&net->sctp.local_addr_list);\n \tspin_lock_init(&net->sctp.local_addr_lock);\n@@ -1300,9 +1294,6 @@ static int __net_init sctp_net_init(struct net *net)\n \n \treturn 0;\n \n-err_ctl_sock_init:\n-\tsctp_dbg_objcnt_exit(net);\n-\tsctp_proc_exit(net);\n err_init_proc:\n \tcleanup_sctp_mibs(net);\n err_init_mibs:\n@@ -1311,25 +1302,45 @@ static int __net_init sctp_net_init(struct net *net)\n \treturn status;\n }\n \n-static void __net_exit sctp_net_exit(struct net *net)\n+static void __net_exit sctp_defaults_exit(struct net *net)\n {\n \t/* Free the local address list */\n \tsctp_free_addr_wq(net);\n \tsctp_free_local_addr_list(net);\n \n-\t/* Free the control endpoint.  */\n-\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n-\n \tsctp_dbg_objcnt_exit(net);\n \n \tsctp_proc_exit(net);\n \tcleanup_sctp_mibs(net);\n \tsctp_sysctl_net_unregister(net);\n }\n \n-static struct pernet_operations sctp_net_ops = {\n-\t.init = sctp_net_init,\n-\t.exit = sctp_net_exit,\n+static struct pernet_operations sctp_defaults_ops = {\n+\t.init = sctp_defaults_init,\n+\t.exit = sctp_defaults_exit,\n+};\n+\n+static int __net_init sctp_ctrlsock_init(struct net *net)\n+{\n+\tint status;\n+\n+\t/* Initialize the control inode/socket for handling OOTB packets.  */\n+\tstatus = sctp_ctl_sock_init(net);\n+\tif (status)\n+\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n+\n+\treturn status;\n+}\n+\n+static void __net_init sctp_ctrlsock_exit(struct net *net)\n+{\n+\t/* Free the control endpoint.  */\n+\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n+}\n+\n+static struct pernet_operations sctp_ctrlsock_ops = {\n+\t.init = sctp_ctrlsock_init,\n+\t.exit = sctp_ctrlsock_exit,\n };\n \n /* Initialize the universe into something sensible.  */\n@@ -1462,18 +1473,21 @@ static __init int sctp_init(void)\n \tsctp_v4_pf_init();\n \tsctp_v6_pf_init();\n \n-\tstatus = sctp_v4_protosw_init();\n+\tstatus = register_pernet_subsys(&sctp_defaults_ops);\n+\tif (status)\n+\t\tgoto err_register_defaults;\n \n+\tstatus = sctp_v4_protosw_init();\n \tif (status)\n \t\tgoto err_protosw_init;\n \n \tstatus = sctp_v6_protosw_init();\n \tif (status)\n \t\tgoto err_v6_protosw_init;\n \n-\tstatus = register_pernet_subsys(&sctp_net_ops);\n+\tstatus = register_pernet_subsys(&sctp_ctrlsock_ops);\n \tif (status)\n-\t\tgoto err_register_pernet_subsys;\n+\t\tgoto err_register_ctrlsock;\n \n \tstatus = sctp_v4_add_protocol();\n \tif (status)\n@@ -1489,12 +1503,14 @@ static __init int sctp_init(void)\n err_v6_add_protocol:\n \tsctp_v4_del_protocol();\n err_add_protocol:\n-\tunregister_pernet_subsys(&sctp_net_ops);\n-err_register_pernet_subsys:\n+\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\n+err_register_ctrlsock:\n \tsctp_v6_protosw_exit();\n err_v6_protosw_init:\n \tsctp_v4_protosw_exit();\n err_protosw_init:\n+\tunregister_pernet_subsys(&sctp_defaults_ops);\n+err_register_defaults:\n \tsctp_v4_pf_exit();\n \tsctp_v6_pf_exit();\n \tsctp_sysctl_unregister();\n@@ -1527,12 +1543,14 @@ static __exit void sctp_exit(void)\n \tsctp_v6_del_protocol();\n \tsctp_v4_del_protocol();\n \n-\tunregister_pernet_subsys(&sctp_net_ops);\n+\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\n \n \t/* Free protosw registrations */\n \tsctp_v6_protosw_exit();\n \tsctp_v4_protosw_exit();\n \n+\tunregister_pernet_subsys(&sctp_defaults_ops);\n+\n \t/* Unregister with socket layer. */\n \tsctp_v6_pf_exit();\n \tsctp_v4_pf_exit();",
  "project": "linux",
  "commit_id": "8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4",
  "target": 1,
  "func": "static __init int sctp_init(void)\n{\n\tint i;\n\tint status = -EINVAL;\n\tunsigned long goal;\n\tunsigned long limit;\n\tint max_share;\n\tint order;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t/* Allocate bind_bucket and chunk caches. */\n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create(\"sctp_bind_bucket\",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create(\"sctp_chunk\",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t/* Implementation specific variables. */\n\n\t/* Initialize default stream count setup information. */\n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t/* Initialize handle used for association ids. */\n\tidr_init(&sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold*/\n\tlimit = (sysctl_sctp_mem[1]) << (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = SK_MEM_QUANTUM; /* give each asoc 1 page min */\n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t/* Size and allocate the association hash table.\n\t * The methodology is similar to that of the tcp hash tables.\n\t */\n\tif (totalram_pages >= (128 * 1024))\n\t\tgoal = totalram_pages >> (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = totalram_pages >> (24 - PAGE_SHIFT);\n\n\tfor (order = 0; (1UL << order) < goal; order++)\n\t\t;\n\n\tdo {\n\t\tsctp_assoc_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_hashbucket);\n\t\tif ((sctp_assoc_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_assoc_hashtable = (struct sctp_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_assoc_hashtable && --order > 0);\n\tif (!sctp_assoc_hashtable) {\n\t\tpr_err(\"Failed association hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ahash_alloc;\n\t}\n\tfor (i = 0; i < sctp_assoc_hashsize; i++) {\n\t\trwlock_init(&sctp_assoc_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_assoc_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the endpoint hash table.  */\n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc(64 * sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err(\"Failed endpoint_hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i < sctp_ep_hashsize; i++) {\n\t\trwlock_init(&sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_ep_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the SCTP port hash table.  */\n\tdo {\n\t\tsctp_port_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_bind_hashbucket);\n\t\tif ((sctp_port_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable && --order > 0);\n\tif (!sctp_port_hashtable) {\n\t\tpr_err(\"Failed bind hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\tfor (i = 0; i < sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);\n\t}\n\n\tpr_info(\"Hash tables configured (established %d bind %d)\\n\",\n\t\tsctp_assoc_hashsize, sctp_port_hashsize);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&sctp_address_families);\n \tsctp_v4_pf_init();\n \tsctp_v6_pf_init();\n \n\tstatus = sctp_v4_protosw_init();\n \n \tif (status)\n \t\tgoto err_protosw_init;\n \n \tstatus = sctp_v6_protosw_init();\n \tif (status)\n \t\tgoto err_v6_protosw_init;\n \n\tstatus = register_pernet_subsys(&sctp_net_ops);\n \tif (status)\n\t\tgoto err_register_pernet_subsys;\n \n \tstatus = sctp_v4_add_protocol();\n \tif (status)\n\t\tgoto err_add_protocol;\n\n\t/* Register SCTP with inet6 layer.  */\n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\nout:\n\treturn status;\n err_v6_add_protocol:\n \tsctp_v4_del_protocol();\n err_add_protocol:\n\tunregister_pernet_subsys(&sctp_net_ops);\nerr_register_pernet_subsys:\n \tsctp_v6_protosw_exit();\n err_v6_protosw_init:\n \tsctp_v4_protosw_exit();\n err_protosw_init:\n \tsctp_v4_pf_exit();\n \tsctp_v6_pf_exit();\n \tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\nerr_ahash_alloc:\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}\n",
  "big_vul_idx": 179778,
  "idx": 1463,
  "hash": 167189804297399068515278735693731747529,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a race condition during the initialization of the SCTP module, preventing potential panics or incorrect behavior due to premature socket creation. It splits the initialization into two phases to ensure proper setup before protocol registration. The issue doesn't involve exploitable security flaws but improves system stability.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.95"
}