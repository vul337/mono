{
  "id": 587,
  "language": "c",
  "cwe": "CWE-17",
  "commit_url": "https://github.com/viaembedded/arm-soc/commit/3f7352bf21f8fd7ba3e2fcef9488756f188e12be",
  "commit_sha": "3f7352bf21f8fd7ba3e2fcef9488756f188e12be",
  "commit_msg": "x86: bpf_jit: fix compilation of large bpf programs\n\nx86 has variable length encoding. x86 JIT compiler is trying\nto pick the shortest encoding for given bpf instruction.\nWhile doing so the jump targets are changing, so JIT is doing\nmultiple passes over the program. Typical program needs 3 passes.\nSome very short programs converge with 2 passes. Large programs\nmay need 4 or 5. But specially crafted bpf programs may hit the\npass limit and if the program converges on the last iteration\nthe JIT compiler will be producing an image full of 'int 3' insns.\nFix this corner case by doing final iteration over bpf program.\n\nFixes: 0a14842f5a3c (\"net: filter: Just In Time compiler for x86-64\")\nReported-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Alexei Starovoitov <ast@plumgrid.com>\nTested-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "arch/x86/net/bpf_jit_comp.c",
  "func_name": "",
  "raw_func_from_json": "void bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\tstruct bpf_binary_header *header = NULL;\n\tint proglen, oldproglen = 0;\n\tstruct jit_context ctx = {};\n\tu8 *image = NULL;\n\tint *addrs;\n\tint pass;\n\tint i;\n\n\tif (!bpf_jit_enable)\n\t\treturn;\n\n\tif (!prog || !prog->len)\n\t\treturn;\n\n\taddrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn;\n\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n \t}\n \tctx.cleanup_addr = proglen;\n \n\tfor (pass = 0; pass < 10; pass++) {\n \t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n \t\tif (proglen <= 0) {\n \t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",\n\t\t\t\t       proglen, oldproglen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\theader = bpf_jit_binary_alloc(proglen, &image,\n\t\t\t\t\t\t      1, jit_fill_hole);\n\t\t\tif (!header)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\n\tif (bpf_jit_enable > 1)\n\t\tbpf_jit_dump(prog->len, proglen, 0, image);\n\n\tif (image) {\n\t\tbpf_flush_icache(header, image + proglen);\n\t\tset_memory_ro((unsigned long)header, header->pages);\n\t\tprog->bpf_func = (void *)image;\n\t\tprog->jited = true;\n\t}\nout:\n\tkfree(addrs);\n}\n",
  "diff_func": "@@ -966,7 +966,12 @@ void bpf_int_jit_compile(struct bpf_prog *prog)\n \t}\n \tctx.cleanup_addr = proglen;\n \n-\tfor (pass = 0; pass < 10; pass++) {\n+\t/* JITed image shrinks with every pass and the loop iterates\n+\t * until the image stops shrinking. Very large bpf programs\n+\t * may converge on the last pass. In such case do one more\n+\t * pass to emit the final image\n+\t */\n+\tfor (pass = 0; pass < 10 || image; pass++) {\n \t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n \t\tif (proglen <= 0) {\n \t\t\timage = NULL;",
  "project": "linux",
  "commit_id": "3f7352bf21f8fd7ba3e2fcef9488756f188e12be",
  "target": 1,
  "func": "void bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\tstruct bpf_binary_header *header = NULL;\n\tint proglen, oldproglen = 0;\n\tstruct jit_context ctx = {};\n\tu8 *image = NULL;\n\tint *addrs;\n\tint pass;\n\tint i;\n\n\tif (!bpf_jit_enable)\n\t\treturn;\n\n\tif (!prog || !prog->len)\n\t\treturn;\n\n\taddrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn;\n\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n \t}\n \tctx.cleanup_addr = proglen;\n \n\tfor (pass = 0; pass < 10; pass++) {\n \t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n \t\tif (proglen <= 0) {\n \t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",\n\t\t\t\t       proglen, oldproglen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\theader = bpf_jit_binary_alloc(proglen, &image,\n\t\t\t\t\t\t      1, jit_fill_hole);\n\t\t\tif (!header)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\n\tif (bpf_jit_enable > 1)\n\t\tbpf_jit_dump(prog->len, proglen, 0, image);\n\n\tif (image) {\n\t\tbpf_flush_icache(header, image + proglen);\n\t\tset_memory_ro((unsigned long)header, header->pages);\n\t\tprog->bpf_func = (void *)image;\n\t\tprog->jited = true;\n\t}\nout:\n\tkfree(addrs);\n}\n",
  "big_vul_idx": 179783,
  "idx": 1468,
  "hash": 286732731074854733591806138169679928315,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\nThe patch modifies the JIT compiler's loop to handle large BPF programs correctly, preventing incorrect 'int 3' instructions. The issue is about program correctness, not security.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.8"
}