{
  "id": 492,
  "language": "cc",
  "cwe": "",
  "commit_url": "https://github.com/prividentity/tensorflow/commit/fca9874a9b42a2134f907d2fb46ab774a831404a",
  "commit_sha": "fca9874a9b42a2134f907d2fb46ab774a831404a",
  "commit_msg": "Prevent another division by zero.\n\nPiperOrigin-RevId: 369338598\nChange-Id: I55471d363e401fdcf8d259670ad4eef672b731e2",
  "pr_url": null,
  "pr_info": null,
  "file_name": "tensorflow/core/kernels/conv_grad_shape_utils.cc",
  "func_name": "",
  "raw_func_from_json": "Status ConvBackpropComputeDimensionsV2(\n    StringPiece label, int num_spatial_dims, const TensorShape& input_shape,\n    const TensorShape& filter_shape, const TensorShape& out_backprop_shape,\n    const gtl::ArraySlice<int32>& dilations, const std::vector<int32>& strides,\n    Padding padding, absl::Span<const int64> explicit_paddings,\n    TensorFormat data_format, ConvBackpropDimensions* dims) {\n  // The + 2 in the following line is for the batch and feature dimensions.\n  const int num_dims = num_spatial_dims + 2;\n  if (input_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": input must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  if (filter_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": filter must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  if (out_backprop_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": out_backprop must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  int batch_dim = GetTensorBatchDimIndex(num_dims, data_format);\n  dims->batch_size = input_shape.dim_size(batch_dim);\n  if (dims->batch_size != out_backprop_shape.dim_size(batch_dim)) {\n    return errors::InvalidArgument(\n        label, \": input and out_backprop must have the same batch size.\",\n        \" Input batch: \", dims->batch_size,\n        \", outbackprop batch: \", out_backprop_shape.dim_size(batch_dim),\n        \", batch_dim: \", batch_dim);\n  }\n\n  int feature_dim = GetTensorFeatureDimIndex(num_dims, data_format);\n  dims->in_depth = input_shape.dim_size(feature_dim);\n  // The input and output feature dimensions are the second last and last\n  // dimensions of the filter Tensor.\n  VLOG(2) << \"input vs filter_in depth \" << dims->in_depth << \" \"\n          << filter_shape.dim_size(num_dims - 2);\n  if (dims->in_depth % filter_shape.dim_size(num_dims - 2)) {\n    return errors::InvalidArgument(\n        label, \": input depth must be evenly divisible by filter depth\");\n  }\n  dims->out_depth = filter_shape.dim_size(num_dims - 1);\n  if (dims->out_depth != out_backprop_shape.dim_size(feature_dim)) {\n    return errors::InvalidArgument(\n        label, \": filter and out_backprop must have the same out_depth\");\n  }\n  dims->spatial_dims.resize(num_spatial_dims);\n  for (int i = 0; i < num_spatial_dims; ++i) {\n    int image_dim = GetTensorSpatialDimIndex(num_dims, data_format, i);\n    int64 padding_before = -1, padding_after = -1;\n    if (padding == EXPLICIT) {\n      padding_before = explicit_paddings[2 * image_dim];\n      padding_after = explicit_paddings[2 * image_dim + 1];\n    }\n    TF_RETURN_IF_ERROR(ConvBackpropExtractAndVerifyDimension(\n        label, input_shape, filter_shape, out_backprop_shape, dilations,\n        strides, padding, padding_before, padding_after, image_dim, i,\n        &dims->spatial_dims[i]));\n  }\n  return Status::OK();\n}",
  "diff_func": "@@ -127,6 +127,10 @@ Status ConvBackpropComputeDimensionsV2(\n   // dimensions of the filter Tensor.\n   VLOG(2) << \"input vs filter_in depth \" << dims->in_depth << \" \"\n           << filter_shape.dim_size(num_dims - 2);\n+  if (filter_shape.dim_size(num_dims - 2) <= 0) {\n+    return errors ::InvalidArgument(\n+        label, \": filter depth must be strictly greated than zero\");\n+  }\n   if (dims->in_depth % filter_shape.dim_size(num_dims - 2)) {\n     return errors::InvalidArgument(\n         label, \": input depth must be evenly divisible by filter depth\");",
  "func": "Status ConvBackpropComputeDimensionsV2(\n    StringPiece label, int num_spatial_dims, const TensorShape& input_shape,\n    const TensorShape& filter_shape, const TensorShape& out_backprop_shape,\n    const gtl::ArraySlice<int32>& dilations, const std::vector<int32>& strides,\n    Padding padding, absl::Span<const int64> explicit_paddings,\n    TensorFormat data_format, ConvBackpropDimensions* dims) {\n  // The + 2 in the following line is for the batch and feature dimensions.\n  const int num_dims = num_spatial_dims + 2;\n  if (input_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": input must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  if (filter_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": filter must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  if (out_backprop_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": out_backprop must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  int batch_dim = GetTensorBatchDimIndex(num_dims, data_format);\n  dims->batch_size = input_shape.dim_size(batch_dim);\n  if (dims->batch_size != out_backprop_shape.dim_size(batch_dim)) {\n    return errors::InvalidArgument(\n        label, \": input and out_backprop must have the same batch size.\",\n        \" Input batch: \", dims->batch_size,\n        \", outbackprop batch: \", out_backprop_shape.dim_size(batch_dim),\n        \", batch_dim: \", batch_dim);\n  }\n\n  int feature_dim = GetTensorFeatureDimIndex(num_dims, data_format);\n  dims->in_depth = input_shape.dim_size(feature_dim);\n  // The input and output feature dimensions are the second last and last\n  // dimensions of the filter Tensor.\n  VLOG(2) << \"input vs filter_in depth \" << dims->in_depth << \" \"\n          << filter_shape.dim_size(num_dims - 2);\n  if (dims->in_depth % filter_shape.dim_size(num_dims - 2)) {\n    return errors::InvalidArgument(\n        label, \": input depth must be evenly divisible by filter depth\");\n  }\n  dims->out_depth = filter_shape.dim_size(num_dims - 1);\n  if (dims->out_depth != out_backprop_shape.dim_size(feature_dim)) {\n    return errors::InvalidArgument(\n        label, \": filter and out_backprop must have the same out_depth\");\n  }\n  dims->spatial_dims.resize(num_spatial_dims);\n  for (int i = 0; i < num_spatial_dims; ++i) {\n    int image_dim = GetTensorSpatialDimIndex(num_dims, data_format, i);\n    int64 padding_before = -1, padding_after = -1;\n    if (padding == EXPLICIT) {\n      padding_before = explicit_paddings[2 * image_dim];\n      padding_after = explicit_paddings[2 * image_dim + 1];\n    }\n    TF_RETURN_IF_ERROR(ConvBackpropExtractAndVerifyDimension(\n        label, input_shape, filter_shape, out_backprop_shape, dilations,\n        strides, padding, padding_before, padding_after, image_dim, i,\n        &dims->spatial_dims[i]));\n  }\n  return Status::OK();\n}",
  "project": "tensorflow",
  "hash": 320799004957211890798176933281449360794,
  "size": 60,
  "commit_id": "fca9874a9b42a2134f907d2fb46ab774a831404a",
  "message": "Prevent another division by zero.\n\nPiperOrigin-RevId: 369338598\nChange-Id: I55471d363e401fdcf8d259670ad4eef672b731e2",
  "target": 1,
  "dataset": "other",
  "idx": 197183,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\nThe patch addresses a division by zero error by adding a check for the filter's depth. While this prevents a runtime error, the classification depends on whether the filter depth is attacker-controlled. Without such evidence, it's categorized as a defect fix.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.7"
}