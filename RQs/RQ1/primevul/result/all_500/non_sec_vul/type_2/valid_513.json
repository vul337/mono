{
  "id": 513,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/orgTestCodacy11KRepos110MB/repo-3304-flatpak/commit/eb7946bb6248923d8c90fe9b84425fef97ae580d",
  "commit_sha": "eb7946bb6248923d8c90fe9b84425fef97ae580d",
  "commit_msg": "dir: Reserve the whole @@ prefix\n\nIf we add new features analogous to file forwarding later, we might\nfind that we need a different magic token. Let's reserve the whole\n@@* namespace so we can call it @@something-else.\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>\n(cherry picked from commit 1e7e8fdb24b51078f4c48e0711e24a14930ba1f0)",
  "pr_url": null,
  "pr_info": null,
  "file_name": "common/flatpak-dir.c",
  "func_name": "else",
  "raw_func_from_json": "export_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)\n                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}",
  "diff_func": "@@ -7139,7 +7139,7 @@ export_desktop_file (const char         *app,\n                 g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n               else if (strcasecmp (arg, \"%u\") == 0)\n                 g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n-              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)\n+              else if (g_str_has_prefix (arg, \"@@\"))\n                 g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n               else\n                 g_string_append_printf (new_exec, \" %s\", arg);",
  "func": "export_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)\n                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}",
  "project": "flatpak",
  "hash": 274777042485969823856846326715241447396,
  "size": 225,
  "commit_id": "eb7946bb6248923d8c90fe9b84425fef97ae580d",
  "message": "dir: Reserve the whole @@ prefix\n\nIf we add new features analogous to file forwarding later, we might\nfind that we need a different magic token. Let's reserve the whole\n@@* namespace so we can call it @@something-else.\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>\n(cherry picked from commit 1e7e8fdb24b51078f4c48e0711e24a14930ba1f0)",
  "target": 1,
  "dataset": "other",
  "idx": 197477,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch enhances input validation by reserving the @@ prefix, which could prevent potential misuse. However, without explicit security context, it's classified as a defect remediation.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.8"
}