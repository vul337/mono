{
  "id": 592,
  "language": "cpp",
  "cwe": "",
  "commit_url": "https://github.com/zxy787956151/hpvm/commit/1888810e77b446a79a7674784d5f139fcfa605e2",
  "commit_sha": "1888810e77b446a79a7674784d5f139fcfa605e2",
  "commit_msg": "Fix infinite recursion in wddx\n\nSummary:\nIt wasn't checking for infinite recursion due to references or self-referential\nobjects. As it turns out closures always return themselves when converted to an\narray. Raising a warning and returning is how PHP-src deals with this problem,\nnothing special is done for closures.\n\nReviewed By: alexmalyshev\n\nDifferential Revision: D3465655\n\nfbshipit-source-id: a42bc34d30cf4825faf33596139c0c05f8e4f5f1",
  "pr_url": null,
  "pr_info": null,
  "file_name": "hphp/runtime/ext/wddx/ext_wddx.cpp",
  "func_name": "",
  "raw_func_from_json": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString.append(\"<var name='\");\n      m_packetString.append(varName.data());\n      m_packetString.append(\"'>\");\n    }\n\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString.append(\"<struct>\");\n        if (!isArray) {\n          m_packetString.append(\"<var name='php_class_name'><string>\");\n          m_packetString.append(varAsObject->getClassName());\n          m_packetString.append(\"</string></var>\");\n        }\n      } else {\n        m_packetString.append(\"<array length='\");\n        m_packetString.append(std::to_string(length));\n        m_packetString.append(\"'>\");\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString.append(\"</struct>\");\n      }\n      else {\n        m_packetString.append(\"</array>\");\n      }\n    }\n    else {\n      //empty object\n      if (isObject) {\n        m_packetString.append(\"<struct>\");\n        if (!isArray) {\n          m_packetString.append(\"<var name='php_class_name'><string>\");\n          m_packetString.append(varAsObject->getClassName());\n          m_packetString.append(\"</string></var>\");\n        }\n        m_packetString.append(\"</struct>\");\n      }\n    }\n    if (hasVarTag) {\n      m_packetString.append(\"</var>\");\n    }\n    return true;\n  }\n\n  String varType = getDataTypeString(varVariant.getType());\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    String varValue;\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    } else {\n      varValue = StringUtil::HtmlEncode(varVariant.toString(),\n                                        StringUtil::QuoteStyle::Double,\n                                        \"UTF-8\", false, false).toCppString();\n    }\n    m_packetString.append(\n      getWddxEncoded(varType, varValue, varName, hasVarTag));\n    return true;\n  }\n\n  return false;\n}",
  "diff_func": "@@ -66,22 +66,43 @@ bool WddxPacket::serialize_value(const Variant& varVariant) {\n bool WddxPacket::recursiveAddVar(const String& varName,\n                                  const Variant& varVariant,\n                                  bool hasVarTag) {\n+  SeenContainers seen;\n+  return recursiveAddVarImpl(varName, varVariant, hasVarTag, seen);\n+}\n \n+bool WddxPacket::recursiveAddVarImpl(const String& varName,\n+                                     const Variant& varVariant,\n+                                     bool hasVarTag,\n+                                     SeenContainers& seen) {\n   bool isArray = varVariant.isArray();\n   bool isObject = varVariant.isObject();\n \n   if (isArray || isObject) {\n+    Array varAsArray;\n+    Object varAsObject;\n+    ArrayOrObject ptr;\n+    if (isArray) {\n+      varAsArray = varVariant.toArray();\n+      ptr = varAsArray.get();\n+    }\n+    if (isObject) {\n+      varAsObject = varVariant.toObject();\n+      varAsArray = varAsObject.toArray();\n+      ptr = varAsObject.get();\n+    }\n+    assert(!ptr.isNull());\n+    if (!seen.emplace(ptr).second) {\n+      raise_warning(\"recursion detected\");\n+      return false;\n+    }\n+    SCOPE_EXIT { seen.erase(ptr); };\n+\n     if (hasVarTag) {\n       m_packetString.append(\"<var name='\");\n       m_packetString.append(varName.data());\n       m_packetString.append(\"'>\");\n     }\n \n-    Array varAsArray;\n-    Object varAsObject = varVariant.toObject();\n-    if (isArray) varAsArray = varVariant.toArray();\n-    if (isObject) varAsArray = varAsObject.toArray();\n-\n     int length = varAsArray.length();\n     if (length > 0) {\n       ArrayIter it = ArrayIter(varAsArray);\n@@ -99,9 +120,9 @@ bool WddxPacket::recursiveAddVar(const String& varName,\n         m_packetString.append(\"'>\");\n       }\n       for (ArrayIter it(varAsArray); it; ++it) {\n-        Variant key = it.first();\n-        Variant value = it.second();\n-        recursiveAddVar(key.toString(), value, isObject);\n+        auto key = it.first();\n+        auto const& value = it.secondRef();\n+        recursiveAddVarImpl(key.toString(), value, isObject, seen);\n       }\n       if (isObject) {\n         m_packetString.append(\"</struct>\");",
  "func": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString.append(\"<var name='\");\n      m_packetString.append(varName.data());\n      m_packetString.append(\"'>\");\n    }\n\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString.append(\"<struct>\");\n        if (!isArray) {\n          m_packetString.append(\"<var name='php_class_name'><string>\");\n          m_packetString.append(varAsObject->getClassName());\n          m_packetString.append(\"</string></var>\");\n        }\n      } else {\n        m_packetString.append(\"<array length='\");\n        m_packetString.append(std::to_string(length));\n        m_packetString.append(\"'>\");\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString.append(\"</struct>\");\n      }\n      else {\n        m_packetString.append(\"</array>\");\n      }\n    }\n    else {\n      //empty object\n      if (isObject) {\n        m_packetString.append(\"<struct>\");\n        if (!isArray) {\n          m_packetString.append(\"<var name='php_class_name'><string>\");\n          m_packetString.append(varAsObject->getClassName());\n          m_packetString.append(\"</string></var>\");\n        }\n        m_packetString.append(\"</struct>\");\n      }\n    }\n    if (hasVarTag) {\n      m_packetString.append(\"</var>\");\n    }\n    return true;\n  }\n\n  String varType = getDataTypeString(varVariant.getType());\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    String varValue;\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    } else {\n      varValue = StringUtil::HtmlEncode(varVariant.toString(),\n                                        StringUtil::QuoteStyle::Double,\n                                        \"UTF-8\", false, false).toCppString();\n    }\n    m_packetString.append(\n      getWddxEncoded(varType, varValue, varName, hasVarTag));\n    return true;\n  }\n\n  return false;\n}",
  "project": "hhvm",
  "hash": 257002953542231292524849386209084454732,
  "size": 82,
  "commit_id": "1888810e77b446a79a7674784d5f139fcfa605e2",
  "message": "Fix infinite recursion in wddx\n\nSummary:\nIt wasn't checking for infinite recursion due to references or self-referential\nobjects. As it turns out closures always return themselves when converted to an\narray. Raising a warning and returning is how PHP-src deals with this problem,\nnothing special is done for closures.\n\nReviewed By: alexmalyshev\n\nDifferential Revision: D3465655\n\nfbshipit-source-id: a42bc34d30cf4825faf33596139c0c05f8e4f5f1",
  "target": 1,
  "dataset": "other",
  "idx": 195551,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an infinite recursion issue in the WddxPacket::recursiveAddVar function by introducing a tracking mechanism for seen containers. This prevents the function from entering an infinite loop when handling self-referential objects or arrays. The commit message and code changes do not explicitly indicate a security vulnerability but focus on fixing a functional bug to prevent crashes or hangs, which could be a security concern if exploited.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.9"
}