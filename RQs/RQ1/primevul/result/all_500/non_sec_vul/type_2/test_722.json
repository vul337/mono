{
  "id": 722,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/nginx/njs/commit/6a40a85ff239497c6458c7dbef18f6a2736fe992",
  "commit_sha": "6a40a85ff239497c6458c7dbef18f6a2736fe992",
  "commit_msg": "Fixed type confusion bug while resolving promises.\n\nPreviously, the internal function njs_promise_perform_then() which\nimplements PerformPromiseThen() expects its first argument to always be\na promise instance.  This assertion might be invalid because the\nfunctions corresponding to Promise.prototype.then() and\nPromise.resolve() incorrectly verified their arguments.\n\nSpecifically, the functions recognized their first argument as promise\nif it was an object which was an Promise or had Promise object in its\nprototype chain.  The later condition is not correct because internal\nslots are not inherited according to the spec.\n\nThis closes #447 issue in Github.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/njs_promise.c",
  "func_name": "",
  "raw_func_from_json": "njs_promise_perform_then(njs_vm_t *vm, njs_value_t *value,\n    njs_value_t *fulfilled, njs_value_t *rejected,\n    njs_promise_capability_t *capability)\n{\n    njs_int_t               ret;\n    njs_value_t             arguments[2];\n    njs_promise_t           *promise;\n    njs_function_t          *function;\n    njs_promise_data_t      *data;\n    njs_promise_reaction_t  *fulfilled_reaction, *rejected_reaction;\n\n    if (!njs_is_function(fulfilled)) {\n        fulfilled = njs_value_arg(&njs_value_undefined);\n    }\n\n    if (!njs_is_function(rejected)) {\n        rejected = njs_value_arg(&njs_value_undefined);\n    }\n\n    promise = njs_promise(value);\n    data = njs_data(&promise->value);\n\n    fulfilled_reaction = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(fulfilled_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    fulfilled_reaction->capability = capability;\n    fulfilled_reaction->handler = *fulfilled;\n    fulfilled_reaction->type = NJS_PROMISE_FULFILL;\n\n    rejected_reaction = njs_mp_alloc(vm->mem_pool,\n                                     sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(rejected_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    rejected_reaction->capability = capability;\n    rejected_reaction->handler = *rejected;\n    rejected_reaction->type = NJS_PROMISE_REJECTED;\n\n    if (data->state == NJS_PROMISE_PENDING) {\n        njs_queue_insert_tail(&data->fulfill_queue, &fulfilled_reaction->link);\n        njs_queue_insert_tail(&data->reject_queue, &rejected_reaction->link);\n\n    } else {\n        function = njs_promise_create_function(vm,\n                                               sizeof(njs_promise_context_t));\n        function->u.native = njs_promise_reaction_job;\n\n        if (data->state == NJS_PROMISE_REJECTED) {\n            njs_set_data(&arguments[0], rejected_reaction, 0);\n\n            ret = njs_promise_host_rejection_tracker(vm, promise,\n                                                     NJS_PROMISE_HANDLE);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n        } else {\n            njs_set_data(&arguments[0], fulfilled_reaction, 0);\n        }\n\n        arguments[1] = data->result;\n\n        ret = njs_promise_add_event(vm, function, arguments, 2);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    data->is_handled = 1;\n\n    if (capability == NULL) {\n        njs_vm_retval_set(vm, &njs_value_undefined);\n\n    } else {\n        njs_vm_retval_set(vm, &capability->promise);\n    }\n\n    return NJS_OK;\n}",
  "diff_func": "@@ -771,25 +771,19 @@ njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n {\n     njs_int_t                 ret;\n     njs_value_t               value;\n-    njs_object_t              *object;\n     njs_promise_capability_t  *capability;\n \n     static const njs_value_t  string_constructor = njs_string(\"constructor\");\n \n-    if (njs_is_object(x)) {\n-        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n-                                         njs_object_t);\n-\n-        if (object != NULL) {\n-            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n-                                     &value);\n-            if (njs_slow_path(ret == NJS_ERROR)) {\n-                return NULL;\n-            }\n+    if (njs_is_promise(x)) {\n+        ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n+                                 &value);\n+        if (njs_slow_path(ret == NJS_ERROR)) {\n+            return NULL;\n+        }\n \n-            if (njs_values_same(&value, constructor)) {\n-                return njs_promise(x);\n-            }\n+        if (njs_values_same(&value, constructor)) {\n+            return njs_promise(x);\n         }\n     }\n \n@@ -875,19 +869,12 @@ njs_promise_prototype_then(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n {\n     njs_int_t                 ret;\n     njs_value_t               *promise, *fulfilled, *rejected, constructor;\n-    njs_object_t              *object;\n     njs_function_t            *function;\n     njs_promise_capability_t  *capability;\n \n     promise = njs_argument(args, 0);\n \n-    if (njs_slow_path(!njs_is_object(promise))) {\n-        goto failed;\n-    }\n-\n-    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n-                                     njs_object_t);\n-    if (njs_slow_path(object == NULL)) {\n+    if (njs_slow_path(!njs_is_promise(promise))) {\n         goto failed;\n     }\n \n@@ -933,6 +920,8 @@ njs_promise_perform_then(njs_vm_t *vm, njs_value_t *value,\n     njs_promise_data_t      *data;\n     njs_promise_reaction_t  *fulfilled_reaction, *rejected_reaction;\n \n+    njs_assert(njs_is_promise(value));\n+\n     if (!njs_is_function(fulfilled)) {\n         fulfilled = njs_value_arg(&njs_value_undefined);\n     }",
  "func": "njs_promise_perform_then(njs_vm_t *vm, njs_value_t *value,\n    njs_value_t *fulfilled, njs_value_t *rejected,\n    njs_promise_capability_t *capability)\n{\n    njs_int_t               ret;\n    njs_value_t             arguments[2];\n    njs_promise_t           *promise;\n    njs_function_t          *function;\n    njs_promise_data_t      *data;\n    njs_promise_reaction_t  *fulfilled_reaction, *rejected_reaction;\n\n    if (!njs_is_function(fulfilled)) {\n        fulfilled = njs_value_arg(&njs_value_undefined);\n    }\n\n    if (!njs_is_function(rejected)) {\n        rejected = njs_value_arg(&njs_value_undefined);\n    }\n\n    promise = njs_promise(value);\n    data = njs_data(&promise->value);\n\n    fulfilled_reaction = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(fulfilled_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    fulfilled_reaction->capability = capability;\n    fulfilled_reaction->handler = *fulfilled;\n    fulfilled_reaction->type = NJS_PROMISE_FULFILL;\n\n    rejected_reaction = njs_mp_alloc(vm->mem_pool,\n                                     sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(rejected_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    rejected_reaction->capability = capability;\n    rejected_reaction->handler = *rejected;\n    rejected_reaction->type = NJS_PROMISE_REJECTED;\n\n    if (data->state == NJS_PROMISE_PENDING) {\n        njs_queue_insert_tail(&data->fulfill_queue, &fulfilled_reaction->link);\n        njs_queue_insert_tail(&data->reject_queue, &rejected_reaction->link);\n\n    } else {\n        function = njs_promise_create_function(vm,\n                                               sizeof(njs_promise_context_t));\n        function->u.native = njs_promise_reaction_job;\n\n        if (data->state == NJS_PROMISE_REJECTED) {\n            njs_set_data(&arguments[0], rejected_reaction, 0);\n\n            ret = njs_promise_host_rejection_tracker(vm, promise,\n                                                     NJS_PROMISE_HANDLE);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n        } else {\n            njs_set_data(&arguments[0], fulfilled_reaction, 0);\n        }\n\n        arguments[1] = data->result;\n\n        ret = njs_promise_add_event(vm, function, arguments, 2);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    data->is_handled = 1;\n\n    if (capability == NULL) {\n        njs_vm_retval_set(vm, &njs_value_undefined);\n\n    } else {\n        njs_vm_retval_set(vm, &capability->promise);\n    }\n\n    return NJS_OK;\n}",
  "project": "njs",
  "hash": 155587680052916618369463188511595578744,
  "size": 85,
  "commit_id": "6a40a85ff239497c6458c7dbef18f6a2736fe992",
  "message": "Fixed type confusion bug while resolving promises.\n\nPreviously, the internal function njs_promise_perform_then() which\nimplements PerformPromiseThen() expects its first argument to always be\na promise instance.  This assertion might be invalid because the\nfunctions corresponding to Promise.prototype.then() and\nPromise.resolve() incorrectly verified their arguments.\n\nSpecifically, the functions recognized their first argument as promise\nif it was an object which was an Promise or had Promise object in its\nprototype chain.  The later condition is not correct because internal\nslots are not inherited according to the spec.\n\nThis closes #447 issue in Github.",
  "target": 1,
  "dataset": "other",
  "idx": 197632,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n- The patch addresses a type confusion bug in promise handling, correcting how promises are verified.\n- The changes replace object checks with `njs_is_promise`, ensuring proper promise validation.\n- While the bug could lead to unexpected behavior, there's no clear indication of security exploitation.\n\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.8"
}