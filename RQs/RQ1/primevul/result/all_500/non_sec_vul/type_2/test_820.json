{
  "id": 820,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/sYnfo/samba/commit/eb50fb8f3bf670bd7d1cf8fd4368ef4a73083696",
  "commit_sha": "eb50fb8f3bf670bd7d1cf8fd4368ef4a73083696",
  "commit_msg": "FSCTL_GET_SHADOW_COPY_DATA: Don't return 4 extra bytes at end\n\nlabels_data_count already accounts for the unicode null character at the\nend of the array. There is no need in adding space for it again.\n\nSigned-off-by: Christof Schmitt <christof.schmitt@us.ibm.com>\nReviewed-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Simo Sorce <idra@samba.org>\n\nAutobuild-User(master): Jeremy Allison <jra@samba.org>\nAutobuild-Date(master): Tue Aug  6 04:03:17 CEST 2013 on sn-devel-104",
  "pr_url": null,
  "pr_info": null,
  "file_name": "source3/modules/vfs_default.c",
  "func_name": "",
  "raw_func_from_json": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, /* Needed for UNICODE ... */\n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\t\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\n\t\treturn status;\n\t}\n\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\n\t\t/* This should return the object-id on this file.\n\t\t * I think I'll make this be the inode+dev. JRA.\n\t\t */\n\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\t/* Hmmm, will this cause problems if less data asked for? */\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t/* For backwards compatibility only store the dev/inode. */\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\t/* Fail it with STATUS_NOT_A_REPARSE_POINT */\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\t/* Fail it with STATUS_NOT_A_REPARSE_POINT */\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\t/*\n\t\t * This is called to retrieve the number of Shadow Copies (a.k.a. snapshots)\n\t\t * and return their volume names.  If max_data_count is 16, then it is just\n\t\t * asking for the number of volumes and length of the combined names.\n\t\t *\n\t\t * pdata is the data allocated by our caller, but that uses\n\t\t * total_data_count (which is 0 in our case) rather than max_data_count.\n\t\t * Allocate the correct amount and return the pointer to let\n\t\t * it be deallocated when we return.\n\t\t */\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t/*\n\t\t * Call the VFS routine to actually do the work.\n\t\t */\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count + 4;\n\t\t}\n\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t*out_data = cur_pdata;\n\n\t\t/* num_volumes 4 bytes */\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\n\t\tif (labels) {\n\t\t\t/* num_labels 4 bytes */\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\n\t\t/* needed_data_count 4 bytes */\n\t\tSIVAL(cur_pdata, 8, labels_data_count + 4);\n\n\t\tcur_pdata += 12;\n\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\n\t\tTALLOC_FREE(shadow_data);\n\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\t/* pretend this succeeded -\n\t\t *\n\t\t * we have to send back a list with all files owned by this SID\n\t\t *\n\t\t * but I have to check that --metze\n\t\t */\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\n\t\tif (in_len < 8) {\n\t\t\t/* NT_STATUS_BUFFER_TOO_SMALL maybe? */\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\n\t\t/* unknown 4 bytes: this is not the length of the sid :-(  */\n\t\t/*unknown = IVAL(pdata,0);*/\n\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\n\t\t/* we can take a look at the find source :-)\n\t\t *\n\t\t * find ./ -uid $uid  -name '*'   is what we need here\n\t\t *\n\t\t *\n\t\t * and send 4bytes len and then NULL terminated unicode strings\n\t\t * for each file\n\t\t *\n\t\t * but I don't know how to deal with the paged results\n\t\t * (maybe we can hang the result anywhere in the fsp struct)\n\t\t *\n\t\t * but I don't know how to deal with the paged results\n\t\t * (maybe we can hang the result anywhere in the fsp struct)\n\t\t *\n\t\t * we don't send all files at once\n\t\t * and at the next we should *not* start from the beginning,\n\t\t * so we have to cache the result\n\t\t *\n\t\t * --metze\n\t\t */\n\n\t\t/* this works for now... */\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\t/* FIXME: This is just a dummy reply, telling that all of the\n\t\t * file is allocated. MKS cp needs that.\n\t\t * Adding the real allocated ranges via FIEMAP on Linux\n\t\t * and SEEK_DATA/SEEK_HOLE on Solaris is needed to make\n\t\t * this FSCTL correct for sparse files.\n\t\t */\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\n\t\tif (offset + length < offset) {\n\t\t\t/* No 64-bit integer wrap. */\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\t/* Shouldn't this be SMB_VFS_STAT ... ? */\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\n\t\t*out_data = out_data_tmp;\n\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\t/*\n\t\t * http://msdn.microsoft.com/en-us/library/cc232128%28PROT.10%29.aspx\n\t\t * says we have to respond with NT_STATUS_INVALID_PARAMETER\n\t\t */\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\tdefault:\n\t\t/* \n\t\t * Only print once ... unfortunately there could be lots of\n\t\t * different FSCTLs that are called.\n\t\t */\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\n\treturn NT_STATUS_NOT_SUPPORTED;\n}",
  "diff_func": "@@ -1141,7 +1141,7 @@ static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n \t\tif (!labels) {\n \t\t\t*out_len = 16;\n \t\t} else {\n-\t\t\t*out_len = 12 + labels_data_count + 4;\n+\t\t\t*out_len = 12 + labels_data_count;\n \t\t}\n \n \t\tif (max_out_len < *out_len) {\n@@ -1168,7 +1168,7 @@ static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n \t\t}\n \n \t\t/* needed_data_count 4 bytes */\n-\t\tSIVAL(cur_pdata, 8, labels_data_count + 4);\n+\t\tSIVAL(cur_pdata, 8, labels_data_count);\n \n \t\tcur_pdata += 12;\n ",
  "func": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, /* Needed for UNICODE ... */\n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\t\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\n\t\treturn status;\n\t}\n\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\n\t\t/* This should return the object-id on this file.\n\t\t * I think I'll make this be the inode+dev. JRA.\n\t\t */\n\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\t/* Hmmm, will this cause problems if less data asked for? */\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t/* For backwards compatibility only store the dev/inode. */\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\t/* Fail it with STATUS_NOT_A_REPARSE_POINT */\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\t/* Fail it with STATUS_NOT_A_REPARSE_POINT */\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\t/*\n\t\t * This is called to retrieve the number of Shadow Copies (a.k.a. snapshots)\n\t\t * and return their volume names.  If max_data_count is 16, then it is just\n\t\t * asking for the number of volumes and length of the combined names.\n\t\t *\n\t\t * pdata is the data allocated by our caller, but that uses\n\t\t * total_data_count (which is 0 in our case) rather than max_data_count.\n\t\t * Allocate the correct amount and return the pointer to let\n\t\t * it be deallocated when we return.\n\t\t */\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t/*\n\t\t * Call the VFS routine to actually do the work.\n\t\t */\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count + 4;\n\t\t}\n\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\t*out_data = cur_pdata;\n\n\t\t/* num_volumes 4 bytes */\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\n\t\tif (labels) {\n\t\t\t/* num_labels 4 bytes */\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\n\t\t/* needed_data_count 4 bytes */\n\t\tSIVAL(cur_pdata, 8, labels_data_count + 4);\n\n\t\tcur_pdata += 12;\n\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\n\t\tTALLOC_FREE(shadow_data);\n\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\t/* pretend this succeeded -\n\t\t *\n\t\t * we have to send back a list with all files owned by this SID\n\t\t *\n\t\t * but I have to check that --metze\n\t\t */\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\n\t\tif (in_len < 8) {\n\t\t\t/* NT_STATUS_BUFFER_TOO_SMALL maybe? */\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\n\t\t/* unknown 4 bytes: this is not the length of the sid :-(  */\n\t\t/*unknown = IVAL(pdata,0);*/\n\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\n\t\t/* we can take a look at the find source :-)\n\t\t *\n\t\t * find ./ -uid $uid  -name '*'   is what we need here\n\t\t *\n\t\t *\n\t\t * and send 4bytes len and then NULL terminated unicode strings\n\t\t * for each file\n\t\t *\n\t\t * but I don't know how to deal with the paged results\n\t\t * (maybe we can hang the result anywhere in the fsp struct)\n\t\t *\n\t\t * but I don't know how to deal with the paged results\n\t\t * (maybe we can hang the result anywhere in the fsp struct)\n\t\t *\n\t\t * we don't send all files at once\n\t\t * and at the next we should *not* start from the beginning,\n\t\t * so we have to cache the result\n\t\t *\n\t\t * --metze\n\t\t */\n\n\t\t/* this works for now... */\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\t/* FIXME: This is just a dummy reply, telling that all of the\n\t\t * file is allocated. MKS cp needs that.\n\t\t * Adding the real allocated ranges via FIEMAP on Linux\n\t\t * and SEEK_DATA/SEEK_HOLE on Solaris is needed to make\n\t\t * this FSCTL correct for sparse files.\n\t\t */\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\n\t\tif (offset + length < offset) {\n\t\t\t/* No 64-bit integer wrap. */\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\t/* Shouldn't this be SMB_VFS_STAT ... ? */\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\n\t\t*out_data = out_data_tmp;\n\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\t/*\n\t\t * http://msdn.microsoft.com/en-us/library/cc232128%28PROT.10%29.aspx\n\t\t * says we have to respond with NT_STATUS_INVALID_PARAMETER\n\t\t */\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\tdefault:\n\t\t/* \n\t\t * Only print once ... unfortunately there could be lots of\n\t\t * different FSCTLs that are called.\n\t\t */\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\n\treturn NT_STATUS_NOT_SUPPORTED;\n}",
  "project": "samba",
  "hash": 36864430679636639714404842179779335208,
  "size": 330,
  "commit_id": "eb50fb8f3bf670bd7d1cf8fd4368ef4a73083696",
  "message": "FSCTL_GET_SHADOW_COPY_DATA: Don't return 4 extra bytes at end\n\nlabels_data_count already accounts for the unicode null character at the\nend of the array. There is no need in adding space for it again.\n\nSigned-off-by: Christof Schmitt <christof.schmitt@us.ibm.com>\nReviewed-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Simo Sorce <idra@samba.org>\n\nAutobuild-User(master): Jeremy Allison <jra@samba.org>\nAutobuild-Date(master): Tue Aug  6 04:03:17 CEST 2013 on sn-devel-104",
  "target": 1,
  "dataset": "other",
  "idx": 200320,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\nFinal Output:\nAnalysis: The patch corrects an incorrect calculation of the output length in a filesystem control operation, preventing the return of 4 extra bytes. This addresses a potential buffer overflow, which could be a security issue, but the commit message doesn't explicitly state it as a security fix. The change is more of a bug fix related to data handling.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.7"
}