{
  "id": 812,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/iarxm/neomutt/commit/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc",
  "commit_sha": "fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc",
  "commit_msg": "Fix seqset iterator when it ends in a comma\n\nIf the seqset ended with a comma, the substr_end marker would be just\nbefore the trailing nul.  In the next call, the loop to skip the\nmarker would iterate right past the end of string too.\n\nThe fix is simple: place the substr_end marker and skip past it\nimmediately.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "imap/util.c",
  "func_name": "",
  "raw_func_from_json": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n\n  return 0;\n}",
  "diff_func": "@@ -1119,13 +1119,11 @@ int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n     if (iter->substr_cur == iter->eostr)\n       return 1;\n \n-    while (!*(iter->substr_cur))\n-      iter->substr_cur++;\n     iter->substr_end = strchr(iter->substr_cur, ',');\n     if (!iter->substr_end)\n       iter->substr_end = iter->eostr;\n     else\n-      *(iter->substr_end) = '\\0';\n+      *(iter->substr_end++) = '\\0';\n \n     char *range_sep = strchr(iter->substr_cur, ':');\n     if (range_sep)",
  "func": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n\n  return 0;\n}",
  "project": "neomutt",
  "hash": 255563423373473490710136560651315420142,
  "size": 54,
  "commit_id": "fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc",
  "message": "Fix seqset iterator when it ends in a comma\n\nIf the seqset ended with a comma, the substr_end marker would be just\nbefore the trailing nul.  In the next call, the loop to skip the\nmarker would iterate right past the end of string too.\n\nThe fix is simple: place the substr_end marker and skip past it\nimmediately.",
  "target": 1,
  "dataset": "other",
  "idx": 207568,
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a bug in the seqset iterator where a trailing comma caused incorrect handling of the end marker, potentially leading to out-of-bounds access. The fix modifies how the marker is placed and skipped, preventing the iterator from going past the string end. While the issue could cause undefined behavior, it doesn't directly address a security exploit.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.85"
}