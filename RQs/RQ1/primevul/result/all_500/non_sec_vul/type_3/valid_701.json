{
  "id": 701,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/DanBloomberg/leptonica/commit/5ba34b1fe741d69d43a6c8cf767756997eadd87c",
  "commit_sha": "5ba34b1fe741d69d43a6c8cf767756997eadd87c",
  "commit_msg": "Issue 23654 in oss-fuzz: Heap-buffer-overflow in pixReadFromTiffStream\n  * Increase scanline buffer for reading gray+alpha and converting to RGBA",
  "pr_url": null,
  "pr_info": null,
  "file_name": "prog/dewarptest1.c",
  "func_name": "",
  "raw_func_from_json": "pixReadFromTiffStream(TIFF  *tif)\n{\nchar      *text;\nl_uint8   *linebuf, *data, *rowptr;\nl_uint16   spp, bps, photometry, tiffcomp, orientation, sample_fmt;\nl_uint16  *redmap, *greenmap, *bluemap;\nl_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval;\nl_int32    xres, yres, tiffbpl, packedbpl, halfsize;\nl_uint32   w, h, tiffword, read_oriented;\nl_uint32  *line, *ppixel, *tiffdata, *pixdata;\nPIX       *pix, *pix1;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadFromTiffStream\");\n\n    if (!tif)\n        return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n\n    read_oriented = 0;\n\n        /* Only accept uint image data:\n         *   SAMPLEFORMAT_UINT = 1;\n         *   SAMPLEFORMAT_INT = 2;\n         *   SAMPLEFORMAT_IEEEFP = 3;\n         *   SAMPLEFORMAT_VOID = 4;   */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);\n    if (sample_fmt != SAMPLEFORMAT_UINT) {\n        L_ERROR(\"sample format = %d is not uint\\n\", procName, sample_fmt);\n        return NULL;\n    }\n\n        /* Can't read tiff in tiled format. For what is involved, see, e.g:\n         *   https://www.cs.rochester.edu/~nelson/courses/vision/\\\n         *     resources/tiff/libtiff.html#Tiles\n         * A tiled tiff can be converted to a normal (strip) tif:\n         *   tiffcp -s <input-tiled-tif> <output-strip-tif>    */\n    if (TIFFIsTiled(tif)) {\n        L_ERROR(\"tiled format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Old style jpeg is not supported.  We tried supporting 8 bpp.\n         * TIFFReadScanline() fails on this format, so we used RGBA\n         * reading, which generates a 4 spp image, and pulled out the\n         * red component.  However, there were problems with double-frees\n         * in cleanup.  For RGB, tiffbpl is exactly half the size that\n         * you would expect for the raster data in a scanline, which\n         * is 3 * w.  */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    if (tiffcomp == COMPRESSION_OJPEG) {\n        L_ERROR(\"old style jpeg format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Use default fields for bps and spp */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {\n        L_ERROR(\"invalid bps = %d\\n\", procName, bps);\n        return NULL;\n    }\n    if (spp == 2 && bps != 8) {\n        L_WARNING(\"for 2 spp, only handle 8 bps\\n\", procName);\n        return NULL;\n    }\n    if (spp == 1)\n        d = bps;\n    else if (spp == 2)  /* gray plus alpha */\n        d = 32;  /* will convert to RGBA */\n    else if (spp == 3 || spp == 4)\n        d = 32;\n    else\n        return (PIX *)ERROR_PTR(\"spp not in set {1,2,3,4}\", procName, NULL);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    if (w > MaxTiffWidth) {\n        L_ERROR(\"width = %d pixels; too large\\n\", procName, w);\n        return NULL;\n    }\n    if (h > MaxTiffHeight) {\n        L_ERROR(\"height = %d pixels; too large\\n\", procName, h);\n        return NULL;\n    }\n\n        /* The relation between the size of a byte buffer required to hold\n           a raster of image pixels (packedbpl) and the size of the tiff\n           buffer (tiffbuf) is either 1:1 or approximately 2:1, depending\n           on how the data is stored and subsampled.  Allow some slop\n           when validating the relation between buffer size and the image\n           parameters w, spp and bps. */\n    tiffbpl = TIFFScanlineSize(tif);\n    packedbpl = (bps * spp * w + 7) / 8;\n    halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;\n#if 0\n    if (halfsize)\n        L_INFO(\"packedbpl = %d is approx. twice tiffbpl = %d\\n\", procName,\n               packedbpl, tiffbpl);\n#endif\n    if (tiffbpl != packedbpl && !halfsize) {\n        L_ERROR(\"invalid tiffbpl: tiffbpl = %d, packedbpl = %d, \"\n                \"bps = %d, spp = %d, w = %d\\n\",\n                procName, tiffbpl, packedbpl, bps, spp, w);\n        return NULL;\n    }\n\n    if ((pix = pixCreate(w, h, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n    pixSetInputFormat(pix, IFF_TIFF);\n    data = (l_uint8 *)pixGetData(pix);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n\n    if (spp == 1) {\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            memcpy(data, linebuf, tiffbpl);\n            data += bpl;\n        }\n        if (bps <= 8)\n            pixEndianByteSwap(pix);\n        else   /* bps == 16 */\n            pixEndianTwoByteSwap(pix);\n        LEPT_FREE(linebuf);\n    } else if (spp == 2 && bps == 8) {  /* gray plus alpha */\n        L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);\n        pixSetSpp(pix, 4);\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        pixdata = pixGetData(pix);\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            rowptr = linebuf;\n            ppixel = pixdata + i * wpl;\n            for (j = k = 0; j < w; j++) {\n                    /* Copy gray value into r, g and b */\n                SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);\n                SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);\n                ppixel++;\n            }\n        }\n        LEPT_FREE(linebuf);\n    } else {  /* rgb and rgba */\n        if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,\n                                                 sizeof(l_uint32))) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n        }\n            /* TIFFReadRGBAImageOriented() converts to 8 bps */\n        if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,\n                                       ORIENTATION_TOPLEFT, 0)) {\n            LEPT_FREE(tiffdata);\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n        } else {\n            read_oriented = 1;\n        }\n\n        if (spp == 4) pixSetSpp(pix, 4);\n        line = pixGetData(pix);\n        for (i = 0; i < h; i++, line += wpl) {\n            for (j = 0, ppixel = line; j < w; j++) {\n                    /* TIFFGet* are macros */\n                tiffword = tiffdata[i * w + j];\n                rval = TIFFGetR(tiffword);\n                gval = TIFFGetG(tiffword);\n                bval = TIFFGetB(tiffword);\n                if (spp == 3) {\n                    composeRGBPixel(rval, gval, bval, ppixel);\n                } else {  /* spp == 4 */\n                    aval = TIFFGetA(tiffword);\n                    composeRGBAPixel(rval, gval, bval, aval, ppixel);\n                }\n                ppixel++;\n            }\n        }\n        LEPT_FREE(tiffdata);\n    }\n\n    if (getTiffStreamResolution(tif, &xres, &yres) == 0) {\n        pixSetXRes(pix, xres);\n        pixSetYRes(pix, yres);\n    }\n\n        /* Find and save the compression type */\n    comptype = getTiffCompressedFormat(tiffcomp);\n    pixSetInputFormat(pix, comptype);\n\n    if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n            /* Save the colormap as a pix cmap.  Because the\n             * tiff colormap components are 16 bit unsigned,\n             * and go from black (0) to white (0xffff), the\n             * the pix cmap takes the most significant byte. */\n        if (bps > 8) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap size > 256\", procName, NULL);\n        }\n        if ((cmap = pixcmapCreate(bps)) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap not made\", procName, NULL);\n        }\n        ncolors = 1 << bps;\n        for (i = 0; i < ncolors; i++)\n            pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                            bluemap[i] >> 8);\n        if (pixSetColormap(pix, cmap)) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n        }\n\n            /* Remove the colormap for 1 bpp. */\n        if (bps == 1) {\n            pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n            pixDestroy(&pix);\n            pix = pix1;\n        }\n    } else {   /* No colormap: check photometry and invert if necessary */\n        if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n                /* Guess default photometry setting.  Assume min_is_white\n                 * if compressed 1 bpp; min_is_black otherwise. */\n            if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                tiffcomp == COMPRESSION_CCITTFAX4 ||\n                tiffcomp == COMPRESSION_CCITTRLE ||\n                tiffcomp == COMPRESSION_CCITTRLEW) {\n                photometry = PHOTOMETRIC_MINISWHITE;\n            } else {\n                photometry = PHOTOMETRIC_MINISBLACK;\n            }\n        }\n        if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n            (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n            pixInvert(pix, pix);\n    }\n\n    if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n        if (orientation >= 1 && orientation <= 8) {\n            struct tiff_transform *transform = (read_oriented) ?\n                &tiff_partial_orientation_transforms[orientation - 1] :\n                &tiff_orientation_transforms[orientation - 1];\n            if (transform->vflip) pixFlipTB(pix, pix);\n            if (transform->hflip) pixFlipLR(pix, pix);\n            if (transform->rotate) {\n                PIX *oldpix = pix;\n                pix = pixRotate90(oldpix, transform->rotate);\n                pixDestroy(&oldpix);\n            }\n        }\n    }\n\n    text = NULL;\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);\n    if (text) pixSetText(pix, text);\n    return pix;\n}",
  "diff_func": "@@ -52,6 +52,8 @@ PIX        *pixs2, *pixn2, *pixg2, *pixb2, *pixd2;\n \n     setLeptDebugOK(1);\n     lept_mkdir(\"lept/model\");\n+    lept_rmdir(\"lept/dewmod\");\n+    lept_mkdir(\"lept/dewmod\");\n \n /*    pixs = pixRead(\"1555.007.jpg\"); */\n     pixs = pixRead(\"cat.035.jpg\");\n@@ -160,8 +162,6 @@ PIX        *pixs2, *pixn2, *pixg2, *pixb2, *pixd2;\n                       \"/tmp/lept/dewarptest1.pdf\");\n     lept_stderr(\"pdf file made: /tmp/lept/model/dewarptest1.pdf\\n\");\n \n-    lept_rmdir(\"lept/dewmod\");\n-    lept_rmdir(\"lept/dewtest\");\n     pixDestroy(&pixs);\n     pixDestroy(&pixn);\n     pixDestroy(&pixg);",
  "func": "pixReadFromTiffStream(TIFF  *tif)\n{\nchar      *text;\nl_uint8   *linebuf, *data, *rowptr;\nl_uint16   spp, bps, photometry, tiffcomp, orientation, sample_fmt;\nl_uint16  *redmap, *greenmap, *bluemap;\nl_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval;\nl_int32    xres, yres, tiffbpl, packedbpl, halfsize;\nl_uint32   w, h, tiffword, read_oriented;\nl_uint32  *line, *ppixel, *tiffdata, *pixdata;\nPIX       *pix, *pix1;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadFromTiffStream\");\n\n    if (!tif)\n        return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n\n    read_oriented = 0;\n\n        /* Only accept uint image data:\n         *   SAMPLEFORMAT_UINT = 1;\n         *   SAMPLEFORMAT_INT = 2;\n         *   SAMPLEFORMAT_IEEEFP = 3;\n         *   SAMPLEFORMAT_VOID = 4;   */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);\n    if (sample_fmt != SAMPLEFORMAT_UINT) {\n        L_ERROR(\"sample format = %d is not uint\\n\", procName, sample_fmt);\n        return NULL;\n    }\n\n        /* Can't read tiff in tiled format. For what is involved, see, e.g:\n         *   https://www.cs.rochester.edu/~nelson/courses/vision/\\\n         *     resources/tiff/libtiff.html#Tiles\n         * A tiled tiff can be converted to a normal (strip) tif:\n         *   tiffcp -s <input-tiled-tif> <output-strip-tif>    */\n    if (TIFFIsTiled(tif)) {\n        L_ERROR(\"tiled format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Old style jpeg is not supported.  We tried supporting 8 bpp.\n         * TIFFReadScanline() fails on this format, so we used RGBA\n         * reading, which generates a 4 spp image, and pulled out the\n         * red component.  However, there were problems with double-frees\n         * in cleanup.  For RGB, tiffbpl is exactly half the size that\n         * you would expect for the raster data in a scanline, which\n         * is 3 * w.  */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    if (tiffcomp == COMPRESSION_OJPEG) {\n        L_ERROR(\"old style jpeg format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Use default fields for bps and spp */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {\n        L_ERROR(\"invalid bps = %d\\n\", procName, bps);\n        return NULL;\n    }\n    if (spp == 2 && bps != 8) {\n        L_WARNING(\"for 2 spp, only handle 8 bps\\n\", procName);\n        return NULL;\n    }\n    if (spp == 1)\n        d = bps;\n    else if (spp == 2)  /* gray plus alpha */\n        d = 32;  /* will convert to RGBA */\n    else if (spp == 3 || spp == 4)\n        d = 32;\n    else\n        return (PIX *)ERROR_PTR(\"spp not in set {1,2,3,4}\", procName, NULL);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    if (w > MaxTiffWidth) {\n        L_ERROR(\"width = %d pixels; too large\\n\", procName, w);\n        return NULL;\n    }\n    if (h > MaxTiffHeight) {\n        L_ERROR(\"height = %d pixels; too large\\n\", procName, h);\n        return NULL;\n    }\n\n        /* The relation between the size of a byte buffer required to hold\n           a raster of image pixels (packedbpl) and the size of the tiff\n           buffer (tiffbuf) is either 1:1 or approximately 2:1, depending\n           on how the data is stored and subsampled.  Allow some slop\n           when validating the relation between buffer size and the image\n           parameters w, spp and bps. */\n    tiffbpl = TIFFScanlineSize(tif);\n    packedbpl = (bps * spp * w + 7) / 8;\n    halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;\n#if 0\n    if (halfsize)\n        L_INFO(\"packedbpl = %d is approx. twice tiffbpl = %d\\n\", procName,\n               packedbpl, tiffbpl);\n#endif\n    if (tiffbpl != packedbpl && !halfsize) {\n        L_ERROR(\"invalid tiffbpl: tiffbpl = %d, packedbpl = %d, \"\n                \"bps = %d, spp = %d, w = %d\\n\",\n                procName, tiffbpl, packedbpl, bps, spp, w);\n        return NULL;\n    }\n\n    if ((pix = pixCreate(w, h, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n    pixSetInputFormat(pix, IFF_TIFF);\n    data = (l_uint8 *)pixGetData(pix);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n\n    if (spp == 1) {\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            memcpy(data, linebuf, tiffbpl);\n            data += bpl;\n        }\n        if (bps <= 8)\n            pixEndianByteSwap(pix);\n        else   /* bps == 16 */\n            pixEndianTwoByteSwap(pix);\n        LEPT_FREE(linebuf);\n    } else if (spp == 2 && bps == 8) {  /* gray plus alpha */\n        L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);\n        pixSetSpp(pix, 4);\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        pixdata = pixGetData(pix);\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            rowptr = linebuf;\n            ppixel = pixdata + i * wpl;\n            for (j = k = 0; j < w; j++) {\n                    /* Copy gray value into r, g and b */\n                SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);\n                SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);\n                ppixel++;\n            }\n        }\n        LEPT_FREE(linebuf);\n    } else {  /* rgb and rgba */\n        if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,\n                                                 sizeof(l_uint32))) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n        }\n            /* TIFFReadRGBAImageOriented() converts to 8 bps */\n        if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,\n                                       ORIENTATION_TOPLEFT, 0)) {\n            LEPT_FREE(tiffdata);\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n        } else {\n            read_oriented = 1;\n        }\n\n        if (spp == 4) pixSetSpp(pix, 4);\n        line = pixGetData(pix);\n        for (i = 0; i < h; i++, line += wpl) {\n            for (j = 0, ppixel = line; j < w; j++) {\n                    /* TIFFGet* are macros */\n                tiffword = tiffdata[i * w + j];\n                rval = TIFFGetR(tiffword);\n                gval = TIFFGetG(tiffword);\n                bval = TIFFGetB(tiffword);\n                if (spp == 3) {\n                    composeRGBPixel(rval, gval, bval, ppixel);\n                } else {  /* spp == 4 */\n                    aval = TIFFGetA(tiffword);\n                    composeRGBAPixel(rval, gval, bval, aval, ppixel);\n                }\n                ppixel++;\n            }\n        }\n        LEPT_FREE(tiffdata);\n    }\n\n    if (getTiffStreamResolution(tif, &xres, &yres) == 0) {\n        pixSetXRes(pix, xres);\n        pixSetYRes(pix, yres);\n    }\n\n        /* Find and save the compression type */\n    comptype = getTiffCompressedFormat(tiffcomp);\n    pixSetInputFormat(pix, comptype);\n\n    if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n            /* Save the colormap as a pix cmap.  Because the\n             * tiff colormap components are 16 bit unsigned,\n             * and go from black (0) to white (0xffff), the\n             * the pix cmap takes the most significant byte. */\n        if (bps > 8) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap size > 256\", procName, NULL);\n        }\n        if ((cmap = pixcmapCreate(bps)) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap not made\", procName, NULL);\n        }\n        ncolors = 1 << bps;\n        for (i = 0; i < ncolors; i++)\n            pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                            bluemap[i] >> 8);\n        if (pixSetColormap(pix, cmap)) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n        }\n\n            /* Remove the colormap for 1 bpp. */\n        if (bps == 1) {\n            pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n            pixDestroy(&pix);\n            pix = pix1;\n        }\n    } else {   /* No colormap: check photometry and invert if necessary */\n        if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n                /* Guess default photometry setting.  Assume min_is_white\n                 * if compressed 1 bpp; min_is_black otherwise. */\n            if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                tiffcomp == COMPRESSION_CCITTFAX4 ||\n                tiffcomp == COMPRESSION_CCITTRLE ||\n                tiffcomp == COMPRESSION_CCITTRLEW) {\n                photometry = PHOTOMETRIC_MINISWHITE;\n            } else {\n                photometry = PHOTOMETRIC_MINISBLACK;\n            }\n        }\n        if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n            (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n            pixInvert(pix, pix);\n    }\n\n    if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n        if (orientation >= 1 && orientation <= 8) {\n            struct tiff_transform *transform = (read_oriented) ?\n                &tiff_partial_orientation_transforms[orientation - 1] :\n                &tiff_orientation_transforms[orientation - 1];\n            if (transform->vflip) pixFlipTB(pix, pix);\n            if (transform->hflip) pixFlipLR(pix, pix);\n            if (transform->rotate) {\n                PIX *oldpix = pix;\n                pix = pixRotate90(oldpix, transform->rotate);\n                pixDestroy(&oldpix);\n            }\n        }\n    }\n\n    text = NULL;\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);\n    if (text) pixSetText(pix, text);\n    return pix;\n}",
  "project": "leptonica",
  "hash": 132046392038694907222335403052712221680,
  "size": 264,
  "commit_id": "5ba34b1fe741d69d43a6c8cf767756997eadd87c",
  "message": "Issue 23654 in oss-fuzz: Heap-buffer-overflow in pixReadFromTiffStream\n  * Increase scanline buffer for reading gray+alpha and converting to RGBA",
  "target": 1,
  "dataset": "other",
  "idx": 204059,
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\nThe patch involves changes to directory management, such as creating and removing directories, which are setup tasks. While the commit message suggests a security fix for a heap-buffer-overflow, the code changes don't address that issue. Therefore, the classification is based on the code changes, which are non-core improvements.\n\n**Final Output:**\n\nAnalysis: The commit message indicates a security fix, but the code changes involve directory operations unrelated to the buffer overflow. Thus, it's a supporting improvement.\n\nFinal Classification: Supporting & Non-Core Improvements  \nConfidence Score: 0.7"
}