{
  "id": 387,
  "language": "c",
  "cwe": "CWE-189",
  "commit_url": "https://github.com/ljalves/linux_media/commit/fc9bbca8f650e5f738af8806317c0a041a48ae4a",
  "commit_sha": "fc9bbca8f650e5f738af8806317c0a041a48ae4a",
  "commit_msg": "vm: convert fb_mmap to vm_iomap_memory() helper\n\nThis is my example conversion of a few existing mmap users.  The\nfb_mmap() case is a good example because it is a bit more complicated\nthan some: fb_mmap() mmaps one of two different memory areas depending\non the page offset of the mmap (but happily there is never any mixing of\nthe two, so the helper function still works).\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/video/fbmem.c",
  "func_name": "",
  "raw_func_from_json": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n\tunsigned long off;\n \tunsigned long start;\n \tu32 len;\n \n \tif (!info)\n \t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n \t\treturn res;\n \t}\n \n\t/* frame buffer memory */\n \tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\t/* memory mapped io */\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n \t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n \t}\n \tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n }\n",
  "diff_func": "@@ -1373,15 +1373,12 @@ fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n-\tunsigned long off;\n+\tunsigned long mmio_pgoff;\n \tunsigned long start;\n \tu32 len;\n \n \tif (!info)\n \t\treturn -ENODEV;\n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n-\t\treturn -EINVAL;\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n@@ -1393,32 +1390,24 @@ fb_mmap(struct file *file, struct vm_area_struct * vma)\n \t\treturn res;\n \t}\n \n-\t/* frame buffer memory */\n+\t/*\n+\t * Ugh. This can be either the frame buffer mapping, or\n+\t * if pgoff points past it, the mmio mapping.\n+\t */\n \tstart = info->fix.smem_start;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n-\tif (off >= len) {\n-\t\t/* memory mapped io */\n-\t\toff -= len;\n-\t\tif (info->var.accel_flags) {\n-\t\t\tmutex_unlock(&info->mm_lock);\n-\t\t\treturn -EINVAL;\n-\t\t}\n+\tlen = info->fix.smem_len;\n+\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n+\tif (vma->vm_pgoff >= mmio_pgoff) {\n+\t\tvma->vm_pgoff -= mmio_pgoff;\n \t\tstart = info->fix.mmio_start;\n-\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n+\t\tlen = info->fix.mmio_len;\n \t}\n \tmutex_unlock(&info->mm_lock);\n-\tstart &= PAGE_MASK;\n-\tif ((vma->vm_end - vma->vm_start + off) > len)\n-\t\treturn -EINVAL;\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n-\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/\n+\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n-\tfb_pgprotect(file, vma, off);\n-\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n-\t\treturn -EAGAIN;\n-\treturn 0;\n+\tfb_pgprotect(file, vma, start);\n+\n+\treturn vm_iomap_memory(vma, start, len);\n }\n \n static int",
  "project": "linux",
  "commit_id": "fc9bbca8f650e5f738af8806317c0a041a48ae4a",
  "target": 1,
  "func": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n\tunsigned long off;\n \tunsigned long start;\n \tu32 len;\n \n \tif (!info)\n \t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n \t\treturn res;\n \t}\n \n\t/* frame buffer memory */\n \tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\t/* memory mapped io */\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n \t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n \t}\n \tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n }\n",
  "big_vul_idx": 179232,
  "idx": 1022,
  "hash": 61607845425516357035166702793045732353,
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch refactors the fb_mmap function to use a helper function, vm_iomap_memory(), simplifying the memory mapping process. The changes involve removing manual calculations and checks, which improves code maintainability and efficiency without addressing any security issues.\n\nFinal Classification: Supporting & Non-Core Improvements  \nConfidence Score: 0.9"
}