{
  "id": 627,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/chipcraft-ic/toolchain-component-linux/commit/d0cb50185ae942b03c4327be322055d622dc79f6",
  "commit_sha": "d0cb50185ae942b03c4327be322055d622dc79f6",
  "commit_msg": "do_last(): fetch directory ->i_mode and ->i_uid before it's too late\n\nmay_create_in_sticky() call is done when we already have dropped the\nreference to dir.\n\nFixes: 30aba6656f61e (namei: allow restricted O_CREAT of FIFOs and regular files)\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/namei.c",
  "func_name": "",
  "raw_func_from_json": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}",
  "diff_func": "@@ -1001,7 +1001,8 @@ static int may_linkat(struct path *link)\n  * may_create_in_sticky - Check whether an O_CREAT open in a sticky directory\n  *\t\t\t  should be allowed, or not, on files that already\n  *\t\t\t  exist.\n- * @dir: the sticky parent directory\n+ * @dir_mode: mode bits of directory\n+ * @dir_uid: owner of directory\n  * @inode: the inode of the file to open\n  *\n  * Block an O_CREAT open of a FIFO (or a regular file) when:\n@@ -1017,18 +1018,18 @@ static int may_linkat(struct path *link)\n  *\n  * Returns 0 if the open is allowed, -ve on error.\n  */\n-static int may_create_in_sticky(struct dentry * const dir,\n+static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,\n \t\t\t\tstruct inode * const inode)\n {\n \tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n \t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n-\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n-\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n+\t    likely(!(dir_mode & S_ISVTX)) ||\n+\t    uid_eq(inode->i_uid, dir_uid) ||\n \t    uid_eq(current_fsuid(), inode->i_uid))\n \t\treturn 0;\n \n-\tif (likely(dir->d_inode->i_mode & 0002) ||\n-\t    (dir->d_inode->i_mode & 0020 &&\n+\tif (likely(dir_mode & 0002) ||\n+\t    (dir_mode & 0020 &&\n \t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n \t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n \t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n@@ -3201,6 +3202,8 @@ static int do_last(struct nameidata *nd,\n \t\t   struct file *file, const struct open_flags *op)\n {\n \tstruct dentry *dir = nd->path.dentry;\n+\tkuid_t dir_uid = dir->d_inode->i_uid;\n+\tumode_t dir_mode = dir->d_inode->i_mode;\n \tint open_flag = op->open_flag;\n \tbool will_truncate = (open_flag & O_TRUNC) != 0;\n \tbool got_write = false;\n@@ -3331,7 +3334,7 @@ static int do_last(struct nameidata *nd,\n \t\terror = -EISDIR;\n \t\tif (d_is_dir(nd->path.dentry))\n \t\t\tgoto out;\n-\t\terror = may_create_in_sticky(dir,\n+\t\terror = may_create_in_sticky(dir_mode, dir_uid,\n \t\t\t\t\t     d_backing_inode(nd->path.dentry));\n \t\tif (unlikely(error))\n \t\t\tgoto out;",
  "func": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}",
  "project": "linux",
  "hash": 20871760417441141942075932160806615554,
  "size": 22,
  "commit_id": "d0cb50185ae942b03c4327be322055d622dc79f6",
  "message": "do_last(): fetch directory ->i_mode and ->i_uid before it's too late\n\nmay_create_in_sticky() call is done when we already have dropped the\nreference to dir.\n\nFixes: 30aba6656f61e (namei: allow restricted O_CREAT of FIFOs and regular files)\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
  "target": 1,
  "dataset": "other",
  "idx": 199916,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the `may_create_in_sticky` function to use `dir_mode` and `dir_uid` instead of accessing them from the `dir` struct, ensuring these values are captured before the directory reference is dropped. This prevents incorrect permission checks that could lead to unauthorized file creation in sticky directories, addressing a potential security vulnerability.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}