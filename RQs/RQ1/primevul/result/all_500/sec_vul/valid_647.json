{
  "id": 647,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/chipcraft-ic/toolchain-component-expat/commit/c4bf96bb51dd2a1b0e185374362ee136fe2c9d7f",
  "commit_sha": "c4bf96bb51dd2a1b0e185374362ee136fe2c9d7f",
  "commit_msg": "xmlparse.c: Fix external entity infinite loop bug (CVE-2017-9233)",
  "pr_url": null,
  "pr_info": null,
  "file_name": "expat/lib/xmlparse.c",
  "func_name": "",
  "raw_func_from_json": "entityValueInitProcessor(XML_Parser parser,\n                         const char *s,\n                         const char *end,\n                         const char **nextPtr)\n{\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  eventPtr = start;\n\n  for (;;) {\n    tok = XmlPrologTok(encoding, start, end, &next);\n    eventEndPtr = next;\n    if (tok <= 0) {\n      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE:   /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, encoding, s, end);\n    }\n    else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        *nextPtr = next;\n        return XML_ERROR_NONE;\n      case XML_FINISHED:\n        return XML_ERROR_ABORTED;\n      default:\n        *nextPtr = next;\n      }\n      /* stop scanning for text declaration - we found one */\n      processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    /* If we are at the end of the buffer, this would cause XmlPrologTok to\n       return XML_TOK_NONE on the next call, which would then cause the\n       function to exit with *nextPtr set to s - that is what we want for other\n       tokens, but not for the BOM - we would rather like to skip it;\n       then, when this routine is entered the next time, XmlPrologTok will\n       return XML_TOK_INVALID, since the BOM is still in the buffer\n    */\n    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    eventPtr = start;\n  }\n}",
  "diff_func": "@@ -3981,6 +3981,14 @@ entityValueInitProcessor(XML_Parser parser,\n       *nextPtr = next;\n       return XML_ERROR_NONE;\n     }\n+    /* If we get this token, we have the start of what might be a\n+       normal tag, but not a declaration (i.e. it doesn't begin with\n+       \"<!\").  In a DTD context, that isn't legal.\n+    */\n+    else if (tok == XML_TOK_INSTANCE_START) {\n+      *nextPtr = next;\n+      return XML_ERROR_SYNTAX;\n+    }\n     start = next;\n     eventPtr = start;\n   }",
  "func": "entityValueInitProcessor(XML_Parser parser,\n                         const char *s,\n                         const char *end,\n                         const char **nextPtr)\n{\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  eventPtr = start;\n\n  for (;;) {\n    tok = XmlPrologTok(encoding, start, end, &next);\n    eventEndPtr = next;\n    if (tok <= 0) {\n      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE:   /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, encoding, s, end);\n    }\n    else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        *nextPtr = next;\n        return XML_ERROR_NONE;\n      case XML_FINISHED:\n        return XML_ERROR_ABORTED;\n      default:\n        *nextPtr = next;\n      }\n      /* stop scanning for text declaration - we found one */\n      processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    /* If we are at the end of the buffer, this would cause XmlPrologTok to\n       return XML_TOK_NONE on the next call, which would then cause the\n       function to exit with *nextPtr set to s - that is what we want for other\n       tokens, but not for the BOM - we would rather like to skip it;\n       then, when this routine is entered the next time, XmlPrologTok will\n       return XML_TOK_INVALID, since the BOM is still in the buffer\n    */\n    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    eventPtr = start;\n  }\n}",
  "project": "libexpat",
  "hash": 337998318068132835707143746781218093260,
  "size": 65,
  "commit_id": "c4bf96bb51dd2a1b0e185374362ee136fe2c9d7f",
  "message": "xmlparse.c: Fix external entity infinite loop bug (CVE-2017-9233)",
  "target": 1,
  "dataset": "other",
  "idx": 200711,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a known security vulnerability (CVE-2017-9233) by adding error handling to prevent an infinite loop caused by external entities. The code change specifically checks for an invalid token in a DTD context and returns a syntax error, thus mitigating a potential DoS attack.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}