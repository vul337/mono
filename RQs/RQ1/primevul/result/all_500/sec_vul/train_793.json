{
  "id": 793,
  "language": "unknown",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/cla7aye15I4nd/libtiff/commit/b18012dae552f85dcc5c57d3bf4e997a15b1cc1c",
  "commit_sha": "b18012dae552f85dcc5c57d3bf4e997a15b1cc1c",
  "commit_msg": "* libtiff/tif_next.c: fix potential out-of-bound write in NeXTDecode()\ntriggered by http://lcamtuf.coredump.cx/afl/vulns/libtiff5.tif\n(bugzilla #2508)",
  "pr_url": null,
  "pr_info": null,
  "file_name": "ChangeLog",
  "func_name": "",
  "raw_func_from_json": "NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++, cc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\tif( cc < 4 )\n\t\t\t\tgoto bad;\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n \t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n             if( isTiled(tif) )\n                 imagewidth = tif->tif_dir.td_tilewidth;\n \n \t\t\t/*\n \t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n \t\t\t\t * bounds, potentially resulting in a security\n \t\t\t\t * issue.\n \t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\n \t\t\t\t\tSETPIXEL(op, grey);\n \t\t\t\tif (npixels >= imagewidth)\n \t\t\t\t\tbreak;\n \t\t\t\tif (cc == 0)\n \t\t\t\t\tgoto bad;\n \t\t\t\tn = *bp++, cc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}\n",
  "diff_func": "@@ -1,3 +1,9 @@\n+2015-12-27  Even Rouault <even.rouault at spatialys.com>\n+\n+\t* libtiff/tif_next.c: fix potential out-of-bound write in NeXTDecode()\n+\ttriggered by http://lcamtuf.coredump.cx/afl/vulns/libtiff5.tif\n+\t(bugzilla #2508)\n+\n 2015-12-27  Even Rouault <even.rouault at spatialys.com>\n \n \t* libtiff/tif_luv.c: fix potential out-of-bound writes in decode",
  "project": "libtiff",
  "commit_id": "b18012dae552f85dcc5c57d3bf4e997a15b1cc1c",
  "target": 1,
  "func": "NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++, cc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\tif( cc < 4 )\n\t\t\t\tgoto bad;\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n \t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n             if( isTiled(tif) )\n                 imagewidth = tif->tif_dir.td_tilewidth;\n \n \t\t\t/*\n \t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n \t\t\t\t * bounds, potentially resulting in a security\n \t\t\t\t * issue.\n \t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\n \t\t\t\t\tSETPIXEL(op, grey);\n \t\t\t\tif (npixels >= imagewidth)\n \t\t\t\t\tbreak;\n \t\t\t\tif (cc == 0)\n \t\t\t\t\tgoto bad;\n \t\t\t\tn = *bp++, cc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}\n",
  "big_vul_idx": 180671,
  "idx": 2241,
  "hash": 79488190277959363230528255704370749024,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The commit message and code diff indicate a fix for a potential out-of-bound write in NeXTDecode(), which is a security vulnerability. The patch addresses an issue that could be exploited, fitting the criteria for a Security Vulnerability Fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}