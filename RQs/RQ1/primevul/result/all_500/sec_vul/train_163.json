{
  "id": 163,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/0xd61/imlib2/commit/ce94edca1ccfbe314cb7cd9453433fad404ec7ef",
  "commit_sha": "ce94edca1ccfbe314cb7cd9453433fad404ec7ef",
  "commit_msg": "Fix off-by-one OOB read in __imlib_MergeUpdate().\n\nPatch by Yuriy M. Kaminskiy.\n\nhttps://bugs.debian.org/819818",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/lib/updates.c",
  "func_name": "",
  "raw_func_from_json": "__imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n{\n   ImlibUpdate        *nu = NULL, *uu;\n   struct _tile       *t;\n   int                 tw, th, x, y, i;\n   int                *gaps = NULL;\n\n   /* if theres no rects to process.. return NULL */\n   if (!u)\n      return NULL;\n   tw = w >> TB;\n   if (w & TM)\n      tw++;\n   th = h >> TB;\n   if (h & TM)\n      th++;\n   t = malloc(tw * th * sizeof(struct _tile));\n   /* fill in tiles to be all not used */\n   for (i = 0, y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n           t[i++].used = T_UNUSED;\n     }\n   /* fill in all tiles */\n   for (uu = u; uu; uu = uu->next)\n     {\n        CLIP(uu->x, uu->y, uu->w, uu->h, 0, 0, w, h);\n        for (y = uu->y >> TB; y <= ((uu->y + uu->h - 1) >> TB); y++)\n          {\n             for (x = uu->x >> TB; x <= ((uu->x + uu->w - 1) >> TB); x++)\n                T(x, y).used = T_USED;\n          }\n     }\n   /* scan each line - if > hgapmax gaps between tiles, then fill smallest */\n   gaps = malloc(tw * sizeof(int));\n   for (y = 0; y < th; y++)\n     {\n        int                 hgaps = 0, start = -1, min;\n        char                have = 1, gap = 0;\n\n        for (x = 0; x < tw; x++)\n           gaps[x] = 0;\n        for (x = 0; x < tw; x++)\n          {\n             if ((have) && (T(x, y).used == T_UNUSED))\n               {\n                  start = x;\n                  gap = 1;\n                  have = 0;\n               }\n             else if ((!have) && (gap) && (T(x, y).used & T_USED))\n               {\n                  gap = 0;\n                  hgaps++;\n                  have = 1;\n                  gaps[start] = x - start;\n               }\n             else if (T(x, y).used & T_USED)\n                have = 1;\n          }\n        while (hgaps > hgapmax)\n          {\n             start = -1;\n             min = tw;\n\n             for (x = 0; x < tw; x++)\n               {\n                  if ((gaps[x] > 0) && (gaps[x] < min))\n                    {\n                       start = x;\n                       min = gaps[x];\n                    }\n               }\n             if (start >= 0)\n               {\n                  gaps[start] = 0;\n                  for (x = start;\n                       T(x, y).used == T_UNUSED; T(x++, y).used = T_USED);\n                  hgaps--;\n               }\n          }\n     }\n   free(gaps);\n   /* coalesce tiles into larger blocks and make new rect list */\n   for (y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n          {\n             if (T(x, y).used & T_USED)\n               {\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n                       (T(xx, y).used & T_USED) && (xx < tw); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                         {\n                            if (!(T(xx, yy).used & T_USED))\n                              {\n                                 ok = 0;\n                                 hh--;\n                                 break;\n                              }\n                         }\n                    }\n                  for (yy = y; yy < (y + hh); yy++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                          T(xx, yy).used = T_UNUSED;\n                    }\n                  nu = __imlib_AddUpdate(nu, (x << TB), (y << TB),\n                                         (ww << TB), (hh << TB));\n               }\n          }\n     }\n   free(t);\n   __imlib_FreeUpdates(u);\n   return nu;\n}\n",
  "diff_func": "@@ -112,7 +112,7 @@ __imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n-                       (T(xx, y).used & T_USED) && (xx < tw); xx++, ww++);\n+                       (xx < tw) && (T(xx, y).used & T_USED); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)",
  "project": "enlightment",
  "commit_id": "ce94edca1ccfbe314cb7cd9453433fad404ec7ef",
  "target": 1,
  "func": "__imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n{\n   ImlibUpdate        *nu = NULL, *uu;\n   struct _tile       *t;\n   int                 tw, th, x, y, i;\n   int                *gaps = NULL;\n\n   /* if theres no rects to process.. return NULL */\n   if (!u)\n      return NULL;\n   tw = w >> TB;\n   if (w & TM)\n      tw++;\n   th = h >> TB;\n   if (h & TM)\n      th++;\n   t = malloc(tw * th * sizeof(struct _tile));\n   /* fill in tiles to be all not used */\n   for (i = 0, y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n           t[i++].used = T_UNUSED;\n     }\n   /* fill in all tiles */\n   for (uu = u; uu; uu = uu->next)\n     {\n        CLIP(uu->x, uu->y, uu->w, uu->h, 0, 0, w, h);\n        for (y = uu->y >> TB; y <= ((uu->y + uu->h - 1) >> TB); y++)\n          {\n             for (x = uu->x >> TB; x <= ((uu->x + uu->w - 1) >> TB); x++)\n                T(x, y).used = T_USED;\n          }\n     }\n   /* scan each line - if > hgapmax gaps between tiles, then fill smallest */\n   gaps = malloc(tw * sizeof(int));\n   for (y = 0; y < th; y++)\n     {\n        int                 hgaps = 0, start = -1, min;\n        char                have = 1, gap = 0;\n\n        for (x = 0; x < tw; x++)\n           gaps[x] = 0;\n        for (x = 0; x < tw; x++)\n          {\n             if ((have) && (T(x, y).used == T_UNUSED))\n               {\n                  start = x;\n                  gap = 1;\n                  have = 0;\n               }\n             else if ((!have) && (gap) && (T(x, y).used & T_USED))\n               {\n                  gap = 0;\n                  hgaps++;\n                  have = 1;\n                  gaps[start] = x - start;\n               }\n             else if (T(x, y).used & T_USED)\n                have = 1;\n          }\n        while (hgaps > hgapmax)\n          {\n             start = -1;\n             min = tw;\n\n             for (x = 0; x < tw; x++)\n               {\n                  if ((gaps[x] > 0) && (gaps[x] < min))\n                    {\n                       start = x;\n                       min = gaps[x];\n                    }\n               }\n             if (start >= 0)\n               {\n                  gaps[start] = 0;\n                  for (x = start;\n                       T(x, y).used == T_UNUSED; T(x++, y).used = T_USED);\n                  hgaps--;\n               }\n          }\n     }\n   free(gaps);\n   /* coalesce tiles into larger blocks and make new rect list */\n   for (y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n          {\n             if (T(x, y).used & T_USED)\n               {\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n                       (T(xx, y).used & T_USED) && (xx < tw); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                         {\n                            if (!(T(xx, yy).used & T_USED))\n                              {\n                                 ok = 0;\n                                 hh--;\n                                 break;\n                              }\n                         }\n                    }\n                  for (yy = y; yy < (y + hh); yy++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                          T(xx, yy).used = T_UNUSED;\n                    }\n                  nu = __imlib_AddUpdate(nu, (x << TB), (y << TB),\n                                         (ww << TB), (hh << TB));\n               }\n          }\n     }\n   free(t);\n   __imlib_FreeUpdates(u);\n   return nu;\n}\n",
  "big_vul_idx": 178252,
  "idx": 290,
  "hash": 36599931638812584056030971307038057704,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an off-by-one error in the loop condition of the function __imlib_MergeUpdate(), which could lead to an out-of-bounds read. This type of error is a security vulnerability as it can result in unauthorized data access. The code change ensures that the loop correctly bounds the variable 'xx' to prevent accessing memory outside the intended array.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}