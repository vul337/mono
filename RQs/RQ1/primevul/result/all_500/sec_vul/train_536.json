{
  "id": 536,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/ljalves/linux_media/commit/5d81de8e8667da7135d3a32a964087c0faf5483f",
  "commit_sha": "5d81de8e8667da7135d3a32a964087c0faf5483f",
  "commit_msg": "cifs: ensure that uncached writes handle unmapped areas correctly\n\nIt's possible for userland to pass down an iovec via writev() that has a\nbogus user pointer in it. If that happens and we're doing an uncached\nwrite, then we can end up getting less bytes than we expect from the\ncall to iov_iter_copy_from_user. This is CVE-2014-0069\n\ncifs_iovec_write isn't set up to handle that situation however. It'll\nblindly keep chugging through the page array and not filling those pages\nwith anything useful. Worse yet, we'll later end up with a negative\nnumber in wdata->tailsz, which will confuse the sending routines and\ncause an oops at the very least.\n\nFix this by having the copy phase of cifs_iovec_write stop copying data\nin this situation and send the last write as a short one. At the same\ntime, we want to avoid sending a zero-length write to the server, so\nbreak out of the loop and set rc to -EFAULT if that happens. This also\nallows us to handle the case where no address in the iovec is valid.\n\n[Note: Marking this for stable on v3.4+ kernels, but kernels as old as\n       v2.6.38 may have a similar problem and may need similar fix]\n\nCc: <stable@vger.kernel.org> # v3.4+\nReviewed-by: Pavel Shilovsky <piastry@etersoft.ru>\nReported-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/cifs/file.c",
  "func_name": "",
  "raw_func_from_json": "cifs_iovec_write(struct file *file, const struct iovec *iov,\n \t\t unsigned long nr_segs, loff_t *poffset)\n {\n \tunsigned long nr_pages, i;\n\tsize_t copied, len, cur_len;\n \tssize_t total_written = 0;\n \tloff_t offset;\n \tstruct iov_iter it;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tint rc;\n\tpid_t pid;\n\n\tlen = iov_length(iov, nr_segs);\n\tif (!len)\n\t\treturn 0;\n\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\toffset = *poffset;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tiov_iter_init(&it, iov, nr_segs, len, 0);\n\tdo {\n\t\tsize_t save_len;\n\n\t\tnr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tbreak;\n\t\t}\n \n \t\tsave_len = cur_len;\n \t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tcopied = min_t(const size_t, cur_len, PAGE_SIZE);\n \t\t\tcopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n\t\t\t\t\t\t\t 0, copied);\n \t\t\tcur_len -= copied;\n \t\t\tiov_iter_advance(&it, copied);\n \t\t}\n \t\tcur_len = save_len - cur_len;\n \n \t\twdata->sync_mode = WB_SYNC_ALL;\n \t\twdata->nr_pages = nr_pages;\n \t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\trc = cifs_uncached_retry_writev(wdata);\n\t\tif (rc) {\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, &wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\trc = cifs_uncached_retry_writev(wdata);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}\n",
  "diff_func": "@@ -2389,7 +2389,7 @@ cifs_iovec_write(struct file *file, const struct iovec *iov,\n \t\t unsigned long nr_segs, loff_t *poffset)\n {\n \tunsigned long nr_pages, i;\n-\tsize_t copied, len, cur_len;\n+\tsize_t bytes, copied, len, cur_len;\n \tssize_t total_written = 0;\n \tloff_t offset;\n \tstruct iov_iter it;\n@@ -2444,14 +2444,45 @@ cifs_iovec_write(struct file *file, const struct iovec *iov,\n \n \t\tsave_len = cur_len;\n \t\tfor (i = 0; i < nr_pages; i++) {\n-\t\t\tcopied = min_t(const size_t, cur_len, PAGE_SIZE);\n+\t\t\tbytes = min_t(const size_t, cur_len, PAGE_SIZE);\n \t\t\tcopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n-\t\t\t\t\t\t\t 0, copied);\n+\t\t\t\t\t\t\t 0, bytes);\n \t\t\tcur_len -= copied;\n \t\t\tiov_iter_advance(&it, copied);\n+\t\t\t/*\n+\t\t\t * If we didn't copy as much as we expected, then that\n+\t\t\t * may mean we trod into an unmapped area. Stop copying\n+\t\t\t * at that point. On the next pass through the big\n+\t\t\t * loop, we'll likely end up getting a zero-length\n+\t\t\t * write and bailing out of it.\n+\t\t\t */\n+\t\t\tif (copied < bytes)\n+\t\t\t\tbreak;\n \t\t}\n \t\tcur_len = save_len - cur_len;\n \n+\t\t/*\n+\t\t * If we have no data to send, then that probably means that\n+\t\t * the copy above failed altogether. That's most likely because\n+\t\t * the address in the iovec was bogus. Set the rc to -EFAULT,\n+\t\t * free anything we allocated and bail out.\n+\t\t */\n+\t\tif (!cur_len) {\n+\t\t\tfor (i = 0; i < nr_pages; i++)\n+\t\t\t\tput_page(wdata->pages[i]);\n+\t\t\tkfree(wdata);\n+\t\t\trc = -EFAULT;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t/*\n+\t\t * i + 1 now represents the number of pages we actually used in\n+\t\t * the copy phase above. Bring nr_pages down to that, and free\n+\t\t * any pages that we didn't use.\n+\t\t */\n+\t\tfor ( ; nr_pages > i + 1; nr_pages--)\n+\t\t\tput_page(wdata->pages[nr_pages - 1]);\n+\n \t\twdata->sync_mode = WB_SYNC_ALL;\n \t\twdata->nr_pages = nr_pages;\n \t\twdata->offset = (__u64)offset;",
  "project": "linux",
  "commit_id": "5d81de8e8667da7135d3a32a964087c0faf5483f",
  "target": 1,
  "func": "cifs_iovec_write(struct file *file, const struct iovec *iov,\n \t\t unsigned long nr_segs, loff_t *poffset)\n {\n \tunsigned long nr_pages, i;\n\tsize_t copied, len, cur_len;\n \tssize_t total_written = 0;\n \tloff_t offset;\n \tstruct iov_iter it;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tint rc;\n\tpid_t pid;\n\n\tlen = iov_length(iov, nr_segs);\n\tif (!len)\n\t\treturn 0;\n\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\toffset = *poffset;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tiov_iter_init(&it, iov, nr_segs, len, 0);\n\tdo {\n\t\tsize_t save_len;\n\n\t\tnr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tbreak;\n\t\t}\n \n \t\tsave_len = cur_len;\n \t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tcopied = min_t(const size_t, cur_len, PAGE_SIZE);\n \t\t\tcopied = iov_iter_copy_from_user(wdata->pages[i], &it,\n\t\t\t\t\t\t\t 0, copied);\n \t\t\tcur_len -= copied;\n \t\t\tiov_iter_advance(&it, copied);\n \t\t}\n \t\tcur_len = save_len - cur_len;\n \n \t\twdata->sync_mode = WB_SYNC_ALL;\n \t\twdata->nr_pages = nr_pages;\n \t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\trc = cifs_uncached_retry_writev(wdata);\n\t\tif (rc) {\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, &wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\trc = cifs_uncached_retry_writev(wdata);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}\n",
  "big_vul_idx": 179634,
  "idx": 1343,
  "hash": 82332909522185401279552185166060953871,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security vulnerability (CVE-2014-0069) by handling invalid iovec pointers, preventing kernel crashes. The code changes include checks for incomplete data copying and error handling.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}