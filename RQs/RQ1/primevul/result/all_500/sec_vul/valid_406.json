{
  "id": 406,
  "language": "cpp",
  "cwe": "",
  "commit_url": "https://github.com/GioPan04/kde-connect/commit/542d94a70c56aa386c8d4d793481ce181b0422e8",
  "commit_sha": "542d94a70c56aa386c8d4d793481ce181b0422e8",
  "commit_msg": "Limit number of connected sockets from unpaired devices\n\nThanks Matthias Gerstner <mgerstner@suse.de> for reporting this.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "core/backends/lan/lanlinkprovider.cpp",
  "func_name": "",
  "raw_func_from_json": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    // Socket disconnection will now be handled by LanDeviceLink\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n\n    LanDeviceLink* deviceLink;\n    //Do we have a link for this device already?\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        //qCDebug(KDECONNECT_CORE) << \"Reusing link to\" << deviceId;\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            //We shouldn't have a pairinghandler if we didn't have a link.\n            //Crash if debug, recover if release (by setting the new devicelink to the old pairinghandler)\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}",
  "diff_func": "@@ -33,6 +33,8 @@\n \n #define MIN_VERSION_WITH_SSL_SUPPORT 6\n \n+static const int MAX_UNPAIRED_CONNECTIONS = 42;\n+\n LanLinkProvider::LanLinkProvider(\n         bool testMode,\n         quint16 udpBroadcastPort,\n@@ -580,6 +582,15 @@ void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, Netwo\n         deviceLink->reset(socket, connectionOrigin);\n     } else {\n         deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n+        // Socket disconnection will now be handled by LanDeviceLink\n+        disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n+        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n+        if (!isDeviceTrusted && m_links.size() > MAX_UNPAIRED_CONNECTIONS) {\n+            qCWarning(KDECONNECT_CORE) << \"Too many unpaired devices to remember them all. Ignoring \" << deviceId;\n+            socket->disconnectFromHost();\n+            socket->deleteLater();\n+            return;\n+        }\n         connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n         m_links[deviceId] = deviceLink;\n         if (m_pairingHandlers.contains(deviceId)) {",
  "func": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    // Socket disconnection will now be handled by LanDeviceLink\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n\n    LanDeviceLink* deviceLink;\n    //Do we have a link for this device already?\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        //qCDebug(KDECONNECT_CORE) << \"Reusing link to\" << deviceId;\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            //We shouldn't have a pairinghandler if we didn't have a link.\n            //Crash if debug, recover if release (by setting the new devicelink to the old pairinghandler)\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}",
  "project": "kdeconnect-kde",
  "hash": 173422384228019084279107414716208706323,
  "size": 25,
  "commit_id": "542d94a70c56aa386c8d4d793481ce181b0422e8",
  "message": "Limit number of connected sockets from unpaired devices\n\nThanks Matthias Gerstner <mgerstner@suse.de> for reporting this.",
  "target": 1,
  "dataset": "other",
  "idx": 195488,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch introduces a limit on unpaired device connections to prevent potential resource exhaustion, addressing a security concern.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}