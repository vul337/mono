{
  "id": 596,
  "language": "c",
  "cwe": "CWE-362",
  "commit_url": "https://github.com/viaembedded/arm-soc/commit/8b01fc86b9f425899f8a3a8fc1c47d73c2c20543",
  "commit_sha": "8b01fc86b9f425899f8a3a8fc1c47d73c2c20543",
  "commit_msg": "fs: take i_mutex during prepare_binprm for set[ug]id executables\n\nThis prevents a race between chown() and execve(), where chowning a\nsetuid-user binary to root would momentarily make the binary setuid\nroot.\n\nThis patch was mostly written by Linus Torvalds.\n\nSigned-off-by: Jann Horn <jann@thejh.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/exec.c",
  "func_name": "",
  "raw_func_from_json": " int prepare_binprm(struct linux_binprm *bprm)\n {\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n \tint retval;\n \n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n \n \t/* fill in binprm security blob */\n \tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}\n",
  "diff_func": "@@ -1275,6 +1275,53 @@ static void check_unsafe_exec(struct linux_binprm *bprm)\n \tspin_unlock(&p->fs->lock);\n }\n \n+static void bprm_fill_uid(struct linux_binprm *bprm)\n+{\n+\tstruct inode *inode;\n+\tunsigned int mode;\n+\tkuid_t uid;\n+\tkgid_t gid;\n+\n+\t/* clear any previous set[ug]id data from a previous binary */\n+\tbprm->cred->euid = current_euid();\n+\tbprm->cred->egid = current_egid();\n+\n+\tif (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)\n+\t\treturn;\n+\n+\tif (task_no_new_privs(current))\n+\t\treturn;\n+\n+\tinode = file_inode(bprm->file);\n+\tmode = READ_ONCE(inode->i_mode);\n+\tif (!(mode & (S_ISUID|S_ISGID)))\n+\t\treturn;\n+\n+\t/* Be careful if suid/sgid is set */\n+\tmutex_lock(&inode->i_mutex);\n+\n+\t/* reload atomically mode/uid/gid now that lock held */\n+\tmode = inode->i_mode;\n+\tuid = inode->i_uid;\n+\tgid = inode->i_gid;\n+\tmutex_unlock(&inode->i_mutex);\n+\n+\t/* We ignore suid/sgid if there are no mappings for them in the ns */\n+\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n+\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n+\t\treturn;\n+\n+\tif (mode & S_ISUID) {\n+\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n+\t\tbprm->cred->euid = uid;\n+\t}\n+\n+\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n+\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n+\t\tbprm->cred->egid = gid;\n+\t}\n+}\n+\n /*\n  * Fill the binprm structure from the inode.\n  * Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes\n@@ -1283,36 +1330,9 @@ static void check_unsafe_exec(struct linux_binprm *bprm)\n  */\n int prepare_binprm(struct linux_binprm *bprm)\n {\n-\tstruct inode *inode = file_inode(bprm->file);\n-\tumode_t mode = inode->i_mode;\n \tint retval;\n \n-\n-\t/* clear any previous set[ug]id data from a previous binary */\n-\tbprm->cred->euid = current_euid();\n-\tbprm->cred->egid = current_egid();\n-\n-\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n-\t    !task_no_new_privs(current) &&\n-\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n-\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n-\t\t/* Set-uid? */\n-\t\tif (mode & S_ISUID) {\n-\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n-\t\t\tbprm->cred->euid = inode->i_uid;\n-\t\t}\n-\n-\t\t/* Set-gid? */\n-\t\t/*\n-\t\t * If setgid is set but no group execute bit then this\n-\t\t * is a candidate for mandatory locking, not a setgid\n-\t\t * executable.\n-\t\t */\n-\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n-\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n-\t\t\tbprm->cred->egid = inode->i_gid;\n-\t\t}\n-\t}\n+\tbprm_fill_uid(bprm);\n \n \t/* fill in binprm security blob */\n \tretval = security_bprm_set_creds(bprm);",
  "project": "linux",
  "commit_id": "8b01fc86b9f425899f8a3a8fc1c47d73c2c20543",
  "target": 1,
  "func": " int prepare_binprm(struct linux_binprm *bprm)\n {\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n \tint retval;\n \n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n \n \t/* fill in binprm security blob */\n \tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}\n",
  "big_vul_idx": 179797,
  "idx": 1480,
  "hash": 335498349453083006685277225065572088694,
  "Bug Filter": "Security Vulnerability Fix**\n\n**Confidence Score: 0.95**",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a race condition that could allow a setuid binary to be temporarily exploited, which is a clear security vulnerability. The added lock ensures atomic reading of file attributes, preventing unauthorized privilege escalation.\n\n**Final Classification: Security Vulnerability Fix**\n\n**Confidence Score: 0.95**"
}