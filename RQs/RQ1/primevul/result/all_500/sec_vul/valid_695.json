{
  "id": 695,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/uranix/ghostpdl/commit/b184e783702246e154294326d03d9abda669fcfa",
  "commit_sha": "b184e783702246e154294326d03d9abda669fcfa",
  "commit_msg": "Bug 697703: Prevent integer overflow vulnerability.\n\nAdd extra check for the offset being greater than the size\nof the image and hence reading off the end of the buffer.\n\nThank you to Dai Ge for finding this issue and suggesting a patch.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "jbig2dec/jbig2_symbol_dict.c",
  "func_name": "",
  "raw_func_from_json": "jbig2_decode_symbol_dict(Jbig2Ctx *ctx,\n                         Jbig2Segment *segment,\n                         const Jbig2SymbolDictParams *params, const byte *data, size_t size, Jbig2ArithCx *GB_stats, Jbig2ArithCx *GR_stats)\n{\n    Jbig2SymbolDict *SDNEWSYMS = NULL;\n    Jbig2SymbolDict *SDEXSYMS = NULL;\n    uint32_t HCHEIGHT;\n    uint32_t NSYMSDECODED;\n    uint32_t SYMWIDTH, TOTWIDTH;\n    uint32_t HCFIRSTSYM;\n    uint32_t *SDNEWSYMWIDTHS = NULL;\n    int SBSYMCODELEN = 0;\n    Jbig2WordStream *ws = NULL;\n    Jbig2HuffmanState *hs = NULL;\n    Jbig2HuffmanTable *SDHUFFRDX = NULL;\n    Jbig2HuffmanTable *SBHUFFRSIZE = NULL;\n    Jbig2ArithState *as = NULL;\n    Jbig2ArithIntCtx *IADH = NULL;\n    Jbig2ArithIntCtx *IADW = NULL;\n    Jbig2ArithIntCtx *IAEX = NULL;\n    Jbig2ArithIntCtx *IAAI = NULL;\n    Jbig2ArithIaidCtx *IAID = NULL;\n    Jbig2ArithIntCtx *IARDX = NULL;\n    Jbig2ArithIntCtx *IARDY = NULL;\n    int code = 0;\n    Jbig2SymbolDict **refagg_dicts = NULL;\n    int n_refagg_dicts = 1;\n\n    Jbig2TextRegionParams *tparams = NULL;\n\n    /* 6.5.5 (3) */\n    HCHEIGHT = 0;\n    NSYMSDECODED = 0;\n\n    ws = jbig2_word_stream_buf_new(ctx, data, size);\n    if (ws == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate ws in jbig2_decode_symbol_dict\");\n        return NULL;\n    }\n\n    as = jbig2_arith_new(ctx, ws);\n    if (as == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate as in jbig2_decode_symbol_dict\");\n        jbig2_word_stream_buf_free(ctx, ws);\n        return NULL;\n    }\n\n    if (!params->SDHUFF) {\n        IADH = jbig2_arith_int_ctx_new(ctx);\n        IADW = jbig2_arith_int_ctx_new(ctx);\n        IAEX = jbig2_arith_int_ctx_new(ctx);\n        IAAI = jbig2_arith_int_ctx_new(ctx);\n        if ((IADH == NULL) || (IADW == NULL) || (IAEX == NULL) || (IAAI == NULL)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n            goto cleanup1;\n        }\n        if (params->SDREFAGG) {\n            int64_t tmp = params->SDNUMINSYMS + params->SDNUMNEWSYMS;\n\n            for (SBSYMCODELEN = 0; ((int64_t) 1 << SBSYMCODELEN) < tmp; SBSYMCODELEN++);\n            IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);\n            IARDX = jbig2_arith_int_ctx_new(ctx);\n            IARDY = jbig2_arith_int_ctx_new(ctx);\n            if ((IAID == NULL) || (IARDX == NULL) || (IARDY == NULL)) {\n                jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n                goto cleanup2;\n            }\n        }\n    } else {\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"huffman coded symbol dictionary\");\n        hs = jbig2_huffman_new(ctx, ws);\n        SDHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);\n        SBHUFFRSIZE = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_A);\n        if ((hs == NULL) || (SDHUFFRDX == NULL) || (SBHUFFRSIZE == NULL)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n            goto cleanup2;\n        }\n        if (!params->SDREFAGG) {\n            SDNEWSYMWIDTHS = jbig2_new(ctx, uint32_t, params->SDNUMNEWSYMS);\n            if (SDNEWSYMWIDTHS == NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate storage for (%u) symbol widths\", params->SDNUMNEWSYMS);\n                goto cleanup2;\n            }\n        }\n    }\n\n    SDNEWSYMS = jbig2_sd_new(ctx, params->SDNUMNEWSYMS);\n    if (SDNEWSYMS == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"could not allocate storage for (%u) new symbols\", params->SDNUMNEWSYMS);\n        goto cleanup2;\n    }\n\n    /* 6.5.5 (4a) */\n    while (NSYMSDECODED < params->SDNUMNEWSYMS) {\n        int32_t HCDH, DW;\n\n        /* 6.5.6 */\n        if (params->SDHUFF) {\n            HCDH = jbig2_huffman_get(hs, params->SDHUFFDH, &code);\n        } else {\n            code = jbig2_arith_int_decode(IADH, as, &HCDH);\n        }\n\n        if (code != 0) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"error or OOB decoding height class delta (%d)\\n\", code);\n        }\n\n        if (!params->SDHUFF && jbig2_arith_has_reached_marker(as)) {\n            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"prevent DOS while decoding height classes\");\n            goto cleanup2;\n        }\n\n        /* 6.5.5 (4b) */\n        HCHEIGHT = HCHEIGHT + HCDH;\n        SYMWIDTH = 0;\n        TOTWIDTH = 0;\n        HCFIRSTSYM = NSYMSDECODED;\n\n        if ((int32_t) HCHEIGHT < 0) {\n            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid HCHEIGHT value\");\n            goto cleanup2;\n        }\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"HCHEIGHT = %d\", HCHEIGHT);\n#endif\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoding height class %d with %d syms decoded\", HCHEIGHT, NSYMSDECODED);\n\n        for (;;) {\n            /* 6.5.7 */\n            if (params->SDHUFF) {\n                DW = jbig2_huffman_get(hs, params->SDHUFFDW, &code);\n            } else {\n                code = jbig2_arith_int_decode(IADW, as, &DW);\n            }\n            if (code < 0)\n                goto cleanup4;\n\n            /* 6.5.5 (4c.i) */\n            if (code == 1) {\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \" OOB signals end of height class %d\", HCHEIGHT);\n                break;\n            }\n\n            /* check for broken symbol table */\n            if (NSYMSDECODED >= params->SDNUMNEWSYMS) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"No OOB signalling end of height class %d\", HCHEIGHT);\n                goto cleanup4;\n            }\n\n            SYMWIDTH = SYMWIDTH + DW;\n            TOTWIDTH = TOTWIDTH + SYMWIDTH;\n            if ((int32_t) SYMWIDTH < 0) {\n                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid SYMWIDTH value (%d) at symbol %d\", SYMWIDTH, NSYMSDECODED + 1);\n                goto cleanup4;\n            }\n#ifdef JBIG2_DEBUG\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SYMWIDTH = %d TOTWIDTH = %d\", SYMWIDTH, TOTWIDTH);\n#endif\n            /* 6.5.5 (4c.ii) */\n            if (!params->SDHUFF || params->SDREFAGG) {\n#ifdef JBIG2_DEBUG\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SDHUFF = %d; SDREFAGG = %d\", params->SDHUFF, params->SDREFAGG);\n#endif\n                /* 6.5.8 */\n                if (!params->SDREFAGG) {\n                    Jbig2GenericRegionParams region_params;\n                    int sdat_bytes;\n                    Jbig2Image *image;\n\n                    /* Table 16 */\n                    region_params.MMR = 0;\n                    region_params.GBTEMPLATE = params->SDTEMPLATE;\n                    region_params.TPGDON = 0;\n                    region_params.USESKIP = 0;\n                    sdat_bytes = params->SDTEMPLATE == 0 ? 8 : 2;\n                    memcpy(region_params.gbat, params->sdat, sdat_bytes);\n\n                    image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                    if (image == NULL) {\n                        code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate image in jbig2_decode_symbol_dict\");\n                        goto cleanup4;\n                    }\n\n                    code = jbig2_decode_generic_region(ctx, segment, &region_params, as, image, GB_stats);\n                    if (code < 0) {\n                        jbig2_image_release(ctx, image);\n                        goto cleanup4;\n                    }\n\n                    SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n                } else {\n                    /* 6.5.8.2 refinement/aggregate symbol */\n                    uint32_t REFAGGNINST;\n\n                    if (params->SDHUFF) {\n                        REFAGGNINST = jbig2_huffman_get(hs, params->SDHUFFAGGINST, &code);\n                    } else {\n                        code = jbig2_arith_int_decode(IAAI, as, (int32_t *) & REFAGGNINST);\n                    }\n                    if (code || (int32_t) REFAGGNINST <= 0) {\n                        code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"invalid number of symbols or OOB in aggregate glyph\");\n                        goto cleanup4;\n                    }\n\n                    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"aggregate symbol coding (%d instances)\", REFAGGNINST);\n\n                    if (REFAGGNINST > 1) {\n                        Jbig2Image *image;\n                        uint32_t i;\n\n                        if (tparams == NULL) {\n                            /* First time through, we need to initialise the */\n                            /* various tables for Huffman or adaptive encoding */\n                            /* as well as the text region parameters structure */\n                            refagg_dicts = jbig2_new(ctx, Jbig2SymbolDict *, n_refagg_dicts);\n                            if (refagg_dicts == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating dictionary array\");\n                                goto cleanup4;\n                            }\n                            refagg_dicts[0] = jbig2_sd_new(ctx, params->SDNUMINSYMS + params->SDNUMNEWSYMS);\n                            if (refagg_dicts[0] == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating symbol dictionary\");\n                                jbig2_free(ctx->allocator, refagg_dicts);\n                                goto cleanup4;\n                            }\n                            for (i = 0; i < params->SDNUMINSYMS; i++) {\n                                refagg_dicts[0]->glyphs[i] = jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]);\n                            }\n\n                            tparams = jbig2_new(ctx, Jbig2TextRegionParams, 1);\n                            if (tparams == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating text region params\");\n                                goto cleanup4;\n                            }\n                            if (!params->SDHUFF) {\n                                /* Values from Table 17, section 6.5.8.2 (2) */\n                                tparams->IADT = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IAFS = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IADS = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IAIT = jbig2_arith_int_ctx_new(ctx);\n                                /* Table 31 */\n                                for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < (int)(params->SDNUMINSYMS + params->SDNUMNEWSYMS); SBSYMCODELEN++);\n                                tparams->IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);\n                                tparams->IARI = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDW = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDH = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDX = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDY = jbig2_arith_int_ctx_new(ctx);\n                            } else {\n                                tparams->SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_F);    /* Table B.6 */\n                                tparams->SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_H);    /* Table B.8 */\n                                tparams->SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_K);    /* Table B.11 */\n                                tparams->SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                            }\n                            tparams->SBHUFF = params->SDHUFF;\n                            tparams->SBREFINE = 1;\n                            tparams->SBSTRIPS = 1;\n                            tparams->SBDEFPIXEL = 0;\n                            tparams->SBCOMBOP = JBIG2_COMPOSE_OR;\n                            tparams->TRANSPOSED = 0;\n                            tparams->REFCORNER = JBIG2_CORNER_TOPLEFT;\n                            tparams->SBDSOFFSET = 0;\n                            tparams->SBRTEMPLATE = params->SDRTEMPLATE;\n                        }\n                        tparams->SBNUMINSTANCES = REFAGGNINST;\n\n                        image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                        if (image == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");\n                            goto cleanup4;\n                        }\n\n                        /* multiple symbols are handled as a text region */\n                        jbig2_decode_text_region(ctx, segment, tparams, (const Jbig2SymbolDict * const *)refagg_dicts,\n                                                 n_refagg_dicts, image, data, size, GR_stats, as, ws);\n\n                        SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n                        refagg_dicts[0]->glyphs[params->SDNUMINSYMS + NSYMSDECODED] = jbig2_image_clone(ctx, SDNEWSYMS->glyphs[NSYMSDECODED]);\n                    } else {\n                        /* 6.5.8.2.2 */\n                        /* bool SBHUFF = params->SDHUFF; */\n                        Jbig2RefinementRegionParams rparams;\n                        Jbig2Image *image;\n                        uint32_t ID;\n                        int32_t RDX, RDY;\n                        int BMSIZE = 0;\n                        uint32_t ninsyms = params->SDNUMINSYMS;\n                        int code1 = 0;\n                        int code2 = 0;\n                        int code3 = 0;\n                        int code4 = 0;\n\n                        /* 6.5.8.2.2 (2, 3, 4, 5) */\n                        if (params->SDHUFF) {\n                            ID = jbig2_huffman_get_bits(hs, SBSYMCODELEN, &code4);\n                            RDX = jbig2_huffman_get(hs, SDHUFFRDX, &code1);\n                            RDY = jbig2_huffman_get(hs, SDHUFFRDX, &code2);\n                            BMSIZE = jbig2_huffman_get(hs, SBHUFFRSIZE, &code3);\n                            jbig2_huffman_skip(hs);\n                        } else {\n                            code1 = jbig2_arith_iaid_decode(IAID, as, (int32_t *) & ID);\n                            code2 = jbig2_arith_int_decode(IARDX, as, &RDX);\n                            code3 = jbig2_arith_int_decode(IARDY, as, &RDY);\n                        }\n\n                        if ((code1 < 0) || (code2 < 0) || (code3 < 0) || (code4 < 0)) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode data\");\n                            goto cleanup4;\n                        }\n\n                        if (ID >= ninsyms + NSYMSDECODED) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"refinement references unknown symbol %d\", ID);\n                            goto cleanup4;\n                        }\n\n                        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                                    \"symbol is a refinement of id %d with the \" \"refinement applied at (%d,%d)\", ID, RDX, RDY);\n\n                        image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                        if (image == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");\n                            goto cleanup4;\n                        }\n\n                        /* Table 18 */\n                        rparams.GRTEMPLATE = params->SDRTEMPLATE;\n                        rparams.reference = (ID < ninsyms) ? params->SDINSYMS->glyphs[ID] : SDNEWSYMS->glyphs[ID - ninsyms];\n                        /* SumatraPDF: fail on missing glyphs */\n                        if (rparams.reference == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"missing glyph %d/%d!\", ID, ninsyms);\n                            jbig2_image_release(ctx, image);\n                            goto cleanup4;\n                        }\n                        rparams.DX = RDX;\n                        rparams.DY = RDY;\n                        rparams.TPGRON = 0;\n                        memcpy(rparams.grat, params->sdrat, 4);\n                        code = jbig2_decode_refinement_region(ctx, segment, &rparams, as, image, GR_stats);\n                        if (code < 0)\n                            goto cleanup4;\n\n                        SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n\n                        /* 6.5.8.2.2 (7) */\n                        if (params->SDHUFF) {\n                            if (BMSIZE == 0)\n                                BMSIZE = image->height * image->stride;\n                            jbig2_huffman_advance(hs, BMSIZE);\n                        }\n                    }\n                }\n\n#ifdef OUTPUT_PBM\n                {\n                    char name[64];\n                    FILE *out;\n\n                    snprintf(name, 64, \"sd.%04d.%04d.pbm\", segment->number, NSYMSDECODED);\n                    out = fopen(name, \"wb\");\n                    jbig2_image_write_pbm(SDNEWSYMS->glyphs[NSYMSDECODED], out);\n                    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"writing out glyph as '%s' ...\", name);\n                    fclose(out);\n                }\n#endif\n\n            }\n\n            /* 6.5.5 (4c.iii) */\n            if (params->SDHUFF && !params->SDREFAGG) {\n                SDNEWSYMWIDTHS[NSYMSDECODED] = SYMWIDTH;\n            }\n\n            /* 6.5.5 (4c.iv) */\n            NSYMSDECODED = NSYMSDECODED + 1;\n\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoded symbol %u of %u (%ux%u)\", NSYMSDECODED, params->SDNUMNEWSYMS, SYMWIDTH, HCHEIGHT);\n\n        }                       /* end height class decode loop */\n\n        /* 6.5.5 (4d) */\n        if (params->SDHUFF && !params->SDREFAGG) {\n            /* 6.5.9 */\n            Jbig2Image *image;\n            uint32_t BMSIZE = jbig2_huffman_get(hs, params->SDHUFFBMSIZE, &code);\n            uint32_t j;\n            int x;\n\n            if (code) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding size of collective bitmap!\");\n                goto cleanup4;\n            }\n\n            /* skip any bits before the next byte boundary */\n            jbig2_huffman_skip(hs);\n\n            image = jbig2_image_new(ctx, TOTWIDTH, HCHEIGHT);\n            if (image == NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate collective bitmap image!\");\n                goto cleanup4;\n            }\n\n            if (BMSIZE == 0) {\n                /* if BMSIZE == 0 bitmap is uncompressed */\n                const byte *src = data + jbig2_huffman_offset(hs);\n                const int stride = (image->width >> 3) + ((image->width & 7) ? 1 : 0);\n                byte *dst = image->data;\n\n                /* SumatraPDF: prevent read access violation */\n                if (size - jbig2_huffman_offset(hs) < image->height * stride) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", image->height * stride,\n                                size - jbig2_huffman_offset(hs));\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n\n                BMSIZE = image->height * stride;\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                            \"reading %dx%d uncompressed bitmap\" \" for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);\n\n                for (j = 0; j < image->height; j++) {\n                    memcpy(dst, src, stride);\n                    dst += image->stride;\n                    src += stride;\n                }\n            } else {\n                Jbig2GenericRegionParams rparams;\n\n                /* SumatraPDF: prevent read access violation */\n                if (size - jbig2_huffman_offset(hs) < BMSIZE) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", BMSIZE, size - jbig2_huffman_offset(hs));\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                            \"reading %dx%d collective bitmap for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);\n\n                rparams.MMR = 1;\n                code = jbig2_decode_generic_mmr(ctx, segment, &rparams, data + jbig2_huffman_offset(hs), BMSIZE, image);\n                if (code) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding MMR bitmap image!\");\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n            }\n\n            /* advance past the data we've just read */\n            jbig2_huffman_advance(hs, BMSIZE);\n\n            /* copy the collective bitmap into the symbol dictionary */\n            x = 0;\n            for (j = HCFIRSTSYM; j < NSYMSDECODED; j++) {\n                Jbig2Image *glyph;\n\n                glyph = jbig2_image_new(ctx, SDNEWSYMWIDTHS[j], HCHEIGHT);\n                if (glyph == NULL) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to copy the collective bitmap into symbol dictionary\");\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n                jbig2_image_compose(ctx, glyph, image, -x, 0, JBIG2_COMPOSE_REPLACE);\n                x += SDNEWSYMWIDTHS[j];\n                SDNEWSYMS->glyphs[j] = glyph;\n            }\n            jbig2_image_release(ctx, image);\n        }\n\n    }                           /* end of symbol decode loop */\n\n    /* 6.5.10 */\n    SDEXSYMS = jbig2_sd_new(ctx, params->SDNUMEXSYMS);\n    if (SDEXSYMS == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate symbols exported from symbols dictionary\");\n        goto cleanup4;\n    } else {\n        uint32_t i = 0;\n        uint32_t j = 0;\n        uint32_t k;\n        int exflag = 0;\n        uint32_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;\n        uint32_t exrunlength;\n        int zerolength = 0;\n\n        while (i < limit) {\n            if (params->SDHUFF)\n                exrunlength = jbig2_huffman_get(hs, SBHUFFRSIZE, &code);\n            else\n                code = jbig2_arith_int_decode(IAEX, as, (int32_t *)&exrunlength);\n            /* prevent infinite loop */\n            zerolength = exrunlength > 0 ? 0 : zerolength + 1;\n            if (code || (exrunlength > limit - i) || (zerolength > 4) || (exflag && (exrunlength + j > params->SDNUMEXSYMS))) {\n                if (code)\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode exrunlength for exported symbols\");\n                else if (exrunlength <= 0)\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"runlength too small in export symbol table (%d <= 0)\\n\", exrunlength);\n                else\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number,\n                                \"runlength too large in export symbol table (%d > %d - %d)\\n\", exrunlength, params->SDNUMEXSYMS, j);\n                /* skip to the cleanup code and return SDEXSYMS = NULL */\n                jbig2_sd_release(ctx, SDEXSYMS);\n                SDEXSYMS = NULL;\n                break;\n            }\n            for (k = 0; k < exrunlength; k++) {\n                if (exflag) {\n                    SDEXSYMS->glyphs[j++] = (i < params->SDNUMINSYMS) ?\n                                            jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]) : jbig2_image_clone(ctx, SDNEWSYMS->glyphs[i - params->SDNUMINSYMS]);\n                }\n                i++;\n            }\n            exflag = !exflag;\n        }\n    }\n\ncleanup4:\n    if (tparams != NULL) {\n        if (!params->SDHUFF) {\n            jbig2_arith_int_ctx_free(ctx, tparams->IADT);\n            jbig2_arith_int_ctx_free(ctx, tparams->IAFS);\n            jbig2_arith_int_ctx_free(ctx, tparams->IADS);\n            jbig2_arith_int_ctx_free(ctx, tparams->IAIT);\n            jbig2_arith_iaid_ctx_free(ctx, tparams->IAID);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARI);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDW);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDH);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDX);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDY);\n        } else {\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFFS);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFDS);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFDT);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDX);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDY);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDW);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDH);\n        }\n        jbig2_free(ctx->allocator, tparams);\n    }\n    if (refagg_dicts != NULL) {\n        jbig2_sd_release(ctx, refagg_dicts[0]);\n        jbig2_free(ctx->allocator, refagg_dicts);\n    }\n\ncleanup2:\n    jbig2_sd_release(ctx, SDNEWSYMS);\n    if (params->SDHUFF && !params->SDREFAGG) {\n        jbig2_free(ctx->allocator, SDNEWSYMWIDTHS);\n    }\n    jbig2_release_huffman_table(ctx, SDHUFFRDX);\n    jbig2_release_huffman_table(ctx, SBHUFFRSIZE);\n    jbig2_huffman_free(ctx, hs);\n    jbig2_arith_iaid_ctx_free(ctx, IAID);\n    jbig2_arith_int_ctx_free(ctx, IARDX);\n    jbig2_arith_int_ctx_free(ctx, IARDY);\n\ncleanup1:\n    jbig2_word_stream_buf_free(ctx, ws);\n    jbig2_free(ctx->allocator, as);\n    jbig2_arith_int_ctx_free(ctx, IADH);\n    jbig2_arith_int_ctx_free(ctx, IADW);\n    jbig2_arith_int_ctx_free(ctx, IAEX);\n    jbig2_arith_int_ctx_free(ctx, IAAI);\n\n    return SDEXSYMS;\n}",
  "diff_func": "@@ -629,7 +629,7 @@ jbig2_decode_symbol_dict(Jbig2Ctx *ctx,\n                 byte *dst = image->data;\n \n                 /* SumatraPDF: prevent read access violation */\n-                if (size - jbig2_huffman_offset(hs) < image->height * stride) {\n+                if ((size - jbig2_huffman_offset(hs) < image->height * stride) || (size < jbig2_huffman_offset(hs))) {\n                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", image->height * stride,\n                                 size - jbig2_huffman_offset(hs));\n                     jbig2_image_release(ctx, image);",
  "func": "jbig2_decode_symbol_dict(Jbig2Ctx *ctx,\n                         Jbig2Segment *segment,\n                         const Jbig2SymbolDictParams *params, const byte *data, size_t size, Jbig2ArithCx *GB_stats, Jbig2ArithCx *GR_stats)\n{\n    Jbig2SymbolDict *SDNEWSYMS = NULL;\n    Jbig2SymbolDict *SDEXSYMS = NULL;\n    uint32_t HCHEIGHT;\n    uint32_t NSYMSDECODED;\n    uint32_t SYMWIDTH, TOTWIDTH;\n    uint32_t HCFIRSTSYM;\n    uint32_t *SDNEWSYMWIDTHS = NULL;\n    int SBSYMCODELEN = 0;\n    Jbig2WordStream *ws = NULL;\n    Jbig2HuffmanState *hs = NULL;\n    Jbig2HuffmanTable *SDHUFFRDX = NULL;\n    Jbig2HuffmanTable *SBHUFFRSIZE = NULL;\n    Jbig2ArithState *as = NULL;\n    Jbig2ArithIntCtx *IADH = NULL;\n    Jbig2ArithIntCtx *IADW = NULL;\n    Jbig2ArithIntCtx *IAEX = NULL;\n    Jbig2ArithIntCtx *IAAI = NULL;\n    Jbig2ArithIaidCtx *IAID = NULL;\n    Jbig2ArithIntCtx *IARDX = NULL;\n    Jbig2ArithIntCtx *IARDY = NULL;\n    int code = 0;\n    Jbig2SymbolDict **refagg_dicts = NULL;\n    int n_refagg_dicts = 1;\n\n    Jbig2TextRegionParams *tparams = NULL;\n\n    /* 6.5.5 (3) */\n    HCHEIGHT = 0;\n    NSYMSDECODED = 0;\n\n    ws = jbig2_word_stream_buf_new(ctx, data, size);\n    if (ws == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate ws in jbig2_decode_symbol_dict\");\n        return NULL;\n    }\n\n    as = jbig2_arith_new(ctx, ws);\n    if (as == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate as in jbig2_decode_symbol_dict\");\n        jbig2_word_stream_buf_free(ctx, ws);\n        return NULL;\n    }\n\n    if (!params->SDHUFF) {\n        IADH = jbig2_arith_int_ctx_new(ctx);\n        IADW = jbig2_arith_int_ctx_new(ctx);\n        IAEX = jbig2_arith_int_ctx_new(ctx);\n        IAAI = jbig2_arith_int_ctx_new(ctx);\n        if ((IADH == NULL) || (IADW == NULL) || (IAEX == NULL) || (IAAI == NULL)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n            goto cleanup1;\n        }\n        if (params->SDREFAGG) {\n            int64_t tmp = params->SDNUMINSYMS + params->SDNUMNEWSYMS;\n\n            for (SBSYMCODELEN = 0; ((int64_t) 1 << SBSYMCODELEN) < tmp; SBSYMCODELEN++);\n            IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);\n            IARDX = jbig2_arith_int_ctx_new(ctx);\n            IARDY = jbig2_arith_int_ctx_new(ctx);\n            if ((IAID == NULL) || (IARDX == NULL) || (IARDY == NULL)) {\n                jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n                goto cleanup2;\n            }\n        }\n    } else {\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"huffman coded symbol dictionary\");\n        hs = jbig2_huffman_new(ctx, ws);\n        SDHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);\n        SBHUFFRSIZE = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_A);\n        if ((hs == NULL) || (SDHUFFRDX == NULL) || (SBHUFFRSIZE == NULL)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");\n            goto cleanup2;\n        }\n        if (!params->SDREFAGG) {\n            SDNEWSYMWIDTHS = jbig2_new(ctx, uint32_t, params->SDNUMNEWSYMS);\n            if (SDNEWSYMWIDTHS == NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate storage for (%u) symbol widths\", params->SDNUMNEWSYMS);\n                goto cleanup2;\n            }\n        }\n    }\n\n    SDNEWSYMS = jbig2_sd_new(ctx, params->SDNUMNEWSYMS);\n    if (SDNEWSYMS == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"could not allocate storage for (%u) new symbols\", params->SDNUMNEWSYMS);\n        goto cleanup2;\n    }\n\n    /* 6.5.5 (4a) */\n    while (NSYMSDECODED < params->SDNUMNEWSYMS) {\n        int32_t HCDH, DW;\n\n        /* 6.5.6 */\n        if (params->SDHUFF) {\n            HCDH = jbig2_huffman_get(hs, params->SDHUFFDH, &code);\n        } else {\n            code = jbig2_arith_int_decode(IADH, as, &HCDH);\n        }\n\n        if (code != 0) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"error or OOB decoding height class delta (%d)\\n\", code);\n        }\n\n        if (!params->SDHUFF && jbig2_arith_has_reached_marker(as)) {\n            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"prevent DOS while decoding height classes\");\n            goto cleanup2;\n        }\n\n        /* 6.5.5 (4b) */\n        HCHEIGHT = HCHEIGHT + HCDH;\n        SYMWIDTH = 0;\n        TOTWIDTH = 0;\n        HCFIRSTSYM = NSYMSDECODED;\n\n        if ((int32_t) HCHEIGHT < 0) {\n            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid HCHEIGHT value\");\n            goto cleanup2;\n        }\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"HCHEIGHT = %d\", HCHEIGHT);\n#endif\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoding height class %d with %d syms decoded\", HCHEIGHT, NSYMSDECODED);\n\n        for (;;) {\n            /* 6.5.7 */\n            if (params->SDHUFF) {\n                DW = jbig2_huffman_get(hs, params->SDHUFFDW, &code);\n            } else {\n                code = jbig2_arith_int_decode(IADW, as, &DW);\n            }\n            if (code < 0)\n                goto cleanup4;\n\n            /* 6.5.5 (4c.i) */\n            if (code == 1) {\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \" OOB signals end of height class %d\", HCHEIGHT);\n                break;\n            }\n\n            /* check for broken symbol table */\n            if (NSYMSDECODED >= params->SDNUMNEWSYMS) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"No OOB signalling end of height class %d\", HCHEIGHT);\n                goto cleanup4;\n            }\n\n            SYMWIDTH = SYMWIDTH + DW;\n            TOTWIDTH = TOTWIDTH + SYMWIDTH;\n            if ((int32_t) SYMWIDTH < 0) {\n                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid SYMWIDTH value (%d) at symbol %d\", SYMWIDTH, NSYMSDECODED + 1);\n                goto cleanup4;\n            }\n#ifdef JBIG2_DEBUG\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SYMWIDTH = %d TOTWIDTH = %d\", SYMWIDTH, TOTWIDTH);\n#endif\n            /* 6.5.5 (4c.ii) */\n            if (!params->SDHUFF || params->SDREFAGG) {\n#ifdef JBIG2_DEBUG\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SDHUFF = %d; SDREFAGG = %d\", params->SDHUFF, params->SDREFAGG);\n#endif\n                /* 6.5.8 */\n                if (!params->SDREFAGG) {\n                    Jbig2GenericRegionParams region_params;\n                    int sdat_bytes;\n                    Jbig2Image *image;\n\n                    /* Table 16 */\n                    region_params.MMR = 0;\n                    region_params.GBTEMPLATE = params->SDTEMPLATE;\n                    region_params.TPGDON = 0;\n                    region_params.USESKIP = 0;\n                    sdat_bytes = params->SDTEMPLATE == 0 ? 8 : 2;\n                    memcpy(region_params.gbat, params->sdat, sdat_bytes);\n\n                    image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                    if (image == NULL) {\n                        code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate image in jbig2_decode_symbol_dict\");\n                        goto cleanup4;\n                    }\n\n                    code = jbig2_decode_generic_region(ctx, segment, &region_params, as, image, GB_stats);\n                    if (code < 0) {\n                        jbig2_image_release(ctx, image);\n                        goto cleanup4;\n                    }\n\n                    SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n                } else {\n                    /* 6.5.8.2 refinement/aggregate symbol */\n                    uint32_t REFAGGNINST;\n\n                    if (params->SDHUFF) {\n                        REFAGGNINST = jbig2_huffman_get(hs, params->SDHUFFAGGINST, &code);\n                    } else {\n                        code = jbig2_arith_int_decode(IAAI, as, (int32_t *) & REFAGGNINST);\n                    }\n                    if (code || (int32_t) REFAGGNINST <= 0) {\n                        code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"invalid number of symbols or OOB in aggregate glyph\");\n                        goto cleanup4;\n                    }\n\n                    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"aggregate symbol coding (%d instances)\", REFAGGNINST);\n\n                    if (REFAGGNINST > 1) {\n                        Jbig2Image *image;\n                        uint32_t i;\n\n                        if (tparams == NULL) {\n                            /* First time through, we need to initialise the */\n                            /* various tables for Huffman or adaptive encoding */\n                            /* as well as the text region parameters structure */\n                            refagg_dicts = jbig2_new(ctx, Jbig2SymbolDict *, n_refagg_dicts);\n                            if (refagg_dicts == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating dictionary array\");\n                                goto cleanup4;\n                            }\n                            refagg_dicts[0] = jbig2_sd_new(ctx, params->SDNUMINSYMS + params->SDNUMNEWSYMS);\n                            if (refagg_dicts[0] == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating symbol dictionary\");\n                                jbig2_free(ctx->allocator, refagg_dicts);\n                                goto cleanup4;\n                            }\n                            for (i = 0; i < params->SDNUMINSYMS; i++) {\n                                refagg_dicts[0]->glyphs[i] = jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]);\n                            }\n\n                            tparams = jbig2_new(ctx, Jbig2TextRegionParams, 1);\n                            if (tparams == NULL) {\n                                code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating text region params\");\n                                goto cleanup4;\n                            }\n                            if (!params->SDHUFF) {\n                                /* Values from Table 17, section 6.5.8.2 (2) */\n                                tparams->IADT = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IAFS = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IADS = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IAIT = jbig2_arith_int_ctx_new(ctx);\n                                /* Table 31 */\n                                for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < (int)(params->SDNUMINSYMS + params->SDNUMNEWSYMS); SBSYMCODELEN++);\n                                tparams->IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);\n                                tparams->IARI = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDW = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDH = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDX = jbig2_arith_int_ctx_new(ctx);\n                                tparams->IARDY = jbig2_arith_int_ctx_new(ctx);\n                            } else {\n                                tparams->SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_F);    /* Table B.6 */\n                                tparams->SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_H);    /* Table B.8 */\n                                tparams->SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_K);    /* Table B.11 */\n                                tparams->SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                                tparams->SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);   /* Table B.15 */\n                            }\n                            tparams->SBHUFF = params->SDHUFF;\n                            tparams->SBREFINE = 1;\n                            tparams->SBSTRIPS = 1;\n                            tparams->SBDEFPIXEL = 0;\n                            tparams->SBCOMBOP = JBIG2_COMPOSE_OR;\n                            tparams->TRANSPOSED = 0;\n                            tparams->REFCORNER = JBIG2_CORNER_TOPLEFT;\n                            tparams->SBDSOFFSET = 0;\n                            tparams->SBRTEMPLATE = params->SDRTEMPLATE;\n                        }\n                        tparams->SBNUMINSTANCES = REFAGGNINST;\n\n                        image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                        if (image == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");\n                            goto cleanup4;\n                        }\n\n                        /* multiple symbols are handled as a text region */\n                        jbig2_decode_text_region(ctx, segment, tparams, (const Jbig2SymbolDict * const *)refagg_dicts,\n                                                 n_refagg_dicts, image, data, size, GR_stats, as, ws);\n\n                        SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n                        refagg_dicts[0]->glyphs[params->SDNUMINSYMS + NSYMSDECODED] = jbig2_image_clone(ctx, SDNEWSYMS->glyphs[NSYMSDECODED]);\n                    } else {\n                        /* 6.5.8.2.2 */\n                        /* bool SBHUFF = params->SDHUFF; */\n                        Jbig2RefinementRegionParams rparams;\n                        Jbig2Image *image;\n                        uint32_t ID;\n                        int32_t RDX, RDY;\n                        int BMSIZE = 0;\n                        uint32_t ninsyms = params->SDNUMINSYMS;\n                        int code1 = 0;\n                        int code2 = 0;\n                        int code3 = 0;\n                        int code4 = 0;\n\n                        /* 6.5.8.2.2 (2, 3, 4, 5) */\n                        if (params->SDHUFF) {\n                            ID = jbig2_huffman_get_bits(hs, SBSYMCODELEN, &code4);\n                            RDX = jbig2_huffman_get(hs, SDHUFFRDX, &code1);\n                            RDY = jbig2_huffman_get(hs, SDHUFFRDX, &code2);\n                            BMSIZE = jbig2_huffman_get(hs, SBHUFFRSIZE, &code3);\n                            jbig2_huffman_skip(hs);\n                        } else {\n                            code1 = jbig2_arith_iaid_decode(IAID, as, (int32_t *) & ID);\n                            code2 = jbig2_arith_int_decode(IARDX, as, &RDX);\n                            code3 = jbig2_arith_int_decode(IARDY, as, &RDY);\n                        }\n\n                        if ((code1 < 0) || (code2 < 0) || (code3 < 0) || (code4 < 0)) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode data\");\n                            goto cleanup4;\n                        }\n\n                        if (ID >= ninsyms + NSYMSDECODED) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"refinement references unknown symbol %d\", ID);\n                            goto cleanup4;\n                        }\n\n                        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                                    \"symbol is a refinement of id %d with the \" \"refinement applied at (%d,%d)\", ID, RDX, RDY);\n\n                        image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);\n                        if (image == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");\n                            goto cleanup4;\n                        }\n\n                        /* Table 18 */\n                        rparams.GRTEMPLATE = params->SDRTEMPLATE;\n                        rparams.reference = (ID < ninsyms) ? params->SDINSYMS->glyphs[ID] : SDNEWSYMS->glyphs[ID - ninsyms];\n                        /* SumatraPDF: fail on missing glyphs */\n                        if (rparams.reference == NULL) {\n                            code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"missing glyph %d/%d!\", ID, ninsyms);\n                            jbig2_image_release(ctx, image);\n                            goto cleanup4;\n                        }\n                        rparams.DX = RDX;\n                        rparams.DY = RDY;\n                        rparams.TPGRON = 0;\n                        memcpy(rparams.grat, params->sdrat, 4);\n                        code = jbig2_decode_refinement_region(ctx, segment, &rparams, as, image, GR_stats);\n                        if (code < 0)\n                            goto cleanup4;\n\n                        SDNEWSYMS->glyphs[NSYMSDECODED] = image;\n\n                        /* 6.5.8.2.2 (7) */\n                        if (params->SDHUFF) {\n                            if (BMSIZE == 0)\n                                BMSIZE = image->height * image->stride;\n                            jbig2_huffman_advance(hs, BMSIZE);\n                        }\n                    }\n                }\n\n#ifdef OUTPUT_PBM\n                {\n                    char name[64];\n                    FILE *out;\n\n                    snprintf(name, 64, \"sd.%04d.%04d.pbm\", segment->number, NSYMSDECODED);\n                    out = fopen(name, \"wb\");\n                    jbig2_image_write_pbm(SDNEWSYMS->glyphs[NSYMSDECODED], out);\n                    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"writing out glyph as '%s' ...\", name);\n                    fclose(out);\n                }\n#endif\n\n            }\n\n            /* 6.5.5 (4c.iii) */\n            if (params->SDHUFF && !params->SDREFAGG) {\n                SDNEWSYMWIDTHS[NSYMSDECODED] = SYMWIDTH;\n            }\n\n            /* 6.5.5 (4c.iv) */\n            NSYMSDECODED = NSYMSDECODED + 1;\n\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoded symbol %u of %u (%ux%u)\", NSYMSDECODED, params->SDNUMNEWSYMS, SYMWIDTH, HCHEIGHT);\n\n        }                       /* end height class decode loop */\n\n        /* 6.5.5 (4d) */\n        if (params->SDHUFF && !params->SDREFAGG) {\n            /* 6.5.9 */\n            Jbig2Image *image;\n            uint32_t BMSIZE = jbig2_huffman_get(hs, params->SDHUFFBMSIZE, &code);\n            uint32_t j;\n            int x;\n\n            if (code) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding size of collective bitmap!\");\n                goto cleanup4;\n            }\n\n            /* skip any bits before the next byte boundary */\n            jbig2_huffman_skip(hs);\n\n            image = jbig2_image_new(ctx, TOTWIDTH, HCHEIGHT);\n            if (image == NULL) {\n                jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate collective bitmap image!\");\n                goto cleanup4;\n            }\n\n            if (BMSIZE == 0) {\n                /* if BMSIZE == 0 bitmap is uncompressed */\n                const byte *src = data + jbig2_huffman_offset(hs);\n                const int stride = (image->width >> 3) + ((image->width & 7) ? 1 : 0);\n                byte *dst = image->data;\n\n                /* SumatraPDF: prevent read access violation */\n                if (size - jbig2_huffman_offset(hs) < image->height * stride) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", image->height * stride,\n                                size - jbig2_huffman_offset(hs));\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n\n                BMSIZE = image->height * stride;\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                            \"reading %dx%d uncompressed bitmap\" \" for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);\n\n                for (j = 0; j < image->height; j++) {\n                    memcpy(dst, src, stride);\n                    dst += image->stride;\n                    src += stride;\n                }\n            } else {\n                Jbig2GenericRegionParams rparams;\n\n                /* SumatraPDF: prevent read access violation */\n                if (size - jbig2_huffman_offset(hs) < BMSIZE) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", BMSIZE, size - jbig2_huffman_offset(hs));\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n\n                jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,\n                            \"reading %dx%d collective bitmap for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);\n\n                rparams.MMR = 1;\n                code = jbig2_decode_generic_mmr(ctx, segment, &rparams, data + jbig2_huffman_offset(hs), BMSIZE, image);\n                if (code) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding MMR bitmap image!\");\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n            }\n\n            /* advance past the data we've just read */\n            jbig2_huffman_advance(hs, BMSIZE);\n\n            /* copy the collective bitmap into the symbol dictionary */\n            x = 0;\n            for (j = HCFIRSTSYM; j < NSYMSDECODED; j++) {\n                Jbig2Image *glyph;\n\n                glyph = jbig2_image_new(ctx, SDNEWSYMWIDTHS[j], HCHEIGHT);\n                if (glyph == NULL) {\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to copy the collective bitmap into symbol dictionary\");\n                    jbig2_image_release(ctx, image);\n                    goto cleanup4;\n                }\n                jbig2_image_compose(ctx, glyph, image, -x, 0, JBIG2_COMPOSE_REPLACE);\n                x += SDNEWSYMWIDTHS[j];\n                SDNEWSYMS->glyphs[j] = glyph;\n            }\n            jbig2_image_release(ctx, image);\n        }\n\n    }                           /* end of symbol decode loop */\n\n    /* 6.5.10 */\n    SDEXSYMS = jbig2_sd_new(ctx, params->SDNUMEXSYMS);\n    if (SDEXSYMS == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate symbols exported from symbols dictionary\");\n        goto cleanup4;\n    } else {\n        uint32_t i = 0;\n        uint32_t j = 0;\n        uint32_t k;\n        int exflag = 0;\n        uint32_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;\n        uint32_t exrunlength;\n        int zerolength = 0;\n\n        while (i < limit) {\n            if (params->SDHUFF)\n                exrunlength = jbig2_huffman_get(hs, SBHUFFRSIZE, &code);\n            else\n                code = jbig2_arith_int_decode(IAEX, as, (int32_t *)&exrunlength);\n            /* prevent infinite loop */\n            zerolength = exrunlength > 0 ? 0 : zerolength + 1;\n            if (code || (exrunlength > limit - i) || (zerolength > 4) || (exflag && (exrunlength + j > params->SDNUMEXSYMS))) {\n                if (code)\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode exrunlength for exported symbols\");\n                else if (exrunlength <= 0)\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"runlength too small in export symbol table (%d <= 0)\\n\", exrunlength);\n                else\n                    jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number,\n                                \"runlength too large in export symbol table (%d > %d - %d)\\n\", exrunlength, params->SDNUMEXSYMS, j);\n                /* skip to the cleanup code and return SDEXSYMS = NULL */\n                jbig2_sd_release(ctx, SDEXSYMS);\n                SDEXSYMS = NULL;\n                break;\n            }\n            for (k = 0; k < exrunlength; k++) {\n                if (exflag) {\n                    SDEXSYMS->glyphs[j++] = (i < params->SDNUMINSYMS) ?\n                                            jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]) : jbig2_image_clone(ctx, SDNEWSYMS->glyphs[i - params->SDNUMINSYMS]);\n                }\n                i++;\n            }\n            exflag = !exflag;\n        }\n    }\n\ncleanup4:\n    if (tparams != NULL) {\n        if (!params->SDHUFF) {\n            jbig2_arith_int_ctx_free(ctx, tparams->IADT);\n            jbig2_arith_int_ctx_free(ctx, tparams->IAFS);\n            jbig2_arith_int_ctx_free(ctx, tparams->IADS);\n            jbig2_arith_int_ctx_free(ctx, tparams->IAIT);\n            jbig2_arith_iaid_ctx_free(ctx, tparams->IAID);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARI);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDW);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDH);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDX);\n            jbig2_arith_int_ctx_free(ctx, tparams->IARDY);\n        } else {\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFFS);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFDS);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFDT);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDX);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDY);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDW);\n            jbig2_release_huffman_table(ctx, tparams->SBHUFFRDH);\n        }\n        jbig2_free(ctx->allocator, tparams);\n    }\n    if (refagg_dicts != NULL) {\n        jbig2_sd_release(ctx, refagg_dicts[0]);\n        jbig2_free(ctx->allocator, refagg_dicts);\n    }\n\ncleanup2:\n    jbig2_sd_release(ctx, SDNEWSYMS);\n    if (params->SDHUFF && !params->SDREFAGG) {\n        jbig2_free(ctx->allocator, SDNEWSYMWIDTHS);\n    }\n    jbig2_release_huffman_table(ctx, SDHUFFRDX);\n    jbig2_release_huffman_table(ctx, SBHUFFRSIZE);\n    jbig2_huffman_free(ctx, hs);\n    jbig2_arith_iaid_ctx_free(ctx, IAID);\n    jbig2_arith_int_ctx_free(ctx, IARDX);\n    jbig2_arith_int_ctx_free(ctx, IARDY);\n\ncleanup1:\n    jbig2_word_stream_buf_free(ctx, ws);\n    jbig2_free(ctx->allocator, as);\n    jbig2_arith_int_ctx_free(ctx, IADH);\n    jbig2_arith_int_ctx_free(ctx, IADW);\n    jbig2_arith_int_ctx_free(ctx, IAEX);\n    jbig2_arith_int_ctx_free(ctx, IAAI);\n\n    return SDEXSYMS;\n}",
  "project": "ghostpdl",
  "hash": 151781195134694545420505614324781028208,
  "size": 568,
  "commit_id": "b184e783702246e154294326d03d9abda669fcfa",
  "message": "Bug 697703: Prevent integer overflow vulnerability.\n\nAdd extra check for the offset being greater than the size\nof the image and hence reading off the end of the buffer.\n\nThank you to Dai Ge for finding this issue and suggesting a patch.",
  "target": 1,
  "dataset": "other",
  "idx": 202890,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses an integer overflow vulnerability by adding a check to prevent buffer overflows, which is a clear security issue.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}