{
  "id": 479,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/Hitsxx/Combiner_cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e",
  "commit_sha": "e1c5050734123973b99d181c45e74b2cbb00272e",
  "commit_msg": "Do some random sanity checking for stratum message parsing",
  "pr_url": null,
  "pr_info": null,
  "file_name": "util.c",
  "func_name": "",
  "raw_func_from_json": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n \n\tsprintf(address, \"%s:%s\", url, port);\n \n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "diff_func": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2011-2013 Con Kolivas\n+ * Copyright 2011-2014 Con Kolivas\n  * Copyright 2010 Jeff Garzik\n  *\n  * This program is free software; you can redistribute it and/or modify it\n@@ -720,6 +720,34 @@ bool hex2bin(unsigned char *p, const char *hexstr, size_t len)\n \treturn ret;\n }\n \n+static bool _valid_hex(char *s, const char *file, const char *func, const int line)\n+{\n+\tbool ret = false;\n+\tint i, len;\n+\n+\tif (unlikely(!s)) {\n+\t\tapplog(LOG_ERR, \"Null string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n+\t\treturn ret;\n+\t}\n+\tlen = strlen(s);\n+\tif (unlikely(!len)) {\n+\t\tapplog(LOG_ERR, \"Zero length string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n+\t\treturn ret;\n+\t}\n+\tfor (i = 0; i < len; i++) {\n+\t\tunsigned char idx = s[i];\n+\n+\t\tif (unlikely(hex2bin_tbl[idx] < 0)) {\n+\t\t\tapplog(LOG_ERR, \"Invalid char %x passed to valid_hex from\"IN_FMT_FFL, idx, file, func, line);\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\tret = true;\n+\treturn ret;\n+}\n+\n+#define valid_hex(s) _valid_hex(s, __FILE__, __func__, __LINE__)\n+\n static const int b58tobin_tbl[] = {\n \t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n \t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n@@ -1375,7 +1403,7 @@ bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n \tif (url_len < 1)\n \t\treturn false;\n \n-\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n+\tsnprintf(url_address, 254, \"%.*s\", url_len, url_begin);\n \n \tif (port_len) {\n \t\tchar *slash;\n@@ -1685,14 +1713,13 @@ static bool parse_notify(struct pool *pool, json_t *val)\n \tntime = __json_array_string(val, 7);\n \tclean = json_is_true(json_array_get(val, 8));\n \n-\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n+\tif (!valid_hex(job_id) || !valid_hex(prev_hash) || !valid_hex(coinbase1) ||\n+\t    !valid_hex(coinbase2) || !valid_hex(bbversion) || !valid_hex(nbit) ||\n+\t    !valid_hex(ntime)) {\n \t\t/* Annoying but we must not leak memory */\n-\t\tif (job_id)\n-\t\t\tfree(job_id);\n-\t\tif (coinbase1)\n-\t\t\tfree(coinbase1);\n-\t\tif (coinbase2)\n-\t\t\tfree(coinbase2);\n+\t\tfree(job_id);\n+\t\tfree(coinbase1);\n+\t\tfree(coinbase2);\n \t\tgoto out;\n \t}\n \n@@ -1880,7 +1907,7 @@ static bool parse_reconnect(struct pool *pool, json_t *val)\n \tif (!port)\n \t\tport = pool->stratum_port;\n \n-\tsprintf(address, \"%s:%s\", url, port);\n+\tsnprintf(address, 254, \"%s:%s\", url, port);\n \n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n@@ -2551,14 +2578,14 @@ bool initiate_stratum(struct pool *pool)\n \tif (!sessionid)\n \t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n \tnonce1 = json_array_string(res_val, 1);\n-\tif (!nonce1) {\n-\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n+\tif (!valid_hex(nonce1)) {\n+\t\tapplog(LOG_INFO, \"Failed to get valid nonce1 in initiate_stratum\");\n \t\tfree(sessionid);\n \t\tgoto out;\n \t}\n \tn2size = json_integer_value(json_array_get(res_val, 2));\n-\tif (!n2size) {\n-\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n+\tif (n2size < 2 || n2size > 16) {\n+\t\tapplog(LOG_INFO, \"Failed to get valid n2size in initiate_stratum\");\n \t\tfree(sessionid);\n \t\tfree(nonce1);\n \t\tgoto out;",
  "project": "cgminer",
  "commit_id": "e1c5050734123973b99d181c45e74b2cbb00272e",
  "target": 1,
  "func": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n \n\tsprintf(address, \"%s:%s\", url, port);\n \n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "big_vul_idx": 179479,
  "idx": 1238,
  "hash": 137361347459447412875947908752625113506,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch introduces validation checks for hexadecimal strings and replaces `sprintf` with `snprintf` to prevent buffer overflows, addressing potential security vulnerabilities.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}