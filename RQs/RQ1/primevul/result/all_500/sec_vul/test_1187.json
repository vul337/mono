{
  "id": 1187,
  "language": "c",
  "cwe": [
    "CWE-125"
  ],
  "commit_url": "https://github.com/balabit-deps/openssl/commit/94d23fcff9b2a7a8368dfe52214d5c2569882c11",
  "commit_sha": "94d23fcff9b2a7a8368dfe52214d5c2569882c11",
  "commit_msg": "Fix EC_GROUP_new_from_ecparameters to check the base length\n\nCheck that there's at least one byte in params->base before trying to\nread it.\n\nCVE-2021-3712\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "crypto/ec/ec_asn1.c",
  "func_name": "",
  "raw_func_from_json": "EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n{\n    int ok = 0, tmp;\n    EC_GROUP *ret = NULL, *dup = NULL;\n    BIGNUM *p = NULL, *a = NULL, *b = NULL;\n    EC_POINT *point = NULL;\n    long field_bits;\n    int curve_name = NID_undef;\n    BN_CTX *ctx = NULL;\n\n    if (!params->fieldID || !params->fieldID->fieldType ||\n        !params->fieldID->p.ptr) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    /*\n     * Now extract the curve parameters a and b. Note that, although SEC 1\n     * specifies the length of their encodings, historical versions of OpenSSL\n     * encoded them incorrectly, so we must accept any length for backwards\n     * compatibility.\n     */\n    if (!params->curve || !params->curve->a ||\n        !params->curve->a->data || !params->curve->b ||\n        !params->curve->b->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\n    if (a == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\n    if (b == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* get the field parameters */\n    tmp = OBJ_obj2nid(params->fieldID->fieldType);\n    if (tmp == NID_X9_62_characteristic_two_field)\n#ifdef OPENSSL_NO_EC2M\n    {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);\n        goto err;\n    }\n#else\n    {\n        X9_62_CHARACTERISTIC_TWO *char_two;\n\n        char_two = params->fieldID->p.char_two;\n\n        field_bits = char_two->m;\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        if ((p = BN_new()) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* get the base type */\n        tmp = OBJ_obj2nid(char_two->type);\n\n        if (tmp == NID_X9_62_tpBasis) {\n            long tmp_long;\n\n            if (!char_two->p.tpBasis) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\n\n            if (!(char_two->m > tmp_long && tmp_long > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_TRINOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)tmp_long))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_ppBasis) {\n            X9_62_PENTANOMIAL *penta;\n\n            penta = char_two->p.ppBasis;\n            if (!penta) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            if (!\n                (char_two->m > penta->k3 && penta->k3 > penta->k2\n                 && penta->k2 > penta->k1 && penta->k1 > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_PENTANOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k1))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k2))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k3))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_onBasis) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);\n            goto err;\n        } else {                /* error */\n\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\n    }\n#endif\n    else if (tmp == NID_X9_62_prime_field) {\n        /* we have a curve over a prime field */\n        /* extract the prime number */\n        if (!params->fieldID->p.prime) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\n        if (p == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (BN_is_negative(p) || BN_is_zero(p)) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n            goto err;\n        }\n\n        field_bits = BN_num_bits(p);\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\n    } else {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n        goto err;\n    }\n\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract seed (optional) */\n    if (params->curve->seed != NULL) {\n        OPENSSL_free(ret->seed);\n        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(ret->seed, params->curve->seed->data,\n               params->curve->seed->length);\n        ret->seed_len = params->curve->seed->length;\n    }\n\n    if (!params->order || !params->base || !params->base->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    if ((point = EC_POINT_new(ret)) == NULL)\n        goto err;\n\n    /* set the point conversion form */\n    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\n                                       (params->base->data[0] & ~0x01));\n\n    /* extract the ec point */\n    if (!EC_POINT_oct2point(ret, point, params->base->data,\n                            params->base->length, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract the order */\n    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    if (BN_is_negative(a) || BN_is_zero(a)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n\n    /* extract the cofactor (optional) */\n    if (params->cofactor == NULL) {\n        BN_free(b);\n        b = NULL;\n    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    /* set the generator, order and cofactor (if present) */\n    if (!EC_GROUP_set_generator(ret, point, a, b)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /*\n     * Check if the explicit parameters group just created matches one of the\n     * built-in curves.\n     *\n     * We create a copy of the group just built, so that we can remove optional\n     * fields for the lookup: we do this to avoid the possibility that one of\n     * the optional parameters is used to force the library into using a less\n     * performant and less secure EC_METHOD instead of the specialized one.\n     * In any case, `seed` is not really used in any computation, while a\n     * cofactor different from the one in the built-in table is just\n     * mathematically wrong anyway and should not be used.\n     */\n    if ((ctx = BN_CTX_new()) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    if ((dup = EC_GROUP_dup(ret)) == NULL\n            || EC_GROUP_set_seed(dup, NULL, 0) != 1\n            || !EC_GROUP_set_generator(dup, point, a, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n        /*\n         * The input explicit parameters successfully matched one of the\n         * built-in curves: often for built-in curves we have specialized\n         * methods with better performance and hardening.\n         *\n         * In this case we replace the `EC_GROUP` created through explicit\n         * parameters with one created from a named group.\n         */\n        EC_GROUP *named_group = NULL;\n\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n        /*\n         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for\n         * the same curve, we prefer the SECP nid when matching explicit\n         * parameters as that is associated with a specialized EC_METHOD.\n         */\n        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)\n            curve_name = NID_secp224r1;\n#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */\n\n        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ret);\n        ret = named_group;\n\n        /*\n         * Set the flag so that EC_GROUPs created from explicit parameters are\n         * serialized using explicit parameters by default.\n         */\n        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);\n\n        /*\n         * If the input params do not contain the optional seed field we make\n         * sure it is not added to the returned group.\n         *\n         * The seed field is not really used inside libcrypto anyway, and\n         * adding it to parsed explicit parameter keys would alter their DER\n         * encoding output (because of the extra field) which could impact\n         * applications fingerprinting keys by their DER encoding.\n         */\n        if (params->curve->seed == NULL) {\n            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)\n                goto err;\n        }\n    }\n\n    ok = 1;\n\n err:\n    if (!ok) {\n        EC_GROUP_free(ret);\n        ret = NULL;\n    }\n    EC_GROUP_free(dup);\n\n    BN_free(p);\n    BN_free(a);\n    BN_free(b);\n    EC_POINT_free(point);\n\n    BN_CTX_free(ctx);\n\n    return ret;\n}",
  "diff_func": "@@ -761,7 +761,10 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n         ret->seed_len = params->curve->seed->length;\n     }\n \n-    if (!params->order || !params->base || !params->base->data) {\n+    if (params->order == NULL\n+            || params->base == NULL\n+            || params->base->data == NULL\n+            || params->base->length == 0) {\n         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n         goto err;\n     }",
  "func": "EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n{\n    int ok = 0, tmp;\n    EC_GROUP *ret = NULL, *dup = NULL;\n    BIGNUM *p = NULL, *a = NULL, *b = NULL;\n    EC_POINT *point = NULL;\n    long field_bits;\n    int curve_name = NID_undef;\n    BN_CTX *ctx = NULL;\n\n    if (!params->fieldID || !params->fieldID->fieldType ||\n        !params->fieldID->p.ptr) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    /*\n     * Now extract the curve parameters a and b. Note that, although SEC 1\n     * specifies the length of their encodings, historical versions of OpenSSL\n     * encoded them incorrectly, so we must accept any length for backwards\n     * compatibility.\n     */\n    if (!params->curve || !params->curve->a ||\n        !params->curve->a->data || !params->curve->b ||\n        !params->curve->b->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\n    if (a == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\n    if (b == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* get the field parameters */\n    tmp = OBJ_obj2nid(params->fieldID->fieldType);\n    if (tmp == NID_X9_62_characteristic_two_field)\n#ifdef OPENSSL_NO_EC2M\n    {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);\n        goto err;\n    }\n#else\n    {\n        X9_62_CHARACTERISTIC_TWO *char_two;\n\n        char_two = params->fieldID->p.char_two;\n\n        field_bits = char_two->m;\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        if ((p = BN_new()) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* get the base type */\n        tmp = OBJ_obj2nid(char_two->type);\n\n        if (tmp == NID_X9_62_tpBasis) {\n            long tmp_long;\n\n            if (!char_two->p.tpBasis) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\n\n            if (!(char_two->m > tmp_long && tmp_long > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_TRINOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)tmp_long))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_ppBasis) {\n            X9_62_PENTANOMIAL *penta;\n\n            penta = char_two->p.ppBasis;\n            if (!penta) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            if (!\n                (char_two->m > penta->k3 && penta->k3 > penta->k2\n                 && penta->k2 > penta->k1 && penta->k1 > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_PENTANOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k1))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k2))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k3))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_onBasis) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);\n            goto err;\n        } else {                /* error */\n\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\n    }\n#endif\n    else if (tmp == NID_X9_62_prime_field) {\n        /* we have a curve over a prime field */\n        /* extract the prime number */\n        if (!params->fieldID->p.prime) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\n        if (p == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (BN_is_negative(p) || BN_is_zero(p)) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n            goto err;\n        }\n\n        field_bits = BN_num_bits(p);\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\n    } else {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n        goto err;\n    }\n\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract seed (optional) */\n    if (params->curve->seed != NULL) {\n        OPENSSL_free(ret->seed);\n        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(ret->seed, params->curve->seed->data,\n               params->curve->seed->length);\n        ret->seed_len = params->curve->seed->length;\n    }\n\n    if (!params->order || !params->base || !params->base->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    if ((point = EC_POINT_new(ret)) == NULL)\n        goto err;\n\n    /* set the point conversion form */\n    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\n                                       (params->base->data[0] & ~0x01));\n\n    /* extract the ec point */\n    if (!EC_POINT_oct2point(ret, point, params->base->data,\n                            params->base->length, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract the order */\n    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    if (BN_is_negative(a) || BN_is_zero(a)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n\n    /* extract the cofactor (optional) */\n    if (params->cofactor == NULL) {\n        BN_free(b);\n        b = NULL;\n    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    /* set the generator, order and cofactor (if present) */\n    if (!EC_GROUP_set_generator(ret, point, a, b)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /*\n     * Check if the explicit parameters group just created matches one of the\n     * built-in curves.\n     *\n     * We create a copy of the group just built, so that we can remove optional\n     * fields for the lookup: we do this to avoid the possibility that one of\n     * the optional parameters is used to force the library into using a less\n     * performant and less secure EC_METHOD instead of the specialized one.\n     * In any case, `seed` is not really used in any computation, while a\n     * cofactor different from the one in the built-in table is just\n     * mathematically wrong anyway and should not be used.\n     */\n    if ((ctx = BN_CTX_new()) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    if ((dup = EC_GROUP_dup(ret)) == NULL\n            || EC_GROUP_set_seed(dup, NULL, 0) != 1\n            || !EC_GROUP_set_generator(dup, point, a, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n        /*\n         * The input explicit parameters successfully matched one of the\n         * built-in curves: often for built-in curves we have specialized\n         * methods with better performance and hardening.\n         *\n         * In this case we replace the `EC_GROUP` created through explicit\n         * parameters with one created from a named group.\n         */\n        EC_GROUP *named_group = NULL;\n\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n        /*\n         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for\n         * the same curve, we prefer the SECP nid when matching explicit\n         * parameters as that is associated with a specialized EC_METHOD.\n         */\n        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)\n            curve_name = NID_secp224r1;\n#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */\n\n        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ret);\n        ret = named_group;\n\n        /*\n         * Set the flag so that EC_GROUPs created from explicit parameters are\n         * serialized using explicit parameters by default.\n         */\n        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);\n\n        /*\n         * If the input params do not contain the optional seed field we make\n         * sure it is not added to the returned group.\n         *\n         * The seed field is not really used inside libcrypto anyway, and\n         * adding it to parsed explicit parameter keys would alter their DER\n         * encoding output (because of the extra field) which could impact\n         * applications fingerprinting keys by their DER encoding.\n         */\n        if (params->curve->seed == NULL) {\n            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)\n                goto err;\n        }\n    }\n\n    ok = 1;\n\n err:\n    if (!ok) {\n        EC_GROUP_free(ret);\n        ret = NULL;\n    }\n    EC_GROUP_free(dup);\n\n    BN_free(p);\n    BN_free(a);\n    BN_free(b);\n    EC_POINT_free(point);\n\n    BN_CTX_free(ctx);\n\n    return ret;\n}",
  "target": 1,
  "project": "openssl",
  "commit_id": "94d23fcff9b2a7a8368dfe52214d5c2569882c11",
  "hash": 43104526119033803920048277467902323704,
  "size": 315,
  "message": "Fix EC_GROUP_new_from_ecparameters to check the base length\n\nCheck that there's at least one byte in params->base before trying to\nread it.\n\nCVE-2021-3712\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>",
  "dataset": "other",
  "idx": 216861,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\nStep 1: The patch modifies the EC_GROUP_new_from_ecparameters function to add a check for the length of the base parameter, preventing potential security issues.\nStep 2: The code change addresses a defect that could lead to unauthorized access or data corruption, fitting the criteria for a security vulnerability.\nStep 3: The patch is clearly a security fix, so no need to consider other categories.\nStep 4: High confidence due to the presence of a CVE and clear code changes addressing a security flaw.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}