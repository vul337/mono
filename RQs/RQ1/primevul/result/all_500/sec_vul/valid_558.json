{
  "id": 558,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/2lambda123/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
  "commit_sha": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
  "commit_msg": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\r\n* Fix build with --with-openssl\r\n* Use RBuffer in r_socket_http_answer()\r\n* r_socket_http_answer: Fix read for big responses\r\n* Implement r_str_escape_sh()\r\n* Cleanup r_socket_connect() on Windows\r\n* Fix socket being created without a protocol\r\n* Fix socket connect with SSL ##socket\r\n* Use select() in r_socket_ready()\r\n* Fix read failing if received only protocol answer\r\n* Fix double-free\r\n* r_socket_http_get: Fail if req. SSL with no support\r\n* Follow redirects in r_socket_http_answer()\r\n* Fix r_socket_http_get result length with R2_CURL=1\r\n* Also follow redirects\r\n* Avoid using curl for downloading PDBs\r\n* Use r_socket_http_get() on UNIXs\r\n* Use WinINet API on Windows for r_socket_http_get()\r\n* Fix command injection\r\n* Fix r_sys_cmd_str_full output for binary data\r\n* Validate GUID on PDB download\r\n* Pass depth to socket_http_get_recursive()\r\n* Remove 'r_' and '__' from static function names\r\n* Fix is_valid_guid\r\n* Fix for comments",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libr/bin/pdb/pdb_downloader.c",
  "func_name": "",
  "raw_func_from_json": "static int download(struct SPDBDownloader *pd) {\n\tSPDBDownloaderOpt *opt = pd->opt;\n\tchar *curl_cmd = NULL;\n\tchar *extractor_cmd = NULL;\n\tchar *abspath_to_archive = NULL;\n\tchar *abspath_to_file = NULL;\n\tchar *archive_name = NULL;\n\tsize_t archive_name_len = 0;\n\tchar *symbol_store_path = NULL;\n\tchar *dbg_file = NULL;\n\tchar *guid = NULL;\n\tchar *archive_name_escaped  = NULL;\n\tchar *user_agent = NULL;\n\tchar *symbol_server = NULL;\n\n\tint res = 0;\n\tint cmd_ret;\n\tif (!opt->dbg_file || !*opt->dbg_file) {\n\t\t// no pdb debug file\n\t\treturn 0;\n\t}\n\tif (!checkCurl ()) {\n\t\treturn 0;\n\t}\n\t// dbg_file len is > 0\n\tarchive_name_len = strlen (opt->dbg_file);\n\tarchive_name = malloc (archive_name_len + 1);\n\tif (!archive_name) {\n\t\treturn 0;\n\t}\n\tmemcpy (archive_name, opt->dbg_file, archive_name_len + 1);\n\tarchive_name[archive_name_len - 1] = '_';\n\tsymbol_store_path = r_str_escape (opt->symbol_store_path);\n\tdbg_file = r_str_escape (opt->dbg_file);\n\tguid = r_str_escape (opt->guid);\n\tarchive_name_escaped = r_str_escape (archive_name);\n\tuser_agent = r_str_escape (opt->user_agent);\n\tsymbol_server = r_str_escape (opt->symbol_server);\n\n\tabspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\t\t    symbol_store_path, R_SYS_DIR,\n\t\t\t    dbg_file, R_SYS_DIR,\n\t\t\t    guid, R_SYS_DIR,\n\t\t\t    archive_name_escaped);\n\n\tabspath_to_file = strdup (abspath_to_archive);\n\tabspath_to_file[strlen (abspath_to_file) - 1] = 'b';\n\tif (r_file_exists (abspath_to_file)) {\n\t\teprintf (\"File already downloaded.\\n\");\n\t\tR_FREE (user_agent);\n\t\tR_FREE (abspath_to_archive);\n\t\tR_FREE (archive_name_escaped);\n\t\tR_FREE (symbol_store_path);\n\t\tR_FREE (dbg_file);\n\t\tR_FREE (guid);\n\t\tR_FREE (archive_name);\n\t\tR_FREE (abspath_to_file);\n\t\tR_FREE (symbol_server);\n\t\treturn 1;\n\t}\n\n\tif (checkExtract () || opt->extract == 0) {\n\t\tres = 1;\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       user_agent,\n\t\t                       symbol_server,\n\t\t\t\t\t\t\t   dbg_file,\n\t\t\t\t\t\t\t   guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_archive);\n#if __WINDOWS__\n\t\tconst char *cabextractor = \"expand\";\n\t\tconst char *format = \"%s %s %s\";\n\n\t\t// extractor_cmd -> %1 %2 %3\n\t\t// %1 - 'expand'\n\t\t// %2 - absolute path to archive\n\t\t// %3 - absolute path to file that will be dearchive\n\t\textractor_cmd = r_str_newf (format, cabextractor,\n\t\t\tabspath_to_archive, abspath_to_file);\n#else\n\t\tconst char *cabextractor = \"cabextract\";\n\t\tconst char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\t// cabextract -d %1 %2\n\t\t// %1 - path to directory where to extract all files from cab archive\n\t\t// %2 - absolute path to cab archive\n\t\textractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);\n\t\tR_FREE (abspath_to_dir);\n#endif\n\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\teprintf (\"Attempting to decompress pdb\\n\");\n\t\tif (opt->extract > 0) {\n\t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n\t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tr_file_rm (abspath_to_archive);\n\t\t}\n\t\tR_FREE (curl_cmd);\n\t}\n\tif (res == 0) {\n\t\teprintf (\"Falling back to uncompressed pdb\\n\");\n\t\tres = 1;\n\n\t\tarchive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       opt->user_agent,\n\t\t                       opt->symbol_server,\n\t\t                       opt->dbg_file,\n\t\t                       opt->guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_file);\n\t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\tR_FREE (curl_cmd);\n\t}\n\tR_FREE (abspath_to_archive);\n\tR_FREE (abspath_to_file);\n\tR_FREE (archive_name);\n\tR_FREE (extractor_cmd);\n\tR_FREE (symbol_store_path);\n\tR_FREE (dbg_file);\n\tR_FREE (guid);\n\tR_FREE (archive_name_escaped);\n\tR_FREE (user_agent);\n\tR_FREE (symbol_server);\n\treturn res;\n}",
  "diff_func": "@@ -18,150 +18,107 @@ static bool checkExtract() {\n \treturn true;\n }\n \n-static bool checkCurl() {\n-\tconst char nul[] = R_SYS_DEVNULL;\n-\tif (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {\n+static bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {\n+\tchar *dir = r_str_newf (\"%s%s%s%s%s\",\n+\t\topt->symbol_store_path, R_SYS_DIR,\n+\t\topt->dbg_file, R_SYS_DIR,\n+\t\topt->guid);\n+\tif (!r_sys_mkdirp (dir)) {\n+\t\tfree (dir);\n \t\treturn false;\n \t}\n+\tchar *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);\n+\tint len;\n+\tchar *file_buf = r_socket_http_get (url, NULL, &len);\n+\tfree (url);\n+\tif (!len || R_STR_ISEMPTY (file_buf)) {\n+\t\tfree (dir);\n+\t\tfree (file_buf);\n+\t\treturn false;\n+\t}\n+\tchar *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);\n+\tFILE *f = fopen (path, \"wb\");\n+\tif (f) {\n+\t\tfwrite (file_buf, sizeof (char), (size_t)len, f);\n+\t\tfclose (f);\n+\t}\n+\tfree (dir);\n+\tfree (path);\n+\tfree (file_buf);\n \treturn true;\n }\n \n static int download(struct SPDBDownloader *pd) {\n \tSPDBDownloaderOpt *opt = pd->opt;\n-\tchar *curl_cmd = NULL;\n-\tchar *extractor_cmd = NULL;\n-\tchar *abspath_to_archive = NULL;\n-\tchar *abspath_to_file = NULL;\n-\tchar *archive_name = NULL;\n-\tsize_t archive_name_len = 0;\n-\tchar *symbol_store_path = NULL;\n-\tchar *dbg_file = NULL;\n-\tchar *guid = NULL;\n-\tchar *archive_name_escaped  = NULL;\n-\tchar *user_agent = NULL;\n-\tchar *symbol_server = NULL;\n-\n \tint res = 0;\n \tint cmd_ret;\n+\n \tif (!opt->dbg_file || !*opt->dbg_file) {\n \t\t// no pdb debug file\n \t\treturn 0;\n \t}\n-\tif (!checkCurl ()) {\n-\t\treturn 0;\n-\t}\n-\t// dbg_file len is > 0\n-\tarchive_name_len = strlen (opt->dbg_file);\n-\tarchive_name = malloc (archive_name_len + 1);\n-\tif (!archive_name) {\n-\t\treturn 0;\n-\t}\n-\tmemcpy (archive_name, opt->dbg_file, archive_name_len + 1);\n-\tarchive_name[archive_name_len - 1] = '_';\n-\tsymbol_store_path = r_str_escape (opt->symbol_store_path);\n-\tdbg_file = r_str_escape (opt->dbg_file);\n-\tguid = r_str_escape (opt->guid);\n-\tarchive_name_escaped = r_str_escape (archive_name);\n-\tuser_agent = r_str_escape (opt->user_agent);\n-\tsymbol_server = r_str_escape (opt->symbol_server);\n-\n-\tabspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n-\t\t\t    symbol_store_path, R_SYS_DIR,\n-\t\t\t    dbg_file, R_SYS_DIR,\n-\t\t\t    guid, R_SYS_DIR,\n-\t\t\t    archive_name_escaped);\n-\n-\tabspath_to_file = strdup (abspath_to_archive);\n-\tabspath_to_file[strlen (abspath_to_file) - 1] = 'b';\n+\n+\tchar *abspath_to_file = r_str_newf (\"%s%s%s%s%s%s%s\",\n+\t\topt->symbol_store_path, R_SYS_DIR,\n+\t\topt->dbg_file, R_SYS_DIR,\n+\t\topt->guid, R_SYS_DIR,\n+\t\topt->dbg_file);\n+\n \tif (r_file_exists (abspath_to_file)) {\n \t\teprintf (\"File already downloaded.\\n\");\n-\t\tR_FREE (user_agent);\n-\t\tR_FREE (abspath_to_archive);\n-\t\tR_FREE (archive_name_escaped);\n-\t\tR_FREE (symbol_store_path);\n-\t\tR_FREE (dbg_file);\n-\t\tR_FREE (guid);\n-\t\tR_FREE (archive_name);\n-\t\tR_FREE (abspath_to_file);\n-\t\tR_FREE (symbol_server);\n+\t\tfree (abspath_to_file);\n \t\treturn 1;\n \t}\n \n \tif (checkExtract () || opt->extract == 0) {\n-\t\tres = 1;\n-\n-\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n-\t\t                       user_agent,\n-\t\t                       symbol_server,\n-\t\t\t\t\t\t\t   dbg_file,\n-\t\t\t\t\t\t\t   guid,\n-\t\t                       archive_name_escaped,\n-\t\t                       abspath_to_archive);\n+\t\tchar *extractor_cmd = NULL;\n+\t\tchar *archive_name = strdup (opt->dbg_file);\n+\t\tarchive_name[strlen (archive_name) - 1] = '_';\n+\t\tchar *abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n+\t\t\topt->symbol_store_path, R_SYS_DIR,\n+\t\t\topt->dbg_file, R_SYS_DIR,\n+\t\t\topt->guid, R_SYS_DIR,\n+\t\t\tarchive_name);\n+\n+\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n+\t\tchar *abs_arch_esc = r_str_escape_sh (abspath_to_archive);\n #if __WINDOWS__\n-\t\tconst char *cabextractor = \"expand\";\n-\t\tconst char *format = \"%s %s %s\";\n-\n-\t\t// extractor_cmd -> %1 %2 %3\n-\t\t// %1 - 'expand'\n-\t\t// %2 - absolute path to archive\n-\t\t// %3 - absolute path to file that will be dearchive\n-\t\textractor_cmd = r_str_newf (format, cabextractor,\n-\t\t\tabspath_to_archive, abspath_to_file);\n+\t\tchar *abs_file_esc = r_str_escape_sh (abspath_to_file);\n+\t\t// expand %1 %2\n+\t\t// %1 - absolute path to archive\n+\t\t// %2 - absolute path to file that will be dearchive\n+\t\textractor_cmd = r_str_newf (\"expand \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_file_esc);\n+\t\tfree (abs_file_esc);\n #else\n-\t\tconst char *cabextractor = \"cabextract\";\n-\t\tconst char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";\n \t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n+\t\tchar *abs_dir_esc = r_str_escape_sh (abspath_to_dir);\n \t\t// cabextract -d %1 %2\n \t\t// %1 - path to directory where to extract all files from cab archive\n \t\t// %2 - absolute path to cab archive\n-\t\textractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);\n-\t\tR_FREE (abspath_to_dir);\n+\t\textractor_cmd = r_str_newf (\"cabextract -d \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_dir_esc);\n+\t\tfree (abs_dir_esc);\n+\t\tfree (abspath_to_dir);\n #endif\n-\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n-\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n-\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n-\t\t\tres = 0;\n-\t\t}\n-\t\teprintf (\"Attempting to decompress pdb\\n\");\n-\t\tif (opt->extract > 0) {\n+\t\tfree (abs_arch_esc);\n+\t\tres = download_and_write (opt, archive_name);\n+\n+\t\tif (opt->extract > 0 && res) {\n+\t\t\teprintf (\"Attempting to decompress pdb\\n\");\n \t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n \t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n \t\t\t\tres = 0;\n \t\t\t}\n \t\t\tr_file_rm (abspath_to_archive);\n \t\t}\n-\t\tR_FREE (curl_cmd);\n+\t\tfree (archive_name);\n+\t\tfree (abspath_to_archive);\n \t}\n \tif (res == 0) {\n \t\teprintf (\"Falling back to uncompressed pdb\\n\");\n-\t\tres = 1;\n-\n-\t\tarchive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';\n-\n-\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n-\t\t                       opt->user_agent,\n-\t\t                       opt->symbol_server,\n-\t\t                       opt->dbg_file,\n-\t\t                       opt->guid,\n-\t\t                       archive_name_escaped,\n-\t\t                       abspath_to_file);\n \t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n-\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n-\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n-\t\t\tres = 0;\n-\t\t}\n-\t\tR_FREE (curl_cmd);\n-\t}\n-\tR_FREE (abspath_to_archive);\n-\tR_FREE (abspath_to_file);\n-\tR_FREE (archive_name);\n-\tR_FREE (extractor_cmd);\n-\tR_FREE (symbol_store_path);\n-\tR_FREE (dbg_file);\n-\tR_FREE (guid);\n-\tR_FREE (archive_name_escaped);\n-\tR_FREE (user_agent);\n-\tR_FREE (symbol_server);\n+\t\tres = download_and_write (opt, opt->dbg_file);\n+\t}\n+\tfree (abspath_to_file);\n \treturn res;\n }\n \n@@ -191,6 +148,19 @@ void deinit_pdb_downloader(SPDBDownloader *pd) {\n \tpd->download = 0;\n }\n \n+static bool is_valid_guid(const char *guid) {\n+\tif (!guid) {\n+\t\treturn false;\n+\t}\n+\tsize_t i;\n+\tfor (i = 0; guid[i]; i++) {\n+\t\tif (!isxdigit (guid[i])) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn i >= 33; // len of GUID and age\n+}\n+\n int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n \tint ret;\n \tSPDBDownloaderOpt opt;\n@@ -202,6 +172,11 @@ int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOption\n \t\treturn 1;\n \t}\n \n+\tif (!is_valid_guid (info->guid)) {\n+\t\teprintf (\"Invalid GUID for file\\n\");\n+\t\treturn 1;\n+\t}\n+\n \tif (!options || !options->symbol_server || !options->user_agent) {\n \t\teprintf (\"Can't retrieve pdb configurations\\n\");\n \t\treturn 1;",
  "func": "static int download(struct SPDBDownloader *pd) {\n\tSPDBDownloaderOpt *opt = pd->opt;\n\tchar *curl_cmd = NULL;\n\tchar *extractor_cmd = NULL;\n\tchar *abspath_to_archive = NULL;\n\tchar *abspath_to_file = NULL;\n\tchar *archive_name = NULL;\n\tsize_t archive_name_len = 0;\n\tchar *symbol_store_path = NULL;\n\tchar *dbg_file = NULL;\n\tchar *guid = NULL;\n\tchar *archive_name_escaped  = NULL;\n\tchar *user_agent = NULL;\n\tchar *symbol_server = NULL;\n\n\tint res = 0;\n\tint cmd_ret;\n\tif (!opt->dbg_file || !*opt->dbg_file) {\n\t\t// no pdb debug file\n\t\treturn 0;\n\t}\n\tif (!checkCurl ()) {\n\t\treturn 0;\n\t}\n\t// dbg_file len is > 0\n\tarchive_name_len = strlen (opt->dbg_file);\n\tarchive_name = malloc (archive_name_len + 1);\n\tif (!archive_name) {\n\t\treturn 0;\n\t}\n\tmemcpy (archive_name, opt->dbg_file, archive_name_len + 1);\n\tarchive_name[archive_name_len - 1] = '_';\n\tsymbol_store_path = r_str_escape (opt->symbol_store_path);\n\tdbg_file = r_str_escape (opt->dbg_file);\n\tguid = r_str_escape (opt->guid);\n\tarchive_name_escaped = r_str_escape (archive_name);\n\tuser_agent = r_str_escape (opt->user_agent);\n\tsymbol_server = r_str_escape (opt->symbol_server);\n\n\tabspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\t\t    symbol_store_path, R_SYS_DIR,\n\t\t\t    dbg_file, R_SYS_DIR,\n\t\t\t    guid, R_SYS_DIR,\n\t\t\t    archive_name_escaped);\n\n\tabspath_to_file = strdup (abspath_to_archive);\n\tabspath_to_file[strlen (abspath_to_file) - 1] = 'b';\n\tif (r_file_exists (abspath_to_file)) {\n\t\teprintf (\"File already downloaded.\\n\");\n\t\tR_FREE (user_agent);\n\t\tR_FREE (abspath_to_archive);\n\t\tR_FREE (archive_name_escaped);\n\t\tR_FREE (symbol_store_path);\n\t\tR_FREE (dbg_file);\n\t\tR_FREE (guid);\n\t\tR_FREE (archive_name);\n\t\tR_FREE (abspath_to_file);\n\t\tR_FREE (symbol_server);\n\t\treturn 1;\n\t}\n\n\tif (checkExtract () || opt->extract == 0) {\n\t\tres = 1;\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       user_agent,\n\t\t                       symbol_server,\n\t\t\t\t\t\t\t   dbg_file,\n\t\t\t\t\t\t\t   guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_archive);\n#if __WINDOWS__\n\t\tconst char *cabextractor = \"expand\";\n\t\tconst char *format = \"%s %s %s\";\n\n\t\t// extractor_cmd -> %1 %2 %3\n\t\t// %1 - 'expand'\n\t\t// %2 - absolute path to archive\n\t\t// %3 - absolute path to file that will be dearchive\n\t\textractor_cmd = r_str_newf (format, cabextractor,\n\t\t\tabspath_to_archive, abspath_to_file);\n#else\n\t\tconst char *cabextractor = \"cabextract\";\n\t\tconst char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\t// cabextract -d %1 %2\n\t\t// %1 - path to directory where to extract all files from cab archive\n\t\t// %2 - absolute path to cab archive\n\t\textractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);\n\t\tR_FREE (abspath_to_dir);\n#endif\n\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\teprintf (\"Attempting to decompress pdb\\n\");\n\t\tif (opt->extract > 0) {\n\t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n\t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tr_file_rm (abspath_to_archive);\n\t\t}\n\t\tR_FREE (curl_cmd);\n\t}\n\tif (res == 0) {\n\t\teprintf (\"Falling back to uncompressed pdb\\n\");\n\t\tres = 1;\n\n\t\tarchive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       opt->user_agent,\n\t\t                       opt->symbol_server,\n\t\t                       opt->dbg_file,\n\t\t                       opt->guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_file);\n\t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\tR_FREE (curl_cmd);\n\t}\n\tR_FREE (abspath_to_archive);\n\tR_FREE (abspath_to_file);\n\tR_FREE (archive_name);\n\tR_FREE (extractor_cmd);\n\tR_FREE (symbol_store_path);\n\tR_FREE (dbg_file);\n\tR_FREE (guid);\n\tR_FREE (archive_name_escaped);\n\tR_FREE (user_agent);\n\tR_FREE (symbol_server);\n\treturn res;\n}",
  "project": "radare2",
  "hash": 235350912544331798088834006772646860216,
  "size": 138,
  "commit_id": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
  "message": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\r\n* Fix build with --with-openssl\r\n* Use RBuffer in r_socket_http_answer()\r\n* r_socket_http_answer: Fix read for big responses\r\n* Implement r_str_escape_sh()\r\n* Cleanup r_socket_connect() on Windows\r\n* Fix socket being created without a protocol\r\n* Fix socket connect with SSL ##socket\r\n* Use select() in r_socket_ready()\r\n* Fix read failing if received only protocol answer\r\n* Fix double-free\r\n* r_socket_http_get: Fail if req. SSL with no support\r\n* Follow redirects in r_socket_http_answer()\r\n* Fix r_socket_http_get result length with R2_CURL=1\r\n* Also follow redirects\r\n* Avoid using curl for downloading PDBs\r\n* Use r_socket_http_get() on UNIXs\r\n* Use WinINet API on Windows for r_socket_http_get()\r\n* Fix command injection\r\n* Fix r_sys_cmd_str_full output for binary data\r\n* Validate GUID on PDB download\r\n* Pass depth to socket_http_get_recursive()\r\n* Remove 'r_' and '__' from static function names\r\n* Fix is_valid_guid\r\n* Fix for comments",
  "target": 1,
  "dataset": "other",
  "idx": 198095,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a command injection vulnerability by replacing unsafe shell command usage with secure HTTP handling and input validation.\n\n**Final Output:**\nAnalysis: The patch fixes a command injection vulnerability by replacing direct curl command usage with r_socket_http_get and adding input escaping and validation. This prevents attackers from injecting malicious commands.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}