{
  "id": 731,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ljalves/linux_media/commit/38327424b40bcebe2de92d07312c89360ac9229a",
  "commit_sha": "38327424b40bcebe2de92d07312c89360ac9229a",
  "commit_msg": "KEYS: potential uninitialized variable\n\nIf __key_link_begin() failed then \"edit\" would be uninitialized.  I've\nadded a check to fix that.\n\nThis allows a random user to crash the kernel, though it's quite\ndifficult to achieve.  There are three ways it can be done as the user\nwould have to cause an error to occur in __key_link():\n\n (1) Cause the kernel to run out of memory.  In practice, this is difficult\n     to achieve without ENOMEM cropping up elsewhere and aborting the\n     attempt.\n\n (2) Revoke the destination keyring between the keyring ID being looked up\n     and it being tested for revocation.  In practice, this is difficult to\n     time correctly because the KEYCTL_REJECT function can only be used\n     from the request-key upcall process.  Further, users can only make use\n     of what's in /sbin/request-key.conf, though this does including a\n     rejection debugging test - which means that the destination keyring\n     has to be the caller's session keyring in practice.\n\n (3) Have just enough key quota available to create a key, a new session\n     keyring for the upcall and a link in the session keyring, but not then\n     sufficient quota to create a link in the nominated destination keyring\n     so that it fails with EDQUOT.\n\nThe bug can be triggered using option (3) above using something like the\nfollowing:\n\n\techo 80 >/proc/sys/kernel/keys/root_maxbytes\n\tkeyctl request2 user debug:fred negate @t\n\nThe above sets the quota to something much lower (80) to make the bug\neasier to trigger, but this is dependent on the system.  Note also that\nthe name of the keyring created contains a random number that may be\nbetween 1 and 10 characters in size, so may throw the test off by\nchanging the amount of quota used.\n\nAssuming the failure occurs, something like the following will be seen:\n\n\tkfree_debugcheck: out of range ptr 6b6b6b6b6b6b6b68h\n\t------------[ cut here ]------------\n\tkernel BUG at ../mm/slab.c:2821!\n\t...\n\tRIP: 0010:[<ffffffff811600f9>] kfree_debugcheck+0x20/0x25\n\tRSP: 0018:ffff8804014a7de8  EFLAGS: 00010092\n\tRAX: 0000000000000034 RBX: 6b6b6b6b6b6b6b68 RCX: 0000000000000000\n\tRDX: 0000000000040001 RSI: 00000000000000f6 RDI: 0000000000000300\n\tRBP: ffff8804014a7df0 R08: 0000000000000001 R09: 0000000000000000\n\tR10: ffff8804014a7e68 R11: 0000000000000054 R12: 0000000000000202\n\tR13: ffffffff81318a66 R14: 0000000000000000 R15: 0000000000000001\n\t...\n\tCall Trace:\n\t  kfree+0xde/0x1bc\n\t  assoc_array_cancel_edit+0x1f/0x36\n\t  __key_link_end+0x55/0x63\n\t  key_reject_and_link+0x124/0x155\n\t  keyctl_reject_key+0xb6/0xe0\n\t  keyctl_negate_key+0x10/0x12\n\t  SyS_keyctl+0x9f/0xe7\n\t  do_syscall_64+0x63/0x13a\n\t  entry_SYSCALL64_slow_path+0x25/0x25\n\nFixes: f70e2e06196a ('KEYS: Do preallocation for __key_link()')\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\ncc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "security/keys/key.c",
  "func_name": "",
  "raw_func_from_json": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n \n \tmutex_unlock(&key_construction_mutex);\n \n\tif (keyring)\n \t\t__key_link_end(keyring, &key->index_key, edit);\n \n \t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\n",
  "diff_func": "@@ -597,7 +597,7 @@ int key_reject_and_link(struct key *key,\n \n \tmutex_unlock(&key_construction_mutex);\n \n-\tif (keyring)\n+\tif (keyring && link_ret == 0)\n \t\t__key_link_end(keyring, &key->index_key, edit);\n \n \t/* wake up anyone waiting for a key to be constructed */",
  "project": "linux",
  "commit_id": "38327424b40bcebe2de92d07312c89360ac9229a",
  "target": 1,
  "func": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n \n \tmutex_unlock(&key_construction_mutex);\n \n\tif (keyring)\n \t\t__key_link_end(keyring, &key->index_key, edit);\n \n \t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\n",
  "big_vul_idx": 180433,
  "idx": 2025,
  "hash": 256806618522082725575568185487269011487,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an uninitialized variable issue in the key management system, which could lead to a kernel crash. The commit message details how this bug can be exploited to cause a Denial of Service (DoS). The code change adds a condition to check for successful link operations before proceeding, preventing the use of an uninitialized variable.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}