{
  "id": 646,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/thevipwan/linux-pam/commit/57a1e2b274d0a6376d92ada9926e5c5741e7da20",
  "commit_sha": "57a1e2b274d0a6376d92ada9926e5c5741e7da20",
  "commit_msg": "pam_userdb: fix password hash comparison\n\nStarting with commit Linux-PAM-0-77-28-g0b3e583 that introduced hashed\npasswords support in pam_userdb, hashes are compared case-insensitively.\nThis bug leads to accepting hashes for completely different passwords in\naddition to those that should be accepted.\n\nAdditionally, commit Linux-PAM-1_1_6-13-ge2a8187 that added support for\nmodern password hashes with different lengths and settings, did not\nupdate the hash comparison accordingly, which leads to accepting\ncomputed hashes longer than stored hashes when the latter is a prefix\nof the former.\n\n* modules/pam_userdb/pam_userdb.c (user_lookup): Reject the computed\nhash whose length differs from the stored hash length.\nCompare computed and stored hashes case-sensitively.\nFixes CVE-2013-7041.\n\nBug-Debian: http://bugs.debian.org/731368",
  "pr_url": null,
  "pr_info": null,
  "file_name": "modules/pam_userdb/pam_userdb.c",
  "func_name": "",
  "raw_func_from_json": "user_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n\t     const char *user, const char *pass, int ctrl)\n{\n    DBM *dbm;\n    datum key, data;\n\n    /* Open the DB file. */\n    dbm = dbm_open(database, O_RDONLY, 0644);\n    if (dbm == NULL) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"user_lookup: could not open database `%s': %m\", database);\n\treturn -2;\n    }\n\n    /* dump out the database contents for debugging */\n    if (ctrl & PAM_DUMP_ARG) {\n\tpam_syslog(pamh, LOG_INFO, \"Database dump:\");\n\tfor (key = dbm_firstkey(dbm);  key.dptr != NULL;\n\t     key = dbm_nextkey(dbm)) {\n\t    data = dbm_fetch(dbm, key);\n\t    pam_syslog(pamh, LOG_INFO,\n\t\t       \"key[len=%d] = `%s', data[len=%d] = `%s'\",\n\t\t       key.dsize, key.dptr, data.dsize, data.dptr);\n\t}\n    }\n\n    /* do some more init work */\n    memset(&key, 0, sizeof(key));\n    memset(&data, 0, sizeof(data));\n    if (ctrl & PAM_KEY_ONLY_ARG) {\n\tif (asprintf(&key.dptr, \"%s-%s\", user, pass) < 0)\n\t    key.dptr = NULL;\n\telse\n\t    key.dsize = strlen(key.dptr);\n    } else {\n        key.dptr = x_strdup(user);\n        key.dsize = strlen(user);\n    }\n\n    if (key.dptr) {\n\tdata = dbm_fetch(dbm, key);\n\tmemset(key.dptr, 0, key.dsize);\n\tfree(key.dptr);\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_INFO,\n\t\t   \"password in database is [%p]`%.*s', len is %d\",\n\t\t   data.dptr, data.dsize, (char *) data.dptr, data.dsize);\n    }\n\n    if (data.dptr != NULL) {\n\tint compare = 0;\n\n\tif (ctrl & PAM_KEY_ONLY_ARG)\n\t  {\n\t    dbm_close (dbm);\n\t    return 0; /* found it, data contents don't matter */\n\t}\n\n\tif (cryptmode && strncasecmp(cryptmode, \"crypt\", 5) == 0) {\n\n\t  /* crypt(3) password storage */\n\n\t  char *cryptpw;\n\n\t  if (data.dsize < 13) {\n\t    compare = -2;\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = -2;\n\t  } else {\n\t    cryptpw = crypt (pass, data.dptr);\n\n\t    if (cryptpw) {\n\t      compare = strncasecmp (data.dptr, cryptpw, data.dsize);\n\t    } else {\n\t      compare = -2;\n\t      if (ctrl & PAM_DEBUG_ARG) {\n\t\tpam_syslog(pamh, LOG_INFO, \"crypt() returned NULL\");\n\t      }\n\t    };\n\n\t  };\n\n\t} else {\n\n\t  /* Unknown password encryption method -\n\t   * default to plaintext password storage\n\t   */\n\n\t  if (strlen(pass) != (size_t)data.dsize) {\n\t    compare = 1; /* wrong password len -> wrong password */\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = strncasecmp(data.dptr, pass, data.dsize);\n\t  } else {\n\t    compare = strncmp(data.dptr, pass, data.dsize);\n\t  }\n\n\t  if (cryptmode && strncasecmp(cryptmode, \"none\", 4)\n\t\t&& (ctrl & PAM_DEBUG_ARG)) {\n\t    pam_syslog(pamh, LOG_INFO, \"invalid value for crypt parameter: %s\",\n\t\t       cryptmode);\n\t    pam_syslog(pamh, LOG_INFO, \"defaulting to plaintext password mode\");\n\t  }\n\n\t}\n\n\tdbm_close(dbm);\n\tif (compare == 0)\n\t    return 0; /* match */\n\telse\n\t    return -1; /* wrong */\n    } else {\n        int saw_user = 0;\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_INFO, \"error returned by dbm_fetch: %m\");\n\t}\n\n\t/* probably we should check dbm_error() here */\n\n        if ((ctrl & PAM_KEY_ONLY_ARG) == 0) {\n\t    dbm_close(dbm);\n            return 1; /* not key_only, so no entry => no entry for the user */\n        }\n\n        /* now handle the key_only case */\n        for (key = dbm_firstkey(dbm);\n             key.dptr != NULL;\n             key = dbm_nextkey(dbm)) {\n            int compare;\n            /* first compare the user portion (case sensitive) */\n            compare = strncmp(key.dptr, user, strlen(user));\n            if (compare == 0) {\n                /* assume failure */\n                compare = -1;\n                /* if we have the divider where we expect it to be... */\n                if (key.dptr[strlen(user)] == '-') {\n\t\t    saw_user = 1;\n\t\t    if ((size_t)key.dsize == strlen(user) + 1 + strlen(pass)) {\n\t\t        if (ctrl & PAM_ICASE_ARG) {\n\t\t\t    /* compare the password portion (case insensitive)*/\n                            compare = strncasecmp(key.dptr + strlen(user) + 1,\n                                                  pass,\n                                                  strlen(pass));\n\t\t        } else {\n                            /* compare the password portion (case sensitive) */\n                            compare = strncmp(key.dptr + strlen(user) + 1,\n                                              pass,\n                                              strlen(pass));\n\t\t        }\n\t\t    }\n                }\n                if (compare == 0) {\n                    dbm_close(dbm);\n                    return 0; /* match */\n                }\n            }\n        }\n        dbm_close(dbm);\n\tif (saw_user)\n\t    return -1; /* saw the user, but password mismatch */\n\telse\n\t    return 1; /* not found */\n    }\n\n    /* NOT REACHED */\n    return -2;\n}",
  "diff_func": "@@ -222,12 +222,15 @@ user_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n \t  } else {\n \t    cryptpw = crypt (pass, data.dptr);\n \n-\t    if (cryptpw) {\n-\t      compare = strncasecmp (data.dptr, cryptpw, data.dsize);\n+\t    if (cryptpw && strlen(cryptpw) == (size_t)data.dsize) {\n+\t      compare = memcmp(data.dptr, cryptpw, data.dsize);\n \t    } else {\n \t      compare = -2;\n \t      if (ctrl & PAM_DEBUG_ARG) {\n-\t\tpam_syslog(pamh, LOG_INFO, \"crypt() returned NULL\");\n+\t\tif (cryptpw)\n+\t\t  pam_syslog(pamh, LOG_INFO, \"lengths of computed and stored hashes differ\");\n+\t\telse\n+\t\t  pam_syslog(pamh, LOG_INFO, \"crypt() returned NULL\");\n \t      }\n \t    };\n ",
  "func": "user_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,\n\t     const char *user, const char *pass, int ctrl)\n{\n    DBM *dbm;\n    datum key, data;\n\n    /* Open the DB file. */\n    dbm = dbm_open(database, O_RDONLY, 0644);\n    if (dbm == NULL) {\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"user_lookup: could not open database `%s': %m\", database);\n\treturn -2;\n    }\n\n    /* dump out the database contents for debugging */\n    if (ctrl & PAM_DUMP_ARG) {\n\tpam_syslog(pamh, LOG_INFO, \"Database dump:\");\n\tfor (key = dbm_firstkey(dbm);  key.dptr != NULL;\n\t     key = dbm_nextkey(dbm)) {\n\t    data = dbm_fetch(dbm, key);\n\t    pam_syslog(pamh, LOG_INFO,\n\t\t       \"key[len=%d] = `%s', data[len=%d] = `%s'\",\n\t\t       key.dsize, key.dptr, data.dsize, data.dptr);\n\t}\n    }\n\n    /* do some more init work */\n    memset(&key, 0, sizeof(key));\n    memset(&data, 0, sizeof(data));\n    if (ctrl & PAM_KEY_ONLY_ARG) {\n\tif (asprintf(&key.dptr, \"%s-%s\", user, pass) < 0)\n\t    key.dptr = NULL;\n\telse\n\t    key.dsize = strlen(key.dptr);\n    } else {\n        key.dptr = x_strdup(user);\n        key.dsize = strlen(user);\n    }\n\n    if (key.dptr) {\n\tdata = dbm_fetch(dbm, key);\n\tmemset(key.dptr, 0, key.dsize);\n\tfree(key.dptr);\n    }\n\n    if (ctrl & PAM_DEBUG_ARG) {\n\tpam_syslog(pamh, LOG_INFO,\n\t\t   \"password in database is [%p]`%.*s', len is %d\",\n\t\t   data.dptr, data.dsize, (char *) data.dptr, data.dsize);\n    }\n\n    if (data.dptr != NULL) {\n\tint compare = 0;\n\n\tif (ctrl & PAM_KEY_ONLY_ARG)\n\t  {\n\t    dbm_close (dbm);\n\t    return 0; /* found it, data contents don't matter */\n\t}\n\n\tif (cryptmode && strncasecmp(cryptmode, \"crypt\", 5) == 0) {\n\n\t  /* crypt(3) password storage */\n\n\t  char *cryptpw;\n\n\t  if (data.dsize < 13) {\n\t    compare = -2;\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = -2;\n\t  } else {\n\t    cryptpw = crypt (pass, data.dptr);\n\n\t    if (cryptpw) {\n\t      compare = strncasecmp (data.dptr, cryptpw, data.dsize);\n\t    } else {\n\t      compare = -2;\n\t      if (ctrl & PAM_DEBUG_ARG) {\n\t\tpam_syslog(pamh, LOG_INFO, \"crypt() returned NULL\");\n\t      }\n\t    };\n\n\t  };\n\n\t} else {\n\n\t  /* Unknown password encryption method -\n\t   * default to plaintext password storage\n\t   */\n\n\t  if (strlen(pass) != (size_t)data.dsize) {\n\t    compare = 1; /* wrong password len -> wrong password */\n\t  } else if (ctrl & PAM_ICASE_ARG) {\n\t    compare = strncasecmp(data.dptr, pass, data.dsize);\n\t  } else {\n\t    compare = strncmp(data.dptr, pass, data.dsize);\n\t  }\n\n\t  if (cryptmode && strncasecmp(cryptmode, \"none\", 4)\n\t\t&& (ctrl & PAM_DEBUG_ARG)) {\n\t    pam_syslog(pamh, LOG_INFO, \"invalid value for crypt parameter: %s\",\n\t\t       cryptmode);\n\t    pam_syslog(pamh, LOG_INFO, \"defaulting to plaintext password mode\");\n\t  }\n\n\t}\n\n\tdbm_close(dbm);\n\tif (compare == 0)\n\t    return 0; /* match */\n\telse\n\t    return -1; /* wrong */\n    } else {\n        int saw_user = 0;\n\n\tif (ctrl & PAM_DEBUG_ARG) {\n\t    pam_syslog(pamh, LOG_INFO, \"error returned by dbm_fetch: %m\");\n\t}\n\n\t/* probably we should check dbm_error() here */\n\n        if ((ctrl & PAM_KEY_ONLY_ARG) == 0) {\n\t    dbm_close(dbm);\n            return 1; /* not key_only, so no entry => no entry for the user */\n        }\n\n        /* now handle the key_only case */\n        for (key = dbm_firstkey(dbm);\n             key.dptr != NULL;\n             key = dbm_nextkey(dbm)) {\n            int compare;\n            /* first compare the user portion (case sensitive) */\n            compare = strncmp(key.dptr, user, strlen(user));\n            if (compare == 0) {\n                /* assume failure */\n                compare = -1;\n                /* if we have the divider where we expect it to be... */\n                if (key.dptr[strlen(user)] == '-') {\n\t\t    saw_user = 1;\n\t\t    if ((size_t)key.dsize == strlen(user) + 1 + strlen(pass)) {\n\t\t        if (ctrl & PAM_ICASE_ARG) {\n\t\t\t    /* compare the password portion (case insensitive)*/\n                            compare = strncasecmp(key.dptr + strlen(user) + 1,\n                                                  pass,\n                                                  strlen(pass));\n\t\t        } else {\n                            /* compare the password portion (case sensitive) */\n                            compare = strncmp(key.dptr + strlen(user) + 1,\n                                              pass,\n                                              strlen(pass));\n\t\t        }\n\t\t    }\n                }\n                if (compare == 0) {\n                    dbm_close(dbm);\n                    return 0; /* match */\n                }\n            }\n        }\n        dbm_close(dbm);\n\tif (saw_user)\n\t    return -1; /* saw the user, but password mismatch */\n\telse\n\t    return 1; /* not found */\n    }\n\n    /* NOT REACHED */\n    return -2;\n}",
  "project": "linux-pam",
  "hash": 112434099628297315187231061836027553571,
  "size": 169,
  "commit_id": "57a1e2b274d0a6376d92ada9926e5c5741e7da20",
  "message": "pam_userdb: fix password hash comparison\n\nStarting with commit Linux-PAM-0-77-28-g0b3e583 that introduced hashed\npasswords support in pam_userdb, hashes are compared case-insensitively.\nThis bug leads to accepting hashes for completely different passwords in\naddition to those that should be accepted.\n\nAdditionally, commit Linux-PAM-1_1_6-13-ge2a8187 that added support for\nmodern password hashes with different lengths and settings, did not\nupdate the hash comparison accordingly, which leads to accepting\ncomputed hashes longer than stored hashes when the latter is a prefix\nof the former.\n\n* modules/pam_userdb/pam_userdb.c (user_lookup): Reject the computed\nhash whose length differs from the stored hash length.\nCompare computed and stored hashes case-sensitively.\nFixes CVE-2013-7041.\n\nBug-Debian: http://bugs.debian.org/731368",
  "target": 1,
  "dataset": "other",
  "idx": 200647,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by correcting password hash comparisons to be case-sensitive and ensuring hash lengths match, preventing unauthorized access. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}