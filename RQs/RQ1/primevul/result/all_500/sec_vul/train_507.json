{
  "id": 507,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/viaembedded/arm-soc/commit/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36",
  "commit_sha": "ad3e14d7c5268c2e24477c6ef54bbdf88add5d36",
  "commit_msg": "HID: logitech: perform bounds checking on device_id early enough\n\ndevice_index is a char type and the size of paired_dj_deivces is 7\nelements, therefore proper bounds checking has to be applied to\ndevice_index before it is used.\n\nWe are currently performing the bounds checking in\nlogi_dj_recv_add_djhid_device(), which is too late, as malicious device\ncould send REPORT_TYPE_NOTIF_DEVICE_UNPAIRED early enough and trigger the\nproblem in one of the report forwarding functions called from\nlogi_dj_raw_event().\n\nFix this by performing the check at the earliest possible ocasion in\nlogi_dj_raw_event().\n\nCc: stable@vger.kernel.org\nReported-by: Ben Hawkes <hawkes@google.com>\nReviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/hid/hid-logitech-dj.c",
  "func_name": "",
  "raw_func_from_json": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\n\t/* Here we receive all data coming from iface 2, there are 4 cases:\n\t *\n\t * 1) Data should continue its normal processing i.e. data does not\n\t * come from the DJ collection, in which case we do nothing and\n\t * return 0, so hid-core can continue normal processing (will forward\n\t * to associated hidraw device)\n\t *\n\t * 2) Data is from DJ collection, and is intended for this driver i. e.\n\t * data contains arrival, departure, etc notifications, in which case\n\t * we queue them for delayed processing by the work queue. We return 1\n\t * to hid-core as no further processing is required from it.\n\t *\n\t * 3) Data is from DJ collection, and informs a connection change,\n\t * if the change means rf link loss, then we must send a null report\n\t * to the upper layer to discard potentially pressed keys that may be\n\t * repeated forever by the input layer. Return 1 to hid-core as no\n\t * further processing is required.\n\t *\n\t * 4) Data is from DJ collection and is an actual input event from\n\t * a paired DJ device in which case we forward it to the correct hid\n \t * device (via hid_input_report() ) and return 1 so hid-core does not do\n \t * anything else with it.\n \t */\n \n \tspin_lock_irqsave(&djrcv_dev->lock, flags);\n \tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\treturn report_processed;\n}\n",
  "diff_func": "@@ -238,13 +238,6 @@ static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n \t\treturn;\n \t}\n \n-\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n-\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n-\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n-\t\t\t__func__, dj_report->device_index);\n-\t\treturn;\n-\t}\n-\n \tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n \t\t/* The device is already known. No need to reallocate it. */\n \t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n@@ -690,6 +683,12 @@ static int logi_dj_raw_event(struct hid_device *hdev,\n \t * device (via hid_input_report() ) and return 1 so hid-core does not do\n \t * anything else with it.\n \t */\n+\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n+\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n+\t\tdev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n+\t\t\t\t__func__, dj_report->device_index);\n+\t\treturn false;\n+\t}\n \n \tspin_lock_irqsave(&djrcv_dev->lock, flags);\n \tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {",
  "project": "linux",
  "commit_id": "ad3e14d7c5268c2e24477c6ef54bbdf88add5d36",
  "target": 1,
  "func": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\n\t/* Here we receive all data coming from iface 2, there are 4 cases:\n\t *\n\t * 1) Data should continue its normal processing i.e. data does not\n\t * come from the DJ collection, in which case we do nothing and\n\t * return 0, so hid-core can continue normal processing (will forward\n\t * to associated hidraw device)\n\t *\n\t * 2) Data is from DJ collection, and is intended for this driver i. e.\n\t * data contains arrival, departure, etc notifications, in which case\n\t * we queue them for delayed processing by the work queue. We return 1\n\t * to hid-core as no further processing is required from it.\n\t *\n\t * 3) Data is from DJ collection, and informs a connection change,\n\t * if the change means rf link loss, then we must send a null report\n\t * to the upper layer to discard potentially pressed keys that may be\n\t * repeated forever by the input layer. Return 1 to hid-core as no\n\t * further processing is required.\n\t *\n\t * 4) Data is from DJ collection and is an actual input event from\n\t * a paired DJ device in which case we forward it to the correct hid\n \t * device (via hid_input_report() ) and return 1 so hid-core does not do\n \t * anything else with it.\n \t */\n \n \tspin_lock_irqsave(&djrcv_dev->lock, flags);\n \tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\treturn report_processed;\n}\n",
  "big_vul_idx": 179549,
  "idx": 1297,
  "hash": 260936126132763383743728146298078027704,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nFinal Output:\n\nAnalysis:\n- The patch addresses a bounds checking issue in the HID driver for Logitech devices. The device_index was not properly validated early enough, allowing potential exploitation. The fix moves the bounds check to an earlier function to prevent invalid accesses.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}