{
  "id": 158,
  "language": "txt",
  "cwe": "CWE-200",
  "commit_url": "https://github.com/benemorius/plasma-workspace/commit/5bc696b5abcdb460c1017592e80b2d7f6ed3107c",
  "commit_sha": "5bc696b5abcdb460c1017592e80b2d7f6ed3107c",
  "commit_msg": "Sanitise notification HTML\n\nSummary:\nQt labels support a HTML subset, using a completely internal parser in\nQTextDocument.\n\nThe Notification spec support an even smaller subset of notification\nelements.\n\nIt's important to strip out irrelevant tags that could potentially load\nremote information without user interaction, such as img\nsrc or even <b style=\"background:url...\n\nBut we want to maintain the basic rich text formatting of bold and\nitalics and links.\n\nThis parser iterates reads the XML, copying only permissable tags and\nattributes.\n\nA future obvious improvement would be to merge the original regular\nexpressions into this stream parser, but I'm trying to minimise\nbreakages to get this into 5.12.\n\nTest Plan:\nMoved code into it's own class for easy unit testing\nTried a bunch of things, including what the old regexes were doing\n\nAlso ran notify send with a few options to make sure things worked\n\nReviewers: #plasma, fvogt\n\nReviewed By: fvogt\n\nSubscribers: aacid, fvogt, plasma-devel\n\nTags: #plasma\n\nDifferential Revision: https://phabricator.kde.org/D10188",
  "pr_url": null,
  "pr_info": null,
  "file_name": "dataengines/notifications/CMakeLists.txt",
  "func_name": "",
  "raw_func_from_json": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n\n    qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n    qDebug() << \"Guessing partOf as:\" << partOf;\n    qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n\n    if (partOf > 0) {\n        const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n        Plasma::DataContainer *container = containerForSource(source);\n        if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n            }\n\n            replaces_id = partOf;\n\n            CloseNotification(partOf);\n        }\n    }\n\n    uint id = replaces_id ? replaces_id : m_nextId++;\n\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n\n    bool isPersistent = timeout == 0;\n\n    const int AVERAGE_WORD_LENGTH = 6;\n    const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n\n    if (timeout <= 0) {\n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n\n        timeout = 2000 + qMax(timeout, 3000);\n    }\n\n    const QString source = QStringLiteral(\"notification %1\").arg(id);\n     const QString source = QStringLiteral(\"notification %1\").arg(id);\n \n     QString bodyFinal = (partOf == 0 ? body : _body);\n    bodyFinal = bodyFinal.trimmed();\n    bodyFinal = bodyFinal.replace(QLatin1String(\"\\n\"), QLatin1String(\"<br/>\"));\n    bodyFinal = bodyFinal.simplified();\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"<br/>\\\\s*<br/>(\\\\s|<br/>)*\")), QLatin1String(\"<br/>\"));\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"&(?!(?:apos|quot|[gl]t|amp);|#)\")), QLatin1String(\"&amp;\"));\n    bodyFinal.replace(QLatin1String(\"&apos;\"), QChar('\\''));\n \n     Plasma::DataEngine::Data notificationData;\n     notificationData.insert(QStringLiteral(\"id\"), QString::number(id));\n    bodyFinal = bodyFinal.simplified();\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"<br/>\\\\s*<br/>(\\\\s|<br/>)*\")), QLatin1String(\"<br/>\"));\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"&(?!(?:apos|quot|[gl]t|amp);|#)\")), QLatin1String(\"&amp;\"));\n    bodyFinal.replace(QLatin1String(\"&apos;\"), QChar('\\''));\n\n    Plasma::DataEngine::Data notificationData;\n    notificationData.insert(QStringLiteral(\"id\"), QString::number(id));\n    notificationData.insert(QStringLiteral(\"eventId\"), eventId);\n    notificationData.insert(QStringLiteral(\"appName\"), appname_str);\n    notificationData.insert(QStringLiteral(\"appIcon\"), app_icon);\n    notificationData.insert(QStringLiteral(\"summary\"), summary);\n    notificationData.insert(QStringLiteral(\"body\"), bodyFinal);\n    notificationData.insert(QStringLiteral(\"actions\"), actions);\n    notificationData.insert(QStringLiteral(\"isPersistent\"), isPersistent);\n    notificationData.insert(QStringLiteral(\"expireTimeout\"), timeout);\n\n    bool configurable = false;\n    if (!appRealName.isEmpty()) {\n\n        if (m_configurableApplications.contains(appRealName)) {\n            configurable = m_configurableApplications.value(appRealName);\n        } else {\n            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral(\".notifyrc\"), KConfig::NoGlobals));\n            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,\n                                     QStringLiteral(\"knotifications5/\") + appRealName + QStringLiteral(\".notifyrc\")));\n\n            const QRegularExpression regexp(QStringLiteral(\"^Event/([^/]*)$\"));\n            configurable = !config->groupList().filter(regexp).isEmpty();\n            m_configurableApplications.insert(appRealName, configurable);\n        }\n    }\n    notificationData.insert(QStringLiteral(\"appRealName\"), appRealName);\n    notificationData.insert(QStringLiteral(\"configurable\"), configurable);\n\n    QImage image;\n    if (hints.contains(QStringLiteral(\"image-data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"image-data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    } else if (hints.contains(QStringLiteral(\"image_data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"image_data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    } else if (hints.contains(QStringLiteral(\"image-path\"))) {\n        QString path = findImageForSpecImagePath(hints[QStringLiteral(\"image-path\")].toString());\n        if (!path.isEmpty()) {\n            image.load(path);\n        }\n    } else if (hints.contains(QStringLiteral(\"image_path\"))) {\n        QString path = findImageForSpecImagePath(hints[QStringLiteral(\"image_path\")].toString());\n        if (!path.isEmpty()) {\n            image.load(path);\n        }\n    } else if (hints.contains(QStringLiteral(\"icon_data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"icon_data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    }\n    notificationData.insert(QStringLiteral(\"image\"), image.isNull() ? QVariant() : image);\n\n    if (hints.contains(QStringLiteral(\"urgency\"))) {\n        notificationData.insert(QStringLiteral(\"urgency\"), hints[QStringLiteral(\"urgency\")].toInt());\n    }\n\n    setData(source, notificationData);\n\n    m_activeNotifications.insert(source, app_name + summary);\n\n    return id;\n}\n",
  "diff_func": "@@ -4,6 +4,7 @@ set(notifications_engine_SRCS\n     notificationsengine.cpp\n     notificationservice.cpp\n     notificationaction.cpp\n+    notificationsanitizer.cpp\n )\n \n qt5_add_dbus_adaptor( notifications_engine_SRCS org.freedesktop.Notifications.xml notificationsengine.h  NotificationsEngine )\n@@ -26,3 +27,10 @@ kcoreaddons_desktop_to_json(plasma_engine_notifications plasma-dataengine-notifi\n install(TARGETS plasma_engine_notifications DESTINATION ${KDE_INSTALL_PLUGINDIR}/plasma/dataengine)\n install(FILES plasma-dataengine-notifications.desktop DESTINATION ${KDE_INSTALL_KSERVICES5DIR} )\n install(FILES notifications.operations DESTINATION ${PLASMA_DATA_INSTALL_DIR}/services)\n+\n+\n+#unit test\n+\n+add_executable(notification_test  notificationsanitizer.cpp notifications_test.cpp)\n+target_link_libraries(notification_test Qt5::Test Qt5::Core)\n+ecm_mark_as_test(notification_test)",
  "project": "kde",
  "commit_id": "5bc696b5abcdb460c1017592e80b2d7f6ed3107c",
  "target": 1,
  "func": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n\n    qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n    qDebug() << \"Guessing partOf as:\" << partOf;\n    qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n\n    if (partOf > 0) {\n        const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n        Plasma::DataContainer *container = containerForSource(source);\n        if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n            }\n\n            replaces_id = partOf;\n\n            CloseNotification(partOf);\n        }\n    }\n\n    uint id = replaces_id ? replaces_id : m_nextId++;\n\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n\n    bool isPersistent = timeout == 0;\n\n    const int AVERAGE_WORD_LENGTH = 6;\n    const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n\n    if (timeout <= 0) {\n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n\n        timeout = 2000 + qMax(timeout, 3000);\n    }\n\n    const QString source = QStringLiteral(\"notification %1\").arg(id);\n     const QString source = QStringLiteral(\"notification %1\").arg(id);\n \n     QString bodyFinal = (partOf == 0 ? body : _body);\n    bodyFinal = bodyFinal.trimmed();\n    bodyFinal = bodyFinal.replace(QLatin1String(\"\\n\"), QLatin1String(\"<br/>\"));\n    bodyFinal = bodyFinal.simplified();\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"<br/>\\\\s*<br/>(\\\\s|<br/>)*\")), QLatin1String(\"<br/>\"));\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"&(?!(?:apos|quot|[gl]t|amp);|#)\")), QLatin1String(\"&amp;\"));\n    bodyFinal.replace(QLatin1String(\"&apos;\"), QChar('\\''));\n \n     Plasma::DataEngine::Data notificationData;\n     notificationData.insert(QStringLiteral(\"id\"), QString::number(id));\n    bodyFinal = bodyFinal.simplified();\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"<br/>\\\\s*<br/>(\\\\s|<br/>)*\")), QLatin1String(\"<br/>\"));\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"&(?!(?:apos|quot|[gl]t|amp);|#)\")), QLatin1String(\"&amp;\"));\n    bodyFinal.replace(QLatin1String(\"&apos;\"), QChar('\\''));\n\n    Plasma::DataEngine::Data notificationData;\n    notificationData.insert(QStringLiteral(\"id\"), QString::number(id));\n    notificationData.insert(QStringLiteral(\"eventId\"), eventId);\n    notificationData.insert(QStringLiteral(\"appName\"), appname_str);\n    notificationData.insert(QStringLiteral(\"appIcon\"), app_icon);\n    notificationData.insert(QStringLiteral(\"summary\"), summary);\n    notificationData.insert(QStringLiteral(\"body\"), bodyFinal);\n    notificationData.insert(QStringLiteral(\"actions\"), actions);\n    notificationData.insert(QStringLiteral(\"isPersistent\"), isPersistent);\n    notificationData.insert(QStringLiteral(\"expireTimeout\"), timeout);\n\n    bool configurable = false;\n    if (!appRealName.isEmpty()) {\n\n        if (m_configurableApplications.contains(appRealName)) {\n            configurable = m_configurableApplications.value(appRealName);\n        } else {\n            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral(\".notifyrc\"), KConfig::NoGlobals));\n            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,\n                                     QStringLiteral(\"knotifications5/\") + appRealName + QStringLiteral(\".notifyrc\")));\n\n            const QRegularExpression regexp(QStringLiteral(\"^Event/([^/]*)$\"));\n            configurable = !config->groupList().filter(regexp).isEmpty();\n            m_configurableApplications.insert(appRealName, configurable);\n        }\n    }\n    notificationData.insert(QStringLiteral(\"appRealName\"), appRealName);\n    notificationData.insert(QStringLiteral(\"configurable\"), configurable);\n\n    QImage image;\n    if (hints.contains(QStringLiteral(\"image-data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"image-data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    } else if (hints.contains(QStringLiteral(\"image_data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"image_data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    } else if (hints.contains(QStringLiteral(\"image-path\"))) {\n        QString path = findImageForSpecImagePath(hints[QStringLiteral(\"image-path\")].toString());\n        if (!path.isEmpty()) {\n            image.load(path);\n        }\n    } else if (hints.contains(QStringLiteral(\"image_path\"))) {\n        QString path = findImageForSpecImagePath(hints[QStringLiteral(\"image_path\")].toString());\n        if (!path.isEmpty()) {\n            image.load(path);\n        }\n    } else if (hints.contains(QStringLiteral(\"icon_data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"icon_data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    }\n    notificationData.insert(QStringLiteral(\"image\"), image.isNull() ? QVariant() : image);\n\n    if (hints.contains(QStringLiteral(\"urgency\"))) {\n        notificationData.insert(QStringLiteral(\"urgency\"), hints[QStringLiteral(\"urgency\")].toInt());\n    }\n\n    setData(source, notificationData);\n\n    m_activeNotifications.insert(source, app_name + summary);\n\n    return id;\n}\n",
  "big_vul_idx": 178198,
  "idx": 280,
  "hash": 49080920792690681565819742613436372042,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch introduces a sanitizer for HTML notifications to prevent loading remote content, addressing a security concern. The code adds a new sanitizer class and unit tests, indicating a security fix.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}