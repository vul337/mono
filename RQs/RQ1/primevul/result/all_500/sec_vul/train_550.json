{
  "id": 550,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/ljalves/linux_media/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
  "commit_sha": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
  "commit_msg": "net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include/linux/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "crypto/algif_hash.c",
  "func_name": "",
  "raw_func_from_json": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t/*\n\t\t *\tNo Q bit information on Interrupt data.\n\t\t */\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t/* Now we can treat all alike */\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Currently, each datagram always contains a complete record */\n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n \t}\n \n\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
  "diff_func": "@@ -161,8 +161,6 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;",
  "project": "linux",
  "commit_id": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
  "target": 1,
  "func": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t/*\n\t\t *\tNo Q bit information on Interrupt data.\n\t\t */\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t/* Now we can treat all alike */\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Currently, each datagram always contains a complete record */\n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n \t}\n \n\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
  "big_vul_idx": 179696,
  "idx": 1394,
  "hash": 87996953335419633392336015864465689987,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95\n\n```json\n{\n  \"Analysis\": \"The patch modifies the recvmsg handler to prevent uninitialized memory leaks, which are security vulnerabilities. The code changes remove the assignment of msg_namelen to 0, relying on handlers to set it correctly, thus fixing a security vulnerability.\",\n  \"Final Classification\": \"Security Vulnerability Fix\",\n  \"Confidence Score\": 0.95\n}\n```",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses uninitialized memory leaks in the recvmsg handlers, which are security vulnerabilities. The changes prevent information disclosure and enhance system security.\n\n**Final Output:**\nAnalysis: The patch modifies the recvmsg handler to prevent uninitialized memory leaks, a security issue. The code changes remove the assignment of msg_namelen to 0, relying on handlers to set it correctly, thus fixing a security vulnerability.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95\n\n```json\n{\n  \"Analysis\": \"The patch modifies the recvmsg handler to prevent uninitialized memory leaks, which are security vulnerabilities. The code changes remove the assignment of msg_namelen to 0, relying on handlers to set it correctly, thus fixing a security vulnerability.\",\n  \"Final Classification\": \"Security Vulnerability Fix\",\n  \"Confidence Score\": 0.95\n}\n```"
}