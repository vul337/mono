{
  "id": 1088,
  "language": "c",
  "cwe": "CWE-835",
  "commit_url": "https://github.com/sjp38/linux.personal/commit/ccf7abb93af09ad0868ae9033d1ca8108bdaec82",
  "commit_sha": "ccf7abb93af09ad0868ae9033d1ca8108bdaec82",
  "commit_msg": "tcp: avoid infinite loop in tcp_splice_read()\n\nSplicing from TCP socket is vulnerable when a packet with URG flag is\nreceived and stored into receive queue.\n\n__tcp_splice_read() returns 0, and sk_wait_data() immediately\nreturns since there is the problematic skb in queue.\n\nThis is a nice way to burn cpu (aka infinite loop) and trigger\nsoft lockups.\n\nAgain, this gem was found by syzkaller tool.\n\nFixes: 9c55e01c0cc8 (\"[TCP]: Splice receive support.\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Dmitry Vyukov  <dvyukov@google.com>\nCc: Willy Tarreau <w@1wt.eu>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/ipv4/tcp.c",
  "func_name": "",
  "raw_func_from_json": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\n\tsock_rps_record_flow(sk);\n\t/*\n\t * We can't seek on a socket input\n\t */\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\n\tret = spliced = 0;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\t/*\n\t\t\t\t * This occurs when user tries to read\n\t\t\t\t * from never connected socket.\n\t\t\t\t */\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n \t\t\t\tret = -EAGAIN;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tsk_wait_data(sk, &timeo, NULL);\n \t\t\tif (signal_pending(current)) {\n \t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tif (spliced)\n\t\treturn spliced;\n\n\treturn ret;\n}\n",
  "diff_func": "@@ -770,6 +770,12 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n \t\t\t\tret = -EAGAIN;\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t\t/* if __tcp_splice_read() got nothing while we have\n+\t\t\t * an skb in receive queue, we do not want to loop.\n+\t\t\t * This might happen with URG data.\n+\t\t\t */\n+\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n+\t\t\t\tbreak;\n \t\t\tsk_wait_data(sk, &timeo, NULL);\n \t\t\tif (signal_pending(current)) {\n \t\t\t\tret = sock_intr_errno(timeo);",
  "project": "linux",
  "commit_id": "ccf7abb93af09ad0868ae9033d1ca8108bdaec82",
  "target": 1,
  "func": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\n\tsock_rps_record_flow(sk);\n\t/*\n\t * We can't seek on a socket input\n\t */\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\n\tret = spliced = 0;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\t/*\n\t\t\t\t * This occurs when user tries to read\n\t\t\t\t * from never connected socket.\n\t\t\t\t */\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n \t\t\t\tret = -EAGAIN;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tsk_wait_data(sk, &timeo, NULL);\n \t\t\tif (signal_pending(current)) {\n \t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tif (spliced)\n\t\treturn spliced;\n\n\treturn ret;\n}\n",
  "big_vul_idx": 181533,
  "idx": 2980,
  "hash": 191298991681736993260501096489063019278,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95\n\n**Final Answer**\nThe patch is classified as a Security Vulnerability Fix with a confidence score of 0.95.\n\n```json\n{\n  \"Analysis\": \"The patch addresses an infinite loop in the TCP splice read function, which could be exploited to cause a denial of service. The code change breaks the loop when data is present in the receive queue, mitigating the vulnerability.\",\n  \"Final Classification\": \"Security Vulnerability Fix\",\n  \"Confidence Score\": 0.95\n}\n```",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability in the TCP splice read function, preventing an infinite loop that could be exploited for a denial of service. The code change introduces a condition to break the loop when data is present, thus mitigating the risk.\n\n**Final Output:**\nAnalysis: The patch fixes an infinite loop in the TCP splice read function that could be triggered by a packet with the URG flag, leading to a denial of service. The code change breaks the loop when the receive queue is not empty, preventing the vulnerability.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95\n\n**Final Answer**\nThe patch is classified as a Security Vulnerability Fix with a confidence score of 0.95.\n\n```json\n{\n  \"Analysis\": \"The patch addresses an infinite loop in the TCP splice read function, which could be exploited to cause a denial of service. The code change breaks the loop when data is present in the receive queue, mitigating the vulnerability.\",\n  \"Final Classification\": \"Security Vulnerability Fix\",\n  \"Confidence Score\": 0.95\n}\n```"
}