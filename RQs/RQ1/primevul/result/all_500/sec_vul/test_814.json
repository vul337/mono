{
  "id": 814,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/dreamsxin/async-php/commit/64043cb9e5d8bc5af719678893e38ee0290e0c0a",
  "commit_sha": "64043cb9e5d8bc5af719678893e38ee0290e0c0a",
  "commit_msg": "Fix bug #70385 (Buffer over-read in exif_read_data with TIFF IFD tag byte value of 32 bytes)",
  "pr_url": null,
  "pr_info": null,
  "file_name": "ext/exif/exif.c",
  "func_name": "",
  "raw_func_from_json": "static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, char *offset_base, size_t IFDlength, size_t displacement, int section_index, int ReadNextIFD, tag_table_type tag_table TSRMLS_DC)\n{\n\tsize_t length;\n\tint tag, format, components;\n\tchar *value_ptr, tagname[64], cbuf[32], *outside=NULL;\n\tsize_t byte_count, offset_val, fpos, fgot;\n\tint64_t byte_count_signed;\n\txp_field_type *tmp_xp;\n#ifdef EXIF_DEBUG\n\tchar *dump_data;\n\tint dump_free;\n#endif /* EXIF_DEBUG */\n\n\t/* Protect against corrupt headers */\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"corrupt EXIF header: maximum directory nesting level reached\");\n\t\treturn FALSE;\n\t}\n\tImageInfo->ifd_nesting_level++;\n\n\ttag = php_ifd_get16u(dir_entry, ImageInfo->motorola_intel);\n\tformat = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\tcomponents = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);\n\n\tif (!format || format > NUM_FORMATS) {\n\t\t/* (-1) catches illegal zero case as unsigned underflows to positive large. */\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), format);\n\t\tformat = TAG_FMT_BYTE;\n\t\t/*return TRUE;*/\n\t}\n\n\tif (components < 0) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal components(%ld)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), components);\n\t\treturn FALSE;\n\t}\n\n\tbyte_count_signed = (int64_t)components * php_tiff_bytes_per_format[format];\n\n\tif (byte_count_signed < 0 || (byte_count_signed > INT32_MAX)) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal byte_count\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC));\n\t\treturn FALSE;\n\t}\n\n\tbyte_count = (size_t)byte_count_signed;\n\n\tif (byte_count > 4) {\n\t\toffset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t/* If its bigger than 4 bytes, the dir entry contains an offset. */\n\t\tvalue_ptr = offset_base+offset_val;\n        /* \n            dir_entry is ImageInfo->file.list[sn].data+2+i*12\n            offset_base is ImageInfo->file.list[sn].data-dir_offset \n            dir_entry - offset_base is dir_offset+2+i*12\n        */\n\t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base)) {\n\t\t\t/* It is important to check for IMAGE_FILETYPE_TIFF\n\t\t\t * JPEG does not use absolute pointers instead its pointers are\n\t\t\t * relative to the start of the TIFF header in APP1 section. */\n\t\t\tif (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {\n\t\t\t\tif (value_ptr < dir_entry) {\n\t\t\t\t\t/* we can read this if offset_val > 0 */\n\t\t\t\t\t/* some files have their values in other parts of the file */\n\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, dir_entry);\n\t\t\t\t} else {\n\t\t\t\t\t/* this is for sure not allowed */\n\t\t\t\t\t/* exception are IFD pointers */\n\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, byte_count, offset_val+byte_count, IFDlength);\n\t\t\t\t}\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tif (byte_count>sizeof(cbuf)) {\n\t\t\t\t/* mark as outside range and get buffer */\n\t\t\t\tvalue_ptr = safe_emalloc(byte_count, 1, 0);\n\t\t\t\toutside = value_ptr;\n\t\t\t} else {\n\t\t\t\t/* In most cases we only access a small range so\n\t\t\t\t * it is faster to use a static buffer there\n\t\t\t\t * BUT it offers also the possibility to have\n\t\t\t\t * pointers read without the need to free them\n\t\t\t\t * explicitley before returning. */\n\t\t\t\tmemset(&cbuf, 0, sizeof(cbuf));\n\t\t\t\tvalue_ptr = cbuf;\n\t\t\t}\n\n\t\t\tfpos = php_stream_tell(ImageInfo->infile);\n\t\t\tphp_stream_seek(ImageInfo->infile, offset_val, SEEK_SET);\n\t\t\tfgot = php_stream_tell(ImageInfo->infile);\n\t\t\tif (fgot!=offset_val) {\n\t\t\t\tEFREE_IF(outside);\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Wrong file pointer: 0x%08X != 0x%08X\", fgot, offset_val);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tfgot = php_stream_read(ImageInfo->infile, value_ptr, byte_count);\n\t\t\tphp_stream_seek(ImageInfo->infile, fpos, SEEK_SET);\n\t\t\tif (fgot<byte_count) {\n\t\t\t\tEFREE_IF(outside);\n\t\t\t\tEXIF_ERRLOG_FILEEOF(ImageInfo)\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* 4 bytes or less and value is in the dir entry itself */\n\t\tvalue_ptr = dir_entry+8;\n\t\toffset_val= value_ptr-offset_base;\n\t}\n\n\tImageInfo->sections_found |= FOUND_ANY_TAG;\n#ifdef EXIF_DEBUG\n\tdump_data = exif_dump_data(&dump_free, format, components, length, ImageInfo->motorola_intel, value_ptr TSRMLS_CC);\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val+displacement, byte_count, byte_count, (components>1)&&format!=TAG_FMT_UNDEFINED&&format!=TAG_FMT_STRING?\"ARRAY OF \":\"\", exif_get_tagformat(format), dump_data);\n\tif (dump_free) {\n\t\tefree(dump_data);\n\t}\n#endif\n\n\tif (section_index==SECTION_THUMBNAIL) {\n\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\tswitch(tag) {\n\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\tImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\tImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_STRIP_OFFSETS:\n\t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\t\t/* accept both formats */\n\t\t\t\t\tImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_STRIP_BYTE_COUNTS:\n\t\t\t\t\tif (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = ImageInfo->FileType;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* motorola is easier to read */\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_TIFF_MM;\n\t\t\t\t\t}\n\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT_LEN:\n\t\t\t\t\tif (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;\n\t\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (section_index==SECTION_IFD0 || section_index==SECTION_EXIF)\n\t\tswitch(tag) {\n\t\t\tcase TAG_COPYRIGHT:\n\t\t\t\t/* check for \"<photographer> NUL <editor> NUL\" */\n\t\t\t\tif (byte_count>1 && (length=php_strnlen(value_ptr, byte_count)) > 0) {\n\t\t\t\t\tif (length<byte_count-1) {\n\t\t\t\t\t\t/* When there are any characters after the first NUL */\n\t\t\t\t\t\tImageInfo->CopyrightPhotographer  = estrdup(value_ptr);\n\t\t\t\t\t\tImageInfo->CopyrightEditor        = estrdup(value_ptr+length+1);\n\t\t\t\t\t\tspprintf(&ImageInfo->Copyright, 0, \"%s, %s\", value_ptr, value_ptr+length+1);\n\t\t\t\t\t\t/* format = TAG_FMT_UNDEFINED; this musn't be ASCII         */\n\t\t\t\t\t\t/* but we are not supposed to change this                   */\n\t\t\t\t\t\t/* keep in mind that image_info does not store editor value */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tImageInfo->Copyright = estrdup(value_ptr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;   \n\n\t\t\tcase TAG_USERCOMMENT:\n\t\t\t\tImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_XP_TITLE:\n\t\t\tcase TAG_XP_COMMENTS:\n\t\t\tcase TAG_XP_AUTHOR:\n\t\t\tcase TAG_XP_KEYWORDS:\n\t\t\tcase TAG_XP_SUBJECT:\n\t\t\t\ttmp_xp = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);\n\t\t\t\tImageInfo->sections_found |= FOUND_WINXP;\n\t\t\t\tImageInfo->xp_fields.list = tmp_xp;\n\t\t\t\tImageInfo->xp_fields.count++;\n\t\t\t\texif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), tag, value_ptr, byte_count TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FNUMBER:\n\t\t\t\t/* Simplest way of expressing aperture, so I trust it the most.\n\t\t\t\t   (overwrite previously computed value if there is one) */\n\t\t\t\tImageInfo->ApertureFNumber = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_APERTURE:\n\t\t\tcase TAG_MAX_APERTURE:\n\t\t\t\t/* More relevant info always comes earlier, so only use this field if we don't\n\t\t\t\t   have appropriate aperture information yet. */\n\t\t\t\tif (ImageInfo->ApertureFNumber == 0) {\n\t\t\t\t\tImageInfo->ApertureFNumber\n\t\t\t\t\t\t= (float)exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)*0.5);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SHUTTERSPEED:\n\t\t\t\t/* More complicated way of expressing exposure time, so only use\n\t\t\t\t   this value if we don't already have it from somewhere else.\n\t\t\t\t   SHUTTERSPEED comes after EXPOSURE TIME\n\t\t\t\t  */\n\t\t\t\tif (ImageInfo->ExposureTime == 0) {\n\t\t\t\t\tImageInfo->ExposureTime\n\t\t\t\t\t\t= (float)(1/exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TAG_EXPOSURETIME:\n\t\t\t\tImageInfo->ExposureTime = -1;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\tImageInfo->ExifImageWidth = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FOCALPLANE_X_RES:\n\t\t\t\tImageInfo->FocalplaneXRes = exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SUBJECT_DISTANCE:\n\t\t\t\t/* Inidcates the distacne the autofocus camera is focused to.\n\t\t\t\t   Tends to be less accurate as distance increases. */\n\t\t\t\tImageInfo->Distance = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FOCALPLANE_RESOLUTION_UNIT:\n\t\t\t\tswitch((int)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)) {\n\t\t\t\t\tcase 1: ImageInfo->FocalplaneUnits = 25.4; break; /* inch */\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t/* According to the information I was using, 2 measn meters.\n\t\t\t\t\t\t   But looking at the Cannon powershot's files, inches is the only\n\t\t\t\t\t\t   sensible value. */\n\t\t\t\t\t\tImageInfo->FocalplaneUnits = 25.4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3: ImageInfo->FocalplaneUnits = 10;   break;  /* centimeter */\n\t\t\t\t\tcase 4: ImageInfo->FocalplaneUnits = 1;    break;  /* milimeter  */\n\t\t\t\t\tcase 5: ImageInfo->FocalplaneUnits = .001; break;  /* micrometer */\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SUB_IFD:\n\t\t\t\tif (format==TAG_FMT_IFD) {\n\t\t\t\t\t/* If this is called we are either in a TIFFs thumbnail or a JPEG where we cannot handle it */\n\t\t\t\t\t/* TIFF thumbnail: our data structure cannot store a thumbnail of a thumbnail */\n\t\t\t\t\t/* JPEG do we have the data area and what to do with it */\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Skip SUB IFD\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAKE:\n\t\t\t\tImageInfo->make = estrdup(value_ptr);\n\t\t\t\tbreak;\n\t\t\tcase TAG_MODEL:\n\t\t\t\tImageInfo->model = estrdup(value_ptr);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAKER_NOTE:\n\t\t\t\texif_process_IFD_in_MAKERNOTE(ImageInfo, value_ptr, byte_count, offset_base, IFDlength, displacement TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\tif (ReadNextIFD) {\n\t\t\t\t\tchar *Subdir_start;\n\t\t\t\t\tint sub_section_index = 0;\n\t\t\t\t\tswitch(tag) {\n\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found EXIF\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found GPS\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found INTEROPERABILITY\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSubdir_start = offset_base + php_ifd_get32u(value_ptr, ImageInfo->motorola_intel);\n\t\t\t\t\tif (Subdir_start < offset_base || Subdir_start > offset_base+IFDlength) {\n\t\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD Pointer\");\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (!exif_process_IFD_in_JPEG(ImageInfo, Subdir_start, offset_base, IFDlength, displacement, sub_section_index TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Subsection %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t}\n\t\t}\n\t}\n\texif_iif_add_tag(ImageInfo, section_index, exif_get_tagname(tag, tagname, sizeof(tagname), tag_table TSRMLS_CC), tag, format, components, value_ptr TSRMLS_CC);\n\tEFREE_IF(outside);\n\treturn TRUE;\n}",
  "diff_func": "@@ -74,7 +74,7 @@\n #include \"php_ini.h\"\n #include \"ext/standard/php_string.h\"\n #include \"ext/standard/php_image.h\"\n-#include \"ext/standard/info.h\" \n+#include \"ext/standard/info.h\"\n \n /* needed for ssize_t definition */\n #include <sys/types.h>\n@@ -161,7 +161,7 @@ ZEND_BEGIN_MODULE_GLOBALS(exif)\n \tchar * encode_jis;\n \tchar * decode_jis_be;\n \tchar * decode_jis_le;\n-ZEND_END_MODULE_GLOBALS(exif) \n+ZEND_END_MODULE_GLOBALS(exif)\n \n ZEND_DECLARE_MODULE_GLOBALS(exif)\n \n@@ -170,7 +170,7 @@ ZEND_DECLARE_MODULE_GLOBALS(exif)\n #else\n #define EXIF_G(v) (exif_globals.v)\n #endif\n- \n+\n /* {{{ PHP_INI\n  */\n \n@@ -213,7 +213,7 @@ PHP_INI_BEGIN()\n     STD_PHP_INI_ENTRY(\"exif.decode_jis_intel\",        \"JIS\",         PHP_INI_ALL, OnUpdateDecode, decode_jis_le,     zend_exif_globals, exif_globals)\n PHP_INI_END()\n /* }}} */\n- \n+\n /* {{{ PHP_GINIT_FUNCTION\n  */\n static PHP_GINIT_FUNCTION(exif)\n@@ -233,9 +233,9 @@ PHP_MINIT_FUNCTION(exif)\n {\n \tREGISTER_INI_ENTRIES();\n \tif (zend_hash_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\"))) {\n-\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 1, CONST_CS | CONST_PERSISTENT); \n+\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 1, CONST_CS | CONST_PERSISTENT);\n \t} else {\n-\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 0, CONST_CS | CONST_PERSISTENT); \n+\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 0, CONST_CS | CONST_PERSISTENT);\n \t}\n \treturn SUCCESS;\n }\n@@ -265,7 +265,7 @@ zend_module_entry exif_module_entry = {\n \texif_module_deps,\n \t\"exif\",\n \texif_functions,\n-\tPHP_MINIT(exif), \n+\tPHP_MINIT(exif),\n \tPHP_MSHUTDOWN(exif),\n \tNULL, NULL,\n \tPHP_MINFO(exif),\n@@ -278,7 +278,7 @@ zend_module_entry exif_module_entry = {\n \tNULL,\n \tNULL,\n \tSTANDARD_MODULE_PROPERTIES_EX\n-#else\t\n+#else\n \tSTANDARD_MODULE_PROPERTIES\n #endif\n };\n@@ -667,73 +667,73 @@ static tag_info_array tag_table_IFD = {\n   { 0x0213, \"YCbCrPositioning\"},\n   { 0x0214, \"ReferenceBlackWhite\"},\n   { 0x02BC, \"ExtensibleMetadataPlatform\"}, /* XAP: Extensible Authoring Publishing, obsoleted by XMP: Extensible Metadata Platform */\n-  { 0x0301, \"Gamma\"}, \n-  { 0x0302, \"ICCProfileDescriptor\"}, \n-  { 0x0303, \"SRGBRenderingIntent\"}, \n-  { 0x0320, \"ImageTitle\"}, \n-  { 0x5001, \"ResolutionXUnit\"}, \n-  { 0x5002, \"ResolutionYUnit\"}, \n-  { 0x5003, \"ResolutionXLengthUnit\"}, \n-  { 0x5004, \"ResolutionYLengthUnit\"}, \n-  { 0x5005, \"PrintFlags\"}, \n-  { 0x5006, \"PrintFlagsVersion\"}, \n-  { 0x5007, \"PrintFlagsCrop\"}, \n-  { 0x5008, \"PrintFlagsBleedWidth\"}, \n-  { 0x5009, \"PrintFlagsBleedWidthScale\"}, \n-  { 0x500A, \"HalftoneLPI\"}, \n-  { 0x500B, \"HalftoneLPIUnit\"}, \n-  { 0x500C, \"HalftoneDegree\"}, \n-  { 0x500D, \"HalftoneShape\"}, \n-  { 0x500E, \"HalftoneMisc\"}, \n-  { 0x500F, \"HalftoneScreen\"}, \n-  { 0x5010, \"JPEGQuality\"}, \n-  { 0x5011, \"GridSize\"}, \n-  { 0x5012, \"ThumbnailFormat\"}, \n-  { 0x5013, \"ThumbnailWidth\"}, \n-  { 0x5014, \"ThumbnailHeight\"}, \n-  { 0x5015, \"ThumbnailColorDepth\"}, \n-  { 0x5016, \"ThumbnailPlanes\"}, \n-  { 0x5017, \"ThumbnailRawBytes\"}, \n-  { 0x5018, \"ThumbnailSize\"}, \n-  { 0x5019, \"ThumbnailCompressedSize\"}, \n-  { 0x501A, \"ColorTransferFunction\"}, \n-  { 0x501B, \"ThumbnailData\"}, \n-  { 0x5020, \"ThumbnailImageWidth\"}, \n-  { 0x5021, \"ThumbnailImageHeight\"}, \n-  { 0x5022, \"ThumbnailBitsPerSample\"}, \n-  { 0x5023, \"ThumbnailCompression\"}, \n-  { 0x5024, \"ThumbnailPhotometricInterp\"}, \n-  { 0x5025, \"ThumbnailImageDescription\"}, \n-  { 0x5026, \"ThumbnailEquipMake\"}, \n-  { 0x5027, \"ThumbnailEquipModel\"}, \n-  { 0x5028, \"ThumbnailStripOffsets\"}, \n-  { 0x5029, \"ThumbnailOrientation\"}, \n-  { 0x502A, \"ThumbnailSamplesPerPixel\"}, \n-  { 0x502B, \"ThumbnailRowsPerStrip\"}, \n-  { 0x502C, \"ThumbnailStripBytesCount\"}, \n-  { 0x502D, \"ThumbnailResolutionX\"}, \n-  { 0x502E, \"ThumbnailResolutionY\"}, \n-  { 0x502F, \"ThumbnailPlanarConfig\"}, \n-  { 0x5030, \"ThumbnailResolutionUnit\"}, \n-  { 0x5031, \"ThumbnailTransferFunction\"}, \n-  { 0x5032, \"ThumbnailSoftwareUsed\"}, \n-  { 0x5033, \"ThumbnailDateTime\"}, \n-  { 0x5034, \"ThumbnailArtist\"}, \n-  { 0x5035, \"ThumbnailWhitePoint\"}, \n-  { 0x5036, \"ThumbnailPrimaryChromaticities\"}, \n-  { 0x5037, \"ThumbnailYCbCrCoefficients\"}, \n-  { 0x5038, \"ThumbnailYCbCrSubsampling\"}, \n-  { 0x5039, \"ThumbnailYCbCrPositioning\"}, \n-  { 0x503A, \"ThumbnailRefBlackWhite\"}, \n-  { 0x503B, \"ThumbnailCopyRight\"}, \n-  { 0x5090, \"LuminanceTable\"}, \n-  { 0x5091, \"ChrominanceTable\"}, \n-  { 0x5100, \"FrameDelay\"}, \n-  { 0x5101, \"LoopCount\"}, \n-  { 0x5110, \"PixelUnit\"}, \n-  { 0x5111, \"PixelPerUnitX\"}, \n-  { 0x5112, \"PixelPerUnitY\"}, \n-  { 0x5113, \"PaletteHistogram\"}, \n+  { 0x0301, \"Gamma\"},\n+  { 0x0302, \"ICCProfileDescriptor\"},\n+  { 0x0303, \"SRGBRenderingIntent\"},\n+  { 0x0320, \"ImageTitle\"},\n+  { 0x5001, \"ResolutionXUnit\"},\n+  { 0x5002, \"ResolutionYUnit\"},\n+  { 0x5003, \"ResolutionXLengthUnit\"},\n+  { 0x5004, \"ResolutionYLengthUnit\"},\n+  { 0x5005, \"PrintFlags\"},\n+  { 0x5006, \"PrintFlagsVersion\"},\n+  { 0x5007, \"PrintFlagsCrop\"},\n+  { 0x5008, \"PrintFlagsBleedWidth\"},\n+  { 0x5009, \"PrintFlagsBleedWidthScale\"},\n+  { 0x500A, \"HalftoneLPI\"},\n+  { 0x500B, \"HalftoneLPIUnit\"},\n+  { 0x500C, \"HalftoneDegree\"},\n+  { 0x500D, \"HalftoneShape\"},\n+  { 0x500E, \"HalftoneMisc\"},\n+  { 0x500F, \"HalftoneScreen\"},\n+  { 0x5010, \"JPEGQuality\"},\n+  { 0x5011, \"GridSize\"},\n+  { 0x5012, \"ThumbnailFormat\"},\n+  { 0x5013, \"ThumbnailWidth\"},\n+  { 0x5014, \"ThumbnailHeight\"},\n+  { 0x5015, \"ThumbnailColorDepth\"},\n+  { 0x5016, \"ThumbnailPlanes\"},\n+  { 0x5017, \"ThumbnailRawBytes\"},\n+  { 0x5018, \"ThumbnailSize\"},\n+  { 0x5019, \"ThumbnailCompressedSize\"},\n+  { 0x501A, \"ColorTransferFunction\"},\n+  { 0x501B, \"ThumbnailData\"},\n+  { 0x5020, \"ThumbnailImageWidth\"},\n+  { 0x5021, \"ThumbnailImageHeight\"},\n+  { 0x5022, \"ThumbnailBitsPerSample\"},\n+  { 0x5023, \"ThumbnailCompression\"},\n+  { 0x5024, \"ThumbnailPhotometricInterp\"},\n+  { 0x5025, \"ThumbnailImageDescription\"},\n+  { 0x5026, \"ThumbnailEquipMake\"},\n+  { 0x5027, \"ThumbnailEquipModel\"},\n+  { 0x5028, \"ThumbnailStripOffsets\"},\n+  { 0x5029, \"ThumbnailOrientation\"},\n+  { 0x502A, \"ThumbnailSamplesPerPixel\"},\n+  { 0x502B, \"ThumbnailRowsPerStrip\"},\n+  { 0x502C, \"ThumbnailStripBytesCount\"},\n+  { 0x502D, \"ThumbnailResolutionX\"},\n+  { 0x502E, \"ThumbnailResolutionY\"},\n+  { 0x502F, \"ThumbnailPlanarConfig\"},\n+  { 0x5030, \"ThumbnailResolutionUnit\"},\n+  { 0x5031, \"ThumbnailTransferFunction\"},\n+  { 0x5032, \"ThumbnailSoftwareUsed\"},\n+  { 0x5033, \"ThumbnailDateTime\"},\n+  { 0x5034, \"ThumbnailArtist\"},\n+  { 0x5035, \"ThumbnailWhitePoint\"},\n+  { 0x5036, \"ThumbnailPrimaryChromaticities\"},\n+  { 0x5037, \"ThumbnailYCbCrCoefficients\"},\n+  { 0x5038, \"ThumbnailYCbCrSubsampling\"},\n+  { 0x5039, \"ThumbnailYCbCrPositioning\"},\n+  { 0x503A, \"ThumbnailRefBlackWhite\"},\n+  { 0x503B, \"ThumbnailCopyRight\"},\n+  { 0x5090, \"LuminanceTable\"},\n+  { 0x5091, \"ChrominanceTable\"},\n+  { 0x5100, \"FrameDelay\"},\n+  { 0x5101, \"LoopCount\"},\n+  { 0x5110, \"PixelUnit\"},\n+  { 0x5111, \"PixelPerUnitX\"},\n+  { 0x5112, \"PixelPerUnitY\"},\n+  { 0x5113, \"PaletteHistogram\"},\n   { 0x1000, \"RelatedImageFileFormat\"},\n   { 0x800D, \"ImageID\"},\n   { 0x80E3, \"Matteing\"},   /* obsoleted by ExtraSamples */\n@@ -939,7 +939,7 @@ static tag_info_array tag_table_VND_NIKON = {\n   { 0x000b, \"Converter\"},\n   TAG_TABLE_END\n };\n-  \n+\n static tag_info_array tag_table_VND_NIKON_990 = {\n   { 0x0001, \"Version\"},\n   { 0x0002, \"ISOSetting\"},\n@@ -958,7 +958,7 @@ static tag_info_array tag_table_VND_NIKON_990 = {\n   { 0x0010, \"DataDump\"},\n   TAG_TABLE_END\n };\n-  \n+\n static tag_info_array tag_table_VND_OLYMPUS = {\n   { 0x0200, \"SpecialMode\"},\n   { 0x0201, \"JPEGQuality\"},\n@@ -1224,7 +1224,7 @@ char * exif_dump_data(int *dump_free, int format, int components, int length, in\n \t\tif (components > 0) {\n \t\t\tdump = erealloc(dump, len + 2 + 1);\n \t\t\tsnprintf(dump + len, 2 + 1, \", \");\n-\t\t\tlen += 2;\t\t\t\n+\t\t\tlen += 2;\n \t\t\tcomponents--;\n \t\t} else{\n \t\t\tbreak;\n@@ -1574,7 +1574,7 @@ typedef struct {\n static void exif_error_docref(const char *docref EXIFERR_DC, const image_info_type *ImageInfo, int type, const char *format, ...)\n {\n \tva_list args;\n-\t\n+\n \tva_start(args, format);\n #ifdef EXIF_DEBUG\n \t{\n@@ -2627,7 +2627,7 @@ static int exif_process_user_comment(image_info_type *ImageInfo, char **pszInfoP\n \t\t\t*pszEncoding = estrdup((const char*)szValuePtr);\n \t\t\tszValuePtr = szValuePtr+8;\n \t\t\tByteCount -= 8;\n-\t\t\t/* First try to detect BOM: ZERO WIDTH NOBREAK SPACE (FEFF 16) \n+\t\t\t/* First try to detect BOM: ZERO WIDTH NOBREAK SPACE (FEFF 16)\n \t\t\t * since we have no encoding support for the BOM yet we skip that.\n \t\t\t */\n \t\t\tif (!memcmp(szValuePtr, \"\\xFE\\xFF\", 2)) {\n@@ -2645,8 +2645,8 @@ static int exif_process_user_comment(image_info_type *ImageInfo, char **pszInfoP\n \t\t\t}\n \t\t\t/* XXX this will fail again if encoding_converter returns on error something different than SIZE_MAX   */\n \t\t\tif (zend_multibyte_encoding_converter(\n-\t\t\t\t\t(unsigned char**)pszInfoPtr, \n-\t\t\t\t\t&len, \n+\t\t\t\t\t(unsigned char**)pszInfoPtr,\n+\t\t\t\t\t&len,\n \t\t\t\t\t(unsigned char*)szValuePtr,\n \t\t\t\t\tByteCount,\n \t\t\t\t\tzend_multibyte_fetch_encoding(ImageInfo->encode_unicode TSRMLS_CC),\n@@ -2666,8 +2666,8 @@ static int exif_process_user_comment(image_info_type *ImageInfo, char **pszInfoP\n \t\t\tByteCount -= 8;\n \t\t\t/* XXX this will fail again if encoding_converter returns on error something different than SIZE_MAX   */\n \t\t\tif (zend_multibyte_encoding_converter(\n-\t\t\t\t\t(unsigned char**)pszInfoPtr, \n-\t\t\t\t\t&len, \n+\t\t\t\t\t(unsigned char**)pszInfoPtr,\n+\t\t\t\t\t&len,\n \t\t\t\t\t(unsigned char*)szValuePtr,\n \t\t\t\t\tByteCount,\n \t\t\t\t\tzend_multibyte_fetch_encoding(ImageInfo->encode_jis TSRMLS_CC),\n@@ -2701,12 +2701,12 @@ static int exif_process_user_comment(image_info_type *ImageInfo, char **pszInfoP\n  * Process unicode field in IFD. */\n static int exif_process_unicode(image_info_type *ImageInfo, xp_field_type *xp_field, int tag, char *szValuePtr, int ByteCount TSRMLS_DC)\n {\n-\txp_field->tag = tag;\t\n+\txp_field->tag = tag;\n \txp_field->value = NULL;\n \t/* XXX this will fail again if encoding_converter returns on error something different than SIZE_MAX   */\n \tif (zend_multibyte_encoding_converter(\n-\t\t\t(unsigned char**)&xp_field->value, \n-\t\t\t&xp_field->size, \n+\t\t\t(unsigned char**)&xp_field->value,\n+\t\t\t&xp_field->size,\n \t\t\t(unsigned char*)szValuePtr,\n \t\t\tByteCount,\n \t\t\tzend_multibyte_fetch_encoding(ImageInfo->encode_unicode TSRMLS_CC),\n@@ -2731,7 +2731,7 @@ static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * valu\n \t\tif (i==sizeof(maker_note_array)/sizeof(maker_note_type))\n \t\t\treturn FALSE;\n \t\tmaker_note = maker_note_array+i;\n-\t\t\n+\n \t\t/*exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"check (%s,%s)\", maker_note->make?maker_note->make:\"\", maker_note->model?maker_note->model:\"\");*/\n \t\tif (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make)))\n \t\t\tcontinue;\n@@ -2852,9 +2852,9 @@ static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, cha\n \t\toffset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n \t\t/* If its bigger than 4 bytes, the dir entry contains an offset. */\n \t\tvalue_ptr = offset_base+offset_val;\n-        /* \n+        /*\n             dir_entry is ImageInfo->file.list[sn].data+2+i*12\n-            offset_base is ImageInfo->file.list[sn].data-dir_offset \n+            offset_base is ImageInfo->file.list[sn].data-dir_offset\n             dir_entry - offset_base is dir_offset+2+i*12\n         */\n \t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base)) {\n@@ -2925,18 +2925,18 @@ static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, cha\n \t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n \t\t\t\t\tImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n \t\t\t\t\tbreak;\n-\t\n+\n \t\t\t\tcase TAG_IMAGEHEIGHT:\n \t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n \t\t\t\t\tImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n \t\t\t\t\tbreak;\n-\t\n+\n \t\t\t\tcase TAG_STRIP_OFFSETS:\n \t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT:\n \t\t\t\t\t/* accept both formats */\n \t\t\t\t\tImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n \t\t\t\t\tbreak;\n-\t\n+\n \t\t\t\tcase TAG_STRIP_BYTE_COUNTS:\n \t\t\t\t\tif (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {\n \t\t\t\t\t\tImageInfo->Thumbnail.filetype = ImageInfo->FileType;\n@@ -2946,7 +2946,7 @@ static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, cha\n \t\t\t\t\t}\n \t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n \t\t\t\t\tbreak;\n-\t\n+\n \t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT_LEN:\n \t\t\t\t\tif (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {\n \t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;\n@@ -2973,7 +2973,7 @@ static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, cha\n \t\t\t\t\t\tImageInfo->Copyright = estrdup(value_ptr);\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tbreak;   \n+\t\t\t\tbreak;\n \n \t\t\tcase TAG_USERCOMMENT:\n \t\t\t\tImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count TSRMLS_CC);\n@@ -3061,10 +3061,10 @@ static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, cha\n \t\t\t\tbreak;\n \n \t\t\tcase TAG_MAKE:\n-\t\t\t\tImageInfo->make = estrdup(value_ptr);\n+\t\t\t\tImageInfo->make = estrndup(value_ptr, byte_count);\n \t\t\t\tbreak;\n \t\t\tcase TAG_MODEL:\n-\t\t\t\tImageInfo->model = estrdup(value_ptr);\n+\t\t\t\tImageInfo->model = estrndup(value_ptr, byte_count);\n \t\t\t\tbreak;\n \n \t\t\tcase TAG_MAKER_NOTE:\n@@ -3414,7 +3414,7 @@ static int exif_scan_JPEG_header(image_info_type *ImageInfo TSRMLS_DC)\n \t\t\t\tif ((itemlen - 2) < 6) {\n \t\t\t\t\treturn FALSE;\n \t\t\t\t}\n-\t\t\n+\n \t\t\t\texif_process_SOFn(Data, marker, &sof_info);\n \t\t\t\tImageInfo->Width  = sof_info.width;\n \t\t\t\tImageInfo->Height = sof_info.height;\n@@ -3459,21 +3459,21 @@ static int exif_scan_thumbnail(image_info_type *ImageInfo TSRMLS_DC)\n \t}\n \tfor (;;) {\n \t\tpos += length;\n-\t\tif (pos>=ImageInfo->Thumbnail.size) \n+\t\tif (pos>=ImageInfo->Thumbnail.size)\n \t\t\treturn FALSE;\n \t\tc = data[pos++];\n-\t\tif (pos>=ImageInfo->Thumbnail.size) \n+\t\tif (pos>=ImageInfo->Thumbnail.size)\n \t\t\treturn FALSE;\n \t\tif (c != 0xFF) {\n \t\t\treturn FALSE;\n \t\t}\n \t\tn = 8;\n \t\twhile ((c = data[pos++]) == 0xFF && n--) {\n-\t\t\tif (pos+3>=ImageInfo->Thumbnail.size) \n+\t\t\tif (pos+3>=ImageInfo->Thumbnail.size)\n \t\t\t\treturn FALSE;\n \t\t\t/* +3 = pos++ of next check when reaching marker + 2 bytes for length */\n \t\t}\n-\t\tif (c == 0xFF) \n+\t\tif (c == 0xFF)\n \t\t\treturn FALSE;\n \t\tmarker = c;\n \t\tlength = php_jpg_get16(data+pos);\n@@ -3787,7 +3787,7 @@ static int exif_scan_FILE_header(image_info_type *ImageInfo TSRMLS_DC)\n \t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"File has TIFF/II format\");\n #endif\n \t\t\t\tImageInfo->sections_found |= FOUND_IFD0;\n-\t\t\t\tif (exif_process_IFD_in_TIFF(ImageInfo, \n+\t\t\t\tif (exif_process_IFD_in_TIFF(ImageInfo,\n \t\t\t\t\t\t\t\t\t\t\t php_ifd_get32u(file_header + 4, ImageInfo->motorola_intel),\n \t\t\t\t\t\t\t\t\t\t\t SECTION_IFD0 TSRMLS_CC)) {\n \t\t\t\t\tret = TRUE;\n@@ -3967,7 +3967,7 @@ PHP_FUNCTION(exif_read_data)\n \tsections_str = exif_get_sectionlist(ImageInfo.sections_found TSRMLS_CC);\n \n #ifdef EXIF_DEBUG\n-\tif (sections_str) \n+\tif (sections_str)\n \t\texif_error_docref(NULL EXIFERR_CC, &ImageInfo, E_NOTICE, \"Sections found: %s\", sections_str[0] ? sections_str : \"None\");\n #endif\n ",
  "func": "static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, char *offset_base, size_t IFDlength, size_t displacement, int section_index, int ReadNextIFD, tag_table_type tag_table TSRMLS_DC)\n{\n\tsize_t length;\n\tint tag, format, components;\n\tchar *value_ptr, tagname[64], cbuf[32], *outside=NULL;\n\tsize_t byte_count, offset_val, fpos, fgot;\n\tint64_t byte_count_signed;\n\txp_field_type *tmp_xp;\n#ifdef EXIF_DEBUG\n\tchar *dump_data;\n\tint dump_free;\n#endif /* EXIF_DEBUG */\n\n\t/* Protect against corrupt headers */\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"corrupt EXIF header: maximum directory nesting level reached\");\n\t\treturn FALSE;\n\t}\n\tImageInfo->ifd_nesting_level++;\n\n\ttag = php_ifd_get16u(dir_entry, ImageInfo->motorola_intel);\n\tformat = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\tcomponents = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);\n\n\tif (!format || format > NUM_FORMATS) {\n\t\t/* (-1) catches illegal zero case as unsigned underflows to positive large. */\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), format);\n\t\tformat = TAG_FMT_BYTE;\n\t\t/*return TRUE;*/\n\t}\n\n\tif (components < 0) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal components(%ld)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), components);\n\t\treturn FALSE;\n\t}\n\n\tbyte_count_signed = (int64_t)components * php_tiff_bytes_per_format[format];\n\n\tif (byte_count_signed < 0 || (byte_count_signed > INT32_MAX)) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal byte_count\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC));\n\t\treturn FALSE;\n\t}\n\n\tbyte_count = (size_t)byte_count_signed;\n\n\tif (byte_count > 4) {\n\t\toffset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t/* If its bigger than 4 bytes, the dir entry contains an offset. */\n\t\tvalue_ptr = offset_base+offset_val;\n        /* \n            dir_entry is ImageInfo->file.list[sn].data+2+i*12\n            offset_base is ImageInfo->file.list[sn].data-dir_offset \n            dir_entry - offset_base is dir_offset+2+i*12\n        */\n\t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base)) {\n\t\t\t/* It is important to check for IMAGE_FILETYPE_TIFF\n\t\t\t * JPEG does not use absolute pointers instead its pointers are\n\t\t\t * relative to the start of the TIFF header in APP1 section. */\n\t\t\tif (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {\n\t\t\t\tif (value_ptr < dir_entry) {\n\t\t\t\t\t/* we can read this if offset_val > 0 */\n\t\t\t\t\t/* some files have their values in other parts of the file */\n\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, dir_entry);\n\t\t\t\t} else {\n\t\t\t\t\t/* this is for sure not allowed */\n\t\t\t\t\t/* exception are IFD pointers */\n\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, byte_count, offset_val+byte_count, IFDlength);\n\t\t\t\t}\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tif (byte_count>sizeof(cbuf)) {\n\t\t\t\t/* mark as outside range and get buffer */\n\t\t\t\tvalue_ptr = safe_emalloc(byte_count, 1, 0);\n\t\t\t\toutside = value_ptr;\n\t\t\t} else {\n\t\t\t\t/* In most cases we only access a small range so\n\t\t\t\t * it is faster to use a static buffer there\n\t\t\t\t * BUT it offers also the possibility to have\n\t\t\t\t * pointers read without the need to free them\n\t\t\t\t * explicitley before returning. */\n\t\t\t\tmemset(&cbuf, 0, sizeof(cbuf));\n\t\t\t\tvalue_ptr = cbuf;\n\t\t\t}\n\n\t\t\tfpos = php_stream_tell(ImageInfo->infile);\n\t\t\tphp_stream_seek(ImageInfo->infile, offset_val, SEEK_SET);\n\t\t\tfgot = php_stream_tell(ImageInfo->infile);\n\t\t\tif (fgot!=offset_val) {\n\t\t\t\tEFREE_IF(outside);\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Wrong file pointer: 0x%08X != 0x%08X\", fgot, offset_val);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tfgot = php_stream_read(ImageInfo->infile, value_ptr, byte_count);\n\t\t\tphp_stream_seek(ImageInfo->infile, fpos, SEEK_SET);\n\t\t\tif (fgot<byte_count) {\n\t\t\t\tEFREE_IF(outside);\n\t\t\t\tEXIF_ERRLOG_FILEEOF(ImageInfo)\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* 4 bytes or less and value is in the dir entry itself */\n\t\tvalue_ptr = dir_entry+8;\n\t\toffset_val= value_ptr-offset_base;\n\t}\n\n\tImageInfo->sections_found |= FOUND_ANY_TAG;\n#ifdef EXIF_DEBUG\n\tdump_data = exif_dump_data(&dump_free, format, components, length, ImageInfo->motorola_intel, value_ptr TSRMLS_CC);\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val+displacement, byte_count, byte_count, (components>1)&&format!=TAG_FMT_UNDEFINED&&format!=TAG_FMT_STRING?\"ARRAY OF \":\"\", exif_get_tagformat(format), dump_data);\n\tif (dump_free) {\n\t\tefree(dump_data);\n\t}\n#endif\n\n\tif (section_index==SECTION_THUMBNAIL) {\n\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\tswitch(tag) {\n\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\tImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\tImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_STRIP_OFFSETS:\n\t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\t\t/* accept both formats */\n\t\t\t\t\tImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_STRIP_BYTE_COUNTS:\n\t\t\t\t\tif (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = ImageInfo->FileType;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* motorola is easier to read */\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_TIFF_MM;\n\t\t\t\t\t}\n\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT_LEN:\n\t\t\t\t\tif (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;\n\t\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (section_index==SECTION_IFD0 || section_index==SECTION_EXIF)\n\t\tswitch(tag) {\n\t\t\tcase TAG_COPYRIGHT:\n\t\t\t\t/* check for \"<photographer> NUL <editor> NUL\" */\n\t\t\t\tif (byte_count>1 && (length=php_strnlen(value_ptr, byte_count)) > 0) {\n\t\t\t\t\tif (length<byte_count-1) {\n\t\t\t\t\t\t/* When there are any characters after the first NUL */\n\t\t\t\t\t\tImageInfo->CopyrightPhotographer  = estrdup(value_ptr);\n\t\t\t\t\t\tImageInfo->CopyrightEditor        = estrdup(value_ptr+length+1);\n\t\t\t\t\t\tspprintf(&ImageInfo->Copyright, 0, \"%s, %s\", value_ptr, value_ptr+length+1);\n\t\t\t\t\t\t/* format = TAG_FMT_UNDEFINED; this musn't be ASCII         */\n\t\t\t\t\t\t/* but we are not supposed to change this                   */\n\t\t\t\t\t\t/* keep in mind that image_info does not store editor value */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tImageInfo->Copyright = estrdup(value_ptr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;   \n\n\t\t\tcase TAG_USERCOMMENT:\n\t\t\t\tImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_XP_TITLE:\n\t\t\tcase TAG_XP_COMMENTS:\n\t\t\tcase TAG_XP_AUTHOR:\n\t\t\tcase TAG_XP_KEYWORDS:\n\t\t\tcase TAG_XP_SUBJECT:\n\t\t\t\ttmp_xp = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);\n\t\t\t\tImageInfo->sections_found |= FOUND_WINXP;\n\t\t\t\tImageInfo->xp_fields.list = tmp_xp;\n\t\t\t\tImageInfo->xp_fields.count++;\n\t\t\t\texif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), tag, value_ptr, byte_count TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FNUMBER:\n\t\t\t\t/* Simplest way of expressing aperture, so I trust it the most.\n\t\t\t\t   (overwrite previously computed value if there is one) */\n\t\t\t\tImageInfo->ApertureFNumber = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_APERTURE:\n\t\t\tcase TAG_MAX_APERTURE:\n\t\t\t\t/* More relevant info always comes earlier, so only use this field if we don't\n\t\t\t\t   have appropriate aperture information yet. */\n\t\t\t\tif (ImageInfo->ApertureFNumber == 0) {\n\t\t\t\t\tImageInfo->ApertureFNumber\n\t\t\t\t\t\t= (float)exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)*0.5);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SHUTTERSPEED:\n\t\t\t\t/* More complicated way of expressing exposure time, so only use\n\t\t\t\t   this value if we don't already have it from somewhere else.\n\t\t\t\t   SHUTTERSPEED comes after EXPOSURE TIME\n\t\t\t\t  */\n\t\t\t\tif (ImageInfo->ExposureTime == 0) {\n\t\t\t\t\tImageInfo->ExposureTime\n\t\t\t\t\t\t= (float)(1/exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TAG_EXPOSURETIME:\n\t\t\t\tImageInfo->ExposureTime = -1;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\tImageInfo->ExifImageWidth = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FOCALPLANE_X_RES:\n\t\t\t\tImageInfo->FocalplaneXRes = exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SUBJECT_DISTANCE:\n\t\t\t\t/* Inidcates the distacne the autofocus camera is focused to.\n\t\t\t\t   Tends to be less accurate as distance increases. */\n\t\t\t\tImageInfo->Distance = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FOCALPLANE_RESOLUTION_UNIT:\n\t\t\t\tswitch((int)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)) {\n\t\t\t\t\tcase 1: ImageInfo->FocalplaneUnits = 25.4; break; /* inch */\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t/* According to the information I was using, 2 measn meters.\n\t\t\t\t\t\t   But looking at the Cannon powershot's files, inches is the only\n\t\t\t\t\t\t   sensible value. */\n\t\t\t\t\t\tImageInfo->FocalplaneUnits = 25.4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3: ImageInfo->FocalplaneUnits = 10;   break;  /* centimeter */\n\t\t\t\t\tcase 4: ImageInfo->FocalplaneUnits = 1;    break;  /* milimeter  */\n\t\t\t\t\tcase 5: ImageInfo->FocalplaneUnits = .001; break;  /* micrometer */\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SUB_IFD:\n\t\t\t\tif (format==TAG_FMT_IFD) {\n\t\t\t\t\t/* If this is called we are either in a TIFFs thumbnail or a JPEG where we cannot handle it */\n\t\t\t\t\t/* TIFF thumbnail: our data structure cannot store a thumbnail of a thumbnail */\n\t\t\t\t\t/* JPEG do we have the data area and what to do with it */\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Skip SUB IFD\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAKE:\n\t\t\t\tImageInfo->make = estrdup(value_ptr);\n\t\t\t\tbreak;\n\t\t\tcase TAG_MODEL:\n\t\t\t\tImageInfo->model = estrdup(value_ptr);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAKER_NOTE:\n\t\t\t\texif_process_IFD_in_MAKERNOTE(ImageInfo, value_ptr, byte_count, offset_base, IFDlength, displacement TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\tif (ReadNextIFD) {\n\t\t\t\t\tchar *Subdir_start;\n\t\t\t\t\tint sub_section_index = 0;\n\t\t\t\t\tswitch(tag) {\n\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found EXIF\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found GPS\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found INTEROPERABILITY\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSubdir_start = offset_base + php_ifd_get32u(value_ptr, ImageInfo->motorola_intel);\n\t\t\t\t\tif (Subdir_start < offset_base || Subdir_start > offset_base+IFDlength) {\n\t\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD Pointer\");\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (!exif_process_IFD_in_JPEG(ImageInfo, Subdir_start, offset_base, IFDlength, displacement, sub_section_index TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Subsection %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t}\n\t\t}\n\t}\n\texif_iif_add_tag(ImageInfo, section_index, exif_get_tagname(tag, tagname, sizeof(tagname), tag_table TSRMLS_CC), tag, format, components, value_ptr TSRMLS_CC);\n\tEFREE_IF(outside);\n\treturn TRUE;\n}",
  "project": "php-src",
  "hash": 110126115483762895567445864042748786778,
  "size": 315,
  "commit_id": "64043cb9e5d8bc5af719678893e38ee0290e0c0a",
  "message": "Fix bug #70385 (Buffer over-read in exif_read_data with TIFF IFD tag byte value of 32 bytes)",
  "target": 1,
  "dataset": "other",
  "idx": 200032,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The commit fixes a buffer over-read vulnerability in the exif_read_data function when processing TIFF IFD tags with a 32-byte value. The code changes ensure that only the specified number of bytes are copied, preventing over-reads and potential security risks.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}