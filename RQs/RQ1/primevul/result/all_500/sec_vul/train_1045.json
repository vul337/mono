{
  "id": 1045,
  "language": "c",
  "cwe": "CWE-125",
  "commit_url": "https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e",
  "commit_sha": "83d799804648c2a0895d40a19835d9b757c6fa4e",
  "commit_msg": "Fix issue #646 (#648)\n\n* Fix issue #646 and some edge cases with wide regexps using \\b and \\B\r\n\r\n* Rename function IS_WORD_CHAR to _yr_re_is_word_char",
  "pr_url": "https://github.com/VirusTotal/yara/pull/648",
  "pr_info": "",
  "file_name": "libyara/re.c",
  "func_name": "else",
  "raw_func_from_json": " int yr_re_exec(\n     uint8_t* re_code,\n     uint8_t* input_data,\n    size_t input_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n{\n  uint8_t* ip;\n  uint8_t* input;\n  uint8_t mask;\n  uint8_t value;\n\n  RE_FIBER_LIST fibers;\n  RE_THREAD_STORAGE* storage;\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n\n  int error;\n  int bytes_matched;\n  int max_bytes_matched;\n  int match;\n  int character_size;\n  int input_incr;\n  int kill;\n  int action;\n  int result = -1;\n\n  #define ACTION_NONE       0\n  #define ACTION_CONTINUE   1\n   #define ACTION_KILL       2\n   #define ACTION_KILL_TAIL  3\n \n  #define prolog if (bytes_matched >= max_bytes_matched) \\\n       { \\\n         action = ACTION_KILL; \\\n         break; \\\n      }\n \n  #define fail_if_error(e) switch (e) { \\\n         case ERROR_INSUFFICIENT_MEMORY: \\\n           return -2; \\\n         case ERROR_TOO_MANY_RE_FIBERS: \\\n           return -4; \\\n      }\n \n   if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n     return -2;\n\n  if (flags & RE_FLAGS_WIDE)\n    character_size = 2;\n  else\n    character_size = 1;\n\n  input = input_data;\n  input_incr = character_size;\n \n   if (flags & RE_FLAGS_BACKWARDS)\n   {\n     input -= character_size;\n     input_incr = -input_incr;\n   }\n  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);\n \n \n   max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n  bytes_matched = 0;\n\n  error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n  fail_if_error(error);\n\n  fiber->ip = re_code;\n  fibers.head = fiber;\n  fibers.tail = fiber;\n\n  error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n  fail_if_error(error);\n\n  while (fibers.head != NULL)\n  {\n    fiber = fibers.head;\n\n    while(fiber != NULL)\n    {\n      ip = fiber->ip;\n      action = ACTION_NONE;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_ANY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_GREEDY:\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n\n\n          break;\n\n        case RE_OPCODE_LITERAL:\n          prolog;\n          if (flags & RE_FLAGS_NO_CASE)\n            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];\n          else\n            match = (*input == *(ip + 1));\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 2;\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n          prolog;\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n\n          match = ((*input & mask) == value);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 3;\n          break;\n\n        case RE_OPCODE_CLASS:\n          prolog;\n          match = CHAR_IN_CLASS(*input, ip + 1);\n          if (!match && (flags & RE_FLAGS_NO_CASE))\n            match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 33;\n          break;\n \n         case RE_OPCODE_WORD_CHAR:\n           prolog;\n          match = IS_WORD_CHAR(*input);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_NON_WORD_CHAR:\n           prolog;\n          match = !IS_WORD_CHAR(*input);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n\n        case RE_OPCODE_SPACE:\n        case RE_OPCODE_NON_SPACE:\n\n          prolog;\n\n          switch(*input)\n          {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n            case '\\v':\n            case '\\f':\n              match = TRUE;\n              break;\n            default:\n              match = FALSE;\n          }\n\n          if (*ip == RE_OPCODE_NON_SPACE)\n            match = !match;\n\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_DIGIT:\n          prolog;\n          match = isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_DIGIT:\n          prolog;\n          match = !isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n         case RE_OPCODE_WORD_BOUNDARY:\n         case RE_OPCODE_NON_WORD_BOUNDARY:\n \n          if (bytes_matched == 0 &&\n              !(flags & RE_FLAGS_NOT_AT_START) &&\n              !(flags & RE_FLAGS_BACKWARDS))\n             match = TRUE;\n           else if (bytes_matched >= max_bytes_matched)\n             match = TRUE;\n          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))\n            match = TRUE;\n           else\n            match = FALSE;\n \n           if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n             match = !match;\n\n          action = match ? ACTION_CONTINUE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n \n         case RE_OPCODE_MATCH_AT_START:\n           if (flags & RE_FLAGS_BACKWARDS)\n            kill = input_size > (size_t) bytes_matched;\n           else\n            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_MATCH_AT_END:\n           kill = flags & RE_FLAGS_BACKWARDS ||\n                 input_size > (size_t) bytes_matched;\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n\n        case RE_OPCODE_MATCH:\n\n          result = bytes_matched;\n\n          if (flags & RE_FLAGS_EXHAUSTIVE)\n          {\n            if (callback != NULL)\n            {\n              int cb_result;\n\n              if (flags & RE_FLAGS_BACKWARDS)\n                cb_result = callback(\n                    input + character_size,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n              else\n                cb_result = callback(\n                    input_data,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n\n              switch(cb_result)\n              {\n                case ERROR_INSUFFICIENT_MEMORY:\n                  return -2;\n                case ERROR_TOO_MANY_MATCHES:\n                  return -3;\n                default:\n                  if (cb_result != ERROR_SUCCESS)\n                    return -4;\n              }\n            }\n\n            action = ACTION_KILL;\n          }\n          else\n          {\n            action = ACTION_KILL_TAIL;\n          }\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n\n      switch(action)\n      {\n        case ACTION_KILL:\n          fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);\n          break;\n\n        case ACTION_KILL_TAIL:\n          _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);\n          fiber = NULL;\n          break;\n\n        case ACTION_CONTINUE:\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          break;\n\n        default:\n          next_fiber = fiber->next;\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          fiber = next_fiber;\n       }\n     }\n \n    if (flags & RE_FLAGS_WIDE &&\n        bytes_matched < max_bytes_matched &&\n        *(input + 1) != 0)\n    {\n      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);\n    }\n     input += input_incr;\n     bytes_matched += character_size;\n \n    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)\n    {\n      error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n      fail_if_error(error);\n\n      fiber->ip = re_code;\n      _yr_re_fiber_append(&fibers, fiber);\n\n      error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n      fail_if_error(error);\n    }\n  }\n\n  return result;\n}\n",
  "diff_func": "@@ -140,6 +140,24 @@ typedef struct _RE_THREAD_STORAGE\n YR_THREAD_STORAGE_KEY thread_storage_key = 0;\n \n \n+#define CHAR_IN_CLASS(chr, cls)  \\\n+    ((cls)[(chr) / 8] & 1 << ((chr) % 8))\n+\n+\n+int _yr_re_is_word_char(\n+    uint8_t* input,\n+    int character_size)\n+{\n+  int result = ((isalnum(*input) || (*input) == '_'));\n+\n+  if (character_size == 2)\n+    result = result && (*(input + 1) == 0);\n+\n+  return result;\n+}\n+\n+\n+\n //\n // yr_re_initialize\n //\n@@ -360,6 +378,7 @@ int yr_re_match(\n       re->code,\n       (uint8_t*) target,\n       strlen(target),\n+      0,\n       re->flags | RE_FLAGS_SCAN,\n       NULL,\n       NULL);\n@@ -1799,18 +1818,30 @@ int _yr_re_fiber_sync(\n //\n // yr_re_exec\n //\n-// Executes a regular expression\n+// Executes a regular expression. The specified regular expression will try to\n+// match the data starting at the address specified by \"input\". The \"input\"\n+// pointer can point to any address inside a memory buffer. Arguments\n+// \"input_forwards_size\" and \"input_backwards_size\" indicate how many bytes\n+// can be accesible starting at \"input\" and going forwards and backwards\n+// respectively.\n+//\n+//   <--- input_backwards_size -->|<----------- input_forwards_size -------->\n+//  |--------  memory buffer  -----------------------------------------------|\n+//                                ^\n+//                              input\n //\n // Args:\n //   uint8_t* re_code                 - Regexp code be executed\n //   uint8_t* input                   - Pointer to input data\n-//   size_t input_size                - Input data size\n+//   size_t input_forwards_size       - Number of accessible bytes starting at\n+//                                      \"input\" and going forwards.\n+//   size_t input_backwards_size      - Number of accessible bytes starting at\n+//                                      \"input\" and going backwards\n //   int flags                        - Flags:\n //      RE_FLAGS_SCAN\n //      RE_FLAGS_BACKWARDS\n //      RE_FLAGS_EXHAUSTIVE\n //      RE_FLAGS_WIDE\n-//      RE_FLAGS_NOT_AT_START\n //      RE_FLAGS_NO_CASE\n //      RE_FLAGS_DOT_ALL\n //   RE_MATCH_CALLBACK_FUNC callback  - Callback function\n@@ -1825,10 +1856,12 @@ int _yr_re_fiber_sync(\n //      -4  Too many fibers\n //      -5  Unknown fatal error\n \n+\n int yr_re_exec(\n     uint8_t* re_code,\n     uint8_t* input_data,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n@@ -1858,18 +1891,23 @@ int yr_re_exec(\n   #define ACTION_KILL       2\n   #define ACTION_KILL_TAIL  3\n \n-  #define prolog if (bytes_matched >= max_bytes_matched) \\\n+  #define prolog { \\\n+      if ((bytes_matched >= max_bytes_matched) || \\\n+          (character_size == 2 && *(input + 1) != 0)) \\\n       { \\\n         action = ACTION_KILL; \\\n         break; \\\n-      }\n+      } \\\n+    }\n \n-  #define fail_if_error(e) switch (e) { \\\n+  #define fail_if_error(e) { \\\n+      switch (e) { \\\n         case ERROR_INSUFFICIENT_MEMORY: \\\n           return -2; \\\n         case ERROR_TOO_MANY_RE_FIBERS: \\\n           return -4; \\\n-      }\n+      } \\\n+    }\n \n   if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n     return -2;\n@@ -1884,14 +1922,17 @@ int yr_re_exec(\n \n   if (flags & RE_FLAGS_BACKWARDS)\n   {\n+    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);\n     input -= character_size;\n     input_incr = -input_incr;\n   }\n-\n-  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);\n+  else\n+  {\n+    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);\n+  }\n \n   // Round down max_bytes_matched to a multiple of character_size, this way if\n-  // character_size is 2 and input_size is odd we are ignoring the\n+  // character_size is 2 and max_bytes_matched is odd we are ignoring the\n   // extra byte which can't match anyways.\n \n   max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n@@ -1973,14 +2014,14 @@ int yr_re_exec(\n \n         case RE_OPCODE_WORD_CHAR:\n           prolog;\n-          match = IS_WORD_CHAR(*input);\n+          match = _yr_re_is_word_char(input, character_size);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_NON_WORD_CHAR:\n           prolog;\n-          match = !IS_WORD_CHAR(*input);\n+          match = !_yr_re_is_word_char(input, character_size);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n@@ -2028,16 +2069,25 @@ int yr_re_exec(\n         case RE_OPCODE_WORD_BOUNDARY:\n         case RE_OPCODE_NON_WORD_BOUNDARY:\n \n-          if (bytes_matched == 0 &&\n-              !(flags & RE_FLAGS_NOT_AT_START) &&\n-              !(flags & RE_FLAGS_BACKWARDS))\n+          if (bytes_matched == 0 && input_backwards_size < character_size)\n+          {\n             match = TRUE;\n+          }\n           else if (bytes_matched >= max_bytes_matched)\n+          {\n             match = TRUE;\n-          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))\n-            match = TRUE;\n+          }\n           else\n-            match = FALSE;\n+          {\n+            assert(input <  input_data + input_forwards_size);\n+            assert(input >= input_data - input_backwards_size);\n+\n+            assert(input - input_incr <  input_data + input_forwards_size);\n+            assert(input - input_incr >= input_data - input_backwards_size);\n+\n+            match = _yr_re_is_word_char(input, character_size) != \\\n+                    _yr_re_is_word_char(input - input_incr, character_size);\n+          }\n \n           if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n             match = !match;\n@@ -2048,16 +2098,16 @@ int yr_re_exec(\n \n         case RE_OPCODE_MATCH_AT_START:\n           if (flags & RE_FLAGS_BACKWARDS)\n-            kill = input_size > (size_t) bytes_matched;\n+            kill = input_backwards_size > (size_t) bytes_matched;\n           else\n-            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);\n+            kill = input_backwards_size > 0 || (bytes_matched != 0);\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_MATCH_AT_END:\n           kill = flags & RE_FLAGS_BACKWARDS ||\n-                 input_size > (size_t) bytes_matched;\n+                 input_forwards_size > (size_t) bytes_matched;\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n@@ -2134,13 +2184,6 @@ int yr_re_exec(\n       }\n     }\n \n-    if (flags & RE_FLAGS_WIDE &&\n-        bytes_matched < max_bytes_matched &&\n-        *(input + 1) != 0)\n-    {\n-      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);\n-    }\n-\n     input += input_incr;\n     bytes_matched += character_size;\n \n@@ -2164,7 +2207,8 @@ int yr_re_exec(\n int yr_re_fast_exec(\n     uint8_t* code,\n     uint8_t* input_data,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n@@ -2187,7 +2231,11 @@ int yr_re_fast_exec(\n   int input_incr;\n   int sp = 0;\n   int bytes_matched;\n-  int max_bytes_matched = input_size;\n+  int max_bytes_matched;\n+\n+  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?\n+      input_backwards_size :\n+      input_forwards_size;\n \n   input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;\n ",
  "project": "yara",
  "commit_id": "83d799804648c2a0895d40a19835d9b757c6fa4e",
  "target": 1,
  "func": " int yr_re_exec(\n     uint8_t* re_code,\n     uint8_t* input_data,\n    size_t input_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n{\n  uint8_t* ip;\n  uint8_t* input;\n  uint8_t mask;\n  uint8_t value;\n\n  RE_FIBER_LIST fibers;\n  RE_THREAD_STORAGE* storage;\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n\n  int error;\n  int bytes_matched;\n  int max_bytes_matched;\n  int match;\n  int character_size;\n  int input_incr;\n  int kill;\n  int action;\n  int result = -1;\n\n  #define ACTION_NONE       0\n  #define ACTION_CONTINUE   1\n   #define ACTION_KILL       2\n   #define ACTION_KILL_TAIL  3\n \n  #define prolog if (bytes_matched >= max_bytes_matched) \\\n       { \\\n         action = ACTION_KILL; \\\n         break; \\\n      }\n \n  #define fail_if_error(e) switch (e) { \\\n         case ERROR_INSUFFICIENT_MEMORY: \\\n           return -2; \\\n         case ERROR_TOO_MANY_RE_FIBERS: \\\n           return -4; \\\n      }\n \n   if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n     return -2;\n\n  if (flags & RE_FLAGS_WIDE)\n    character_size = 2;\n  else\n    character_size = 1;\n\n  input = input_data;\n  input_incr = character_size;\n \n   if (flags & RE_FLAGS_BACKWARDS)\n   {\n     input -= character_size;\n     input_incr = -input_incr;\n   }\n  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);\n \n \n   max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n  bytes_matched = 0;\n\n  error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n  fail_if_error(error);\n\n  fiber->ip = re_code;\n  fibers.head = fiber;\n  fibers.tail = fiber;\n\n  error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n  fail_if_error(error);\n\n  while (fibers.head != NULL)\n  {\n    fiber = fibers.head;\n\n    while(fiber != NULL)\n    {\n      ip = fiber->ip;\n      action = ACTION_NONE;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_ANY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_GREEDY:\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n\n\n          break;\n\n        case RE_OPCODE_LITERAL:\n          prolog;\n          if (flags & RE_FLAGS_NO_CASE)\n            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];\n          else\n            match = (*input == *(ip + 1));\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 2;\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n          prolog;\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n\n          match = ((*input & mask) == value);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 3;\n          break;\n\n        case RE_OPCODE_CLASS:\n          prolog;\n          match = CHAR_IN_CLASS(*input, ip + 1);\n          if (!match && (flags & RE_FLAGS_NO_CASE))\n            match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 33;\n          break;\n \n         case RE_OPCODE_WORD_CHAR:\n           prolog;\n          match = IS_WORD_CHAR(*input);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_NON_WORD_CHAR:\n           prolog;\n          match = !IS_WORD_CHAR(*input);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n\n        case RE_OPCODE_SPACE:\n        case RE_OPCODE_NON_SPACE:\n\n          prolog;\n\n          switch(*input)\n          {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n            case '\\v':\n            case '\\f':\n              match = TRUE;\n              break;\n            default:\n              match = FALSE;\n          }\n\n          if (*ip == RE_OPCODE_NON_SPACE)\n            match = !match;\n\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_DIGIT:\n          prolog;\n          match = isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_DIGIT:\n          prolog;\n          match = !isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n         case RE_OPCODE_WORD_BOUNDARY:\n         case RE_OPCODE_NON_WORD_BOUNDARY:\n \n          if (bytes_matched == 0 &&\n              !(flags & RE_FLAGS_NOT_AT_START) &&\n              !(flags & RE_FLAGS_BACKWARDS))\n             match = TRUE;\n           else if (bytes_matched >= max_bytes_matched)\n             match = TRUE;\n          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))\n            match = TRUE;\n           else\n            match = FALSE;\n \n           if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n             match = !match;\n\n          action = match ? ACTION_CONTINUE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n \n         case RE_OPCODE_MATCH_AT_START:\n           if (flags & RE_FLAGS_BACKWARDS)\n            kill = input_size > (size_t) bytes_matched;\n           else\n            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_MATCH_AT_END:\n           kill = flags & RE_FLAGS_BACKWARDS ||\n                 input_size > (size_t) bytes_matched;\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n\n        case RE_OPCODE_MATCH:\n\n          result = bytes_matched;\n\n          if (flags & RE_FLAGS_EXHAUSTIVE)\n          {\n            if (callback != NULL)\n            {\n              int cb_result;\n\n              if (flags & RE_FLAGS_BACKWARDS)\n                cb_result = callback(\n                    input + character_size,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n              else\n                cb_result = callback(\n                    input_data,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n\n              switch(cb_result)\n              {\n                case ERROR_INSUFFICIENT_MEMORY:\n                  return -2;\n                case ERROR_TOO_MANY_MATCHES:\n                  return -3;\n                default:\n                  if (cb_result != ERROR_SUCCESS)\n                    return -4;\n              }\n            }\n\n            action = ACTION_KILL;\n          }\n          else\n          {\n            action = ACTION_KILL_TAIL;\n          }\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n\n      switch(action)\n      {\n        case ACTION_KILL:\n          fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);\n          break;\n\n        case ACTION_KILL_TAIL:\n          _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);\n          fiber = NULL;\n          break;\n\n        case ACTION_CONTINUE:\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          break;\n\n        default:\n          next_fiber = fiber->next;\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          fiber = next_fiber;\n       }\n     }\n \n    if (flags & RE_FLAGS_WIDE &&\n        bytes_matched < max_bytes_matched &&\n        *(input + 1) != 0)\n    {\n      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);\n    }\n     input += input_incr;\n     bytes_matched += character_size;\n \n    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)\n    {\n      error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n      fail_if_error(error);\n\n      fiber->ip = re_code;\n      _yr_re_fiber_append(&fibers, fiber);\n\n      error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n      fail_if_error(error);\n    }\n  }\n\n  return result;\n}\n",
  "big_vul_idx": 181374,
  "idx": 2855,
  "hash": 71603843470270065462721611903582741596,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses issues with regex word boundaries, particularly for multi-byte characters. It introduces boundary checks and assertions to prevent out-of-bounds access, fixing potential security vulnerabilities.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}