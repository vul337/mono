{
  "id": 454,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/merlinepedra/TCPDUMP/commit/0f95d441e4b5d7512cc5c326c8668a120e048eda",
  "commit_sha": "0f95d441e4b5d7512cc5c326c8668a120e048eda",
  "commit_msg": "Do bounds checking when unescaping PPP.\n\nClean up a const issue while we're at it.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "print-ppp.c",
  "func_name": "",
  "raw_func_from_json": " ppp_hdlc(netdissect_options *ndo,\n          const u_char *p, int length)\n {\n\tu_char *b, *s, *t, c;\n \tint i, proto;\n \tconst void *se;\n \n         if (length <= 0)\n                 return;\n \n\tb = (uint8_t *)malloc(length);\n \tif (b == NULL)\n \t\treturn;\n \n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n \t * Do this so that we dont overwrite the original packet\n \t * contents.\n \t */\n\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n \t\tc = *s++;\n \t\tif (c == 0x7d) {\n\t\t\tif (i > 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n \t\t}\n \t\t*t++ = c;\n \t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}\n",
  "diff_func": "@@ -1351,14 +1351,15 @@ static void\n ppp_hdlc(netdissect_options *ndo,\n          const u_char *p, int length)\n {\n-\tu_char *b, *s, *t, c;\n+\tu_char *b, *t, c;\n+\tconst u_char *s;\n \tint i, proto;\n \tconst void *se;\n \n         if (length <= 0)\n                 return;\n \n-\tb = (uint8_t *)malloc(length);\n+\tb = (u_char *)malloc(length);\n \tif (b == NULL)\n \t\treturn;\n \n@@ -1367,14 +1368,13 @@ ppp_hdlc(netdissect_options *ndo,\n \t * Do this so that we dont overwrite the original packet\n \t * contents.\n \t */\n-\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n+\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {\n \t\tc = *s++;\n \t\tif (c == 0x7d) {\n-\t\t\tif (i > 1) {\n-\t\t\t\ti--;\n-\t\t\t\tc = *s++ ^ 0x20;\n-\t\t\t} else\n-\t\t\t\tcontinue;\n+\t\t\tif (i <= 1 || !ND_TTEST(*s))\n+\t\t\t\tbreak;\n+\t\t\ti--;\n+\t\t\tc = *s++ ^ 0x20;\n \t\t}\n \t\t*t++ = c;\n \t}",
  "project": "tcpdump",
  "commit_id": "0f95d441e4b5d7512cc5c326c8668a120e048eda",
  "target": 1,
  "func": " ppp_hdlc(netdissect_options *ndo,\n          const u_char *p, int length)\n {\n\tu_char *b, *s, *t, c;\n \tint i, proto;\n \tconst void *se;\n \n         if (length <= 0)\n                 return;\n \n\tb = (uint8_t *)malloc(length);\n \tif (b == NULL)\n \t\treturn;\n \n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n \t * Do this so that we dont overwrite the original packet\n \t * contents.\n \t */\n\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n \t\tc = *s++;\n \t\tif (c == 0x7d) {\n\t\t\tif (i > 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n \t\t}\n \t\t*t++ = c;\n \t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}\n",
  "big_vul_idx": 179412,
  "idx": 1183,
  "hash": 163830884355634389581814561024512585440,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch introduces bounds checking during the unescaping of PPP packets, preventing potential buffer overflows that could lead to security issues. The code changes ensure that the loop does not read beyond the buffer, addressing a security vulnerability.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}