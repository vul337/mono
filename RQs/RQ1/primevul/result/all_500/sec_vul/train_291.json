{
  "id": 291,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/malvira/lpc31xx/commit/be20250c13f88375345ad99950190685eda51eb8",
  "commit_sha": "be20250c13f88375345ad99950190685eda51eb8",
  "commit_msg": "ROSE: prevent heap corruption with bad facilities\n\nWhen parsing the FAC_NATIONAL_DIGIS facilities field, it's possible for\na remote host to provide more digipeaters than expected, resulting in\nheap corruption.  Check against ROSE_MAX_DIGIS to prevent overflows, and\nabort facilities parsing on failure.\n\nAdditionally, when parsing the FAC_CCITT_DEST_NSAP and\nFAC_CCITT_SRC_NSAP facilities fields, a remote host can provide a length\nof less than 10, resulting in an underflow in a memcpy size, causing a\nkernel panic due to massive heap corruption.  A length of greater than\n20 results in a stack overflow of the callsign array.  Abort facilities\nparsing on these invalid length values.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/rose/rose_subr.c",
  "func_name": "",
  "raw_func_from_json": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n \n \t\tcase 0xC0:\n \t\t\tl = p[1];\n \t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n \t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n \t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n",
  "diff_func": "@@ -290,10 +290,15 @@ static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *\n \t\t\t\tfacilities->source_ndigis = 0;\n \t\t\t\tfacilities->dest_ndigis   = 0;\n \t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n-\t\t\t\t\tif (pt[6] & AX25_HBIT)\n+\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n+\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n+\t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n-\t\t\t\t\telse\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n+\t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tp   += l + 2;\n@@ -333,6 +338,11 @@ static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *fac\n \n \t\tcase 0xC0:\n \t\t\tl = p[1];\n+\n+\t\t\t/* Prevent overflows*/\n+\t\t\tif (l < 10 || l > 20)\n+\t\t\t\treturn -1;\n+\n \t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n \t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n \t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n@@ -373,12 +383,16 @@ int rose_parse_facilities(unsigned char *p,\n \t\t\tswitch (*p) {\n \t\t\tcase FAC_NATIONAL:\t\t/* National */\n \t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n+\t\t\t\tif (len < 0)\n+\t\t\t\t\treturn 0;\n \t\t\t\tfacilities_len -= len + 1;\n \t\t\t\tp += len + 1;\n \t\t\t\tbreak;\n \n \t\t\tcase FAC_CCITT:\t\t/* CCITT */\n \t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n+\t\t\t\tif (len < 0)\n+\t\t\t\t\treturn 0;\n \t\t\t\tfacilities_len -= len + 1;\n \t\t\t\tp += len + 1;\n \t\t\t\tbreak;",
  "project": "linux",
  "commit_id": "be20250c13f88375345ad99950190685eda51eb8",
  "target": 1,
  "func": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n \n \t\tcase 0xC0:\n \t\t\tl = p[1];\n \t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n \t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n \t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n",
  "big_vul_idx": 178843,
  "idx": 693,
  "hash": 116021283864279117765367862922593228970,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by adding input validation to prevent buffer overflows and heap corruption. The commit message explicitly states the intention to fix these issues, and the code changes include necessary checks to mitigate the risks.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}