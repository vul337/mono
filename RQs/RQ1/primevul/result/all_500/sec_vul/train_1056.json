{
  "id": 1056,
  "language": "c",
  "cwe": "CWE-732",
  "commit_url": "https://github.com/sjp38/linux.personal/commit/a4866aa812518ed1a37d8ea0c881dc946409de94",
  "commit_sha": "a4866aa812518ed1a37d8ea0c881dc946409de94",
  "commit_msg": "mm: Tighten x86 /dev/mem with zeroing reads\n\nUnder CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is\ndisallowed. However, on x86, the first 1MB was always allowed for BIOS\nand similar things, regardless of it actually being System RAM. It was\npossible for heap to end up getting allocated in low 1MB RAM, and then\nread by things like x86info or dd, which would trip hardened usercopy:\n\nusercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)\n\nThis changes the x86 exception for the low 1MB by reading back zeros for\nSystem RAM areas instead of blindly allowing them. More work is needed to\nextend this to mmap, but currently mmap doesn't go through usercopy, so\nhardened usercopy won't Oops the kernel.\n\nReported-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nTested-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "arch/x86/mm/init.c",
  "func_name": "",
  "raw_func_from_json": " int devmem_is_allowed(unsigned long pagenr)\n {\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n \t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n }\n",
  "diff_func": "@@ -643,21 +643,40 @@ void __init init_mem_mapping(void)\n  * devmem_is_allowed() checks to see if /dev/mem access to a certain address\n  * is valid. The argument is a physical page number.\n  *\n- *\n- * On x86, access has to be given to the first megabyte of ram because that area\n- * contains BIOS code and data regions used by X and dosemu and similar apps.\n- * Access has to be given to non-kernel-ram areas as well, these contain the PCI\n- * mmio resources as well as potential bios/acpi data regions.\n+ * On x86, access has to be given to the first megabyte of RAM because that\n+ * area traditionally contains BIOS code and data regions used by X, dosemu,\n+ * and similar apps. Since they map the entire memory range, the whole range\n+ * must be allowed (for mapping), but any areas that would otherwise be\n+ * disallowed are flagged as being \"zero filled\" instead of rejected.\n+ * Access has to be given to non-kernel-ram areas as well, these contain the\n+ * PCI mmio resources as well as potential bios/acpi data regions.\n  */\n int devmem_is_allowed(unsigned long pagenr)\n {\n-\tif (pagenr < 256)\n-\t\treturn 1;\n-\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n+\tif (page_is_ram(pagenr)) {\n+\t\t/*\n+\t\t * For disallowed memory regions in the low 1MB range,\n+\t\t * request that the page be shown as all zeros.\n+\t\t */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 2;\n+\n+\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * This must follow RAM test, since System RAM is considered a\n+\t * restricted resource under CONFIG_STRICT_IOMEM.\n+\t */\n+\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {\n+\t\t/* Low 1MB bypasses iomem restrictions. */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 1;\n+\n \t\treturn 0;\n-\tif (!page_is_ram(pagenr))\n-\t\treturn 1;\n-\treturn 0;\n+\t}\n+\n+\treturn 1;\n }\n \n void free_init_pages(char *what, unsigned long begin, unsigned long end)",
  "project": "linux",
  "commit_id": "a4866aa812518ed1a37d8ea0c881dc946409de94",
  "target": 1,
  "func": " int devmem_is_allowed(unsigned long pagenr)\n {\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n \t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n }\n",
  "big_vul_idx": 181413,
  "idx": 2887,
  "hash": 205621365268399109573443948739494420926,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch tightens access to the low 1MB RAM on x86 systems by returning zeros for System RAM reads, preventing kernel memory exposure. This addresses a security vulnerability by mitigating unauthorized data disclosure.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}