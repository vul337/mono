{
  "id": 872,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/HKL-Kevin/msm8998-mainline/commit/3e0588c291d6ce225f2b891753ca41d45ba42469",
  "commit_sha": "3e0588c291d6ce225f2b891753ca41d45ba42469",
  "commit_msg": "hamradio: defer ax25 kfree after unregister_netdev\n\nThere is a possible race condition (use-after-free) like below\n\n (USE)                       |  (FREE)\nax25_sendmsg                 |\n ax25_queue_xmit             |\n  dev_queue_xmit             |\n   __dev_queue_xmit          |\n    __dev_xmit_skb           |\n     sch_direct_xmit         | ...\n      xmit_one               |\n       netdev_start_xmit     | tty_ldisc_kill\n        __netdev_start_xmit  |  mkiss_close\n         ax_xmit             |   kfree\n          ax_encaps          |\n                             |\n\nEven though there are two synchronization primitives before the kfree:\n1. wait_for_completion(&ax->dead). This can prevent the race with\nroutines from mkiss_ioctl. However, it cannot stop the routine coming\nfrom upper layer, i.e., the ax25_sendmsg.\n\n2. netif_stop_queue(ax->dev). It seems that this line of code aims to\nhalt the transmit queue but it fails to stop the routine that already\nbeing xmit.\n\nThis patch reorder the kfree after the unregister_netdev to avoid the\npossible UAF as the unregister_netdev() is well synchronized and won't\nreturn if there is a running routine.\n\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/net/hamradio/mkiss.c",
  "func_name": "",
  "raw_func_from_json": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\n\tif (!ax)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\t/*\n\t * Halt the transmit queue so that a new transmit cannot scribble\n\t * on our buffers\n\t */\n\tnetif_stop_queue(ax->dev);\n\n\t/* Free all AX25 frame buffers. */\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\n\tax->tty = NULL;\n\n\tunregister_netdev(ax->dev);\n\tfree_netdev(ax->dev);\n}",
  "diff_func": "@@ -792,13 +792,14 @@ static void mkiss_close(struct tty_struct *tty)\n \t */\n \tnetif_stop_queue(ax->dev);\n \n-\t/* Free all AX25 frame buffers. */\n-\tkfree(ax->rbuff);\n-\tkfree(ax->xbuff);\n-\n \tax->tty = NULL;\n \n \tunregister_netdev(ax->dev);\n+\n+\t/* Free all AX25 frame buffers after unreg. */\n+\tkfree(ax->rbuff);\n+\tkfree(ax->xbuff);\n+\n \tfree_netdev(ax->dev);\n }\n ",
  "func": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\n\tif (!ax)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\t/*\n\t * Halt the transmit queue so that a new transmit cannot scribble\n\t * on our buffers\n\t */\n\tnetif_stop_queue(ax->dev);\n\n\t/* Free all AX25 frame buffers. */\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\n\tax->tty = NULL;\n\n\tunregister_netdev(ax->dev);\n\tfree_netdev(ax->dev);\n}",
  "project": "linux",
  "hash": 109440345853446194360273736668132912271,
  "size": 33,
  "commit_id": "3e0588c291d6ce225f2b891753ca41d45ba42469",
  "message": "hamradio: defer ax25 kfree after unregister_netdev\n\nThere is a possible race condition (use-after-free) like below\n\n (USE)                       |  (FREE)\nax25_sendmsg                 |\n ax25_queue_xmit             |\n  dev_queue_xmit             |\n   __dev_queue_xmit          |\n    __dev_xmit_skb           |\n     sch_direct_xmit         | ...\n      xmit_one               |\n       netdev_start_xmit     | tty_ldisc_kill\n        __netdev_start_xmit  |  mkiss_close\n         ax_xmit             |   kfree\n          ax_encaps          |\n                             |\n\nEven though there are two synchronization primitives before the kfree:\n1. wait_for_completion(&ax->dead). This can prevent the race with\nroutines from mkiss_ioctl. However, it cannot stop the routine coming\nfrom upper layer, i.e., the ax25_sendmsg.\n\n2. netif_stop_queue(ax->dev). It seems that this line of code aims to\nhalt the transmit queue but it fails to stop the routine that already\nbeing xmit.\n\nThis patch reorder the kfree after the unregister_netdev to avoid the\npossible UAF as the unregister_netdev() is well synchronized and won't\nreturn if there is a running routine.\n\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "target": 1,
  "dataset": "other",
  "idx": 203980,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a use-after-free vulnerability by reordering operations to prevent race conditions, ensuring memory is not accessed after freeing. This is a security fix.\n\n**Final Output:**\nAnalysis: The patch fixes a use-after-free vulnerability by reordering kfree calls after unregister_netdev, preventing a race condition that could lead to unauthorized memory access.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}