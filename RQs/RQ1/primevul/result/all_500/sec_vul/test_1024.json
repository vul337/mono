{
  "id": 1024,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/DennissimOS/platform_external_libxml2/commit/38eae571111db3b43ffdeb05487c9f60551906fb",
  "commit_sha": "38eae571111db3b43ffdeb05487c9f60551906fb",
  "commit_msg": "Heap use-after-free in xmlSAX2AttributeNs\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=759020\n\n* parser.c:\n(xmlParseStartTag2): Attribute strings are only valid if the\nbase does not change, so add another check where the base may\nchange.  Make sure to set 'attvalue' to NULL after freeing it.\n* result/errors/759020.xml: Added.\n* result/errors/759020.xml.err: Added.\n* result/errors/759020.xml.str: Added.\n* test/errors/759020.xml: Added test case.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "parser.c",
  "func_name": "",
  "raw_func_from_json": "xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,\n                  const xmlChar **URI, int *tlen) {\n    const xmlChar *localname;\n    const xmlChar *prefix;\n    const xmlChar *attname;\n    const xmlChar *aprefix;\n    const xmlChar *nsname;\n    xmlChar *attvalue;\n    const xmlChar **atts = ctxt->atts;\n    int maxatts = ctxt->maxatts;\n    int nratts, nbatts, nbdef;\n    int i, j, nbNs, attval, oldline, oldcol, inputNr;\n    const xmlChar *base;\n    unsigned long cur;\n    int nsNr = ctxt->nsNr;\n\n    if (RAW != '<') return(NULL);\n    NEXT1;\n\n    /*\n     * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that\n     *       point since the attribute values may be stored as pointers to\n     *       the buffer and calling SHRINK would destroy them !\n     *       The Shrinking is only possible once the full set of attribute\n     *       callbacks have been done.\n     */\nreparse:\n    SHRINK;\n    base = ctxt->input->base;\n    cur = ctxt->input->cur - ctxt->input->base;\n    inputNr = ctxt->inputNr;\n    oldline = ctxt->input->line;\n    oldcol = ctxt->input->col;\n    nbatts = 0;\n    nratts = 0;\n    nbdef = 0;\n    nbNs = 0;\n    attval = 0;\n    /* Forget any namespaces added during an earlier parse of this element. */\n    ctxt->nsNr = nsNr;\n\n    localname = xmlParseQName(ctxt, &prefix);\n    if (localname == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"StartTag: invalid element name\\n\");\n        return(NULL);\n    }\n    *tlen = ctxt->input->cur - ctxt->input->base - cur;\n\n    /*\n     * Now parse the attributes, it ends up with the ending\n     *\n     * (S Attribute)* S?\n     */\n    SKIP_BLANKS;\n    GROW;\n    if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n        goto base_changed;\n\n    while (((RAW != '>') &&\n\t   ((RAW != '/') || (NXT(1) != '>')) &&\n\t   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {\n\tconst xmlChar *q = CUR_PTR;\n\tunsigned int cons = ctxt->input->consumed;\n\tint len = -1, alloc = 0;\n\n\tattname = xmlParseAttribute2(ctxt, prefix, localname,\n\t                             &aprefix, &attvalue, &len, &alloc);\n\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) {\n\t    if ((attvalue != NULL) && (alloc != 0))\n\t        xmlFree(attvalue);\n\t    attvalue = NULL;\n\t    goto base_changed;\n\t}\n        if ((attname != NULL) && (attvalue != NULL)) {\n\t    if (len < 0) len = xmlStrlen(attvalue);\n            if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {\n\t        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);\n\t\txmlURIPtr uri;\n\n                if (URL == NULL) {\n\t\t    xmlErrMemory(ctxt, \"dictionary allocation failure\");\n\t\t    if ((attvalue != NULL) && (alloc != 0))\n\t\t\txmlFree(attvalue);\n\t\t    return(NULL);\n\t\t}\n                if (*URL != 0) {\n\t\t    uri = xmlParseURI((const char *) URL);\n\t\t    if (uri == NULL) {\n\t\t\txmlNsErr(ctxt, XML_WAR_NS_URI,\n\t\t\t         \"xmlns: '%s' is not a valid URI\\n\",\n\t\t\t\t\t   URL, NULL, NULL);\n\t\t    } else {\n\t\t\tif (uri->scheme == NULL) {\n\t\t\t    xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,\n\t\t\t\t      \"xmlns: URI %s is not absolute\\n\",\n\t\t\t\t      URL, NULL, NULL);\n\t\t\t}\n\t\t\txmlFreeURI(uri);\n\t\t    }\n\t\t    if (URL == ctxt->str_xml_ns) {\n\t\t\tif (attname != ctxt->str_xml) {\n\t\t\t    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t \"xml namespace URI cannot be the default namespace\\n\",\n\t\t\t\t     NULL, NULL, NULL);\n\t\t\t}\n\t\t\tgoto skip_default_ns;\n\t\t    }\n\t\t    if ((len == 29) &&\n\t\t\t(xmlStrEqual(URL,\n\t\t\t\t BAD_CAST \"http://www.w3.org/2000/xmlns/\"))) {\n\t\t\txmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t     \"reuse of the xmlns namespace name is forbidden\\n\",\n\t\t\t\t NULL, NULL, NULL);\n\t\t\tgoto skip_default_ns;\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * check that it's not a defined namespace\n\t\t */\n\t\tfor (j = 1;j <= nbNs;j++)\n\t\t    if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)\n\t\t\tbreak;\n\t\tif (j <= nbNs)\n\t\t    xmlErrAttributeDup(ctxt, NULL, attname);\n\t\telse\n\t\t    if (nsPush(ctxt, NULL, URL) > 0) nbNs++;\nskip_default_ns:\n\t\tif (alloc != 0) xmlFree(attvalue);\n\t\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n\t\t    break;\n\t\tif (!IS_BLANK_CH(RAW)) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t\t   \"attributes construct error\\n\");\n\t\t    break;\n\t\t}\n\t\tSKIP_BLANKS;\n\t\tcontinue;\n\t    }\n            if (aprefix == ctxt->str_xmlns) {\n\t        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);\n\t\txmlURIPtr uri;\n\n                if (attname == ctxt->str_xml) {\n\t\t    if (URL != ctxt->str_xml_ns) {\n\t\t        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t         \"xml namespace prefix mapped to wrong URI\\n\",\n\t\t\t         NULL, NULL, NULL);\n\t\t    }\n\t\t    /*\n\t\t     * Do not keep a namespace definition node\n\t\t     */\n\t\t    goto skip_ns;\n\t\t}\n                if (URL == ctxt->str_xml_ns) {\n\t\t    if (attname != ctxt->str_xml) {\n\t\t        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t         \"xml namespace URI mapped to wrong prefix\\n\",\n\t\t\t         NULL, NULL, NULL);\n\t\t    }\n\t\t    goto skip_ns;\n\t\t}\n                if (attname == ctxt->str_xmlns) {\n\t\t    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t     \"redefinition of the xmlns prefix is forbidden\\n\",\n\t\t\t     NULL, NULL, NULL);\n\t\t    goto skip_ns;\n\t\t}\n\t\tif ((len == 29) &&\n\t\t    (xmlStrEqual(URL,\n\t\t                 BAD_CAST \"http://www.w3.org/2000/xmlns/\"))) {\n\t\t    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t     \"reuse of the xmlns namespace name is forbidden\\n\",\n\t\t\t     NULL, NULL, NULL);\n\t\t    goto skip_ns;\n\t\t}\n\t\tif ((URL == NULL) || (URL[0] == 0)) {\n\t\t    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t             \"xmlns:%s: Empty XML namespace is not allowed\\n\",\n\t\t\t          attname, NULL, NULL);\n\t\t    goto skip_ns;\n\t\t} else {\n\t\t    uri = xmlParseURI((const char *) URL);\n\t\t    if (uri == NULL) {\n\t\t\txmlNsErr(ctxt, XML_WAR_NS_URI,\n\t\t\t     \"xmlns:%s: '%s' is not a valid URI\\n\",\n\t\t\t\t\t   attname, URL, NULL);\n\t\t    } else {\n\t\t\tif ((ctxt->pedantic) && (uri->scheme == NULL)) {\n\t\t\t    xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,\n\t\t\t\t      \"xmlns:%s: URI %s is not absolute\\n\",\n\t\t\t\t      attname, URL, NULL);\n\t\t\t}\n\t\t\txmlFreeURI(uri);\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * check that it's not a defined namespace\n\t\t */\n\t\tfor (j = 1;j <= nbNs;j++)\n\t\t    if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)\n\t\t\tbreak;\n\t\tif (j <= nbNs)\n\t\t    xmlErrAttributeDup(ctxt, aprefix, attname);\n\t\telse\n\t\t    if (nsPush(ctxt, attname, URL) > 0) nbNs++;\nskip_ns:\n\t\tif (alloc != 0) xmlFree(attvalue);\n\t\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n\t\t    break;\n\t\tif (!IS_BLANK_CH(RAW)) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t\t   \"attributes construct error\\n\");\n\t\t    break;\n\t\t}\n\t\tSKIP_BLANKS;\n\t\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n\t\t    goto base_changed;\n\t\tcontinue;\n\t    }\n\n\t    /*\n\t     * Add the pair to atts\n\t     */\n\t    if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n\t        if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n\t\t    if (attvalue[len] == 0)\n\t\t\txmlFree(attvalue);\n\t\t    goto failed;\n\t\t}\n\t        maxatts = ctxt->maxatts;\n\t\tatts = ctxt->atts;\n\t    }\n\t    ctxt->attallocs[nratts++] = alloc;\n\t    atts[nbatts++] = attname;\n\t    atts[nbatts++] = aprefix;\n\t    atts[nbatts++] = NULL; /* the URI will be fetched later */\n\t    atts[nbatts++] = attvalue;\n\t    attvalue += len;\n\t    atts[nbatts++] = attvalue;\n\t    /*\n\t     * tag if some deallocation is needed\n\t     */\n\t    if (alloc != 0) attval = 1;\n\t} else {\n\t    if ((attvalue != NULL) && (attvalue[len] == 0))\n\t\txmlFree(attvalue);\n\t}\n\nfailed:\n\n\tGROW\n        if (ctxt->instate == XML_PARSER_EOF)\n            break;\n\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n\t    goto base_changed;\n\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n\t    break;\n\tif (!IS_BLANK_CH(RAW)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t   \"attributes construct error\\n\");\n\t    break;\n\t}\n\tSKIP_BLANKS;\n        if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&\n            (attname == NULL) && (attvalue == NULL)) {\n\t    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t         \"xmlParseStartTag: problem parsing attributes\\n\");\n\t    break;\n\t}\n        GROW;\n\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n\t    goto base_changed;\n    }\n\n    /*\n     * The attributes defaulting\n     */\n    if (ctxt->attsDefault != NULL) {\n        xmlDefAttrsPtr defaults;\n\n\tdefaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n\tif (defaults != NULL) {\n\t    for (i = 0;i < defaults->nbAttrs;i++) {\n\t        attname = defaults->values[5 * i];\n\t\taprefix = defaults->values[5 * i + 1];\n\n                /*\n\t\t * special work for namespaces defaulted defs\n\t\t */\n\t\tif ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {\n\t\t    /*\n\t\t     * check that it's not a defined namespace\n\t\t     */\n\t\t    for (j = 1;j <= nbNs;j++)\n\t\t        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)\n\t\t\t    break;\n\t            if (j <= nbNs) continue;\n\n\t\t    nsname = xmlGetNamespace(ctxt, NULL);\n\t\t    if (nsname != defaults->values[5 * i + 2]) {\n\t\t\tif (nsPush(ctxt, NULL,\n\t\t\t           defaults->values[5 * i + 2]) > 0)\n\t\t\t    nbNs++;\n\t\t    }\n\t\t} else if (aprefix == ctxt->str_xmlns) {\n\t\t    /*\n\t\t     * check that it's not a defined namespace\n\t\t     */\n\t\t    for (j = 1;j <= nbNs;j++)\n\t\t        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)\n\t\t\t    break;\n\t            if (j <= nbNs) continue;\n\n\t\t    nsname = xmlGetNamespace(ctxt, attname);\n\t\t    if (nsname != defaults->values[2]) {\n\t\t\tif (nsPush(ctxt, attname,\n\t\t\t           defaults->values[5 * i + 2]) > 0)\n\t\t\t    nbNs++;\n\t\t    }\n\t\t} else {\n\t\t    /*\n\t\t     * check that it's not a defined attribute\n\t\t     */\n\t\t    for (j = 0;j < nbatts;j+=5) {\n\t\t\tif ((attname == atts[j]) && (aprefix == atts[j+1]))\n\t\t\t    break;\n\t\t    }\n\t\t    if (j < nbatts) continue;\n\n\t\t    if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n\t\t\tif (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n\t\t\t    return(NULL);\n\t\t\t}\n\t\t\tmaxatts = ctxt->maxatts;\n\t\t\tatts = ctxt->atts;\n\t\t    }\n\t\t    atts[nbatts++] = attname;\n\t\t    atts[nbatts++] = aprefix;\n\t\t    if (aprefix == NULL)\n\t\t\tatts[nbatts++] = NULL;\n\t\t    else\n\t\t        atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);\n\t\t    atts[nbatts++] = defaults->values[5 * i + 2];\n\t\t    atts[nbatts++] = defaults->values[5 * i + 3];\n\t\t    if ((ctxt->standalone == 1) &&\n\t\t        (defaults->values[5 * i + 4] != NULL)) {\n\t\t\txmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n\t  \"standalone: attribute %s on %s defaulted from external subset\\n\",\n\t                                 attname, localname);\n\t\t    }\n\t\t    nbdef++;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * The attributes checkings\n     */\n    for (i = 0; i < nbatts;i += 5) {\n        /*\n\t* The default namespace does not apply to attribute names.\n\t*/\n\tif (atts[i + 1] != NULL) {\n\t    nsname = xmlGetNamespace(ctxt, atts[i + 1]);\n\t    if (nsname == NULL) {\n\t\txmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n\t\t    \"Namespace prefix %s for %s on %s is not defined\\n\",\n\t\t    atts[i + 1], atts[i], localname);\n\t    }\n\t    atts[i + 2] = nsname;\n\t} else\n\t    nsname = NULL;\n\t/*\n\t * [ WFC: Unique Att Spec ]\n\t * No attribute name may appear more than once in the same\n\t * start-tag or empty-element tag.\n\t * As extended by the Namespace in XML REC.\n\t */\n        for (j = 0; j < i;j += 5) {\n\t    if (atts[i] == atts[j]) {\n\t        if (atts[i+1] == atts[j+1]) {\n\t\t    xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);\n\t\t    break;\n\t\t}\n\t\tif ((nsname != NULL) && (atts[j + 2] == nsname)) {\n\t\t    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,\n\t\t\t     \"Namespaced Attribute %s in '%s' redefined\\n\",\n\t\t\t     atts[i], nsname, NULL);\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    nsname = xmlGetNamespace(ctxt, prefix);\n    if ((prefix != NULL) && (nsname == NULL)) {\n\txmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n\t         \"Namespace prefix %s on %s is not defined\\n\",\n\t\t prefix, localname, NULL);\n    }\n    *pref = prefix;\n    *URI = nsname;\n\n    /*\n     * SAX: Start of Element !\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&\n\t(!ctxt->disableSAX)) {\n\tif (nbNs > 0)\n\t    ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n\t\t\t  nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs],\n\t\t\t  nbatts / 5, nbdef, atts);\n\telse\n\t    ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n\t                  nsname, 0, NULL, nbatts / 5, nbdef, atts);\n    }\n\n    /*\n     * Free up attribute allocated strings if needed\n     */\n    if (attval != 0) {\n\tfor (i = 3,j = 0; j < nratts;i += 5,j++)\n\t    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))\n\t        xmlFree((xmlChar *) atts[i]);\n    }\n\n    return(localname);\n\nbase_changed:\n    /*\n     * the attribute strings are valid iif the base didn't changed\n     */\n    if (attval != 0) {\n\tfor (i = 3,j = 0; j < nratts;i += 5,j++)\n\t    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))\n\t        xmlFree((xmlChar *) atts[i]);\n    }\n\n    /*\n     * We can't switch from one entity to another in the middle\n     * of a start tag\n     */\n    if (inputNr != ctxt->inputNr) {\n        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t    \"Start tag doesn't start and stop in the same entity\\n\");\n\treturn(NULL);\n    }\n\n    ctxt->input->cur = ctxt->input->base + cur;\n    ctxt->input->line = oldline;\n    ctxt->input->col = oldcol;\n    if (ctxt->wellFormed == 1) {\n\tgoto reparse;\n    }\n    return(NULL);\n}",
  "diff_func": "@@ -9488,7 +9488,10 @@ xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,\n \t\telse\n \t\t    if (nsPush(ctxt, NULL, URL) > 0) nbNs++;\n skip_default_ns:\n-\t\tif (alloc != 0) xmlFree(attvalue);\n+\t\tif ((attvalue != NULL) && (alloc != 0)) {\n+\t\t    xmlFree(attvalue);\n+\t\t    attvalue = NULL;\n+\t\t}\n \t\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n \t\t    break;\n \t\tif (!IS_BLANK_CH(RAW)) {\n@@ -9497,6 +9500,8 @@ xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,\n \t\t    break;\n \t\t}\n \t\tSKIP_BLANKS;\n+\t\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n+\t\t    goto base_changed;\n \t\tcontinue;\n \t    }\n             if (aprefix == ctxt->str_xmlns) {\n@@ -9568,7 +9573,10 @@ xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,\n \t\telse\n \t\t    if (nsPush(ctxt, attname, URL) > 0) nbNs++;\n skip_ns:\n-\t\tif (alloc != 0) xmlFree(attvalue);\n+\t\tif ((attvalue != NULL) && (alloc != 0)) {\n+\t\t    xmlFree(attvalue);\n+\t\t    attvalue = NULL;\n+\t\t}\n \t\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n \t\t    break;\n \t\tif (!IS_BLANK_CH(RAW)) {",
  "func": "xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,\n                  const xmlChar **URI, int *tlen) {\n    const xmlChar *localname;\n    const xmlChar *prefix;\n    const xmlChar *attname;\n    const xmlChar *aprefix;\n    const xmlChar *nsname;\n    xmlChar *attvalue;\n    const xmlChar **atts = ctxt->atts;\n    int maxatts = ctxt->maxatts;\n    int nratts, nbatts, nbdef;\n    int i, j, nbNs, attval, oldline, oldcol, inputNr;\n    const xmlChar *base;\n    unsigned long cur;\n    int nsNr = ctxt->nsNr;\n\n    if (RAW != '<') return(NULL);\n    NEXT1;\n\n    /*\n     * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that\n     *       point since the attribute values may be stored as pointers to\n     *       the buffer and calling SHRINK would destroy them !\n     *       The Shrinking is only possible once the full set of attribute\n     *       callbacks have been done.\n     */\nreparse:\n    SHRINK;\n    base = ctxt->input->base;\n    cur = ctxt->input->cur - ctxt->input->base;\n    inputNr = ctxt->inputNr;\n    oldline = ctxt->input->line;\n    oldcol = ctxt->input->col;\n    nbatts = 0;\n    nratts = 0;\n    nbdef = 0;\n    nbNs = 0;\n    attval = 0;\n    /* Forget any namespaces added during an earlier parse of this element. */\n    ctxt->nsNr = nsNr;\n\n    localname = xmlParseQName(ctxt, &prefix);\n    if (localname == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"StartTag: invalid element name\\n\");\n        return(NULL);\n    }\n    *tlen = ctxt->input->cur - ctxt->input->base - cur;\n\n    /*\n     * Now parse the attributes, it ends up with the ending\n     *\n     * (S Attribute)* S?\n     */\n    SKIP_BLANKS;\n    GROW;\n    if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n        goto base_changed;\n\n    while (((RAW != '>') &&\n\t   ((RAW != '/') || (NXT(1) != '>')) &&\n\t   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {\n\tconst xmlChar *q = CUR_PTR;\n\tunsigned int cons = ctxt->input->consumed;\n\tint len = -1, alloc = 0;\n\n\tattname = xmlParseAttribute2(ctxt, prefix, localname,\n\t                             &aprefix, &attvalue, &len, &alloc);\n\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) {\n\t    if ((attvalue != NULL) && (alloc != 0))\n\t        xmlFree(attvalue);\n\t    attvalue = NULL;\n\t    goto base_changed;\n\t}\n        if ((attname != NULL) && (attvalue != NULL)) {\n\t    if (len < 0) len = xmlStrlen(attvalue);\n            if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {\n\t        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);\n\t\txmlURIPtr uri;\n\n                if (URL == NULL) {\n\t\t    xmlErrMemory(ctxt, \"dictionary allocation failure\");\n\t\t    if ((attvalue != NULL) && (alloc != 0))\n\t\t\txmlFree(attvalue);\n\t\t    return(NULL);\n\t\t}\n                if (*URL != 0) {\n\t\t    uri = xmlParseURI((const char *) URL);\n\t\t    if (uri == NULL) {\n\t\t\txmlNsErr(ctxt, XML_WAR_NS_URI,\n\t\t\t         \"xmlns: '%s' is not a valid URI\\n\",\n\t\t\t\t\t   URL, NULL, NULL);\n\t\t    } else {\n\t\t\tif (uri->scheme == NULL) {\n\t\t\t    xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,\n\t\t\t\t      \"xmlns: URI %s is not absolute\\n\",\n\t\t\t\t      URL, NULL, NULL);\n\t\t\t}\n\t\t\txmlFreeURI(uri);\n\t\t    }\n\t\t    if (URL == ctxt->str_xml_ns) {\n\t\t\tif (attname != ctxt->str_xml) {\n\t\t\t    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t \"xml namespace URI cannot be the default namespace\\n\",\n\t\t\t\t     NULL, NULL, NULL);\n\t\t\t}\n\t\t\tgoto skip_default_ns;\n\t\t    }\n\t\t    if ((len == 29) &&\n\t\t\t(xmlStrEqual(URL,\n\t\t\t\t BAD_CAST \"http://www.w3.org/2000/xmlns/\"))) {\n\t\t\txmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t     \"reuse of the xmlns namespace name is forbidden\\n\",\n\t\t\t\t NULL, NULL, NULL);\n\t\t\tgoto skip_default_ns;\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * check that it's not a defined namespace\n\t\t */\n\t\tfor (j = 1;j <= nbNs;j++)\n\t\t    if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)\n\t\t\tbreak;\n\t\tif (j <= nbNs)\n\t\t    xmlErrAttributeDup(ctxt, NULL, attname);\n\t\telse\n\t\t    if (nsPush(ctxt, NULL, URL) > 0) nbNs++;\nskip_default_ns:\n\t\tif (alloc != 0) xmlFree(attvalue);\n\t\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n\t\t    break;\n\t\tif (!IS_BLANK_CH(RAW)) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t\t   \"attributes construct error\\n\");\n\t\t    break;\n\t\t}\n\t\tSKIP_BLANKS;\n\t\tcontinue;\n\t    }\n            if (aprefix == ctxt->str_xmlns) {\n\t        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);\n\t\txmlURIPtr uri;\n\n                if (attname == ctxt->str_xml) {\n\t\t    if (URL != ctxt->str_xml_ns) {\n\t\t        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t         \"xml namespace prefix mapped to wrong URI\\n\",\n\t\t\t         NULL, NULL, NULL);\n\t\t    }\n\t\t    /*\n\t\t     * Do not keep a namespace definition node\n\t\t     */\n\t\t    goto skip_ns;\n\t\t}\n                if (URL == ctxt->str_xml_ns) {\n\t\t    if (attname != ctxt->str_xml) {\n\t\t        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t         \"xml namespace URI mapped to wrong prefix\\n\",\n\t\t\t         NULL, NULL, NULL);\n\t\t    }\n\t\t    goto skip_ns;\n\t\t}\n                if (attname == ctxt->str_xmlns) {\n\t\t    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t     \"redefinition of the xmlns prefix is forbidden\\n\",\n\t\t\t     NULL, NULL, NULL);\n\t\t    goto skip_ns;\n\t\t}\n\t\tif ((len == 29) &&\n\t\t    (xmlStrEqual(URL,\n\t\t                 BAD_CAST \"http://www.w3.org/2000/xmlns/\"))) {\n\t\t    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t\t     \"reuse of the xmlns namespace name is forbidden\\n\",\n\t\t\t     NULL, NULL, NULL);\n\t\t    goto skip_ns;\n\t\t}\n\t\tif ((URL == NULL) || (URL[0] == 0)) {\n\t\t    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,\n\t\t             \"xmlns:%s: Empty XML namespace is not allowed\\n\",\n\t\t\t          attname, NULL, NULL);\n\t\t    goto skip_ns;\n\t\t} else {\n\t\t    uri = xmlParseURI((const char *) URL);\n\t\t    if (uri == NULL) {\n\t\t\txmlNsErr(ctxt, XML_WAR_NS_URI,\n\t\t\t     \"xmlns:%s: '%s' is not a valid URI\\n\",\n\t\t\t\t\t   attname, URL, NULL);\n\t\t    } else {\n\t\t\tif ((ctxt->pedantic) && (uri->scheme == NULL)) {\n\t\t\t    xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,\n\t\t\t\t      \"xmlns:%s: URI %s is not absolute\\n\",\n\t\t\t\t      attname, URL, NULL);\n\t\t\t}\n\t\t\txmlFreeURI(uri);\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * check that it's not a defined namespace\n\t\t */\n\t\tfor (j = 1;j <= nbNs;j++)\n\t\t    if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)\n\t\t\tbreak;\n\t\tif (j <= nbNs)\n\t\t    xmlErrAttributeDup(ctxt, aprefix, attname);\n\t\telse\n\t\t    if (nsPush(ctxt, attname, URL) > 0) nbNs++;\nskip_ns:\n\t\tif (alloc != 0) xmlFree(attvalue);\n\t\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n\t\t    break;\n\t\tif (!IS_BLANK_CH(RAW)) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t\t   \"attributes construct error\\n\");\n\t\t    break;\n\t\t}\n\t\tSKIP_BLANKS;\n\t\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n\t\t    goto base_changed;\n\t\tcontinue;\n\t    }\n\n\t    /*\n\t     * Add the pair to atts\n\t     */\n\t    if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n\t        if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n\t\t    if (attvalue[len] == 0)\n\t\t\txmlFree(attvalue);\n\t\t    goto failed;\n\t\t}\n\t        maxatts = ctxt->maxatts;\n\t\tatts = ctxt->atts;\n\t    }\n\t    ctxt->attallocs[nratts++] = alloc;\n\t    atts[nbatts++] = attname;\n\t    atts[nbatts++] = aprefix;\n\t    atts[nbatts++] = NULL; /* the URI will be fetched later */\n\t    atts[nbatts++] = attvalue;\n\t    attvalue += len;\n\t    atts[nbatts++] = attvalue;\n\t    /*\n\t     * tag if some deallocation is needed\n\t     */\n\t    if (alloc != 0) attval = 1;\n\t} else {\n\t    if ((attvalue != NULL) && (attvalue[len] == 0))\n\t\txmlFree(attvalue);\n\t}\n\nfailed:\n\n\tGROW\n        if (ctxt->instate == XML_PARSER_EOF)\n            break;\n\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n\t    goto base_changed;\n\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n\t    break;\n\tif (!IS_BLANK_CH(RAW)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t   \"attributes construct error\\n\");\n\t    break;\n\t}\n\tSKIP_BLANKS;\n        if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&\n            (attname == NULL) && (attvalue == NULL)) {\n\t    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t         \"xmlParseStartTag: problem parsing attributes\\n\");\n\t    break;\n\t}\n        GROW;\n\tif ((ctxt->input->base != base) || (inputNr != ctxt->inputNr))\n\t    goto base_changed;\n    }\n\n    /*\n     * The attributes defaulting\n     */\n    if (ctxt->attsDefault != NULL) {\n        xmlDefAttrsPtr defaults;\n\n\tdefaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n\tif (defaults != NULL) {\n\t    for (i = 0;i < defaults->nbAttrs;i++) {\n\t        attname = defaults->values[5 * i];\n\t\taprefix = defaults->values[5 * i + 1];\n\n                /*\n\t\t * special work for namespaces defaulted defs\n\t\t */\n\t\tif ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {\n\t\t    /*\n\t\t     * check that it's not a defined namespace\n\t\t     */\n\t\t    for (j = 1;j <= nbNs;j++)\n\t\t        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)\n\t\t\t    break;\n\t            if (j <= nbNs) continue;\n\n\t\t    nsname = xmlGetNamespace(ctxt, NULL);\n\t\t    if (nsname != defaults->values[5 * i + 2]) {\n\t\t\tif (nsPush(ctxt, NULL,\n\t\t\t           defaults->values[5 * i + 2]) > 0)\n\t\t\t    nbNs++;\n\t\t    }\n\t\t} else if (aprefix == ctxt->str_xmlns) {\n\t\t    /*\n\t\t     * check that it's not a defined namespace\n\t\t     */\n\t\t    for (j = 1;j <= nbNs;j++)\n\t\t        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)\n\t\t\t    break;\n\t            if (j <= nbNs) continue;\n\n\t\t    nsname = xmlGetNamespace(ctxt, attname);\n\t\t    if (nsname != defaults->values[2]) {\n\t\t\tif (nsPush(ctxt, attname,\n\t\t\t           defaults->values[5 * i + 2]) > 0)\n\t\t\t    nbNs++;\n\t\t    }\n\t\t} else {\n\t\t    /*\n\t\t     * check that it's not a defined attribute\n\t\t     */\n\t\t    for (j = 0;j < nbatts;j+=5) {\n\t\t\tif ((attname == atts[j]) && (aprefix == atts[j+1]))\n\t\t\t    break;\n\t\t    }\n\t\t    if (j < nbatts) continue;\n\n\t\t    if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n\t\t\tif (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n\t\t\t    return(NULL);\n\t\t\t}\n\t\t\tmaxatts = ctxt->maxatts;\n\t\t\tatts = ctxt->atts;\n\t\t    }\n\t\t    atts[nbatts++] = attname;\n\t\t    atts[nbatts++] = aprefix;\n\t\t    if (aprefix == NULL)\n\t\t\tatts[nbatts++] = NULL;\n\t\t    else\n\t\t        atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);\n\t\t    atts[nbatts++] = defaults->values[5 * i + 2];\n\t\t    atts[nbatts++] = defaults->values[5 * i + 3];\n\t\t    if ((ctxt->standalone == 1) &&\n\t\t        (defaults->values[5 * i + 4] != NULL)) {\n\t\t\txmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n\t  \"standalone: attribute %s on %s defaulted from external subset\\n\",\n\t                                 attname, localname);\n\t\t    }\n\t\t    nbdef++;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * The attributes checkings\n     */\n    for (i = 0; i < nbatts;i += 5) {\n        /*\n\t* The default namespace does not apply to attribute names.\n\t*/\n\tif (atts[i + 1] != NULL) {\n\t    nsname = xmlGetNamespace(ctxt, atts[i + 1]);\n\t    if (nsname == NULL) {\n\t\txmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n\t\t    \"Namespace prefix %s for %s on %s is not defined\\n\",\n\t\t    atts[i + 1], atts[i], localname);\n\t    }\n\t    atts[i + 2] = nsname;\n\t} else\n\t    nsname = NULL;\n\t/*\n\t * [ WFC: Unique Att Spec ]\n\t * No attribute name may appear more than once in the same\n\t * start-tag or empty-element tag.\n\t * As extended by the Namespace in XML REC.\n\t */\n        for (j = 0; j < i;j += 5) {\n\t    if (atts[i] == atts[j]) {\n\t        if (atts[i+1] == atts[j+1]) {\n\t\t    xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);\n\t\t    break;\n\t\t}\n\t\tif ((nsname != NULL) && (atts[j + 2] == nsname)) {\n\t\t    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,\n\t\t\t     \"Namespaced Attribute %s in '%s' redefined\\n\",\n\t\t\t     atts[i], nsname, NULL);\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    nsname = xmlGetNamespace(ctxt, prefix);\n    if ((prefix != NULL) && (nsname == NULL)) {\n\txmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n\t         \"Namespace prefix %s on %s is not defined\\n\",\n\t\t prefix, localname, NULL);\n    }\n    *pref = prefix;\n    *URI = nsname;\n\n    /*\n     * SAX: Start of Element !\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&\n\t(!ctxt->disableSAX)) {\n\tif (nbNs > 0)\n\t    ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n\t\t\t  nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs],\n\t\t\t  nbatts / 5, nbdef, atts);\n\telse\n\t    ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n\t                  nsname, 0, NULL, nbatts / 5, nbdef, atts);\n    }\n\n    /*\n     * Free up attribute allocated strings if needed\n     */\n    if (attval != 0) {\n\tfor (i = 3,j = 0; j < nratts;i += 5,j++)\n\t    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))\n\t        xmlFree((xmlChar *) atts[i]);\n    }\n\n    return(localname);\n\nbase_changed:\n    /*\n     * the attribute strings are valid iif the base didn't changed\n     */\n    if (attval != 0) {\n\tfor (i = 3,j = 0; j < nratts;i += 5,j++)\n\t    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))\n\t        xmlFree((xmlChar *) atts[i]);\n    }\n\n    /*\n     * We can't switch from one entity to another in the middle\n     * of a start tag\n     */\n    if (inputNr != ctxt->inputNr) {\n        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t    \"Start tag doesn't start and stop in the same entity\\n\");\n\treturn(NULL);\n    }\n\n    ctxt->input->cur = ctxt->input->base + cur;\n    ctxt->input->line = oldline;\n    ctxt->input->col = oldcol;\n    if (ctxt->wellFormed == 1) {\n\tgoto reparse;\n    }\n    return(NULL);\n}",
  "project": "libxml2",
  "hash": 222205143045940612724836722883651844635,
  "size": 459,
  "commit_id": "38eae571111db3b43ffdeb05487c9f60551906fb",
  "message": "Heap use-after-free in xmlSAX2AttributeNs\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=759020\n\n* parser.c:\n(xmlParseStartTag2): Attribute strings are only valid if the\nbase does not change, so add another check where the base may\nchange.  Make sure to set 'attvalue' to NULL after freeing it.\n* result/errors/759020.xml: Added.\n* result/errors/759020.xml.err: Added.\n* result/errors/759020.xml.str: Added.\n* test/errors/759020.xml: Added test case.",
  "target": 1,
  "dataset": "other",
  "idx": 210378,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a heap use-after-free vulnerability by properly freeing memory and adding checks to prevent stale pointer usage. This directly mitigates a security risk.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}