{
  "id": 307,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/malvira/lpc31xx/commit/64f3b9e203bd06855072e295557dca1485a2ecba",
  "commit_sha": "64f3b9e203bd06855072e295557dca1485a2ecba",
  "commit_msg": "net: ip_expire() must revalidate route\n\nCommit 4a94445c9a5c (net: Use ip_route_input_noref() in input path)\nadded a bug in IP defragmentation handling, in case timeout is fired.\n\nWhen a frame is defragmented, we use last skb dst field when building\nfinal skb. Its dst is valid, since we are in rcu read section.\n\nBut if a timeout occurs, we take first queued fragment to build one ICMP\nTIME EXCEEDED message. Problem is all queued skb have weak dst pointers,\nsince we escaped RCU critical section after their queueing. icmp_send()\nmight dereference a now freed (and possibly reused) part of memory.\n\nCalling skb_dst_drop() and ip_route_input_noref() to revalidate route is\nthe only possible choice.\n\nReported-by: Denys Fedoryshchenko <denys@visp.net.lb>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/ipv4/ip_fragment.c",
  "func_name": "",
  "raw_func_from_json": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\n\tspin_lock(&qp->q.lock);\n\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tipq_kill(qp);\n\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n \n \tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n \t\tstruct sk_buff *head = qp->q.fragments;\n \n \t\trcu_read_lock();\n \t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n \t\tif (!head->dev)\n \t\t\tgoto out_rcu_unlock;\n \n \t\t/*\n\t\t * Only search router table for the head fragment,\n\t\t * when defraging timeout at PRE_ROUTING HOOK.\n \t\t */\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\t/*\n\t\t\t * Only an end host needs to send an ICMP\n\t\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n\t\t\t */\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n \n\t\t}\n \n \t\t/* Send an ICMP \"Fragment Reassembly Timeout\" message. */\n \t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}\n",
  "diff_func": "@@ -223,31 +223,30 @@ static void ip_expire(unsigned long arg)\n \n \tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n \t\tstruct sk_buff *head = qp->q.fragments;\n+\t\tconst struct iphdr *iph;\n+\t\tint err;\n \n \t\trcu_read_lock();\n \t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n \t\tif (!head->dev)\n \t\t\tgoto out_rcu_unlock;\n \n+\t\t/* skb dst is stale, drop it, and perform route lookup again */\n+\t\tskb_dst_drop(head);\n+\t\tiph = ip_hdr(head);\n+\t\terr = ip_route_input_noref(head, iph->daddr, iph->saddr,\n+\t\t\t\t\t   iph->tos, head->dev);\n+\t\tif (err)\n+\t\t\tgoto out_rcu_unlock;\n+\n \t\t/*\n-\t\t * Only search router table for the head fragment,\n-\t\t * when defraging timeout at PRE_ROUTING HOOK.\n+\t\t * Only an end host needs to send an ICMP\n+\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n \t\t */\n-\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n-\t\t\tconst struct iphdr *iph = ip_hdr(head);\n-\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n-\t\t\t\t\t\t iph->tos, head->dev);\n-\t\t\tif (unlikely(err))\n-\t\t\t\tgoto out_rcu_unlock;\n-\n-\t\t\t/*\n-\t\t\t * Only an end host needs to send an ICMP\n-\t\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n-\t\t\t */\n-\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n-\t\t\t\tgoto out_rcu_unlock;\n+\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN &&\n+\t\t    skb_rtable(head)->rt_type != RTN_LOCAL)\n+\t\t\tgoto out_rcu_unlock;\n \n-\t\t}\n \n \t\t/* Send an ICMP \"Fragment Reassembly Timeout\" message. */\n \t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);",
  "project": "linux",
  "commit_id": "64f3b9e203bd06855072e295557dca1485a2ecba",
  "target": 1,
  "func": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\n\tspin_lock(&qp->q.lock);\n\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tipq_kill(qp);\n\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n \n \tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n \t\tstruct sk_buff *head = qp->q.fragments;\n \n \t\trcu_read_lock();\n \t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n \t\tif (!head->dev)\n \t\t\tgoto out_rcu_unlock;\n \n \t\t/*\n\t\t * Only search router table for the head fragment,\n\t\t * when defraging timeout at PRE_ROUTING HOOK.\n \t\t */\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\t/*\n\t\t\t * Only an end host needs to send an ICMP\n\t\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n\t\t\t */\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n \n\t\t}\n \n \t\t/* Send an ICMP \"Fragment Reassembly Timeout\" message. */\n \t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}\n",
  "big_vul_idx": 179045,
  "idx": 855,
  "hash": 133776853164301156762765270288111357500,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability in IP defragmentation by fixing a memory access issue that could lead to crashes or exploitation. The code revalidates the route to prevent accessing stale pointers.\n\n**Final Output:**\nAnalysis: The patch fixes a security issue where accessing stale memory could cause system instability or exploitation. It ensures proper route revalidation to prevent such accesses.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}