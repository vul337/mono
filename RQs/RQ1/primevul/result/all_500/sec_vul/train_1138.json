{
  "id": 1138,
  "language": "c",
  "cwe": "CWE-125",
  "commit_url": "https://github.com/SubiU/libevent/commit/96f64a022014a208105ead6c8a7066018449d86d",
  "commit_sha": "96f64a022014a208105ead6c8a7066018449d86d",
  "commit_msg": "evdns: name_parse(): fix remote stack overread\n\n@asn-the-goblin-slayer:\n  \"the name_parse() function in libevent's DNS code is vulnerable to a buffer overread.\n\n   971         if (cp != name_out) {\n   972             if (cp + 1 >= end) return -1;\n   973             *cp++ = '.';\n   974         }\n   975         if (cp + label_len >= end) return -1;\n   976         memcpy(cp, packet + j, label_len);\n   977         cp += label_len;\n   978         j += label_len;\n   No check is made against length before the memcpy occurs.\n\n   This was found through the Tor bug bounty program and the discovery should be credited to 'Guido Vranken'.\"\n\nReproducer for gdb (https://gist.github.com/azat/e4fcf540e9b89ab86d02):\n  set $PROT_NONE=0x0\n  set $PROT_READ=0x1\n  set $PROT_WRITE=0x2\n  set $MAP_ANONYMOUS=0x20\n  set $MAP_SHARED=0x01\n  set $MAP_FIXED=0x10\n  set $MAP_32BIT=0x40\n\n  start\n\n  set $length=202\n  # overread\n  set $length=2\n  # allocate with mmap to have a seg fault on page boundary\n  set $l=(1<<20)*2\n  p mmap(0, $l, $PROT_READ|$PROT_WRITE, $MAP_ANONYMOUS|$MAP_SHARED|$MAP_32BIT, -1, 0)\n  set $packet=(char *)$1+$l-$length\n  # hack the packet\n  set $packet[0]=63\n  set $packet[1]='/'\n\n  p malloc(sizeof(int))\n  set $idx=(int *)$2\n  set $idx[0]=0\n  set $name_out_len=202\n\n  p malloc($name_out_len)\n  set $name_out=$3\n\n  # have WRITE only mapping to fail on read\n  set $end=$1+$l\n  p (void *)mmap($end, 1<<12, $PROT_NONE, $MAP_ANONYMOUS|$MAP_SHARED|$MAP_FIXED|$MAP_32BIT, -1, 0)\n  set $m=$4\n\n  p name_parse($packet, $length, $idx, $name_out, $name_out_len)\n  x/2s (char *)$name_out\n\nBefore this patch:\n$ gdb -ex 'source gdb' dns-example\n$1 = 1073741824\n$2 = (void *) 0x633010\n$3 = (void *) 0x633030\n$4 = (void *) 0x40200000\n\nProgram received signal SIGSEGV, Segmentation fault.\n__memcpy_sse2_unaligned () at memcpy-sse2-unaligned.S:33\n\nAfter this patch:\n$ gdb -ex 'source gdb' dns-example\n$1 = 1073741824\n$2 = (void *) 0x633010\n$3 = (void *) 0x633030\n$4 = (void *) 0x40200000\n$5 = -1\n0x633030:       \"/\"\n0x633032:       \"\"\n(gdb) p $m\n$6 = (void *) 0x40200000\n(gdb) p $1\n$7 = 1073741824\n(gdb) p/x $1\n$8 = 0x40000000\n(gdb) quit\n\nP.S. plus drop one condition duplicate.\n\nFixes: #317",
  "pr_url": null,
  "pr_info": null,
  "file_name": "evdns.c",
  "func_name": "",
  "raw_func_from_json": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\n\t/* Normally, names are a series of length prefixed strings terminated */\n\t/* with a length of 0 (the lengths are u8's < 63). */\n\t/* However, the length can start with a pair of 1 bits and that */\n\t/* means that the next 14 bits are a pointer within the current */\n\t/* packet. */\n \n \tfor (;;) {\n \t\tu8 label_len;\n\t\tif (j >= length) return -1;\n \t\tGET8(label_len);\n \t\tif (!label_len) break;\n \t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\t/* Make sure that the target offset is in-bounds. */\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\t/* If we've jumped more times than there are characters in the\n\t\t\t * message, we must have a loop. */\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n \t\t\t*cp++ = '.';\n \t\t}\n \t\tif (cp + label_len >= end) return -1;\n \t\tmemcpy(cp, packet + j, label_len);\n \t\tcp += label_len;\n \t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}\n",
  "diff_func": "@@ -976,7 +976,6 @@ name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n \n \tfor (;;) {\n \t\tu8 label_len;\n-\t\tif (j >= length) return -1;\n \t\tGET8(label_len);\n \t\tif (!label_len) break;\n \t\tif (label_len & 0xc0) {\n@@ -997,6 +996,7 @@ name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n \t\t\t*cp++ = '.';\n \t\t}\n \t\tif (cp + label_len >= end) return -1;\n+\t\tif (j + label_len > length) return -1;\n \t\tmemcpy(cp, packet + j, label_len);\n \t\tcp += label_len;\n \t\tj += label_len;",
  "project": "libevent",
  "commit_id": "96f64a022014a208105ead6c8a7066018449d86d",
  "target": 1,
  "func": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\n\t/* Normally, names are a series of length prefixed strings terminated */\n\t/* with a length of 0 (the lengths are u8's < 63). */\n\t/* However, the length can start with a pair of 1 bits and that */\n\t/* means that the next 14 bits are a pointer within the current */\n\t/* packet. */\n \n \tfor (;;) {\n \t\tu8 label_len;\n\t\tif (j >= length) return -1;\n \t\tGET8(label_len);\n \t\tif (!label_len) break;\n \t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\t/* Make sure that the target offset is in-bounds. */\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\t/* If we've jumped more times than there are characters in the\n\t\t\t * message, we must have a loop. */\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n \t\t\t*cp++ = '.';\n \t\t}\n \t\tif (cp + label_len >= end) return -1;\n \t\tmemcpy(cp, packet + j, label_len);\n \t\tcp += label_len;\n \t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}\n",
  "big_vul_idx": 181665,
  "idx": 3091,
  "hash": 116803398451156561056178042928543918371,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a buffer overread vulnerability in the `name_parse()` function by adding a bounds check before a `memcpy` operation, preventing unauthorized data access and potential system compromise.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}