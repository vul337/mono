{
  "id": 781,
  "language": "h",
  "cwe": "",
  "commit_url": "https://github.com/cmshing/nodejs/commit/78b0e30954111cfaba0edbeee85450d8cbc6fdf6",
  "commit_sha": "78b0e30954111cfaba0edbeee85450d8cbc6fdf6",
  "commit_msg": "deps: fix out-of-band write in utf8 decoder\n\nOriginally reported by: Kris Reeves <kris.re@bbhmedia.com>\n\nReviewed-By: Trevor Norris <trev.norris@gmail.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "deps/v8/src/unicode-inl.h",
  "func_name": "",
  "raw_func_from_json": "void Utf8DecoderBase::WriteUtf16Slow(const uint8_t* stream,\n                                     uint16_t* data,\n                                     unsigned data_length) {\n  while (data_length != 0) {\n    unsigned cursor = 0;\n    uint32_t character = Utf8::ValueOf(stream, Utf8::kMaxEncodedSize, &cursor);\n    // There's a total lack of bounds checking for stream\n    // as it was already done in Reset.\n    stream += cursor;\n    if (character > unibrow::Utf16::kMaxNonSurrogateCharCode) {\n      *data++ = Utf16::LeadSurrogate(character);\n      *data++ = Utf16::TrailSurrogate(character);\n      DCHECK(data_length > 1);\n      data_length -= 2;\n    } else {\n      *data++ = character;\n      data_length -= 1;\n    }\n  }\n}",
  "diff_func": "@@ -155,6 +155,7 @@ unsigned Utf8::Length(uchar c, int previous) {\n \n Utf8DecoderBase::Utf8DecoderBase()\n   : unbuffered_start_(NULL),\n+    unbuffered_length_(0),\n     utf16_length_(0),\n     last_byte_of_buffer_unused_(false) {}\n \n@@ -194,8 +195,7 @@ unsigned Utf8Decoder<kBufferSize>::WriteUtf16(uint16_t* data,\n   if (length <= buffer_length) return length;\n   DCHECK(unbuffered_start_ != NULL);\n   // Copy the rest the slow way.\n-  WriteUtf16Slow(unbuffered_start_,\n-                 data + buffer_length,\n+  WriteUtf16Slow(unbuffered_start_, unbuffered_length_, data + buffer_length,\n                  length - buffer_length);\n   return length;\n }",
  "func": "void Utf8DecoderBase::WriteUtf16Slow(const uint8_t* stream,\n                                     uint16_t* data,\n                                     unsigned data_length) {\n  while (data_length != 0) {\n    unsigned cursor = 0;\n    uint32_t character = Utf8::ValueOf(stream, Utf8::kMaxEncodedSize, &cursor);\n    // There's a total lack of bounds checking for stream\n    // as it was already done in Reset.\n    stream += cursor;\n    if (character > unibrow::Utf16::kMaxNonSurrogateCharCode) {\n      *data++ = Utf16::LeadSurrogate(character);\n      *data++ = Utf16::TrailSurrogate(character);\n      DCHECK(data_length > 1);\n      data_length -= 2;\n    } else {\n      *data++ = character;\n      data_length -= 1;\n    }\n  }\n}",
  "project": "node",
  "hash": 252347364978872387181975652701666279871,
  "size": 20,
  "commit_id": "78b0e30954111cfaba0edbeee85450d8cbc6fdf6",
  "message": "deps: fix out-of-band write in utf8 decoder\n\nOriginally reported by: Kris Reeves <kris.re@bbhmedia.com>\n\nReviewed-By: Trevor Norris <trev.norris@gmail.com>",
  "target": 1,
  "dataset": "other",
  "idx": 206709,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a buffer overflow issue in the UTF-8 decoder, which is a security vulnerability. The changes fix an out-of-band write by properly initializing a variable and adjusting function parameters to prevent buffer overflow.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}