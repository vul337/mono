{
  "id": 984,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/YASHTHAKUR879/Yashbh/commit/b8beb55913471952f92770c90c372139d78c16c0",
  "commit_sha": "b8beb55913471952f92770c90c372139d78c16c0",
  "commit_msg": "Fixed OOB read in update_read_cache_bitmap_v3_order\n\nCVE-2020-11096 thanks @antonio-morales for finding this.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libfreerdp/core/orders.c",
  "func_name": "",
  "raw_func_from_json": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}",
  "diff_func": "@@ -113,20 +113,74 @@ BYTE get_primary_drawing_order_field_bytes(UINT32 orderType, BOOL* pValid)\n \t}\n }\n \n-static const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n-\n-static const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n-\t                             0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n-\n-static const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n-\n-static const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n-\t                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n-\n-static const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };\n+static BYTE get_cbr2_bpp(UINT32 bpp, BOOL* pValid)\n+{\n+\tif (pValid)\n+\t\t*pValid = TRUE;\n+\tswitch (bpp)\n+\t{\n+\t\tcase 3:\n+\t\t\treturn 8;\n+\t\tcase 4:\n+\t\t\treturn 16;\n+\t\tcase 5:\n+\t\t\treturn 24;\n+\t\tcase 6:\n+\t\t\treturn 32;\n+\t\tdefault:\n+\t\t\tWLog_WARN(TAG, \"Invalid bpp %\" PRIu32, bpp);\n+\t\t\tif (pValid)\n+\t\t\t\t*pValid = FALSE;\n+\t\t\treturn 0;\n+\t}\n+}\n \n-static const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n-\t                            0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n+static BYTE get_bmf_bpp(UINT32 bmf, BOOL* pValid)\n+{\n+\tif (pValid)\n+\t\t*pValid = TRUE;\n+\tswitch (bmf)\n+\t{\n+\t\tcase 1:\n+\t\t\treturn 1;\n+\t\tcase 3:\n+\t\t\treturn 8;\n+\t\tcase 4:\n+\t\t\treturn 16;\n+\t\tcase 5:\n+\t\t\treturn 24;\n+\t\tcase 6:\n+\t\t\treturn 32;\n+\t\tdefault:\n+\t\t\tWLog_WARN(TAG, \"Invalid bmf %\" PRIu32, bmf);\n+\t\t\tif (pValid)\n+\t\t\t\t*pValid = FALSE;\n+\t\t\treturn 0;\n+\t}\n+}\n+static BYTE get_bpp_bmf(UINT32 bpp, BOOL* pValid)\n+{\n+\tif (pValid)\n+\t\t*pValid = TRUE;\n+\tswitch (bpp)\n+\t{\n+\t\tcase 1:\n+\t\t\treturn 1;\n+\t\tcase 8:\n+\t\t\treturn 3;\n+\t\tcase 16:\n+\t\t\treturn 4;\n+\t\tcase 24:\n+\t\t\treturn 5;\n+\t\tcase 32:\n+\t\t\treturn 6;\n+\t\tdefault:\n+\t\t\tWLog_WARN(TAG, \"Invalid color depth %\" PRIu32, bpp);\n+\t\t\tif (pValid)\n+\t\t\t\t*pValid = FALSE;\n+\t\t\treturn 0;\n+\t}\n+}\n \n static BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName,\n                                   BOOL condition)\n@@ -814,9 +868,11 @@ static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlag\n \n \tif (brush->style & CACHED_BRUSH)\n \t{\n+\t\tBOOL rc;\n \t\tbrush->index = brush->hatch;\n-\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n-\n+\t\tbrush->bpp = get_bmf_bpp(brush->style, &rc);\n+\t\tif (!rc)\n+\t\t\treturn FALSE;\n \t\tif (brush->bpp == 0)\n \t\t\tbrush->bpp = 1;\n \t}\n@@ -858,9 +914,11 @@ static INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFla\n \n \tif (brush->style & CACHED_BRUSH)\n \t{\n+\t\tBOOL rc;\n \t\tbrush->hatch = brush->index;\n-\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n-\n+\t\tbrush->bpp = get_bmf_bpp(brush->style, &rc);\n+\t\tif (!rc)\n+\t\t\treturn FALSE;\n \t\tif (brush->bpp == 0)\n \t\t\tbrush->bpp = 1;\n \t}\n@@ -2016,6 +2074,7 @@ BOOL update_write_cache_bitmap_order(wStream* s, const CACHE_BITMAP_ORDER* cache\n static CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s,\n                                                                 BOOL compressed, UINT16 flags)\n {\n+\tBOOL rc;\n \tBYTE bitsPerPixelId;\n \tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n \n@@ -2030,7 +2089,9 @@ static CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* updat\n \tcache_bitmap_v2->cacheId = flags & 0x0003;\n \tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n \tbitsPerPixelId = (flags & 0x0078) >> 3;\n-\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n+\tcache_bitmap_v2->bitmapBpp = get_cbr2_bpp(bitsPerPixelId, &rc);\n+\tif (!rc)\n+\t\tgoto fail;\n \n \tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n \t{\n@@ -2109,13 +2170,16 @@ int update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap\n BOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                         BOOL compressed, UINT16* flags)\n {\n+\tBOOL rc;\n \tBYTE bitsPerPixelId;\n \n \tif (!Stream_EnsureRemainingCapacity(\n \t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n \t\treturn FALSE;\n \n-\tbitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];\n+\tbitsPerPixelId = get_bpp_bmf(cache_bitmap_v2->bitmapBpp, &rc);\n+\tif (!rc)\n+\t\treturn FALSE;\n \t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n \t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n \n@@ -2177,6 +2241,7 @@ BOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache\n static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                 UINT16 flags)\n {\n+\tBOOL rc;\n \tBYTE bitsPerPixelId;\n \tBITMAP_DATA_EX* bitmapData;\n \tUINT32 new_len;\n@@ -2194,7 +2259,9 @@ static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* updat\n \tcache_bitmap_v3->cacheId = flags & 0x00000003;\n \tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n \tbitsPerPixelId = (flags & 0x00000078) >> 3;\n-\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n+\tcache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc);\n+\tif (!rc)\n+\t\tgoto fail;\n \n \tif (Stream_GetRemainingLength(s) < 21)\n \t\tgoto fail;\n@@ -2242,6 +2309,7 @@ int update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap\n BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                         UINT16* flags)\n {\n+\tBOOL rc;\n \tBYTE bitsPerPixelId;\n \tBITMAP_DATA_EX* bitmapData;\n \n@@ -2250,7 +2318,9 @@ BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache\n \t\treturn FALSE;\n \n \tbitmapData = &cache_bitmap_v3->bitmapData;\n-\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n+\tbitsPerPixelId = get_bpp_bmf(cache_bitmap_v3->bpp, &rc);\n+\tif (!rc)\n+\t\treturn FALSE;\n \t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n \t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n \tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n@@ -2574,6 +2644,7 @@ static BOOL update_compress_brush(wStream* s, const BYTE* input, BYTE bpp)\n static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n {\n \tint i;\n+\tBOOL rc;\n \tBYTE iBitmapFormat;\n \tBOOL compressed = FALSE;\n \tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n@@ -2587,10 +2658,10 @@ static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStre\n \tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n \tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n \n-\tif (iBitmapFormat >= ARRAYSIZE(BMF_BPP))\n+\tcache_brush->bpp = get_bmf_bpp(iBitmapFormat, &rc);\n+\tif (!rc)\n \t\tgoto fail;\n \n-\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n \tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n \tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n \tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n@@ -2661,13 +2732,16 @@ BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_b\n {\n \tint i;\n \tBYTE iBitmapFormat;\n+\tBOOL rc;\n \tBOOL compressed = FALSE;\n \n \tif (!Stream_EnsureRemainingCapacity(s,\n \t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n \t\treturn FALSE;\n \n-\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n+\tiBitmapFormat = get_bpp_bmf(cache_brush->bpp, &rc);\n+\tif (!rc)\n+\t\treturn FALSE;\n \tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n \tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n \tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */",
  "func": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}",
  "project": "FreeRDP",
  "hash": 77696160753710370793899447687850386826,
  "size": 60,
  "commit_id": "b8beb55913471952f92770c90c372139d78c16c0",
  "message": "Fixed OOB read in update_read_cache_bitmap_v3_order\n\nCVE-2020-11096 thanks @antonio-morales for finding this.",
  "target": 1,
  "dataset": "other",
  "idx": 213355,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an out-of-bounds (OOB) read vulnerability by replacing static array lookups with validation functions. These functions check input validity, preventing unauthorized memory access. The commit message references a CVE, confirming it's a security fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}