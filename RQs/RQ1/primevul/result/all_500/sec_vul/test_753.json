{
  "id": 753,
  "language": "h",
  "cwe": "",
  "commit_url": "https://github.com/myliu1999/ffmpeg/commit/61d59703c91869f4e5cdacd8d6be52f8b89d4ba4",
  "commit_sha": "61d59703c91869f4e5cdacd8d6be52f8b89d4ba4",
  "commit_msg": "avcodec/snow: split block clipping checks\n\nFixes out of array read\nFixes: d4476f68ca1c1c57afbc45806f581963-asan_heap-oob_2266b27_8607_cov_4044577381_snow_chroma_bug.avi\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libavcodec/snow.h",
  "func_name": "",
  "raw_func_from_json": "static av_always_inline void add_yblock(SnowContext *s, int sliced, slice_buffer *sb, IDWTELEM *dst, uint8_t *dst8, const uint8_t *obmc, int src_x, int src_y, int b_w, int b_h, int w, int h, int dst_stride, int src_stride, int obmc_stride, int b_x, int b_y, int add, int offset_dst, int plane_index){\n    const int b_width = s->b_width  << s->block_max_depth;\n    const int b_height= s->b_height << s->block_max_depth;\n    const int b_stride= b_width;\n    BlockNode *lt= &s->block[b_x + b_y*b_stride];\n    BlockNode *rt= lt+1;\n    BlockNode *lb= lt+b_stride;\n    BlockNode *rb= lb+1;\n    uint8_t *block[4];\n    int tmp_step= src_stride >= 7*MB_SIZE ? MB_SIZE : MB_SIZE*src_stride;\n    uint8_t *tmp = s->scratchbuf;\n    uint8_t *ptmp;\n    int x,y;\n\n    if(b_x<0){\n        lt= rt;\n        lb= rb;\n    }else if(b_x + 1 >= b_width){\n        rt= lt;\n        rb= lb;\n    }\n    if(b_y<0){\n        lt= lb;\n        rt= rb;\n    }else if(b_y + 1 >= b_height){\n        lb= lt;\n        rb= rt;\n    }\n\n    if(src_x<0){ //FIXME merge with prev & always round internal width up to *16\n        obmc -= src_x;\n        b_w += src_x;\n        if(!sliced && !offset_dst)\n            dst -= src_x;\n        src_x=0;\n    }else if(src_x + b_w > w){\n        b_w = w - src_x;\n    }\n    if(src_y<0){\n        obmc -= src_y*obmc_stride;\n        b_h += src_y;\n        if(!sliced && !offset_dst)\n            dst -= src_y*dst_stride;\n        src_y=0;\n    }else if(src_y + b_h> h){\n        b_h = h - src_y;\n    }\n\n    if(b_w<=0 || b_h<=0) return;\n\n    av_assert2(src_stride > 2*MB_SIZE + 5);\n\n    if(!sliced && offset_dst)\n        dst += src_x + src_y*dst_stride;\n    dst8+= src_x + src_y*src_stride;\n//    src += src_x + src_y*src_stride;\n\n    ptmp= tmp + 3*tmp_step;\n    block[0]= ptmp;\n    ptmp+=tmp_step;\n    ff_snow_pred_block(s, block[0], tmp, src_stride, src_x, src_y, b_w, b_h, lt, plane_index, w, h);\n\n    if(same_block(lt, rt)){\n        block[1]= block[0];\n    }else{\n        block[1]= ptmp;\n        ptmp+=tmp_step;\n        ff_snow_pred_block(s, block[1], tmp, src_stride, src_x, src_y, b_w, b_h, rt, plane_index, w, h);\n    }\n\n    if(same_block(lt, lb)){\n        block[2]= block[0];\n    }else if(same_block(rt, lb)){\n        block[2]= block[1];\n    }else{\n        block[2]= ptmp;\n        ptmp+=tmp_step;\n        ff_snow_pred_block(s, block[2], tmp, src_stride, src_x, src_y, b_w, b_h, lb, plane_index, w, h);\n    }\n\n    if(same_block(lt, rb) ){\n        block[3]= block[0];\n    }else if(same_block(rt, rb)){\n        block[3]= block[1];\n    }else if(same_block(lb, rb)){\n        block[3]= block[2];\n    }else{\n        block[3]= ptmp;\n        ff_snow_pred_block(s, block[3], tmp, src_stride, src_x, src_y, b_w, b_h, rb, plane_index, w, h);\n    }\n    if(sliced){\n        s->dwt.inner_add_yblock(obmc, obmc_stride, block, b_w, b_h, src_x,src_y, src_stride, sb, add, dst8);\n    }else{\n        for(y=0; y<b_h; y++){\n            //FIXME ugly misuse of obmc_stride\n            const uint8_t *obmc1= obmc + y*obmc_stride;\n            const uint8_t *obmc2= obmc1+ (obmc_stride>>1);\n            const uint8_t *obmc3= obmc1+ obmc_stride*(obmc_stride>>1);\n            const uint8_t *obmc4= obmc3+ (obmc_stride>>1);\n            for(x=0; x<b_w; x++){\n                int v=   obmc1[x] * block[3][x + y*src_stride]\n                        +obmc2[x] * block[2][x + y*src_stride]\n                        +obmc3[x] * block[1][x + y*src_stride]\n                        +obmc4[x] * block[0][x + y*src_stride];\n\n                v <<= 8 - LOG2_OBMC_MAX;\n                if(FRAC_BITS != 8){\n                    v >>= 8 - FRAC_BITS;\n                }\n                if(add){\n                    v += dst[x + y*dst_stride];\n                    v = (v + (1<<(FRAC_BITS-1))) >> FRAC_BITS;\n                    if(v&(~255)) v= ~(v>>31);\n                    dst8[x + y*src_stride] = v;\n                }else{\n                    dst[x + y*dst_stride] -= v;\n                }\n            }\n        }\n    }\n}",
  "diff_func": "@@ -318,7 +318,8 @@ static av_always_inline void add_yblock(SnowContext *s, int sliced, slice_buffer\n         if(!sliced && !offset_dst)\n             dst -= src_x;\n         src_x=0;\n-    }else if(src_x + b_w > w){\n+    }\n+    if(src_x + b_w > w){\n         b_w = w - src_x;\n     }\n     if(src_y<0){\n@@ -327,7 +328,8 @@ static av_always_inline void add_yblock(SnowContext *s, int sliced, slice_buffer\n         if(!sliced && !offset_dst)\n             dst -= src_y*dst_stride;\n         src_y=0;\n-    }else if(src_y + b_h> h){\n+    }\n+    if(src_y + b_h> h){\n         b_h = h - src_y;\n     }\n ",
  "func": "static av_always_inline void add_yblock(SnowContext *s, int sliced, slice_buffer *sb, IDWTELEM *dst, uint8_t *dst8, const uint8_t *obmc, int src_x, int src_y, int b_w, int b_h, int w, int h, int dst_stride, int src_stride, int obmc_stride, int b_x, int b_y, int add, int offset_dst, int plane_index){\n    const int b_width = s->b_width  << s->block_max_depth;\n    const int b_height= s->b_height << s->block_max_depth;\n    const int b_stride= b_width;\n    BlockNode *lt= &s->block[b_x + b_y*b_stride];\n    BlockNode *rt= lt+1;\n    BlockNode *lb= lt+b_stride;\n    BlockNode *rb= lb+1;\n    uint8_t *block[4];\n    int tmp_step= src_stride >= 7*MB_SIZE ? MB_SIZE : MB_SIZE*src_stride;\n    uint8_t *tmp = s->scratchbuf;\n    uint8_t *ptmp;\n    int x,y;\n\n    if(b_x<0){\n        lt= rt;\n        lb= rb;\n    }else if(b_x + 1 >= b_width){\n        rt= lt;\n        rb= lb;\n    }\n    if(b_y<0){\n        lt= lb;\n        rt= rb;\n    }else if(b_y + 1 >= b_height){\n        lb= lt;\n        rb= rt;\n    }\n\n    if(src_x<0){ //FIXME merge with prev & always round internal width up to *16\n        obmc -= src_x;\n        b_w += src_x;\n        if(!sliced && !offset_dst)\n            dst -= src_x;\n        src_x=0;\n    }else if(src_x + b_w > w){\n        b_w = w - src_x;\n    }\n    if(src_y<0){\n        obmc -= src_y*obmc_stride;\n        b_h += src_y;\n        if(!sliced && !offset_dst)\n            dst -= src_y*dst_stride;\n        src_y=0;\n    }else if(src_y + b_h> h){\n        b_h = h - src_y;\n    }\n\n    if(b_w<=0 || b_h<=0) return;\n\n    av_assert2(src_stride > 2*MB_SIZE + 5);\n\n    if(!sliced && offset_dst)\n        dst += src_x + src_y*dst_stride;\n    dst8+= src_x + src_y*src_stride;\n//    src += src_x + src_y*src_stride;\n\n    ptmp= tmp + 3*tmp_step;\n    block[0]= ptmp;\n    ptmp+=tmp_step;\n    ff_snow_pred_block(s, block[0], tmp, src_stride, src_x, src_y, b_w, b_h, lt, plane_index, w, h);\n\n    if(same_block(lt, rt)){\n        block[1]= block[0];\n    }else{\n        block[1]= ptmp;\n        ptmp+=tmp_step;\n        ff_snow_pred_block(s, block[1], tmp, src_stride, src_x, src_y, b_w, b_h, rt, plane_index, w, h);\n    }\n\n    if(same_block(lt, lb)){\n        block[2]= block[0];\n    }else if(same_block(rt, lb)){\n        block[2]= block[1];\n    }else{\n        block[2]= ptmp;\n        ptmp+=tmp_step;\n        ff_snow_pred_block(s, block[2], tmp, src_stride, src_x, src_y, b_w, b_h, lb, plane_index, w, h);\n    }\n\n    if(same_block(lt, rb) ){\n        block[3]= block[0];\n    }else if(same_block(rt, rb)){\n        block[3]= block[1];\n    }else if(same_block(lb, rb)){\n        block[3]= block[2];\n    }else{\n        block[3]= ptmp;\n        ff_snow_pred_block(s, block[3], tmp, src_stride, src_x, src_y, b_w, b_h, rb, plane_index, w, h);\n    }\n    if(sliced){\n        s->dwt.inner_add_yblock(obmc, obmc_stride, block, b_w, b_h, src_x,src_y, src_stride, sb, add, dst8);\n    }else{\n        for(y=0; y<b_h; y++){\n            //FIXME ugly misuse of obmc_stride\n            const uint8_t *obmc1= obmc + y*obmc_stride;\n            const uint8_t *obmc2= obmc1+ (obmc_stride>>1);\n            const uint8_t *obmc3= obmc1+ obmc_stride*(obmc_stride>>1);\n            const uint8_t *obmc4= obmc3+ (obmc_stride>>1);\n            for(x=0; x<b_w; x++){\n                int v=   obmc1[x] * block[3][x + y*src_stride]\n                        +obmc2[x] * block[2][x + y*src_stride]\n                        +obmc3[x] * block[1][x + y*src_stride]\n                        +obmc4[x] * block[0][x + y*src_stride];\n\n                v <<= 8 - LOG2_OBMC_MAX;\n                if(FRAC_BITS != 8){\n                    v >>= 8 - FRAC_BITS;\n                }\n                if(add){\n                    v += dst[x + y*dst_stride];\n                    v = (v + (1<<(FRAC_BITS-1))) >> FRAC_BITS;\n                    if(v&(~255)) v= ~(v>>31);\n                    dst8[x + y*src_stride] = v;\n                }else{\n                    dst[x + y*dst_stride] -= v;\n                }\n            }\n        }\n    }\n}",
  "project": "FFmpeg",
  "hash": 130981242716370455651346005101230835197,
  "size": 121,
  "commit_id": "61d59703c91869f4e5cdacd8d6be52f8b89d4ba4",
  "message": "avcodec/snow: split block clipping checks\n\nFixes out of array read\nFixes: d4476f68ca1c1c57afbc45806f581963-asan_heap-oob_2266b27_8607_cov_4044577381_snow_chroma_bug.avi\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
  "target": 1,
  "dataset": "other",
  "idx": 198115,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a buffer overflow vulnerability by ensuring array bounds are respected, preventing out-of-bounds reads.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}