{
  "id": 67,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/mirror/xserver/commit/215f894965df5fb0bb45b107d84524e700d2073c",
  "commit_sha": "215f894965df5fb0bb45b107d84524e700d2073c",
  "commit_msg": "dix: Disallow GenericEvent in SendEvent request.\n\nThe SendEvent request holds xEvent which is exactly 32 bytes long, no more,\nno less. Both ProcSendEvent and SProcSendEvent verify that the received data\nexactly match the request size. However nothing stops the client from passing\nin event with xEvent::type = GenericEvent and any value of\nxGenericEvent::length.\n\nIn the case of ProcSendEvent, the event will be eventually passed to\nWriteEventsToClient which will see that it is Generic event and copy the\narbitrary length from the receive buffer (and possibly past it) and send it to\nthe other client. This allows clients to copy unitialized heap memory out of X\nserver or to crash it.\n\nIn case of SProcSendEvent, it will attempt to swap the incoming event by\ncalling a swapping function from the EventSwapVector array. The swapped event\nis written to target buffer, which in this case is local xEvent variable. The\nxEvent variable is 32 bytes long, but the swapping functions for GenericEvents\nexpect that the target buffer has size matching the size of the source\nGenericEvent. This allows clients to cause stack buffer overflows.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "dix/events.c",
  "func_name": "",
  "raw_func_from_json": "ProcSendEvent(ClientPtr client)\n{\n    WindowPtr pWin;\n    WindowPtr effectiveFocus = NullWindow;      /* only set if dest==InputFocus */\n    DeviceIntPtr dev = PickPointer(client);\n    DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);\n    SpritePtr pSprite = dev->spriteInfo->sprite;\n\n    REQUEST(xSendEventReq);\n\n    REQUEST_SIZE_MATCH(xSendEventReq);\n\n    /* libXext and other extension libraries may set the bit indicating\n     * that this event came from a SendEvent request so remove it\n     * since otherwise the event type may fail the range checks\n     * and cause an invalid BadValue error to be returned.\n     *\n     * This is safe to do since we later add the SendEvent bit (0x80)\n     * back in once we send the event to the client */\n\n    stuff->event.u.u.type &= ~(SEND_EVENT_BIT);\n\n    /* The client's event type must be a core event type or one defined by an\n       extension. */\n\n    if (!((stuff->event.u.u.type > X_Reply &&\n           stuff->event.u.u.type < LASTEvent) ||\n          (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&\n           stuff->event.u.u.type < (unsigned) lastEvent))) {\n         client->errorValue = stuff->event.u.u.type;\n         return BadValue;\n     }\n     if (stuff->event.u.u.type == ClientMessage &&\n         stuff->event.u.u.detail != 8 &&\n         stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {\n    }\n\n    if (stuff->destination == PointerWindow)\n        pWin = pSprite->win;\n    else if (stuff->destination == InputFocus) {\n        WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;\n\n        if (inputFocus == NoneWin)\n            return Success;\n\n        /* If the input focus is PointerRootWin, send the event to where\n           the pointer is if possible, then perhaps propogate up to root. */\n        if (inputFocus == PointerRootWin)\n            inputFocus = GetCurrentRootWindow(dev);\n\n        if (IsParent(inputFocus, pSprite->win)) {\n            effectiveFocus = inputFocus;\n            pWin = pSprite->win;\n        }\n        else\n            effectiveFocus = pWin = inputFocus;\n    }\n    else\n        dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);\n\n    if (!pWin)\n        return BadWindow;\n    if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {\n        client->errorValue = stuff->propagate;\n        return BadValue;\n    }\n    stuff->event.u.u.type |= SEND_EVENT_BIT;\n    if (stuff->propagate) {\n        for (; pWin; pWin = pWin->parent) {\n            if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,\n                         &stuff->event, 1))\n                return Success;\n            if (DeliverEventsToWindow(dev, pWin,\n                                      &stuff->event, 1, stuff->eventMask,\n                                      NullGrab))\n                return Success;\n            if (pWin == effectiveFocus)\n                return Success;\n            stuff->eventMask &= ~wDontPropagateMask(pWin);\n            if (!stuff->eventMask)\n                break;\n        }\n    }\n    else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))\n        DeliverEventsToWindow(dev, pWin, &stuff->event,\n                              1, stuff->eventMask, NullGrab);\n    return Success;\n}\n",
  "diff_func": "@@ -5366,6 +5366,12 @@ ProcSendEvent(ClientPtr client)\n         client->errorValue = stuff->event.u.u.type;\n         return BadValue;\n     }\n+    /* Generic events can have variable size, but SendEvent request holds\n+       exactly 32B of event data. */\n+    if (stuff->event.u.u.type == GenericEvent) {\n+        client->errorValue = stuff->event.u.u.type;\n+        return BadValue;\n+    }\n     if (stuff->event.u.u.type == ClientMessage &&\n         stuff->event.u.u.detail != 8 &&\n         stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {",
  "project": "xserver",
  "commit_id": "215f894965df5fb0bb45b107d84524e700d2073c",
  "target": 1,
  "func": "ProcSendEvent(ClientPtr client)\n{\n    WindowPtr pWin;\n    WindowPtr effectiveFocus = NullWindow;      /* only set if dest==InputFocus */\n    DeviceIntPtr dev = PickPointer(client);\n    DeviceIntPtr keybd = GetMaster(dev, MASTER_KEYBOARD);\n    SpritePtr pSprite = dev->spriteInfo->sprite;\n\n    REQUEST(xSendEventReq);\n\n    REQUEST_SIZE_MATCH(xSendEventReq);\n\n    /* libXext and other extension libraries may set the bit indicating\n     * that this event came from a SendEvent request so remove it\n     * since otherwise the event type may fail the range checks\n     * and cause an invalid BadValue error to be returned.\n     *\n     * This is safe to do since we later add the SendEvent bit (0x80)\n     * back in once we send the event to the client */\n\n    stuff->event.u.u.type &= ~(SEND_EVENT_BIT);\n\n    /* The client's event type must be a core event type or one defined by an\n       extension. */\n\n    if (!((stuff->event.u.u.type > X_Reply &&\n           stuff->event.u.u.type < LASTEvent) ||\n          (stuff->event.u.u.type >= EXTENSION_EVENT_BASE &&\n           stuff->event.u.u.type < (unsigned) lastEvent))) {\n         client->errorValue = stuff->event.u.u.type;\n         return BadValue;\n     }\n     if (stuff->event.u.u.type == ClientMessage &&\n         stuff->event.u.u.detail != 8 &&\n         stuff->event.u.u.detail != 16 && stuff->event.u.u.detail != 32) {\n    }\n\n    if (stuff->destination == PointerWindow)\n        pWin = pSprite->win;\n    else if (stuff->destination == InputFocus) {\n        WindowPtr inputFocus = (keybd) ? keybd->focus->win : NoneWin;\n\n        if (inputFocus == NoneWin)\n            return Success;\n\n        /* If the input focus is PointerRootWin, send the event to where\n           the pointer is if possible, then perhaps propogate up to root. */\n        if (inputFocus == PointerRootWin)\n            inputFocus = GetCurrentRootWindow(dev);\n\n        if (IsParent(inputFocus, pSprite->win)) {\n            effectiveFocus = inputFocus;\n            pWin = pSprite->win;\n        }\n        else\n            effectiveFocus = pWin = inputFocus;\n    }\n    else\n        dixLookupWindow(&pWin, stuff->destination, client, DixSendAccess);\n\n    if (!pWin)\n        return BadWindow;\n    if ((stuff->propagate != xFalse) && (stuff->propagate != xTrue)) {\n        client->errorValue = stuff->propagate;\n        return BadValue;\n    }\n    stuff->event.u.u.type |= SEND_EVENT_BIT;\n    if (stuff->propagate) {\n        for (; pWin; pWin = pWin->parent) {\n            if (XaceHook(XACE_SEND_ACCESS, client, NULL, pWin,\n                         &stuff->event, 1))\n                return Success;\n            if (DeliverEventsToWindow(dev, pWin,\n                                      &stuff->event, 1, stuff->eventMask,\n                                      NullGrab))\n                return Success;\n            if (pWin == effectiveFocus)\n                return Success;\n            stuff->eventMask &= ~wDontPropagateMask(pWin);\n            if (!stuff->eventMask)\n                break;\n        }\n    }\n    else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, &stuff->event, 1))\n        DeliverEventsToWindow(dev, pWin, &stuff->event,\n                              1, stuff->eventMask, NullGrab);\n    return Success;\n}\n",
  "big_vul_idx": 177936,
  "idx": 128,
  "hash": 36683317052216501366087070681901031177,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing the processing of GenericEvents with arbitrary lengths, which could lead to memory corruption or buffer overflows. The code change directly mitigates this security risk, fitting the criteria for a Security Vulnerability Fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}