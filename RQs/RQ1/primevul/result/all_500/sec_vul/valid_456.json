{
  "id": 456,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/DavidYou/gpac/commit/1273cdc706eeedf8346d4b9faa5b33435056061d",
  "commit_sha": "1273cdc706eeedf8346d4b9faa5b33435056061d",
  "commit_msg": "fixed #1780 (fuzz)",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/media_tools/av_parsers.c",
  "func_name": "",
  "raw_func_from_json": "static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];\n\n\tu32 k, d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 num_ref_layers[64];\n\t//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\t//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found = 1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\thevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);\n\n\tsplitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");\n\tnum_scalability_types = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types >= 16) {\n\t\tnum_scalability_types = 16;\n\t}\n\tdimension_id_len[0] = 0;\n\tfor (i = 0; i < (num_scalability_types - splitting_flag); i++) {\n\t\tdimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < num_scalability_types; i++) {\n\t\t\tdim_bit_offset[i] = 0;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdim_bit_offset[i] += dimension_id_len[j];\n\t\t}\n\t\tdimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);\n\t\tdim_bit_offset[num_scalability_types] = 6;\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j = 0; j < num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < vps->max_layers; i++)\n\t\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);\n\t}\n\telse {\n\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");\n\tif (view_id_len > 0) {\n\t\tfor (i = 0; i < lhvc_get_num_views(vps); i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);\n\t\t}\n\t}\n\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n\t\t//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64 * sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\tgf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);\n\t\t}\n\n\n\tif (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {\n\t\tfor (i = 0; i < (vps->max_layers - 1); i++) {\n\t\t\tfor (j = i + 1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");\n\n\tvps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);\n\t\thevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);\n\t}\n\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");\n\t\tdefault_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\tvps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);\n\t}\n\n\tvps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs, i);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n\t//TODO - we don't use the rest ...\n\n\treturn GF_TRUE;\n}",
  "diff_func": "@@ -7475,6 +7475,11 @@ static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n \t}\n \tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n \n+\tif (vps->num_output_layer_sets > MAX_LHVC_LAYERS) {\n+\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of output layer sets in VPS %d, max %d supported\\n\", vps->num_output_layer_sets, MAX_LHVC_LAYERS));\n+\t\tvps->num_output_layer_sets = 1;\n+\t\treturn GF_FALSE;\n+\t}\n \n \tlayer_set_idx_for_ols_minus1[0] = 1;\n \tvps->output_layer_flag[0][0] = 1;",
  "func": "static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];\n\n\tu32 k, d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 num_ref_layers[64];\n\t//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\t//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n\t//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found = 1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\thevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);\n\n\tsplitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");\n\tnum_scalability_types = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types >= 16) {\n\t\tnum_scalability_types = 16;\n\t}\n\tdimension_id_len[0] = 0;\n\tfor (i = 0; i < (num_scalability_types - splitting_flag); i++) {\n\t\tdimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < num_scalability_types; i++) {\n\t\t\tdim_bit_offset[i] = 0;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdim_bit_offset[i] += dimension_id_len[j];\n\t\t}\n\t\tdimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);\n\t\tdim_bit_offset[num_scalability_types] = 6;\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j = 0; j < num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < vps->max_layers; i++)\n\t\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);\n\t}\n\telse {\n\t\tfor (j = 0; j < num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");\n\tif (view_id_len > 0) {\n\t\tfor (i = 0; i < lhvc_get_num_views(vps); i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);\n\t\t}\n\t}\n\n\tfor (i = 1; i < vps->max_layers; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n\t\t\t\t//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n\t\t//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64 * sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\tgf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);\n\t\t}\n\n\n\tif (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {\n\t\tfor (i = 0; i < (vps->max_layers - 1); i++) {\n\t\t\tfor (j = i + 1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");\n\n\tvps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level = 1;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);\n\t\thevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);\n\t}\n\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");\n\t\tdefault_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\tvps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);\n\t}\n\n\tvps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs, i);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n\t//TODO - we don't use the rest ...\n\n\treturn GF_TRUE;\n}",
  "project": "gpac",
  "hash": 331733932633957602155233038970535298624,
  "size": 301,
  "commit_id": "1273cdc706eeedf8346d4b9faa5b33435056061d",
  "message": "fixed #1780 (fuzz)",
  "target": 1,
  "dataset": "other",
  "idx": 196765,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch adds a bounds check to prevent an overflow condition in the HEVC parsing function, which was identified through fuzzing. This addresses a potential security vulnerability by ensuring the number of output layer sets does not exceed a safe limit.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}