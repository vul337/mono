{
  "id": 620,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/pjsip/pjproject/commit/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a",
  "commit_sha": "9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a",
  "commit_msg": "Merge pull request from GHSA-p6g5-v97c-w5q4\n\n* Prevent heap buffer overflow when parsing DNS packets\n\n* Make sure packet parsing doesn't advance beyond max/end\n\n* Update checks\n\n* Remove  check\n\nCo-authored-by: sauwming <ming@teluu.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "pjlib-util/src/pjlib-util/dns.c",
  "func_name": "",
  "raw_func_from_json": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    p = (start + name_part_len);\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}",
  "diff_func": "@@ -159,8 +159,13 @@ static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt,\n \t} else {\n \t    unsigned label_len = *p;\n \n-\t    /* Check that label length is valid */\n-\t    if (pkt+label_len > max)\n+\t    /* Check that label length is valid.\n+\t     * Each label consists of an octet length (of size 1) followed\n+\t     * by the octet of the specified length (label_len). Then it\n+\t     * must be followed by either another label's octet length or\n+\t     * a zero length octet (that terminates the sequence).\n+\t     */\n+\t    if (p+1+label_len+1 > max)\n \t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n \n \t    p += (label_len + 1);\n@@ -170,9 +175,6 @@ static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt,\n \t\t++label_len;\n \t    \n \t    *name_len += label_len;\n-\n-\t    if (p >= max)\n-\t\treturn PJLIB_UTIL_EDNSINSIZE;\n \t}\n     }\n     ++p;\n@@ -222,8 +224,13 @@ static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt,\n \t} else {\n \t    unsigned label_len = *p;\n \n-\t    /* Check that label length is valid */\n-\t    if (pkt+label_len > max)\n+\t    /* Check that label length is valid.\n+\t     * Each label consists of an octet length (of size 1) followed\n+\t     * by the octet of the specified length (label_len). Then it\n+\t     * must be followed by either another label's octet length or\n+\t     * a zero length octet (that terminates the sequence).\n+\t     */\n+\t    if (p+1+label_len+1 > max)\n \t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n \n \t    pj_memcpy(name->ptr + name->slen, p+1, label_len);\n@@ -234,9 +241,6 @@ static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt,\n \t\t*(name->ptr + name->slen) = '.';\n \t\t++name->slen;\n \t    }\n-\n-\t    if (p >= max)\n-\t\treturn PJLIB_UTIL_EDNSINSIZE;\n \t}\n     }\n \n@@ -269,6 +273,10 @@ static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n \n     p = (start + name_part_len);\n \n+    /* Check the size can accomodate next few fields. */\n+    if (p + 4 > max)\n+    \treturn PJLIB_UTIL_EDNSINSIZE;\n+\n     /* Get the type */\n     pj_memcpy(&q->type, p, 2);\n     q->type = pj_ntohs(q->type);",
  "func": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    p = (start + name_part_len);\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}",
  "project": "pjproject",
  "hash": 126258121414833088809132976389975059096,
  "size": 38,
  "commit_id": "9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a",
  "message": "Merge pull request from GHSA-p6g5-v97c-w5q4\n\n* Prevent heap buffer overflow when parsing DNS packets\n\n* Make sure packet parsing doesn't advance beyond max/end\n\n* Update checks\n\n* Remove  check\n\nCo-authored-by: sauwming <ming@teluu.com>",
  "target": 1,
  "dataset": "other",
  "idx": 195954,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0\n\n**Final Output:**\nAnalysis: The patch introduces stricter bounds checking in DNS packet parsing to prevent heap buffer overflow, addressing a security vulnerability.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a buffer overflow vulnerability in DNS packet parsing, which is a security issue. The changes ensure that parsing doesn't exceed buffer limits, preventing potential exploitation.\n\n**Final Output:**\nAnalysis: The patch modifies DNS parsing functions to prevent buffer overflows by adding stricter bounds checks. This addresses a security vulnerability that could be exploited via crafted DNS packets, leading to crashes or code execution.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0\n\n**Final Output:**\nAnalysis: The patch introduces stricter bounds checking in DNS packet parsing to prevent heap buffer overflow, addressing a security vulnerability.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}