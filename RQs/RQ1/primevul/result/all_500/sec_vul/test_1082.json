{
  "id": 1082,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/dreamsxin/async-php/commit/1744be2d17befc69bf00033993f4081852a747d6",
  "commit_sha": "1744be2d17befc69bf00033993f4081852a747d6",
  "commit_msg": "Fix for bug #69782",
  "pr_url": null,
  "pr_info": null,
  "file_name": "ext/xsl/xsltprocessor.c",
  "func_name": "",
  "raw_func_from_json": "static void xsl_ext_function_php(xmlXPathParserContextPtr ctxt, int nargs, int type) /* {{{ */\n{\n\txsltTransformContextPtr tctxt;\n\tzval **args;\n\tzval *retval;\n\tint result, i, ret;\n\tint error = 0;\n\tzend_fcall_info fci;\n\tzval handler;\n\txmlXPathObjectPtr obj;\n\tchar *str;\n\tchar *callable = NULL;\n\txsl_object *intern;\n\t\n\tTSRMLS_FETCH();\n\n\tif (! zend_is_executing(TSRMLS_C)) {\n\t\txsltGenericError(xsltGenericErrorContext,\n\t\t\"xsltExtFunctionTest: Function called from outside of PHP\\n\");\n\t\terror = 1;\n\t} else {\n\t\ttctxt = xsltXPathGetTransformContext(ctxt);\n\t\tif (tctxt == NULL) {\n\t\t\txsltGenericError(xsltGenericErrorContext,\n\t\t\t\"xsltExtFunctionTest: failed to get the transformation context\\n\");\n\t\t\terror = 1;\n\t\t} else {\n\t\t\tintern = (xsl_object *) tctxt->_private;\n\t\t\tif (intern == NULL) {\n\t\t\t\txsltGenericError(xsltGenericErrorContext,\n\t\t\t\t\"xsltExtFunctionTest: failed to get the internal object\\n\");\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\telse if (intern->registerPhpFunctions == 0) {\n\t\t\t\txsltGenericError(xsltGenericErrorContext,\n\t\t\t\t\"xsltExtFunctionTest: PHP Object did not register PHP functions\\n\");\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (error == 1) {\n\t\tfor (i = nargs - 1; i >= 0; i--) {\n\t\t\tobj = valuePop(ctxt);\n\t\t\txmlXPathFreeObject(obj);\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\tfci.param_count = nargs - 1;\n\tif (fci.param_count > 0) {\n\t\tfci.params = safe_emalloc(fci.param_count, sizeof(zval**), 0);\n\t\targs = safe_emalloc(fci.param_count, sizeof(zval *), 0);\n\t}\n\t/* Reverse order to pop values off ctxt stack */\n\tfor (i = nargs - 2; i >= 0; i--) {\n\t\tobj = valuePop(ctxt);\n\t\tMAKE_STD_ZVAL(args[i]);\n\t\tswitch (obj->type) {\n\t\t\tcase XPATH_STRING:\n\t\t\t\tZVAL_STRING(args[i],  obj->stringval, 1);\n\t\t\t\tbreak;\n\t\t\tcase XPATH_BOOLEAN:\n\t\t\t\tZVAL_BOOL(args[i],  obj->boolval);\n\t\t\t\tbreak;\n\t\t\tcase XPATH_NUMBER:\n\t\t\t\tZVAL_DOUBLE(args[i], obj->floatval);\n\t\t\t\tbreak;\n\t\t\tcase XPATH_NODESET:\n\t\t\t\tif (type == 1) {\n\t\t\t\t\tstr = xmlXPathCastToString(obj);\n\t\t\t\t\tZVAL_STRING(args[i], str, 1);\n\t\t\t\t\txmlFree(str);\n\t\t\t\t} else if (type == 2) {\n\t\t\t\t\tint j;\n\t\t\t\t\tdom_object *domintern = (dom_object *)intern->doc;\n\t\t\t\t\tarray_init(args[i]);\n\t\t\t\t\tif (obj->nodesetval && obj->nodesetval->nodeNr > 0) {\n\t\t\t\t\t\tfor (j = 0; j < obj->nodesetval->nodeNr; j++) {\n\t\t\t\t\t\t\txmlNodePtr node = obj->nodesetval->nodeTab[j];\n\t\t\t\t\t\t\tzval *child;\n\t\t\t\t\t\t\tMAKE_STD_ZVAL(child);\n\t\t\t\t\t\t\t/* not sure, if we need this... it's copied from xpath.c */\n\t\t\t\t\t\t\tif (node->type == XML_NAMESPACE_DECL) {\n\t\t\t\t\t\t\t\txmlNsPtr curns;\n\t\t\t\t\t\t\t\txmlNodePtr nsparent;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tnsparent = node->_private;\n\t\t\t\t\t\t\t\tcurns = xmlNewNs(NULL, node->name, NULL);\n\t\t\t\t\t\t\t\tif (node->children) {\n\t\t\t\t\t\t\t\t\tcurns->prefix = xmlStrdup((char *) node->children);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (node->children) {\n\t\t\t\t\t\t\t\t\tnode = xmlNewDocNode(node->doc, NULL, (char *) node->children, node->name);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode = xmlNewDocNode(node->doc, NULL, \"xmlns\", node->name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnode->type = XML_NAMESPACE_DECL;\n\t\t\t\t\t\t\t\tnode->parent = nsparent;\n\t\t\t\t\t\t\t\tnode->ns = curns;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnode = xmlDocCopyNodeList(domintern->document->ptr, node);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tchild = php_dom_create_object(node, &ret, child, domintern TSRMLS_CC);\n\t\t\t\t\t\t\tadd_next_index_zval(args[i], child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr = xmlXPathCastToString(obj);\n\t\t\t\tZVAL_STRING(args[i], str, 1);\n\t\t\t\txmlFree(str);\n\t\t}\n\t\txmlXPathFreeObject(obj);\n\t\tfci.params[i] = &args[i];\n\t}\n\t\n\tfci.size = sizeof(fci);\n\tfci.function_table = EG(function_table);\n\t\n\tobj = valuePop(ctxt);\n\tif (obj->stringval == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Handler name must be a string\");\n\t\txmlXPathFreeObject(obj);\n\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t\tif (fci.param_count > 0) {\n\t\t\tfor (i = 0; i < nargs - 1; i++) {\n\t\t\t\tzval_ptr_dtor(&args[i]);\n\t\t\t}\n\t\t\tefree(args);\n\t\t\tefree(fci.params);\n\t\t}\n\t\treturn; \n\t}\n\tINIT_PZVAL(&handler);\n\tZVAL_STRING(&handler, obj->stringval, 1);\n\txmlXPathFreeObject(obj);\n\t\n\tfci.function_name = &handler;\n\tfci.symbol_table = NULL;\n\tfci.object_ptr = NULL;\n\tfci.retval_ptr_ptr = &retval;\n\tfci.no_separation = 0;\n\t/*fci.function_handler_cache = &function_ptr;*/\n\tif (!zend_make_callable(&handler, &callable TSRMLS_CC)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s()\", callable);\n\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t} else if ( intern->registerPhpFunctions == 2 && zend_hash_exists(intern->registered_phpfunctions, callable, strlen(callable) + 1) == 0) { \n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Not allowed to call handler '%s()'\", callable);\n\t\t/* Push an empty string, so that we at least have an xslt result... */\n\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t} else {\n\t\tresult = zend_call_function(&fci, NULL TSRMLS_CC);\n\t\tif (result == FAILURE) {\n\t\t\tif (Z_TYPE(handler) == IS_STRING) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s()\", Z_STRVAL_P(&handler));\n\t\t\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t\t\t}\n\t\t/* retval is == NULL, when an exception occurred, don't report anything, because PHP itself will handle that */\n\t\t} else if (retval == NULL) {\n\t\t} else {\n\t\t\tif (retval->type == IS_OBJECT && instanceof_function( Z_OBJCE_P(retval), dom_node_class_entry TSRMLS_CC)) {\n\t\t\t\txmlNode *nodep;\n\t\t\t\tdom_object *obj;\n\t\t\t\tif (intern->node_list == NULL) {\n\t\t\t\t\tALLOC_HASHTABLE(intern->node_list);\n\t\t\t\t\tzend_hash_init(intern->node_list, 0, NULL, ZVAL_PTR_DTOR, 0);\n\t\t\t\t}\n\t\t\t\tzval_add_ref(&retval);\n\t\t\t\tzend_hash_next_index_insert(intern->node_list, &retval, sizeof(zval *), NULL);\n\t\t\t\tobj = (dom_object *)zend_object_store_get_object(retval TSRMLS_CC);\n\t\t\t\tnodep = dom_object_get_node(obj);\n\t\t\t\tvaluePush(ctxt, xmlXPathNewNodeSet(nodep));\n\t\t\t} else if (retval->type == IS_BOOL) {\n\t\t\t\tvaluePush(ctxt, xmlXPathNewBoolean(retval->value.lval));\n\t\t\t} else if (retval->type == IS_OBJECT) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"A PHP Object cannot be converted to a XPath-string\");\n\t\t\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t\t\t} else {\n\t\t\t\tconvert_to_string_ex(&retval);\n\t\t\t\tvaluePush(ctxt, xmlXPathNewString( Z_STRVAL_P(retval)));\n\t\t\t}\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\t}\n\tefree(callable);\n\tzval_dtor(&handler);\n\tif (fci.param_count > 0) {\n\t\tfor (i = 0; i < nargs - 1; i++) {\n\t\t\tzval_ptr_dtor(&args[i]);\n\t\t}\n\t\tefree(args);\n\t\tefree(fci.params);\n\t}\n}",
  "diff_func": "@@ -81,10 +81,10 @@ ZEND_END_ARG_INFO();\n /* }}} */\n \n /*\n-* class xsl_xsltprocessor \n+* class xsl_xsltprocessor\n *\n * URL: http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#\n-* Since: \n+* Since:\n */\n \n const zend_function_entry php_xsl_xsltprocessor_class_functions[] = {\n@@ -111,9 +111,9 @@ static char *php_xsl_xslt_string_to_xpathexpr(const char *str TSRMLS_DC)\n \n \txmlChar *value;\n \tint str_len;\n-\t\n+\n \tstr_len = xmlStrlen(string) + 3;\n-\t\n+\n \tif (xmlStrchr(string, '\"')) {\n \t\tif (xmlStrchr(string, '\\'')) {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot create XPath expression (string contains both quote and double-quotes)\");\n@@ -133,7 +133,7 @@ static char *php_xsl_xslt_string_to_xpathexpr(const char *str TSRMLS_DC)\n    Translates a PHP array to a libxslt parameters array */\n static char **php_xsl_xslt_make_params(HashTable *parht, int xpath_params TSRMLS_DC)\n {\n-\t\n+\n \tint parsize;\n \tzval **value;\n \tchar *xpath_expr, *string_key = NULL;\n@@ -158,7 +158,7 @@ static char **php_xsl_xslt_make_params(HashTable *parht, int xpath_params TSRMLS\n \t\t\t\tSEPARATE_ZVAL(value);\n \t\t\t\tconvert_to_string(*value);\n \t\t\t}\n-\t\t\t\n+\n \t\t\tif (!xpath_params) {\n \t\t\t\txpath_expr = php_xsl_xslt_string_to_xpathexpr(Z_STRVAL_PP(value) TSRMLS_CC);\n \t\t\t} else {\n@@ -192,7 +192,7 @@ static void xsl_ext_function_php(xmlXPathParserContextPtr ctxt, int nargs, int t\n \tchar *str;\n \tchar *callable = NULL;\n \txsl_object *intern;\n-\t\n+\n \tTSRMLS_FETCH();\n \n \tif (! zend_is_executing(TSRMLS_C)) {\n@@ -219,15 +219,17 @@ static void xsl_ext_function_php(xmlXPathParserContextPtr ctxt, int nargs, int t\n \t\t\t}\n \t\t}\n \t}\n-\t\n+\n \tif (error == 1) {\n \t\tfor (i = nargs - 1; i >= 0; i--) {\n \t\t\tobj = valuePop(ctxt);\n-\t\t\txmlXPathFreeObject(obj);\n+\t\t\tif (obj) {\n+\t\t\t\txmlXPathFreeObject(obj);\n+\t\t\t}\n \t\t}\n \t\treturn;\n \t}\n-\t\t\n+\n \tfci.param_count = nargs - 1;\n \tif (fci.param_count > 0) {\n \t\tfci.params = safe_emalloc(fci.param_count, sizeof(zval**), 0);\n@@ -265,7 +267,7 @@ static void xsl_ext_function_php(xmlXPathParserContextPtr ctxt, int nargs, int t\n \t\t\t\t\t\t\tif (node->type == XML_NAMESPACE_DECL) {\n \t\t\t\t\t\t\t\txmlNsPtr curns;\n \t\t\t\t\t\t\t\txmlNodePtr nsparent;\n-\t\t\t\t\t\t\t\t\n+\n \t\t\t\t\t\t\t\tnsparent = node->_private;\n \t\t\t\t\t\t\t\tcurns = xmlNewNs(NULL, node->name, NULL);\n \t\t\t\t\t\t\t\tif (node->children) {\n@@ -297,14 +299,16 @@ static void xsl_ext_function_php(xmlXPathParserContextPtr ctxt, int nargs, int t\n \t\txmlXPathFreeObject(obj);\n \t\tfci.params[i] = &args[i];\n \t}\n-\t\n+\n \tfci.size = sizeof(fci);\n \tfci.function_table = EG(function_table);\n-\t\n+\n \tobj = valuePop(ctxt);\n-\tif (obj->stringval == NULL) {\n-\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Handler name must be a string\");\n-\t\txmlXPathFreeObject(obj);\n+\tif (obj == NULL || obj->stringval == NULL) {\n+\t\tif (obj) {\n+\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Handler name must be a string\");\n+\t\t\txmlXPathFreeObject(obj);\n+\t\t}\n \t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n \t\tif (fci.param_count > 0) {\n \t\t\tfor (i = 0; i < nargs - 1; i++) {\n@@ -313,12 +317,12 @@ static void xsl_ext_function_php(xmlXPathParserContextPtr ctxt, int nargs, int t\n \t\t\tefree(args);\n \t\t\tefree(fci.params);\n \t\t}\n-\t\treturn; \n+\t\treturn;\n \t}\n \tINIT_PZVAL(&handler);\n \tZVAL_STRING(&handler, obj->stringval, 1);\n \txmlXPathFreeObject(obj);\n-\t\n+\n \tfci.function_name = &handler;\n \tfci.symbol_table = NULL;\n \tfci.object_ptr = NULL;\n@@ -328,7 +332,7 @@ static void xsl_ext_function_php(xmlXPathParserContextPtr ctxt, int nargs, int t\n \tif (!zend_make_callable(&handler, &callable TSRMLS_CC)) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s()\", callable);\n \t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n-\t} else if ( intern->registerPhpFunctions == 2 && zend_hash_exists(intern->registered_phpfunctions, callable, strlen(callable) + 1) == 0) { \n+\t} else if ( intern->registerPhpFunctions == 2 && zend_hash_exists(intern->registered_phpfunctions, callable, strlen(callable) + 1) == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Not allowed to call handler '%s()'\", callable);\n \t\t/* Push an empty string, so that we at least have an xslt result... */\n \t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n@@ -392,7 +396,7 @@ void xsl_ext_function_object_php(xmlXPathParserContextPtr ctxt, int nargs) /* {{\n \n /* {{{ proto void xsl_xsltprocessor_import_stylesheet(domdocument doc);\n URL: http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#\n-Since: \n+Since:\n */\n PHP_FUNCTION(xsl_xsltprocessor_import_stylesheet)\n {\n@@ -404,13 +408,13 @@ PHP_FUNCTION(xsl_xsltprocessor_import_stylesheet)\n \txmlNode *nodep = NULL;\n \tzend_object_handlers *std_hnd;\n \tzval *cloneDocu, *member;\n-\t\n+\n \tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Oo\", &id, xsl_xsltprocessor_class_entry, &docp) == FAILURE) {\n \t\tRETURN_FALSE;\n \t}\n \n \tnodep = php_libxml_import_node(docp TSRMLS_CC);\n-\t\n+\n \tif (nodep) {\n \t\tdoc = nodep->doc;\n \t}\n@@ -419,7 +423,7 @@ PHP_FUNCTION(xsl_xsltprocessor_import_stylesheet)\n \t\tRETURN_FALSE;\n \t}\n \n-\t/* libxslt uses _private, so we must copy the imported \n+\t/* libxslt uses _private, so we must copy the imported\n \tstylesheet document otherwise the node proxies will be a mess */\n \tnewdoc = xmlCopyDoc(doc, 1);\n \txmlNodeSetBase((xmlNodePtr) newdoc, (xmlChar *)doc->URL);\n@@ -436,7 +440,7 @@ PHP_FUNCTION(xsl_xsltprocessor_import_stylesheet)\n \t\tRETURN_FALSE;\n \t}\n \n-\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC); \n+\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n \n \tstd_hnd = zend_get_std_object_handlers();\n \tMAKE_STD_ZVAL(member);\n@@ -463,10 +467,10 @@ PHP_FUNCTION(xsl_xsltprocessor_import_stylesheet)\n \t\tintern->hasKeys = clone_docu;\n \t}\n \n-\tif ((oldsheetp = (xsltStylesheetPtr)intern->ptr)) { \n+\tif ((oldsheetp = (xsltStylesheetPtr)intern->ptr)) {\n \t\t/* free wrapper */\n \t\tif (((xsltStylesheetPtr) intern->ptr)->_private != NULL) {\n-\t\t\t((xsltStylesheetPtr) intern->ptr)->_private = NULL;   \n+\t\t\t((xsltStylesheetPtr) intern->ptr)->_private = NULL;\n \t\t}\n \t\txsltFreeStylesheet((xsltStylesheetPtr) intern->ptr);\n \t\tintern->ptr = NULL;\n@@ -494,7 +498,7 @@ static xmlDocPtr php_xsl_apply_stylesheet(zval *id, xsl_object *intern, xsltStyl\n \txsltSecurityPrefsPtr secPrefs = NULL;\n \n \tnode = php_libxml_import_node(docp TSRMLS_CC);\n-\t\n+\n \tif (node) {\n \t\tdoc = node->doc;\n \t}\n@@ -507,7 +511,7 @@ static xmlDocPtr php_xsl_apply_stylesheet(zval *id, xsl_object *intern, xsltStyl\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No stylesheet associated to this object\");\n \t\treturn NULL;\n \t}\n-\t\n+\n \tif (intern->profiling) {\n \t\tif (php_check_open_basedir(intern->profiling TSRMLS_CC)) {\n \t\t\tf = NULL;\n@@ -517,7 +521,7 @@ static xmlDocPtr php_xsl_apply_stylesheet(zval *id, xsl_object *intern, xsltStyl\n \t} else {\n \t\tf = NULL;\n \t}\n-\t\n+\n \tif (intern->parameter) {\n \t\tparams = php_xsl_xslt_make_params(intern->parameter, 0 TSRMLS_CC);\n \t}\n@@ -549,7 +553,7 @@ static xmlDocPtr php_xsl_apply_stylesheet(zval *id, xsl_object *intern, xsltStyl\n \tefree(member);\n \n \tsecPrefsValue = intern->securityPrefs;\n-\t\n+\n \t/* This whole if block can be removed, when we remove the xsl.security_prefs php.ini option in PHP 6+ */\n \tsecPrefsIni= INI_INT(\"xsl.security_prefs\");\n \t/* if secPrefsIni has the same value as secPrefsValue, all is fine */\n@@ -569,38 +573,38 @@ static xmlDocPtr php_xsl_apply_stylesheet(zval *id, xsl_object *intern, xsltStyl\n \n \t/* if securityPrefs is set to NONE, we don't have to do any checks, but otherwise... */\n \tif (secPrefsValue != XSL_SECPREF_NONE) {\n-\t\tsecPrefs = xsltNewSecurityPrefs(); \n-\t\tif (secPrefsValue & XSL_SECPREF_READ_FILE ) { \n-\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_READ_FILE, xsltSecurityForbid)) { \n+\t\tsecPrefs = xsltNewSecurityPrefs();\n+\t\tif (secPrefsValue & XSL_SECPREF_READ_FILE ) {\n+\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_READ_FILE, xsltSecurityForbid)) {\n \t\t\t\tsecPrefsError = 1;\n \t\t\t}\n \t\t}\n-\t\tif (secPrefsValue & XSL_SECPREF_WRITE_FILE ) { \n-\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_WRITE_FILE, xsltSecurityForbid)) { \n+\t\tif (secPrefsValue & XSL_SECPREF_WRITE_FILE ) {\n+\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_WRITE_FILE, xsltSecurityForbid)) {\n \t\t\t\tsecPrefsError = 1;\n \t\t\t}\n \t\t}\n-\t\tif (secPrefsValue & XSL_SECPREF_CREATE_DIRECTORY ) { \n-\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_CREATE_DIRECTORY, xsltSecurityForbid)) { \n+\t\tif (secPrefsValue & XSL_SECPREF_CREATE_DIRECTORY ) {\n+\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_CREATE_DIRECTORY, xsltSecurityForbid)) {\n \t\t\t\tsecPrefsError = 1;\n \t\t\t}\n \t\t}\n-\t\tif (secPrefsValue & XSL_SECPREF_READ_NETWORK) { \n-\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_READ_NETWORK, xsltSecurityForbid)) { \n+\t\tif (secPrefsValue & XSL_SECPREF_READ_NETWORK) {\n+\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_READ_NETWORK, xsltSecurityForbid)) {\n \t\t\t\tsecPrefsError = 1;\n \t\t\t}\n \t\t}\n-\t\tif (secPrefsValue & XSL_SECPREF_WRITE_NETWORK) { \n-\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_WRITE_NETWORK, xsltSecurityForbid)) { \n+\t\tif (secPrefsValue & XSL_SECPREF_WRITE_NETWORK) {\n+\t\t\tif (0 != xsltSetSecurityPrefs(secPrefs, XSLT_SECPREF_WRITE_NETWORK, xsltSecurityForbid)) {\n \t\t\t\tsecPrefsError = 1;\n \t\t\t}\n \t\t}\n-\t\n-\t\tif (0 != xsltSetCtxtSecurityPrefs(secPrefs, ctxt)) { \n+\n+\t\tif (0 != xsltSetCtxtSecurityPrefs(secPrefs, ctxt)) {\n \t\t\tsecPrefsError = 1;\n \t\t}\n \t}\n-\t\n+\n \tif (secPrefsError == 1) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can't set libxslt security properties, not doing transformation for security reasons\");\n \t} else {\n@@ -609,15 +613,15 @@ static xmlDocPtr php_xsl_apply_stylesheet(zval *id, xsl_object *intern, xsltStyl\n \tif (f) {\n \t\tfclose(f);\n \t}\n-\t\n+\n \txsltFreeTransformContext(ctxt);\n \tif (secPrefs) {\n \t\txsltFreeSecurityPrefs(secPrefs);\n \t}\n \n \tif (intern->node_list != NULL) {\n \t\tzend_hash_destroy(intern->node_list);\n-\t\tFREE_HASHTABLE(intern->node_list);\t\n+\t\tFREE_HASHTABLE(intern->node_list);\n \t\tintern->node_list = NULL;\n \t}\n \n@@ -640,7 +644,7 @@ static xmlDocPtr php_xsl_apply_stylesheet(zval *id, xsl_object *intern, xsltStyl\n \n /* {{{ proto domdocument xsl_xsltprocessor_transform_to_doc(domnode doc);\n URL: http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030226/DOM3-Core.html#\n-Since: \n+Since:\n */\n PHP_FUNCTION(xsl_xsltprocessor_transform_to_doc)\n {\n@@ -677,13 +681,13 @@ PHP_FUNCTION(xsl_xsltprocessor_transform_to_doc)\n \t\t\tfound = zend_lookup_class(ret_class, ret_class_len, &ce TSRMLS_CC);\n \t\t\tif ((found != SUCCESS) || !instanceof_function(*ce, curce TSRMLS_CC)) {\n \t\t\t\txmlFreeDoc(newdocp);\n-\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \n+\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n \t\t\t\t\t\"Expecting class compatible with %s, '%s' given\", curclass_name, ret_class);\n \t\t\t\tRETURN_FALSE;\n \t\t\t}\n \n \t\t\tobject_init_ex(return_value, *ce);\n-\t\t\n+\n \t\t\tinterndoc = (php_libxml_node_object *)zend_objects_get_address(return_value TSRMLS_CC);\n \t\t\tphp_libxml_increment_doc_ref(interndoc, newdocp TSRMLS_CC);\n \t\t\tphp_libxml_increment_node_ptr(interndoc, (xmlNodePtr)newdocp, (void *)interndoc TSRMLS_CC);\n@@ -693,7 +697,7 @@ PHP_FUNCTION(xsl_xsltprocessor_transform_to_doc)\n \t} else {\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n }\n /* }}} end xsl_xsltprocessor_transform_to_doc */\n \n@@ -707,7 +711,7 @@ PHP_FUNCTION(xsl_xsltprocessor_transform_to_uri)\n \tint ret, uri_len;\n \tchar *uri;\n \txsl_object *intern;\n-\t\n+\n \tid = getThis();\n \tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n \tsheetp = (xsltStylesheetPtr) intern->ptr;\n@@ -739,7 +743,7 @@ PHP_FUNCTION(xsl_xsltprocessor_transform_to_xml)\n \txmlChar *doc_txt_ptr;\n \tint doc_txt_len;\n \txsl_object *intern;\n-\t\n+\n \tid = getThis();\n \tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n \tsheetp = (xsltStylesheetPtr) intern->ptr;\n@@ -770,7 +774,7 @@ PHP_FUNCTION(xsl_xsltprocessor_transform_to_xml)\n */\n PHP_FUNCTION(xsl_xsltprocessor_set_parameter)\n {\n- \n+\n \tzval *id;\n \tzval *array_value, **entry, *new_string;\n \txsl_object *intern;\n@@ -786,34 +790,34 @@ PHP_FUNCTION(xsl_xsltprocessor_set_parameter)\n \t\twhile (zend_hash_get_current_data(Z_ARRVAL_P(array_value), (void **)&entry) == SUCCESS) {\n \t\t\tSEPARATE_ZVAL(entry);\n \t\t\tconvert_to_string_ex(entry);\n-\t\t\t\n+\n \t\t\tif (zend_hash_get_current_key_ex(Z_ARRVAL_P(array_value), &string_key, &string_key_len, &idx, 0, NULL) != HASH_KEY_IS_STRING) {\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid parameter array\");\n \t\t\t\tRETURN_FALSE;\n \t\t\t}\n-\t\t\t\n+\n \t\t\tALLOC_ZVAL(new_string);\n \t\t\tZ_ADDREF_PP(entry);\n \t\t\tCOPY_PZVAL_TO_ZVAL(*new_string, *entry);\n-\t\t\t\n+\n \t\t\tzend_hash_update(intern->parameter, string_key, string_key_len, &new_string, sizeof(zval*), NULL);\n \t\t\tzend_hash_move_forward(Z_ARRVAL_P(array_value));\n \t\t}\n \t\tRETURN_TRUE;\n \n \t} else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"sss\", &namespace, &namespace_len, &name, &name_len, &value, &value_len) == SUCCESS) {\n-\t\t\n+\n \t\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n-\t\t\n+\n \t\tMAKE_STD_ZVAL(new_string);\n \t\tZVAL_STRING(new_string, value, 1);\n-\t\t\n+\n \t\tzend_hash_update(intern->parameter, name, name_len + 1, &new_string, sizeof(zval*), NULL);\n \t\tRETURN_TRUE;\n \t} else {\n \t\tWRONG_PARAM_COUNT;\n \t}\n-\t\n+\n }\n /* }}} end xsl_xsltprocessor_set_parameter */\n \n@@ -828,7 +832,7 @@ PHP_FUNCTION(xsl_xsltprocessor_get_parameter)\n \txsl_object *intern;\n \n \tDOM_GET_THIS(id);\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &namespace, &namespace_len, &name, &name_len) == FAILURE) {\n \t\tRETURN_FALSE;\n \t}\n@@ -852,7 +856,7 @@ PHP_FUNCTION(xsl_xsltprocessor_remove_parameter)\n \txsl_object *intern;\n \n \tDOM_GET_THIS(id);\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &namespace, &namespace_len, &name, &name_len) == FAILURE) {\n \t\tRETURN_FALSE;\n \t}\n@@ -876,36 +880,36 @@ PHP_FUNCTION(xsl_xsltprocessor_register_php_functions)\n \tchar *name;\n \n \tDOM_GET_THIS(id);\n-\t\n+\n \tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"a\",  &array_value) == SUCCESS) {\n \t\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n \t\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(array_value));\n \n \t\twhile (zend_hash_get_current_data(Z_ARRVAL_P(array_value), (void **)&entry) == SUCCESS) {\n \t\t\tSEPARATE_ZVAL(entry);\n \t\t\tconvert_to_string_ex(entry);\n-\t\t\t\n+\n \t\t\tMAKE_STD_ZVAL(new_string);\n \t\t\tZVAL_LONG(new_string,1);\n-\t\t\n+\n \t\t\tzend_hash_update(intern->registered_phpfunctions, Z_STRVAL_PP(entry), Z_STRLEN_PP(entry) + 1, &new_string, sizeof(zval*), NULL);\n \t\t\tzend_hash_move_forward(Z_ARRVAL_P(array_value));\n \t\t}\n \t\tintern->registerPhpFunctions = 2;\n \n \t} else if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"s\",  &name, &name_len) == SUCCESS) {\n \t\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n-\t\t\n+\n \t\tMAKE_STD_ZVAL(new_string);\n \t\tZVAL_LONG(new_string,1);\n \t\tzend_hash_update(intern->registered_phpfunctions, name, name_len + 1, &new_string, sizeof(zval*), NULL);\n \t\tintern->registerPhpFunctions = 2;\n-\t\t\n+\n \t} else {\n \t\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n \t\tintern->registerPhpFunctions = 1;\n \t}\n-\t\n+\n }\n /* }}} end xsl_xsltprocessor_register_php_functions(); */\n \n@@ -947,7 +951,7 @@ PHP_FUNCTION(xsl_xsltprocessor_set_security_prefs)\n \t\treturn;\n \t}\n \tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n-\toldSecurityPrefs = intern->securityPrefs; \n+\toldSecurityPrefs = intern->securityPrefs;\n \tintern->securityPrefs = securityPrefs;\n \t/* set this to 1 so that we know, it was set through this method. Can be removed, when we remove the ini setting */\n \tintern->securityPrefsSet = 1;",
  "func": "static void xsl_ext_function_php(xmlXPathParserContextPtr ctxt, int nargs, int type) /* {{{ */\n{\n\txsltTransformContextPtr tctxt;\n\tzval **args;\n\tzval *retval;\n\tint result, i, ret;\n\tint error = 0;\n\tzend_fcall_info fci;\n\tzval handler;\n\txmlXPathObjectPtr obj;\n\tchar *str;\n\tchar *callable = NULL;\n\txsl_object *intern;\n\t\n\tTSRMLS_FETCH();\n\n\tif (! zend_is_executing(TSRMLS_C)) {\n\t\txsltGenericError(xsltGenericErrorContext,\n\t\t\"xsltExtFunctionTest: Function called from outside of PHP\\n\");\n\t\terror = 1;\n\t} else {\n\t\ttctxt = xsltXPathGetTransformContext(ctxt);\n\t\tif (tctxt == NULL) {\n\t\t\txsltGenericError(xsltGenericErrorContext,\n\t\t\t\"xsltExtFunctionTest: failed to get the transformation context\\n\");\n\t\t\terror = 1;\n\t\t} else {\n\t\t\tintern = (xsl_object *) tctxt->_private;\n\t\t\tif (intern == NULL) {\n\t\t\t\txsltGenericError(xsltGenericErrorContext,\n\t\t\t\t\"xsltExtFunctionTest: failed to get the internal object\\n\");\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\telse if (intern->registerPhpFunctions == 0) {\n\t\t\t\txsltGenericError(xsltGenericErrorContext,\n\t\t\t\t\"xsltExtFunctionTest: PHP Object did not register PHP functions\\n\");\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (error == 1) {\n\t\tfor (i = nargs - 1; i >= 0; i--) {\n\t\t\tobj = valuePop(ctxt);\n\t\t\txmlXPathFreeObject(obj);\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\tfci.param_count = nargs - 1;\n\tif (fci.param_count > 0) {\n\t\tfci.params = safe_emalloc(fci.param_count, sizeof(zval**), 0);\n\t\targs = safe_emalloc(fci.param_count, sizeof(zval *), 0);\n\t}\n\t/* Reverse order to pop values off ctxt stack */\n\tfor (i = nargs - 2; i >= 0; i--) {\n\t\tobj = valuePop(ctxt);\n\t\tMAKE_STD_ZVAL(args[i]);\n\t\tswitch (obj->type) {\n\t\t\tcase XPATH_STRING:\n\t\t\t\tZVAL_STRING(args[i],  obj->stringval, 1);\n\t\t\t\tbreak;\n\t\t\tcase XPATH_BOOLEAN:\n\t\t\t\tZVAL_BOOL(args[i],  obj->boolval);\n\t\t\t\tbreak;\n\t\t\tcase XPATH_NUMBER:\n\t\t\t\tZVAL_DOUBLE(args[i], obj->floatval);\n\t\t\t\tbreak;\n\t\t\tcase XPATH_NODESET:\n\t\t\t\tif (type == 1) {\n\t\t\t\t\tstr = xmlXPathCastToString(obj);\n\t\t\t\t\tZVAL_STRING(args[i], str, 1);\n\t\t\t\t\txmlFree(str);\n\t\t\t\t} else if (type == 2) {\n\t\t\t\t\tint j;\n\t\t\t\t\tdom_object *domintern = (dom_object *)intern->doc;\n\t\t\t\t\tarray_init(args[i]);\n\t\t\t\t\tif (obj->nodesetval && obj->nodesetval->nodeNr > 0) {\n\t\t\t\t\t\tfor (j = 0; j < obj->nodesetval->nodeNr; j++) {\n\t\t\t\t\t\t\txmlNodePtr node = obj->nodesetval->nodeTab[j];\n\t\t\t\t\t\t\tzval *child;\n\t\t\t\t\t\t\tMAKE_STD_ZVAL(child);\n\t\t\t\t\t\t\t/* not sure, if we need this... it's copied from xpath.c */\n\t\t\t\t\t\t\tif (node->type == XML_NAMESPACE_DECL) {\n\t\t\t\t\t\t\t\txmlNsPtr curns;\n\t\t\t\t\t\t\t\txmlNodePtr nsparent;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tnsparent = node->_private;\n\t\t\t\t\t\t\t\tcurns = xmlNewNs(NULL, node->name, NULL);\n\t\t\t\t\t\t\t\tif (node->children) {\n\t\t\t\t\t\t\t\t\tcurns->prefix = xmlStrdup((char *) node->children);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (node->children) {\n\t\t\t\t\t\t\t\t\tnode = xmlNewDocNode(node->doc, NULL, (char *) node->children, node->name);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode = xmlNewDocNode(node->doc, NULL, \"xmlns\", node->name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnode->type = XML_NAMESPACE_DECL;\n\t\t\t\t\t\t\t\tnode->parent = nsparent;\n\t\t\t\t\t\t\t\tnode->ns = curns;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnode = xmlDocCopyNodeList(domintern->document->ptr, node);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tchild = php_dom_create_object(node, &ret, child, domintern TSRMLS_CC);\n\t\t\t\t\t\t\tadd_next_index_zval(args[i], child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr = xmlXPathCastToString(obj);\n\t\t\t\tZVAL_STRING(args[i], str, 1);\n\t\t\t\txmlFree(str);\n\t\t}\n\t\txmlXPathFreeObject(obj);\n\t\tfci.params[i] = &args[i];\n\t}\n\t\n\tfci.size = sizeof(fci);\n\tfci.function_table = EG(function_table);\n\t\n\tobj = valuePop(ctxt);\n\tif (obj->stringval == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Handler name must be a string\");\n\t\txmlXPathFreeObject(obj);\n\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t\tif (fci.param_count > 0) {\n\t\t\tfor (i = 0; i < nargs - 1; i++) {\n\t\t\t\tzval_ptr_dtor(&args[i]);\n\t\t\t}\n\t\t\tefree(args);\n\t\t\tefree(fci.params);\n\t\t}\n\t\treturn; \n\t}\n\tINIT_PZVAL(&handler);\n\tZVAL_STRING(&handler, obj->stringval, 1);\n\txmlXPathFreeObject(obj);\n\t\n\tfci.function_name = &handler;\n\tfci.symbol_table = NULL;\n\tfci.object_ptr = NULL;\n\tfci.retval_ptr_ptr = &retval;\n\tfci.no_separation = 0;\n\t/*fci.function_handler_cache = &function_ptr;*/\n\tif (!zend_make_callable(&handler, &callable TSRMLS_CC)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s()\", callable);\n\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t} else if ( intern->registerPhpFunctions == 2 && zend_hash_exists(intern->registered_phpfunctions, callable, strlen(callable) + 1) == 0) { \n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Not allowed to call handler '%s()'\", callable);\n\t\t/* Push an empty string, so that we at least have an xslt result... */\n\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t} else {\n\t\tresult = zend_call_function(&fci, NULL TSRMLS_CC);\n\t\tif (result == FAILURE) {\n\t\t\tif (Z_TYPE(handler) == IS_STRING) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s()\", Z_STRVAL_P(&handler));\n\t\t\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t\t\t}\n\t\t/* retval is == NULL, when an exception occurred, don't report anything, because PHP itself will handle that */\n\t\t} else if (retval == NULL) {\n\t\t} else {\n\t\t\tif (retval->type == IS_OBJECT && instanceof_function( Z_OBJCE_P(retval), dom_node_class_entry TSRMLS_CC)) {\n\t\t\t\txmlNode *nodep;\n\t\t\t\tdom_object *obj;\n\t\t\t\tif (intern->node_list == NULL) {\n\t\t\t\t\tALLOC_HASHTABLE(intern->node_list);\n\t\t\t\t\tzend_hash_init(intern->node_list, 0, NULL, ZVAL_PTR_DTOR, 0);\n\t\t\t\t}\n\t\t\t\tzval_add_ref(&retval);\n\t\t\t\tzend_hash_next_index_insert(intern->node_list, &retval, sizeof(zval *), NULL);\n\t\t\t\tobj = (dom_object *)zend_object_store_get_object(retval TSRMLS_CC);\n\t\t\t\tnodep = dom_object_get_node(obj);\n\t\t\t\tvaluePush(ctxt, xmlXPathNewNodeSet(nodep));\n\t\t\t} else if (retval->type == IS_BOOL) {\n\t\t\t\tvaluePush(ctxt, xmlXPathNewBoolean(retval->value.lval));\n\t\t\t} else if (retval->type == IS_OBJECT) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"A PHP Object cannot be converted to a XPath-string\");\n\t\t\t\tvaluePush(ctxt, xmlXPathNewString(\"\"));\n\t\t\t} else {\n\t\t\t\tconvert_to_string_ex(&retval);\n\t\t\t\tvaluePush(ctxt, xmlXPathNewString( Z_STRVAL_P(retval)));\n\t\t\t}\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\t}\n\tefree(callable);\n\tzval_dtor(&handler);\n\tif (fci.param_count > 0) {\n\t\tfor (i = 0; i < nargs - 1; i++) {\n\t\t\tzval_ptr_dtor(&args[i]);\n\t\t}\n\t\tefree(args);\n\t\tefree(fci.params);\n\t}\n}",
  "project": "php-src",
  "hash": 166937765955710490140933898378014635515,
  "size": 197,
  "commit_id": "1744be2d17befc69bf00033993f4081852a747d6",
  "message": "Fix for bug #69782",
  "target": 1,
  "dataset": "other",
  "idx": 211810,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.8",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses several potential security issues, including null pointer dereferences and improper input handling, which could lead to crashes or unauthorized access. These changes are in the XSLT processor, an area prone to security vulnerabilities.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.8"
}