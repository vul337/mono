{
  "id": 1048,
  "language": "c",
  "cwe": [
    "CWE-254"
  ],
  "commit_url": "https://github.com/fulei0920/ssl/commit/cb22d2ae5a5b6069dbf66dbcce07223ac15a16de",
  "commit_sha": "cb22d2ae5a5b6069dbf66dbcce07223ac15a16de",
  "commit_msg": "Fix alt chains bug\n\nThis is a follow up to the alternate chains certificate forgery issue\n(CVE-2015-1793). That issue is exacerbated in 1.0.1 by a related bug which\nmeans that we *always* check for an alternative chain, even if we have\nalready found a chain. The code is supposed to stop as soon as it has found\none (and does do in master and 1.0.2).\n\nReviewed-by: Stephen Henson <steve@openssl.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "crypto/x509/verify_extra_test.c",
  "func_name": "",
  "raw_func_from_json": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n    int bad_chain = 0;\n    X509_VERIFY_PARAM *param = ctx->param;\n    int depth, i, ok = 0;\n    int num, j, retry;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    STACK_OF(X509) *sktmp = NULL;\n    if (ctx->cert == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n        return -1;\n    }\n    if (ctx->chain != NULL) {\n        /*\n         * This X509_STORE_CTX has already been used to verify a cert. We\n         * cannot do another one.\n         */\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    cb = ctx->verify_cb;\n\n    /*\n     * first we make sure the chain we are going to build is present and that\n     * the first entry is in place\n     */\n    if (((ctx->chain = sk_X509_new_null()) == NULL) ||\n        (!sk_X509_push(ctx->chain, ctx->cert))) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n    CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\n    ctx->last_untrusted = 1;\n\n    /* We use a temporary STACK so we can chop and hack at it */\n    if (ctx->untrusted != NULL\n        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    num = sk_X509_num(ctx->chain);\n    x = sk_X509_value(ctx->chain, num - 1);\n    depth = param->depth;\n\n    for (;;) {\n        /* If we have enough, we break */\n        if (depth < num)\n            break;              /* FIXME: If this happens, we should take\n                                 * note of it and, if appropriate, use the\n                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code\n                                 * later. */\n\n        /* If we are self signed, we break */\n        if (ctx->check_issued(ctx, x, x))\n            break;\n\n        /* If we were passed a cert chain, use it first */\n        if (ctx->untrusted != NULL) {\n            xtmp = find_issuer(ctx, sktmp, x);\n            if (xtmp != NULL) {\n                if (!sk_X509_push(ctx->chain, xtmp)) {\n                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                    goto end;\n                }\n                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n                (void)sk_X509_delete_ptr(sktmp, xtmp);\n                ctx->last_untrusted++;\n                x = xtmp;\n                num++;\n                /*\n                 * reparse the full chain for the next one\n                 */\n                continue;\n            }\n        }\n        break;\n    }\n\n    /* Remember how many untrusted certs we have */\n    j = num;\n    /*\n     * at this point, chain should contain a list of untrusted certificates.\n     * We now need to add at least one trusted one, if possible, otherwise we\n     * complain.\n     */\n\n    do {\n        /*\n         * Examine last certificate in chain and see if it is self signed.\n         */\n        i = sk_X509_num(ctx->chain);\n        x = sk_X509_value(ctx->chain, i - 1);\n        if (ctx->check_issued(ctx, x, x)) {\n            /* we have a self signed certificate */\n            if (sk_X509_num(ctx->chain) == 1) {\n                /*\n                 * We have a single self signed certificate: see if we can\n                 * find it in the store. We must have an exact match to avoid\n                 * possible impersonation.\n                 */\n                ok = ctx->get_issuer(&xtmp, ctx, x);\n                if ((ok <= 0) || X509_cmp(x, xtmp)) {\n                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n                    ctx->current_cert = x;\n                    ctx->error_depth = i - 1;\n                    if (ok == 1)\n                        X509_free(xtmp);\n                    bad_chain = 1;\n                    ok = cb(0, ctx);\n                    if (!ok)\n                        goto end;\n                } else {\n                    /*\n                     * We have a match: replace certificate with store\n                     * version so we get any trust settings.\n                     */\n                    X509_free(x);\n                    x = xtmp;\n                    (void)sk_X509_set(ctx->chain, i - 1, x);\n                    ctx->last_untrusted = 0;\n                }\n            } else {\n                /*\n                 * extract and save self signed certificate for later use\n                 */\n                chain_ss = sk_X509_pop(ctx->chain);\n                ctx->last_untrusted--;\n                num--;\n                j--;\n                x = sk_X509_value(ctx->chain, num - 1);\n            }\n        }\n        /* We now lookup certs from the certificate store */\n        for (;;) {\n            /* If we have enough, we break */\n            if (depth < num)\n                break;\n            /* If we are self signed, we break */\n            if (ctx->check_issued(ctx, x, x))\n                break;\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n            if (ok < 0)\n                return ok;\n            if (ok == 0)\n                break;\n            x = xtmp;\n            if (!sk_X509_push(ctx->chain, x)) {\n                X509_free(xtmp);\n                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n            num++;\n        }\n\n        /*\n         * If we haven't got a least one certificate from our store then check\n         * if there is an alternative chain that could be used.  We only do this\n         * if the user hasn't switched off alternate chain checking\n         */\n        retry = 0;\n        if (j == ctx->last_untrusted &&\n            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n            while (j-- > 1) {\n                xtmp2 = sk_X509_value(ctx->chain, j - 1);\n                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n                if (ok < 0)\n                    goto end;\n                /* Check if we found an alternate chain */\n                if (ok > 0) {\n                    /*\n                     * Free up the found cert we'll add it again later\n                     */\n                    X509_free(xtmp);\n\n                    /*\n                     * Dump all the certs above this point - we've found an\n                     * alternate chain\n                     */\n                    while (num > j) {\n                        xtmp = sk_X509_pop(ctx->chain);\n                        X509_free(xtmp);\n                        num--;\n                    }\n                    ctx->last_untrusted = sk_X509_num(ctx->chain);\n                    retry = 1;\n                    break;\n                }\n            }\n        }\n    } while (retry);\n\n    /* Is last certificate looked up self signed? */\n    if (!ctx->check_issued(ctx, x, x)) {\n        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n            if (ctx->last_untrusted >= num)\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n            else\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n            ctx->current_cert = x;\n        } else {\n\n            sk_X509_push(ctx->chain, chain_ss);\n            num++;\n            ctx->last_untrusted = num;\n            ctx->current_cert = chain_ss;\n            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n            chain_ss = NULL;\n        }\n\n        ctx->error_depth = num - 1;\n        bad_chain = 1;\n        ok = cb(0, ctx);\n        if (!ok)\n            goto end;\n    }\n\n    /* We have the chain complete: now we need to check its purpose */\n    ok = check_chain_extensions(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* Check name constraints */\n\n    ok = check_name_constraints(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* The chain extensions are OK: check trust */\n\n    if (param->trust > 0)\n        ok = check_trust(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* We may as well copy down any DSA parameters that are required */\n    X509_get_pubkey_parameters(NULL, ctx->chain);\n\n    /*\n     * Check revocation status: we do this after copying parameters because\n     * they may be needed for CRL signature verification.\n     */\n\n    ok = ctx->check_revocation(ctx);\n    if (!ok)\n        goto end;\n\n    /* At this point, we have a chain and need to verify it */\n    if (ctx->verify != NULL)\n        ok = ctx->verify(ctx);\n    else\n        ok = internal_verify(ctx);\n    if (!ok)\n        goto end;\n\n#ifndef OPENSSL_NO_RFC3779\n    /* RFC 3779 path validation, now that CRL check has been done */\n    ok = v3_asid_validate_path(ctx);\n    if (!ok)\n        goto end;\n    ok = v3_addr_validate_path(ctx);\n    if (!ok)\n        goto end;\n#endif\n\n    /* If we get this far evaluate policies */\n    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n        ok = ctx->check_policy(ctx);\n    if (!ok)\n        goto end;\n    if (0) {\n end:\n        X509_get_pubkey_parameters(NULL, ctx->chain);\n    }\n    if (sktmp != NULL)\n        sk_X509_free(sktmp);\n    if (chain_ss != NULL)\n        X509_free(chain_ss);\n    return ok;\n}",
  "diff_func": "@@ -168,7 +168,8 @@ static int test_alt_chains_cert_forgery(void)\n \n     i = X509_verify_cert(sctx);\n \n-    if(i == 0 && X509_STORE_CTX_get_error(sctx) == X509_V_ERR_INVALID_CA) {\n+    if(i == 0 && X509_STORE_CTX_get_error(sctx)\n+                 == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT) {\n         /* This is the result we were expecting: Test passed */\n         ret = 1;\n     }",
  "func": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n    int bad_chain = 0;\n    X509_VERIFY_PARAM *param = ctx->param;\n    int depth, i, ok = 0;\n    int num, j, retry;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    STACK_OF(X509) *sktmp = NULL;\n    if (ctx->cert == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n        return -1;\n    }\n    if (ctx->chain != NULL) {\n        /*\n         * This X509_STORE_CTX has already been used to verify a cert. We\n         * cannot do another one.\n         */\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    cb = ctx->verify_cb;\n\n    /*\n     * first we make sure the chain we are going to build is present and that\n     * the first entry is in place\n     */\n    if (((ctx->chain = sk_X509_new_null()) == NULL) ||\n        (!sk_X509_push(ctx->chain, ctx->cert))) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n    CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\n    ctx->last_untrusted = 1;\n\n    /* We use a temporary STACK so we can chop and hack at it */\n    if (ctx->untrusted != NULL\n        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    num = sk_X509_num(ctx->chain);\n    x = sk_X509_value(ctx->chain, num - 1);\n    depth = param->depth;\n\n    for (;;) {\n        /* If we have enough, we break */\n        if (depth < num)\n            break;              /* FIXME: If this happens, we should take\n                                 * note of it and, if appropriate, use the\n                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code\n                                 * later. */\n\n        /* If we are self signed, we break */\n        if (ctx->check_issued(ctx, x, x))\n            break;\n\n        /* If we were passed a cert chain, use it first */\n        if (ctx->untrusted != NULL) {\n            xtmp = find_issuer(ctx, sktmp, x);\n            if (xtmp != NULL) {\n                if (!sk_X509_push(ctx->chain, xtmp)) {\n                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                    goto end;\n                }\n                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n                (void)sk_X509_delete_ptr(sktmp, xtmp);\n                ctx->last_untrusted++;\n                x = xtmp;\n                num++;\n                /*\n                 * reparse the full chain for the next one\n                 */\n                continue;\n            }\n        }\n        break;\n    }\n\n    /* Remember how many untrusted certs we have */\n    j = num;\n    /*\n     * at this point, chain should contain a list of untrusted certificates.\n     * We now need to add at least one trusted one, if possible, otherwise we\n     * complain.\n     */\n\n    do {\n        /*\n         * Examine last certificate in chain and see if it is self signed.\n         */\n        i = sk_X509_num(ctx->chain);\n        x = sk_X509_value(ctx->chain, i - 1);\n        if (ctx->check_issued(ctx, x, x)) {\n            /* we have a self signed certificate */\n            if (sk_X509_num(ctx->chain) == 1) {\n                /*\n                 * We have a single self signed certificate: see if we can\n                 * find it in the store. We must have an exact match to avoid\n                 * possible impersonation.\n                 */\n                ok = ctx->get_issuer(&xtmp, ctx, x);\n                if ((ok <= 0) || X509_cmp(x, xtmp)) {\n                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n                    ctx->current_cert = x;\n                    ctx->error_depth = i - 1;\n                    if (ok == 1)\n                        X509_free(xtmp);\n                    bad_chain = 1;\n                    ok = cb(0, ctx);\n                    if (!ok)\n                        goto end;\n                } else {\n                    /*\n                     * We have a match: replace certificate with store\n                     * version so we get any trust settings.\n                     */\n                    X509_free(x);\n                    x = xtmp;\n                    (void)sk_X509_set(ctx->chain, i - 1, x);\n                    ctx->last_untrusted = 0;\n                }\n            } else {\n                /*\n                 * extract and save self signed certificate for later use\n                 */\n                chain_ss = sk_X509_pop(ctx->chain);\n                ctx->last_untrusted--;\n                num--;\n                j--;\n                x = sk_X509_value(ctx->chain, num - 1);\n            }\n        }\n        /* We now lookup certs from the certificate store */\n        for (;;) {\n            /* If we have enough, we break */\n            if (depth < num)\n                break;\n            /* If we are self signed, we break */\n            if (ctx->check_issued(ctx, x, x))\n                break;\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n            if (ok < 0)\n                return ok;\n            if (ok == 0)\n                break;\n            x = xtmp;\n            if (!sk_X509_push(ctx->chain, x)) {\n                X509_free(xtmp);\n                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n            num++;\n        }\n\n        /*\n         * If we haven't got a least one certificate from our store then check\n         * if there is an alternative chain that could be used.  We only do this\n         * if the user hasn't switched off alternate chain checking\n         */\n        retry = 0;\n        if (j == ctx->last_untrusted &&\n            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n            while (j-- > 1) {\n                xtmp2 = sk_X509_value(ctx->chain, j - 1);\n                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n                if (ok < 0)\n                    goto end;\n                /* Check if we found an alternate chain */\n                if (ok > 0) {\n                    /*\n                     * Free up the found cert we'll add it again later\n                     */\n                    X509_free(xtmp);\n\n                    /*\n                     * Dump all the certs above this point - we've found an\n                     * alternate chain\n                     */\n                    while (num > j) {\n                        xtmp = sk_X509_pop(ctx->chain);\n                        X509_free(xtmp);\n                        num--;\n                    }\n                    ctx->last_untrusted = sk_X509_num(ctx->chain);\n                    retry = 1;\n                    break;\n                }\n            }\n        }\n    } while (retry);\n\n    /* Is last certificate looked up self signed? */\n    if (!ctx->check_issued(ctx, x, x)) {\n        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n            if (ctx->last_untrusted >= num)\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n            else\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n            ctx->current_cert = x;\n        } else {\n\n            sk_X509_push(ctx->chain, chain_ss);\n            num++;\n            ctx->last_untrusted = num;\n            ctx->current_cert = chain_ss;\n            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n            chain_ss = NULL;\n        }\n\n        ctx->error_depth = num - 1;\n        bad_chain = 1;\n        ok = cb(0, ctx);\n        if (!ok)\n            goto end;\n    }\n\n    /* We have the chain complete: now we need to check its purpose */\n    ok = check_chain_extensions(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* Check name constraints */\n\n    ok = check_name_constraints(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* The chain extensions are OK: check trust */\n\n    if (param->trust > 0)\n        ok = check_trust(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* We may as well copy down any DSA parameters that are required */\n    X509_get_pubkey_parameters(NULL, ctx->chain);\n\n    /*\n     * Check revocation status: we do this after copying parameters because\n     * they may be needed for CRL signature verification.\n     */\n\n    ok = ctx->check_revocation(ctx);\n    if (!ok)\n        goto end;\n\n    /* At this point, we have a chain and need to verify it */\n    if (ctx->verify != NULL)\n        ok = ctx->verify(ctx);\n    else\n        ok = internal_verify(ctx);\n    if (!ok)\n        goto end;\n\n#ifndef OPENSSL_NO_RFC3779\n    /* RFC 3779 path validation, now that CRL check has been done */\n    ok = v3_asid_validate_path(ctx);\n    if (!ok)\n        goto end;\n    ok = v3_addr_validate_path(ctx);\n    if (!ok)\n        goto end;\n#endif\n\n    /* If we get this far evaluate policies */\n    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n        ok = ctx->check_policy(ctx);\n    if (!ok)\n        goto end;\n    if (0) {\n end:\n        X509_get_pubkey_parameters(NULL, ctx->chain);\n    }\n    if (sktmp != NULL)\n        sk_X509_free(sktmp);\n    if (chain_ss != NULL)\n        X509_free(chain_ss);\n    return ok;\n}",
  "target": 1,
  "project": "openssl",
  "commit_id": "cb22d2ae5a5b6069dbf66dbcce07223ac15a16de",
  "hash": 157510682266880135227270063780618680419,
  "size": 285,
  "message": "Fix alt chains bug\n\nThis is a follow up to the alternate chains certificate forgery issue\n(CVE-2015-1793). That issue is exacerbated in 1.0.1 by a related bug which\nmeans that we *always* check for an alternative chain, even if we have\nalready found a chain. The code is supposed to stop as soon as it has found\none (and does do in master and 1.0.2).\n\nReviewed-by: Stephen Henson <steve@openssl.org>",
  "dataset": "other",
  "idx": 216521,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by fixing a bug in certificate verification that could lead to forgery. The code change modifies error handling to correctly identify invalid certificates, preventing potential attacks.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}