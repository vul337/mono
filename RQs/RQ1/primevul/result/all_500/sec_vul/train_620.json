{
  "id": 620,
  "language": "c",
  "cwe": "CWE-310",
  "commit_url": "https://github.com/vkrasnov/multiprime/commit/ce325c60c74b0fa784f5872404b722e120e5cab0",
  "commit_sha": "ce325c60c74b0fa784f5872404b722e120e5cab0",
  "commit_msg": "Only allow ephemeral RSA keys in export ciphersuites.\n\nOpenSSL clients would tolerate temporary RSA keys in non-export\nciphersuites. It also had an option SSL_OP_EPHEMERAL_RSA which\nenabled this server side. Remove both options as they are a\nprotocol violation.\n\nThanks to Karthikeyan Bhargavan for reporting this issue.\n(CVE-2015-0204)\nReviewed-by: Matt Caswell <matt@openssl.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "ssl/d1_srvr.c",
  "func_name": "else",
  "raw_func_from_json": "int ssl3_get_key_exchange(SSL *s)\n\t{\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\n#endif\n\tEVP_MD_CTX md_ctx;\n\tunsigned char *param,*p;\n\tint al,j,ok;\n\tlong i,param_len,n,alg_k,alg_a;\n\tEVP_PKEY *pkey=NULL;\n\tconst EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n\tRSA *rsa=NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n\tDH *dh=NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *ecdh = NULL;\n\tBN_CTX *bn_ctx = NULL;\n\tEC_POINT *srvr_ecpoint = NULL;\n\tint curve_nid = 0;\n\tint encoded_pt_len = 0;\n#endif\n\n\tEVP_MD_CTX_init(&md_ctx);\n\n\t/* use same message size as in ssl3_get_certificate_request()\n\t * as ServerKeyExchange message may be skipped */\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_KEY_EXCH_A,\n\t\tSSL3_ST_CR_KEY_EXCH_B,\n\t\t-1,\n\t\ts->max_cert_list,\n\t\t&ok);\n\tif (!ok) return((int)n);\n\n\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n\n\tif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n\t\t{\n\t\t/*\n\t\t * Can't skip server key exchange if this is an ephemeral\n\t\t * ciphersuite.\n\t\t */\n\t\tif (alg_k & (SSL_kDHE|SSL_kECDHE))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tal = SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifndef OPENSSL_NO_PSK\n\t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n\t\t   omitted if no identity hint is sent. Set\n\t\t   session->sess_cert anyway to avoid problems\n\t\t   later.*/\n\t\tif (alg_k & SSL_kPSK)\n\t\t\t{\n\t\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t\tif (s->ctx->psk_identity_hint)\n\t\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\t\ts->ctx->psk_identity_hint = NULL;\n\t\t\t}\n#endif\n\t\ts->s3->tmp.reuse_message=1;\n\t\treturn(1);\n\t\t}\n\n\tparam=p=(unsigned char *)s->init_msg;\n\tif (s->session->sess_cert != NULL)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n\t\t\t{\n\t\t\tRSA_free(s->session->sess_cert->peer_rsa_tmp);\n\t\t\ts->session->sess_cert->peer_rsa_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\tif (s->session->sess_cert->peer_dh_tmp)\n\t\t\t{\n\t\t\tDH_free(s->session->sess_cert->peer_dh_tmp);\n\t\t\ts->session->sess_cert->peer_dh_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDH\n\t\tif (s->session->sess_cert->peer_ecdh_tmp)\n\t\t\t{\n\t\t\tEC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n\t\t\ts->session->sess_cert->peer_ecdh_tmp=NULL;\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t}\n\n\t/* Total length of the parameters including the length prefix */\n\tparam_len=0;\n\n\talg_a=s->s3->tmp.new_cipher->algorithm_auth;\n\n\tal=SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n\tif (alg_k & SSL_kPSK)\n\t\t{\n\t\tchar tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\t/* Store PSK identity hint for later use, hint is used\n\t\t * in ssl3_send_client_key_exchange.  Assume that the\n\t\t * maximum length of a PSK identity hint can be as\n\t\t * long as the maximum length of a PSK identity. */\n\t\tif (i > PSK_MAX_IDENTITY_LEN)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_DATA_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\t/* If received PSK identity hint contains NULL\n\t\t * characters, the hint is truncated from the first\n\t\t * NULL. p may not be ending with NULL, so create a\n\t\t * NULL-terminated string. */\n\t\tmemcpy(tmp_id_hint, p, i);\n\t\tmemset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);\n\t\tif (s->ctx->psk_identity_hint != NULL)\n\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\ts->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);\n\t\tif (s->ctx->psk_identity_hint == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n\t\t\tgoto f_err;\n\t\t\t}\t   \n\n\t\tp+=i;\n\t\tn-=param_len;\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n\tif (alg_k & SSL_kSRP)\n\t\t{\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (1 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 1;\n\n\t\ti = (unsigned int)(p[0]);\n\t\tp++;\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!srp_verify_server_param(s, &al))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n/* We must check if there is a certificate */\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_SRP */\n #ifndef OPENSSL_NO_RSA\n \tif (alg_k & SSL_kRSA)\n \t\t{\n \t\tif ((rsa=RSA_new()) == NULL)\n \t\t\t{\n \t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->n=BN_bin2bn(p,i,rsa->n)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->e=BN_bin2bn(p,i,rsa->e)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\t/* this should be because we are using an export cipher */\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->session->sess_cert->peer_rsa_tmp=rsa;\n\t\trsa=NULL;\n\t\t}\n#else /* OPENSSL_NO_RSA */\n\tif (0)\n\t\t;\n#endif\n#ifndef OPENSSL_NO_DH\n\telse if (alg_k & SSL_kDHE)\n\t\t{\n\t\tif ((dh=DH_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->p=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->pub_key=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!ssl_security(s, SSL_SECOP_TMP_DH,\n\t\t\t\t\t\tDH_security_bits(dh), 0, dh))\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t/* else anonymous DH, so no certificate or pkey. */\n\n\t\ts->session->sess_cert->peer_dh_tmp=dh;\n\t\tdh=NULL;\n\t\t}\n\telse if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n\telse if (alg_k & SSL_kECDHE)\n\t\t{\n\t\tEC_GROUP *ngroup;\n\t\tconst EC_GROUP *group;\n\n\t\tif ((ecdh=EC_KEY_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Extract elliptic curve parameters and the\n\t\t * server's ephemeral ECDH public key.\n\t\t * Keep accumulating lengths of various components in\n\t\t * param_len and make sure it never exceeds n.\n\t\t */\n\n\t\t/* XXX: For now we only support named (not generic) curves\n\t\t * and the ECParameters in this case is just three bytes. We\n\t\t * also need one byte for the length of the encoded point\n\t\t */\n\t\tparam_len=4;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Check curve is one of our preferences, if not server has\n\t\t * sent an invalid curve. ECParameters is 3 bytes.\n\t\t */\n\t\tif (!tls1_check_curve(s, p, 3))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) \n\t\t\t{\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tngroup = EC_GROUP_new_by_curve_name(curve_nid);\n\t\tif (ngroup == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (EC_KEY_set_group(ecdh, ngroup) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tEC_GROUP_free(ngroup);\n\n\t\tgroup = EC_KEY_get0_group(ecdh);\n\n\t\tif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n\t\t    (EC_GROUP_get_degree(group) > 163))\n\t\t\t{\n\t\t\tal=SSL_AD_EXPORT_RESTRICTION;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tp+=3;\n\n\t\t/* Next, get the encoded ECPoint */\n\t\tif (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n\t\t    ((bn_ctx = BN_CTX_new()) == NULL))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tencoded_pt_len = *p;  /* length of encoded point */\n\t\tp+=1;\n\n\t\tif ((encoded_pt_len > n - param_len) ||\n\t\t    (EC_POINT_oct2point(group, srvr_ecpoint, \n\t\t\tp, encoded_pt_len, bn_ctx) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += encoded_pt_len;\n\n\t\tn-=param_len;\n\t\tp+=encoded_pt_len;\n\n\t\t/* The ECC/TLS specification does not mention\n\t\t * the use of DSA to sign ECParameters in the server\n\t\t * key exchange message. We do support RSA and ECDSA.\n\t\t */\n\t\tif (0) ;\n#ifndef OPENSSL_NO_RSA\n\t\telse if (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\telse if (alg_a & SSL_aECDSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n#endif\n\t\t/* else anonymous ECDH, so no certificate or pkey. */\n\t\tEC_KEY_set_public_key(ecdh, srvr_ecpoint);\n\t\ts->session->sess_cert->peer_ecdh_tmp=ecdh;\n\t\tecdh=NULL;\n\t\tBN_CTX_free(bn_ctx);\n\t\tbn_ctx = NULL;\n\t\tEC_POINT_free(srvr_ecpoint);\n\t\tsrvr_ecpoint = NULL;\n\t\t}\n\telse if (alg_k)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\n\n\t/* p points to the next byte, there are 'n' bytes left */\n\n\t/* if it was signed, check the signature */\n\tif (pkey != NULL)\n\t\t{\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv;\n\t\t\tif (2 > n)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\trv = tls12_check_peer_sigalg(&md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\tgoto err;\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\telse\n\t\t\tmd = EVP_sha1();\n\n\t\tif (2 > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tj=EVP_PKEY_size(pkey);\n\n\t\t/* Check signature length. If n is 0 then signature is empty */\n\t\tif ((i != n) || (n > j) || (n <= 0))\n\t\t\t{\n\t\t\t/* wrong packet length */\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint num;\n\t\t\tunsigned int size;\n\n\t\t\tj=0;\n\t\t\tq=md_buf;\n\t\t\tfor (num=2; num > 0; num--)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_set_flags(&md_ctx,\n\t\t\t\t\tEVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n\t\t\t\tEVP_DigestInit_ex(&md_ctx,(num == 2)\n\t\t\t\t\t?s->ctx->md5:s->ctx->sha1, NULL);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,param,param_len);\n\t\t\t\tEVP_DigestFinal_ex(&md_ctx,q,&size);\n\t\t\t\tq+=size;\n\t\t\t\tj+=size;\n\t\t\t\t}\n\t\t\ti=RSA_verify(NID_md5_sha1, md_buf, j, p, n,\n\t\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\t\tif (i < 0)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n\t\t\tEVP_VerifyInit_ex(&md_ctx, md, NULL);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,param,param_len);\n\t\t\tif (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\t/* aNULL, aSRP or kPSK do not need public keys */\n\t\tif (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))\n\t\t\t{\n\t\t\t/* Might be wrong key type, check it */\n\t\t\tif (ssl3_check_cert_and_algorithm(s))\n\t\t\t\t/* Otherwise this shouldn't happen */\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t/* still data left over */\n\t\tif (n != 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\tEVP_PKEY_free(pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\tEVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n\tif (dh != NULL)\n\t\tDH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tEC_POINT_free(srvr_ecpoint);\n\tif (ecdh != NULL)\n\t\tEC_KEY_free(ecdh);\n#endif\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(-1);\n\t}\n",
  "diff_func": "@@ -472,24 +472,15 @@ int dtls1_accept(SSL *s)\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \t\t\t/* only send if a DH key exchange or\n \t\t\t * RSA but we have a sign only certificate */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK",
  "project": "openssl",
  "commit_id": "ce325c60c74b0fa784f5872404b722e120e5cab0",
  "target": 1,
  "func": "int ssl3_get_key_exchange(SSL *s)\n\t{\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\n#endif\n\tEVP_MD_CTX md_ctx;\n\tunsigned char *param,*p;\n\tint al,j,ok;\n\tlong i,param_len,n,alg_k,alg_a;\n\tEVP_PKEY *pkey=NULL;\n\tconst EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n\tRSA *rsa=NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n\tDH *dh=NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *ecdh = NULL;\n\tBN_CTX *bn_ctx = NULL;\n\tEC_POINT *srvr_ecpoint = NULL;\n\tint curve_nid = 0;\n\tint encoded_pt_len = 0;\n#endif\n\n\tEVP_MD_CTX_init(&md_ctx);\n\n\t/* use same message size as in ssl3_get_certificate_request()\n\t * as ServerKeyExchange message may be skipped */\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_KEY_EXCH_A,\n\t\tSSL3_ST_CR_KEY_EXCH_B,\n\t\t-1,\n\t\ts->max_cert_list,\n\t\t&ok);\n\tif (!ok) return((int)n);\n\n\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n\n\tif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n\t\t{\n\t\t/*\n\t\t * Can't skip server key exchange if this is an ephemeral\n\t\t * ciphersuite.\n\t\t */\n\t\tif (alg_k & (SSL_kDHE|SSL_kECDHE))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tal = SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifndef OPENSSL_NO_PSK\n\t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n\t\t   omitted if no identity hint is sent. Set\n\t\t   session->sess_cert anyway to avoid problems\n\t\t   later.*/\n\t\tif (alg_k & SSL_kPSK)\n\t\t\t{\n\t\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t\tif (s->ctx->psk_identity_hint)\n\t\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\t\ts->ctx->psk_identity_hint = NULL;\n\t\t\t}\n#endif\n\t\ts->s3->tmp.reuse_message=1;\n\t\treturn(1);\n\t\t}\n\n\tparam=p=(unsigned char *)s->init_msg;\n\tif (s->session->sess_cert != NULL)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n\t\t\t{\n\t\t\tRSA_free(s->session->sess_cert->peer_rsa_tmp);\n\t\t\ts->session->sess_cert->peer_rsa_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\tif (s->session->sess_cert->peer_dh_tmp)\n\t\t\t{\n\t\t\tDH_free(s->session->sess_cert->peer_dh_tmp);\n\t\t\ts->session->sess_cert->peer_dh_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDH\n\t\tif (s->session->sess_cert->peer_ecdh_tmp)\n\t\t\t{\n\t\t\tEC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n\t\t\ts->session->sess_cert->peer_ecdh_tmp=NULL;\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t}\n\n\t/* Total length of the parameters including the length prefix */\n\tparam_len=0;\n\n\talg_a=s->s3->tmp.new_cipher->algorithm_auth;\n\n\tal=SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n\tif (alg_k & SSL_kPSK)\n\t\t{\n\t\tchar tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\t/* Store PSK identity hint for later use, hint is used\n\t\t * in ssl3_send_client_key_exchange.  Assume that the\n\t\t * maximum length of a PSK identity hint can be as\n\t\t * long as the maximum length of a PSK identity. */\n\t\tif (i > PSK_MAX_IDENTITY_LEN)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_DATA_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\t/* If received PSK identity hint contains NULL\n\t\t * characters, the hint is truncated from the first\n\t\t * NULL. p may not be ending with NULL, so create a\n\t\t * NULL-terminated string. */\n\t\tmemcpy(tmp_id_hint, p, i);\n\t\tmemset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);\n\t\tif (s->ctx->psk_identity_hint != NULL)\n\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\ts->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);\n\t\tif (s->ctx->psk_identity_hint == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n\t\t\tgoto f_err;\n\t\t\t}\t   \n\n\t\tp+=i;\n\t\tn-=param_len;\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n\tif (alg_k & SSL_kSRP)\n\t\t{\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (1 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 1;\n\n\t\ti = (unsigned int)(p[0]);\n\t\tp++;\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!srp_verify_server_param(s, &al))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n/* We must check if there is a certificate */\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_SRP */\n #ifndef OPENSSL_NO_RSA\n \tif (alg_k & SSL_kRSA)\n \t\t{\n \t\tif ((rsa=RSA_new()) == NULL)\n \t\t\t{\n \t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->n=BN_bin2bn(p,i,rsa->n)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->e=BN_bin2bn(p,i,rsa->e)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\t/* this should be because we are using an export cipher */\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->session->sess_cert->peer_rsa_tmp=rsa;\n\t\trsa=NULL;\n\t\t}\n#else /* OPENSSL_NO_RSA */\n\tif (0)\n\t\t;\n#endif\n#ifndef OPENSSL_NO_DH\n\telse if (alg_k & SSL_kDHE)\n\t\t{\n\t\tif ((dh=DH_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->p=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->pub_key=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!ssl_security(s, SSL_SECOP_TMP_DH,\n\t\t\t\t\t\tDH_security_bits(dh), 0, dh))\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t/* else anonymous DH, so no certificate or pkey. */\n\n\t\ts->session->sess_cert->peer_dh_tmp=dh;\n\t\tdh=NULL;\n\t\t}\n\telse if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n\telse if (alg_k & SSL_kECDHE)\n\t\t{\n\t\tEC_GROUP *ngroup;\n\t\tconst EC_GROUP *group;\n\n\t\tif ((ecdh=EC_KEY_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Extract elliptic curve parameters and the\n\t\t * server's ephemeral ECDH public key.\n\t\t * Keep accumulating lengths of various components in\n\t\t * param_len and make sure it never exceeds n.\n\t\t */\n\n\t\t/* XXX: For now we only support named (not generic) curves\n\t\t * and the ECParameters in this case is just three bytes. We\n\t\t * also need one byte for the length of the encoded point\n\t\t */\n\t\tparam_len=4;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Check curve is one of our preferences, if not server has\n\t\t * sent an invalid curve. ECParameters is 3 bytes.\n\t\t */\n\t\tif (!tls1_check_curve(s, p, 3))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) \n\t\t\t{\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tngroup = EC_GROUP_new_by_curve_name(curve_nid);\n\t\tif (ngroup == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (EC_KEY_set_group(ecdh, ngroup) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tEC_GROUP_free(ngroup);\n\n\t\tgroup = EC_KEY_get0_group(ecdh);\n\n\t\tif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n\t\t    (EC_GROUP_get_degree(group) > 163))\n\t\t\t{\n\t\t\tal=SSL_AD_EXPORT_RESTRICTION;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tp+=3;\n\n\t\t/* Next, get the encoded ECPoint */\n\t\tif (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n\t\t    ((bn_ctx = BN_CTX_new()) == NULL))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tencoded_pt_len = *p;  /* length of encoded point */\n\t\tp+=1;\n\n\t\tif ((encoded_pt_len > n - param_len) ||\n\t\t    (EC_POINT_oct2point(group, srvr_ecpoint, \n\t\t\tp, encoded_pt_len, bn_ctx) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += encoded_pt_len;\n\n\t\tn-=param_len;\n\t\tp+=encoded_pt_len;\n\n\t\t/* The ECC/TLS specification does not mention\n\t\t * the use of DSA to sign ECParameters in the server\n\t\t * key exchange message. We do support RSA and ECDSA.\n\t\t */\n\t\tif (0) ;\n#ifndef OPENSSL_NO_RSA\n\t\telse if (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\telse if (alg_a & SSL_aECDSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n#endif\n\t\t/* else anonymous ECDH, so no certificate or pkey. */\n\t\tEC_KEY_set_public_key(ecdh, srvr_ecpoint);\n\t\ts->session->sess_cert->peer_ecdh_tmp=ecdh;\n\t\tecdh=NULL;\n\t\tBN_CTX_free(bn_ctx);\n\t\tbn_ctx = NULL;\n\t\tEC_POINT_free(srvr_ecpoint);\n\t\tsrvr_ecpoint = NULL;\n\t\t}\n\telse if (alg_k)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\n\n\t/* p points to the next byte, there are 'n' bytes left */\n\n\t/* if it was signed, check the signature */\n\tif (pkey != NULL)\n\t\t{\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv;\n\t\t\tif (2 > n)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\trv = tls12_check_peer_sigalg(&md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\tgoto err;\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\telse\n\t\t\tmd = EVP_sha1();\n\n\t\tif (2 > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tj=EVP_PKEY_size(pkey);\n\n\t\t/* Check signature length. If n is 0 then signature is empty */\n\t\tif ((i != n) || (n > j) || (n <= 0))\n\t\t\t{\n\t\t\t/* wrong packet length */\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint num;\n\t\t\tunsigned int size;\n\n\t\t\tj=0;\n\t\t\tq=md_buf;\n\t\t\tfor (num=2; num > 0; num--)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_set_flags(&md_ctx,\n\t\t\t\t\tEVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n\t\t\t\tEVP_DigestInit_ex(&md_ctx,(num == 2)\n\t\t\t\t\t?s->ctx->md5:s->ctx->sha1, NULL);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,param,param_len);\n\t\t\t\tEVP_DigestFinal_ex(&md_ctx,q,&size);\n\t\t\t\tq+=size;\n\t\t\t\tj+=size;\n\t\t\t\t}\n\t\t\ti=RSA_verify(NID_md5_sha1, md_buf, j, p, n,\n\t\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\t\tif (i < 0)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n\t\t\tEVP_VerifyInit_ex(&md_ctx, md, NULL);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,param,param_len);\n\t\t\tif (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\t/* aNULL, aSRP or kPSK do not need public keys */\n\t\tif (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))\n\t\t\t{\n\t\t\t/* Might be wrong key type, check it */\n\t\t\tif (ssl3_check_cert_and_algorithm(s))\n\t\t\t\t/* Otherwise this shouldn't happen */\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t/* still data left over */\n\t\tif (n != 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\tEVP_PKEY_free(pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\tEVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n\tif (dh != NULL)\n\t\tDH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tEC_POINT_free(srvr_ecpoint);\n\tif (ecdh != NULL)\n\t\tEC_KEY_free(ecdh);\n#endif\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(-1);\n\t}\n",
  "big_vul_idx": 179924,
  "idx": 1586,
  "hash": 19329931296243780979852259158361896486,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by removing support for ephemeral RSA keys in non-export ciphersuites, which was a protocol violation. The changes directly fix the issue referenced by CVE-2015-0204, confirming it as a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}