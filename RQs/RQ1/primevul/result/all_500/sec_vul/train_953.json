{
  "id": 953,
  "language": "c",
  "cwe": "CWE-125",
  "commit_url": "https://github.com/merlinepedra/TCPDUMP/commit/8512734883227c11568bb35da1d48b9f8466f43f",
  "commit_sha": "8512734883227c11568bb35da1d48b9f8466f43f",
  "commit_msg": "CVE-2017-13000/IEEE 802.15.4: Fix bug introduced two fixes prior.\n\nWe've already advanced the pointer past the PAN ID, if present; it now\npoints to the address, so don't add 2 to it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti LevomÃ¤ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
  "pr_url": null,
  "pr_info": null,
  "file_name": "print-802_15_4.c",
  "func_name": "",
  "raw_func_from_json": "ieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n \t\t\treturn hdrlen;\n \t\t}\n \t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n \t\tp += 2;\n \t\tcaplen -= 2;\n \t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
  "diff_func": "@@ -122,7 +122,7 @@ ieee802_15_4_if_print(netdissect_options *ndo,\n \t\t\treturn hdrlen;\n \t\t}\n \t\tif (ndo->ndo_vflag)\n-\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n+\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n \t\tp += 2;\n \t\tcaplen -= 2;\n \t\thdrlen += 2;",
  "project": "tcpdump",
  "commit_id": "8512734883227c11568bb35da1d48b9f8466f43f",
  "target": 1,
  "func": "ieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n \t\t\treturn hdrlen;\n \t\t}\n \t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n \t\tp += 2;\n \t\tcaplen -= 2;\n \t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
  "big_vul_idx": 181079,
  "idx": 2595,
  "hash": 226608746932513567177224896690679480708,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a buffer over-read vulnerability, which is a security issue. The code change corrects pointer arithmetic to prevent unauthorized data access, confirming it as a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}