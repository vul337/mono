{
  "id": 257,
  "language": "c",
  "cwe": "CWE-264",
  "commit_url": "https://github.com/tizenorg/platform.upstream.enlightenment/commit/666df815cd86a50343859bce36c5cf968c5f38b0",
  "commit_sha": "666df815cd86a50343859bce36c5cf968c5f38b0",
  "commit_msg": "e_sys - address security concerns with environment - more\n\nadd more environment variables to nuke and add alternate envrionment\nnuke method to raise security level.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/bin/e_sys_main.c",
  "func_name": "else",
  "raw_func_from_json": "main(int argc,\n     char **argv)\n{\n   int i, gn;\n   int test = 0;\n   char *action = NULL, *cmd;\n   char *output = NULL;\n#ifdef HAVE_EEZE_MOUNT\n   Eina_Bool mnt = EINA_FALSE;\n   const char *act;\n#endif\n   gid_t gid, gl[65536], egid;\n\n   for (i = 1; i < argc; i++)\n     {\n        if ((!strcmp(argv[i], \"-h\")) ||\n            (!strcmp(argv[i], \"-help\")) ||\n            (!strcmp(argv[i], \"--help\")))\n          {\n             printf(\n               \"This is an internal tool for Enlightenment.\\n\"\n               \"do not use it.\\n\"\n               );\n             exit(0);\n          }\n     }\n   if (argc >= 3)\n     {\n        if ((argc == 3) && (!strcmp(argv[1], \"-t\")))\n          {\n             test = 1;\n             action = argv[2];\n          }\n\telse if (!strcmp(argv[1], \"l2ping\"))\n\t  {\n\t     action = argv[1];\n\t     output = argv[2];\n\t  }\n#ifdef HAVE_EEZE_MOUNT\n        else\n          {\n             const char *s;\n\n             s = strrchr(argv[1], '/');\n             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */\n             s++;\n             if (strcmp(s, \"mount\") && strcmp(s, \"umount\") && strcmp(s, \"eject\")) exit(1);\n             mnt = EINA_TRUE;\n             act = s;\n             action = argv[1];\n          }\n#endif\n     }\n   else if (argc == 2)\n     {\n        action = argv[1];\n     }\n   else\n     {\n        exit(1);\n     }\n   if (!action) exit(1);\n   fprintf(stderr, \"action %s %i\\n\", action, argc);\n\n   uid = getuid();\n   gid = getgid();\n   egid = getegid();\n   gn = getgroups(65536, gl);\n   if (gn < 0)\n     {\n        printf(\"ERROR: MEMBER OF MORE THAN 65536 GROUPS\\n\");\n        exit(3);\n     }\n   if (setuid(0) != 0)\n     {\n        printf(\"ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\\n\");\n        exit(5);\n     }\n   if (setgid(0) != 0)\n     {\n        printf(\"ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\\n\");\n        exit(7);\n     }\n\n   eina_init();\n\n   if (!auth_action_ok(action, gid, gl, gn, egid))\n     {\n        printf(\"ERROR: ACTION NOT ALLOWED: %s\\n\", action);\n        exit(10);\n     }\n   /* we can add more levels of auth here */\n\n   /* when mounting, this will match the exact path to the exe,\n    * as required in sysactions.conf\n    * this is intentionally pedantic for security\n    */\n   cmd = eina_hash_find(actions, action);\n   if (!cmd)\n     {\n        printf(\"ERROR: UNDEFINED ACTION: %s\\n\", action);\n        exit(20);\n     }\n\n   if (!test && !strcmp(action, \"l2ping\"))\n     {\n        char tmp[128];\n\tdouble latency;\n\n\tlatency = e_sys_l2ping(output);\n\n\teina_convert_dtoa(latency, tmp);\n\tfputs(tmp, stdout);\n\n\treturn (latency < 0) ? 1 : 0;\n     }\n   /* sanitize environment */\n#ifdef HAVE_UNSETENV\n# define NOENV(x) unsetenv(x)\n#else\n# define NOENV(x)\n#endif\n   NOENV(\"IFS\");\n    /* sanitize environment */\n #ifdef HAVE_UNSETENV\n # define NOENV(x) unsetenv(x)\n#else\n# define NOENV(x)\n#endif\n    NOENV(\"IFS\");\n    NOENV(\"LD_PRELOAD\");\n   NOENV(\"PYTHONPATH\");\n    NOENV(\"LD_LIBRARY_PATH\");\n #ifdef HAVE_CLEARENV\n     clearenv();\n #endif\n   /* set path and ifs to minimal defaults */\n    putenv(\"PATH=/bin:/usr/bin\");\n    putenv(\"IFS= \\t\\n\");\n   const char *p;\n   char *end;\n   unsigned long muid;\n   Eina_Bool nosuid, nodev, noexec, nuid;\n\n   nosuid = nodev = noexec = nuid = EINA_FALSE;\n\n   /* these are the only possible options which can be present here; check them strictly */\n   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;\n   for (p = buf; p && p[1]; p = strchr(p + 1, ','))\n     {\n        if (p[0] == ',') p++;\n#define CMP(OPT) \\\n  if (!strncmp(p, OPT, sizeof(OPT) - 1))\n\n        CMP(\"nosuid,\")\n        {\n           nosuid = EINA_TRUE;\n           continue;\n        }\n        CMP(\"nodev,\")\n        {\n           nodev = EINA_TRUE;\n           continue;\n        }\n        CMP(\"noexec,\")\n        {\n           noexec = EINA_TRUE;\n           continue;\n        }\n        CMP(\"utf8,\") continue;\n        CMP(\"utf8=0,\") continue;\n        CMP(\"utf8=1,\") continue;\n        CMP(\"iocharset=utf8,\") continue;\n        CMP(\"uid=\")\n        {\n           p += 4;\n           errno = 0;\n           muid = strtoul(p, &end, 10);\n           if (muid == ULONG_MAX) return EINA_FALSE;\n           if (errno) return EINA_FALSE;\n           if (end[0] != ',') return EINA_FALSE;\n           if (muid != uid) return EINA_FALSE;\n           nuid = EINA_TRUE;\n           continue;\n        }\n        return EINA_FALSE;\n     }\n   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;\n   return EINA_TRUE;\n}\n",
  "diff_func": "@@ -8,6 +8,9 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n+#ifdef HAVE_ENVIRON\n+# define _GNU_SOURCE 1\n+#endif\n #include <unistd.h>\n #include <string.h>\n #include <sys/types.h>\n@@ -22,6 +25,10 @@\n #endif\n #include <Eina.h>\n \n+#ifdef HAVE_ENVIRON\n+extern char **environ;\n+#endif\n+\n double e_sys_l2ping(const char *bluetooth_mac);\n \n /* local subsystem functions */\n@@ -166,17 +173,111 @@ main(int argc,\n    /* sanitize environment */\n #ifdef HAVE_UNSETENV\n # define NOENV(x) unsetenv(x)\n-#else\n-# define NOENV(x)\n-#endif\n+   /* pass 1 - just nuke known dangerous env vars brutally if possible via\n+    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */\n    NOENV(\"IFS\");\n+   NOENV(\"CDPATH\");\n+   NOENV(\"LOCALDOMAIN\");\n+   NOENV(\"RES_OPTIONS\");\n+   NOENV(\"HOSTALIASES\");\n+   NOENV(\"NLSPATH\");\n+   NOENV(\"PATH_LOCALE\");\n+   NOENV(\"COLORTERM\");\n+   NOENV(\"LANG\");\n+   NOENV(\"LANGUAGE\");\n+   NOENV(\"LINGUAS\");\n+   NOENV(\"TERM\");\n    NOENV(\"LD_PRELOAD\");\n-   NOENV(\"PYTHONPATH\");\n    NOENV(\"LD_LIBRARY_PATH\");\n+   NOENV(\"SHLIB_PATH\");\n+   NOENV(\"LIBPATH\");\n+   NOENV(\"AUTHSTATE\");\n+   NOENV(\"DYLD_*\");\n+   NOENV(\"KRB_CONF*\");\n+   NOENV(\"KRBCONFDIR\");\n+   NOENV(\"KRBTKFILE\");\n+   NOENV(\"KRB5_CONFIG*\");\n+   NOENV(\"KRB5_KTNAME\");\n+   NOENV(\"VAR_ACE\");\n+   NOENV(\"USR_ACE\");\n+   NOENV(\"DLC_ACE\");\n+   NOENV(\"TERMINFO\");\n+   NOENV(\"TERMINFO_DIRS\");\n+   NOENV(\"TERMPATH\");\n+   NOENV(\"TERMCAP\");\n+   NOENV(\"ENV\");\n+   NOENV(\"BASH_ENV\");\n+   NOENV(\"PS4\");\n+   NOENV(\"GLOBIGNORE\");\n+   NOENV(\"SHELLOPTS\");\n+   NOENV(\"JAVA_TOOL_OPTIONS\");\n+   NOENV(\"PERLIO_DEBUG\");\n+   NOENV(\"PERLLIB\");\n+   NOENV(\"PERL5LIB\");\n+   NOENV(\"PERL5OPT\");\n+   NOENV(\"PERL5DB\");\n+   NOENV(\"FPATH\");\n+   NOENV(\"NULLCMD\");\n+   NOENV(\"READNULLCMD\");\n+   NOENV(\"ZDOTDIR\");\n+   NOENV(\"TMPPREFIX\");\n+   NOENV(\"PYTHONPATH\");\n+   NOENV(\"PYTHONHOME\");\n+   NOENV(\"PYTHONINSPECT\");\n+   NOENV(\"RUBYLIB\");\n+   NOENV(\"RUBYOPT\");\n+# ifdef HAVE_ENVIRON\n+   if (environ)\n+     {\n+        int again;\n+        char *tmp, *p;\n+\n+        /* go over environment array again and again... safely */\n+        do\n+          {\n+             again = 0;\n+\n+             /* walk through and find first entry that we don't like */\n+             for (i = 0; environ[i]; i++)\n+               {\n+                  /* if it begins with any of these, it's possibly nasty */\n+                  if ((!strncmp(environ[i], \"LD_\", 3)) ||\n+                      (!strncmp(environ[i], \"_RLD_\", 5)) ||\n+                      (!strncmp(environ[i], \"LC_\", 3)) ||\n+                      (!strncmp(environ[i], \"LDR_\", 3)))\n+                    {\n+                       /* unset it */\n+                       tmp = strdup(environ[i]);\n+                       if (!tmp) abort();\n+                       p = strchr(tmp, '=');\n+                       if (!p) abort();\n+                       *p = 0;\n+                       NOENV(p);\n+                       free(tmp);\n+                       /* and mark our do to try again from the start in case\n+                        * unsetenv changes environ ptr */\n+                       again = 1;\n+                       break;\n+                    }\n+               }\n+          }\n+        while (again);\n+     }\n+# endif\n+#endif\n+\n+   /* pass 2 - clear entire environment so it doesn't exist at all. if you\n+    * can't do this... you're possibly in trouble... but the worst is still\n+    * fixed in pass 3 */\n #ifdef HAVE_CLEARENV\n-     clearenv();\n+   clearenv();\n+#else\n+# ifdef HAVE_ENVIRON\n+   environ = NULL;\n+# endif\n #endif\n-   /* set path and ifs to minimal defaults */\n+\n+   /* pass 3 - set path and ifs to minimal defaults */\n    putenv(\"PATH=/bin:/usr/bin\");\n    putenv(\"IFS= \\t\\n\");\n ",
  "project": "enlightment",
  "commit_id": "666df815cd86a50343859bce36c5cf968c5f38b0",
  "target": 1,
  "func": "main(int argc,\n     char **argv)\n{\n   int i, gn;\n   int test = 0;\n   char *action = NULL, *cmd;\n   char *output = NULL;\n#ifdef HAVE_EEZE_MOUNT\n   Eina_Bool mnt = EINA_FALSE;\n   const char *act;\n#endif\n   gid_t gid, gl[65536], egid;\n\n   for (i = 1; i < argc; i++)\n     {\n        if ((!strcmp(argv[i], \"-h\")) ||\n            (!strcmp(argv[i], \"-help\")) ||\n            (!strcmp(argv[i], \"--help\")))\n          {\n             printf(\n               \"This is an internal tool for Enlightenment.\\n\"\n               \"do not use it.\\n\"\n               );\n             exit(0);\n          }\n     }\n   if (argc >= 3)\n     {\n        if ((argc == 3) && (!strcmp(argv[1], \"-t\")))\n          {\n             test = 1;\n             action = argv[2];\n          }\n\telse if (!strcmp(argv[1], \"l2ping\"))\n\t  {\n\t     action = argv[1];\n\t     output = argv[2];\n\t  }\n#ifdef HAVE_EEZE_MOUNT\n        else\n          {\n             const char *s;\n\n             s = strrchr(argv[1], '/');\n             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */\n             s++;\n             if (strcmp(s, \"mount\") && strcmp(s, \"umount\") && strcmp(s, \"eject\")) exit(1);\n             mnt = EINA_TRUE;\n             act = s;\n             action = argv[1];\n          }\n#endif\n     }\n   else if (argc == 2)\n     {\n        action = argv[1];\n     }\n   else\n     {\n        exit(1);\n     }\n   if (!action) exit(1);\n   fprintf(stderr, \"action %s %i\\n\", action, argc);\n\n   uid = getuid();\n   gid = getgid();\n   egid = getegid();\n   gn = getgroups(65536, gl);\n   if (gn < 0)\n     {\n        printf(\"ERROR: MEMBER OF MORE THAN 65536 GROUPS\\n\");\n        exit(3);\n     }\n   if (setuid(0) != 0)\n     {\n        printf(\"ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\\n\");\n        exit(5);\n     }\n   if (setgid(0) != 0)\n     {\n        printf(\"ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\\n\");\n        exit(7);\n     }\n\n   eina_init();\n\n   if (!auth_action_ok(action, gid, gl, gn, egid))\n     {\n        printf(\"ERROR: ACTION NOT ALLOWED: %s\\n\", action);\n        exit(10);\n     }\n   /* we can add more levels of auth here */\n\n   /* when mounting, this will match the exact path to the exe,\n    * as required in sysactions.conf\n    * this is intentionally pedantic for security\n    */\n   cmd = eina_hash_find(actions, action);\n   if (!cmd)\n     {\n        printf(\"ERROR: UNDEFINED ACTION: %s\\n\", action);\n        exit(20);\n     }\n\n   if (!test && !strcmp(action, \"l2ping\"))\n     {\n        char tmp[128];\n\tdouble latency;\n\n\tlatency = e_sys_l2ping(output);\n\n\teina_convert_dtoa(latency, tmp);\n\tfputs(tmp, stdout);\n\n\treturn (latency < 0) ? 1 : 0;\n     }\n   /* sanitize environment */\n#ifdef HAVE_UNSETENV\n# define NOENV(x) unsetenv(x)\n#else\n# define NOENV(x)\n#endif\n   NOENV(\"IFS\");\n    /* sanitize environment */\n #ifdef HAVE_UNSETENV\n # define NOENV(x) unsetenv(x)\n#else\n# define NOENV(x)\n#endif\n    NOENV(\"IFS\");\n    NOENV(\"LD_PRELOAD\");\n   NOENV(\"PYTHONPATH\");\n    NOENV(\"LD_LIBRARY_PATH\");\n #ifdef HAVE_CLEARENV\n     clearenv();\n #endif\n   /* set path and ifs to minimal defaults */\n    putenv(\"PATH=/bin:/usr/bin\");\n    putenv(\"IFS= \\t\\n\");\n   const char *p;\n   char *end;\n   unsigned long muid;\n   Eina_Bool nosuid, nodev, noexec, nuid;\n\n   nosuid = nodev = noexec = nuid = EINA_FALSE;\n\n   /* these are the only possible options which can be present here; check them strictly */\n   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;\n   for (p = buf; p && p[1]; p = strchr(p + 1, ','))\n     {\n        if (p[0] == ',') p++;\n#define CMP(OPT) \\\n  if (!strncmp(p, OPT, sizeof(OPT) - 1))\n\n        CMP(\"nosuid,\")\n        {\n           nosuid = EINA_TRUE;\n           continue;\n        }\n        CMP(\"nodev,\")\n        {\n           nodev = EINA_TRUE;\n           continue;\n        }\n        CMP(\"noexec,\")\n        {\n           noexec = EINA_TRUE;\n           continue;\n        }\n        CMP(\"utf8,\") continue;\n        CMP(\"utf8=0,\") continue;\n        CMP(\"utf8=1,\") continue;\n        CMP(\"iocharset=utf8,\") continue;\n        CMP(\"uid=\")\n        {\n           p += 4;\n           errno = 0;\n           muid = strtoul(p, &end, 10);\n           if (muid == ULONG_MAX) return EINA_FALSE;\n           if (errno) return EINA_FALSE;\n           if (end[0] != ',') return EINA_FALSE;\n           if (muid != uid) return EINA_FALSE;\n           nuid = EINA_TRUE;\n           continue;\n        }\n        return EINA_FALSE;\n     }\n   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;\n   return EINA_TRUE;\n}\n",
  "big_vul_idx": 178685,
  "idx": 563,
  "hash": 300699053216122192196495428322166073677,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses security concerns by sanitizing environment variables to prevent potential exploitation. It removes several environment variables known to pose security risks and implements a thorough cleanup process.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}