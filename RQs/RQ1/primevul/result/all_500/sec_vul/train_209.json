{
  "id": 209,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/dlespiau/xserver/commit/ec9c97c6bf70b523bc500bd3adf62176f1bb33a4",
  "commit_sha": "ec9c97c6bf70b523bc500bd3adf62176f1bb33a4",
  "commit_msg": "glx: validate request lengths\n\nReviewed-by: Adam Jackson <ajax@redhat.com>\nReviewed-by: Kristian HÃ¸gsberg <krh@bitplanet.net>\nReviewed-by: Daniel Stone <daniel@fooishbar.org>\nSigned-off-by: Julien Cristau <jcristau@debian.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "glx/glxcmds.c",
  "func_name": "",
  "raw_func_from_json": " int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n\t\t\t   config, pGlxScreen, req->isDirect);\n}\n",
  "diff_func": "@@ -314,11 +314,14 @@ DoCreateContext(__GLXclientState *cl, GLXContextID gcId,\n \n int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateContextReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n@@ -330,11 +333,14 @@ int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreateNewContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateNewContextReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n@@ -346,12 +352,15 @@ int __glXDisp_CreateNewContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateContextWithConfigSGIXReq *req = \n \t(xGLXCreateContextWithConfigSGIXReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateContextWithConfigSGIXReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n@@ -362,10 +371,13 @@ int __glXDisp_CreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n }\n int __glXDisp_DestroyContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) pc;\n     __GLXcontext *glxc;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyContextReq);\n+\n     if (!validGlxContext(cl->client, req->context, DixDestroyAccess,\n \t\t\t &glxc, &err))\n \t    return err;\n@@ -685,24 +697,33 @@ DoMakeCurrent(__GLXclientState *cl,\n \n int __glXDisp_MakeCurrent(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeCurrentReq);\n+\n     return DoMakeCurrent( cl, req->drawable, req->drawable,\n \t\t\t  req->context, req->oldContextTag );\n }\n \n int __glXDisp_MakeContextCurrent(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeContextCurrentReq);\n+\n     return DoMakeCurrent( cl, req->drawable, req->readdrawable,\n \t\t\t  req->context, req->oldContextTag );\n }\n \n int __glXDisp_MakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeCurrentReadSGIReq);\n+\n     return DoMakeCurrent( cl, req->drawable, req->readable,\n \t\t\t  req->context, req->oldContextTag );\n }\n@@ -715,6 +736,8 @@ int __glXDisp_IsDirect(__GLXclientState *cl, GLbyte *pc)\n     __GLXcontext *glxc;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXIsDirectReq);\n+\n     if (!validGlxContext(cl->client, req->context, DixReadAccess, &glxc, &err))\n \treturn err;\n \n@@ -739,6 +762,8 @@ int __glXDisp_QueryVersion(__GLXclientState *cl, GLbyte *pc)\n     xGLXQueryVersionReply reply;\n     GLuint major, minor;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryVersionReq);\n+\n     major = req->majorVersion;\n     minor = req->minorVersion;\n     (void)major;\n@@ -765,11 +790,15 @@ int __glXDisp_QueryVersion(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_WaitGL(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXWaitGLReq *req = (xGLXWaitGLReq *)pc;\n-    GLXContextTag tag = req->contextTag;\n+    GLXContextTag tag;\n     __GLXcontext *glxc = NULL;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXWaitGLReq);\n+\n+    tag = req->contextTag;\n     if (tag) {\n \tglxc = __glXLookupContextByTag(cl, tag);\n \tif (!glxc)\n@@ -789,11 +818,15 @@ int __glXDisp_WaitGL(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_WaitX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXWaitXReq *req = (xGLXWaitXReq *)pc;\n-    GLXContextTag tag = req->contextTag;\n+    GLXContextTag tag;\n     __GLXcontext *glxc = NULL;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXWaitXReq);\n+\n+    tag = req->contextTag;\n     if (tag) {\n \tglxc = __glXLookupContextByTag(cl, tag);\n \tif (!glxc)\n@@ -813,13 +846,19 @@ int __glXDisp_CopyContext(__GLXclientState *cl, GLbyte *pc)\n {\n     ClientPtr client = cl->client;\n     xGLXCopyContextReq *req = (xGLXCopyContextReq *) pc;\n-    GLXContextID source = req->source;\n-    GLXContextID dest = req->dest;\n-    GLXContextTag tag = req->contextTag;\n-    unsigned long mask = req->mask;\n+    GLXContextID source;\n+    GLXContextID dest;\n+    GLXContextTag tag;\n+    unsigned long mask;\n     __GLXcontext *src, *dst;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXCopyContextReq);\n+\n+    source = req->source;\n+    dest = req->dest;\n+    tag = req->contextTag;\n+    mask = req->mask;\n     if (!validGlxContext(cl->client, source, DixReadAccess, &src, &error))\n \treturn error;\n     if (!validGlxContext(cl->client, dest, DixWriteAccess, &dst, &error))\n@@ -902,6 +941,8 @@ int __glXDisp_GetVisualConfigs(__GLXclientState *cl, GLbyte *pc)\n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXGetVisualConfigsReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n \n@@ -1081,13 +1122,17 @@ DoGetFBConfigs(__GLXclientState *cl, unsigned screen)\n \n int __glXDisp_GetFBConfigs(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetFBConfigsReq *req = (xGLXGetFBConfigsReq *) pc;\n+    REQUEST_SIZE_MATCH(xGLXGetFBConfigsReq);\n     return DoGetFBConfigs(cl, req->screen);\n }\n \n int __glXDisp_GetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *) pc;\n+    REQUEST_SIZE_MATCH(xGLXGetFBConfigsSGIXReq);\n     return DoGetFBConfigs(cl, req->screen);\n }\n \n@@ -1213,11 +1258,14 @@ determineTextureTarget(ClientPtr client, XID glxDrawableID,\n \n int __glXDisp_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n@@ -1229,11 +1277,14 @@ int __glXDisp_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreatePixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_FIXED_SIZE(xGLXCreatePixmapReq, req->numAttribs << 3);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n@@ -1252,12 +1303,15 @@ int __glXDisp_CreatePixmap(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPixmapWithConfigSGIXReq *req = \n \t(xGLXCreateGLXPixmapWithConfigSGIXReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapWithConfigSGIXReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n@@ -1284,15 +1338,21 @@ static int DoDestroyDrawable(__GLXclientState *cl, XID glxdrawable, int type)\n \n int __glXDisp_DestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyGLXPixmapReq);\n+\n     return DoDestroyDrawable(cl, req->glxpixmap, GLX_DRAWABLE_PIXMAP);\n }\n \n int __glXDisp_DestroyPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyPixmapReq *req = (xGLXDestroyPixmapReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyPixmapReq);\n+\n     return DoDestroyDrawable(cl, req->glxpixmap, GLX_DRAWABLE_PIXMAP);\n }\n \n@@ -1331,10 +1391,13 @@ DoCreatePbuffer(ClientPtr client, int screenNum, XID fbconfigId,\n \n int __glXDisp_CreatePbuffer(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreatePbufferReq\t*req = (xGLXCreatePbufferReq *) pc;\n     CARD32\t\t\t*attrs;\n     int\t\t\t\t width, height, i;\n \n+    REQUEST_FIXED_SIZE(xGLXCreatePbufferReq, req->numAttribs << 3);\n+\n     attrs = (CARD32 *) (req + 1);\n     width = 0;\n     height = 0;\n@@ -1360,23 +1423,32 @@ int __glXDisp_CreatePbuffer(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreateGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPbufferSGIXReq *req = (xGLXCreateGLXPbufferSGIXReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPbufferSGIXReq);\n+\n     return DoCreatePbuffer(cl->client, req->screen, req->fbconfig,\n \t\t\t   req->width, req->height, req->pbuffer);\n }\n \n int __glXDisp_DestroyPbuffer(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyPbufferReq);\n+\n     return DoDestroyDrawable(cl, req->pbuffer, GLX_DRAWABLE_PBUFFER);\n }\n \n int __glXDisp_DestroyGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyGLXPbufferSGIXReq *req = (xGLXDestroyGLXPbufferSGIXReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyGLXPbufferSGIXReq);\n+\n     return DoDestroyDrawable(cl, req->pbuffer, GLX_DRAWABLE_PBUFFER);\n }\n \n@@ -1407,18 +1479,24 @@ DoChangeDrawableAttributes(ClientPtr client, XID glxdrawable,\n \n int __glXDisp_ChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXChangeDrawableAttributesReq *req =\n \t(xGLXChangeDrawableAttributesReq *) pc;\n \n+    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesReq, req->numAttribs << 3);\n+\n     return DoChangeDrawableAttributes(cl->client, req->drawable,\n \t\t\t\t      req->numAttribs, (CARD32 *) (req + 1));\n }\n \n int __glXDisp_ChangeDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXChangeDrawableAttributesSGIXReq *req =\n \t(xGLXChangeDrawableAttributesSGIXReq *)pc;\n \n+    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesSGIXReq, req->numAttribs << 3);\n+\n     return DoChangeDrawableAttributes(cl->client, req->drawable,\n \t\t\t\t      req->numAttribs, (CARD32 *) (req + 1));\n }\n@@ -1432,6 +1510,8 @@ int __glXDisp_CreateWindow(__GLXclientState *cl, GLbyte *pc)\n     DrawablePtr\t\t pDraw;\n     int\t\t\t err;\n \n+    REQUEST_FIXED_SIZE(xGLXCreateWindowReq, req->numAttribs << 3);\n+\n     LEGAL_NEW_RESOURCE(req->glxwindow, client);\n \n     if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))\n@@ -1455,8 +1535,11 @@ int __glXDisp_CreateWindow(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_DestroyWindow(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyWindowReq *req = (xGLXDestroyWindowReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyWindowReq);\n+\n     return DoDestroyDrawable(cl, req->glxwindow, GLX_DRAWABLE_WINDOW);\n }\n \n@@ -1472,12 +1555,16 @@ int __glXDisp_SwapBuffers(__GLXclientState *cl, GLbyte *pc)\n {\n     ClientPtr client = cl->client;\n     xGLXSwapBuffersReq *req = (xGLXSwapBuffersReq *) pc;\n-    GLXContextTag tag = req->contextTag;\n-    XID drawId = req->drawable;\n+    GLXContextTag tag;\n+    XID drawId;\n     __GLXcontext *glxc = NULL;\n     __GLXdrawable *pGlxDraw;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXSwapBuffersReq);\n+\n+    tag = req->contextTag;\n+    drawId = req->drawable;\n     if (tag) {\n \tglxc = __glXLookupContextByTag(cl, tag);\n \tif (!glxc) {\n@@ -1558,15 +1645,21 @@ DoQueryContext(__GLXclientState *cl, GLXContextID gcId)\n \n int __glXDisp_QueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryContextInfoEXTReq *req = (xGLXQueryContextInfoEXTReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryContextInfoEXTReq);\n+\n     return DoQueryContext(cl, req->context);\n }\n \n int __glXDisp_QueryContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryContextReq *req = (xGLXQueryContextReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryContextReq);\n+\n     return DoQueryContext(cl, req->context);\n }\n \n@@ -1580,6 +1673,8 @@ int __glXDisp_BindTexImageEXT(__GLXclientState *cl, GLbyte *pc)\n     int\t\t\t buffer;\n     int\t\t\t error;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 8);\n+\n     pc += __GLX_VENDPRIV_HDR_SIZE;\n \n     drawId = *((CARD32 *) (pc));\n@@ -1614,6 +1709,8 @@ int __glXDisp_ReleaseTexImageEXT(__GLXclientState *cl, GLbyte *pc)\n     int\t\t\t buffer;\n     int\t\t\t error;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 8);\n+\n     pc += __GLX_VENDPRIV_HDR_SIZE;\n \n     drawId = *((CARD32 *) (pc));\n@@ -1649,6 +1746,8 @@ int __glXDisp_CopySubBufferMESA(__GLXclientState *cl, GLbyte *pc)\n     (void) client;\n     (void) req;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 20);\n+\n     pc += __GLX_VENDPRIV_HDR_SIZE;\n \n     drawId = *((CARD32 *) (pc));\n@@ -1737,16 +1836,22 @@ DoGetDrawableAttributes(__GLXclientState *cl, XID drawId)\n \n int __glXDisp_GetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *)pc;\n \n+    REQUEST_SIZE_MATCH(xGLXGetDrawableAttributesReq);\n+\n     return DoGetDrawableAttributes(cl, req->drawable);\n }\n \n int __glXDisp_GetDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetDrawableAttributesSGIXReq *req =\n \t(xGLXGetDrawableAttributesSGIXReq *)pc;\n     \n+    REQUEST_SIZE_MATCH(xGLXGetDrawableAttributesSGIXReq);\n+\n     return DoGetDrawableAttributes(cl, req->drawable);\n }\n \n@@ -1771,6 +1876,8 @@ int __glXDisp_Render(__GLXclientState *cl, GLbyte *pc)\n     __GLXcontext *glxc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXRenderReq);\n+\n     req = (xGLXRenderReq *) pc;\n     if (client->swapped) {\n \t__GLX_SWAP_SHORT(&req->length);\n@@ -1791,6 +1898,9 @@ int __glXDisp_Render(__GLXclientState *cl, GLbyte *pc)\n \t__GLXdispatchRenderProcPtr proc;\n \tint err;\n \n+\tif (left < sizeof(__GLXrenderHeader))\n+\t    return BadLength;\n+\n \t/*\n \t** Verify that the header length and the overall length agree.\n \t** Also, each command must be word aligned.\n@@ -2069,10 +2179,12 @@ int __glXDisp_RenderLarge(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_VendorPrivate(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;\n     GLint vendorcode = req->vendorCode;\n     __GLXdispatchVendorPrivProcPtr proc;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);\n \n     proc = (__GLXdispatchVendorPrivProcPtr)\n       __glXGetProtocolDecodeFunction(& VendorPriv_dispatch_info,\n@@ -2088,10 +2200,12 @@ int __glXDisp_VendorPrivate(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_VendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;\n     GLint vendorcode = req->vendorCode;\n     __GLXdispatchVendorPrivProcPtr proc;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);\n \n     proc = (__GLXdispatchVendorPrivProcPtr)\n       __glXGetProtocolDecodeFunction(& VendorPriv_dispatch_info,\n@@ -2114,6 +2228,8 @@ int __glXDisp_QueryExtensionsString(__GLXclientState *cl, GLbyte *pc)\n     char *buf;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryExtensionsStringReq);\n+\n     if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))\n \treturn err;\n \n@@ -2153,6 +2269,8 @@ int __glXDisp_QueryServerString(__GLXclientState *cl, GLbyte *pc)\n     int err;\n     char ver_str[16];\n \n+    REQUEST_SIZE_MATCH(xGLXQueryServerStringReq);\n+\n     if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))\n \treturn err;\n \n@@ -2200,13 +2318,19 @@ int __glXDisp_QueryServerString(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_ClientInfo(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXClientInfoReq *req = (xGLXClientInfoReq *) pc;\n     const char *buf;\n    \n+    REQUEST_AT_LEAST_SIZE(xGLXClientInfoReq);\n+\n+    buf = (const char *)(req+1);\n+    if (!memchr(buf, 0, (client->req_len << 2) - sizeof(xGLXClientInfoReq)))\n+\treturn BadLength;\n+\n     cl->GLClientmajorVersion = req->major;\n     cl->GLClientminorVersion = req->minor;\n     free(cl->GLClientextensions);\n-    buf = (const char *)(req+1);\n     cl->GLClientextensions = strdup(buf);\n \n     return Success;",
  "project": "xserver",
  "commit_id": "ec9c97c6bf70b523bc500bd3adf62176f1bb33a4",
  "target": 1,
  "func": " int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n\t\t\t   config, pGlxScreen, req->isDirect);\n}\n",
  "big_vul_idx": 178443,
  "idx": 427,
  "hash": 157514919002916136363478838617068996789,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch introduces validation checks for request lengths in multiple functions, which is crucial for preventing security issues like buffer overflows. The commit message explicitly states the purpose of validating request lengths, aligning with the code changes. This indicates a focus on fixing a security vulnerability by ensuring requests are handled correctly.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}