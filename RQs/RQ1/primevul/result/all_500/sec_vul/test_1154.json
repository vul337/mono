{
  "id": 1154,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/bfabiszewski/libmobi/commit/ab5bf0e37e540eac682a14e628853b918626e72b",
  "commit_sha": "ab5bf0e37e540eac682a14e628853b918626e72b",
  "commit_msg": "fix oob write bug inside libmobi",
  "pr_url": "https://github.com/bfabiszewski/libmobi/pull/33",
  "pr_info": "Hey, guys, recently I found an OOB write bug inside libmobi, I made a fix for it and hope you are happy to receive this fix.\r\n\r\nHere is the detail of this vulnerability:\r\n\r\n# ‚úçÔ∏è Description\r\n## Overview\r\nThis vulnerability is of writing user controlled values out of the buffer. The buffer is of `MOBIBuffer` type which is allocated using `malloc`. It is possible for the attacker to finally accomplish RCE (Remote Code Execution) using this out-of-bound write vulnerability to overwrite control-flow critical memory values.\r\n\r\n## Root Cause & Fix Suggestion\r\nThis vulnerability is introduced by incomplete check of buffer boundaries in `mobi_buffer_move` (`src/buffer.c`). In that function,  when `offset < 0`, the condition `buf->offset + len <= buf->maxlen` doesn't be checked. Currently, that function only checks whether `buf->offset >= abs(offset)` when `offset < 0`.\r\n\r\nThe following code shows the vulnerable point and possible fix.\r\n\r\n```c\r\n// src/buffer.c\r\nvoid mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\r\n    size_t aoffset = (size_t) abs(offset);\r\n    unsigned char *source = buf->data + buf->offset;\r\n    if (offset >= 0) {\r\n        if (buf->offset + aoffset + len > buf->maxlen) {\r\n            debug_print(\"%s\", \"End of buffer\\n\");\r\n            buf->error = MOBI_BUFFER_END;\r\n            return;\r\n        }\r\n        source += aoffset;\r\n    } else {\r\n        // INCOMPLETE CHECK HERE:\r\n        // should also check buf->offset + len <= buf->maxlen\r\n        // POSSIBLE FIX:\r\n        // if ( (buf->offset < aoffset) || (buf->offset + len <= buf->maxlen) )\r\n        if (buf->offset < aoffset) {\r\n            debug_print(\"%s\", \"End of buffer\\n\");\r\n            buf->error = MOBI_BUFFER_END;\r\n            return;\r\n        }\r\n        source -= aoffset;\r\n    }\r\n    // due to the incomplete check, the memmove can out-of-bound write\r\n    memmove(buf->data + buf->offset, source, len);\r\n    buf->offset += len;\r\n}\r\n```\r\n\r\n\r\n\r\n # üïµÔ∏è‚Äç‚ôÇÔ∏è Proof of Concept\r\n- Download latest `libmobi` and compile it with Address Sanitizer: `CFLAGS=\" -fsanitize=address \" CXXFLAGS=\" -fsanitize=address \"`\r\n- Use the following command and this [POC-FILE](https://drive.google.com/file/d/1Y3mYZthjlhq4iXOQzWzUYvDouWOnXk53/view?usp=sharing) to reproduce the crash:\r\n\r\n```bash\r\n# enable address sanitizer\r\nexport ASAN_OPTIONS=abort_on_error=1:disable_coredump=0:unmap_shadow_on_exit=1\r\n# reproduce the crash\r\n./mobitool -cdeimsrux7 -o any-tmp-dir-path POC-FILE\r\n```\r\n\r\nYou should get similar crash information as follows:\r\n```bash\r\n=================================================================\r\n==14492==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x621000009d00 at pc 0x7ffff762917a bp 0x7fffffffbef0 sp 0x7fffffffb698\r\nWRITE of size 1 at 0x621000009d00 thread T0\r\n    #0 0x7ffff7629179 in memmove (/lib/x86_64-linux-gnu/libasan.so.6+0x3a179)\r\n    #1 0x7ffff75857c9 in mobi_buffer_move /src/libmobi/libmobi-git/src/buffer.c:520\r\n    #2 0x7ffff7585d83 in mobi_decompress_lz77 /src/libmobi/libmobi-git/src/compression.c:59\r\n    #3 0x7ffff75ad161 in mobi_decompress_content /src/libmobi/libmobi-git/src/util.c:1774\r\n    #4 0x7ffff75ad677 in mobi_dump_rawml /src/libmobi/libmobi-git/src/util.c:1856\r\n    #5 0x5555555630e4 in dump_rawml /src/libmobi/libmobi-git/tools/mobitool.c:333\r\n    #6 0x5555555661e3 in loadfilename /src/libmobi/libmobi-git/tools/mobitool.c:775\r\n    #7 0x555555566e46 in main /src/libmobi/libmobi-git/tools/mobitool.c:962\r\n    #8 0x7ffff73a90b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\r\n    #9 0x55555555dead in _start (/src/libmobi/libmobi-git/install/bin/mobitool+0x9ead)\r\n\r\n0x621000009d00 is located 0 bytes to the right of 4096-byte region [0x621000008d00,0x621000009d00)\r\nallocated by thread T0 here:\r\n    #0 0x7ffff769f517 in malloc (/lib/x86_64-linux-gnu/libasan.so.6+0xb0517)\r\n    #1 0x7ffff75acb85 in mobi_decompress_content /src/libmobi/libmobi-git/src/util.c:1702\r\n    #2 0x7ffff75ad677 in mobi_dump_rawml /src/libmobi/libmobi-git/src/util.c:1856\r\n    #3 0x5555555630e4 in dump_rawml /src/libmobi/libmobi-git/tools/mobitool.c:333\r\n    #4 0x5555555661e3 in loadfilename /src/libmobi/libmobi-git/tools/mobitool.c:775\r\n    #5 0x555555566e46 in main /src/libmobi/libmobi-git/tools/mobitool.c:962\r\n    #6 0x7ffff73a90b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\r\n```\r\n\r\n# üí• Impact\r\nThis vulnerability is capable of overwriting memory content with user given values. For all applications using `libmobi` (commits `983b89820e1c592d9d7c8c438af46e75be1f96e1 ` in Jun 8th, 2021 or release version 0.6 (2020 Aug 1st))\r\nIt is possible for the attacker to finally accomplish RCE (Remote Code Execution) using this out-of-bound write vulnerability to overwrite control-flow critical memory values.\r\n",
  "file_name": "src/buffer.c",
  "func_name": "",
  "raw_func_from_json": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
  "diff_func": "@@ -510,8 +510,8 @@ void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n         }\n         source += aoffset;\n     } else {\n-        if (buf->offset < aoffset) {\n-            debug_print(\"%s\", \"End of buffer\\n\");\n+        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {\n+            debug_print(\"%s\", \"Beyond start/end of buffer\\n\");\n             buf->error = MOBI_BUFFER_END;\n             return;\n         }",
  "func": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
  "project": "libmobi",
  "hash": 112966685438841866605584430600685767431,
  "size": 21,
  "commit_id": "ab5bf0e37e540eac682a14e628853b918626e72b",
  "message": "fix oob write bug inside libmobi",
  "target": 1,
  "dataset": "other",
  "idx": 215188,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an out-of-bounds (OOB) write vulnerability in the `mobi_buffer_move` function. The code change adds a bounds check to prevent writing beyond the buffer's limits, which could lead to buffer overflow and potential security exploitation.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}