{
  "id": 183,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/pol51/OpenSSL-CMake/commit/2919516136a4227d9e6d8f2fe66ef976aaf8c561",
  "commit_sha": "2919516136a4227d9e6d8f2fe66ef976aaf8c561",
  "commit_msg": "Prevent EBCDIC overread for very long strings\n\nASN1 Strings that are over 1024 bytes can cause an overread in\napplications using the X509_NAME_oneline() function on EBCDIC systems.\nThis could result in arbitrary stack data being returned in the buffer.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2176\n\nReviewed-by: Andy Polyakov <appro@openssl.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "crypto/x509/x509_obj.c",
  "func_name": "",
  "raw_func_from_json": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)\n                         ? sizeof ebcdic_buf : num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n",
  "diff_func": "@@ -130,8 +130,9 @@ char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n-            ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)\n-                         ? sizeof ebcdic_buf : num);\n+            if (num > (int)sizeof(ebcdic_buf))\n+                num = sizeof(ebcdic_buf);\n+            ascii2ebcdic(ebcdic_buf, q, num);\n             q = ebcdic_buf;\n         }\n #endif",
  "project": "openssl",
  "commit_id": "2919516136a4227d9e6d8f2fe66ef976aaf8c561",
  "target": 1,
  "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)\n                         ? sizeof ebcdic_buf : num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n",
  "big_vul_idx": 178379,
  "idx": 383,
  "hash": 92428507097973547653884047469651088423,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n1. The commit message indicates a security issue related to an overread in EBCDIC systems, referencing a CVE.\n2. The code diff modifies buffer handling to prevent overreads, a clear security fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}