{
  "id": 986,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/etemesi254/ffmpeg-ht/commit/ffcc82219cef0928bed2d558b19ef6ea35634130",
  "commit_sha": "ffcc82219cef0928bed2d558b19ef6ea35634130",
  "commit_msg": "avformat/rtmppkt: Convert ff_amf_get_field_value() to bytestream2\n\nFixes: out of array accesses\n\nFound-by: JunDong Xie of Ant-financial Light-Year Security Lab\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libavformat/rtmppkt.c",
  "func_name": "",
  "raw_func_from_json": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                            const uint8_t *name, uint8_t *dst, int dst_size)\n {\n     int namelen = strlen(name);\n     int len;\n \n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n     }\n    if (data_end - data < 3)\n         return -1;\n    data++;\n     for (;;) {\n        int size = bytestream_get_be16(&data);\n         if (!size)\n             break;\n        if (size < 0 || size >= data_end - data)\n             return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n             case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                 break;\n             case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                 break;\n             case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                 break;\n             default:\n                 return -1;\n             }\n             return 0;\n         }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n             return -1;\n        data += len;\n     }\n     return -1;\n }\n",
  "diff_func": "@@ -505,53 +505,70 @@ int ff_amf_tag_size(const uint8_t *data, const uint8_t *data_end)\n     return bytestream2_tell(&gb);\n }\n \n-int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n+static int amf_get_field_value2(GetByteContext *gb,\n                            const uint8_t *name, uint8_t *dst, int dst_size)\n {\n     int namelen = strlen(name);\n     int len;\n \n-    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n-        len = ff_amf_tag_size(data, data_end);\n-        if (len < 0)\n-            len = data_end - data;\n-        data += len;\n+    while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {\n+        int ret = amf_tag_skip(gb);\n+        if (ret < 0)\n+            return -1;\n     }\n-    if (data_end - data < 3)\n+    if (bytestream2_get_bytes_left(gb) < 3)\n         return -1;\n-    data++;\n+    bytestream2_get_byte(gb);\n+\n     for (;;) {\n-        int size = bytestream_get_be16(&data);\n+        int size = bytestream2_get_be16(gb);\n         if (!size)\n             break;\n-        if (size < 0 || size >= data_end - data)\n+        if (size < 0 || size >= bytestream2_get_bytes_left(gb))\n             return -1;\n-        data += size;\n-        if (size == namelen && !memcmp(data-size, name, namelen)) {\n-            switch (*data++) {\n+        bytestream2_skip(gb, size);\n+        if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {\n+            switch (bytestream2_get_byte(gb)) {\n             case AMF_DATA_TYPE_NUMBER:\n-                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n+                snprintf(dst, dst_size, \"%g\", av_int2double(bytestream2_get_be64(gb)));\n                 break;\n             case AMF_DATA_TYPE_BOOL:\n-                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n+                snprintf(dst, dst_size, \"%s\", bytestream2_get_byte(gb) ? \"true\" : \"false\");\n                 break;\n             case AMF_DATA_TYPE_STRING:\n-                len = bytestream_get_be16(&data);\n-                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n+                len = bytestream2_get_be16(gb);\n+                if (dst_size < 1)\n+                    return -1;\n+                if (dst_size < len + 1)\n+                    len = dst_size - 1;\n+                bytestream2_get_buffer(gb, dst, len);\n+                dst[len] = 0;\n                 break;\n             default:\n                 return -1;\n             }\n             return 0;\n         }\n-        len = ff_amf_tag_size(data, data_end);\n-        if (len < 0 || len >= data_end - data)\n+        len = amf_tag_skip(gb);\n+        if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)\n             return -1;\n-        data += len;\n     }\n     return -1;\n }\n \n+int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n+                           const uint8_t *name, uint8_t *dst, int dst_size)\n+{\n+    GetByteContext gb;\n+\n+    if (data >= data_end)\n+        return -1;\n+\n+    bytestream2_init(&gb, data, data_end - data);\n+\n+    return amf_get_field_value2(&gb, name, dst, dst_size);\n+}\n+\n static const char* rtmp_packet_type(int type)\n {\n     switch (type) {",
  "project": "FFmpeg",
  "commit_id": "ffcc82219cef0928bed2d558b19ef6ea35634130",
  "target": 1,
  "func": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                            const uint8_t *name, uint8_t *dst, int dst_size)\n {\n     int namelen = strlen(name);\n     int len;\n \n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n     }\n    if (data_end - data < 3)\n         return -1;\n    data++;\n     for (;;) {\n        int size = bytestream_get_be16(&data);\n         if (!size)\n             break;\n        if (size < 0 || size >= data_end - data)\n             return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n             case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                 break;\n             case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                 break;\n             case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                 break;\n             default:\n                 return -1;\n             }\n             return 0;\n         }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n             return -1;\n        data += len;\n     }\n     return -1;\n }\n",
  "big_vul_idx": 181173,
  "idx": 2676,
  "hash": 65922353615166357961739409061322950452,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an out-of-bounds access issue in the `ff_amf_get_field_value` function by replacing manual pointer arithmetic with `bytestream2` functions, preventing potential buffer overflows.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}