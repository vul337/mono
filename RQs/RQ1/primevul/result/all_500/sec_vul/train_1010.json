{
  "id": 1010,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/supremegamers/android_external_ffmpeg/commit/cb243972b121b1ae6b60a78ff55a0506c69f3879",
  "commit_sha": "cb243972b121b1ae6b60a78ff55a0506c69f3879",
  "commit_msg": "avcodec/xpmdec: Fix multiple pointer/memory issues\n\nMost of these were found through code review in response to\nfixing 1466/clusterfuzz-testcase-minimized-5961584419536896\nThere is thus no testcase for most of this.\nThe initial issue was Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libavcodec/xpmdec.c",
  "func_name": "",
  "raw_func_from_json": "static uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n     const ColorEntry *entry;\n     char color_name[100];\n \n     if (*p == '#') {\n         p++;\n         len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n\n        if (!entry)\n            return ret;\n\n        ret = entry->rgb_color;\n    }\n    return ret;\n}\n",
  "diff_func": "@@ -29,6 +29,8 @@\n typedef struct XPMContext {\n     uint32_t  *pixels;\n     int        pixels_size;\n+    uint8_t   *buf;\n+    int        buf_size;\n } XPMDecContext;\n \n typedef struct ColorEntry {\n@@ -233,6 +235,8 @@ static uint32_t color_string_to_rgba(const char *p, int len)\n     const ColorEntry *entry;\n     char color_name[100];\n \n+    len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);\n+\n     if (*p == '#') {\n         p++;\n         len--;\n@@ -299,18 +303,25 @@ static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n {\n     XPMDecContext *x = avctx->priv_data;\n     AVFrame *p=data;\n-    const uint8_t *end, *ptr = avpkt->data;\n+    const uint8_t *end, *ptr;\n     int ncolors, cpp, ret, i, j;\n     int64_t size;\n     uint32_t *dst;\n \n     avctx->pix_fmt = AV_PIX_FMT_BGRA;\n \n-    end = avpkt->data + avpkt->size;\n-    while (memcmp(ptr, \"/* XPM */\", 9) && ptr < end - 9)\n+    av_fast_padded_malloc(&x->buf, &x->buf_size, avpkt->size);\n+    if (!x->buf)\n+        return AVERROR(ENOMEM);\n+    memcpy(x->buf, avpkt->data, avpkt->size);\n+    x->buf[avpkt->size] = 0;\n+\n+    ptr = x->buf;\n+    end = x->buf + avpkt->size;\n+    while (end - ptr > 9 && memcmp(ptr, \"/* XPM */\", 9))\n         ptr++;\n \n-    if (ptr >= end) {\n+    if (end - ptr <= 9) {\n         av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n         return AVERROR_INVALIDDATA;\n     }\n@@ -335,7 +346,7 @@ static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n \n     size = 1;\n     for (i = 0; i < cpp; i++)\n-        size *= 94;\n+        size *= 95;\n \n     if (ncolors <= 0 || ncolors > size) {\n         av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n@@ -349,12 +360,15 @@ static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n         return AVERROR(ENOMEM);\n \n     ptr += mod_strcspn(ptr, \",\") + 1;\n+    if (end - ptr < 1)\n+        return AVERROR_INVALIDDATA;\n+\n     for (i = 0; i < ncolors; i++) {\n         const uint8_t *index;\n         int len;\n \n         ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n-        if (ptr + cpp > end)\n+        if (end - ptr < cpp)\n             return AVERROR_INVALIDDATA;\n         index = ptr;\n         ptr += cpp;\n@@ -373,14 +387,20 @@ static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n \n         x->pixels[ret] = color_string_to_rgba(ptr, len);\n         ptr += mod_strcspn(ptr, \",\") + 1;\n+        if (end - ptr < 1)\n+            return AVERROR_INVALIDDATA;\n     }\n \n     for (i = 0; i < avctx->height; i++) {\n         dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n+        if (end - ptr < 1)\n+            return AVERROR_INVALIDDATA;\n         ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n+        if (end - ptr < 1)\n+            return AVERROR_INVALIDDATA;\n \n         for (j = 0; j < avctx->width; j++) {\n-            if (ptr + cpp > end)\n+            if (end - ptr < cpp)\n                 return AVERROR_INVALIDDATA;\n \n             if ((ret = ascii2index(ptr, cpp)) < 0)\n@@ -405,6 +425,9 @@ static av_cold int xpm_decode_close(AVCodecContext *avctx)\n     XPMDecContext *x = avctx->priv_data;\n     av_freep(&x->pixels);\n \n+    av_freep(&x->buf);\n+    x->buf_size = 0;\n+\n     return 0;\n }\n ",
  "project": "FFmpeg",
  "commit_id": "cb243972b121b1ae6b60a78ff55a0506c69f3879",
  "target": 1,
  "func": "static uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n     const ColorEntry *entry;\n     char color_name[100];\n \n     if (*p == '#') {\n         p++;\n         len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n\n        if (!entry)\n            return ret;\n\n        ret = entry->rgb_color;\n    }\n    return ret;\n}\n",
  "big_vul_idx": 181248,
  "idx": 2742,
  "hash": 238040376254480215925986692629755930821,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses buffer overflow and memory management issues in the XPM decoder, which are critical for preventing security vulnerabilities such as arbitrary code execution. The code changes include adding bounds checks, using a managed buffer, and proper memory cleanup. These fixes mitigate potential exploits, classifying this as a security vulnerability fix.\n\n**Final Output:**\nAnalysis: The patch fixes memory and pointer issues, preventing potential buffer overflows. Changes include adding buffer checks and proper memory management, which are critical for security.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}