{
  "id": 511,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ourfor/mpv-swapchain2/commit/d0c530919d8cd4d7a774e38ab064e0fabdae34e6",
  "commit_sha": "d0c530919d8cd4d7a774e38ab064e0fabdae34e6",
  "commit_msg": "demux_mf: improve format string processing\n\nBefore this commit, the user could specify a printf format string\nwhich wasn't verified, and could result in:\n- Undefined behavior due to missing or non-matching arguments.\n- Buffer overflow due to untested result length.\n\nThe offending code was added at commit 103a9609 (2002, mplayer svn):\ngit-svn-id: svn://svn.mplayerhq.hu/mplayer/trunk@4566 b3059339-0415-0410-9bf9-f77b7e298cf2\n\nIt moved around but was not modified meaningfully until now.\n\nNow we reject all conversion specifiers at the format except %%\nand a simple subset of the valid specifiers. Also, we now use\nsnprintf to avoid buffer overflow.\n\nThe format string is provided by the user as part of mf:// URI.\n\nReport and initial patch by Stefan Schiller.\nPatch reviewed by @jeeb, @sfan5, Stefan Schiller.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "demux/demux_mf.c",
  "func_name": "",
  "raw_func_from_json": "static mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename)\n{\n    struct mp_log *log = d->log;\n    int error_count = 0;\n    int count = 0;\n\n    mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n    mf->log = log;\n\n    if (filename[0] == '@') {\n        struct stream *s = stream_create(filename + 1,\n                            d->stream_origin | STREAM_READ, d->cancel, d->global);\n        if (s) {\n            while (1) {\n                char buf[512];\n                int len = stream_read_peek(s, buf, sizeof(buf));\n                if (!len)\n                    break;\n                bstr data = (bstr){buf, len};\n                int pos = bstrchr(data, '\\n');\n                data = bstr_splice(data, 0, pos < 0 ? data.len : pos + 1);\n                bstr fname = bstr_strip(data);\n                if (fname.len) {\n                    if (bstrchr(fname, '\\0') >= 0) {\n                        mp_err(log, \"invalid filename\\n\");\n                        break;\n                    }\n                    char *entry = bstrto0(mf, fname);\n                    if (!mp_path_exists(entry)) {\n                        mp_verbose(log, \"file not found: '%s'\\n\", entry);\n                    } else {\n                        MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n                    }\n                }\n                stream_seek_skip(s, stream_tell(s) + data.len);\n            }\n            free_stream(s);\n\n            mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n            goto exit_mf;\n        }\n        mp_info(log, \"%s is not indirect filelist\\n\", filename + 1);\n    }\n\n    if (strchr(filename, ',')) {\n        mp_info(log, \"filelist: %s\\n\", filename);\n        bstr bfilename = bstr0(filename);\n\n        while (bfilename.len) {\n            bstr bfname;\n            bstr_split_tok(bfilename, \",\", &bfname, &bfilename);\n            char *fname2 = bstrdup0(mf, bfname);\n\n            if (!mp_path_exists(fname2))\n                mp_verbose(log, \"file not found: '%s'\\n\", fname2);\n            else {\n                mf_add(mf, fname2);\n            }\n            talloc_free(fname2);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\n        goto exit_mf;\n    }\n\n    char *fname = talloc_size(mf, strlen(filename) + 32);\n\n#if HAVE_GLOB\n    if (!strchr(filename, '%')) {\n        strcpy(fname, filename);\n        if (!strchr(filename, '*'))\n            strcat(fname, \"*\");\n\n        mp_info(log, \"search expr: %s\\n\", fname);\n\n        glob_t gg;\n        if (glob(fname, 0, NULL, &gg)) {\n            talloc_free(mf);\n            return NULL;\n        }\n\n        for (int i = 0; i < gg.gl_pathc; i++) {\n            if (mp_path_isdir(gg.gl_pathv[i]))\n                continue;\n            mf_add(mf, gg.gl_pathv[i]);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n        globfree(&gg);\n        goto exit_mf;\n    }\n#endif\n\n    mp_info(log, \"search expr: %s\\n\", filename);\n\n    while (error_count < 5) {\n        sprintf(fname, filename, count++);\n        if (!mp_path_exists(fname)) {\n            error_count++;\n            mp_verbose(log, \"file not found: '%s'\\n\", fname);\n        } else {\n            mf_add(mf, fname);\n        }\n    }\n\n    mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\nexit_mf:\n    return mf;\n}",
  "diff_func": "@@ -121,7 +121,8 @@ static mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename\n         goto exit_mf;\n     }\n \n-    char *fname = talloc_size(mf, strlen(filename) + 32);\n+    size_t fname_avail = strlen(filename) + 32;\n+    char *fname = talloc_size(mf, fname_avail);\n \n #if HAVE_GLOB\n     if (!strchr(filename, '%')) {\n@@ -148,10 +149,44 @@ static mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename\n     }\n #endif\n \n+    // We're using arbitrary user input as printf format with 1 int argument.\n+    // Any format which uses exactly 1 int argument would be valid, but for\n+    // simplicity we reject all conversion specifiers except %% and simple\n+    // integer specifier: %[.][NUM]d where NUM is 1-3 digits (%.d is valid)\n+    const char *f = filename;\n+    int MAXDIGS = 3, nspec = 0, bad_spec = 0, c;\n+\n+    while (nspec < 2 && (c = *f++)) {\n+        if (c != '%')\n+            continue;\n+        if (*f != '%') {\n+            nspec++;  // conversion specifier which isn't %%\n+            if (*f == '.')\n+                f++;\n+            for (int ndig = 0; mp_isdigit(*f) && ndig < MAXDIGS; ndig++, f++)\n+                /* no-op */;\n+            if (*f != 'd') {\n+                bad_spec++;  // not int, or beyond our validation capacity\n+                break;\n+            }\n+        }\n+        // *f is '%' or 'd'\n+        f++;\n+    }\n+\n+    // nspec==0 (zero specifiers) is rejected because fname wouldn't advance.\n+    if (bad_spec || nspec != 1) {\n+        mp_err(log, \"unsupported expr format: '%s'\\n\", filename);\n+        goto exit_mf;\n+    }\n+\n     mp_info(log, \"search expr: %s\\n\", filename);\n \n     while (error_count < 5) {\n-        sprintf(fname, filename, count++);\n+        if (snprintf(fname, fname_avail, filename, count++) >= fname_avail) {\n+            mp_err(log, \"format result too long: '%s'\\n\", filename);\n+            goto exit_mf;\n+        }\n         if (!mp_path_exists(fname)) {\n             error_count++;\n             mp_verbose(log, \"file not found: '%s'\\n\", fname);",
  "func": "static mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename)\n{\n    struct mp_log *log = d->log;\n    int error_count = 0;\n    int count = 0;\n\n    mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n    mf->log = log;\n\n    if (filename[0] == '@') {\n        struct stream *s = stream_create(filename + 1,\n                            d->stream_origin | STREAM_READ, d->cancel, d->global);\n        if (s) {\n            while (1) {\n                char buf[512];\n                int len = stream_read_peek(s, buf, sizeof(buf));\n                if (!len)\n                    break;\n                bstr data = (bstr){buf, len};\n                int pos = bstrchr(data, '\\n');\n                data = bstr_splice(data, 0, pos < 0 ? data.len : pos + 1);\n                bstr fname = bstr_strip(data);\n                if (fname.len) {\n                    if (bstrchr(fname, '\\0') >= 0) {\n                        mp_err(log, \"invalid filename\\n\");\n                        break;\n                    }\n                    char *entry = bstrto0(mf, fname);\n                    if (!mp_path_exists(entry)) {\n                        mp_verbose(log, \"file not found: '%s'\\n\", entry);\n                    } else {\n                        MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n                    }\n                }\n                stream_seek_skip(s, stream_tell(s) + data.len);\n            }\n            free_stream(s);\n\n            mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n            goto exit_mf;\n        }\n        mp_info(log, \"%s is not indirect filelist\\n\", filename + 1);\n    }\n\n    if (strchr(filename, ',')) {\n        mp_info(log, \"filelist: %s\\n\", filename);\n        bstr bfilename = bstr0(filename);\n\n        while (bfilename.len) {\n            bstr bfname;\n            bstr_split_tok(bfilename, \",\", &bfname, &bfilename);\n            char *fname2 = bstrdup0(mf, bfname);\n\n            if (!mp_path_exists(fname2))\n                mp_verbose(log, \"file not found: '%s'\\n\", fname2);\n            else {\n                mf_add(mf, fname2);\n            }\n            talloc_free(fname2);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\n        goto exit_mf;\n    }\n\n    char *fname = talloc_size(mf, strlen(filename) + 32);\n\n#if HAVE_GLOB\n    if (!strchr(filename, '%')) {\n        strcpy(fname, filename);\n        if (!strchr(filename, '*'))\n            strcat(fname, \"*\");\n\n        mp_info(log, \"search expr: %s\\n\", fname);\n\n        glob_t gg;\n        if (glob(fname, 0, NULL, &gg)) {\n            talloc_free(mf);\n            return NULL;\n        }\n\n        for (int i = 0; i < gg.gl_pathc; i++) {\n            if (mp_path_isdir(gg.gl_pathv[i]))\n                continue;\n            mf_add(mf, gg.gl_pathv[i]);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n        globfree(&gg);\n        goto exit_mf;\n    }\n#endif\n\n    mp_info(log, \"search expr: %s\\n\", filename);\n\n    while (error_count < 5) {\n        sprintf(fname, filename, count++);\n        if (!mp_path_exists(fname)) {\n            error_count++;\n            mp_verbose(log, \"file not found: '%s'\\n\", fname);\n        } else {\n            mf_add(mf, fname);\n        }\n    }\n\n    mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\nexit_mf:\n    return mf;\n}",
  "project": "mpv",
  "hash": 274378014879641404725355042981539405209,
  "size": 109,
  "commit_id": "d0c530919d8cd4d7a774e38ab064e0fabdae34e6",
  "message": "demux_mf: improve format string processing\n\nBefore this commit, the user could specify a printf format string\nwhich wasn't verified, and could result in:\n- Undefined behavior due to missing or non-matching arguments.\n- Buffer overflow due to untested result length.\n\nThe offending code was added at commit 103a9609 (2002, mplayer svn):\ngit-svn-id: svn://svn.mplayerhq.hu/mplayer/trunk@4566 b3059339-0415-0410-9bf9-f77b7e298cf2\n\nIt moved around but was not modified meaningfully until now.\n\nNow we reject all conversion specifiers at the format except %%\nand a simple subset of the valid specifiers. Also, we now use\nsnprintf to avoid buffer overflow.\n\nThe format string is provided by the user as part of mf:// URI.\n\nReport and initial patch by Stefan Schiller.\nPatch reviewed by @jeeb, @sfan5, Stefan Schiller.",
  "target": 1,
  "dataset": "other",
  "idx": 197465,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by validating user-provided format strings and preventing buffer overflows. The code changes include adding validation checks and replacing unsafe string functions with safer alternatives.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}