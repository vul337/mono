{
  "id": 451,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/MrE-Fog/krb521/commit/cf1a0c411b2668c57c41e9c4efd15ba17b6b322c",
  "commit_sha": "cf1a0c411b2668c57c41e9c4efd15ba17b6b322c",
  "commit_msg": "Fix kpasswd UDP ping-pong [CVE-2002-2443]\n\nThe kpasswd service provided by kadmind was vulnerable to a UDP\n\"ping-pong\" attack [CVE-2002-2443].  Don't respond to packets unless\nthey pass some basic validation, and don't respond to our own error\npackets.\n\nSome authors use CVE-1999-0103 to refer to the kpasswd UDP ping-pong\nattack or UDP ping-pong attacks in general, but there is discussion\nleading toward narrowing the definition of CVE-1999-0103 to the echo,\nchargen, or other similar built-in inetd services.\n\nThanks to Vincent Danen for alerting us to this issue.\n\nCVSSv2: AV:N/AC:L/Au:N/C:N/I:N/A:P/E:P/RL:O/RC:C\n\nticket: 7637 (new)\ntarget_version: 1.11.3\ntags: pullup",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/kadmin/server/schpw.c",
  "func_name": "",
  "raw_func_from_json": "process_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        /* either this, or the server is printing bad messages,\n           or the caller passed in garbage */\n         ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto chpwfail;\n     }\n \n     ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request length was inconsistent\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n         numresult = KRB5_KPASSWD_BAD_VERSION;\n         snprintf(strresult, sizeof(strresult),\n                  \"Request contained unknown protocol version number %d\", vno);\n        goto chpwfail;\n     }\n \n     /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* decrypt the ChangePasswdData */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    /*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     */\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    /* decode ChangePasswdData for setpw requests */\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* for cpw, verify that this is an AS_REQ ticket */\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* change the password */\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    /* zap the password */\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n        /* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        /* this is really icky.  but it's what all the other callers\n           to mk_error do. */\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    /* construct the reply */\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}\n",
  "diff_func": "@@ -52,7 +52,7 @@ process_chpw_request(krb5_context context, void *server_handle, char *realm,\n         ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n-        goto chpwfail;\n+        goto bailout;\n     }\n \n     ptr = req->data;\n@@ -67,7 +67,7 @@ process_chpw_request(krb5_context context, void *server_handle, char *realm,\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request length was inconsistent\",\n                 sizeof(strresult));\n-        goto chpwfail;\n+        goto bailout;\n     }\n \n     /* verify version number */\n@@ -80,7 +80,7 @@ process_chpw_request(krb5_context context, void *server_handle, char *realm,\n         numresult = KRB5_KPASSWD_BAD_VERSION;\n         snprintf(strresult, sizeof(strresult),\n                  \"Request contained unknown protocol version number %d\", vno);\n-        goto chpwfail;\n+        goto bailout;\n     }\n \n     /* read, check ap-req length */\n@@ -93,7 +93,7 @@ process_chpw_request(krb5_context context, void *server_handle, char *realm,\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                 sizeof(strresult));\n-        goto chpwfail;\n+        goto bailout;\n     }\n \n     /* verify ap_req */",
  "project": "krb5",
  "commit_id": "cf1a0c411b2668c57c41e9c4efd15ba17b6b322c",
  "target": 1,
  "func": "process_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        /* either this, or the server is printing bad messages,\n           or the caller passed in garbage */\n         ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto chpwfail;\n     }\n \n     ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request length was inconsistent\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n         numresult = KRB5_KPASSWD_BAD_VERSION;\n         snprintf(strresult, sizeof(strresult),\n                  \"Request contained unknown protocol version number %d\", vno);\n        goto chpwfail;\n     }\n \n     /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                 sizeof(strresult));\n        goto chpwfail;\n     }\n \n     /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* decrypt the ChangePasswdData */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    /*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     */\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    /* decode ChangePasswdData for setpw requests */\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* for cpw, verify that this is an AS_REQ ticket */\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* change the password */\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    /* zap the password */\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n        /* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        /* this is really icky.  but it's what all the other callers\n           to mk_error do. */\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    /* construct the reply */\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}\n",
  "big_vul_idx": 179407,
  "idx": 1178,
  "hash": 151952841528932102997447826449546146841,
  "Bug Filter": "**\n   - The patch clearly addresses a security issue, fitting the 'Security Vulnerability Fix' category.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Analysis:**\n\n1. **Patch Analysis:**\n   - The commit message references a known security vulnerability (CVE-2002-2443) related to a UDP ping-pong attack in the kpasswd service. The changes aim to prevent responding to invalid packets, which suggests a security fix.\n   - The code diff shows modifications in error handling, replacing `goto chpwfail` with `goto bailout`. This likely changes how errors are processed, possibly to avoid sending responses that could be exploited.\n\n2. **Security Vulnerability Assessment:**\n   - The patch addresses a vulnerability (CVE-2002-2443) that allows attackers to perform a ping-pong attack, leading to denial of service or resource exhaustion.\n   - The code changes indicate a fix to prevent unauthorized access and mitigate the attack vector.\n\n3. **Classification:**\n   - The patch clearly addresses a security issue, fitting the 'Security Vulnerability Fix' category.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}