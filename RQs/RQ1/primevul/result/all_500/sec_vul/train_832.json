{
  "id": 832,
  "language": "c",
  "cwe": "CWE-862",
  "commit_url": "https://github.com/sjp38/linux.personal/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b",
  "commit_sha": "4dca6ea1d9432052afb06baf2e3ae78188a4410b",
  "commit_msg": "KEYS: add missing permission check for request_key() destination\n\nWhen the request_key() syscall is not passed a destination keyring, it\nlinks the requested key (if constructed) into the \"default\" request-key\nkeyring.  This should require Write permission to the keyring.  However,\nthere is actually no permission check.\n\nThis can be abused to add keys to any keyring to which only Search\npermission is granted.  This is because Search permission allows joining\nthe keyring.  keyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_SESSION_KEYRING)\nthen will set the default request-key keyring to the session keyring.\nThen, request_key() can be used to add keys to the keyring.\n\nBoth negatively and positively instantiated keys can be added using this\nmethod.  Adding negative keys is trivial.  Adding a positive key is a\nbit trickier.  It requires that either /sbin/request-key positively\ninstantiates the key, or that another thread adds the key to the process\nkeyring at just the right time, such that request_key() misses it\ninitially but then finds it in construct_alloc_key().\n\nFix this bug by checking for Write permission to the keyring in\nconstruct_get_dest_keyring() when the default keyring is being used.\n\nWe don't do the permission check for non-default keyrings because that\nwas already done by the earlier call to lookup_user_key().  Also,\nrequest_key_and_link() is currently passed a 'struct key *' rather than\na key_ref_t, so the \"possessed\" bit is unavailable.\n\nWe also don't do the permission check for the \"requestor keyring\", to\ncontinue to support the use case described by commit 8bbf4976b59f\n(\"KEYS: Alter use of key instantiation link-to-keyring argument\") where\n/sbin/request-key recursively calls request_key() to add keys to the\noriginal requestor's destination keyring.  (I don't know of any users\nwho actually do that, though...)\n\nFixes: 3e30148c3d52 (\"[PATCH] Keys: Make request-key create an authorisation key\")\nCc: <stable@vger.kernel.org>\t# v2.6.13+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "security/keys/request_key.c",
  "func_name": "",
  "raw_func_from_json": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n \n \tkenter(\"%p\", dest_keyring);\n \n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n \t\t/* the caller supplied one */\n \t\tkey_get(dest_keyring);\n \t} else {\n \t\t/* use a default keyring; falling through the cases until we\n \t\t * find one that we actually have */\n \t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n \t\t\t\t\tbreak;\n \t\t\t}\n \n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n \t}\n \n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n }\n",
  "diff_func": "@@ -251,11 +251,12 @@ static int construct_key(struct key *key, const void *callout_info,\n  * The keyring selected is returned with an extra reference upon it which the\n  * caller must release.\n  */\n-static void construct_get_dest_keyring(struct key **_dest_keyring)\n+static int construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n+\tint ret;\n \n \tkenter(\"%p\", dest_keyring);\n \n@@ -264,6 +265,8 @@ static void construct_get_dest_keyring(struct key **_dest_keyring)\n \t\t/* the caller supplied one */\n \t\tkey_get(dest_keyring);\n \t} else {\n+\t\tbool do_perm_check = true;\n+\n \t\t/* use a default keyring; falling through the cases until we\n \t\t * find one that we actually have */\n \t\tswitch (cred->jit_keyring) {\n@@ -278,8 +281,10 @@ static void construct_get_dest_keyring(struct key **_dest_keyring)\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n-\t\t\t\tif (dest_keyring)\n+\t\t\t\tif (dest_keyring) {\n+\t\t\t\t\tdo_perm_check = false;\n \t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n \n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n@@ -314,11 +319,29 @@ static void construct_get_dest_keyring(struct key **_dest_keyring)\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n+\n+\t\t/*\n+\t\t * Require Write permission on the keyring.  This is essential\n+\t\t * because the default keyring may be the session keyring, and\n+\t\t * joining a keyring only requires Search permission.\n+\t\t *\n+\t\t * However, this check is skipped for the \"requestor keyring\" so\n+\t\t * that /sbin/request-key can itself use request_key() to add\n+\t\t * keys to the original requestor's destination keyring.\n+\t\t */\n+\t\tif (dest_keyring && do_perm_check) {\n+\t\t\tret = key_permission(make_key_ref(dest_keyring, 1),\n+\t\t\t\t\t     KEY_NEED_WRITE);\n+\t\t\tif (ret) {\n+\t\t\t\tkey_put(dest_keyring);\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t}\n \t}\n \n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n-\treturn;\n+\treturn 0;\n }\n \n /*\n@@ -444,11 +467,15 @@ static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n \tif (ctx->index_key.type == &key_type_keyring)\n \t\treturn ERR_PTR(-EPERM);\n \n-\tuser = key_user_lookup(current_fsuid());\n-\tif (!user)\n-\t\treturn ERR_PTR(-ENOMEM);\n+\tret = construct_get_dest_keyring(&dest_keyring);\n+\tif (ret)\n+\t\tgoto error;\n \n-\tconstruct_get_dest_keyring(&dest_keyring);\n+\tuser = key_user_lookup(current_fsuid());\n+\tif (!user) {\n+\t\tret = -ENOMEM;\n+\t\tgoto error_put_dest_keyring;\n+\t}\n \n \tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n \tkey_user_put(user);\n@@ -463,7 +490,7 @@ static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n \t} else if (ret == -EINPROGRESS) {\n \t\tret = 0;\n \t} else {\n-\t\tgoto couldnt_alloc_key;\n+\t\tgoto error_put_dest_keyring;\n \t}\n \n \tkey_put(dest_keyring);\n@@ -473,8 +500,9 @@ static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n construction_failed:\n \tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n \tkey_put(key);\n-couldnt_alloc_key:\n+error_put_dest_keyring:\n \tkey_put(dest_keyring);\n+error:\n \tkleave(\" = %d\", ret);\n \treturn ERR_PTR(ret);\n }",
  "project": "linux",
  "commit_id": "4dca6ea1d9432052afb06baf2e3ae78188a4410b",
  "target": 1,
  "func": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n \n \tkenter(\"%p\", dest_keyring);\n \n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n \t\t/* the caller supplied one */\n \t\tkey_get(dest_keyring);\n \t} else {\n \t\t/* use a default keyring; falling through the cases until we\n \t\t * find one that we actually have */\n \t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n \t\t\t\t\tbreak;\n \t\t\t}\n \n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n \t}\n \n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n }\n",
  "big_vul_idx": 180819,
  "idx": 2373,
  "hash": 275435868270037711146449830073903331943,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a missing permission check in the request_key() syscall, which allowed unauthorized key additions to keyrings. The code changes introduce a Write permission check, mitigating a security vulnerability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}