{
  "id": 405,
  "language": "cpp",
  "cwe": "",
  "commit_url": "https://github.com/josedelacerda835/https-github.com-facebook-hhvm/commit/b3679121bb3c7017ff04b4c08402ffff5cf59b13",
  "commit_sha": "b3679121bb3c7017ff04b4c08402ffff5cf59b13",
  "commit_msg": "Fix buffer overrun in SimpleParser::handleBackslash\n\nSummary:\nIt read 4 chars, then checked for validity, but any of them could have\nbeen the end of the string, so check after each one instead.\n\nReviewed By: oulgen\n\nDifferential Revision: D19611163\n\nfbshipit-source-id: 3da0a39555cb85a93f4fd98048368f17cf37e2e4",
  "pr_url": null,
  "pr_info": null,
  "file_name": "hphp/runtime/ext/json/JSON_parser.cpp",
  "func_name": "",
  "raw_func_from_json": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; // includes check for end of string\n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }",
  "diff_func": "@@ -453,12 +453,13 @@ struct SimpleParser {\n       case 'u': {\n         if (UNLIKELY(is_tsimplejson)) {\n           auto const ch1 = *p++;\n+          if (UNLIKELY(ch1 != '0')) return false;\n           auto const ch2 = *p++;\n+          if (UNLIKELY(ch2 != '0')) return false;\n           auto const dch3 = dehexchar(*p++);\n+          if (UNLIKELY(dch3 < 0)) return false;\n           auto const dch4 = dehexchar(*p++);\n-          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n-            return false;\n-          }\n+          if (UNLIKELY(dch4 < 0)) return false;\n           out = (dch3 << 4) | dch4;\n           return true;\n         } else {",
  "func": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; // includes check for end of string\n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }",
  "project": "hhvm",
  "hash": 222661936735492214340109696360679833540,
  "size": 42,
  "commit_id": "b3679121bb3c7017ff04b4c08402ffff5cf59b13",
  "message": "Fix buffer overrun in SimpleParser::handleBackslash\n\nSummary:\nIt read 4 chars, then checked for validity, but any of them could have\nbeen the end of the string, so check after each one instead.\n\nReviewed By: oulgen\n\nDifferential Revision: D19611163\n\nfbshipit-source-id: 3da0a39555cb85a93f4fd98048368f17cf37e2e4",
  "target": 1,
  "dataset": "other",
  "idx": 195486,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a buffer overrun issue in SimpleParser::handleBackslash by adding individual checks after each character read, preventing potential overflow and unauthorized access.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}