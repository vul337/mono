{
  "id": 687,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/etemesi254/ffmpeg-ht/commit/9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6",
  "commit_sha": "9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6",
  "commit_msg": "avformat/adtsenc: return value check for init_get_bits in adts_decode_extradata\n\nAs the second argument for init_get_bits (buf) can be crafted, a return value check for this function call is necessary.\n'buf' is  part of  'AVPacket pkt'.\nreplace init_get_bits with init_get_bits8.\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libavformat/adtsenc.c",
  "func_name": "",
  "raw_func_from_json": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n\n        put_bits(&pb, 3, 5); //ID_PCE\n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n\n    adts->write_adts = 1;\n\n    return 0;\n}",
  "diff_func": "@@ -53,9 +53,11 @@ static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const ui\n     GetBitContext gb;\n     PutBitContext pb;\n     MPEG4AudioConfig m4ac;\n-    int off;\n+    int off, ret;\n \n-    init_get_bits(&gb, buf, size * 8);\n+    ret = init_get_bits8(&gb, buf, size);\n+    if (ret < 0)\n+        return ret;\n     off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n     if (off < 0)\n         return off;",
  "func": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n\n        put_bits(&pb, 3, 5); //ID_PCE\n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n\n    adts->write_adts = 1;\n\n    return 0;\n}",
  "project": "FFmpeg",
  "hash": 27134847231468977506511316145171824130,
  "size": 48,
  "commit_id": "9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6",
  "message": "avformat/adtsenc: return value check for init_get_bits in adts_decode_extradata\n\nAs the second argument for init_get_bits (buf) can be crafted, a return value check for this function call is necessary.\n'buf' is  part of  'AVPacket pkt'.\nreplace init_get_bits with init_get_bits8.\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
  "target": 1,
  "dataset": "other",
  "idx": 197185,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a potential security issue by adding a return value check after initializing the GetBitContext, which prevents the function from proceeding with invalid state if the buffer is crafted by an attacker.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}