{
  "id": 624,
  "language": "c",
  "cwe": "CWE-399",
  "commit_url": "https://github.com/sailfishos-mirror/file/commit/65437cee25199dbd385fb35901bc0011e164276c",
  "commit_sha": "65437cee25199dbd385fb35901bc0011e164276c",
  "commit_msg": "Limit string printing to 100 chars, and add flags I forgot in the previous\ncommit.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/readelf.c",
  "func_name": "",
  "raw_func_from_json": "donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap, size_t align, int *flags, uint16_t *notecount)\n{\n\tElf32_Nhdr nh32;\n\tElf64_Nhdr nh64;\n\tsize_t noff, doff;\n\tuint32_t namesz, descsz;\n\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n\n\tif (*notecount == 0)\n\t\treturn 0;\n\t--*notecount;\n\n\tif (xnh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xnh_sizeof + offset;\n\t}\n\n\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n\toffset += xnh_sizeof;\n\n\tnamesz = xnh_namesz;\n\tdescsz = xnh_descsz;\n\tif ((namesz == 0) && (descsz == 0)) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\tif (namesz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note name size 0x%lx\",\n\t\t(unsigned long)namesz);\n\t    return 0;\n\t}\n\n\tif (descsz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note description size 0x%lx\",\n\t\t(unsigned long)descsz);\n\t    return 0;\n\t}\n\n\tnoff = offset;\n\tdoff = ELF_ALIGN(offset + namesz);\n\n\tif (offset + namesz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn doff;\n\t}\n\n\toffset = ELF_ALIGN(doff + descsz);\n\tif (doff + descsz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\tif ((*flags & FLAGS_DID_OS_NOTE) == 0) {\n\t\tif (do_os_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn size;\n\t}\n\n\tif ((*flags & FLAGS_DID_BUILD_ID) == 0) {\n\t\tif (do_bid_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn size;\n\t}\n\t\t\n\tif ((*flags & FLAGS_DID_NETBSD_PAX) == 0) {\n\t\tif (do_pax_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn size;\n\t}\n\n\tif ((*flags & FLAGS_DID_CORE) == 0) {\n\t\tif (do_core_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags, size, clazz))\n\t\t\treturn size;\n \t}\n \n \tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n \t\tswitch (xnh_type) {\n \t    \tcase NT_NETBSD_VERSION:\n \t\t\treturn size;\n \t\tcase NT_NETBSD_MARCH:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n \t\t\t\treturn size;\n\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n\t\t\t    (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase NT_NETBSD_CMODEL:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n \t\t\t\treturn size;\n \t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n \t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n \t\t\t\treturn size;\n \t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n\t\t}\n\t\treturn size;\n\t}\n\n\treturn offset;\n}\n",
  "diff_func": "@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.115 2014/12/16 20:53:05 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.116 2014/12/16 23:18:40 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -900,26 +900,31 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t}\n \n \tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n+\t\tif (descsz > 100)\n+\t\t\tdescsz = 100;\n \t\tswitch (xnh_type) {\n \t    \tcase NT_NETBSD_VERSION:\n \t\t\treturn size;\n \t\tcase NT_NETBSD_MARCH:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n \t\t\t\treturn size;\n-\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n-\t\t\t    (const char *)&nbuf[doff]) == -1)\n+\t\t\t*flags |= FLAGS_DID_NETBSD_MARCH;\n+\t\t\tif (file_printf(ms, \", compiled for: %.*s\",\n+\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase NT_NETBSD_CMODEL:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n \t\t\t\treturn size;\n+\t\t\t*flags |= FLAGS_DID_NETBSD_CMODEL;\n \t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n \t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n \t\t\t\treturn size;\n+\t\t\t*flags |= FLAGS_DID_NETBSD_UNKNOWN;\n \t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;",
  "project": "file",
  "commit_id": "65437cee25199dbd385fb35901bc0011e164276c",
  "target": 1,
  "func": "donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap, size_t align, int *flags, uint16_t *notecount)\n{\n\tElf32_Nhdr nh32;\n\tElf64_Nhdr nh64;\n\tsize_t noff, doff;\n\tuint32_t namesz, descsz;\n\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n\n\tif (*notecount == 0)\n\t\treturn 0;\n\t--*notecount;\n\n\tif (xnh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xnh_sizeof + offset;\n\t}\n\n\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n\toffset += xnh_sizeof;\n\n\tnamesz = xnh_namesz;\n\tdescsz = xnh_descsz;\n\tif ((namesz == 0) && (descsz == 0)) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\tif (namesz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note name size 0x%lx\",\n\t\t(unsigned long)namesz);\n\t    return 0;\n\t}\n\n\tif (descsz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note description size 0x%lx\",\n\t\t(unsigned long)descsz);\n\t    return 0;\n\t}\n\n\tnoff = offset;\n\tdoff = ELF_ALIGN(offset + namesz);\n\n\tif (offset + namesz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn doff;\n\t}\n\n\toffset = ELF_ALIGN(doff + descsz);\n\tif (doff + descsz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\tif ((*flags & FLAGS_DID_OS_NOTE) == 0) {\n\t\tif (do_os_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn size;\n\t}\n\n\tif ((*flags & FLAGS_DID_BUILD_ID) == 0) {\n\t\tif (do_bid_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn size;\n\t}\n\t\t\n\tif ((*flags & FLAGS_DID_NETBSD_PAX) == 0) {\n\t\tif (do_pax_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn size;\n\t}\n\n\tif ((*flags & FLAGS_DID_CORE) == 0) {\n\t\tif (do_core_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags, size, clazz))\n\t\t\treturn size;\n \t}\n \n \tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n \t\tswitch (xnh_type) {\n \t    \tcase NT_NETBSD_VERSION:\n \t\t\treturn size;\n \t\tcase NT_NETBSD_MARCH:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n \t\t\t\treturn size;\n\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n\t\t\t    (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase NT_NETBSD_CMODEL:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n \t\t\t\treturn size;\n \t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n \t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n \t\t\t\treturn size;\n \t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n\t\t}\n\t\treturn size;\n\t}\n\n\treturn offset;\n}\n",
  "big_vul_idx": 179944,
  "idx": 1601,
  "hash": 206842038504383384764350029146618750488,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch introduces a limit on string printing length to prevent buffer overflow, a clear security measure. The confidence is high as the change directly mitigates a potential security vulnerability.\n\n**Final Output:**\n\nAnalysis: The patch limits string printing to 100 characters, preventing potential buffer overflow attacks. This addresses a security vulnerability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}