{
  "id": 344,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/ljalves/linux_media/commit/338c7dbadd2671189cec7faf64c84d01071b3f96",
  "commit_sha": "338c7dbadd2671189cec7faf64c84d01071b3f96",
  "commit_msg": "KVM: Improve create VCPU parameter (CVE-2013-4587)\n\nIn multiple functions the vcpu_id is used as an offset into a bitfield.  Ag\nmalicious user could specify a vcpu_id greater than 255 in order to set or\nclear bits in kernel memory.  This could be used to elevate priveges in the\nkernel.  This patch verifies that the vcpu_id provided is less than 255.\nThe api documentation already specifies that the vcpu_id must be less than\nmax_vcpus, but this is currently not checked.\n\nReported-by: Andrew Honig <ahonig@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "virt/kvm/kvm_main.c",
  "func_name": "",
  "raw_func_from_json": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);\n\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}\n",
  "diff_func": "@@ -1898,6 +1898,9 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \n+\tif (id >= KVM_MAX_VCPUS)\n+\t\treturn -EINVAL;\n+\n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);",
  "project": "linux",
  "commit_id": "338c7dbadd2671189cec7faf64c84d01071b3f96",
  "target": 1,
  "func": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);\n\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}\n",
  "big_vul_idx": 179131,
  "idx": 932,
  "hash": 78071846559468948243618412598588559342,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses a security vulnerability (CVE-2013-4587) where an attacker could provide a vcpu_id exceeding 255 to manipulate kernel memory. The fix adds a check to prevent this, enhancing system security.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}