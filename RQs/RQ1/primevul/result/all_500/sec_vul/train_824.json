{
  "id": 824,
  "language": "c",
  "cwe": "CWE-476",
  "commit_url": "https://github.com/open-iscsi/tcmu-runner/commit/bb80e9c7a798f035768260ebdadffb6eb0786178",
  "commit_sha": "bb80e9c7a798f035768260ebdadffb6eb0786178",
  "commit_msg": "only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS\n\nTrying to unregister an internal handler ended up in a SEGFAULT, because\nthe tcmur_handler->opaque was NULL. Way to reproduce:\n\ndbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow\n\nwe use a newly introduced boolean in struct tcmur_handler for keeping\ntrack of external handlers. As suggested by mikechristie adjusting the\npublic data structure is acceptable.",
  "pr_url": "https://github.com/open-iscsi/tcmu-runner/pull/200",
  "pr_info": "While doing a security audit of tcmu-runner I've come across these issues.\r\n\r\nRebased and squashed version of previous pull request:\r\n\r\nhttps://github.com/open-iscsi/tcmu-runner/pull/193",
  "file_name": "main.c",
  "func_name": "",
  "raw_func_from_json": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}\n",
  "diff_func": "@@ -91,6 +91,12 @@ int tcmur_register_handler(struct tcmur_handler *handler)\n \treturn 0;\n }\n \n+static int tcmur_register_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tassert(handler->_is_dbus_handler == true);\n+\treturn tcmur_register_handler(handler);\n+}\n+\n bool tcmur_unregister_handler(struct tcmur_handler *handler)\n {\n \tint i;\n@@ -103,6 +109,16 @@ bool tcmur_unregister_handler(struct tcmur_handler *handler)\n \treturn false;\n }\n \n+static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)\n+{\n+\tbool ret = false;\n+\tassert(handler->_is_dbus_handler == true);\n+\n+\tret = tcmur_unregister_handler(handler);\n+\n+\treturn ret;\n+}\n+\n static int is_handler(const struct dirent *dirent)\n {\n \tif (strncmp(dirent->d_name, \"handler_\", 8))\n@@ -315,7 +331,7 @@ on_handler_appeared(GDBusConnection *connection,\n \n \tif (info->register_invocation) {\n \t\tinfo->connection = connection;\n-\t\ttcmur_register_handler(handler);\n+\t\ttcmur_register_dbus_handler(handler);\n \t\tdbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));\n \t\tg_dbus_method_invocation_return_value(info->register_invocation,\n \t\t\t    g_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n@@ -340,7 +356,7 @@ on_handler_vanished(GDBusConnection *connection,\n \t\t\t    g_variant_new(\"(bs)\", FALSE, reason));\n \t\tg_free(reason);\n \t}\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n \tdbus_unexport_handler(handler);\n }\n \n@@ -366,6 +382,8 @@ on_register_handler(TCMUService1HandlerManager1 *interface,\n \thandler->handle_cmd   = dbus_handler_handle_cmd;\n \n \tinfo = g_new0(struct dbus_info, 1);\n+\thandler->opaque = info;\n+\thandler->_is_dbus_handler = 1;\n \tinfo->register_invocation = invocation;\n \tinfo->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,\n \t\t\t\t\t    bus_name,\n@@ -394,8 +412,16 @@ on_unregister_handler(TCMUService1HandlerManager1 *interface,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n+\telse if (handler->_is_dbus_handler != 1) {\n+\t\tg_dbus_method_invocation_return_value(invocation,\n+\t\t\tg_variant_new(\"(bs)\", FALSE,\n+\t\t\t\t      \"cannot unregister internal handler\"));\n+\t\treturn TRUE;\n+\t}\n+\n \tdbus_unexport_handler(handler);\n-\ttcmur_unregister_handler(handler);\n+\ttcmur_unregister_dbus_handler(handler);\n+\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);",
  "project": "tcmu-runner",
  "commit_id": "bb80e9c7a798f035768260ebdadffb6eb0786178",
  "target": 1,
  "func": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}\n",
  "big_vul_idx": 180806,
  "idx": 2360,
  "hash": 274977298780245980512070718535102508647,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing a Denial of Service (DoS) attack through improper handler unregistration. It introduces checks and new functions to handle external handlers safely.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}