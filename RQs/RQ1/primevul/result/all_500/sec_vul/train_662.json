{
  "id": 662,
  "language": "c",
  "cwe": "CWE-125",
  "commit_url": "https://github.com/ljalves/linux_media/commit/50220dead1650609206efe91f0cc116132d59b3f",
  "commit_sha": "50220dead1650609206efe91f0cc116132d59b3f",
  "commit_msg": "HID: core: prevent out-of-bound readings\n\nPlugging a Logitech DJ receiver with KASAN activated raises a bunch of\nout-of-bound readings.\n\nThe fields are allocated up to MAX_USAGE, meaning that potentially, we do\nnot have enough fields to fit the incoming values.\nAdd checks and silence KASAN.\n\nSigned-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/hid/hid-core.c",
  "func_name": "",
  "raw_func_from_json": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\n \t\t/* Ignore report if ErrorRollOver */\n \t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n \t\t    value[n] >= min && value[n] <= max &&\n \t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n \t\t\tgoto exit;\n \t}\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n \t\t}\n \n \t\tif (field->value[n] >= min && field->value[n] <= max\n \t\t\t&& field->usage[field->value[n] - min].hid\n \t\t\t&& search(value, field->value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n \n \t\tif (value[n] >= min && value[n] <= max\n \t\t\t&& field->usage[value[n] - min].hid\n \t\t\t&& search(field->value, value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}\n",
  "diff_func": "@@ -1293,6 +1293,7 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n \t\t/* Ignore report if ErrorRollOver */\n \t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n \t\t    value[n] >= min && value[n] <= max &&\n+\t\t    value[n] - min < field->maxusage &&\n \t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n \t\t\tgoto exit;\n \t}\n@@ -1305,11 +1306,13 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n \t\t}\n \n \t\tif (field->value[n] >= min && field->value[n] <= max\n+\t\t\t&& field->value[n] - min < field->maxusage\n \t\t\t&& field->usage[field->value[n] - min].hid\n \t\t\t&& search(value, field->value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n \n \t\tif (value[n] >= min && value[n] <= max\n+\t\t\t&& value[n] - min < field->maxusage\n \t\t\t&& field->usage[value[n] - min].hid\n \t\t\t&& search(field->value, value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);",
  "project": "linux",
  "commit_id": "50220dead1650609206efe91f0cc116132d59b3f",
  "target": 1,
  "func": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\n \t\t/* Ignore report if ErrorRollOver */\n \t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n \t\t    value[n] >= min && value[n] <= max &&\n \t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n \t\t\tgoto exit;\n \t}\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n \t\t}\n \n \t\tif (field->value[n] >= min && field->value[n] <= max\n \t\t\t&& field->usage[field->value[n] - min].hid\n \t\t\t&& search(value, field->value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n \n \t\tif (value[n] >= min && value[n] <= max\n \t\t\t&& field->usage[value[n] - min].hid\n \t\t\t&& search(field->value, value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}\n",
  "big_vul_idx": 180093,
  "idx": 1726,
  "hash": 188242288363672829911451266792476420814,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an out-of-bound reading issue in the HID core, which could lead to security vulnerabilities. The added checks prevent array index overflows, mitigating potential attacks.\n\n**Final Output:**\nAnalysis: The patch adds bounds checks to prevent out-of-bound reads, which could cause memory corruption or information disclosure. This is a security fix as it prevents unauthorized access or data compromise.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}