{
  "id": 635,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/vkrasnov/multiprime/commit/248385c606620b29ecc96ca9d3603463f879652b",
  "commit_sha": "248385c606620b29ecc96ca9d3603463f879652b",
  "commit_msg": "Follow on from CVE-2014-3571. This fixes the code that was the original source\nof the crash due to p being NULL. Steve's fix prevents this situation from\noccuring - however this is by no means obvious by looking at the code for\ndtls1_get_record. This fix just makes things look a bit more sane.\n\nReviewed-by: Dr Stephen Henson <steve@openssl.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "ssl/d1_pkt.c",
  "func_name": "",
  "raw_func_from_json": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n\n\t/* The epoch may have changed.  If so, process all the\n\t * pending records.  This is a non-blocking operation. */\n\tdtls1_process_buffered_records(s);\n\n\t/* if we're renegotiating, then there may be buffered records */\n\tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n \t\t * would be dropped unnecessarily.\n \t\t */\n \t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    *p == SSL3_MT_CLIENT_HELLO) &&\n \t\t    !dtls1_record_replay_check(s, bitmap))\n \t\t\t{\n \t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n\t\t{\n\t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n\t\t\t{\n\t\t\tdtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\n\t\t\t}\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n\treturn(1);\n\n\t}\n",
  "diff_func": "@@ -679,7 +679,8 @@ int dtls1_get_record(SSL *s)\n \t\t * would be dropped unnecessarily.\n \t\t */\n \t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n-\t\t    *p == SSL3_MT_CLIENT_HELLO) &&\n+\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n+\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n \t\t    !dtls1_record_replay_check(s, bitmap))\n \t\t\t{\n \t\t\trr->length = 0;",
  "project": "openssl",
  "commit_id": "248385c606620b29ecc96ca9d3603463f879652b",
  "target": 1,
  "func": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n\n\t/* The epoch may have changed.  If so, process all the\n\t * pending records.  This is a non-blocking operation. */\n\tdtls1_process_buffered_records(s);\n\n\t/* if we're renegotiating, then there may be buffered records */\n\tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n \t\t * would be dropped unnecessarily.\n \t\t */\n \t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    *p == SSL3_MT_CLIENT_HELLO) &&\n \t\t    !dtls1_record_replay_check(s, bitmap))\n \t\t\t{\n \t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n\t\t{\n\t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n\t\t\t{\n\t\t\tdtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\n\t\t\t}\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n\treturn(1);\n\n\t}\n",
  "big_vul_idx": 179999,
  "idx": 1647,
  "hash": 286481766337439137439057692486533801243,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a known security vulnerability (CVE-2014-3571) by fixing a crash condition. The code changes modify the condition to prevent a NULL pointer dereference, which could be exploited. This makes the classification clear.\n\n**Final Output:**\nAnalysis: The patch fixes a crash due to a NULL pointer, related to CVE-2014-3571, indicating a security vulnerability.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}