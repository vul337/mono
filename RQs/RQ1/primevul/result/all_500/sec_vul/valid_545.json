{
  "id": 545,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ntop/nDPI/commit/23594f036536468072198a57c59b6e9d63caf6ce",
  "commit_sha": "23594f036536468072198a57c59b6e9d63caf6ce",
  "commit_msg": "Fixed stack overflow caused by missing length check\n\nSigned-off-by: Toni Uhlig <matzeton@googlemail.com>",
  "pr_url": "https://github.com/ntop/nDPI/pull/920",
  "pr_info": "Signed-off-by: Toni Uhlig <matzeton@googlemail.com>",
  "file_name": "src/lib/protocols/tls.c",
  "func_name": "",
  "raw_func_from_json": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n\n  // packet is truncated... further inspection is not needed\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n\n  str = (char*)&packet->payload[offset+5];\n\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n\n  // check string is printable\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n\n  return(is_printable);\n}",
  "diff_func": "@@ -196,6 +196,14 @@ static int extractRDNSequence(struct ndpi_packet_struct *packet,\n   char *str;\n   u_int len, j;\n \n+  if (*rdnSeqBuf_offset >= rdnSeqBuf_len) {\n+#ifdef DEBUG_TLS\n+    printf(\"[TLS] %s() [buffer capacity reached][%u]\\n\",\n+           __FUNCTION__, rdnSeqBuf_len);\n+#endif\n+    return -1;\n+  }\n+\n   // packet is truncated... further inspection is not needed\n   if((offset+4+str_len) >= packet->payload_packet_len)\n     return(-1);\n@@ -235,7 +243,7 @@ static void processCertificateElements(struct ndpi_detection_module_struct *ndpi\n \t\t\t\t       u_int16_t p_offset, u_int16_t certificate_len) {\n   struct ndpi_packet_struct *packet = &flow->packet;\n   u_int num_found = 0, i;\n-  char buffer[64] = { '\\0' }, rdnSeqBuf[1024] = { '\\0' };\n+  char buffer[64] = { '\\0' }, rdnSeqBuf[2048] = { '\\0' };\n   u_int rdn_len = 0;\n \n #ifdef DEBUG_TLS",
  "func": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n\n  // packet is truncated... further inspection is not needed\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n\n  str = (char*)&packet->payload[offset+5];\n\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n\n  // check string is printable\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n\n  return(is_printable);\n}",
  "project": "nDPI",
  "hash": 248381067839662632014583537592329241918,
  "size": 39,
  "commit_id": "23594f036536468072198a57c59b6e9d63caf6ce",
  "message": "Fixed stack overflow caused by missing length check\n\nSigned-off-by: Toni Uhlig <matzeton@googlemail.com>",
  "target": 1,
  "dataset": "other",
  "idx": 197908,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a buffer overflow vulnerability by adding a length check and increasing the buffer size. This prevents potential exploitation leading to stack overflow, which is a security concern.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}