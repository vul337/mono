{
  "id": 612,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/viaembedded/arm-soc/commit/600ddd6825543962fb807884169e57b580dba208",
  "commit_sha": "600ddd6825543962fb807884169e57b580dba208",
  "commit_msg": "net: sctp: fix slab corruption from use after free on INIT collisions\n\nWhen hitting an INIT collision case during the 4WHS with AUTH enabled, as\nalready described in detail in commit 1be9a950c646 (\"net: sctp: inherit\nauth_capable on INIT collisions\"), it can happen that we occasionally\nstill remotely trigger the following panic on server side which seems to\nhave been uncovered after the fix from commit 1be9a950c646 ...\n\n[  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff\n[  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230\n[  533.940559] PGD 5030f2067 PUD 0\n[  533.957104] Oops: 0000 [#1] SMP\n[  533.974283] Modules linked in: sctp mlx4_en [...]\n[  534.939704] Call Trace:\n[  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0\n[  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0\n[  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170\n[  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0\n[  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50\n[  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]\n[  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0\n[  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b\n\n... or depending on the the application, for example this one:\n\n[ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff\n[ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0\n[ 1370.054568] PGD 633c94067 PUD 0\n[ 1370.070446] Oops: 0000 [#1] SMP\n[ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]\n[ 1370.963431] Call Trace:\n[ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960\n[ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960\n[ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170\n[ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130\n[ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b\n\nWith slab debugging enabled, we can see that the poison has been overwritten:\n\n[  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten\n[  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b\n[  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494\n[  669.826424]  __slab_alloc+0x4bf/0x566\n[  669.826433]  __kmalloc+0x280/0x310\n[  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]\n[  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]\n[  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]\n[  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]\n[  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494\n[  669.826635]  __slab_free+0x39/0x2a8\n[  669.826643]  kfree+0x1d6/0x230\n[  669.826650]  kzfree+0x31/0x40\n[  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]\n[  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]\n[  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]\n\nSince this only triggers in some collision-cases with AUTH, the problem at\nheart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice\nwhen having refcnt 1, once directly in sctp_assoc_update() and yet again\nfrom within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on\nthe already kzfree'd memory, which is also consistent with the observation\nof the poison decrease from 0x6b to 0x6a (note: the overwrite is detected\nat a later point in time when poison is checked on new allocation).\n\nReference counting of auth keys revisited:\n\nShared keys for AUTH chunks are being stored in endpoints and associations\nin endpoint_shared_keys list. On endpoint creation, a null key is being\nadded; on association creation, all endpoint shared keys are being cached\nand thus cloned over to the association. struct sctp_shared_key only holds\na pointer to the actual key bytes, that is, struct sctp_auth_bytes which\nkeeps track of users internally through refcounting. Naturally, on assoc\nor enpoint destruction, sctp_shared_key are being destroyed directly and\nthe reference on sctp_auth_bytes dropped.\n\nUser space can add keys to either list via setsockopt(2) through struct\nsctp_authkey and by passing that to sctp_auth_set_key() which replaces or\nadds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes\nwith refcount 1 and in case of replacement drops the reference on the old\nsctp_auth_bytes. A key can be set active from user space through setsockopt()\non the id via sctp_auth_set_active_key(), which iterates through either\nendpoint_shared_keys and in case of an assoc, invokes (one of various places)\nsctp_auth_asoc_init_active_key().\n\nsctp_auth_asoc_init_active_key() computes the actual secret from local's\nand peer's random, hmac and shared key parameters and returns a new key\ndirectly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops\nthe reference if there was a previous one. The secret, which where we\neventually double drop the ref comes from sctp_auth_asoc_set_secret() with\nintitial refcount of 1, which also stays unchanged eventually in\nsctp_assoc_update(). This key is later being used for crypto layer to\nset the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().\n\nTo close the loop: asoc->asoc_shared_key is freshly allocated secret\nmaterial and independant of the sctp_shared_key management keeping track\nof only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76\n(\"net: sctp: fix memory leak in auth key management\") is independant of\nthis bug here since it concerns a different layer (though same structures\nbeing used eventually). asoc->asoc_shared_key is reference dropped correctly\non assoc destruction in sctp_association_free() and when active keys are\nbeing replaced in sctp_auth_asoc_init_active_key(), it always has a refcount\nof 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is\nto remove that sctp_auth_key_put() from there which fixes these panics.\n\nFixes: 730fc3d05cd4 (\"[SCTP]: Implete SCTP-AUTH parameter processing\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/sctp/associola.c",
  "func_name": "",
  "raw_func_from_json": "void sctp_assoc_update(struct sctp_association *asoc,\n\t\t       struct sctp_association *new)\n{\n\tstruct sctp_transport *trans;\n\tstruct list_head *pos, *temp;\n\n\t/* Copy in new parameters of peer. */\n\tasoc->c = new->c;\n\tasoc->peer.rwnd = new->peer.rwnd;\n\tasoc->peer.sack_needed = new->peer.sack_needed;\n\tasoc->peer.auth_capable = new->peer.auth_capable;\n\tasoc->peer.i = new->peer.i;\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t asoc->peer.i.initial_tsn, GFP_ATOMIC);\n\n\t/* Remove any peer addresses not present in the new association. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttrans = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_assoc_lookup_paddr(new, &trans->ipaddr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, trans);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (asoc->state >= SCTP_STATE_ESTABLISHED)\n\t\t\tsctp_transport_reset(trans);\n\t}\n\n\t/* If the case is A (association restart), use\n\t * initial_tsn as next_tsn. If the case is B, use\n\t * current next_tsn in case data sent to peer\n\t * has been discarded and needs retransmission.\n\t */\n\tif (asoc->state >= SCTP_STATE_ESTABLISHED) {\n\t\tasoc->next_tsn = new->next_tsn;\n\t\tasoc->ctsn_ack_point = new->ctsn_ack_point;\n\t\tasoc->adv_peer_ack_point = new->adv_peer_ack_point;\n\n\t\t/* Reinitialize SSN for both local streams\n\t\t * and peer's streams.\n\t\t */\n\t\tsctp_ssnmap_clear(asoc->ssnmap);\n\n\t\t/* Flush the ULP reassembly and ordered queue.\n\t\t * Any data there will now be stale and will\n\t\t * cause problems.\n\t\t */\n\t\tsctp_ulpq_flush(&asoc->ulpq);\n\n\t\t/* reset the overall association error count so\n\t\t * that the restarted association doesn't get torn\n\t\t * down on the next retransmission timer.\n\t\t */\n\t\tasoc->overall_error_count = 0;\n\n\t} else {\n\t\t/* Add any peer addresses from the new association. */\n\t\tlist_for_each_entry(trans, &new->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tif (!sctp_assoc_lookup_paddr(asoc, &trans->ipaddr))\n\t\t\t\tsctp_assoc_add_peer(asoc, &trans->ipaddr,\n\t\t\t\t\t\t    GFP_ATOMIC, trans->state);\n\t\t}\n\n\t\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\t\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\t\tif (!asoc->ssnmap) {\n\t\t\t/* Move the ssnmap. */\n\t\t\tasoc->ssnmap = new->ssnmap;\n\t\t\tnew->ssnmap = NULL;\n\t\t}\n\n\t\tif (!asoc->assoc_id) {\n\t\t\t/* get a new association id since we don't have one\n\t\t\t * yet.\n\t\t\t */\n\t\t\tsctp_assoc_set_id(asoc, GFP_ATOMIC);\n\t\t}\n\t}\n\n\t/* SCTP-AUTH: Save the peer parameters from the new associations\n\t * and also move the association shared keys over\n\t */\n\tkfree(asoc->peer.peer_random);\n\tasoc->peer.peer_random = new->peer.peer_random;\n\tnew->peer.peer_random = NULL;\n\n\tkfree(asoc->peer.peer_chunks);\n\tasoc->peer.peer_chunks = new->peer.peer_chunks;\n\tnew->peer.peer_chunks = NULL;\n\n\tkfree(asoc->peer.peer_hmacs);\n \tasoc->peer.peer_hmacs = new->peer.peer_hmacs;\n \tnew->peer.peer_hmacs = NULL;\n \n\tsctp_auth_key_put(asoc->asoc_shared_key);\n \tsctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\n }\n",
  "diff_func": "@@ -1182,7 +1182,6 @@ void sctp_assoc_update(struct sctp_association *asoc,\n \tasoc->peer.peer_hmacs = new->peer.peer_hmacs;\n \tnew->peer.peer_hmacs = NULL;\n \n-\tsctp_auth_key_put(asoc->asoc_shared_key);\n \tsctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\n }\n ",
  "project": "linux",
  "commit_id": "600ddd6825543962fb807884169e57b580dba208",
  "target": 1,
  "func": "void sctp_assoc_update(struct sctp_association *asoc,\n\t\t       struct sctp_association *new)\n{\n\tstruct sctp_transport *trans;\n\tstruct list_head *pos, *temp;\n\n\t/* Copy in new parameters of peer. */\n\tasoc->c = new->c;\n\tasoc->peer.rwnd = new->peer.rwnd;\n\tasoc->peer.sack_needed = new->peer.sack_needed;\n\tasoc->peer.auth_capable = new->peer.auth_capable;\n\tasoc->peer.i = new->peer.i;\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t asoc->peer.i.initial_tsn, GFP_ATOMIC);\n\n\t/* Remove any peer addresses not present in the new association. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttrans = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_assoc_lookup_paddr(new, &trans->ipaddr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, trans);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (asoc->state >= SCTP_STATE_ESTABLISHED)\n\t\t\tsctp_transport_reset(trans);\n\t}\n\n\t/* If the case is A (association restart), use\n\t * initial_tsn as next_tsn. If the case is B, use\n\t * current next_tsn in case data sent to peer\n\t * has been discarded and needs retransmission.\n\t */\n\tif (asoc->state >= SCTP_STATE_ESTABLISHED) {\n\t\tasoc->next_tsn = new->next_tsn;\n\t\tasoc->ctsn_ack_point = new->ctsn_ack_point;\n\t\tasoc->adv_peer_ack_point = new->adv_peer_ack_point;\n\n\t\t/* Reinitialize SSN for both local streams\n\t\t * and peer's streams.\n\t\t */\n\t\tsctp_ssnmap_clear(asoc->ssnmap);\n\n\t\t/* Flush the ULP reassembly and ordered queue.\n\t\t * Any data there will now be stale and will\n\t\t * cause problems.\n\t\t */\n\t\tsctp_ulpq_flush(&asoc->ulpq);\n\n\t\t/* reset the overall association error count so\n\t\t * that the restarted association doesn't get torn\n\t\t * down on the next retransmission timer.\n\t\t */\n\t\tasoc->overall_error_count = 0;\n\n\t} else {\n\t\t/* Add any peer addresses from the new association. */\n\t\tlist_for_each_entry(trans, &new->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tif (!sctp_assoc_lookup_paddr(asoc, &trans->ipaddr))\n\t\t\t\tsctp_assoc_add_peer(asoc, &trans->ipaddr,\n\t\t\t\t\t\t    GFP_ATOMIC, trans->state);\n\t\t}\n\n\t\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\t\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\t\tif (!asoc->ssnmap) {\n\t\t\t/* Move the ssnmap. */\n\t\t\tasoc->ssnmap = new->ssnmap;\n\t\t\tnew->ssnmap = NULL;\n\t\t}\n\n\t\tif (!asoc->assoc_id) {\n\t\t\t/* get a new association id since we don't have one\n\t\t\t * yet.\n\t\t\t */\n\t\t\tsctp_assoc_set_id(asoc, GFP_ATOMIC);\n\t\t}\n\t}\n\n\t/* SCTP-AUTH: Save the peer parameters from the new associations\n\t * and also move the association shared keys over\n\t */\n\tkfree(asoc->peer.peer_random);\n\tasoc->peer.peer_random = new->peer.peer_random;\n\tnew->peer.peer_random = NULL;\n\n\tkfree(asoc->peer.peer_chunks);\n\tasoc->peer.peer_chunks = new->peer.peer_chunks;\n\tnew->peer.peer_chunks = NULL;\n\n\tkfree(asoc->peer.peer_hmacs);\n \tasoc->peer.peer_hmacs = new->peer.peer_hmacs;\n \tnew->peer.peer_hmacs = NULL;\n \n\tsctp_auth_key_put(asoc->asoc_shared_key);\n \tsctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\n }\n",
  "big_vul_idx": 179872,
  "idx": 1542,
  "hash": 245205618481032024532167015760818142910,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses a use-after-free vulnerability in the SCTP protocol, specifically when handling INIT collisions with AUTH enabled. The issue caused kernel panics due to memory being accessed after being freed, which is a security concern. The fix removes a redundant memory deallocation to prevent this condition.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}