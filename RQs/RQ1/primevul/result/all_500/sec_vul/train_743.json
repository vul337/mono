{
  "id": 743,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ljalves/linux_media/commit/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754",
  "commit_sha": "c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754",
  "commit_msg": "USB: cypress_m8: add endpoint sanity check\n\nAn attack using missing endpoints exists.\n\nCVE-2016-3137\n\nSigned-off-by: Oliver Neukum <ONeukum@suse.com>\nCC: stable@vger.kernel.org\nSigned-off-by: Johan Hovold <johan@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/usb/serial/cypress_m8.c",
  "func_name": "",
  "raw_func_from_json": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n \tstruct usb_serial *serial = port->serial;\n \tstruct cypress_private *priv;\n \n \tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Skip reset for FRWD device. It is a workaound:\n\t   device hangs if it receives SET_CONFIGURE in Configured\n\t   state. */\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\t/* Default packet format setting is determined by packet size.\n\t   Anything with a size larger then 9 must have a separate\n\t   count field since the 3 bit count field is otherwise too\n\t   small.  Otherwise we can use the slightly more compact\n\t   format.  This is in accordance with the cypress_m8 serial\n\t   converter app note. */\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\n\tport->port.drain_delay = 256;\n\n\treturn 0;\n}\n",
  "diff_func": "@@ -447,6 +447,11 @@ static int cypress_generic_port_probe(struct usb_serial_port *port)\n \tstruct usb_serial *serial = port->serial;\n \tstruct cypress_private *priv;\n \n+\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n+\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n+\t\treturn -ENODEV;\n+\t}\n+\n \tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n@@ -606,12 +611,6 @@ static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n \t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n \n \t/* setup the port and start reading from the device */\n-\tif (!port->interrupt_in_urb) {\n-\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n-\t\t\t__func__);\n-\t\treturn -1;\n-\t}\n-\n \tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n \t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n \t\tport->interrupt_in_urb->transfer_buffer,",
  "project": "linux",
  "commit_id": "c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754",
  "target": 1,
  "func": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n \tstruct usb_serial *serial = port->serial;\n \tstruct cypress_private *priv;\n \n \tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Skip reset for FRWD device. It is a workaound:\n\t   device hangs if it receives SET_CONFIGURE in Configured\n\t   state. */\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\t/* Default packet format setting is determined by packet size.\n\t   Anything with a size larger then 9 must have a separate\n\t   count field since the 3 bit count field is otherwise too\n\t   small.  Otherwise we can use the slightly more compact\n\t   format.  This is in accordance with the cypress_m8 serial\n\t   converter app note. */\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\n\tport->port.drain_delay = 256;\n\n\treturn 0;\n}\n",
  "big_vul_idx": 180531,
  "idx": 2113,
  "hash": 117115164139605757131025956153091238162,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch adds a check for required USB endpoints to prevent attacks, clearly addressing a security vulnerability. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}