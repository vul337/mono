{
  "id": 908,
  "language": "cpp",
  "cwe": "",
  "commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/3eda5d70aba127bae9bd6bae9956fcf024b64031",
  "commit_sha": "3eda5d70aba127bae9bd6bae9956fcf024b64031",
  "commit_msg": "fixes for DWA uncompress: sanity check unknown data reading, off-by-one error on max suffix string length\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/643",
  "pr_info": "- Prevent out-of-bounds reads by better sanity checking of input data\r\n- Fix memory leaks when exceptions are thrown from constructors when opening broken files\r\n- Fix memory leaks in test suite\r\n",
  "file_name": "OpenEXR/IlmImf/ImfDwaCompressor.cpp",
  "func_name": "",
  "raw_func_from_json": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n            \n        {\n            char suffix[Name::SIZE];\n            memset (suffix, 0, Name::SIZE);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n\n        _caseInsensitive = (value & 1 ? true : false);\n\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }",
  "diff_func": "@@ -268,8 +268,9 @@ struct DwaCompressor::Classifier\n                                 \" (truncated rule).\");\n             \n         {\n-            char suffix[Name::SIZE];\n-            memset (suffix, 0, Name::SIZE);\n+            // maximum length of string plus one byte for terminating NULL\n+            char suffix[Name::SIZE+1];\n+            memset (suffix, 0, Name::SIZE+1);\n             Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n             _suffix = std::string(suffix);\n         }\n@@ -2816,6 +2817,14 @@ DwaCompressor::uncompress\n                     if (IMATH_NAMESPACE::modp (y, cd->ySampling) != 0)\n                         continue;\n \n+                    //\n+                    // sanity check for buffer data lying within range\n+                    //\n+                    if (cd->planarUncBufferEnd + dstScanlineSize - _planarUncBuffer[UNKNOWN] > _planarUncBufferSize[UNKNOWN] )\n+                    {\n+                        throw Iex::InputExc(\"DWA data corrupt\");\n+                    }\n+\n                     memcpy (rowPtrs[chan][row],\n                             cd->planarUncBufferEnd,\n                             dstScanlineSize);",
  "func": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n            \n        {\n            char suffix[Name::SIZE];\n            memset (suffix, 0, Name::SIZE);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n\n        _caseInsensitive = (value & 1 ? true : false);\n\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }",
  "project": "openexr",
  "hash": 286477158467248343403232113020885568232,
  "size": 38,
  "commit_id": "3eda5d70aba127bae9bd6bae9956fcf024b64031",
  "message": "fixes for DWA uncompress: sanity check unknown data reading, off-by-one error on max suffix string length\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
  "target": 1,
  "dataset": "other",
  "idx": 210760,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses two security issues: an off-by-one buffer overflow in the suffix array and a missing sanity check for data reading, both of which could lead to memory corruption or unauthorized access.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}