{
  "id": 887,
  "language": "c",
  "cwe": "CWE-200",
  "commit_url": "https://github.com/sjp38/linux.personal/commit/197e7e521384a23b9e585178f3f11c9fa08274b9",
  "commit_sha": "197e7e521384a23b9e585178f3f11c9fa08274b9",
  "commit_msg": "Sanitize 'move_pages()' permission checks\n\nThe 'move_paghes()' system call was introduced long long ago with the\nsame permission checks as for sending a signal (except using\nCAP_SYS_NICE instead of CAP_SYS_KILL for the overriding capability).\n\nThat turns out to not be a great choice - while the system call really\nonly moves physical page allocations around (and you need other\ncapabilities to do a lot of it), you can check the return value to map\nout some the virtual address choices and defeat ASLR of a binary that\nstill shares your uid.\n\nSo change the access checks to the more common 'ptrace_may_access()'\nmodel instead.\n\nThis tightens the access checks for the uid, and also effectively\nchanges the CAP_SYS_NICE check to CAP_SYS_PTRACE, but it's unlikely that\nanybody really _uses_ this legacy system call any more (we hav ebetter\nNUMA placement models these days), so I expect nobody to notice.\n\nFamous last words.\n\nReported-by: Otto Ebeling <otto.ebeling@iki.fi>\nAcked-by: Eric W. Biederman <ebiederm@xmission.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "mm/migrate.c",
  "func_name": "",
  "raw_func_from_json": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n\tnodemask_t task_nodes;\n\n\t/* Check flags */\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n \n \t/*\n \t * Check if this process has the right to modify the specified\n\t * process. The right exists if the process has administrative\n\t * capabilities, superuser privileges or the same\n\t * userid as the target process.\n \t */\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm)\n\t\treturn -EINVAL;\n\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\n\tmmput(mm);\n\treturn err;\n\nout:\n\tput_task_struct(task);\n\treturn err;\n}\n",
  "diff_func": "@@ -41,6 +41,7 @@\n #include <linux/page_idle.h>\n #include <linux/page_owner.h>\n #include <linux/sched/mm.h>\n+#include <linux/ptrace.h>\n \n #include <asm/tlbflush.h>\n \n@@ -1652,7 +1653,6 @@ SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n-\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n@@ -1676,14 +1676,9 @@ SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n \n \t/*\n \t * Check if this process has the right to modify the specified\n-\t * process. The right exists if the process has administrative\n-\t * capabilities, superuser privileges or the same\n-\t * userid as the target process.\n+\t * process. Use the regular \"ptrace_may_access()\" checks.\n \t */\n-\ttcred = __task_cred(task);\n-\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n-\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n-\t    !capable(CAP_SYS_NICE)) {\n+\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;",
  "project": "linux",
  "commit_id": "197e7e521384a23b9e585178f3f11c9fa08274b9",
  "target": 1,
  "func": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n\tnodemask_t task_nodes;\n\n\t/* Check flags */\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n \n \t/*\n \t * Check if this process has the right to modify the specified\n\t * process. The right exists if the process has administrative\n\t * capabilities, superuser privileges or the same\n\t * userid as the target process.\n \t */\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm)\n\t\treturn -EINVAL;\n\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\n\tmmput(mm);\n\treturn err;\n\nout:\n\tput_task_struct(task);\n\treturn err;\n}\n",
  "big_vul_idx": 180942,
  "idx": 2478,
  "hash": 333020230899744479196439444734213940999,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the permission checks for the 'move_pages()' system call to tighten security by preventing ASLR bypass. The code change replaces existing uid and capability checks with 'ptrace_may_access()', enhancing security.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}