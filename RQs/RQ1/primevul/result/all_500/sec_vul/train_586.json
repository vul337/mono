{
  "id": 586,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/ljalves/linux_media/commit/48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39",
  "commit_sha": "48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39",
  "commit_msg": "virtio-net: drop NETIF_F_FRAGLIST\n\nvirtio declares support for NETIF_F_FRAGLIST, but assumes\nthat there are at most MAX_SKB_FRAGS + 2 fragments which isn't\nalways true with a fraglist.\n\nA longer fraglist in the skb will make the call to skb_to_sgvec overflow\nthe sg array, leading to memory corruption.\n\nDrop NETIF_F_FRAGLIST so we only get what we can handle.\n\nCc: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nAcked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/net/virtio_net.c",
  "func_name": "",
  "raw_func_from_json": "static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err;\n\tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\n\tif (!vdev->config->get) {\n\t\tdev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!virtnet_validate_features(vdev))\n\t\treturn -EINVAL;\n\n\t/* Find if host supports multiqueue virtio_net device */\n\terr = virtio_cread_feature(vdev, VIRTIO_NET_F_MQ,\n\t\t\t\t   struct virtio_net_config,\n\t\t\t\t   max_virtqueue_pairs, &max_queue_pairs);\n\n\t/* We need at least 2 queue's */\n\tif (err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\tdev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\n\tdev->netdev_ops = &virtnet_netdev;\n\tdev->features = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n \t/* Do we support \"hardware\" checksums? */\n \tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n \t\t/* This opens up the world of extra features. */\n\t\tdev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n \t\tif (csum)\n\t\t\tdev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n \n \t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n \t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_UFO))\n\t\t\tdev->hw_features |= NETIF_F_UFO;\n\n\t\tdev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features & (NETIF_F_ALL_TSO|NETIF_F_UFO);\n\t\t/* (!csum && gso) case will be fixed by register_netdev() */\n\t}\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_CSUM))\n\t\tdev->features |= NETIF_F_RXCSUM;\n\n\tdev->vlan_features = dev->features;\n\n\t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MAC))\n\t\tvirtio_cread_bytes(vdev,\n\t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   dev->dev_addr, dev->addr_len);\n\telse\n\t\teth_hw_addr_random(dev);\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\tvi->stats = alloc_percpu(struct virtnet_stats);\n\terr = -ENOMEM;\n\tif (vi->stats == NULL)\n\t\tgoto free;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct virtnet_stats *virtnet_stats;\n\t\tvirtnet_stats = per_cpu_ptr(vi->stats, i);\n\t\tu64_stats_init(&virtnet_stats->tx_syncp);\n\t\tu64_stats_init(&virtnet_stats->rx_syncp);\n\t}\n\n\tINIT_WORK(&vi->config_work, virtnet_config_changed_work);\n\n\t/* If we can receive ANY GSO packets, we must allocate large ones. */\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_ECN) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_UFO))\n\t\tvi->big_packets = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\n\t\tvi->mergeable_rx_bufs = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF) ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT) ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq = true;\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\t/* Use single tx/rx queue pair as default */\n\tvi->curr_queue_pairs = 1;\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\tgoto free_stats;\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\tgoto free_vqs;\n\t}\n\n\tvirtio_device_ready(vdev);\n\n\t/* Last of all, set up some receive buffers. */\n\tfor (i = 0; i < vi->curr_queue_pairs; i++) {\n\t\ttry_fill_recv(vi, &vi->rq[i], GFP_KERNEL);\n\n\t\t/* If we didn't even get one input buffer, we're useless. */\n\t\tif (vi->rq[i].vq->num_free ==\n\t\t    virtqueue_get_vring_size(vi->rq[i].vq)) {\n\t\t\tfree_unused_bufs(vi);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_recv_bufs;\n\t\t}\n\t}\n\n\tvi->nb.notifier_call = &virtnet_cpu_callback;\n\terr = register_hotcpu_notifier(&vi->nb);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering cpu notifier failed\\n\");\n\t\tgoto free_recv_bufs;\n\t}\n\n\t/* Assume link up if device can't report link status,\n\t   otherwise get link status from config. */\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {\n\t\tnetif_carrier_off(dev);\n\t\tschedule_work(&vi->config_work);\n\t} else {\n\t\tvi->status = VIRTIO_NET_S_LINK_UP;\n\t\tnetif_carrier_on(dev);\n\t}\n\n\tpr_debug(\"virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\n\treturn 0;\n\nfree_recv_bufs:\n\tvi->vdev->config->reset(vdev);\n\n\tfree_receive_bufs(vi);\n\tunregister_netdev(dev);\nfree_vqs:\n\tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\nfree_stats:\n\tfree_percpu(vi->stats);\nfree:\n\tfree_netdev(dev);\n\treturn err;\n}\n",
  "diff_func": "@@ -1756,9 +1756,9 @@ static int virtnet_probe(struct virtio_device *vdev)\n \t/* Do we support \"hardware\" checksums? */\n \tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n \t\t/* This opens up the world of extra features. */\n-\t\tdev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n+\t\tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n \t\tif (csum)\n-\t\t\tdev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n+\t\t\tdev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n \n \t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n \t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO",
  "project": "linux",
  "commit_id": "48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39",
  "target": 1,
  "func": "static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err;\n\tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\n\tif (!vdev->config->get) {\n\t\tdev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!virtnet_validate_features(vdev))\n\t\treturn -EINVAL;\n\n\t/* Find if host supports multiqueue virtio_net device */\n\terr = virtio_cread_feature(vdev, VIRTIO_NET_F_MQ,\n\t\t\t\t   struct virtio_net_config,\n\t\t\t\t   max_virtqueue_pairs, &max_queue_pairs);\n\n\t/* We need at least 2 queue's */\n\tif (err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\tdev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\n\tdev->netdev_ops = &virtnet_netdev;\n\tdev->features = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n \t/* Do we support \"hardware\" checksums? */\n \tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n \t\t/* This opens up the world of extra features. */\n\t\tdev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n \t\tif (csum)\n\t\t\tdev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n \n \t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n \t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_UFO))\n\t\t\tdev->hw_features |= NETIF_F_UFO;\n\n\t\tdev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features & (NETIF_F_ALL_TSO|NETIF_F_UFO);\n\t\t/* (!csum && gso) case will be fixed by register_netdev() */\n\t}\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_CSUM))\n\t\tdev->features |= NETIF_F_RXCSUM;\n\n\tdev->vlan_features = dev->features;\n\n\t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MAC))\n\t\tvirtio_cread_bytes(vdev,\n\t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   dev->dev_addr, dev->addr_len);\n\telse\n\t\teth_hw_addr_random(dev);\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\tvi->stats = alloc_percpu(struct virtnet_stats);\n\terr = -ENOMEM;\n\tif (vi->stats == NULL)\n\t\tgoto free;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct virtnet_stats *virtnet_stats;\n\t\tvirtnet_stats = per_cpu_ptr(vi->stats, i);\n\t\tu64_stats_init(&virtnet_stats->tx_syncp);\n\t\tu64_stats_init(&virtnet_stats->rx_syncp);\n\t}\n\n\tINIT_WORK(&vi->config_work, virtnet_config_changed_work);\n\n\t/* If we can receive ANY GSO packets, we must allocate large ones. */\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_ECN) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_UFO))\n\t\tvi->big_packets = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\n\t\tvi->mergeable_rx_bufs = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF) ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT) ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq = true;\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\t/* Use single tx/rx queue pair as default */\n\tvi->curr_queue_pairs = 1;\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\tgoto free_stats;\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\tgoto free_vqs;\n\t}\n\n\tvirtio_device_ready(vdev);\n\n\t/* Last of all, set up some receive buffers. */\n\tfor (i = 0; i < vi->curr_queue_pairs; i++) {\n\t\ttry_fill_recv(vi, &vi->rq[i], GFP_KERNEL);\n\n\t\t/* If we didn't even get one input buffer, we're useless. */\n\t\tif (vi->rq[i].vq->num_free ==\n\t\t    virtqueue_get_vring_size(vi->rq[i].vq)) {\n\t\t\tfree_unused_bufs(vi);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_recv_bufs;\n\t\t}\n\t}\n\n\tvi->nb.notifier_call = &virtnet_cpu_callback;\n\terr = register_hotcpu_notifier(&vi->nb);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering cpu notifier failed\\n\");\n\t\tgoto free_recv_bufs;\n\t}\n\n\t/* Assume link up if device can't report link status,\n\t   otherwise get link status from config. */\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {\n\t\tnetif_carrier_off(dev);\n\t\tschedule_work(&vi->config_work);\n\t} else {\n\t\tvi->status = VIRTIO_NET_S_LINK_UP;\n\t\tnetif_carrier_on(dev);\n\t}\n\n\tpr_debug(\"virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\n\treturn 0;\n\nfree_recv_bufs:\n\tvi->vdev->config->reset(vdev);\n\n\tfree_receive_bufs(vi);\n\tunregister_netdev(dev);\nfree_vqs:\n\tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\nfree_stats:\n\tfree_percpu(vi->stats);\nfree:\n\tfree_netdev(dev);\n\treturn err;\n}\n",
  "big_vul_idx": 179782,
  "idx": 1467,
  "hash": 286743572691752184776898404441994023786,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis**: The commit removes NETIF_F_FRAGLIST from the device's features to prevent an overflow in the sg array, which could cause memory corruption.\n\n2. **Security Vulnerability Assessment**: The change addresses a flaw that could lead to memory corruption, a security issue. Memory corruption can be exploited for arbitrary code execution.\n\n3. **Classification**: The patch fixes a security vulnerability by preventing potential overflow attacks.\n\n4. **Confidence Score**: High confidence (0.95) as the code change clearly targets a security-related issue.",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch removes support for NETIF_F_FRAGLIST to prevent memory corruption caused by overflow, indicating a security fix.\n\n**Final Output:**\nAnalysis: The patch removes support for NETIF_F_FRAGLIST to prevent memory corruption, indicating a security vulnerability fix.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis**: The commit removes NETIF_F_FRAGLIST from the device's features to prevent an overflow in the sg array, which could cause memory corruption.\n\n2. **Security Vulnerability Assessment**: The change addresses a flaw that could lead to memory corruption, a security issue. Memory corruption can be exploited for arbitrary code execution.\n\n3. **Classification**: The patch fixes a security vulnerability by preventing potential overflow attacks.\n\n4. **Confidence Score**: High confidence (0.95) as the code change clearly targets a security-related issue."
}