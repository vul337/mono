{
  "id": 927,
  "language": "c",
  "cwe": "CWE-125",
  "commit_url": "https://github.com/merlinepedra/TCPDUMP/commit/88b2dac837e81cf56dce05e6e7b5989332c0092d",
  "commit_sha": "88b2dac837e81cf56dce05e6e7b5989332c0092d",
  "commit_msg": "CVE-2017-13036/OSPFv3: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "print-ospf6.c",
  "func_name": "",
  "raw_func_from_json": "ospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n \tcase OSPF_TYPE_HELLO: {\n \t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n \n \t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n \t\t          bittok2str(ospf6_option_values, \"none\",\n \t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n",
  "diff_func": "@@ -735,6 +735,7 @@ ospf6_decode_v3(netdissect_options *ndo,\n \tcase OSPF_TYPE_HELLO: {\n \t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n \n+\t\tND_TCHECK_32BITS(&hellop->hello_options);\n \t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n \t\t          bittok2str(ospf6_option_values, \"none\",\n \t\t          EXTRACT_32BITS(&hellop->hello_options))));",
  "project": "tcpdump",
  "commit_id": "88b2dac837e81cf56dce05e6e7b5989332c0092d",
  "target": 1,
  "func": "ospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n \tcase OSPF_TYPE_HELLO: {\n \t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n \n \t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n \t\t          bittok2str(ospf6_option_values, \"none\",\n \t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n",
  "big_vul_idx": 181019,
  "idx": 2541,
  "hash": 290205176660766475590676037302365169806,
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95  \n\n**Analysis:**\nThe patch addresses a buffer over-read vulnerability (CVE-2017-13036) by adding a bounds check, preventing unauthorized data access. The code change is a direct fix for a security issue, making it a clear Security Vulnerability Fix with high confidence.",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95  \n\n**Analysis:**\nThe patch addresses a buffer over-read vulnerability (CVE-2017-13036) by adding a bounds check, preventing unauthorized data access. The code change is a direct fix for a security issue, making it a clear Security Vulnerability Fix with high confidence."
}