{
  "id": 428,
  "language": "c",
  "cwe": "CWE-200",
  "commit_url": "https://github.com/scruiser/kernel/commit/fe685aabf7c8c9f138e5ea900954d295bf229175",
  "commit_sha": "fe685aabf7c8c9f138e5ea900954d295bf229175",
  "commit_msg": "isofs: avoid info leak on export\n\nFor type 1 the parent_offset member in struct isofs_fid gets copied\nuninitialized to userland. Fix this by initializing it to 0.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: Jan Kara <jack@suse.cz>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/isofs/export.c",
  "func_name": "",
  "raw_func_from_json": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\n\t/*\n\t * WARNING: max_len is 5 for NFSv2.  Because of this\n\t * limitation, we use the lower 16 bits of fh32[1] to hold the\n\t * offset of the inode and the upper 16 bits of fh32[1] to\n\t * hold the offset of the parent.\n\t */\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n\n \tlen = 3;\n \tfh32[0] = ei->i_iget5_block;\n  \tfh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */\n \tfh32[2] = inode->i_generation;\n \tif (parent) {\n \t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */\n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}\n",
  "diff_func": "@@ -134,6 +134,7 @@ isofs_export_encode_fh(struct inode *inode,\n \tlen = 3;\n \tfh32[0] = ei->i_iget5_block;\n  \tfh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */\n+\tfh16[3] = 0;  /* avoid leaking uninitialized data */\n \tfh32[2] = inode->i_generation;\n \tif (parent) {\n \t\tstruct iso_inode_info *eparent;",
  "project": "linux",
  "commit_id": "fe685aabf7c8c9f138e5ea900954d295bf229175",
  "target": 1,
  "func": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\n\t/*\n\t * WARNING: max_len is 5 for NFSv2.  Because of this\n\t * limitation, we use the lower 16 bits of fh32[1] to hold the\n\t * offset of the inode and the upper 16 bits of fh32[1] to\n\t * hold the offset of the parent.\n\t */\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n\n \tlen = 3;\n \tfh32[0] = ei->i_iget5_block;\n  \tfh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */\n \tfh32[2] = inode->i_generation;\n \tif (parent) {\n \t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */\n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}\n",
  "big_vul_idx": 179349,
  "idx": 1124,
  "hash": 175765004232940692877706715077624484230,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch initializes a variable to prevent uninitialized data from being exposed to userland, addressing an information leak which is a security issue.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}