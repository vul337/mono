{
  "id": 182,
  "language": "h",
  "cwe": "CWE-189",
  "commit_url": "https://github.com/luluandleilei/openssl/commit/1fb9fdc3027b27d8eb6a1e6a846435b070980770",
  "commit_sha": "1fb9fdc3027b27d8eb6a1e6a846435b070980770",
  "commit_msg": "Fix DTLS replay protection\n\nThe DTLS implementation provides some protection against replay attacks\nin accordance with RFC6347 section 4.1.2.6.\n\nA sliding \"window\" of valid record sequence numbers is maintained with\nthe \"right\" hand edge of the window set to the highest sequence number we\nhave received so far. Records that arrive that are off the \"left\" hand\nedge of the window are rejected. Records within the window are checked\nagainst a list of records received so far. If we already received it then\nwe also reject the new record.\n\nIf we have not already received the record, or the sequence number is off\nthe right hand edge of the window then we verify the MAC of the record.\nIf MAC verification fails then we discard the record. Otherwise we mark\nthe record as received. If the sequence number was off the right hand edge\nof the window, then we slide the window along so that the right hand edge\nis in line with the newly received sequence number.\n\nRecords may arrive for future epochs, i.e. a record from after a CCS being\nsent, can arrive before the CCS does if the packets get re-ordered. As we\nhave not yet received the CCS we are not yet in a position to decrypt or\nvalidate the MAC of those records. OpenSSL places those records on an\nunprocessed records queue. It additionally updates the window immediately,\neven though we have not yet verified the MAC. This will only occur if\ncurrently in a handshake/renegotiation.\n\nThis could be exploited by an attacker by sending a record for the next\nepoch (which does not have to decrypt or have a valid MAC), with a very\nlarge sequence number. This means the right hand edge of the window is\nmoved very far to the right, and all subsequent legitimate packets are\ndropped causing a denial of service.\n\nA similar effect can be achieved during the initial handshake. In this\ncase there is no MAC key negotiated yet. Therefore an attacker can send a\nmessage for the current epoch with a very large sequence number. The code\nwill process the record as normal. If the hanshake message sequence number\n(as opposed to the record sequence number that we have been talking about\nso far) is in the future then the injected message is bufferred to be\nhandled later, but the window is still updated. Therefore all subsequent\nlegitimate handshake records are dropped. This aspect is not considered a\nsecurity issue because there are many ways for an attacker to disrupt the\ninitial handshake and prevent it from completing successfully (e.g.\ninjection of a handshake message will cause the Finished MAC to fail and\nthe handshake to be aborted). This issue comes about as a result of trying\nto do replay protection, but having no integrity mechanism in place yet.\nDoes it even make sense to have replay protection in epoch 0? That\nissue isn't addressed here though.\n\nThis addressed an OCAP Audit issue.\n\nCVE-2016-2181\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "include/openssl/ssl.h",
  "func_name": "",
  "raw_func_from_json": "int dtls1_process_buffered_records(SSL *s)\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n \n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         /* Check if epoch is current. */\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return (1);         /* Nothing to do. */\n \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n \n             */\n            return 1;\n        }\n\n        /* Process all the records. */\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n         /* Process all the records. */\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <\n                0)\n                return -1;\n         }\n     }\n \n *             here, anything else is handled by higher layers\n *     Application data protocol\n *             none of our business\n */\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n \n    return (1);\n }\n",
  "diff_func": "@@ -2066,6 +2066,7 @@ int ERR_load_SSL_strings(void);\n # define SSL_F_DTLS1_CHECK_TIMEOUT_NUM                    318\n # define SSL_F_DTLS1_HEARTBEAT                            305\n # define SSL_F_DTLS1_PREPROCESS_FRAGMENT                  288\n+# define SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS             423\n # define SSL_F_DTLS1_PROCESS_RECORD                       257\n # define SSL_F_DTLS1_READ_BYTES                           258\n # define SSL_F_DTLS1_READ_FAILED                          339",
  "project": "openssl",
  "commit_id": "1fb9fdc3027b27d8eb6a1e6a846435b070980770",
  "target": 1,
  "func": "int dtls1_process_buffered_records(SSL *s)\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n \n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         /* Check if epoch is current. */\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return (1);         /* Nothing to do. */\n \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n \n             */\n            return 1;\n        }\n\n        /* Process all the records. */\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n         /* Process all the records. */\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <\n                0)\n                return -1;\n         }\n     }\n \n *             here, anything else is handled by higher layers\n *     Application data protocol\n *             none of our business\n */\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n \n    return (1);\n }\n",
  "big_vul_idx": 178366,
  "idx": 371,
  "hash": 299136167801831334632170022306068067325,
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses a replay attack vulnerability in DTLS, preventing an attacker from causing a denial of service. The code change introduces a new function to handle buffered records correctly, mitigating the security issue.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}