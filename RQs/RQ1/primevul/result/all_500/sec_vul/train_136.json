{
  "id": 136,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/luluandleilei/openssl/commit/e97763c92c655dcf4af2860b3abd2bc4c8a267f9",
  "commit_sha": "e97763c92c655dcf4af2860b3abd2bc4c8a267f9",
  "commit_msg": "Sanity check ticket length.\n\nIf a ticket callback changes the HMAC digest to SHA512 the existing\nsanity checks are not sufficient and an attacker could perform a DoS\nattack with a malformed ticket. Add additional checks based on\nHMAC size.\n\nThanks to Shi Lei for reporting this bug.\n\nCVE-2016-6302\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "ssl/t1_lib.c",
  "func_name": "",
  "raw_func_from_json": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n                              int eticklen, const unsigned char *sess_id,\n                              int sesslen, SSL_SESSION **psess)\n{\n    SSL_SESSION *sess;\n    unsigned char *sdec;\n    const unsigned char *p;\n    int slen, mlen, renew_ticket = 0, ret = -1;\n    unsigned char tick_hmac[EVP_MAX_MD_SIZE];\n     HMAC_CTX *hctx = NULL;\n     EVP_CIPHER_CTX *ctx;\n     SSL_CTX *tctx = s->initial_ctx;\n    /* Need at least keyname + iv + some encrypted data */\n    if (eticklen < 48)\n        return 2;\n     /* Initialize session ticket encryption and HMAC contexts */\n     hctx = HMAC_CTX_new();\n     if (hctx == NULL)\n    hctx = HMAC_CTX_new();\n    if (hctx == NULL)\n        return -2;\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        ret = -2;\n        goto err;\n    }\n    if (tctx->tlsext_ticket_key_cb) {\n        unsigned char *nctick = (unsigned char *)etick;\n        int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n                                            ctx, hctx, 0);\n        if (rv < 0)\n            goto err;\n        if (rv == 0) {\n            ret = 2;\n            goto err;\n        }\n        if (rv == 2)\n            renew_ticket = 1;\n    } else {\n        /* Check key name matches */\n        if (memcmp(etick, tctx->tlsext_tick_key_name,\n                   sizeof(tctx->tlsext_tick_key_name)) != 0) {\n            ret = 2;\n            goto err;\n        }\n        if (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,\n                         sizeof(tctx->tlsext_tick_hmac_key),\n                         EVP_sha256(), NULL) <= 0\n            || EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,\n                                  tctx->tlsext_tick_aes_key,\n                                  etick + sizeof(tctx->tlsext_tick_key_name)) <=\n            0) {\n            goto err;\n        }\n    }\n    /*\n     * Attempt to process session ticket, first conduct sanity and integrity\n     * checks on ticket.\n     if (mlen < 0) {\n         goto err;\n     }\n     eticklen -= mlen;\n     /* Check HMAC of encrypted ticket */\n     if (HMAC_Update(hctx, etick, eticklen) <= 0\n    if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return 2;\n    }\n    /* Attempt to decrypt session data */\n    /* Move p after IV to start of encrypted ticket, update length */\n    p = etick + 16 + EVP_CIPHER_CTX_iv_length(ctx);\n    eticklen -= 16 + EVP_CIPHER_CTX_iv_length(ctx);\n    sdec = OPENSSL_malloc(eticklen);\n    if (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return -1;\n    }\n    if (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return 2;\n    }\n    slen += mlen;\n    EVP_CIPHER_CTX_free(ctx);\n    ctx = NULL;\n    p = sdec;\n\n    sess = d2i_SSL_SESSION(NULL, &p, slen);\n    OPENSSL_free(sdec);\n    if (sess) {\n        /*\n         * The session ID, if non-empty, is used by some clients to detect\n         * that the ticket has been accepted. So we copy it to the session\n         * structure. If it is empty set length to zero as required by\n         * standard.\n         */\n        if (sesslen)\n            memcpy(sess->session_id, sess_id, sesslen);\n        sess->session_id_length = sesslen;\n        *psess = sess;\n        if (renew_ticket)\n            return 4;\n        else\n            return 3;\n    }\n    ERR_clear_error();\n    /*\n     * For session parse failure, indicate that we need to send a new ticket.\n     */\n    return 2;\n err:\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    return ret;\n}\n",
  "diff_func": "@@ -2969,9 +2969,7 @@ static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n     HMAC_CTX *hctx = NULL;\n     EVP_CIPHER_CTX *ctx;\n     SSL_CTX *tctx = s->initial_ctx;\n-    /* Need at least keyname + iv + some encrypted data */\n-    if (eticklen < 48)\n-        return 2;\n+\n     /* Initialize session ticket encryption and HMAC contexts */\n     hctx = HMAC_CTX_new();\n     if (hctx == NULL)\n@@ -3018,6 +3016,12 @@ static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n     if (mlen < 0) {\n         goto err;\n     }\n+    /* Sanity check ticket length: must exceed keyname + IV + HMAC */\n+    if (eticklen <=\n+        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {\n+        ret = 2;\n+        goto err;\n+    }\n     eticklen -= mlen;\n     /* Check HMAC of encrypted ticket */\n     if (HMAC_Update(hctx, etick, eticklen) <= 0",
  "project": "openssl",
  "commit_id": "e97763c92c655dcf4af2860b3abd2bc4c8a267f9",
  "target": 1,
  "func": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n                              int eticklen, const unsigned char *sess_id,\n                              int sesslen, SSL_SESSION **psess)\n{\n    SSL_SESSION *sess;\n    unsigned char *sdec;\n    const unsigned char *p;\n    int slen, mlen, renew_ticket = 0, ret = -1;\n    unsigned char tick_hmac[EVP_MAX_MD_SIZE];\n     HMAC_CTX *hctx = NULL;\n     EVP_CIPHER_CTX *ctx;\n     SSL_CTX *tctx = s->initial_ctx;\n    /* Need at least keyname + iv + some encrypted data */\n    if (eticklen < 48)\n        return 2;\n     /* Initialize session ticket encryption and HMAC contexts */\n     hctx = HMAC_CTX_new();\n     if (hctx == NULL)\n    hctx = HMAC_CTX_new();\n    if (hctx == NULL)\n        return -2;\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        ret = -2;\n        goto err;\n    }\n    if (tctx->tlsext_ticket_key_cb) {\n        unsigned char *nctick = (unsigned char *)etick;\n        int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n                                            ctx, hctx, 0);\n        if (rv < 0)\n            goto err;\n        if (rv == 0) {\n            ret = 2;\n            goto err;\n        }\n        if (rv == 2)\n            renew_ticket = 1;\n    } else {\n        /* Check key name matches */\n        if (memcmp(etick, tctx->tlsext_tick_key_name,\n                   sizeof(tctx->tlsext_tick_key_name)) != 0) {\n            ret = 2;\n            goto err;\n        }\n        if (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,\n                         sizeof(tctx->tlsext_tick_hmac_key),\n                         EVP_sha256(), NULL) <= 0\n            || EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,\n                                  tctx->tlsext_tick_aes_key,\n                                  etick + sizeof(tctx->tlsext_tick_key_name)) <=\n            0) {\n            goto err;\n        }\n    }\n    /*\n     * Attempt to process session ticket, first conduct sanity and integrity\n     * checks on ticket.\n     if (mlen < 0) {\n         goto err;\n     }\n     eticklen -= mlen;\n     /* Check HMAC of encrypted ticket */\n     if (HMAC_Update(hctx, etick, eticklen) <= 0\n    if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return 2;\n    }\n    /* Attempt to decrypt session data */\n    /* Move p after IV to start of encrypted ticket, update length */\n    p = etick + 16 + EVP_CIPHER_CTX_iv_length(ctx);\n    eticklen -= 16 + EVP_CIPHER_CTX_iv_length(ctx);\n    sdec = OPENSSL_malloc(eticklen);\n    if (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return -1;\n    }\n    if (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return 2;\n    }\n    slen += mlen;\n    EVP_CIPHER_CTX_free(ctx);\n    ctx = NULL;\n    p = sdec;\n\n    sess = d2i_SSL_SESSION(NULL, &p, slen);\n    OPENSSL_free(sdec);\n    if (sess) {\n        /*\n         * The session ID, if non-empty, is used by some clients to detect\n         * that the ticket has been accepted. So we copy it to the session\n         * structure. If it is empty set length to zero as required by\n         * standard.\n         */\n        if (sesslen)\n            memcpy(sess->session_id, sess_id, sesslen);\n        sess->session_id_length = sesslen;\n        *psess = sess;\n        if (renew_ticket)\n            return 4;\n        else\n            return 3;\n    }\n    ERR_clear_error();\n    /*\n     * For session parse failure, indicate that we need to send a new ticket.\n     */\n    return 2;\n err:\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    return ret;\n}\n",
  "big_vul_idx": 178138,
  "idx": 250,
  "hash": 2230119928438274047665345409737174926,
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security vulnerability by enhancing ticket length checks to prevent DoS attacks. The commit message references CVE-2016-6302, indicating a security fix. The code changes replace a static length check with a dynamic one, improving security.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}