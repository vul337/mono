{
  "id": 103,
  "language": "unknown",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/TinkerBoard-Android/rockchip-android-external-freetype/commit/18a8f0d9943369449bc4de92d411c78fb08d616c",
  "commit_sha": "18a8f0d9943369449bc4de92d411c78fb08d616c",
  "commit_msg": "Fix Savannah bug #43540.\n\n* src/base/ftmac.c (parse_fond): Prevent a buffer overrun\ncaused by a font including too many (> 63) strings to store\nnames[] table.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "ChangeLog",
  "func_name": "",
  "raw_func_from_json": "  parse_fond( char*   fond_data,\n              short*  have_sfnt,\n              ResID*  sfnt_id,\n              Str255  lwfn_file_name,\n              short   face_index )\n  {\n    AsscEntry*  assoc;\n    AsscEntry*  base_assoc;\n    FamRec*     fond;\n\n\n    *sfnt_id          = 0;\n    *have_sfnt        = 0;\n    lwfn_file_name[0] = 0;\n\n    fond       = (FamRec*)fond_data;\n    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\n    base_assoc = assoc;\n\n    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */\n    if ( 47 < face_index )\n      return;\n\n    /* Let's do a little range checking before we get too excited here */\n    if ( face_index < count_faces_sfnt( fond_data ) )\n    {\n      assoc += face_index;        /* add on the face_index! */\n\n      /* if the face at this index is not scalable,\n         fall back to the first one (old behavior) */\n      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( assoc->fontID );\n      }\n      else if ( base_assoc->fontSize == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n      }\n    }\n\n    if ( EndianS32_BtoN( fond->ffStylOff ) )\n    {\n      unsigned char*  p = (unsigned char*)fond_data;\n      StyleTable*     style;\n      unsigned short  string_count;\n      char            ps_name[256];\n      unsigned char*  names[64];\n      int             i;\n\n\n      p += EndianS32_BtoN( fond->ffStylOff );\n       style = (StyleTable*)p;\n       p += sizeof ( StyleTable );\n       string_count = EndianS16_BtoN( *(short*)(p) );\n       p += sizeof ( short );\n \n      for ( i = 0; i < string_count && i < 64; i++ )\n       {\n         names[i] = p;\n         p       += names[i][0];\n      }\n\n      {\n        size_t  ps_name_len = (size_t)names[0][0];\n\n\n        if ( ps_name_len != 0 )\n        {\n          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n          ps_name[ps_name_len] = 0;\n           ps_name[ps_name_len] = 0;\n         }\n         if ( style->indexes[face_index] > 1 &&\n             style->indexes[face_index] <= FT_MIN( string_count, 64 ) )\n         {\n           unsigned char*  suffixes = names[style->indexes[face_index] - 1];\n          for ( i = 1; i <= suffixes[0]; i++ )\n          {\n            unsigned char*  s;\n            size_t          j = suffixes[i] - 1;\n\n\n            if ( j < string_count && ( s = names[j] ) != NULL )\n            {\n              size_t  s_len = (size_t)s[0];\n\n\n              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n              {\n                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );\n                ps_name_len += s_len;\n                ps_name[ps_name_len] = 0;\n              }\n            }\n          }\n        }\n      }\n\n      create_lwfn_name( ps_name, lwfn_file_name );\n    }\n  }\n",
  "diff_func": "@@ -1,3 +1,11 @@\n+2014-11-26  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>\n+\n+\tFix Savannah bug #43540.\n+\n+\t* src/base/ftmac.c (parse_fond): Prevent a buffer overrun\n+\tcaused by a font including too many (> 63) strings to store\n+\tnames[] table.\n+\n 2014-11-26  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>\n \n \t* src/base/ftobjs.c (Mac_Read_POST_Resource): Use unsigned long",
  "project": "savannah",
  "commit_id": "18a8f0d9943369449bc4de92d411c78fb08d616c",
  "target": 1,
  "func": "  parse_fond( char*   fond_data,\n              short*  have_sfnt,\n              ResID*  sfnt_id,\n              Str255  lwfn_file_name,\n              short   face_index )\n  {\n    AsscEntry*  assoc;\n    AsscEntry*  base_assoc;\n    FamRec*     fond;\n\n\n    *sfnt_id          = 0;\n    *have_sfnt        = 0;\n    lwfn_file_name[0] = 0;\n\n    fond       = (FamRec*)fond_data;\n    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );\n    base_assoc = assoc;\n\n    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */\n    if ( 47 < face_index )\n      return;\n\n    /* Let's do a little range checking before we get too excited here */\n    if ( face_index < count_faces_sfnt( fond_data ) )\n    {\n      assoc += face_index;        /* add on the face_index! */\n\n      /* if the face at this index is not scalable,\n         fall back to the first one (old behavior) */\n      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( assoc->fontID );\n      }\n      else if ( base_assoc->fontSize == 0 )\n      {\n        *have_sfnt = 1;\n        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );\n      }\n    }\n\n    if ( EndianS32_BtoN( fond->ffStylOff ) )\n    {\n      unsigned char*  p = (unsigned char*)fond_data;\n      StyleTable*     style;\n      unsigned short  string_count;\n      char            ps_name[256];\n      unsigned char*  names[64];\n      int             i;\n\n\n      p += EndianS32_BtoN( fond->ffStylOff );\n       style = (StyleTable*)p;\n       p += sizeof ( StyleTable );\n       string_count = EndianS16_BtoN( *(short*)(p) );\n       p += sizeof ( short );\n \n      for ( i = 0; i < string_count && i < 64; i++ )\n       {\n         names[i] = p;\n         p       += names[i][0];\n      }\n\n      {\n        size_t  ps_name_len = (size_t)names[0][0];\n\n\n        if ( ps_name_len != 0 )\n        {\n          ft_memcpy(ps_name, names[0] + 1, ps_name_len);\n          ps_name[ps_name_len] = 0;\n           ps_name[ps_name_len] = 0;\n         }\n         if ( style->indexes[face_index] > 1 &&\n             style->indexes[face_index] <= FT_MIN( string_count, 64 ) )\n         {\n           unsigned char*  suffixes = names[style->indexes[face_index] - 1];\n          for ( i = 1; i <= suffixes[0]; i++ )\n          {\n            unsigned char*  s;\n            size_t          j = suffixes[i] - 1;\n\n\n            if ( j < string_count && ( s = names[j] ) != NULL )\n            {\n              size_t  s_len = (size_t)s[0];\n\n\n              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )\n              {\n                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );\n                ps_name_len += s_len;\n                ps_name[ps_name_len] = 0;\n              }\n            }\n          }\n        }\n      }\n\n      create_lwfn_name( ps_name, lwfn_file_name );\n    }\n  }\n",
  "big_vul_idx": 178014,
  "idx": 179,
  "hash": 233045259701863811358636688341910118112,
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a buffer overflow vulnerability, a critical security issue that could allow unauthorized access or code execution.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}