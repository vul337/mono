{
  "id": 524,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/ljalves/linux_media/commit/2690d97ade05c5325cbf7c72b94b90d265659886",
  "commit_sha": "2690d97ade05c5325cbf7c72b94b90d265659886",
  "commit_msg": "netfilter: nf_nat: fix access to uninitialized buffer in IRC NAT helper\n\nCommit 5901b6be885e attempted to introduce IPv6 support into\nIRC NAT helper. By doing so, the following code seemed to be removed\nby accident:\n\n  ip = ntohl(exp->master->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip);\n  sprintf(buffer, \"%u %u\", ip, port);\n  pr_debug(\"nf_nat_irc: inserting '%s' == %pI4, port %u\\n\", buffer, &ip, port);\n\nThis leads to the fact that buffer[] was left uninitialized and\ncontained some stack value. When we call nf_nat_mangle_tcp_packet(),\nwe call strlen(buffer) on excatly this uninitialized buffer. If we\nare unlucky and the skb has enough tailroom, we overwrite resp. leak\ncontents with values that sit on our stack into the packet and send\nthat out to the receiver.\n\nSince the rather informal DCC spec [1] does not seem to specify\nIPv6 support right now, we log such occurences so that admins can\nact accordingly, and drop the packet. I've looked into XChat source,\nand IPv6 is not supported there: addresses are in u32 and print\nvia %u format string.\n\nTherefore, restore old behaviour as in IPv4, use snprintf(). The\nIRC helper does not support IPv6 by now. By this, we can safely use\nstrlen(buffer) in nf_nat_mangle_tcp_packet() and prevent a buffer\noverflow. Also simplify some code as we now have ct variable anyway.\n\n  [1] http://www.irchelp.org/irchelp/rfc/ctcpspec.html\n\nFixes: 5901b6be885e (\"netfilter: nf_nat: support IPv6 in IRC NAT helper\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Harald Welte <laforge@gnumonks.org>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/netfilter/nf_nat_irc.c",
  "func_name": "",
  "raw_func_from_json": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n \tu_int16_t port;\n \tunsigned int ret;\n \n \t/* Reply comes from server. */\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n\n\t/* Try to get same port: if not, try to change it. */\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n \n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n \treturn ret;\n }\n",
  "diff_func": "@@ -34,10 +34,14 @@ static unsigned int help(struct sk_buff *skb,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n+\tstruct nf_conn *ct = exp->master;\n+\tunion nf_inet_addr newaddr;\n \tu_int16_t port;\n \tunsigned int ret;\n \n \t/* Reply comes from server. */\n+\tnewaddr = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3;\n+\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n@@ -57,17 +61,35 @@ static unsigned int help(struct sk_buff *skb,\n \t}\n \n \tif (port == 0) {\n-\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n+\t\tnf_ct_helper_log(skb, ct, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n \n-\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n-\t\t\t\t       protoff, matchoff, matchlen, buffer,\n-\t\t\t\t       strlen(buffer));\n+\t/* strlen(\"\\1DCC CHAT chat AAAAAAAA P\\1\\n\")=27\n+\t * strlen(\"\\1DCC SCHAT chat AAAAAAAA P\\1\\n\")=28\n+\t * strlen(\"\\1DCC SEND F AAAAAAAA P S\\1\\n\")=26\n+\t * strlen(\"\\1DCC MOVE F AAAAAAAA P S\\1\\n\")=26\n+\t * strlen(\"\\1DCC TSEND F AAAAAAAA P S\\1\\n\")=27\n+\t *\n+\t * AAAAAAAAA: bound addr (1.0.0.0==16777216, min 8 digits,\n+\t *                        255.255.255.255==4294967296, 10 digits)\n+\t * P:         bound port (min 1 d, max 5d (65635))\n+\t * F:         filename   (min 1 d )\n+\t * S:         size       (min 1 d )\n+\t * 0x01, \\n:  terminators\n+\t */\n+\t/* AAA = \"us\", ie. where server normally talks to. */\n+\tsnprintf(buffer, sizeof(buffer), \"%u %u\", ntohl(newaddr.ip), port);\n+\tpr_debug(\"nf_nat_irc: inserting '%s' == %pI4, port %u\\n\",\n+\t\t buffer, &newaddr.ip, port);\n+\n+\tret = nf_nat_mangle_tcp_packet(skb, ct, ctinfo, protoff, matchoff,\n+\t\t\t\t       matchlen, buffer, strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n-\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n+\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n+\n \treturn ret;\n }\n ",
  "project": "linux",
  "commit_id": "2690d97ade05c5325cbf7c72b94b90d265659886",
  "target": 1,
  "func": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n \tu_int16_t port;\n \tunsigned int ret;\n \n \t/* Reply comes from server. */\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n\n\t/* Try to get same port: if not, try to change it. */\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n \n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n \treturn ret;\n }\n",
  "big_vul_idx": 179608,
  "idx": 1325,
  "hash": 59351750141192127461878933880847518584
}