{
  "id": 710,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/DennissimOS/platform_external_libxml2/commit/f0709e3ca8f8947f2d91ed34e92e38a4c23eae63",
  "commit_sha": "f0709e3ca8f8947f2d91ed34e92e38a4c23eae63",
  "commit_msg": "CVE-2015-8035 Fix XZ compression support loop\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=757466\nDoS when parsing specially crafted XML document if XZ support\nis compiled in (which wasn't the case for 2.9.2 and master since\nNov 2013, fixed in next commit !)",
  "pr_url": null,
  "pr_info": null,
  "file_name": "xzlib.c",
  "func_name": "",
  "raw_func_from_json": "xz_decomp(xz_statep state)\n{\n    int ret;\n    unsigned had;\n    unsigned long crc, len;\n    lzma_stream *strm = &(state->strm);\n\n    lzma_action action = LZMA_RUN;\n\n    /* fill output buffer up to end of deflate stream */\n    had = strm->avail_out;\n    do {\n        /* get more input for inflate() */\n        if (strm->avail_in == 0 && xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0) {\n            xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n            return -1;\n        }\n        if (state->eof)\n            action = LZMA_FINISH;\n\n        /* decompress and handle errors */\n#ifdef HAVE_ZLIB_H\n        if (state->how == GZIP) {\n            state->zstrm.avail_in = (uInt) state->strm.avail_in;\n            state->zstrm.next_in = (Bytef *) state->strm.next_in;\n            state->zstrm.avail_out = (uInt) state->strm.avail_out;\n            state->zstrm.next_out = (Bytef *) state->strm.next_out;\n            ret = inflate(&state->zstrm, Z_NO_FLUSH);\n            if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n                xz_error(state, Z_STREAM_ERROR,\n                         \"internal error: inflate stream corrupt\");\n                return -1;\n            }\n            if (ret == Z_MEM_ERROR)\n                ret = LZMA_MEM_ERROR;\n            if (ret == Z_DATA_ERROR)\n                ret = LZMA_DATA_ERROR;\n            if (ret == Z_STREAM_END)\n                ret = LZMA_STREAM_END;\n            state->strm.avail_in = state->zstrm.avail_in;\n            state->strm.next_in = state->zstrm.next_in;\n            state->strm.avail_out = state->zstrm.avail_out;\n            state->strm.next_out = state->zstrm.next_out;\n        } else                  /* state->how == LZMA */\n#endif\n            ret = lzma_code(strm, action);\n        if (ret == LZMA_MEM_ERROR) {\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        if (ret == LZMA_DATA_ERROR) {\n            xz_error(state, LZMA_DATA_ERROR, \"compressed data error\");\n            return -1;\n        }\n    } while (strm->avail_out && ret != LZMA_STREAM_END);\n\n    /* update available output and crc check value */\n    state->have = had - strm->avail_out;\n    state->next = strm->next_out - state->have;\n#ifdef HAVE_ZLIB_H\n    state->zstrm.adler =\n        crc32(state->zstrm.adler, state->next, state->have);\n#endif\n\n    if (ret == LZMA_STREAM_END) {\n#ifdef HAVE_ZLIB_H\n        if (state->how == GZIP) {\n            if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {\n                xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n                return -1;\n            }\n            if (crc != state->zstrm.adler) {\n                xz_error(state, LZMA_DATA_ERROR, \"incorrect data check\");\n                return -1;\n            }\n            if (len != (state->zstrm.total_out & 0xffffffffL)) {\n                xz_error(state, LZMA_DATA_ERROR, \"incorrect length check\");\n                return -1;\n            }\n            state->strm.avail_in = 0;\n            state->strm.next_in = NULL;\n            state->strm.avail_out = 0;\n            state->strm.next_out = NULL;\n        } else\n#endif\n        if (strm->avail_in != 0 || !state->eof) {\n            xz_error(state, LZMA_DATA_ERROR, \"trailing garbage\");\n            return -1;\n        }\n        state->how = LOOK;      /* ready for next stream, once have is 0 (leave\n                                 * state->direct unchanged to remember how) */\n    }\n\n    /* good decompression */\n    return 0;\n}",
  "diff_func": "@@ -581,6 +581,10 @@ xz_decomp(xz_statep state)\n             xz_error(state, LZMA_DATA_ERROR, \"compressed data error\");\n             return -1;\n         }\n+        if (ret == LZMA_PROG_ERROR) {\n+            xz_error(state, LZMA_PROG_ERROR, \"compression error\");\n+            return -1;\n+        }\n     } while (strm->avail_out && ret != LZMA_STREAM_END);\n \n     /* update available output and crc check value */",
  "func": "xz_decomp(xz_statep state)\n{\n    int ret;\n    unsigned had;\n    unsigned long crc, len;\n    lzma_stream *strm = &(state->strm);\n\n    lzma_action action = LZMA_RUN;\n\n    /* fill output buffer up to end of deflate stream */\n    had = strm->avail_out;\n    do {\n        /* get more input for inflate() */\n        if (strm->avail_in == 0 && xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0) {\n            xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n            return -1;\n        }\n        if (state->eof)\n            action = LZMA_FINISH;\n\n        /* decompress and handle errors */\n#ifdef HAVE_ZLIB_H\n        if (state->how == GZIP) {\n            state->zstrm.avail_in = (uInt) state->strm.avail_in;\n            state->zstrm.next_in = (Bytef *) state->strm.next_in;\n            state->zstrm.avail_out = (uInt) state->strm.avail_out;\n            state->zstrm.next_out = (Bytef *) state->strm.next_out;\n            ret = inflate(&state->zstrm, Z_NO_FLUSH);\n            if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n                xz_error(state, Z_STREAM_ERROR,\n                         \"internal error: inflate stream corrupt\");\n                return -1;\n            }\n            if (ret == Z_MEM_ERROR)\n                ret = LZMA_MEM_ERROR;\n            if (ret == Z_DATA_ERROR)\n                ret = LZMA_DATA_ERROR;\n            if (ret == Z_STREAM_END)\n                ret = LZMA_STREAM_END;\n            state->strm.avail_in = state->zstrm.avail_in;\n            state->strm.next_in = state->zstrm.next_in;\n            state->strm.avail_out = state->zstrm.avail_out;\n            state->strm.next_out = state->zstrm.next_out;\n        } else                  /* state->how == LZMA */\n#endif\n            ret = lzma_code(strm, action);\n        if (ret == LZMA_MEM_ERROR) {\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        if (ret == LZMA_DATA_ERROR) {\n            xz_error(state, LZMA_DATA_ERROR, \"compressed data error\");\n            return -1;\n        }\n    } while (strm->avail_out && ret != LZMA_STREAM_END);\n\n    /* update available output and crc check value */\n    state->have = had - strm->avail_out;\n    state->next = strm->next_out - state->have;\n#ifdef HAVE_ZLIB_H\n    state->zstrm.adler =\n        crc32(state->zstrm.adler, state->next, state->have);\n#endif\n\n    if (ret == LZMA_STREAM_END) {\n#ifdef HAVE_ZLIB_H\n        if (state->how == GZIP) {\n            if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {\n                xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n                return -1;\n            }\n            if (crc != state->zstrm.adler) {\n                xz_error(state, LZMA_DATA_ERROR, \"incorrect data check\");\n                return -1;\n            }\n            if (len != (state->zstrm.total_out & 0xffffffffL)) {\n                xz_error(state, LZMA_DATA_ERROR, \"incorrect length check\");\n                return -1;\n            }\n            state->strm.avail_in = 0;\n            state->strm.next_in = NULL;\n            state->strm.avail_out = 0;\n            state->strm.next_out = NULL;\n        } else\n#endif\n        if (strm->avail_in != 0 || !state->eof) {\n            xz_error(state, LZMA_DATA_ERROR, \"trailing garbage\");\n            return -1;\n        }\n        state->how = LOOK;      /* ready for next stream, once have is 0 (leave\n                                 * state->direct unchanged to remember how) */\n    }\n\n    /* good decompression */\n    return 0;\n}",
  "project": "libxml2",
  "hash": 325103388462275924711924070031298132490,
  "size": 98,
  "commit_id": "f0709e3ca8f8947f2d91ed34e92e38a4c23eae63",
  "message": "CVE-2015-8035 Fix XZ compression support loop\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=757466\nDoS when parsing specially crafted XML document if XZ support\nis compiled in (which wasn't the case for 2.9.2 and master since\nNov 2013, fixed in next commit !)",
  "target": 1,
  "dataset": "other",
  "idx": 204281
}