{
  "id": 743,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/Seagate/cortx-s3server/commit/dd6bfbc4b84f14f898598922ca9efd5aaa645c5d",
  "commit_sha": "dd6bfbc4b84f14f898598922ca9efd5aaa645c5d",
  "commit_msg": "avoid the unrelesed lock after the method returns (#1041)\n\nUpdate s3_memory_pool.c. Avoid the unreleased lock pool->lock after the method returns.\r\n\r\nCo-authored-by: nileshgovande <63101371+nileshgovande@users.noreply.github.com>",
  "pr_url": "https://github.com/Seagate/cortx-s3server/pull/1041",
  "pr_info": "Update s3_memory_pool.c. Avoid the unreleased lock pool->lock after the method returns. This patch for issue#1037.",
  "file_name": "mempool/s3_memory_pool.c",
  "func_name": "",
  "raw_func_from_json": "int mempool_destroy(MemoryPoolHandle *handle) {\n  struct mempool *pool = NULL;\n  struct memory_pool_element *pool_item;\n  char *log_msg_fmt = \"mempool(%p): free(%p) called for buffer size(%zu)\";\n  char log_msg[200];\n\n  if (handle == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  pool = (struct mempool *)*handle;\n  if (pool == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n\n  if (*handle == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  /* reset the handle */\n  *handle = NULL;\n  /* Free the items in free list */\n  pool_item = pool->free_list;\n  while (pool_item != NULL) {\n    pool->free_list = pool_item->next;\n    /* Log message about free()'ed item */\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               (void *)pool_item, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_DEBUG, log_msg);\n    }\n    free(pool_item);\n#if 0\n    /* Need this if below asserts are there */\n    pool->total_bufs_allocated_by_pool--;\n    pool->free_bufs_in_pool--;\n#endif\n    pool_item = pool->free_list;\n  }\n  pool->free_list = NULL;\n\n  /* TODO: libevhtp/libevent seems to hold some references and not release back\n   * to pool. Bug will be logged for this to investigate.\n   */\n  /* Assert if there are leaks */\n  /*\n    assert(pool->total_bufs_allocated_by_pool == 0);\n    assert(pool->number_of_bufs_shared == 0);\n    assert(pool->free_bufs_in_pool == 0);\n  */\n\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n    pthread_mutex_destroy(&pool->lock);\n  }\n\n  free(pool);\n  pool = NULL;\n  return 0;\n}",
  "diff_func": "@@ -540,6 +540,9 @@ int mempool_destroy(MemoryPoolHandle *handle) {\n   }\n \n   if (*handle == NULL) {\n+    if ((pool->flags & ENABLE_LOCKING) != 0) {\n+      pthread_mutex_unlock(&pool->lock);\n+    }\n     return S3_MEMPOOL_INVALID_ARG;\n   }\n ",
  "func": "int mempool_destroy(MemoryPoolHandle *handle) {\n  struct mempool *pool = NULL;\n  struct memory_pool_element *pool_item;\n  char *log_msg_fmt = \"mempool(%p): free(%p) called for buffer size(%zu)\";\n  char log_msg[200];\n\n  if (handle == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  pool = (struct mempool *)*handle;\n  if (pool == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n\n  if (*handle == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  /* reset the handle */\n  *handle = NULL;\n  /* Free the items in free list */\n  pool_item = pool->free_list;\n  while (pool_item != NULL) {\n    pool->free_list = pool_item->next;\n    /* Log message about free()'ed item */\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               (void *)pool_item, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_DEBUG, log_msg);\n    }\n    free(pool_item);\n#if 0\n    /* Need this if below asserts are there */\n    pool->total_bufs_allocated_by_pool--;\n    pool->free_bufs_in_pool--;\n#endif\n    pool_item = pool->free_list;\n  }\n  pool->free_list = NULL;\n\n  /* TODO: libevhtp/libevent seems to hold some references and not release back\n   * to pool. Bug will be logged for this to investigate.\n   */\n  /* Assert if there are leaks */\n  /*\n    assert(pool->total_bufs_allocated_by_pool == 0);\n    assert(pool->number_of_bufs_shared == 0);\n    assert(pool->free_bufs_in_pool == 0);\n  */\n\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n    pthread_mutex_destroy(&pool->lock);\n  }\n\n  free(pool);\n  pool = NULL;\n  return 0;\n}",
  "project": "cortx-s3server",
  "hash": 135921271694027953193959070993632037428,
  "size": 64,
  "commit_id": "dd6bfbc4b84f14f898598922ca9efd5aaa645c5d",
  "message": "avoid the unrelesed lock after the method returns (#1041)\n\nUpdate s3_memory_pool.c. Avoid the unreleased lock pool->lock after the method returns.\r\n\r\nCo-authored-by: nileshgovande <63101371+nileshgovande@users.noreply.github.com>",
  "target": 1,
  "dataset": "other",
  "idx": 197912
}