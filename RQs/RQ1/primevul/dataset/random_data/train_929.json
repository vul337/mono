{
  "id": 929,
  "language": "c",
  "cwe": "CWE-125",
  "commit_url": "https://github.com/merlinepedra/TCPDUMP/commit/ae83295915d08a854de27a88efac5dd7353e6d3f",
  "commit_sha": "ae83295915d08a854de27a88efac5dd7353e6d3f",
  "commit_msg": "CVE-2017-13033/VTP: Add more bound and length checks.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n\nUpdate another VTP test's .out file for this change.\n\nDon't treate a TLV type or length of 0 as invalid; a type of 0 should\njust be reported as illegal if that type isn't used, and the length is\nthe length of the *value*, not the length of the entire TLV, so if it's\nzero there won't be an infinite loop.  (It's still not *legal*, as the\nvalues of all the TLVs we handle are 1 16-bit word long; we added a\ncheck for that.)\n\nUpdate some comments while we're at it, to give a new URL for one Cisco\npage and a non-Cisco URL for another former Cisco page (Cisco's UniverCD\npages don't seem to be available any more, and Cisco's robots.txt file\ndidn't allow the Wayback Machine to archive it).",
  "pr_url": null,
  "pr_info": null,
  "file_name": "print-vtp.c",
  "func_name": "",
  "raw_func_from_json": "vtp_print (netdissect_options *ndo,\n           const u_char *pptr, u_int length)\n{\n    int type, len, tlv_len, tlv_value, mgmtd_len;\n    const u_char *tptr;\n    const struct vtp_vlan_ *vtp_vlan;\n\n    if (length < VTP_HEADER_LEN)\n        goto trunc;\n\n    tptr = pptr;\n\n    ND_TCHECK2(*tptr, VTP_HEADER_LEN);\n\n    type = *(tptr+1);\n    ND_PRINT((ndo, \"VTPv%u, Message %s (0x%02x), length %u\",\n\t   *tptr,\n\t   tok2str(vtp_message_type_values,\"Unknown message type\", type),\n\t   type,\n\t   length));\n\n    /* In non-verbose mode, just print version and message type */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    /* verbose mode print all fields */\n    ND_PRINT((ndo, \"\\n\\tDomain name: \"));\n    mgmtd_len = *(tptr + 3);\n    if (mgmtd_len < 1 ||  mgmtd_len > 32) {\n\tND_PRINT((ndo, \" [invalid MgmtD Len %d]\", mgmtd_len));\n\treturn;\n    }\n    fn_printzp(ndo, tptr + 4, mgmtd_len, NULL);\n    ND_PRINT((ndo, \", %s: %u\",\n\t   tok2str(vtp_header_values, \"Unknown\", type),\n\t   *(tptr+2)));\n\n    tptr += VTP_HEADER_LEN;\n\n    switch (type) {\n\n    case VTP_SUMMARY_ADV:\n\n\t/*\n\t *  SUMMARY ADVERTISEMENT\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |    Followers  |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Configuration revision number              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                  Updater Identity IP address                  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Update Timestamp (12 bytes)                |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                        MD5 digest (16 bytes)                  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK2(*tptr, 8);\n\tND_PRINT((ndo, \"\\n\\t  Config Rev %x, Updater %s\",\n\t       EXTRACT_32BITS(tptr),\n\t       ipaddr_string(ndo, tptr+4)));\n\ttptr += 8;\n\tND_TCHECK2(*tptr, VTP_UPDATE_TIMESTAMP_LEN);\n\tND_PRINT((ndo, \", Timestamp 0x%08x 0x%08x 0x%08x\",\n\t       EXTRACT_32BITS(tptr),\n\t       EXTRACT_32BITS(tptr + 4),\n\t       EXTRACT_32BITS(tptr + 8)));\n\ttptr += VTP_UPDATE_TIMESTAMP_LEN;\n\tND_TCHECK2(*tptr, VTP_MD5_DIGEST_LEN);\n\tND_PRINT((ndo, \", MD5 digest: %08x%08x%08x%08x\",\n\t       EXTRACT_32BITS(tptr),\n\t       EXTRACT_32BITS(tptr + 4),\n\t       EXTRACT_32BITS(tptr + 8),\n\t       EXTRACT_32BITS(tptr + 12)));\n\ttptr += VTP_MD5_DIGEST_LEN;\n\tbreak;\n\n    case VTP_SUBSET_ADV:\n\n\t/*\n\t *  SUBSET ADVERTISEMENT\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |   Seq number  |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Configuration revision number              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN info field 1                     |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         ................                      |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN info field N                     |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK_32BITS(tptr);\n\tND_PRINT((ndo, \", Config Rev %x\", EXTRACT_32BITS(tptr)));\n\n\t/*\n\t *  VLAN INFORMATION\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  | V info len    |    Status     |  VLAN type    | VLAN name len |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       ISL vlan id             |            MTU size           |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                     802.10 index (SAID)                       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN name                             |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\ttptr += 4;\n\twhile (tptr < (pptr+length)) {\n\n\t    ND_TCHECK_8BITS(tptr);\n\t    len = *tptr;\n\t    if (len == 0)\n\t\tbreak;\n\n \t    ND_TCHECK2(*tptr, len);\n \n \t    vtp_vlan = (const struct vtp_vlan_*)tptr;\n \t    ND_TCHECK(*vtp_vlan);\n \t    ND_PRINT((ndo, \"\\n\\tVLAN info status %s, type %s, VLAN-id %u, MTU %u, SAID 0x%08x, Name \",\n \t\t   tok2str(vtp_vlan_status,\"Unknown\",vtp_vlan->status),\n \t\t   tok2str(vtp_vlan_type_values,\"Unknown\",vtp_vlan->type),\n \t\t   EXTRACT_16BITS(&vtp_vlan->vlanid),\n \t\t   EXTRACT_16BITS(&vtp_vlan->mtu),\n \t\t   EXTRACT_32BITS(&vtp_vlan->index)));\n\t    fn_printzp(ndo, tptr + VTP_VLAN_INFO_OFFSET, vtp_vlan->name_len, NULL);\n            /*\n             * Vlan names are aligned to 32-bit boundaries.\n             */\n            len  -= VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n            tptr += VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n \n             /* TLV information follows */\n \n             while (len > 0) {\n \n                 /*\n                 * Cisco specs says 2 bytes for type + 2 bytes for length, take only 1\n                 * See: http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm\n                  */\n                 type = *tptr;\n                 tlv_len = *(tptr+1);\n \n                 ND_PRINT((ndo, \"\\n\\t\\t%s (0x%04x) TLV\",\n                        tok2str(vtp_vlan_tlv_values, \"Unknown\", type),\n                        type));\n \n                /*\n                 * infinite loop check\n                 */\n                if (type == 0 || tlv_len == 0) {\n                     return;\n                 }\n                 ND_TCHECK2(*tptr, tlv_len * 2 +2);\n \n                tlv_value = EXTRACT_16BITS(tptr+2);\n                switch (type) {\n                case VTP_VLAN_STE_HOP_COUNT:\n                    ND_PRINT((ndo, \", %u\", tlv_value));\n                    break;\n                case VTP_VLAN_PRUNING:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"Enabled\" : \"Disabled\",\n                           tlv_value));\n                    break;\n                case VTP_VLAN_STP_TYPE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tok2str(vtp_stp_type_values, \"Unknown\", tlv_value),\n                           tlv_value));\n                    break;\n                case VTP_VLAN_BRIDGE_TYPE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"SRB\" : \"SRT\",\n                           tlv_value));\n                    break;\n                case VTP_VLAN_BACKUP_CRF_MODE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"Backup\" : \"Not backup\",\n                           tlv_value));\n                    break;\n                    /*\n                     * FIXME those are the defined TLVs that lack a decoder\n                     * you are welcome to contribute code ;-)\n                     */\n                case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:\n                case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:\n                case VTP_VLAN_PARENT_VLAN:\n                case VTP_VLAN_TRANS_BRIDGED_VLAN:\n                case VTP_VLAN_ARP_HOP_COUNT:\n                default:\n\t\t    print_unknown_data(ndo, tptr, \"\\n\\t\\t  \", 2 + tlv_len*2);\n                    break;\n                 }\n                 len -= 2 + tlv_len*2;\n                 tptr += 2 + tlv_len*2;\n            }\n\t}\n\tbreak;\n\n    case VTP_ADV_REQUEST:\n\n\t/*\n\t *  ADVERTISEMENT REQUEST\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |   Reserved    |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                          Start value                          |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK2(*tptr, 4);\n\tND_PRINT((ndo, \"\\n\\tStart value: %u\", EXTRACT_32BITS(tptr)));\n\tbreak;\n\n    case VTP_JOIN_MESSAGE:\n\n\t/* FIXME - Could not find message format */\n\tbreak;\n\n    default:\n\tbreak;\n    }\n\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"[|vtp]\"));\n}\n",
  "diff_func": "@@ -13,9 +13,8 @@\n  * FOR A PARTICULAR PURPOSE.\n  *\n  * Reference documentation:\n- *  http://www.cisco.com/en/US/tech/tk389/tk689/technologies_tech_note09186a0080094c52.shtml\n- *  http://www.cisco.com/warp/public/473/21.html\n- *  http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm\n+ *  http://www.cisco.com/c/en/us/support/docs/lan-switching/vtp/10558-21.html\n+ *  http://docstore.mik.ua/univercd/cc/td/doc/product/lan/trsrb/frames.htm\n  *\n  * Original code ode by Carles Kishimoto <carles.kishimoto@gmail.com>\n  */\n@@ -36,7 +35,7 @@\n #define\tVTP_DOMAIN_NAME_LEN\t\t32\n #define\tVTP_MD5_DIGEST_LEN\t\t16\n #define VTP_UPDATE_TIMESTAMP_LEN\t12\n-#define VTP_VLAN_INFO_OFFSET\t\t12\n+#define VTP_VLAN_INFO_FIXED_PART_LEN\t12\t/* length of VLAN info before VLAN name */\n \n #define VTP_SUMMARY_ADV\t\t\t0x01\n #define VTP_SUBSET_ADV\t\t\t0x02\n@@ -252,89 +251,108 @@ vtp_print (netdissect_options *ndo,\n \t    ND_TCHECK2(*tptr, len);\n \n \t    vtp_vlan = (const struct vtp_vlan_*)tptr;\n+\t    if (len < VTP_VLAN_INFO_FIXED_PART_LEN)\n+\t\tgoto trunc;\n \t    ND_TCHECK(*vtp_vlan);\n \t    ND_PRINT((ndo, \"\\n\\tVLAN info status %s, type %s, VLAN-id %u, MTU %u, SAID 0x%08x, Name \",\n \t\t   tok2str(vtp_vlan_status,\"Unknown\",vtp_vlan->status),\n \t\t   tok2str(vtp_vlan_type_values,\"Unknown\",vtp_vlan->type),\n \t\t   EXTRACT_16BITS(&vtp_vlan->vlanid),\n \t\t   EXTRACT_16BITS(&vtp_vlan->mtu),\n \t\t   EXTRACT_32BITS(&vtp_vlan->index)));\n-\t    fn_printzp(ndo, tptr + VTP_VLAN_INFO_OFFSET, vtp_vlan->name_len, NULL);\n-\n-            /*\n-             * Vlan names are aligned to 32-bit boundaries.\n-             */\n-            len  -= VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n-            tptr += VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n+\t    len  -= VTP_VLAN_INFO_FIXED_PART_LEN;\n+\t    tptr += VTP_VLAN_INFO_FIXED_PART_LEN;\n+\t    if (len < 4*((vtp_vlan->name_len + 3)/4))\n+\t\tgoto trunc;\n+\t    ND_TCHECK2(*tptr, vtp_vlan->name_len);\n+\t    fn_printzp(ndo, tptr, vtp_vlan->name_len, NULL);\n+\n+\t    /*\n+\t     * Vlan names are aligned to 32-bit boundaries.\n+\t     */\n+\t    len  -= 4*((vtp_vlan->name_len + 3)/4);\n+\t    tptr += 4*((vtp_vlan->name_len + 3)/4);\n \n             /* TLV information follows */\n \n             while (len > 0) {\n \n                 /*\n-                 * Cisco specs says 2 bytes for type + 2 bytes for length, take only 1\n-                 * See: http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm\n+                 * Cisco specs say 2 bytes for type + 2 bytes for length;\n+                 * see http://docstore.mik.ua/univercd/cc/td/doc/product/lan/trsrb/frames.htm\n+                 * However, actual packets on the wire appear to use 1\n+                 * byte for the type and 1 byte for the length, so that's\n+                 * what we do.\n                  */\n+                if (len < 2)\n+                    goto trunc;\n+                ND_TCHECK2(*tptr, 2);\n                 type = *tptr;\n                 tlv_len = *(tptr+1);\n \n                 ND_PRINT((ndo, \"\\n\\t\\t%s (0x%04x) TLV\",\n                        tok2str(vtp_vlan_tlv_values, \"Unknown\", type),\n                        type));\n \n-                /*\n-                 * infinite loop check\n-                 */\n-                if (type == 0 || tlv_len == 0) {\n+                if (len < tlv_len * 2 + 2) {\n+                    ND_PRINT((ndo, \" (TLV goes past the end of the packet)\"));\n                     return;\n                 }\n-\n                 ND_TCHECK2(*tptr, tlv_len * 2 +2);\n \n-                tlv_value = EXTRACT_16BITS(tptr+2);\n-\n-                switch (type) {\n-                case VTP_VLAN_STE_HOP_COUNT:\n-                    ND_PRINT((ndo, \", %u\", tlv_value));\n-                    break;\n-\n-                case VTP_VLAN_PRUNING:\n-                    ND_PRINT((ndo, \", %s (%u)\",\n-                           tlv_value == 1 ? \"Enabled\" : \"Disabled\",\n-                           tlv_value));\n-                    break;\n-\n-                case VTP_VLAN_STP_TYPE:\n-                    ND_PRINT((ndo, \", %s (%u)\",\n-                           tok2str(vtp_stp_type_values, \"Unknown\", tlv_value),\n-                           tlv_value));\n-                    break;\n-\n-                case VTP_VLAN_BRIDGE_TYPE:\n-                    ND_PRINT((ndo, \", %s (%u)\",\n-                           tlv_value == 1 ? \"SRB\" : \"SRT\",\n-                           tlv_value));\n-                    break;\n-\n-                case VTP_VLAN_BACKUP_CRF_MODE:\n-                    ND_PRINT((ndo, \", %s (%u)\",\n-                           tlv_value == 1 ? \"Backup\" : \"Not backup\",\n-                           tlv_value));\n-                    break;\n-\n-                    /*\n-                     * FIXME those are the defined TLVs that lack a decoder\n-                     * you are welcome to contribute code ;-)\n-                     */\n-\n-                case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:\n-                case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:\n-                case VTP_VLAN_PARENT_VLAN:\n-                case VTP_VLAN_TRANS_BRIDGED_VLAN:\n-                case VTP_VLAN_ARP_HOP_COUNT:\n-                default:\n-\t\t    print_unknown_data(ndo, tptr, \"\\n\\t\\t  \", 2 + tlv_len*2);\n-                    break;\n+                /*\n+                 * We assume the value is a 2-byte integer; the length is\n+                 * in units of 16-bit words.\n+                 */\n+                if (tlv_len != 1) {\n+                    ND_PRINT((ndo, \" (invalid TLV length %u != 1)\", tlv_len));\n+                    return;\n+                } else {\n+                    tlv_value = EXTRACT_16BITS(tptr+2);\n+\n+                    switch (type) {\n+                    case VTP_VLAN_STE_HOP_COUNT:\n+                        ND_PRINT((ndo, \", %u\", tlv_value));\n+                        break;\n+\n+                    case VTP_VLAN_PRUNING:\n+                        ND_PRINT((ndo, \", %s (%u)\",\n+                               tlv_value == 1 ? \"Enabled\" : \"Disabled\",\n+                               tlv_value));\n+                        break;\n+\n+                    case VTP_VLAN_STP_TYPE:\n+                        ND_PRINT((ndo, \", %s (%u)\",\n+                               tok2str(vtp_stp_type_values, \"Unknown\", tlv_value),\n+                               tlv_value));\n+                        break;\n+\n+                    case VTP_VLAN_BRIDGE_TYPE:\n+                        ND_PRINT((ndo, \", %s (%u)\",\n+                               tlv_value == 1 ? \"SRB\" : \"SRT\",\n+                               tlv_value));\n+                        break;\n+\n+                    case VTP_VLAN_BACKUP_CRF_MODE:\n+                        ND_PRINT((ndo, \", %s (%u)\",\n+                               tlv_value == 1 ? \"Backup\" : \"Not backup\",\n+                               tlv_value));\n+                        break;\n+\n+                        /*\n+                         * FIXME those are the defined TLVs that lack a decoder\n+                         * you are welcome to contribute code ;-)\n+                         */\n+\n+                    case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:\n+                    case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:\n+                    case VTP_VLAN_PARENT_VLAN:\n+                    case VTP_VLAN_TRANS_BRIDGED_VLAN:\n+                    case VTP_VLAN_ARP_HOP_COUNT:\n+                    default:\n+                        print_unknown_data(ndo, tptr, \"\\n\\t\\t  \", 2 + tlv_len*2);\n+                        break;\n+                    }\n                 }\n                 len -= 2 + tlv_len*2;\n                 tptr += 2 + tlv_len*2;",
  "project": "tcpdump",
  "commit_id": "ae83295915d08a854de27a88efac5dd7353e6d3f",
  "target": 1,
  "func": "vtp_print (netdissect_options *ndo,\n           const u_char *pptr, u_int length)\n{\n    int type, len, tlv_len, tlv_value, mgmtd_len;\n    const u_char *tptr;\n    const struct vtp_vlan_ *vtp_vlan;\n\n    if (length < VTP_HEADER_LEN)\n        goto trunc;\n\n    tptr = pptr;\n\n    ND_TCHECK2(*tptr, VTP_HEADER_LEN);\n\n    type = *(tptr+1);\n    ND_PRINT((ndo, \"VTPv%u, Message %s (0x%02x), length %u\",\n\t   *tptr,\n\t   tok2str(vtp_message_type_values,\"Unknown message type\", type),\n\t   type,\n\t   length));\n\n    /* In non-verbose mode, just print version and message type */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    /* verbose mode print all fields */\n    ND_PRINT((ndo, \"\\n\\tDomain name: \"));\n    mgmtd_len = *(tptr + 3);\n    if (mgmtd_len < 1 ||  mgmtd_len > 32) {\n\tND_PRINT((ndo, \" [invalid MgmtD Len %d]\", mgmtd_len));\n\treturn;\n    }\n    fn_printzp(ndo, tptr + 4, mgmtd_len, NULL);\n    ND_PRINT((ndo, \", %s: %u\",\n\t   tok2str(vtp_header_values, \"Unknown\", type),\n\t   *(tptr+2)));\n\n    tptr += VTP_HEADER_LEN;\n\n    switch (type) {\n\n    case VTP_SUMMARY_ADV:\n\n\t/*\n\t *  SUMMARY ADVERTISEMENT\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |    Followers  |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Configuration revision number              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                  Updater Identity IP address                  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Update Timestamp (12 bytes)                |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                        MD5 digest (16 bytes)                  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK2(*tptr, 8);\n\tND_PRINT((ndo, \"\\n\\t  Config Rev %x, Updater %s\",\n\t       EXTRACT_32BITS(tptr),\n\t       ipaddr_string(ndo, tptr+4)));\n\ttptr += 8;\n\tND_TCHECK2(*tptr, VTP_UPDATE_TIMESTAMP_LEN);\n\tND_PRINT((ndo, \", Timestamp 0x%08x 0x%08x 0x%08x\",\n\t       EXTRACT_32BITS(tptr),\n\t       EXTRACT_32BITS(tptr + 4),\n\t       EXTRACT_32BITS(tptr + 8)));\n\ttptr += VTP_UPDATE_TIMESTAMP_LEN;\n\tND_TCHECK2(*tptr, VTP_MD5_DIGEST_LEN);\n\tND_PRINT((ndo, \", MD5 digest: %08x%08x%08x%08x\",\n\t       EXTRACT_32BITS(tptr),\n\t       EXTRACT_32BITS(tptr + 4),\n\t       EXTRACT_32BITS(tptr + 8),\n\t       EXTRACT_32BITS(tptr + 12)));\n\ttptr += VTP_MD5_DIGEST_LEN;\n\tbreak;\n\n    case VTP_SUBSET_ADV:\n\n\t/*\n\t *  SUBSET ADVERTISEMENT\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |   Seq number  |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Configuration revision number              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN info field 1                     |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         ................                      |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN info field N                     |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK_32BITS(tptr);\n\tND_PRINT((ndo, \", Config Rev %x\", EXTRACT_32BITS(tptr)));\n\n\t/*\n\t *  VLAN INFORMATION\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  | V info len    |    Status     |  VLAN type    | VLAN name len |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       ISL vlan id             |            MTU size           |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                     802.10 index (SAID)                       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN name                             |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\ttptr += 4;\n\twhile (tptr < (pptr+length)) {\n\n\t    ND_TCHECK_8BITS(tptr);\n\t    len = *tptr;\n\t    if (len == 0)\n\t\tbreak;\n\n \t    ND_TCHECK2(*tptr, len);\n \n \t    vtp_vlan = (const struct vtp_vlan_*)tptr;\n \t    ND_TCHECK(*vtp_vlan);\n \t    ND_PRINT((ndo, \"\\n\\tVLAN info status %s, type %s, VLAN-id %u, MTU %u, SAID 0x%08x, Name \",\n \t\t   tok2str(vtp_vlan_status,\"Unknown\",vtp_vlan->status),\n \t\t   tok2str(vtp_vlan_type_values,\"Unknown\",vtp_vlan->type),\n \t\t   EXTRACT_16BITS(&vtp_vlan->vlanid),\n \t\t   EXTRACT_16BITS(&vtp_vlan->mtu),\n \t\t   EXTRACT_32BITS(&vtp_vlan->index)));\n\t    fn_printzp(ndo, tptr + VTP_VLAN_INFO_OFFSET, vtp_vlan->name_len, NULL);\n            /*\n             * Vlan names are aligned to 32-bit boundaries.\n             */\n            len  -= VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n            tptr += VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n \n             /* TLV information follows */\n \n             while (len > 0) {\n \n                 /*\n                 * Cisco specs says 2 bytes for type + 2 bytes for length, take only 1\n                 * See: http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm\n                  */\n                 type = *tptr;\n                 tlv_len = *(tptr+1);\n \n                 ND_PRINT((ndo, \"\\n\\t\\t%s (0x%04x) TLV\",\n                        tok2str(vtp_vlan_tlv_values, \"Unknown\", type),\n                        type));\n \n                /*\n                 * infinite loop check\n                 */\n                if (type == 0 || tlv_len == 0) {\n                     return;\n                 }\n                 ND_TCHECK2(*tptr, tlv_len * 2 +2);\n \n                tlv_value = EXTRACT_16BITS(tptr+2);\n                switch (type) {\n                case VTP_VLAN_STE_HOP_COUNT:\n                    ND_PRINT((ndo, \", %u\", tlv_value));\n                    break;\n                case VTP_VLAN_PRUNING:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"Enabled\" : \"Disabled\",\n                           tlv_value));\n                    break;\n                case VTP_VLAN_STP_TYPE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tok2str(vtp_stp_type_values, \"Unknown\", tlv_value),\n                           tlv_value));\n                    break;\n                case VTP_VLAN_BRIDGE_TYPE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"SRB\" : \"SRT\",\n                           tlv_value));\n                    break;\n                case VTP_VLAN_BACKUP_CRF_MODE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"Backup\" : \"Not backup\",\n                           tlv_value));\n                    break;\n                    /*\n                     * FIXME those are the defined TLVs that lack a decoder\n                     * you are welcome to contribute code ;-)\n                     */\n                case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:\n                case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:\n                case VTP_VLAN_PARENT_VLAN:\n                case VTP_VLAN_TRANS_BRIDGED_VLAN:\n                case VTP_VLAN_ARP_HOP_COUNT:\n                default:\n\t\t    print_unknown_data(ndo, tptr, \"\\n\\t\\t  \", 2 + tlv_len*2);\n                    break;\n                 }\n                 len -= 2 + tlv_len*2;\n                 tptr += 2 + tlv_len*2;\n            }\n\t}\n\tbreak;\n\n    case VTP_ADV_REQUEST:\n\n\t/*\n\t *  ADVERTISEMENT REQUEST\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |   Reserved    |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                          Start value                          |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK2(*tptr, 4);\n\tND_PRINT((ndo, \"\\n\\tStart value: %u\", EXTRACT_32BITS(tptr)));\n\tbreak;\n\n    case VTP_JOIN_MESSAGE:\n\n\t/* FIXME - Could not find message format */\n\tbreak;\n\n    default:\n\tbreak;\n    }\n\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"[|vtp]\"));\n}\n",
  "big_vul_idx": 181022,
  "idx": 2543,
  "hash": 133576823966685874228817295114021225034
}