{
  "id": 333,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/ljalves/linux_media/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
  "commit_sha": "7314e613d5ff9f0934f7a0f74ed7973b903315d1",
  "commit_msg": "Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/uio/uio.c",
  "func_name": "",
  "raw_func_from_json": " int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n \n \tfbdev = to_au1100fb_device(fbi);\n \n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n \n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n }\n",
  "diff_func": "@@ -642,16 +642,29 @@ static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n+\tstruct uio_mem *mem;\n \tif (mi < 0)\n \t\treturn -EINVAL;\n+\tmem = idev->info->mem + mi;\n \n-\tvma->vm_ops = &uio_physical_vm_ops;\n+\tif (vma->vm_end - vma->vm_start > mem->size)\n+\t\treturn -EINVAL;\n \n+\tvma->vm_ops = &uio_physical_vm_ops;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \n+\t/*\n+\t * We cannot use the vm_iomap_memory() helper here,\n+\t * because vma->vm_pgoff is the map index we looked\n+\t * up above in uio_find_mem_index(), rather than an\n+\t * actual page offset into the mmap.\n+\t *\n+\t * So we just do the physical mmap without a page\n+\t * offset.\n+\t */\n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n-\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n+\t\t\t       mem->addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }",
  "project": "linux",
  "commit_id": "7314e613d5ff9f0934f7a0f74ed7973b903315d1",
  "target": 1,
  "func": " int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n \n \tfbdev = to_au1100fb_device(fbi);\n \n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n \n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n }\n",
  "big_vul_idx": 179107,
  "idx": 912,
  "hash": 177273139877749557163219661985792046530
}