{
  "id": 819,
  "language": "c",
  "cwe": "CWE-200",
  "commit_url": "https://github.com/sjp38/linux.personal/commit/ba3021b2c79b2fa9114f92790a99deb27a65b728",
  "commit_sha": "ba3021b2c79b2fa9114f92790a99deb27a65b728",
  "commit_msg": "ALSA: timer: Fix missing queue indices reset at SNDRV_TIMER_IOCTL_SELECT\n\nsnd_timer_user_tselect() reallocates the queue buffer dynamically, but\nit forgot to reset its indices.  Since the read may happen\nconcurrently with ioctl and snd_timer_user_tselect() allocates the\nbuffer via kmalloc(), this may lead to the leak of uninitialized\nkernel-space data, as spotted via KMSAN:\n\n  BUG: KMSAN: use of unitialized memory in snd_timer_user_read+0x6c4/0xa10\n  CPU: 0 PID: 1037 Comm: probe Not tainted 4.11.0-rc5+ #2739\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n  Call Trace:\n   __dump_stack lib/dump_stack.c:16\n   dump_stack+0x143/0x1b0 lib/dump_stack.c:52\n   kmsan_report+0x12a/0x180 mm/kmsan/kmsan.c:1007\n   kmsan_check_memory+0xc2/0x140 mm/kmsan/kmsan.c:1086\n   copy_to_user ./arch/x86/include/asm/uaccess.h:725\n   snd_timer_user_read+0x6c4/0xa10 sound/core/timer.c:2004\n   do_loop_readv_writev fs/read_write.c:716\n   __do_readv_writev+0x94c/0x1380 fs/read_write.c:864\n   do_readv_writev fs/read_write.c:894\n   vfs_readv fs/read_write.c:908\n   do_readv+0x52a/0x5d0 fs/read_write.c:934\n   SYSC_readv+0xb6/0xd0 fs/read_write.c:1021\n   SyS_readv+0x87/0xb0 fs/read_write.c:1018\n\nThis patch adds the missing reset of queue indices.  Together with the\nprevious fix for the ioctl/read race, we cover the whole problem.\n\nReported-by: Alexander Potapenko <glider@google.com>\nTested-by: Alexander Potapenko <glider@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "sound/core/timer.c",
  "func_name": "",
  "raw_func_from_json": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n \tif (err < 0)\n \t\tgoto __err;\n \n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n\n      __err:\n\treturn err;\n}\n",
  "diff_func": "@@ -1618,6 +1618,7 @@ static int snd_timer_user_tselect(struct file *file,\n \tif (err < 0)\n \t\tgoto __err;\n \n+\ttu->qhead = tu->qtail = tu->qused = 0;\n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);",
  "project": "linux",
  "commit_id": "ba3021b2c79b2fa9114f92790a99deb27a65b728",
  "target": 1,
  "func": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n \tif (err < 0)\n \t\tgoto __err;\n \n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n\n      __err:\n\treturn err;\n}\n",
  "big_vul_idx": 180791,
  "idx": 2346,
  "hash": 18027996916287278673301734704406442254
}