{
  "id": 910,
  "language": "c",
  "cwe": "CWE-125",
  "commit_url": "https://github.com/merlinepedra/TCPDUMP/commit/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e",
  "commit_sha": "5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e",
  "commit_msg": "CVE-2017-13055/IS-IS: fix an Extended IS Reachability sub-TLV\n\nIn isis_print_is_reach_subtlv() one of the case blocks did not check that\nthe sub-TLV \"V\" is actually present and could over-read the input buffer.\nAdd a length check to fix that and remove a useless boundary check from\na loop because the boundary is tested for the full length of \"V\" before\nthe switch block.\n\nUpdate one of the prior test cases as it turns out it depended on this\npreviously incorrect code path to make it to its own malformed structure\nfurther down the buffer, the bugfix has changed its output.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
  "pr_url": null,
  "pr_info": null,
  "file_name": "print-isoclns.c",
  "func_name": "",
  "raw_func_from_json": "isis_print_is_reach_subtlv(netdissect_options *ndo,\n                           const uint8_t *tptr, u_int subt, u_int subl,\n                           const char *ident)\n{\n        u_int te_class,priority_level,gmpls_switch_cap;\n        union { /* int to float conversion buffer for several subTLVs */\n            float f;\n            uint32_t i;\n        } bw;\n\n        /* first lets see if we know the subTLVs name*/\n\tND_PRINT((ndo, \"%s%s subTLV #%u, length: %u\",\n\t          ident, tok2str(isis_ext_is_reach_subtlv_values, \"unknown\", subt),\n\t          subt, subl));\n\n\tND_TCHECK2(*tptr, subl);\n\n        switch(subt) {\n        case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:\n\t    if (subl >= 4) {\n\t      ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr)));\n\t      if (subl == 8) /* rfc4205 */\n\t        ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr+4)));\n\t    }\n\t    break;\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:\n            if (subl >= sizeof(struct in_addr))\n              ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :\n\tcase ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:\n            if (subl >= 4) {\n              bw.i = EXTRACT_32BITS(tptr);\n              ND_PRINT((ndo, \", %.3f Mbps\", bw.f * 8 / 1000000));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :\n            if (subl >= 32) {\n              for (te_class = 0; te_class < 8; te_class++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  TE-Class %u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n\t      }\n            }\n             break;\n         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n             ND_PRINT((ndo, \"%sBandwidth Constraints Model ID: %s (%u)\",\n                    ident,\n                    tok2str(diffserv_te_bc_values, \"unknown\", *tptr),\n                    *tptr));\n             tptr++;\n             /* decode BCs until the subTLV ends */\n             for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n                ND_TCHECK2(*tptr, 4);\n                 bw.i = EXTRACT_32BITS(tptr);\n                 ND_PRINT((ndo, \"%s  Bandwidth constraint CT%u: %.3f Mbps\",\n                        ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:\n            if (subl >= 3)\n              ND_PRINT((ndo, \", %u\", EXTRACT_24BITS(tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:\n            if (subl == 2) {\n               ND_PRINT((ndo, \", [ %s ] (0x%04x)\",\n                      bittok2str(isis_subtlv_link_attribute_values,\n                                 \"Unknown\",\n                                 EXTRACT_16BITS(tptr)),\n                      EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:\n            if (subl >= 2) {\n              ND_PRINT((ndo, \", %s, Priority %u\",\n\t\t   bittok2str(gmpls_link_prot_values, \"none\", *tptr),\n                   *(tptr+1)));\n            }\n            break;\n        case ISIS_SUBTLV_SPB_METRIC:\n            if (subl >= 6) {\n              ND_PRINT((ndo, \", LM: %u\", EXTRACT_24BITS(tptr)));\n              tptr=tptr+3;\n              ND_PRINT((ndo, \", P: %u\", *(tptr)));\n              tptr++;\n              ND_PRINT((ndo, \", P-ID: %u\", EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:\n            if (subl >= 36) {\n              gmpls_switch_cap = *tptr;\n              ND_PRINT((ndo, \"%s  Interface Switching Capability:%s\",\n                   ident,\n                   tok2str(gmpls_switch_cap_values, \"Unknown\", gmpls_switch_cap)));\n              ND_PRINT((ndo, \", LSP Encoding: %s\",\n                   tok2str(gmpls_encoding_values, \"Unknown\", *(tptr + 1))));\n\t      tptr+=4;\n              ND_PRINT((ndo, \"%s  Max LSP Bandwidth:\", ident));\n              for (priority_level = 0; priority_level < 8; priority_level++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s    priority level %d: %.3f Mbps\",\n                       ident,\n                       priority_level,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n              }\n              subl-=36;\n              switch (gmpls_switch_cap) {\n              case GMPLS_PSC1:\n              case GMPLS_PSC2:\n              case GMPLS_PSC3:\n              case GMPLS_PSC4:\n                ND_TCHECK2(*tptr, 6);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Interface MTU: %u\", ident, EXTRACT_16BITS(tptr + 4)));\n                break;\n              case GMPLS_TSC:\n                ND_TCHECK2(*tptr, 8);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Indication %s\", ident,\n                       tok2str(gmpls_switch_cap_tsc_indication_values, \"Unknown (%u)\", *(tptr + 4))));\n                break;\n              default:\n                /* there is some optional stuff left to decode but this is as of yet\n                   not specified so just lets hexdump what is left */\n                if(subl>0){\n                  if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                    return(0);\n                }\n              }\n            }\n            break;\n        default:\n            if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                return(0);\n            break;\n        }\n        return(1);\n\ntrunc:\n    return(0);\n}\n",
  "diff_func": "@@ -1861,14 +1861,15 @@ isis_print_is_reach_subtlv(netdissect_options *ndo,\n             break;\n         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n+            if (subl == 0)\n+                break;\n             ND_PRINT((ndo, \"%sBandwidth Constraints Model ID: %s (%u)\",\n                    ident,\n                    tok2str(diffserv_te_bc_values, \"unknown\", *tptr),\n                    *tptr));\n             tptr++;\n             /* decode BCs until the subTLV ends */\n             for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n-                ND_TCHECK2(*tptr, 4);\n                 bw.i = EXTRACT_32BITS(tptr);\n                 ND_PRINT((ndo, \"%s  Bandwidth constraint CT%u: %.3f Mbps\",\n                        ident,",
  "project": "tcpdump",
  "commit_id": "5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e",
  "target": 1,
  "func": "isis_print_is_reach_subtlv(netdissect_options *ndo,\n                           const uint8_t *tptr, u_int subt, u_int subl,\n                           const char *ident)\n{\n        u_int te_class,priority_level,gmpls_switch_cap;\n        union { /* int to float conversion buffer for several subTLVs */\n            float f;\n            uint32_t i;\n        } bw;\n\n        /* first lets see if we know the subTLVs name*/\n\tND_PRINT((ndo, \"%s%s subTLV #%u, length: %u\",\n\t          ident, tok2str(isis_ext_is_reach_subtlv_values, \"unknown\", subt),\n\t          subt, subl));\n\n\tND_TCHECK2(*tptr, subl);\n\n        switch(subt) {\n        case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:\n\t    if (subl >= 4) {\n\t      ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr)));\n\t      if (subl == 8) /* rfc4205 */\n\t        ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr+4)));\n\t    }\n\t    break;\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:\n            if (subl >= sizeof(struct in_addr))\n              ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :\n\tcase ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:\n            if (subl >= 4) {\n              bw.i = EXTRACT_32BITS(tptr);\n              ND_PRINT((ndo, \", %.3f Mbps\", bw.f * 8 / 1000000));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :\n            if (subl >= 32) {\n              for (te_class = 0; te_class < 8; te_class++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  TE-Class %u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n\t      }\n            }\n             break;\n         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n             ND_PRINT((ndo, \"%sBandwidth Constraints Model ID: %s (%u)\",\n                    ident,\n                    tok2str(diffserv_te_bc_values, \"unknown\", *tptr),\n                    *tptr));\n             tptr++;\n             /* decode BCs until the subTLV ends */\n             for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n                ND_TCHECK2(*tptr, 4);\n                 bw.i = EXTRACT_32BITS(tptr);\n                 ND_PRINT((ndo, \"%s  Bandwidth constraint CT%u: %.3f Mbps\",\n                        ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:\n            if (subl >= 3)\n              ND_PRINT((ndo, \", %u\", EXTRACT_24BITS(tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:\n            if (subl == 2) {\n               ND_PRINT((ndo, \", [ %s ] (0x%04x)\",\n                      bittok2str(isis_subtlv_link_attribute_values,\n                                 \"Unknown\",\n                                 EXTRACT_16BITS(tptr)),\n                      EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:\n            if (subl >= 2) {\n              ND_PRINT((ndo, \", %s, Priority %u\",\n\t\t   bittok2str(gmpls_link_prot_values, \"none\", *tptr),\n                   *(tptr+1)));\n            }\n            break;\n        case ISIS_SUBTLV_SPB_METRIC:\n            if (subl >= 6) {\n              ND_PRINT((ndo, \", LM: %u\", EXTRACT_24BITS(tptr)));\n              tptr=tptr+3;\n              ND_PRINT((ndo, \", P: %u\", *(tptr)));\n              tptr++;\n              ND_PRINT((ndo, \", P-ID: %u\", EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:\n            if (subl >= 36) {\n              gmpls_switch_cap = *tptr;\n              ND_PRINT((ndo, \"%s  Interface Switching Capability:%s\",\n                   ident,\n                   tok2str(gmpls_switch_cap_values, \"Unknown\", gmpls_switch_cap)));\n              ND_PRINT((ndo, \", LSP Encoding: %s\",\n                   tok2str(gmpls_encoding_values, \"Unknown\", *(tptr + 1))));\n\t      tptr+=4;\n              ND_PRINT((ndo, \"%s  Max LSP Bandwidth:\", ident));\n              for (priority_level = 0; priority_level < 8; priority_level++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s    priority level %d: %.3f Mbps\",\n                       ident,\n                       priority_level,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n              }\n              subl-=36;\n              switch (gmpls_switch_cap) {\n              case GMPLS_PSC1:\n              case GMPLS_PSC2:\n              case GMPLS_PSC3:\n              case GMPLS_PSC4:\n                ND_TCHECK2(*tptr, 6);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Interface MTU: %u\", ident, EXTRACT_16BITS(tptr + 4)));\n                break;\n              case GMPLS_TSC:\n                ND_TCHECK2(*tptr, 8);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Indication %s\", ident,\n                       tok2str(gmpls_switch_cap_tsc_indication_values, \"Unknown (%u)\", *(tptr + 4))));\n                break;\n              default:\n                /* there is some optional stuff left to decode but this is as of yet\n                   not specified so just lets hexdump what is left */\n                if(subl>0){\n                  if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                    return(0);\n                }\n              }\n            }\n            break;\n        default:\n            if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                return(0);\n            break;\n        }\n        return(1);\n\ntrunc:\n    return(0);\n}\n",
  "big_vul_idx": 180990,
  "idx": 2514,
  "hash": 96299723517562303743255723214015925326
}