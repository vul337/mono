{
  "id": 1117,
  "language": "unknown",
  "cwe": "CWE-617",
  "commit_url": "https://github.com/monetor/monetor-0.3.2.10/commit/56a7c5bc15e0447203a491c1ee37de9939ad1dcd",
  "commit_sha": "56a7c5bc15e0447203a491c1ee37de9939ad1dcd",
  "commit_msg": "TROVE-2017-005: Fix assertion failure in connection_edge_process_relay_cell\n\nOn an hidden service rendezvous circuit, a BEGIN_DIR could be sent\n(maliciously) which would trigger a tor_assert() because\nconnection_edge_process_relay_cell() thought that the circuit is an\nor_circuit_t but is an origin circuit in reality.\n\nFixes #22494\n\nReported-by: Roger Dingledine <arma@torproject.org>\nSigned-off-by: David Goulet <dgoulet@torproject.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "changes/trove-2017-005",
  "func_name": "",
  "raw_func_from_json": "connection_edge_process_relay_cell(cell_t *cell, circuit_t *circ,\n                                   edge_connection_t *conn,\n                                   crypt_path_t *layer_hint)\n{\n  static int num_seen=0;\n  relay_header_t rh;\n  unsigned domain = layer_hint?LD_APP:LD_EXIT;\n  int reason;\n  int optimistic_data = 0; /* Set to 1 if we receive data on a stream\n                            * that's in the EXIT_CONN_STATE_RESOLVING\n                            * or EXIT_CONN_STATE_CONNECTING states. */\n\n  tor_assert(cell);\n  tor_assert(circ);\n\n  relay_header_unpack(&rh, cell->payload);\n  num_seen++;\n  log_debug(domain, \"Now seen %d relay cells here (command %d, stream %d).\",\n            num_seen, rh.command, rh.stream_id);\n\n  if (rh.length > RELAY_PAYLOAD_SIZE) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Relay cell length field too long. Closing circuit.\");\n    return - END_CIRC_REASON_TORPROTOCOL;\n  }\n\n  if (rh.stream_id == 0) {\n    switch (rh.command) {\n      case RELAY_COMMAND_BEGIN:\n      case RELAY_COMMAND_CONNECTED:\n      case RELAY_COMMAND_DATA:\n      case RELAY_COMMAND_END:\n      case RELAY_COMMAND_RESOLVE:\n      case RELAY_COMMAND_RESOLVED:\n      case RELAY_COMMAND_BEGIN_DIR:\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL, \"Relay command %d with zero \"\n               \"stream_id. Dropping.\", (int)rh.command);\n        return 0;\n      default:\n        ;\n    }\n  }\n\n  /* either conn is NULL, in which case we've got a control cell, or else\n   * conn points to the recognized stream. */\n\n  if (conn && !connection_state_is_open(TO_CONN(conn))) {\n    if (conn->base_.type == CONN_TYPE_EXIT &&\n        (conn->base_.state == EXIT_CONN_STATE_CONNECTING ||\n         conn->base_.state == EXIT_CONN_STATE_RESOLVING) &&\n        rh.command == RELAY_COMMAND_DATA) {\n      /* Allow DATA cells to be delivered to an exit node in state\n       * EXIT_CONN_STATE_CONNECTING or EXIT_CONN_STATE_RESOLVING.\n       * This speeds up HTTP, for example. */\n      optimistic_data = 1;\n    } else {\n      return connection_edge_process_relay_cell_not_open(\n               &rh, cell, circ, conn, layer_hint);\n    }\n  }\n\n  switch (rh.command) {\n    case RELAY_COMMAND_DROP:\n      return 0;\n    case RELAY_COMMAND_BEGIN:\n    case RELAY_COMMAND_BEGIN_DIR:\n      if (layer_hint &&\n          circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"Relay begin request unsupported at AP. Dropping.\");\n        return 0;\n      }\n      if (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED &&\n          layer_hint != TO_ORIGIN_CIRCUIT(circ)->cpath->prev) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"Relay begin request to Hidden Service \"\n               \"from intermediary node. Dropping.\");\n        return 0;\n      }\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n                \"Begin cell for known stream. Dropping.\");\n         return 0;\n       }\n      if (rh.command == RELAY_COMMAND_BEGIN_DIR) {\n         /* Assign this circuit and its app-ward OR connection a unique ID,\n          * so that we can measure download times. The local edge and dir\n          * connection will be assigned the same ID when they are created\n         * and linked. */\n        static uint64_t next_id = 0;\n        circ->dirreq_id = ++next_id;\n        TO_OR_CIRCUIT(circ)->p_chan->dirreq_id = circ->dirreq_id;\n      }\n\n      return connection_exit_begin_conn(cell, circ);\n    case RELAY_COMMAND_DATA:\n      ++stats_n_data_cells_received;\n      if (( layer_hint && --layer_hint->deliver_window < 0) ||\n          (!layer_hint && --circ->deliver_window < 0)) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"(relay data) circ deliver_window below 0. Killing.\");\n        if (conn) {\n          /* XXXX Do we actually need to do this?  Will killing the circuit\n           * not send an END and mark the stream for close as appropriate? */\n          connection_edge_end(conn, END_STREAM_REASON_TORPROTOCOL);\n          connection_mark_for_close(TO_CONN(conn));\n        }\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_debug(domain,\"circ deliver_window now %d.\", layer_hint ?\n                layer_hint->deliver_window : circ->deliver_window);\n\n      circuit_consider_sending_sendme(circ, layer_hint);\n\n      if (!conn) {\n        log_info(domain,\"data cell dropped, unknown stream (streamid %d).\",\n                 rh.stream_id);\n        return 0;\n      }\n\n      if (--conn->deliver_window < 0) { /* is it below 0 after decrement? */\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"(relay data) conn deliver_window below 0. Killing.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n\n      stats_n_data_bytes_received += rh.length;\n      connection_write_to_buf((char*)(cell->payload + RELAY_HEADER_SIZE),\n                              rh.length, TO_CONN(conn));\n\n      if (!optimistic_data) {\n        /* Only send a SENDME if we're not getting optimistic data; otherwise\n         * a SENDME could arrive before the CONNECTED.\n         */\n        connection_edge_consider_sending_sendme(conn);\n      }\n\n      return 0;\n    case RELAY_COMMAND_END:\n      reason = rh.length > 0 ?\n        get_uint8(cell->payload+RELAY_HEADER_SIZE) : END_STREAM_REASON_MISC;\n      if (!conn) {\n        log_info(domain,\"end cell (%s) dropped, unknown stream.\",\n                 stream_end_reason_to_string(reason));\n        return 0;\n      }\n/* XXX add to this log_fn the exit node's nickname? */\n      log_info(domain,TOR_SOCKET_T_FORMAT\": end cell (%s) for stream %d. \"\n               \"Removing stream.\",\n               conn->base_.s,\n               stream_end_reason_to_string(reason),\n               conn->stream_id);\n      if (conn->base_.type == CONN_TYPE_AP) {\n        entry_connection_t *entry_conn = EDGE_TO_ENTRY_CONN(conn);\n        if (entry_conn->socks_request &&\n            !entry_conn->socks_request->has_finished)\n          log_warn(LD_BUG,\n                   \"open stream hasn't sent socks answer yet? Closing.\");\n      }\n      /* We just *got* an end; no reason to send one. */\n      conn->edge_has_sent_end = 1;\n      if (!conn->end_reason)\n        conn->end_reason = reason | END_STREAM_REASON_FLAG_REMOTE;\n      if (!conn->base_.marked_for_close) {\n        /* only mark it if not already marked. it's possible to\n         * get the 'end' right around when the client hangs up on us. */\n        connection_mark_and_flush(TO_CONN(conn));\n      }\n      return 0;\n    case RELAY_COMMAND_EXTEND:\n    case RELAY_COMMAND_EXTEND2: {\n      static uint64_t total_n_extend=0, total_nonearly=0;\n      total_n_extend++;\n      if (rh.stream_id) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"'extend' cell received for non-zero stream. Dropping.\");\n        return 0;\n      }\n      if (cell->command != CELL_RELAY_EARLY &&\n          !networkstatus_get_param(NULL,\"AllowNonearlyExtend\",0,0,1)) {\n#define EARLY_WARNING_INTERVAL 3600\n        static ratelim_t early_warning_limit =\n          RATELIM_INIT(EARLY_WARNING_INTERVAL);\n        char *m;\n        if (cell->command == CELL_RELAY) {\n          ++total_nonearly;\n          if ((m = rate_limit_log(&early_warning_limit, approx_time()))) {\n            double percentage = ((double)total_nonearly)/total_n_extend;\n            percentage *= 100;\n            log_fn(LOG_PROTOCOL_WARN, domain, \"EXTEND cell received, \"\n                   \"but not via RELAY_EARLY. Dropping.%s\", m);\n            log_fn(LOG_PROTOCOL_WARN, domain, \"  (We have dropped %.02f%% of \"\n                   \"all EXTEND cells for this reason)\", percentage);\n            tor_free(m);\n          }\n        } else {\n          log_fn(LOG_WARN, domain,\n                 \"EXTEND cell received, in a cell with type %d! Dropping.\",\n                 cell->command);\n        }\n        return 0;\n      }\n      return circuit_extend(cell, circ);\n    }\n    case RELAY_COMMAND_EXTENDED:\n    case RELAY_COMMAND_EXTENDED2:\n      if (!layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"'extended' unsupported at non-origin. Dropping.\");\n        return 0;\n      }\n      log_debug(domain,\"Got an extended cell! Yay.\");\n      {\n        extended_cell_t extended_cell;\n        if (extended_cell_parse(&extended_cell, rh.command,\n                        (const uint8_t*)cell->payload+RELAY_HEADER_SIZE,\n                        rh.length)<0) {\n          log_warn(LD_PROTOCOL,\n                   \"Can't parse EXTENDED cell; killing circuit.\");\n          return -END_CIRC_REASON_TORPROTOCOL;\n        }\n        if ((reason = circuit_finish_handshake(TO_ORIGIN_CIRCUIT(circ),\n                                         &extended_cell.created_cell)) < 0) {\n          log_warn(domain,\"circuit_finish_handshake failed.\");\n          return reason;\n        }\n      }\n      if ((reason=circuit_send_next_onion_skin(TO_ORIGIN_CIRCUIT(circ)))<0) {\n        log_info(domain,\"circuit_send_next_onion_skin() failed.\");\n        return reason;\n      }\n      return 0;\n    case RELAY_COMMAND_TRUNCATE:\n      if (layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"'truncate' unsupported at origin. Dropping.\");\n        return 0;\n      }\n      if (circ->n_hop) {\n        if (circ->n_chan)\n          log_warn(LD_BUG, \"n_chan and n_hop set on the same circuit!\");\n        extend_info_free(circ->n_hop);\n        circ->n_hop = NULL;\n        tor_free(circ->n_chan_create_cell);\n        circuit_set_state(circ, CIRCUIT_STATE_OPEN);\n      }\n      if (circ->n_chan) {\n        uint8_t trunc_reason = get_uint8(cell->payload + RELAY_HEADER_SIZE);\n        circuit_clear_cell_queue(circ, circ->n_chan);\n        channel_send_destroy(circ->n_circ_id, circ->n_chan,\n                             trunc_reason);\n        circuit_set_n_circid_chan(circ, 0, NULL);\n      }\n      log_debug(LD_EXIT, \"Processed 'truncate', replying.\");\n      {\n        char payload[1];\n        payload[0] = (char)END_CIRC_REASON_REQUESTED;\n        relay_send_command_from_edge(0, circ, RELAY_COMMAND_TRUNCATED,\n                                     payload, sizeof(payload), NULL);\n      }\n      return 0;\n    case RELAY_COMMAND_TRUNCATED:\n      if (!layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_EXIT,\n               \"'truncated' unsupported at non-origin. Dropping.\");\n        return 0;\n      }\n      circuit_truncated(TO_ORIGIN_CIRCUIT(circ), layer_hint,\n                        get_uint8(cell->payload + RELAY_HEADER_SIZE));\n      return 0;\n    case RELAY_COMMAND_CONNECTED:\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"'connected' unsupported while open. Closing circ.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_info(domain,\n               \"'connected' received, no conn attached anymore. Ignoring.\");\n      return 0;\n    case RELAY_COMMAND_SENDME:\n      if (!rh.stream_id) {\n        if (layer_hint) {\n          if (layer_hint->package_window + CIRCWINDOW_INCREMENT >\n                CIRCWINDOW_START_MAX) {\n            log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n                   \"Unexpected sendme cell from exit relay. \"\n                   \"Closing circ.\");\n            return -END_CIRC_REASON_TORPROTOCOL;\n          }\n          layer_hint->package_window += CIRCWINDOW_INCREMENT;\n          log_debug(LD_APP,\"circ-level sendme at origin, packagewindow %d.\",\n                    layer_hint->package_window);\n          circuit_resume_edge_reading(circ, layer_hint);\n        } else {\n          if (circ->package_window + CIRCWINDOW_INCREMENT >\n                CIRCWINDOW_START_MAX) {\n            log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n                   \"Unexpected sendme cell from client. \"\n                   \"Closing circ (window %d).\",\n                   circ->package_window);\n            return -END_CIRC_REASON_TORPROTOCOL;\n          }\n          circ->package_window += CIRCWINDOW_INCREMENT;\n          log_debug(LD_APP,\n                    \"circ-level sendme at non-origin, packagewindow %d.\",\n                    circ->package_window);\n          circuit_resume_edge_reading(circ, layer_hint);\n        }\n        return 0;\n      }\n      if (!conn) {\n        log_info(domain,\"sendme cell dropped, unknown stream (streamid %d).\",\n                 rh.stream_id);\n        return 0;\n      }\n      conn->package_window += STREAMWINDOW_INCREMENT;\n      log_debug(domain,\"stream-level sendme, packagewindow now %d.\",\n                conn->package_window);\n      if (circuit_queue_streams_are_blocked(circ)) {\n        /* Still waiting for queue to flush; don't touch conn */\n        return 0;\n      }\n      connection_start_reading(TO_CONN(conn));\n      /* handle whatever might still be on the inbuf */\n      if (connection_edge_package_raw_inbuf(conn, 1, NULL) < 0) {\n        /* (We already sent an end cell if possible) */\n        connection_mark_for_close(TO_CONN(conn));\n        return 0;\n      }\n      return 0;\n    case RELAY_COMMAND_RESOLVE:\n      if (layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"resolve request unsupported at AP; dropping.\");\n        return 0;\n      } else if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"resolve request for known stream; dropping.\");\n        return 0;\n      } else if (circ->purpose != CIRCUIT_PURPOSE_OR) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"resolve request on circ with purpose %d; dropping\",\n               circ->purpose);\n        return 0;\n      }\n      connection_exit_begin_resolve(cell, TO_OR_CIRCUIT(circ));\n      return 0;\n    case RELAY_COMMAND_RESOLVED:\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"'resolved' unsupported while open. Closing circ.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_info(domain,\n               \"'resolved' received, no conn attached anymore. Ignoring.\");\n      return 0;\n    case RELAY_COMMAND_ESTABLISH_INTRO:\n    case RELAY_COMMAND_ESTABLISH_RENDEZVOUS:\n    case RELAY_COMMAND_INTRODUCE1:\n    case RELAY_COMMAND_INTRODUCE2:\n    case RELAY_COMMAND_INTRODUCE_ACK:\n    case RELAY_COMMAND_RENDEZVOUS1:\n    case RELAY_COMMAND_RENDEZVOUS2:\n    case RELAY_COMMAND_INTRO_ESTABLISHED:\n    case RELAY_COMMAND_RENDEZVOUS_ESTABLISHED:\n      rend_process_relay_cell(circ, layer_hint,\n                              rh.command, rh.length,\n                              cell->payload+RELAY_HEADER_SIZE);\n      return 0;\n  }\n  log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n         \"Received unknown relay command %d. Perhaps the other side is using \"\n         \"a newer version of Tor? Dropping.\",\n         rh.command);\n  return 0; /* for forward compatibility, don't kill the circuit */\n}\n",
  "diff_func": "@@ -0,0 +1,7 @@\n+  o Major bugfixes (hidden service, relay, security):\n+    - Fix an assertion failure caused by receiving a BEGIN_DIR cell on\n+      a hidden service rendezvous circuit. Fixes bug 22494, tracked as\n+      TROVE-2017-005 and CVE-2017-0376; bugfix on 0.2.2.1-alpha. Found\n+      by armadev.\n+\n+",
  "project": "tor",
  "commit_id": "56a7c5bc15e0447203a491c1ee37de9939ad1dcd",
  "target": 1,
  "func": "connection_edge_process_relay_cell(cell_t *cell, circuit_t *circ,\n                                   edge_connection_t *conn,\n                                   crypt_path_t *layer_hint)\n{\n  static int num_seen=0;\n  relay_header_t rh;\n  unsigned domain = layer_hint?LD_APP:LD_EXIT;\n  int reason;\n  int optimistic_data = 0; /* Set to 1 if we receive data on a stream\n                            * that's in the EXIT_CONN_STATE_RESOLVING\n                            * or EXIT_CONN_STATE_CONNECTING states. */\n\n  tor_assert(cell);\n  tor_assert(circ);\n\n  relay_header_unpack(&rh, cell->payload);\n  num_seen++;\n  log_debug(domain, \"Now seen %d relay cells here (command %d, stream %d).\",\n            num_seen, rh.command, rh.stream_id);\n\n  if (rh.length > RELAY_PAYLOAD_SIZE) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Relay cell length field too long. Closing circuit.\");\n    return - END_CIRC_REASON_TORPROTOCOL;\n  }\n\n  if (rh.stream_id == 0) {\n    switch (rh.command) {\n      case RELAY_COMMAND_BEGIN:\n      case RELAY_COMMAND_CONNECTED:\n      case RELAY_COMMAND_DATA:\n      case RELAY_COMMAND_END:\n      case RELAY_COMMAND_RESOLVE:\n      case RELAY_COMMAND_RESOLVED:\n      case RELAY_COMMAND_BEGIN_DIR:\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL, \"Relay command %d with zero \"\n               \"stream_id. Dropping.\", (int)rh.command);\n        return 0;\n      default:\n        ;\n    }\n  }\n\n  /* either conn is NULL, in which case we've got a control cell, or else\n   * conn points to the recognized stream. */\n\n  if (conn && !connection_state_is_open(TO_CONN(conn))) {\n    if (conn->base_.type == CONN_TYPE_EXIT &&\n        (conn->base_.state == EXIT_CONN_STATE_CONNECTING ||\n         conn->base_.state == EXIT_CONN_STATE_RESOLVING) &&\n        rh.command == RELAY_COMMAND_DATA) {\n      /* Allow DATA cells to be delivered to an exit node in state\n       * EXIT_CONN_STATE_CONNECTING or EXIT_CONN_STATE_RESOLVING.\n       * This speeds up HTTP, for example. */\n      optimistic_data = 1;\n    } else {\n      return connection_edge_process_relay_cell_not_open(\n               &rh, cell, circ, conn, layer_hint);\n    }\n  }\n\n  switch (rh.command) {\n    case RELAY_COMMAND_DROP:\n      return 0;\n    case RELAY_COMMAND_BEGIN:\n    case RELAY_COMMAND_BEGIN_DIR:\n      if (layer_hint &&\n          circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"Relay begin request unsupported at AP. Dropping.\");\n        return 0;\n      }\n      if (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED &&\n          layer_hint != TO_ORIGIN_CIRCUIT(circ)->cpath->prev) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"Relay begin request to Hidden Service \"\n               \"from intermediary node. Dropping.\");\n        return 0;\n      }\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n                \"Begin cell for known stream. Dropping.\");\n         return 0;\n       }\n      if (rh.command == RELAY_COMMAND_BEGIN_DIR) {\n         /* Assign this circuit and its app-ward OR connection a unique ID,\n          * so that we can measure download times. The local edge and dir\n          * connection will be assigned the same ID when they are created\n         * and linked. */\n        static uint64_t next_id = 0;\n        circ->dirreq_id = ++next_id;\n        TO_OR_CIRCUIT(circ)->p_chan->dirreq_id = circ->dirreq_id;\n      }\n\n      return connection_exit_begin_conn(cell, circ);\n    case RELAY_COMMAND_DATA:\n      ++stats_n_data_cells_received;\n      if (( layer_hint && --layer_hint->deliver_window < 0) ||\n          (!layer_hint && --circ->deliver_window < 0)) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"(relay data) circ deliver_window below 0. Killing.\");\n        if (conn) {\n          /* XXXX Do we actually need to do this?  Will killing the circuit\n           * not send an END and mark the stream for close as appropriate? */\n          connection_edge_end(conn, END_STREAM_REASON_TORPROTOCOL);\n          connection_mark_for_close(TO_CONN(conn));\n        }\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_debug(domain,\"circ deliver_window now %d.\", layer_hint ?\n                layer_hint->deliver_window : circ->deliver_window);\n\n      circuit_consider_sending_sendme(circ, layer_hint);\n\n      if (!conn) {\n        log_info(domain,\"data cell dropped, unknown stream (streamid %d).\",\n                 rh.stream_id);\n        return 0;\n      }\n\n      if (--conn->deliver_window < 0) { /* is it below 0 after decrement? */\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"(relay data) conn deliver_window below 0. Killing.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n\n      stats_n_data_bytes_received += rh.length;\n      connection_write_to_buf((char*)(cell->payload + RELAY_HEADER_SIZE),\n                              rh.length, TO_CONN(conn));\n\n      if (!optimistic_data) {\n        /* Only send a SENDME if we're not getting optimistic data; otherwise\n         * a SENDME could arrive before the CONNECTED.\n         */\n        connection_edge_consider_sending_sendme(conn);\n      }\n\n      return 0;\n    case RELAY_COMMAND_END:\n      reason = rh.length > 0 ?\n        get_uint8(cell->payload+RELAY_HEADER_SIZE) : END_STREAM_REASON_MISC;\n      if (!conn) {\n        log_info(domain,\"end cell (%s) dropped, unknown stream.\",\n                 stream_end_reason_to_string(reason));\n        return 0;\n      }\n/* XXX add to this log_fn the exit node's nickname? */\n      log_info(domain,TOR_SOCKET_T_FORMAT\": end cell (%s) for stream %d. \"\n               \"Removing stream.\",\n               conn->base_.s,\n               stream_end_reason_to_string(reason),\n               conn->stream_id);\n      if (conn->base_.type == CONN_TYPE_AP) {\n        entry_connection_t *entry_conn = EDGE_TO_ENTRY_CONN(conn);\n        if (entry_conn->socks_request &&\n            !entry_conn->socks_request->has_finished)\n          log_warn(LD_BUG,\n                   \"open stream hasn't sent socks answer yet? Closing.\");\n      }\n      /* We just *got* an end; no reason to send one. */\n      conn->edge_has_sent_end = 1;\n      if (!conn->end_reason)\n        conn->end_reason = reason | END_STREAM_REASON_FLAG_REMOTE;\n      if (!conn->base_.marked_for_close) {\n        /* only mark it if not already marked. it's possible to\n         * get the 'end' right around when the client hangs up on us. */\n        connection_mark_and_flush(TO_CONN(conn));\n      }\n      return 0;\n    case RELAY_COMMAND_EXTEND:\n    case RELAY_COMMAND_EXTEND2: {\n      static uint64_t total_n_extend=0, total_nonearly=0;\n      total_n_extend++;\n      if (rh.stream_id) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"'extend' cell received for non-zero stream. Dropping.\");\n        return 0;\n      }\n      if (cell->command != CELL_RELAY_EARLY &&\n          !networkstatus_get_param(NULL,\"AllowNonearlyExtend\",0,0,1)) {\n#define EARLY_WARNING_INTERVAL 3600\n        static ratelim_t early_warning_limit =\n          RATELIM_INIT(EARLY_WARNING_INTERVAL);\n        char *m;\n        if (cell->command == CELL_RELAY) {\n          ++total_nonearly;\n          if ((m = rate_limit_log(&early_warning_limit, approx_time()))) {\n            double percentage = ((double)total_nonearly)/total_n_extend;\n            percentage *= 100;\n            log_fn(LOG_PROTOCOL_WARN, domain, \"EXTEND cell received, \"\n                   \"but not via RELAY_EARLY. Dropping.%s\", m);\n            log_fn(LOG_PROTOCOL_WARN, domain, \"  (We have dropped %.02f%% of \"\n                   \"all EXTEND cells for this reason)\", percentage);\n            tor_free(m);\n          }\n        } else {\n          log_fn(LOG_WARN, domain,\n                 \"EXTEND cell received, in a cell with type %d! Dropping.\",\n                 cell->command);\n        }\n        return 0;\n      }\n      return circuit_extend(cell, circ);\n    }\n    case RELAY_COMMAND_EXTENDED:\n    case RELAY_COMMAND_EXTENDED2:\n      if (!layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"'extended' unsupported at non-origin. Dropping.\");\n        return 0;\n      }\n      log_debug(domain,\"Got an extended cell! Yay.\");\n      {\n        extended_cell_t extended_cell;\n        if (extended_cell_parse(&extended_cell, rh.command,\n                        (const uint8_t*)cell->payload+RELAY_HEADER_SIZE,\n                        rh.length)<0) {\n          log_warn(LD_PROTOCOL,\n                   \"Can't parse EXTENDED cell; killing circuit.\");\n          return -END_CIRC_REASON_TORPROTOCOL;\n        }\n        if ((reason = circuit_finish_handshake(TO_ORIGIN_CIRCUIT(circ),\n                                         &extended_cell.created_cell)) < 0) {\n          log_warn(domain,\"circuit_finish_handshake failed.\");\n          return reason;\n        }\n      }\n      if ((reason=circuit_send_next_onion_skin(TO_ORIGIN_CIRCUIT(circ)))<0) {\n        log_info(domain,\"circuit_send_next_onion_skin() failed.\");\n        return reason;\n      }\n      return 0;\n    case RELAY_COMMAND_TRUNCATE:\n      if (layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"'truncate' unsupported at origin. Dropping.\");\n        return 0;\n      }\n      if (circ->n_hop) {\n        if (circ->n_chan)\n          log_warn(LD_BUG, \"n_chan and n_hop set on the same circuit!\");\n        extend_info_free(circ->n_hop);\n        circ->n_hop = NULL;\n        tor_free(circ->n_chan_create_cell);\n        circuit_set_state(circ, CIRCUIT_STATE_OPEN);\n      }\n      if (circ->n_chan) {\n        uint8_t trunc_reason = get_uint8(cell->payload + RELAY_HEADER_SIZE);\n        circuit_clear_cell_queue(circ, circ->n_chan);\n        channel_send_destroy(circ->n_circ_id, circ->n_chan,\n                             trunc_reason);\n        circuit_set_n_circid_chan(circ, 0, NULL);\n      }\n      log_debug(LD_EXIT, \"Processed 'truncate', replying.\");\n      {\n        char payload[1];\n        payload[0] = (char)END_CIRC_REASON_REQUESTED;\n        relay_send_command_from_edge(0, circ, RELAY_COMMAND_TRUNCATED,\n                                     payload, sizeof(payload), NULL);\n      }\n      return 0;\n    case RELAY_COMMAND_TRUNCATED:\n      if (!layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_EXIT,\n               \"'truncated' unsupported at non-origin. Dropping.\");\n        return 0;\n      }\n      circuit_truncated(TO_ORIGIN_CIRCUIT(circ), layer_hint,\n                        get_uint8(cell->payload + RELAY_HEADER_SIZE));\n      return 0;\n    case RELAY_COMMAND_CONNECTED:\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"'connected' unsupported while open. Closing circ.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_info(domain,\n               \"'connected' received, no conn attached anymore. Ignoring.\");\n      return 0;\n    case RELAY_COMMAND_SENDME:\n      if (!rh.stream_id) {\n        if (layer_hint) {\n          if (layer_hint->package_window + CIRCWINDOW_INCREMENT >\n                CIRCWINDOW_START_MAX) {\n            log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n                   \"Unexpected sendme cell from exit relay. \"\n                   \"Closing circ.\");\n            return -END_CIRC_REASON_TORPROTOCOL;\n          }\n          layer_hint->package_window += CIRCWINDOW_INCREMENT;\n          log_debug(LD_APP,\"circ-level sendme at origin, packagewindow %d.\",\n                    layer_hint->package_window);\n          circuit_resume_edge_reading(circ, layer_hint);\n        } else {\n          if (circ->package_window + CIRCWINDOW_INCREMENT >\n                CIRCWINDOW_START_MAX) {\n            log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n                   \"Unexpected sendme cell from client. \"\n                   \"Closing circ (window %d).\",\n                   circ->package_window);\n            return -END_CIRC_REASON_TORPROTOCOL;\n          }\n          circ->package_window += CIRCWINDOW_INCREMENT;\n          log_debug(LD_APP,\n                    \"circ-level sendme at non-origin, packagewindow %d.\",\n                    circ->package_window);\n          circuit_resume_edge_reading(circ, layer_hint);\n        }\n        return 0;\n      }\n      if (!conn) {\n        log_info(domain,\"sendme cell dropped, unknown stream (streamid %d).\",\n                 rh.stream_id);\n        return 0;\n      }\n      conn->package_window += STREAMWINDOW_INCREMENT;\n      log_debug(domain,\"stream-level sendme, packagewindow now %d.\",\n                conn->package_window);\n      if (circuit_queue_streams_are_blocked(circ)) {\n        /* Still waiting for queue to flush; don't touch conn */\n        return 0;\n      }\n      connection_start_reading(TO_CONN(conn));\n      /* handle whatever might still be on the inbuf */\n      if (connection_edge_package_raw_inbuf(conn, 1, NULL) < 0) {\n        /* (We already sent an end cell if possible) */\n        connection_mark_for_close(TO_CONN(conn));\n        return 0;\n      }\n      return 0;\n    case RELAY_COMMAND_RESOLVE:\n      if (layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"resolve request unsupported at AP; dropping.\");\n        return 0;\n      } else if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"resolve request for known stream; dropping.\");\n        return 0;\n      } else if (circ->purpose != CIRCUIT_PURPOSE_OR) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"resolve request on circ with purpose %d; dropping\",\n               circ->purpose);\n        return 0;\n      }\n      connection_exit_begin_resolve(cell, TO_OR_CIRCUIT(circ));\n      return 0;\n    case RELAY_COMMAND_RESOLVED:\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"'resolved' unsupported while open. Closing circ.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_info(domain,\n               \"'resolved' received, no conn attached anymore. Ignoring.\");\n      return 0;\n    case RELAY_COMMAND_ESTABLISH_INTRO:\n    case RELAY_COMMAND_ESTABLISH_RENDEZVOUS:\n    case RELAY_COMMAND_INTRODUCE1:\n    case RELAY_COMMAND_INTRODUCE2:\n    case RELAY_COMMAND_INTRODUCE_ACK:\n    case RELAY_COMMAND_RENDEZVOUS1:\n    case RELAY_COMMAND_RENDEZVOUS2:\n    case RELAY_COMMAND_INTRO_ESTABLISHED:\n    case RELAY_COMMAND_RENDEZVOUS_ESTABLISHED:\n      rend_process_relay_cell(circ, layer_hint,\n                              rh.command, rh.length,\n                              cell->payload+RELAY_HEADER_SIZE);\n      return 0;\n  }\n  log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n         \"Received unknown relay command %d. Perhaps the other side is using \"\n         \"a newer version of Tor? Dropping.\",\n         rh.command);\n  return 0; /* for forward compatibility, don't kill the circuit */\n}\n",
  "big_vul_idx": 181623,
  "idx": 3054,
  "hash": 2913244036608667225287318293337220092
}