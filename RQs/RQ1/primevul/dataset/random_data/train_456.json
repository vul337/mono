{
  "id": 456,
  "language": "c",
  "cwe": "CWE-200",
  "commit_url": "https://github.com/ljalves/linux_media/commit/338f977f4eb441e69bb9a46eaa0ac715c931a67f",
  "commit_sha": "338f977f4eb441e69bb9a46eaa0ac715c931a67f",
  "commit_msg": "mac80211: fix fragmentation code, particularly for encryption\n\nThe \"new\" fragmentation code (since my rewrite almost 5 years ago)\nerroneously sets skb->len rather than using skb_trim() to adjust\nthe length of the first fragment after copying out all the others.\nThis leaves the skb tail pointer pointing to after where the data\noriginally ended, and thus causes the encryption MIC to be written\nat that point, rather than where it belongs: immediately after the\ndata.\n\nThe impact of this is that if software encryption is done, then\n a) encryption doesn't work for the first fragment, the connection\n    becomes unusable as the first fragment will never be properly\n    verified at the receiver, the MIC is practically guaranteed to\n    be wrong\n b) we leak up to 8 bytes of plaintext (!) of the packet out into\n    the air\n\nThis is only mitigated by the fact that many devices are capable\nof doing encryption in hardware, in which case this can't happen\nas the tail pointer is irrelevant in that case. Additionally,\nfragmentation is not used very frequently and would normally have\nto be configured manually.\n\nFix this by using skb_trim() properly.\n\nCc: stable@vger.kernel.org\nFixes: 2de8e0d999b8 (\"mac80211: rewrite fragmentation\")\nReported-by: Jouni Malinen <j@w1.fi>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/mac80211/tx.c",
  "func_name": "",
  "raw_func_from_json": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\n\t/* first fragment was already added to queue by caller */\n\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\n\t\t/* copy control information */\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\n\t\t/* copy header and data */\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\n\t\tpos += fraglen;\n \t}\n \n \t/* adjust first fragment's length */\n\tskb->len = hdrlen + per_fragm;\n \treturn 0;\n }\n",
  "diff_func": "@@ -878,7 +878,7 @@ static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n \t}\n \n \t/* adjust first fragment's length */\n-\tskb->len = hdrlen + per_fragm;\n+\tskb_trim(skb, hdrlen + per_fragm);\n \treturn 0;\n }\n ",
  "project": "linux",
  "commit_id": "338f977f4eb441e69bb9a46eaa0ac715c931a67f",
  "target": 1,
  "func": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\n\t/* first fragment was already added to queue by caller */\n\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\n\t\t/* copy control information */\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\n\t\t/* copy header and data */\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\n\t\tpos += fraglen;\n \t}\n \n \t/* adjust first fragment's length */\n\tskb->len = hdrlen + per_fragm;\n \treturn 0;\n }\n",
  "big_vul_idx": 179414,
  "idx": 1185,
  "hash": 252627261483521544309005842789154299812
}