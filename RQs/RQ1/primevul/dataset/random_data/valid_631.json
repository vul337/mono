{
  "id": 631,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/sailfishos-mirror/libvncserver/commit/a6788d1da719ae006605b78d22f5a9f170b423af",
  "commit_sha": "a6788d1da719ae006605b78d22f5a9f170b423af",
  "commit_msg": "libvncserver: scale: cast to 64 bit before shifting\n\nSince pixel_value is 64 bit the data type of the shift operand should\nbe 64 bit too to prevent integer overflows.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libvncserver/scale.c",
  "func_name": "",
  "raw_func_from_json": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}",
  "diff_func": "@@ -210,7 +210,7 @@ void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, in\n              default:\n                /* fixme: endianness problem? */\n                for (z = 0; z < bytesPerPixel; z++)\n-                 pixel_value += (srcptr2[z] << (8 * z));\n+                 pixel_value += ((unsigned long)srcptr2[z] << (8 * z));\n                 break;\n               }\n               /*",
  "func": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}",
  "project": "libvncserver",
  "hash": 295503009586478475692075987935889055828,
  "size": 122,
  "commit_id": "a6788d1da719ae006605b78d22f5a9f170b423af",
  "message": "libvncserver: scale: cast to 64 bit before shifting\n\nSince pixel_value is 64 bit the data type of the shift operand should\nbe 64 bit too to prevent integer overflows.",
  "target": 1,
  "dataset": "other",
  "idx": 199993
}