{
  "id": 964,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/chipcraft-ic/toolchain-component-linux/commit/dbbe2ad02e9df26e372f38cc3e70dab9222c832e",
  "commit_sha": "dbbe2ad02e9df26e372f38cc3e70dab9222c832e",
  "commit_msg": "x86/speculation: Prevent rogue cross-process SSBD shutdown\n\nOn context switch the change of TIF_SSBD and TIF_SPEC_IB are evaluated\nto adjust the mitigations accordingly. This is optimized to avoid the\nexpensive MSR write if not needed.\n\nThis optimization is buggy and allows an attacker to shutdown the SSBD\nprotection of a victim process.\n\nThe update logic reads the cached base value for the speculation control\nMSR which has neither the SSBD nor the STIBP bit set. It then OR's the\nSSBD bit only when TIF_SSBD is different and requests the MSR update.\n\nThat means if TIF_SSBD of the previous and next task are the same, then\nthe base value is not updated, even if TIF_SSBD is set. The MSR write is\nnot requested.\n\nSubsequently if the TIF_STIBP bit differs then the STIBP bit is updated\nin the base value and the MSR is written with a wrong SSBD value.\n\nThis was introduced when the per task/process conditional STIPB\nswitching was added on top of the existing SSBD switching.\n\nIt is exploitable if the attacker creates a process which enforces SSBD\nand has the contrary value of STIBP than the victim process (i.e. if the\nvictim process enforces STIBP, the attacker process must not enforce it;\nif the victim process does not enforce STIBP, the attacker process must\nenforce it) and schedule it on the same core as the victim process. If\nthe victim runs after the attacker the victim becomes vulnerable to\nSpectre V4.\n\nTo fix this, update the MSR value independent of the TIF_SSBD difference\nand dependent on the SSBD mitigation method available. This ensures that\na subsequent STIPB initiated MSR write has the correct state of SSBD.\n\n[ tglx: Handle X86_FEATURE_VIRT_SSBD & X86_FEATURE_VIRT_SSBD correctly\n        and massaged changelog ]\n\nFixes: 5bfbe3ad5840 (\"x86/speculation: Prepare for per task indirect branch speculation control\")\nSigned-off-by: Anthony Steinhauser <asteinhauser@google.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@vger.kernel.org",
  "pr_url": null,
  "pr_info": null,
  "file_name": "arch/x86/kernel/process.c",
  "func_name": "",
  "raw_func_from_json": "static __always_inline void __speculation_ctrl_update(unsigned long tifp,\n\t\t\t\t\t\t      unsigned long tifn)\n{\n\tunsigned long tif_diff = tifp ^ tifn;\n\tu64 msr = x86_spec_ctrl_base;\n\tbool updmsr = false;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * If TIF_SSBD is different, select the proper mitigation\n\t * method. Note that if SSBD mitigation is disabled or permanentely\n\t * enabled this branch can't be taken because nothing can set\n\t * TIF_SSBD.\n\t */\n\tif (tif_diff & _TIF_SSBD) {\n\t\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n\t\t\tamd_set_ssb_virt_state(tifn);\n\t\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {\n\t\t\tamd_set_core_ssb_state(tifn);\n\t\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||\n\t\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {\n\t\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);\n\t\t\tupdmsr  = true;\n\t\t}\n\t}\n\n\t/*\n\t * Only evaluate TIF_SPEC_IB if conditional STIBP is enabled,\n\t * otherwise avoid the MSR write.\n\t */\n\tif (IS_ENABLED(CONFIG_SMP) &&\n\t    static_branch_unlikely(&switch_to_cond_stibp)) {\n\t\tupdmsr |= !!(tif_diff & _TIF_SPEC_IB);\n\t\tmsr |= stibp_tif_to_spec_ctrl(tifn);\n\t}\n\n\tif (updmsr)\n\t\twrmsrl(MSR_IA32_SPEC_CTRL, msr);\n}",
  "diff_func": "@@ -545,28 +545,20 @@ static __always_inline void __speculation_ctrl_update(unsigned long tifp,\n \n \tlockdep_assert_irqs_disabled();\n \n-\t/*\n-\t * If TIF_SSBD is different, select the proper mitigation\n-\t * method. Note that if SSBD mitigation is disabled or permanentely\n-\t * enabled this branch can't be taken because nothing can set\n-\t * TIF_SSBD.\n-\t */\n-\tif (tif_diff & _TIF_SSBD) {\n-\t\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n+\t/* Handle change of TIF_SSBD depending on the mitigation method. */\n+\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n+\t\tif (tif_diff & _TIF_SSBD)\n \t\t\tamd_set_ssb_virt_state(tifn);\n-\t\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {\n+\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {\n+\t\tif (tif_diff & _TIF_SSBD)\n \t\t\tamd_set_core_ssb_state(tifn);\n-\t\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||\n-\t\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {\n-\t\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);\n-\t\t\tupdmsr  = true;\n-\t\t}\n+\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||\n+\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {\n+\t\tupdmsr |= !!(tif_diff & _TIF_SSBD);\n+\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);\n \t}\n \n-\t/*\n-\t * Only evaluate TIF_SPEC_IB if conditional STIBP is enabled,\n-\t * otherwise avoid the MSR write.\n-\t */\n+\t/* Only evaluate TIF_SPEC_IB if conditional STIBP is enabled. */\n \tif (IS_ENABLED(CONFIG_SMP) &&\n \t    static_branch_unlikely(&switch_to_cond_stibp)) {\n \t\tupdmsr |= !!(tif_diff & _TIF_SPEC_IB);",
  "func": "static __always_inline void __speculation_ctrl_update(unsigned long tifp,\n\t\t\t\t\t\t      unsigned long tifn)\n{\n\tunsigned long tif_diff = tifp ^ tifn;\n\tu64 msr = x86_spec_ctrl_base;\n\tbool updmsr = false;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * If TIF_SSBD is different, select the proper mitigation\n\t * method. Note that if SSBD mitigation is disabled or permanentely\n\t * enabled this branch can't be taken because nothing can set\n\t * TIF_SSBD.\n\t */\n\tif (tif_diff & _TIF_SSBD) {\n\t\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n\t\t\tamd_set_ssb_virt_state(tifn);\n\t\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {\n\t\t\tamd_set_core_ssb_state(tifn);\n\t\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||\n\t\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {\n\t\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);\n\t\t\tupdmsr  = true;\n\t\t}\n\t}\n\n\t/*\n\t * Only evaluate TIF_SPEC_IB if conditional STIBP is enabled,\n\t * otherwise avoid the MSR write.\n\t */\n\tif (IS_ENABLED(CONFIG_SMP) &&\n\t    static_branch_unlikely(&switch_to_cond_stibp)) {\n\t\tupdmsr |= !!(tif_diff & _TIF_SPEC_IB);\n\t\tmsr |= stibp_tif_to_spec_ctrl(tifn);\n\t}\n\n\tif (updmsr)\n\t\twrmsrl(MSR_IA32_SPEC_CTRL, msr);\n}",
  "project": "linux",
  "hash": 187065062412313618084393903131194537257,
  "size": 40,
  "commit_id": "dbbe2ad02e9df26e372f38cc3e70dab9222c832e",
  "message": "x86/speculation: Prevent rogue cross-process SSBD shutdown\n\nOn context switch the change of TIF_SSBD and TIF_SPEC_IB are evaluated\nto adjust the mitigations accordingly. This is optimized to avoid the\nexpensive MSR write if not needed.\n\nThis optimization is buggy and allows an attacker to shutdown the SSBD\nprotection of a victim process.\n\nThe update logic reads the cached base value for the speculation control\nMSR which has neither the SSBD nor the STIBP bit set. It then OR's the\nSSBD bit only when TIF_SSBD is different and requests the MSR update.\n\nThat means if TIF_SSBD of the previous and next task are the same, then\nthe base value is not updated, even if TIF_SSBD is set. The MSR write is\nnot requested.\n\nSubsequently if the TIF_STIBP bit differs then the STIBP bit is updated\nin the base value and the MSR is written with a wrong SSBD value.\n\nThis was introduced when the per task/process conditional STIPB\nswitching was added on top of the existing SSBD switching.\n\nIt is exploitable if the attacker creates a process which enforces SSBD\nand has the contrary value of STIBP than the victim process (i.e. if the\nvictim process enforces STIBP, the attacker process must not enforce it;\nif the victim process does not enforce STIBP, the attacker process must\nenforce it) and schedule it on the same core as the victim process. If\nthe victim runs after the attacker the victim becomes vulnerable to\nSpectre V4.\n\nTo fix this, update the MSR value independent of the TIF_SSBD difference\nand dependent on the SSBD mitigation method available. This ensures that\na subsequent STIPB initiated MSR write has the correct state of SSBD.\n\n[ tglx: Handle X86_FEATURE_VIRT_SSBD & X86_FEATURE_VIRT_SSBD correctly\n        and massaged changelog ]\n\nFixes: 5bfbe3ad5840 (\"x86/speculation: Prepare for per task indirect branch speculation control\")\nSigned-off-by: Anthony Steinhauser <asteinhauser@google.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@vger.kernel.org",
  "target": 1,
  "dataset": "other",
  "idx": 212693
}