{
  "id": 777,
  "language": "c",
  "cwe": "CWE-284",
  "commit_url": "https://github.com/ljalves/linux_media/commit/999653786df6954a31044528ac3f7a5dadca08f4",
  "commit_sha": "999653786df6954a31044528ac3f7a5dadca08f4",
  "commit_msg": "nfsd: check permissions when setting ACLs\n\nUse set_posix_acl, which includes proper permission checks, instead of\ncalling ->set_acl directly.  Without this anyone may be able to grant\nthemselves permissions to a file by setting the ACL.\n\nLock the inode to make the new checks atomic with respect to set_acl.\n(Also, nfsd was the only caller of set_acl not locking the inode, so I\nsuspect this may fix other races.)\n\nThis also simplifies the code, and ensures our ACLs are checked by\nposix_acl_valid.\n\nThe permission checks and the inode locking were lost with commit\n4ac7249e, which changed nfsd to use the set_acl inode operation directly\ninstead of going through xattr handlers.\n\nReported-by: David Sinquin <david@sinquin.eu>\n[agreunba@redhat.com: use set_posix_acl]\nFixes: 4ac7249e\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/nfsd/nfs2acl.c",
  "func_name": "",
  "raw_func_from_json": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n \n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n \n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n \n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n \tif (host_error < 0)\n\t\tgoto out_release;\n \n \tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n \t}\n \nout_release:\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}\n",
  "diff_func": "@@ -104,22 +104,21 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \tif (error)\n-\t\tgoto out_drop_write;\n+\t\tgoto out_drop_lock;\n+\n+\tfh_unlock(fh);\n \n \tfh_drop_write(fh);\n \n@@ -131,7 +130,8 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \tposix_acl_release(argp->acl_access);\n \tposix_acl_release(argp->acl_default);\n \treturn nfserr;\n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);",
  "project": "linux",
  "commit_id": "999653786df6954a31044528ac3f7a5dadca08f4",
  "target": 1,
  "func": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n \n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n \n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n \n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n \tif (host_error < 0)\n\t\tgoto out_release;\n \n \tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n \t}\n \nout_release:\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}\n",
  "big_vul_idx": 180621,
  "idx": 2197,
  "hash": 214645545890968048098851004449982791558
}