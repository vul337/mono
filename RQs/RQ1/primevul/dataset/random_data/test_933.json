{
  "id": 933,
  "language": "h",
  "cwe": "",
  "commit_url": "https://github.com/ljalves/linux_media/commit/bb458c644a59dbba3a1fe59b27106c5e68e1c4bd",
  "commit_sha": "bb458c644a59dbba3a1fe59b27106c5e68e1c4bd",
  "commit_msg": "Safer ABI for O_TMPFILE\n\n[suggested by Rasmus Villemoes] make O_DIRECTORY | O_RDWR part of O_TMPFILE;\nthat will fail on old kernels in a lot more cases than what I came up with.\nAnd make sure O_CREAT doesn't get there...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "arch/alpha/include/uapi/asm/fcntl.h",
  "func_name": "",
  "raw_func_from_json": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *base = NULL;\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n\n\tif (unlikely(file->f_flags & O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\n\terror = path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nd, &base);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tcurrent->total_link_count = 0;\n\terror = link_path_walk(pathname->name, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { /* trailing symlink */\n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT))\n\t\tpath_put(&nd->root);\n\tif (base)\n\t\tfput(base);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}",
  "diff_func": "@@ -32,7 +32,7 @@\n #define O_SYNC\t\t(__O_SYNC|O_DSYNC)\n \n #define O_PATH\t\t040000000\n-#define O_TMPFILE\t0100000000\n+#define __O_TMPFILE\t0100000000\n \n #define F_GETLK\t\t7\n #define F_SETLK\t\t8",
  "func": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *base = NULL;\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n\n\tif (unlikely(file->f_flags & O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\n\terror = path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nd, &base);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tcurrent->total_link_count = 0;\n\terror = link_path_walk(pathname->name, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { /* trailing symlink */\n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT))\n\t\tpath_put(&nd->root);\n\tif (base)\n\t\tfput(base);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}",
  "project": "linux",
  "hash": 254660321291828395776330198697429452775,
  "size": 70,
  "commit_id": "bb458c644a59dbba3a1fe59b27106c5e68e1c4bd",
  "message": "Safer ABI for O_TMPFILE\n\n[suggested by Rasmus Villemoes] make O_DIRECTORY | O_RDWR part of O_TMPFILE;\nthat will fail on old kernels in a lot more cases than what I came up with.\nAnd make sure O_CREAT doesn't get there...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
  "target": 1,
  "dataset": "other",
  "idx": 206720
}