{
  "id": 715,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/iarxm/neomutt/commit/9c36717a3e2af1f2c1b7242035455ec8112b4b06",
  "commit_sha": "9c36717a3e2af1f2c1b7242035455ec8112b4b06",
  "commit_msg": "imap: close connection on all failures\n\nThanks to Gabriel Salles-Loustau for spotting the problem.\n\nCo-authored-by: Kevin McCarthy <kevin@8t8.us>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "imap/imap.c",
  "func_name": "else",
  "raw_func_from_json": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_istr_startswith(adata->buf, \"* OK\"))\n  {\n    if (!mutt_istr_startswith(adata->buf, \"* OK [CAPABILITY\") && check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && (adata->conn->ssf == 0))\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_istr_startswith(adata->buf, \"* PREAUTH\"))\n  {\n#ifdef USE_SSL\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response may be a\n     * MITM attack.  The only way to stop \"STARTTLS\" MITM attacks is via\n     * $ssl_force_tls: an attacker can easily spoof \"* OK\" and strip the\n     * STARTTLS capability.  So consult $ssl_force_tls, not $ssl_starttls, to\n     * decide whether to abort. Note that if using $tunnel and\n     * $tunnel_is_secure, adata->conn->ssf will be set to 1. */\n    if ((adata->conn->ssf == 0) && C_SslForceTls)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}",
  "diff_func": "@@ -761,7 +761,7 @@ int imap_open_connection(struct ImapAccountData *adata)\n       else if ((ans = query_quadoption(C_SslStarttls,\n                                        _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n       {\n-        goto err_close_conn;\n+        goto bail;\n       }\n       if (ans == MUTT_YES)\n       {\n@@ -776,7 +776,7 @@ int imap_open_connection(struct ImapAccountData *adata)\n           if (mutt_ssl_starttls(adata->conn))\n           {\n             mutt_error(_(\"Could not negotiate TLS connection\"));\n-            goto err_close_conn;\n+            goto bail;\n           }\n           else\n           {\n@@ -791,7 +791,7 @@ int imap_open_connection(struct ImapAccountData *adata)\n     if (C_SslForceTls && (adata->conn->ssf == 0))\n     {\n       mutt_error(_(\"Encrypted connection unavailable\"));\n-      goto err_close_conn;\n+      goto bail;\n     }\n #endif\n   }\n@@ -807,7 +807,7 @@ int imap_open_connection(struct ImapAccountData *adata)\n     if ((adata->conn->ssf == 0) && C_SslForceTls)\n     {\n       mutt_error(_(\"Encrypted connection unavailable\"));\n-      goto err_close_conn;\n+      goto bail;\n     }\n #endif\n \n@@ -824,11 +824,8 @@ int imap_open_connection(struct ImapAccountData *adata)\n \n   return 0;\n \n-#ifdef USE_SSL\n-err_close_conn:\n-  imap_close_connection(adata);\n-#endif\n bail:\n+  imap_close_connection(adata);\n   FREE(&adata->capstr);\n   return -1;\n }",
  "func": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_istr_startswith(adata->buf, \"* OK\"))\n  {\n    if (!mutt_istr_startswith(adata->buf, \"* OK [CAPABILITY\") && check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && (adata->conn->ssf == 0))\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_istr_startswith(adata->buf, \"* PREAUTH\"))\n  {\n#ifdef USE_SSL\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response may be a\n     * MITM attack.  The only way to stop \"STARTTLS\" MITM attacks is via\n     * $ssl_force_tls: an attacker can easily spoof \"* OK\" and strip the\n     * STARTTLS capability.  So consult $ssl_force_tls, not $ssl_starttls, to\n     * decide whether to abort. Note that if using $tunnel and\n     * $tunnel_is_secure, adata->conn->ssf will be set to 1. */\n    if ((adata->conn->ssf == 0) && C_SslForceTls)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}",
  "project": "neomutt",
  "hash": 116037772614219807053318355003276943446,
  "size": 101,
  "commit_id": "9c36717a3e2af1f2c1b7242035455ec8112b4b06",
  "message": "imap: close connection on all failures\n\nThanks to Gabriel Salles-Loustau for spotting the problem.\n\nCo-authored-by: Kevin McCarthy <kevin@8t8.us>",
  "target": 1,
  "dataset": "other",
  "idx": 204337
}