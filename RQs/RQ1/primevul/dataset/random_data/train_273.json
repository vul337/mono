{
  "id": 273,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/Evervolv/android_kernel_oppo_apq8064/commit/13d518074a952d33d47c428419693f63389547e9",
  "commit_sha": "13d518074a952d33d47c428419693f63389547e9",
  "commit_msg": "epoll: clear the tfile_check_list on -ELOOP\n\nAn epoll_ctl(,EPOLL_CTL_ADD,,) operation can return '-ELOOP' to prevent\ncircular epoll dependencies from being created.  However, in that case we\ndo not properly clear the 'tfile_check_list'.  Thus, add a call to\nclear_tfile_check_list() for the -ELOOP case.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nReported-by: Yurij M. Plotnikov <Yurij.Plotnikov@oktetlabs.ru>\nCc: Nelson Elhage <nelhage@nelhage.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nTested-by: Alexandra N. Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/eventpoll.c",
  "func_name": "",
  "raw_func_from_json": "SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n\tint error;\n\tint did_lock_epmutex = 0;\n\tstruct file *file, *tfile;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the eventpoll file */\n\terror = -EBADF;\n\tfile = fget(epfd);\n\tif (!file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttfile = fget(fd);\n\tif (!tfile)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!tfile->f_op || !tfile->f_op->poll)\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (file == tfile || !is_file_epoll(file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven't created too many possible wakeup paths.\n\t *\n\t * We need to hold the epmutex across both ep_insert and ep_remove\n\t * b/c we want to make sure we are looking at a coherent view of\n\t * epoll network.\n\t */\n\tif (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) {\n\t\tmutex_lock(&epmutex);\n\t\tdid_lock_epmutex = 1;\n\t}\n \tif (op == EPOLL_CTL_ADD) {\n \t\tif (is_file_epoll(tfile)) {\n \t\t\terror = -ELOOP;\n\t\t\tif (ep_loop_check(ep, tfile) != 0)\n \t\t\t\tgoto error_tgt_fput;\n \t\t} else\n \t\t\tlist_add(&tfile->f_tfile_llink, &tfile_check_list);\n \t}\n\n\tmutex_lock_nested(&ep->mtx, 0);\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tfile, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_insert(ep, &epds, tfile, fd);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tclear_tfile_check_list();\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_modify(ep, epi, &epds);\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (did_lock_epmutex)\n\t\tmutex_unlock(&epmutex);\n\n\tfput(tfile);\nerror_fput:\n\tfput(file);\nerror_return:\n\n\treturn error;\n}\n",
  "diff_func": "@@ -1663,8 +1663,10 @@ SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n \tif (op == EPOLL_CTL_ADD) {\n \t\tif (is_file_epoll(tfile)) {\n \t\t\terror = -ELOOP;\n-\t\t\tif (ep_loop_check(ep, tfile) != 0)\n+\t\t\tif (ep_loop_check(ep, tfile) != 0) {\n+\t\t\t\tclear_tfile_check_list();\n \t\t\t\tgoto error_tgt_fput;\n+\t\t\t}\n \t\t} else\n \t\t\tlist_add(&tfile->f_tfile_llink, &tfile_check_list);\n \t}",
  "project": "linux",
  "commit_id": "13d518074a952d33d47c428419693f63389547e9",
  "target": 1,
  "func": "SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n\tint error;\n\tint did_lock_epmutex = 0;\n\tstruct file *file, *tfile;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the eventpoll file */\n\terror = -EBADF;\n\tfile = fget(epfd);\n\tif (!file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttfile = fget(fd);\n\tif (!tfile)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!tfile->f_op || !tfile->f_op->poll)\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (file == tfile || !is_file_epoll(file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven't created too many possible wakeup paths.\n\t *\n\t * We need to hold the epmutex across both ep_insert and ep_remove\n\t * b/c we want to make sure we are looking at a coherent view of\n\t * epoll network.\n\t */\n\tif (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) {\n\t\tmutex_lock(&epmutex);\n\t\tdid_lock_epmutex = 1;\n\t}\n \tif (op == EPOLL_CTL_ADD) {\n \t\tif (is_file_epoll(tfile)) {\n \t\t\terror = -ELOOP;\n\t\t\tif (ep_loop_check(ep, tfile) != 0)\n \t\t\t\tgoto error_tgt_fput;\n \t\t} else\n \t\t\tlist_add(&tfile->f_tfile_llink, &tfile_check_list);\n \t}\n\n\tmutex_lock_nested(&ep->mtx, 0);\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tfile, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_insert(ep, &epds, tfile, fd);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tclear_tfile_check_list();\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_modify(ep, epi, &epds);\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (did_lock_epmutex)\n\t\tmutex_unlock(&epmutex);\n\n\tfput(tfile);\nerror_fput:\n\tfput(file);\nerror_return:\n\n\treturn error;\n}\n",
  "big_vul_idx": 178760,
  "idx": 626,
  "hash": 158960947259321225881221408709650413864
}