{
  "id": 999,
  "language": "c",
  "cwe": "CWE-200",
  "commit_url": "https://github.com/sjp38/linux.personal/commit/089bc0143f489bd3a4578bdff5f4ca68fb26f341",
  "commit_sha": "089bc0143f489bd3a4578bdff5f4ca68fb26f341",
  "commit_msg": "xen-blkback: don't leak stack data via response ring\n\nRather than constructing a local structure instance on the stack, fill\nthe fields directly on the shared ring, just like other backends do.\nBuild on the fact that all response structure flavors are actually\nidentical (the old code did make this assumption too).\n\nThis is XSA-216.\n\nCc: stable@vger.kernel.org\n\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nSigned-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/block/xen-blkback/blkback.c",
  "func_name": "",
  "raw_func_from_json": " static void make_response(struct xen_blkif_ring *ring, u64 id,\n \t\t\t  unsigned short op, int st)\n {\n\tstruct blkif_response  resp;\n \tunsigned long     flags;\n \tunion blkif_back_rings *blk_rings;\n \tint notify;\n \n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n \tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n \tblk_rings = &ring->blk_rings;\n \t/* Place on the response ring for the relevant domain. */\n \tswitch (ring->blkif->blk_protocol) {\n \tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n \tblk_rings->common.rsp_prod_pvt++;\n \tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n \tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}\n",
  "diff_func": "@@ -1433,34 +1433,35 @@ static int dispatch_rw_block_io(struct xen_blkif_ring *ring,\n static void make_response(struct xen_blkif_ring *ring, u64 id,\n \t\t\t  unsigned short op, int st)\n {\n-\tstruct blkif_response  resp;\n+\tstruct blkif_response *resp;\n \tunsigned long     flags;\n \tunion blkif_back_rings *blk_rings;\n \tint notify;\n \n-\tresp.id        = id;\n-\tresp.operation = op;\n-\tresp.status    = st;\n-\n \tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n \tblk_rings = &ring->blk_rings;\n \t/* Place on the response ring for the relevant domain. */\n \tswitch (ring->blkif->blk_protocol) {\n \tcase BLKIF_PROTOCOL_NATIVE:\n-\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n-\t\t       &resp, sizeof(resp));\n+\t\tresp = RING_GET_RESPONSE(&blk_rings->native,\n+\t\t\t\t\t blk_rings->native.rsp_prod_pvt);\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_32:\n-\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n-\t\t       &resp, sizeof(resp));\n+\t\tresp = RING_GET_RESPONSE(&blk_rings->x86_32,\n+\t\t\t\t\t blk_rings->x86_32.rsp_prod_pvt);\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_64:\n-\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n-\t\t       &resp, sizeof(resp));\n+\t\tresp = RING_GET_RESPONSE(&blk_rings->x86_64,\n+\t\t\t\t\t blk_rings->x86_64.rsp_prod_pvt);\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n+\n+\tresp->id        = id;\n+\tresp->operation = op;\n+\tresp->status    = st;\n+\n \tblk_rings->common.rsp_prod_pvt++;\n \tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n \tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);",
  "project": "linux",
  "commit_id": "089bc0143f489bd3a4578bdff5f4ca68fb26f341",
  "target": 1,
  "func": " static void make_response(struct xen_blkif_ring *ring, u64 id,\n \t\t\t  unsigned short op, int st)\n {\n\tstruct blkif_response  resp;\n \tunsigned long     flags;\n \tunion blkif_back_rings *blk_rings;\n \tint notify;\n \n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n \tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n \tblk_rings = &ring->blk_rings;\n \t/* Place on the response ring for the relevant domain. */\n \tswitch (ring->blkif->blk_protocol) {\n \tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n \tblk_rings->common.rsp_prod_pvt++;\n \tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n \tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}\n",
  "big_vul_idx": 181231,
  "idx": 2726,
  "hash": 3010677516050940168971720314141414057
}