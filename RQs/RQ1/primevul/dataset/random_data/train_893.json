{
  "id": 893,
  "language": "c",
  "cwe": "CWE-834",
  "commit_url": "https://github.com/etemesi254/ffmpeg-ht/commit/4f05e2e2dc1a89f38cd9f0960a6561083d714f1e",
  "commit_sha": "4f05e2e2dc1a89f38cd9f0960a6561083d714f1e",
  "commit_msg": "avformat/mvdec: Fix DoS due to lack of eof check\n\nFixes: loop.mv\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libavformat/mvdec.c",
  "func_name": "",
  "raw_func_from_json": "static int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \"Video compression %i\", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \"title\", 0x80);\n        var_read_metadata(avctx, \"comment\", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n             uint32_t pos   = avio_rb32(pb);\n             uint32_t asize = avio_rb32(pb);\n             uint32_t vsize = avio_rb32(pb);\n             avio_skip(pb, 8);\n             av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n             av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple audio streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n                return AVERROR(ENOMEM);\n            ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            if ((read_table(avctx, ast, parse_audio_var)) < 0)\n                return ret;\n            if (mv->acompression == 100 &&\n                mv->aformat == AUDIO_FORMAT_SIGNED &&\n                ast->codecpar->bits_per_coded_sample == 16) {\n                ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else {\n                avpriv_request_sample(avctx,\n                                      \"Audio compression %i (format %i, sr %i)\",\n                                      mv->acompression, mv->aformat,\n                                      ast->codecpar->bits_per_coded_sample);\n                ast->codecpar->codec_id = AV_CODEC_ID_NONE;\n            }\n            if (ast->codecpar->channels <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"No valid channel count found.\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        if (mv->nb_video_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple video streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_video_tracks) {\n            vst = avformat_new_stream(avctx, NULL);\n            if (!vst)\n                return AVERROR(ENOMEM);\n            vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            if ((ret = read_table(avctx, vst, parse_video_var))<0)\n                return ret;\n        }\n\n        if (mv->nb_audio_tracks)\n            read_index(pb, ast);\n\n        if (mv->nb_video_tracks)\n            read_index(pb, vst);\n    } else {\n        avpriv_request_sample(avctx, \"Version %i\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}\n",
  "diff_func": "@@ -342,6 +342,8 @@ static int mv_read_header(AVFormatContext *avctx)\n             uint32_t pos   = avio_rb32(pb);\n             uint32_t asize = avio_rb32(pb);\n             uint32_t vsize = avio_rb32(pb);\n+            if (avio_feof(pb))\n+                return AVERROR_INVALIDDATA;\n             avio_skip(pb, 8);\n             av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n             av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);",
  "project": "FFmpeg",
  "commit_id": "4f05e2e2dc1a89f38cd9f0960a6561083d714f1e",
  "target": 1,
  "func": "static int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \"Video compression %i\", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \"title\", 0x80);\n        var_read_metadata(avctx, \"comment\", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n             uint32_t pos   = avio_rb32(pb);\n             uint32_t asize = avio_rb32(pb);\n             uint32_t vsize = avio_rb32(pb);\n             avio_skip(pb, 8);\n             av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n             av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple audio streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n                return AVERROR(ENOMEM);\n            ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            if ((read_table(avctx, ast, parse_audio_var)) < 0)\n                return ret;\n            if (mv->acompression == 100 &&\n                mv->aformat == AUDIO_FORMAT_SIGNED &&\n                ast->codecpar->bits_per_coded_sample == 16) {\n                ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else {\n                avpriv_request_sample(avctx,\n                                      \"Audio compression %i (format %i, sr %i)\",\n                                      mv->acompression, mv->aformat,\n                                      ast->codecpar->bits_per_coded_sample);\n                ast->codecpar->codec_id = AV_CODEC_ID_NONE;\n            }\n            if (ast->codecpar->channels <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"No valid channel count found.\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        if (mv->nb_video_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple video streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_video_tracks) {\n            vst = avformat_new_stream(avctx, NULL);\n            if (!vst)\n                return AVERROR(ENOMEM);\n            vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            if ((ret = read_table(avctx, vst, parse_video_var))<0)\n                return ret;\n        }\n\n        if (mv->nb_audio_tracks)\n            read_index(pb, ast);\n\n        if (mv->nb_video_tracks)\n            read_index(pb, vst);\n    } else {\n        avpriv_request_sample(avctx, \"Version %i\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}\n",
  "big_vul_idx": 180949,
  "idx": 2484,
  "hash": 61768510921436960692985129912388758664
}