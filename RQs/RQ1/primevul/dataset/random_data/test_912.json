{
  "id": 912,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/malvira/lpc31xx/commit/fdac1e0697356ac212259f2147aa60c72e334861",
  "commit_sha": "fdac1e0697356ac212259f2147aa60c72e334861",
  "commit_msg": "irda: prevent integer underflow in IRLMP_ENUMDEVICES\n\nIf the user-provided len is less than the expected offset, the\nIRLMP_ENUMDEVICES getsockopt will do a copy_to_user() with a very large\nsize value.  While this isn't be a security issue on x86 because it will\nget caught by the access_ok() check, it may leak large amounts of kernel\nheap on other architectures.  In any event, this patch fixes it.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/irda/af_irda.c",
  "func_name": "",
  "raw_func_from_json": "static int irda_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct irda_device_list list;\n\tstruct irda_device_info *discoveries;\n\tstruct irda_ias_set *\tias_opt;\t/* IAS get/query params */\n\tstruct ias_object *\tias_obj;\t/* Object in IAS */\n\tstruct ias_attrib *\tias_attr;\t/* Attribute in IAS object */\n\tint daddr = DEV_ADDR_ANY;\t/* Dest address for IAS queries */\n\tint val = 0;\n\tint len = 0;\n\tint err = 0;\n\tint offset, total;\n\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\n\tif (level != SOL_IRLMP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif(len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IRLMP_ENUMDEVICES:\n\t\t/* Ask lmp for the current discovery log */\n\t\tdiscoveries = irlmp_get_discoveries(&list.len, self->mask.word,\n\t\t\t\t\t\t    self->nslots);\n\t\t/* Check if the we got some results */\n\t\tif (discoveries == NULL) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\t\t/* Didn't find any devices */\n\t\t}\n\n\t\t/* Write total list length back to client */\n\t\tif (copy_to_user(optval, &list,\n\t\t\t\t sizeof(struct irda_device_list) -\n\t\t\t\t sizeof(struct irda_device_info)))\n\t\t\terr = -EFAULT;\n\n\t\t/* Offset to first device entry */\n\t\toffset = sizeof(struct irda_device_list) -\n\t\t\tsizeof(struct irda_device_info);\n\n\t\t/* Copy the list itself - watch for overflow */\n\t\tif (list.len > 2048) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto bed;\n\t\t}\n\t\ttotal = offset + (list.len * sizeof(struct irda_device_info));\n\t\tif (total > len)\n\t\t\ttotal = len;\n\t\tif (copy_to_user(optval+offset, discoveries, total - offset))\n\t\t\terr = -EFAULT;\n\n\t\t/* Write total number of bytes used back to client */\n\t\tif (put_user(total, optlen))\n\t\t\terr = -EFAULT;\nbed:\n\t\t/* Free up our buffer */\n\t\tkfree(discoveries);\n\t\tbreak;\n\tcase IRLMP_MAX_SDU_SIZE:\n\t\tval = self->max_data_size;\n\t\tlen = sizeof(int);\n\t\tif (put_user(len, optlen)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(optval, &val, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tcase IRLMP_IAS_GET:\n\t\t/* The user want an object from our local IAS database.\n\t\t * We just need to query the IAS and return the value\n\t\t * that we found */\n\n\t\t/* Check that the user has allocated the right space for us */\n\t\tif (len != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, len)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the object we target.\n\t\t * If the user gives us an empty string, we use the object\n\t\t * associated with this socket. This will workaround\n\t\t * duplicated class name - Jean II */\n\t\tif(ias_opt->irda_class_name[0] == '\\0')\n\t\t\tias_obj = self->ias_obj;\n\t\telse\n\t\t\tias_obj = irias_find_object(ias_opt->irda_class_name);\n\t\tif(ias_obj == (struct ias_object *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the attribute (in the object) we target */\n\t\tias_attr = irias_find_attrib(ias_obj,\n\t\t\t\t\t     ias_opt->irda_attrib_name);\n\t\tif(ias_attr == (struct ias_attrib *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Translate from internal to user structure */\n\t\terr = irda_extract_ias_value(ias_opt, ias_attr->value);\n\t\tif(err) {\n\t\t\tkfree(ias_opt);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy reply to the user */\n\t\tif (copy_to_user(optval, ias_opt,\n\t\t\t\t sizeof(struct irda_ias_set))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Note : don't need to put optlen, we checked it */\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_IAS_QUERY:\n\t\t/* The user want an object from a remote IAS database.\n\t\t * We need to use IAP to query the remote database and\n\t\t * then wait for the answer to come back. */\n\n\t\t/* Check that the user has allocated the right space for us */\n\t\tif (len != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, len)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* At this point, there are two cases...\n\t\t * 1) the socket is connected - that's the easy case, we\n\t\t *\tjust query the device we are connected to...\n\t\t * 2) the socket is not connected - the user doesn't want\n\t\t *\tto connect and/or may not have a valid service name\n\t\t *\t(so can't create a fake connection). In this case,\n\t\t *\twe assume that the user pass us a valid destination\n\t\t *\taddress in the requesting structure...\n\t\t */\n\t\tif(self->daddr != DEV_ADDR_ANY) {\n\t\t\t/* We are connected - reuse known daddr */\n\t\t\tdaddr = self->daddr;\n\t\t} else {\n\t\t\t/* We are not connected, we must specify a valid\n\t\t\t * destination address */\n\t\t\tdaddr = ias_opt->daddr;\n\t\t\tif((!daddr) || (daddr == DEV_ADDR_ANY)) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* Check that we can proceed with IAP */\n\t\tif (self->iriap) {\n\t\t\tIRDA_WARNING(\"%s: busy with a previous query\\n\",\n\t\t\t\t     __func__);\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\n\t\t\t\t\t irda_getvalue_confirm);\n\n\t\tif (self->iriap == NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Treat unexpected wakeup as disconnect */\n\t\tself->errno = -EHOSTUNREACH;\n\n\t\t/* Query remote LM-IAS */\n\t\tiriap_getvaluebyclass_request(self->iriap,\n\t\t\t\t\t      self->saddr, daddr,\n\t\t\t\t\t      ias_opt->irda_class_name,\n\t\t\t\t\t      ias_opt->irda_attrib_name);\n\n\t\t/* Wait for answer, if not yet finished (or failed) */\n\t\tif (wait_event_interruptible(self->query_wait,\n\t\t\t\t\t     (self->iriap == NULL))) {\n\t\t\t/* pending request uses copy of ias_opt-content\n\t\t\t * we can free it regardless! */\n\t\t\tkfree(ias_opt);\n\t\t\t/* Treat signals as disconnect */\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check what happened */\n\t\tif (self->errno)\n\t\t{\n\t\t\tkfree(ias_opt);\n\t\t\t/* Requested object/attribute doesn't exist */\n\t\t\tif((self->errno == IAS_CLASS_UNKNOWN) ||\n\t\t\t   (self->errno == IAS_ATTRIB_UNKNOWN))\n\t\t\t\terr = -EADDRNOTAVAIL;\n\t\t\telse\n\t\t\t\terr = -EHOSTUNREACH;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Translate from internal to user structure */\n\t\terr = irda_extract_ias_value(ias_opt, self->ias_result);\n\t\tif (self->ias_result)\n\t\t\tirias_delete_value(self->ias_result);\n\t\tif (err) {\n\t\t\tkfree(ias_opt);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy reply to the user */\n\t\tif (copy_to_user(optval, ias_opt,\n\t\t\t\t sizeof(struct irda_ias_set))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Note : don't need to put optlen, we checked it */\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_WAITDEVICE:\n\t\t/* This function is just another way of seeing life ;-)\n\t\t * IRLMP_ENUMDEVICES assumes that you have a static network,\n\t\t * and that you just want to pick one of the devices present.\n\t\t * On the other hand, in here we assume that no device is\n\t\t * present and that at some point in the future a device will\n\t\t * come into range. When this device arrive, we just wake\n\t\t * up the caller, so that he has time to connect to it before\n\t\t * the device goes away...\n\t\t * Note : once the node has been discovered for more than a\n\t\t * few second, it won't trigger this function, unless it\n\t\t * goes away and come back changes its hint bits (so we\n\t\t * might call it IRLMP_WAITNEWDEVICE).\n\t\t */\n\n\t\t/* Check that the user is passing us an int */\n\t\tif (len != sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Get timeout in ms (max time we block the caller) */\n\t\tif (get_user(val, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Tell IrLMP we want to be notified */\n\t\tirlmp_update_client(self->ckey, self->mask.word,\n\t\t\t\t    irda_selective_discovery_indication,\n\t\t\t\t    NULL, (void *) self);\n\n\t\t/* Do some discovery (and also return cached results) */\n\t\tirlmp_discovery_request(self->nslots);\n\n\t\t/* Wait until a node is discovered */\n\t\tif (!self->cachedaddr) {\n\t\t\tIRDA_DEBUG(1, \"%s(), nothing discovered yet, going to sleep...\\n\", __func__);\n\n\t\t\t/* Set watchdog timer to expire in <val> ms. */\n\t\t\tself->errno = 0;\n\t\t\tsetup_timer(&self->watchdog, irda_discovery_timeout,\n\t\t\t\t\t(unsigned long)self);\n\t\t\tself->watchdog.expires = jiffies + (val * HZ/1000);\n\t\t\tadd_timer(&(self->watchdog));\n\n\t\t\t/* Wait for IR-LMP to call us back */\n\t\t\t__wait_event_interruptible(self->query_wait,\n\t\t\t      (self->cachedaddr != 0 || self->errno == -ETIME),\n\t\t\t\t\t\t   err);\n\n\t\t\t/* If watchdog is still activated, kill it! */\n\t\t\tif(timer_pending(&(self->watchdog)))\n\t\t\t\tdel_timer(&(self->watchdog));\n\n\t\t\tIRDA_DEBUG(1, \"%s(), ...waking up !\\n\", __func__);\n\n\t\t\tif (err != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\telse\n\t\t\tIRDA_DEBUG(1, \"%s(), found immediately !\\n\",\n\t\t\t\t   __func__);\n\n\t\t/* Tell IrLMP that we have been notified */\n\t\tirlmp_update_client(self->ckey, self->mask.word,\n\t\t\t\t    NULL, NULL, NULL);\n\n\t\t/* Check if the we got some results */\n\t\tif (!self->cachedaddr)\n\t\t\treturn -EAGAIN;\t\t/* Didn't find any devices */\n\t\tdaddr = self->cachedaddr;\n\t\t/* Cleanup */\n\t\tself->cachedaddr = 0;\n\n\t\t/* We return the daddr of the device that trigger the\n\t\t * wakeup. As irlmp pass us only the new devices, we\n\t\t * are sure that it's not an old device.\n\t\t * If the user want more details, he should query\n\t\t * the whole discovery log and pick one device...\n\t\t */\n\t\tif (put_user(daddr, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\nout:\n\n\trelease_sock(sk);\n\n\treturn err;\n}",
  "diff_func": "@@ -2281,6 +2281,16 @@ static int irda_getsockopt(struct socket *sock, int level, int optname,\n \n \tswitch (optname) {\n \tcase IRLMP_ENUMDEVICES:\n+\n+\t\t/* Offset to first device entry */\n+\t\toffset = sizeof(struct irda_device_list) -\n+\t\t\tsizeof(struct irda_device_info);\n+\n+\t\tif (len < offset) {\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto out;\n+\t\t}\n+\n \t\t/* Ask lmp for the current discovery log */\n \t\tdiscoveries = irlmp_get_discoveries(&list.len, self->mask.word,\n \t\t\t\t\t\t    self->nslots);\n@@ -2291,15 +2301,9 @@ static int irda_getsockopt(struct socket *sock, int level, int optname,\n \t\t}\n \n \t\t/* Write total list length back to client */\n-\t\tif (copy_to_user(optval, &list,\n-\t\t\t\t sizeof(struct irda_device_list) -\n-\t\t\t\t sizeof(struct irda_device_info)))\n+\t\tif (copy_to_user(optval, &list, offset))\n \t\t\terr = -EFAULT;\n \n-\t\t/* Offset to first device entry */\n-\t\toffset = sizeof(struct irda_device_list) -\n-\t\t\tsizeof(struct irda_device_info);\n-\n \t\t/* Copy the list itself - watch for overflow */\n \t\tif (list.len > 2048) {\n \t\t\terr = -EINVAL;",
  "func": "static int irda_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct irda_device_list list;\n\tstruct irda_device_info *discoveries;\n\tstruct irda_ias_set *\tias_opt;\t/* IAS get/query params */\n\tstruct ias_object *\tias_obj;\t/* Object in IAS */\n\tstruct ias_attrib *\tias_attr;\t/* Attribute in IAS object */\n\tint daddr = DEV_ADDR_ANY;\t/* Dest address for IAS queries */\n\tint val = 0;\n\tint len = 0;\n\tint err = 0;\n\tint offset, total;\n\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\n\tif (level != SOL_IRLMP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif(len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IRLMP_ENUMDEVICES:\n\t\t/* Ask lmp for the current discovery log */\n\t\tdiscoveries = irlmp_get_discoveries(&list.len, self->mask.word,\n\t\t\t\t\t\t    self->nslots);\n\t\t/* Check if the we got some results */\n\t\tif (discoveries == NULL) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\t\t/* Didn't find any devices */\n\t\t}\n\n\t\t/* Write total list length back to client */\n\t\tif (copy_to_user(optval, &list,\n\t\t\t\t sizeof(struct irda_device_list) -\n\t\t\t\t sizeof(struct irda_device_info)))\n\t\t\terr = -EFAULT;\n\n\t\t/* Offset to first device entry */\n\t\toffset = sizeof(struct irda_device_list) -\n\t\t\tsizeof(struct irda_device_info);\n\n\t\t/* Copy the list itself - watch for overflow */\n\t\tif (list.len > 2048) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto bed;\n\t\t}\n\t\ttotal = offset + (list.len * sizeof(struct irda_device_info));\n\t\tif (total > len)\n\t\t\ttotal = len;\n\t\tif (copy_to_user(optval+offset, discoveries, total - offset))\n\t\t\terr = -EFAULT;\n\n\t\t/* Write total number of bytes used back to client */\n\t\tif (put_user(total, optlen))\n\t\t\terr = -EFAULT;\nbed:\n\t\t/* Free up our buffer */\n\t\tkfree(discoveries);\n\t\tbreak;\n\tcase IRLMP_MAX_SDU_SIZE:\n\t\tval = self->max_data_size;\n\t\tlen = sizeof(int);\n\t\tif (put_user(len, optlen)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(optval, &val, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tcase IRLMP_IAS_GET:\n\t\t/* The user want an object from our local IAS database.\n\t\t * We just need to query the IAS and return the value\n\t\t * that we found */\n\n\t\t/* Check that the user has allocated the right space for us */\n\t\tif (len != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, len)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the object we target.\n\t\t * If the user gives us an empty string, we use the object\n\t\t * associated with this socket. This will workaround\n\t\t * duplicated class name - Jean II */\n\t\tif(ias_opt->irda_class_name[0] == '\\0')\n\t\t\tias_obj = self->ias_obj;\n\t\telse\n\t\t\tias_obj = irias_find_object(ias_opt->irda_class_name);\n\t\tif(ias_obj == (struct ias_object *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the attribute (in the object) we target */\n\t\tias_attr = irias_find_attrib(ias_obj,\n\t\t\t\t\t     ias_opt->irda_attrib_name);\n\t\tif(ias_attr == (struct ias_attrib *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Translate from internal to user structure */\n\t\terr = irda_extract_ias_value(ias_opt, ias_attr->value);\n\t\tif(err) {\n\t\t\tkfree(ias_opt);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy reply to the user */\n\t\tif (copy_to_user(optval, ias_opt,\n\t\t\t\t sizeof(struct irda_ias_set))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Note : don't need to put optlen, we checked it */\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_IAS_QUERY:\n\t\t/* The user want an object from a remote IAS database.\n\t\t * We need to use IAP to query the remote database and\n\t\t * then wait for the answer to come back. */\n\n\t\t/* Check that the user has allocated the right space for us */\n\t\tif (len != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, len)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* At this point, there are two cases...\n\t\t * 1) the socket is connected - that's the easy case, we\n\t\t *\tjust query the device we are connected to...\n\t\t * 2) the socket is not connected - the user doesn't want\n\t\t *\tto connect and/or may not have a valid service name\n\t\t *\t(so can't create a fake connection). In this case,\n\t\t *\twe assume that the user pass us a valid destination\n\t\t *\taddress in the requesting structure...\n\t\t */\n\t\tif(self->daddr != DEV_ADDR_ANY) {\n\t\t\t/* We are connected - reuse known daddr */\n\t\t\tdaddr = self->daddr;\n\t\t} else {\n\t\t\t/* We are not connected, we must specify a valid\n\t\t\t * destination address */\n\t\t\tdaddr = ias_opt->daddr;\n\t\t\tif((!daddr) || (daddr == DEV_ADDR_ANY)) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* Check that we can proceed with IAP */\n\t\tif (self->iriap) {\n\t\t\tIRDA_WARNING(\"%s: busy with a previous query\\n\",\n\t\t\t\t     __func__);\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\n\t\t\t\t\t irda_getvalue_confirm);\n\n\t\tif (self->iriap == NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Treat unexpected wakeup as disconnect */\n\t\tself->errno = -EHOSTUNREACH;\n\n\t\t/* Query remote LM-IAS */\n\t\tiriap_getvaluebyclass_request(self->iriap,\n\t\t\t\t\t      self->saddr, daddr,\n\t\t\t\t\t      ias_opt->irda_class_name,\n\t\t\t\t\t      ias_opt->irda_attrib_name);\n\n\t\t/* Wait for answer, if not yet finished (or failed) */\n\t\tif (wait_event_interruptible(self->query_wait,\n\t\t\t\t\t     (self->iriap == NULL))) {\n\t\t\t/* pending request uses copy of ias_opt-content\n\t\t\t * we can free it regardless! */\n\t\t\tkfree(ias_opt);\n\t\t\t/* Treat signals as disconnect */\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check what happened */\n\t\tif (self->errno)\n\t\t{\n\t\t\tkfree(ias_opt);\n\t\t\t/* Requested object/attribute doesn't exist */\n\t\t\tif((self->errno == IAS_CLASS_UNKNOWN) ||\n\t\t\t   (self->errno == IAS_ATTRIB_UNKNOWN))\n\t\t\t\terr = -EADDRNOTAVAIL;\n\t\t\telse\n\t\t\t\terr = -EHOSTUNREACH;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Translate from internal to user structure */\n\t\terr = irda_extract_ias_value(ias_opt, self->ias_result);\n\t\tif (self->ias_result)\n\t\t\tirias_delete_value(self->ias_result);\n\t\tif (err) {\n\t\t\tkfree(ias_opt);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy reply to the user */\n\t\tif (copy_to_user(optval, ias_opt,\n\t\t\t\t sizeof(struct irda_ias_set))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Note : don't need to put optlen, we checked it */\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_WAITDEVICE:\n\t\t/* This function is just another way of seeing life ;-)\n\t\t * IRLMP_ENUMDEVICES assumes that you have a static network,\n\t\t * and that you just want to pick one of the devices present.\n\t\t * On the other hand, in here we assume that no device is\n\t\t * present and that at some point in the future a device will\n\t\t * come into range. When this device arrive, we just wake\n\t\t * up the caller, so that he has time to connect to it before\n\t\t * the device goes away...\n\t\t * Note : once the node has been discovered for more than a\n\t\t * few second, it won't trigger this function, unless it\n\t\t * goes away and come back changes its hint bits (so we\n\t\t * might call it IRLMP_WAITNEWDEVICE).\n\t\t */\n\n\t\t/* Check that the user is passing us an int */\n\t\tif (len != sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Get timeout in ms (max time we block the caller) */\n\t\tif (get_user(val, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Tell IrLMP we want to be notified */\n\t\tirlmp_update_client(self->ckey, self->mask.word,\n\t\t\t\t    irda_selective_discovery_indication,\n\t\t\t\t    NULL, (void *) self);\n\n\t\t/* Do some discovery (and also return cached results) */\n\t\tirlmp_discovery_request(self->nslots);\n\n\t\t/* Wait until a node is discovered */\n\t\tif (!self->cachedaddr) {\n\t\t\tIRDA_DEBUG(1, \"%s(), nothing discovered yet, going to sleep...\\n\", __func__);\n\n\t\t\t/* Set watchdog timer to expire in <val> ms. */\n\t\t\tself->errno = 0;\n\t\t\tsetup_timer(&self->watchdog, irda_discovery_timeout,\n\t\t\t\t\t(unsigned long)self);\n\t\t\tself->watchdog.expires = jiffies + (val * HZ/1000);\n\t\t\tadd_timer(&(self->watchdog));\n\n\t\t\t/* Wait for IR-LMP to call us back */\n\t\t\t__wait_event_interruptible(self->query_wait,\n\t\t\t      (self->cachedaddr != 0 || self->errno == -ETIME),\n\t\t\t\t\t\t   err);\n\n\t\t\t/* If watchdog is still activated, kill it! */\n\t\t\tif(timer_pending(&(self->watchdog)))\n\t\t\t\tdel_timer(&(self->watchdog));\n\n\t\t\tIRDA_DEBUG(1, \"%s(), ...waking up !\\n\", __func__);\n\n\t\t\tif (err != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\telse\n\t\t\tIRDA_DEBUG(1, \"%s(), found immediately !\\n\",\n\t\t\t\t   __func__);\n\n\t\t/* Tell IrLMP that we have been notified */\n\t\tirlmp_update_client(self->ckey, self->mask.word,\n\t\t\t\t    NULL, NULL, NULL);\n\n\t\t/* Check if the we got some results */\n\t\tif (!self->cachedaddr)\n\t\t\treturn -EAGAIN;\t\t/* Didn't find any devices */\n\t\tdaddr = self->cachedaddr;\n\t\t/* Cleanup */\n\t\tself->cachedaddr = 0;\n\n\t\t/* We return the daddr of the device that trigger the\n\t\t * wakeup. As irlmp pass us only the new devices, we\n\t\t * are sure that it's not an old device.\n\t\t * If the user want more details, he should query\n\t\t * the whole discovery log and pick one device...\n\t\t */\n\t\tif (put_user(daddr, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\nout:\n\n\trelease_sock(sk);\n\n\treturn err;\n}",
  "project": "linux",
  "hash": 206723367980818827503124126810367962719,
  "size": 360,
  "commit_id": "fdac1e0697356ac212259f2147aa60c72e334861",
  "message": "irda: prevent integer underflow in IRLMP_ENUMDEVICES\n\nIf the user-provided len is less than the expected offset, the\nIRLMP_ENUMDEVICES getsockopt will do a copy_to_user() with a very large\nsize value.  While this isn't be a security issue on x86 because it will\nget caught by the access_ok() check, it may leak large amounts of kernel\nheap on other architectures.  In any event, this patch fixes it.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "target": 1,
  "dataset": "other",
  "idx": 205821
}