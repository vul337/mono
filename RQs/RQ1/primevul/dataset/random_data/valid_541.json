{
  "id": 541,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/pankaj2n/EGIGNNEW-JEFF/commit/0206ebe76f748bb39d9de4dd4b3fce777fdfdccf",
  "commit_sha": "0206ebe76f748bb39d9de4dd4b3fce777fdfdccf",
  "commit_msg": "Fixed ngx_gmtime() on 32-bit platforms with 64-bit time_t.\n\nIn ngx_gmtime(), instead of casting to ngx_uint_t we now work with\ntime_t directly.  This allows using dates after 2038 on 32-bit platforms\nwhich use 64-bit time_t, notably NetBSD and OpenBSD.\n\nAs the code is not able to work with negative time_t values, argument\nis now set to 0 for negative values.  As a positive side effect, this\nresults in Epoch being used for such values instead of a date in distant\nfuture.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/core/ngx_times.c",
  "func_name": "",
  "raw_func_from_json": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  n, sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    n = (ngx_uint_t) t;\n\n    days = n / 86400;\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    n %= 86400;\n    hour = n / 3600;\n    n %= 3600;\n    min = n / 60;\n    sec = n % 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}",
  "diff_func": "@@ -300,23 +300,25 @@ void\n ngx_gmtime(time_t t, ngx_tm_t *tp)\n {\n     ngx_int_t   yday;\n-    ngx_uint_t  n, sec, min, hour, mday, mon, year, wday, days, leap;\n+    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n \n     /* the calculation is valid for positive time_t only */\n \n-    n = (ngx_uint_t) t;\n+    if (t < 0) {\n+        t = 0;\n+    }\n \n-    days = n / 86400;\n+    days = t / 86400;\n+    sec = t % 86400;\n \n     /* January 1, 1970 was Thursday */\n \n     wday = (4 + days) % 7;\n \n-    n %= 86400;\n-    hour = n / 3600;\n-    n %= 3600;\n-    min = n / 60;\n-    sec = n % 60;\n+    hour = sec / 3600;\n+    sec %= 3600;\n+    min = sec / 60;\n+    sec %= 60;\n \n     /*\n      * the algorithm based on Gauss' formula,",
  "func": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  n, sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    n = (ngx_uint_t) t;\n\n    days = n / 86400;\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    n %= 86400;\n    hour = n / 3600;\n    n %= 3600;\n    min = n / 60;\n    sec = n % 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}",
  "project": "nginx",
  "hash": 57982225550842118886439812311974890926,
  "size": 90,
  "commit_id": "0206ebe76f748bb39d9de4dd4b3fce777fdfdccf",
  "message": "Fixed ngx_gmtime() on 32-bit platforms with 64-bit time_t.\n\nIn ngx_gmtime(), instead of casting to ngx_uint_t we now work with\ntime_t directly.  This allows using dates after 2038 on 32-bit platforms\nwhich use 64-bit time_t, notably NetBSD and OpenBSD.\n\nAs the code is not able to work with negative time_t values, argument\nis now set to 0 for negative values.  As a positive side effect, this\nresults in Epoch being used for such values instead of a date in distant\nfuture.",
  "target": 1,
  "dataset": "other",
  "idx": 197849
}