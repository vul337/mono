{
  "id": 483,
  "language": "c",
  "cwe": "CWE-264",
  "commit_url": "https://github.com/ljalves/linux_media/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc",
  "commit_sha": "4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc",
  "commit_msg": "target/rd: Refactor rd_build_device_space + rd_release_device_space\n\nThis patch refactors rd_build_device_space() + rd_release_device_space()\ninto rd_allocate_sgl_table() + rd_release_device_space() so that they\nmay be used seperatly for setup + release of protection information\nscatterlists.\n\nAlso add explicit memset of pages within rd_allocate_sgl_table() based\nupon passed 'init_payload' value.\n\nv2 changes:\n  - Drop unused sg_table from rd_release_device_space (Wei)\n\nCc: Martin K. Petersen <martin.petersen@oracle.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Hannes Reinecke <hare@suse.de>\nCc: Sagi Grimberg <sagig@mellanox.com>\nCc: Or Gerlitz <ogerlitz@mellanox.com>\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/target/target_core_rd.c",
  "func_name": "",
  "raw_func_from_json": "static int rd_build_device_space(struct rd_dev *rd_dev)\n {\n\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n \tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n \t\t\t\tsizeof(struct scatterlist));\n\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n\tif (rd_dev->rd_page_count <= 0) {\n\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n\t\t\trd_dev->rd_page_count);\n\t\treturn -EINVAL;\n\t}\n\t/* Don't need backing pages for NULLIO */\n\tif (rd_dev->rd_flags & RDF_NULLIO)\n\t\treturn 0;\n\ttotal_sg_needed = rd_dev->rd_page_count;\n\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n\tif (!sg_table) {\n\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n\t\t\t\" scatterlist tables\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trd_dev->sg_table_array = sg_table;\n\trd_dev->sg_table_count = sg_tables;\n \n \twhile (total_sg_needed) {\n \t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tsg_init_table(sg, sg_per_table);\n\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n \t\t\t}\n \t\t\tsg_assign_page(&sg[j], pg);\n \t\t\tsg[j].length = PAGE_SIZE;\n \t\t}\n \n \t\tpage_offset += sg_per_table;\n \t\ttotal_sg_needed -= sg_per_table;\n \t}\n \n \tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"\n\t\t\" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\trd_dev->sg_table_count);\n \n \treturn 0;\n }\n",
  "diff_func": "@@ -78,23 +78,14 @@ static void rd_detach_hba(struct se_hba *hba)\n \thba->hba_ptr = NULL;\n }\n \n-/*\trd_release_device_space():\n- *\n- *\n- */\n-static void rd_release_device_space(struct rd_dev *rd_dev)\n+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 sg_table_count)\n {\n-\tu32 i, j, page_count = 0, sg_per_table;\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n+\tu32 i, j, page_count = 0, sg_per_table;\n \n-\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n-\t\treturn;\n-\n-\tsg_table = rd_dev->sg_table_array;\n-\n-\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n+\tfor (i = 0; i < sg_table_count; i++) {\n \t\tsg = sg_table[i].sg_table;\n \t\tsg_per_table = sg_table[i].rd_sg_count;\n \n@@ -105,16 +96,28 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n \t\t\t\tpage_count++;\n \t\t\t}\n \t\t}\n-\n \t\tkfree(sg);\n \t}\n \n+\tkfree(sg_table);\n+\treturn page_count;\n+}\n+\n+static void rd_release_device_space(struct rd_dev *rd_dev)\n+{\n+\tu32 page_count;\n+\n+\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n+\t\treturn;\n+\n+\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,\n+\t\t\t\t\t  rd_dev->sg_table_count);\n+\n \tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n \t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n \t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n \t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n \n-\tkfree(sg_table);\n \trd_dev->sg_table_array = NULL;\n \trd_dev->sg_table_count = 0;\n }\n@@ -124,38 +127,15 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n  *\n  *\n  */\n-static int rd_build_device_space(struct rd_dev *rd_dev)\n+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n {\n-\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n+\tu32 i = 0, j, page_offset = 0, sg_per_table;\n \tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n \t\t\t\tsizeof(struct scatterlist));\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n-\n-\tif (rd_dev->rd_page_count <= 0) {\n-\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n-\t\t\trd_dev->rd_page_count);\n-\t\treturn -EINVAL;\n-\t}\n-\n-\t/* Don't need backing pages for NULLIO */\n-\tif (rd_dev->rd_flags & RDF_NULLIO)\n-\t\treturn 0;\n-\n-\ttotal_sg_needed = rd_dev->rd_page_count;\n-\n-\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n-\n-\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n-\tif (!sg_table) {\n-\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n-\t\t\t\" scatterlist tables\\n\");\n-\t\treturn -ENOMEM;\n-\t}\n-\n-\trd_dev->sg_table_array = sg_table;\n-\trd_dev->sg_table_count = sg_tables;\n+\tunsigned char *p;\n \n \twhile (total_sg_needed) {\n \t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n@@ -186,16 +166,59 @@ static int rd_build_device_space(struct rd_dev *rd_dev)\n \t\t\t}\n \t\t\tsg_assign_page(&sg[j], pg);\n \t\t\tsg[j].length = PAGE_SIZE;\n+\n+\t\t\tp = kmap(pg);\n+\t\t\tmemset(p, init_payload, PAGE_SIZE);\n+\t\t\tkunmap(pg);\n \t\t}\n \n \t\tpage_offset += sg_per_table;\n \t\ttotal_sg_needed -= sg_per_table;\n \t}\n \n+\treturn 0;\n+}\n+\n+static int rd_build_device_space(struct rd_dev *rd_dev)\n+{\n+\tstruct rd_dev_sg_table *sg_table;\n+\tu32 sg_tables, total_sg_needed;\n+\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n+\t\t\t\tsizeof(struct scatterlist));\n+\tint rc;\n+\n+\tif (rd_dev->rd_page_count <= 0) {\n+\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n+\t\t       rd_dev->rd_page_count);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\t/* Don't need backing pages for NULLIO */\n+\tif (rd_dev->rd_flags & RDF_NULLIO)\n+\t\treturn 0;\n+\n+\ttotal_sg_needed = rd_dev->rd_page_count;\n+\n+\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n+\n+\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n+\tif (!sg_table) {\n+\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n+\t\t       \" scatterlist tables\\n\");\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\trd_dev->sg_table_array = sg_table;\n+\trd_dev->sg_table_count = sg_tables;\n+\n+\trc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);\n+\tif (rc)\n+\t\treturn rc;\n+\n \tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"\n-\t\t\" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n-\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n-\t\trd_dev->sg_table_count);\n+\t\t \" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n+\t\t rd_dev->rd_dev_id, rd_dev->rd_page_count,\n+\t\t rd_dev->sg_table_count);\n \n \treturn 0;\n }",
  "project": "linux",
  "commit_id": "4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc",
  "target": 1,
  "func": "static int rd_build_device_space(struct rd_dev *rd_dev)\n {\n\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n \tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n \t\t\t\tsizeof(struct scatterlist));\n\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n\tif (rd_dev->rd_page_count <= 0) {\n\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n\t\t\trd_dev->rd_page_count);\n\t\treturn -EINVAL;\n\t}\n\t/* Don't need backing pages for NULLIO */\n\tif (rd_dev->rd_flags & RDF_NULLIO)\n\t\treturn 0;\n\ttotal_sg_needed = rd_dev->rd_page_count;\n\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n\tif (!sg_table) {\n\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n\t\t\t\" scatterlist tables\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trd_dev->sg_table_array = sg_table;\n\trd_dev->sg_table_count = sg_tables;\n \n \twhile (total_sg_needed) {\n \t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tsg_init_table(sg, sg_per_table);\n\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n \t\t\t}\n \t\t\tsg_assign_page(&sg[j], pg);\n \t\t\tsg[j].length = PAGE_SIZE;\n \t\t}\n \n \t\tpage_offset += sg_per_table;\n \t\ttotal_sg_needed -= sg_per_table;\n \t}\n \n \tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"\n\t\t\" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\trd_dev->sg_table_count);\n \n \treturn 0;\n }\n",
  "big_vul_idx": 179487,
  "idx": 1243,
  "hash": 231707640209773852599856573451469871968
}