{
  "id": 1183,
  "language": "c",
  "cwe": [
    "CWE-327"
  ],
  "commit_url": "https://github.com/liji15865292551/openssl/commit/f426625b6ae9a7831010750490a5f0ad689c5ba3",
  "commit_sha": "f426625b6ae9a7831010750490a5f0ad689c5ba3",
  "commit_msg": "Prevent over long nonces in ChaCha20-Poly1305\n\nChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for\nevery encryption operation. RFC 7539 specifies that the nonce value (IV)\nshould be 96 bits (12 bytes). OpenSSL allows a variable nonce length and\nfront pads the nonce with 0 bytes if it is less than 12 bytes. However it\nalso incorrectly allows a nonce to be set of up to 16 bytes. In this case\nonly the last 12 bytes are significant and any additional leading bytes are\nignored.\n\nIt is a requirement of using this cipher that nonce values are unique.\nMessages encrypted using a reused nonce value are susceptible to serious\nconfidentiality and integrity attacks. If an application changes the\ndefault nonce length to be longer than 12 bytes and then makes a change to\nthe leading bytes of the nonce expecting the new value to be a new unique\nnonce then such an application could inadvertently encrypt messages with a\nreused nonce.\n\nAdditionally the ignored bytes in a long nonce are not covered by the\nintegrity guarantee of this cipher. Any application that relies on the\nintegrity of these ignored leading bytes of a long nonce may be further\naffected.\n\nAny OpenSSL internal use of this cipher, including in SSL/TLS, is safe\nbecause no such use sets such a long nonce value. However user\napplications that use this cipher directly and set a non-default nonce\nlength to be longer than 12 bytes may be vulnerable.\n\nCVE-2019-1543\n\nFixes #8345\n\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8406)\n\n(cherry picked from commit 2a3d0ee9d59156c48973592331404471aca886d6)",
  "pr_url": null,
  "pr_info": null,
  "file_name": "crypto/evp/e_chacha20_poly1305.c",
  "func_name": "",
  "raw_func_from_json": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr;\n\n            memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            aad = actx->tls_aad;\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
  "diff_func": "@@ -30,6 +30,8 @@ typedef struct {\n \n #define data(ctx)   ((EVP_CHACHA_KEY *)(ctx)->cipher_data)\n \n+#define CHACHA20_POLY1305_MAX_IVLEN     12\n+\n static int chacha_init_key(EVP_CIPHER_CTX *ctx,\n                            const unsigned char user_key[CHACHA_KEY_SIZE],\n                            const unsigned char iv[CHACHA_CTR_SIZE], int enc)\n@@ -533,7 +535,7 @@ static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n         return 1;\n \n     case EVP_CTRL_AEAD_SET_IVLEN:\n-        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n+        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)\n             return 0;\n         actx->nonce_len = arg;\n         return 1;",
  "func": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr;\n\n            memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            aad = actx->tls_aad;\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
  "target": 1,
  "project": "openssl",
  "commit_id": "f426625b6ae9a7831010750490a5f0ad689c5ba3",
  "hash": 175133467495968151780225875830501530554,
  "size": 108,
  "message": "Prevent over long nonces in ChaCha20-Poly1305\n\nChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for\nevery encryption operation. RFC 7539 specifies that the nonce value (IV)\nshould be 96 bits (12 bytes). OpenSSL allows a variable nonce length and\nfront pads the nonce with 0 bytes if it is less than 12 bytes. However it\nalso incorrectly allows a nonce to be set of up to 16 bytes. In this case\nonly the last 12 bytes are significant and any additional leading bytes are\nignored.\n\nIt is a requirement of using this cipher that nonce values are unique.\nMessages encrypted using a reused nonce value are susceptible to serious\nconfidentiality and integrity attacks. If an application changes the\ndefault nonce length to be longer than 12 bytes and then makes a change to\nthe leading bytes of the nonce expecting the new value to be a new unique\nnonce then such an application could inadvertently encrypt messages with a\nreused nonce.\n\nAdditionally the ignored bytes in a long nonce are not covered by the\nintegrity guarantee of this cipher. Any application that relies on the\nintegrity of these ignored leading bytes of a long nonce may be further\naffected.\n\nAny OpenSSL internal use of this cipher, including in SSL/TLS, is safe\nbecause no such use sets such a long nonce value. However user\napplications that use this cipher directly and set a non-default nonce\nlength to be longer than 12 bytes may be vulnerable.\n\nCVE-2019-1543\n\nFixes #8345\n\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8406)\n\n(cherry picked from commit 2a3d0ee9d59156c48973592331404471aca886d6)",
  "dataset": "other",
  "idx": 216726
}