{
  "id": 621,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/viaembedded/arm-soc/commit/e237ec37ec154564f8690c5bd1795339955eeef9",
  "commit_sha": "e237ec37ec154564f8690c5bd1795339955eeef9",
  "commit_msg": "udf: Check component length before reading it\n\nCheck that length specified in a component of a symlink fits in the\ninput buffer we are reading. Also properly ignore component length for\ncomponent types that do not use it. Otherwise we read memory after end\nof buffer for corrupted udf image.\n\nReported-by: Carl Henrik Lunde <chlunde@ping.uio.no>\nCC: stable@vger.kernel.org\nSigned-off-by: Jan Kara <jack@suse.cz>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/udf/symlink.c",
  "func_name": "",
  "raw_func_from_json": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n \ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n \t\tcase 1:\n \t\t\t/*\n \t\t\t * Symlink points to some place which should be agreed\n  \t\t\t * upon between originator and receiver of the media. Ignore.\n \t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n \t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n \t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n \t\t\t\t\t\t    pc->lengthComponentIdent,\n \t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n \t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n \t}\n \tif (p > to + 1)\n \t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}\n",
  "diff_func": "@@ -42,14 +42,17 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n+\t\telen += sizeof(struct pathComponent);\n \t\tswitch (pc->componentType) {\n \t\tcase 1:\n \t\t\t/*\n \t\t\t * Symlink points to some place which should be agreed\n  \t\t\t * upon between originator and receiver of the media. Ignore.\n \t\t\t */\n-\t\t\tif (pc->lengthComponentIdent > 0)\n+\t\t\tif (pc->lengthComponentIdent > 0) {\n+\t\t\t\telen += pc->lengthComponentIdent;\n \t\t\t\tbreak;\n+\t\t\t}\n \t\t\t/* Fall through */\n \t\tcase 2:\n \t\t\tif (tolen == 0)\n@@ -74,6 +77,9 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n+\t\t\telen += pc->lengthComponentIdent;\n+\t\t\tif (elen > fromlen)\n+\t\t\t\treturn -EIO;\n \t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n \t\t\t\t\t\t    pc->lengthComponentIdent,\n \t\t\t\t\t\t    p, tolen);\n@@ -85,7 +91,6 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n \t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n-\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n \t}\n \tif (p > to + 1)\n \t\tp[-1] = '\\0';",
  "project": "linux",
  "commit_id": "e237ec37ec154564f8690c5bd1795339955eeef9",
  "target": 1,
  "func": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n \ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n \t\tcase 1:\n \t\t\t/*\n \t\t\t * Symlink points to some place which should be agreed\n  \t\t\t * upon between originator and receiver of the media. Ignore.\n \t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n \t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n \t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n \t\t\t\t\t\t    pc->lengthComponentIdent,\n \t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n \t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n \t}\n \tif (p > to + 1)\n \t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}\n",
  "big_vul_idx": 179933,
  "idx": 1593,
  "hash": 325864361331960325458577495980179554331
}