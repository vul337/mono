{
  "id": 410,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/ljalves/linux_media/commit/eb178619f930fa2ba2348de332a1ff1c66a31424",
  "commit_sha": "eb178619f930fa2ba2348de332a1ff1c66a31424",
  "commit_msg": "xfs: fix _xfs_buf_find oops on blocks beyond the filesystem end\n\nWhen _xfs_buf_find is passed an out of range address, it will fail\nto find a relevant struct xfs_perag and oops with a null\ndereference. This can happen when trying to walk a filesystem with a\nmetadata inode that has a partially corrupted extent map (i.e. the\nblock number returned is corrupt, but is otherwise intact) and we\ntry to read from the corrupted block address.\n\nIn this case, just fail the lookup. If it is readahead being issued,\nit will simply not be done, but if it is real read that fails we\nwill get an error being reported.  Ideally this case should result\nin an EFSCORRUPTED error being reported, but we cannot return an\nerror through xfs_buf_read() or xfs_buf_get() so this lookup failure\nmay result in ENOMEM or EIO errors being reported instead.\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Ben Myers <bpm@sgi.com>\nSigned-off-by: Ben Myers <bpm@sgi.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/xfs/xfs_buf.c",
  "func_name": "",
  "raw_func_from_json": "_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n \t/* get tree root */\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}\n",
  "diff_func": "@@ -487,6 +487,7 @@ _xfs_buf_find(\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n+\txfs_daddr_t\t\teofs;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n@@ -498,6 +499,23 @@ _xfs_buf_find(\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n+\t/*\n+\t * Corrupted block numbers can get through to here, unfortunately, so we\n+\t * have to check that the buffer falls within the filesystem bounds.\n+\t */\n+\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n+\tif (blkno >= eofs) {\n+\t\t/*\n+\t\t * XXX (dgc): we should really be returning EFSCORRUPTED here,\n+\t\t * but none of the higher level infrastructure supports\n+\t\t * returning a specific error on buffer lookup failures.\n+\t\t */\n+\t\txfs_alert(btp->bt_mount,\n+\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n+\t\t\t  __func__, blkno, eofs);\n+\t\treturn NULL;\n+\t}\n+\n \t/* get tree root */\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));",
  "project": "linux",
  "commit_id": "eb178619f930fa2ba2348de332a1ff1c66a31424",
  "target": 1,
  "func": "_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n \t/* get tree root */\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}\n",
  "big_vul_idx": 179285,
  "idx": 1067,
  "hash": 91424937264814556580236710533933601112
}