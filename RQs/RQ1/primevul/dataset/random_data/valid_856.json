{
  "id": 856,
  "language": "tif",
  "cwe": "",
  "commit_url": "https://github.com/MadnetM/Pillow-replica/commit/cbdce6c5d054fccaf4af34b47f212355c64ace7a",
  "commit_sha": "cbdce6c5d054fccaf4af34b47f212355c64ace7a",
  "commit_msg": "Fix for CVE-2021-25291\n\n* Invalid tile boundaries lead to OOB Read in TiffDecode.c, in TiffReadRGBATile\n* Check the tile validity before attempting to read.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "Tests/images/crash-63b1dffefc8c075ddc606c0a2f5fdc15ece78863.tif",
  "func_name": "",
  "raw_func_from_json": "ImagingLibTiffDecode(\n    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes) {\n    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n    char *filename = \"tempfile.tif\";\n    char *mode = \"r\";\n    TIFF *tiff;\n    uint16 photometric = 0;  // init to not PHOTOMETRIC_YCBCR\n    int isYCbCr = 0;\n\n    /* buffer is the encoded file, bytes is the length of the encoded file */\n    /*     it all ends up in state->buffer, which is a uint8* from Imaging.h */\n\n    TRACE((\"in decoder: bytes %d\\n\", bytes));\n    TRACE(\n        (\"State: count %d, state %d, x %d, y %d, ystep %d\\n\",\n         state->count,\n         state->state,\n         state->x,\n         state->y,\n         state->ystep));\n    TRACE(\n        (\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\",\n         state->xsize,\n         state->ysize,\n         state->xoff,\n         state->yoff));\n    TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n    TRACE(\n        (\"Buffer: %p: %c%c%c%c\\n\",\n         buffer,\n         (char)buffer[0],\n         (char)buffer[1],\n         (char)buffer[2],\n         (char)buffer[3]));\n    TRACE(\n        (\"State->Buffer: %c%c%c%c\\n\",\n         (char)state->buffer[0],\n         (char)state->buffer[1],\n         (char)state->buffer[2],\n         (char)state->buffer[3]));\n    TRACE(\n        (\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\",\n         im->mode,\n         im->type,\n         im->bands,\n         im->xsize,\n         im->ysize));\n    TRACE(\n        (\"Image: image8 %p, image32 %p, image %p, block %p \\n\",\n         im->image8,\n         im->image32,\n         im->image,\n         im->block));\n    TRACE((\"Image: pixelsize: %d, linesize %d \\n\", im->pixelsize, im->linesize));\n\n    dump_state(clientstate);\n    clientstate->size = bytes;\n    clientstate->eof = clientstate->size;\n    clientstate->loc = 0;\n    clientstate->data = (tdata_t)buffer;\n    clientstate->flrealloc = 0;\n    dump_state(clientstate);\n\n    TIFFSetWarningHandler(NULL);\n    TIFFSetWarningHandlerExt(NULL);\n\n    if (clientstate->fp) {\n        TRACE((\"Opening using fd: %d\\n\", clientstate->fp));\n        lseek(clientstate->fp, 0, SEEK_SET);  // Sometimes, I get it set to the end.\n        tiff = TIFFFdOpen(fd_to_tiff_fd(clientstate->fp), filename, mode);\n    } else {\n        TRACE((\"Opening from string\\n\"));\n        tiff = TIFFClientOpen(\n            filename,\n            mode,\n            (thandle_t)clientstate,\n            _tiffReadProc,\n            _tiffWriteProc,\n            _tiffSeekProc,\n            _tiffCloseProc,\n            _tiffSizeProc,\n            _tiffMapProc,\n            _tiffUnmapProc);\n    }\n\n    if (!tiff) {\n        TRACE((\"Error, didn't get the tiff\\n\"));\n        state->errcode = IMAGING_CODEC_BROKEN;\n        return -1;\n    }\n\n    if (clientstate->ifd) {\n        int rv;\n        uint32 ifdoffset = clientstate->ifd;\n        TRACE((\"reading tiff ifd %u\\n\", ifdoffset));\n        rv = TIFFSetSubDirectory(tiff, ifdoffset);\n        if (!rv) {\n            TRACE((\"error in TIFFSetSubDirectory\"));\n            goto decode_err;\n        }\n    }\n\n    TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n    isYCbCr = photometric == PHOTOMETRIC_YCBCR;\n\n    if (TIFFIsTiled(tiff)) {\n        INT32 x, y, tile_y;\n        UINT32 tile_width, tile_length, current_tile_length, current_line,\n            current_tile_width, row_byte_size;\n        UINT8 *new_data;\n\n        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);\n        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);\n\n        /* overflow check for row_byte_size calculation */\n        if ((UINT32)INT_MAX / state->bits < tile_width) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            goto decode_err;\n        }\n\n        if (isYCbCr) {\n            row_byte_size = tile_width * 4;\n            /* sanity check, we use this value in shuffle below */\n            if (im->pixelsize != 4) {\n                state->errcode = IMAGING_CODEC_BROKEN;\n                goto decode_err;\n            }\n        } else {\n            // We could use TIFFTileSize, but for YCbCr data it returns subsampled data\n            // size\n            row_byte_size = (tile_width * state->bits + 7) / 8;\n        }\n\n        /* overflow check for realloc */\n        if (INT_MAX / row_byte_size < tile_length) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            goto decode_err;\n        }\n\n        state->bytes = row_byte_size * tile_length;\n\n        if (TIFFTileSize(tiff) > state->bytes) {\n            // If the strip size as expected by LibTiff isn't what we're expecting,\n            // abort.\n            state->errcode = IMAGING_CODEC_MEMORY;\n            goto decode_err;\n        }\n\n        /* realloc to fit whole tile */\n        /* malloc check above */\n        new_data = realloc(state->buffer, state->bytes);\n        if (!new_data) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            goto decode_err;\n        }\n\n        state->buffer = new_data;\n\n        TRACE((\"TIFFTileSize: %d\\n\", state->bytes));\n\n        for (y = state->yoff; y < state->ysize; y += tile_length) {\n            for (x = state->xoff; x < state->xsize; x += tile_width) {\n                if (isYCbCr) {\n                    /* To avoid dealing with YCbCr subsampling, let libtiff handle it */\n                    if (!TIFFReadRGBATile(tiff, x, y, (UINT32 *)state->buffer)) {\n                        TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                        state->errcode = IMAGING_CODEC_BROKEN;\n                        goto decode_err;\n                    }\n                } else {\n                    if (TIFFReadTile(tiff, (tdata_t)state->buffer, x, y, 0, 0) == -1) {\n                        TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                        state->errcode = IMAGING_CODEC_BROKEN;\n                        goto decode_err;\n                    }\n                }\n\n                TRACE((\"Read tile at %dx%d; \\n\\n\", x, y));\n\n                current_tile_width = min((INT32)tile_width, state->xsize - x);\n                current_tile_length = min((INT32)tile_length, state->ysize - y);\n                // iterate over each line in the tile and stuff data into image\n                for (tile_y = 0; tile_y < current_tile_length; tile_y++) {\n                    TRACE(\n                        (\"Writing tile data at %dx%d using tile_width: %d; \\n\",\n                         tile_y + y,\n                         x,\n                         current_tile_width));\n\n                    // UINT8 * bbb = state->buffer + tile_y * row_byte_size;\n                    // TRACE((\"chars: %x%x%x%x\\n\", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1],\n                    // ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));\n                    /*\n                     * For some reason the TIFFReadRGBATile() function\n                     * chooses the lower left corner as the origin.\n                     * Vertically mirror by shuffling the scanlines\n                     * backwards\n                     */\n\n                    if (isYCbCr) {\n                        current_line = tile_length - tile_y - 1;\n                    } else {\n                        current_line = tile_y;\n                    }\n\n                    state->shuffle(\n                        (UINT8 *)im->image[tile_y + y] + x * im->pixelsize,\n                        state->buffer + current_line * row_byte_size,\n                        current_tile_width);\n                }\n            }\n        }\n    } else {\n        if (!isYCbCr) {\n            _decodeStrip(im, state, tiff);\n        } else {\n            _decodeStripYCbCr(im, state, tiff);\n        }\n    }\n\ndecode_err:\n    TIFFClose(tiff);\n    TRACE((\"Done Decoding, Returning \\n\"));\n    // Returning -1 here to force ImageFile.load to break, rather than\n    // even think about looping back around.\n    return -1;\n}",
  "diff_func": "",
  "func": "ImagingLibTiffDecode(\n    Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes) {\n    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n    char *filename = \"tempfile.tif\";\n    char *mode = \"r\";\n    TIFF *tiff;\n    uint16 photometric = 0;  // init to not PHOTOMETRIC_YCBCR\n    int isYCbCr = 0;\n\n    /* buffer is the encoded file, bytes is the length of the encoded file */\n    /*     it all ends up in state->buffer, which is a uint8* from Imaging.h */\n\n    TRACE((\"in decoder: bytes %d\\n\", bytes));\n    TRACE(\n        (\"State: count %d, state %d, x %d, y %d, ystep %d\\n\",\n         state->count,\n         state->state,\n         state->x,\n         state->y,\n         state->ystep));\n    TRACE(\n        (\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\",\n         state->xsize,\n         state->ysize,\n         state->xoff,\n         state->yoff));\n    TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n    TRACE(\n        (\"Buffer: %p: %c%c%c%c\\n\",\n         buffer,\n         (char)buffer[0],\n         (char)buffer[1],\n         (char)buffer[2],\n         (char)buffer[3]));\n    TRACE(\n        (\"State->Buffer: %c%c%c%c\\n\",\n         (char)state->buffer[0],\n         (char)state->buffer[1],\n         (char)state->buffer[2],\n         (char)state->buffer[3]));\n    TRACE(\n        (\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\",\n         im->mode,\n         im->type,\n         im->bands,\n         im->xsize,\n         im->ysize));\n    TRACE(\n        (\"Image: image8 %p, image32 %p, image %p, block %p \\n\",\n         im->image8,\n         im->image32,\n         im->image,\n         im->block));\n    TRACE((\"Image: pixelsize: %d, linesize %d \\n\", im->pixelsize, im->linesize));\n\n    dump_state(clientstate);\n    clientstate->size = bytes;\n    clientstate->eof = clientstate->size;\n    clientstate->loc = 0;\n    clientstate->data = (tdata_t)buffer;\n    clientstate->flrealloc = 0;\n    dump_state(clientstate);\n\n    TIFFSetWarningHandler(NULL);\n    TIFFSetWarningHandlerExt(NULL);\n\n    if (clientstate->fp) {\n        TRACE((\"Opening using fd: %d\\n\", clientstate->fp));\n        lseek(clientstate->fp, 0, SEEK_SET);  // Sometimes, I get it set to the end.\n        tiff = TIFFFdOpen(fd_to_tiff_fd(clientstate->fp), filename, mode);\n    } else {\n        TRACE((\"Opening from string\\n\"));\n        tiff = TIFFClientOpen(\n            filename,\n            mode,\n            (thandle_t)clientstate,\n            _tiffReadProc,\n            _tiffWriteProc,\n            _tiffSeekProc,\n            _tiffCloseProc,\n            _tiffSizeProc,\n            _tiffMapProc,\n            _tiffUnmapProc);\n    }\n\n    if (!tiff) {\n        TRACE((\"Error, didn't get the tiff\\n\"));\n        state->errcode = IMAGING_CODEC_BROKEN;\n        return -1;\n    }\n\n    if (clientstate->ifd) {\n        int rv;\n        uint32 ifdoffset = clientstate->ifd;\n        TRACE((\"reading tiff ifd %u\\n\", ifdoffset));\n        rv = TIFFSetSubDirectory(tiff, ifdoffset);\n        if (!rv) {\n            TRACE((\"error in TIFFSetSubDirectory\"));\n            goto decode_err;\n        }\n    }\n\n    TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n    isYCbCr = photometric == PHOTOMETRIC_YCBCR;\n\n    if (TIFFIsTiled(tiff)) {\n        INT32 x, y, tile_y;\n        UINT32 tile_width, tile_length, current_tile_length, current_line,\n            current_tile_width, row_byte_size;\n        UINT8 *new_data;\n\n        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);\n        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);\n\n        /* overflow check for row_byte_size calculation */\n        if ((UINT32)INT_MAX / state->bits < tile_width) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            goto decode_err;\n        }\n\n        if (isYCbCr) {\n            row_byte_size = tile_width * 4;\n            /* sanity check, we use this value in shuffle below */\n            if (im->pixelsize != 4) {\n                state->errcode = IMAGING_CODEC_BROKEN;\n                goto decode_err;\n            }\n        } else {\n            // We could use TIFFTileSize, but for YCbCr data it returns subsampled data\n            // size\n            row_byte_size = (tile_width * state->bits + 7) / 8;\n        }\n\n        /* overflow check for realloc */\n        if (INT_MAX / row_byte_size < tile_length) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            goto decode_err;\n        }\n\n        state->bytes = row_byte_size * tile_length;\n\n        if (TIFFTileSize(tiff) > state->bytes) {\n            // If the strip size as expected by LibTiff isn't what we're expecting,\n            // abort.\n            state->errcode = IMAGING_CODEC_MEMORY;\n            goto decode_err;\n        }\n\n        /* realloc to fit whole tile */\n        /* malloc check above */\n        new_data = realloc(state->buffer, state->bytes);\n        if (!new_data) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            goto decode_err;\n        }\n\n        state->buffer = new_data;\n\n        TRACE((\"TIFFTileSize: %d\\n\", state->bytes));\n\n        for (y = state->yoff; y < state->ysize; y += tile_length) {\n            for (x = state->xoff; x < state->xsize; x += tile_width) {\n                if (isYCbCr) {\n                    /* To avoid dealing with YCbCr subsampling, let libtiff handle it */\n                    if (!TIFFReadRGBATile(tiff, x, y, (UINT32 *)state->buffer)) {\n                        TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                        state->errcode = IMAGING_CODEC_BROKEN;\n                        goto decode_err;\n                    }\n                } else {\n                    if (TIFFReadTile(tiff, (tdata_t)state->buffer, x, y, 0, 0) == -1) {\n                        TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                        state->errcode = IMAGING_CODEC_BROKEN;\n                        goto decode_err;\n                    }\n                }\n\n                TRACE((\"Read tile at %dx%d; \\n\\n\", x, y));\n\n                current_tile_width = min((INT32)tile_width, state->xsize - x);\n                current_tile_length = min((INT32)tile_length, state->ysize - y);\n                // iterate over each line in the tile and stuff data into image\n                for (tile_y = 0; tile_y < current_tile_length; tile_y++) {\n                    TRACE(\n                        (\"Writing tile data at %dx%d using tile_width: %d; \\n\",\n                         tile_y + y,\n                         x,\n                         current_tile_width));\n\n                    // UINT8 * bbb = state->buffer + tile_y * row_byte_size;\n                    // TRACE((\"chars: %x%x%x%x\\n\", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1],\n                    // ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));\n                    /*\n                     * For some reason the TIFFReadRGBATile() function\n                     * chooses the lower left corner as the origin.\n                     * Vertically mirror by shuffling the scanlines\n                     * backwards\n                     */\n\n                    if (isYCbCr) {\n                        current_line = tile_length - tile_y - 1;\n                    } else {\n                        current_line = tile_y;\n                    }\n\n                    state->shuffle(\n                        (UINT8 *)im->image[tile_y + y] + x * im->pixelsize,\n                        state->buffer + current_line * row_byte_size,\n                        current_tile_width);\n                }\n            }\n        }\n    } else {\n        if (!isYCbCr) {\n            _decodeStrip(im, state, tiff);\n        } else {\n            _decodeStripYCbCr(im, state, tiff);\n        }\n    }\n\ndecode_err:\n    TIFFClose(tiff);\n    TRACE((\"Done Decoding, Returning \\n\"));\n    // Returning -1 here to force ImageFile.load to break, rather than\n    // even think about looping back around.\n    return -1;\n}",
  "project": "Pillow",
  "hash": 337949595576035235304375695306533039366,
  "size": 227,
  "commit_id": "cbdce6c5d054fccaf4af34b47f212355c64ace7a",
  "message": "Fix for CVE-2021-25291\n\n* Invalid tile boundaries lead to OOB Read in TiffDecode.c, in TiffReadRGBATile\n* Check the tile validity before attempting to read.",
  "target": 1,
  "dataset": "other",
  "idx": 208556
}