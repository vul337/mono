{
  "id": 602,
  "language": "c",
  "cwe": "CWE-264",
  "commit_url": "https://github.com/MrE-Fog/krb521/commit/e3b5a5e5267818c97750b266df50b6a3d4649604",
  "commit_sha": "e3b5a5e5267818c97750b266df50b6a3d4649604",
  "commit_msg": "Prevent requires_preauth bypass [CVE-2015-2694]\n\nIn the OTP kdcpreauth module, don't set the TKT_FLG_PRE_AUTH bit until\nthe request is successfully verified.  In the PKINIT kdcpreauth\nmodule, don't respond with code 0 on empty input or an unconfigured\nrealm.  Together these bugs could cause the KDC preauth framework to\nerroneously treat a request as pre-authenticated.\n\nCVE-2015-2694:\n\nIn MIT krb5 1.12 and later, when the KDC is configured with PKINIT\nsupport, an unauthenticated remote attacker can bypass the\nrequires_preauth flag on a client principal and obtain a ciphertext\nencrypted in the principal's long-term key.  This ciphertext could be\nused to conduct an off-line dictionary attack against the user's\npassword.\n\n    CVSSv2 Vector: AV:N/AC:M/Au:N/C:P/I:P/A:N/E:POC/RL:OF/RC:C\n\nticket: 8160 (new)\ntarget_version: 1.13.2\ntags: pullup\nsubject: requires_preauth bypass in PKINIT-enabled KDC [CVE-2015-2694]",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/plugins/preauth/otp/main.c",
  "func_name": "",
  "raw_func_from_json": "pkinit_server_verify_padata(krb5_context context,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_enc_tkt_part * enc_tkt_reply,\n                            krb5_pa_data * data,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_verify_respond_fn respond,\n                            void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    krb5_auth_pack *auth_pack = NULL;\n    krb5_auth_pack_draft9 *auth_pack9 = NULL;\n    pkinit_kdc_context plgctx = NULL;\n    pkinit_kdc_req_context reqctx = NULL;\n    krb5_checksum cksum = {0, 0, 0, NULL};\n    krb5_data *der_req = NULL;\n    int valid_eku = 0, valid_san = 0;\n    krb5_data k5data;\n    int is_signed = 1;\n    krb5_pa_data **e_data = NULL;\n    krb5_kdcpreauth_modreq modreq = NULL;\n \n     pkiDebug(\"pkinit_verify_padata: entered!\\n\");\n     if (data == NULL || data->length <= 0 || data->contents == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n         return;\n     }\n \n\n    if (moddata == NULL) {\n        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n        return;\n    }\n \n     plgctx = pkinit_find_realm_context(context, moddata, request->server);\n     if (plgctx == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n         return;\n     }\n \n#ifdef DEBUG_ASN1\n    print_buffer_bin(data->contents, data->length, \"/tmp/kdc_as_req\");\n#endif\n    /* create a per-request context */\n    retval = pkinit_init_kdc_req_context(context, &reqctx);\n    if (retval)\n        goto cleanup;\n    reqctx->pa_type = data->pa_type;\n\n    PADATA_TO_KRB5DATA(data, &k5data);\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp->signedAuthPack.data,\n                         reqp->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data\");\n#endif\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,\n                                       plgctx->opts->require_crl_checking,\n                                       (unsigned char *)\n                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,\n                                       (unsigned char **)&authp_data.data,\n                                       &authp_data.length,\n                                       (unsigned char **)&krb5_authz.data,\n                                       &krb5_authz.length, &is_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ_OLD\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req_draft9 failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp9->signedAuthPack.data,\n                         reqp9->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data_draft9\");\n#endif\n\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,\n                                       plgctx->opts->require_crl_checking,\n                                       (unsigned char *)\n                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,\n                                       (unsigned char **)&authp_data.data,\n                                       &authp_data.length,\n                                       (unsigned char **)&krb5_authz.data,\n                                       &krb5_authz.length, NULL);\n        break;\n    default:\n        pkiDebug(\"unrecognized pa_type = %d\\n\", data->pa_type);\n        retval = EINVAL;\n        goto cleanup;\n    }\n    if (retval) {\n        pkiDebug(\"pkcs7_signeddata_verify failed\\n\");\n        goto cleanup;\n    }\n    if (is_signed) {\n\n        retval = verify_client_san(context, plgctx, reqctx, request->client,\n                                   &valid_san);\n        if (retval)\n            goto cleanup;\n        if (!valid_san) {\n            pkiDebug(\"%s: did not find an acceptable SAN in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n            goto cleanup;\n        }\n        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);\n        if (retval)\n            goto cleanup;\n\n        if (!valid_eku) {\n            pkiDebug(\"%s: did not find an acceptable EKU in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n            goto cleanup;\n        }\n    } else { /* !is_signed */\n        if (!krb5_principal_compare(context, request->client,\n                                    krb5_anonymous_principal())) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Pkinit request not signed, but client \"\n                                     \"not anonymous.\"));\n            goto cleanup;\n        }\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin(authp_data.data, authp_data.length, \"/tmp/kdc_auth_pack\");\n#endif\n\n    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack\\n\");\n            goto cleanup;\n        }\n\n        retval = krb5_check_clockskew(context,\n                                      auth_pack->pkAuthenticator.ctime);\n        if (retval)\n            goto cleanup;\n\n        /* check dh parameters */\n        if (auth_pack->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        } else if (!is_signed) {\n            /*Anonymous pkinit requires DH*/\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Anonymous pkinit without DH public \"\n                                     \"value not supported.\"));\n            goto cleanup;\n        }\n        der_req = cb->request_body(context, rock);\n        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,\n                                      0, der_req, &cksum);\n        if (retval) {\n            pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n            goto cleanup;\n        }\n        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||\n            k5_bcmp(cksum.contents,\n                    auth_pack->pkAuthenticator.paChecksum.contents,\n                    cksum.length) != 0) {\n            pkiDebug(\"failed to match the checksum\\n\");\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size (%d)\\n\",\n                     req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"received checksum type=%d size=%d \",\n                     auth_pack->pkAuthenticator.paChecksum.checksum_type,\n                     auth_pack->pkAuthenticator.paChecksum.length);\n            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,\n                         auth_pack->pkAuthenticator.paChecksum.length);\n            pkiDebug(\"expected checksum type=%d size=%d \",\n                     cksum.checksum_type, cksum.length);\n            print_buffer(cksum.contents, cksum.length);\n#endif\n\n            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n            goto cleanup;\n        }\n\n        /* check if kdcPkId present and match KDC's subjectIdentifier */\n        if (reqp->kdcPkId.data != NULL) {\n            int valid_kdcPkId = 0;\n            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx,\n                                           (unsigned char *)reqp->kdcPkId.data,\n                                           reqp->kdcPkId.length, &valid_kdcPkId);\n            if (retval)\n                goto cleanup;\n            if (!valid_kdcPkId)\n                pkiDebug(\"kdcPkId in AS_REQ does not match KDC's cert\"\n                         \"RFC says to ignore and proceed\\n\");\n\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack = auth_pack;\n        auth_pack = NULL;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack_draft9\\n\");\n            goto cleanup;\n        }\n        if (auth_pack9->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack9->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack9 = auth_pack9;\n        auth_pack9 = NULL;\n        break;\n    }\n\n    /* remember to set the PREAUTH flag in the reply */\n    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    modreq = (krb5_kdcpreauth_modreq)reqctx;\n    reqctx = NULL;\n\ncleanup:\n    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {\n        pkiDebug(\"pkinit_verify_padata failed: creating e-data\\n\");\n        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,\n                                plgctx->idctx, plgctx->opts, retval, &e_data))\n            pkiDebug(\"pkinit_create_edata failed\\n\");\n    }\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free(cksum.contents);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n    }\n    free(authp_data.data);\n    free(krb5_authz.data);\n    if (reqctx != NULL)\n        pkinit_fini_kdc_req_context(context, reqctx);\n    free_krb5_auth_pack(&auth_pack);\n    free_krb5_auth_pack_draft9(context, &auth_pack9);\n\n    (*respond)(arg, retval, modreq, e_data, NULL);\n}\n",
  "diff_func": "@@ -42,6 +42,7 @@ static krb5_preauthtype otp_pa_type_list[] =\n struct request_state {\n     krb5_kdcpreauth_verify_respond_fn respond;\n     void *arg;\n+    krb5_enc_tkt_part *enc_tkt_reply;\n };\n \n static krb5_error_code\n@@ -159,6 +160,9 @@ on_response(void *data, krb5_error_code retval, otp_response response)\n     if (retval == 0 && response != otp_response_success)\n         retval = KRB5_PREAUTH_FAILED;\n \n+    if (retval == 0)\n+        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n+\n     rs.respond(rs.arg, retval, NULL, NULL, NULL);\n }\n \n@@ -263,8 +267,6 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n     krb5_data d, plaintext;\n     char *config;\n \n-    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n-\n     /* Get the FAST armor key. */\n     armor_key = cb->fast_armor(context, rock);\n     if (armor_key == NULL) {\n@@ -298,12 +300,14 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n         goto error;\n     }\n \n-    /* Create the request state. */\n+    /* Create the request state.  Save the response callback, and the\n+     * enc_tkt_reply pointer so we can set the TKT_FLG_PRE_AUTH flag later. */\n     rs = k5alloc(sizeof(struct request_state), &retval);\n     if (rs == NULL)\n         goto error;\n     rs->arg = arg;\n     rs->respond = respond;\n+    rs->enc_tkt_reply = enc_tkt_reply;\n \n     /* Get the principal's OTP configuration string. */\n     retval = cb->get_string(context, rock, \"otp\", &config);",
  "project": "krb5",
  "commit_id": "e3b5a5e5267818c97750b266df50b6a3d4649604",
  "target": 1,
  "func": "pkinit_server_verify_padata(krb5_context context,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_enc_tkt_part * enc_tkt_reply,\n                            krb5_pa_data * data,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_verify_respond_fn respond,\n                            void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    krb5_auth_pack *auth_pack = NULL;\n    krb5_auth_pack_draft9 *auth_pack9 = NULL;\n    pkinit_kdc_context plgctx = NULL;\n    pkinit_kdc_req_context reqctx = NULL;\n    krb5_checksum cksum = {0, 0, 0, NULL};\n    krb5_data *der_req = NULL;\n    int valid_eku = 0, valid_san = 0;\n    krb5_data k5data;\n    int is_signed = 1;\n    krb5_pa_data **e_data = NULL;\n    krb5_kdcpreauth_modreq modreq = NULL;\n \n     pkiDebug(\"pkinit_verify_padata: entered!\\n\");\n     if (data == NULL || data->length <= 0 || data->contents == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n         return;\n     }\n \n\n    if (moddata == NULL) {\n        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n        return;\n    }\n \n     plgctx = pkinit_find_realm_context(context, moddata, request->server);\n     if (plgctx == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n         return;\n     }\n \n#ifdef DEBUG_ASN1\n    print_buffer_bin(data->contents, data->length, \"/tmp/kdc_as_req\");\n#endif\n    /* create a per-request context */\n    retval = pkinit_init_kdc_req_context(context, &reqctx);\n    if (retval)\n        goto cleanup;\n    reqctx->pa_type = data->pa_type;\n\n    PADATA_TO_KRB5DATA(data, &k5data);\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp->signedAuthPack.data,\n                         reqp->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data\");\n#endif\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,\n                                       plgctx->opts->require_crl_checking,\n                                       (unsigned char *)\n                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,\n                                       (unsigned char **)&authp_data.data,\n                                       &authp_data.length,\n                                       (unsigned char **)&krb5_authz.data,\n                                       &krb5_authz.length, &is_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ_OLD\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req_draft9 failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp9->signedAuthPack.data,\n                         reqp9->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data_draft9\");\n#endif\n\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,\n                                       plgctx->opts->require_crl_checking,\n                                       (unsigned char *)\n                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,\n                                       (unsigned char **)&authp_data.data,\n                                       &authp_data.length,\n                                       (unsigned char **)&krb5_authz.data,\n                                       &krb5_authz.length, NULL);\n        break;\n    default:\n        pkiDebug(\"unrecognized pa_type = %d\\n\", data->pa_type);\n        retval = EINVAL;\n        goto cleanup;\n    }\n    if (retval) {\n        pkiDebug(\"pkcs7_signeddata_verify failed\\n\");\n        goto cleanup;\n    }\n    if (is_signed) {\n\n        retval = verify_client_san(context, plgctx, reqctx, request->client,\n                                   &valid_san);\n        if (retval)\n            goto cleanup;\n        if (!valid_san) {\n            pkiDebug(\"%s: did not find an acceptable SAN in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n            goto cleanup;\n        }\n        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);\n        if (retval)\n            goto cleanup;\n\n        if (!valid_eku) {\n            pkiDebug(\"%s: did not find an acceptable EKU in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n            goto cleanup;\n        }\n    } else { /* !is_signed */\n        if (!krb5_principal_compare(context, request->client,\n                                    krb5_anonymous_principal())) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Pkinit request not signed, but client \"\n                                     \"not anonymous.\"));\n            goto cleanup;\n        }\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin(authp_data.data, authp_data.length, \"/tmp/kdc_auth_pack\");\n#endif\n\n    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack\\n\");\n            goto cleanup;\n        }\n\n        retval = krb5_check_clockskew(context,\n                                      auth_pack->pkAuthenticator.ctime);\n        if (retval)\n            goto cleanup;\n\n        /* check dh parameters */\n        if (auth_pack->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        } else if (!is_signed) {\n            /*Anonymous pkinit requires DH*/\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Anonymous pkinit without DH public \"\n                                     \"value not supported.\"));\n            goto cleanup;\n        }\n        der_req = cb->request_body(context, rock);\n        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,\n                                      0, der_req, &cksum);\n        if (retval) {\n            pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n            goto cleanup;\n        }\n        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||\n            k5_bcmp(cksum.contents,\n                    auth_pack->pkAuthenticator.paChecksum.contents,\n                    cksum.length) != 0) {\n            pkiDebug(\"failed to match the checksum\\n\");\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size (%d)\\n\",\n                     req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"received checksum type=%d size=%d \",\n                     auth_pack->pkAuthenticator.paChecksum.checksum_type,\n                     auth_pack->pkAuthenticator.paChecksum.length);\n            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,\n                         auth_pack->pkAuthenticator.paChecksum.length);\n            pkiDebug(\"expected checksum type=%d size=%d \",\n                     cksum.checksum_type, cksum.length);\n            print_buffer(cksum.contents, cksum.length);\n#endif\n\n            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n            goto cleanup;\n        }\n\n        /* check if kdcPkId present and match KDC's subjectIdentifier */\n        if (reqp->kdcPkId.data != NULL) {\n            int valid_kdcPkId = 0;\n            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx,\n                                           (unsigned char *)reqp->kdcPkId.data,\n                                           reqp->kdcPkId.length, &valid_kdcPkId);\n            if (retval)\n                goto cleanup;\n            if (!valid_kdcPkId)\n                pkiDebug(\"kdcPkId in AS_REQ does not match KDC's cert\"\n                         \"RFC says to ignore and proceed\\n\");\n\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack = auth_pack;\n        auth_pack = NULL;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack_draft9\\n\");\n            goto cleanup;\n        }\n        if (auth_pack9->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack9->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack9 = auth_pack9;\n        auth_pack9 = NULL;\n        break;\n    }\n\n    /* remember to set the PREAUTH flag in the reply */\n    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    modreq = (krb5_kdcpreauth_modreq)reqctx;\n    reqctx = NULL;\n\ncleanup:\n    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {\n        pkiDebug(\"pkinit_verify_padata failed: creating e-data\\n\");\n        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,\n                                plgctx->idctx, plgctx->opts, retval, &e_data))\n            pkiDebug(\"pkinit_create_edata failed\\n\");\n    }\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free(cksum.contents);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n    }\n    free(authp_data.data);\n    free(krb5_authz.data);\n    if (reqctx != NULL)\n        pkinit_fini_kdc_req_context(context, reqctx);\n    free_krb5_auth_pack(&auth_pack);\n    free_krb5_auth_pack_draft9(context, &auth_pack9);\n\n    (*respond)(arg, retval, modreq, e_data, NULL);\n}\n",
  "big_vul_idx": 179850,
  "idx": 1523,
  "hash": 7409460042177961454675481229883863278
}