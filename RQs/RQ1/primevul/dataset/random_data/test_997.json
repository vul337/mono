{
  "id": 997,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/vilcon/vim-local-copy/commit/80525751c5ce9ed82c41d83faf9ef38667bf61b1",
  "commit_sha": "80525751c5ce9ed82c41d83faf9ef38667bf61b1",
  "commit_msg": "patch 9.0.0259: crash with mouse click when not initialized\n\nProblem:    Crash with mouse click when not initialized.\nSolution:   Check TabPageIdxs[] is not NULL.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/mouse.c",
  "func_name": "else",
  "raw_func_from_json": "do_mouse(\n    oparg_T\t*oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n    int\t\tdir,\t\t// Direction to 'put' if necessary\n    long\tcount,\n    int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static int\tdo_always = FALSE;\t// ignore 'mouse' setting next time\n    static int\tgot_click = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's a drag or release event\n    int\t\tis_drag = FALSE;  // If TRUE it's a drag event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status line\n    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n    int\t\tin_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n    save_cursor = curwin->w_cursor;\n#endif\n\n    // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.\n    // - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.\n    // - For command line and insert mode 'mouse' is checked before calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is the same mouse event then use that\n\t    // one. Speeds up dragging the status line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\t    // below need to come before the next character, do not do this\n\t    // when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() != NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\tvungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n#endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped dragging the status or separator line.  The pointer is\n    // most likely still on the status or separator line.\n    if (!is_drag && drag_status_line)\n    {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n    }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n    else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag and release events, as well as\n    // multiple clicks and the middle mouse button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\".\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button that is held down, ignore\n    // drag/release events.\n    if (!is_click && which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't know what the user wanted\n\t    // to do. Go back to normal mode: Clear the operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t    {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual was active, yank the highlighted text and put it\n\t    // before the mouse pointer position.\n\t    // In Select mode replace the highlighted text with the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"+p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert mode doesn't move the mouse, just insert the\n\t// contents of a register.  '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t    if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n    // Check for clicking in the tab page line.\n    if (mouse_row == 0 && firstwin->w_winrow > 0)\n    {\n\tif (is_drag)\n\t{\n\t    if (in_tab_line)\n\t    {\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\ttabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\t\t\t\t\t\t\t\t? c1 - 1 : c1);\n\t    }\n\t    return FALSE;\n\t}\n\n\t// click in a tab selects that tab page\n\tif (is_click\n# ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n# endif\n\t\t&& mouse_col < Columns)\n\t{\n\t    in_tab_line = TRUE;\n\t    c1 = TabPageIdxs[mouse_col];\n\t    if (c1 >= 0)\n\t    {\n\t\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t{\n\t\t    // double click opens new page\n\t\t    end_visual_mode_keep_button();\n\t\t    tabpage_new();\n\t\t    tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Go to specified tab page, or next one if not clicking\n\t\t    // on a label.\n\t\t    goto_tabpage(c1);\n\n\t\t    // It's like clicking on the status line of a window.\n\t\t    if (curwin != old_curwin)\n\t\t\tend_visual_mode_keep_button();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ttabpage_T\t*tp;\n\n\t\t// Close the current or specified tab page.\n\t\tif (c1 == -999)\n\t\t    tp = curtab;\n\t\telse\n\t\t    tp = find_tabpage(-c1);\n\t\tif (tp == curtab)\n\t\t{\n\t\t    if (first_tabpage->tp_next != NULL)\n\t\t\ttabpage_close(FALSE);\n\t\t}\n\t\telse if (tp != NULL)\n\t\t    tabpage_close_other(tp, FALSE);\n\t    }\n\t}\n\treturn TRUE;\n    }\n    else if (is_drag && in_tab_line)\n    {\n\tc1 = TabPageIdxs[mouse_col];\n\ttabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\treturn FALSE;\n    }\n\n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n    // right button up   -> pop-up menu\n    // shift-left button -> right button\n    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore right button release events, only shows the popup\n\t\t    // menu on the button down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore right button down and drag mouse events.  Windows\n\t\t    // only shows the popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n# endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n# endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore right button release events, only shows the popup\n\t\t// menu on the button down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem, \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t    // selection or the current window (might have false\n\t\t    // negative here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t{\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol, &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags, NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t// ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) != 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t// cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending, ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive), which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags & IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping to another window, clear a pending operator.  That's a bit\n    // friendlier than beeping and not jumping to that window.\n    if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum, 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n    }\n#endif\n\n    // Set global flag that we are extending the Visual area with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window, scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\tscroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\t// right click in visual mode\n    {\n       // When ALT is pressed make Visual mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t// that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col = leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the click is before the start of visual, change the start.\n\t    // If the click is after the end of visual, change the end.  If\n\t    // the click is inside the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t    if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col - curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\telse\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t// closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t// closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t    VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT) && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click: Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname = '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\tif (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t}\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where the paste started, so in edit() Insstart can be set\n\t// to this position\n\tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n    // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse click searches for the next occurrence of the word under\n    // the mouse pointer\n    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT) || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\tif (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual = curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\tVIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode = Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end may still be the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t    if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white space) is\n\t\t// not a word character, try finding a match and select a (),\n\t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t    {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor, orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t    find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    // If Visual mode changed show it later.\n    if ((!VIsual_active && old_active && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\n    return moved;\n}",
  "diff_func": "@@ -471,74 +471,77 @@ do_mouse(\n \n     start_visual.lnum = 0;\n \n-    // Check for clicking in the tab page line.\n-    if (mouse_row == 0 && firstwin->w_winrow > 0)\n+    if (TabPageIdxs != NULL)  // only when initialized\n     {\n-\tif (is_drag)\n+\t// Check for clicking in the tab page line.\n+\tif (mouse_row == 0 && firstwin->w_winrow > 0)\n \t{\n-\t    if (in_tab_line)\n+\t    if (is_drag)\n \t    {\n-\t\tc1 = TabPageIdxs[mouse_col];\n-\t\ttabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n-\t\t\t\t\t\t\t\t? c1 - 1 : c1);\n+\t\tif (in_tab_line)\n+\t\t{\n+\t\t    c1 = TabPageIdxs[mouse_col];\n+\t\t    tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n+\t\t\t\t\t\t\t\t    ? c1 - 1 : c1);\n+\t\t}\n+\t\treturn FALSE;\n \t    }\n-\t    return FALSE;\n-\t}\n \n-\t// click in a tab selects that tab page\n-\tif (is_click\n+\t    // click in a tab selects that tab page\n+\t    if (is_click\n # ifdef FEAT_CMDWIN\n-\t\t&& cmdwin_type == 0\n+\t\t    && cmdwin_type == 0\n # endif\n-\t\t&& mouse_col < Columns)\n-\t{\n-\t    in_tab_line = TRUE;\n-\t    c1 = TabPageIdxs[mouse_col];\n-\t    if (c1 >= 0)\n+\t\t    && mouse_col < Columns)\n \t    {\n-\t\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n-\t\t{\n-\t\t    // double click opens new page\n-\t\t    end_visual_mode_keep_button();\n-\t\t    tabpage_new();\n-\t\t    tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n-\t\t}\n-\t\telse\n+\t\tin_tab_line = TRUE;\n+\t\tc1 = TabPageIdxs[mouse_col];\n+\t\tif (c1 >= 0)\n \t\t{\n-\t\t    // Go to specified tab page, or next one if not clicking\n-\t\t    // on a label.\n-\t\t    goto_tabpage(c1);\n-\n-\t\t    // It's like clicking on the status line of a window.\n-\t\t    if (curwin != old_curwin)\n+\t\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n+\t\t    {\n+\t\t\t// double click opens new page\n \t\t\tend_visual_mode_keep_button();\n-\t\t}\n-\t    }\n-\t    else\n-\t    {\n-\t\ttabpage_T\t*tp;\n+\t\t\ttabpage_new();\n+\t\t\ttabpage_move(c1 == 0 ? 9999 : c1 - 1);\n+\t\t    }\n+\t\t    else\n+\t\t    {\n+\t\t\t// Go to specified tab page, or next one if not clicking\n+\t\t\t// on a label.\n+\t\t\tgoto_tabpage(c1);\n \n-\t\t// Close the current or specified tab page.\n-\t\tif (c1 == -999)\n-\t\t    tp = curtab;\n+\t\t\t// It's like clicking on the status line of a window.\n+\t\t\tif (curwin != old_curwin)\n+\t\t\t    end_visual_mode_keep_button();\n+\t\t    }\n+\t\t}\n \t\telse\n-\t\t    tp = find_tabpage(-c1);\n-\t\tif (tp == curtab)\n \t\t{\n-\t\t    if (first_tabpage->tp_next != NULL)\n-\t\t\ttabpage_close(FALSE);\n+\t\t    tabpage_T\t*tp;\n+\n+\t\t    // Close the current or specified tab page.\n+\t\t    if (c1 == -999)\n+\t\t\ttp = curtab;\n+\t\t    else\n+\t\t\ttp = find_tabpage(-c1);\n+\t\t    if (tp == curtab)\n+\t\t    {\n+\t\t\tif (first_tabpage->tp_next != NULL)\n+\t\t\t    tabpage_close(FALSE);\n+\t\t    }\n+\t\t    else if (tp != NULL)\n+\t\t\ttabpage_close_other(tp, FALSE);\n \t\t}\n-\t\telse if (tp != NULL)\n-\t\t    tabpage_close_other(tp, FALSE);\n \t    }\n+\t    return TRUE;\n+\t}\n+\telse if (is_drag && in_tab_line)\n+\t{\n+\t    c1 = TabPageIdxs[mouse_col];\n+\t    tabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n+\t    return FALSE;\n \t}\n-\treturn TRUE;\n-    }\n-    else if (is_drag && in_tab_line)\n-    {\n-\tc1 = TabPageIdxs[mouse_col];\n-\ttabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n-\treturn FALSE;\n     }\n \n     // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:",
  "func": "do_mouse(\n    oparg_T\t*oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n    int\t\tdir,\t\t// Direction to 'put' if necessary\n    long\tcount,\n    int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static int\tdo_always = FALSE;\t// ignore 'mouse' setting next time\n    static int\tgot_click = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's a drag or release event\n    int\t\tis_drag = FALSE;  // If TRUE it's a drag event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status line\n    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n    int\t\tin_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n    save_cursor = curwin->w_cursor;\n#endif\n\n    // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.\n    // - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.\n    // - For command line and insert mode 'mouse' is checked before calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is the same mouse event then use that\n\t    // one. Speeds up dragging the status line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\t    // below need to come before the next character, do not do this\n\t    // when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() != NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\tvungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n#endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped dragging the status or separator line.  The pointer is\n    // most likely still on the status or separator line.\n    if (!is_drag && drag_status_line)\n    {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n    }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n    else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag and release events, as well as\n    // multiple clicks and the middle mouse button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\".\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button that is held down, ignore\n    // drag/release events.\n    if (!is_click && which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't know what the user wanted\n\t    // to do. Go back to normal mode: Clear the operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t    {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual was active, yank the highlighted text and put it\n\t    // before the mouse pointer position.\n\t    // In Select mode replace the highlighted text with the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"+p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert mode doesn't move the mouse, just insert the\n\t// contents of a register.  '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t    if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n    // Check for clicking in the tab page line.\n    if (mouse_row == 0 && firstwin->w_winrow > 0)\n    {\n\tif (is_drag)\n\t{\n\t    if (in_tab_line)\n\t    {\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\ttabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\t\t\t\t\t\t\t\t? c1 - 1 : c1);\n\t    }\n\t    return FALSE;\n\t}\n\n\t// click in a tab selects that tab page\n\tif (is_click\n# ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n# endif\n\t\t&& mouse_col < Columns)\n\t{\n\t    in_tab_line = TRUE;\n\t    c1 = TabPageIdxs[mouse_col];\n\t    if (c1 >= 0)\n\t    {\n\t\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t{\n\t\t    // double click opens new page\n\t\t    end_visual_mode_keep_button();\n\t\t    tabpage_new();\n\t\t    tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Go to specified tab page, or next one if not clicking\n\t\t    // on a label.\n\t\t    goto_tabpage(c1);\n\n\t\t    // It's like clicking on the status line of a window.\n\t\t    if (curwin != old_curwin)\n\t\t\tend_visual_mode_keep_button();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ttabpage_T\t*tp;\n\n\t\t// Close the current or specified tab page.\n\t\tif (c1 == -999)\n\t\t    tp = curtab;\n\t\telse\n\t\t    tp = find_tabpage(-c1);\n\t\tif (tp == curtab)\n\t\t{\n\t\t    if (first_tabpage->tp_next != NULL)\n\t\t\ttabpage_close(FALSE);\n\t\t}\n\t\telse if (tp != NULL)\n\t\t    tabpage_close_other(tp, FALSE);\n\t    }\n\t}\n\treturn TRUE;\n    }\n    else if (is_drag && in_tab_line)\n    {\n\tc1 = TabPageIdxs[mouse_col];\n\ttabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\treturn FALSE;\n    }\n\n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n    // right button up   -> pop-up menu\n    // shift-left button -> right button\n    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore right button release events, only shows the popup\n\t\t    // menu on the button down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore right button down and drag mouse events.  Windows\n\t\t    // only shows the popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n# endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n# endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore right button release events, only shows the popup\n\t\t// menu on the button down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem, \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t    // selection or the current window (might have false\n\t\t    // negative here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t{\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol, &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags, NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t// ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) != 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t// cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending, ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive), which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags & IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping to another window, clear a pending operator.  That's a bit\n    // friendlier than beeping and not jumping to that window.\n    if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum, 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n    }\n#endif\n\n    // Set global flag that we are extending the Visual area with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window, scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\tscroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\t// right click in visual mode\n    {\n       // When ALT is pressed make Visual mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t// that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col = leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the click is before the start of visual, change the start.\n\t    // If the click is after the end of visual, change the end.  If\n\t    // the click is inside the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t    if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col - curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\telse\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t// closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t// closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t    VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT) && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click: Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname = '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\tif (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t}\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where the paste started, so in edit() Insstart can be set\n\t// to this position\n\tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname, NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n    // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse click searches for the next occurrence of the word under\n    // the mouse pointer\n    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT) || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\tif (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual = curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\tVIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode = Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end may still be the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t    if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white space) is\n\t\t// not a word character, try finding a match and select a (),\n\t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t    {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor, orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t    find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    // If Visual mode changed show it later.\n    if ((!VIsual_active && old_active && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\n    return moved;\n}",
  "project": "vim",
  "hash": 159266025064479013943001437579885155483,
  "size": 829,
  "commit_id": "80525751c5ce9ed82c41d83faf9ef38667bf61b1",
  "message": "patch 9.0.0259: crash with mouse click when not initialized\n\nProblem:    Crash with mouse click when not initialized.\nSolution:   Check TabPageIdxs[] is not NULL.",
  "target": 1,
  "dataset": "other",
  "idx": 209102
}