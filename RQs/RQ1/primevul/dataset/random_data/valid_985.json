{
  "id": 985,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/4bf64fdd786728f372e8a701a663caa2774e7a23",
  "commit_sha": "4bf64fdd786728f372e8a701a663caa2774e7a23",
  "commit_msg": "https://github.com/ImageMagick/ImageMagick/issues/3337",
  "pr_url": null,
  "pr_info": null,
  "file_name": "magick/widget.c",
  "func_name": "do",
  "raw_func_from_json": "MagickExport void XTextViewWidget(Display *display,\n  const XResourceInfo *resource_info,XWindows *windows,\n  const MagickBooleanType mono,const char *title,const char **textlist)\n{\n#define DismissButtonText  \"Dismiss\"\n\n  char\n    primary_selection[MaxTextExtent];\n\n  int\n    i;\n\n  static MagickStatusType\n    mask = (MagickStatusType) (CWWidth | CWHeight | CWX | CWY);\n\n  Status\n    status;\n\n  unsigned int\n    height,\n    lines,\n    text_width,\n    visible_lines,\n    width;\n\n  size_t\n    delay,\n    state;\n\n  XEvent\n    event;\n\n  XFontStruct\n    *font_info,\n    *text_info;\n\n  XTextProperty\n    window_name;\n\n  XWidgetInfo\n    dismiss_info,\n    expose_info,\n    list_info,\n    north_info,\n    scroll_info,\n    selection_info,\n    slider_info,\n    south_info;\n\n  XWindowChanges\n    window_changes;\n\n  /*\n    Convert text string to a text list.\n  */\n  assert(display != (Display *) NULL);\n  assert(resource_info != (XResourceInfo *) NULL);\n  assert(windows != (XWindows *) NULL);\n  assert(title != (const char *) NULL);\n  assert(textlist != (const char **) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",title);\n  XSetCursorState(display,windows,MagickTrue);\n  XCheckRefreshWindows(display,windows);\n  if (textlist == (const char **) NULL)\n    {\n      XNoticeWidget(display,windows,\"No text to view:\",(char *) NULL);\n      return;\n    }\n  /*\n    Determine Text View widget attributes.\n  */\n  font_info=windows->widget.font_info;\n  text_info=(XFontStruct *) NULL;\n  if (mono != MagickFalse)\n    text_info=XBestFont(display,resource_info,MagickTrue);\n  if (text_info == (XFontStruct *) NULL)\n    text_info=windows->widget.font_info;\n  text_width=0;\n  for (i=0; textlist[i] != (char *) NULL; i++)\n    if (WidgetTextWidth(text_info,(char *) textlist[i]) > text_width)\n      text_width=(unsigned int) XTextWidth(text_info,(char *) textlist[i],\n        MagickMin(Extent(textlist[i]),160));\n  lines=(unsigned int) i;\n  width=WidgetTextWidth(font_info,DismissButtonText);\n  width+=QuantumMargin;\n  height=(unsigned int) (text_info->ascent+text_info->descent);\n  /*\n    Position Text View widget.\n  */\n  windows->widget.width=(unsigned int) (MagickMin((int) text_width,\n    (int) MaxTextWidth)+5*QuantumMargin);\n  windows->widget.min_width=(unsigned int) (MinTextWidth+4*QuantumMargin);\n  if (windows->widget.width < windows->widget.min_width)\n    windows->widget.width=windows->widget.min_width;\n  windows->widget.height=(unsigned int) (MagickMin(MagickMax((int) lines,3),32)*\n    height+((13*height) >> 1)+((9*QuantumMargin) >> 1));\n  windows->widget.min_height=(unsigned int) (3*height+((13*height) >> 1)+((9*\n    QuantumMargin) >> 1));\n  if (windows->widget.height < windows->widget.min_height)\n    windows->widget.height=windows->widget.min_height;\n  XConstrainWindowPosition(display,&windows->widget);\n  /*\n    Map Text View widget.\n  */\n  (void) CopyMagickString(windows->widget.name,title,MaxTextExtent);\n  status=XStringListToTextProperty(&windows->widget.name,1,&window_name);\n  if (status != False)\n    {\n      XSetWMName(display,windows->widget.id,&window_name);\n      XSetWMIconName(display,windows->widget.id,&window_name);\n      (void) XFree((void *) window_name.value);\n    }\n  window_changes.width=(int) windows->widget.width;\n  window_changes.height=(int) windows->widget.height;\n  window_changes.x=windows->widget.x;\n  window_changes.y=windows->widget.y;\n  (void) XReconfigureWMWindow(display,windows->widget.id,\n    windows->widget.screen,(unsigned int) mask,&window_changes);\n  (void) XMapRaised(display,windows->widget.id);\n  windows->widget.mapped=MagickFalse;\n  /*\n    Respond to X events.\n  */\n  XGetWidgetInfo((char *) NULL,&slider_info);\n  XGetWidgetInfo((char *) NULL,&north_info);\n  XGetWidgetInfo((char *) NULL,&south_info);\n  XGetWidgetInfo((char *) NULL,&expose_info);\n  XGetWidgetInfo((char *) NULL,&selection_info);\n  visible_lines=0;\n  delay=SuspendTime << 2;\n  height=(unsigned int) (font_info->ascent+font_info->descent);\n  state=UpdateConfigurationState;\n  do\n  {\n    if (state & UpdateConfigurationState)\n      {\n        int\n          id;\n\n        /*\n          Initialize button information.\n        */\n        XGetWidgetInfo(DismissButtonText,&dismiss_info);\n        dismiss_info.width=width;\n        dismiss_info.height=(unsigned int) ((3*height) >> 1);\n        dismiss_info.x=(int) windows->widget.width-dismiss_info.width-\n          QuantumMargin-2;\n        dismiss_info.y=(int) windows->widget.height-dismiss_info.height-\n          QuantumMargin;\n        /*\n          Initialize scroll information.\n        */\n        XGetWidgetInfo((char *) NULL,&scroll_info);\n        scroll_info.bevel_width--;\n        scroll_info.width=height;\n        scroll_info.height=(unsigned int) (dismiss_info.y-((5*QuantumMargin) >>\n          1));\n        scroll_info.x=(int) windows->widget.width-QuantumMargin-\n          scroll_info.width;\n        scroll_info.y=(3*QuantumMargin) >> 1;\n        scroll_info.raised=MagickFalse;\n        scroll_info.trough=MagickTrue;\n        north_info=scroll_info;\n        north_info.raised=MagickTrue;\n        north_info.width-=(north_info.bevel_width << 1);\n        north_info.height=north_info.width-1;\n        north_info.x+=north_info.bevel_width;\n        north_info.y+=north_info.bevel_width;\n        south_info=north_info;\n        south_info.y=scroll_info.y+scroll_info.height-scroll_info.bevel_width-\n          south_info.height;\n        id=slider_info.id;\n        slider_info=north_info;\n        slider_info.id=id;\n        slider_info.width-=2;\n        slider_info.min_y=north_info.y+north_info.height+north_info.bevel_width+\n          slider_info.bevel_width+2;\n        slider_info.height=scroll_info.height-((slider_info.min_y-\n          scroll_info.y+1) << 1)+4;\n        visible_lines=scroll_info.height/(text_info->ascent+text_info->descent+\n          ((text_info->ascent+text_info->descent) >> 3));\n        if (lines > visible_lines)\n          slider_info.height=(unsigned int) (visible_lines*slider_info.height)/\n            lines;\n        slider_info.max_y=south_info.y-south_info.bevel_width-\n          slider_info.bevel_width-2;\n        slider_info.x=scroll_info.x+slider_info.bevel_width+1;\n        slider_info.y=slider_info.min_y;\n        expose_info=scroll_info;\n        expose_info.y=slider_info.y;\n        /*\n          Initialize list information.\n        */\n        XGetWidgetInfo((char *) NULL,&list_info);\n        list_info.raised=MagickFalse;\n        list_info.bevel_width--;\n        list_info.width=(unsigned int) scroll_info.x-((3*QuantumMargin) >> 1);\n        list_info.height=scroll_info.height;\n        list_info.x=QuantumMargin;\n        list_info.y=scroll_info.y;\n        /*\n          Initialize selection information.\n        */\n        XGetWidgetInfo((char *) NULL,&selection_info);\n        selection_info.center=MagickFalse;\n        selection_info.width=list_info.width;\n        selection_info.height=(unsigned int)\n          (9*(text_info->ascent+text_info->descent)) >> 3;\n        selection_info.x=list_info.x;\n        state&=(~UpdateConfigurationState);\n      }\n    if (state & RedrawWidgetState)\n      {\n        /*\n          Redraw Text View window.\n        */\n        XDrawBeveledMatte(display,&windows->widget,&list_info);\n        XDrawBeveledMatte(display,&windows->widget,&scroll_info);\n        XDrawTriangleNorth(display,&windows->widget,&north_info);\n        XDrawBeveledButton(display,&windows->widget,&slider_info);\n        XDrawTriangleSouth(display,&windows->widget,&south_info);\n        XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        selection_info.id=(~0);\n        state|=RedrawListState;\n        state&=(~RedrawWidgetState);\n      }\n    if (state & RedrawListState)\n      {\n        /*\n          Determine slider id and position.\n        */\n        if (slider_info.id >= (int) (lines-visible_lines))\n          slider_info.id=(int) lines-visible_lines;\n        if ((slider_info.id < 0) || (lines <= visible_lines))\n          slider_info.id=0;\n        slider_info.y=slider_info.min_y;\n        if (lines != 0)\n          slider_info.y+=\n            slider_info.id*(slider_info.max_y-slider_info.min_y+1)/lines;\n        if (slider_info.id != selection_info.id)\n          {\n            /*\n              Redraw scroll bar and text.\n            */\n            windows->widget.font_info=text_info;\n            (void) XSetFont(display,windows->widget.annotate_context,\n              text_info->fid);\n            (void) XSetFont(display,windows->widget.highlight_context,\n              text_info->fid);\n            selection_info.id=slider_info.id;\n            selection_info.y=list_info.y+(height >> 3)+2;\n            for (i=0; i < (int) visible_lines; i++)\n            {\n              selection_info.raised=\n                (slider_info.id+i) != list_info.id ? MagickTrue : MagickFalse;\n              selection_info.text=(char *) NULL;\n              if ((slider_info.id+i) < (int) lines)\n                selection_info.text=(char *) textlist[slider_info.id+i];\n              XDrawWidgetText(display,&windows->widget,&selection_info);\n              selection_info.y+=(int) selection_info.height;\n            }\n            windows->widget.font_info=font_info;\n            (void) XSetFont(display,windows->widget.annotate_context,\n              font_info->fid);\n            (void) XSetFont(display,windows->widget.highlight_context,\n              font_info->fid);\n            /*\n              Update slider.\n            */\n            if (slider_info.y > expose_info.y)\n              {\n                expose_info.height=(unsigned int) slider_info.y-expose_info.y;\n                expose_info.y=slider_info.y-expose_info.height-\n                  slider_info.bevel_width-1;\n              }\n            else\n              {\n                expose_info.height=(unsigned int) expose_info.y-slider_info.y;\n                expose_info.y=slider_info.y+slider_info.height+\n                  slider_info.bevel_width+1;\n              }\n            XDrawTriangleNorth(display,&windows->widget,&north_info);\n            XDrawMatte(display,&windows->widget,&expose_info);\n            XDrawBeveledButton(display,&windows->widget,&slider_info);\n            XDrawTriangleSouth(display,&windows->widget,&south_info);\n            expose_info.y=slider_info.y;\n          }\n        state&=(~RedrawListState);\n      }\n    /*\n      Wait for next event.\n    */\n    if (north_info.raised && south_info.raised)\n      (void) XIfEvent(display,&event,XScreenEvent,(char *) windows);\n    else\n      {\n        /*\n          Brief delay before advancing scroll bar.\n        */\n        XDelay(display,delay);\n        delay=SuspendTime;\n        (void) XCheckIfEvent(display,&event,XScreenEvent,(char *) windows);\n        if (north_info.raised == MagickFalse)\n          if (slider_info.id > 0)\n            {\n              /*\n                Move slider up.\n              */\n              slider_info.id--;\n              state|=RedrawListState;\n            }\n        if (south_info.raised == MagickFalse)\n          if (slider_info.id < (int) lines)\n            {\n              /*\n                Move slider down.\n              */\n              slider_info.id++;\n              state|=RedrawListState;\n            }\n        if (event.type != ButtonRelease)\n          continue;\n      }\n    switch (event.type)\n    {\n      case ButtonPress:\n      {\n        if (MatteIsActive(slider_info,event.xbutton))\n          {\n            /*\n              Track slider.\n            */\n            slider_info.active=MagickTrue;\n            break;\n          }\n        if (MatteIsActive(north_info,event.xbutton))\n          if (slider_info.id > 0)\n            {\n              /*\n                Move slider up.\n              */\n              north_info.raised=MagickFalse;\n              slider_info.id--;\n              state|=RedrawListState;\n              break;\n            }\n        if (MatteIsActive(south_info,event.xbutton))\n          if (slider_info.id < (int) lines)\n            {\n              /*\n                Move slider down.\n              */\n              south_info.raised=MagickFalse;\n              slider_info.id++;\n              state|=RedrawListState;\n              break;\n            }\n        if (MatteIsActive(scroll_info,event.xbutton))\n          {\n            /*\n              Move slider.\n            */\n            if (event.xbutton.y < slider_info.y)\n              slider_info.id-=(visible_lines-1);\n            else\n              slider_info.id+=(visible_lines-1);\n            state|=RedrawListState;\n            break;\n          }\n        if (MatteIsActive(dismiss_info,event.xbutton))\n          {\n            /*\n              User pressed Dismiss button.\n            */\n            dismiss_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n            break;\n          }\n        if (MatteIsActive(list_info,event.xbutton))\n          {\n            int\n              id;\n\n            static Time\n              click_time;\n\n            /*\n              User pressed list matte.\n            */\n            id=slider_info.id+(event.xbutton.y-(list_info.y+(height >> 1))+1)/\n              selection_info.height;\n            if (id >= (int) lines)\n              break;\n            if (id != list_info.id)\n              {\n                list_info.id=id;\n                click_time=event.xbutton.time;\n                break;\n              }\n            list_info.id=id;\n            if (event.xbutton.time >= (click_time+DoubleClick))\n              {\n                click_time=event.xbutton.time;\n                break;\n              }\n            click_time=event.xbutton.time;\n            /*\n              Become the XA_PRIMARY selection owner.\n            */\n            (void) CopyMagickString(primary_selection,textlist[list_info.id],\n              MaxTextExtent);\n            (void) XSetSelectionOwner(display,XA_PRIMARY,windows->widget.id,\n              event.xbutton.time);\n            if (XGetSelectionOwner(display,XA_PRIMARY) != windows->widget.id)\n              break;\n            selection_info.id=(~0);\n            list_info.id=id;\n            state|=RedrawListState;\n            break;\n          }\n        break;\n      }\n      case ButtonRelease:\n      {\n        if (windows->widget.mapped == MagickFalse)\n          break;\n        if (north_info.raised == MagickFalse)\n          {\n            /*\n              User released up button.\n            */\n            delay=SuspendTime << 2;\n            north_info.raised=MagickTrue;\n            XDrawTriangleNorth(display,&windows->widget,&north_info);\n          }\n        if (south_info.raised == MagickFalse)\n          {\n            /*\n              User released down button.\n            */\n            delay=SuspendTime << 2;\n            south_info.raised=MagickTrue;\n            XDrawTriangleSouth(display,&windows->widget,&south_info);\n          }\n        if (slider_info.active)\n          {\n            /*\n              Stop tracking slider.\n            */\n            slider_info.active=MagickFalse;\n            break;\n          }\n        if (dismiss_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(dismiss_info,event.xbutton))\n                state|=ExitState;\n            dismiss_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n          }\n        break;\n      }\n      case ClientMessage:\n      {\n        /*\n          If client window delete message, exit.\n        */\n        if (event.xclient.message_type != windows->wm_protocols)\n          break;\n        if (*event.xclient.data.l == (int) windows->wm_take_focus)\n          {\n            (void) XSetInputFocus(display,event.xclient.window,RevertToParent,\n              (Time) event.xclient.data.l[1]);\n            break;\n          }\n        if (*event.xclient.data.l != (int) windows->wm_delete_window)\n          break;\n        if (event.xclient.window == windows->widget.id)\n          {\n            state|=ExitState;\n            break;\n          }\n        break;\n      }\n      case ConfigureNotify:\n      {\n        /*\n          Update widget configuration.\n        */\n        if (event.xconfigure.window != windows->widget.id)\n          break;\n        if ((event.xconfigure.width == (int) windows->widget.width) &&\n            (event.xconfigure.height == (int) windows->widget.height))\n          break;\n        windows->widget.width=(unsigned int)\n          MagickMax(event.xconfigure.width,(int) windows->widget.min_width);\n        windows->widget.height=(unsigned int)\n          MagickMax(event.xconfigure.height,(int) windows->widget.min_height);\n        state|=UpdateConfigurationState;\n        break;\n      }\n      case EnterNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state&=(~InactiveWidgetState);\n        break;\n      }\n      case Expose:\n      {\n        if (event.xexpose.window != windows->widget.id)\n          break;\n        if (event.xexpose.count != 0)\n          break;\n        state|=RedrawWidgetState;\n        break;\n      }\n      case KeyPress:\n      {\n        static char\n          command[MaxTextExtent];\n\n        static int\n          length;\n\n        static KeySym\n          key_symbol;\n\n        /*\n          Respond to a user key press.\n        */\n        if (event.xkey.window != windows->widget.id)\n          break;\n        length=XLookupString((XKeyEvent *) &event.xkey,command,\n          (int) sizeof(command),&key_symbol,(XComposeStatus *) NULL);\n        *(command+length)='\\0';\n        if ((key_symbol == XK_Return) || (key_symbol == XK_KP_Enter))\n          {\n            dismiss_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n            state|=ExitState;\n            break;\n          }\n        if (AreaIsActive(scroll_info,event.xkey))\n          {\n            /*\n              Move slider.\n            */\n            switch ((int) key_symbol)\n            {\n              case XK_Home:\n              case XK_KP_Home:\n              {\n                slider_info.id=0;\n                break;\n              }\n              case XK_Up:\n              case XK_KP_Up:\n              {\n                slider_info.id--;\n                break;\n              }\n              case XK_Down:\n              case XK_KP_Down:\n              {\n                slider_info.id++;\n                break;\n              }\n              case XK_Prior:\n              case XK_KP_Prior:\n              {\n                slider_info.id-=visible_lines;\n                break;\n              }\n              case XK_Next:\n              case XK_KP_Next:\n              {\n                slider_info.id+=visible_lines;\n                break;\n              }\n              case XK_End:\n              case XK_KP_End:\n              {\n                slider_info.id=(int) lines;\n                break;\n              }\n            }\n            state|=RedrawListState;\n            break;\n          }\n        break;\n      }\n      case KeyRelease:\n        break;\n      case LeaveNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state|=InactiveWidgetState;\n        break;\n      }\n      case MapNotify:\n      {\n        mask&=(~CWX);\n        mask&=(~CWY);\n        break;\n      }\n      case MotionNotify:\n      {\n        /*\n          Discard pending button motion events.\n        */\n        while (XCheckMaskEvent(display,ButtonMotionMask,&event)) ;\n        if (slider_info.active)\n          {\n            /*\n              Move slider matte.\n            */\n            slider_info.y=event.xmotion.y-\n              ((slider_info.height+slider_info.bevel_width) >> 1)+1;\n            if (slider_info.y < slider_info.min_y)\n              slider_info.y=slider_info.min_y;\n            if (slider_info.y > slider_info.max_y)\n              slider_info.y=slider_info.max_y;\n            slider_info.id=0;\n            if (slider_info.y != slider_info.min_y)\n              slider_info.id=(int) (lines*(slider_info.y-slider_info.min_y+1))/\n                (slider_info.max_y-slider_info.min_y+1);\n            state|=RedrawListState;\n            break;\n          }\n        if (state & InactiveWidgetState)\n          break;\n        if (dismiss_info.raised == MatteIsActive(dismiss_info,event.xmotion))\n          {\n            /*\n              Dismiss button status changed.\n            */\n            dismiss_info.raised=\n              dismiss_info.raised == MagickFalse ? MagickTrue : MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n            break;\n          }\n        break;\n      }\n      case SelectionClear:\n      {\n        list_info.id=(~0);\n        selection_info.id=(~0);\n        state|=RedrawListState;\n        break;\n      }\n      case SelectionRequest:\n      {\n        XSelectionEvent\n          notify;\n\n        XSelectionRequestEvent\n          *request;\n\n        if (list_info.id == (~0))\n          break;\n        /*\n          Set primary selection.\n        */\n        request=(&(event.xselectionrequest));\n        (void) XChangeProperty(request->display,request->requestor,\n          request->property,request->target,8,PropModeReplace,\n          (unsigned char *) primary_selection,Extent(primary_selection));\n        notify.type=SelectionNotify;\n        notify.send_event=MagickTrue;\n        notify.display=request->display;\n        notify.requestor=request->requestor;\n        notify.selection=request->selection;\n        notify.target=request->target;\n        notify.time=request->time;\n        if (request->property == None)\n          notify.property=request->target;\n        else\n          notify.property=request->property;\n        (void) XSendEvent(request->display,request->requestor,False,NoEventMask,\n          (XEvent *) &notify);\n      }\n      default:\n        break;\n    }\n  } while ((state & ExitState) == 0);\n  if (text_info != windows->widget.font_info)\n    (void) XFreeFont(display,text_info);\n  XSetCursorState(display,windows,MagickFalse);\n  (void) XWithdrawWindow(display,windows->widget.id,windows->widget.screen);\n  XCheckRefreshWindows(display,windows);\n}",
  "diff_func": "@@ -9127,8 +9127,9 @@ MagickExport void XTextViewWidget(Display *display,\n           slider_info.bevel_width+2;\n         slider_info.height=scroll_info.height-((slider_info.min_y-\n           scroll_info.y+1) << 1)+4;\n-        visible_lines=scroll_info.height/(text_info->ascent+text_info->descent+\n-          ((text_info->ascent+text_info->descent) >> 3));\n+        visible_lines=(unsigned int) (scroll_info.height*PerceptibleReciprocal(\n+          (double) text_info->ascent+text_info->descent+((text_info->ascent+\n+          text_info->descent) >> 3)));\n         if (lines > visible_lines)\n           slider_info.height=(unsigned int) (visible_lines*slider_info.height)/\n             lines;",
  "func": "MagickExport void XTextViewWidget(Display *display,\n  const XResourceInfo *resource_info,XWindows *windows,\n  const MagickBooleanType mono,const char *title,const char **textlist)\n{\n#define DismissButtonText  \"Dismiss\"\n\n  char\n    primary_selection[MaxTextExtent];\n\n  int\n    i;\n\n  static MagickStatusType\n    mask = (MagickStatusType) (CWWidth | CWHeight | CWX | CWY);\n\n  Status\n    status;\n\n  unsigned int\n    height,\n    lines,\n    text_width,\n    visible_lines,\n    width;\n\n  size_t\n    delay,\n    state;\n\n  XEvent\n    event;\n\n  XFontStruct\n    *font_info,\n    *text_info;\n\n  XTextProperty\n    window_name;\n\n  XWidgetInfo\n    dismiss_info,\n    expose_info,\n    list_info,\n    north_info,\n    scroll_info,\n    selection_info,\n    slider_info,\n    south_info;\n\n  XWindowChanges\n    window_changes;\n\n  /*\n    Convert text string to a text list.\n  */\n  assert(display != (Display *) NULL);\n  assert(resource_info != (XResourceInfo *) NULL);\n  assert(windows != (XWindows *) NULL);\n  assert(title != (const char *) NULL);\n  assert(textlist != (const char **) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",title);\n  XSetCursorState(display,windows,MagickTrue);\n  XCheckRefreshWindows(display,windows);\n  if (textlist == (const char **) NULL)\n    {\n      XNoticeWidget(display,windows,\"No text to view:\",(char *) NULL);\n      return;\n    }\n  /*\n    Determine Text View widget attributes.\n  */\n  font_info=windows->widget.font_info;\n  text_info=(XFontStruct *) NULL;\n  if (mono != MagickFalse)\n    text_info=XBestFont(display,resource_info,MagickTrue);\n  if (text_info == (XFontStruct *) NULL)\n    text_info=windows->widget.font_info;\n  text_width=0;\n  for (i=0; textlist[i] != (char *) NULL; i++)\n    if (WidgetTextWidth(text_info,(char *) textlist[i]) > text_width)\n      text_width=(unsigned int) XTextWidth(text_info,(char *) textlist[i],\n        MagickMin(Extent(textlist[i]),160));\n  lines=(unsigned int) i;\n  width=WidgetTextWidth(font_info,DismissButtonText);\n  width+=QuantumMargin;\n  height=(unsigned int) (text_info->ascent+text_info->descent);\n  /*\n    Position Text View widget.\n  */\n  windows->widget.width=(unsigned int) (MagickMin((int) text_width,\n    (int) MaxTextWidth)+5*QuantumMargin);\n  windows->widget.min_width=(unsigned int) (MinTextWidth+4*QuantumMargin);\n  if (windows->widget.width < windows->widget.min_width)\n    windows->widget.width=windows->widget.min_width;\n  windows->widget.height=(unsigned int) (MagickMin(MagickMax((int) lines,3),32)*\n    height+((13*height) >> 1)+((9*QuantumMargin) >> 1));\n  windows->widget.min_height=(unsigned int) (3*height+((13*height) >> 1)+((9*\n    QuantumMargin) >> 1));\n  if (windows->widget.height < windows->widget.min_height)\n    windows->widget.height=windows->widget.min_height;\n  XConstrainWindowPosition(display,&windows->widget);\n  /*\n    Map Text View widget.\n  */\n  (void) CopyMagickString(windows->widget.name,title,MaxTextExtent);\n  status=XStringListToTextProperty(&windows->widget.name,1,&window_name);\n  if (status != False)\n    {\n      XSetWMName(display,windows->widget.id,&window_name);\n      XSetWMIconName(display,windows->widget.id,&window_name);\n      (void) XFree((void *) window_name.value);\n    }\n  window_changes.width=(int) windows->widget.width;\n  window_changes.height=(int) windows->widget.height;\n  window_changes.x=windows->widget.x;\n  window_changes.y=windows->widget.y;\n  (void) XReconfigureWMWindow(display,windows->widget.id,\n    windows->widget.screen,(unsigned int) mask,&window_changes);\n  (void) XMapRaised(display,windows->widget.id);\n  windows->widget.mapped=MagickFalse;\n  /*\n    Respond to X events.\n  */\n  XGetWidgetInfo((char *) NULL,&slider_info);\n  XGetWidgetInfo((char *) NULL,&north_info);\n  XGetWidgetInfo((char *) NULL,&south_info);\n  XGetWidgetInfo((char *) NULL,&expose_info);\n  XGetWidgetInfo((char *) NULL,&selection_info);\n  visible_lines=0;\n  delay=SuspendTime << 2;\n  height=(unsigned int) (font_info->ascent+font_info->descent);\n  state=UpdateConfigurationState;\n  do\n  {\n    if (state & UpdateConfigurationState)\n      {\n        int\n          id;\n\n        /*\n          Initialize button information.\n        */\n        XGetWidgetInfo(DismissButtonText,&dismiss_info);\n        dismiss_info.width=width;\n        dismiss_info.height=(unsigned int) ((3*height) >> 1);\n        dismiss_info.x=(int) windows->widget.width-dismiss_info.width-\n          QuantumMargin-2;\n        dismiss_info.y=(int) windows->widget.height-dismiss_info.height-\n          QuantumMargin;\n        /*\n          Initialize scroll information.\n        */\n        XGetWidgetInfo((char *) NULL,&scroll_info);\n        scroll_info.bevel_width--;\n        scroll_info.width=height;\n        scroll_info.height=(unsigned int) (dismiss_info.y-((5*QuantumMargin) >>\n          1));\n        scroll_info.x=(int) windows->widget.width-QuantumMargin-\n          scroll_info.width;\n        scroll_info.y=(3*QuantumMargin) >> 1;\n        scroll_info.raised=MagickFalse;\n        scroll_info.trough=MagickTrue;\n        north_info=scroll_info;\n        north_info.raised=MagickTrue;\n        north_info.width-=(north_info.bevel_width << 1);\n        north_info.height=north_info.width-1;\n        north_info.x+=north_info.bevel_width;\n        north_info.y+=north_info.bevel_width;\n        south_info=north_info;\n        south_info.y=scroll_info.y+scroll_info.height-scroll_info.bevel_width-\n          south_info.height;\n        id=slider_info.id;\n        slider_info=north_info;\n        slider_info.id=id;\n        slider_info.width-=2;\n        slider_info.min_y=north_info.y+north_info.height+north_info.bevel_width+\n          slider_info.bevel_width+2;\n        slider_info.height=scroll_info.height-((slider_info.min_y-\n          scroll_info.y+1) << 1)+4;\n        visible_lines=scroll_info.height/(text_info->ascent+text_info->descent+\n          ((text_info->ascent+text_info->descent) >> 3));\n        if (lines > visible_lines)\n          slider_info.height=(unsigned int) (visible_lines*slider_info.height)/\n            lines;\n        slider_info.max_y=south_info.y-south_info.bevel_width-\n          slider_info.bevel_width-2;\n        slider_info.x=scroll_info.x+slider_info.bevel_width+1;\n        slider_info.y=slider_info.min_y;\n        expose_info=scroll_info;\n        expose_info.y=slider_info.y;\n        /*\n          Initialize list information.\n        */\n        XGetWidgetInfo((char *) NULL,&list_info);\n        list_info.raised=MagickFalse;\n        list_info.bevel_width--;\n        list_info.width=(unsigned int) scroll_info.x-((3*QuantumMargin) >> 1);\n        list_info.height=scroll_info.height;\n        list_info.x=QuantumMargin;\n        list_info.y=scroll_info.y;\n        /*\n          Initialize selection information.\n        */\n        XGetWidgetInfo((char *) NULL,&selection_info);\n        selection_info.center=MagickFalse;\n        selection_info.width=list_info.width;\n        selection_info.height=(unsigned int)\n          (9*(text_info->ascent+text_info->descent)) >> 3;\n        selection_info.x=list_info.x;\n        state&=(~UpdateConfigurationState);\n      }\n    if (state & RedrawWidgetState)\n      {\n        /*\n          Redraw Text View window.\n        */\n        XDrawBeveledMatte(display,&windows->widget,&list_info);\n        XDrawBeveledMatte(display,&windows->widget,&scroll_info);\n        XDrawTriangleNorth(display,&windows->widget,&north_info);\n        XDrawBeveledButton(display,&windows->widget,&slider_info);\n        XDrawTriangleSouth(display,&windows->widget,&south_info);\n        XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n        XHighlightWidget(display,&windows->widget,BorderOffset,BorderOffset);\n        selection_info.id=(~0);\n        state|=RedrawListState;\n        state&=(~RedrawWidgetState);\n      }\n    if (state & RedrawListState)\n      {\n        /*\n          Determine slider id and position.\n        */\n        if (slider_info.id >= (int) (lines-visible_lines))\n          slider_info.id=(int) lines-visible_lines;\n        if ((slider_info.id < 0) || (lines <= visible_lines))\n          slider_info.id=0;\n        slider_info.y=slider_info.min_y;\n        if (lines != 0)\n          slider_info.y+=\n            slider_info.id*(slider_info.max_y-slider_info.min_y+1)/lines;\n        if (slider_info.id != selection_info.id)\n          {\n            /*\n              Redraw scroll bar and text.\n            */\n            windows->widget.font_info=text_info;\n            (void) XSetFont(display,windows->widget.annotate_context,\n              text_info->fid);\n            (void) XSetFont(display,windows->widget.highlight_context,\n              text_info->fid);\n            selection_info.id=slider_info.id;\n            selection_info.y=list_info.y+(height >> 3)+2;\n            for (i=0; i < (int) visible_lines; i++)\n            {\n              selection_info.raised=\n                (slider_info.id+i) != list_info.id ? MagickTrue : MagickFalse;\n              selection_info.text=(char *) NULL;\n              if ((slider_info.id+i) < (int) lines)\n                selection_info.text=(char *) textlist[slider_info.id+i];\n              XDrawWidgetText(display,&windows->widget,&selection_info);\n              selection_info.y+=(int) selection_info.height;\n            }\n            windows->widget.font_info=font_info;\n            (void) XSetFont(display,windows->widget.annotate_context,\n              font_info->fid);\n            (void) XSetFont(display,windows->widget.highlight_context,\n              font_info->fid);\n            /*\n              Update slider.\n            */\n            if (slider_info.y > expose_info.y)\n              {\n                expose_info.height=(unsigned int) slider_info.y-expose_info.y;\n                expose_info.y=slider_info.y-expose_info.height-\n                  slider_info.bevel_width-1;\n              }\n            else\n              {\n                expose_info.height=(unsigned int) expose_info.y-slider_info.y;\n                expose_info.y=slider_info.y+slider_info.height+\n                  slider_info.bevel_width+1;\n              }\n            XDrawTriangleNorth(display,&windows->widget,&north_info);\n            XDrawMatte(display,&windows->widget,&expose_info);\n            XDrawBeveledButton(display,&windows->widget,&slider_info);\n            XDrawTriangleSouth(display,&windows->widget,&south_info);\n            expose_info.y=slider_info.y;\n          }\n        state&=(~RedrawListState);\n      }\n    /*\n      Wait for next event.\n    */\n    if (north_info.raised && south_info.raised)\n      (void) XIfEvent(display,&event,XScreenEvent,(char *) windows);\n    else\n      {\n        /*\n          Brief delay before advancing scroll bar.\n        */\n        XDelay(display,delay);\n        delay=SuspendTime;\n        (void) XCheckIfEvent(display,&event,XScreenEvent,(char *) windows);\n        if (north_info.raised == MagickFalse)\n          if (slider_info.id > 0)\n            {\n              /*\n                Move slider up.\n              */\n              slider_info.id--;\n              state|=RedrawListState;\n            }\n        if (south_info.raised == MagickFalse)\n          if (slider_info.id < (int) lines)\n            {\n              /*\n                Move slider down.\n              */\n              slider_info.id++;\n              state|=RedrawListState;\n            }\n        if (event.type != ButtonRelease)\n          continue;\n      }\n    switch (event.type)\n    {\n      case ButtonPress:\n      {\n        if (MatteIsActive(slider_info,event.xbutton))\n          {\n            /*\n              Track slider.\n            */\n            slider_info.active=MagickTrue;\n            break;\n          }\n        if (MatteIsActive(north_info,event.xbutton))\n          if (slider_info.id > 0)\n            {\n              /*\n                Move slider up.\n              */\n              north_info.raised=MagickFalse;\n              slider_info.id--;\n              state|=RedrawListState;\n              break;\n            }\n        if (MatteIsActive(south_info,event.xbutton))\n          if (slider_info.id < (int) lines)\n            {\n              /*\n                Move slider down.\n              */\n              south_info.raised=MagickFalse;\n              slider_info.id++;\n              state|=RedrawListState;\n              break;\n            }\n        if (MatteIsActive(scroll_info,event.xbutton))\n          {\n            /*\n              Move slider.\n            */\n            if (event.xbutton.y < slider_info.y)\n              slider_info.id-=(visible_lines-1);\n            else\n              slider_info.id+=(visible_lines-1);\n            state|=RedrawListState;\n            break;\n          }\n        if (MatteIsActive(dismiss_info,event.xbutton))\n          {\n            /*\n              User pressed Dismiss button.\n            */\n            dismiss_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n            break;\n          }\n        if (MatteIsActive(list_info,event.xbutton))\n          {\n            int\n              id;\n\n            static Time\n              click_time;\n\n            /*\n              User pressed list matte.\n            */\n            id=slider_info.id+(event.xbutton.y-(list_info.y+(height >> 1))+1)/\n              selection_info.height;\n            if (id >= (int) lines)\n              break;\n            if (id != list_info.id)\n              {\n                list_info.id=id;\n                click_time=event.xbutton.time;\n                break;\n              }\n            list_info.id=id;\n            if (event.xbutton.time >= (click_time+DoubleClick))\n              {\n                click_time=event.xbutton.time;\n                break;\n              }\n            click_time=event.xbutton.time;\n            /*\n              Become the XA_PRIMARY selection owner.\n            */\n            (void) CopyMagickString(primary_selection,textlist[list_info.id],\n              MaxTextExtent);\n            (void) XSetSelectionOwner(display,XA_PRIMARY,windows->widget.id,\n              event.xbutton.time);\n            if (XGetSelectionOwner(display,XA_PRIMARY) != windows->widget.id)\n              break;\n            selection_info.id=(~0);\n            list_info.id=id;\n            state|=RedrawListState;\n            break;\n          }\n        break;\n      }\n      case ButtonRelease:\n      {\n        if (windows->widget.mapped == MagickFalse)\n          break;\n        if (north_info.raised == MagickFalse)\n          {\n            /*\n              User released up button.\n            */\n            delay=SuspendTime << 2;\n            north_info.raised=MagickTrue;\n            XDrawTriangleNorth(display,&windows->widget,&north_info);\n          }\n        if (south_info.raised == MagickFalse)\n          {\n            /*\n              User released down button.\n            */\n            delay=SuspendTime << 2;\n            south_info.raised=MagickTrue;\n            XDrawTriangleSouth(display,&windows->widget,&south_info);\n          }\n        if (slider_info.active)\n          {\n            /*\n              Stop tracking slider.\n            */\n            slider_info.active=MagickFalse;\n            break;\n          }\n        if (dismiss_info.raised == MagickFalse)\n          {\n            if (event.xbutton.window == windows->widget.id)\n              if (MatteIsActive(dismiss_info,event.xbutton))\n                state|=ExitState;\n            dismiss_info.raised=MagickTrue;\n            XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n          }\n        break;\n      }\n      case ClientMessage:\n      {\n        /*\n          If client window delete message, exit.\n        */\n        if (event.xclient.message_type != windows->wm_protocols)\n          break;\n        if (*event.xclient.data.l == (int) windows->wm_take_focus)\n          {\n            (void) XSetInputFocus(display,event.xclient.window,RevertToParent,\n              (Time) event.xclient.data.l[1]);\n            break;\n          }\n        if (*event.xclient.data.l != (int) windows->wm_delete_window)\n          break;\n        if (event.xclient.window == windows->widget.id)\n          {\n            state|=ExitState;\n            break;\n          }\n        break;\n      }\n      case ConfigureNotify:\n      {\n        /*\n          Update widget configuration.\n        */\n        if (event.xconfigure.window != windows->widget.id)\n          break;\n        if ((event.xconfigure.width == (int) windows->widget.width) &&\n            (event.xconfigure.height == (int) windows->widget.height))\n          break;\n        windows->widget.width=(unsigned int)\n          MagickMax(event.xconfigure.width,(int) windows->widget.min_width);\n        windows->widget.height=(unsigned int)\n          MagickMax(event.xconfigure.height,(int) windows->widget.min_height);\n        state|=UpdateConfigurationState;\n        break;\n      }\n      case EnterNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state&=(~InactiveWidgetState);\n        break;\n      }\n      case Expose:\n      {\n        if (event.xexpose.window != windows->widget.id)\n          break;\n        if (event.xexpose.count != 0)\n          break;\n        state|=RedrawWidgetState;\n        break;\n      }\n      case KeyPress:\n      {\n        static char\n          command[MaxTextExtent];\n\n        static int\n          length;\n\n        static KeySym\n          key_symbol;\n\n        /*\n          Respond to a user key press.\n        */\n        if (event.xkey.window != windows->widget.id)\n          break;\n        length=XLookupString((XKeyEvent *) &event.xkey,command,\n          (int) sizeof(command),&key_symbol,(XComposeStatus *) NULL);\n        *(command+length)='\\0';\n        if ((key_symbol == XK_Return) || (key_symbol == XK_KP_Enter))\n          {\n            dismiss_info.raised=MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n            state|=ExitState;\n            break;\n          }\n        if (AreaIsActive(scroll_info,event.xkey))\n          {\n            /*\n              Move slider.\n            */\n            switch ((int) key_symbol)\n            {\n              case XK_Home:\n              case XK_KP_Home:\n              {\n                slider_info.id=0;\n                break;\n              }\n              case XK_Up:\n              case XK_KP_Up:\n              {\n                slider_info.id--;\n                break;\n              }\n              case XK_Down:\n              case XK_KP_Down:\n              {\n                slider_info.id++;\n                break;\n              }\n              case XK_Prior:\n              case XK_KP_Prior:\n              {\n                slider_info.id-=visible_lines;\n                break;\n              }\n              case XK_Next:\n              case XK_KP_Next:\n              {\n                slider_info.id+=visible_lines;\n                break;\n              }\n              case XK_End:\n              case XK_KP_End:\n              {\n                slider_info.id=(int) lines;\n                break;\n              }\n            }\n            state|=RedrawListState;\n            break;\n          }\n        break;\n      }\n      case KeyRelease:\n        break;\n      case LeaveNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state|=InactiveWidgetState;\n        break;\n      }\n      case MapNotify:\n      {\n        mask&=(~CWX);\n        mask&=(~CWY);\n        break;\n      }\n      case MotionNotify:\n      {\n        /*\n          Discard pending button motion events.\n        */\n        while (XCheckMaskEvent(display,ButtonMotionMask,&event)) ;\n        if (slider_info.active)\n          {\n            /*\n              Move slider matte.\n            */\n            slider_info.y=event.xmotion.y-\n              ((slider_info.height+slider_info.bevel_width) >> 1)+1;\n            if (slider_info.y < slider_info.min_y)\n              slider_info.y=slider_info.min_y;\n            if (slider_info.y > slider_info.max_y)\n              slider_info.y=slider_info.max_y;\n            slider_info.id=0;\n            if (slider_info.y != slider_info.min_y)\n              slider_info.id=(int) (lines*(slider_info.y-slider_info.min_y+1))/\n                (slider_info.max_y-slider_info.min_y+1);\n            state|=RedrawListState;\n            break;\n          }\n        if (state & InactiveWidgetState)\n          break;\n        if (dismiss_info.raised == MatteIsActive(dismiss_info,event.xmotion))\n          {\n            /*\n              Dismiss button status changed.\n            */\n            dismiss_info.raised=\n              dismiss_info.raised == MagickFalse ? MagickTrue : MagickFalse;\n            XDrawBeveledButton(display,&windows->widget,&dismiss_info);\n            break;\n          }\n        break;\n      }\n      case SelectionClear:\n      {\n        list_info.id=(~0);\n        selection_info.id=(~0);\n        state|=RedrawListState;\n        break;\n      }\n      case SelectionRequest:\n      {\n        XSelectionEvent\n          notify;\n\n        XSelectionRequestEvent\n          *request;\n\n        if (list_info.id == (~0))\n          break;\n        /*\n          Set primary selection.\n        */\n        request=(&(event.xselectionrequest));\n        (void) XChangeProperty(request->display,request->requestor,\n          request->property,request->target,8,PropModeReplace,\n          (unsigned char *) primary_selection,Extent(primary_selection));\n        notify.type=SelectionNotify;\n        notify.send_event=MagickTrue;\n        notify.display=request->display;\n        notify.requestor=request->requestor;\n        notify.selection=request->selection;\n        notify.target=request->target;\n        notify.time=request->time;\n        if (request->property == None)\n          notify.property=request->target;\n        else\n          notify.property=request->property;\n        (void) XSendEvent(request->display,request->requestor,False,NoEventMask,\n          (XEvent *) &notify);\n      }\n      default:\n        break;\n    }\n  } while ((state & ExitState) == 0);\n  if (text_info != windows->widget.font_info)\n    (void) XFreeFont(display,text_info);\n  XSetCursorState(display,windows,MagickFalse);\n  (void) XWithdrawWindow(display,windows->widget.id,windows->widget.screen);\n  XCheckRefreshWindows(display,windows);\n}",
  "project": "ImageMagick6",
  "hash": 60415464241515117185476350103153384876,
  "size": 694,
  "commit_id": "4bf64fdd786728f372e8a701a663caa2774e7a23",
  "message": "https://github.com/ImageMagick/ImageMagick/issues/3337",
  "target": 1,
  "dataset": "other",
  "idx": 213359
}