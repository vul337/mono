{
  "id": 532,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/malvira/lpc31xx/commit/7ada876a8703f23befbb20a7465a702ee39b1704",
  "commit_sha": "7ada876a8703f23befbb20a7465a702ee39b1704",
  "commit_msg": "futex: Fix errors in nested key ref-counting\n\nfutex_wait() is leaking key references due to futex_wait_setup()\nacquiring an additional reference via the queue_lock() routine. The\nnested key ref-counting has been masking bugs and complicating code\nanalysis. queue_lock() is only called with a previously ref-counted\nkey, so remove the additional ref-counting from the queue_(un)lock()\nfunctions.\n\nAlso futex_wait_requeue_pi() drops one key reference too many in\nunqueue_me_pi(). Remove the key reference handling from\nunqueue_me_pi(). This was paired with a queue_lock() in\nfutex_lock_pi(), so the count remains unchanged.\n\nDocument remaining nested key ref-counting sites.\n\nSigned-off-by: Darren Hart <dvhart@linux.intel.com>\nReported-and-tested-by: Matthieu Fertr√©<matthieu.fertre@kerlabs.com>\nReported-by: Louis Rilling<louis.rilling@kerlabs.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Eric Dumazet <eric.dumazet@gmail.com>\nCc: John Kacur <jkacur@redhat.com>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nLKML-Reference: <4CBB17A8.70401@linux.intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@kernel.org",
  "pr_url": null,
  "pr_info": null,
  "file_name": "kernel/futex.c",
  "func_name": "",
  "raw_func_from_json": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n \t}\n \n retry:\n\t/* Prepare to wait on uaddr. */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n \n \t/* If we were woken (and unqueued), we succeeded, whatever. */\n \tret = 0;\n \tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n \tret = -ETIMEDOUT;\n \tif (to && !to->task)\n\t\tgoto out_put_key;\n \n \t/*\n \t * We expect signal_pending(current), but we might be the\n \t * victim of a spurious wakeup as well.\n \t */\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n \t\tgoto retry;\n\t}\n \n \tret = -ERESTARTSYS;\n \tif (!abs_time)\n\t\tgoto out_put_key;\n \n \trestart = &current_thread_info()->restart_block;\n \trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n \n \tret = -ERESTART_RESTARTBLOCK;\n \nout_put_key:\n\tput_futex_key(fshared, &q.key);\n out:\n \tif (to) {\n \t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n",
  "diff_func": "@@ -1363,7 +1363,6 @@ static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n {\n \tstruct futex_hash_bucket *hb;\n \n-\tget_futex_key_refs(&q->key);\n \thb = hash_futex(&q->key);\n \tq->lock_ptr = &hb->lock;\n \n@@ -1375,7 +1374,6 @@ static inline void\n queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n {\n \tspin_unlock(&hb->lock);\n-\tdrop_futex_key_refs(&q->key);\n }\n \n /**\n@@ -1480,8 +1478,6 @@ static void unqueue_me_pi(struct futex_q *q)\n \tq->pi_state = NULL;\n \n \tspin_unlock(q->lock_ptr);\n-\n-\tdrop_futex_key_refs(&q->key);\n }\n \n /*\n@@ -1812,7 +1808,10 @@ static int futex_wait(u32 __user *uaddr, int fshared,\n \t}\n \n retry:\n-\t/* Prepare to wait on uaddr. */\n+\t/*\n+\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n+\t * q.key refs.\n+\t */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out;\n@@ -1822,24 +1821,23 @@ static int futex_wait(u32 __user *uaddr, int fshared,\n \n \t/* If we were woken (and unqueued), we succeeded, whatever. */\n \tret = 0;\n+\t/* unqueue_me() drops q.key ref */\n \tif (!unqueue_me(&q))\n-\t\tgoto out_put_key;\n+\t\tgoto out;\n \tret = -ETIMEDOUT;\n \tif (to && !to->task)\n-\t\tgoto out_put_key;\n+\t\tgoto out;\n \n \t/*\n \t * We expect signal_pending(current), but we might be the\n \t * victim of a spurious wakeup as well.\n \t */\n-\tif (!signal_pending(current)) {\n-\t\tput_futex_key(fshared, &q.key);\n+\tif (!signal_pending(current))\n \t\tgoto retry;\n-\t}\n \n \tret = -ERESTARTSYS;\n \tif (!abs_time)\n-\t\tgoto out_put_key;\n+\t\tgoto out;\n \n \trestart = &current_thread_info()->restart_block;\n \trestart->fn = futex_wait_restart;\n@@ -1856,8 +1854,6 @@ static int futex_wait(u32 __user *uaddr, int fshared,\n \n \tret = -ERESTART_RESTARTBLOCK;\n \n-out_put_key:\n-\tput_futex_key(fshared, &q.key);\n out:\n \tif (to) {\n \t\thrtimer_cancel(&to->timer);\n@@ -2236,7 +2232,10 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n \tq.rt_waiter = &rt_waiter;\n \tq.requeue_pi_key = &key2;\n \n-\t/* Prepare to wait on uaddr. */\n+\t/*\n+\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n+\t * count.\n+\t */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out_key2;\n@@ -2254,7 +2253,9 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n \t * In order for us to be here, we know our q.key == key2, and since\n \t * we took the hb->lock above, we also know that futex_requeue() has\n \t * completed and we no longer have to concern ourselves with a wakeup\n-\t * race with the atomic proxy lock acquition by the requeue code.\n+\t * race with the atomic proxy lock acquisition by the requeue code. The\n+\t * futex_requeue dropped our key1 reference and incremented our key2\n+\t * reference count.\n \t */\n \n \t/* Check if the requeue code acquired the second futex for us. */",
  "project": "linux",
  "commit_id": "7ada876a8703f23befbb20a7465a702ee39b1704",
  "target": 1,
  "func": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n \t}\n \n retry:\n\t/* Prepare to wait on uaddr. */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n \n \t/* If we were woken (and unqueued), we succeeded, whatever. */\n \tret = 0;\n \tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n \tret = -ETIMEDOUT;\n \tif (to && !to->task)\n\t\tgoto out_put_key;\n \n \t/*\n \t * We expect signal_pending(current), but we might be the\n \t * victim of a spurious wakeup as well.\n \t */\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n \t\tgoto retry;\n\t}\n \n \tret = -ERESTARTSYS;\n \tif (!abs_time)\n\t\tgoto out_put_key;\n \n \trestart = &current_thread_info()->restart_block;\n \trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n \n \tret = -ERESTART_RESTARTBLOCK;\n \nout_put_key:\n\tput_futex_key(fshared, &q.key);\n out:\n \tif (to) {\n \t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n",
  "big_vul_idx": 179621,
  "idx": 1335,
  "hash": 173721295716039508648389125595800340840
}