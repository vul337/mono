{
  "id": 470,
  "language": "c",
  "cwe": "CWE-59",
  "commit_url": "https://github.com/ljalves/linux_media/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
  "commit_sha": "295dc39d941dc2ae53d5c170365af4c9d5c16212",
  "commit_msg": "fs: umount on symlink leaks mnt count\n\nCurrently umount on symlink blocks following umount:\n\n/vz is separate mount\n\n# ls /vz/ -al | grep test\ndrwxr-xr-x.  2 root root       4096 Jul 19 01:14 testdir\nlrwxrwxrwx.  1 root root         11 Jul 19 01:16 testlink -> /vz/testdir\n# umount -l /vz/testlink\numount: /vz/testlink: not mounted (expected)\n\n# lsof /vz\n# umount /vz\numount: /vz: device is busy. (unexpected)\n\nIn this case mountpoint_last() gets an extra refcount on path->mnt\n\nSigned-off-by: Vasily Averin <vvs@openvz.org>\nAcked-by: Ian Kent <raven@themaw.net>\nAcked-by: Jeff Layton <jlayton@primarydata.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Christoph Hellwig <hch@lst.de>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/namei.c",
  "func_name": "",
  "raw_func_from_json": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n \tfollow_mount(path);\n \terror = 0;\n out:\n\tterminate_walk(nd);\n\treturn error;\n}\n",
  "diff_func": "@@ -2256,9 +2256,10 @@ mountpoint_last(struct nameidata *nd, struct path *path)\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n-\tpath->mnt = mntget(nd->path.mnt);\n+\tpath->mnt = nd->path.mnt;\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n+\tmntget(path->mnt);\n \tfollow_mount(path);\n \terror = 0;\n out:",
  "project": "linux",
  "commit_id": "295dc39d941dc2ae53d5c170365af4c9d5c16212",
  "target": 1,
  "func": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n \tfollow_mount(path);\n \terror = 0;\n out:\n\tterminate_walk(nd);\n\treturn error;\n}\n",
  "big_vul_idx": 179457,
  "idx": 1220,
  "hash": 289527718022341317804957843288422047472
}