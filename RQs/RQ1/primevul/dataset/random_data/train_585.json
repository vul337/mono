{
  "id": 585,
  "language": "am",
  "cwe": "CWE-59",
  "commit_url": "https://github.com/abrt/abrt/commit/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e",
  "commit_sha": "50ee8130fb4cd4ef1af7682a2c85dd99cb99424e",
  "commit_msg": "a-a-i-d-to-abrt-cache: make own random temporary directory\n\nThe set-user-ID wrapper must use own new temporary directory in order to\navoid security issues with unpacking specially crafted debuginfo\npackages that might be used to create files or symlinks anywhere on the\nfile system as the abrt user.\n\nWithot the forking code the temporary directory would remain on the\nfilesystem in the case where all debuginfo data are already available.\nThis is caused by the fact that the underlying libreport functionality\naccepts path to a desired temporary directory and creates it only if\nnecessary. Otherwise, the directory is not touched at all.\n\nThis commit addresses CVE-2015-5273\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/plugins/Makefile.am",
  "func_name": "",
  "raw_func_from_json": "int main(int argc, char **argv)\n{\n    /* I18n */\n    setlocale(LC_ALL, \"\");\n#if ENABLE_NLS\n    bindtextdomain(PACKAGE, LOCALEDIR);\n    textdomain(PACKAGE);\n#endif\n\n    abrt_init(argv);\n\n    /* Can't keep these strings/structs static: _() doesn't support that */\n    const char *program_usage_string = _(\n        \"& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\\n\"\n        \"\\t[-r REPO]\\n\"\n        \"\\n\"\n        \"Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\\n\"\n        \"ABRT system cache.\"\n    );\n\n    enum {\n        OPT_v = 1 << 0,\n        OPT_y = 1 << 1,\n        OPT_i = 1 << 2,\n        OPT_e = 1 << 3,\n        OPT_r = 1 << 4,\n        OPT_s = 1 << 5,\n    };\n\n    const char *build_ids = \"build_ids\";\n    const char *exact = NULL;\n    const char *repo = NULL;\n    const char *size_mb = NULL;\n\n    struct options program_options[] = {\n        OPT__VERBOSE(&g_verbose),\n        OPT_BOOL  ('y', \"yes\",         NULL,                   _(\"Noninteractive, assume 'Yes' to all questions\")),\n        OPT_STRING('i', \"ids\",   &build_ids, \"BUILD_IDS_FILE\", _(\"- means STDIN, default: build_ids\")),\n        OPT_STRING('e', \"exact\",     &exact, \"EXACT\",          _(\"Download only specified files\")),\n        OPT_STRING('r', \"repo\",       &repo, \"REPO\",           _(\"Pattern to use when searching for repos, default: *debug*\")),\n        OPT_STRING('s', \"size_mb\", &size_mb, \"SIZE_MB\",        _(\"Ignored option\")),\n        OPT_END()\n    };\n    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);\n\n    const gid_t egid = getegid();\n    const gid_t rgid = getgid();\n    const uid_t euid = geteuid();\n    const gid_t ruid = getuid();\n\n    /* We need to open the build ids file under the caller's UID/GID to avoid\n     * information disclosures when reading files with changed UID.\n     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses\n     * STDIN to communicate with the caller. So, the following code opens a\n     * dummy file descriptor to the build ids file and passes the new fd's proc\n     * path to the wrapped program in the ids argument.\n     * The new fd remains opened, the OS will close it for us. */\n    char *build_ids_self_fd = NULL;\n    if (strcmp(\"-\", build_ids) != 0)\n    {\n        if (setregid(egid, rgid) < 0)\n            perror_msg_and_die(\"setregid(egid, rgid)\");\n\n        if (setreuid(euid, ruid) < 0)\n            perror_msg_and_die(\"setreuid(euid, ruid)\");\n\n        const int build_ids_fd = open(build_ids, O_RDONLY);\n\n        if (setregid(rgid, egid) < 0)\n            perror_msg_and_die(\"setregid(rgid, egid)\");\n\n        if (setreuid(ruid, euid) < 0 )\n            perror_msg_and_die(\"setreuid(ruid, euid)\");\n\n        if (build_ids_fd < 0)\n            perror_msg_and_die(\"Failed to open file '%s'\", build_ids);\n\n        /* We are not going to free this memory. There is no place to do so. */\n         build_ids_self_fd = xasprintf(\"/proc/self/fd/%d\", build_ids_fd);\n     }\n \n    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */\n    const char *args[11];\n     {\n         const char *verbs[] = { \"\", \"-v\", \"-vv\", \"-vvv\" };\n         unsigned i = 0;\n        args[i++] = EXECUTABLE;\n        args[i++] = \"--ids\";\n        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : \"-\";\n        if (g_verbose > 0)\n            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];\n        if ((opts & OPT_y))\n            args[i++] = \"-y\";\n        if ((opts & OPT_e))\n        {\n            args[i++] = \"--exact\";\n            args[i++] = exact;\n        }\n        if ((opts & OPT_r))\n        {\n             args[i++] = \"--repo\";\n             args[i++] = repo;\n         }\n         args[i++] = \"--\";\n         args[i] = NULL;\n     }\n\n    /* Switch real user/group to effective ones.\n     * Otherwise yum library gets confused - gets EPERM (why??).\n     */\n    /* do setregid only if we have to, to not upset selinux needlessly */\n    if (egid != rgid)\n        IGNORE_RESULT(setregid(egid, egid));\n    if (euid != ruid)\n    {\n        IGNORE_RESULT(setreuid(euid, euid));\n        /* We are suid'ed! */\n        /* Prevent malicious user from messing up with suid'ed process: */\n#if 1\n\n        static const char *whitelist[] = {\n            \"REPORT_CLIENT_SLAVE\", //  Check if the app is being run as a slave\n            \"LANG\",\n        };\n        const size_t wlsize = sizeof(whitelist)/sizeof(char*);\n        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };\n        char *p = NULL;\n        for (size_t i = 0; i < wlsize; i++)\n            if ((p = getenv(whitelist[i])) != NULL)\n                setlist[i] = xstrdup(p);\n\n        clearenv();\n\n        for (size_t i = 0; i < wlsize; i++)\n            if (setlist[i] != NULL)\n            {\n                xsetenv(whitelist[i], setlist[i]);\n                free(setlist[i]);\n            }\n#else\n        /* Clear dangerous stuff from env */\n        static const char forbid[] =\n            \"LD_LIBRARY_PATH\" \"\\0\"\n            \"LD_PRELOAD\" \"\\0\"\n            \"LD_TRACE_LOADED_OBJECTS\" \"\\0\"\n            \"LD_BIND_NOW\" \"\\0\"\n            \"LD_AOUT_LIBRARY_PATH\" \"\\0\"\n            \"LD_AOUT_PRELOAD\" \"\\0\"\n            \"LD_NOWARN\" \"\\0\"\n            \"LD_KEEPDIR\" \"\\0\"\n        ;\n        const char *p = forbid;\n        do {\n            unsetenv(p);\n            p += strlen(p) + 1;\n        } while (*p);\n#endif\n        /* Set safe PATH */\n        char path_env[] = \"PATH=/usr/sbin:/sbin:/usr/bin:/bin:\"BIN_DIR\":\"SBIN_DIR;\n        if (euid != 0)\n            strcpy(path_env, \"PATH=/usr/bin:/bin:\"BIN_DIR);\n        putenv(path_env);\n\n        /* Use safe umask */\n         umask(0022);\n     }\n \n    execvp(EXECUTABLE, (char **)args);\n    error_msg_and_die(\"Can't execute %s\", EXECUTABLE);\n }\n",
  "diff_func": "@@ -371,6 +371,7 @@ abrt_action_install_debuginfo_to_abrt_cache_CPPFLAGS = \\\n     -D_GNU_SOURCE \\\n     -DBIN_DIR=\\\"$(bindir)\\\" \\\n     -DSBIN_DIR=\\\"$(sbindir)\\\" \\\n+    -DLARGE_DATA_TMP_DIR=\\\"$(LARGE_DATA_TMP_DIR)\\\" \\\n     $(LIBREPORT_CFLAGS) \\\n     -Wall -Wwrite-strings \\\n     -fPIE",
  "project": "abrt",
  "commit_id": "50ee8130fb4cd4ef1af7682a2c85dd99cb99424e",
  "target": 1,
  "func": "int main(int argc, char **argv)\n{\n    /* I18n */\n    setlocale(LC_ALL, \"\");\n#if ENABLE_NLS\n    bindtextdomain(PACKAGE, LOCALEDIR);\n    textdomain(PACKAGE);\n#endif\n\n    abrt_init(argv);\n\n    /* Can't keep these strings/structs static: _() doesn't support that */\n    const char *program_usage_string = _(\n        \"& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\\n\"\n        \"\\t[-r REPO]\\n\"\n        \"\\n\"\n        \"Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\\n\"\n        \"ABRT system cache.\"\n    );\n\n    enum {\n        OPT_v = 1 << 0,\n        OPT_y = 1 << 1,\n        OPT_i = 1 << 2,\n        OPT_e = 1 << 3,\n        OPT_r = 1 << 4,\n        OPT_s = 1 << 5,\n    };\n\n    const char *build_ids = \"build_ids\";\n    const char *exact = NULL;\n    const char *repo = NULL;\n    const char *size_mb = NULL;\n\n    struct options program_options[] = {\n        OPT__VERBOSE(&g_verbose),\n        OPT_BOOL  ('y', \"yes\",         NULL,                   _(\"Noninteractive, assume 'Yes' to all questions\")),\n        OPT_STRING('i', \"ids\",   &build_ids, \"BUILD_IDS_FILE\", _(\"- means STDIN, default: build_ids\")),\n        OPT_STRING('e', \"exact\",     &exact, \"EXACT\",          _(\"Download only specified files\")),\n        OPT_STRING('r', \"repo\",       &repo, \"REPO\",           _(\"Pattern to use when searching for repos, default: *debug*\")),\n        OPT_STRING('s', \"size_mb\", &size_mb, \"SIZE_MB\",        _(\"Ignored option\")),\n        OPT_END()\n    };\n    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);\n\n    const gid_t egid = getegid();\n    const gid_t rgid = getgid();\n    const uid_t euid = geteuid();\n    const gid_t ruid = getuid();\n\n    /* We need to open the build ids file under the caller's UID/GID to avoid\n     * information disclosures when reading files with changed UID.\n     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses\n     * STDIN to communicate with the caller. So, the following code opens a\n     * dummy file descriptor to the build ids file and passes the new fd's proc\n     * path to the wrapped program in the ids argument.\n     * The new fd remains opened, the OS will close it for us. */\n    char *build_ids_self_fd = NULL;\n    if (strcmp(\"-\", build_ids) != 0)\n    {\n        if (setregid(egid, rgid) < 0)\n            perror_msg_and_die(\"setregid(egid, rgid)\");\n\n        if (setreuid(euid, ruid) < 0)\n            perror_msg_and_die(\"setreuid(euid, ruid)\");\n\n        const int build_ids_fd = open(build_ids, O_RDONLY);\n\n        if (setregid(rgid, egid) < 0)\n            perror_msg_and_die(\"setregid(rgid, egid)\");\n\n        if (setreuid(ruid, euid) < 0 )\n            perror_msg_and_die(\"setreuid(ruid, euid)\");\n\n        if (build_ids_fd < 0)\n            perror_msg_and_die(\"Failed to open file '%s'\", build_ids);\n\n        /* We are not going to free this memory. There is no place to do so. */\n         build_ids_self_fd = xasprintf(\"/proc/self/fd/%d\", build_ids_fd);\n     }\n \n    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */\n    const char *args[11];\n     {\n         const char *verbs[] = { \"\", \"-v\", \"-vv\", \"-vvv\" };\n         unsigned i = 0;\n        args[i++] = EXECUTABLE;\n        args[i++] = \"--ids\";\n        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : \"-\";\n        if (g_verbose > 0)\n            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];\n        if ((opts & OPT_y))\n            args[i++] = \"-y\";\n        if ((opts & OPT_e))\n        {\n            args[i++] = \"--exact\";\n            args[i++] = exact;\n        }\n        if ((opts & OPT_r))\n        {\n             args[i++] = \"--repo\";\n             args[i++] = repo;\n         }\n         args[i++] = \"--\";\n         args[i] = NULL;\n     }\n\n    /* Switch real user/group to effective ones.\n     * Otherwise yum library gets confused - gets EPERM (why??).\n     */\n    /* do setregid only if we have to, to not upset selinux needlessly */\n    if (egid != rgid)\n        IGNORE_RESULT(setregid(egid, egid));\n    if (euid != ruid)\n    {\n        IGNORE_RESULT(setreuid(euid, euid));\n        /* We are suid'ed! */\n        /* Prevent malicious user from messing up with suid'ed process: */\n#if 1\n\n        static const char *whitelist[] = {\n            \"REPORT_CLIENT_SLAVE\", //  Check if the app is being run as a slave\n            \"LANG\",\n        };\n        const size_t wlsize = sizeof(whitelist)/sizeof(char*);\n        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };\n        char *p = NULL;\n        for (size_t i = 0; i < wlsize; i++)\n            if ((p = getenv(whitelist[i])) != NULL)\n                setlist[i] = xstrdup(p);\n\n        clearenv();\n\n        for (size_t i = 0; i < wlsize; i++)\n            if (setlist[i] != NULL)\n            {\n                xsetenv(whitelist[i], setlist[i]);\n                free(setlist[i]);\n            }\n#else\n        /* Clear dangerous stuff from env */\n        static const char forbid[] =\n            \"LD_LIBRARY_PATH\" \"\\0\"\n            \"LD_PRELOAD\" \"\\0\"\n            \"LD_TRACE_LOADED_OBJECTS\" \"\\0\"\n            \"LD_BIND_NOW\" \"\\0\"\n            \"LD_AOUT_LIBRARY_PATH\" \"\\0\"\n            \"LD_AOUT_PRELOAD\" \"\\0\"\n            \"LD_NOWARN\" \"\\0\"\n            \"LD_KEEPDIR\" \"\\0\"\n        ;\n        const char *p = forbid;\n        do {\n            unsetenv(p);\n            p += strlen(p) + 1;\n        } while (*p);\n#endif\n        /* Set safe PATH */\n        char path_env[] = \"PATH=/usr/sbin:/sbin:/usr/bin:/bin:\"BIN_DIR\":\"SBIN_DIR;\n        if (euid != 0)\n            strcpy(path_env, \"PATH=/usr/bin:/bin:\"BIN_DIR);\n        putenv(path_env);\n\n        /* Use safe umask */\n         umask(0022);\n     }\n \n    execvp(EXECUTABLE, (char **)args);\n    error_msg_and_die(\"Can't execute %s\", EXECUTABLE);\n }\n",
  "big_vul_idx": 179781,
  "idx": 1466,
  "hash": 92934402516180269336018717421217665238
}