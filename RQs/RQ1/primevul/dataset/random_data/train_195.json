{
  "id": 195,
  "language": "c",
  "cwe": "CWE-59",
  "commit_url": "https://github.com/dlespiau/xserver/commit/6ba44b91e37622ef8c146d8f2ac92d708a18ed34",
  "commit_sha": "6ba44b91e37622ef8c146d8f2ac92d708a18ed34",
  "commit_msg": "Fix CVE-2011-4028: File disclosure vulnerability.\n\nuse O_NOFOLLOW to open the existing lock file, so symbolic links\naren't followed, thus avoid revealing if it point to an existing\nfile.\n\nSigned-off-by: Matthieu Herrb <matthieu.herrb@laas.fr>\nReviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "os/utils.c",
  "func_name": "",
  "raw_func_from_json": "LockServer(void)\n{\n  char tmp[PATH_MAX], pid_str[12];\n  int lfd, i, haslock, l_pid, t;\n  char *tmppath = NULL;\n  int len;\n  char port[20];\n\n  if (nolock) return;\n  /*\n   * Path names\n   */\n  tmppath = LOCK_DIR;\n\n  sprintf(port, \"%d\", atoi(display));\n  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :\n\t\t\t\t\t\tstrlen(LOCK_TMP_PREFIX);\n  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;\n  if (len > sizeof(LockFile))\n    FatalError(\"Display name `%s' is too long\\n\", port);\n  (void)sprintf(tmp, \"%s\" LOCK_TMP_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);\n  (void)sprintf(LockFile, \"%s\" LOCK_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);\n\n  /*\n   * Create a temporary file containing our PID.  Attempt three times\n   * to create the file.\n   */\n  StillLocking = TRUE;\n  i = 0;\n  do {\n    i++;\n    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);\n    if (lfd < 0)\n       sleep(2);\n    else\n       break;\n  } while (i < 3);\n  if (lfd < 0) {\n    unlink(tmp);\n    i = 0;\n    do {\n      i++;\n      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);\n      if (lfd < 0)\n         sleep(2);\n      else\n         break;\n    } while (i < 3);\n  }\n  if (lfd < 0)\n    FatalError(\"Could not create lock file in %s\\n\", tmp);\n  (void) sprintf(pid_str, \"%10ld\\n\", (long)getpid());\n  (void) write(lfd, pid_str, 11);\n  (void) chmod(tmp, 0444);\n  (void) close(lfd);\n\n  /*\n   * OK.  Now the tmp file exists.  Try three times to move it in place\n   * for the lock.\n   */\n  i = 0;\n  haslock = 0;\n  while ((!haslock) && (i++ < 3)) {\n    haslock = (link(tmp,LockFile) == 0);\n    if (haslock) {\n      /*\n       * We're done.\n       */\n      break;\n    }\n    else {\n       /*\n        * Read the pid from the existing file\n        */\n      lfd = open(LockFile, O_RDONLY);\n       if (lfd < 0) {\n         unlink(tmp);\n         FatalError(\"Can't read lock file %s\\n\", LockFile);\n      }\n      pid_str[0] = '\\0';\n      if (read(lfd, pid_str, 11) != 11) {\n        /*\n         * Bogus lock file.\n         */\n        unlink(LockFile);\n        close(lfd);\n        continue;\n      }\n      pid_str[11] = '\\0';\n      sscanf(pid_str, \"%d\", &l_pid);\n      close(lfd);\n\n      /*\n       * Now try to kill the PID to see if it exists.\n       */\n      errno = 0;\n      t = kill(l_pid, 0);\n      if ((t< 0) && (errno == ESRCH)) {\n        /*\n         * Stale lock file.\n         */\n        unlink(LockFile);\n        continue;\n      }\n      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {\n        /*\n         * Process is still active.\n         */\n        unlink(tmp);\n\tFatalError(\"Server is already active for display %s\\n%s %s\\n%s\\n\",\n\t\t   port, \"\\tIf this server is no longer running, remove\",\n\t\t   LockFile, \"\\tand start again.\");\n      }\n    }\n  }\n  unlink(tmp);\n  if (!haslock)\n    FatalError(\"Could not create server lock file: %s\\n\", LockFile);\n  StillLocking = FALSE;\n}\n",
  "diff_func": "@@ -318,7 +318,7 @@ LockServer(void)\n       /*\n        * Read the pid from the existing file\n        */\n-      lfd = open(LockFile, O_RDONLY);\n+      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);\n       if (lfd < 0) {\n         unlink(tmp);\n         FatalError(\"Can't read lock file %s\\n\", LockFile);",
  "project": "xserver",
  "commit_id": "6ba44b91e37622ef8c146d8f2ac92d708a18ed34",
  "target": 1,
  "func": "LockServer(void)\n{\n  char tmp[PATH_MAX], pid_str[12];\n  int lfd, i, haslock, l_pid, t;\n  char *tmppath = NULL;\n  int len;\n  char port[20];\n\n  if (nolock) return;\n  /*\n   * Path names\n   */\n  tmppath = LOCK_DIR;\n\n  sprintf(port, \"%d\", atoi(display));\n  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :\n\t\t\t\t\t\tstrlen(LOCK_TMP_PREFIX);\n  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;\n  if (len > sizeof(LockFile))\n    FatalError(\"Display name `%s' is too long\\n\", port);\n  (void)sprintf(tmp, \"%s\" LOCK_TMP_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);\n  (void)sprintf(LockFile, \"%s\" LOCK_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);\n\n  /*\n   * Create a temporary file containing our PID.  Attempt three times\n   * to create the file.\n   */\n  StillLocking = TRUE;\n  i = 0;\n  do {\n    i++;\n    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);\n    if (lfd < 0)\n       sleep(2);\n    else\n       break;\n  } while (i < 3);\n  if (lfd < 0) {\n    unlink(tmp);\n    i = 0;\n    do {\n      i++;\n      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);\n      if (lfd < 0)\n         sleep(2);\n      else\n         break;\n    } while (i < 3);\n  }\n  if (lfd < 0)\n    FatalError(\"Could not create lock file in %s\\n\", tmp);\n  (void) sprintf(pid_str, \"%10ld\\n\", (long)getpid());\n  (void) write(lfd, pid_str, 11);\n  (void) chmod(tmp, 0444);\n  (void) close(lfd);\n\n  /*\n   * OK.  Now the tmp file exists.  Try three times to move it in place\n   * for the lock.\n   */\n  i = 0;\n  haslock = 0;\n  while ((!haslock) && (i++ < 3)) {\n    haslock = (link(tmp,LockFile) == 0);\n    if (haslock) {\n      /*\n       * We're done.\n       */\n      break;\n    }\n    else {\n       /*\n        * Read the pid from the existing file\n        */\n      lfd = open(LockFile, O_RDONLY);\n       if (lfd < 0) {\n         unlink(tmp);\n         FatalError(\"Can't read lock file %s\\n\", LockFile);\n      }\n      pid_str[0] = '\\0';\n      if (read(lfd, pid_str, 11) != 11) {\n        /*\n         * Bogus lock file.\n         */\n        unlink(LockFile);\n        close(lfd);\n        continue;\n      }\n      pid_str[11] = '\\0';\n      sscanf(pid_str, \"%d\", &l_pid);\n      close(lfd);\n\n      /*\n       * Now try to kill the PID to see if it exists.\n       */\n      errno = 0;\n      t = kill(l_pid, 0);\n      if ((t< 0) && (errno == ESRCH)) {\n        /*\n         * Stale lock file.\n         */\n        unlink(LockFile);\n        continue;\n      }\n      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {\n        /*\n         * Process is still active.\n         */\n        unlink(tmp);\n\tFatalError(\"Server is already active for display %s\\n%s %s\\n%s\\n\",\n\t\t   port, \"\\tIf this server is no longer running, remove\",\n\t\t   LockFile, \"\\tand start again.\");\n      }\n    }\n  }\n  unlink(tmp);\n  if (!haslock)\n    FatalError(\"Could not create server lock file: %s\\n\", LockFile);\n  StillLocking = FALSE;\n}\n",
  "big_vul_idx": 178409,
  "idx": 406,
  "hash": 20891641801682437742426402633668824466
}