{
  "id": 330,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/myliu1999/ffmpeg/commit/3819db745da2ac7fb3faacb116788c32f4753f34",
  "commit_sha": "3819db745da2ac7fb3faacb116788c32f4753f34",
  "commit_msg": "avcodec/rpza: Perform pointer advance and checks before using the pointers\n\nFixes out of array accesses\nFixes Ticket2850\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libavcodec/rpza.c",
  "func_name": "",
  "raw_func_from_json": "static void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n     unsigned short *pixels = (unsigned short *)s->frame.data[0];\n \n     int row_ptr = 0;\n    int pixel_ptr = 0;\n     int block_ptr;\n     int pixel_x, pixel_y;\n     int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n             colorA = AV_RB16 (&s->buf[stream_ptr]);\n             stream_ptr += 2;\n             while (n_blocks--) {\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n                ADVANCE_BLOCK();\n             }\n             break;\n \n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n             if (s->size - stream_ptr < n_blocks * 4)\n                 return;\n             while (n_blocks--) {\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n                ADVANCE_BLOCK();\n             }\n             break;\n \n         /* Fill block with 16 colors */\n         case 0x00:\n             if (s->size - stream_ptr < 16)\n                 return;\n             block_ptr = row_ptr + pixel_ptr;\n             for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                 for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                 }\n                 block_ptr += row_inc;\n             }\n            ADVANCE_BLOCK();\n             break;\n \n         /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}\n",
  "diff_func": "@@ -85,7 +85,7 @@ static void rpza_decode_stream(RpzaContext *s)\n     unsigned short *pixels = (unsigned short *)s->frame.data[0];\n \n     int row_ptr = 0;\n-    int pixel_ptr = 0;\n+    int pixel_ptr = -4;\n     int block_ptr;\n     int pixel_x, pixel_y;\n     int total_blocks;\n@@ -141,6 +141,7 @@ static void rpza_decode_stream(RpzaContext *s)\n             colorA = AV_RB16 (&s->buf[stream_ptr]);\n             stream_ptr += 2;\n             while (n_blocks--) {\n+                ADVANCE_BLOCK()\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     for (pixel_x = 0; pixel_x < 4; pixel_x++){\n@@ -149,7 +150,6 @@ static void rpza_decode_stream(RpzaContext *s)\n                     }\n                     block_ptr += row_inc;\n                 }\n-                ADVANCE_BLOCK();\n             }\n             break;\n \n@@ -188,6 +188,7 @@ static void rpza_decode_stream(RpzaContext *s)\n             if (s->size - stream_ptr < n_blocks * 4)\n                 return;\n             while (n_blocks--) {\n+                ADVANCE_BLOCK();\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     index = s->buf[stream_ptr++];\n@@ -198,14 +199,14 @@ static void rpza_decode_stream(RpzaContext *s)\n                     }\n                     block_ptr += row_inc;\n                 }\n-                ADVANCE_BLOCK();\n             }\n             break;\n \n         /* Fill block with 16 colors */\n         case 0x00:\n             if (s->size - stream_ptr < 16)\n                 return;\n+            ADVANCE_BLOCK();\n             block_ptr = row_ptr + pixel_ptr;\n             for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                 for (pixel_x = 0; pixel_x < 4; pixel_x++){\n@@ -219,7 +220,6 @@ static void rpza_decode_stream(RpzaContext *s)\n                 }\n                 block_ptr += row_inc;\n             }\n-            ADVANCE_BLOCK();\n             break;\n \n         /* Unknown opcode */",
  "project": "FFmpeg",
  "commit_id": "3819db745da2ac7fb3faacb116788c32f4753f34",
  "target": 1,
  "func": "static void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n     unsigned short *pixels = (unsigned short *)s->frame.data[0];\n \n     int row_ptr = 0;\n    int pixel_ptr = 0;\n     int block_ptr;\n     int pixel_x, pixel_y;\n     int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n             colorA = AV_RB16 (&s->buf[stream_ptr]);\n             stream_ptr += 2;\n             while (n_blocks--) {\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n                ADVANCE_BLOCK();\n             }\n             break;\n \n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n             if (s->size - stream_ptr < n_blocks * 4)\n                 return;\n             while (n_blocks--) {\n                 block_ptr = row_ptr + pixel_ptr;\n                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                     index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                     }\n                     block_ptr += row_inc;\n                 }\n                ADVANCE_BLOCK();\n             }\n             break;\n \n         /* Fill block with 16 colors */\n         case 0x00:\n             if (s->size - stream_ptr < 16)\n                 return;\n             block_ptr = row_ptr + pixel_ptr;\n             for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                 for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                 }\n                 block_ptr += row_inc;\n             }\n            ADVANCE_BLOCK();\n             break;\n \n         /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}\n",
  "big_vul_idx": 179103,
  "idx": 909,
  "hash": 269902084834802765407826520872887191624
}