{
  "id": 734,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/libguestfs/hivex/commit/8f1935733b10d974a1a4176d38dd151ed98cf381",
  "commit_sha": "8f1935733b10d974a1a4176d38dd151ed98cf381",
  "commit_msg": "lib/handle.c: Bounds check for block exceeding page length (CVE-2021-3504)\n\nHives are encoded as fixed-sized pages containing smaller variable-\nlength blocks:\n\n  +-------------------+-------------------+-------------------+--\n  | header            |[ blk ][blk][ blk ]|[blk][blk][blk]    |\n  +-------------------+-------------------+-------------------+--\n\nBlocks should not straddle a page boundary.  However because blocks\ncontain a 32 bit length field it is possible to construct an invalid\nhive where the last block in a page overlaps either the next page or\nthe end of the file:\n\n  +-------------------+-------------------+\n  | header            |[ blk ][blk][ blk ..... ]\n  +-------------------+-------------------+\n\nHivex lacked a bounds check and would process the registry.  Because\nthe rest of the code assumes this situation can never happen it was\npossible to have a block containing some field (eg. a registry key\nname) which would extend beyond the end of the file.  Hivex mmaps or\nmallocs the file, causing hivex to read memory beyond the end of the\nmapped region, resulting in reading other memory structures or a\ncrash.  (Writing beyond the end of the mapped region seems to be\nimpossible because we always allocate a new page before writing.)\n\nThis commit adds a check which rejects the malformed registry on\nhivex_open.\n\nCredit: Jeremy Galindo, Sr Security Engineer, Datto.com\nSigned-off-by: Richard W.M. Jones <rjones@redhat.com>\nFixes: CVE-2021-3504\nFixes: https://bugzilla.redhat.com/show_bug.cgi?id=1949687",
  "pr_url": null,
  "pr_info": null,
  "file_name": "lib/handle.c",
  "func_name": "",
  "raw_func_from_json": "hivex_open (const char *filename, int flags)\n{\n  hive_h *h = NULL;\n\n  assert (sizeof (struct ntreg_header) == 0x1000);\n  assert (offsetof (struct ntreg_header, csum) == 0x1fc);\n\n  h = calloc (1, sizeof *h);\n  if (h == NULL)\n    goto error;\n\n  h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;\n\n  const char *debug = getenv (\"HIVEX_DEBUG\");\n  if (debug && STREQ (debug, \"1\"))\n    h->msglvl = 2;\n\n  DEBUG (2, \"created handle %p\", h);\n\n  h->writable = !!(flags & HIVEX_OPEN_WRITE);\n  h->unsafe = !!(flags & HIVEX_OPEN_UNSAFE);\n  h->filename = strdup (filename);\n  if (h->filename == NULL)\n    goto error;\n\n#ifdef O_CLOEXEC\n  h->fd = open (filename, O_RDONLY | O_CLOEXEC | O_BINARY);\n#else\n  h->fd = open (filename, O_RDONLY | O_BINARY);\n#endif\n  if (h->fd == -1)\n    goto error;\n#ifndef O_CLOEXEC\n  fcntl (h->fd, F_SETFD, FD_CLOEXEC);\n#endif\n\n  struct stat statbuf;\n  if (fstat (h->fd, &statbuf) == -1)\n    goto error;\n\n  h->size = statbuf.st_size;\n\n  if (h->size < 0x2000) {\n    SET_ERRNO (EINVAL,\n               \"%s: file is too small to be a Windows NT Registry hive file\",\n               filename);\n    goto error;\n  }\n\n  if (!h->writable) {\n    h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);\n    if (h->addr == MAP_FAILED)\n      goto error;\n\n    DEBUG (2, \"mapped file at %p\", h->addr);\n  } else {\n    h->addr = malloc (h->size);\n    if (h->addr == NULL)\n      goto error;\n\n    if (full_read (h->fd, h->addr, h->size) < h->size)\n      goto error;\n\n    /* We don't need the file descriptor along this path, since we\n     * have read all the data.\n     */\n    if (close (h->fd) == -1)\n      goto error;\n    h->fd = -1;\n  }\n\n  /* Check header. */\n  if (h->hdr->magic[0] != 'r' ||\n      h->hdr->magic[1] != 'e' ||\n      h->hdr->magic[2] != 'g' ||\n      h->hdr->magic[3] != 'f') {\n    SET_ERRNO (ENOTSUP,\n               \"%s: not a Windows NT Registry hive file\", filename);\n    goto error;\n  }\n\n  /* Check major version. */\n  uint32_t major_ver = le32toh (h->hdr->major_ver);\n  if (major_ver != 1) {\n    SET_ERRNO (ENOTSUP,\n               \"%s: hive file major version %\" PRIu32 \" (expected 1)\",\n               filename, major_ver);\n    goto error;\n  }\n\n  h->bitmap = calloc (1 + h->size / 32, 1);\n  if (h->bitmap == NULL)\n    goto error;\n\n  /* Header checksum. */\n  uint32_t sum = header_checksum (h);\n  if (sum != le32toh (h->hdr->csum)) {\n    SET_ERRNO (EINVAL, \"%s: bad checksum in hive header\", filename);\n    goto error;\n  }\n\n  for (int t=0; t<nr_recode_types; t++) {\n    gl_lock_init (h->iconv_cache[t].mutex);\n    h->iconv_cache[t].handle = NULL;\n  }\n\n  /* Last modified time. */\n  h->last_modified = le64toh ((int64_t) h->hdr->last_modified);\n\n  if (h->msglvl >= 2) {\n    char *name = _hivex_recode (h, utf16le_to_utf8,\n                                h->hdr->name, 64, NULL);\n\n    fprintf (stderr,\n             \"hivex_open: header fields:\\n\"\n             \"  file version             %\" PRIu32 \".%\" PRIu32 \"\\n\"\n             \"  sequence nos             %\" PRIu32 \" %\" PRIu32 \"\\n\"\n             \"    (sequences nos should match if hive was synched at shutdown)\\n\"\n             \"  last modified            %\" PRIi64 \"\\n\"\n             \"    (Windows filetime, x 100 ns since 1601-01-01)\\n\"\n             \"  original file name       %s\\n\"\n             \"    (only 32 chars are stored, name is probably truncated)\\n\"\n             \"  root offset              0x%x + 0x1000\\n\"\n             \"  end of last page         0x%x + 0x1000 (total file size 0x%zx)\\n\"\n             \"  checksum                 0x%x (calculated 0x%x)\\n\",\n             major_ver, le32toh (h->hdr->minor_ver),\n             le32toh (h->hdr->sequence1), le32toh (h->hdr->sequence2),\n             h->last_modified,\n             name ? name : \"(conversion failed)\",\n             le32toh (h->hdr->offset),\n             le32toh (h->hdr->blocks), h->size,\n             le32toh (h->hdr->csum), sum);\n    free (name);\n  }\n\n  h->rootoffs = le32toh (h->hdr->offset) + 0x1000;\n  h->endpages = le32toh (h->hdr->blocks) + 0x1000;\n\n  DEBUG (2, \"root offset = 0x%zx\", h->rootoffs);\n\n  /* We'll set this flag when we see a block with the root offset (ie.\n   * the root block).\n   */\n  int seen_root_block = 0, bad_root_block = 0;\n\n  /* Collect some stats. */\n  size_t pages = 0;           /* Number of hbin pages read. */\n  size_t smallest_page = SIZE_MAX, largest_page = 0;\n  size_t blocks = 0;          /* Total number of blocks found. */\n  size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;\n  size_t used_blocks = 0;     /* Total number of used blocks found. */\n  size_t used_size = 0;       /* Total size (bytes) of used blocks. */\n\n  /* Read the pages and blocks.  The aim here is to be robust against\n   * corrupt or malicious registries.  So we make sure the loops\n   * always make forward progress.  We add the address of each block\n   * we read to a hash table so pointers will only reference the start\n   * of valid blocks.\n   */\n  size_t off;\n  struct ntreg_hbin_page *page;\n  for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {\n    if (off >= h->endpages)\n      break;\n\n    page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n    if (page->magic[0] != 'h' ||\n        page->magic[1] != 'b' ||\n        page->magic[2] != 'i' ||\n        page->magic[3] != 'n') {\n\n      if (!h->unsafe) {\n        SET_ERRNO (ENOTSUP,\n                   \"%s: trailing garbage at end of file \"\n                   \"(at 0x%zx, after %zu pages)\",\n                   filename, off, pages);\n        goto error;\n      }\n\n      DEBUG (2,\n             \"page not found at expected offset 0x%zx, \"\n             \"seeking until one is found or EOF is reached\",\n             off);\n\n      int found = 0;\n      while (off < h->size) {\n        off += 0x1000;\n\n        if (off >= h->endpages)\n          break;\n\n        page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n        if (page->magic[0] == 'h' &&\n            page->magic[1] == 'b' &&\n            page->magic[2] == 'i' &&\n            page->magic[3] == 'n') {\n          DEBUG (2, \"found next page by seeking at 0x%zx\", off);\n          found = 1;\n          break;\n        }\n      }\n\n      if (!found) {\n        DEBUG (2, \"page not found and end of pages section reached\");\n        break;\n      }\n    }\n\n    size_t page_size = le32toh (page->page_size);\n    DEBUG (2, \"page at 0x%zx, size %zu\", off, page_size);\n    pages++;\n    if (page_size < smallest_page) smallest_page = page_size;\n    if (page_size > largest_page) largest_page = page_size;\n\n    if (page_size <= sizeof (struct ntreg_hbin_page) ||\n        (page_size & 0x0fff) != 0) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: page size %zu at 0x%zx, bad registry\",\n                 filename, page_size, off);\n      goto error;\n    }\n\n    if (off + page_size > h->size) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: page size %zu at 0x%zx extends beyond end of file, bad registry\",\n                 filename, page_size, off);\n      goto error;\n    }\n\n    size_t page_offset = le32toh(page->offset_first) + 0x1000;\n\n    if (page_offset != off) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: declared page offset (0x%zx) does not match computed \"\n                 \"offset (0x%zx), bad registry\",\n                 filename, page_offset, off);\n      goto error;\n    }\n\n    /* Read the blocks in this page. */\n    size_t blkoff;\n    struct ntreg_hbin_block *block;\n    size_t seg_len;\n    for (blkoff = off + 0x20;\n         blkoff < off + page_size;\n         blkoff += seg_len) {\n      blocks++;\n\n      int is_root = blkoff == h->rootoffs;\n      if (is_root)\n        seen_root_block = 1;\n\n      block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);\n      int used;\n      seg_len = block_len (h, blkoff, &used);\n/* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78665 */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wstrict-overflow\"\n      if (seg_len <= 4 || (seg_len & 3) != 0) {\n#pragma GCC diagnostic pop\n        if (is_root || !h->unsafe) {\n          SET_ERRNO (ENOTSUP,\n                     \"%s, the block at 0x%zx has invalid size %\" PRIu32\n                     \", bad registry\",\n                     filename, blkoff, le32toh (block->seg_len));\n          goto error;\n        } else {\n          DEBUG (2,\n                 \"%s: block at 0x%zx has invalid size %\" PRIu32 \", skipping\",\n                 filename, blkoff, le32toh (block->seg_len));\n          break;\n        }\n      }\n\n      if (h->msglvl >= 2) {\n        unsigned char *id = (unsigned char *) block->id;\n        int id0 = id[0], id1 = id[1];\n\n        fprintf (stderr, \"%s: %s: \"\n                 \"%s block id %d,%d (%c%c) at 0x%zx size %zu%s\\n\",\n                 \"hivex\", __func__,\n                 used ? \"used\" : \"free\",\n                 id0, id1,\n                 c_isprint (id0) ? id0 : '.',\n                 c_isprint (id1) ? id1 : '.',\n                 blkoff,\n                 seg_len, is_root ? \" (root)\" : \"\");\n      }\n\n      blocks_bytes += seg_len;\n      if (seg_len < smallest_block) smallest_block = seg_len;\n      if (seg_len > largest_block) largest_block = seg_len;\n\n      if (is_root && !used)\n        bad_root_block = 1;\n\n      if (used) {\n        used_blocks++;\n        used_size += seg_len;\n\n        /* Root block must be an nk-block. */\n        if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))\n          bad_root_block = 1;\n\n        /* Note this blkoff is a valid address. */\n        BITMAP_SET (h->bitmap, blkoff);\n      }\n    }\n  }\n\n  if (!seen_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: no root block found\", filename);\n    goto error;\n  }\n\n  if (bad_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: bad root block (free or not nk)\", filename);\n    goto error;\n  }\n\n  DEBUG (1, \"successfully read Windows Registry hive file:\\n\"\n         \"  pages:          %zu [sml: %zu, lge: %zu]\\n\"\n         \"  blocks:         %zu [sml: %zu, avg: %zu, lge: %zu]\\n\"\n         \"  blocks used:    %zu\\n\"\n         \"  bytes used:     %zu\",\n         pages, smallest_page, largest_page,\n         blocks, smallest_block, blocks_bytes / blocks, largest_block,\n         used_blocks, used_size);\n\n  return h;\n\n error:;\n  int err = errno;\n  if (h) {\n    free (h->bitmap);\n    if (h->addr && h->size && h->addr != MAP_FAILED) {\n      if (!h->writable)\n        munmap (h->addr, h->size);\n      else\n        free (h->addr);\n    }\n    if (h->fd >= 0)\n      close (h->fd);\n    free (h->filename);\n    free (h);\n  }\n  errno = err;\n  return NULL;\n}",
  "diff_func": "@@ -353,8 +353,8 @@ hivex_open (const char *filename, int flags)\n #pragma GCC diagnostic pop\n         if (is_root || !h->unsafe) {\n           SET_ERRNO (ENOTSUP,\n-                     \"%s, the block at 0x%zx has invalid size %\" PRIu32\n-                     \", bad registry\",\n+                     \"%s, the block at 0x%zx size %\" PRIu32\n+                     \" <= 4 or not a multiple of 4, bad registry\",\n                      filename, blkoff, le32toh (block->seg_len));\n           goto error;\n         } else {\n@@ -365,6 +365,14 @@ hivex_open (const char *filename, int flags)\n         }\n       }\n \n+      if (blkoff + seg_len > off + page_size) {\n+        SET_ERRNO (ENOTSUP,\n+                   \"%s, the block at 0x%zx size %\" PRIu32\n+                   \" extends beyond the current page, bad registry\",\n+                   filename, blkoff, le32toh (block->seg_len));\n+        goto error;\n+      }\n+\n       if (h->msglvl >= 2) {\n         unsigned char *id = (unsigned char *) block->id;\n         int id0 = id[0], id1 = id[1];",
  "func": "hivex_open (const char *filename, int flags)\n{\n  hive_h *h = NULL;\n\n  assert (sizeof (struct ntreg_header) == 0x1000);\n  assert (offsetof (struct ntreg_header, csum) == 0x1fc);\n\n  h = calloc (1, sizeof *h);\n  if (h == NULL)\n    goto error;\n\n  h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;\n\n  const char *debug = getenv (\"HIVEX_DEBUG\");\n  if (debug && STREQ (debug, \"1\"))\n    h->msglvl = 2;\n\n  DEBUG (2, \"created handle %p\", h);\n\n  h->writable = !!(flags & HIVEX_OPEN_WRITE);\n  h->unsafe = !!(flags & HIVEX_OPEN_UNSAFE);\n  h->filename = strdup (filename);\n  if (h->filename == NULL)\n    goto error;\n\n#ifdef O_CLOEXEC\n  h->fd = open (filename, O_RDONLY | O_CLOEXEC | O_BINARY);\n#else\n  h->fd = open (filename, O_RDONLY | O_BINARY);\n#endif\n  if (h->fd == -1)\n    goto error;\n#ifndef O_CLOEXEC\n  fcntl (h->fd, F_SETFD, FD_CLOEXEC);\n#endif\n\n  struct stat statbuf;\n  if (fstat (h->fd, &statbuf) == -1)\n    goto error;\n\n  h->size = statbuf.st_size;\n\n  if (h->size < 0x2000) {\n    SET_ERRNO (EINVAL,\n               \"%s: file is too small to be a Windows NT Registry hive file\",\n               filename);\n    goto error;\n  }\n\n  if (!h->writable) {\n    h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);\n    if (h->addr == MAP_FAILED)\n      goto error;\n\n    DEBUG (2, \"mapped file at %p\", h->addr);\n  } else {\n    h->addr = malloc (h->size);\n    if (h->addr == NULL)\n      goto error;\n\n    if (full_read (h->fd, h->addr, h->size) < h->size)\n      goto error;\n\n    /* We don't need the file descriptor along this path, since we\n     * have read all the data.\n     */\n    if (close (h->fd) == -1)\n      goto error;\n    h->fd = -1;\n  }\n\n  /* Check header. */\n  if (h->hdr->magic[0] != 'r' ||\n      h->hdr->magic[1] != 'e' ||\n      h->hdr->magic[2] != 'g' ||\n      h->hdr->magic[3] != 'f') {\n    SET_ERRNO (ENOTSUP,\n               \"%s: not a Windows NT Registry hive file\", filename);\n    goto error;\n  }\n\n  /* Check major version. */\n  uint32_t major_ver = le32toh (h->hdr->major_ver);\n  if (major_ver != 1) {\n    SET_ERRNO (ENOTSUP,\n               \"%s: hive file major version %\" PRIu32 \" (expected 1)\",\n               filename, major_ver);\n    goto error;\n  }\n\n  h->bitmap = calloc (1 + h->size / 32, 1);\n  if (h->bitmap == NULL)\n    goto error;\n\n  /* Header checksum. */\n  uint32_t sum = header_checksum (h);\n  if (sum != le32toh (h->hdr->csum)) {\n    SET_ERRNO (EINVAL, \"%s: bad checksum in hive header\", filename);\n    goto error;\n  }\n\n  for (int t=0; t<nr_recode_types; t++) {\n    gl_lock_init (h->iconv_cache[t].mutex);\n    h->iconv_cache[t].handle = NULL;\n  }\n\n  /* Last modified time. */\n  h->last_modified = le64toh ((int64_t) h->hdr->last_modified);\n\n  if (h->msglvl >= 2) {\n    char *name = _hivex_recode (h, utf16le_to_utf8,\n                                h->hdr->name, 64, NULL);\n\n    fprintf (stderr,\n             \"hivex_open: header fields:\\n\"\n             \"  file version             %\" PRIu32 \".%\" PRIu32 \"\\n\"\n             \"  sequence nos             %\" PRIu32 \" %\" PRIu32 \"\\n\"\n             \"    (sequences nos should match if hive was synched at shutdown)\\n\"\n             \"  last modified            %\" PRIi64 \"\\n\"\n             \"    (Windows filetime, x 100 ns since 1601-01-01)\\n\"\n             \"  original file name       %s\\n\"\n             \"    (only 32 chars are stored, name is probably truncated)\\n\"\n             \"  root offset              0x%x + 0x1000\\n\"\n             \"  end of last page         0x%x + 0x1000 (total file size 0x%zx)\\n\"\n             \"  checksum                 0x%x (calculated 0x%x)\\n\",\n             major_ver, le32toh (h->hdr->minor_ver),\n             le32toh (h->hdr->sequence1), le32toh (h->hdr->sequence2),\n             h->last_modified,\n             name ? name : \"(conversion failed)\",\n             le32toh (h->hdr->offset),\n             le32toh (h->hdr->blocks), h->size,\n             le32toh (h->hdr->csum), sum);\n    free (name);\n  }\n\n  h->rootoffs = le32toh (h->hdr->offset) + 0x1000;\n  h->endpages = le32toh (h->hdr->blocks) + 0x1000;\n\n  DEBUG (2, \"root offset = 0x%zx\", h->rootoffs);\n\n  /* We'll set this flag when we see a block with the root offset (ie.\n   * the root block).\n   */\n  int seen_root_block = 0, bad_root_block = 0;\n\n  /* Collect some stats. */\n  size_t pages = 0;           /* Number of hbin pages read. */\n  size_t smallest_page = SIZE_MAX, largest_page = 0;\n  size_t blocks = 0;          /* Total number of blocks found. */\n  size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;\n  size_t used_blocks = 0;     /* Total number of used blocks found. */\n  size_t used_size = 0;       /* Total size (bytes) of used blocks. */\n\n  /* Read the pages and blocks.  The aim here is to be robust against\n   * corrupt or malicious registries.  So we make sure the loops\n   * always make forward progress.  We add the address of each block\n   * we read to a hash table so pointers will only reference the start\n   * of valid blocks.\n   */\n  size_t off;\n  struct ntreg_hbin_page *page;\n  for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {\n    if (off >= h->endpages)\n      break;\n\n    page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n    if (page->magic[0] != 'h' ||\n        page->magic[1] != 'b' ||\n        page->magic[2] != 'i' ||\n        page->magic[3] != 'n') {\n\n      if (!h->unsafe) {\n        SET_ERRNO (ENOTSUP,\n                   \"%s: trailing garbage at end of file \"\n                   \"(at 0x%zx, after %zu pages)\",\n                   filename, off, pages);\n        goto error;\n      }\n\n      DEBUG (2,\n             \"page not found at expected offset 0x%zx, \"\n             \"seeking until one is found or EOF is reached\",\n             off);\n\n      int found = 0;\n      while (off < h->size) {\n        off += 0x1000;\n\n        if (off >= h->endpages)\n          break;\n\n        page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n        if (page->magic[0] == 'h' &&\n            page->magic[1] == 'b' &&\n            page->magic[2] == 'i' &&\n            page->magic[3] == 'n') {\n          DEBUG (2, \"found next page by seeking at 0x%zx\", off);\n          found = 1;\n          break;\n        }\n      }\n\n      if (!found) {\n        DEBUG (2, \"page not found and end of pages section reached\");\n        break;\n      }\n    }\n\n    size_t page_size = le32toh (page->page_size);\n    DEBUG (2, \"page at 0x%zx, size %zu\", off, page_size);\n    pages++;\n    if (page_size < smallest_page) smallest_page = page_size;\n    if (page_size > largest_page) largest_page = page_size;\n\n    if (page_size <= sizeof (struct ntreg_hbin_page) ||\n        (page_size & 0x0fff) != 0) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: page size %zu at 0x%zx, bad registry\",\n                 filename, page_size, off);\n      goto error;\n    }\n\n    if (off + page_size > h->size) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: page size %zu at 0x%zx extends beyond end of file, bad registry\",\n                 filename, page_size, off);\n      goto error;\n    }\n\n    size_t page_offset = le32toh(page->offset_first) + 0x1000;\n\n    if (page_offset != off) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: declared page offset (0x%zx) does not match computed \"\n                 \"offset (0x%zx), bad registry\",\n                 filename, page_offset, off);\n      goto error;\n    }\n\n    /* Read the blocks in this page. */\n    size_t blkoff;\n    struct ntreg_hbin_block *block;\n    size_t seg_len;\n    for (blkoff = off + 0x20;\n         blkoff < off + page_size;\n         blkoff += seg_len) {\n      blocks++;\n\n      int is_root = blkoff == h->rootoffs;\n      if (is_root)\n        seen_root_block = 1;\n\n      block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);\n      int used;\n      seg_len = block_len (h, blkoff, &used);\n/* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78665 */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wstrict-overflow\"\n      if (seg_len <= 4 || (seg_len & 3) != 0) {\n#pragma GCC diagnostic pop\n        if (is_root || !h->unsafe) {\n          SET_ERRNO (ENOTSUP,\n                     \"%s, the block at 0x%zx has invalid size %\" PRIu32\n                     \", bad registry\",\n                     filename, blkoff, le32toh (block->seg_len));\n          goto error;\n        } else {\n          DEBUG (2,\n                 \"%s: block at 0x%zx has invalid size %\" PRIu32 \", skipping\",\n                 filename, blkoff, le32toh (block->seg_len));\n          break;\n        }\n      }\n\n      if (h->msglvl >= 2) {\n        unsigned char *id = (unsigned char *) block->id;\n        int id0 = id[0], id1 = id[1];\n\n        fprintf (stderr, \"%s: %s: \"\n                 \"%s block id %d,%d (%c%c) at 0x%zx size %zu%s\\n\",\n                 \"hivex\", __func__,\n                 used ? \"used\" : \"free\",\n                 id0, id1,\n                 c_isprint (id0) ? id0 : '.',\n                 c_isprint (id1) ? id1 : '.',\n                 blkoff,\n                 seg_len, is_root ? \" (root)\" : \"\");\n      }\n\n      blocks_bytes += seg_len;\n      if (seg_len < smallest_block) smallest_block = seg_len;\n      if (seg_len > largest_block) largest_block = seg_len;\n\n      if (is_root && !used)\n        bad_root_block = 1;\n\n      if (used) {\n        used_blocks++;\n        used_size += seg_len;\n\n        /* Root block must be an nk-block. */\n        if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))\n          bad_root_block = 1;\n\n        /* Note this blkoff is a valid address. */\n        BITMAP_SET (h->bitmap, blkoff);\n      }\n    }\n  }\n\n  if (!seen_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: no root block found\", filename);\n    goto error;\n  }\n\n  if (bad_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: bad root block (free or not nk)\", filename);\n    goto error;\n  }\n\n  DEBUG (1, \"successfully read Windows Registry hive file:\\n\"\n         \"  pages:          %zu [sml: %zu, lge: %zu]\\n\"\n         \"  blocks:         %zu [sml: %zu, avg: %zu, lge: %zu]\\n\"\n         \"  blocks used:    %zu\\n\"\n         \"  bytes used:     %zu\",\n         pages, smallest_page, largest_page,\n         blocks, smallest_block, blocks_bytes / blocks, largest_block,\n         used_blocks, used_size);\n\n  return h;\n\n error:;\n  int err = errno;\n  if (h) {\n    free (h->bitmap);\n    if (h->addr && h->size && h->addr != MAP_FAILED) {\n      if (!h->writable)\n        munmap (h->addr, h->size);\n      else\n        free (h->addr);\n    }\n    if (h->fd >= 0)\n      close (h->fd);\n    free (h->filename);\n    free (h);\n  }\n  errno = err;\n  return NULL;\n}",
  "project": "hivex",
  "hash": 255254112256589566988814098457378736252,
  "size": 349,
  "commit_id": "8f1935733b10d974a1a4176d38dd151ed98cf381",
  "message": "lib/handle.c: Bounds check for block exceeding page length (CVE-2021-3504)\n\nHives are encoded as fixed-sized pages containing smaller variable-\nlength blocks:\n\n  +-------------------+-------------------+-------------------+--\n  | header            |[ blk ][blk][ blk ]|[blk][blk][blk]    |\n  +-------------------+-------------------+-------------------+--\n\nBlocks should not straddle a page boundary.  However because blocks\ncontain a 32 bit length field it is possible to construct an invalid\nhive where the last block in a page overlaps either the next page or\nthe end of the file:\n\n  +-------------------+-------------------+\n  | header            |[ blk ][blk][ blk ..... ]\n  +-------------------+-------------------+\n\nHivex lacked a bounds check and would process the registry.  Because\nthe rest of the code assumes this situation can never happen it was\npossible to have a block containing some field (eg. a registry key\nname) which would extend beyond the end of the file.  Hivex mmaps or\nmallocs the file, causing hivex to read memory beyond the end of the\nmapped region, resulting in reading other memory structures or a\ncrash.  (Writing beyond the end of the mapped region seems to be\nimpossible because we always allocate a new page before writing.)\n\nThis commit adds a check which rejects the malformed registry on\nhivex_open.\n\nCredit: Jeremy Galindo, Sr Security Engineer, Datto.com\nSigned-off-by: Richard W.M. Jones <rjones@redhat.com>\nFixes: CVE-2021-3504\nFixes: https://bugzilla.redhat.com/show_bug.cgi?id=1949687",
  "target": 1,
  "dataset": "other",
  "idx": 205584
}