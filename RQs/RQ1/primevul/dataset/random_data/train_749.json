{
  "id": 749,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/MrE-Fog/krb521/commit/08c642c09c38a9c6454ab43a9b53b2a89b9eef99",
  "commit_sha": "08c642c09c38a9c6454ab43a9b53b2a89b9eef99",
  "commit_msg": "Fix LDAP null deref on empty arg [CVE-2016-3119]\n\nIn the LDAP KDB module's process_db_args(), strtok_r() may return NULL\nif there is an empty string in the db_args array.  Check for this case\nand avoid dereferencing a null pointer.\n\nCVE-2016-3119:\n\nIn MIT krb5 1.6 and later, an authenticated attacker with permission\nto modify a principal entry can cause kadmind to dereference a null\npointer by supplying an empty DB argument to the modify_principal\ncommand, if kadmind is configured to use the LDAP KDB module.\n\n    CVSSv2 Vector: AV:N/AC:H/Au:S/C:N/I:N/A:C/E:H/RL:OF/RC:ND\n\nticket: 8383 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next\ntags: pullup",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c",
  "func_name": "",
  "raw_func_from_json": "process_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n                OPERATION optype)\n{\n    int                   i=0;\n    krb5_error_code       st=0;\n    char                  *arg=NULL, *arg_val=NULL;\n    char                  **dptr=NULL;\n    unsigned int          arg_val_len=0;\n\n     if (db_args) {\n         for (i=0; db_args[i]; ++i) {\n             arg = strtok_r(db_args[i], \"=\", &arg_val);\n             if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                 dptr = &xargs->tktpolicydn;\n             } else {\n                if (strcmp(arg, USERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL ||\n                        xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->dn;\n                } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->containerdn;\n                } else if (strcmp(arg, LINKDN_ARG) == 0) {\n                    if (xargs->dn != NULL || xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->linkdn;\n                } else {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"unknown option: %s\"), arg);\n                    goto cleanup;\n                }\n\n                xargs->dn_from_kbd = TRUE;\n                if (arg_val == NULL || strlen(arg_val) == 0) {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                    goto cleanup;\n                }\n            }\n\n            if (arg_val == NULL) {\n                st = EINVAL;\n                k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                goto cleanup;\n            }\n            arg_val_len = strlen(arg_val) + 1;\n\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                if ((st = krb5_ldap_name_to_policydn (context,\n                                                      arg_val,\n                                                      dptr)) != 0)\n                    goto cleanup;\n            } else {\n                *dptr = k5memdup(arg_val, arg_val_len, &st);\n                if (*dptr == NULL)\n                    goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return st;\n}\n",
  "diff_func": "@@ -296,6 +296,7 @@ process_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n     if (db_args) {\n         for (i=0; db_args[i]; ++i) {\n             arg = strtok_r(db_args[i], \"=\", &arg_val);\n+            arg = (arg != NULL) ? arg : \"\";\n             if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                 dptr = &xargs->tktpolicydn;\n             } else {",
  "project": "krb5",
  "commit_id": "08c642c09c38a9c6454ab43a9b53b2a89b9eef99",
  "target": 1,
  "func": "process_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n                OPERATION optype)\n{\n    int                   i=0;\n    krb5_error_code       st=0;\n    char                  *arg=NULL, *arg_val=NULL;\n    char                  **dptr=NULL;\n    unsigned int          arg_val_len=0;\n\n     if (db_args) {\n         for (i=0; db_args[i]; ++i) {\n             arg = strtok_r(db_args[i], \"=\", &arg_val);\n             if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                 dptr = &xargs->tktpolicydn;\n             } else {\n                if (strcmp(arg, USERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL ||\n                        xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->dn;\n                } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->containerdn;\n                } else if (strcmp(arg, LINKDN_ARG) == 0) {\n                    if (xargs->dn != NULL || xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->linkdn;\n                } else {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"unknown option: %s\"), arg);\n                    goto cleanup;\n                }\n\n                xargs->dn_from_kbd = TRUE;\n                if (arg_val == NULL || strlen(arg_val) == 0) {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                    goto cleanup;\n                }\n            }\n\n            if (arg_val == NULL) {\n                st = EINVAL;\n                k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                goto cleanup;\n            }\n            arg_val_len = strlen(arg_val) + 1;\n\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                if ((st = krb5_ldap_name_to_policydn (context,\n                                                      arg_val,\n                                                      dptr)) != 0)\n                    goto cleanup;\n            } else {\n                *dptr = k5memdup(arg_val, arg_val_len, &st);\n                if (*dptr == NULL)\n                    goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return st;\n}\n",
  "big_vul_idx": 180551,
  "idx": 2132,
  "hash": 14345514354298604134499839020667775167
}