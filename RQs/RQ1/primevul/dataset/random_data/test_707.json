{
  "id": 707,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ibouazizi/gpac-mvhevc/commit/dc7de8d3d604426c7a6e628d90cb9fb88e7b4c2c",
  "commit_sha": "dc7de8d3d604426c7a6e628d90cb9fb88e7b4c2c",
  "commit_msg": "fixed #2212",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/bifs/field_decode.c",
  "func_name": "",
  "raw_func_from_json": "GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\tlast = NULL;\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n\n\t\t\t\tif (node) {\n\t\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*proto coding*/\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\t/*according to the spec, the QP applies to the current node itself, not just children.\n\t\tIf IsLocal is TRUE remove the node*/\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t\t} else {\n\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t\t}\n\t\t}\n\t}\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn GF_OK;\n}",
  "diff_func": "@@ -427,64 +427,71 @@ GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node,\n \t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n \t\t\tif (e) return e;\n \t\t}\n-\t} else {\n-\t\tlast = NULL;\n-\t\tfor (i=0; i<nbFields; i++) {\n-\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n-\t\t\tif (new_node) {\n-\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n-\t\t\t\tif (e) return e;\n-\n-\t\t\t\tif (node) {\n-\t\t\t\t\t/*special case for QP, register as the current QP*/\n-\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n-\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n-\t\t\t\t\t\t/*we have a QP in the same scope, remove previous\n-\t\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n-\t\t\t\t\t\twhether QP is cumulative or not*/\n-\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n+\t\treturn GF_OK;\n+\t}\n \n-\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n-\t\t\t\t\t\tif (e) return e;\n-\t\t\t\t\t\tqp_on = 1;\n-\t\t\t\t\t\tif (qp_local) qp_local = 2;\n-\t\t\t\t\t\tif (codec->force_keep_qp) {\n-\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n-\t\t\t\t\t\t\tif (e) return e;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n-\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n+\te = GF_OK;\n+\tlast = NULL;\n+\tfor (i=0; i<nbFields; i++) {\n+\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n+\t\tif (new_node) {\n+\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n+\t\t\tif (e) goto exit;\n+\n+\t\t\tif (node) {\n+\t\t\t\t/*special case for QP, register as the current QP*/\n+\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n+\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n+\t\t\t\t\t/*we have a QP in the same scope, remove previous\n+\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n+\t\t\t\t\twhether QP is cumulative or not*/\n+\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n+\n+\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n+\t\t\t\t\tif (e) goto exit;\n+\t\t\t\t\tqp_on = 1;\n+\t\t\t\t\tif (qp_local) qp_local = 2;\n+\t\t\t\t\tif (codec->force_keep_qp) {\n \t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n-\t\t\t\t\t\tif (e) return e;\n+\t\t\t\t\t\tif (e) goto exit;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tgf_node_register(new_node, NULL);\n+\t\t\t\t\t\tgf_node_unregister(new_node, node);\n \t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n+\t\t\t\t\tif (e) goto exit;\n \t\t\t\t}\n-\t\t\t\t/*proto coding*/\n-\t\t\t\telse if (codec->pCurrentProto) {\n-\t\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n-\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n-\t\t\t\t\tif (e) return e;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n \t\t\t}\n+\t\t\t/*proto coding*/\n+\t\t\telse if (codec->pCurrentProto) {\n+\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n+\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n+\t\t\t\tif (e)goto exit;\n+\t\t\t}\n+\t\t} else {\n+\t\t\te = codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n+\t\t\tgoto exit;\n \t\t}\n-\t\t/*according to the spec, the QP applies to the current node itself, not just children.\n-\t\tIf IsLocal is TRUE remove the node*/\n-\t\tif (qp_on && qp_local) {\n-\t\t\tif (qp_local == 2) {\n+\t}\n+\n+exit:\n+\n+\t/*according to the spec, the QP applies to the current node itself, not just children.\n+\tIf IsLocal is TRUE remove the node*/\n+\tif (qp_on && qp_local) {\n+\t\tif (qp_local == 2) {\n //\t\t\t\tqp_local = 1;\n-\t\t\t} else {\n-\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n-\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n+\t\t} else {\n+\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n+\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n //\t\t\t\tqp_local = 0;\n-\t\t\t}\n \t\t}\n \t}\n+\n \t/*finally delete the QP if any (local or not) as we get out of this node*/\n \tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n-\treturn GF_OK;\n+\treturn e;\n }\n \n ",
  "func": "GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\tlast = NULL;\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n\n\t\t\t\tif (node) {\n\t\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*proto coding*/\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\t/*according to the spec, the QP applies to the current node itself, not just children.\n\t\tIf IsLocal is TRUE remove the node*/\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t\t} else {\n\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t\t}\n\t\t}\n\t}\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn GF_OK;\n}",
  "project": "gpac",
  "hash": 299257728605197431750731122978204720459,
  "size": 96,
  "commit_id": "dc7de8d3d604426c7a6e628d90cb9fb88e7b4c2c",
  "message": "fixed #2212",
  "target": 1,
  "dataset": "other",
  "idx": 197499
}