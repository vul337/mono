{
  "id": 704,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/zidel/wireshark/commit/3270dfac43da861c714df76513456b46765ff47f",
  "commit_sha": "3270dfac43da861c714df76513456b46765ff47f",
  "commit_msg": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12394\nChange-Id: I4b19b95f2e1ffc96dac5c91bff6698c246f52007\nReviewed-on: https://code.wireshark.org/review/15230\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "wiretap/toshiba.c",
  "func_name": "",
  "raw_func_from_json": "parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n\tguint\tpkt_len;\n\tint\tpktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Find text in line after \"[No.\". Limit the length of the\n\t * two strings since we have fixed buffers for channel[] and\n\t * direction[] */\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn FALSE;\n\t}\n\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\n\t * this will be the next line. But if you save your telnet session\n\t * to a file from within a Windows-based telnet client, it may\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\n\t * Here we assume that 80 columns will be the minimum size, and that\n\t * the OFFSET line is not broken in the middle. It's the previous\n\t * line that is normally long and can thus be broken at column 80.\n\t */\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (guint8)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n",
  "diff_func": "@@ -248,8 +248,7 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n-\tguint\tpkt_len;\n-\tint\tpktnum, hr, min, sec, csec;\n+\tint\tpkt_len, pktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n@@ -301,12 +300,17 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n-\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n+\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying",
  "project": "wireshark",
  "commit_id": "3270dfac43da861c714df76513456b46765ff47f",
  "target": 1,
  "func": "parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n\tguint\tpkt_len;\n\tint\tpktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/* Find text in line after \"[No.\". Limit the length of the\n\t * two strings since we have fixed buffers for channel[] and\n\t * direction[] */\n\tnum_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\",\n\t\t\t&pktnum, &hr, &min, &sec, &csec, channel, direction);\n\n\tif (num_items_scanned != 7) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: record header isn't valid\");\n\t\treturn FALSE;\n\t}\n\n\t/* Scan lines until we find the OFFSET line. In a \"telnet\" trace,\n\t * this will be the next line. But if you save your telnet session\n\t * to a file from within a Windows-based telnet client, it may\n\t * put in line breaks at 80 columns (or however big your \"telnet\" box\n\t * is). CRT (a Windows telnet app from VanDyke) does this.\n\t * Here we assume that 80 columns will be the minimum size, and that\n\t * the OFFSET line is not broken in the middle. It's the previous\n\t * line that is normally long and can thus be broken at column 80.\n\t */\n\tdo {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\tswitch (channel[0]) {\n\t\tcase 'B':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = (guint8)\n\t\t\t    strtol(&channel[1], NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ISDN;\n\t\t\tpseudo_header->isdn.uton = (direction[0] == 'T');\n\t\t\tpseudo_header->isdn.channel = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (!parse_single_hex_dump_line(line, pd, i * 16)) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"toshiba: hex dump not valid\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n",
  "big_vul_idx": 180323,
  "idx": 1926,
  "hash": 46587021802752220107433725147046834904
}