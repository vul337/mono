{
  "id": 824,
  "language": "cpp",
  "cwe": "",
  "commit_url": "https://github.com/2lambda123/dragonwell-project-dragonwell8/commit/1dafef08cc922ee85a8e216387100dc681a5484d",
  "commit_sha": "1dafef08cc922ee85a8e216387100dc681a5484d",
  "commit_msg": "8281859: Improve class compilation\n\nReviewed-by: andrew\nBackport-of: 3ac62a66efd05d0842076dd4cfbea0e53b12630f",
  "pr_url": null,
  "pr_info": null,
  "file_name": "hotspot/src/share/vm/ci/ciEnv.cpp",
  "func_name": "",
  "raw_func_from_json": "ciConstant ciEnv::get_constant_by_index_impl(constantPoolHandle cpool,\n                                             int pool_index, int cache_index,\n                                             ciInstanceKlass* accessor) {\n  bool ignore_will_link;\n  EXCEPTION_CONTEXT;\n  int index = pool_index;\n  if (cache_index >= 0) {\n    assert(index < 0, \"only one kind of index at a time\");\n    oop obj = cpool->resolved_references()->obj_at(cache_index);\n    if (obj != NULL) {\n      ciObject* ciobj = get_object(obj);\n      if (ciobj->is_array()) {\n        return ciConstant(T_ARRAY, ciobj);\n      } else {\n        assert(ciobj->is_instance(), \"should be an instance\");\n        return ciConstant(T_OBJECT, ciobj);\n      }\n    }\n    index = cpool->object_to_cp_index(cache_index);\n  }\n  constantTag tag = cpool->tag_at(index);\n  if (tag.is_int()) {\n    return ciConstant(T_INT, (jint)cpool->int_at(index));\n  } else if (tag.is_long()) {\n    return ciConstant((jlong)cpool->long_at(index));\n  } else if (tag.is_float()) {\n    return ciConstant((jfloat)cpool->float_at(index));\n  } else if (tag.is_double()) {\n    return ciConstant((jdouble)cpool->double_at(index));\n  } else if (tag.is_string()) {\n    oop string = NULL;\n    assert(cache_index >= 0, \"should have a cache index\");\n    if (cpool->is_pseudo_string_at(index)) {\n      string = cpool->pseudo_string_at(index, cache_index);\n    } else {\n      string = cpool->string_at(index, cache_index, THREAD);\n      if (HAS_PENDING_EXCEPTION) {\n        CLEAR_PENDING_EXCEPTION;\n        record_out_of_memory_failure();\n        return ciConstant();\n      }\n    }\n    ciObject* constant = get_object(string);\n    if (constant->is_array()) {\n      return ciConstant(T_ARRAY, constant);\n    } else {\n      assert (constant->is_instance(), \"must be an instance, or not? \");\n      return ciConstant(T_OBJECT, constant);\n    }\n  } else if (tag.is_klass() || tag.is_unresolved_klass()) {\n    // 4881222: allow ldc to take a class type\n    ciKlass* klass = get_klass_by_index_impl(cpool, index, ignore_will_link, accessor);\n    if (HAS_PENDING_EXCEPTION) {\n      CLEAR_PENDING_EXCEPTION;\n      record_out_of_memory_failure();\n      return ciConstant();\n    }\n    assert (klass->is_instance_klass() || klass->is_array_klass(),\n            \"must be an instance or array klass \");\n    return ciConstant(T_OBJECT, klass->java_mirror());\n  } else if (tag.is_method_type()) {\n    // must execute Java code to link this CP entry into cache[i].f1\n    ciSymbol* signature = get_symbol(cpool->method_type_signature_at(index));\n    ciObject* ciobj = get_unloaded_method_type_constant(signature);\n    return ciConstant(T_OBJECT, ciobj);\n  } else if (tag.is_method_handle()) {\n    // must execute Java code to link this CP entry into cache[i].f1\n    int ref_kind        = cpool->method_handle_ref_kind_at(index);\n    int callee_index    = cpool->method_handle_klass_index_at(index);\n    ciKlass* callee     = get_klass_by_index_impl(cpool, callee_index, ignore_will_link, accessor);\n    ciSymbol* name      = get_symbol(cpool->method_handle_name_ref_at(index));\n    ciSymbol* signature = get_symbol(cpool->method_handle_signature_ref_at(index));\n    ciObject* ciobj     = get_unloaded_method_handle_constant(callee, name, signature, ref_kind);\n    return ciConstant(T_OBJECT, ciobj);\n  } else {\n    ShouldNotReachHere();\n    return ciConstant();\n  }\n}",
  "diff_func": "@@ -587,7 +587,6 @@ ciKlass* ciEnv::get_klass_by_index(constantPoolHandle cpool,\n ciConstant ciEnv::get_constant_by_index_impl(constantPoolHandle cpool,\n                                              int pool_index, int cache_index,\n                                              ciInstanceKlass* accessor) {\n-  bool ignore_will_link;\n   EXCEPTION_CONTEXT;\n   int index = pool_index;\n   if (cache_index >= 0) {\n@@ -634,23 +633,25 @@ ciConstant ciEnv::get_constant_by_index_impl(constantPoolHandle cpool,\n       return ciConstant(T_OBJECT, constant);\n     }\n   } else if (tag.is_klass() || tag.is_unresolved_klass()) {\n-    // 4881222: allow ldc to take a class type\n-    ciKlass* klass = get_klass_by_index_impl(cpool, index, ignore_will_link, accessor);\n+    bool will_link;\n+    ciKlass* klass = get_klass_by_index_impl(cpool, index, will_link, accessor);\n     if (HAS_PENDING_EXCEPTION) {\n       CLEAR_PENDING_EXCEPTION;\n       record_out_of_memory_failure();\n       return ciConstant();\n     }\n     assert (klass->is_instance_klass() || klass->is_array_klass(),\n             \"must be an instance or array klass \");\n-    return ciConstant(T_OBJECT, klass->java_mirror());\n+    ciInstance* mirror = (will_link ? klass->java_mirror() : get_unloaded_klass_mirror(klass));\n+    return ciConstant(T_OBJECT, mirror);\n   } else if (tag.is_method_type()) {\n     // must execute Java code to link this CP entry into cache[i].f1\n     ciSymbol* signature = get_symbol(cpool->method_type_signature_at(index));\n     ciObject* ciobj = get_unloaded_method_type_constant(signature);\n     return ciConstant(T_OBJECT, ciobj);\n   } else if (tag.is_method_handle()) {\n     // must execute Java code to link this CP entry into cache[i].f1\n+    bool ignore_will_link;\n     int ref_kind        = cpool->method_handle_ref_kind_at(index);\n     int callee_index    = cpool->method_handle_klass_index_at(index);\n     ciKlass* callee     = get_klass_by_index_impl(cpool, callee_index, ignore_will_link, accessor);",
  "func": "ciConstant ciEnv::get_constant_by_index_impl(constantPoolHandle cpool,\n                                             int pool_index, int cache_index,\n                                             ciInstanceKlass* accessor) {\n  bool ignore_will_link;\n  EXCEPTION_CONTEXT;\n  int index = pool_index;\n  if (cache_index >= 0) {\n    assert(index < 0, \"only one kind of index at a time\");\n    oop obj = cpool->resolved_references()->obj_at(cache_index);\n    if (obj != NULL) {\n      ciObject* ciobj = get_object(obj);\n      if (ciobj->is_array()) {\n        return ciConstant(T_ARRAY, ciobj);\n      } else {\n        assert(ciobj->is_instance(), \"should be an instance\");\n        return ciConstant(T_OBJECT, ciobj);\n      }\n    }\n    index = cpool->object_to_cp_index(cache_index);\n  }\n  constantTag tag = cpool->tag_at(index);\n  if (tag.is_int()) {\n    return ciConstant(T_INT, (jint)cpool->int_at(index));\n  } else if (tag.is_long()) {\n    return ciConstant((jlong)cpool->long_at(index));\n  } else if (tag.is_float()) {\n    return ciConstant((jfloat)cpool->float_at(index));\n  } else if (tag.is_double()) {\n    return ciConstant((jdouble)cpool->double_at(index));\n  } else if (tag.is_string()) {\n    oop string = NULL;\n    assert(cache_index >= 0, \"should have a cache index\");\n    if (cpool->is_pseudo_string_at(index)) {\n      string = cpool->pseudo_string_at(index, cache_index);\n    } else {\n      string = cpool->string_at(index, cache_index, THREAD);\n      if (HAS_PENDING_EXCEPTION) {\n        CLEAR_PENDING_EXCEPTION;\n        record_out_of_memory_failure();\n        return ciConstant();\n      }\n    }\n    ciObject* constant = get_object(string);\n    if (constant->is_array()) {\n      return ciConstant(T_ARRAY, constant);\n    } else {\n      assert (constant->is_instance(), \"must be an instance, or not? \");\n      return ciConstant(T_OBJECT, constant);\n    }\n  } else if (tag.is_klass() || tag.is_unresolved_klass()) {\n    // 4881222: allow ldc to take a class type\n    ciKlass* klass = get_klass_by_index_impl(cpool, index, ignore_will_link, accessor);\n    if (HAS_PENDING_EXCEPTION) {\n      CLEAR_PENDING_EXCEPTION;\n      record_out_of_memory_failure();\n      return ciConstant();\n    }\n    assert (klass->is_instance_klass() || klass->is_array_klass(),\n            \"must be an instance or array klass \");\n    return ciConstant(T_OBJECT, klass->java_mirror());\n  } else if (tag.is_method_type()) {\n    // must execute Java code to link this CP entry into cache[i].f1\n    ciSymbol* signature = get_symbol(cpool->method_type_signature_at(index));\n    ciObject* ciobj = get_unloaded_method_type_constant(signature);\n    return ciConstant(T_OBJECT, ciobj);\n  } else if (tag.is_method_handle()) {\n    // must execute Java code to link this CP entry into cache[i].f1\n    int ref_kind        = cpool->method_handle_ref_kind_at(index);\n    int callee_index    = cpool->method_handle_klass_index_at(index);\n    ciKlass* callee     = get_klass_by_index_impl(cpool, callee_index, ignore_will_link, accessor);\n    ciSymbol* name      = get_symbol(cpool->method_handle_name_ref_at(index));\n    ciSymbol* signature = get_symbol(cpool->method_handle_signature_ref_at(index));\n    ciObject* ciobj     = get_unloaded_method_handle_constant(callee, name, signature, ref_kind);\n    return ciConstant(T_OBJECT, ciobj);\n  } else {\n    ShouldNotReachHere();\n    return ciConstant();\n  }\n}",
  "project": "jdk8u",
  "hash": 213862644864366524796846638949126077190,
  "size": 79,
  "commit_id": "1dafef08cc922ee85a8e216387100dc681a5484d",
  "message": "8281859: Improve class compilation\n\nReviewed-by: andrew\nBackport-of: 3ac62a66efd05d0842076dd4cfbea0e53b12630f",
  "target": 1,
  "dataset": "other",
  "idx": 200680
}