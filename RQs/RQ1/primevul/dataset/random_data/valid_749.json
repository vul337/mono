{
  "id": 749,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/okt-ilyarepk/libslirp/commit/126c04acbabd7ad32c2b018fe10dfac2a3bc1210",
  "commit_sha": "126c04acbabd7ad32c2b018fe10dfac2a3bc1210",
  "commit_msg": "Fix heap overflow in ip_reass on big packet input\n\nWhen the first fragment does not fit in the preallocated buffer, q will\nalready be pointing to the ext buffer, so we mustn't try to update it.\n\nSigned-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/ip_input.c",
  "func_name": "",
  "raw_func_from_json": "static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)\n{\n    register struct mbuf *m = dtom(slirp, ip);\n    register struct ipasfrag *q;\n    int hlen = ip->ip_hl << 2;\n    int i, next;\n\n    DEBUG_CALL(\"ip_reass\");\n    DEBUG_ARG(\"ip = %p\", ip);\n    DEBUG_ARG(\"fp = %p\", fp);\n    DEBUG_ARG(\"m = %p\", m);\n\n    /*\n     * Presence of header sizes in mbufs\n     * would confuse code below.\n     * Fragment m_data is concatenated.\n     */\n    m->m_data += hlen;\n    m->m_len -= hlen;\n\n    /*\n     * If first fragment to arrive, create a reassembly queue.\n     */\n    if (fp == NULL) {\n        struct mbuf *t = m_get(slirp);\n\n        if (t == NULL) {\n            goto dropfrag;\n        }\n        fp = mtod(t, struct ipq *);\n        insque(&fp->ip_link, &slirp->ipq.ip_link);\n        fp->ipq_ttl = IPFRAGTTL;\n        fp->ipq_p = ip->ip_p;\n        fp->ipq_id = ip->ip_id;\n        fp->frag_link.next = fp->frag_link.prev = &fp->frag_link;\n        fp->ipq_src = ip->ip_src;\n        fp->ipq_dst = ip->ip_dst;\n        q = (struct ipasfrag *)fp;\n        goto insert;\n    }\n\n    /*\n     * Find a segment which begins after this one does.\n     */\n    for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n         q = q->ipf_next)\n        if (q->ipf_off > ip->ip_off)\n            break;\n\n    /*\n     * If there is a preceding segment, it may provide some of\n     * our data already.  If so, drop the data from the incoming\n     * segment.  If it provides all of our data, drop us.\n     */\n    if (q->ipf_prev != &fp->frag_link) {\n        struct ipasfrag *pq = q->ipf_prev;\n        i = pq->ipf_off + pq->ipf_len - ip->ip_off;\n        if (i > 0) {\n            if (i >= ip->ip_len)\n                goto dropfrag;\n            m_adj(dtom(slirp, ip), i);\n            ip->ip_off += i;\n            ip->ip_len -= i;\n        }\n    }\n\n    /*\n     * While we overlap succeeding segments trim them or,\n     * if they are completely covered, dequeue them.\n     */\n    while (q != (struct ipasfrag *)&fp->frag_link &&\n           ip->ip_off + ip->ip_len > q->ipf_off) {\n        i = (ip->ip_off + ip->ip_len) - q->ipf_off;\n        if (i < q->ipf_len) {\n            q->ipf_len -= i;\n            q->ipf_off += i;\n            m_adj(dtom(slirp, q), i);\n            break;\n        }\n        q = q->ipf_next;\n        m_free(dtom(slirp, q->ipf_prev));\n        ip_deq(q->ipf_prev);\n    }\n\ninsert:\n    /*\n     * Stick new segment in its place;\n     * check for complete reassembly.\n     */\n    ip_enq(iptofrag(ip), q->ipf_prev);\n    next = 0;\n    for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n         q = q->ipf_next) {\n        if (q->ipf_off != next)\n            return NULL;\n        next += q->ipf_len;\n    }\n    if (((struct ipasfrag *)(q->ipf_prev))->ipf_tos & 1)\n        return NULL;\n\n    /*\n     * Reassembly is complete; concatenate fragments.\n     */\n    q = fp->frag_link.next;\n    m = dtom(slirp, q);\n\n    q = (struct ipasfrag *)q->ipf_next;\n    while (q != (struct ipasfrag *)&fp->frag_link) {\n        struct mbuf *t = dtom(slirp, q);\n        q = (struct ipasfrag *)q->ipf_next;\n        m_cat(m, t);\n    }\n\n    /*\n     * Create header for new ip packet by\n     * modifying header of first packet;\n     * dequeue and discard fragment reassembly header.\n     * Make header visible.\n     */\n    q = fp->frag_link.next;\n\n    /*\n     * If the fragments concatenated to an mbuf that's\n     * bigger than the total size of the fragment, then and\n     * m_ext buffer was alloced. But fp->ipq_next points to\n     * the old buffer (in the mbuf), so we must point ip\n     * into the new buffer.\n     */\n    if (m->m_flags & M_EXT) {\n        int delta = (char *)q - m->m_dat;\n        q = (struct ipasfrag *)(m->m_ext + delta);\n    }\n\n    ip = fragtoip(q);\n    ip->ip_len = next;\n    ip->ip_tos &= ~1;\n    ip->ip_src = fp->ipq_src;\n    ip->ip_dst = fp->ipq_dst;\n    remque(&fp->ip_link);\n    (void)m_free(dtom(slirp, fp));\n    m->m_len += (ip->ip_hl << 2);\n    m->m_data -= (ip->ip_hl << 2);\n\n    return ip;\n\ndropfrag:\n    m_free(m);\n    return NULL;\n}",
  "diff_func": "@@ -326,6 +326,8 @@ static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)\n     q = fp->frag_link.next;\n     m = dtom(slirp, q);\n \n+    int was_ext = m->m_flags & M_EXT;\n+\n     q = (struct ipasfrag *)q->ipf_next;\n     while (q != (struct ipasfrag *)&fp->frag_link) {\n         struct mbuf *t = dtom(slirp, q);\n@@ -348,7 +350,7 @@ static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)\n      * the old buffer (in the mbuf), so we must point ip\n      * into the new buffer.\n      */\n-    if (m->m_flags & M_EXT) {\n+    if (!was_ext && m->m_flags & M_EXT) {\n         int delta = (char *)q - m->m_dat;\n         q = (struct ipasfrag *)(m->m_ext + delta);\n     }",
  "func": "static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)\n{\n    register struct mbuf *m = dtom(slirp, ip);\n    register struct ipasfrag *q;\n    int hlen = ip->ip_hl << 2;\n    int i, next;\n\n    DEBUG_CALL(\"ip_reass\");\n    DEBUG_ARG(\"ip = %p\", ip);\n    DEBUG_ARG(\"fp = %p\", fp);\n    DEBUG_ARG(\"m = %p\", m);\n\n    /*\n     * Presence of header sizes in mbufs\n     * would confuse code below.\n     * Fragment m_data is concatenated.\n     */\n    m->m_data += hlen;\n    m->m_len -= hlen;\n\n    /*\n     * If first fragment to arrive, create a reassembly queue.\n     */\n    if (fp == NULL) {\n        struct mbuf *t = m_get(slirp);\n\n        if (t == NULL) {\n            goto dropfrag;\n        }\n        fp = mtod(t, struct ipq *);\n        insque(&fp->ip_link, &slirp->ipq.ip_link);\n        fp->ipq_ttl = IPFRAGTTL;\n        fp->ipq_p = ip->ip_p;\n        fp->ipq_id = ip->ip_id;\n        fp->frag_link.next = fp->frag_link.prev = &fp->frag_link;\n        fp->ipq_src = ip->ip_src;\n        fp->ipq_dst = ip->ip_dst;\n        q = (struct ipasfrag *)fp;\n        goto insert;\n    }\n\n    /*\n     * Find a segment which begins after this one does.\n     */\n    for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n         q = q->ipf_next)\n        if (q->ipf_off > ip->ip_off)\n            break;\n\n    /*\n     * If there is a preceding segment, it may provide some of\n     * our data already.  If so, drop the data from the incoming\n     * segment.  If it provides all of our data, drop us.\n     */\n    if (q->ipf_prev != &fp->frag_link) {\n        struct ipasfrag *pq = q->ipf_prev;\n        i = pq->ipf_off + pq->ipf_len - ip->ip_off;\n        if (i > 0) {\n            if (i >= ip->ip_len)\n                goto dropfrag;\n            m_adj(dtom(slirp, ip), i);\n            ip->ip_off += i;\n            ip->ip_len -= i;\n        }\n    }\n\n    /*\n     * While we overlap succeeding segments trim them or,\n     * if they are completely covered, dequeue them.\n     */\n    while (q != (struct ipasfrag *)&fp->frag_link &&\n           ip->ip_off + ip->ip_len > q->ipf_off) {\n        i = (ip->ip_off + ip->ip_len) - q->ipf_off;\n        if (i < q->ipf_len) {\n            q->ipf_len -= i;\n            q->ipf_off += i;\n            m_adj(dtom(slirp, q), i);\n            break;\n        }\n        q = q->ipf_next;\n        m_free(dtom(slirp, q->ipf_prev));\n        ip_deq(q->ipf_prev);\n    }\n\ninsert:\n    /*\n     * Stick new segment in its place;\n     * check for complete reassembly.\n     */\n    ip_enq(iptofrag(ip), q->ipf_prev);\n    next = 0;\n    for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n         q = q->ipf_next) {\n        if (q->ipf_off != next)\n            return NULL;\n        next += q->ipf_len;\n    }\n    if (((struct ipasfrag *)(q->ipf_prev))->ipf_tos & 1)\n        return NULL;\n\n    /*\n     * Reassembly is complete; concatenate fragments.\n     */\n    q = fp->frag_link.next;\n    m = dtom(slirp, q);\n\n    q = (struct ipasfrag *)q->ipf_next;\n    while (q != (struct ipasfrag *)&fp->frag_link) {\n        struct mbuf *t = dtom(slirp, q);\n        q = (struct ipasfrag *)q->ipf_next;\n        m_cat(m, t);\n    }\n\n    /*\n     * Create header for new ip packet by\n     * modifying header of first packet;\n     * dequeue and discard fragment reassembly header.\n     * Make header visible.\n     */\n    q = fp->frag_link.next;\n\n    /*\n     * If the fragments concatenated to an mbuf that's\n     * bigger than the total size of the fragment, then and\n     * m_ext buffer was alloced. But fp->ipq_next points to\n     * the old buffer (in the mbuf), so we must point ip\n     * into the new buffer.\n     */\n    if (m->m_flags & M_EXT) {\n        int delta = (char *)q - m->m_dat;\n        q = (struct ipasfrag *)(m->m_ext + delta);\n    }\n\n    ip = fragtoip(q);\n    ip->ip_len = next;\n    ip->ip_tos &= ~1;\n    ip->ip_src = fp->ipq_src;\n    ip->ip_dst = fp->ipq_dst;\n    remque(&fp->ip_link);\n    (void)m_free(dtom(slirp, fp));\n    m->m_len += (ip->ip_hl << 2);\n    m->m_data -= (ip->ip_hl << 2);\n\n    return ip;\n\ndropfrag:\n    m_free(m);\n    return NULL;\n}",
  "project": "libslirp",
  "hash": 138883903530681634140467642895512584556,
  "size": 149,
  "commit_id": "126c04acbabd7ad32c2b018fe10dfac2a3bc1210",
  "message": "Fix heap overflow in ip_reass on big packet input\n\nWhen the first fragment does not fit in the preallocated buffer, q will\nalready be pointing to the ext buffer, so we mustn't try to update it.\n\nSigned-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>",
  "target": 1,
  "dataset": "other",
  "idx": 205959
}