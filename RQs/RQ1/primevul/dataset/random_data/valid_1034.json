{
  "id": 1034,
  "language": "unknown",
  "cwe": [
    "CWE-189"
  ],
  "commit_url": "https://github.com/Distrotech/grep/commit/8fcf61523644df42e1905c81bed26838e0b04f91",
  "commit_sha": "8fcf61523644df42e1905c81bed26838e0b04f91",
  "commit_msg": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "NEWS",
  "func_name": "",
  "raw_func_from_json": "grep (int fd, char const *file, struct stats *stats)\n{\n  int nlines, i;\n  int not_text;\n  size_t residue, save;\n  char oldc;\n  char *beg;\n  char *lim;\n  char eol = eolbyte;\n\n  if (!reset (fd, file, stats))\n    return 0;\n\n  if (file && directories == RECURSE_DIRECTORIES\n      && S_ISDIR (stats->stat.st_mode))\n    {\n      /* Close fd now, so that we don't open a lot of file descriptors\n         when we recurse deeply.  */\n      if (close (fd) != 0)\n        suppressible_error (file, errno);\n      return grepdir (file, stats) - 2;\n    }\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  outleft = max_count;\n  after_last_match = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  if (! fillbuf (save, stats))\n    {\n      suppressible_error (filename, errno);\n      return 0;\n    }\n\n  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n               || binary_files == WITHOUT_MATCH_BINARY_FILES)\n              && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n    return 0;\n  done_on_match += not_text;\n  out_quiet += not_text;\n\n  for (;;)\n    {\n      lastnl = bufbeg;\n      if (lastout)\n        lastout = bufbeg;\n\n      beg = bufbeg + save;\n\n      /* no more data to scan (eof) except for maybe a residue -> break */\n      if (beg == buflim)\n        break;\n\n      /* Determine new residue (the length of an incomplete line at the end of\n         the buffer, 0 means there is no incomplete last line).  */\n      oldc = beg[-1];\n      beg[-1] = eol;\n      for (lim = buflim; lim[-1] != eol; lim--)\n        continue;\n      beg[-1] = oldc;\n      if (lim == beg)\n        lim = beg - residue;\n      beg -= residue;\n      residue = buflim - lim;\n\n      if (beg < lim)\n        {\n          if (outleft)\n            nlines += grepbuf (beg, lim);\n          if (pending)\n            prpending (lim);\n          if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n            goto finish_grep;\n        }\n\n      /* The last OUT_BEFORE lines at the end of the buffer will be needed as\n         leading context if there is a matching line at the begin of the\n         next data. Make beg point to their begin.  */\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n        {\n          ++i;\n          do\n            --beg;\n          while (beg[-1] != eol);\n        }\n\n      /* detect if leading context is discontinuous from last printed line.  */\n      if (beg != lastout)\n        lastout = 0;\n\n      /* Handle some details and read more data to scan.  */\n      save = residue + lim - beg;\n      if (out_byte)\n        totalcc = add_count (totalcc, buflim - bufbeg - save);\n      if (out_line)\n        nlscan (beg);\n      if (! fillbuf (save, stats))\n        {\n          suppressible_error (filename, errno);\n          goto finish_grep;\n        }\n    }\n  if (residue)\n    {\n      *buflim++ = eol;\n      if (outleft)\n        nlines += grepbuf (bufbeg + save - residue, buflim);\n      if (pending)\n        prpending (buflim);\n    }\n\n finish_grep:\n  done_on_match -= not_text;\n  out_quiet -= not_text;\n  if ((not_text & ~out_quiet) && nlines != 0)\n    printf (_(\"Binary file %s matches\\n\"), filename);\n  return nlines;\n}",
  "diff_func": "@@ -11,6 +11,11 @@ GNU grep NEWS                                    -*- outline -*-\n   GNU C library's regular expression functions cannot handle such long lines.\n   [bug present since \"the beginning\"]\n \n+  The -m, -A, -B, and -C options no longer mishandle context line\n+  counts that do not fit in 'int'.  Also, grep -c's counts are now\n+  limited by the type 'intmax_t' (typically less than 2**63) rather\n+  than 'int' (typically less than 2**31).\n+\n   grep no longer silently suppresses errors when reading a directory\n   as if it were a text file.  For example, \"grep x .\" now reports a\n   read error on most systems; formerly, it ignored the error.",
  "func": "grep (int fd, char const *file, struct stats *stats)\n{\n  int nlines, i;\n  int not_text;\n  size_t residue, save;\n  char oldc;\n  char *beg;\n  char *lim;\n  char eol = eolbyte;\n\n  if (!reset (fd, file, stats))\n    return 0;\n\n  if (file && directories == RECURSE_DIRECTORIES\n      && S_ISDIR (stats->stat.st_mode))\n    {\n      /* Close fd now, so that we don't open a lot of file descriptors\n         when we recurse deeply.  */\n      if (close (fd) != 0)\n        suppressible_error (file, errno);\n      return grepdir (file, stats) - 2;\n    }\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  outleft = max_count;\n  after_last_match = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  if (! fillbuf (save, stats))\n    {\n      suppressible_error (filename, errno);\n      return 0;\n    }\n\n  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n               || binary_files == WITHOUT_MATCH_BINARY_FILES)\n              && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n    return 0;\n  done_on_match += not_text;\n  out_quiet += not_text;\n\n  for (;;)\n    {\n      lastnl = bufbeg;\n      if (lastout)\n        lastout = bufbeg;\n\n      beg = bufbeg + save;\n\n      /* no more data to scan (eof) except for maybe a residue -> break */\n      if (beg == buflim)\n        break;\n\n      /* Determine new residue (the length of an incomplete line at the end of\n         the buffer, 0 means there is no incomplete last line).  */\n      oldc = beg[-1];\n      beg[-1] = eol;\n      for (lim = buflim; lim[-1] != eol; lim--)\n        continue;\n      beg[-1] = oldc;\n      if (lim == beg)\n        lim = beg - residue;\n      beg -= residue;\n      residue = buflim - lim;\n\n      if (beg < lim)\n        {\n          if (outleft)\n            nlines += grepbuf (beg, lim);\n          if (pending)\n            prpending (lim);\n          if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n            goto finish_grep;\n        }\n\n      /* The last OUT_BEFORE lines at the end of the buffer will be needed as\n         leading context if there is a matching line at the begin of the\n         next data. Make beg point to their begin.  */\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n        {\n          ++i;\n          do\n            --beg;\n          while (beg[-1] != eol);\n        }\n\n      /* detect if leading context is discontinuous from last printed line.  */\n      if (beg != lastout)\n        lastout = 0;\n\n      /* Handle some details and read more data to scan.  */\n      save = residue + lim - beg;\n      if (out_byte)\n        totalcc = add_count (totalcc, buflim - bufbeg - save);\n      if (out_line)\n        nlscan (beg);\n      if (! fillbuf (save, stats))\n        {\n          suppressible_error (filename, errno);\n          goto finish_grep;\n        }\n    }\n  if (residue)\n    {\n      *buflim++ = eol;\n      if (outleft)\n        nlines += grepbuf (bufbeg + save - residue, buflim);\n      if (pending)\n        prpending (buflim);\n    }\n\n finish_grep:\n  done_on_match -= not_text;\n  out_quiet -= not_text;\n  if ((not_text & ~out_quiet) && nlines != 0)\n    printf (_(\"Binary file %s matches\\n\"), filename);\n  return nlines;\n}",
  "target": 1,
  "project": "grep",
  "commit_id": "8fcf61523644df42e1905c81bed26838e0b04f91",
  "hash": 127493158851729294951078837033344135674,
  "size": 127,
  "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow.",
  "dataset": "other",
  "idx": 215830
}