{
  "id": 916,
  "language": "cpp",
  "cwe": "",
  "commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/bc88cdb6c97fbf5bc5d11ad8ca55306da931283a",
  "commit_sha": "bc88cdb6c97fbf5bc5d11ad8ca55306da931283a",
  "commit_msg": "sanity check ScanlineInput bytesPerLine instead of lineOffset size (#863)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\r\n\r\nCo-authored-by: Cary Phillips <cary@ilm.com>",
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/863",
  "pr_info": "Address https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=27409\r\nUpdates the filesize check added by #824 to files with a large number of scanlines, rather than a large number of chunks, giving more protection against very small specially crafted files causing large memory allocations.\r\n\r\n#824 prevented large memory allocations for scanline offset tables in files which were too small to contain large tables. ScanLineInput files have a 'scanline offset table' (one per chunk) as well as 'bytesPerLine' and 'offsetInLineBuffer' tables (each one per scanline). DWAB files contain 256 scanlines per chunk, so can have a huge bytesPerLine table with only a moderate scanline offset table.\r\n\r\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
  "file_name": "src/lib/OpenEXR/ImfScanLineInputFile.cpp",
  "func_name": "",
  "raw_func_from_json": "void ScanLineInputFile::initialize(const Header& header)\n{\n        _data->header = header;\n\n        _data->lineOrder = _data->header.lineOrder();\n\n        const Box2i &dataWindow = _data->header.dataWindow();\n\n        _data->minX = dataWindow.min.x;\n        _data->maxX = dataWindow.max.x;\n        _data->minY = dataWindow.min.y;\n        _data->maxY = dataWindow.max.y;\n\n        Compression comp = _data->header.compression();\n\n        _data->linesInBuffer =\n            numLinesInBuffer (comp);\n\n        int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                              _data->linesInBuffer) / _data->linesInBuffer;\n\n        //\n        // avoid allocating excessive memory due to large lineOffsets table size.\n        // If the chunktablesize claims to be large,\n        // check the file is big enough to contain the table before allocating memory\n        // in the bytesPerLineTable and the lineOffsets table.\n        // Attempt to read the last entry in the table. Either the seekg() or the read()\n        // call will throw an exception if the file is too small to contain the table\n        //\n        if (lineOffsetSize > gLargeChunkTableSize)\n        {\n            Int64 pos = _streamData->is->tellg();\n            _streamData->is->seekg(pos + (lineOffsetSize-1)*sizeof(Int64));\n            Int64 temp;\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*_streamData->is, temp);\n            _streamData->is->seekg(pos);\n\n        }\n\n\n        size_t maxBytesPerLine = bytesPerLineTable (_data->header,\n                                                    _data->bytesPerLine);\n\n        if (maxBytesPerLine*numLinesInBuffer(comp) > INT_MAX)\n        {\n            throw IEX_NAMESPACE::InputExc(\"maximum bytes per scanline exceeds maximum permissible size\");\n        }\n\n\n        //\n        // allocate compressor objects\n        //\n        for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n        {\n            _data->lineBuffers[i] = new LineBuffer (newCompressor(comp,\n                                                 maxBytesPerLine,\n                                                 _data->header));\n        }\n\n\n\n        _data->lineBufferSize = maxBytesPerLine * _data->linesInBuffer;\n\n        if (!_streamData->is->isMemoryMapped())\n        {\n            for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n            {\n                _data->lineBuffers[i]->buffer = (char *) EXRAllocAligned(_data->lineBufferSize*sizeof(char),16);\n                if (!_data->lineBuffers[i]->buffer)\n                {\n                    throw IEX_NAMESPACE::LogicExc(\"Failed to allocate memory for scanline buffers\");\n                }\n            }\n        }\n        _data->nextLineBufferMinY = _data->minY - 1;\n\n        offsetInLineBufferTable (_data->bytesPerLine,\n                                 _data->linesInBuffer,\n                                 _data->offsetInLineBuffer);\n\n\n        _data->lineOffsets.resize (lineOffsetSize);\n}",
  "diff_func": "@@ -1135,14 +1135,14 @@ void ScanLineInputFile::initialize(const Header& header)\n                               _data->linesInBuffer) / _data->linesInBuffer;\n \n         //\n-        // avoid allocating excessive memory due to large lineOffsets table size.\n+        // avoid allocating excessive memory due to large lineOffsets and bytesPerLine table sizes.\n         // If the chunktablesize claims to be large,\n-        // check the file is big enough to contain the table before allocating memory\n+        // check the file is big enough to contain the lineOffsets table before allocating memory\n         // in the bytesPerLineTable and the lineOffsets table.\n         // Attempt to read the last entry in the table. Either the seekg() or the read()\n         // call will throw an exception if the file is too small to contain the table\n         //\n-        if (lineOffsetSize > gLargeChunkTableSize)\n+        if (lineOffsetSize * _data->linesInBuffer > gLargeChunkTableSize)\n         {\n             Int64 pos = _streamData->is->tellg();\n             _streamData->is->seekg(pos + (lineOffsetSize-1)*sizeof(Int64));",
  "func": "void ScanLineInputFile::initialize(const Header& header)\n{\n        _data->header = header;\n\n        _data->lineOrder = _data->header.lineOrder();\n\n        const Box2i &dataWindow = _data->header.dataWindow();\n\n        _data->minX = dataWindow.min.x;\n        _data->maxX = dataWindow.max.x;\n        _data->minY = dataWindow.min.y;\n        _data->maxY = dataWindow.max.y;\n\n        Compression comp = _data->header.compression();\n\n        _data->linesInBuffer =\n            numLinesInBuffer (comp);\n\n        int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                              _data->linesInBuffer) / _data->linesInBuffer;\n\n        //\n        // avoid allocating excessive memory due to large lineOffsets table size.\n        // If the chunktablesize claims to be large,\n        // check the file is big enough to contain the table before allocating memory\n        // in the bytesPerLineTable and the lineOffsets table.\n        // Attempt to read the last entry in the table. Either the seekg() or the read()\n        // call will throw an exception if the file is too small to contain the table\n        //\n        if (lineOffsetSize > gLargeChunkTableSize)\n        {\n            Int64 pos = _streamData->is->tellg();\n            _streamData->is->seekg(pos + (lineOffsetSize-1)*sizeof(Int64));\n            Int64 temp;\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*_streamData->is, temp);\n            _streamData->is->seekg(pos);\n\n        }\n\n\n        size_t maxBytesPerLine = bytesPerLineTable (_data->header,\n                                                    _data->bytesPerLine);\n\n        if (maxBytesPerLine*numLinesInBuffer(comp) > INT_MAX)\n        {\n            throw IEX_NAMESPACE::InputExc(\"maximum bytes per scanline exceeds maximum permissible size\");\n        }\n\n\n        //\n        // allocate compressor objects\n        //\n        for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n        {\n            _data->lineBuffers[i] = new LineBuffer (newCompressor(comp,\n                                                 maxBytesPerLine,\n                                                 _data->header));\n        }\n\n\n\n        _data->lineBufferSize = maxBytesPerLine * _data->linesInBuffer;\n\n        if (!_streamData->is->isMemoryMapped())\n        {\n            for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n            {\n                _data->lineBuffers[i]->buffer = (char *) EXRAllocAligned(_data->lineBufferSize*sizeof(char),16);\n                if (!_data->lineBuffers[i]->buffer)\n                {\n                    throw IEX_NAMESPACE::LogicExc(\"Failed to allocate memory for scanline buffers\");\n                }\n            }\n        }\n        _data->nextLineBufferMinY = _data->minY - 1;\n\n        offsetInLineBufferTable (_data->bytesPerLine,\n                                 _data->linesInBuffer,\n                                 _data->offsetInLineBuffer);\n\n\n        _data->lineOffsets.resize (lineOffsetSize);\n}",
  "project": "openexr",
  "hash": 22351819646121800230325071822285424033,
  "size": 83,
  "commit_id": "bc88cdb6c97fbf5bc5d11ad8ca55306da931283a",
  "message": "sanity check ScanlineInput bytesPerLine instead of lineOffset size (#863)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\r\n\r\nCo-authored-by: Cary Phillips <cary@ilm.com>",
  "target": 1,
  "dataset": "other",
  "idx": 211127
}