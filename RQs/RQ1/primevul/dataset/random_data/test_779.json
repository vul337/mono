{
  "id": 779,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/nginx/njs/commit/6a07c2156a07ef307b6dcf3c2ca8571a5f1af7a6",
  "commit_sha": "6a07c2156a07ef307b6dcf3c2ca8571a5f1af7a6",
  "commit_msg": "Fixed recursive async function calls.\n\nPreviously, PromiseCapability record was stored (function->context)\ndirectly in function object during a function invocation.  This is\nnot correct, because PromiseCapability record should be linked to\ncurrent execution context.  As a result, function->context is\noverwritten with consecutive recursive calls which results in\nuse-after-free.\n\nThis closes #451 issue on Github.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/njs_async.c",
  "func_name": "",
  "raw_func_from_json": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n\n    ctx = vm->top_frame->function->context;\n\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n\n    function = async->function;\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n\n    vm->top_frame->retval = &vm->retval;\n\n    function->context = ctx->capability;\n    function->await = ctx;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n\n    function->context = NULL;\n    function->await = NULL;\n\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n\n    vm->top_frame = top;\n    vm->active_frame = frame;\n\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n\n        njs_async_context_free(vm, ctx);\n\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n\n        value = &vm->retval;\n\n        goto failed;\n    }\n\n    return ret;\n\nfailed:\n\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n\n    njs_async_context_free(vm, ctx);\n\n    return NJS_ERROR;\n}",
  "diff_func": "@@ -29,9 +29,7 @@ njs_async_function_frame_invoke(njs_vm_t *vm, njs_value_t *retval)\n         return NJS_ERROR;\n     }\n \n-    frame->function->context = capability;\n-\n-    ret = njs_function_lambda_call(vm);\n+    ret = njs_function_lambda_call(vm, capability, NULL);\n \n     if (ret == NJS_OK) {\n         ret = njs_function_call(vm, njs_function(&capability->resolve),\n@@ -63,7 +61,6 @@ njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n     njs_int_t           ret;\n     njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n     njs_frame_t         *frame, *async_frame;\n-    njs_function_t      *function;\n     njs_async_ctx_t     *ctx;\n     njs_native_frame_t  *top, *async;\n \n@@ -78,8 +75,6 @@ njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n     async = &async_frame->native;\n     async->previous = vm->top_frame;\n \n-    function = async->function;\n-\n     cur_local = vm->levels[NJS_LEVEL_LOCAL];\n     cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n     cur_temp = vm->levels[NJS_LEVEL_TEMP];\n@@ -98,13 +93,7 @@ njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n \n     vm->top_frame->retval = &vm->retval;\n \n-    function->context = ctx->capability;\n-    function->await = ctx;\n-\n-    ret = njs_vmcode_interpreter(vm, ctx->pc);\n-\n-    function->context = NULL;\n-    function->await = NULL;\n+    ret = njs_vmcode_interpreter(vm, ctx->pc, ctx->capability, ctx);\n \n     vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n     vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;",
  "func": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n\n    ctx = vm->top_frame->function->context;\n\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n\n    function = async->function;\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n\n    vm->top_frame->retval = &vm->retval;\n\n    function->context = ctx->capability;\n    function->await = ctx;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n\n    function->context = NULL;\n    function->await = NULL;\n\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n\n    vm->top_frame = top;\n    vm->active_frame = frame;\n\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n\n        njs_async_context_free(vm, ctx);\n\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n\n        value = &vm->retval;\n\n        goto failed;\n    }\n\n    return ret;\n\nfailed:\n\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n\n    njs_async_context_free(vm, ctx);\n\n    return NJS_ERROR;\n}",
  "project": "njs",
  "hash": 30140299270589977394449369465621934034,
  "size": 86,
  "commit_id": "6a07c2156a07ef307b6dcf3c2ca8571a5f1af7a6",
  "message": "Fixed recursive async function calls.\n\nPreviously, PromiseCapability record was stored (function->context)\ndirectly in function object during a function invocation.  This is\nnot correct, because PromiseCapability record should be linked to\ncurrent execution context.  As a result, function->context is\noverwritten with consecutive recursive calls which results in\nuse-after-free.\n\nThis closes #451 issue on Github.",
  "target": 1,
  "dataset": "other",
  "idx": 198476
}