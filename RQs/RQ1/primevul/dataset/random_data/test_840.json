{
  "id": 840,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/louissong7912/SMP_gnutls/commit/20a98e817713764b9df5306286091df1b61190d9",
  "commit_sha": "20a98e817713764b9df5306286091df1b61190d9",
  "commit_msg": "handshake: check inappropriate fallback against the configured max version\n\nThat allows to operate on a server which is explicitly configured to\nutilize earlier than TLS 1.2 versions.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "lib/gnutls_handshake.c",
  "func_name": "",
  "raw_func_from_json": "_gnutls_server_select_suite(gnutls_session_t session, uint8_t * data,\n\t\t\t    unsigned int datalen)\n{\n\tint ret;\n\tunsigned int i, j, cipher_suites_size;\n\tsize_t pk_algos_size;\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE];\n\tint retval;\n\tgnutls_pk_algorithm_t pk_algos[MAX_ALGOS];\t/* will hold the pk algorithms\n\t\t\t\t\t\t\t * supported by the peer.\n\t\t\t\t\t\t\t */\n\n\tfor (i = 0; i < datalen; i += 2) {\n\t\t/* TLS_RENEGO_PROTECTION_REQUEST = { 0x00, 0xff } */\n\t\tif (session->internals.priorities.sr != SR_DISABLED &&\n\t\t    data[i] == GNUTLS_RENEGO_PROTECTION_REQUEST_MAJOR &&\n\t\t    data[i + 1] == GNUTLS_RENEGO_PROTECTION_REQUEST_MINOR) {\n\t\t\t_gnutls_handshake_log\n\t\t\t    (\"HSK[%p]: Received safe renegotiation CS\\n\",\n\t\t\t     session);\n\t\t\tretval = _gnutls_ext_sr_recv_cs(session);\n\t\t\tif (retval < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\n\t\t/* TLS_FALLBACK_SCSV */\n\t\tif (data[i] == GNUTLS_FALLBACK_SCSV_MAJOR &&\n\t\t    data[i + 1] == GNUTLS_FALLBACK_SCSV_MINOR) {\n\t\t\t_gnutls_handshake_log\n\t\t\t    (\"HSK[%p]: Received fallback CS\\n\",\n\t\t\t     session);\n\n\t\t\tif (gnutls_protocol_get_version(session) !=\n\t\t\t    GNUTLS_TLS_VERSION_MAX)\n\t\t\t\treturn GNUTLS_E_INAPPROPRIATE_FALLBACK;\n\t\t}\n\t}\n\n\tpk_algos_size = MAX_ALGOS;\n\tret =\n\t    server_find_pk_algos_in_ciphersuites(data, datalen, pk_algos,\n\t\t\t\t\t\t &pk_algos_size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\tret =\n\t    _gnutls_supported_ciphersuites(session, cipher_suites,\n\t\t\t\t\t   sizeof(cipher_suites));\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\tcipher_suites_size = ret;\n\n\t/* Here we remove any ciphersuite that does not conform\n\t * the certificate requested, or to the\n\t * authentication requested (e.g. SRP).\n\t */\n\tret =\n\t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n\t\t\t\t\t\t cipher_suites_size,\n\t\t\t\t\t\t pk_algos, pk_algos_size);\n\tif (ret <= 0) {\n\t\tgnutls_assert();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn GNUTLS_E_UNKNOWN_CIPHER_SUITE;\n\t}\n\n\tcipher_suites_size = ret;\n\n\t/* Data length should be zero mod 2 since\n\t * every ciphersuite is 2 bytes. (this check is needed\n\t * see below).\n\t */\n\tif (datalen % 2 != 0) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n\n\tmemset(session->security_parameters.cipher_suite, 0, 2);\n\n\tretval = GNUTLS_E_UNKNOWN_CIPHER_SUITE;\n\n\t_gnutls_handshake_log\n\t    (\"HSK[%p]: Requested cipher suites[size: %d]: \\n\", session,\n\t     (int) datalen);\n\n\tif (session->internals.priorities.server_precedence == 0) {\n\t\tfor (j = 0; j < datalen; j += 2) {\n\t\t\t_gnutls_handshake_log(\"\\t0x%.2x, 0x%.2x %s\\n\",\n\t\t\t\t\t      data[j], data[j + 1],\n\t\t\t\t\t      _gnutls_cipher_suite_get_name\n\t\t\t\t\t      (&data[j]));\n\t\t\tfor (i = 0; i < cipher_suites_size; i += 2) {\n\t\t\t\tif (memcmp(&cipher_suites[i], &data[j], 2)\n\t\t\t\t    == 0) {\n\t\t\t\t\t_gnutls_handshake_log\n\t\t\t\t\t    (\"HSK[%p]: Selected cipher suite: %s\\n\",\n\t\t\t\t\t     session,\n\t\t\t\t\t     _gnutls_cipher_suite_get_name\n\t\t\t\t\t     (&data[j]));\n\t\t\t\t\tmemcpy(session->\n\t\t\t\t\t       security_parameters.\n\t\t\t\t\t       cipher_suite,\n\t\t\t\t\t       &cipher_suites[i], 2);\n\t\t\t\t\t_gnutls_epoch_set_cipher_suite\n\t\t\t\t\t    (session, EPOCH_NEXT,\n\t\t\t\t\t     session->security_parameters.\n\t\t\t\t\t     cipher_suite);\n\n\n\t\t\t\t\tretval = 0;\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\t\t/* server selects */\n\n\t\tfor (i = 0; i < cipher_suites_size; i += 2) {\n\t\t\tfor (j = 0; j < datalen; j += 2) {\n\t\t\t\tif (memcmp(&cipher_suites[i], &data[j], 2)\n\t\t\t\t    == 0) {\n\t\t\t\t\t_gnutls_handshake_log\n\t\t\t\t\t    (\"HSK[%p]: Selected cipher suite: %s\\n\",\n\t\t\t\t\t     session,\n\t\t\t\t\t     _gnutls_cipher_suite_get_name\n\t\t\t\t\t     (&data[j]));\n\t\t\t\t\tmemcpy(session->\n\t\t\t\t\t       security_parameters.\n\t\t\t\t\t       cipher_suite,\n\t\t\t\t\t       &cipher_suites[i], 2);\n\t\t\t\t\t_gnutls_epoch_set_cipher_suite\n\t\t\t\t\t    (session, EPOCH_NEXT,\n\t\t\t\t\t     session->security_parameters.\n\t\t\t\t\t     cipher_suite);\n\n\n\t\t\t\t\tretval = 0;\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n      finish:\n\n\tif (retval != 0) {\n\t\tgnutls_assert();\n\t\treturn retval;\n\t}\n\n\t/* check if the credentials (username, public key etc.) are ok\n\t */\n\tif (_gnutls_get_kx_cred\n\t    (session,\n\t     _gnutls_cipher_suite_get_kx_algo(session->security_parameters.\n\t\t\t\t\t      cipher_suite)) == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n\t}\n\n\n\t/* set the mod_auth_st to the appropriate struct\n\t * according to the KX algorithm. This is needed since all the\n\t * handshake functions are read from there;\n\t */\n\tsession->internals.auth_struct =\n\t    _gnutls_kx_auth_struct(_gnutls_cipher_suite_get_kx_algo\n\t\t\t\t   (session->security_parameters.\n\t\t\t\t    cipher_suite));\n\tif (session->internals.auth_struct == NULL) {\n\n\t\t_gnutls_handshake_log\n\t\t    (\"HSK[%p]: Cannot find the appropriate handler for the KX algorithm\\n\",\n\t\t     session);\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INTERNAL_ERROR;\n\t}\n\n\treturn 0;\n\n}",
  "diff_func": "@@ -927,13 +927,13 @@ _gnutls_server_select_suite(gnutls_session_t session, uint8_t * data,\n \t\t/* TLS_FALLBACK_SCSV */\n \t\tif (data[i] == GNUTLS_FALLBACK_SCSV_MAJOR &&\n \t\t    data[i + 1] == GNUTLS_FALLBACK_SCSV_MINOR) {\n+\t\t\tunsigned max = _gnutls_version_max(session);\n \t\t\t_gnutls_handshake_log\n \t\t\t    (\"HSK[%p]: Received fallback CS\\n\",\n \t\t\t     session);\n \n-\t\t\tif (gnutls_protocol_get_version(session) !=\n-\t\t\t    GNUTLS_TLS_VERSION_MAX)\n-\t\t\t\treturn GNUTLS_E_INAPPROPRIATE_FALLBACK;\n+\t\t\tif (gnutls_protocol_get_version(session) != max)\n+\t\t\t\treturn gnutls_assert_val(GNUTLS_E_INAPPROPRIATE_FALLBACK);\n \t\t}\n \t}\n ",
  "func": "_gnutls_server_select_suite(gnutls_session_t session, uint8_t * data,\n\t\t\t    unsigned int datalen)\n{\n\tint ret;\n\tunsigned int i, j, cipher_suites_size;\n\tsize_t pk_algos_size;\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE];\n\tint retval;\n\tgnutls_pk_algorithm_t pk_algos[MAX_ALGOS];\t/* will hold the pk algorithms\n\t\t\t\t\t\t\t * supported by the peer.\n\t\t\t\t\t\t\t */\n\n\tfor (i = 0; i < datalen; i += 2) {\n\t\t/* TLS_RENEGO_PROTECTION_REQUEST = { 0x00, 0xff } */\n\t\tif (session->internals.priorities.sr != SR_DISABLED &&\n\t\t    data[i] == GNUTLS_RENEGO_PROTECTION_REQUEST_MAJOR &&\n\t\t    data[i + 1] == GNUTLS_RENEGO_PROTECTION_REQUEST_MINOR) {\n\t\t\t_gnutls_handshake_log\n\t\t\t    (\"HSK[%p]: Received safe renegotiation CS\\n\",\n\t\t\t     session);\n\t\t\tretval = _gnutls_ext_sr_recv_cs(session);\n\t\t\tif (retval < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\n\t\t/* TLS_FALLBACK_SCSV */\n\t\tif (data[i] == GNUTLS_FALLBACK_SCSV_MAJOR &&\n\t\t    data[i + 1] == GNUTLS_FALLBACK_SCSV_MINOR) {\n\t\t\t_gnutls_handshake_log\n\t\t\t    (\"HSK[%p]: Received fallback CS\\n\",\n\t\t\t     session);\n\n\t\t\tif (gnutls_protocol_get_version(session) !=\n\t\t\t    GNUTLS_TLS_VERSION_MAX)\n\t\t\t\treturn GNUTLS_E_INAPPROPRIATE_FALLBACK;\n\t\t}\n\t}\n\n\tpk_algos_size = MAX_ALGOS;\n\tret =\n\t    server_find_pk_algos_in_ciphersuites(data, datalen, pk_algos,\n\t\t\t\t\t\t &pk_algos_size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\tret =\n\t    _gnutls_supported_ciphersuites(session, cipher_suites,\n\t\t\t\t\t   sizeof(cipher_suites));\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\n\tcipher_suites_size = ret;\n\n\t/* Here we remove any ciphersuite that does not conform\n\t * the certificate requested, or to the\n\t * authentication requested (e.g. SRP).\n\t */\n\tret =\n\t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n\t\t\t\t\t\t cipher_suites_size,\n\t\t\t\t\t\t pk_algos, pk_algos_size);\n\tif (ret <= 0) {\n\t\tgnutls_assert();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn GNUTLS_E_UNKNOWN_CIPHER_SUITE;\n\t}\n\n\tcipher_suites_size = ret;\n\n\t/* Data length should be zero mod 2 since\n\t * every ciphersuite is 2 bytes. (this check is needed\n\t * see below).\n\t */\n\tif (datalen % 2 != 0) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n\n\tmemset(session->security_parameters.cipher_suite, 0, 2);\n\n\tretval = GNUTLS_E_UNKNOWN_CIPHER_SUITE;\n\n\t_gnutls_handshake_log\n\t    (\"HSK[%p]: Requested cipher suites[size: %d]: \\n\", session,\n\t     (int) datalen);\n\n\tif (session->internals.priorities.server_precedence == 0) {\n\t\tfor (j = 0; j < datalen; j += 2) {\n\t\t\t_gnutls_handshake_log(\"\\t0x%.2x, 0x%.2x %s\\n\",\n\t\t\t\t\t      data[j], data[j + 1],\n\t\t\t\t\t      _gnutls_cipher_suite_get_name\n\t\t\t\t\t      (&data[j]));\n\t\t\tfor (i = 0; i < cipher_suites_size; i += 2) {\n\t\t\t\tif (memcmp(&cipher_suites[i], &data[j], 2)\n\t\t\t\t    == 0) {\n\t\t\t\t\t_gnutls_handshake_log\n\t\t\t\t\t    (\"HSK[%p]: Selected cipher suite: %s\\n\",\n\t\t\t\t\t     session,\n\t\t\t\t\t     _gnutls_cipher_suite_get_name\n\t\t\t\t\t     (&data[j]));\n\t\t\t\t\tmemcpy(session->\n\t\t\t\t\t       security_parameters.\n\t\t\t\t\t       cipher_suite,\n\t\t\t\t\t       &cipher_suites[i], 2);\n\t\t\t\t\t_gnutls_epoch_set_cipher_suite\n\t\t\t\t\t    (session, EPOCH_NEXT,\n\t\t\t\t\t     session->security_parameters.\n\t\t\t\t\t     cipher_suite);\n\n\n\t\t\t\t\tretval = 0;\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\t\t/* server selects */\n\n\t\tfor (i = 0; i < cipher_suites_size; i += 2) {\n\t\t\tfor (j = 0; j < datalen; j += 2) {\n\t\t\t\tif (memcmp(&cipher_suites[i], &data[j], 2)\n\t\t\t\t    == 0) {\n\t\t\t\t\t_gnutls_handshake_log\n\t\t\t\t\t    (\"HSK[%p]: Selected cipher suite: %s\\n\",\n\t\t\t\t\t     session,\n\t\t\t\t\t     _gnutls_cipher_suite_get_name\n\t\t\t\t\t     (&data[j]));\n\t\t\t\t\tmemcpy(session->\n\t\t\t\t\t       security_parameters.\n\t\t\t\t\t       cipher_suite,\n\t\t\t\t\t       &cipher_suites[i], 2);\n\t\t\t\t\t_gnutls_epoch_set_cipher_suite\n\t\t\t\t\t    (session, EPOCH_NEXT,\n\t\t\t\t\t     session->security_parameters.\n\t\t\t\t\t     cipher_suite);\n\n\n\t\t\t\t\tretval = 0;\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n      finish:\n\n\tif (retval != 0) {\n\t\tgnutls_assert();\n\t\treturn retval;\n\t}\n\n\t/* check if the credentials (username, public key etc.) are ok\n\t */\n\tif (_gnutls_get_kx_cred\n\t    (session,\n\t     _gnutls_cipher_suite_get_kx_algo(session->security_parameters.\n\t\t\t\t\t      cipher_suite)) == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n\t}\n\n\n\t/* set the mod_auth_st to the appropriate struct\n\t * according to the KX algorithm. This is needed since all the\n\t * handshake functions are read from there;\n\t */\n\tsession->internals.auth_struct =\n\t    _gnutls_kx_auth_struct(_gnutls_cipher_suite_get_kx_algo\n\t\t\t\t   (session->security_parameters.\n\t\t\t\t    cipher_suite));\n\tif (session->internals.auth_struct == NULL) {\n\n\t\t_gnutls_handshake_log\n\t\t    (\"HSK[%p]: Cannot find the appropriate handler for the KX algorithm\\n\",\n\t\t     session);\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INTERNAL_ERROR;\n\t}\n\n\treturn 0;\n\n}",
  "project": "gnutls",
  "hash": 142548387300837609415546667828512694218,
  "size": 184,
  "commit_id": "20a98e817713764b9df5306286091df1b61190d9",
  "message": "handshake: check inappropriate fallback against the configured max version\n\nThat allows to operate on a server which is explicitly configured to\nutilize earlier than TLS 1.2 versions.",
  "target": 1,
  "dataset": "other",
  "idx": 201872
}