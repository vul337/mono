{
  "id": 837,
  "language": "c",
  "cwe": "CWE-476",
  "commit_url": "https://github.com/MrE-Fog/heimdal/commit/1a6a6e462dc2ac6111f9e02c6852ddec4849b887",
  "commit_sha": "1a6a6e462dc2ac6111f9e02c6852ddec4849b887",
  "commit_msg": "Security: Avoid NULL structure pointer member dereference\n\nThis can happen in the error path when processing malformed AS\nrequests with a NULL client name.  Bug originally introduced on\nFri Feb 13 09:26:01 2015 +0100 in commit:\n\n    a873e21d7c06f22943a90a41dc733ae76799390d\n\n    kdc: base _kdc_fast_mk_error() on krb5_mk_error_ext()\n\nOriginal patch by Jeffrey Altman <jaltman@secure-endpoints.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "kdc/kerberos5.c",
  "func_name": "",
  "raw_func_from_json": "_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n     /*\n      * In case of a non proxy error, build an error message.\n      */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kdc_fast_mk_error(context, r,\n \t\t\t\t &error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n \t\t\t\t NULL, NULL,\n \t\t\t\t reply);\n \tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}\n",
  "diff_func": "@@ -2232,15 +2232,17 @@ _kdc_as_rep(kdc_request_t r,\n     /*\n      * In case of a non proxy error, build an error message.\n      */\n-    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n+    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kdc_fast_mk_error(context, r,\n \t\t\t\t &error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_princ,\n-\t\t\t\t &r->client_princ->name,\n-\t\t\t\t &r->client_princ->realm,\n+\t\t\t\t r->client_princ ?\n+                                     &r->client_princ->name : NULL,\n+\t\t\t\t r->client_princ ?\n+                                     &r->client_princ->realm : NULL,\n \t\t\t\t NULL, NULL,\n \t\t\t\t reply);\n \tif (ret)",
  "project": "heimdal",
  "commit_id": "1a6a6e462dc2ac6111f9e02c6852ddec4849b887",
  "target": 1,
  "func": "_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n     /*\n      * In case of a non proxy error, build an error message.\n      */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kdc_fast_mk_error(context, r,\n \t\t\t\t &error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n \t\t\t\t NULL, NULL,\n \t\t\t\t reply);\n \tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}\n",
  "big_vul_idx": 180826,
  "idx": 2380,
  "hash": 56768369760868757704328364106042737253
}