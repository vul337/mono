{
  "id": 1038,
  "language": "c",
  "cwe": [],
  "commit_url": "https://github.com/mitchcapper/wget/commit/59b920874daa565a1323ffa1e756e80493190686",
  "commit_sha": "59b920874daa565a1323ffa1e756e80493190686",
  "commit_msg": "Support non-ASCII URLs\n\n* src/url.c [HAVE_ICONV]: Include iconv.h and langinfo.h.\n(convert_fname): New function.\n[HAVE_ICONV]: Convert file name from remote encoding to local\nencoding.\n(url_file_name): Call convert_fname.\n(filechr_table): Don't consider bytes in 128..159 as control\ncharacters.\n\n* tests/Test-ftp-iri.px: Fix the expected file name to match the\nnew file-name recoding.  State the remote encoding explicitly on\nthe Wget command line.\n\n* NEWS: Mention the URI recoding when built with libiconv.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/url.c",
  "func_name": "else",
  "raw_func_from_json": "url_file_name (const struct url *u, char *replaced_filename)\n{\n  struct growable fnres;        /* stands for \"file name result\" */\n  struct growable temp_fnres;\n\n  const char *u_file;\n  char *fname, *unique, *fname_len_check;\n  const char *index_filename = \"index.html\"; /* The default index file is index.html */\n  size_t max_length;\n\n  fnres.base = NULL;\n  fnres.size = 0;\n  fnres.tail = 0;\n\n  temp_fnres.base = NULL;\n  temp_fnres.size = 0;\n  temp_fnres.tail = 0;\n\n  /* If an alternative index file was defined, change index_filename */\n  if (opt.default_page)\n    index_filename = opt.default_page;\n\n\n  /* Start with the directory prefix, if specified. */\n  if (opt.dir_prefix)\n    append_string (opt.dir_prefix, &fnres);\n\n  /* If \"dirstruct\" is turned on (typically the case with -r), add\n     the host and port (unless those have been turned off) and\n     directory structure.  */\n  if (opt.dirstruct)\n    {\n      if (opt.protocol_directories)\n        {\n          if (fnres.tail)\n            append_char ('/', &fnres);\n          append_string (supported_schemes[u->scheme].name, &fnres);\n        }\n      if (opt.add_hostdir)\n        {\n          if (fnres.tail)\n            append_char ('/', &fnres);\n          if (0 != strcmp (u->host, \"..\"))\n            append_string (u->host, &fnres);\n          else\n            /* Host name can come from the network; malicious DNS may\n               allow \"..\" to be resolved, causing us to write to\n               \"../<file>\".  Defang such host names.  */\n            append_string (\"%2E%2E\", &fnres);\n          if (u->port != scheme_default_port (u->scheme))\n            {\n              char portstr[24];\n              number_to_string (portstr, u->port);\n              append_char (FN_PORT_SEP, &fnres);\n              append_string (portstr, &fnres);\n            }\n        }\n\n      append_dir_structure (u, &fnres);\n    }\n\n  if (!replaced_filename)\n    {\n      /* Create the filename. */\n      u_file = *u->file ? u->file : index_filename;\n\n      /* Append \"?query\" to the file name, even if empty,\n       * and create fname_len_check. */\n      if (u->query)\n        fname_len_check = concat_strings (u_file, FN_QUERY_SEP_STR, u->query, NULL);\n      else\n        fname_len_check = strdupdelim (u_file, u_file + strlen (u_file));\n    }\n  else\n    {\n      u_file = replaced_filename;\n      fname_len_check = strdupdelim (u_file, u_file + strlen (u_file));\n    }\n\n  append_uri_pathel (fname_len_check,\n    fname_len_check + strlen (fname_len_check), false, &temp_fnres);\n\n  /* Zero-terminate the temporary file name. */\n  append_char ('\\0', &temp_fnres);\n\n  /* Check that the length of the file name is acceptable. */\n#ifdef WINDOWS\n  if (MAX_PATH > (fnres.tail + CHOMP_BUFFER + 2))\n    {\n      max_length = MAX_PATH - (fnres.tail + CHOMP_BUFFER + 2);\n      /* FIXME: In Windows a filename is usually limited to 255 characters.\n      To really be accurate you could call GetVolumeInformation() to get\n      lpMaximumComponentLength\n      */\n      if (max_length > 255)\n        {\n          max_length = 255;\n        }\n    }\n  else\n    {\n      max_length = 0;\n    }\n#else\n  max_length = get_max_length (fnres.base, fnres.tail, _PC_NAME_MAX) - CHOMP_BUFFER;\n#endif\n  if (max_length > 0 && strlen (temp_fnres.base) > max_length)\n    {\n      logprintf (LOG_NOTQUIET, \"The name is too long, %lu chars total.\\n\",\n          (unsigned long) strlen (temp_fnres.base));\n      logprintf (LOG_NOTQUIET, \"Trying to shorten...\\n\");\n\n      /* Shorten the file name. */\n      temp_fnres.base[max_length] = '\\0';\n\n      logprintf (LOG_NOTQUIET, \"New name is %s.\\n\", temp_fnres.base);\n    }\n\n  xfree (fname_len_check);\n\n  /* The filename has already been 'cleaned' by append_uri_pathel() above.  So,\n   * just append it. */\n  if (fnres.tail)\n    append_char ('/', &fnres);\n  append_string (temp_fnres.base, &fnres);\n\n  fname = fnres.base;\n\n  /* Make a final check that the path length is acceptable? */\n  /* TODO: check fnres.base for path length problem */\n\n  xfree (temp_fnres.base);\n\n  /* Check the cases in which the unique extensions are not used:\n     1) Clobbering is turned off (-nc).\n     2) Retrieval with regetting.\n     3) Timestamping is used.\n     4) Hierarchy is built.\n     5) Backups are specified.\n\n     The exception is the case when file does exist and is a\n     directory (see `mkalldirs' for explanation).  */\n\n  if (ALLOW_CLOBBER\n      && !(file_exists_p (fname) && !file_non_directory_p (fname)))\n    {\n      unique = fname;\n    }\n  else\n    {\n      unique = unique_name (fname, true);\n      if (unique != fname)\n        xfree (fname);\n    }\n\n/* On VMS, alter the name as required. */\n#ifdef __VMS\n  {\n    char *unique2;\n\n    unique2 = ods_conform( unique);\n    if (unique2 != unique)\n      {\n        xfree (unique);\n        unique = unique2;\n      }\n  }\n#endif /* def __VMS */\n\n  return unique;\n}",
  "diff_func": "@@ -43,6 +43,11 @@ as that of the covered work.  */\n #include \"host.h\"  /* for is_valid_ipv6_address */\n #include \"c-strcase.h\"\n \n+#if HAVE_ICONV\n+#include <iconv.h>\n+#include <langinfo.h>\n+#endif\n+\n #ifdef __VMS\n #include \"vms.h\"\n #endif /* def __VMS */\n@@ -1399,8 +1404,8 @@ UVWC, VC, VC, VC,  VC, VC, VC, VC,   /* NUL SOH STX ETX  EOT ENQ ACK BEL */\n    0,  0,  0,  0,   0,  0,  0,  0,   /* p   q   r   s    t   u   v   w   */\n    0,  0,  0,  0,   W,  0,  0,  C,   /* x   y   z   {    |   }   ~   DEL */\n \n-  C, C, C, C,  C, C, C, C,  C, C, C, C,  C, C, C, C, /* 128-143 */\n-  C, C, C, C,  C, C, C, C,  C, C, C, C,  C, C, C, C, /* 144-159 */\n+  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, /* 128-143 */\n+  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, /* 144-159 */\n   0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,\n   0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,\n \n@@ -1531,6 +1536,82 @@ append_uri_pathel (const char *b, const char *e, bool escaped,\n   append_null (dest);\n }\n \n+static char *\n+convert_fname (const char *fname)\n+{\n+  char *converted_fname = (char *)fname;\n+#if HAVE_ICONV\n+  const char *from_encoding = opt.encoding_remote;\n+  const char *to_encoding = opt.locale;\n+  iconv_t cd;\n+  size_t len, done, inlen, outlen;\n+  char *s;\n+  const char *orig_fname = fname;;\n+\n+  /* Defaults for remote and local encodings.  */\n+  if (!from_encoding)\n+    from_encoding = \"UTF-8\";\n+  if (!to_encoding)\n+    to_encoding = nl_langinfo (CODESET);\n+\n+  cd = iconv_open (to_encoding, from_encoding);\n+  if (cd == (iconv_t)(-1))\n+    logprintf (LOG_VERBOSE, _(\"Conversion from %s to %s isn't supported\\n\"),\n+\t       quote (from_encoding), quote (to_encoding));\n+  else\n+    {\n+      inlen = strlen (fname);\n+      len = outlen = inlen * 2;\n+      converted_fname = s = xmalloc (outlen + 1);\n+      done = 0;\n+\n+      for (;;)\n+\t{\n+\t  if (iconv (cd, &fname, &inlen, &s, &outlen) != (size_t)(-1)\n+\t      && iconv (cd, NULL, NULL, &s, &outlen) != (size_t)(-1))\n+\t    {\n+\t      *(converted_fname + len - outlen - done) = '\\0';\n+\t      iconv_close(cd);\n+\t      DEBUGP ((\"Converted file name '%s' (%s) -> '%s' (%s)\\n\",\n+\t\t       orig_fname, from_encoding, converted_fname, to_encoding));\n+\t      xfree (orig_fname);\n+\t      return converted_fname;\n+\t    }\n+\n+\t  /* Incomplete or invalid multibyte sequence */\n+\t  if (errno == EINVAL || errno == EILSEQ)\n+\t    {\n+\t      logprintf (LOG_VERBOSE,\n+\t\t\t _(\"Incomplete or invalid multibyte sequence encountered\\n\"));\n+\t      xfree (converted_fname);\n+\t      converted_fname = (char *)orig_fname;\n+\t      break;\n+\t    }\n+\t  else if (errno == E2BIG) /* Output buffer full */\n+\t    {\n+\t      done = len;\n+\t      len = outlen = done + inlen * 2;\n+\t      converted_fname = xrealloc (converted_fname, outlen + 1);\n+\t      s = converted_fname + done;\n+\t    }\n+\t  else /* Weird, we got an unspecified error */\n+\t    {\n+\t      logprintf (LOG_VERBOSE, _(\"Unhandled errno %d\\n\"), errno);\n+\t      xfree (converted_fname);\n+\t      converted_fname = (char *)orig_fname;\n+\t      break;\n+\t    }\n+\t}\n+      DEBUGP ((\"Failed to convert file name '%s' (%s) -> '?' (%s)\\n\",\n+\t       orig_fname, from_encoding, to_encoding));\n+    }\n+\n+    iconv_close(cd);\n+#endif\n+\n+  return converted_fname;\n+}\n+\n /* Append to DEST the directory structure that corresponds the\n    directory part of URL's path.  For example, if the URL is\n    http://server/dir1/dir2/file, this appends \"/dir1/dir2\".\n@@ -1706,6 +1787,8 @@ url_file_name (const struct url *u, char *replaced_filename)\n \n   xfree (temp_fnres.base);\n \n+  fname = convert_fname (fname);\n+\n   /* Check the cases in which the unique extensions are not used:\n      1) Clobbering is turned off (-nc).\n      2) Retrieval with regetting.",
  "func": "url_file_name (const struct url *u, char *replaced_filename)\n{\n  struct growable fnres;        /* stands for \"file name result\" */\n  struct growable temp_fnres;\n\n  const char *u_file;\n  char *fname, *unique, *fname_len_check;\n  const char *index_filename = \"index.html\"; /* The default index file is index.html */\n  size_t max_length;\n\n  fnres.base = NULL;\n  fnres.size = 0;\n  fnres.tail = 0;\n\n  temp_fnres.base = NULL;\n  temp_fnres.size = 0;\n  temp_fnres.tail = 0;\n\n  /* If an alternative index file was defined, change index_filename */\n  if (opt.default_page)\n    index_filename = opt.default_page;\n\n\n  /* Start with the directory prefix, if specified. */\n  if (opt.dir_prefix)\n    append_string (opt.dir_prefix, &fnres);\n\n  /* If \"dirstruct\" is turned on (typically the case with -r), add\n     the host and port (unless those have been turned off) and\n     directory structure.  */\n  if (opt.dirstruct)\n    {\n      if (opt.protocol_directories)\n        {\n          if (fnres.tail)\n            append_char ('/', &fnres);\n          append_string (supported_schemes[u->scheme].name, &fnres);\n        }\n      if (opt.add_hostdir)\n        {\n          if (fnres.tail)\n            append_char ('/', &fnres);\n          if (0 != strcmp (u->host, \"..\"))\n            append_string (u->host, &fnres);\n          else\n            /* Host name can come from the network; malicious DNS may\n               allow \"..\" to be resolved, causing us to write to\n               \"../<file>\".  Defang such host names.  */\n            append_string (\"%2E%2E\", &fnres);\n          if (u->port != scheme_default_port (u->scheme))\n            {\n              char portstr[24];\n              number_to_string (portstr, u->port);\n              append_char (FN_PORT_SEP, &fnres);\n              append_string (portstr, &fnres);\n            }\n        }\n\n      append_dir_structure (u, &fnres);\n    }\n\n  if (!replaced_filename)\n    {\n      /* Create the filename. */\n      u_file = *u->file ? u->file : index_filename;\n\n      /* Append \"?query\" to the file name, even if empty,\n       * and create fname_len_check. */\n      if (u->query)\n        fname_len_check = concat_strings (u_file, FN_QUERY_SEP_STR, u->query, NULL);\n      else\n        fname_len_check = strdupdelim (u_file, u_file + strlen (u_file));\n    }\n  else\n    {\n      u_file = replaced_filename;\n      fname_len_check = strdupdelim (u_file, u_file + strlen (u_file));\n    }\n\n  append_uri_pathel (fname_len_check,\n    fname_len_check + strlen (fname_len_check), false, &temp_fnres);\n\n  /* Zero-terminate the temporary file name. */\n  append_char ('\\0', &temp_fnres);\n\n  /* Check that the length of the file name is acceptable. */\n#ifdef WINDOWS\n  if (MAX_PATH > (fnres.tail + CHOMP_BUFFER + 2))\n    {\n      max_length = MAX_PATH - (fnres.tail + CHOMP_BUFFER + 2);\n      /* FIXME: In Windows a filename is usually limited to 255 characters.\n      To really be accurate you could call GetVolumeInformation() to get\n      lpMaximumComponentLength\n      */\n      if (max_length > 255)\n        {\n          max_length = 255;\n        }\n    }\n  else\n    {\n      max_length = 0;\n    }\n#else\n  max_length = get_max_length (fnres.base, fnres.tail, _PC_NAME_MAX) - CHOMP_BUFFER;\n#endif\n  if (max_length > 0 && strlen (temp_fnres.base) > max_length)\n    {\n      logprintf (LOG_NOTQUIET, \"The name is too long, %lu chars total.\\n\",\n          (unsigned long) strlen (temp_fnres.base));\n      logprintf (LOG_NOTQUIET, \"Trying to shorten...\\n\");\n\n      /* Shorten the file name. */\n      temp_fnres.base[max_length] = '\\0';\n\n      logprintf (LOG_NOTQUIET, \"New name is %s.\\n\", temp_fnres.base);\n    }\n\n  xfree (fname_len_check);\n\n  /* The filename has already been 'cleaned' by append_uri_pathel() above.  So,\n   * just append it. */\n  if (fnres.tail)\n    append_char ('/', &fnres);\n  append_string (temp_fnres.base, &fnres);\n\n  fname = fnres.base;\n\n  /* Make a final check that the path length is acceptable? */\n  /* TODO: check fnres.base for path length problem */\n\n  xfree (temp_fnres.base);\n\n  /* Check the cases in which the unique extensions are not used:\n     1) Clobbering is turned off (-nc).\n     2) Retrieval with regetting.\n     3) Timestamping is used.\n     4) Hierarchy is built.\n     5) Backups are specified.\n\n     The exception is the case when file does exist and is a\n     directory (see `mkalldirs' for explanation).  */\n\n  if (ALLOW_CLOBBER\n      && !(file_exists_p (fname) && !file_non_directory_p (fname)))\n    {\n      unique = fname;\n    }\n  else\n    {\n      unique = unique_name (fname, true);\n      if (unique != fname)\n        xfree (fname);\n    }\n\n/* On VMS, alter the name as required. */\n#ifdef __VMS\n  {\n    char *unique2;\n\n    unique2 = ods_conform( unique);\n    if (unique2 != unique)\n      {\n        xfree (unique);\n        unique = unique2;\n      }\n  }\n#endif /* def __VMS */\n\n  return unique;\n}",
  "target": 1,
  "project": "wget",
  "commit_id": "59b920874daa565a1323ffa1e756e80493190686",
  "hash": 248269352987592620345400062055884756082,
  "size": 171,
  "message": "Support non-ASCII URLs\n\n* src/url.c [HAVE_ICONV]: Include iconv.h and langinfo.h.\n(convert_fname): New function.\n[HAVE_ICONV]: Convert file name from remote encoding to local\nencoding.\n(url_file_name): Call convert_fname.\n(filechr_table): Don't consider bytes in 128..159 as control\ncharacters.\n\n* tests/Test-ftp-iri.px: Fix the expected file name to match the\nnew file-name recoding.  State the remote encoding explicitly on\nthe Wget command line.\n\n* NEWS: Mention the URI recoding when built with libiconv.",
  "dataset": "other",
  "idx": 215957
}