{
  "id": 827,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/sjp38/linux.personal/commit/ea25f914dc164c8d56b36147ecc86bc65f83c469",
  "commit_sha": "ea25f914dc164c8d56b36147ecc86bc65f83c469",
  "commit_msg": "bpf: fix missing error return in check_stack_boundary()\n\nPrevent indirect stack accesses at non-constant addresses, which would\npermit reading and corrupting spilled pointers.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "kernel/bpf/verifier.c",
  "func_name": "",
  "raw_func_from_json": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\n\t/* Only allow fixed-offset stack reads */\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\n \t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n \t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n \t\t\tregno, tn_buf);\n \t}\n \toff = regs[regno].off + regs[regno].var_off.value;\n \tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "diff_func": "@@ -1303,6 +1303,7 @@ static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n \t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n \t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n \t\t\tregno, tn_buf);\n+\t\treturn -EACCES;\n \t}\n \toff = regs[regno].off + regs[regno].var_off.value;\n \tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||",
  "project": "linux",
  "commit_id": "ea25f914dc164c8d56b36147ecc86bc65f83c469",
  "target": 1,
  "func": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\n\t/* Only allow fixed-offset stack reads */\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\n \t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n \t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n \t\t\tregno, tn_buf);\n \t}\n \toff = regs[regno].off + regs[regno].var_off.value;\n \tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "big_vul_idx": 180812,
  "idx": 2366,
  "hash": 100968769887024984694199990496086030146
}