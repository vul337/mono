{
  "id": 763,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/Matthias-Wandel/jhead/commit/5186ddcf9e35a7aa0ff0539489a930434a1325f4",
  "commit_sha": "5186ddcf9e35a7aa0ff0539489a930434a1325f4",
  "commit_msg": "Just allocate 20 bytes extra at the end of a section. Otherwise, we end\nup with a whole lot of little checks for structures that the file says\nare there but are unexpectedly cut off in fuzz tests",
  "pr_url": null,
  "pr_info": null,
  "file_name": "jpgfile.c",
  "func_name": "",
  "raw_func_from_json": "int ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\r\n{\r\n    int a;\r\n    int HaveCom = FALSE;\r\n\r\n    a = fgetc(infile);\r\n\r\n    if (a != 0xff || fgetc(infile) != M_SOI){\r\n        return FALSE;\r\n    }\r\n\r\n    ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;\r\n    ImageInfo.JfifHeader.ResolutionUnits = 1;\r\n\r\n    for(;;){\r\n        int itemlen;\r\n        int prev;\r\n        int marker = 0;\r\n        int ll,lh, got;\r\n        uchar * Data;\r\n\r\n        CheckSectionsAllocated();\r\n\r\n        prev = 0;\r\n        for (a=0;;a++){\r\n            marker = fgetc(infile);\r\n            if (marker != 0xff && prev == 0xff) break;\r\n            if (marker == EOF){\r\n                ErrFatal(\"Unexpected end of file\");\r\n            }\r\n            prev = marker;\r\n        }\r\n\r\n        if (a > 10){\r\n            ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);\r\n        }\r\n\r\n        Sections[SectionsRead].Type = marker;\r\n  \r\n        // Read the length of the section.\r\n        lh = fgetc(infile);\r\n        ll = fgetc(infile);\r\n        if (lh == EOF || ll == EOF){\r\n            ErrFatal(\"Unexpected end of file\");\r\n        }\r\n\r\n        itemlen = (lh << 8) | ll;\r\n\r\n        if (itemlen < 2){\r\n            ErrFatal(\"invalid marker\");\r\n        }\r\n\r\n        Sections[SectionsRead].Size = itemlen;\r\n\r\n        Data = (uchar *)malloc(itemlen);\r\n        if (Data == NULL){\r\n            ErrFatal(\"Could not allocate memory\");\r\n        }\r\n        Sections[SectionsRead].Data = Data;\r\n\r\n        // Store first two pre-read bytes.\r\n        Data[0] = (uchar)lh;\r\n        Data[1] = (uchar)ll;\r\n\r\n        got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section.\r\n        if (got != itemlen-2){\r\n            ErrFatal(\"Premature end of file?\");\r\n        }\r\n        SectionsRead += 1;\r\n\r\n        switch(marker){\r\n\r\n            case M_SOS:   // stop before hitting compressed data \r\n                // If reading entire image is requested, read the rest of the data.\r\n                if (ReadMode & READ_IMAGE){\r\n                    int cp, ep, size;\r\n                    // Determine how much file is left.\r\n                    cp = ftell(infile);\r\n                    fseek(infile, 0, SEEK_END);\r\n                    ep = ftell(infile);\r\n                    fseek(infile, cp, SEEK_SET);\r\n\r\n                    size = ep-cp;\r\n                    Data = (uchar *)malloc(size);\r\n                    if (Data == NULL){\r\n                        ErrFatal(\"could not allocate data for entire image\");\r\n                    }\r\n\r\n                    got = fread(Data, 1, size, infile);\r\n                    if (got != size){\r\n                        ErrFatal(\"could not read the rest of the image\");\r\n                    }\r\n\r\n                    CheckSectionsAllocated();\r\n                    Sections[SectionsRead].Data = Data;\r\n                    Sections[SectionsRead].Size = size;\r\n                    Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;\r\n                    SectionsRead ++;\r\n                    HaveAll = 1;\r\n                }\r\n                return TRUE;\r\n\r\n            case M_DQT:\r\n                // Use for jpeg quality guessing\r\n                process_DQT(Data, itemlen);\r\n                break;\r\n\r\n            case M_DHT:   \r\n                // Use for jpeg quality guessing\r\n                process_DHT(Data, itemlen);\r\n                break;\r\n\r\n\r\n            case M_EOI:   // in case it's a tables-only JPEG stream\r\n                fprintf(stderr,\"No image in jpeg!\\n\");\r\n                return FALSE;\r\n\r\n            case M_COM: // Comment section\r\n                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){\r\n                    // Discard this section.\r\n                    free(Sections[--SectionsRead].Data);\r\n                }else{\r\n                    process_COM(Data, itemlen);\r\n                    HaveCom = TRUE;\r\n                }\r\n                break;\r\n\r\n            case M_JFIF:\r\n                // Regular jpegs always have this tag, exif images have the exif\r\n                // marker instead, althogh ACDsee will write images with both markers.\r\n                // this program will re-create this marker on absence of exif marker.\r\n                // hence no need to keep the copy from the file.\r\n                if (itemlen < 16){\r\n                    fprintf(stderr,\"Jfif header too short\\n\");\r\n                    goto ignore;\r\n                }\r\n                if (memcmp(Data+2, \"JFIF\\0\",5)){\r\n                    fprintf(stderr,\"Header missing JFIF marker\\n\");\r\n                }\r\n\r\n                ImageInfo.JfifHeader.Present = TRUE;\r\n                ImageInfo.JfifHeader.ResolutionUnits = Data[9];\r\n                ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];\r\n                ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];\r\n                if (ShowTags){\r\n                    printf(\"JFIF SOI marker: Units: %d \",ImageInfo.JfifHeader.ResolutionUnits);\r\n                    switch(ImageInfo.JfifHeader.ResolutionUnits){\r\n                        case 0: printf(\"(aspect ratio)\"); break;\r\n                        case 1: printf(\"(dots per inch)\"); break;\r\n                        case 2: printf(\"(dots per cm)\"); break;\r\n                        default: printf(\"(unknown)\"); break;\r\n                    }\r\n                    printf(\"  X-density=%d Y-density=%d\\n\",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity);\r\n\r\n                    if (Data[14] || Data[15]){\r\n                        fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");\r\n                    }\r\n                }\r\n\r\n                ignore:\r\n\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_EXIF:\r\n                // There can be different section using the same marker.\r\n                if (ReadMode & READ_METADATA){\r\n                    if (memcmp(Data+2, \"Exif\", 4) == 0){\r\n                        process_EXIF(Data, itemlen);\r\n                        break;\r\n                    }else if (memcmp(Data+2, \"http:\", 5) == 0){\r\n                        Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes.\r\n                        if (ShowTags){\r\n                            printf(\"Image contains XMP section, %d bytes long\\n\", itemlen);\r\n                            if (ShowTags){\r\n                                ShowXmp(Sections[SectionsRead-1]);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                // Oterwise, discard this section.\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_IPTC:\r\n                if (ReadMode & READ_METADATA){\r\n                    if (ShowTags){\r\n                        printf(\"Image contains IPTC section, %d bytes long\\n\", itemlen);\r\n                    }\r\n                    // Note: We just store the IPTC section.  Its relatively straightforward\r\n                    // and we don't act on any part of it, so just display it at parse time.\r\n                }else{\r\n                    free(Sections[--SectionsRead].Data);\r\n                }\r\n                break;\r\n           \r\n            case M_SOF0: \r\n            case M_SOF1: \r\n            case M_SOF2: \r\n            case M_SOF3: \r\n            case M_SOF5: \r\n            case M_SOF6: \r\n            case M_SOF7: \r\n            case M_SOF9: \r\n            case M_SOF10:\r\n            case M_SOF11:\r\n            case M_SOF13:\r\n            case M_SOF14:\r\n            case M_SOF15:\r\n                if (itemlen < 8){\r\n                    fprintf(stderr,\"Section too short\\n\");\r\n                    break;\r\n                }\r\n                process_SOFn(Data, marker);\r\n                break;\r\n            default:\r\n                // Skip any other sections.\r\n                if (ShowTags){\r\n                    printf(\"Jpeg section marker 0x%02x size %d\\n\",marker, itemlen);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return TRUE;\r\n}\r",
  "diff_func": "@@ -169,7 +169,10 @@ int ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\n \r\n         Sections[SectionsRead].Size = itemlen;\r\n \r\n-        Data = (uchar *)malloc(itemlen);\r\n+        // Allocate an extra 20 bytes more than needed, because sometimes when reading structures,\r\n+        // if the section erroneously ends before short structures that should be there, that can trip\r\n+        // memory checkers in combination with fuzzers.\r\n+        Data = (uchar *)malloc(itemlen+20);\r\n         if (Data == NULL){\r\n             ErrFatal(\"Could not allocate memory\");\r\n         }\r\n@@ -476,7 +479,7 @@ int ReplaceThumbnail(const char * ThumbFileName)\n              return FALSE;\r\n         }\r\n \r\n-        ThumbLen = 0;\r\r\n+        ThumbLen = 0;\r\r\r\n         ThumbnailFile = NULL;\r\n     }\r\n \r",
  "func": "int ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\r\n{\r\n    int a;\r\n    int HaveCom = FALSE;\r\n\r\n    a = fgetc(infile);\r\n\r\n    if (a != 0xff || fgetc(infile) != M_SOI){\r\n        return FALSE;\r\n    }\r\n\r\n    ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;\r\n    ImageInfo.JfifHeader.ResolutionUnits = 1;\r\n\r\n    for(;;){\r\n        int itemlen;\r\n        int prev;\r\n        int marker = 0;\r\n        int ll,lh, got;\r\n        uchar * Data;\r\n\r\n        CheckSectionsAllocated();\r\n\r\n        prev = 0;\r\n        for (a=0;;a++){\r\n            marker = fgetc(infile);\r\n            if (marker != 0xff && prev == 0xff) break;\r\n            if (marker == EOF){\r\n                ErrFatal(\"Unexpected end of file\");\r\n            }\r\n            prev = marker;\r\n        }\r\n\r\n        if (a > 10){\r\n            ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);\r\n        }\r\n\r\n        Sections[SectionsRead].Type = marker;\r\n  \r\n        // Read the length of the section.\r\n        lh = fgetc(infile);\r\n        ll = fgetc(infile);\r\n        if (lh == EOF || ll == EOF){\r\n            ErrFatal(\"Unexpected end of file\");\r\n        }\r\n\r\n        itemlen = (lh << 8) | ll;\r\n\r\n        if (itemlen < 2){\r\n            ErrFatal(\"invalid marker\");\r\n        }\r\n\r\n        Sections[SectionsRead].Size = itemlen;\r\n\r\n        Data = (uchar *)malloc(itemlen);\r\n        if (Data == NULL){\r\n            ErrFatal(\"Could not allocate memory\");\r\n        }\r\n        Sections[SectionsRead].Data = Data;\r\n\r\n        // Store first two pre-read bytes.\r\n        Data[0] = (uchar)lh;\r\n        Data[1] = (uchar)ll;\r\n\r\n        got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section.\r\n        if (got != itemlen-2){\r\n            ErrFatal(\"Premature end of file?\");\r\n        }\r\n        SectionsRead += 1;\r\n\r\n        switch(marker){\r\n\r\n            case M_SOS:   // stop before hitting compressed data \r\n                // If reading entire image is requested, read the rest of the data.\r\n                if (ReadMode & READ_IMAGE){\r\n                    int cp, ep, size;\r\n                    // Determine how much file is left.\r\n                    cp = ftell(infile);\r\n                    fseek(infile, 0, SEEK_END);\r\n                    ep = ftell(infile);\r\n                    fseek(infile, cp, SEEK_SET);\r\n\r\n                    size = ep-cp;\r\n                    Data = (uchar *)malloc(size);\r\n                    if (Data == NULL){\r\n                        ErrFatal(\"could not allocate data for entire image\");\r\n                    }\r\n\r\n                    got = fread(Data, 1, size, infile);\r\n                    if (got != size){\r\n                        ErrFatal(\"could not read the rest of the image\");\r\n                    }\r\n\r\n                    CheckSectionsAllocated();\r\n                    Sections[SectionsRead].Data = Data;\r\n                    Sections[SectionsRead].Size = size;\r\n                    Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;\r\n                    SectionsRead ++;\r\n                    HaveAll = 1;\r\n                }\r\n                return TRUE;\r\n\r\n            case M_DQT:\r\n                // Use for jpeg quality guessing\r\n                process_DQT(Data, itemlen);\r\n                break;\r\n\r\n            case M_DHT:   \r\n                // Use for jpeg quality guessing\r\n                process_DHT(Data, itemlen);\r\n                break;\r\n\r\n\r\n            case M_EOI:   // in case it's a tables-only JPEG stream\r\n                fprintf(stderr,\"No image in jpeg!\\n\");\r\n                return FALSE;\r\n\r\n            case M_COM: // Comment section\r\n                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){\r\n                    // Discard this section.\r\n                    free(Sections[--SectionsRead].Data);\r\n                }else{\r\n                    process_COM(Data, itemlen);\r\n                    HaveCom = TRUE;\r\n                }\r\n                break;\r\n\r\n            case M_JFIF:\r\n                // Regular jpegs always have this tag, exif images have the exif\r\n                // marker instead, althogh ACDsee will write images with both markers.\r\n                // this program will re-create this marker on absence of exif marker.\r\n                // hence no need to keep the copy from the file.\r\n                if (itemlen < 16){\r\n                    fprintf(stderr,\"Jfif header too short\\n\");\r\n                    goto ignore;\r\n                }\r\n                if (memcmp(Data+2, \"JFIF\\0\",5)){\r\n                    fprintf(stderr,\"Header missing JFIF marker\\n\");\r\n                }\r\n\r\n                ImageInfo.JfifHeader.Present = TRUE;\r\n                ImageInfo.JfifHeader.ResolutionUnits = Data[9];\r\n                ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];\r\n                ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];\r\n                if (ShowTags){\r\n                    printf(\"JFIF SOI marker: Units: %d \",ImageInfo.JfifHeader.ResolutionUnits);\r\n                    switch(ImageInfo.JfifHeader.ResolutionUnits){\r\n                        case 0: printf(\"(aspect ratio)\"); break;\r\n                        case 1: printf(\"(dots per inch)\"); break;\r\n                        case 2: printf(\"(dots per cm)\"); break;\r\n                        default: printf(\"(unknown)\"); break;\r\n                    }\r\n                    printf(\"  X-density=%d Y-density=%d\\n\",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity);\r\n\r\n                    if (Data[14] || Data[15]){\r\n                        fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");\r\n                    }\r\n                }\r\n\r\n                ignore:\r\n\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_EXIF:\r\n                // There can be different section using the same marker.\r\n                if (ReadMode & READ_METADATA){\r\n                    if (memcmp(Data+2, \"Exif\", 4) == 0){\r\n                        process_EXIF(Data, itemlen);\r\n                        break;\r\n                    }else if (memcmp(Data+2, \"http:\", 5) == 0){\r\n                        Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes.\r\n                        if (ShowTags){\r\n                            printf(\"Image contains XMP section, %d bytes long\\n\", itemlen);\r\n                            if (ShowTags){\r\n                                ShowXmp(Sections[SectionsRead-1]);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                // Oterwise, discard this section.\r\n                free(Sections[--SectionsRead].Data);\r\n                break;\r\n\r\n            case M_IPTC:\r\n                if (ReadMode & READ_METADATA){\r\n                    if (ShowTags){\r\n                        printf(\"Image contains IPTC section, %d bytes long\\n\", itemlen);\r\n                    }\r\n                    // Note: We just store the IPTC section.  Its relatively straightforward\r\n                    // and we don't act on any part of it, so just display it at parse time.\r\n                }else{\r\n                    free(Sections[--SectionsRead].Data);\r\n                }\r\n                break;\r\n           \r\n            case M_SOF0: \r\n            case M_SOF1: \r\n            case M_SOF2: \r\n            case M_SOF3: \r\n            case M_SOF5: \r\n            case M_SOF6: \r\n            case M_SOF7: \r\n            case M_SOF9: \r\n            case M_SOF10:\r\n            case M_SOF11:\r\n            case M_SOF13:\r\n            case M_SOF14:\r\n            case M_SOF15:\r\n                if (itemlen < 8){\r\n                    fprintf(stderr,\"Section too short\\n\");\r\n                    break;\r\n                }\r\n                process_SOFn(Data, marker);\r\n                break;\r\n            default:\r\n                // Skip any other sections.\r\n                if (ShowTags){\r\n                    printf(\"Jpeg section marker 0x%02x size %d\\n\",marker, itemlen);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return TRUE;\r\n}\r",
  "project": "jhead",
  "hash": 109190490159385379929171220952643934796,
  "size": 226,
  "commit_id": "5186ddcf9e35a7aa0ff0539489a930434a1325f4",
  "message": "Just allocate 20 bytes extra at the end of a section. Otherwise, we end\nup with a whole lot of little checks for structures that the file says\nare there but are unexpectedly cut off in fuzz tests",
  "target": 1,
  "dataset": "other",
  "idx": 206412
}