{
  "id": 526,
  "language": "c",
  "cwe": "CWE-399",
  "commit_url": "https://github.com/ljalves/linux_media/commit/2b13d06c9584b4eb773f1e80bbaedab9a1c344e1",
  "commit_sha": "2b13d06c9584b4eb773f1e80bbaedab9a1c344e1",
  "commit_msg": "wanxl: fix info leak in ioctl\n\nThe wanxl_ioctl() code fails to initialize the two padding bytes of\nstruct sync_serial_settings after the ->loopback member. Add an explicit\nmemset(0) before filling the structure to avoid the info leak.\n\nSigned-off-by: Salva Peir√≥ <speiro@ai2.upv.es>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/net/wan/wanxl.c",
  "func_name": "",
  "raw_func_from_json": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n \t\t\tifr->ifr_settings.size = size; /* data size wanted */\n \t\t\treturn -ENOBUFS;\n \t\t}\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;\n\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; /* No such clock setting */\n\n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}\n",
  "diff_func": "@@ -355,6 +355,7 @@ static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n \t\t\tifr->ifr_settings.size = size; /* data size wanted */\n \t\t\treturn -ENOBUFS;\n \t\t}\n+\t\tmemset(&line, 0, sizeof(line));\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;",
  "project": "linux",
  "commit_id": "2b13d06c9584b4eb773f1e80bbaedab9a1c344e1",
  "target": 1,
  "func": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n \t\t\tifr->ifr_settings.size = size; /* data size wanted */\n \t\t\treturn -ENOBUFS;\n \t\t}\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;\n\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; /* No such clock setting */\n\n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}\n",
  "big_vul_idx": 179610,
  "idx": 1327,
  "hash": 289977000113180624110394930896450816184
}