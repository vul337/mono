{
  "id": 140,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/mittorn/virglrenderer/commit/28894a30a17a84529be102b21118e55d6c9f23fa",
  "commit_sha": "28894a30a17a84529be102b21118e55d6c9f23fa",
  "commit_msg": "gallium/tgsi: fix oob access in parse instruction\n\nWhen parsing texture instruction, it doesn't stop if the\n'cur' is ',', the loop variable 'i' will also be increased\nand be used to index the 'inst.TexOffsets' array. This can lead\nan oob access issue. This patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/gallium/auxiliary/tgsi/tgsi_text.c",
  "func_name": "",
  "raw_func_from_json": "parse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n \n    cur = ctx->cur;\n    eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n          cur++;\n          eat_opt_white( &cur );\n          ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n",
  "diff_func": "@@ -1097,7 +1097,7 @@ parse_instruction(\n \n    cur = ctx->cur;\n    eat_opt_white( &cur );\n-   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n+   for (i = 0; inst.Instruction.Texture && *cur == ',' && i < TGSI_FULL_MAX_TEX_OFFSETS; i++) {\n          cur++;\n          eat_opt_white( &cur );\n          ctx->cur = cur;",
  "project": "virglrenderer",
  "commit_id": "28894a30a17a84529be102b21118e55d6c9f23fa",
  "target": 1,
  "func": "parse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n \n    cur = ctx->cur;\n    eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n          cur++;\n          eat_opt_white( &cur );\n          ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n",
  "big_vul_idx": 178159,
  "idx": 254,
  "hash": 207706300612945852467345419819110560855
}