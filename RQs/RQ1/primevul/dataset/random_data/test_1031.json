{
  "id": 1031,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/HKL-Kevin/msm8998-mainline/commit/04c9b00ba83594a29813d6b1fb8fdc93a3915174",
  "commit_sha": "04c9b00ba83594a29813d6b1fb8fdc93a3915174",
  "commit_msg": "can: mcba_usb: mcba_usb_start_xmit(): fix double dev_kfree_skb in error path\n\nThere is no need to call dev_kfree_skb() when usb_submit_urb() fails\nbecause can_put_echo_skb() deletes original skb and\ncan_free_echo_skb() deletes the cloned skb.\n\nFixes: 51f3baad7de9 (\"can: mcba_usb: Add support for Microchip CAN BUS Analyzer\")\nLink: https://lore.kernel.org/all/20220311080208.45047-1-hbh25y@gmail.com\nSigned-off-by: Hangyu Hua <hbh25y@gmail.com>\nSigned-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/net/can/usb/mcba_usb.c",
  "func_name": "",
  "raw_func_from_json": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t/* store 28-18 bits */\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t/* store 17-16 bits */\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t/* store 15-0 bits */\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
  "diff_func": "@@ -364,7 +364,6 @@ static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n xmit_failed:\n \tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n \tmcba_usb_free_ctx(ctx);\n-\tdev_kfree_skb(skb);\n \tstats->tx_dropped++;\n \n \treturn NETDEV_TX_OK;",
  "func": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t/* store 28-18 bits */\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t/* store 17-16 bits */\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t/* store 15-0 bits */\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
  "project": "linux",
  "hash": 273216865611265197222085391246765638267,
  "size": 65,
  "commit_id": "04c9b00ba83594a29813d6b1fb8fdc93a3915174",
  "message": "can: mcba_usb: mcba_usb_start_xmit(): fix double dev_kfree_skb in error path\n\nThere is no need to call dev_kfree_skb() when usb_submit_urb() fails\nbecause can_put_echo_skb() deletes original skb and\ncan_free_echo_skb() deletes the cloned skb.\n\nFixes: 51f3baad7de9 (\"can: mcba_usb: Add support for Microchip CAN BUS Analyzer\")\nLink: https://lore.kernel.org/all/20220311080208.45047-1-hbh25y@gmail.com\nSigned-off-by: Hangyu Hua <hbh25y@gmail.com>\nSigned-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",
  "target": 1,
  "dataset": "other",
  "idx": 210527
}