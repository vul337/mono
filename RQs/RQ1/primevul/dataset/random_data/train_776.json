{
  "id": 776,
  "language": "c",
  "cwe": "CWE-284",
  "commit_url": "https://github.com/ljalves/linux_media/commit/999653786df6954a31044528ac3f7a5dadca08f4",
  "commit_sha": "999653786df6954a31044528ac3f7a5dadca08f4",
  "commit_msg": "nfsd: check permissions when setting ACLs\n\nUse set_posix_acl, which includes proper permission checks, instead of\ncalling ->set_acl directly.  Without this anyone may be able to grant\nthemselves permissions to a file by setting the ACL.\n\nLock the inode to make the new checks atomic with respect to set_acl.\n(Also, nfsd was the only caller of set_acl not locking the inode, so I\nsuspect this may fix other races.)\n\nThis also simplifies the code, and ensures our ACLs are checked by\nposix_acl_valid.\n\nThe permission checks and the inode locking were lost with commit\n4ac7249e, which changed nfsd to use the set_acl inode operation directly\ninstead of going through xattr handlers.\n\nReported-by: David Sinquin <david@sinquin.eu>\n[agreunba@redhat.com: use set_posix_acl]\nFixes: 4ac7249e\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/nfsd/nfs2acl.c",
  "func_name": "",
  "raw_func_from_json": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n \tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n \nout_drop_write:\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfs3svc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}\n",
  "diff_func": "@@ -104,22 +104,21 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \tif (error)\n-\t\tgoto out_drop_write;\n+\t\tgoto out_drop_lock;\n+\n+\tfh_unlock(fh);\n \n \tfh_drop_write(fh);\n \n@@ -131,7 +130,8 @@ static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n \tposix_acl_release(argp->acl_access);\n \tposix_acl_release(argp->acl_default);\n \treturn nfserr;\n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);",
  "project": "linux",
  "commit_id": "999653786df6954a31044528ac3f7a5dadca08f4",
  "target": 1,
  "func": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n \tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n \nout_drop_write:\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfs3svc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}\n",
  "big_vul_idx": 180620,
  "idx": 2196,
  "hash": 90832810491214471515114484934224730157
}