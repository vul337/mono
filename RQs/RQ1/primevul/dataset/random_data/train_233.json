{
  "id": 233,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/amartinz/BusyBox-Android-NDK/commit/352f79acbd759c14399e39baef21fc4ffe180ac2",
  "commit_sha": "352f79acbd759c14399e39baef21fc4ffe180ac2",
  "commit_msg": "udhcpc: fix OPTION_6RD parsing (could overflow its malloced buffer)\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "networking/udhcp/common.c",
  "func_name": "",
  "raw_func_from_json": "static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_optflag *optflag, const char *opt_name)\n{\n\tunsigned upper_length;\n\tint len, type, optlen;\n\tchar *dest, *ret;\n\n\t/* option points to OPT_DATA, need to go back to get OPT_LEN */\n\tlen = option[-OPT_DATA + OPT_LEN];\n\n \ttype = optflag->flags & OPTION_TYPE_MASK;\n \toptlen = dhcp_option_lengths[type];\n \tupper_length = len_of_option_as_string[type]\n\t\t* ((unsigned)(len + optlen - 1) / (unsigned)optlen);\n \n \tdest = ret = xmalloc(upper_length + strlen(opt_name) + 2);\n \tdest += sprintf(ret, \"%s=\", opt_name);\n\n\twhile (len >= optlen) {\n\t\tswitch (type) {\n\t\tcase OPTION_IP:\n\t\tcase OPTION_IP_PAIR:\n\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\tif (type == OPTION_IP)\n\t\t\t\tbreak;\n\t\t\tdest += sprint_nip(dest, \"/\", option + 4);\n\t\t\tbreak;\n\t\tcase OPTION_U8:\n\t\t\tdest += sprintf(dest, \"%u\", *option);\n\t\t\tbreak;\n\t\tcase OPTION_U16: {\n\t\t\tuint16_t val_u16;\n\t\t\tmove_from_unaligned16(val_u16, option);\n\t\t\tdest += sprintf(dest, \"%u\", ntohs(val_u16));\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32:\n\t\tcase OPTION_U32: {\n\t\t\tuint32_t val_u32;\n\t\t\tmove_from_unaligned32(val_u32, option);\n\t\t\tdest += sprintf(dest, type == OPTION_U32 ? \"%lu\" : \"%ld\", (unsigned long) ntohl(val_u32));\n\t\t\tbreak;\n\t\t}\n\t\t/* Note: options which use 'return' instead of 'break'\n\t\t * (for example, OPTION_STRING) skip the code which handles\n\t\t * the case of list of options.\n\t\t */\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_STRING_HOST:\n\t\t\tmemcpy(dest, option, len);\n\t\t\tdest[len] = '\\0';\n\t\t\tif (type == OPTION_STRING_HOST && !good_hostname(dest))\n\t\t\t\tsafe_strncpy(dest, \"bad\", len);\n\t\t\treturn ret;\n\t\tcase OPTION_STATIC_ROUTES: {\n\t\t\t/* Option binary format:\n\t\t\t * mask [one byte, 0..32]\n\t\t\t * ip [big endian, 0..4 bytes depending on mask]\n\t\t\t * router [big endian, 4 bytes]\n\t\t\t * may be repeated\n\t\t\t *\n\t\t\t * We convert it to a string \"IP/MASK ROUTER IP2/MASK2 ROUTER2\"\n\t\t\t */\n\t\t\tconst char *pfx = \"\";\n\n\t\t\twhile (len >= 1 + 4) { /* mask + 0-byte ip + router */\n\t\t\t\tuint32_t nip;\n\t\t\t\tuint8_t *p;\n\t\t\t\tunsigned mask;\n\t\t\t\tint bytes;\n\n\t\t\t\tmask = *option++;\n\t\t\t\tif (mask > 32)\n\t\t\t\t\tbreak;\n\t\t\t\tlen--;\n\n\t\t\t\tnip = 0;\n\t\t\t\tp = (void*) &nip;\n\t\t\t\tbytes = (mask + 7) / 8; /* 0 -> 0, 1..8 -> 1, 9..16 -> 2 etc */\n\t\t\t\twhile (--bytes >= 0) {\n\t\t\t\t\t*p++ = *option++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\t\t\t\tif (len < 4)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* print ip/mask */\n\t\t\t\tdest += sprint_nip(dest, pfx, (void*) &nip);\n\t\t\t\tpfx = \" \";\n\t\t\t\tdest += sprintf(dest, \"/%u \", mask);\n\t\t\t\t/* print router */\n\t\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\t\toption += 4;\n\t\t\t\tlen -= 4;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\tcase OPTION_6RD:\n\t\t\t/* Option binary format (see RFC 5969):\n\t\t\t *  0                   1                   2                   3\n\t\t\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |  OPTION_6RD   | option-length |  IPv4MaskLen  |  6rdPrefixLen |\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |                           6rdPrefix                           |\n\t\t\t * ...                        (16 octets)                        ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * ...                   6rdBRIPv4Address(es)                    ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * We convert it to a string\n\t\t\t * \"IPv4MaskLen 6rdPrefixLen 6rdPrefix 6rdBRIPv4Address...\"\n\t\t\t *\n\t\t\t * Sanity check: ensure that our length is at least 22 bytes, that\n\t\t\t * IPv4MaskLen <= 32,\n\t\t\t * 6rdPrefixLen <= 128,\n\t\t\t * 6rdPrefixLen + (32 - IPv4MaskLen) <= 128\n\t\t\t * (2nd condition need no check - it follows from 1st and 3rd).\n\t\t\t * Else, return envvar with empty value (\"optname=\")\n\t\t\t */\n\t\t\tif (len >= (1 + 1 + 16 + 4)\n\t\t\t && option[0] <= 32\n\t\t\t && (option[1] + 32 - option[0]) <= 128\n\t\t\t) {\n\t\t\t\t/* IPv4MaskLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefixLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefix */\n\t\t\t\tdest += sprint_nip6(dest, /* \"\", */ option);\n\t\t\t\toption += 16;\n\t\t\t\tlen -= 1 + 1 + 16 + 4;\n\t\t\t\t/* \"+ 4\" above corresponds to the length of IPv4 addr\n\t\t\t\t * we consume in the loop below */\n\t\t\t\twhile (1) {\n\t\t\t\t\t/* 6rdBRIPv4Address(es) */\n\t\t\t\t\tdest += sprint_nip(dest, \" \", option);\n\t\t\t\t\toption += 4;\n\t\t\t\t\tlen -= 4; /* do we have yet another 4+ bytes? */\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak; /* no */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n\t\t\t/* unpack option into dest; use ret for prefix (i.e., \"optname=\") */\n\t\t\tdest = dname_dec(option, len, ret);\n\t\t\tif (dest) {\n\t\t\t\tfree(ret);\n\t\t\t\treturn dest;\n\t\t\t}\n\t\t\t/* error. return \"optname=\" string */\n\t\t\treturn ret;\n\t\tcase OPTION_SIP_SERVERS:\n\t\t\t/* Option binary format:\n\t\t\t * type: byte\n\t\t\t * type=0: domain names, dns-compressed\n\t\t\t * type=1: IP addrs\n\t\t\t */\n\t\t\toption++;\n\t\t\tlen--;\n\t\t\tif (option[-1] == 0) {\n\t\t\t\tdest = dname_dec(option, len, ret);\n\t\t\t\tif (dest) {\n\t\t\t\t\tfree(ret);\n\t\t\t\t\treturn dest;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif (option[-1] == 1) {\n\t\t\t\tconst char *pfx = \"\";\n\t\t\t\twhile (1) {\n\t\t\t\t\tlen -= 4;\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdest += sprint_nip(dest, pfx, option);\n\t\t\t\t\tpfx = \" \";\n\t\t\t\t\toption += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n#endif\n\t\t} /* switch */\n\n\t\t/* If we are here, try to format any remaining data\n\t\t * in the option as another, similarly-formatted option\n\t\t */\n\t\toption += optlen;\n\t\tlen -= optlen;\n\t\tif (len < optlen /* || !(optflag->flags & OPTION_LIST) */)\n\t\t\tbreak;\n\t\t*dest++ = ' ';\n\t\t*dest = '\\0';\n\t} /* while */\n\n\treturn ret;\n}\n",
  "diff_func": "@@ -142,7 +142,7 @@ const char dhcp_option_strings[] ALIGN1 =\n  * udhcp_str2optset: to determine how many bytes to allocate.\n  * xmalloc_optname_optval: to estimate string length\n  * from binary option length: (option[LEN] / dhcp_option_lengths[opt_type])\n- * is the number of elements, multiply in by one element's string width\n+ * is the number of elements, multiply it by one element's string width\n  * (len_of_option_as_string[opt_type]) and you know how wide string you need.\n  */\n const uint8_t dhcp_option_lengths[] ALIGN1 = {\n@@ -162,7 +162,18 @@ const uint8_t dhcp_option_lengths[] ALIGN1 = {\n \t[OPTION_S32] =     4,\n \t/* Just like OPTION_STRING, we use minimum length here */\n \t[OPTION_STATIC_ROUTES] = 5,\n-\t[OPTION_6RD] =    22,  /* ignored by udhcp_str2optset */\n+\t[OPTION_6RD] =    12,  /* ignored by udhcp_str2optset */\n+\t/* The above value was chosen as follows:\n+\t * len_of_option_as_string[] for this option is >60: it's a string of the form\n+\t * \"32 128 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff 255.255.255.255 \".\n+\t * Each additional ipv4 address takes 4 bytes in binary option and appends\n+\t * another \"255.255.255.255 \" 16-byte string. We can set [OPTION_6RD] = 4\n+\t * but this severely overestimates string length: instead of 16 bytes,\n+\t * it adds >60 for every 4 bytes in binary option.\n+\t * We cheat and declare here that option is in units of 12 bytes.\n+\t * This adds more than 60 bytes for every three ipv4 addresses - more than enough.\n+\t * (Even 16 instead of 12 should work, but let's be paranoid).\n+\t */\n };\n \n ",
  "project": "busybox",
  "commit_id": "352f79acbd759c14399e39baef21fc4ffe180ac2",
  "target": 1,
  "func": "static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_optflag *optflag, const char *opt_name)\n{\n\tunsigned upper_length;\n\tint len, type, optlen;\n\tchar *dest, *ret;\n\n\t/* option points to OPT_DATA, need to go back to get OPT_LEN */\n\tlen = option[-OPT_DATA + OPT_LEN];\n\n \ttype = optflag->flags & OPTION_TYPE_MASK;\n \toptlen = dhcp_option_lengths[type];\n \tupper_length = len_of_option_as_string[type]\n\t\t* ((unsigned)(len + optlen - 1) / (unsigned)optlen);\n \n \tdest = ret = xmalloc(upper_length + strlen(opt_name) + 2);\n \tdest += sprintf(ret, \"%s=\", opt_name);\n\n\twhile (len >= optlen) {\n\t\tswitch (type) {\n\t\tcase OPTION_IP:\n\t\tcase OPTION_IP_PAIR:\n\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\tif (type == OPTION_IP)\n\t\t\t\tbreak;\n\t\t\tdest += sprint_nip(dest, \"/\", option + 4);\n\t\t\tbreak;\n\t\tcase OPTION_U8:\n\t\t\tdest += sprintf(dest, \"%u\", *option);\n\t\t\tbreak;\n\t\tcase OPTION_U16: {\n\t\t\tuint16_t val_u16;\n\t\t\tmove_from_unaligned16(val_u16, option);\n\t\t\tdest += sprintf(dest, \"%u\", ntohs(val_u16));\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32:\n\t\tcase OPTION_U32: {\n\t\t\tuint32_t val_u32;\n\t\t\tmove_from_unaligned32(val_u32, option);\n\t\t\tdest += sprintf(dest, type == OPTION_U32 ? \"%lu\" : \"%ld\", (unsigned long) ntohl(val_u32));\n\t\t\tbreak;\n\t\t}\n\t\t/* Note: options which use 'return' instead of 'break'\n\t\t * (for example, OPTION_STRING) skip the code which handles\n\t\t * the case of list of options.\n\t\t */\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_STRING_HOST:\n\t\t\tmemcpy(dest, option, len);\n\t\t\tdest[len] = '\\0';\n\t\t\tif (type == OPTION_STRING_HOST && !good_hostname(dest))\n\t\t\t\tsafe_strncpy(dest, \"bad\", len);\n\t\t\treturn ret;\n\t\tcase OPTION_STATIC_ROUTES: {\n\t\t\t/* Option binary format:\n\t\t\t * mask [one byte, 0..32]\n\t\t\t * ip [big endian, 0..4 bytes depending on mask]\n\t\t\t * router [big endian, 4 bytes]\n\t\t\t * may be repeated\n\t\t\t *\n\t\t\t * We convert it to a string \"IP/MASK ROUTER IP2/MASK2 ROUTER2\"\n\t\t\t */\n\t\t\tconst char *pfx = \"\";\n\n\t\t\twhile (len >= 1 + 4) { /* mask + 0-byte ip + router */\n\t\t\t\tuint32_t nip;\n\t\t\t\tuint8_t *p;\n\t\t\t\tunsigned mask;\n\t\t\t\tint bytes;\n\n\t\t\t\tmask = *option++;\n\t\t\t\tif (mask > 32)\n\t\t\t\t\tbreak;\n\t\t\t\tlen--;\n\n\t\t\t\tnip = 0;\n\t\t\t\tp = (void*) &nip;\n\t\t\t\tbytes = (mask + 7) / 8; /* 0 -> 0, 1..8 -> 1, 9..16 -> 2 etc */\n\t\t\t\twhile (--bytes >= 0) {\n\t\t\t\t\t*p++ = *option++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\t\t\t\tif (len < 4)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* print ip/mask */\n\t\t\t\tdest += sprint_nip(dest, pfx, (void*) &nip);\n\t\t\t\tpfx = \" \";\n\t\t\t\tdest += sprintf(dest, \"/%u \", mask);\n\t\t\t\t/* print router */\n\t\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\t\toption += 4;\n\t\t\t\tlen -= 4;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\tcase OPTION_6RD:\n\t\t\t/* Option binary format (see RFC 5969):\n\t\t\t *  0                   1                   2                   3\n\t\t\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |  OPTION_6RD   | option-length |  IPv4MaskLen  |  6rdPrefixLen |\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |                           6rdPrefix                           |\n\t\t\t * ...                        (16 octets)                        ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * ...                   6rdBRIPv4Address(es)                    ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * We convert it to a string\n\t\t\t * \"IPv4MaskLen 6rdPrefixLen 6rdPrefix 6rdBRIPv4Address...\"\n\t\t\t *\n\t\t\t * Sanity check: ensure that our length is at least 22 bytes, that\n\t\t\t * IPv4MaskLen <= 32,\n\t\t\t * 6rdPrefixLen <= 128,\n\t\t\t * 6rdPrefixLen + (32 - IPv4MaskLen) <= 128\n\t\t\t * (2nd condition need no check - it follows from 1st and 3rd).\n\t\t\t * Else, return envvar with empty value (\"optname=\")\n\t\t\t */\n\t\t\tif (len >= (1 + 1 + 16 + 4)\n\t\t\t && option[0] <= 32\n\t\t\t && (option[1] + 32 - option[0]) <= 128\n\t\t\t) {\n\t\t\t\t/* IPv4MaskLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefixLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefix */\n\t\t\t\tdest += sprint_nip6(dest, /* \"\", */ option);\n\t\t\t\toption += 16;\n\t\t\t\tlen -= 1 + 1 + 16 + 4;\n\t\t\t\t/* \"+ 4\" above corresponds to the length of IPv4 addr\n\t\t\t\t * we consume in the loop below */\n\t\t\t\twhile (1) {\n\t\t\t\t\t/* 6rdBRIPv4Address(es) */\n\t\t\t\t\tdest += sprint_nip(dest, \" \", option);\n\t\t\t\t\toption += 4;\n\t\t\t\t\tlen -= 4; /* do we have yet another 4+ bytes? */\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak; /* no */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n\t\t\t/* unpack option into dest; use ret for prefix (i.e., \"optname=\") */\n\t\t\tdest = dname_dec(option, len, ret);\n\t\t\tif (dest) {\n\t\t\t\tfree(ret);\n\t\t\t\treturn dest;\n\t\t\t}\n\t\t\t/* error. return \"optname=\" string */\n\t\t\treturn ret;\n\t\tcase OPTION_SIP_SERVERS:\n\t\t\t/* Option binary format:\n\t\t\t * type: byte\n\t\t\t * type=0: domain names, dns-compressed\n\t\t\t * type=1: IP addrs\n\t\t\t */\n\t\t\toption++;\n\t\t\tlen--;\n\t\t\tif (option[-1] == 0) {\n\t\t\t\tdest = dname_dec(option, len, ret);\n\t\t\t\tif (dest) {\n\t\t\t\t\tfree(ret);\n\t\t\t\t\treturn dest;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif (option[-1] == 1) {\n\t\t\t\tconst char *pfx = \"\";\n\t\t\t\twhile (1) {\n\t\t\t\t\tlen -= 4;\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdest += sprint_nip(dest, pfx, option);\n\t\t\t\t\tpfx = \" \";\n\t\t\t\t\toption += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n#endif\n\t\t} /* switch */\n\n\t\t/* If we are here, try to format any remaining data\n\t\t * in the option as another, similarly-formatted option\n\t\t */\n\t\toption += optlen;\n\t\tlen -= optlen;\n\t\tif (len < optlen /* || !(optflag->flags & OPTION_LIST) */)\n\t\t\tbreak;\n\t\t*dest++ = ' ';\n\t\t*dest = '\\0';\n\t} /* while */\n\n\treturn ret;\n}\n",
  "big_vul_idx": 178521,
  "idx": 461,
  "hash": 126744712125939498246335946299723440030
}