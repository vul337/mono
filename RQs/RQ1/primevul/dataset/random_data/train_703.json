{
  "id": 703,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/zidel/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd",
  "commit_sha": "a66628e425db725df1ac52a3c573a03357060ddd",
  "commit_msg": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12395\nChange-Id: I43b458a73b0934e9a5c2c89d34eac5a8f21a7455\nReviewed-on: https://code.wireshark.org/review/15223\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "wiretap/cosine.c",
  "func_name": "",
  "raw_func_from_json": "parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    char *line, int *err, gchar **err_info)\n {\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tint\tnum_items_scanned;\n\tint\tyy, mm, dd, hr, min, sec, csec;\n\tguint\tpkt_len;\n \tint\tpro, off, pri, rm, error;\n \tguint\tcode1, code2;\n \tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n\tstruct\ttm tm;\n\tguint8 *pd;\n\tint\ti, hex_lines, n, caplen = 0;\n\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\n \t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n \t\t/* appears to be output to a control blade */\n \t\tnum_items_scanned = sscanf(line,\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 17) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\n\t\t\treturn FALSE;\n\t\t}\n \t} else {\n \t\t/* appears to be output to PE */\n \t\tnum_items_scanned = sscanf(line,\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n \t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 10) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\n\t\t\treturn FALSE;\n \t\t}\n \t\tyy = mm = dd = hr = min = sec = csec = 0;\n \t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\ttm.tm_year = yy - 1900;\n\ttm.tm_mon = mm - 1;\n\ttm.tm_mday = dd;\n\ttm.tm_hour = hr;\n\ttm.tm_min = min;\n\ttm.tm_sec = sec;\n\ttm.tm_isdst = -1;\n\tphdr->ts.secs = mktime(&tm);\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->len = pkt_len;\n\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\n\t   Frame Relay and ATM */\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\n\t} else {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\n\t}\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\n\t}\n\tg_strlcpy(pseudo_header->cosine.if_name, if_name,\n\t\tCOSINE_MAX_IF_NAME_LEN);\n\tpseudo_header->cosine.pro = pro;\n\tpseudo_header->cosine.off = off;\n\tpseudo_header->cosine.pri = pri;\n\tpseudo_header->cosine.rm = rm;\n\tpseudo_header->cosine.err = error;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tcaplen += n;\n\t}\n\tphdr->caplen = caplen;\n\treturn TRUE;\n}\n",
  "diff_func": "@@ -330,8 +330,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n {\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tint\tnum_items_scanned;\n-\tint\tyy, mm, dd, hr, min, sec, csec;\n-\tguint\tpkt_len;\n+\tint\tyy, mm, dd, hr, min, sec, csec, pkt_len;\n \tint\tpro, off, pri, rm, error;\n \tguint\tcode1, code2;\n \tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n@@ -343,7 +342,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n \t\t/* appears to be output to a control blade */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n@@ -357,7 +356,7 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t} else {\n \t\t/* appears to be output to PE */\n \t\tnum_items_scanned = sscanf(line,\n-\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n+\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n \t\t\t\t   &code1, &code2);\n@@ -369,6 +368,11 @@ parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t\t}\n \t\tyy = mm = dd = hr = min = sec = csec = 0;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"cosine: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying",
  "project": "wireshark",
  "commit_id": "a66628e425db725df1ac52a3c573a03357060ddd",
  "target": 1,
  "func": "parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    char *line, int *err, gchar **err_info)\n {\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tint\tnum_items_scanned;\n\tint\tyy, mm, dd, hr, min, sec, csec;\n\tguint\tpkt_len;\n \tint\tpro, off, pri, rm, error;\n \tguint\tcode1, code2;\n \tchar\tif_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";\n\tstruct\ttm tm;\n\tguint8 *pd;\n\tint\ti, hex_lines, n, caplen = 0;\n\n\tif (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",\n \t\t   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\n \t\t/* appears to be output to a control blade */\n \t\tnum_items_scanned = sscanf(line,\n\t\t   \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t&yy, &mm, &dd, &hr, &min, &sec, &csec,\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n\t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 17) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: purported control blade line doesn't have code values\");\n\t\t\treturn FALSE;\n\t\t}\n \t} else {\n \t\t/* appears to be output to PE */\n \t\tnum_items_scanned = sscanf(line,\n\t\t   \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",\n \t\t\t\t   direction, if_name, &pkt_len,\n \t\t\t\t   &pro, &off, &pri, &rm, &error,\n \t\t\t\t   &code1, &code2);\n\n\t\tif (num_items_scanned != 10) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: header line is neither control blade nor PE output\");\n\t\t\treturn FALSE;\n \t\t}\n \t\tyy = mm = dd = hr = min = sec = csec = 0;\n \t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"cosine: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\ttm.tm_year = yy - 1900;\n\ttm.tm_mon = mm - 1;\n\ttm.tm_mday = dd;\n\ttm.tm_hour = hr;\n\ttm.tm_min = min;\n\ttm.tm_sec = sec;\n\ttm.tm_isdst = -1;\n\tphdr->ts.secs = mktime(&tm);\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->len = pkt_len;\n\n\t/* XXX need to handle other encapsulations like Cisco HDLC,\n\t   Frame Relay and ATM */\n\tif (strncmp(if_name, \"TEST:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_TEST;\n\t} else if (strncmp(if_name, \"PPoATM:\", 7) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\n\t} else if (strncmp(if_name, \"PPoFR:\", 6) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\n\t} else if (strncmp(if_name, \"ATM:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ATM;\n\t} else if (strncmp(if_name, \"FR:\", 3) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_FR;\n\t} else if (strncmp(if_name, \"HDLC:\", 5) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\n\t} else if (strncmp(if_name, \"PPP:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_PPP;\n\t} else if (strncmp(if_name, \"ETH:\", 4) == 0) {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_ETH;\n\t} else {\n\t\tpseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\n\t}\n\tif (strncmp(direction, \"l2-tx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_TX;\n\t} else if (strncmp(direction, \"l2-rx\", 5) == 0) {\n\t\tpseudo_header->cosine.direction = COSINE_DIR_RX;\n\t}\n\tg_strlcpy(pseudo_header->cosine.if_name, if_name,\n\t\tCOSINE_MAX_IF_NAME_LEN);\n\tpseudo_header->cosine.pro = pro;\n\tpseudo_header->cosine.off = off;\n\tpseudo_header->cosine.pri = pri;\n\tpseudo_header->cosine.rm = rm;\n\tpseudo_header->cosine.err = error;\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (empty_line(line)) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup(\"cosine: hex dump line doesn't have 16 numbers\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tcaplen += n;\n\t}\n\tphdr->caplen = caplen;\n\treturn TRUE;\n}\n",
  "big_vul_idx": 180322,
  "idx": 1925,
  "hash": 775128632240788716577692590477050856
}