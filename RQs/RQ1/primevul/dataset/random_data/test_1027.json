{
  "id": 1027,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/jcomeauictx/casperscript/commit/366ad48d076c1aa4c8f83c65011258a04e348207",
  "commit_sha": "366ad48d076c1aa4c8f83c65011258a04e348207",
  "commit_msg": "Bug 701815: avoid uninitialised bytes being >7, which broke indexing.\n\nFixes:\n    ./sanbin/gs -dBATCH -dNOPAUSE -sOutputFile=tmp -sDEVICE=jetp3852 ../bug-701815.pdf",
  "pr_url": null,
  "pr_info": null,
  "file_name": "devices/gdev3852.c",
  "func_name": "",
  "raw_func_from_json": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n\n    /* Set initial condition for printer */\n    gp_fputs(\"\\033@\",prn_stream);\n\n    /* Send each scan line in turn */\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            /* Remove trailing 0s. */\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                /* Blank line */\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n\n                /* Pad with 0s to fill out the last */\n                /* block of 8 bytes. */\n                memset(end_data, 0, 7);\n\n                /* Transpose the data to get pixel planes. */\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { /* The following is for 16-bit machines */\n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                /* Skip blank lines if any */\n                if ( num_blank_lines > 0 ) {\n                    /* Do \"dot skips\" */\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n\n                /* Transfer raster graphics in the order R, G, B. */\n                /* Apparently it is stored in B, G, R */\n                /* Calculate the amount of data to send by what */\n                /* Ghostscript tells us the scan line_size in (bytes) */\n\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    /* Complement bytes */\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n\n    /* eject page */\n    gp_fputs(\"\\014\", prn_stream);\n\n    return 0;\n}",
  "diff_func": "@@ -69,6 +69,10 @@ jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n     byte data[DATA_SIZE];\n     byte plane_data[LINE_SIZE * 3];\n \n+    /* Initialise data to zeros, otherwise later on, uninitialised bytes in\n+    dp[] can be greater than 7, which breaks spr8[dp[]]. */\n+    memset(data, 0x00, DATA_SIZE);\n+\n     /* Set initial condition for printer */\n     gp_fputs(\"\\033@\",prn_stream);\n \n@@ -99,10 +103,6 @@ jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n                 byte *odp;\n                 byte *row;\n \n-                /* Pad with 0s to fill out the last */\n-                /* block of 8 bytes. */\n-                memset(end_data, 0, 7);\n-\n                 /* Transpose the data to get pixel planes. */\n                 for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                       i += 8, odp++",
  "func": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n\n    /* Set initial condition for printer */\n    gp_fputs(\"\\033@\",prn_stream);\n\n    /* Send each scan line in turn */\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            /* Remove trailing 0s. */\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                /* Blank line */\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n\n                /* Pad with 0s to fill out the last */\n                /* block of 8 bytes. */\n                memset(end_data, 0, 7);\n\n                /* Transpose the data to get pixel planes. */\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { /* The following is for 16-bit machines */\n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                /* Skip blank lines if any */\n                if ( num_blank_lines > 0 ) {\n                    /* Do \"dot skips\" */\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n\n                /* Transfer raster graphics in the order R, G, B. */\n                /* Apparently it is stored in B, G, R */\n                /* Calculate the amount of data to send by what */\n                /* Ghostscript tells us the scan line_size in (bytes) */\n\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    /* Complement bytes */\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n\n    /* eject page */\n    gp_fputs(\"\\014\", prn_stream);\n\n    return 0;\n}",
  "project": "ghostpdl",
  "hash": 302183289353260954524490328979171476250,
  "size": 118,
  "commit_id": "366ad48d076c1aa4c8f83c65011258a04e348207",
  "message": "Bug 701815: avoid uninitialised bytes being >7, which broke indexing.\n\nFixes:\n    ./sanbin/gs -dBATCH -dNOPAUSE -sOutputFile=tmp -sDEVICE=jetp3852 ../bug-701815.pdf",
  "target": 1,
  "dataset": "other",
  "idx": 210453
}