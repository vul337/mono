{
  "id": 609,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/vkrasnov/multiprime/commit/f48b83b4fb7d6689584cf25f61ca63a4891f5b11",
  "commit_sha": "f48b83b4fb7d6689584cf25f61ca63a4891f5b11",
  "commit_msg": "Fix length checks in X509_cmp_time to avoid out-of-bounds reads.\n\nAlso tighten X509_cmp_time to reject more than three fractional\nseconds in the time; and to reject trailing garbage after the offset.\n\nCVE-2015-1789\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "crypto/x509/x509_vfy.c",
  "func_name": "",
  "raw_func_from_json": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n     ASN1_TIME atm;\n     long offset;\n     char buff1[24], buff2[24], *p;\n    int i, j;\n \n     p = buff1;\n    i = ctm->length;\n     str = (char *)ctm->data;\n     if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n             return 0;\n         memcpy(p, str, 10);\n         p += 10;\n         str += 10;\n     } else {\n        if (i < 13)\n             return 0;\n         memcpy(p, str, 12);\n         p += 12;\n         str += 12;\n     }\n \n     if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n         *(p++) = '0';\n         *(p++) = '0';\n     } else {\n         *(p++) = *(str++);\n         *(p++) = *(str++);\n        /* Skip any fractional seconds... */\n        if (*str == '.') {\n             str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n         }\n \n     }\n     *(p++) = 'Z';\n     *(p++) = '\\0';\n \n    if (*str == 'Z')\n         offset = 0;\n    else {\n         if ((*str != '+') && (*str != '-'))\n             return 0;\n         offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n         offset += (str[3] - '0') * 10 + (str[4] - '0');\n         if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           /* cf. RFC 2459 */\n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 /* wait a second then return younger :-) */\n        return -1;\n    else\n        return i;\n}\n",
  "diff_func": "@@ -1808,47 +1808,84 @@ int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n     ASN1_TIME atm;\n     long offset;\n     char buff1[24], buff2[24], *p;\n-    int i, j;\n+    int i, j, remaining;\n \n     p = buff1;\n-    i = ctm->length;\n+    remaining = ctm->length;\n     str = (char *)ctm->data;\n+    /*\n+     * Note that the following (historical) code allows much more slack in the\n+     * time format than RFC5280. In RFC5280, the representation is fixed:\n+     * UTCTime: YYMMDDHHMMSSZ\n+     * GeneralizedTime: YYYYMMDDHHMMSSZ\n+     */\n     if (ctm->type == V_ASN1_UTCTIME) {\n-        if ((i < 11) || (i > 17))\n+        /* YYMMDDHHMM[SS]Z or YYMMDDHHMM[SS](+-)hhmm */\n+        int min_length = sizeof(\"YYMMDDHHMMZ\") - 1;\n+        int max_length = sizeof(\"YYMMDDHHMMSS+hhmm\") - 1;\n+        if (remaining < min_length || remaining > max_length)\n             return 0;\n         memcpy(p, str, 10);\n         p += 10;\n         str += 10;\n+        remaining -= 10;\n     } else {\n-        if (i < 13)\n+        /* YYYYMMDDHHMM[SS[.fff]]Z or YYYYMMDDHHMM[SS[.f[f[f]]]](+-)hhmm */\n+        int min_length = sizeof(\"YYYYMMDDHHMMZ\") - 1;\n+        int max_length = sizeof(\"YYYYMMDDHHMMSS.fff+hhmm\") - 1;\n+        if (remaining < min_length || remaining > max_length)\n             return 0;\n         memcpy(p, str, 12);\n         p += 12;\n         str += 12;\n+        remaining -= 12;\n     }\n \n     if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n         *(p++) = '0';\n         *(p++) = '0';\n     } else {\n+        /* SS (seconds) */\n+        if (remaining < 2)\n+            return 0;\n         *(p++) = *(str++);\n         *(p++) = *(str++);\n-        /* Skip any fractional seconds... */\n-        if (*str == '.') {\n+        remaining -= 2;\n+        /*\n+         * Skip any (up to three) fractional seconds...\n+         * TODO(emilia): in RFC5280, fractional seconds are forbidden.\n+         * Can we just kill them altogether?\n+         */\n+        if (remaining && *str == '.') {\n             str++;\n-            while ((*str >= '0') && (*str <= '9'))\n-                str++;\n+            remaining--;\n+            for (i = 0; i < 3 && remaining; i++, str++, remaining--) {\n+                if (*str < '0' || *str > '9')\n+                    break;\n+            }\n         }\n \n     }\n     *(p++) = 'Z';\n     *(p++) = '\\0';\n \n-    if (*str == 'Z')\n+    /* We now need either a terminating 'Z' or an offset. */\n+    if (!remaining)\n+        return 0;\n+    if (*str == 'Z') {\n+        if (remaining != 1)\n+            return 0;\n         offset = 0;\n-    else {\n+    } else {\n+        /* (+-)HHMM */\n         if ((*str != '+') && (*str != '-'))\n             return 0;\n+        /* Historical behaviour: the (+-)hhmm offset is forbidden in RFC5280. */\n+        if (remaining != 5)\n+            return 0;\n+        if (str[1] < '0' || str[1] > '9' || str[2] < '0' || str[2] > '9' ||\n+            str[3] < '0' || str[3] > '9' || str[4] < '0' || str[4] > '9')\n+            return 0;\n         offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n         offset += (str[3] - '0') * 10 + (str[4] - '0');\n         if (*str == '-')",
  "project": "openssl",
  "commit_id": "f48b83b4fb7d6689584cf25f61ca63a4891f5b11",
  "target": 1,
  "func": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n     ASN1_TIME atm;\n     long offset;\n     char buff1[24], buff2[24], *p;\n    int i, j;\n \n     p = buff1;\n    i = ctm->length;\n     str = (char *)ctm->data;\n     if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n             return 0;\n         memcpy(p, str, 10);\n         p += 10;\n         str += 10;\n     } else {\n        if (i < 13)\n             return 0;\n         memcpy(p, str, 12);\n         p += 12;\n         str += 12;\n     }\n \n     if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n         *(p++) = '0';\n         *(p++) = '0';\n     } else {\n         *(p++) = *(str++);\n         *(p++) = *(str++);\n        /* Skip any fractional seconds... */\n        if (*str == '.') {\n             str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n         }\n \n     }\n     *(p++) = 'Z';\n     *(p++) = '\\0';\n \n    if (*str == 'Z')\n         offset = 0;\n    else {\n         if ((*str != '+') && (*str != '-'))\n             return 0;\n         offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n         offset += (str[3] - '0') * 10 + (str[4] - '0');\n         if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           /* cf. RFC 2459 */\n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 /* wait a second then return younger :-) */\n        return -1;\n    else\n        return i;\n}\n",
  "big_vul_idx": 179865,
  "idx": 1537,
  "hash": 277602867865507801622013475312332483541
}