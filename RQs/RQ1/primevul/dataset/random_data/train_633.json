{
  "id": 633,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/MrE-Fog/krb521/commit/102bb6ebf20f9174130c85c3b052ae104e5073ec",
  "commit_sha": "102bb6ebf20f9174130c85c3b052ae104e5073ec",
  "commit_msg": "Fix krb5_read_message handling [CVE-2014-5355]\n\nIn recvauth_common, do not use strcmp against the data fields of\nkrb5_data objects populated by krb5_read_message(), as there is no\nguarantee that they are C strings.  Instead, create an expected\nkrb5_data value and use data_eq().\n\nIn the sample user-to-user server application, check that the received\nclient principal name is null-terminated before using it with printf\nand krb5_parse_name.\n\nCVE-2014-5355:\n\nIn MIT krb5, when a server process uses the krb5_recvauth function, an\nunauthenticated remote attacker can cause a NULL dereference by\nsending a zero-byte version string, or a read beyond the end of\nallocated storage by sending a non-null-terminated version string.\nThe example user-to-user server application (uuserver) is similarly\nvulnerable to a zero-length or non-null-terminated principal name\nstring.\n\nThe krb5_recvauth function reads two version strings from the client\nusing krb5_read_message(), which produces a krb5_data structure\ncontaining a length and a pointer to an octet sequence.  krb5_recvauth\nassumes that the data pointer is a valid C string and passes it to\nstrcmp() to verify the versions.  If the client sends an empty octet\nsequence, the data pointer will be NULL and strcmp() will dereference\na NULL pointer, causing the process to crash.  If the client sends a\nnon-null-terminated octet sequence, strcmp() will read beyond the end\nof the allocated storage, possibly causing the process to crash.\n\nuuserver similarly uses krb5_read_message() to read a client principal\nname, and then passes it to printf() and krb5_parse_name() without\nverifying that it is a valid C string.\n\nThe krb5_recvauth function is used by kpropd and the Kerberized\nversions of the BSD rlogin and rsh daemons.  These daemons are usually\nrun out of inetd or in a mode which forks before processing incoming\nconnections, so a process crash will generally not result in a\ncomplete denial of service.\n\nThanks to Tim Uglow for discovering this issue.\n\nCVSSv2: AV:N/AC:L/Au:N/C:N/I:N/A:P/E:POC/RL:OF/RC:C\n\n[tlyu@mit.edu: CVSS score]\n\nticket: 8050 (new)\ntarget_version: 1.13.1\ntags: pullup",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/appl/user_user/server.c",
  "func_name": "",
  "raw_func_from_json": "int main(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_data pname_data, tkt_data;\n    int sock = 0;\n    socklen_t l;\n    int retval;\n    struct sockaddr_in l_inaddr, f_inaddr;        /* local, foreign address */\n    krb5_creds creds, *new_creds;\n    krb5_ccache cc;\n    krb5_data msgtext, msg;\n    krb5_context context;\n    krb5_auth_context auth_context = NULL;\n\n#ifndef DEBUG\n    freopen(\"/tmp/uu-server.log\", \"w\", stderr);\n#endif\n\n    retval = krb5_init_context(&context);\n    if (retval) {\n        com_err(argv[0], retval, \"while initializing krb5\");\n        exit(1);\n    }\n\n#ifdef DEBUG\n    {\n        int one = 1;\n        int acc;\n        struct servent *sp;\n        socklen_t namelen = sizeof(f_inaddr);\n\n        if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {\n            com_err(\"uu-server\", errno, \"creating socket\");\n            exit(3);\n        }\n\n        l_inaddr.sin_family = AF_INET;\n        l_inaddr.sin_addr.s_addr = 0;\n        if (argc == 2) {\n            l_inaddr.sin_port = htons(atoi(argv[1]));\n        } else  {\n            if (!(sp = getservbyname(\"uu-sample\", \"tcp\"))) {\n                com_err(\"uu-server\", 0, \"can't find uu-sample/tcp service\");\n                exit(3);\n            }\n            l_inaddr.sin_port = sp->s_port;\n        }\n\n        (void) setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof (one));\n        if (bind(sock, (struct sockaddr *)&l_inaddr, sizeof(l_inaddr))) {\n            com_err(\"uu-server\", errno, \"binding socket\");\n            exit(3);\n        }\n        if (listen(sock, 1) == -1) {\n            com_err(\"uu-server\", errno, \"listening\");\n            exit(3);\n        }\n\n        printf(\"Server started\\n\");\n        fflush(stdout);\n\n        if ((acc = accept(sock, (struct sockaddr *)&f_inaddr, &namelen)) == -1) {\n            com_err(\"uu-server\", errno, \"accepting\");\n            exit(3);\n        }\n        dup2(acc, 0);\n        close(sock);\n        sock = 0;\n     }\n #endif\n \n     retval = krb5_read_message(context, (krb5_pointer) &sock, &pname_data);\n    if (retval) {\n         com_err (\"uu-server\", retval, \"reading pname\");\n         return 2;\n     }\n\n    retval = krb5_read_message(context, (krb5_pointer) &sock, &tkt_data);\n    if (retval) {\n        com_err (\"uu-server\", retval, \"reading ticket data\");\n        return 2;\n    }\n\n    retval = krb5_cc_default(context, &cc);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"getting credentials cache\");\n        return 4;\n    }\n\n    memset (&creds, 0, sizeof(creds));\n    retval = krb5_cc_get_principal(context, cc, &creds.client);\n    if (retval) {\n        com_err(\"uu-client\", retval, \"getting principal name\");\n        return 6;\n    }\n\n    /* client sends it already null-terminated. */\n    printf (\"uu-server: client principal is \\\"%s\\\".\\n\", pname_data.data);\n\n    retval = krb5_parse_name(context, pname_data.data, &creds.server);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"parsing client name\");\n        return 3;\n    }\n\n    creds.second_ticket = tkt_data;\n    printf (\"uu-server: client ticket is %d bytes.\\n\",\n            creds.second_ticket.length);\n\n    retval = krb5_get_credentials(context, KRB5_GC_USER_USER, cc,\n                                  &creds, &new_creds);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"getting user-user ticket\");\n        return 5;\n    }\n\n#ifndef DEBUG\n    l = sizeof(f_inaddr);\n    if (getpeername(0, (struct sockaddr *)&f_inaddr, &l) == -1)\n    {\n        com_err(\"uu-server\", errno, \"getting client address\");\n        return 6;\n    }\n#endif\n    l = sizeof(l_inaddr);\n    if (getsockname(0, (struct sockaddr *)&l_inaddr, &l) == -1)\n    {\n        com_err(\"uu-server\", errno, \"getting local address\");\n        return 6;\n    }\n\n    /* send a ticket/authenticator to the other side, so it can get the key\n       we're using for the krb_safe below. */\n\n    retval = krb5_auth_con_init(context, &auth_context);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"making auth_context\");\n        return 8;\n    }\n\n    retval = krb5_auth_con_setflags(context, auth_context,\n                                    KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"initializing the auth_context flags\");\n        return 8;\n    }\n\n    retval =\n        krb5_auth_con_genaddrs(context, auth_context, sock,\n                               KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR |\n                               KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"generating addrs for auth_context\");\n        return 9;\n    }\n\n#if 1\n    retval = krb5_mk_req_extended(context, &auth_context,\n                                  AP_OPTS_USE_SESSION_KEY,\n                                  NULL, new_creds, &msg);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"making AP_REQ\");\n        return 8;\n    }\n    retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);\n#else\n    retval = krb5_sendauth(context, &auth_context, (krb5_pointer)&sock, \"???\",\n                           0, 0,\n                           AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SESSION_KEY,\n                           NULL, &creds, cc, NULL, NULL, NULL);\n#endif\n    if (retval)\n        goto cl_short_wrt;\n\n    free(msg.data);\n\n    msgtext.length = 32;\n    msgtext.data = \"Hello, other end of connection.\";\n\n    retval = krb5_mk_safe(context, auth_context, &msgtext, &msg, NULL);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"encoding message to client\");\n        return 6;\n    }\n\n    retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);\n    if (retval) {\n    cl_short_wrt:\n        com_err(\"uu-server\", retval, \"writing message to client\");\n        return 7;\n    }\n\n\n    krb5_free_data_contents(context, &msg);\n    krb5_free_data_contents(context, &pname_data);\n    /* tkt_data freed with creds */\n    krb5_free_cred_contents(context, &creds);\n    krb5_free_creds(context, new_creds);\n    krb5_cc_close(context, cc);\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_context(context);\n    return 0;\n}\n",
  "diff_func": "@@ -111,8 +111,10 @@ int main(argc, argv)\n     }\n #endif\n \n+    /* principal name must be sent null-terminated. */\n     retval = krb5_read_message(context, (krb5_pointer) &sock, &pname_data);\n-    if (retval) {\n+    if (retval || pname_data.length == 0 ||\n+        pname_data.data[pname_data.length - 1] != '\\0') {\n         com_err (\"uu-server\", retval, \"reading pname\");\n         return 2;\n     }",
  "project": "krb5",
  "commit_id": "102bb6ebf20f9174130c85c3b052ae104e5073ec",
  "target": 1,
  "func": "int main(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_data pname_data, tkt_data;\n    int sock = 0;\n    socklen_t l;\n    int retval;\n    struct sockaddr_in l_inaddr, f_inaddr;        /* local, foreign address */\n    krb5_creds creds, *new_creds;\n    krb5_ccache cc;\n    krb5_data msgtext, msg;\n    krb5_context context;\n    krb5_auth_context auth_context = NULL;\n\n#ifndef DEBUG\n    freopen(\"/tmp/uu-server.log\", \"w\", stderr);\n#endif\n\n    retval = krb5_init_context(&context);\n    if (retval) {\n        com_err(argv[0], retval, \"while initializing krb5\");\n        exit(1);\n    }\n\n#ifdef DEBUG\n    {\n        int one = 1;\n        int acc;\n        struct servent *sp;\n        socklen_t namelen = sizeof(f_inaddr);\n\n        if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {\n            com_err(\"uu-server\", errno, \"creating socket\");\n            exit(3);\n        }\n\n        l_inaddr.sin_family = AF_INET;\n        l_inaddr.sin_addr.s_addr = 0;\n        if (argc == 2) {\n            l_inaddr.sin_port = htons(atoi(argv[1]));\n        } else  {\n            if (!(sp = getservbyname(\"uu-sample\", \"tcp\"))) {\n                com_err(\"uu-server\", 0, \"can't find uu-sample/tcp service\");\n                exit(3);\n            }\n            l_inaddr.sin_port = sp->s_port;\n        }\n\n        (void) setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof (one));\n        if (bind(sock, (struct sockaddr *)&l_inaddr, sizeof(l_inaddr))) {\n            com_err(\"uu-server\", errno, \"binding socket\");\n            exit(3);\n        }\n        if (listen(sock, 1) == -1) {\n            com_err(\"uu-server\", errno, \"listening\");\n            exit(3);\n        }\n\n        printf(\"Server started\\n\");\n        fflush(stdout);\n\n        if ((acc = accept(sock, (struct sockaddr *)&f_inaddr, &namelen)) == -1) {\n            com_err(\"uu-server\", errno, \"accepting\");\n            exit(3);\n        }\n        dup2(acc, 0);\n        close(sock);\n        sock = 0;\n     }\n #endif\n \n     retval = krb5_read_message(context, (krb5_pointer) &sock, &pname_data);\n    if (retval) {\n         com_err (\"uu-server\", retval, \"reading pname\");\n         return 2;\n     }\n\n    retval = krb5_read_message(context, (krb5_pointer) &sock, &tkt_data);\n    if (retval) {\n        com_err (\"uu-server\", retval, \"reading ticket data\");\n        return 2;\n    }\n\n    retval = krb5_cc_default(context, &cc);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"getting credentials cache\");\n        return 4;\n    }\n\n    memset (&creds, 0, sizeof(creds));\n    retval = krb5_cc_get_principal(context, cc, &creds.client);\n    if (retval) {\n        com_err(\"uu-client\", retval, \"getting principal name\");\n        return 6;\n    }\n\n    /* client sends it already null-terminated. */\n    printf (\"uu-server: client principal is \\\"%s\\\".\\n\", pname_data.data);\n\n    retval = krb5_parse_name(context, pname_data.data, &creds.server);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"parsing client name\");\n        return 3;\n    }\n\n    creds.second_ticket = tkt_data;\n    printf (\"uu-server: client ticket is %d bytes.\\n\",\n            creds.second_ticket.length);\n\n    retval = krb5_get_credentials(context, KRB5_GC_USER_USER, cc,\n                                  &creds, &new_creds);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"getting user-user ticket\");\n        return 5;\n    }\n\n#ifndef DEBUG\n    l = sizeof(f_inaddr);\n    if (getpeername(0, (struct sockaddr *)&f_inaddr, &l) == -1)\n    {\n        com_err(\"uu-server\", errno, \"getting client address\");\n        return 6;\n    }\n#endif\n    l = sizeof(l_inaddr);\n    if (getsockname(0, (struct sockaddr *)&l_inaddr, &l) == -1)\n    {\n        com_err(\"uu-server\", errno, \"getting local address\");\n        return 6;\n    }\n\n    /* send a ticket/authenticator to the other side, so it can get the key\n       we're using for the krb_safe below. */\n\n    retval = krb5_auth_con_init(context, &auth_context);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"making auth_context\");\n        return 8;\n    }\n\n    retval = krb5_auth_con_setflags(context, auth_context,\n                                    KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"initializing the auth_context flags\");\n        return 8;\n    }\n\n    retval =\n        krb5_auth_con_genaddrs(context, auth_context, sock,\n                               KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR |\n                               KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"generating addrs for auth_context\");\n        return 9;\n    }\n\n#if 1\n    retval = krb5_mk_req_extended(context, &auth_context,\n                                  AP_OPTS_USE_SESSION_KEY,\n                                  NULL, new_creds, &msg);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"making AP_REQ\");\n        return 8;\n    }\n    retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);\n#else\n    retval = krb5_sendauth(context, &auth_context, (krb5_pointer)&sock, \"???\",\n                           0, 0,\n                           AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SESSION_KEY,\n                           NULL, &creds, cc, NULL, NULL, NULL);\n#endif\n    if (retval)\n        goto cl_short_wrt;\n\n    free(msg.data);\n\n    msgtext.length = 32;\n    msgtext.data = \"Hello, other end of connection.\";\n\n    retval = krb5_mk_safe(context, auth_context, &msgtext, &msg, NULL);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"encoding message to client\");\n        return 6;\n    }\n\n    retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);\n    if (retval) {\n    cl_short_wrt:\n        com_err(\"uu-server\", retval, \"writing message to client\");\n        return 7;\n    }\n\n\n    krb5_free_data_contents(context, &msg);\n    krb5_free_data_contents(context, &pname_data);\n    /* tkt_data freed with creds */\n    krb5_free_cred_contents(context, &creds);\n    krb5_free_creds(context, new_creds);\n    krb5_cc_close(context, cc);\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_context(context);\n    return 0;\n}\n",
  "big_vul_idx": 179983,
  "idx": 1636,
  "hash": 132886479854659192640622899708439787419
}