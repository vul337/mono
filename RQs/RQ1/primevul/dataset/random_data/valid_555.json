{
  "id": 555,
  "language": "cc",
  "cwe": "",
  "commit_url": "https://github.com/prividentity/tensorflow/commit/4c0ee937c0f61c4fc5f5d32d9bb4c67428012a60",
  "commit_sha": "4c0ee937c0f61c4fc5f5d32d9bb4c67428012a60",
  "commit_msg": "Prevent overflow in sparse op\n\nPiperOrigin-RevId: 372442006\nChange-Id: I60fe31cd7e56fb3501e97c63500caf902ddeee96",
  "pr_url": null,
  "pr_info": null,
  "file_name": "tensorflow/core/kernels/sparse_split_op.cc",
  "func_name": "",
  "raw_func_from_json": "  void Compute(OpKernelContext* context) override {\n    const int64 axis_input = context->input(0).scalar<int64>()();\n    const Tensor& input_indices = context->input(1);\n    const Tensor& input_values = context->input(2);\n    const Tensor& input_shape = context->input(3);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values.shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape.shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape.shape().DebugString()));\n\n    const int64 input_rank = input_shape.vec<int64>().size();\n    const int64 axis = (axis_input < 0) ? input_rank + axis_input : axis_input;\n\n    OP_REQUIRES(\n        context, axis >= 0 && axis < input_rank,\n        errors::InvalidArgument(\"Input axis should be in range [\", -input_rank,\n                                \", \", input_rank, \"), got \", axis_input));\n\n    OP_REQUIRES(context,\n                num_split_ >= 1 && num_split_ <= input_shape.vec<int64>()(axis),\n                errors::InvalidArgument(\"Input num_split should be between 1 \"\n                                        \"and the splitting dimension size (\",\n                                        input_shape.vec<int64>()(axis),\n                                        \"), got \", num_split_));\n\n    sparse::SparseTensor sparse_tensor;\n    OP_REQUIRES_OK(context,\n                   sparse::SparseTensor::Create(\n                       input_indices, input_values,\n                       TensorShape(input_shape.vec<int64>()), &sparse_tensor));\n\n    std::vector<sparse::SparseTensor> outputs;\n    OP_REQUIRES_OK(context, sparse::SparseTensor::Split<T>(\n                                sparse_tensor, axis, num_split_, &outputs));\n\n    for (int slice_index = 0; slice_index < num_split_; ++slice_index) {\n      context->set_output(slice_index, outputs[slice_index].indices());\n      context->set_output(slice_index + num_split_,\n                          outputs[slice_index].values());\n      Tensor* shape = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(\n                                  slice_index + 2 * num_split_,\n                                  {outputs[slice_index].dims()}, &shape));\n      auto output_shape = outputs[slice_index].shape();\n      for (int dim = 0; dim < outputs[slice_index].dims(); ++dim) {\n        shape->vec<int64>()(dim) = output_shape[dim];\n      }\n    }\n  }",
  "diff_func": "@@ -63,11 +63,18 @@ class SparseSplitOp : public OpKernel {\n                                         input_shape.vec<int64>()(axis),\n                                         \"), got \", num_split_));\n \n+    // Prevent overflow by constructing the dense shape separately\n+    TensorShape dense_shape;\n+    const auto input_shape_flat = input_shape.flat<int64>();\n+    for (int i = 0; i < input_shape.NumElements(); i++) {\n+      OP_REQUIRES_OK(context,\n+                     dense_shape.AddDimWithStatus(input_shape_flat(i)));\n+    }\n+\n     sparse::SparseTensor sparse_tensor;\n     OP_REQUIRES_OK(context,\n-                   sparse::SparseTensor::Create(\n-                       input_indices, input_values,\n-                       TensorShape(input_shape.vec<int64>()), &sparse_tensor));\n+                   sparse::SparseTensor::Create(input_indices, input_values,\n+                                                dense_shape, &sparse_tensor));\n \n     std::vector<sparse::SparseTensor> outputs;\n     OP_REQUIRES_OK(context, sparse::SparseTensor::Split<T>(",
  "func": "  void Compute(OpKernelContext* context) override {\n    const int64 axis_input = context->input(0).scalar<int64>()();\n    const Tensor& input_indices = context->input(1);\n    const Tensor& input_values = context->input(2);\n    const Tensor& input_shape = context->input(3);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values.shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_indices.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape.shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape.shape().DebugString()));\n\n    const int64 input_rank = input_shape.vec<int64>().size();\n    const int64 axis = (axis_input < 0) ? input_rank + axis_input : axis_input;\n\n    OP_REQUIRES(\n        context, axis >= 0 && axis < input_rank,\n        errors::InvalidArgument(\"Input axis should be in range [\", -input_rank,\n                                \", \", input_rank, \"), got \", axis_input));\n\n    OP_REQUIRES(context,\n                num_split_ >= 1 && num_split_ <= input_shape.vec<int64>()(axis),\n                errors::InvalidArgument(\"Input num_split should be between 1 \"\n                                        \"and the splitting dimension size (\",\n                                        input_shape.vec<int64>()(axis),\n                                        \"), got \", num_split_));\n\n    sparse::SparseTensor sparse_tensor;\n    OP_REQUIRES_OK(context,\n                   sparse::SparseTensor::Create(\n                       input_indices, input_values,\n                       TensorShape(input_shape.vec<int64>()), &sparse_tensor));\n\n    std::vector<sparse::SparseTensor> outputs;\n    OP_REQUIRES_OK(context, sparse::SparseTensor::Split<T>(\n                                sparse_tensor, axis, num_split_, &outputs));\n\n    for (int slice_index = 0; slice_index < num_split_; ++slice_index) {\n      context->set_output(slice_index, outputs[slice_index].indices());\n      context->set_output(slice_index + num_split_,\n                          outputs[slice_index].values());\n      Tensor* shape = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(\n                                  slice_index + 2 * num_split_,\n                                  {outputs[slice_index].dims()}, &shape));\n      auto output_shape = outputs[slice_index].shape();\n      for (int dim = 0; dim < outputs[slice_index].dims(); ++dim) {\n        shape->vec<int64>()(dim) = output_shape[dim];\n      }\n    }\n  }",
  "project": "tensorflow",
  "hash": 117534156949568730230637035600140974853,
  "size": 58,
  "commit_id": "4c0ee937c0f61c4fc5f5d32d9bb4c67428012a60",
  "message": "Prevent overflow in sparse op\n\nPiperOrigin-RevId: 372442006\nChange-Id: I60fe31cd7e56fb3501e97c63500caf902ddeee96",
  "target": 1,
  "dataset": "other",
  "idx": 198015
}