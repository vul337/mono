{
  "id": 694,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/chipcraft-ic/toolchain-component-linux/commit/5d069dbe8aaf2a197142558b6fb2978189ba3454",
  "commit_sha": "5d069dbe8aaf2a197142558b6fb2978189ba3454",
  "commit_msg": "fuse: fix bad inode\n\nJan Kara's analysis of the syzbot report (edited):\n\n  The reproducer opens a directory on FUSE filesystem, it then attaches\n  dnotify mark to the open directory.  After that a fuse_do_getattr() call\n  finds that attributes returned by the server are inconsistent, and calls\n  make_bad_inode() which, among other things does:\n\n          inode->i_mode = S_IFREG;\n\n  This then confuses dnotify which doesn't tear down its structures\n  properly and eventually crashes.\n\nAvoid calling make_bad_inode() on a live inode: switch to a private flag on\nthe fuse inode.  Also add the test to ops which the bad_inode_ops would\nhave caught.\n\nThis bug goes back to the initial merge of fuse in 2.6.14...\n\nReported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\nTested-by: Jan Kara <jack@suse.cz>\nCc: <stable@vger.kernel.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/fuse/acl.c",
  "func_name": "",
  "raw_func_from_json": "static int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fm->fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t/* Directories have separate file-handle space */\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.opcode = FUSE_GETATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tif (fuse_invalid_attr(&outarg.attr) ||\n\t\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}",
  "diff_func": "@@ -19,6 +19,9 @@ struct posix_acl *fuse_get_acl(struct inode *inode, int type)\n \tvoid *value = NULL;\n \tstruct posix_acl *acl;\n \n+\tif (fuse_is_bad(inode))\n+\t\treturn ERR_PTR(-EIO);\n+\n \tif (!fc->posix_acl || fc->no_getxattr)\n \t\treturn NULL;\n \n@@ -53,6 +56,9 @@ int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tconst char *name;\n \tint ret;\n \n+\tif (fuse_is_bad(inode))\n+\t\treturn -EIO;\n+\n \tif (!fc->posix_acl || fc->no_setxattr)\n \t\treturn -EOPNOTSUPP;\n ",
  "func": "static int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fm->fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t/* Directories have separate file-handle space */\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.opcode = FUSE_GETATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tif (fuse_invalid_attr(&outarg.attr) ||\n\t\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}",
  "project": "linux",
  "hash": 66305836614615397501498682867266125877,
  "size": 45,
  "commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454",
  "message": "fuse: fix bad inode\n\nJan Kara's analysis of the syzbot report (edited):\n\n  The reproducer opens a directory on FUSE filesystem, it then attaches\n  dnotify mark to the open directory.  After that a fuse_do_getattr() call\n  finds that attributes returned by the server are inconsistent, and calls\n  make_bad_inode() which, among other things does:\n\n          inode->i_mode = S_IFREG;\n\n  This then confuses dnotify which doesn't tear down its structures\n  properly and eventually crashes.\n\nAvoid calling make_bad_inode() on a live inode: switch to a private flag on\nthe fuse inode.  Also add the test to ops which the bad_inode_ops would\nhave caught.\n\nThis bug goes back to the initial merge of fuse in 2.6.14...\n\nReported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\nTested-by: Jan Kara <jack@suse.cz>\nCc: <stable@vger.kernel.org>",
  "target": 1,
  "dataset": "other",
  "idx": 202842
}