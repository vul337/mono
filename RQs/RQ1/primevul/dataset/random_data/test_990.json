{
  "id": 990,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/DennissimOS/platform_external_libxml2/commit/03c6723043775122313f107695066e5744189a08",
  "commit_sha": "03c6723043775122313f107695066e5744189a08",
  "commit_msg": "Handling of XPath function arguments in error case\n\nThe XPath engine tries to guarantee that every XPath function can pop\n'nargs' non-NULL values off the stack. libxslt, for example, relies on\nthis assumption. But the check isn't thorough enough if there are errors\nduring the evaluation of arguments. This can lead to segfaults:\n\nhttps://mail.gnome.org/archives/xslt/2013-December/msg00005.html\n\nThis commit makes the handling of function arguments more robust.\n\n* Bail out early when evaluation of XPath function arguments fails.\n* Make sure that there are 'nargs' arguments in the current call frame.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "xpath.c",
  "func_name": "",
  "raw_func_from_json": " */\nstatic int\nxmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)\n{\n    int total = 0;\n    int equal, ret;\n    xmlXPathCompExprPtr comp;\n    xmlXPathObjectPtr arg1, arg2;\n    xmlNodePtr bak;\n    xmlDocPtr bakd;\n    int pp;\n    int cs;\n\n    CHECK_ERROR0;\n    comp = ctxt->comp;\n    switch (op->op) {\n        case XPATH_OP_END:\n            return (0);\n        case XPATH_OP_AND:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))\n                return (total);\n            arg2 = valuePop(ctxt);\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval &= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_OR:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))\n                return (total);\n            arg2 = valuePop(ctxt);\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval |= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_EQUAL:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    if (op->value)\n\t\tequal = xmlXPathEqualValues(ctxt);\n\t    else\n\t\tequal = xmlXPathNotEqualValues(ctxt);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));\n            return (total);\n        case XPATH_OP_CMP:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ret = xmlXPathCompareValues(ctxt, op->value, op->value2);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));\n            return (total);\n        case XPATH_OP_PLUS:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n\t\tctxt->context->doc = bakd;\n\t\tctxt->context->node = bak;\n\t\tctxt->context->proximityPosition = pp;\n\t\tctxt->context->contextSize = cs;\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    }\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathSubValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathAddValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathValueFlipSign(ctxt);\n            else if (op->value == 3) {\n                CAST_TO_NUMBER;\n                CHECK_TYPE0(XPATH_NUMBER);\n            }\n            return (total);\n        case XPATH_OP_MULT:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathMultValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathDivValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathModValues(ctxt);\n            return (total);\n        case XPATH_OP_UNION:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            CHECK_TYPE0(XPATH_NODESET);\n            arg2 = valuePop(ctxt);\n\n            CHECK_TYPE0(XPATH_NODESET);\n            arg1 = valuePop(ctxt);\n\n\t    if ((arg1->nodesetval == NULL) ||\n\t\t((arg2->nodesetval != NULL) &&\n\t\t (arg2->nodesetval->nodeNr != 0)))\n\t    {\n\t\targ1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n\t\t\t\t\t\t\targ2->nodesetval);\n\t    }\n\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_ROOT:\n            xmlXPathRoot(ctxt);\n            return (total);\n        case XPATH_OP_NODE:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n\t\tctxt->context->node));\n            return (total);\n        case XPATH_OP_RESET:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ctxt->context->node = NULL;\n            return (total);\n        case XPATH_OP_COLLECT:{\n                if (op->ch1 == -1)\n                    return (total);\n\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n\n                total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);\n                return (total);\n            }\n        case XPATH_OP_VALUE:\n            valuePush(ctxt,\n                      xmlXPathCacheObjectCopy(ctxt->context,\n\t\t\t(xmlXPathObjectPtr) op->value4));\n            return (total);\n        case XPATH_OP_VARIABLE:{\n\t\txmlXPathObjectPtr val;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->value5 == NULL) {\n\t\t    val = xmlXPathVariableLookup(ctxt->context, op->value4);\n\t\t    if (val == NULL) {\n\t\t\tctxt->error = XPATH_UNDEF_VARIABLE_ERROR;\n\t\t\treturn(0);\n\t\t    }\n                    valuePush(ctxt, val);\n\t\t} else {\n                    const xmlChar *URI;\n\n                    URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                    if (URI == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: variable %s bound to undefined prefix %s\\n\",\n                                    (char *) op->value4, (char *)op->value5);\n                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;\n                        return (total);\n                    }\n\t\t    val = xmlXPathVariableLookupNS(ctxt->context,\n                                                       op->value4, URI);\n\t\t    if (val == NULL) {\n\t\t\tctxt->error = XPATH_UNDEF_VARIABLE_ERROR;\n\t\t\treturn(0);\n\t\t    }\n                    valuePush(ctxt, val);\n                }\n                return (total);\n            }\n        case XPATH_OP_FUNCTION:{\n                xmlXPathFunction func;\n                const xmlChar *oldFunc, *oldFuncURI;\n\t\tint i;\n                int frame;\n\n                frame = xmlXPathSetFrame(ctxt);\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tif (ctxt->valueNr < op->value) {\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"xmlXPathCompOpEval: parameter error\\n\");\n\t\t    ctxt->error = XPATH_INVALID_OPERAND;\n                    xmlXPathPopFrame(ctxt, frame);\n\t\t    return (total);\n\t\t}\n\t\tfor (i = 0; i < op->value; i++) {\n\t\t    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"xmlXPathCompOpEval: parameter error\\n\");\n\t\t\tctxt->error = XPATH_INVALID_OPERAND;\n                        xmlXPathPopFrame(ctxt, frame);\n\t\t\treturn (total);\n\t\t    }\n                }\n                if (op->cache != NULL)\n                    XML_CAST_FPTR(func) = op->cache;\n                else {\n                    const xmlChar *URI = NULL;\n\n                    if (op->value5 == NULL)\n                        func =\n                            xmlXPathFunctionLookup(ctxt->context,\n                                                   op->value4);\n                    else {\n                        URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                        if (URI == NULL) {\n                            xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: function %s bound to undefined prefix %s\\n\",\n                                    (char *)op->value4, (char *)op->value5);\n                            xmlXPathPopFrame(ctxt, frame);\n                            ctxt->error = XPATH_UNDEF_PREFIX_ERROR;\n                            return (total);\n                        }\n                        func = xmlXPathFunctionLookupNS(ctxt->context,\n                                                        op->value4, URI);\n                    }\n                    if (func == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n                                \"xmlXPathCompOpEval: function %s not found\\n\",\n                                        (char *)op->value4);\n                        XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);\n                    }\n                    op->cache = XML_CAST_FPTR(func);\n                    op->cacheURI = (void *) URI;\n                }\n                oldFunc = ctxt->context->function;\n                oldFuncURI = ctxt->context->functionURI;\n                ctxt->context->function = op->value4;\n                ctxt->context->functionURI = op->cacheURI;\n                func(ctxt, op->value);\n                ctxt->context->function = oldFunc;\n                ctxt->context->functionURI = oldFuncURI;\n                xmlXPathPopFrame(ctxt, frame);\n                return (total);\n            }\n        case XPATH_OP_ARG:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    ctxt->context->contextSize = cs;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->doc = bakd;\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t        ctxt->context->doc = bakd;\n\t        ctxt->context->node = bak;\n\t        CHECK_ERROR0;\n\t    }\n            return (total);\n        case XPATH_OP_PREDICATE:\n        case XPATH_OP_FILTER:{\n                xmlXPathObjectPtr res;\n                xmlXPathObjectPtr obj, tmp;\n                xmlNodeSetPtr newset = NULL;\n                xmlNodeSetPtr oldset;\n                xmlNodePtr oldnode;\n\t\txmlDocPtr oldDoc;\n                int i;\n\n                /*\n                 * Optimization for ()[1] selection i.e. the first elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n#ifdef XP_OPTIMIZED_FILTER_FIRST\n\t\t    /*\n\t\t    * FILTER TODO: Can we assume that the inner processing\n\t\t    *  will result in an ordered list if we have an\n\t\t    *  XPATH_OP_FILTER?\n\t\t    *  What about an additional field or flag on\n\t\t    *  xmlXPathObject like @sorted ? This way we wouln'd need\n\t\t    *  to assume anything, so it would be more robust and\n\t\t    *  easier to optimize.\n\t\t    */\n                    ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */\n\t\t     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */\n#else\n\t\t    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n#endif\n                    (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */\n                    xmlXPathObjectPtr val;\n\n                    val = comp->steps[op->ch2].value4;\n                    if ((val != NULL) && (val->type == XPATH_NUMBER) &&\n                        (val->floatval == 1.0)) {\n                        xmlNodePtr first = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalFirst(ctxt,\n                                                    &comp->steps[op->ch1],\n                                                    &first);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the first value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1))\n                            ctxt->value->nodesetval->nodeNr = 1;\n                        return (total);\n                    }\n                }\n                /*\n                 * Optimization for ()[last()] selection i.e. the last elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n                    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n                    int f = comp->steps[op->ch2].ch1;\n\n                    if ((f != -1) &&\n                        (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n                        (comp->steps[f].value5 == NULL) &&\n                        (comp->steps[f].value == 0) &&\n                        (comp->steps[f].value4 != NULL) &&\n                        (xmlStrEqual\n                         (comp->steps[f].value4, BAD_CAST \"last\"))) {\n                        xmlNodePtr last = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalLast(ctxt,\n                                                   &comp->steps[op->ch1],\n                                                   &last);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the last value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeTab != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1)) {\n                            ctxt->value->nodesetval->nodeTab[0] =\n                                ctxt->value->nodesetval->nodeTab[ctxt->\n                                                                 value->\n                                                                 nodesetval->\n                                                                 nodeNr -\n                                                                 1];\n                            ctxt->value->nodesetval->nodeNr = 1;\n                        }\n                        return (total);\n                    }\n                }\n\t\t/*\n\t\t* Process inner predicates first.\n\t\t* Example \"index[parent::book][1]\":\n\t\t* ...\n\t\t*   PREDICATE   <-- we are here \"[1]\"\n\t\t*     PREDICATE <-- process \"[parent::book]\" first\n\t\t*       SORT\n\t\t*         COLLECT  'parent' 'name' 'node' book\n\t\t*           NODE\n\t\t*     ELEM Object is a number : 1\n\t\t*/\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n                if (op->ch2 == -1)\n                    return (total);\n                if (ctxt->value == NULL)\n                    return (total);\n\n                oldnode = ctxt->context->node;\n\n#ifdef LIBXML_XPTR_ENABLED\n                /*\n                 * Hum are we filtering the result of an XPointer expression\n                 */\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    xmlLocationSetPtr newlocset = NULL;\n                    xmlLocationSetPtr oldlocset;\n\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n                    ctxt->context->node = NULL;\n\n                    if ((oldlocset == NULL) || (oldlocset->locNr == 0)) {\n                        ctxt->context->contextSize = 0;\n                        ctxt->context->proximityPosition = 0;\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n                        res = valuePop(ctxt);\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        valuePush(ctxt, obj);\n                        CHECK_ERROR0;\n                        return (total);\n                    }\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation need to be tested to\n                         * decided whether the filter succeeded or not\n                         */\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            xmlXPtrLocationSetAdd(newlocset,\n                                                  xmlXPathObjectCopy\n                                                  (oldlocset->locTab[i]));\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n\n                        ctxt->context->node = NULL;\n                    }\n\n                    /*\n                     * The result is used as the new evaluation locset.\n                     */\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = NULL;\n                    ctxt->context->contextSize = -1;\n                    ctxt->context->proximityPosition = -1;\n                    valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n                    ctxt->context->node = oldnode;\n                    return (total);\n                }\n#endif /* LIBXML_XPTR_ENABLED */\n\n                /*\n                 * Extract the old set, and then evaluate the result of the\n                 * expression for all the element in the set. use it to grow\n                 * up a new set.\n                 */\n                CHECK_TYPE0(XPATH_NODESET);\n                obj = valuePop(ctxt);\n                oldset = obj->nodesetval;\n\n                oldnode = ctxt->context->node;\n\t\toldDoc = ctxt->context->doc;\n                ctxt->context->node = NULL;\n\n                if ((oldset == NULL) || (oldset->nodeNr == 0)) {\n                    ctxt->context->contextSize = 0;\n                    ctxt->context->proximityPosition = 0;\n/*\n                    if (op->ch2 != -1)\n                        total +=\n                            xmlXPathCompOpEval(ctxt,\n                                               &comp->steps[op->ch2]);\n\t\t    CHECK_ERROR0;\n                    res = valuePop(ctxt);\n                    if (res != NULL)\n                        xmlXPathFreeObject(res);\n*/\n                    valuePush(ctxt, obj);\n                    ctxt->context->node = oldnode;\n                    CHECK_ERROR0;\n                } else {\n\t\t    tmp = NULL;\n                    /*\n                     * Initialize the new set.\n\t\t     * Also set the xpath document in case things like\n\t\t     * key() evaluation are attempted on the predicate\n                     */\n                    newset = xmlXPathNodeSetCreate(NULL);\n\t\t    /*\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"For each node in the node-set to be filtered, the\n\t\t    *  PredicateExpr is evaluated with that node as the\n\t\t    *  context node, with the number of nodes in the\n\t\t    *  node-set as the context size, and with the proximity\n\t\t    *  position of the node in the node-set with respect to\n\t\t    *  the axis as the context position;\"\n\t\t    * @oldset is the node-set\" to be filtered.\n\t\t    *\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"only predicates change the context position and\n\t\t    *  context size (see [2.4 Predicates]).\"\n\t\t    * Example:\n\t\t    *   node-set  context pos\n\t\t    *    nA         1\n\t\t    *    nB         2\n\t\t    *    nC         3\n\t\t    *   After applying predicate [position() > 1] :\n\t\t    *   node-set  context pos\n\t\t    *    nB         1\n\t\t    *    nC         2\n\t\t    *\n\t\t    * removed the first node in the node-set, then\n\t\t    * the context position of the\n\t\t    */\n                    for (i = 0; i < oldset->nodeNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of\n                         * a single item in the nodeset.\n                         */\n                        ctxt->context->node = oldset->nodeTab[i];\n\t\t\tif ((oldset->nodeTab[i]->type != XML_NAMESPACE_DECL) &&\n\t\t\t    (oldset->nodeTab[i]->doc != NULL))\n\t\t            ctxt->context->doc = oldset->nodeTab[i]->doc;\n\t\t\tif (tmp == NULL) {\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n\t\t\t} else {\n\t\t\t    if (xmlXPathNodeSetAddUnique(tmp->nodesetval,\n\t\t\t\t               ctxt->context->node) < 0) {\n\t\t\t\tctxt->error = XPATH_MEMORY_ERROR;\n\t\t\t    }\n\t\t\t}\n                        valuePush(ctxt, tmp);\n                        ctxt->context->contextSize = oldset->nodeNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\t/*\n\t\t\t* Evaluate the predicate against the context node.\n\t\t\t* Can/should we optimize position() predicates\n\t\t\t* here (e.g. \"[1]\")?\n\t\t\t*/\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeNodeSet(newset);\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation needs to be tested to\n                         * decide whether the filter succeeded or not\n                         */\n\t\t\t/*\n\t\t\t* OPTIMIZE TODO: Can we use\n\t\t\t* xmlXPathNodeSetAdd*Unique()* instead?\n\t\t\t*/\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            if (xmlXPathNodeSetAdd(newset, oldset->nodeTab[i])\n\t\t\t        < 0)\n\t\t\t\tctxt->error = XPATH_MEMORY_ERROR;\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            valuePop(ctxt);\n\t\t\t    xmlXPathNodeSetClear(tmp->nodesetval, 1);\n\t\t\t    /*\n\t\t\t    * Don't free the temporary nodeset\n\t\t\t    * in order to avoid massive recreation inside this\n\t\t\t    * loop.\n\t\t\t    */\n                        } else\n\t\t\t    tmp = NULL;\n                        ctxt->context->node = NULL;\n                    }\n\t\t    if (tmp != NULL)\n\t\t\txmlXPathReleaseObject(ctxt->context, tmp);\n                    /*\n                     * The result is used as the new evaluation set.\n                     */\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = NULL;\n                    ctxt->context->contextSize = -1;\n                    ctxt->context->proximityPosition = -1;\n\t\t    /* may want to move this past the '}' later */\n\t\t    ctxt->context->doc = oldDoc;\n\t\t    valuePush(ctxt,\n\t\t\txmlXPathCacheWrapNodeSet(ctxt->context, newset));\n                }\n                ctxt->context->node = oldnode;\n                return (total);\n            }\n        case XPATH_OP_SORT:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if ((ctxt->value != NULL) &&\n                (ctxt->value->type == XPATH_NODESET) &&\n                (ctxt->value->nodesetval != NULL) &&\n\t\t(ctxt->value->nodesetval->nodeNr > 1))\n\t    {\n                xmlXPathNodeSetSort(ctxt->value->nodesetval);\n\t    }\n            return (total);\n#ifdef LIBXML_XPTR_ENABLED\n        case XPATH_OP_RANGETO:{\n                xmlXPathObjectPtr range;\n                xmlXPathObjectPtr res, obj;\n                xmlXPathObjectPtr tmp;\n                xmlLocationSetPtr newlocset = NULL;\n\t\t    xmlLocationSetPtr oldlocset;\n                xmlNodeSetPtr oldset;\n                int i, j;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->ch2 == -1)\n                    return (total);\n\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n\n                    if ((oldlocset == NULL) || (oldlocset->locNr == 0)) {\n\t\t        ctxt->context->node = NULL;\n                        ctxt->context->contextSize = 0;\n                        ctxt->context->proximityPosition = 0;\n                        total += xmlXPathCompOpEval(ctxt,&comp->steps[op->ch2]);\n                        res = valuePop(ctxt);\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        valuePush(ctxt, obj);\n                        CHECK_ERROR0;\n                        return (total);\n                    }\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        res = valuePop(ctxt);\n\t\t\tif (res->type == XPATH_LOCATIONSET) {\n\t\t\t    xmlLocationSetPtr rloc =\n\t\t\t        (xmlLocationSetPtr)res->user;\n\t\t\t    for (j=0; j<rloc->locNr; j++) {\n\t\t\t        range = xmlXPtrNewRange(\n\t\t\t\t  oldlocset->locTab[i]->user,\n\t\t\t\t  oldlocset->locTab[i]->index,\n\t\t\t\t  rloc->locTab[j]->user2,\n\t\t\t\t  rloc->locTab[j]->index2);\n\t\t\t\tif (range != NULL) {\n\t\t\t\t    xmlXPtrLocationSetAdd(newlocset, range);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    range = xmlXPtrNewRangeNodeObject(\n\t\t\t\t(xmlNodePtr)oldlocset->locTab[i]->user, res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset,range);\n\t\t\t    }\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n\n                        ctxt->context->node = NULL;\n                    }\n\t\t} else {\t/* Not a location set */\n                    CHECK_TYPE0(XPATH_NODESET);\n                    obj = valuePop(ctxt);\n                    oldset = obj->nodesetval;\n                    ctxt->context->node = NULL;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    if (oldset != NULL) {\n                        for (i = 0; i < oldset->nodeNr; i++) {\n                            /*\n                             * Run the evaluation with a node list made of a single item\n                             * in the nodeset.\n                             */\n                            ctxt->context->node = oldset->nodeTab[i];\n\t\t\t    /*\n\t\t\t    * OPTIMIZE TODO: Avoid recreation for every iteration.\n\t\t\t    */\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n                            valuePush(ctxt, tmp);\n\n                            if (op->ch2 != -1)\n                                total +=\n                                    xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\t    if (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t\txmlXPathFreeObject(obj);\n\t\t\t\treturn(0);\n\t\t\t    }\n\n                            res = valuePop(ctxt);\n                            range =\n                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],\n                                                      res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset, range);\n                            }\n\n                            /*\n                             * Cleanup\n                             */\n                            if (res != NULL) {\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n\t\t\t    }\n                            if (ctxt->value == tmp) {\n                                res = valuePop(ctxt);\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n                            }\n\n                            ctxt->context->node = NULL;\n                        }\n                    }\n                }\n\n                /*\n                 * The result is used as the new evaluation set.\n                 */\n\t\txmlXPathReleaseObject(ctxt->context, obj);\n                ctxt->context->node = NULL;\n                ctxt->context->contextSize = -1;\n                ctxt->context->proximityPosition = -1;\n                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n                return (total);\n            }\n#endif /* LIBXML_XPTR_ENABLED */\n    }\n    xmlGenericError(xmlGenericErrorContext,\n                    \"XPath: unknown precompiled operation %d\\n\", op->op);\n    ctxt->error = XPATH_INVALID_OPERAND;",
  "diff_func": "@@ -13524,10 +13524,15 @@ xmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)\n                 int frame;\n \n                 frame = xmlXPathSetFrame(ctxt);\n-                if (op->ch1 != -1)\n+                if (op->ch1 != -1) {\n                     total +=\n                         xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n-\t\tif (ctxt->valueNr < op->value) {\n+                    if (ctxt->error != XPATH_EXPRESSION_OK) {\n+                        xmlXPathPopFrame(ctxt, frame);\n+                        return (total);\n+                    }\n+                }\n+\t\tif (ctxt->valueNr < ctxt->valueFrame + op->value) {\n \t\t    xmlGenericError(xmlGenericErrorContext,\n \t\t\t    \"xmlXPathCompOpEval: parameter error\\n\");\n \t\t    ctxt->error = XPATH_INVALID_OPERAND;",
  "func": " */\nstatic int\nxmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)\n{\n    int total = 0;\n    int equal, ret;\n    xmlXPathCompExprPtr comp;\n    xmlXPathObjectPtr arg1, arg2;\n    xmlNodePtr bak;\n    xmlDocPtr bakd;\n    int pp;\n    int cs;\n\n    CHECK_ERROR0;\n    comp = ctxt->comp;\n    switch (op->op) {\n        case XPATH_OP_END:\n            return (0);\n        case XPATH_OP_AND:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))\n                return (total);\n            arg2 = valuePop(ctxt);\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval &= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_OR:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))\n                return (total);\n            arg2 = valuePop(ctxt);\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval |= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_EQUAL:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    if (op->value)\n\t\tequal = xmlXPathEqualValues(ctxt);\n\t    else\n\t\tequal = xmlXPathNotEqualValues(ctxt);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));\n            return (total);\n        case XPATH_OP_CMP:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ret = xmlXPathCompareValues(ctxt, op->value, op->value2);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));\n            return (total);\n        case XPATH_OP_PLUS:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n\t\tctxt->context->doc = bakd;\n\t\tctxt->context->node = bak;\n\t\tctxt->context->proximityPosition = pp;\n\t\tctxt->context->contextSize = cs;\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    }\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathSubValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathAddValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathValueFlipSign(ctxt);\n            else if (op->value == 3) {\n                CAST_TO_NUMBER;\n                CHECK_TYPE0(XPATH_NUMBER);\n            }\n            return (total);\n        case XPATH_OP_MULT:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathMultValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathDivValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathModValues(ctxt);\n            return (total);\n        case XPATH_OP_UNION:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            CHECK_TYPE0(XPATH_NODESET);\n            arg2 = valuePop(ctxt);\n\n            CHECK_TYPE0(XPATH_NODESET);\n            arg1 = valuePop(ctxt);\n\n\t    if ((arg1->nodesetval == NULL) ||\n\t\t((arg2->nodesetval != NULL) &&\n\t\t (arg2->nodesetval->nodeNr != 0)))\n\t    {\n\t\targ1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n\t\t\t\t\t\t\targ2->nodesetval);\n\t    }\n\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_ROOT:\n            xmlXPathRoot(ctxt);\n            return (total);\n        case XPATH_OP_NODE:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n\t\tctxt->context->node));\n            return (total);\n        case XPATH_OP_RESET:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ctxt->context->node = NULL;\n            return (total);\n        case XPATH_OP_COLLECT:{\n                if (op->ch1 == -1)\n                    return (total);\n\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n\n                total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);\n                return (total);\n            }\n        case XPATH_OP_VALUE:\n            valuePush(ctxt,\n                      xmlXPathCacheObjectCopy(ctxt->context,\n\t\t\t(xmlXPathObjectPtr) op->value4));\n            return (total);\n        case XPATH_OP_VARIABLE:{\n\t\txmlXPathObjectPtr val;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->value5 == NULL) {\n\t\t    val = xmlXPathVariableLookup(ctxt->context, op->value4);\n\t\t    if (val == NULL) {\n\t\t\tctxt->error = XPATH_UNDEF_VARIABLE_ERROR;\n\t\t\treturn(0);\n\t\t    }\n                    valuePush(ctxt, val);\n\t\t} else {\n                    const xmlChar *URI;\n\n                    URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                    if (URI == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: variable %s bound to undefined prefix %s\\n\",\n                                    (char *) op->value4, (char *)op->value5);\n                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;\n                        return (total);\n                    }\n\t\t    val = xmlXPathVariableLookupNS(ctxt->context,\n                                                       op->value4, URI);\n\t\t    if (val == NULL) {\n\t\t\tctxt->error = XPATH_UNDEF_VARIABLE_ERROR;\n\t\t\treturn(0);\n\t\t    }\n                    valuePush(ctxt, val);\n                }\n                return (total);\n            }\n        case XPATH_OP_FUNCTION:{\n                xmlXPathFunction func;\n                const xmlChar *oldFunc, *oldFuncURI;\n\t\tint i;\n                int frame;\n\n                frame = xmlXPathSetFrame(ctxt);\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tif (ctxt->valueNr < op->value) {\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"xmlXPathCompOpEval: parameter error\\n\");\n\t\t    ctxt->error = XPATH_INVALID_OPERAND;\n                    xmlXPathPopFrame(ctxt, frame);\n\t\t    return (total);\n\t\t}\n\t\tfor (i = 0; i < op->value; i++) {\n\t\t    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"xmlXPathCompOpEval: parameter error\\n\");\n\t\t\tctxt->error = XPATH_INVALID_OPERAND;\n                        xmlXPathPopFrame(ctxt, frame);\n\t\t\treturn (total);\n\t\t    }\n                }\n                if (op->cache != NULL)\n                    XML_CAST_FPTR(func) = op->cache;\n                else {\n                    const xmlChar *URI = NULL;\n\n                    if (op->value5 == NULL)\n                        func =\n                            xmlXPathFunctionLookup(ctxt->context,\n                                                   op->value4);\n                    else {\n                        URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                        if (URI == NULL) {\n                            xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: function %s bound to undefined prefix %s\\n\",\n                                    (char *)op->value4, (char *)op->value5);\n                            xmlXPathPopFrame(ctxt, frame);\n                            ctxt->error = XPATH_UNDEF_PREFIX_ERROR;\n                            return (total);\n                        }\n                        func = xmlXPathFunctionLookupNS(ctxt->context,\n                                                        op->value4, URI);\n                    }\n                    if (func == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n                                \"xmlXPathCompOpEval: function %s not found\\n\",\n                                        (char *)op->value4);\n                        XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);\n                    }\n                    op->cache = XML_CAST_FPTR(func);\n                    op->cacheURI = (void *) URI;\n                }\n                oldFunc = ctxt->context->function;\n                oldFuncURI = ctxt->context->functionURI;\n                ctxt->context->function = op->value4;\n                ctxt->context->functionURI = op->cacheURI;\n                func(ctxt, op->value);\n                ctxt->context->function = oldFunc;\n                ctxt->context->functionURI = oldFuncURI;\n                xmlXPathPopFrame(ctxt, frame);\n                return (total);\n            }\n        case XPATH_OP_ARG:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    ctxt->context->contextSize = cs;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->doc = bakd;\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t        ctxt->context->doc = bakd;\n\t        ctxt->context->node = bak;\n\t        CHECK_ERROR0;\n\t    }\n            return (total);\n        case XPATH_OP_PREDICATE:\n        case XPATH_OP_FILTER:{\n                xmlXPathObjectPtr res;\n                xmlXPathObjectPtr obj, tmp;\n                xmlNodeSetPtr newset = NULL;\n                xmlNodeSetPtr oldset;\n                xmlNodePtr oldnode;\n\t\txmlDocPtr oldDoc;\n                int i;\n\n                /*\n                 * Optimization for ()[1] selection i.e. the first elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n#ifdef XP_OPTIMIZED_FILTER_FIRST\n\t\t    /*\n\t\t    * FILTER TODO: Can we assume that the inner processing\n\t\t    *  will result in an ordered list if we have an\n\t\t    *  XPATH_OP_FILTER?\n\t\t    *  What about an additional field or flag on\n\t\t    *  xmlXPathObject like @sorted ? This way we wouln'd need\n\t\t    *  to assume anything, so it would be more robust and\n\t\t    *  easier to optimize.\n\t\t    */\n                    ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */\n\t\t     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */\n#else\n\t\t    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n#endif\n                    (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */\n                    xmlXPathObjectPtr val;\n\n                    val = comp->steps[op->ch2].value4;\n                    if ((val != NULL) && (val->type == XPATH_NUMBER) &&\n                        (val->floatval == 1.0)) {\n                        xmlNodePtr first = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalFirst(ctxt,\n                                                    &comp->steps[op->ch1],\n                                                    &first);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the first value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1))\n                            ctxt->value->nodesetval->nodeNr = 1;\n                        return (total);\n                    }\n                }\n                /*\n                 * Optimization for ()[last()] selection i.e. the last elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n                    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n                    int f = comp->steps[op->ch2].ch1;\n\n                    if ((f != -1) &&\n                        (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n                        (comp->steps[f].value5 == NULL) &&\n                        (comp->steps[f].value == 0) &&\n                        (comp->steps[f].value4 != NULL) &&\n                        (xmlStrEqual\n                         (comp->steps[f].value4, BAD_CAST \"last\"))) {\n                        xmlNodePtr last = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalLast(ctxt,\n                                                   &comp->steps[op->ch1],\n                                                   &last);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the last value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeTab != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1)) {\n                            ctxt->value->nodesetval->nodeTab[0] =\n                                ctxt->value->nodesetval->nodeTab[ctxt->\n                                                                 value->\n                                                                 nodesetval->\n                                                                 nodeNr -\n                                                                 1];\n                            ctxt->value->nodesetval->nodeNr = 1;\n                        }\n                        return (total);\n                    }\n                }\n\t\t/*\n\t\t* Process inner predicates first.\n\t\t* Example \"index[parent::book][1]\":\n\t\t* ...\n\t\t*   PREDICATE   <-- we are here \"[1]\"\n\t\t*     PREDICATE <-- process \"[parent::book]\" first\n\t\t*       SORT\n\t\t*         COLLECT  'parent' 'name' 'node' book\n\t\t*           NODE\n\t\t*     ELEM Object is a number : 1\n\t\t*/\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n                if (op->ch2 == -1)\n                    return (total);\n                if (ctxt->value == NULL)\n                    return (total);\n\n                oldnode = ctxt->context->node;\n\n#ifdef LIBXML_XPTR_ENABLED\n                /*\n                 * Hum are we filtering the result of an XPointer expression\n                 */\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    xmlLocationSetPtr newlocset = NULL;\n                    xmlLocationSetPtr oldlocset;\n\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n                    ctxt->context->node = NULL;\n\n                    if ((oldlocset == NULL) || (oldlocset->locNr == 0)) {\n                        ctxt->context->contextSize = 0;\n                        ctxt->context->proximityPosition = 0;\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n                        res = valuePop(ctxt);\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        valuePush(ctxt, obj);\n                        CHECK_ERROR0;\n                        return (total);\n                    }\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation need to be tested to\n                         * decided whether the filter succeeded or not\n                         */\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            xmlXPtrLocationSetAdd(newlocset,\n                                                  xmlXPathObjectCopy\n                                                  (oldlocset->locTab[i]));\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n\n                        ctxt->context->node = NULL;\n                    }\n\n                    /*\n                     * The result is used as the new evaluation locset.\n                     */\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = NULL;\n                    ctxt->context->contextSize = -1;\n                    ctxt->context->proximityPosition = -1;\n                    valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n                    ctxt->context->node = oldnode;\n                    return (total);\n                }\n#endif /* LIBXML_XPTR_ENABLED */\n\n                /*\n                 * Extract the old set, and then evaluate the result of the\n                 * expression for all the element in the set. use it to grow\n                 * up a new set.\n                 */\n                CHECK_TYPE0(XPATH_NODESET);\n                obj = valuePop(ctxt);\n                oldset = obj->nodesetval;\n\n                oldnode = ctxt->context->node;\n\t\toldDoc = ctxt->context->doc;\n                ctxt->context->node = NULL;\n\n                if ((oldset == NULL) || (oldset->nodeNr == 0)) {\n                    ctxt->context->contextSize = 0;\n                    ctxt->context->proximityPosition = 0;\n/*\n                    if (op->ch2 != -1)\n                        total +=\n                            xmlXPathCompOpEval(ctxt,\n                                               &comp->steps[op->ch2]);\n\t\t    CHECK_ERROR0;\n                    res = valuePop(ctxt);\n                    if (res != NULL)\n                        xmlXPathFreeObject(res);\n*/\n                    valuePush(ctxt, obj);\n                    ctxt->context->node = oldnode;\n                    CHECK_ERROR0;\n                } else {\n\t\t    tmp = NULL;\n                    /*\n                     * Initialize the new set.\n\t\t     * Also set the xpath document in case things like\n\t\t     * key() evaluation are attempted on the predicate\n                     */\n                    newset = xmlXPathNodeSetCreate(NULL);\n\t\t    /*\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"For each node in the node-set to be filtered, the\n\t\t    *  PredicateExpr is evaluated with that node as the\n\t\t    *  context node, with the number of nodes in the\n\t\t    *  node-set as the context size, and with the proximity\n\t\t    *  position of the node in the node-set with respect to\n\t\t    *  the axis as the context position;\"\n\t\t    * @oldset is the node-set\" to be filtered.\n\t\t    *\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"only predicates change the context position and\n\t\t    *  context size (see [2.4 Predicates]).\"\n\t\t    * Example:\n\t\t    *   node-set  context pos\n\t\t    *    nA         1\n\t\t    *    nB         2\n\t\t    *    nC         3\n\t\t    *   After applying predicate [position() > 1] :\n\t\t    *   node-set  context pos\n\t\t    *    nB         1\n\t\t    *    nC         2\n\t\t    *\n\t\t    * removed the first node in the node-set, then\n\t\t    * the context position of the\n\t\t    */\n                    for (i = 0; i < oldset->nodeNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of\n                         * a single item in the nodeset.\n                         */\n                        ctxt->context->node = oldset->nodeTab[i];\n\t\t\tif ((oldset->nodeTab[i]->type != XML_NAMESPACE_DECL) &&\n\t\t\t    (oldset->nodeTab[i]->doc != NULL))\n\t\t            ctxt->context->doc = oldset->nodeTab[i]->doc;\n\t\t\tif (tmp == NULL) {\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n\t\t\t} else {\n\t\t\t    if (xmlXPathNodeSetAddUnique(tmp->nodesetval,\n\t\t\t\t               ctxt->context->node) < 0) {\n\t\t\t\tctxt->error = XPATH_MEMORY_ERROR;\n\t\t\t    }\n\t\t\t}\n                        valuePush(ctxt, tmp);\n                        ctxt->context->contextSize = oldset->nodeNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\t/*\n\t\t\t* Evaluate the predicate against the context node.\n\t\t\t* Can/should we optimize position() predicates\n\t\t\t* here (e.g. \"[1]\")?\n\t\t\t*/\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeNodeSet(newset);\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation needs to be tested to\n                         * decide whether the filter succeeded or not\n                         */\n\t\t\t/*\n\t\t\t* OPTIMIZE TODO: Can we use\n\t\t\t* xmlXPathNodeSetAdd*Unique()* instead?\n\t\t\t*/\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            if (xmlXPathNodeSetAdd(newset, oldset->nodeTab[i])\n\t\t\t        < 0)\n\t\t\t\tctxt->error = XPATH_MEMORY_ERROR;\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            valuePop(ctxt);\n\t\t\t    xmlXPathNodeSetClear(tmp->nodesetval, 1);\n\t\t\t    /*\n\t\t\t    * Don't free the temporary nodeset\n\t\t\t    * in order to avoid massive recreation inside this\n\t\t\t    * loop.\n\t\t\t    */\n                        } else\n\t\t\t    tmp = NULL;\n                        ctxt->context->node = NULL;\n                    }\n\t\t    if (tmp != NULL)\n\t\t\txmlXPathReleaseObject(ctxt->context, tmp);\n                    /*\n                     * The result is used as the new evaluation set.\n                     */\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = NULL;\n                    ctxt->context->contextSize = -1;\n                    ctxt->context->proximityPosition = -1;\n\t\t    /* may want to move this past the '}' later */\n\t\t    ctxt->context->doc = oldDoc;\n\t\t    valuePush(ctxt,\n\t\t\txmlXPathCacheWrapNodeSet(ctxt->context, newset));\n                }\n                ctxt->context->node = oldnode;\n                return (total);\n            }\n        case XPATH_OP_SORT:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if ((ctxt->value != NULL) &&\n                (ctxt->value->type == XPATH_NODESET) &&\n                (ctxt->value->nodesetval != NULL) &&\n\t\t(ctxt->value->nodesetval->nodeNr > 1))\n\t    {\n                xmlXPathNodeSetSort(ctxt->value->nodesetval);\n\t    }\n            return (total);\n#ifdef LIBXML_XPTR_ENABLED\n        case XPATH_OP_RANGETO:{\n                xmlXPathObjectPtr range;\n                xmlXPathObjectPtr res, obj;\n                xmlXPathObjectPtr tmp;\n                xmlLocationSetPtr newlocset = NULL;\n\t\t    xmlLocationSetPtr oldlocset;\n                xmlNodeSetPtr oldset;\n                int i, j;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->ch2 == -1)\n                    return (total);\n\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n\n                    if ((oldlocset == NULL) || (oldlocset->locNr == 0)) {\n\t\t        ctxt->context->node = NULL;\n                        ctxt->context->contextSize = 0;\n                        ctxt->context->proximityPosition = 0;\n                        total += xmlXPathCompOpEval(ctxt,&comp->steps[op->ch2]);\n                        res = valuePop(ctxt);\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        valuePush(ctxt, obj);\n                        CHECK_ERROR0;\n                        return (total);\n                    }\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        res = valuePop(ctxt);\n\t\t\tif (res->type == XPATH_LOCATIONSET) {\n\t\t\t    xmlLocationSetPtr rloc =\n\t\t\t        (xmlLocationSetPtr)res->user;\n\t\t\t    for (j=0; j<rloc->locNr; j++) {\n\t\t\t        range = xmlXPtrNewRange(\n\t\t\t\t  oldlocset->locTab[i]->user,\n\t\t\t\t  oldlocset->locTab[i]->index,\n\t\t\t\t  rloc->locTab[j]->user2,\n\t\t\t\t  rloc->locTab[j]->index2);\n\t\t\t\tif (range != NULL) {\n\t\t\t\t    xmlXPtrLocationSetAdd(newlocset, range);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    range = xmlXPtrNewRangeNodeObject(\n\t\t\t\t(xmlNodePtr)oldlocset->locTab[i]->user, res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset,range);\n\t\t\t    }\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n\n                        ctxt->context->node = NULL;\n                    }\n\t\t} else {\t/* Not a location set */\n                    CHECK_TYPE0(XPATH_NODESET);\n                    obj = valuePop(ctxt);\n                    oldset = obj->nodesetval;\n                    ctxt->context->node = NULL;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    if (oldset != NULL) {\n                        for (i = 0; i < oldset->nodeNr; i++) {\n                            /*\n                             * Run the evaluation with a node list made of a single item\n                             * in the nodeset.\n                             */\n                            ctxt->context->node = oldset->nodeTab[i];\n\t\t\t    /*\n\t\t\t    * OPTIMIZE TODO: Avoid recreation for every iteration.\n\t\t\t    */\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n                            valuePush(ctxt, tmp);\n\n                            if (op->ch2 != -1)\n                                total +=\n                                    xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\t    if (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t\txmlXPathFreeObject(obj);\n\t\t\t\treturn(0);\n\t\t\t    }\n\n                            res = valuePop(ctxt);\n                            range =\n                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],\n                                                      res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset, range);\n                            }\n\n                            /*\n                             * Cleanup\n                             */\n                            if (res != NULL) {\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n\t\t\t    }\n                            if (ctxt->value == tmp) {\n                                res = valuePop(ctxt);\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n                            }\n\n                            ctxt->context->node = NULL;\n                        }\n                    }\n                }\n\n                /*\n                 * The result is used as the new evaluation set.\n                 */\n\t\txmlXPathReleaseObject(ctxt->context, obj);\n                ctxt->context->node = NULL;\n                ctxt->context->contextSize = -1;\n                ctxt->context->proximityPosition = -1;\n                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n                return (total);\n            }\n#endif /* LIBXML_XPTR_ENABLED */\n    }\n    xmlGenericError(xmlGenericErrorContext,\n                    \"XPath: unknown precompiled operation %d\\n\", op->op);\n    ctxt->error = XPATH_INVALID_OPERAND;",
  "project": "libxml2",
  "hash": 90052071217259512981949438005234061143,
  "size": 878,
  "commit_id": "03c6723043775122313f107695066e5744189a08",
  "message": "Handling of XPath function arguments in error case\n\nThe XPath engine tries to guarantee that every XPath function can pop\n'nargs' non-NULL values off the stack. libxslt, for example, relies on\nthis assumption. But the check isn't thorough enough if there are errors\nduring the evaluation of arguments. This can lead to segfaults:\n\nhttps://mail.gnome.org/archives/xslt/2013-December/msg00005.html\n\nThis commit makes the handling of function arguments more robust.\n\n* Bail out early when evaluation of XPath function arguments fails.\n* Make sure that there are 'nargs' arguments in the current call frame.",
  "target": 1,
  "dataset": "other",
  "idx": 208741
}