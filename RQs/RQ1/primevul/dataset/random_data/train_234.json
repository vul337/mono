{
  "id": 234,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/guillemj/libbsd/commit/c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7",
  "commit_sha": "c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7",
  "commit_msg": "Fix heap buffer overflow in fgetwln()\n\nIn the function fgetwln() there's a 4 byte heap overflow.\n\nThere is a while loop that has this check to see whether there's still\nenough space in the buffer:\n\n\t\tif (!fb->len || wused > fb->len) {\n\nIf this is true more memory gets allocated. However this test won't be\ntrue if wused == fb->len, but at that point wused already points out\nof the buffer. Some lines later there's a write to the buffer:\n\n\t\tfb->wbuf[wused++] = wc;\n\nThis bug was found with the help of address sanitizer.\n\nWarned-by: ASAN\nFixes: https://bugs.freedesktop.org/show_bug.cgi?id=93881\nSigned-off-by: Guillem Jover <guillem@hadrons.org>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/fgetwln.c",
  "func_name": "",
  "raw_func_from_json": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\n\t/* Try to diminish the possibility of several fgetwln() calls being\n\t * used on different streams, by using a pool of buffers per file. */\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused > fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\n\t\tfb->wbuf[wused++] = wc;\n\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}\n",
  "diff_func": "@@ -60,7 +60,7 @@ fgetwln(FILE *stream, size_t *lenp)\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n-\t\tif (!fb->len || wused > fb->len) {\n+\t\tif (!fb->len || wused >= fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)",
  "project": "libbsd",
  "commit_id": "c8f0723d2b4520bdd6b9eb7c3e7976de726d7ff7",
  "target": 1,
  "func": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\n\t/* Try to diminish the possibility of several fgetwln() calls being\n\t * used on different streams, by using a pool of buffers per file. */\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused > fb->len) {\n \t\t\twchar_t *wp;\n \n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\n\t\tfb->wbuf[wused++] = wc;\n\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}\n",
  "big_vul_idx": 178522,
  "idx": 462,
  "hash": 111742657801644456380340973720301242850
}