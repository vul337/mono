{
  "id": 908,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/b0c5222ce31e8f941fa02ff9c7a040fb2db30dbc",
  "commit_sha": "b0c5222ce31e8f941fa02ff9c7a040fb2db30dbc",
  "commit_msg": "https://github.com/ImageMagick/ImageMagick/issues/501",
  "pr_url": null,
  "pr_info": null,
  "file_name": "coders/jp2.c",
  "func_name": "",
  "raw_func_from_json": "static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  opj_codestream_index_t\n    *codestream_index = (opj_codestream_index_t *) NULL;\n\n  opj_dparameters_t\n    parameters;\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned char\n    sans[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JP2 codec.\n  */\n  if (ReadBlob(image,4,sans) != 4)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SeekBlob(image,SEEK_SET,0);\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_decompress(OPJ_CODEC_JPT);\n  else\n    if (IsJ2K(sans,4) != MagickFalse)\n      jp2_codec=opj_create_decompress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_decompress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_set_default_decoder_parameters(&parameters);\n  option=GetImageOption(image_info,\"jp2:reduce-factor\");\n  if (option != (const char *) NULL)\n    parameters.cp_reduce=StringToInteger(option);\n  option=GetImageOption(image_info,\"jp2:quality-layers\");\n  if (option == (const char *) NULL)\n    option=GetImageOption(image_info,\"jp2:layer-number\");\n  if (option != (const char *) NULL)\n    parameters.cp_layer=StringToInteger(option);\n  if (opj_setup_decoder(jp2_codec,&parameters) == 0)\n    {\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToManageJP2Stream\");\n    }\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image));\n  if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  jp2_status=1;\n  if ((image->columns != 0) && (image->rows != 0))\n    {\n      /*\n        Extract an area from the image.\n      */\n      jp2_status=opj_set_decode_area(jp2_codec,jp2_image,\n        (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y,\n        (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns,\n        (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows);\n      if (jp2_status == 0)\n        {\n          opj_stream_destroy(jp2_stream);\n          opj_destroy_codec(jp2_codec);\n          opj_image_destroy(jp2_image);\n          ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n        }\n    }\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image,\n      (unsigned int) image_info->scene-1);\n  else\n    if (image->ping == MagickFalse)\n      {\n        jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image);\n        if (jp2_status != 0)\n          jp2_status=opj_end_decompress(jp2_codec,jp2_stream);\n      }\n  if (jp2_status == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  opj_stream_destroy(jp2_stream);\n  for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n  {\n    if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||\n        (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||\n         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n         (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) ||\n        (jp2_image->comps[i].data == NULL))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);\n        ThrowReaderException(CoderError,\"IrregularChannelGeometryNotSupported\")\n      }\n  }\n  /*\n    Convert JP2 image.\n  */\n  image->columns=(size_t) jp2_image->comps[0].w;\n  image->rows=(size_t) jp2_image->comps[0].h;\n  image->depth=jp2_image->comps[0].prec;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  image->compression=JPEG2000Compression;\n  if (jp2_image->color_space == 2)\n    {\n      SetImageColorspace(image,GRAYColorspace);\n      if (jp2_image->numcomps > 1)\n        image->matte=MagickTrue;\n    }\n  else\n    if (jp2_image->color_space == 3)\n      SetImageColorspace(image,Rec601YCbCrColorspace);\n  if (jp2_image->numcomps > 3)\n    image->matte=MagickTrue;\n  if (jp2_image->icc_profile_buf != (unsigned char *) NULL)\n    {\n      StringInfo\n        *profile;\n\n      profile=BlobToStringInfo(jp2_image->icc_profile_buf,\n        jp2_image->icc_profile_len);\n      if (profile != (StringInfo *) NULL)\n        SetImageProfile(image,\"icc\",profile);\n    }\n  if (image->ping != MagickFalse)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      opj_destroy_cstr_index(&codestream_index);\n      return(GetFirstImageInList(image));\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n      {\n        double\n          pixel,\n          scale;\n\n        scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1);\n        pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+\n          (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0));\n        switch (i)\n        {\n           case 0:\n           {\n             q->red=ClampToQuantum(pixel);\n             q->green=q->red;\n             q->blue=q->red;\n             q->opacity=OpaqueOpacity;\n             break;\n           }\n           case 1:\n           {\n             if (jp2_image->numcomps == 2)\n               {\n                 q->opacity=ClampToQuantum(QuantumRange-pixel);\n                 break;\n               }\n             q->green=ClampToQuantum(pixel);\n             break;\n           }\n           case 2:\n           {\n             q->blue=ClampToQuantum(pixel);\n             break;\n           }\n           case 3:\n           {\n             q->opacity=ClampToQuantum(QuantumRange-pixel);\n             break;\n           }\n        }\n      }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  opj_destroy_cstr_index(&codestream_index);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
  "diff_func": "@@ -393,7 +393,7 @@ static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n         (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) ||\n-        (jp2_image->comps[i].data == NULL))\n+        ((image->ping == MagickFalse) && (jp2_image->comps[i].data == NULL)))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);",
  "project": "ImageMagick",
  "commit_id": "b0c5222ce31e8f941fa02ff9c7a040fb2db30dbc",
  "target": 1,
  "func": "static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  opj_codestream_index_t\n    *codestream_index = (opj_codestream_index_t *) NULL;\n\n  opj_dparameters_t\n    parameters;\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned char\n    sans[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JP2 codec.\n  */\n  if (ReadBlob(image,4,sans) != 4)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SeekBlob(image,SEEK_SET,0);\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_decompress(OPJ_CODEC_JPT);\n  else\n    if (IsJ2K(sans,4) != MagickFalse)\n      jp2_codec=opj_create_decompress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_decompress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_set_default_decoder_parameters(&parameters);\n  option=GetImageOption(image_info,\"jp2:reduce-factor\");\n  if (option != (const char *) NULL)\n    parameters.cp_reduce=StringToInteger(option);\n  option=GetImageOption(image_info,\"jp2:quality-layers\");\n  if (option == (const char *) NULL)\n    option=GetImageOption(image_info,\"jp2:layer-number\");\n  if (option != (const char *) NULL)\n    parameters.cp_layer=StringToInteger(option);\n  if (opj_setup_decoder(jp2_codec,&parameters) == 0)\n    {\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToManageJP2Stream\");\n    }\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image));\n  if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  jp2_status=1;\n  if ((image->columns != 0) && (image->rows != 0))\n    {\n      /*\n        Extract an area from the image.\n      */\n      jp2_status=opj_set_decode_area(jp2_codec,jp2_image,\n        (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y,\n        (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns,\n        (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows);\n      if (jp2_status == 0)\n        {\n          opj_stream_destroy(jp2_stream);\n          opj_destroy_codec(jp2_codec);\n          opj_image_destroy(jp2_image);\n          ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n        }\n    }\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image,\n      (unsigned int) image_info->scene-1);\n  else\n    if (image->ping == MagickFalse)\n      {\n        jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image);\n        if (jp2_status != 0)\n          jp2_status=opj_end_decompress(jp2_codec,jp2_stream);\n      }\n  if (jp2_status == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  opj_stream_destroy(jp2_stream);\n  for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n  {\n    if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||\n        (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||\n         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n         (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) ||\n        (jp2_image->comps[i].data == NULL))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);\n        ThrowReaderException(CoderError,\"IrregularChannelGeometryNotSupported\")\n      }\n  }\n  /*\n    Convert JP2 image.\n  */\n  image->columns=(size_t) jp2_image->comps[0].w;\n  image->rows=(size_t) jp2_image->comps[0].h;\n  image->depth=jp2_image->comps[0].prec;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  image->compression=JPEG2000Compression;\n  if (jp2_image->color_space == 2)\n    {\n      SetImageColorspace(image,GRAYColorspace);\n      if (jp2_image->numcomps > 1)\n        image->matte=MagickTrue;\n    }\n  else\n    if (jp2_image->color_space == 3)\n      SetImageColorspace(image,Rec601YCbCrColorspace);\n  if (jp2_image->numcomps > 3)\n    image->matte=MagickTrue;\n  if (jp2_image->icc_profile_buf != (unsigned char *) NULL)\n    {\n      StringInfo\n        *profile;\n\n      profile=BlobToStringInfo(jp2_image->icc_profile_buf,\n        jp2_image->icc_profile_len);\n      if (profile != (StringInfo *) NULL)\n        SetImageProfile(image,\"icc\",profile);\n    }\n  if (image->ping != MagickFalse)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      opj_destroy_cstr_index(&codestream_index);\n      return(GetFirstImageInList(image));\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n      {\n        double\n          pixel,\n          scale;\n\n        scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1);\n        pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+\n          (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0));\n        switch (i)\n        {\n           case 0:\n           {\n             q->red=ClampToQuantum(pixel);\n             q->green=q->red;\n             q->blue=q->red;\n             q->opacity=OpaqueOpacity;\n             break;\n           }\n           case 1:\n           {\n             if (jp2_image->numcomps == 2)\n               {\n                 q->opacity=ClampToQuantum(QuantumRange-pixel);\n                 break;\n               }\n             q->green=ClampToQuantum(pixel);\n             break;\n           }\n           case 2:\n           {\n             q->blue=ClampToQuantum(pixel);\n             break;\n           }\n           case 3:\n           {\n             q->opacity=ClampToQuantum(QuantumRange-pixel);\n             break;\n           }\n        }\n      }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  opj_destroy_cstr_index(&codestream_index);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
  "big_vul_idx": 180981,
  "idx": 2510,
  "hash": 72100147686150998415581732716926132312
}