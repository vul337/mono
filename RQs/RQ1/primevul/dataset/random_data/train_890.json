{
  "id": 890,
  "language": "texi",
  "cwe": "CWE-835",
  "commit_url": "https://github.com/etemesi254/ffmpeg-ht/commit/7ec414892ddcad88313848494b6fc5f437c9ca4a",
  "commit_sha": "7ec414892ddcad88313848494b6fc5f437c9ca4a",
  "commit_msg": "avformat/hls: Fix DoS due to infinite loop\n\nFixes: loop.m3u\n\nThe default max iteration count of 1000 is arbitrary and ideas for a better solution are welcome\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\n\nPrevious version reviewed-by: Steven Liu <lingjiujianke@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "doc/demuxers.texi",
  "func_name": "",
  "raw_func_from_json": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n     HLSContext *c = v->parent->priv_data;\n     int ret, i;\n     int just_opened = 0;\n \n restart:\n     if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n         reload_interval = default_reload_interval(v);\n \n reload:\n         if (!v->finished &&\n             av_gettime_relative() - v->last_load_time >= reload_interval) {\n             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n",
  "diff_func": "@@ -300,6 +300,24 @@ used to end the output video at the length of the shortest input file,\n which in this case is @file{input.mp4} as the GIF in this example loops\n infinitely.\n \n+@section hls\n+\n+HLS demuxer\n+\n+It accepts the following options:\n+\n+@table @option\n+@item live_start_index\n+segment index to start live streams at (negative values are from the end).\n+\n+@item allowed_extensions\n+',' separated list of file extensions that hls is allowed to access.\n+\n+@item max_reload\n+Maximum number of times a insufficient list is attempted to be reloaded.\n+Default value is 1000.\n+@end table\n+\n @section image2\n \n Image file demuxer.",
  "project": "FFmpeg",
  "commit_id": "7ec414892ddcad88313848494b6fc5f437c9ca4a",
  "target": 1,
  "func": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n     HLSContext *c = v->parent->priv_data;\n     int ret, i;\n     int just_opened = 0;\n \n restart:\n     if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n         reload_interval = default_reload_interval(v);\n \n reload:\n         if (!v->finished &&\n             av_gettime_relative() - v->last_load_time >= reload_interval) {\n             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n",
  "big_vul_idx": 180946,
  "idx": 2481,
  "hash": 113402367066446233577404734885364428310
}