{
  "id": 903,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/27b1c74979ac473a430e266ff6c4b645664bc805",
  "commit_sha": "27b1c74979ac473a430e266ff6c4b645664bc805",
  "commit_msg": "https://github.com/ImageMagick/ImageMagick/issues/1522",
  "pr_url": null,
  "pr_info": null,
  "file_name": "magick/image.c",
  "func_name": "",
  "raw_func_from_json": "MagickExport Image *AcquireImage(const ImageInfo *image_info)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireCriticalMemory(sizeof(*image));\n  (void) memset(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MaxTextExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.blue_primary.z=0.7900f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->chromaticity.white_point.z=0.3583f;\n  image->interlace=NoInterlace;\n  image->ticks_per_second=UndefinedTicksPerSecond;\n  image->compose=OverCompositeOp;\n  image->blur=1.0;\n  InitializeExceptionInfo(&image->exception);\n  (void) QueryColorDatabase(BackgroundColor,&image->background_color,\n    &image->exception);\n  (void) QueryColorDatabase(BorderColor,&image->border_color,&image->exception);\n  (void) QueryColorDatabase(MatteColor,&image->matte_color,&image->exception);\n  (void) QueryColorDatabase(TransparentColor,&image->transparent_color,\n    &image->exception);\n  GetTimerInfo(&image->timer);\n  image->ping=MagickFalse;\n  image->cache=AcquirePixelCache(0);\n  image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  image->timestamp=time((time_t *) NULL);\n  image->debug=IsEventLogging();\n  image->reference_count=1;\n  image->semaphore=AllocateSemaphoreInfo();\n  image->signature=MagickCoreSignature;\n  if (image_info == (ImageInfo *) NULL)\n    return(image);\n  /*\n    Transfer image info.\n  */\n  SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n    MagickFalse);\n  (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);\n  (void) CopyMagickString(image->magick_filename,image_info->filename,\n    MaxTextExtent);\n  (void) CopyMagickString(image->magick,image_info->magick,MaxTextExtent);\n  if (image_info->size != (char *) NULL)\n    {\n      (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n      image->columns=image->extract_info.width;\n      image->rows=image->extract_info.height;\n      image->offset=image->extract_info.x;\n      image->extract_info.x=0;\n      image->extract_info.y=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      (void) memset(&geometry,0,sizeof(geometry));\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n        {\n          image->extract_info=geometry;\n          Swap(image->columns,image->extract_info.width);\n          Swap(image->rows,image->extract_info.height);\n        }\n    }\n  image->compression=image_info->compression;\n  image->quality=image_info->quality;\n  image->endian=image_info->endian;\n  image->interlace=image_info->interlace;\n  image->units=image_info->units;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      image->page=image->extract_info;\n      geometry=GetPageGeometry(image_info->page);\n      (void) ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  if (image_info->depth != 0)\n    image->depth=image_info->depth;\n  image->dither=image_info->dither;\n  image->background_color=image_info->background_color;\n  image->border_color=image_info->border_color;\n  image->matte_color=image_info->matte_color;\n  image->transparent_color=image_info->transparent_color;\n  image->ping=image_info->ping;\n  image->progress_monitor=image_info->progress_monitor;\n  image->client_data=image_info->client_data;\n  if (image_info->cache != (void *) NULL)\n    ClonePixelCacheMethods(image->cache,image_info->cache);\n  (void) SyncImageSettings(image_info,image);\n  option=GetImageOption(image_info,\"delay\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & GreaterValue) != 0)\n        {\n          if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n            image->delay=(size_t) floor(geometry_info.rho+0.5);\n        }\n      else\n        if ((flags & LessValue) != 0)\n          {\n            if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n              image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          }\n        else\n          image->delay=(size_t) floor(geometry_info.rho+0.5);\n      if ((flags & SigmaValue) != 0)\n        image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n    }\n  option=GetImageOption(image_info,\"dispose\");\n  if (option != (const char *) NULL)\n    image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n      MagickFalse,option);\n  return(image);\n}",
  "diff_func": "@@ -252,10 +252,11 @@ MagickExport Image *AcquireImage(const ImageInfo *image_info)\n         geometry_info;\n \n       flags=ParseGeometry(image_info->density,&geometry_info);\n-      image->x_resolution=geometry_info.rho;\n-      image->y_resolution=geometry_info.sigma;\n-      if ((flags & SigmaValue) == 0)\n-        image->y_resolution=image->x_resolution;\n+      if ((flags & RhoValue) != 0)\n+        image->x_resolution=geometry_info.rho;\n+      image->y_resolution=image->x_resolution;\n+      if ((flags & SigmaValue) != 0)\n+        image->y_resolution=geometry_info.sigma;\n     }\n   if (image_info->page != (char *) NULL)\n     {",
  "func": "MagickExport Image *AcquireImage(const ImageInfo *image_info)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireCriticalMemory(sizeof(*image));\n  (void) memset(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MaxTextExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.blue_primary.z=0.7900f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->chromaticity.white_point.z=0.3583f;\n  image->interlace=NoInterlace;\n  image->ticks_per_second=UndefinedTicksPerSecond;\n  image->compose=OverCompositeOp;\n  image->blur=1.0;\n  InitializeExceptionInfo(&image->exception);\n  (void) QueryColorDatabase(BackgroundColor,&image->background_color,\n    &image->exception);\n  (void) QueryColorDatabase(BorderColor,&image->border_color,&image->exception);\n  (void) QueryColorDatabase(MatteColor,&image->matte_color,&image->exception);\n  (void) QueryColorDatabase(TransparentColor,&image->transparent_color,\n    &image->exception);\n  GetTimerInfo(&image->timer);\n  image->ping=MagickFalse;\n  image->cache=AcquirePixelCache(0);\n  image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  image->timestamp=time((time_t *) NULL);\n  image->debug=IsEventLogging();\n  image->reference_count=1;\n  image->semaphore=AllocateSemaphoreInfo();\n  image->signature=MagickCoreSignature;\n  if (image_info == (ImageInfo *) NULL)\n    return(image);\n  /*\n    Transfer image info.\n  */\n  SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n    MagickFalse);\n  (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);\n  (void) CopyMagickString(image->magick_filename,image_info->filename,\n    MaxTextExtent);\n  (void) CopyMagickString(image->magick,image_info->magick,MaxTextExtent);\n  if (image_info->size != (char *) NULL)\n    {\n      (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n      image->columns=image->extract_info.width;\n      image->rows=image->extract_info.height;\n      image->offset=image->extract_info.x;\n      image->extract_info.x=0;\n      image->extract_info.y=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      (void) memset(&geometry,0,sizeof(geometry));\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n        {\n          image->extract_info=geometry;\n          Swap(image->columns,image->extract_info.width);\n          Swap(image->rows,image->extract_info.height);\n        }\n    }\n  image->compression=image_info->compression;\n  image->quality=image_info->quality;\n  image->endian=image_info->endian;\n  image->interlace=image_info->interlace;\n  image->units=image_info->units;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      image->page=image->extract_info;\n      geometry=GetPageGeometry(image_info->page);\n      (void) ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  if (image_info->depth != 0)\n    image->depth=image_info->depth;\n  image->dither=image_info->dither;\n  image->background_color=image_info->background_color;\n  image->border_color=image_info->border_color;\n  image->matte_color=image_info->matte_color;\n  image->transparent_color=image_info->transparent_color;\n  image->ping=image_info->ping;\n  image->progress_monitor=image_info->progress_monitor;\n  image->client_data=image_info->client_data;\n  if (image_info->cache != (void *) NULL)\n    ClonePixelCacheMethods(image->cache,image_info->cache);\n  (void) SyncImageSettings(image_info,image);\n  option=GetImageOption(image_info,\"delay\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & GreaterValue) != 0)\n        {\n          if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n            image->delay=(size_t) floor(geometry_info.rho+0.5);\n        }\n      else\n        if ((flags & LessValue) != 0)\n          {\n            if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n              image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          }\n        else\n          image->delay=(size_t) floor(geometry_info.rho+0.5);\n      if ((flags & SigmaValue) != 0)\n        image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n    }\n  option=GetImageOption(image_info,\"dispose\");\n  if (option != (const char *) NULL)\n    image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n      MagickFalse,option);\n  return(image);\n}",
  "project": "ImageMagick6",
  "hash": 172244786076976468574270858869555969333,
  "size": 160,
  "commit_id": "27b1c74979ac473a430e266ff6c4b645664bc805",
  "message": "https://github.com/ImageMagick/ImageMagick/issues/1522",
  "target": 1,
  "dataset": "other",
  "idx": 210612
}