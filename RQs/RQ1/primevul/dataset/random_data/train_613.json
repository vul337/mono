{
  "id": 613,
  "language": "c",
  "cwe": "CWE-264",
  "commit_url": "https://github.com/AdnanHodzic/lxcfs-debian/commit/8ee2a503e102b1a43ec4d83113dc275ab20a869a",
  "commit_sha": "8ee2a503e102b1a43ec4d83113dc275ab20a869a",
  "commit_msg": "Implement privilege check when moving tasks\n\nWhen writing pids to a tasks file in lxcfs, lxcfs was checking\nfor privilege over the tasks file but not over the pid being\nmoved.  Since the cgm_movepid request is done as root on the host,\nnot with the requestor's credentials, we must copy the check which\ncgmanager was doing to ensure that the requesting task is allowed\nto change the victim task's cgroup membership.\n\nThis is CVE-2015-1344\nhttps://bugs.launchpad.net/ubuntu/+source/lxcfs/+bug/1512854\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "lxcfs.c",
  "func_name": "",
  "raw_func_from_json": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n {\n \tint sock[2] = {-1, -1};\n \tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\n\t/*\n\t * write the pids to a socket, have helper in writer's pidns\n\t * call movepid for us\n\t */\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\n\tif (!cpid) { // child\n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n \n \t\tif (recv_creds(sock[0], &cred, &v)) {\n \t\t\tif (v == '0') {\n \t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n \t\t\t\t\tfail = true;\n \t\t\t}\n\t\t}\n\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\n\t/* All good, write the value */\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\n\tif (!fail)\n\t\tanswer = true;\n\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}\n",
  "diff_func": "@@ -1336,7 +1336,95 @@ static void pid_from_ns_wrapper(int sock, pid_t tpid)\n \tgoto loop;\n }\n \n-static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n+/*\n+ * Given host @uid, return the uid to which it maps in\n+ * @pid's user namespace, or -1 if none.\n+ */\n+bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)\n+{\n+\tFILE *f;\n+\tchar line[400];\n+\n+\tsprintf(line, \"/proc/%d/uid_map\", pid);\n+\tif ((f = fopen(line, \"r\")) == NULL) {\n+\t\treturn false;\n+\t}\n+\n+\t*answer = convert_id_to_ns(f, uid);\n+\tfclose(f);\n+\n+\tif (*answer == -1)\n+\t\treturn false;\n+\treturn true;\n+}\n+\n+/*\n+ * get_pid_creds: get the real uid and gid of @pid from\n+ * /proc/$$/status\n+ * (XXX should we use euid here?)\n+ */\n+void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)\n+{\n+\tchar line[400];\n+\tuid_t u;\n+\tgid_t g;\n+\tFILE *f;\n+\n+\t*uid = -1;\n+\t*gid = -1;\n+\tsprintf(line, \"/proc/%d/status\", pid);\n+\tif ((f = fopen(line, \"r\")) == NULL) {\n+\t\tfprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));\n+\t\treturn;\n+\t}\n+\twhile (fgets(line, 400, f)) {\n+\t\tif (strncmp(line, \"Uid:\", 4) == 0) {\n+\t\t\tif (sscanf(line+4, \"%u\", &u) != 1) {\n+\t\t\t\tfprintf(stderr, \"bad uid line for pid %u\\n\", pid);\n+\t\t\t\tfclose(f);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t*uid = u;\n+\t\t} else if (strncmp(line, \"Gid:\", 4) == 0) {\n+\t\t\tif (sscanf(line+4, \"%u\", &g) != 1) {\n+\t\t\t\tfprintf(stderr, \"bad gid line for pid %u\\n\", pid);\n+\t\t\t\tfclose(f);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t*gid = g;\n+\t\t}\n+\t}\n+\tfclose(f);\n+}\n+\n+/*\n+ * May the requestor @r move victim @v to a new cgroup?\n+ * This is allowed if\n+ *   . they are the same task\n+ *   . they are ownedy by the same uid\n+ *   . @r is root on the host, or\n+ *   . @v's uid is mapped into @r's where @r is root.\n+ */\n+bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)\n+{\n+\tuid_t v_uid, tmpuid;\n+\tgid_t v_gid;\n+\n+\tif (r == v)\n+\t\treturn true;\n+\tif (r_uid == 0)\n+\t\treturn true;\n+\tget_pid_creds(v, &v_uid, &v_gid);\n+\tif (r_uid == v_uid)\n+\t\treturn true;\n+\tif (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0\n+\t\t\t&& hostuid_to_ns(v_uid, r, &tmpuid))\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,\n+\t\tconst char *file, const char *buf)\n {\n \tint sock[2] = {-1, -1};\n \tpid_t qpid, cpid = -1;\n@@ -1378,6 +1466,10 @@ static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const\n \n \t\tif (recv_creds(sock[0], &cred, &v)) {\n \t\t\tif (v == '0') {\n+\t\t\t\tif (!may_move_pid(tpid, tuid, cred.pid)) {\n+\t\t\t\t\tfail = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n \t\t\t\t\tfail = true;\n \t\t\t}\n@@ -1450,7 +1542,7 @@ int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n \t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n \t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n \t\t// special case - we have to translate the pids\n-\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n+\t\tr = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);\n \telse\n \t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n ",
  "project": "lxcfs",
  "commit_id": "8ee2a503e102b1a43ec4d83113dc275ab20a869a",
  "target": 1,
  "func": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n {\n \tint sock[2] = {-1, -1};\n \tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\n\t/*\n\t * write the pids to a socket, have helper in writer's pidns\n\t * call movepid for us\n\t */\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\n\tif (!cpid) { // child\n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n \n \t\tif (recv_creds(sock[0], &cred, &v)) {\n \t\t\tif (v == '0') {\n \t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n \t\t\t\t\tfail = true;\n \t\t\t}\n\t\t}\n\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\n\t/* All good, write the value */\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\n\tif (!fail)\n\t\tanswer = true;\n\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}\n",
  "big_vul_idx": 179874,
  "idx": 1543,
  "hash": 6339406417675713990794536956805696333
}