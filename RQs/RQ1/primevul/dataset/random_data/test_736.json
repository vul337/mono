{
  "id": 736,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ProhorP/samba/commit/d92dfb0dabf9cfccb86f2b1146d6c353af2e1435",
  "commit_sha": "d92dfb0dabf9cfccb86f2b1146d6c353af2e1435",
  "commit_msg": "CVE-2021-3670 ldap_server: Remove duplicate print of LDAP search details\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=14694\n\nSigned-off-by: Andrew Bartlett <abartlet@samba.org>\nReviewed-by: Douglas Bagnall <douglas.bagnall@catalyst.net.nz>\n(cherry picked from commit 2b3af3b560c9617a233c131376c870fce146c002)",
  "pr_url": null,
  "pr_info": null,
  "file_name": "source4/ldap_server/ldap_backend.c",
  "func_name": "",
  "raw_func_from_json": "static NTSTATUS ldapsrv_SearchRequest(struct ldapsrv_call *call)\n{\n\tstruct ldap_SearchRequest *req = &call->request->r.SearchRequest;\n\tstruct ldap_Result *done;\n\tstruct ldapsrv_reply *done_r;\n\tTALLOC_CTX *local_ctx;\n\tstruct ldapsrv_context *callback_ctx = NULL;\n\tstruct ldb_context *samdb = talloc_get_type(call->conn->ldb, struct ldb_context);\n\tstruct ldb_dn *basedn;\n\tstruct ldb_request *lreq;\n\tstruct ldb_control *search_control;\n\tstruct ldb_search_options_control *search_options;\n\tstruct ldb_control *extended_dn_control;\n\tstruct ldb_extended_dn_control *extended_dn_decoded = NULL;\n\tstruct ldb_control *notification_control = NULL;\n\tenum ldb_scope scope = LDB_SCOPE_DEFAULT;\n\tconst char **attrs = NULL;\n\tconst char *scope_str, *errstr = NULL;\n\tint result = -1;\n\tint ldb_ret = -1;\n\tunsigned int i;\n\tint extended_type = 1;\n\n\tDEBUG(10, (\"SearchRequest\"));\n\tDEBUGADD(10, (\" basedn: %s\", req->basedn));\n\tDEBUGADD(10, (\" filter: %s\\n\", ldb_filter_from_tree(call, req->tree)));\n\n\tlocal_ctx = talloc_new(call);\n\tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n\n\tbasedn = ldb_dn_new(local_ctx, samdb, req->basedn);\n\tNT_STATUS_HAVE_NO_MEMORY(basedn);\n\n\tDEBUG(10, (\"SearchRequest: basedn: [%s]\\n\", req->basedn));\n\tDEBUG(10, (\"SearchRequest: filter: [%s]\\n\", ldb_filter_from_tree(call, req->tree)));\n\n\tswitch (req->scope) {\n\t\tcase LDAP_SEARCH_SCOPE_BASE:\n\t\t\tscope_str = \"BASE\";\n\t\t\tscope = LDB_SCOPE_BASE;\n\t\t\tbreak;\n\t\tcase LDAP_SEARCH_SCOPE_SINGLE:\n\t\t\tscope_str = \"ONE\";\n\t\t\tscope = LDB_SCOPE_ONELEVEL;\n\t\t\tbreak;\n\t\tcase LDAP_SEARCH_SCOPE_SUB:\n\t\t\tscope_str = \"SUB\";\n\t\t\tscope = LDB_SCOPE_SUBTREE;\n\t\t\tbreak;\n\t        default:\n\t\t\tresult = LDAP_PROTOCOL_ERROR;\n\t\t\tmap_ldb_error(local_ctx, LDB_ERR_PROTOCOL_ERROR, NULL,\n\t\t\t\t&errstr);\n\t\t\terrstr = talloc_asprintf(local_ctx,\n\t\t\t\t\"%s. Invalid scope\", errstr);\n\t\t\tgoto reply;\n\t}\n\tDEBUG(10,(\"SearchRequest: scope: [%s]\\n\", scope_str));\n\n\tif (req->num_attributes >= 1) {\n\t\tattrs = talloc_array(local_ctx, const char *, req->num_attributes+1);\n\t\tNT_STATUS_HAVE_NO_MEMORY(attrs);\n\n\t\tfor (i=0; i < req->num_attributes; i++) {\n\t\t\tDEBUG(10,(\"SearchRequest: attrs: [%s]\\n\",req->attributes[i]));\n\t\t\tattrs[i] = req->attributes[i];\n\t\t}\n\t\tattrs[i] = NULL;\n\t}\n\n\tDEBUG(5,(\"ldb_request %s dn=%s filter=%s\\n\", \n\t\t scope_str, req->basedn, ldb_filter_from_tree(call, req->tree)));\n\n\tcallback_ctx = talloc_zero(local_ctx, struct ldapsrv_context);\n\tNT_STATUS_HAVE_NO_MEMORY(callback_ctx);\n\tcallback_ctx->call = call;\n\tcallback_ctx->extended_type = extended_type;\n\tcallback_ctx->attributesonly = req->attributesonly;\n\n\tldb_ret = ldb_build_search_req_ex(&lreq, samdb, local_ctx,\n\t\t\t\t\t  basedn, scope,\n\t\t\t\t\t  req->tree, attrs,\n\t\t\t\t\t  call->request->controls,\n\t\t\t\t\t  callback_ctx,\n\t\t\t\t\t  ldap_server_search_callback,\n\t\t\t\t\t  NULL);\n\n\tif (ldb_ret != LDB_SUCCESS) {\n\t\tgoto reply;\n\t}\n\n\tif (call->conn->global_catalog) {\n\t\tsearch_control = ldb_request_get_control(lreq, LDB_CONTROL_SEARCH_OPTIONS_OID);\n\n\t\tsearch_options = NULL;\n\t\tif (search_control) {\n\t\t\tsearch_options = talloc_get_type(search_control->data, struct ldb_search_options_control);\n\t\t\tsearch_options->search_options |= LDB_SEARCH_OPTION_PHANTOM_ROOT;\n\t\t} else {\n\t\t\tsearch_options = talloc(lreq, struct ldb_search_options_control);\n\t\t\tNT_STATUS_HAVE_NO_MEMORY(search_options);\n\t\t\tsearch_options->search_options = LDB_SEARCH_OPTION_PHANTOM_ROOT;\n\t\t\tldb_request_add_control(lreq, LDB_CONTROL_SEARCH_OPTIONS_OID, false, search_options);\n\t\t}\n\t} else {\n\t\tldb_request_add_control(lreq, DSDB_CONTROL_NO_GLOBAL_CATALOG, false, NULL);\n\t}\n\n\textended_dn_control = ldb_request_get_control(lreq, LDB_CONTROL_EXTENDED_DN_OID);\n\n\tif (extended_dn_control) {\n\t\tif (extended_dn_control->data) {\n\t\t\textended_dn_decoded = talloc_get_type(extended_dn_control->data, struct ldb_extended_dn_control);\n\t\t\textended_type = extended_dn_decoded->type;\n\t\t} else {\n\t\t\textended_type = 0;\n\t\t}\n\t\tcallback_ctx->extended_type = extended_type;\n\t}\n\n\tnotification_control = ldb_request_get_control(lreq, LDB_CONTROL_NOTIFICATION_OID);\n\tif (notification_control != NULL) {\n\t\tconst struct ldapsrv_call *pc = NULL;\n\t\tsize_t count = 0;\n\n\t\tfor (pc = call->conn->pending_calls; pc != NULL; pc = pc->next) {\n\t\t\tcount += 1;\n\t\t}\n\n\t\tif (count >= call->conn->limits.max_notifications) {\n\t\t\tDEBUG(10,(\"SearchRequest: error MaxNotificationPerConn\\n\"));\n\t\t\tresult = map_ldb_error(local_ctx,\n\t\t\t\t\t       LDB_ERR_ADMIN_LIMIT_EXCEEDED,\n\t\t\t\t\t       \"MaxNotificationPerConn reached\",\n\t\t\t\t\t       &errstr);\n\t\t\tgoto reply;\n\t\t}\n\n\t\t/*\n\t\t * For now we need to do periodic retries on our own.\n\t\t * As the dsdb_notification module will return after each run.\n\t\t */\n\t\tcall->notification.busy = true;\n\t}\n\n\t{\n\t\tconst char *scheme = NULL;\n\t\tswitch (call->conn->referral_scheme) {\n\t\tcase LDAP_REFERRAL_SCHEME_LDAPS:\n\t\t\tscheme = \"ldaps\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscheme = \"ldap\";\n\t\t}\n\t\tldb_ret = ldb_set_opaque(\n\t\t\tsamdb,\n\t\t\tLDAP_REFERRAL_SCHEME_OPAQUE,\n\t\t\tdiscard_const_p(char *, scheme));\n\t\tif (ldb_ret != LDB_SUCCESS) {\n\t\t\tgoto reply;\n\t\t}\n\t}\n\n\t{\n\t\ttime_t timeout = call->conn->limits.search_timeout;\n\n\t\tif (timeout == 0\n\t\t    || (req->timelimit != 0\n\t\t\t&& req->timelimit < timeout))\n\t\t{\n\t\t\ttimeout = req->timelimit;\n\t\t}\n\t\tldb_set_timeout(samdb, lreq, timeout);\n\t}\n\n\tif (!call->conn->is_privileged) {\n\t\tldb_req_mark_untrusted(lreq);\n\t}\n\n\tLDB_REQ_SET_LOCATION(lreq);\n\n\tldb_ret = ldb_request(samdb, lreq);\n\n\tif (ldb_ret != LDB_SUCCESS) {\n\t\tgoto reply;\n\t}\n\n\tldb_ret = ldb_wait(lreq->handle, LDB_WAIT_ALL);\n\n\tif (ldb_ret == LDB_SUCCESS) {\n\t\tif (call->notification.busy) {\n\t\t\t/* Move/Add it to the end */\n\t\t\tDLIST_DEMOTE(call->conn->pending_calls, call);\n\t\t\tcall->notification.generation =\n\t\t\t\tcall->conn->service->notification.generation;\n\n\t\t\tif (callback_ctx->count != 0) {\n\t\t\t\tcall->notification.generation += 1;\n\t\t\t\tldapsrv_notification_retry_setup(call->conn->service,\n\t\t\t\t\t\t\t\t true);\n\t\t\t}\n\n\t\t\ttalloc_free(local_ctx);\n\t\t\treturn NT_STATUS_OK;\n\t\t}\n\t}\n\nreply:\n\tDLIST_REMOVE(call->conn->pending_calls, call);\n\tcall->notification.busy = false;\n\n\tdone_r = ldapsrv_init_reply(call, LDAP_TAG_SearchResultDone);\n\tNT_STATUS_HAVE_NO_MEMORY(done_r);\n\n\tdone = &done_r->msg->r.SearchResultDone;\n\tdone->dn = NULL;\n\tdone->referral = NULL;\n\n\tif (result != -1) {\n\t} else if (ldb_ret == LDB_SUCCESS) {\n\t\tif (callback_ctx->controls) {\n\t\t\tdone_r->msg->controls = callback_ctx->controls;\n\t\t\ttalloc_steal(done_r->msg, callback_ctx->controls);\n\t\t}\n\t\tresult = LDB_SUCCESS;\n\t} else {\n\t\tDEBUG(10,(\"SearchRequest: error\\n\"));\n\t\tresult = map_ldb_error(local_ctx, ldb_ret, ldb_errstring(samdb),\n\t\t\t\t       &errstr);\n\t}\n\n\tdone->resultcode = result;\n\tdone->errormessage = (errstr?talloc_strdup(done_r, errstr):NULL);\n\n\ttalloc_free(local_ctx);\n\n\treturn ldapsrv_queue_reply_forced(call, done_r);\n}",
  "diff_func": "@@ -729,9 +729,6 @@ static NTSTATUS ldapsrv_SearchRequest(struct ldapsrv_call *call)\n \tunsigned int i;\n \tint extended_type = 1;\n \n-\tDEBUG(10, (\"SearchRequest\"));\n-\tDEBUGADD(10, (\" basedn: %s\", req->basedn));\n-\tDEBUGADD(10, (\" filter: %s\\n\", ldb_filter_from_tree(call, req->tree)));\n \n \tlocal_ctx = talloc_new(call);\n \tNT_STATUS_HAVE_NO_MEMORY(local_ctx);",
  "func": "static NTSTATUS ldapsrv_SearchRequest(struct ldapsrv_call *call)\n{\n\tstruct ldap_SearchRequest *req = &call->request->r.SearchRequest;\n\tstruct ldap_Result *done;\n\tstruct ldapsrv_reply *done_r;\n\tTALLOC_CTX *local_ctx;\n\tstruct ldapsrv_context *callback_ctx = NULL;\n\tstruct ldb_context *samdb = talloc_get_type(call->conn->ldb, struct ldb_context);\n\tstruct ldb_dn *basedn;\n\tstruct ldb_request *lreq;\n\tstruct ldb_control *search_control;\n\tstruct ldb_search_options_control *search_options;\n\tstruct ldb_control *extended_dn_control;\n\tstruct ldb_extended_dn_control *extended_dn_decoded = NULL;\n\tstruct ldb_control *notification_control = NULL;\n\tenum ldb_scope scope = LDB_SCOPE_DEFAULT;\n\tconst char **attrs = NULL;\n\tconst char *scope_str, *errstr = NULL;\n\tint result = -1;\n\tint ldb_ret = -1;\n\tunsigned int i;\n\tint extended_type = 1;\n\n\tDEBUG(10, (\"SearchRequest\"));\n\tDEBUGADD(10, (\" basedn: %s\", req->basedn));\n\tDEBUGADD(10, (\" filter: %s\\n\", ldb_filter_from_tree(call, req->tree)));\n\n\tlocal_ctx = talloc_new(call);\n\tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n\n\tbasedn = ldb_dn_new(local_ctx, samdb, req->basedn);\n\tNT_STATUS_HAVE_NO_MEMORY(basedn);\n\n\tDEBUG(10, (\"SearchRequest: basedn: [%s]\\n\", req->basedn));\n\tDEBUG(10, (\"SearchRequest: filter: [%s]\\n\", ldb_filter_from_tree(call, req->tree)));\n\n\tswitch (req->scope) {\n\t\tcase LDAP_SEARCH_SCOPE_BASE:\n\t\t\tscope_str = \"BASE\";\n\t\t\tscope = LDB_SCOPE_BASE;\n\t\t\tbreak;\n\t\tcase LDAP_SEARCH_SCOPE_SINGLE:\n\t\t\tscope_str = \"ONE\";\n\t\t\tscope = LDB_SCOPE_ONELEVEL;\n\t\t\tbreak;\n\t\tcase LDAP_SEARCH_SCOPE_SUB:\n\t\t\tscope_str = \"SUB\";\n\t\t\tscope = LDB_SCOPE_SUBTREE;\n\t\t\tbreak;\n\t        default:\n\t\t\tresult = LDAP_PROTOCOL_ERROR;\n\t\t\tmap_ldb_error(local_ctx, LDB_ERR_PROTOCOL_ERROR, NULL,\n\t\t\t\t&errstr);\n\t\t\terrstr = talloc_asprintf(local_ctx,\n\t\t\t\t\"%s. Invalid scope\", errstr);\n\t\t\tgoto reply;\n\t}\n\tDEBUG(10,(\"SearchRequest: scope: [%s]\\n\", scope_str));\n\n\tif (req->num_attributes >= 1) {\n\t\tattrs = talloc_array(local_ctx, const char *, req->num_attributes+1);\n\t\tNT_STATUS_HAVE_NO_MEMORY(attrs);\n\n\t\tfor (i=0; i < req->num_attributes; i++) {\n\t\t\tDEBUG(10,(\"SearchRequest: attrs: [%s]\\n\",req->attributes[i]));\n\t\t\tattrs[i] = req->attributes[i];\n\t\t}\n\t\tattrs[i] = NULL;\n\t}\n\n\tDEBUG(5,(\"ldb_request %s dn=%s filter=%s\\n\", \n\t\t scope_str, req->basedn, ldb_filter_from_tree(call, req->tree)));\n\n\tcallback_ctx = talloc_zero(local_ctx, struct ldapsrv_context);\n\tNT_STATUS_HAVE_NO_MEMORY(callback_ctx);\n\tcallback_ctx->call = call;\n\tcallback_ctx->extended_type = extended_type;\n\tcallback_ctx->attributesonly = req->attributesonly;\n\n\tldb_ret = ldb_build_search_req_ex(&lreq, samdb, local_ctx,\n\t\t\t\t\t  basedn, scope,\n\t\t\t\t\t  req->tree, attrs,\n\t\t\t\t\t  call->request->controls,\n\t\t\t\t\t  callback_ctx,\n\t\t\t\t\t  ldap_server_search_callback,\n\t\t\t\t\t  NULL);\n\n\tif (ldb_ret != LDB_SUCCESS) {\n\t\tgoto reply;\n\t}\n\n\tif (call->conn->global_catalog) {\n\t\tsearch_control = ldb_request_get_control(lreq, LDB_CONTROL_SEARCH_OPTIONS_OID);\n\n\t\tsearch_options = NULL;\n\t\tif (search_control) {\n\t\t\tsearch_options = talloc_get_type(search_control->data, struct ldb_search_options_control);\n\t\t\tsearch_options->search_options |= LDB_SEARCH_OPTION_PHANTOM_ROOT;\n\t\t} else {\n\t\t\tsearch_options = talloc(lreq, struct ldb_search_options_control);\n\t\t\tNT_STATUS_HAVE_NO_MEMORY(search_options);\n\t\t\tsearch_options->search_options = LDB_SEARCH_OPTION_PHANTOM_ROOT;\n\t\t\tldb_request_add_control(lreq, LDB_CONTROL_SEARCH_OPTIONS_OID, false, search_options);\n\t\t}\n\t} else {\n\t\tldb_request_add_control(lreq, DSDB_CONTROL_NO_GLOBAL_CATALOG, false, NULL);\n\t}\n\n\textended_dn_control = ldb_request_get_control(lreq, LDB_CONTROL_EXTENDED_DN_OID);\n\n\tif (extended_dn_control) {\n\t\tif (extended_dn_control->data) {\n\t\t\textended_dn_decoded = talloc_get_type(extended_dn_control->data, struct ldb_extended_dn_control);\n\t\t\textended_type = extended_dn_decoded->type;\n\t\t} else {\n\t\t\textended_type = 0;\n\t\t}\n\t\tcallback_ctx->extended_type = extended_type;\n\t}\n\n\tnotification_control = ldb_request_get_control(lreq, LDB_CONTROL_NOTIFICATION_OID);\n\tif (notification_control != NULL) {\n\t\tconst struct ldapsrv_call *pc = NULL;\n\t\tsize_t count = 0;\n\n\t\tfor (pc = call->conn->pending_calls; pc != NULL; pc = pc->next) {\n\t\t\tcount += 1;\n\t\t}\n\n\t\tif (count >= call->conn->limits.max_notifications) {\n\t\t\tDEBUG(10,(\"SearchRequest: error MaxNotificationPerConn\\n\"));\n\t\t\tresult = map_ldb_error(local_ctx,\n\t\t\t\t\t       LDB_ERR_ADMIN_LIMIT_EXCEEDED,\n\t\t\t\t\t       \"MaxNotificationPerConn reached\",\n\t\t\t\t\t       &errstr);\n\t\t\tgoto reply;\n\t\t}\n\n\t\t/*\n\t\t * For now we need to do periodic retries on our own.\n\t\t * As the dsdb_notification module will return after each run.\n\t\t */\n\t\tcall->notification.busy = true;\n\t}\n\n\t{\n\t\tconst char *scheme = NULL;\n\t\tswitch (call->conn->referral_scheme) {\n\t\tcase LDAP_REFERRAL_SCHEME_LDAPS:\n\t\t\tscheme = \"ldaps\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscheme = \"ldap\";\n\t\t}\n\t\tldb_ret = ldb_set_opaque(\n\t\t\tsamdb,\n\t\t\tLDAP_REFERRAL_SCHEME_OPAQUE,\n\t\t\tdiscard_const_p(char *, scheme));\n\t\tif (ldb_ret != LDB_SUCCESS) {\n\t\t\tgoto reply;\n\t\t}\n\t}\n\n\t{\n\t\ttime_t timeout = call->conn->limits.search_timeout;\n\n\t\tif (timeout == 0\n\t\t    || (req->timelimit != 0\n\t\t\t&& req->timelimit < timeout))\n\t\t{\n\t\t\ttimeout = req->timelimit;\n\t\t}\n\t\tldb_set_timeout(samdb, lreq, timeout);\n\t}\n\n\tif (!call->conn->is_privileged) {\n\t\tldb_req_mark_untrusted(lreq);\n\t}\n\n\tLDB_REQ_SET_LOCATION(lreq);\n\n\tldb_ret = ldb_request(samdb, lreq);\n\n\tif (ldb_ret != LDB_SUCCESS) {\n\t\tgoto reply;\n\t}\n\n\tldb_ret = ldb_wait(lreq->handle, LDB_WAIT_ALL);\n\n\tif (ldb_ret == LDB_SUCCESS) {\n\t\tif (call->notification.busy) {\n\t\t\t/* Move/Add it to the end */\n\t\t\tDLIST_DEMOTE(call->conn->pending_calls, call);\n\t\t\tcall->notification.generation =\n\t\t\t\tcall->conn->service->notification.generation;\n\n\t\t\tif (callback_ctx->count != 0) {\n\t\t\t\tcall->notification.generation += 1;\n\t\t\t\tldapsrv_notification_retry_setup(call->conn->service,\n\t\t\t\t\t\t\t\t true);\n\t\t\t}\n\n\t\t\ttalloc_free(local_ctx);\n\t\t\treturn NT_STATUS_OK;\n\t\t}\n\t}\n\nreply:\n\tDLIST_REMOVE(call->conn->pending_calls, call);\n\tcall->notification.busy = false;\n\n\tdone_r = ldapsrv_init_reply(call, LDAP_TAG_SearchResultDone);\n\tNT_STATUS_HAVE_NO_MEMORY(done_r);\n\n\tdone = &done_r->msg->r.SearchResultDone;\n\tdone->dn = NULL;\n\tdone->referral = NULL;\n\n\tif (result != -1) {\n\t} else if (ldb_ret == LDB_SUCCESS) {\n\t\tif (callback_ctx->controls) {\n\t\t\tdone_r->msg->controls = callback_ctx->controls;\n\t\t\ttalloc_steal(done_r->msg, callback_ctx->controls);\n\t\t}\n\t\tresult = LDB_SUCCESS;\n\t} else {\n\t\tDEBUG(10,(\"SearchRequest: error\\n\"));\n\t\tresult = map_ldb_error(local_ctx, ldb_ret, ldb_errstring(samdb),\n\t\t\t\t       &errstr);\n\t}\n\n\tdone->resultcode = result;\n\tdone->errormessage = (errstr?talloc_strdup(done_r, errstr):NULL);\n\n\ttalloc_free(local_ctx);\n\n\treturn ldapsrv_queue_reply_forced(call, done_r);\n}",
  "project": "samba",
  "hash": 314918662591421001470003516678988238334,
  "size": 238,
  "commit_id": "d92dfb0dabf9cfccb86f2b1146d6c353af2e1435",
  "message": "CVE-2021-3670 ldap_server: Remove duplicate print of LDAP search details\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=14694\n\nSigned-off-by: Andrew Bartlett <abartlet@samba.org>\nReviewed-by: Douglas Bagnall <douglas.bagnall@catalyst.net.nz>\n(cherry picked from commit 2b3af3b560c9617a233c131376c870fce146c002)",
  "target": 1,
  "dataset": "other",
  "idx": 197830
}