{
  "id": 1059,
  "language": "c",
  "cwe": "CWE-787",
  "commit_url": "https://github.com/Parrot-Developers/ffmpeg/commit/e477f09d0b3619f3d29173b2cd593e17e2d1978e",
  "commit_sha": "e477f09d0b3619f3d29173b2cd593e17e2d1978e",
  "commit_msg": "avcodec/pngdec: Check trns more completely\n\nFixes out of array access\nFixes: 546/clusterfuzz-testcase-4809433909559296\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "libavcodec/pngdec.c",
  "func_name": "",
  "raw_func_from_json": "static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n                               AVFrame *p, AVPacket *avpkt)\n{\n    AVDictionary *metadata  = NULL;\n    uint32_t tag, length;\n    int decode_next_dat = 0;\n    int ret;\n\n    for (;;) {\n        length = bytestream2_get_bytes_left(&s->gb);\n        if (length <= 0) {\n\n            if (avctx->codec_id == AV_CODEC_ID_PNG &&\n                avctx->skip_frame == AVDISCARD_ALL) {\n                av_frame_set_metadata(p, metadata);\n                return 0;\n            }\n\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {\n                if (!(s->state & PNG_IDAT))\n                    return 0;\n                else\n                    goto exit_loop;\n            }\n            av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", length);\n            if (   s->state & PNG_ALLIMAGE\n                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n                goto exit_loop;\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        length = bytestream2_get_be32(&s->gb);\n        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {\n            av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        tag = bytestream2_get_le32(&s->gb);\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",\n                (tag & 0xff),\n                ((tag >> 8) & 0xff),\n                ((tag >> 16) & 0xff),\n                ((tag >> 24) & 0xff), length);\n\n        if (avctx->codec_id == AV_CODEC_ID_PNG &&\n            avctx->skip_frame == AVDISCARD_ALL) {\n            switch(tag) {\n            case MKTAG('I', 'H', 'D', 'R'):\n            case MKTAG('p', 'H', 'Y', 's'):\n            case MKTAG('t', 'E', 'X', 't'):\n            case MKTAG('I', 'D', 'A', 'T'):\n            case MKTAG('t', 'R', 'N', 'S'):\n                break;\n            default:\n                goto skip_tag;\n            }\n        }\n\n        switch (tag) {\n        case MKTAG('I', 'H', 'D', 'R'):\n            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n                goto fail;\n            break;\n        case MKTAG('p', 'H', 'Y', 's'):\n            if ((ret = decode_phys_chunk(avctx, s)) < 0)\n                goto fail;\n            break;\n        case MKTAG('f', 'c', 'T', 'L'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n                goto fail;\n            decode_next_dat = 1;\n            break;\n        case MKTAG('f', 'd', 'A', 'T'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if (!decode_next_dat) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_get_be32(&s->gb);\n            length -= 4;\n            /* fallthrough */\n        case MKTAG('I', 'D', 'A', 'T'):\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)\n                goto skip_tag;\n            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n                goto fail;\n            break;\n        case MKTAG('P', 'L', 'T', 'E'):\n            if (decode_plte_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'R', 'N', 'S'):\n            if (decode_trns_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'E', 'X', 't'):\n            if (decode_text_chunk(s, length, 0, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('z', 'T', 'X', 't'):\n            if (decode_text_chunk(s, length, 1, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('s', 'T', 'E', 'R'): {\n            int mode = bytestream2_get_byte(&s->gb);\n            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);\n            if (!stereo3d)\n                goto fail;\n\n            if (mode == 0 || mode == 1) {\n                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;\n                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;\n            } else {\n                 av_log(avctx, AV_LOG_WARNING,\n                        \"Unknown value in sTER chunk (%d)\\n\", mode);\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        }\n        case MKTAG('I', 'E', 'N', 'D'):\n            if (!(s->state & PNG_ALLIMAGE))\n                av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");\n            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            goto exit_loop;\n        default:\n            /* skip tag */\nskip_tag:\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        }\n    }\nexit_loop:\n    if (avctx->codec_id == AV_CODEC_ID_PNG &&\n        avctx->skip_frame == AVDISCARD_ALL) {\n        av_frame_set_metadata(p, metadata);\n        return 0;\n    }\n\n    if (s->bits_per_pixel <= 4)\n        handle_small_bpp(s, p);\n\n    /* apply transparency if needed */\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n         size_t raw_bpp = s->bpp - byte_depth;\n         unsigned x, y;\n \n         for (y = 0; y < s->height; ++y) {\n             uint8_t *row = &s->image_buf[s->image_linesize * y];\n \n            /* since we're updating in-place, we have to go from right to left */\n            for (x = s->width; x > 0; --x) {\n                uint8_t *pixel = &row[s->bpp * (x - 1)];\n                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n\n                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n                    memset(&pixel[raw_bpp], 0, byte_depth);\n                } else {\n                    memset(&pixel[raw_bpp], 0xff, byte_depth);\n                }\n            }\n        }\n    }\n\n    /* handle P-frames only if a predecessor frame is available */\n    if (s->last_picture.f->data[0]) {\n        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")\n            && s->last_picture.f->width == p->width\n            && s->last_picture.f->height== p->height\n            && s->last_picture.f->format== p->format\n         ) {\n            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)\n                handle_p_frame_png(s, p);\n            else if (CONFIG_APNG_DECODER &&\n                     avctx->codec_id == AV_CODEC_ID_APNG &&\n                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)\n                goto fail;\n        }\n    }\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n\n    av_frame_set_metadata(p, metadata);\n    metadata   = NULL;\n    return 0;\n\nfail:\n    av_dict_free(&metadata);\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n    return ret;\n}\n",
  "diff_func": "@@ -772,6 +772,16 @@ static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n {\n     int v, i;\n \n+    if (!(s->state & PNG_IHDR)) {\n+        av_log(avctx, AV_LOG_ERROR, \"trns before IHDR\\n\");\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n+    if (s->state & PNG_IDAT) {\n+        av_log(avctx, AV_LOG_ERROR, \"trns after IDAT\\n\");\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n     if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n         if (length > 256 || !(s->state & PNG_PLTE))\n             return AVERROR_INVALIDDATA;\n@@ -782,7 +792,8 @@ static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n         }\n     } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n         if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n-            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n+            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||\n+            s->bit_depth == 1)\n             return AVERROR_INVALIDDATA;\n \n         for (i = 0; i < length / 2; i++) {\n@@ -1242,6 +1253,8 @@ static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n         size_t raw_bpp = s->bpp - byte_depth;\n         unsigned x, y;\n \n+        av_assert0(s->bit_depth > 1);\n+\n         for (y = 0; y < s->height; ++y) {\n             uint8_t *row = &s->image_buf[s->image_linesize * y];\n ",
  "project": "FFmpeg",
  "commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e",
  "target": 1,
  "func": "static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n                               AVFrame *p, AVPacket *avpkt)\n{\n    AVDictionary *metadata  = NULL;\n    uint32_t tag, length;\n    int decode_next_dat = 0;\n    int ret;\n\n    for (;;) {\n        length = bytestream2_get_bytes_left(&s->gb);\n        if (length <= 0) {\n\n            if (avctx->codec_id == AV_CODEC_ID_PNG &&\n                avctx->skip_frame == AVDISCARD_ALL) {\n                av_frame_set_metadata(p, metadata);\n                return 0;\n            }\n\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {\n                if (!(s->state & PNG_IDAT))\n                    return 0;\n                else\n                    goto exit_loop;\n            }\n            av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", length);\n            if (   s->state & PNG_ALLIMAGE\n                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n                goto exit_loop;\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        length = bytestream2_get_be32(&s->gb);\n        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {\n            av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        tag = bytestream2_get_le32(&s->gb);\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",\n                (tag & 0xff),\n                ((tag >> 8) & 0xff),\n                ((tag >> 16) & 0xff),\n                ((tag >> 24) & 0xff), length);\n\n        if (avctx->codec_id == AV_CODEC_ID_PNG &&\n            avctx->skip_frame == AVDISCARD_ALL) {\n            switch(tag) {\n            case MKTAG('I', 'H', 'D', 'R'):\n            case MKTAG('p', 'H', 'Y', 's'):\n            case MKTAG('t', 'E', 'X', 't'):\n            case MKTAG('I', 'D', 'A', 'T'):\n            case MKTAG('t', 'R', 'N', 'S'):\n                break;\n            default:\n                goto skip_tag;\n            }\n        }\n\n        switch (tag) {\n        case MKTAG('I', 'H', 'D', 'R'):\n            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n                goto fail;\n            break;\n        case MKTAG('p', 'H', 'Y', 's'):\n            if ((ret = decode_phys_chunk(avctx, s)) < 0)\n                goto fail;\n            break;\n        case MKTAG('f', 'c', 'T', 'L'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n                goto fail;\n            decode_next_dat = 1;\n            break;\n        case MKTAG('f', 'd', 'A', 'T'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if (!decode_next_dat) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_get_be32(&s->gb);\n            length -= 4;\n            /* fallthrough */\n        case MKTAG('I', 'D', 'A', 'T'):\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)\n                goto skip_tag;\n            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n                goto fail;\n            break;\n        case MKTAG('P', 'L', 'T', 'E'):\n            if (decode_plte_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'R', 'N', 'S'):\n            if (decode_trns_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'E', 'X', 't'):\n            if (decode_text_chunk(s, length, 0, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('z', 'T', 'X', 't'):\n            if (decode_text_chunk(s, length, 1, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('s', 'T', 'E', 'R'): {\n            int mode = bytestream2_get_byte(&s->gb);\n            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);\n            if (!stereo3d)\n                goto fail;\n\n            if (mode == 0 || mode == 1) {\n                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;\n                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;\n            } else {\n                 av_log(avctx, AV_LOG_WARNING,\n                        \"Unknown value in sTER chunk (%d)\\n\", mode);\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        }\n        case MKTAG('I', 'E', 'N', 'D'):\n            if (!(s->state & PNG_ALLIMAGE))\n                av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");\n            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            goto exit_loop;\n        default:\n            /* skip tag */\nskip_tag:\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        }\n    }\nexit_loop:\n    if (avctx->codec_id == AV_CODEC_ID_PNG &&\n        avctx->skip_frame == AVDISCARD_ALL) {\n        av_frame_set_metadata(p, metadata);\n        return 0;\n    }\n\n    if (s->bits_per_pixel <= 4)\n        handle_small_bpp(s, p);\n\n    /* apply transparency if needed */\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n         size_t raw_bpp = s->bpp - byte_depth;\n         unsigned x, y;\n \n         for (y = 0; y < s->height; ++y) {\n             uint8_t *row = &s->image_buf[s->image_linesize * y];\n \n            /* since we're updating in-place, we have to go from right to left */\n            for (x = s->width; x > 0; --x) {\n                uint8_t *pixel = &row[s->bpp * (x - 1)];\n                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n\n                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n                    memset(&pixel[raw_bpp], 0, byte_depth);\n                } else {\n                    memset(&pixel[raw_bpp], 0xff, byte_depth);\n                }\n            }\n        }\n    }\n\n    /* handle P-frames only if a predecessor frame is available */\n    if (s->last_picture.f->data[0]) {\n        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")\n            && s->last_picture.f->width == p->width\n            && s->last_picture.f->height== p->height\n            && s->last_picture.f->format== p->format\n         ) {\n            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)\n                handle_p_frame_png(s, p);\n            else if (CONFIG_APNG_DECODER &&\n                     avctx->codec_id == AV_CODEC_ID_APNG &&\n                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)\n                goto fail;\n        }\n    }\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n\n    av_frame_set_metadata(p, metadata);\n    metadata   = NULL;\n    return 0;\n\nfail:\n    av_dict_free(&metadata);\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n    return ret;\n}\n",
  "big_vul_idx": 181419,
  "idx": 2892,
  "hash": 274328107409287348726239037840812935721
}