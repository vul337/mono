{
  "id": 1031,
  "language": "c",
  "cwe": "CWE-772",
  "commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/7b8c1df65b25d6671f113e2306982eded44ce3b4",
  "commit_sha": "7b8c1df65b25d6671f113e2306982eded44ce3b4",
  "commit_msg": "Fixed memory leak reported in #456.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "coders/art.c",
  "func_name": "",
  "raw_func_from_json": "static Image *ReadARTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=1;\n  image->endian=MSBEndian;\n  (void) ReadBlobLSBShort(image);\n  image->columns=(size_t) ReadBlobLSBShort(image);\n  (void) ReadBlobLSBShort(image);\n  image->rows=(size_t) ReadBlobLSBShort(image);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image colormap.\n  */\n  if (AcquireImageColormap(image,2) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  /*\n    Convert bi-level image to pixel packets.\n  */\n  SetImageColorspace(image,GRAYColorspace);\n  quantum_type=IndexQuantum;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  length=GetQuantumExtent(image,quantum_info,quantum_type);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n     pixels=(const unsigned char *) ReadBlobStream(image,length,\n       GetQuantumPixels(quantum_info),&count);\n     if (count != (ssize_t) length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n       quantum_type,pixels,exception);\n     (void) ReadBlobStream(image,(size_t) (-(ssize_t) length) & 0x01,\n      GetQuantumPixels(quantum_info),&count);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
  "diff_func": "@@ -181,7 +181,10 @@ static Image *ReadARTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     pixels=(const unsigned char *) ReadBlobStream(image,length,\n       GetQuantumPixels(quantum_info),&count);\n     if (count != (ssize_t) length)\n-      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+      {\n+        quantum_info=DestroyQuantumInfo(quantum_info);\n+        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+      }\n     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n       quantum_type,pixels,exception);\n     (void) ReadBlobStream(image,(size_t) (-(ssize_t) length) & 0x01,",
  "project": "ImageMagick",
  "commit_id": "7b8c1df65b25d6671f113e2306982eded44ce3b4",
  "target": 1,
  "func": "static Image *ReadARTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=1;\n  image->endian=MSBEndian;\n  (void) ReadBlobLSBShort(image);\n  image->columns=(size_t) ReadBlobLSBShort(image);\n  (void) ReadBlobLSBShort(image);\n  image->rows=(size_t) ReadBlobLSBShort(image);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image colormap.\n  */\n  if (AcquireImageColormap(image,2) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  /*\n    Convert bi-level image to pixel packets.\n  */\n  SetImageColorspace(image,GRAYColorspace);\n  quantum_type=IndexQuantum;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  length=GetQuantumExtent(image,quantum_info,quantum_type);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n     pixels=(const unsigned char *) ReadBlobStream(image,length,\n       GetQuantumPixels(quantum_info),&count);\n     if (count != (ssize_t) length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n       quantum_type,pixels,exception);\n     (void) ReadBlobStream(image,(size_t) (-(ssize_t) length) & 0x01,\n      GetQuantumPixels(quantum_info),&count);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
  "big_vul_idx": 181295,
  "idx": 2781,
  "hash": 223781554613943006697410369759811795698
}