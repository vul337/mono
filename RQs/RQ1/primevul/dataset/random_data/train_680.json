{
  "id": 680,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/welloo6/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a",
  "commit_sha": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a",
  "commit_msg": "Merge pull request #20 from eyalitki/master\n\n2nd round security fixes from eyalitki",
  "pr_url": null,
  "pr_info": null,
  "file_name": "mactelnet.c",
  "func_name": "",
  "raw_func_from_json": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n \n \t\t\t/* If we receive pass_salt, transmit auth data back */\n \t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n \t\t\t\tsend_auth(username, password);\n \t\t\t}\n \n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}\n",
  "diff_func": "@@ -96,7 +96,7 @@ static char autologin_path[255];\n \n static int keepalive_counter = 0;\n \n-static unsigned char pass_salt[17];\n+static unsigned char pass_salt[16];\n static char username[MT_MNDP_MAX_STRING_SIZE];\n static char password[MT_MNDP_MAX_STRING_SIZE];\n static char nonpriv_username[MT_MNDP_MAX_STRING_SIZE];\n@@ -212,23 +212,26 @@ static void send_auth(char *username, char *password) {\n \tchar *terminal = getenv(\"TERM\");\n \tchar md5data[100];\n \tunsigned char md5sum[17];\n-\tint plen;\n+\tint plen, act_pass_len;\n \tmd5_state_t state;\n \n #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)\n \tmlock(md5data, sizeof(md5data));\n \tmlock(md5sum, sizeof(md5data));\n #endif\n \n+\t/* calculate the actual password's length */\n+\tact_pass_len = strnlen(password, 82);\n+\n \t/* Concat string of 0 + password + pass_salt */\n \tmd5data[0] = 0;\n-\tstrncpy(md5data + 1, password, 82);\n-\tmd5data[83] = '\\0';\n-\tmemcpy(md5data + 1 + strlen(password), pass_salt, 16);\n+\tmemcpy(md5data + 1, password, act_pass_len);\n+\t/* in case that password is long, calculate only using the used-up parts */\n+\tmemcpy(md5data + 1 + act_pass_len, pass_salt, 16);\n \n \t/* Generate md5 sum of md5data with a leading 0 */\n \tmd5_init(&state);\n-\tmd5_append(&state, (const md5_byte_t *)md5data, strlen(password) + 17);\n+\tmd5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);\n \tmd5_finish(&state, (md5_byte_t *)md5sum + 1);\n \tmd5sum[0] = 0;\n \n@@ -312,7 +315,11 @@ static int handle_packet(unsigned char *data, int data_len) {\n \n \t\t\t/* If we receive pass_salt, transmit auth data back */\n \t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n-\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n+\t\t\t\t/* check validity, server sends exactly 16 bytes */\n+\t\t\t\tif (cpkt.length != 16) {\n+\t\t\t\t\tfprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));\n+\t\t\t\t}\n+\t\t\t\tmemcpy(pass_salt, cpkt.data, 16);\n \t\t\t\tsend_auth(username, password);\n \t\t\t}\n ",
  "project": "MAC-Telnet",
  "commit_id": "b69d11727d4f0f8cf719c79e3fb700f55ca03e9a",
  "target": 1,
  "func": "static int handle_packet(unsigned char *data, int data_len) {\n\tstruct mt_mactelnet_hdr pkthdr;\n\n\t/* Minimal size checks (pings are not supported here) */\n\tif (data_len < MT_HEADER_LEN){\n\t\treturn -1;\n\t}\n\tparse_packet(data, &pkthdr);\n\n\t/* We only care about packets with correct sessionkey */\n\tif (pkthdr.seskey != sessionkey) {\n\t\treturn -1;\n\t}\n\n\t/* Handle data packets */\n\tif (pkthdr.ptype == MT_PTYPE_DATA) {\n\t\tstruct mt_packet odata;\n\t\tstruct mt_mactelnet_control_hdr cpkt;\n\t\tint success = 0;\n\n\t\t/* Always transmit ACKNOWLEDGE packets in response to DATA packets */\n\t\tinit_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));\n\t\tsend_udp(&odata, 0);\n\n\t\t/* Accept first packet, and all packets greater than incounter, and if counter has\n\t\twrapped around. */\n\t\tif (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {\n\t\t\tincounter = pkthdr.counter;\n\t\t} else {\n\t\t\t/* Ignore double or old packets */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse controlpacket data */\n\t\tsuccess = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);\n\n\t\twhile (success) {\n \n \t\t\t/* If we receive pass_salt, transmit auth data back */\n \t\t\tif (cpkt.cptype == MT_CPTYPE_PASSSALT) {\n\t\t\t\tmemcpy(pass_salt, cpkt.data, cpkt.length);\n \t\t\t\tsend_auth(username, password);\n \t\t\t}\n \n\t\t\t/* If the (remaining) data did not have a control-packet magic byte sequence,\n\t\t\t   the data is raw terminal data to be outputted to the terminal. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {\n\t\t\t\tfwrite((const void *)cpkt.data, 1, cpkt.length, stdout);\n\t\t\t}\n\n\t\t\t/* END_AUTH means that the user/password negotiation is done, and after this point\n\t\t\t   terminal data may arrive, so we set up the terminal to raw mode. */\n\t\t\telse if (cpkt.cptype == MT_CPTYPE_END_AUTH) {\n\n\t\t\t\t/* we have entered \"terminal mode\" */\n\t\t\t\tterminal_mode = 1;\n\n\t\t\t\tif (is_a_tty) {\n\t\t\t\t\t/* stop input buffering at all levels. Give full control of terminal to RouterOS */\n\t\t\t\t\traw_term();\n\n\t\t\t\t\tsetvbuf(stdin,  (char*)NULL, _IONBF, 0);\n\n\t\t\t\t\t/* Add resize signal handler */\n\t\t\t\t\tsignal(SIGWINCH, sig_winch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Parse next controlpacket */\n\t\t\tsuccess = parse_control_packet(NULL, 0, &cpkt);\n\t\t}\n\t}\n\telse if (pkthdr.ptype == MT_PTYPE_ACK) {\n\t\t/* Handled elsewhere */\n\t}\n\n\t/* The server wants to terminate the connection, we have to oblige */\n\telse if (pkthdr.ptype == MT_PTYPE_END) {\n\t\tstruct mt_packet odata;\n\n\t\t/* Acknowledge the disconnection by sending a END packet in return */\n\t\tinit_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);\n\t\tsend_udp(&odata, 0);\n\n\t\tif (!quiet_mode) {\n\t\t\tfprintf(stderr, _(\"Connection closed.\\n\"));\n\t\t}\n\n\t\t/* exit */\n\t\trunning = 0;\n\t} else {\n\t\tfprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));\n\t\treturn -1;\n\t}\n\n\treturn pkthdr.ptype;\n}\n",
  "big_vul_idx": 180134,
  "idx": 1759,
  "hash": 321429272328439869554766759603886266947
}