{
  "id": 719,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/2lambda123/vmware-open-vm-tools/commit/70a74758bfe0042c27f15ce590fb21a2bc54d745",
  "commit_sha": "70a74758bfe0042c27f15ce590fb21a2bc54d745",
  "commit_msg": "Properly check authorization on incoming guestOps requests.\n\nFix public pipe request checks.  Only a SessionRequest type should\nbe accepted on the public pipe.",
  "pr_url": null,
  "pr_info": null,
  "file_name": "open-vm-tools/vgauth/serviceImpl/proto.c",
  "func_name": "",
  "raw_func_from_json": "Proto_SecurityCheckRequest(ServiceConnection *conn,\n                           ProtoRequest *req)\n{\n   VGAuthError err;\n   gboolean isSecure = ServiceNetworkIsConnectionPrivateSuperUser(conn);\n\n   switch (req->reqType) {\n      /*\n       * This comes over the public connection; alwsys let it through.\n       */\n   case PROTO_REQUEST_SESSION_REQ:\n      err = VGAUTH_E_OK;\n      break;\n      /*\n       * No security issues with Connect or QueryMappedCerts\n       */\n   case PROTO_REQUEST_CONN:\n   case PROTO_REQUEST_QUERYMAPPEDALIASES:\n      err = VGAUTH_E_OK;\n      break;\n      /*\n       * These request can come over any user connection; always let\n       * them through if they are coming from root or the owner of\n       * the certstore being changed.\n       */\n   case PROTO_REQUEST_ADDALIAS:\n   case PROTO_REQUEST_REMOVEALIAS:\n   case PROTO_REQUEST_QUERYALIASES:\n   case PROTO_REQUEST_CREATETICKET:\n      if (isSecure) {\n         err = VGAUTH_E_OK;\n      } else {\n         const gchar *connOwner = conn->userName;\n         const gchar *reqUser = NULL;\n\n         if (req->reqType == PROTO_REQUEST_ADDALIAS) {\n            reqUser = req->reqData.addAlias.userName;\n         } else if (req->reqType == PROTO_REQUEST_REMOVEALIAS) {\n            reqUser = req->reqData.removeAlias.userName;\n         } else if (req->reqType == PROTO_REQUEST_QUERYALIASES) {\n            reqUser = req->reqData.queryAliases.userName;\n         } else if (req->reqType == PROTO_REQUEST_CREATETICKET) {\n            reqUser = req->reqData.createTicket.userName;\n         } else {\n            ASSERT(0);\n         }\n\n         if (Usercheck_CompareByName(connOwner, reqUser)) {\n            err = VGAUTH_E_OK;\n         } else {\n            Audit_Event(FALSE,\n                        SU_(proto.attack, \"Possible security attack!  Request type %d has a \"\n                        \"userName (%s) which doesn't match the pipe owner (%s)!\"),\n                        req->reqType, reqUser, connOwner);\n            Warning(\"%s: Possible security attack!  Request type %d has a \"\n                    \"userName (%s) which doesn't match the pipe owner (%s)!\\n\",\n                    __FUNCTION__, req->reqType, reqUser, connOwner);\n            err = VGAUTH_E_PERMISSION_DENIED;\n         }\n      }\n      break;\n      /*\n       * These requests must come through a super-user owned private\n       * connection.\n       */\n   case PROTO_REQUEST_VALIDATETICKET:\n      err = (isSecure) ? VGAUTH_E_OK : VGAUTH_E_PERMISSION_DENIED;\n      break;\n   case PROTO_REQUEST_VALIDATE_SAML_BEARER_TOKEN:\n      /*\n       * CAF wants to be able to validate as any user.\n       */\n      err = VGAUTH_E_OK;\n      break;\n   case PROTO_REQUEST_REVOKETICKET:\n      /*\n       * We want to allow just SUPERUSER and the ticket's owner to do the\n       * Revoke.  But returning VGAUTH_E_PERMISSION_DENIED is also a hint\n       * to an attacker that the ticket is valid.  So rather than\n       * blow it off, we just ignore security at this layer,\n       * and let the request fall through to ServiceRevokeTicket(),\n       * which will turn a security issue into a no-op.\n       */\n      err = VGAUTH_E_OK;\n      break;\n   default:\n      Warning(\"%s: Unrecognized request type '%d'\\n\",\n              __FUNCTION__, req->reqType);\n      err = VGAUTH_E_PERMISSION_DENIED;\n      break;\n   }\n\n   return err;\n}",
  "diff_func": "@@ -1,5 +1,5 @@\n /*********************************************************\n- * Copyright (C) 2011-2016,2019-2021 VMware, Inc. All rights reserved.\n+ * Copyright (C) 2011-2016,2019-2022 VMware, Inc. All rights reserved.\n  *\n  * This program is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -1201,6 +1201,10 @@ Proto_SecurityCheckRequest(ServiceConnection *conn,\n    VGAuthError err;\n    gboolean isSecure = ServiceNetworkIsConnectionPrivateSuperUser(conn);\n \n+   if (conn->isPublic && req->reqType != PROTO_REQUEST_SESSION_REQ) {\n+      return VGAUTH_E_PERMISSION_DENIED;\n+   }\n+\n    switch (req->reqType) {\n       /*\n        * This comes over the public connection; alwsys let it through.",
  "func": "Proto_SecurityCheckRequest(ServiceConnection *conn,\n                           ProtoRequest *req)\n{\n   VGAuthError err;\n   gboolean isSecure = ServiceNetworkIsConnectionPrivateSuperUser(conn);\n\n   switch (req->reqType) {\n      /*\n       * This comes over the public connection; alwsys let it through.\n       */\n   case PROTO_REQUEST_SESSION_REQ:\n      err = VGAUTH_E_OK;\n      break;\n      /*\n       * No security issues with Connect or QueryMappedCerts\n       */\n   case PROTO_REQUEST_CONN:\n   case PROTO_REQUEST_QUERYMAPPEDALIASES:\n      err = VGAUTH_E_OK;\n      break;\n      /*\n       * These request can come over any user connection; always let\n       * them through if they are coming from root or the owner of\n       * the certstore being changed.\n       */\n   case PROTO_REQUEST_ADDALIAS:\n   case PROTO_REQUEST_REMOVEALIAS:\n   case PROTO_REQUEST_QUERYALIASES:\n   case PROTO_REQUEST_CREATETICKET:\n      if (isSecure) {\n         err = VGAUTH_E_OK;\n      } else {\n         const gchar *connOwner = conn->userName;\n         const gchar *reqUser = NULL;\n\n         if (req->reqType == PROTO_REQUEST_ADDALIAS) {\n            reqUser = req->reqData.addAlias.userName;\n         } else if (req->reqType == PROTO_REQUEST_REMOVEALIAS) {\n            reqUser = req->reqData.removeAlias.userName;\n         } else if (req->reqType == PROTO_REQUEST_QUERYALIASES) {\n            reqUser = req->reqData.queryAliases.userName;\n         } else if (req->reqType == PROTO_REQUEST_CREATETICKET) {\n            reqUser = req->reqData.createTicket.userName;\n         } else {\n            ASSERT(0);\n         }\n\n         if (Usercheck_CompareByName(connOwner, reqUser)) {\n            err = VGAUTH_E_OK;\n         } else {\n            Audit_Event(FALSE,\n                        SU_(proto.attack, \"Possible security attack!  Request type %d has a \"\n                        \"userName (%s) which doesn't match the pipe owner (%s)!\"),\n                        req->reqType, reqUser, connOwner);\n            Warning(\"%s: Possible security attack!  Request type %d has a \"\n                    \"userName (%s) which doesn't match the pipe owner (%s)!\\n\",\n                    __FUNCTION__, req->reqType, reqUser, connOwner);\n            err = VGAUTH_E_PERMISSION_DENIED;\n         }\n      }\n      break;\n      /*\n       * These requests must come through a super-user owned private\n       * connection.\n       */\n   case PROTO_REQUEST_VALIDATETICKET:\n      err = (isSecure) ? VGAUTH_E_OK : VGAUTH_E_PERMISSION_DENIED;\n      break;\n   case PROTO_REQUEST_VALIDATE_SAML_BEARER_TOKEN:\n      /*\n       * CAF wants to be able to validate as any user.\n       */\n      err = VGAUTH_E_OK;\n      break;\n   case PROTO_REQUEST_REVOKETICKET:\n      /*\n       * We want to allow just SUPERUSER and the ticket's owner to do the\n       * Revoke.  But returning VGAUTH_E_PERMISSION_DENIED is also a hint\n       * to an attacker that the ticket is valid.  So rather than\n       * blow it off, we just ignore security at this layer,\n       * and let the request fall through to ServiceRevokeTicket(),\n       * which will turn a security issue into a no-op.\n       */\n      err = VGAUTH_E_OK;\n      break;\n   default:\n      Warning(\"%s: Unrecognized request type '%d'\\n\",\n              __FUNCTION__, req->reqType);\n      err = VGAUTH_E_PERMISSION_DENIED;\n      break;\n   }\n\n   return err;\n}",
  "project": "open-vm-tools",
  "hash": 197467841338532217297599212611526262605,
  "size": 94,
  "commit_id": "70a74758bfe0042c27f15ce590fb21a2bc54d745",
  "message": "Properly check authorization on incoming guestOps requests.\n\nFix public pipe request checks.  Only a SessionRequest type should\nbe accepted on the public pipe.",
  "target": 1,
  "dataset": "other",
  "idx": 197611
}