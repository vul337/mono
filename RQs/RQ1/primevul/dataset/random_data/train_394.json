{
  "id": 394,
  "language": "c",
  "cwe": "CWE-119",
  "commit_url": "https://github.com/curl/curl/commit/192c4f788d48f82c03e9cef40013f34370e90737",
  "commit_sha": "192c4f788d48f82c03e9cef40013f34370e90737",
  "commit_msg": "Curl_urldecode: no peeking beyond end of input buffer\n\nSecurity problem: CVE-2013-2174\n\nIf a program would give a string like \"%FF\" to curl_easy_unescape() but\nask for it to decode only the first byte, it would still parse and\ndecode the full hex sequence. The function then not only read beyond the\nallowed buffer but it would also deduct the *unsigned* counter variable\nfor how many more bytes there's left to read in the buffer by two,\nmaking the counter wrap. Continuing this, the function would go on\nreading beyond the buffer and soon writing beyond the allocated target\nbuffer...\n\nBug: http://curl.haxx.se/docs/adv_20130622.html\nReported-by: Timo Sirainen",
  "pr_url": null,
  "pr_info": null,
  "file_name": "lib/escape.c",
  "func_name": "",
  "raw_func_from_json": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       /* this is two hexadecimal digits following a '%' */\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n\n  if(ostring)\n    /* store output string */\n    *ostring = ns;\n\n  return CURLE_OK;\n}\n",
  "diff_func": "@@ -5,7 +5,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2013, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -159,7 +159,8 @@ CURLcode Curl_urldecode(struct SessionHandle *data,\n \n   while(--alloc > 0) {\n     in = *string;\n-    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n+    if(('%' == in) && (alloc > 2) &&\n+       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       /* this is two hexadecimal digits following a '%' */\n       char hexstr[3];\n       char *ptr;",
  "project": "curl",
  "commit_id": "192c4f788d48f82c03e9cef40013f34370e90737",
  "target": 1,
  "func": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n       /* this is two hexadecimal digits following a '%' */\n       char hexstr[3];\n       char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n\n  if(ostring)\n    /* store output string */\n    *ostring = ns;\n\n  return CURLE_OK;\n}\n",
  "big_vul_idx": 179252,
  "idx": 1040,
  "hash": 85709973777579247011240190240020563804
}