{
  "id": 763,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/ljalves/linux_media/commit/162f98dea487206d9ab79fc12ed64700667a894d",
  "commit_sha": "162f98dea487206d9ab79fc12ed64700667a894d",
  "commit_msg": "Input: gtco - fix crash on detecting device without endpoints\n\nThe gtco driver expects at least one valid endpoint. If given malicious\ndescriptors that specify 0 for the number of endpoints, it will crash in\nthe probe function. Ensure there is at least one endpoint on the interface\nbefore using it.\n\nAlso let's fix a minor coding style issue.\n\nThe full correct report of this issue can be found in the public\nRed Hat Bugzilla:\n\nhttps://bugzilla.redhat.com/show_bug.cgi?id=1283385\n\nReported-by: Ralf Spenneberg <ralf@spenneberg.net>\nSigned-off-by: Vladis Dronov <vdronov@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "drivers/input/tablet/gtco.c",
  "func_name": "",
  "raw_func_from_json": "static int gtco_probe(struct usb_interface *usbinterface,\n\t\t      const struct usb_device_id *id)\n{\n\n\tstruct gtco             *gtco;\n\tstruct input_dev        *input_dev;\n\tstruct hid_descriptor   *hid_desc;\n\tchar                    *report;\n\tint                     result = 0, retry;\n\tint\t\t\terror;\n\tstruct usb_endpoint_descriptor *endpoint;\n\n\t/* Allocate memory for device structure */\n\tgtco = kzalloc(sizeof(struct gtco), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!gtco || !input_dev) {\n\t\tdev_err(&usbinterface->dev, \"No more memory\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_devs;\n\t}\n\n\t/* Set pointer to the input device */\n\tgtco->inputdevice = input_dev;\n\n\t/* Save interface information */\n\tgtco->usbdev = interface_to_usbdev(usbinterface);\n\tgtco->intf = usbinterface;\n\n\t/* Allocate some data for incoming reports */\n\tgtco->buffer = usb_alloc_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t\t\t  GFP_KERNEL, &gtco->buf_dma);\n\tif (!gtco->buffer) {\n\t\tdev_err(&usbinterface->dev, \"No more memory for us buffers\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_devs;\n\t}\n\n\t/* Allocate URB for reports */\n\tgtco->urbinfo = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!gtco->urbinfo) {\n\t\tdev_err(&usbinterface->dev, \"Failed to allocate URB\\n\");\n\t\terror = -ENOMEM;\n \t\tgoto err_free_buf;\n \t}\n \n \t/*\n \t * The endpoint is always altsetting 0, we know this since we know\n \t * this device only has one interrupt endpoint\n\t */\n\tendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\n\n\t/* Some debug */\n\tdev_dbg(&usbinterface->dev, \"gtco # interfaces: %d\\n\", usbinterface->num_altsetting);\n\tdev_dbg(&usbinterface->dev, \"num endpoints:     %d\\n\", usbinterface->cur_altsetting->desc.bNumEndpoints);\n\tdev_dbg(&usbinterface->dev, \"interface class:   %d\\n\", usbinterface->cur_altsetting->desc.bInterfaceClass);\n\tdev_dbg(&usbinterface->dev, \"endpoint: attribute:0x%x type:0x%x\\n\", endpoint->bmAttributes, endpoint->bDescriptorType);\n\tif (usb_endpoint_xfer_int(endpoint))\n\t\tdev_dbg(&usbinterface->dev, \"endpoint: we have interrupt endpoint\\n\");\n\n\tdev_dbg(&usbinterface->dev, \"endpoint extra len:%d\\n\", usbinterface->altsetting[0].extralen);\n\n\t/*\n\t * Find the HID descriptor so we can find out the size of the\n \t * HID report descriptor\n \t */\n \tif (usb_get_extra_descriptor(usbinterface->cur_altsetting,\n\t\t\t\t     HID_DEVICE_TYPE, &hid_desc) != 0){\n \t\tdev_err(&usbinterface->dev,\n \t\t\t\"Can't retrieve exta USB descriptor to get hid report descriptor length\\n\");\n \t\terror = -EIO;\n\t\tgoto err_free_urb;\n\t}\n\n\tdev_dbg(&usbinterface->dev,\n\t\t\"Extra descriptor success: type:%d  len:%d\\n\",\n\t\thid_desc->bDescriptorType,  hid_desc->wDescriptorLength);\n\n\treport = kzalloc(le16_to_cpu(hid_desc->wDescriptorLength), GFP_KERNEL);\n\tif (!report) {\n\t\tdev_err(&usbinterface->dev, \"No more memory for report\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_urb;\n\t}\n\n\t/* Couple of tries to get reply */\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tresult = usb_control_msg(gtco->usbdev,\n\t\t\t\t\t usb_rcvctrlpipe(gtco->usbdev, 0),\n\t\t\t\t\t USB_REQ_GET_DESCRIPTOR,\n\t\t\t\t\t USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t\t REPORT_DEVICE_TYPE << 8,\n\t\t\t\t\t 0, /* interface */\n\t\t\t\t\t report,\n\t\t\t\t\t le16_to_cpu(hid_desc->wDescriptorLength),\n\t\t\t\t\t 5000); /* 5 secs */\n\n\t\tdev_dbg(&usbinterface->dev, \"usb_control_msg result: %d\\n\", result);\n\t\tif (result == le16_to_cpu(hid_desc->wDescriptorLength)) {\n\t\t\tparse_hid_report_descriptor(gtco, report, result);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(report);\n\n\t/* If we didn't get the report, fail */\n\tif (result != le16_to_cpu(hid_desc->wDescriptorLength)) {\n\t\tdev_err(&usbinterface->dev,\n\t\t\t\"Failed to get HID Report Descriptor of size: %d\\n\",\n\t\t\thid_desc->wDescriptorLength);\n\t\terror = -EIO;\n\t\tgoto err_free_urb;\n\t}\n\n\t/* Create a device file node */\n\tusb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));\n\tstrlcat(gtco->usbpath, \"/input0\", sizeof(gtco->usbpath));\n\n\t/* Set Input device functions */\n\tinput_dev->open = gtco_input_open;\n\tinput_dev->close = gtco_input_close;\n\n\t/* Set input device information */\n\tinput_dev->name = \"GTCO_CalComp\";\n\tinput_dev->phys = gtco->usbpath;\n\n\tinput_set_drvdata(input_dev, gtco);\n\n\t/* Now set up all the input device capabilities */\n\tgtco_setup_caps(input_dev);\n\n\t/* Set input device required ID information */\n\tusb_to_input_id(gtco->usbdev, &input_dev->id);\n\tinput_dev->dev.parent = &usbinterface->dev;\n\n\t/* Setup the URB, it will be posted later on open of input device */\n\tendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\n\n\tusb_fill_int_urb(gtco->urbinfo,\n\t\t\t gtco->usbdev,\n\t\t\t usb_rcvintpipe(gtco->usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t gtco->buffer,\n\t\t\t REPORT_MAX_SIZE,\n\t\t\t gtco_urb_callback,\n\t\t\t gtco,\n\t\t\t endpoint->bInterval);\n\n\tgtco->urbinfo->transfer_dma = gtco->buf_dma;\n\tgtco->urbinfo->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t/* Save gtco pointer in USB interface gtco */\n\tusb_set_intfdata(usbinterface, gtco);\n\n\t/* All done, now register the input device */\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\tgoto err_free_urb;\n\n\treturn 0;\n\n err_free_urb:\n\tusb_free_urb(gtco->urbinfo);\n err_free_buf:\n\tusb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t  gtco->buffer, gtco->buf_dma);\n err_free_devs:\n\tinput_free_device(input_dev);\n\tkfree(gtco);\n\treturn error;\n}\n",
  "diff_func": "@@ -858,6 +858,14 @@ static int gtco_probe(struct usb_interface *usbinterface,\n \t\tgoto err_free_buf;\n \t}\n \n+\t/* Sanity check that a device has an endpoint */\n+\tif (usbinterface->altsetting[0].desc.bNumEndpoints < 1) {\n+\t\tdev_err(&usbinterface->dev,\n+\t\t\t\"Invalid number of endpoints\\n\");\n+\t\terror = -EINVAL;\n+\t\tgoto err_free_urb;\n+\t}\n+\n \t/*\n \t * The endpoint is always altsetting 0, we know this since we know\n \t * this device only has one interrupt endpoint\n@@ -879,7 +887,7 @@ static int gtco_probe(struct usb_interface *usbinterface,\n \t * HID report descriptor\n \t */\n \tif (usb_get_extra_descriptor(usbinterface->cur_altsetting,\n-\t\t\t\t     HID_DEVICE_TYPE, &hid_desc) != 0){\n+\t\t\t\t     HID_DEVICE_TYPE, &hid_desc) != 0) {\n \t\tdev_err(&usbinterface->dev,\n \t\t\t\"Can't retrieve exta USB descriptor to get hid report descriptor length\\n\");\n \t\terror = -EIO;",
  "project": "linux",
  "commit_id": "162f98dea487206d9ab79fc12ed64700667a894d",
  "target": 1,
  "func": "static int gtco_probe(struct usb_interface *usbinterface,\n\t\t      const struct usb_device_id *id)\n{\n\n\tstruct gtco             *gtco;\n\tstruct input_dev        *input_dev;\n\tstruct hid_descriptor   *hid_desc;\n\tchar                    *report;\n\tint                     result = 0, retry;\n\tint\t\t\terror;\n\tstruct usb_endpoint_descriptor *endpoint;\n\n\t/* Allocate memory for device structure */\n\tgtco = kzalloc(sizeof(struct gtco), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!gtco || !input_dev) {\n\t\tdev_err(&usbinterface->dev, \"No more memory\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_devs;\n\t}\n\n\t/* Set pointer to the input device */\n\tgtco->inputdevice = input_dev;\n\n\t/* Save interface information */\n\tgtco->usbdev = interface_to_usbdev(usbinterface);\n\tgtco->intf = usbinterface;\n\n\t/* Allocate some data for incoming reports */\n\tgtco->buffer = usb_alloc_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t\t\t  GFP_KERNEL, &gtco->buf_dma);\n\tif (!gtco->buffer) {\n\t\tdev_err(&usbinterface->dev, \"No more memory for us buffers\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_devs;\n\t}\n\n\t/* Allocate URB for reports */\n\tgtco->urbinfo = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!gtco->urbinfo) {\n\t\tdev_err(&usbinterface->dev, \"Failed to allocate URB\\n\");\n\t\terror = -ENOMEM;\n \t\tgoto err_free_buf;\n \t}\n \n \t/*\n \t * The endpoint is always altsetting 0, we know this since we know\n \t * this device only has one interrupt endpoint\n\t */\n\tendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\n\n\t/* Some debug */\n\tdev_dbg(&usbinterface->dev, \"gtco # interfaces: %d\\n\", usbinterface->num_altsetting);\n\tdev_dbg(&usbinterface->dev, \"num endpoints:     %d\\n\", usbinterface->cur_altsetting->desc.bNumEndpoints);\n\tdev_dbg(&usbinterface->dev, \"interface class:   %d\\n\", usbinterface->cur_altsetting->desc.bInterfaceClass);\n\tdev_dbg(&usbinterface->dev, \"endpoint: attribute:0x%x type:0x%x\\n\", endpoint->bmAttributes, endpoint->bDescriptorType);\n\tif (usb_endpoint_xfer_int(endpoint))\n\t\tdev_dbg(&usbinterface->dev, \"endpoint: we have interrupt endpoint\\n\");\n\n\tdev_dbg(&usbinterface->dev, \"endpoint extra len:%d\\n\", usbinterface->altsetting[0].extralen);\n\n\t/*\n\t * Find the HID descriptor so we can find out the size of the\n \t * HID report descriptor\n \t */\n \tif (usb_get_extra_descriptor(usbinterface->cur_altsetting,\n\t\t\t\t     HID_DEVICE_TYPE, &hid_desc) != 0){\n \t\tdev_err(&usbinterface->dev,\n \t\t\t\"Can't retrieve exta USB descriptor to get hid report descriptor length\\n\");\n \t\terror = -EIO;\n\t\tgoto err_free_urb;\n\t}\n\n\tdev_dbg(&usbinterface->dev,\n\t\t\"Extra descriptor success: type:%d  len:%d\\n\",\n\t\thid_desc->bDescriptorType,  hid_desc->wDescriptorLength);\n\n\treport = kzalloc(le16_to_cpu(hid_desc->wDescriptorLength), GFP_KERNEL);\n\tif (!report) {\n\t\tdev_err(&usbinterface->dev, \"No more memory for report\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_urb;\n\t}\n\n\t/* Couple of tries to get reply */\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tresult = usb_control_msg(gtco->usbdev,\n\t\t\t\t\t usb_rcvctrlpipe(gtco->usbdev, 0),\n\t\t\t\t\t USB_REQ_GET_DESCRIPTOR,\n\t\t\t\t\t USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t\t REPORT_DEVICE_TYPE << 8,\n\t\t\t\t\t 0, /* interface */\n\t\t\t\t\t report,\n\t\t\t\t\t le16_to_cpu(hid_desc->wDescriptorLength),\n\t\t\t\t\t 5000); /* 5 secs */\n\n\t\tdev_dbg(&usbinterface->dev, \"usb_control_msg result: %d\\n\", result);\n\t\tif (result == le16_to_cpu(hid_desc->wDescriptorLength)) {\n\t\t\tparse_hid_report_descriptor(gtco, report, result);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(report);\n\n\t/* If we didn't get the report, fail */\n\tif (result != le16_to_cpu(hid_desc->wDescriptorLength)) {\n\t\tdev_err(&usbinterface->dev,\n\t\t\t\"Failed to get HID Report Descriptor of size: %d\\n\",\n\t\t\thid_desc->wDescriptorLength);\n\t\terror = -EIO;\n\t\tgoto err_free_urb;\n\t}\n\n\t/* Create a device file node */\n\tusb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));\n\tstrlcat(gtco->usbpath, \"/input0\", sizeof(gtco->usbpath));\n\n\t/* Set Input device functions */\n\tinput_dev->open = gtco_input_open;\n\tinput_dev->close = gtco_input_close;\n\n\t/* Set input device information */\n\tinput_dev->name = \"GTCO_CalComp\";\n\tinput_dev->phys = gtco->usbpath;\n\n\tinput_set_drvdata(input_dev, gtco);\n\n\t/* Now set up all the input device capabilities */\n\tgtco_setup_caps(input_dev);\n\n\t/* Set input device required ID information */\n\tusb_to_input_id(gtco->usbdev, &input_dev->id);\n\tinput_dev->dev.parent = &usbinterface->dev;\n\n\t/* Setup the URB, it will be posted later on open of input device */\n\tendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\n\n\tusb_fill_int_urb(gtco->urbinfo,\n\t\t\t gtco->usbdev,\n\t\t\t usb_rcvintpipe(gtco->usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t gtco->buffer,\n\t\t\t REPORT_MAX_SIZE,\n\t\t\t gtco_urb_callback,\n\t\t\t gtco,\n\t\t\t endpoint->bInterval);\n\n\tgtco->urbinfo->transfer_dma = gtco->buf_dma;\n\tgtco->urbinfo->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t/* Save gtco pointer in USB interface gtco */\n\tusb_set_intfdata(usbinterface, gtco);\n\n\t/* All done, now register the input device */\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\tgoto err_free_urb;\n\n\treturn 0;\n\n err_free_urb:\n\tusb_free_urb(gtco->urbinfo);\n err_free_buf:\n\tusb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t  gtco->buffer, gtco->buf_dma);\n err_free_devs:\n\tinput_free_device(input_dev);\n\tkfree(gtco);\n\treturn error;\n}\n",
  "big_vul_idx": 180603,
  "idx": 2180,
  "hash": 91802595213563342136282711083605490055
}