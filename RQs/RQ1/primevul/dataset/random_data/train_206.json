{
  "id": 206,
  "language": "c",
  "cwe": "CWE-704",
  "commit_url": "https://github.com/uranix/ghostpdl/commit/f5c7555c30393e64ec1f5ab0dfae5b55b3b3fc78",
  "commit_sha": "f5c7555c30393e64ec1f5ab0dfae5b55b3b3fc78",
  "commit_msg": "Bug 697203: check for sufficient params in .sethalftone5\n\nand param types",
  "pr_url": null,
  "pr_info": null,
  "file_name": "psi/zht2.c",
  "func_name": "",
  "raw_func_from_json": "zsethalftone5(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint count;\n    gs_halftone_component *phtc = 0;\n    gs_halftone_component *pc;\n    int code = 0;\n    int j;\n    bool have_default;\n    gs_halftone *pht = 0;\n    gx_device_halftone *pdht = 0;\n    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n     gs_memory_t *mem;\n     uint edepth = ref_stack_count(&e_stack);\n     int npop = 2;\n    int dict_enum = dict_first(op);\n     ref rvalue[2];\n     int cname, colorant_number;\n     byte * pname;\n     uint name_size;\n     int halftonetype, type = 0;\n     gs_gstate *pgs = igs;\n    int space_index = r_space_index(op - 1);\n \n     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n     * the device color space, so we need to mark them\n     * with a different internal halftone type.\n     */\n    code = dict_int_param(op - 1, \"HalftoneType\", 1, 100, 0, &type);\n    if (code < 0)\n          return code;\n    halftonetype = (type == 2 || type == 4)\n                        ? ht_type_multiple_colorscreen\n                        : ht_type_multiple;\n\n    /* Count how many components that we will actually use. */\n\n    have_default = false;\n    for (count = 0; ;) {\n\n        /* Move to next element in the dictionary */\n        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n            break;\n        /*\n         * Verify that we have a valid component.  We may have a\n         * /HalfToneType entry.\n         */\n        if (!r_has_type(&rvalue[0], t_name))\n            continue;\n        if (!r_has_type(&rvalue[1], t_dictionary))\n            continue;\n\n        /* Get the name of the component  verify that we will use it. */\n        cname = name_index(mem, &rvalue[0]);\n        code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n        if (code < 0)\n            break;\n        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n        if (colorant_number < 0)\n            continue;\n        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {\n            /* If here then we have the \"Default\" component */\n            if (have_default)\n                return_error(gs_error_rangecheck);\n            have_default = true;\n        }\n\n        count++;\n        /*\n         * Check to see if we have already reached the legal number of\n         * components.\n         */\n        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {\n            code = gs_note_error(gs_error_rangecheck);\n            break;\n        }\n    }\n    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))\n        code = gs_note_error(gs_error_rangecheck);\n\n    if (code >= 0) {\n        check_estack(5);\t\t/* for sampling Type 1 screens */\n        refset_null(sprocs, count);\n        refset_null(tprocs, count);\n        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,\n                          imemory, pht = 0, \".sethalftone5\");\n        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,\n                                     &st_ht_component_element,\n                                     \".sethalftone5\");\n        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,\n                          imemory, pdht = 0, \".sethalftone5\");\n        if (pht == 0 || phtc == 0 || pdht == 0) {\n            j = 0; /* Quiet the compiler:\n                      gs_note_error isn't necessarily identity,\n                      so j could be left ununitialized. */\n            code = gs_note_error(gs_error_VMerror);\n        }\n    }\n    if (code >= 0) {\n        dict_enum = dict_first(op);\n        for (j = 0, pc = phtc; ;) {\n            int type;\n\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n            /*\n             * Verify that we have a valid component.  We may have a\n             * /HalfToneType entry.\n             */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\t\t/* Do not use this component */\n            pc->cname = cname;\n            pc->comp_number = colorant_number;\n\n            /* Now process the component dictionary */\n            check_dict_read(rvalue[1]);\n            if (dict_int_param(&rvalue[1], \"HalftoneType\", 1, 7, 0, &type) < 0) {\n                code = gs_note_error(gs_error_typecheck);\n                break;\n            }\n            switch (type) {\n                default:\n                    code = gs_note_error(gs_error_rangecheck);\n                    break;\n                case 1:\n                    code = dict_spot_params(&rvalue[1], &pc->params.spot,\n                                                sprocs + j, tprocs + j, mem);\n                    pc->params.spot.screen.spot_function = spot1_dummy;\n                    pc->type = ht_type_spot;\n                    break;\n                case 3:\n                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,\n                                                        tprocs + j);\n                    pc->type = ht_type_threshold;\n                    break;\n                case 7:\n                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,\n                                                        tprocs + j, imemory);\n                    pc->type = ht_type_threshold2;\n                    break;\n            }\n            if (code < 0)\n                break;\n            pc++;\n            j++;\n        }\n    }\n    if (code >= 0) {\n        pht->type = halftonetype;\n        pht->params.multiple.components = phtc;\n        pht->params.multiple.num_comp = j;\n        pht->params.multiple.get_colorname_string = gs_get_colorname_string;\n        code = gs_sethalftone_prepare(igs, pht, pdht);\n    }\n    if (code >= 0) {\n        /*\n         * Put the actual frequency and angle in the spot function component dictionaries.\n         */\n        dict_enum = dict_first(op);\n        for (pc = phtc; ; ) {\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n\n            /* Verify that we have a valid component */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component and verify that we will use it. */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\n\n            if (pc->type == ht_type_spot) {\n                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);\n                if (code < 0)\n                    break;\n            }\n            pc++;\n        }\n    }\n    if (code >= 0) {\n        /*\n         * Schedule the sampling of any Type 1 screens,\n         * and any (Type 1 or Type 3) TransferFunctions.\n         * Save the stack depths in case we have to back out.\n         */\n        uint odepth = ref_stack_count(&o_stack);\n        ref odict, odict5;\n\n        odict = op[-1];\n        odict5 = *op;\n        pop(2);\n        op = osp;\n        esp += 5;\n        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);\n        esp[-3] = odict;\n        make_istruct(esp - 2, 0, pht);\n        make_istruct(esp - 1, 0, pdht);\n        make_op_estack(esp, sethalftone_finish);\n        for (j = 0; j < count; j++) {\n            gx_ht_order *porder = NULL;\n\n            if (pdht->components == 0)\n                porder = &pdht->order;\n            else {\n                /* Find the component in pdht that matches component j in\n                   the pht; gs_sethalftone_prepare() may permute these. */\n                int k;\n                int comp_number = phtc[j].comp_number;\n                for (k = 0; k < count; k++) {\n                    if (pdht->components[k].comp_number == comp_number) {\n                        porder = &pdht->components[k].corder;\n                        break;\n                    }\n                }\n            }\n            switch (phtc[j].type) {\n            case ht_type_spot:\n                code = zscreen_enum_init(i_ctx_p, porder,\n                                         &phtc[j].params.spot.screen,\n                                         &sprocs[j], 0, 0, space_index);\n                if (code < 0)\n                    break;\n                /* falls through */\n            case ht_type_threshold:\n                if (!r_has_type(tprocs + j, t__invalid)) {\n                    /* Schedule TransferFunction sampling. */\n                    /****** check_xstack IS WRONG ******/\n                    check_ostack(zcolor_remap_one_ostack);\n                    check_estack(zcolor_remap_one_estack);\n                    code = zcolor_remap_one(i_ctx_p, tprocs + j,\n                                            porder->transfer, igs,\n                                            zcolor_remap_one_finish);\n                    op = osp;\n                }\n                break;\n            default:\t/* not possible here, but to keep */\n                                /* the compilers happy.... */\n                ;\n            }\n            if (code < 0) {\t/* Restore the stack. */\n                ref_stack_pop_to(&o_stack, odepth);\n                ref_stack_pop_to(&e_stack, edepth);\n                op = osp;\n                op[-1] = odict;\n                *op = odict5;\n                break;\n            }\n            npop = 0;\n        }\n    }\n    if (code < 0) {\n        gs_free_object(mem, pdht, \".sethalftone5\");\n        gs_free_object(mem, phtc, \".sethalftone5\");\n        gs_free_object(mem, pht, \".sethalftone5\");\n        return code;\n    }\n    pop(npop);\n    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);\n}\n",
  "diff_func": "@@ -82,14 +82,22 @@ zsethalftone5(i_ctx_t *i_ctx_p)\n     gs_memory_t *mem;\n     uint edepth = ref_stack_count(&e_stack);\n     int npop = 2;\n-    int dict_enum = dict_first(op);\n+    int dict_enum;\n     ref rvalue[2];\n     int cname, colorant_number;\n     byte * pname;\n     uint name_size;\n     int halftonetype, type = 0;\n     gs_gstate *pgs = igs;\n-    int space_index = r_space_index(op - 1);\n+    int space_index;\n+\n+    if (ref_stack_count(&o_stack) < 2)\n+        return_error(gs_error_stackunderflow);\n+    check_type(*op, t_dictionary);\n+    check_type(*(op - 1), t_dictionary);\n+\n+    dict_enum = dict_first(op);\n+    space_index = r_space_index(op - 1);\n \n     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n ",
  "project": "ghostscript",
  "commit_id": "f5c7555c30393e64ec1f5ab0dfae5b55b3b3fc78",
  "target": 1,
  "func": "zsethalftone5(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint count;\n    gs_halftone_component *phtc = 0;\n    gs_halftone_component *pc;\n    int code = 0;\n    int j;\n    bool have_default;\n    gs_halftone *pht = 0;\n    gx_device_halftone *pdht = 0;\n    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n     gs_memory_t *mem;\n     uint edepth = ref_stack_count(&e_stack);\n     int npop = 2;\n    int dict_enum = dict_first(op);\n     ref rvalue[2];\n     int cname, colorant_number;\n     byte * pname;\n     uint name_size;\n     int halftonetype, type = 0;\n     gs_gstate *pgs = igs;\n    int space_index = r_space_index(op - 1);\n \n     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n     * the device color space, so we need to mark them\n     * with a different internal halftone type.\n     */\n    code = dict_int_param(op - 1, \"HalftoneType\", 1, 100, 0, &type);\n    if (code < 0)\n          return code;\n    halftonetype = (type == 2 || type == 4)\n                        ? ht_type_multiple_colorscreen\n                        : ht_type_multiple;\n\n    /* Count how many components that we will actually use. */\n\n    have_default = false;\n    for (count = 0; ;) {\n\n        /* Move to next element in the dictionary */\n        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n            break;\n        /*\n         * Verify that we have a valid component.  We may have a\n         * /HalfToneType entry.\n         */\n        if (!r_has_type(&rvalue[0], t_name))\n            continue;\n        if (!r_has_type(&rvalue[1], t_dictionary))\n            continue;\n\n        /* Get the name of the component  verify that we will use it. */\n        cname = name_index(mem, &rvalue[0]);\n        code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n        if (code < 0)\n            break;\n        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n        if (colorant_number < 0)\n            continue;\n        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {\n            /* If here then we have the \"Default\" component */\n            if (have_default)\n                return_error(gs_error_rangecheck);\n            have_default = true;\n        }\n\n        count++;\n        /*\n         * Check to see if we have already reached the legal number of\n         * components.\n         */\n        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {\n            code = gs_note_error(gs_error_rangecheck);\n            break;\n        }\n    }\n    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))\n        code = gs_note_error(gs_error_rangecheck);\n\n    if (code >= 0) {\n        check_estack(5);\t\t/* for sampling Type 1 screens */\n        refset_null(sprocs, count);\n        refset_null(tprocs, count);\n        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,\n                          imemory, pht = 0, \".sethalftone5\");\n        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,\n                                     &st_ht_component_element,\n                                     \".sethalftone5\");\n        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,\n                          imemory, pdht = 0, \".sethalftone5\");\n        if (pht == 0 || phtc == 0 || pdht == 0) {\n            j = 0; /* Quiet the compiler:\n                      gs_note_error isn't necessarily identity,\n                      so j could be left ununitialized. */\n            code = gs_note_error(gs_error_VMerror);\n        }\n    }\n    if (code >= 0) {\n        dict_enum = dict_first(op);\n        for (j = 0, pc = phtc; ;) {\n            int type;\n\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n            /*\n             * Verify that we have a valid component.  We may have a\n             * /HalfToneType entry.\n             */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\t\t/* Do not use this component */\n            pc->cname = cname;\n            pc->comp_number = colorant_number;\n\n            /* Now process the component dictionary */\n            check_dict_read(rvalue[1]);\n            if (dict_int_param(&rvalue[1], \"HalftoneType\", 1, 7, 0, &type) < 0) {\n                code = gs_note_error(gs_error_typecheck);\n                break;\n            }\n            switch (type) {\n                default:\n                    code = gs_note_error(gs_error_rangecheck);\n                    break;\n                case 1:\n                    code = dict_spot_params(&rvalue[1], &pc->params.spot,\n                                                sprocs + j, tprocs + j, mem);\n                    pc->params.spot.screen.spot_function = spot1_dummy;\n                    pc->type = ht_type_spot;\n                    break;\n                case 3:\n                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,\n                                                        tprocs + j);\n                    pc->type = ht_type_threshold;\n                    break;\n                case 7:\n                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,\n                                                        tprocs + j, imemory);\n                    pc->type = ht_type_threshold2;\n                    break;\n            }\n            if (code < 0)\n                break;\n            pc++;\n            j++;\n        }\n    }\n    if (code >= 0) {\n        pht->type = halftonetype;\n        pht->params.multiple.components = phtc;\n        pht->params.multiple.num_comp = j;\n        pht->params.multiple.get_colorname_string = gs_get_colorname_string;\n        code = gs_sethalftone_prepare(igs, pht, pdht);\n    }\n    if (code >= 0) {\n        /*\n         * Put the actual frequency and angle in the spot function component dictionaries.\n         */\n        dict_enum = dict_first(op);\n        for (pc = phtc; ; ) {\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n\n            /* Verify that we have a valid component */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component and verify that we will use it. */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\n\n            if (pc->type == ht_type_spot) {\n                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);\n                if (code < 0)\n                    break;\n            }\n            pc++;\n        }\n    }\n    if (code >= 0) {\n        /*\n         * Schedule the sampling of any Type 1 screens,\n         * and any (Type 1 or Type 3) TransferFunctions.\n         * Save the stack depths in case we have to back out.\n         */\n        uint odepth = ref_stack_count(&o_stack);\n        ref odict, odict5;\n\n        odict = op[-1];\n        odict5 = *op;\n        pop(2);\n        op = osp;\n        esp += 5;\n        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);\n        esp[-3] = odict;\n        make_istruct(esp - 2, 0, pht);\n        make_istruct(esp - 1, 0, pdht);\n        make_op_estack(esp, sethalftone_finish);\n        for (j = 0; j < count; j++) {\n            gx_ht_order *porder = NULL;\n\n            if (pdht->components == 0)\n                porder = &pdht->order;\n            else {\n                /* Find the component in pdht that matches component j in\n                   the pht; gs_sethalftone_prepare() may permute these. */\n                int k;\n                int comp_number = phtc[j].comp_number;\n                for (k = 0; k < count; k++) {\n                    if (pdht->components[k].comp_number == comp_number) {\n                        porder = &pdht->components[k].corder;\n                        break;\n                    }\n                }\n            }\n            switch (phtc[j].type) {\n            case ht_type_spot:\n                code = zscreen_enum_init(i_ctx_p, porder,\n                                         &phtc[j].params.spot.screen,\n                                         &sprocs[j], 0, 0, space_index);\n                if (code < 0)\n                    break;\n                /* falls through */\n            case ht_type_threshold:\n                if (!r_has_type(tprocs + j, t__invalid)) {\n                    /* Schedule TransferFunction sampling. */\n                    /****** check_xstack IS WRONG ******/\n                    check_ostack(zcolor_remap_one_ostack);\n                    check_estack(zcolor_remap_one_estack);\n                    code = zcolor_remap_one(i_ctx_p, tprocs + j,\n                                            porder->transfer, igs,\n                                            zcolor_remap_one_finish);\n                    op = osp;\n                }\n                break;\n            default:\t/* not possible here, but to keep */\n                                /* the compilers happy.... */\n                ;\n            }\n            if (code < 0) {\t/* Restore the stack. */\n                ref_stack_pop_to(&o_stack, odepth);\n                ref_stack_pop_to(&e_stack, edepth);\n                op = osp;\n                op[-1] = odict;\n                *op = odict5;\n                break;\n            }\n            npop = 0;\n        }\n    }\n    if (code < 0) {\n        gs_free_object(mem, pdht, \".sethalftone5\");\n        gs_free_object(mem, phtc, \".sethalftone5\");\n        gs_free_object(mem, pht, \".sethalftone5\");\n        return code;\n    }\n    pop(npop);\n    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);\n}\n",
  "big_vul_idx": 178435,
  "idx": 422,
  "hash": 113189749909410079659988113313852115728
}