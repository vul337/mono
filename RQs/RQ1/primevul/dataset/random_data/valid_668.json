{
  "id": 668,
  "language": "c",
  "cwe": "",
  "commit_url": "https://github.com/LouisVeblen/libuv/commit/b7466e31e4bee160d82a68fca11b1f61d46debae",
  "commit_sha": "b7466e31e4bee160d82a68fca11b1f61d46debae",
  "commit_msg": "idna: fix OOB read in punycode decoder\n\nlibuv was vulnerable to out-of-bounds reads in the uv__idna_toascii()\nfunction which is used to convert strings to ASCII. This is called by\nthe DNS resolution function and can lead to information disclosures or\ncrashes.\n\nReported by Eric Sesterhenn in collaboration with Cure53 and ExpressVPN.\n\nReported-By: Eric Sesterhenn <eric.sesterhenn@x41-dsec.de>\nFixes: https://github.com/libuv/libuv/issues/3147\nPR-URL: https://github.com/libuv/libuv-private/pull/1\nRefs: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22918\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "src/idna.c",
  "func_name": "",
  "raw_func_from_json": "long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  for (si = s; si < se; /* empty */) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d < de)\n    *d++ = '\\0';\n\n  return d - ds;  /* Number of bytes written. */\n}",
  "diff_func": "@@ -19,6 +19,7 @@\n \n #include \"uv.h\"\n #include \"idna.h\"\n+#include <assert.h>\n #include <string.h>\n \n static unsigned uv__utf8_decode1_slow(const char** p,\n@@ -32,7 +33,7 @@ static unsigned uv__utf8_decode1_slow(const char** p,\n   if (a > 0xF7)\n     return -1;\n \n-  switch (*p - pe) {\n+  switch (pe - *p) {\n   default:\n     if (a > 0xEF) {\n       min = 0x10000;\n@@ -62,6 +63,8 @@ static unsigned uv__utf8_decode1_slow(const char** p,\n       a = 0;\n       break;\n     }\n+    /* Fall through. */\n+  case 0:\n     return -1;  /* Invalid continuation byte. */\n   }\n \n@@ -88,6 +91,8 @@ static unsigned uv__utf8_decode1_slow(const char** p,\n unsigned uv__utf8_decode1(const char** p, const char* pe) {\n   unsigned a;\n \n+  assert(*p < pe);\n+\n   a = (unsigned char) *(*p)++;\n \n   if (a < 128)\n@@ -96,9 +101,6 @@ unsigned uv__utf8_decode1(const char** p, const char* pe) {\n   return uv__utf8_decode1_slow(p, pe, a);\n }\n \n-#define foreach_codepoint(c, p, pe) \\\n-  for (; (void) (*p <= pe && (c = uv__utf8_decode1(p, pe))), *p <= pe;)\n-\n static int uv__idna_toascii_label(const char* s, const char* se,\n                                   char** d, char* de) {\n   static const char alphabet[] = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n@@ -121,25 +123,36 @@ static int uv__idna_toascii_label(const char* s, const char* se,\n   ss = s;\n   todo = 0;\n \n-  foreach_codepoint(c, &s, se) {\n+  /* Note: after this loop we've visited all UTF-8 characters and know\n+   * they're legal so we no longer need to check for decode errors.\n+   */\n+  while (s < se) {\n+    c = uv__utf8_decode1(&s, se);\n+\n+    if (c == -1u)\n+      return UV_EINVAL;\n+\n     if (c < 128)\n       h++;\n-    else if (c == (unsigned) -1)\n-      return UV_EINVAL;\n     else\n       todo++;\n   }\n \n+  /* Only write \"xn--\" when there are non-ASCII characters. */\n   if (todo > 0) {\n     if (*d < de) *(*d)++ = 'x';\n     if (*d < de) *(*d)++ = 'n';\n     if (*d < de) *(*d)++ = '-';\n     if (*d < de) *(*d)++ = '-';\n   }\n \n+  /* Write ASCII characters. */\n   x = 0;\n   s = ss;\n-  foreach_codepoint(c, &s, se) {\n+  while (s < se) {\n+    c = uv__utf8_decode1(&s, se);\n+    assert(c != -1u);\n+\n     if (c > 127)\n       continue;\n \n@@ -166,10 +179,15 @@ static int uv__idna_toascii_label(const char* s, const char* se,\n   while (todo > 0) {\n     m = -1;\n     s = ss;\n-    foreach_codepoint(c, &s, se)\n+\n+    while (s < se) {\n+      c = uv__utf8_decode1(&s, se);\n+      assert(c != -1u);\n+\n       if (c >= n)\n         if (c < m)\n           m = c;\n+    }\n \n     x = m - n;\n     y = h + 1;\n@@ -181,7 +199,10 @@ static int uv__idna_toascii_label(const char* s, const char* se,\n     n = m;\n \n     s = ss;\n-    foreach_codepoint(c, &s, se) {\n+    while (s < se) {\n+      c = uv__utf8_decode1(&s, se);\n+      assert(c != -1u);\n+\n       if (c < n)\n         if (++delta == 0)\n           return UV_E2BIG;  /* Overflow. */\n@@ -245,8 +266,6 @@ static int uv__idna_toascii_label(const char* s, const char* se,\n   return 0;\n }\n \n-#undef foreach_codepoint\n-\n long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n   const char* si;\n   const char* st;\n@@ -256,10 +275,14 @@ long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n \n   ds = d;\n \n-  for (si = s; si < se; /* empty */) {\n+  si = s;\n+  while (si < se) {\n     st = si;\n     c = uv__utf8_decode1(&si, se);\n \n+    if (c == -1u)\n+      return UV_EINVAL;\n+\n     if (c != '.')\n       if (c != 0x3002)  /* 。 */\n         if (c != 0xFF0E)  /* ． */",
  "func": "long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  for (si = s; si < se; /* empty */) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d < de)\n    *d++ = '\\0';\n\n  return d - ds;  /* Number of bytes written. */\n}",
  "project": "libuv",
  "hash": 330726136045724320865601654107082283716,
  "size": 42,
  "commit_id": "b7466e31e4bee160d82a68fca11b1f61d46debae",
  "message": "idna: fix OOB read in punycode decoder\n\nlibuv was vulnerable to out-of-bounds reads in the uv__idna_toascii()\nfunction which is used to convert strings to ASCII. This is called by\nthe DNS resolution function and can lead to information disclosures or\ncrashes.\n\nReported by Eric Sesterhenn in collaboration with Cure53 and ExpressVPN.\n\nReported-By: Eric Sesterhenn <eric.sesterhenn@x41-dsec.de>\nFixes: https://github.com/libuv/libuv/issues/3147\nPR-URL: https://github.com/libuv/libuv-private/pull/1\nRefs: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22918\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
  "target": 1,
  "dataset": "other",
  "idx": 201892
}