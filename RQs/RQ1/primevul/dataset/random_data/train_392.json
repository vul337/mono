{
  "id": 392,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/ljalves/linux_media/commit/a963a37d384d71ad43b3e9e79d68d42fbe0901f3",
  "commit_sha": "a963a37d384d71ad43b3e9e79d68d42fbe0901f3",
  "commit_msg": "ipv6: ip6_sk_dst_check() must not assume ipv6 dst\n\nIt's possible to use AF_INET6 sockets and to connect to an IPv4\ndestination. After this, socket dst cache is a pointer to a rtable,\nnot rt6_info.\n\nip6_sk_dst_check() should check the socket dst cache is IPv6, or else\nvarious corruptions/crashes can happen.\n\nDave Jones can reproduce immediate crash with\ntrinity -q -l off -n -c sendmsg -c connect\n\nWith help from Hannes Frederic Sowa\n\nReported-by: Dave Jones <davej@redhat.com>\nReported-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "net/ipv6/ip6_output.c",
  "func_name": "",
  "raw_func_from_json": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n \t\t\t\t\t  const struct flowi6 *fl6)\n {\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n \n \tif (!dst)\n \t\tgoto out;\n \n \t/* Yes, checking route validity in not connected\n \t * case is not very simple. Take into account,\n \t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}\n",
  "diff_func": "@@ -821,11 +821,17 @@ static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n \t\t\t\t\t  const struct flowi6 *fl6)\n {\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n-\tstruct rt6_info *rt = (struct rt6_info *)dst;\n+\tstruct rt6_info *rt;\n \n \tif (!dst)\n \t\tgoto out;\n \n+\tif (dst->ops->family != AF_INET6) {\n+\t\tdst_release(dst);\n+\t\treturn NULL;\n+\t}\n+\n+\trt = (struct rt6_info *)dst;\n \t/* Yes, checking route validity in not connected\n \t * case is not very simple. Take into account,\n \t * that we do not support routing by source, TOS,",
  "project": "linux",
  "commit_id": "a963a37d384d71ad43b3e9e79d68d42fbe0901f3",
  "target": 1,
  "func": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n \t\t\t\t\t  const struct flowi6 *fl6)\n {\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n \n \tif (!dst)\n \t\tgoto out;\n \n \t/* Yes, checking route validity in not connected\n \t * case is not very simple. Take into account,\n \t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}\n",
  "big_vul_idx": 179248,
  "idx": 1037,
  "hash": 297614718685075805140610808856983032495
}