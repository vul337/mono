{
  "id": 521,
  "language": "c",
  "cwe": "CWE-20",
  "commit_url": "https://github.com/ljalves/linux_media/commit/263b4509ec4d47e0da3e753f85a39ea12d1eff24",
  "commit_sha": "263b4509ec4d47e0da3e753f85a39ea12d1eff24",
  "commit_msg": "nfs: always make sure page is up-to-date before extending a write to cover the entire page\n\nWe should always make sure the cached page is up-to-date when we're\ndetermining whether we can extend a write to cover the full page -- even\nif we've received a write delegation from the server.\n\nCommit c7559663 added logic to skip this check if we have a write\ndelegation, which can lead to data corruption such as the following\nscenario if client B receives a write delegation from the NFS server:\n\nClient A:\n    # echo 123456789 > /mnt/file\n\nClient B:\n    # echo abcdefghi >> /mnt/file\n    # cat /mnt/file\n    0�D0�abcdefghi\n\nJust because we hold a write delegation doesn't mean that we've read in\nthe entire page contents.\n\nCc: <stable@vger.kernel.org> # v3.11+\nSigned-off-by: Scott Mayhew <smayhew@redhat.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>",
  "pr_url": null,
  "pr_info": null,
  "file_name": "fs/nfs/write.c",
  "func_name": "",
  "raw_func_from_json": " static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n \t\treturn 1;\n \treturn 0;\n }\n",
  "diff_func": "@@ -922,19 +922,20 @@ static bool nfs_write_pageuptodate(struct page *page, struct inode *inode)\n  * extend the write to cover the entire page in order to avoid fragmentation\n  * inefficiencies.\n  *\n- * If the file is opened for synchronous writes or if we have a write delegation\n- * from the server then we can just skip the rest of the checks.\n+ * If the file is opened for synchronous writes then we can just skip the rest\n+ * of the checks.\n  */\n static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n+\tif (!nfs_write_pageuptodate(page, inode))\n+\t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n-\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n-\t\t\t(inode->i_flock->fl_start == 0 &&\n+\tif (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n-\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n+\t\t\tinode->i_flock->fl_type != F_RDLCK))\n \t\treturn 1;\n \treturn 0;\n }",
  "project": "linux",
  "commit_id": "263b4509ec4d47e0da3e753f85a39ea12d1eff24",
  "target": 1,
  "func": " static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n \t\treturn 1;\n \treturn 0;\n }\n",
  "big_vul_idx": 179596,
  "idx": 1316,
  "hash": 289835272320192960652245810503833865526
}