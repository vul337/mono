{
    "cve_id": "CVE-2022-1622",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "libtiff",
    "commit_msg": "tif_lzw.c: fix potential out-of-bounds error when trying to read in the same tile/strip after an error has occured (fixes #410)\n",
    "commit_hash": "b4e79bfa0c7d2d08f6f1e7ec38143fc8cb11394a",
    "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/b4e79bfa0c7d2d08f6f1e7ec38143fc8cb11394a",
    "file_path": "libtiff/tif_lzw.c",
    "func_name": "LZWDecode",
    "func_before": "static int\nLZWDecode(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s)\n{\n\tstatic const char module[] = \"LZWDecode\";\n\tLZWCodecState *sp = DecoderState(tif);\n\tuint8_t *op = (uint8_t*) op0;\n\ttmsize_t occ = occ0;\n\tuint8_t *bp;\n\tlong nbits, nextbits, nbitsmask;\n\tWordType nextdata;\n\tcode_t *free_entp, *maxcodep, *oldcodep;\n\n\t(void) s;\n\tassert(sp != NULL);\n        assert(sp->dec_codetab != NULL);\n\n\t/*\n\t * Restart interrupted output operation.\n\t */\n\tif (sp->dec_restart) {\n\t\ttmsize_t residue;\n\n\t\tcode_t* codep = sp->dec_codep;\n\t\tresidue = codep->length - sp->dec_restart;\n\t\tif (residue > occ) {\n\t\t\t/*\n\t\t\t * Residue from previous decode is sufficient\n\t\t\t * to satisfy decode request.  Skip to the\n\t\t\t * start of the decoded string, place decoded\n\t\t\t * values in the output buffer, and return.\n\t\t\t */\n\t\t\tsp->dec_restart += occ;\n\t\t\tdo {\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--residue > occ && codep);\n\t\t\tif (codep) {\n\t\t\t\tuint8_t* tp = op + occ;\n\t\t\t\tdo {\n\t\t\t\t\t*--tp = codep->value;\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t} while (--occ && codep);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Residue satisfies only part of the decode request.\n\t\t */\n\t\top += residue;\n\t\tocc -= residue;\n\t\tuint8_t* tp = op;\n\t\tdo {\n\t\t\t*--tp = codep->value;\n\t\t\tcodep = codep->next;\n\t\t} while (--residue && codep);\n\t\tsp->dec_restart = 0;\n\t}\n\n\tbp = (uint8_t*)tif->tif_rawcp;\n\tsp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n\tuint64_t dec_bitsleft = sp->dec_bitsleft;\n\tnbits = sp->lzw_nbits;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tnbitsmask = sp->dec_nbitsmask;\n\toldcodep = sp->dec_oldcodep;\n\tfree_entp = sp->dec_free_entp;\n\tmaxcodep = sp->dec_maxcodep;\n\tcode_t* const dec_codetab = sp->dec_codetab;\n\tcode_t* codep;\n\n    if (occ == 0) {\n        goto after_loop;\n    }\n\nbegin:\n    {\n        WordType code;\n        GetNextCodeLZW();\n        codep = dec_codetab + code;\n        if (code >= CODE_FIRST)\n            goto code_above_or_equal_to_258;\n        if (code < 256)\n            goto code_below_256;\n        if (code == CODE_EOI)\n            goto after_loop;\n        goto code_clear;\n\ncode_below_256:\n        {\n            if (codep > free_entp)\n                goto error_code;\n            free_entp->next = oldcodep;\n            free_entp->firstchar = oldcodep->firstchar;\n            free_entp->length = oldcodep->length+1;\n            free_entp->value = (uint8_t)code;\n            free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == code));\n            if (++free_entp > maxcodep) {\n                if (++nbits > BITS_MAX)\t\t/* should not happen for a conformant encoder */\n                    nbits = BITS_MAX;\n                nbitsmask = MAXCODE(nbits);\n                maxcodep = dec_codetab + nbitsmask-1;\n                if( free_entp >= &dec_codetab[CSIZE] )\n                {\n                    /* At that point, the next valid states are either EOI or a */\n                    /* CODE_CLEAR. If a regular code is read, at the next */\n                    /* attempt at registering a new entry, we will error out */\n                    /* due to setting free_entp before any valid code */\n                    free_entp = dec_codetab - 1;\n                }\n            }\n            oldcodep = codep;\n            *op++ = (uint8_t)code;\n            occ--;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_above_or_equal_to_258:\n        {\n            /*\n             * Add the new entry to the code table.\n             */\n\n            if (codep >= free_entp)\n            {\n                if (codep != free_entp)\n                    goto error_code;\n                free_entp->value = oldcodep->firstchar;\n            }\n            else\n            {\n                free_entp->value = codep->firstchar;\n            }\n            free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == free_entp->value));\n            free_entp->next = oldcodep;\n\n            free_entp->firstchar = oldcodep->firstchar;\n            free_entp->length = oldcodep->length+1;\n            if (++free_entp > maxcodep) {\n                if (++nbits > BITS_MAX)\t\t/* should not happen for a conformant encoder */\n                    nbits = BITS_MAX;\n                nbitsmask = MAXCODE(nbits);\n                maxcodep = dec_codetab + nbitsmask-1;\n                if (free_entp >= &dec_codetab[CSIZE])\n                {\n                    /* At that point, the next valid states are either EOI or a */\n                    /* CODE_CLEAR. If a regular code is read, at the next */\n                    /* attempt at registering a new entry, we will error out */\n                    /* due to setting free_entp before any valid code */\n                    free_entp = dec_codetab - 1;\n                }\n            }\n            oldcodep = codep;\n\n            /*\n             * Code maps to a string, copy string\n             * value to output (written in reverse).\n             */\n            /* tiny bit faster on x86_64 to store in unsigned short than int */\n            unsigned short len = codep->length;\n\n            if (len < 3) /* equivalent to len == 2 given all other conditions */\n            {\n                if (occ <= 2)\n                {\n                    if (occ == 2)\n                    {\n                        memcpy(op, &(codep->firstchar), 2);\n                        op += 2;\n                        occ -= 2;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                memcpy(op, &(codep->firstchar), 2);\n                op += 2;\n                occ -= 2;\n                goto begin; /* we can save the comparison occ > 0 */\n            }\n\n            if (len == 3)\n            {\n                if (occ <= 3)\n                {\n                    if (occ == 3)\n                    {\n                        op[0] = codep->firstchar;\n                        op[1] = codep->next->value;\n                        op[2] = codep->value;\n                        op += 3;\n                        occ -= 3;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                op[0] = codep->firstchar;\n                op[1] = codep->next->value;\n                op[2] = codep->value;\n                op += 3;\n                occ -= 3;\n                goto begin; /* we can save the comparison occ > 0 */\n            }\n\n            if (len > occ)\n            {\n                goto too_short_buffer;\n            }\n\n            if (codep->repeated)\n            {\n                memset(op, codep->value, len);\n                op += len;\n                occ -= len;\n                if (occ == 0)\n                    goto after_loop;\n                goto begin;\n            }\n\n            uint8_t* tp = op + len;\n\n            assert(len >= 4);\n\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            if (tp > op)\n            {\n                 do {\n                    codep = codep->next;\n                    *--tp = codep->value;\n                } while (tp > op);\n            }\n\n            assert(occ >= len);\n            op += len;\n            occ -= len;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_clear:\n        {\n            free_entp = dec_codetab + CODE_FIRST;\n            nbits = BITS_MIN;\n            nbitsmask = MAXCODE(BITS_MIN);\n            maxcodep = dec_codetab + nbitsmask-1;\n            do {\n                GetNextCodeLZW();\n            } while (code == CODE_CLEAR);\t/* consecutive CODE_CLEAR codes */\n            if (code == CODE_EOI)\n                goto after_loop;\n            if (code > CODE_EOI) {\n                goto error_code;\n            }\n            *op++ = (uint8_t)code;\n            occ--;\n            oldcodep = dec_codetab + code;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n    }\n\ntoo_short_buffer:\n    {\n        /*\n         * String is too long for decode buffer,\n         * locate portion that will fit, copy to\n         * the decode buffer, and setup restart\n         * logic for the next decoding call.\n         */\n        sp->dec_codep = codep;\n        do {\n            codep = codep->next;\n        } while (codep->length > occ);\n\n        sp->dec_restart = occ;\n        uint8_t* tp = op + occ;\n        do  {\n            *--tp = codep->value;\n            codep = codep->next;\n        }  while (--occ);\n    }\n\nafter_loop:\n\ttif->tif_rawcc -= (tmsize_t)((uint8_t*) bp - tif->tif_rawcp );\n\ttif->tif_rawcp = (uint8_t*) bp;\n\tsp->old_tif_rawcc = tif->tif_rawcc;\n\tsp->dec_bitsleft = dec_bitsleft;\n\tsp->lzw_nbits = (unsigned short) nbits;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->dec_nbitsmask = nbitsmask;\n\tsp->dec_oldcodep = oldcodep;\n\tsp->dec_free_entp = free_entp;\n\tsp->dec_maxcodep = maxcodep;\n\n\tif (occ > 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %\"PRIu32\" (short %\"PRIu64\" bytes)\",\n\t\t\t     tif->tif_row, (uint64_t)occ);\n\t\treturn (0);\n\t}\n\treturn (1);\n\nno_eoi:\n    TIFFErrorExt(tif->tif_clientdata, module,\n                    \"LZWDecode: Strip %\"PRIu32\" not terminated with EOI code\",\n                    tif->tif_curstrip);\n    return 0;\nerror_code:\n    TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Using code not yet in table\");\n    return 0;\n}",
    "abstract_func_before": "static int\nLZWDecode(TIFF* VAR_0, uint8_t* VAR_1, tmsize_t VAR_2, uint16_t VAR_3)\n{\n\tstatic const char VAR_4[] = \"LZWDecode\";\n\tLZWCodecState *VAR_5 = DecoderState(VAR_0);\n\tuint8_t *VAR_6 = (uint8_t*) VAR_1;\n\ttmsize_t VAR_7 = VAR_2;\n\tuint8_t *VAR_8;\n\tlong VAR_9, VAR_10, VAR_11;\n\tWordType VAR_12;\n\tcode_t *VAR_13, *VAR_14, *VAR_15;\n\n\t(void) VAR_3;\n\tassert(VAR_5 != NULL);\n        assert(VAR_5->dec_codetab != NULL);\n\n\t/* COMMENT_0 */\n                                         \n    \n\tif (VAR_5->dec_restart) {\n\t\ttmsize_t VAR_16;\n\n\t\tcode_t* VAR_17 = VAR_5->dec_codep;\n\t\tVAR_16 = VAR_17->length - VAR_5->dec_restart;\n\t\tif (VAR_16 > VAR_7) {\n\t\t\t/* COMMENT_3 */\n                                                \n                                             \n                                                \n                                              \n      \n\t\t\tVAR_5->dec_restart += VAR_7;\n\t\t\tdo {\n\t\t\t\tVAR_17 = VAR_17->next;\n\t\t\t} while (--VAR_16 > VAR_7 && VAR_17);\n\t\t\tif (VAR_17) {\n\t\t\t\tuint8_t* VAR_18 = VAR_6 + VAR_7;\n\t\t\t\tdo {\n\t\t\t\t\t*--VAR_18 = VAR_17->value;\n\t\t\t\t\tVAR_17 = VAR_17->next;\n\t\t\t\t} while (--VAR_7 && VAR_17);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/* COMMENT_9 */\n                                                       \n     \n\t\tVAR_6 += VAR_16;\n\t\tVAR_7 -= VAR_16;\n\t\tuint8_t* VAR_18 = VAR_6;\n\t\tdo {\n\t\t\t*--VAR_18 = VAR_17->value;\n\t\t\tVAR_17 = VAR_17->next;\n\t\t} while (--VAR_16 && VAR_17);\n\t\tVAR_5->dec_restart = 0;\n\t}\n\n\tVAR_8 = (uint8_t*)VAR_0->tif_rawcp;\n\tVAR_5->dec_bitsleft += (((uint64_t)VAR_0->tif_rawcc - VAR_5->old_tif_rawcc) << 3);\n\tuint64_t VAR_19 = VAR_5->dec_bitsleft;\n\tVAR_9 = VAR_5->lzw_nbits;\n\tVAR_12 = VAR_5->lzw_nextdata;\n\tVAR_10 = VAR_5->lzw_nextbits;\n\tVAR_11 = VAR_5->dec_nbitsmask;\n\tVAR_15 = VAR_5->dec_oldcodep;\n\tVAR_13 = VAR_5->dec_free_entp;\n\tVAR_14 = VAR_5->dec_maxcodep;\n\tcode_t* const VAR_20 = VAR_5->dec_codetab;\n\tcode_t* VAR_17;\n\n    if (VAR_7 == 0) {\n        goto after_loop;\n    }\n\nbegin:\n    {\n        WordType VAR_21;\n        GetNextCodeLZW();\n        VAR_17 = VAR_20 + VAR_21;\n        if (VAR_21 >= VAR_22)\n            goto code_above_or_equal_to_258;\n        if (VAR_21 < 256)\n            goto code_below_256;\n        if (VAR_21 == VAR_23)\n            goto after_loop;\n        goto code_clear;\n\ncode_below_256:\n        {\n            if (VAR_17 > VAR_13)\n                goto error_code;\n            VAR_13->next = VAR_15;\n            VAR_13->firstchar = VAR_15->firstchar;\n            VAR_13->length = VAR_15->length+1;\n            VAR_13->value = (uint8_t)VAR_21;\n            VAR_13->repeated = (bool)(VAR_15->repeated & (VAR_15->value == VAR_21));\n            if (++VAR_13 > VAR_14) {\n                if (++VAR_9 > VAR_24)\t\t/* COMMENT_12 */\n                    VAR_9 = VAR_24;\n                VAR_11 = MAXCODE(VAR_9);\n                VAR_14 = VAR_20 + VAR_11-1;\n                if( VAR_13 >= &VAR_20[VAR_25] )\n                {\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    VAR_13 = VAR_20 - 1;\n                }\n            }\n            VAR_15 = VAR_17;\n            *VAR_6++ = (uint8_t)VAR_21;\n            VAR_7--;\n            if (VAR_7 == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_above_or_equal_to_258:\n        {\n            /* COMMENT_17 */\n                                                   \n               \n\n            if (VAR_17 >= VAR_13)\n            {\n                if (VAR_17 != VAR_13)\n                    goto error_code;\n                VAR_13->value = VAR_15->firstchar;\n            }\n            else\n            {\n                VAR_13->value = VAR_17->firstchar;\n            }\n            VAR_13->repeated = (bool)(VAR_15->repeated & (VAR_15->value == VAR_13->value));\n            VAR_13->next = VAR_15;\n\n            VAR_13->firstchar = VAR_15->firstchar;\n            VAR_13->length = VAR_15->length+1;\n            if (++VAR_13 > VAR_14) {\n                if (++VAR_9 > VAR_24)\t\t/* COMMENT_12 */\n                    VAR_9 = VAR_24;\n                VAR_11 = MAXCODE(VAR_9);\n                VAR_14 = VAR_20 + VAR_11-1;\n                if (VAR_13 >= &VAR_20[VAR_25])\n                {\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    VAR_13 = VAR_20 - 1;\n                }\n            }\n            VAR_15 = VAR_17;\n\n            /* COMMENT_20 */\n                                                 \n                                                    \n               \n            /* COMMENT_24 */\n            unsigned short VAR_26 = VAR_17->length;\n\n            if (VAR_26 < 3) /* COMMENT_25 */\n            {\n                if (VAR_7 <= 2)\n                {\n                    if (VAR_7 == 2)\n                    {\n                        memcpy(VAR_6, &(VAR_17->firstchar), 2);\n                        VAR_6 += 2;\n                        VAR_7 -= 2;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                memcpy(VAR_6, &(VAR_17->firstchar), 2);\n                VAR_6 += 2;\n                VAR_7 -= 2;\n                goto begin; /* COMMENT_26 */\n            }\n\n            if (VAR_26 == 3)\n            {\n                if (VAR_7 <= 3)\n                {\n                    if (VAR_7 == 3)\n                    {\n                        VAR_6[0] = VAR_17->firstchar;\n                        VAR_6[1] = VAR_17->next->value;\n                        VAR_6[2] = VAR_17->value;\n                        VAR_6 += 3;\n                        VAR_7 -= 3;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                VAR_6[0] = VAR_17->firstchar;\n                VAR_6[1] = VAR_17->next->value;\n                VAR_6[2] = VAR_17->value;\n                VAR_6 += 3;\n                VAR_7 -= 3;\n                goto begin; /* COMMENT_26 */\n            }\n\n            if (VAR_26 > VAR_7)\n            {\n                goto too_short_buffer;\n            }\n\n            if (VAR_17->repeated)\n            {\n                memset(VAR_6, VAR_17->value, VAR_26);\n                VAR_6 += VAR_26;\n                VAR_7 -= VAR_26;\n                if (VAR_7 == 0)\n                    goto after_loop;\n                goto begin;\n            }\n\n            uint8_t* VAR_18 = VAR_6 + VAR_26;\n\n            assert(VAR_26 >= 4);\n\n            *--VAR_18 = VAR_17->value;\n            VAR_17 = VAR_17->next;\n            *--VAR_18 = VAR_17->value;\n            VAR_17 = VAR_17->next;\n            *--VAR_18 = VAR_17->value;\n            VAR_17 = VAR_17->next;\n            *--VAR_18 = VAR_17->value;\n            if (VAR_18 > VAR_6)\n            {\n                 do {\n                    VAR_17 = VAR_17->next;\n                    *--VAR_18 = VAR_17->value;\n                } while (VAR_18 > VAR_6);\n            }\n\n            assert(VAR_7 >= VAR_26);\n            VAR_6 += VAR_26;\n            VAR_7 -= VAR_26;\n            if (VAR_7 == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_clear:\n        {\n            VAR_13 = VAR_20 + VAR_22;\n            VAR_9 = VAR_27;\n            VAR_11 = MAXCODE(VAR_27);\n            VAR_14 = VAR_20 + VAR_11-1;\n            do {\n                GetNextCodeLZW();\n            } while (VAR_21 == VAR_28);\t/* COMMENT_27 */\n            if (VAR_21 == VAR_23)\n                goto after_loop;\n            if (VAR_21 > VAR_23) {\n                goto error_code;\n            }\n            *VAR_6++ = (uint8_t)VAR_21;\n            VAR_7--;\n            VAR_15 = VAR_20 + VAR_21;\n            if (VAR_7 == 0)\n                goto after_loop;\n            goto begin;\n        }\n    }\n\ntoo_short_buffer:\n    {\n        /* COMMENT_28 */\n                                                \n                                                \n                                               \n                                            \n           \n        VAR_5->dec_codep = VAR_17;\n        do {\n            VAR_17 = VAR_17->next;\n        } while (VAR_17->length > VAR_7);\n\n        VAR_5->dec_restart = VAR_7;\n        uint8_t* VAR_18 = VAR_6 + VAR_7;\n        do  {\n            *--VAR_18 = VAR_17->value;\n            VAR_17 = VAR_17->next;\n        }  while (--VAR_7);\n    }\n\nafter_loop:\n\tVAR_0->tif_rawcc -= (tmsize_t)((uint8_t*) VAR_8 - VAR_0->tif_rawcp );\n\tVAR_0->tif_rawcp = (uint8_t*) VAR_8;\n\tVAR_5->old_tif_rawcc = VAR_0->tif_rawcc;\n\tVAR_5->dec_bitsleft = VAR_19;\n\tVAR_5->lzw_nbits = (unsigned short) VAR_9;\n\tVAR_5->lzw_nextdata = VAR_12;\n\tVAR_5->lzw_nextbits = VAR_10;\n\tVAR_5->dec_nbitsmask = VAR_11;\n\tVAR_5->dec_oldcodep = VAR_15;\n\tVAR_5->dec_free_entp = VAR_13;\n\tVAR_5->dec_maxcodep = VAR_14;\n\n\tif (VAR_7 > 0) {\n\t\tTIFFErrorExt(VAR_0->tif_clientdata, VAR_4,\n\t\t\t\"Not enough data at scanline %\"VAR_29\" (short %\"VAR_30\" bytes)\",\n\t\t\t     VAR_0->tif_row, (uint64_t)VAR_7);\n\t\treturn (0);\n\t}\n\treturn (1);\n\nno_eoi:\n    TIFFErrorExt(VAR_0->tif_clientdata, VAR_4,\n                    \"LZWDecode: Strip %\"VAR_29\" not terminated with EOI code\",\n                    VAR_0->tif_curstrip);\n    return 0;\nerror_code:\n    TIFFErrorExt(VAR_0->tif_clientdata, VAR_0->tif_name, \"Using code not yet in table\");\n    return 0;\n}",
    "func_graph_path_before": "libtiff/b4e79bfa0c7d2d08f6f1e7ec38143fc8cb11394a/tif_lzw.c/vul/before/1.json",
    "func": "static int\nLZWDecode(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s)\n{\n\tstatic const char module[] = \"LZWDecode\";\n\tLZWCodecState *sp = DecoderState(tif);\n\tuint8_t *op = (uint8_t*) op0;\n\ttmsize_t occ = occ0;\n\tuint8_t *bp;\n\tlong nbits, nextbits, nbitsmask;\n\tWordType nextdata;\n\tcode_t *free_entp, *maxcodep, *oldcodep;\n\n\t(void) s;\n\tassert(sp != NULL);\n\tassert(sp->dec_codetab != NULL);\n\n\tif (sp->read_error) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Restart interrupted output operation.\n\t */\n\tif (sp->dec_restart) {\n\t\ttmsize_t residue;\n\n\t\tcode_t* codep = sp->dec_codep;\n\t\tresidue = codep->length - sp->dec_restart;\n\t\tif (residue > occ) {\n\t\t\t/*\n\t\t\t * Residue from previous decode is sufficient\n\t\t\t * to satisfy decode request.  Skip to the\n\t\t\t * start of the decoded string, place decoded\n\t\t\t * values in the output buffer, and return.\n\t\t\t */\n\t\t\tsp->dec_restart += occ;\n\t\t\tdo {\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--residue > occ && codep);\n\t\t\tif (codep) {\n\t\t\t\tuint8_t* tp = op + occ;\n\t\t\t\tdo {\n\t\t\t\t\t*--tp = codep->value;\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t} while (--occ && codep);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Residue satisfies only part of the decode request.\n\t\t */\n\t\top += residue;\n\t\tocc -= residue;\n\t\tuint8_t* tp = op;\n\t\tdo {\n\t\t\t*--tp = codep->value;\n\t\t\tcodep = codep->next;\n\t\t} while (--residue && codep);\n\t\tsp->dec_restart = 0;\n\t}\n\n\tbp = (uint8_t*)tif->tif_rawcp;\n\tsp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n\tuint64_t dec_bitsleft = sp->dec_bitsleft;\n\tnbits = sp->lzw_nbits;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tnbitsmask = sp->dec_nbitsmask;\n\toldcodep = sp->dec_oldcodep;\n\tfree_entp = sp->dec_free_entp;\n\tmaxcodep = sp->dec_maxcodep;\n\tcode_t* const dec_codetab = sp->dec_codetab;\n\tcode_t* codep;\n\n    if (occ == 0) {\n        goto after_loop;\n    }\n\nbegin:\n    {\n        WordType code;\n        GetNextCodeLZW();\n        codep = dec_codetab + code;\n        if (code >= CODE_FIRST)\n            goto code_above_or_equal_to_258;\n        if (code < 256)\n            goto code_below_256;\n        if (code == CODE_EOI)\n            goto after_loop;\n        goto code_clear;\n\ncode_below_256:\n        {\n            if (codep > free_entp)\n                goto error_code;\n            free_entp->next = oldcodep;\n            free_entp->firstchar = oldcodep->firstchar;\n            free_entp->length = oldcodep->length+1;\n            free_entp->value = (uint8_t)code;\n            free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == code));\n            if (++free_entp > maxcodep) {\n                if (++nbits > BITS_MAX)\t\t/* should not happen for a conformant encoder */\n                    nbits = BITS_MAX;\n                nbitsmask = MAXCODE(nbits);\n                maxcodep = dec_codetab + nbitsmask-1;\n                if( free_entp >= &dec_codetab[CSIZE] )\n                {\n                    /* At that point, the next valid states are either EOI or a */\n                    /* CODE_CLEAR. If a regular code is read, at the next */\n                    /* attempt at registering a new entry, we will error out */\n                    /* due to setting free_entp before any valid code */\n                    free_entp = dec_codetab - 1;\n                }\n            }\n            oldcodep = codep;\n            *op++ = (uint8_t)code;\n            occ--;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_above_or_equal_to_258:\n        {\n            /*\n             * Add the new entry to the code table.\n             */\n\n            if (codep >= free_entp)\n            {\n                if (codep != free_entp)\n                    goto error_code;\n                free_entp->value = oldcodep->firstchar;\n            }\n            else\n            {\n                free_entp->value = codep->firstchar;\n            }\n            free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == free_entp->value));\n            free_entp->next = oldcodep;\n\n            free_entp->firstchar = oldcodep->firstchar;\n            free_entp->length = oldcodep->length+1;\n            if (++free_entp > maxcodep) {\n                if (++nbits > BITS_MAX)\t\t/* should not happen for a conformant encoder */\n                    nbits = BITS_MAX;\n                nbitsmask = MAXCODE(nbits);\n                maxcodep = dec_codetab + nbitsmask-1;\n                if (free_entp >= &dec_codetab[CSIZE])\n                {\n                    /* At that point, the next valid states are either EOI or a */\n                    /* CODE_CLEAR. If a regular code is read, at the next */\n                    /* attempt at registering a new entry, we will error out */\n                    /* due to setting free_entp before any valid code */\n                    free_entp = dec_codetab - 1;\n                }\n            }\n            oldcodep = codep;\n\n            /*\n             * Code maps to a string, copy string\n             * value to output (written in reverse).\n             */\n            /* tiny bit faster on x86_64 to store in unsigned short than int */\n            unsigned short len = codep->length;\n\n            if (len < 3) /* equivalent to len == 2 given all other conditions */\n            {\n                if (occ <= 2)\n                {\n                    if (occ == 2)\n                    {\n                        memcpy(op, &(codep->firstchar), 2);\n                        op += 2;\n                        occ -= 2;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                memcpy(op, &(codep->firstchar), 2);\n                op += 2;\n                occ -= 2;\n                goto begin; /* we can save the comparison occ > 0 */\n            }\n\n            if (len == 3)\n            {\n                if (occ <= 3)\n                {\n                    if (occ == 3)\n                    {\n                        op[0] = codep->firstchar;\n                        op[1] = codep->next->value;\n                        op[2] = codep->value;\n                        op += 3;\n                        occ -= 3;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                op[0] = codep->firstchar;\n                op[1] = codep->next->value;\n                op[2] = codep->value;\n                op += 3;\n                occ -= 3;\n                goto begin; /* we can save the comparison occ > 0 */\n            }\n\n            if (len > occ)\n            {\n                goto too_short_buffer;\n            }\n\n            if (codep->repeated)\n            {\n                memset(op, codep->value, len);\n                op += len;\n                occ -= len;\n                if (occ == 0)\n                    goto after_loop;\n                goto begin;\n            }\n\n            uint8_t* tp = op + len;\n\n            assert(len >= 4);\n\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            if (tp > op)\n            {\n                 do {\n                    codep = codep->next;\n                    *--tp = codep->value;\n                } while (tp > op);\n            }\n\n            assert(occ >= len);\n            op += len;\n            occ -= len;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_clear:\n        {\n            free_entp = dec_codetab + CODE_FIRST;\n            nbits = BITS_MIN;\n            nbitsmask = MAXCODE(BITS_MIN);\n            maxcodep = dec_codetab + nbitsmask-1;\n            do {\n                GetNextCodeLZW();\n            } while (code == CODE_CLEAR);\t/* consecutive CODE_CLEAR codes */\n            if (code == CODE_EOI)\n                goto after_loop;\n            if (code > CODE_EOI) {\n                goto error_code;\n            }\n            *op++ = (uint8_t)code;\n            occ--;\n            oldcodep = dec_codetab + code;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n    }\n\ntoo_short_buffer:\n    {\n        /*\n         * String is too long for decode buffer,\n         * locate portion that will fit, copy to\n         * the decode buffer, and setup restart\n         * logic for the next decoding call.\n         */\n        sp->dec_codep = codep;\n        do {\n            codep = codep->next;\n        } while (codep->length > occ);\n\n        sp->dec_restart = occ;\n        uint8_t* tp = op + occ;\n        do  {\n            *--tp = codep->value;\n            codep = codep->next;\n        }  while (--occ);\n    }\n\nafter_loop:\n\ttif->tif_rawcc -= (tmsize_t)((uint8_t*) bp - tif->tif_rawcp );\n\ttif->tif_rawcp = (uint8_t*) bp;\n\tsp->old_tif_rawcc = tif->tif_rawcc;\n\tsp->dec_bitsleft = dec_bitsleft;\n\tsp->lzw_nbits = (unsigned short) nbits;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->dec_nbitsmask = nbitsmask;\n\tsp->dec_oldcodep = oldcodep;\n\tsp->dec_free_entp = free_entp;\n\tsp->dec_maxcodep = maxcodep;\n\n\tif (occ > 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %\"PRIu32\" (short %\"PRIu64\" bytes)\",\n\t\t\t     tif->tif_row, (uint64_t)occ);\n\t\treturn (0);\n\t}\n\treturn (1);\n\nno_eoi:\n    TIFFErrorExt(tif->tif_clientdata, module,\n                    \"LZWDecode: Strip %\"PRIu32\" not terminated with EOI code\",\n                    tif->tif_curstrip);\n    return 0;\nerror_code:\n    sp->read_error = 1;\n    TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Using code not yet in table\");\n    return 0;\n}",
    "abstract_func": "static int\nLZWDecode(TIFF* VAR_0, uint8_t* VAR_1, tmsize_t VAR_2, uint16_t VAR_3)\n{\n\tstatic const char VAR_4[] = \"LZWDecode\";\n\tLZWCodecState *VAR_5 = DecoderState(VAR_0);\n\tuint8_t *VAR_6 = (uint8_t*) VAR_1;\n\ttmsize_t VAR_7 = VAR_2;\n\tuint8_t *VAR_8;\n\tlong VAR_9, VAR_10, VAR_11;\n\tWordType VAR_12;\n\tcode_t *VAR_13, *VAR_14, *VAR_15;\n\n\t(void) VAR_3;\n\tassert(VAR_5 != NULL);\n\tassert(VAR_5->dec_codetab != NULL);\n\n\tif (VAR_5->read_error) {\n\t\treturn 0;\n\t}\n\n\t/* COMMENT_0 */\n                                         \n    \n\tif (VAR_5->dec_restart) {\n\t\ttmsize_t VAR_16;\n\n\t\tcode_t* VAR_17 = VAR_5->dec_codep;\n\t\tVAR_16 = VAR_17->length - VAR_5->dec_restart;\n\t\tif (VAR_16 > VAR_7) {\n\t\t\t/* COMMENT_3 */\n                                                \n                                             \n                                                \n                                              \n      \n\t\t\tVAR_5->dec_restart += VAR_7;\n\t\t\tdo {\n\t\t\t\tVAR_17 = VAR_17->next;\n\t\t\t} while (--VAR_16 > VAR_7 && VAR_17);\n\t\t\tif (VAR_17) {\n\t\t\t\tuint8_t* VAR_18 = VAR_6 + VAR_7;\n\t\t\t\tdo {\n\t\t\t\t\t*--VAR_18 = VAR_17->value;\n\t\t\t\t\tVAR_17 = VAR_17->next;\n\t\t\t\t} while (--VAR_7 && VAR_17);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/* COMMENT_9 */\n                                                       \n     \n\t\tVAR_6 += VAR_16;\n\t\tVAR_7 -= VAR_16;\n\t\tuint8_t* VAR_18 = VAR_6;\n\t\tdo {\n\t\t\t*--VAR_18 = VAR_17->value;\n\t\t\tVAR_17 = VAR_17->next;\n\t\t} while (--VAR_16 && VAR_17);\n\t\tVAR_5->dec_restart = 0;\n\t}\n\n\tVAR_8 = (uint8_t*)VAR_0->tif_rawcp;\n\tVAR_5->dec_bitsleft += (((uint64_t)VAR_0->tif_rawcc - VAR_5->old_tif_rawcc) << 3);\n\tuint64_t VAR_19 = VAR_5->dec_bitsleft;\n\tVAR_9 = VAR_5->lzw_nbits;\n\tVAR_12 = VAR_5->lzw_nextdata;\n\tVAR_10 = VAR_5->lzw_nextbits;\n\tVAR_11 = VAR_5->dec_nbitsmask;\n\tVAR_15 = VAR_5->dec_oldcodep;\n\tVAR_13 = VAR_5->dec_free_entp;\n\tVAR_14 = VAR_5->dec_maxcodep;\n\tcode_t* const VAR_20 = VAR_5->dec_codetab;\n\tcode_t* VAR_17;\n\n    if (VAR_7 == 0) {\n        goto after_loop;\n    }\n\nbegin:\n    {\n        WordType VAR_21;\n        GetNextCodeLZW();\n        VAR_17 = VAR_20 + VAR_21;\n        if (VAR_21 >= VAR_22)\n            goto code_above_or_equal_to_258;\n        if (VAR_21 < 256)\n            goto code_below_256;\n        if (VAR_21 == VAR_23)\n            goto after_loop;\n        goto code_clear;\n\ncode_below_256:\n        {\n            if (VAR_17 > VAR_13)\n                goto error_code;\n            VAR_13->next = VAR_15;\n            VAR_13->firstchar = VAR_15->firstchar;\n            VAR_13->length = VAR_15->length+1;\n            VAR_13->value = (uint8_t)VAR_21;\n            VAR_13->repeated = (bool)(VAR_15->repeated & (VAR_15->value == VAR_21));\n            if (++VAR_13 > VAR_14) {\n                if (++VAR_9 > VAR_24)\t\t/* COMMENT_12 */\n                    VAR_9 = VAR_24;\n                VAR_11 = MAXCODE(VAR_9);\n                VAR_14 = VAR_20 + VAR_11-1;\n                if( VAR_13 >= &VAR_20[VAR_25] )\n                {\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    VAR_13 = VAR_20 - 1;\n                }\n            }\n            VAR_15 = VAR_17;\n            *VAR_6++ = (uint8_t)VAR_21;\n            VAR_7--;\n            if (VAR_7 == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_above_or_equal_to_258:\n        {\n            /* COMMENT_17 */\n                                                   \n               \n\n            if (VAR_17 >= VAR_13)\n            {\n                if (VAR_17 != VAR_13)\n                    goto error_code;\n                VAR_13->value = VAR_15->firstchar;\n            }\n            else\n            {\n                VAR_13->value = VAR_17->firstchar;\n            }\n            VAR_13->repeated = (bool)(VAR_15->repeated & (VAR_15->value == VAR_13->value));\n            VAR_13->next = VAR_15;\n\n            VAR_13->firstchar = VAR_15->firstchar;\n            VAR_13->length = VAR_15->length+1;\n            if (++VAR_13 > VAR_14) {\n                if (++VAR_9 > VAR_24)\t\t/* COMMENT_12 */\n                    VAR_9 = VAR_24;\n                VAR_11 = MAXCODE(VAR_9);\n                VAR_14 = VAR_20 + VAR_11-1;\n                if (VAR_13 >= &VAR_20[VAR_25])\n                {\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    VAR_13 = VAR_20 - 1;\n                }\n            }\n            VAR_15 = VAR_17;\n\n            /* COMMENT_20 */\n                                                 \n                                                    \n               \n            /* COMMENT_24 */\n            unsigned short VAR_26 = VAR_17->length;\n\n            if (VAR_26 < 3) /* COMMENT_25 */\n            {\n                if (VAR_7 <= 2)\n                {\n                    if (VAR_7 == 2)\n                    {\n                        memcpy(VAR_6, &(VAR_17->firstchar), 2);\n                        VAR_6 += 2;\n                        VAR_7 -= 2;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                memcpy(VAR_6, &(VAR_17->firstchar), 2);\n                VAR_6 += 2;\n                VAR_7 -= 2;\n                goto begin; /* COMMENT_26 */\n            }\n\n            if (VAR_26 == 3)\n            {\n                if (VAR_7 <= 3)\n                {\n                    if (VAR_7 == 3)\n                    {\n                        VAR_6[0] = VAR_17->firstchar;\n                        VAR_6[1] = VAR_17->next->value;\n                        VAR_6[2] = VAR_17->value;\n                        VAR_6 += 3;\n                        VAR_7 -= 3;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                VAR_6[0] = VAR_17->firstchar;\n                VAR_6[1] = VAR_17->next->value;\n                VAR_6[2] = VAR_17->value;\n                VAR_6 += 3;\n                VAR_7 -= 3;\n                goto begin; /* COMMENT_26 */\n            }\n\n            if (VAR_26 > VAR_7)\n            {\n                goto too_short_buffer;\n            }\n\n            if (VAR_17->repeated)\n            {\n                memset(VAR_6, VAR_17->value, VAR_26);\n                VAR_6 += VAR_26;\n                VAR_7 -= VAR_26;\n                if (VAR_7 == 0)\n                    goto after_loop;\n                goto begin;\n            }\n\n            uint8_t* VAR_18 = VAR_6 + VAR_26;\n\n            assert(VAR_26 >= 4);\n\n            *--VAR_18 = VAR_17->value;\n            VAR_17 = VAR_17->next;\n            *--VAR_18 = VAR_17->value;\n            VAR_17 = VAR_17->next;\n            *--VAR_18 = VAR_17->value;\n            VAR_17 = VAR_17->next;\n            *--VAR_18 = VAR_17->value;\n            if (VAR_18 > VAR_6)\n            {\n                 do {\n                    VAR_17 = VAR_17->next;\n                    *--VAR_18 = VAR_17->value;\n                } while (VAR_18 > VAR_6);\n            }\n\n            assert(VAR_7 >= VAR_26);\n            VAR_6 += VAR_26;\n            VAR_7 -= VAR_26;\n            if (VAR_7 == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_clear:\n        {\n            VAR_13 = VAR_20 + VAR_22;\n            VAR_9 = VAR_27;\n            VAR_11 = MAXCODE(VAR_27);\n            VAR_14 = VAR_20 + VAR_11-1;\n            do {\n                GetNextCodeLZW();\n            } while (VAR_21 == VAR_28);\t/* COMMENT_27 */\n            if (VAR_21 == VAR_23)\n                goto after_loop;\n            if (VAR_21 > VAR_23) {\n                goto error_code;\n            }\n            *VAR_6++ = (uint8_t)VAR_21;\n            VAR_7--;\n            VAR_15 = VAR_20 + VAR_21;\n            if (VAR_7 == 0)\n                goto after_loop;\n            goto begin;\n        }\n    }\n\ntoo_short_buffer:\n    {\n        /* COMMENT_28 */\n                                                \n                                                \n                                               \n                                            \n           \n        VAR_5->dec_codep = VAR_17;\n        do {\n            VAR_17 = VAR_17->next;\n        } while (VAR_17->length > VAR_7);\n\n        VAR_5->dec_restart = VAR_7;\n        uint8_t* VAR_18 = VAR_6 + VAR_7;\n        do  {\n            *--VAR_18 = VAR_17->value;\n            VAR_17 = VAR_17->next;\n        }  while (--VAR_7);\n    }\n\nafter_loop:\n\tVAR_0->tif_rawcc -= (tmsize_t)((uint8_t*) VAR_8 - VAR_0->tif_rawcp );\n\tVAR_0->tif_rawcp = (uint8_t*) VAR_8;\n\tVAR_5->old_tif_rawcc = VAR_0->tif_rawcc;\n\tVAR_5->dec_bitsleft = VAR_19;\n\tVAR_5->lzw_nbits = (unsigned short) VAR_9;\n\tVAR_5->lzw_nextdata = VAR_12;\n\tVAR_5->lzw_nextbits = VAR_10;\n\tVAR_5->dec_nbitsmask = VAR_11;\n\tVAR_5->dec_oldcodep = VAR_15;\n\tVAR_5->dec_free_entp = VAR_13;\n\tVAR_5->dec_maxcodep = VAR_14;\n\n\tif (VAR_7 > 0) {\n\t\tTIFFErrorExt(VAR_0->tif_clientdata, VAR_4,\n\t\t\t\"Not enough data at scanline %\"VAR_29\" (short %\"VAR_30\" bytes)\",\n\t\t\t     VAR_0->tif_row, (uint64_t)VAR_7);\n\t\treturn (0);\n\t}\n\treturn (1);\n\nno_eoi:\n    TIFFErrorExt(VAR_0->tif_clientdata, VAR_4,\n                    \"LZWDecode: Strip %\"VAR_29\" not terminated with EOI code\",\n                    VAR_0->tif_curstrip);\n    return 0;\nerror_code:\n    VAR_5->read_error = 1;\n    TIFFErrorExt(VAR_0->tif_clientdata, VAR_0->tif_name, \"Using code not yet in table\");\n    return 0;\n}",
    "func_graph_path": "libtiff/b4e79bfa0c7d2d08f6f1e7ec38143fc8cb11394a/tif_lzw.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,11 @@\n \n \t(void) s;\n \tassert(sp != NULL);\n-        assert(sp->dec_codetab != NULL);\n+\tassert(sp->dec_codetab != NULL);\n+\n+\tif (sp->read_error) {\n+\t\treturn 0;\n+\t}\n \n \t/*\n \t * Restart interrupted output operation.\n@@ -317,6 +321,7 @@\n                     tif->tif_curstrip);\n     return 0;\n error_code:\n+    sp->read_error = 1;\n     TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Using code not yet in table\");\n     return 0;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "        assert(sp->dec_codetab != NULL);"
        ],
        "added_lines": [
            "\tassert(sp->dec_codetab != NULL);",
            "",
            "\tif (sp->read_error) {",
            "\t\treturn 0;",
            "\t}",
            "    sp->read_error = 1;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}