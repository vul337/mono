{
    "cve_id": "CVE-2016-3823",
    "cwe_ids": [
        "CWE-119",
        "CWE-200"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "android",
    "commit_msg": "DO NOT MERGE mm-video-v4l2: venc: add checks before accessing heap pointers\n\nHeap pointers do not point to user virtual addresses in case\nof secure session.\nSet them to NULL and add checks to avoid accesing them\n\nBug: 28815329\nBug: 28920116\n\nChange-Id: I94fd5808e753b58654d65e175d3857ef46ffba26\n",
    "commit_hash": "7558d03e6498e970b761aa44fff6b2c659202d95",
    "git_url": "https://android.googlesource.com/platform/hardware/qcom/media/+/7558d03e6498e970b761aa44fff6b2c659202d95",
    "file_path": "mm-video-v4l2/vidc/venc/src/omx_video_encoder.cpp",
    "func_name": "omx_venc::async_message_process",
    "func_before": "int omx_venc::async_message_process (void *context, void* message)\n{\n    omx_video* omx = NULL;\n    struct venc_msg *m_sVenc_msg = NULL;\n    OMX_BUFFERHEADERTYPE* omxhdr = NULL;\n    struct venc_buffer *temp_buff = NULL;\n\n    if (context == NULL || message == NULL) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_venc::async_message_process invalid i/p params\");\n        return -1;\n    }\n    m_sVenc_msg = (struct venc_msg *)message;\n\n    omx = reinterpret_cast<omx_video*>(context);\n\n    if (m_sVenc_msg->statuscode != VEN_S_SUCCESS) {\n        DEBUG_PRINT_ERROR(\"ERROR: async_msg_process() - Error statuscode = %lu\",\n                m_sVenc_msg->statuscode);\n        if(m_sVenc_msg->msgcode == VEN_MSG_HW_OVERLOAD) {\n            omx->omx_report_hw_overload();\n        } else\n        omx->omx_report_error();\n    }\n\n    DEBUG_PRINT_LOW(\"omx_venc::async_message_process- msgcode = %lu\",\n            m_sVenc_msg->msgcode);\n    switch (m_sVenc_msg->msgcode) {\n        case VEN_MSG_START:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_START_DONE);\n            break;\n        case VEN_MSG_STOP:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_STOP_DONE);\n            break;\n        case VEN_MSG_RESUME:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_RESUME_DONE);\n            break;\n        case VEN_MSG_PAUSE:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_PAUSE_DONE);\n            break;\n        case VEN_MSG_FLUSH_INPUT_DONE:\n\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_EVENT_INPUT_FLUSH);\n            break;\n        case VEN_MSG_FLUSH_OUPUT_DONE:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_EVENT_OUTPUT_FLUSH);\n            break;\n        case VEN_MSG_INPUT_BUFFER_DONE:\n            omxhdr = (OMX_BUFFERHEADERTYPE* )\\\n                     m_sVenc_msg->buf.clientdata;\n\n            if (omxhdr == NULL ||\n                    (((OMX_U32)(omxhdr - omx->m_inp_mem_ptr) > omx->m_sInPortDef.nBufferCountActual) &&\n                     ((OMX_U32)(omxhdr - omx->meta_buffer_hdr) > omx->m_sInPortDef.nBufferCountActual))) {\n                omxhdr = NULL;\n                m_sVenc_msg->statuscode = VEN_S_EFAIL;\n            }\n\n#ifdef _ANDROID_ICS_\n            omx->omx_release_meta_buffer(omxhdr);\n#endif\n            omx->post_event ((unsigned long)omxhdr,m_sVenc_msg->statuscode,\n                    OMX_COMPONENT_GENERATE_EBD);\n            break;\n        case VEN_MSG_OUTPUT_BUFFER_DONE:\n            omxhdr = (OMX_BUFFERHEADERTYPE*)m_sVenc_msg->buf.clientdata;\n\n            if ( (omxhdr != NULL) &&\n                    ((OMX_U32)(omxhdr - omx->m_out_mem_ptr)  < omx->m_sOutPortDef.nBufferCountActual)) {\n                if (m_sVenc_msg->buf.len <=  omxhdr->nAllocLen) {\n                    omxhdr->nFilledLen = m_sVenc_msg->buf.len;\n                    omxhdr->nOffset = m_sVenc_msg->buf.offset;\n                    omxhdr->nTimeStamp = m_sVenc_msg->buf.timestamp;\n                    DEBUG_PRINT_LOW(\"o/p TS = %u\", (unsigned int)m_sVenc_msg->buf.timestamp);\n                    omxhdr->nFlags = m_sVenc_msg->buf.flags;\n\n                    /*Use buffer case*/\n                    if (omx->output_use_buffer && !omx->m_use_output_pmem) {\n                        DEBUG_PRINT_LOW(\"memcpy() for o/p Heap UseBuffer\");\n                        memcpy(omxhdr->pBuffer,\n                                (m_sVenc_msg->buf.ptrbuffer),\n                                m_sVenc_msg->buf.len);\n                    }\n                } else {\n                    omxhdr->nFilledLen = 0;\n                }\n\n            } else {\n                omxhdr = NULL;\n                m_sVenc_msg->statuscode = VEN_S_EFAIL;\n            }\n            omx->post_event ((unsigned long)omxhdr,m_sVenc_msg->statuscode,\n                    OMX_COMPONENT_GENERATE_FBD);\n            break;\n        case VEN_MSG_NEED_OUTPUT_BUFFER:\n            //TBD what action needs to be done here??\n            break;\n#ifndef _MSM8974_\n        case VEN_MSG_LTRUSE_FAILED:\n            DEBUG_PRINT_ERROR(\"LTRUSE Failed!\");\n            omx->post_event (NULL,m_sVenc_msg->statuscode,\n                    OMX_COMPONENT_GENERATE_LTRUSE_FAILED);\n            break;\n#endif\n        default:\n            DEBUG_PRINT_HIGH(\"Unknown msg received : %lu\", m_sVenc_msg->msgcode);\n            break;\n    }\n    return 0;\n}",
    "abstract_func_before": "int omx_venc::async_message_process (void *VAR_0, void* VAR_1)\n{\n    omx_video* VAR_2 = NULL;\n    struct venc_msg *VAR_3 = NULL;\n    OMX_BUFFERHEADERTYPE* VAR_4 = NULL;\n    struct venc_buffer *VAR_5 = NULL;\n\n    if (VAR_0 == NULL || VAR_1 == NULL) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_venc::async_message_process invalid i/p params\");\n        return -1;\n    }\n    VAR_3 = (struct venc_msg *)VAR_1;\n\n    VAR_2 = VAR_6<omx_video*>(VAR_0);\n\n    if (VAR_3->statuscode != VAR_7) {\n        DEBUG_PRINT_ERROR(\"ERROR: async_msg_process() - Error statuscode = %lu\",\n                VAR_3->statuscode);\n        if(VAR_3->msgcode == VAR_8) {\n            VAR_2->omx_report_hw_overload();\n        } else\n        VAR_2->omx_report_error();\n    }\n\n    DEBUG_PRINT_LOW(\"omx_venc::async_message_process- msgcode = %lu\",\n            VAR_3->msgcode);\n    switch (VAR_3->msgcode) {\n        case VAR_9:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_10);\n            break;\n        case VAR_11:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_12);\n            break;\n        case VAR_13:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_14);\n            break;\n        case VAR_15:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_16);\n            break;\n        case VAR_17:\n\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_18);\n            break;\n        case VAR_19:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_20);\n            break;\n        case VAR_21:\n            VAR_4 = (OMX_BUFFERHEADERTYPE* )\\\n                     VAR_3->buf.clientdata;\n\n            if (VAR_4 == NULL ||\n                    (((VAR_22)(VAR_4 - VAR_2->m_inp_mem_ptr) > VAR_2->m_sInPortDef.nBufferCountActual) &&\n                     ((VAR_22)(VAR_4 - VAR_2->meta_buffer_hdr) > VAR_2->m_sInPortDef.nBufferCountActual))) {\n                VAR_4 = NULL;\n                VAR_3->statuscode = VAR_23;\n            }\n\n#ifdef VAR_24\n            VAR_2->omx_release_meta_buffer(VAR_4);\n#endif\n            VAR_2->post_event ((unsigned long)VAR_4,VAR_3->statuscode,\n                    VAR_25);\n            break;\n        case VAR_26:\n            VAR_4 = (OMX_BUFFERHEADERTYPE*)VAR_3->buf.clientdata;\n\n            if ( (VAR_4 != NULL) &&\n                    ((VAR_22)(VAR_4 - VAR_2->m_out_mem_ptr)  < VAR_2->m_sOutPortDef.nBufferCountActual)) {\n                if (VAR_3->buf.len <=  VAR_4->nAllocLen) {\n                    VAR_4->nFilledLen = VAR_3->buf.len;\n                    VAR_4->nOffset = VAR_3->buf.offset;\n                    VAR_4->nTimeStamp = VAR_3->buf.timestamp;\n                    DEBUG_PRINT_LOW(\"o/p TS = %u\", (unsigned int)VAR_3->buf.timestamp);\n                    VAR_4->nFlags = VAR_3->buf.flags;\n\n                    /* COMMENT_0 */\n                    if (VAR_2->output_use_buffer && !VAR_2->m_use_output_pmem) {\n                        DEBUG_PRINT_LOW(\"memcpy() for o/p Heap UseBuffer\");\n                        memcpy(VAR_4->pBuffer,\n                                (VAR_3->buf.ptrbuffer),\n                                VAR_3->buf.len);\n                    }\n                } else {\n                    VAR_4->nFilledLen = 0;\n                }\n\n            } else {\n                VAR_4 = NULL;\n                VAR_3->statuscode = VAR_23;\n            }\n            VAR_2->post_event ((unsigned long)VAR_4,VAR_3->statuscode,\n                    VAR_27);\n            break;\n        case VAR_28:\n            /* COMMENT_1 */\n            break;\n#ifndef VAR_29\n        case VAR_30:\n            DEBUG_PRINT_ERROR(\"LTRUSE Failed!\");\n            VAR_2->post_event (NULL,VAR_3->statuscode,\n                    VAR_31);\n            break;\n#endif\n        default:\n            DEBUG_PRINT_HIGH(\"Unknown msg received : %lu\", VAR_3->msgcode);\n            break;\n    }\n    return 0;\n}",
    "func_graph_path_before": "android/7558d03e6498e970b761aa44fff6b2c659202d95/omx_video_encoder.cpp/vul/before/0.json",
    "func": "int omx_venc::async_message_process (void *context, void* message)\n{\n    omx_video* omx = NULL;\n    struct venc_msg *m_sVenc_msg = NULL;\n    OMX_BUFFERHEADERTYPE* omxhdr = NULL;\n    struct venc_buffer *temp_buff = NULL;\n\n    if (context == NULL || message == NULL) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_venc::async_message_process invalid i/p params\");\n        return -1;\n    }\n    m_sVenc_msg = (struct venc_msg *)message;\n\n    omx = reinterpret_cast<omx_video*>(context);\n\n    if (m_sVenc_msg->statuscode != VEN_S_SUCCESS) {\n        DEBUG_PRINT_ERROR(\"ERROR: async_msg_process() - Error statuscode = %lu\",\n                m_sVenc_msg->statuscode);\n        if(m_sVenc_msg->msgcode == VEN_MSG_HW_OVERLOAD) {\n            omx->omx_report_hw_overload();\n        } else\n        omx->omx_report_error();\n    }\n\n    DEBUG_PRINT_LOW(\"omx_venc::async_message_process- msgcode = %lu\",\n            m_sVenc_msg->msgcode);\n    switch (m_sVenc_msg->msgcode) {\n        case VEN_MSG_START:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_START_DONE);\n            break;\n        case VEN_MSG_STOP:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_STOP_DONE);\n            break;\n        case VEN_MSG_RESUME:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_RESUME_DONE);\n            break;\n        case VEN_MSG_PAUSE:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_PAUSE_DONE);\n            break;\n        case VEN_MSG_FLUSH_INPUT_DONE:\n\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_EVENT_INPUT_FLUSH);\n            break;\n        case VEN_MSG_FLUSH_OUPUT_DONE:\n            omx->post_event (0,m_sVenc_msg->statuscode,\\\n                    OMX_COMPONENT_GENERATE_EVENT_OUTPUT_FLUSH);\n            break;\n        case VEN_MSG_INPUT_BUFFER_DONE:\n            omxhdr = (OMX_BUFFERHEADERTYPE* )\\\n                     m_sVenc_msg->buf.clientdata;\n\n            if (omxhdr == NULL ||\n                    (((OMX_U32)(omxhdr - omx->m_inp_mem_ptr) > omx->m_sInPortDef.nBufferCountActual) &&\n                     ((OMX_U32)(omxhdr - omx->meta_buffer_hdr) > omx->m_sInPortDef.nBufferCountActual))) {\n                omxhdr = NULL;\n                m_sVenc_msg->statuscode = VEN_S_EFAIL;\n            }\n\n#ifdef _ANDROID_ICS_\n            omx->omx_release_meta_buffer(omxhdr);\n#endif\n            omx->post_event ((unsigned long)omxhdr,m_sVenc_msg->statuscode,\n                    OMX_COMPONENT_GENERATE_EBD);\n            break;\n        case VEN_MSG_OUTPUT_BUFFER_DONE:\n            omxhdr = (OMX_BUFFERHEADERTYPE*)m_sVenc_msg->buf.clientdata;\n\n            if ( (omxhdr != NULL) &&\n                    ((OMX_U32)(omxhdr - omx->m_out_mem_ptr)  < omx->m_sOutPortDef.nBufferCountActual)) {\n                if (m_sVenc_msg->buf.len <=  omxhdr->nAllocLen) {\n                    omxhdr->nFilledLen = m_sVenc_msg->buf.len;\n                    omxhdr->nOffset = m_sVenc_msg->buf.offset;\n                    omxhdr->nTimeStamp = m_sVenc_msg->buf.timestamp;\n                    DEBUG_PRINT_LOW(\"o/p TS = %u\", (unsigned int)m_sVenc_msg->buf.timestamp);\n                    omxhdr->nFlags = m_sVenc_msg->buf.flags;\n\n                    /*Use buffer case*/\n                    if (omx->output_use_buffer && !omx->m_use_output_pmem && !omx->is_secure_session()) {\n                        DEBUG_PRINT_LOW(\"memcpy() for o/p Heap UseBuffer\");\n                        memcpy(omxhdr->pBuffer,\n                                (m_sVenc_msg->buf.ptrbuffer),\n                                m_sVenc_msg->buf.len);\n                    }\n                } else {\n                    omxhdr->nFilledLen = 0;\n                }\n\n            } else {\n                omxhdr = NULL;\n                m_sVenc_msg->statuscode = VEN_S_EFAIL;\n            }\n            omx->post_event ((unsigned long)omxhdr,m_sVenc_msg->statuscode,\n                    OMX_COMPONENT_GENERATE_FBD);\n            break;\n        case VEN_MSG_NEED_OUTPUT_BUFFER:\n            //TBD what action needs to be done here??\n            break;\n#ifndef _MSM8974_\n        case VEN_MSG_LTRUSE_FAILED:\n            DEBUG_PRINT_ERROR(\"LTRUSE Failed!\");\n            omx->post_event (NULL,m_sVenc_msg->statuscode,\n                    OMX_COMPONENT_GENERATE_LTRUSE_FAILED);\n            break;\n#endif\n        default:\n            DEBUG_PRINT_HIGH(\"Unknown msg received : %lu\", m_sVenc_msg->msgcode);\n            break;\n    }\n    return 0;\n}",
    "abstract_func": "int omx_venc::async_message_process (void *VAR_0, void* VAR_1)\n{\n    omx_video* VAR_2 = NULL;\n    struct venc_msg *VAR_3 = NULL;\n    OMX_BUFFERHEADERTYPE* VAR_4 = NULL;\n    struct venc_buffer *VAR_5 = NULL;\n\n    if (VAR_0 == NULL || VAR_1 == NULL) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_venc::async_message_process invalid i/p params\");\n        return -1;\n    }\n    VAR_3 = (struct venc_msg *)VAR_1;\n\n    VAR_2 = VAR_6<omx_video*>(VAR_0);\n\n    if (VAR_3->statuscode != VAR_7) {\n        DEBUG_PRINT_ERROR(\"ERROR: async_msg_process() - Error statuscode = %lu\",\n                VAR_3->statuscode);\n        if(VAR_3->msgcode == VAR_8) {\n            VAR_2->omx_report_hw_overload();\n        } else\n        VAR_2->omx_report_error();\n    }\n\n    DEBUG_PRINT_LOW(\"omx_venc::async_message_process- msgcode = %lu\",\n            VAR_3->msgcode);\n    switch (VAR_3->msgcode) {\n        case VAR_9:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_10);\n            break;\n        case VAR_11:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_12);\n            break;\n        case VAR_13:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_14);\n            break;\n        case VAR_15:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_16);\n            break;\n        case VAR_17:\n\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_18);\n            break;\n        case VAR_19:\n            VAR_2->post_event (0,VAR_3->statuscode,\\\n                    VAR_20);\n            break;\n        case VAR_21:\n            VAR_4 = (OMX_BUFFERHEADERTYPE* )\\\n                     VAR_3->buf.clientdata;\n\n            if (VAR_4 == NULL ||\n                    (((VAR_22)(VAR_4 - VAR_2->m_inp_mem_ptr) > VAR_2->m_sInPortDef.nBufferCountActual) &&\n                     ((VAR_22)(VAR_4 - VAR_2->meta_buffer_hdr) > VAR_2->m_sInPortDef.nBufferCountActual))) {\n                VAR_4 = NULL;\n                VAR_3->statuscode = VAR_23;\n            }\n\n#ifdef VAR_24\n            VAR_2->omx_release_meta_buffer(VAR_4);\n#endif\n            VAR_2->post_event ((unsigned long)VAR_4,VAR_3->statuscode,\n                    VAR_25);\n            break;\n        case VAR_26:\n            VAR_4 = (OMX_BUFFERHEADERTYPE*)VAR_3->buf.clientdata;\n\n            if ( (VAR_4 != NULL) &&\n                    ((VAR_22)(VAR_4 - VAR_2->m_out_mem_ptr)  < VAR_2->m_sOutPortDef.nBufferCountActual)) {\n                if (VAR_3->buf.len <=  VAR_4->nAllocLen) {\n                    VAR_4->nFilledLen = VAR_3->buf.len;\n                    VAR_4->nOffset = VAR_3->buf.offset;\n                    VAR_4->nTimeStamp = VAR_3->buf.timestamp;\n                    DEBUG_PRINT_LOW(\"o/p TS = %u\", (unsigned int)VAR_3->buf.timestamp);\n                    VAR_4->nFlags = VAR_3->buf.flags;\n\n                    /* COMMENT_0 */\n                    if (VAR_2->output_use_buffer && !VAR_2->m_use_output_pmem && !VAR_2->is_secure_session()) {\n                        DEBUG_PRINT_LOW(\"memcpy() for o/p Heap UseBuffer\");\n                        memcpy(VAR_4->pBuffer,\n                                (VAR_3->buf.ptrbuffer),\n                                VAR_3->buf.len);\n                    }\n                } else {\n                    VAR_4->nFilledLen = 0;\n                }\n\n            } else {\n                VAR_4 = NULL;\n                VAR_3->statuscode = VAR_23;\n            }\n            VAR_2->post_event ((unsigned long)VAR_4,VAR_3->statuscode,\n                    VAR_27);\n            break;\n        case VAR_28:\n            /* COMMENT_1 */\n            break;\n#ifndef VAR_29\n        case VAR_30:\n            DEBUG_PRINT_ERROR(\"LTRUSE Failed!\");\n            VAR_2->post_event (NULL,VAR_3->statuscode,\n                    VAR_31);\n            break;\n#endif\n        default:\n            DEBUG_PRINT_HIGH(\"Unknown msg received : %lu\", VAR_3->msgcode);\n            break;\n    }\n    return 0;\n}",
    "func_graph_path": "android/7558d03e6498e970b761aa44fff6b2c659202d95/omx_video_encoder.cpp/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -80,7 +80,7 @@\n                     omxhdr->nFlags = m_sVenc_msg->buf.flags;\n \n                     /*Use buffer case*/\n-                    if (omx->output_use_buffer && !omx->m_use_output_pmem) {\n+                    if (omx->output_use_buffer && !omx->m_use_output_pmem && !omx->is_secure_session()) {\n                         DEBUG_PRINT_LOW(\"memcpy() for o/p Heap UseBuffer\");\n                         memcpy(omxhdr->pBuffer,\n                                 (m_sVenc_msg->buf.ptrbuffer),",
    "diff_line_info": {
        "deleted_lines": [
            "                    if (omx->output_use_buffer && !omx->m_use_output_pmem) {"
        ],
        "added_lines": [
            "                    if (omx->output_use_buffer && !omx->m_use_output_pmem && !omx->is_secure_session()) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}