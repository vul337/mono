{
    "cve_id": "CVE-2014-9922",
    "cwe_ids": [
        "CWE-264"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "fs: limit filesystem stacking depth\n\nAdd a simple read-only counter to super_block that indicates how deep this\nis in the stack of filesystems.  Previously ecryptfs was the only stackable\nfilesystem and it explicitly disallowed multiple layers of itself.\n\nOverlayfs, however, can be stacked recursively and also may be stacked\non top of ecryptfs or vice versa.\n\nTo limit the kernel stack usage we must limit the depth of the\nfilesystem stack.  Initially the limit is set to 2.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>",
    "commit_hash": "69c433ed2ecd2d3264efd7afec4439524b319121",
    "git_url": "https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121",
    "file_path": "fs/ecryptfs/main.c",
    "func_name": "ecryptfs_mount",
    "func_before": "static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_dentry_info *root_info;\n\tconst char *err = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tuid_t check_ruid;\n\tint rc;\n\n\tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n\tif (rc) {\n\t\terr = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\n\ts = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\trc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\", BDI_CAP_MAP_COPY);\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\ts->s_bdi = &sbi->bdi;\n\n\t/* ->kill_sb() will take care of sbi after that point */\n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n\t\t       \"requested user (uid: %d)\\n\",\n\t\t\ti_uid_read(path.dentry->d_inode),\n\t\t\tfrom_kuid(&init_user_ns, current_uid()));\n\t\tgoto out_free;\n\t}\n\n\tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n\n\t/**\n\t * Set the POSIX ACL flag based on whether they're enabled in the lower\n\t * mount. Force a read-only eCryptfs mount if the lower mount is ro.\n\t * Allow a ro eCryptfs mount even when the lower mount is rw.\n\t */\n\ts->s_flags = flags & ~MS_POSIXACL;\n\ts->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);\n\n\ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t/* ->kill_sb() will take care of root_info */\n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\troot_info->lower_path = path;\n\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}",
    "abstract_func_before": "static struct dentry *ecryptfs_mount(struct file_system_type *VAR_0, int VAR_1,\n\t\t\tconst char *VAR_2, void *VAR_3)\n{\n\tstruct super_block *VAR_4;\n\tstruct ecryptfs_sb_info *VAR_5;\n\tstruct ecryptfs_dentry_info *VAR_6;\n\tconst char *VAR_7 = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tuid_t VAR_8;\n\tint VAR_9;\n\n\tVAR_5 = kmem_cache_zalloc(VAR_10, VAR_11);\n\tif (!VAR_5) {\n\t\tVAR_9 = -VAR_12;\n\t\tgoto out;\n\t}\n\n\tVAR_9 = ecryptfs_parse_options(VAR_5, VAR_3, &VAR_8);\n\tif (VAR_9) {\n\t\tVAR_7 = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\n\tVAR_4 = sget(VAR_0, NULL, VAR_13, VAR_1, NULL);\n\tif (IS_ERR(VAR_4)) {\n\t\tVAR_9 = PTR_ERR(VAR_4);\n\t\tgoto out;\n\t}\n\n\tVAR_9 = bdi_setup_and_register(&VAR_5->bdi, \"ecryptfs\", VAR_14);\n\tif (VAR_9)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(VAR_4, VAR_5);\n\tVAR_4->s_bdi = &VAR_5->bdi;\n\n\t/* COMMENT_0 */\n\tVAR_5 = NULL;\n\tVAR_4->s_op = &VAR_15;\n\tVAR_4->s_d_op = &VAR_16;\n\n\tVAR_7 = \"Reading sb failed\";\n\tVAR_9 = kern_path(VAR_2, VAR_17 | VAR_18, &path);\n\tif (VAR_9) {\n\t\tecryptfs_printk(VAR_19, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &VAR_20) {\n\t\tVAR_9 = -VAR_21;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (VAR_8 && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {\n\t\tVAR_9 = -VAR_22;\n\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n\t\t       \"requested user (uid: %d)\\n\",\n\t\t\ti_uid_read(path.dentry->d_inode),\n\t\t\tfrom_kuid(&VAR_23, current_uid()));\n\t\tgoto out_free;\n\t}\n\n\tecryptfs_set_superblock_lower(VAR_4, path.dentry->d_sb);\n\n\t/* COMMENT_1 */\n                                                                        \n                                                                     \n                                                              \n    \n\tVAR_4->s_flags = VAR_1 & ~VAR_24;\n\tVAR_4->s_flags |= path.dentry->d_sb->s_flags & (VAR_25 | VAR_24);\n\n\tVAR_4->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\tVAR_4->s_blocksize = path.dentry->d_sb->s_blocksize;\n\tVAR_4->s_magic = VAR_26;\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, VAR_4);\n\tVAR_9 = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\tVAR_4->s_root = d_make_root(inode);\n\tif (!VAR_4->s_root) {\n\t\tVAR_9 = -VAR_12;\n\t\tgoto out_free;\n\t}\n\n\tVAR_9 = -VAR_12;\n\tVAR_6 = kmem_cache_zalloc(VAR_27, VAR_11);\n\tif (!VAR_6)\n\t\tgoto out_free;\n\n\t/* COMMENT_6 */\n\tecryptfs_set_dentry_private(VAR_4->s_root, VAR_6);\n\tVAR_6->lower_path = path;\n\n\tVAR_4->s_flags |= VAR_28;\n\treturn dget(VAR_4->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(VAR_4);\nout:\n\tif (VAR_5) {\n\t\tecryptfs_destroy_mount_crypt_stat(&VAR_5->mount_crypt_stat);\n\t\tkmem_cache_free(VAR_10, VAR_5);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", VAR_7, VAR_9);\n\treturn ERR_PTR(VAR_9);\n}",
    "func_graph_path_before": "torvalds/linux/69c433ed2ecd2d3264efd7afec4439524b319121/main.c/vul/before/0.json",
    "func": "static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_dentry_info *root_info;\n\tconst char *err = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tuid_t check_ruid;\n\tint rc;\n\n\tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n\tif (rc) {\n\t\terr = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\n\ts = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\trc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\", BDI_CAP_MAP_COPY);\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\ts->s_bdi = &sbi->bdi;\n\n\t/* ->kill_sb() will take care of sbi after that point */\n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n\t\t       \"requested user (uid: %d)\\n\",\n\t\t\ti_uid_read(path.dentry->d_inode),\n\t\t\tfrom_kuid(&init_user_ns, current_uid()));\n\t\tgoto out_free;\n\t}\n\n\tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n\n\t/**\n\t * Set the POSIX ACL flag based on whether they're enabled in the lower\n\t * mount. Force a read-only eCryptfs mount if the lower mount is ro.\n\t * Allow a ro eCryptfs mount even when the lower mount is rw.\n\t */\n\ts->s_flags = flags & ~MS_POSIXACL;\n\ts->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);\n\n\ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n\n\trc = -EINVAL;\n\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n\t\tpr_err(\"eCryptfs: maximum fs stacking depth exceeded\\n\");\n\t\tgoto out_free;\n\t}\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t/* ->kill_sb() will take care of root_info */\n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\troot_info->lower_path = path;\n\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}",
    "abstract_func": "static struct dentry *ecryptfs_mount(struct file_system_type *VAR_0, int VAR_1,\n\t\t\tconst char *VAR_2, void *VAR_3)\n{\n\tstruct super_block *VAR_4;\n\tstruct ecryptfs_sb_info *VAR_5;\n\tstruct ecryptfs_dentry_info *VAR_6;\n\tconst char *VAR_7 = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tuid_t VAR_8;\n\tint VAR_9;\n\n\tVAR_5 = kmem_cache_zalloc(VAR_10, VAR_11);\n\tif (!VAR_5) {\n\t\tVAR_9 = -VAR_12;\n\t\tgoto out;\n\t}\n\n\tVAR_9 = ecryptfs_parse_options(VAR_5, VAR_3, &VAR_8);\n\tif (VAR_9) {\n\t\tVAR_7 = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\n\tVAR_4 = sget(VAR_0, NULL, VAR_13, VAR_1, NULL);\n\tif (IS_ERR(VAR_4)) {\n\t\tVAR_9 = PTR_ERR(VAR_4);\n\t\tgoto out;\n\t}\n\n\tVAR_9 = bdi_setup_and_register(&VAR_5->bdi, \"ecryptfs\", VAR_14);\n\tif (VAR_9)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(VAR_4, VAR_5);\n\tVAR_4->s_bdi = &VAR_5->bdi;\n\n\t/* COMMENT_0 */\n\tVAR_5 = NULL;\n\tVAR_4->s_op = &VAR_15;\n\tVAR_4->s_d_op = &VAR_16;\n\n\tVAR_7 = \"Reading sb failed\";\n\tVAR_9 = kern_path(VAR_2, VAR_17 | VAR_18, &path);\n\tif (VAR_9) {\n\t\tecryptfs_printk(VAR_19, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &VAR_20) {\n\t\tVAR_9 = -VAR_21;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (VAR_8 && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {\n\t\tVAR_9 = -VAR_22;\n\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n\t\t       \"requested user (uid: %d)\\n\",\n\t\t\ti_uid_read(path.dentry->d_inode),\n\t\t\tfrom_kuid(&VAR_23, current_uid()));\n\t\tgoto out_free;\n\t}\n\n\tecryptfs_set_superblock_lower(VAR_4, path.dentry->d_sb);\n\n\t/* COMMENT_1 */\n                                                                        \n                                                                     \n                                                              \n    \n\tVAR_4->s_flags = VAR_1 & ~VAR_24;\n\tVAR_4->s_flags |= path.dentry->d_sb->s_flags & (VAR_25 | VAR_24);\n\n\tVAR_4->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\tVAR_4->s_blocksize = path.dentry->d_sb->s_blocksize;\n\tVAR_4->s_magic = VAR_26;\n\tVAR_4->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n\n\tVAR_9 = -VAR_21;\n\tif (VAR_4->s_stack_depth > VAR_27) {\n\t\tpr_err(\"eCryptfs: maximum fs stacking depth exceeded\\n\");\n\t\tgoto out_free;\n\t}\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, VAR_4);\n\tVAR_9 = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\tVAR_4->s_root = d_make_root(inode);\n\tif (!VAR_4->s_root) {\n\t\tVAR_9 = -VAR_12;\n\t\tgoto out_free;\n\t}\n\n\tVAR_9 = -VAR_12;\n\tVAR_6 = kmem_cache_zalloc(VAR_28, VAR_11);\n\tif (!VAR_6)\n\t\tgoto out_free;\n\n\t/* COMMENT_6 */\n\tecryptfs_set_dentry_private(VAR_4->s_root, VAR_6);\n\tVAR_6->lower_path = path;\n\n\tVAR_4->s_flags |= VAR_29;\n\treturn dget(VAR_4->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(VAR_4);\nout:\n\tif (VAR_5) {\n\t\tecryptfs_destroy_mount_crypt_stat(&VAR_5->mount_crypt_stat);\n\t\tkmem_cache_free(VAR_10, VAR_5);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", VAR_7, VAR_9);\n\treturn ERR_PTR(VAR_9);\n}",
    "func_graph_path": "torvalds/linux/69c433ed2ecd2d3264efd7afec4439524b319121/main.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -76,6 +76,13 @@\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n \ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n+\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n+\n+\trc = -EINVAL;\n+\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\"eCryptfs: maximum fs stacking depth exceeded\\n\");\n+\t\tgoto out_free;\n+\t}\n \n \tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n \trc = PTR_ERR(inode);",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;",
            "",
            "\trc = -EINVAL;",
            "\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {",
            "\t\tpr_err(\"eCryptfs: maximum fs stacking depth exceeded\\n\");",
            "\t\tgoto out_free;",
            "\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}