{
    "cve_id": "CVE-2018-9918",
    "cwe_ids": [
        "CWE-674"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "qpdf",
    "commit_msg": "Limit depth of nesting in direct objects (fixes #202)\n\nThis fixes CVE-2018-9918.",
    "commit_hash": "b4d6cf6836ce025ba1811b7bbec52680c7204223",
    "git_url": "https://github.com/qpdf/qpdf/commit/b4d6cf6836ce025ba1811b7bbec52680c7204223",
    "file_path": "libqpdf/QPDFObjectHandle.cc",
    "func_name": "QPDFObjectHandle::parseInternal",
    "func_before": "QPDFObjectHandle\nQPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    std::vector<parser_state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    qpdf_offset_t offset = input->tell();\n    offset_stack.push_back(offset);\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        parser_state_e state = state_stack.back();\n        offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description, true);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (! content_stream)\n            {\n                QTC::TC(\"qpdf\", \"QPDFObjectHandle eof in parseInternal\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected EOF\"));\n            }\n            state = st_eof;\n            break;\n\n          case QPDFTokenizer::tt_bad:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad token in parse\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         token.getErrorMessage()));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            olist_stack.push_back(std::vector<QPDFObjectHandle>());\n            state = st_start;\n            offset_stack.push_back(input->tell());\n            state_stack.push_back(\n                (token.getType() == QPDFTokenizer::tt_array_open) ?\n                st_array : st_dictionary);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle treat word as string\");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \"unknown token while reading object;\"\n                                 \" treating as string\"));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \"QPDFObjectHandle::parseInternal: \"\n                \"unexpected uninitialized object\");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"parse error while reading object\"));\n            }\n            done = true;\n            // In content stream mode, leave object uninitialized to\n            // indicate EOF\n            if (! content_stream)\n            {\n                object = newNull();\n            }\n            break;\n\n          case st_dictionary:\n          case st_array:\n            setObjectDescriptionFromInput(\n                object, context, object_description, input,\n                input->getLastOffset());\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \"QPDFObjectHandle::parseInternal: st_stop encountered\"\n                    \" with insufficient elements in stack\");\n            }\n            parser_state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            else if (old_state == st_dictionary)\n            {\n                // Convert list to map. Alternating elements are keys.\n                // Attempt to recover more or less gracefully from\n                // invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \"/QPDFFake\" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"expected dictionary key but found\"\n                                 \" non-name object; inserting key \" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"dictionary ended prematurely; \"\n                                 \"using null as value for last key\"));\n                        val = newNull();\n                        setObjectDescriptionFromInput(\n                            val, context, object_description, input, offset);\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        object, context, object_description, input, offset);\n    return object;\n}",
    "abstract_func_before": "QPDFObjectHandle\nQPDFObjectHandle::parseInternal(PointerHolder<InputSource> VAR_0,\n                                std::string const& VAR_1,\n                                QPDFTokenizer& VAR_2, bool& VAR_3,\n                                StringDecrypter* VAR_4, QPDF* VAR_5,\n                                bool VAR_6)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n\n    VAR_3 = false;\n\n    QPDFObjectHandle VAR_7;\n\n    std::vector<std::vector<QPDFObjectHandle> > VAR_8;\n    VAR_8.push_back(std::vector<QPDFObjectHandle>());\n    std::vector<parser_state_e> VAR_9;\n    VAR_9.push_back(VAR_10);\n    std::vector<qpdf_offset_t> VAR_11;\n    qpdf_offset_t VAR_12 = VAR_0->tell();\n    VAR_11.push_back(VAR_12);\n    bool VAR_13 = false;\n    while (! VAR_13)\n    {\n        std::vector<QPDFObjectHandle>& VAR_14 = VAR_8.back();\n        parser_state_e VAR_15 = VAR_9.back();\n        VAR_12 = VAR_11.back();\n\n\tVAR_7 = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token VAR_16 =\n            VAR_2.readToken(VAR_0, VAR_1, true);\n\n\tswitch (VAR_16.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (! VAR_6)\n            {\n                QTC::TC(\"qpdf\", \"QPDFObjectHandle eof in parseInternal\");\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"unexpected EOF\"));\n            }\n            VAR_15 = VAR_18;\n            break;\n\n          case QPDFTokenizer::tt_bad:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad token in parse\");\n            warn(VAR_5,\n                 QPDFExc(VAR_17, VAR_0->getName(),\n                         VAR_1,\n                         VAR_0->getLastOffset(),\n                         VAR_16.getErrorMessage()));\n            VAR_7 = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(VAR_5,\n                 QPDFExc(VAR_17, VAR_0->getName(),\n                         VAR_1,\n                         VAR_0->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            VAR_7 = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (VAR_15 == VAR_19)\n\t    {\n                VAR_15 = VAR_20;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                VAR_7 = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (VAR_15 == VAR_21)\n\t    {\n                VAR_15 = VAR_20;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                VAR_7 = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            VAR_8.push_back(std::vector<QPDFObjectHandle>());\n            VAR_15 = VAR_22;\n            VAR_11.push_back(VAR_0->tell());\n            VAR_9.push_back(\n                (VAR_16.getType() == QPDFTokenizer::tt_array_open) ?\n                VAR_19 : VAR_21);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    VAR_7 = newBool((VAR_16.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    VAR_7 = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    VAR_7 = newInteger(QUtil::string_to_ll(VAR_16.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    VAR_7 = newReal(VAR_16.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    VAR_7 = newName(VAR_16.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& VAR_23 = VAR_16.getValue();\n                if (VAR_6)\n                {\n                    VAR_7 = QPDFObjectHandle::newOperator(VAR_23);\n                }\n\t\telse if ((VAR_23 == \"R\") && (VAR_15 != VAR_10) &&\n                         (VAR_14.size() >= 2) &&\n                         (! VAR_14.at(VAR_14.size() - 1).isIndirect()) &&\n                         (VAR_14.at(VAR_14.size() - 1).isInteger()) &&\n                         (! VAR_14.at(VAR_14.size() - 2).isIndirect()) &&\n                         (VAR_14.at(VAR_14.size() - 2).isInteger()))\n\t\t{\n                    if (VAR_5 == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    /* COMMENT_4 */\n\t\t    VAR_7 = newIndirect(\n\t\t\tVAR_5,\n\t\t\tVAR_14.at(VAR_14.size() - 2).getIntValue(),\n\t\t\tVAR_14.at(VAR_14.size() - 1).getIntValue());\n\t\t    VAR_14.pop_back();\n\t\t    VAR_14.pop_back();\n\t\t}\n\t\telse if ((VAR_23 == \"endobj\") && (VAR_15 == VAR_10))\n\t\t{\n\t\t    /* COMMENT_5 */\n\t\t    /* COMMENT_6 */\n\t\t    /* COMMENT_7 */\n\t\t    VAR_7 = newNull();\n\t\t    VAR_0->seek(VAR_0->getLastOffset(), VAR_24);\n                    VAR_3 = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle treat word as string\");\n                    warn(VAR_5,\n                         QPDFExc(VAR_17, VAR_0->getName(),\n                                 VAR_1,\n                                 VAR_0->getLastOffset(),\n                                 \"unknown token while reading object;\"\n                                 \" treating as string\"));\n                    VAR_7 = newString(VAR_23);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string VAR_25 = VAR_16.getValue();\n                if (VAR_4)\n                {\n                    VAR_4->decryptString(VAR_25);\n                }\n\t\tVAR_7 = QPDFObjectHandle::newString(VAR_25);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(VAR_5,\n                 QPDFExc(VAR_17, VAR_0->getName(),\n                         VAR_1,\n                         VAR_0->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            VAR_7 = newNull();\n\t    break;\n\t}\n\n        if ((! VAR_7.isInitialized()) &&\n            (! ((VAR_15 == VAR_22) ||\n                (VAR_15 == VAR_20) ||\n                (VAR_15 == VAR_18))))\n        {\n            throw std::logic_error(\n                \"QPDFObjectHandle::parseInternal: \"\n                \"unexpected uninitialized object\");\n            VAR_7 = newNull();\n        }\n\n        switch (VAR_15)\n        {\n          case VAR_18:\n            if (VAR_9.size() > 1)\n            {\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"parse error while reading object\"));\n            }\n            VAR_13 = true;\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            if (! VAR_6)\n            {\n                VAR_7 = newNull();\n            }\n            break;\n\n          case VAR_21:\n          case VAR_19:\n            setObjectDescriptionFromInput(\n                VAR_7, VAR_5, VAR_1, VAR_0,\n                VAR_0->getLastOffset());\n            VAR_14.push_back(VAR_7);\n            break;\n\n          case VAR_10:\n            VAR_13 = true;\n            break;\n\n          case VAR_22:\n            break;\n\n          case VAR_20:\n            if ((VAR_9.size() < 2) || (VAR_8.size() < 2))\n            {\n                throw std::logic_error(\n                    \"QPDFObjectHandle::parseInternal: st_stop encountered\"\n                    \" with insufficient elements in stack\");\n            }\n            parser_state_e VAR_26 = VAR_9.back();\n            VAR_9.pop_back();\n            if (VAR_26 == VAR_19)\n            {\n                VAR_7 = newArray(VAR_14);\n                setObjectDescriptionFromInput(\n                    VAR_7, VAR_5, VAR_1, VAR_0, VAR_12);\n            }\n            else if (VAR_26 == VAR_21)\n            {\n                /* COMMENT_10 */\n                /* COMMENT_11 */\n                /* COMMENT_12 */\n                std::set<std::string> VAR_27;\n                for (std::vector<QPDFObjectHandle>::iterator VAR_28 =\n                         VAR_14.begin();\n                     VAR_28 != VAR_14.end(); ++VAR_28)\n                {\n                    if ((! (*VAR_28).isIndirect()) && (*VAR_28).isName())\n                    {\n                        VAR_27.insert((*VAR_28).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> VAR_29;\n                int VAR_30 = 1;\n                for (unsigned int VAR_31 = 0; VAR_31 < VAR_14.size(); ++VAR_31)\n                {\n                    QPDFObjectHandle VAR_32 = VAR_14.at(VAR_31);\n                    QPDFObjectHandle VAR_25;\n                    if (VAR_32.isIndirect() || (! VAR_32.isName()))\n                    {\n                        bool VAR_33 = false;\n                        std::string VAR_34;\n                        while (! VAR_33)\n                        {\n                            VAR_34 =\n                                \"/QPDFFake\" +\n                                QUtil::int_to_string(VAR_30++);\n                            VAR_33 = (VAR_27.count(VAR_34) == 0);\n                            QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                                    (VAR_33 ? 0 : 1));\n                        }\n                        warn(VAR_5,\n                             QPDFExc(\n                                 VAR_17,\n                                 VAR_0->getName(), VAR_1, VAR_12,\n                                 \"expected dictionary key but found\"\n                                 \" non-name object; inserting key \" +\n                                 VAR_34));\n                        VAR_25 = VAR_32;\n                        VAR_32 = newName(VAR_34);\n                    }\n                    else if (VAR_31 + 1 >= VAR_14.size())\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                        warn(VAR_5,\n                             QPDFExc(\n                                 VAR_17,\n                                 VAR_0->getName(), VAR_1, VAR_12,\n                                 \"dictionary ended prematurely; \"\n                                 \"using null as value for last key\"));\n                        VAR_25 = newNull();\n                        setObjectDescriptionFromInput(\n                            VAR_25, VAR_5, VAR_1, VAR_0, VAR_12);\n                    }\n                    else\n                    {\n                        VAR_25 = VAR_14.at(++VAR_31);\n                    }\n                    VAR_29[VAR_32.getName()] = VAR_25;\n                }\n                VAR_7 = newDictionary(VAR_29);\n                setObjectDescriptionFromInput(\n                    VAR_7, VAR_5, VAR_1, VAR_0, VAR_12);\n            }\n            VAR_8.pop_back();\n            VAR_11.pop_back();\n            if (VAR_9.back() == VAR_10)\n            {\n                VAR_13 = true;\n            }\n            else\n            {\n                VAR_8.back().push_back(VAR_7);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        VAR_7, VAR_5, VAR_1, VAR_0, VAR_12);\n    return VAR_7;\n}",
    "func_graph_path_before": "qpdf/b4d6cf6836ce025ba1811b7bbec52680c7204223/QPDFObjectHandle.cc/vul/before/0.json",
    "func": "QPDFObjectHandle\nQPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    std::vector<parser_state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    qpdf_offset_t offset = input->tell();\n    offset_stack.push_back(offset);\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        parser_state_e state = state_stack.back();\n        offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description, true);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (! content_stream)\n            {\n                QTC::TC(\"qpdf\", \"QPDFObjectHandle eof in parseInternal\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected EOF\"));\n            }\n            state = st_eof;\n            break;\n\n          case QPDFTokenizer::tt_bad:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad token in parse\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         token.getErrorMessage()));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            if (olist_stack.size() > 500)\n            {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle too deep\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"ignoring excessively deeply nested data structure\"));\n                object = newNull();\n                state = st_top;\n            }\n            else\n            {\n                olist_stack.push_back(std::vector<QPDFObjectHandle>());\n                state = st_start;\n                offset_stack.push_back(input->tell());\n                state_stack.push_back(\n                    (token.getType() == QPDFTokenizer::tt_array_open) ?\n                    st_array : st_dictionary);\n            }\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle treat word as string\");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \"unknown token while reading object;\"\n                                 \" treating as string\"));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \"QPDFObjectHandle::parseInternal: \"\n                \"unexpected uninitialized object\");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"parse error while reading object\"));\n            }\n            done = true;\n            // In content stream mode, leave object uninitialized to\n            // indicate EOF\n            if (! content_stream)\n            {\n                object = newNull();\n            }\n            break;\n\n          case st_dictionary:\n          case st_array:\n            setObjectDescriptionFromInput(\n                object, context, object_description, input,\n                input->getLastOffset());\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \"QPDFObjectHandle::parseInternal: st_stop encountered\"\n                    \" with insufficient elements in stack\");\n            }\n            parser_state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            else if (old_state == st_dictionary)\n            {\n                // Convert list to map. Alternating elements are keys.\n                // Attempt to recover more or less gracefully from\n                // invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \"/QPDFFake\" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"expected dictionary key but found\"\n                                 \" non-name object; inserting key \" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"dictionary ended prematurely; \"\n                                 \"using null as value for last key\"));\n                        val = newNull();\n                        setObjectDescriptionFromInput(\n                            val, context, object_description, input, offset);\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        object, context, object_description, input, offset);\n    return object;\n}",
    "abstract_func": "QPDFObjectHandle\nQPDFObjectHandle::parseInternal(PointerHolder<InputSource> VAR_0,\n                                std::string const& VAR_1,\n                                QPDFTokenizer& VAR_2, bool& VAR_3,\n                                StringDecrypter* VAR_4, QPDF* VAR_5,\n                                bool VAR_6)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n\n    VAR_3 = false;\n\n    QPDFObjectHandle VAR_7;\n\n    std::vector<std::vector<QPDFObjectHandle> > VAR_8;\n    VAR_8.push_back(std::vector<QPDFObjectHandle>());\n    std::vector<parser_state_e> VAR_9;\n    VAR_9.push_back(VAR_10);\n    std::vector<qpdf_offset_t> VAR_11;\n    qpdf_offset_t VAR_12 = VAR_0->tell();\n    VAR_11.push_back(VAR_12);\n    bool VAR_13 = false;\n    while (! VAR_13)\n    {\n        std::vector<QPDFObjectHandle>& VAR_14 = VAR_8.back();\n        parser_state_e VAR_15 = VAR_9.back();\n        VAR_12 = VAR_11.back();\n\n\tVAR_7 = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token VAR_16 =\n            VAR_2.readToken(VAR_0, VAR_1, true);\n\n\tswitch (VAR_16.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (! VAR_6)\n            {\n                QTC::TC(\"qpdf\", \"QPDFObjectHandle eof in parseInternal\");\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"unexpected EOF\"));\n            }\n            VAR_15 = VAR_18;\n            break;\n\n          case QPDFTokenizer::tt_bad:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad token in parse\");\n            warn(VAR_5,\n                 QPDFExc(VAR_17, VAR_0->getName(),\n                         VAR_1,\n                         VAR_0->getLastOffset(),\n                         VAR_16.getErrorMessage()));\n            VAR_7 = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(VAR_5,\n                 QPDFExc(VAR_17, VAR_0->getName(),\n                         VAR_1,\n                         VAR_0->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            VAR_7 = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (VAR_15 == VAR_19)\n\t    {\n                VAR_15 = VAR_20;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                VAR_7 = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (VAR_15 == VAR_21)\n\t    {\n                VAR_15 = VAR_20;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                VAR_7 = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            if (VAR_8.size() > 500)\n            {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle too deep\");\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"ignoring excessively deeply nested data structure\"));\n                VAR_7 = newNull();\n                VAR_15 = VAR_10;\n            }\n            else\n            {\n                VAR_8.push_back(std::vector<QPDFObjectHandle>());\n                VAR_15 = VAR_22;\n                VAR_11.push_back(VAR_0->tell());\n                VAR_9.push_back(\n                    (VAR_16.getType() == QPDFTokenizer::tt_array_open) ?\n                    VAR_19 : VAR_21);\n            }\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    VAR_7 = newBool((VAR_16.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    VAR_7 = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    VAR_7 = newInteger(QUtil::string_to_ll(VAR_16.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    VAR_7 = newReal(VAR_16.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    VAR_7 = newName(VAR_16.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& VAR_23 = VAR_16.getValue();\n                if (VAR_6)\n                {\n                    VAR_7 = QPDFObjectHandle::newOperator(VAR_23);\n                }\n\t\telse if ((VAR_23 == \"R\") && (VAR_15 != VAR_10) &&\n                         (VAR_14.size() >= 2) &&\n                         (! VAR_14.at(VAR_14.size() - 1).isIndirect()) &&\n                         (VAR_14.at(VAR_14.size() - 1).isInteger()) &&\n                         (! VAR_14.at(VAR_14.size() - 2).isIndirect()) &&\n                         (VAR_14.at(VAR_14.size() - 2).isInteger()))\n\t\t{\n                    if (VAR_5 == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    /* COMMENT_4 */\n\t\t    VAR_7 = newIndirect(\n\t\t\tVAR_5,\n\t\t\tVAR_14.at(VAR_14.size() - 2).getIntValue(),\n\t\t\tVAR_14.at(VAR_14.size() - 1).getIntValue());\n\t\t    VAR_14.pop_back();\n\t\t    VAR_14.pop_back();\n\t\t}\n\t\telse if ((VAR_23 == \"endobj\") && (VAR_15 == VAR_10))\n\t\t{\n\t\t    /* COMMENT_5 */\n\t\t    /* COMMENT_6 */\n\t\t    /* COMMENT_7 */\n\t\t    VAR_7 = newNull();\n\t\t    VAR_0->seek(VAR_0->getLastOffset(), VAR_24);\n                    VAR_3 = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle treat word as string\");\n                    warn(VAR_5,\n                         QPDFExc(VAR_17, VAR_0->getName(),\n                                 VAR_1,\n                                 VAR_0->getLastOffset(),\n                                 \"unknown token while reading object;\"\n                                 \" treating as string\"));\n                    VAR_7 = newString(VAR_23);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string VAR_25 = VAR_16.getValue();\n                if (VAR_4)\n                {\n                    VAR_4->decryptString(VAR_25);\n                }\n\t\tVAR_7 = QPDFObjectHandle::newString(VAR_25);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(VAR_5,\n                 QPDFExc(VAR_17, VAR_0->getName(),\n                         VAR_1,\n                         VAR_0->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            VAR_7 = newNull();\n\t    break;\n\t}\n\n        if ((! VAR_7.isInitialized()) &&\n            (! ((VAR_15 == VAR_22) ||\n                (VAR_15 == VAR_20) ||\n                (VAR_15 == VAR_18))))\n        {\n            throw std::logic_error(\n                \"QPDFObjectHandle::parseInternal: \"\n                \"unexpected uninitialized object\");\n            VAR_7 = newNull();\n        }\n\n        switch (VAR_15)\n        {\n          case VAR_18:\n            if (VAR_9.size() > 1)\n            {\n                warn(VAR_5,\n                     QPDFExc(VAR_17, VAR_0->getName(),\n                             VAR_1,\n                             VAR_0->getLastOffset(),\n                             \"parse error while reading object\"));\n            }\n            VAR_13 = true;\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            if (! VAR_6)\n            {\n                VAR_7 = newNull();\n            }\n            break;\n\n          case VAR_21:\n          case VAR_19:\n            setObjectDescriptionFromInput(\n                VAR_7, VAR_5, VAR_1, VAR_0,\n                VAR_0->getLastOffset());\n            VAR_14.push_back(VAR_7);\n            break;\n\n          case VAR_10:\n            VAR_13 = true;\n            break;\n\n          case VAR_22:\n            break;\n\n          case VAR_20:\n            if ((VAR_9.size() < 2) || (VAR_8.size() < 2))\n            {\n                throw std::logic_error(\n                    \"QPDFObjectHandle::parseInternal: st_stop encountered\"\n                    \" with insufficient elements in stack\");\n            }\n            parser_state_e VAR_26 = VAR_9.back();\n            VAR_9.pop_back();\n            if (VAR_26 == VAR_19)\n            {\n                VAR_7 = newArray(VAR_14);\n                setObjectDescriptionFromInput(\n                    VAR_7, VAR_5, VAR_1, VAR_0, VAR_12);\n            }\n            else if (VAR_26 == VAR_21)\n            {\n                /* COMMENT_10 */\n                /* COMMENT_11 */\n                /* COMMENT_12 */\n                std::set<std::string> VAR_27;\n                for (std::vector<QPDFObjectHandle>::iterator VAR_28 =\n                         VAR_14.begin();\n                     VAR_28 != VAR_14.end(); ++VAR_28)\n                {\n                    if ((! (*VAR_28).isIndirect()) && (*VAR_28).isName())\n                    {\n                        VAR_27.insert((*VAR_28).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> VAR_29;\n                int VAR_30 = 1;\n                for (unsigned int VAR_31 = 0; VAR_31 < VAR_14.size(); ++VAR_31)\n                {\n                    QPDFObjectHandle VAR_32 = VAR_14.at(VAR_31);\n                    QPDFObjectHandle VAR_25;\n                    if (VAR_32.isIndirect() || (! VAR_32.isName()))\n                    {\n                        bool VAR_33 = false;\n                        std::string VAR_34;\n                        while (! VAR_33)\n                        {\n                            VAR_34 =\n                                \"/QPDFFake\" +\n                                QUtil::int_to_string(VAR_30++);\n                            VAR_33 = (VAR_27.count(VAR_34) == 0);\n                            QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                                    (VAR_33 ? 0 : 1));\n                        }\n                        warn(VAR_5,\n                             QPDFExc(\n                                 VAR_17,\n                                 VAR_0->getName(), VAR_1, VAR_12,\n                                 \"expected dictionary key but found\"\n                                 \" non-name object; inserting key \" +\n                                 VAR_34));\n                        VAR_25 = VAR_32;\n                        VAR_32 = newName(VAR_34);\n                    }\n                    else if (VAR_31 + 1 >= VAR_14.size())\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                        warn(VAR_5,\n                             QPDFExc(\n                                 VAR_17,\n                                 VAR_0->getName(), VAR_1, VAR_12,\n                                 \"dictionary ended prematurely; \"\n                                 \"using null as value for last key\"));\n                        VAR_25 = newNull();\n                        setObjectDescriptionFromInput(\n                            VAR_25, VAR_5, VAR_1, VAR_0, VAR_12);\n                    }\n                    else\n                    {\n                        VAR_25 = VAR_14.at(++VAR_31);\n                    }\n                    VAR_29[VAR_32.getName()] = VAR_25;\n                }\n                VAR_7 = newDictionary(VAR_29);\n                setObjectDescriptionFromInput(\n                    VAR_7, VAR_5, VAR_1, VAR_0, VAR_12);\n            }\n            VAR_8.pop_back();\n            VAR_11.pop_back();\n            if (VAR_9.back() == VAR_10)\n            {\n                VAR_13 = true;\n            }\n            else\n            {\n                VAR_8.back().push_back(VAR_7);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        VAR_7, VAR_5, VAR_1, VAR_0, VAR_12);\n    return VAR_7;\n}",
    "func_graph_path": "qpdf/b4d6cf6836ce025ba1811b7bbec52680c7204223/QPDFObjectHandle.cc/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -105,12 +105,26 @@\n \n \t  case QPDFTokenizer::tt_array_open:\n \t  case QPDFTokenizer::tt_dict_open:\n-            olist_stack.push_back(std::vector<QPDFObjectHandle>());\n-            state = st_start;\n-            offset_stack.push_back(input->tell());\n-            state_stack.push_back(\n-                (token.getType() == QPDFTokenizer::tt_array_open) ?\n-                st_array : st_dictionary);\n+            if (olist_stack.size() > 500)\n+            {\n+\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle too deep\");\n+                warn(context,\n+                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n+                             object_description,\n+                             input->getLastOffset(),\n+                             \"ignoring excessively deeply nested data structure\"));\n+                object = newNull();\n+                state = st_top;\n+            }\n+            else\n+            {\n+                olist_stack.push_back(std::vector<QPDFObjectHandle>());\n+                state = st_start;\n+                offset_stack.push_back(input->tell());\n+                state_stack.push_back(\n+                    (token.getType() == QPDFTokenizer::tt_array_open) ?\n+                    st_array : st_dictionary);\n+            }\n \t    break;\n \n \t  case QPDFTokenizer::tt_bool:",
    "diff_line_info": {
        "deleted_lines": [
            "            olist_stack.push_back(std::vector<QPDFObjectHandle>());",
            "            state = st_start;",
            "            offset_stack.push_back(input->tell());",
            "            state_stack.push_back(",
            "                (token.getType() == QPDFTokenizer::tt_array_open) ?",
            "                st_array : st_dictionary);"
        ],
        "added_lines": [
            "            if (olist_stack.size() > 500)",
            "            {",
            "\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle too deep\");",
            "                warn(context,",
            "                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),",
            "                             object_description,",
            "                             input->getLastOffset(),",
            "                             \"ignoring excessively deeply nested data structure\"));",
            "                object = newNull();",
            "                state = st_top;",
            "            }",
            "            else",
            "            {",
            "                olist_stack.push_back(std::vector<QPDFObjectHandle>());",
            "                state = st_start;",
            "                offset_stack.push_back(input->tell());",
            "                state_stack.push_back(",
            "                    (token.getType() == QPDFTokenizer::tt_array_open) ?",
            "                    st_array : st_dictionary);",
            "            }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}