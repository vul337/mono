{
    "cve_id": "CVE-2014-7924",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "chromium",
    "commit_msg": "IndexedDB: Fixed cursor/blob use-after-free bug\n\nThe IndexedDBDispatcherHost maintains a map of BLOB UUID's to BLOBs, but if two\n(or more) cursors are both active and referencing the same BLOB then two (or\nmore) BLOBs would exist with the same UUID, and their keys would collide in this\nmap. This change reference counts these BLOBs to avoid duplication.\n\nAlso, access to the existing map was not synchronized and was accessed on two\ndifferent threads.\n\nBUG=435880,436137\n\nReview URL: https://codereview.chromium.org/774593004\n\nCr-Commit-Position: refs/heads/master@{#307063}\n",
    "commit_hash": "2d74497dfa5e6fd6ddddc93248c322a57dd8dd2c",
    "git_url": "https://chromium.googlesource.com/chromium/src/+/2d74497dfa5e6fd6ddddc93248c322a57dd8dd2c",
    "file_path": "content/browser/indexed_db/indexed_db_callbacks.cc",
    "func_name": "CreateBlobData",
    "func_before": "static std::string CreateBlobData(\n    const IndexedDBBlobInfo& blob_info,\n    scoped_refptr<IndexedDBDispatcherHost> dispatcher_host,\n    storage::BlobStorageContext* blob_storage_context,\n    base::TaskRunner* task_runner) {\n  std::string uuid = blob_info.uuid();\n  if (!uuid.empty()) {\n    // We're sending back a live blob, not a reference into our backing store.\n    scoped_ptr<storage::BlobDataHandle> blob_data_handle(\n        blob_storage_context->GetBlobDataFromUUID(uuid));\n    dispatcher_host->HoldBlobDataHandle(uuid, blob_data_handle.Pass());\n    return uuid;\n  }\n  scoped_refptr<ShareableFileReference> shareable_file =\n      ShareableFileReference::Get(blob_info.file_path());\n  if (!shareable_file.get()) {\n    shareable_file = ShareableFileReference::GetOrCreate(\n        blob_info.file_path(),\n        ShareableFileReference::DONT_DELETE_ON_FINAL_RELEASE,\n        task_runner);\n    if (!blob_info.release_callback().is_null())\n      shareable_file->AddFinalReleaseCallback(blob_info.release_callback());\n  }\n\n  uuid = base::GenerateGUID();\n  scoped_refptr<storage::BlobData> blob_data = new storage::BlobData(uuid);\n  blob_data->set_content_type(base::UTF16ToUTF8(blob_info.type()));\n  blob_data->AppendFile(\n      blob_info.file_path(), 0, blob_info.size(), blob_info.last_modified());\n  scoped_ptr<storage::BlobDataHandle> blob_data_handle(\n      blob_storage_context->AddFinishedBlob(blob_data.get()));\n  dispatcher_host->HoldBlobDataHandle(uuid, blob_data_handle.Pass());\n\n  return uuid;\n}",
    "abstract_func_before": "static std::string CreateBlobData(\n    const IndexedDBBlobInfo& VAR_0,\n    scoped_refptr<IndexedDBDispatcherHost> VAR_1,\n    storage::BlobStorageContext* VAR_2,\n    base::TaskRunner* VAR_3) {\n  std::string VAR_4 = VAR_0.uuid();\n  if (!VAR_4.empty()) {\n    /* COMMENT_0 */\n    scoped_ptr<storage::BlobDataHandle> VAR_5(\n        VAR_2->GetBlobDataFromUUID(VAR_4));\n    VAR_1->HoldBlobDataHandle(VAR_4, VAR_5.Pass());\n    return VAR_4;\n  }\n  scoped_refptr<ShareableFileReference> VAR_6 =\n      ShareableFileReference::Get(VAR_0.file_path());\n  if (!VAR_6.get()) {\n    VAR_6 = ShareableFileReference::GetOrCreate(\n        VAR_0.file_path(),\n        ShareableFileReference::DONT_DELETE_ON_FINAL_RELEASE,\n        VAR_3);\n    if (!VAR_0.release_callback().is_null())\n      VAR_6->AddFinalReleaseCallback(VAR_0.release_callback());\n  }\n\n  VAR_4 = base::GenerateGUID();\n  scoped_refptr<storage::BlobData> VAR_7 = new storage::BlobData(VAR_4);\n  VAR_7->set_content_type(base::UTF16ToUTF8(VAR_0.type()));\n  VAR_7->AppendFile(\n      VAR_0.file_path(), 0, VAR_0.size(), VAR_0.last_modified());\n  scoped_ptr<storage::BlobDataHandle> VAR_5(\n      VAR_2->AddFinishedBlob(VAR_7.get()));\n  VAR_1->HoldBlobDataHandle(VAR_4, VAR_5.Pass());\n\n  return VAR_4;\n}",
    "func_graph_path_before": "chromium/2d74497dfa5e6fd6ddddc93248c322a57dd8dd2c/indexed_db_callbacks.cc/vul/before/1.json",
    "func": "static std::string CreateBlobData(\n    const IndexedDBBlobInfo& blob_info,\n    scoped_refptr<IndexedDBDispatcherHost> dispatcher_host,\n    base::TaskRunner* task_runner) {\n  if (!blob_info.uuid().empty()) {\n    // We're sending back a live blob, not a reference into our backing store.\n    return dispatcher_host->HoldBlobData(blob_info);\n  }\n  scoped_refptr<ShareableFileReference> shareable_file =\n      ShareableFileReference::Get(blob_info.file_path());\n  if (!shareable_file.get()) {\n    shareable_file = ShareableFileReference::GetOrCreate(\n        blob_info.file_path(),\n        ShareableFileReference::DONT_DELETE_ON_FINAL_RELEASE,\n        task_runner);\n    if (!blob_info.release_callback().is_null())\n      shareable_file->AddFinalReleaseCallback(blob_info.release_callback());\n  }\n  return dispatcher_host->HoldBlobData(blob_info);\n}",
    "abstract_func": "static std::string CreateBlobData(\n    const IndexedDBBlobInfo& VAR_0,\n    scoped_refptr<IndexedDBDispatcherHost> VAR_1,\n    base::TaskRunner* VAR_2) {\n  if (!VAR_0.uuid().empty()) {\n    /* COMMENT_0 */\n    return VAR_1->HoldBlobData(VAR_0);\n  }\n  scoped_refptr<ShareableFileReference> VAR_3 =\n      ShareableFileReference::Get(VAR_0.file_path());\n  if (!VAR_3.get()) {\n    VAR_3 = ShareableFileReference::GetOrCreate(\n        VAR_0.file_path(),\n        ShareableFileReference::DONT_DELETE_ON_FINAL_RELEASE,\n        VAR_2);\n    if (!VAR_0.release_callback().is_null())\n      VAR_3->AddFinalReleaseCallback(VAR_0.release_callback());\n  }\n  return VAR_1->HoldBlobData(VAR_0);\n}",
    "func_graph_path": "chromium/2d74497dfa5e6fd6ddddc93248c322a57dd8dd2c/indexed_db_callbacks.cc/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,10 @@\n static std::string CreateBlobData(\n     const IndexedDBBlobInfo& blob_info,\n     scoped_refptr<IndexedDBDispatcherHost> dispatcher_host,\n-    storage::BlobStorageContext* blob_storage_context,\n     base::TaskRunner* task_runner) {\n-  std::string uuid = blob_info.uuid();\n-  if (!uuid.empty()) {\n+  if (!blob_info.uuid().empty()) {\n     // We're sending back a live blob, not a reference into our backing store.\n-    scoped_ptr<storage::BlobDataHandle> blob_data_handle(\n-        blob_storage_context->GetBlobDataFromUUID(uuid));\n-    dispatcher_host->HoldBlobDataHandle(uuid, blob_data_handle.Pass());\n-    return uuid;\n+    return dispatcher_host->HoldBlobData(blob_info);\n   }\n   scoped_refptr<ShareableFileReference> shareable_file =\n       ShareableFileReference::Get(blob_info.file_path());\n@@ -21,15 +16,5 @@\n     if (!blob_info.release_callback().is_null())\n       shareable_file->AddFinalReleaseCallback(blob_info.release_callback());\n   }\n-\n-  uuid = base::GenerateGUID();\n-  scoped_refptr<storage::BlobData> blob_data = new storage::BlobData(uuid);\n-  blob_data->set_content_type(base::UTF16ToUTF8(blob_info.type()));\n-  blob_data->AppendFile(\n-      blob_info.file_path(), 0, blob_info.size(), blob_info.last_modified());\n-  scoped_ptr<storage::BlobDataHandle> blob_data_handle(\n-      blob_storage_context->AddFinishedBlob(blob_data.get()));\n-  dispatcher_host->HoldBlobDataHandle(uuid, blob_data_handle.Pass());\n-\n-  return uuid;\n+  return dispatcher_host->HoldBlobData(blob_info);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "    storage::BlobStorageContext* blob_storage_context,",
            "  std::string uuid = blob_info.uuid();",
            "  if (!uuid.empty()) {",
            "    scoped_ptr<storage::BlobDataHandle> blob_data_handle(",
            "        blob_storage_context->GetBlobDataFromUUID(uuid));",
            "    dispatcher_host->HoldBlobDataHandle(uuid, blob_data_handle.Pass());",
            "    return uuid;",
            "",
            "  uuid = base::GenerateGUID();",
            "  scoped_refptr<storage::BlobData> blob_data = new storage::BlobData(uuid);",
            "  blob_data->set_content_type(base::UTF16ToUTF8(blob_info.type()));",
            "  blob_data->AppendFile(",
            "      blob_info.file_path(), 0, blob_info.size(), blob_info.last_modified());",
            "  scoped_ptr<storage::BlobDataHandle> blob_data_handle(",
            "      blob_storage_context->AddFinishedBlob(blob_data.get()));",
            "  dispatcher_host->HoldBlobDataHandle(uuid, blob_data_handle.Pass());",
            "",
            "  return uuid;"
        ],
        "added_lines": [
            "  if (!blob_info.uuid().empty()) {",
            "    return dispatcher_host->HoldBlobData(blob_info);",
            "  return dispatcher_host->HoldBlobData(blob_info);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}