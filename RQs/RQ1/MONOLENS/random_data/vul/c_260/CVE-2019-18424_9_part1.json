{
    "cve_id": "CVE-2019-18424",
    "cwe_ids": [
        "CWE-78"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "xen-project/xen",
    "commit_msg": "passthrough: quarantine PCI devices\n\nWhen a PCI device is assigned to an untrusted domain, it is possible for\nthat domain to program the device to DMA to an arbitrary address. The\nIOMMU is used to protect the host from malicious DMA by making sure that\nthe device addresses can only target memory assigned to the guest. However,\nwhen the guest domain is torn down the device is assigned back to dom0,\nthus allowing any in-flight DMA to potentially target critical host data.\n\nThis patch introduces a 'quarantine' for PCI devices using dom_io. When\nthe toolstack makes a device assignable (by binding it to pciback), it\nwill now also assign it to DOMID_IO and the device will only be assigned\nback to dom0 when the device is made unassignable again. Whilst device is\nassignable it will only ever transfer between dom_io and guest domains.\ndom_io is actually only used as a sentinel domain for quarantining purposes;\nit is not configured with any IOMMU mappings. Assignment to dom_io simply\nmeans that the device's initiator (requestor) identifier is not present in\nthe IOMMU's device table and thus any DMA transactions issued will be\nterminated with a fault condition.\n\nIn addition, a fix to assignment handling is made for VT-d.  Failure\nduring the assignment step should not lead to a device still being\nassociated with its prior owner. Hand the device to DomIO temporarily,\nuntil the assignment step has completed successfully.  Remove the PI\nhooks from the source domain then earlier as well.\n\nFailure of the recovery reassign_device_ownership() may not go silent:\nThere e.g. may still be left over RMRR mappings in the domain assignment\nto which has failed, and hence we can't allow that domain to continue\nexecuting.\n\nNOTE: This patch also includes one printk() cleanup; the\n      \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),\n      since similar printk()-s elsewhere also don't log such a tag.\n\nThis is XSA-302.\n\nSigned-off-by: Paul Durrant <paul.durrant@citrix.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nSigned-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",
    "commit_hash": "319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
    "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
    "file_path": "xen/drivers/passthrough/pci.c",
    "func_name": "deassign_device",
    "func_before": "static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \"%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \"%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    pdev->fault.count = 0;\n\n    return ret;\n}",
    "abstract_func_before": "static int deassign_device(struct domain *VAR_0, uint16_t VAR_1, uint8_t VAR_2,\n                           uint8_t VAR_3)\n{\n    const struct domain_iommu *VAR_4 = dom_iommu(VAR_0);\n    struct pci_dev *VAR_5;\n    int VAR_6 = 0;\n\n    if ( !is_iommu_enabled(VAR_0) )\n        return -VAR_7;\n\n    ASSERT(pcidevs_locked());\n    VAR_5 = pci_get_pdev_by_domain(VAR_0, VAR_1, VAR_2, VAR_3);\n    if ( !VAR_5 )\n        return -VAR_8;\n\n    while ( VAR_5->phantom_stride )\n    {\n        VAR_3 += VAR_5->phantom_stride;\n        if ( PCI_SLOT(VAR_3) != PCI_SLOT(VAR_5->devfn) )\n            break;\n        VAR_6 = VAR_4->platform_ops->reassign_device(VAR_0, VAR_9, VAR_3,\n                                                pci_to_dev(VAR_5));\n        if ( !VAR_6 )\n            continue;\n\n        printk(XENLOG_G_ERR \"%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\",\n               VAR_0, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3), VAR_6);\n        return VAR_6;\n    }\n\n    VAR_3 = VAR_5->devfn;\n    VAR_6 = VAR_4->platform_ops->reassign_device(VAR_0, VAR_9, VAR_3,\n                                            pci_to_dev(VAR_5));\n    if ( VAR_6 )\n    {\n        dprintk(VAR_10,\n                \"%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\",\n                VAR_0, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3));\n        return VAR_6;\n    }\n\n    VAR_5->fault.count = 0;\n\n    return VAR_6;\n}",
    "func_graph_path_before": "xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci.c/vul/before/0.json",
    "func": "static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    struct domain *target;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    /* De-assignment from dom_io should de-quarantine the device */\n    target = (pdev->quarantine && pdev->domain != dom_io) ?\n        dom_io : hardware_domain;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \"%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \"%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    if ( pdev->domain == hardware_domain  )\n        pdev->quarantine = false;\n\n    pdev->fault.count = 0;\n\n    return ret;\n}",
    "abstract_func": "static int deassign_device(struct domain *VAR_0, uint16_t VAR_1, uint8_t VAR_2,\n                           uint8_t VAR_3)\n{\n    const struct domain_iommu *VAR_4 = dom_iommu(VAR_0);\n    struct pci_dev *VAR_5;\n    struct domain *VAR_6;\n    int VAR_7 = 0;\n\n    if ( !is_iommu_enabled(VAR_0) )\n        return -VAR_8;\n\n    ASSERT(pcidevs_locked());\n    VAR_5 = pci_get_pdev_by_domain(VAR_0, VAR_1, VAR_2, VAR_3);\n    if ( !VAR_5 )\n        return -VAR_9;\n\n    /* COMMENT_0 */\n    VAR_6 = (VAR_5->quarantine && VAR_5->domain != VAR_10) ?\n        VAR_10 : VAR_11;\n\n    while ( VAR_5->phantom_stride )\n    {\n        VAR_3 += VAR_5->phantom_stride;\n        if ( PCI_SLOT(VAR_3) != PCI_SLOT(VAR_5->devfn) )\n            break;\n        VAR_7 = VAR_4->platform_ops->reassign_device(VAR_0, VAR_6, VAR_3,\n                                                pci_to_dev(VAR_5));\n        if ( !VAR_7 )\n            continue;\n\n        printk(XENLOG_G_ERR \"%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\",\n               VAR_0, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3), VAR_7);\n        return VAR_7;\n    }\n\n    VAR_3 = VAR_5->devfn;\n    VAR_7 = VAR_4->platform_ops->reassign_device(VAR_0, VAR_6, VAR_3,\n                                            pci_to_dev(VAR_5));\n    if ( VAR_7 )\n    {\n        dprintk(VAR_12,\n                \"%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\",\n                VAR_0, VAR_1, VAR_2, PCI_SLOT(VAR_3), PCI_FUNC(VAR_3));\n        return VAR_7;\n    }\n\n    if ( VAR_5->domain == VAR_11  )\n        VAR_5->quarantine = false;\n\n    VAR_5->fault.count = 0;\n\n    return VAR_7;\n}",
    "func_graph_path": "xen-project/xen/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12/pci.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n {\n     const struct domain_iommu *hd = dom_iommu(d);\n     struct pci_dev *pdev;\n+    struct domain *target;\n     int ret = 0;\n \n     if ( !is_iommu_enabled(d) )\n@@ -13,12 +14,16 @@\n     if ( !pdev )\n         return -ENODEV;\n \n+    /* De-assignment from dom_io should de-quarantine the device */\n+    target = (pdev->quarantine && pdev->domain != dom_io) ?\n+        dom_io : hardware_domain;\n+\n     while ( pdev->phantom_stride )\n     {\n         devfn += pdev->phantom_stride;\n         if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n             break;\n-        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n+        ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                                 pci_to_dev(pdev));\n         if ( !ret )\n             continue;\n@@ -29,7 +34,7 @@\n     }\n \n     devfn = pdev->devfn;\n-    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n+    ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                             pci_to_dev(pdev));\n     if ( ret )\n     {\n@@ -39,6 +44,9 @@\n         return ret;\n     }\n \n+    if ( pdev->domain == hardware_domain  )\n+        pdev->quarantine = false;\n+\n     pdev->fault.count = 0;\n \n     return ret;",
    "diff_line_info": {
        "deleted_lines": [
            "        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,",
            "    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,"
        ],
        "added_lines": [
            "    struct domain *target;",
            "    /* De-assignment from dom_io should de-quarantine the device */",
            "    target = (pdev->quarantine && pdev->domain != dom_io) ?",
            "        dom_io : hardware_domain;",
            "",
            "        ret = hd->platform_ops->reassign_device(d, target, devfn,",
            "    ret = hd->platform_ops->reassign_device(d, target, devfn,",
            "    if ( pdev->domain == hardware_domain  )",
            "        pdev->quarantine = false;",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}