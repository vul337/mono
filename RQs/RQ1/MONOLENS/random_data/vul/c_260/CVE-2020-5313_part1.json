{
    "cve_id": "CVE-2020-5313",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "python-pillow/Pillow",
    "commit_msg": "Catch FLI buffer overrun",
    "commit_hash": "a09acd0decd8a87ccce939d5ff65dab59e7d365b",
    "git_url": "https://github.com/python-pillow/Pillow/commit/a09acd0decd8a87ccce939d5ff65dab59e7d365b",
    "file_path": "src/libImaging/FliDecode.c",
    "func_name": "ImagingFliDecode",
    "func_before": "int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8* ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4)\n\treturn 0;\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer (on the other hand, the Python part of the driver\n       makes sure this is always the case) */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr))\n\treturn 0;\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (I16(ptr+4) != 0xF1FA) {\n\tstate->errcode = IMAGING_CODEC_UNKNOWN;\n\treturn -1;\n    }\n\n    chunks = I16(ptr+6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n\tUINT8* data;\n\tif (bytes < 10) {\n\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t    return -1;\n\t}\n\tdata = ptr + 6;\n\tswitch (I16(ptr+4)) {\n\tcase 4: case 11:\n\t    /* FLI COLOR chunk */\n\t    break; /* ignored; handled by Python code */\n\tcase 7:\n\t    /* FLI SS2 chunk (word delta) */\n\t    lines = I16(data); data += 2;\n\t    for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n\t\tUINT8* buf = (UINT8*) im->image[y];\n\t\tint p, packets;\n\t\tpackets = I16(data); data += 2;\n\t\twhile (packets & 0x8000) {\n\t\t    /* flag word */\n\t\t    if (packets & 0x4000) {\n\t\t\ty += 65536 - packets; /* skip lines */\n\t\t\tif (y >= state->ysize) {\n\t\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t\t    return -1;\n\t\t\t}\n\t\t\tbuf = (UINT8*) im->image[y];\n\t\t    } else {\n\t\t\t/* store last byte (used if line width is odd) */\n\t\t\tbuf[state->xsize-1] = (UINT8) packets;\n\t\t    }\n\t\t    packets = I16(data); data += 2;\n\t\t}\n\t\tfor (p = x = 0; p < packets; p++) {\n\t\t    x += data[0]; /* pixel skip */\n\t\t    if (data[1] >= 128) {\n\t\t\ti = 256-data[1]; /* run */\n\t\t\tif (x + i + i > state->xsize)\n\t\t\t    break;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    buf[x++] = data[2];\n\t\t\t    buf[x++] = data[3];\n\t\t\t}\n\t\t\tdata += 2 + 2;\n\t\t    } else {\n\t\t\ti = 2 * (int) data[1]; /* chunk */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(buf + x, data + 2, i);\n\t\t\tdata += 2 + i;\n\t\t\tx += i;\n\t\t    }\n\t\t}\n\t\tif (p < packets)\n\t\t    break; /* didn't process all packets */\n\t    }\n\t    if (l < lines) {\n\t\t/* didn't process all lines */\n\t\tstate->errcode = IMAGING_CODEC_OVERRUN;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 12:\n\t    /* FLI LC chunk (byte delta) */\n\t    y = I16(data); ymax = y + I16(data+2); data += 4;\n\t    for (; y < ymax && y < state->ysize; y++) {\n\t\tUINT8* out = (UINT8*) im->image[y];\n\t\tint p, packets = *data++;\n\t\tfor (p = x = 0; p < packets; p++, x += i) {\n\t\t    x += data[0]; /* skip pixels */\n\t\t    if (data[1] & 0x80) {\n\t\t\ti = 256-data[1]; /* run */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemset(out + x, data[2], i);\n\t\t\tdata += 3;\n\t\t    } else {\n\t\t\ti = data[1]; /* chunk */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(out + x, data + 2, i);\n\t\t\tdata += i + 2;\n\t\t    }\n\t\t}\n\t\tif (p < packets)\n\t\t    break; /* didn't process all packets */\n\t    }\n\t    if (y < ymax) {\n\t\t/* didn't process all lines */\n\t\tstate->errcode = IMAGING_CODEC_OVERRUN;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 13:\n\t    /* FLI BLACK chunk */\n\t    for (y = 0; y < state->ysize; y++)\n\t\tmemset(im->image[y], 0, state->xsize);\n\t    break;\n\tcase 15:\n\t    /* FLI BRUN chunk */\n\t    for (y = 0; y < state->ysize; y++) {\n\t\tUINT8* out = (UINT8*) im->image[y];\n\t\tdata += 1; /* ignore packetcount byte */\n\t\tfor (x = 0; x < state->xsize; x += i) {\n\t\t    if (data[0] & 0x80) {\n\t\t\ti = 256 - data[0];\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break; /* safety first */\n\t\t\tmemcpy(out + x, data + 1, i);\n\t\t\tdata += i + 1;\n\t\t    } else {\n\t\t\ti = data[0];\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break; /* safety first */\n\t\t\tmemset(out + x, data[1], i);\n\t\t\tdata += 2;\n\t\t    }\n\t\t}\n\t\tif (x != state->xsize) {\n\t\t    /* didn't unpack whole line */\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    return -1;\n\t\t}\n\t    }\n\t    break;\n\tcase 16:\n\t    /* COPY chunk */\n\t    for (y = 0; y < state->ysize; y++) {\n\t\tUINT8* buf = (UINT8*) im->image[y];\n\t\tmemcpy(buf, data, state->xsize);\n\t\tdata += state->xsize;\n\t    }\n\t    break;\n\tcase 18:\n\t    /* PSTAMP chunk */\n\t    break; /* ignored */\n\tdefault:\n\t    /* unknown chunk */\n\t    /* printf(\"unknown FLI/FLC chunk: %d\\n\", I16(ptr+4)); */\n\t    state->errcode = IMAGING_CODEC_UNKNOWN;\n\t    return -1;\n\t}\n\tadvance = I32(ptr);\n\tptr += advance;\n\tbytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}",
    "abstract_func_before": "int\nImagingFliDecode(Imaging VAR_0, ImagingCodecState VAR_1, UINT8* VAR_2, Py_ssize_t VAR_3)\n{\n    UINT8* VAR_4;\n    int VAR_5;\n    int VAR_6, VAR_7, VAR_8;\n    int VAR_9, VAR_10;\n    int VAR_11, VAR_12, VAR_13 = 0, VAR_14, VAR_15;\n\n    /* COMMENT_0 */\n\n    if (VAR_3 < 4)\n\treturn 0;\n\n    /* COMMENT_1 */\n                                                                     \n                                             \n\n    VAR_4 = VAR_2;\n\n    VAR_5 = I32(VAR_4);\n    if (VAR_5 < I32(VAR_4))\n\treturn 0;\n\n    /* COMMENT_4 */\n                                    \n\n    if (I16(VAR_4+4) != 0xF1FA) {\n\tVAR_1->errcode = VAR_16;\n\treturn -1;\n    }\n\n    VAR_7 = I16(VAR_4+6);\n    VAR_4 += 16;\n    VAR_3 -= 16;\n\n    /* COMMENT_6 */\n    for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {\n\tUINT8* VAR_17;\n\tif (VAR_3 < 10) {\n\t    VAR_1->errcode = VAR_18;\n\t    return -1;\n\t}\n\tVAR_17 = VAR_4 + 6;\n\tswitch (I16(VAR_4+4)) {\n\tcase 4: case 11:\n\t    /* COMMENT_7 */\n\t    break; /* COMMENT_8 */\n\tcase 7:\n\t    /* COMMENT_9 */\n\t    VAR_10 = I16(VAR_17); VAR_17 += 2;\n\t    for (VAR_9 = VAR_14 = 0; VAR_9 < VAR_10 && VAR_14 < VAR_1->ysize; VAR_9++, VAR_14++) {\n\t\tUINT8* VAR_2 = (UINT8*) VAR_0->image[VAR_14];\n\t\tint VAR_19, VAR_20;\n\t\tVAR_20 = I16(VAR_17); VAR_17 += 2;\n\t\twhile (VAR_20 & 0x8000) {\n\t\t    /* COMMENT_10 */\n\t\t    if (VAR_20 & 0x4000) {\n\t\t\tVAR_14 += 65536 - VAR_20; /* COMMENT_11 */\n\t\t\tif (VAR_14 >= VAR_1->ysize) {\n\t\t\t    VAR_1->errcode = VAR_18;\n\t\t\t    return -1;\n\t\t\t}\n\t\t\tVAR_2 = (UINT8*) VAR_0->image[VAR_14];\n\t\t    } else {\n\t\t\t/* COMMENT_12 */\n\t\t\tVAR_2[VAR_1->xsize-1] = (UINT8) VAR_20;\n\t\t    }\n\t\t    VAR_20 = I16(VAR_17); VAR_17 += 2;\n\t\t}\n\t\tfor (VAR_19 = VAR_13 = 0; VAR_19 < VAR_20; VAR_19++) {\n\t\t    VAR_13 += VAR_17[0]; /* COMMENT_13 */\n\t\t    if (VAR_17[1] >= 128) {\n\t\t\tVAR_11 = 256-VAR_17[1]; /* COMMENT_14 */\n\t\t\tif (VAR_13 + VAR_11 + VAR_11 > VAR_1->xsize)\n\t\t\t    break;\n\t\t\tfor (VAR_12 = 0; VAR_12 < VAR_11; VAR_12++) {\n\t\t\t    VAR_2[VAR_13++] = VAR_17[2];\n\t\t\t    VAR_2[VAR_13++] = VAR_17[3];\n\t\t\t}\n\t\t\tVAR_17 += 2 + 2;\n\t\t    } else {\n\t\t\tVAR_11 = 2 * (int) VAR_17[1]; /* COMMENT_15 */\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(VAR_2 + VAR_13, VAR_17 + 2, VAR_11);\n\t\t\tVAR_17 += 2 + VAR_11;\n\t\t\tVAR_13 += VAR_11;\n\t\t    }\n\t\t}\n\t\tif (VAR_19 < VAR_20)\n\t\t    break; /* COMMENT_16 */\n\t    }\n\t    if (VAR_9 < VAR_10) {\n\t\t/* COMMENT_17 */\n\t\tVAR_1->errcode = VAR_18;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 12:\n\t    /* COMMENT_18 */\n\t    VAR_14 = I16(VAR_17); VAR_15 = VAR_14 + I16(VAR_17+2); VAR_17 += 4;\n\t    for (; VAR_14 < VAR_15 && VAR_14 < VAR_1->ysize; VAR_14++) {\n\t\tUINT8* VAR_21 = (UINT8*) VAR_0->image[VAR_14];\n\t\tint VAR_19, VAR_20 = *VAR_17++;\n\t\tfor (VAR_19 = VAR_13 = 0; VAR_19 < VAR_20; VAR_19++, VAR_13 += VAR_11) {\n\t\t    VAR_13 += VAR_17[0]; /* COMMENT_19 */\n\t\t    if (VAR_17[1] & 0x80) {\n\t\t\tVAR_11 = 256-VAR_17[1]; /* COMMENT_14 */\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break;\n\t\t\tmemset(VAR_21 + VAR_13, VAR_17[2], VAR_11);\n\t\t\tVAR_17 += 3;\n\t\t    } else {\n\t\t\tVAR_11 = VAR_17[1]; /* COMMENT_15 */\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(VAR_21 + VAR_13, VAR_17 + 2, VAR_11);\n\t\t\tVAR_17 += VAR_11 + 2;\n\t\t    }\n\t\t}\n\t\tif (VAR_19 < VAR_20)\n\t\t    break; /* COMMENT_16 */\n\t    }\n\t    if (VAR_14 < VAR_15) {\n\t\t/* COMMENT_17 */\n\t\tVAR_1->errcode = VAR_18;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 13:\n\t    /* COMMENT_20 */\n\t    for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++)\n\t\tmemset(VAR_0->image[VAR_14], 0, VAR_1->xsize);\n\t    break;\n\tcase 15:\n\t    /* COMMENT_21 */\n\t    for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n\t\tUINT8* VAR_21 = (UINT8*) VAR_0->image[VAR_14];\n\t\tVAR_17 += 1; /* COMMENT_22 */\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_1->xsize; VAR_13 += VAR_11) {\n\t\t    if (VAR_17[0] & 0x80) {\n\t\t\tVAR_11 = 256 - VAR_17[0];\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break; /* COMMENT_23 */\n\t\t\tmemcpy(VAR_21 + VAR_13, VAR_17 + 1, VAR_11);\n\t\t\tVAR_17 += VAR_11 + 1;\n\t\t    } else {\n\t\t\tVAR_11 = VAR_17[0];\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break; /* COMMENT_23 */\n\t\t\tmemset(VAR_21 + VAR_13, VAR_17[1], VAR_11);\n\t\t\tVAR_17 += 2;\n\t\t    }\n\t\t}\n\t\tif (VAR_13 != VAR_1->xsize) {\n\t\t    /* COMMENT_24 */\n\t\t    VAR_1->errcode = VAR_18;\n\t\t    return -1;\n\t\t}\n\t    }\n\t    break;\n\tcase 16:\n\t    /* COMMENT_25 */\n\t    for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n\t\tUINT8* VAR_2 = (UINT8*) VAR_0->image[VAR_14];\n\t\tmemcpy(VAR_2, VAR_17, VAR_1->xsize);\n\t\tVAR_17 += VAR_1->xsize;\n\t    }\n\t    break;\n\tcase 18:\n\t    /* COMMENT_26 */\n\t    break; /* COMMENT_27 */\n\tdefault:\n\t    /* COMMENT_28 */\n\t    /* COMMENT_29 */\n\t    VAR_1->errcode = VAR_16;\n\t    return -1;\n\t}\n\tVAR_8 = I32(VAR_4);\n\tVAR_4 += VAR_8;\n\tVAR_3 -= VAR_8;\n    }\n\n    return -1; /* COMMENT_30 */\n}",
    "func_graph_path_before": "python-pillow/Pillow/a09acd0decd8a87ccce939d5ff65dab59e7d365b/FliDecode.c/vul/before/0.json",
    "func": "int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8* ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4)\n\treturn 0;\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr))\n\treturn 0;\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    if (I16(ptr+4) != 0xF1FA) {\n\tstate->errcode = IMAGING_CODEC_UNKNOWN;\n\treturn -1;\n    }\n\n    chunks = I16(ptr+6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n\tUINT8* data;\n\tif (bytes < 10) {\n\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t    return -1;\n\t}\n\tdata = ptr + 6;\n\tswitch (I16(ptr+4)) {\n\tcase 4: case 11:\n\t    /* FLI COLOR chunk */\n\t    break; /* ignored; handled by Python code */\n\tcase 7:\n\t    /* FLI SS2 chunk (word delta) */\n\t    lines = I16(data); data += 2;\n\t    for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n\t\tUINT8* buf = (UINT8*) im->image[y];\n\t\tint p, packets;\n\t\tpackets = I16(data); data += 2;\n\t\twhile (packets & 0x8000) {\n\t\t    /* flag word */\n\t\t    if (packets & 0x4000) {\n\t\t\ty += 65536 - packets; /* skip lines */\n\t\t\tif (y >= state->ysize) {\n\t\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t\t    return -1;\n\t\t\t}\n\t\t\tbuf = (UINT8*) im->image[y];\n\t\t    } else {\n\t\t\t/* store last byte (used if line width is odd) */\n\t\t\tbuf[state->xsize-1] = (UINT8) packets;\n\t\t    }\n\t\t    packets = I16(data); data += 2;\n\t\t}\n\t\tfor (p = x = 0; p < packets; p++) {\n\t\t    x += data[0]; /* pixel skip */\n\t\t    if (data[1] >= 128) {\n\t\t\ti = 256-data[1]; /* run */\n\t\t\tif (x + i + i > state->xsize)\n\t\t\t    break;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t    buf[x++] = data[2];\n\t\t\t    buf[x++] = data[3];\n\t\t\t}\n\t\t\tdata += 2 + 2;\n\t\t    } else {\n\t\t\ti = 2 * (int) data[1]; /* chunk */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(buf + x, data + 2, i);\n\t\t\tdata += 2 + i;\n\t\t\tx += i;\n\t\t    }\n\t\t}\n\t\tif (p < packets)\n\t\t    break; /* didn't process all packets */\n\t    }\n\t    if (l < lines) {\n\t\t/* didn't process all lines */\n\t\tstate->errcode = IMAGING_CODEC_OVERRUN;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 12:\n\t    /* FLI LC chunk (byte delta) */\n\t    y = I16(data); ymax = y + I16(data+2); data += 4;\n\t    for (; y < ymax && y < state->ysize; y++) {\n\t\tUINT8* out = (UINT8*) im->image[y];\n\t\tint p, packets = *data++;\n\t\tfor (p = x = 0; p < packets; p++, x += i) {\n\t\t    x += data[0]; /* skip pixels */\n\t\t    if (data[1] & 0x80) {\n\t\t\ti = 256-data[1]; /* run */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemset(out + x, data[2], i);\n\t\t\tdata += 3;\n\t\t    } else {\n\t\t\ti = data[1]; /* chunk */\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(out + x, data + 2, i);\n\t\t\tdata += i + 2;\n\t\t    }\n\t\t}\n\t\tif (p < packets)\n\t\t    break; /* didn't process all packets */\n\t    }\n\t    if (y < ymax) {\n\t\t/* didn't process all lines */\n\t\tstate->errcode = IMAGING_CODEC_OVERRUN;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 13:\n\t    /* FLI BLACK chunk */\n\t    for (y = 0; y < state->ysize; y++)\n\t\tmemset(im->image[y], 0, state->xsize);\n\t    break;\n\tcase 15:\n\t    /* FLI BRUN chunk */\n\t    for (y = 0; y < state->ysize; y++) {\n\t\tUINT8* out = (UINT8*) im->image[y];\n\t\tdata += 1; /* ignore packetcount byte */\n\t\tfor (x = 0; x < state->xsize; x += i) {\n\t\t    if (data[0] & 0x80) {\n\t\t\ti = 256 - data[0];\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break; /* safety first */\n\t\t\tmemcpy(out + x, data + 1, i);\n\t\t\tdata += i + 1;\n\t\t    } else {\n\t\t\ti = data[0];\n\t\t\tif (x + i > state->xsize)\n\t\t\t    break; /* safety first */\n\t\t\tmemset(out + x, data[1], i);\n\t\t\tdata += 2;\n\t\t    }\n\t\t}\n\t\tif (x != state->xsize) {\n\t\t    /* didn't unpack whole line */\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    return -1;\n\t\t}\n\t    }\n\t    break;\n\tcase 16:\n\t    /* COPY chunk */\n\t    for (y = 0; y < state->ysize; y++) {\n\t\tUINT8* buf = (UINT8*) im->image[y];\n\t\tmemcpy(buf, data, state->xsize);\n\t\tdata += state->xsize;\n\t    }\n\t    break;\n\tcase 18:\n\t    /* PSTAMP chunk */\n\t    break; /* ignored */\n\tdefault:\n\t    /* unknown chunk */\n\t    /* printf(\"unknown FLI/FLC chunk: %d\\n\", I16(ptr+4)); */\n\t    state->errcode = IMAGING_CODEC_UNKNOWN;\n\t    return -1;\n\t}\n\tadvance = I32(ptr);\n\tptr += advance;\n\tbytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}",
    "abstract_func": "int\nImagingFliDecode(Imaging VAR_0, ImagingCodecState VAR_1, UINT8* VAR_2, Py_ssize_t VAR_3)\n{\n    UINT8* VAR_4;\n    int VAR_5;\n    int VAR_6, VAR_7, VAR_8;\n    int VAR_9, VAR_10;\n    int VAR_11, VAR_12, VAR_13 = 0, VAR_14, VAR_15;\n\n    /* COMMENT_0 */\n\n    if (VAR_3 < 4)\n\treturn 0;\n\n    /* COMMENT_1 */\n                      \n\n    VAR_4 = VAR_2;\n\n    VAR_5 = I32(VAR_4);\n    if (VAR_5 < I32(VAR_4))\n\treturn 0;\n\n    /* COMMENT_3 */\n                                    \n\n    if (VAR_3 < 8) {\n        VAR_1->errcode = VAR_16;\n        return -1;\n    }\n    if (I16(VAR_4+4) != 0xF1FA) {\n\tVAR_1->errcode = VAR_17;\n\treturn -1;\n    }\n\n    VAR_7 = I16(VAR_4+6);\n    VAR_4 += 16;\n    VAR_3 -= 16;\n\n    /* COMMENT_5 */\n    for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {\n\tUINT8* VAR_18;\n\tif (VAR_3 < 10) {\n\t    VAR_1->errcode = VAR_16;\n\t    return -1;\n\t}\n\tVAR_18 = VAR_4 + 6;\n\tswitch (I16(VAR_4+4)) {\n\tcase 4: case 11:\n\t    /* COMMENT_6 */\n\t    break; /* COMMENT_7 */\n\tcase 7:\n\t    /* COMMENT_8 */\n\t    VAR_10 = I16(VAR_18); VAR_18 += 2;\n\t    for (VAR_9 = VAR_14 = 0; VAR_9 < VAR_10 && VAR_14 < VAR_1->ysize; VAR_9++, VAR_14++) {\n\t\tUINT8* VAR_2 = (UINT8*) VAR_0->image[VAR_14];\n\t\tint VAR_19, VAR_20;\n\t\tVAR_20 = I16(VAR_18); VAR_18 += 2;\n\t\twhile (VAR_20 & 0x8000) {\n\t\t    /* COMMENT_9 */\n\t\t    if (VAR_20 & 0x4000) {\n\t\t\tVAR_14 += 65536 - VAR_20; /* COMMENT_10 */\n\t\t\tif (VAR_14 >= VAR_1->ysize) {\n\t\t\t    VAR_1->errcode = VAR_16;\n\t\t\t    return -1;\n\t\t\t}\n\t\t\tVAR_2 = (UINT8*) VAR_0->image[VAR_14];\n\t\t    } else {\n\t\t\t/* COMMENT_11 */\n\t\t\tVAR_2[VAR_1->xsize-1] = (UINT8) VAR_20;\n\t\t    }\n\t\t    VAR_20 = I16(VAR_18); VAR_18 += 2;\n\t\t}\n\t\tfor (VAR_19 = VAR_13 = 0; VAR_19 < VAR_20; VAR_19++) {\n\t\t    VAR_13 += VAR_18[0]; /* COMMENT_12 */\n\t\t    if (VAR_18[1] >= 128) {\n\t\t\tVAR_11 = 256-VAR_18[1]; /* COMMENT_13 */\n\t\t\tif (VAR_13 + VAR_11 + VAR_11 > VAR_1->xsize)\n\t\t\t    break;\n\t\t\tfor (VAR_12 = 0; VAR_12 < VAR_11; VAR_12++) {\n\t\t\t    VAR_2[VAR_13++] = VAR_18[2];\n\t\t\t    VAR_2[VAR_13++] = VAR_18[3];\n\t\t\t}\n\t\t\tVAR_18 += 2 + 2;\n\t\t    } else {\n\t\t\tVAR_11 = 2 * (int) VAR_18[1]; /* COMMENT_14 */\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(VAR_2 + VAR_13, VAR_18 + 2, VAR_11);\n\t\t\tVAR_18 += 2 + VAR_11;\n\t\t\tVAR_13 += VAR_11;\n\t\t    }\n\t\t}\n\t\tif (VAR_19 < VAR_20)\n\t\t    break; /* COMMENT_15 */\n\t    }\n\t    if (VAR_9 < VAR_10) {\n\t\t/* COMMENT_16 */\n\t\tVAR_1->errcode = VAR_16;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 12:\n\t    /* COMMENT_17 */\n\t    VAR_14 = I16(VAR_18); VAR_15 = VAR_14 + I16(VAR_18+2); VAR_18 += 4;\n\t    for (; VAR_14 < VAR_15 && VAR_14 < VAR_1->ysize; VAR_14++) {\n\t\tUINT8* VAR_21 = (UINT8*) VAR_0->image[VAR_14];\n\t\tint VAR_19, VAR_20 = *VAR_18++;\n\t\tfor (VAR_19 = VAR_13 = 0; VAR_19 < VAR_20; VAR_19++, VAR_13 += VAR_11) {\n\t\t    VAR_13 += VAR_18[0]; /* COMMENT_18 */\n\t\t    if (VAR_18[1] & 0x80) {\n\t\t\tVAR_11 = 256-VAR_18[1]; /* COMMENT_13 */\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break;\n\t\t\tmemset(VAR_21 + VAR_13, VAR_18[2], VAR_11);\n\t\t\tVAR_18 += 3;\n\t\t    } else {\n\t\t\tVAR_11 = VAR_18[1]; /* COMMENT_14 */\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break;\n\t\t\tmemcpy(VAR_21 + VAR_13, VAR_18 + 2, VAR_11);\n\t\t\tVAR_18 += VAR_11 + 2;\n\t\t    }\n\t\t}\n\t\tif (VAR_19 < VAR_20)\n\t\t    break; /* COMMENT_15 */\n\t    }\n\t    if (VAR_14 < VAR_15) {\n\t\t/* COMMENT_16 */\n\t\tVAR_1->errcode = VAR_16;\n\t\treturn -1;\n\t    }\n\t    break;\n\tcase 13:\n\t    /* COMMENT_19 */\n\t    for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++)\n\t\tmemset(VAR_0->image[VAR_14], 0, VAR_1->xsize);\n\t    break;\n\tcase 15:\n\t    /* COMMENT_20 */\n\t    for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n\t\tUINT8* VAR_21 = (UINT8*) VAR_0->image[VAR_14];\n\t\tVAR_18 += 1; /* COMMENT_21 */\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_1->xsize; VAR_13 += VAR_11) {\n\t\t    if (VAR_18[0] & 0x80) {\n\t\t\tVAR_11 = 256 - VAR_18[0];\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break; /* COMMENT_22 */\n\t\t\tmemcpy(VAR_21 + VAR_13, VAR_18 + 1, VAR_11);\n\t\t\tVAR_18 += VAR_11 + 1;\n\t\t    } else {\n\t\t\tVAR_11 = VAR_18[0];\n\t\t\tif (VAR_13 + VAR_11 > VAR_1->xsize)\n\t\t\t    break; /* COMMENT_22 */\n\t\t\tmemset(VAR_21 + VAR_13, VAR_18[1], VAR_11);\n\t\t\tVAR_18 += 2;\n\t\t    }\n\t\t}\n\t\tif (VAR_13 != VAR_1->xsize) {\n\t\t    /* COMMENT_23 */\n\t\t    VAR_1->errcode = VAR_16;\n\t\t    return -1;\n\t\t}\n\t    }\n\t    break;\n\tcase 16:\n\t    /* COMMENT_24 */\n\t    for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n\t\tUINT8* VAR_2 = (UINT8*) VAR_0->image[VAR_14];\n\t\tmemcpy(VAR_2, VAR_18, VAR_1->xsize);\n\t\tVAR_18 += VAR_1->xsize;\n\t    }\n\t    break;\n\tcase 18:\n\t    /* COMMENT_25 */\n\t    break; /* COMMENT_26 */\n\tdefault:\n\t    /* COMMENT_27 */\n\t    /* COMMENT_28 */\n\t    VAR_1->errcode = VAR_17;\n\t    return -1;\n\t}\n\tVAR_8 = I32(VAR_4);\n\tVAR_4 += VAR_8;\n\tVAR_3 -= VAR_8;\n    }\n\n    return -1; /* COMMENT_29 */\n}",
    "func_graph_path": "python-pillow/Pillow/a09acd0decd8a87ccce939d5ff65dab59e7d365b/FliDecode.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -13,8 +13,7 @@\n \treturn 0;\n \n     /* We don't decode anything unless we have a full chunk in the\n-       input buffer (on the other hand, the Python part of the driver\n-       makes sure this is always the case) */\n+       input buffer */\n \n     ptr = buf;\n \n@@ -25,6 +24,10 @@\n     /* Make sure this is a frame chunk.  The Python driver takes\n        case of other chunk types. */\n \n+    if (bytes < 8) {\n+        state->errcode = IMAGING_CODEC_OVERRUN;\n+        return -1;\n+    }\n     if (I16(ptr+4) != 0xF1FA) {\n \tstate->errcode = IMAGING_CODEC_UNKNOWN;\n \treturn -1;",
    "diff_line_info": {
        "deleted_lines": [
            "       input buffer (on the other hand, the Python part of the driver",
            "       makes sure this is always the case) */"
        ],
        "added_lines": [
            "       input buffer */",
            "    if (bytes < 8) {",
            "        state->errcode = IMAGING_CODEC_OVERRUN;",
            "        return -1;",
            "    }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}