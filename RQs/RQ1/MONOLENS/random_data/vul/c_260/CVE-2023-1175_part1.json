{
    "cve_id": "CVE-2023-1175",
    "cwe_ids": [
        "CWE-131"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H",
    "cvss_is_v3": true,
    "repo_name": "vim",
    "commit_msg": "patch 9.0.1378: illegal memory access when using virtual editing\n\nProblem:    Illegal memory access when using virtual editing.\nSolution:   Make sure \"startspaces\" is not negative.",
    "commit_hash": "c99cbf8f289bdda5d4a77d7ec415850a520330ba",
    "git_url": "https://github.com/vim/vim/commit/c99cbf8f289bdda5d4a77d7ec415850a520330ba",
    "file_path": "src/register.c",
    "func_name": "op_yank",
    "func_before": "int\nop_yank(oparg_T *oap, int deleting, int mess)\n{\n    long\t\ty_idx;\t\t// index in y_array[]\n    yankreg_T\t\t*curr;\t\t// copy of y_current\n    yankreg_T\t\tnewreg;\t\t// new yank register when appending\n    char_u\t\t**new_ptr;\n    linenr_T\t\tlnum;\t\t// current line number\n    long\t\tj;\n    int\t\t\tyanktype = oap->motion_type;\n    long\t\tyanklines = oap->line_count;\n    linenr_T\t\tyankendlnum = oap->end.lnum;\n    char_u\t\t*p;\n    char_u\t\t*pnew;\n    struct block_def\tbd;\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    int\t\t\tdid_star = FALSE;\n#endif\n\n\t\t\t\t    // check for read-only register\n    if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n    if (oap->regname == '_')\t    // black hole: nothing to do\n\treturn OK;\n\n#ifdef FEAT_CLIPBOARD\n    if (!clip_star.available && oap->regname == '*')\n\toap->regname = 0;\n    else if (!clip_plus.available && oap->regname == '+')\n\toap->regname = 0;\n#endif\n\n    if (!deleting)\t\t    // op_delete() already set y_current\n\tget_yank_register(oap->regname, TRUE);\n\n    curr = y_current;\n\t\t\t\t    // append to existing contents\n    if (y_append && y_current->y_array != NULL)\n\ty_current = &newreg;\n    else\n\tfree_yank_all();\t    // free previously yanked lines\n\n    // If the cursor was in column 1 before and after the movement, and the\n    // operator is not inclusive, the yank is always linewise.\n    if (       oap->motion_type == MCHAR\n\t    && oap->start.col == 0\n\t    && !oap->inclusive\n\t    && (!oap->is_VIsual || *p_sel == 'o')\n\t    && !oap->block_mode\n\t    && oap->end.col == 0\n\t    && yanklines > 1)\n    {\n\tyanktype = MLINE;\n\t--yankendlnum;\n\t--yanklines;\n    }\n\n    y_current->y_size = yanklines;\n    y_current->y_type = yanktype;   // set the yank register type\n    y_current->y_width = 0;\n    y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);\n    if (y_current->y_array == NULL)\n    {\n\ty_current = curr;\n\treturn FAIL;\n    }\n#ifdef FEAT_VIMINFO\n    y_current->y_time_set = vim_time();\n#endif\n\n    y_idx = 0;\n    lnum = oap->start.lnum;\n\n    if (oap->block_mode)\n    {\n\t// Visual block mode\n\ty_current->y_type = MBLOCK;\t    // set the yank register type\n\ty_current->y_width = oap->end_vcol - oap->start_vcol;\n\n\tif (curwin->w_curswant == MAXCOL && y_current->y_width > 0)\n\t    y_current->y_width--;\n    }\n\n    for ( ; lnum <= yankendlnum; lnum++, y_idx++)\n    {\n\tswitch (y_current->y_type)\n\t{\n\t    case MBLOCK:\n\t\tblock_prep(oap, &bd, lnum, FALSE);\n\t\tif (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MLINE:\n\t\tif ((y_current->y_array[y_idx] =\n\t\t\t\t\t    vim_strsave(ml_get(lnum))) == NULL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MCHAR:\n\t\t{\n\t\t    colnr_T startcol = 0, endcol = MAXCOL;\n\t\t    int\t    is_oneChar = FALSE;\n\t\t    colnr_T cs, ce;\n\n\t\t    p = ml_get(lnum);\n\t\t    bd.startspaces = 0;\n\t\t    bd.endspaces = 0;\n\n\t\t    if (lnum == oap->start.lnum)\n\t\t    {\n\t\t\tstartcol = oap->start.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->start, &cs, NULL, &ce);\n\t\t\t    if (ce != cs && oap->start.coladd > 0)\n\t\t\t    {\n\t\t\t\t// Part of a tab selected -- but don't\n\t\t\t\t// double-count it.\n\t\t\t\tbd.startspaces = (ce - cs + 1)\n\t\t\t\t\t\t\t  - oap->start.coladd;\n\t\t\t\tstartcol++;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    if (lnum == oap->end.lnum)\n\t\t    {\n\t\t\tendcol = oap->end.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->end, &cs, NULL, &ce);\n\t\t\t    if (p[endcol] == NUL || (cs + oap->end.coladd < ce\n\t\t\t\t\t// Don't add space for double-wide\n\t\t\t\t\t// char; endcol will be on last byte\n\t\t\t\t\t// of multi-byte char.\n\t\t\t\t\t&& (*mb_head_off)(p, p + endcol) == 0))\n\t\t\t    {\n\t\t\t\tif (oap->start.lnum == oap->end.lnum\n\t\t\t\t\t    && oap->start.col == oap->end.col)\n\t\t\t\t{\n\t\t\t\t    // Special case: inside a single char\n\t\t\t\t    is_oneChar = TRUE;\n\t\t\t\t    bd.startspaces = oap->end.coladd\n\t\t\t\t\t - oap->start.coladd + oap->inclusive;\n\t\t\t\t    endcol = startcol;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    bd.endspaces = oap->end.coladd\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\t\t\t    endcol -= oap->inclusive;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (endcol == MAXCOL)\n\t\t\tendcol = (colnr_T)STRLEN(p);\n\t\t    if (startcol > endcol || is_oneChar)\n\t\t\tbd.textlen = 0;\n\t\t    else\n\t\t\tbd.textlen = endcol - startcol + oap->inclusive;\n\t\t    bd.textstart = p + startcol;\n\t\t    if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)\n\t\t\tgoto fail;\n\t\t    break;\n\t\t}\n\t\t// NOTREACHED\n\t}\n    }\n\n    if (curr != y_current)\t// append the new block to the old block\n    {\n\tnew_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);\n\tif (new_ptr == NULL)\n\t    goto fail;\n\tfor (j = 0; j < curr->y_size; ++j)\n\t    new_ptr[j] = curr->y_array[j];\n\tvim_free(curr->y_array);\n\tcurr->y_array = new_ptr;\n#ifdef FEAT_VIMINFO\n\tcurr->y_time_set = vim_time();\n#endif\n\n\tif (yanktype == MLINE)\t// MLINE overrides MCHAR and MBLOCK\n\t    curr->y_type = MLINE;\n\n\t// Concatenate the last line of the old block with the first line of\n\t// the new block, unless being Vi compatible.\n\tif (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)\n\t{\n\t    pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])\n\t\t\t\t\t  + STRLEN(y_current->y_array[0]) + 1);\n\t    if (pnew == NULL)\n\t    {\n\t\ty_idx = y_current->y_size - 1;\n\t\tgoto fail;\n\t    }\n\t    STRCPY(pnew, curr->y_array[--j]);\n\t    STRCAT(pnew, y_current->y_array[0]);\n\t    vim_free(curr->y_array[j]);\n\t    vim_free(y_current->y_array[0]);\n\t    curr->y_array[j++] = pnew;\n\t    y_idx = 1;\n\t}\n\telse\n\t    y_idx = 0;\n\twhile (y_idx < y_current->y_size)\n\t    curr->y_array[j++] = y_current->y_array[y_idx++];\n\tcurr->y_size = j;\n\tvim_free(y_current->y_array);\n\ty_current = curr;\n    }\n\n    if (mess)\t\t\t// Display message about yank?\n    {\n\tif (yanktype == MCHAR\n\t\t&& !oap->block_mode\n\t\t&& yanklines == 1)\n\t    yanklines = 0;\n\t// Some versions of Vi use \">=\" here, some don't...\n\tif (yanklines > p_report)\n\t{\n\t    char namebuf[100];\n\n\t    if (oap->regname == NUL)\n\t\t*namebuf = NUL;\n\t    else\n\t\tvim_snprintf(namebuf, sizeof(namebuf),\n\t\t\t\t\t\t_(\" into \\\"%c\"), oap->regname);\n\n\t    // redisplay now, so message is not deleted\n\t    update_topline_redraw();\n\t    if (oap->block_mode)\n\t    {\n\t\tsmsg(NGETTEXT(\"block of %ld line yanked%s\",\n\t\t\t\t     \"block of %ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t    else\n\t    {\n\t\tsmsg(NGETTEXT(\"%ld line yanked%s\",\n\t\t\t\t\t      \"%ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t}\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (yanktype == MLINE && !oap->block_mode)\n\t{\n\t    curbuf->b_op_start.col = 0;\n\t    curbuf->b_op_end.col = MAXCOL;\n\t}\n    }\n\n#ifdef FEAT_CLIPBOARD\n    // If we were yanking to the '*' register, send result to clipboard.\n    // If no register was specified, and \"unnamed\" in 'clipboard', make a copy\n    // to the '*' register.\n    if (clip_star.available\n\t    && (curr == &(y_regs[STAR_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t   && ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))\n    {\n\tif (curr != &(y_regs[STAR_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\n\tclip_own_selection(&clip_star);\n\tclip_gen_set_selection(&clip_star);\n# ifdef FEAT_X11\n\tdid_star = TRUE;\n# endif\n    }\n\n# ifdef FEAT_X11\n    // If we were yanking to the '+' register, send result to selection.\n    // Also copy to the '*' register, in case auto-select is off.  But not when\n    // 'clipboard' has \"unnamedplus\" and not \"unnamed\"; and not when\n    // deleting and both \"unnamedplus\" and \"unnamed\".\n    if (clip_plus.available\n\t    && (curr == &(y_regs[PLUS_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t  && ((clip_unnamed | clip_unnamed_saved) &\n\t\t\t\t\t\t\t  CLIP_UNNAMED_PLUS))))\n    {\n\tif (curr != &(y_regs[PLUS_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[PLUS_REGISTER]));\n\n\tclip_own_selection(&clip_plus);\n\tclip_gen_set_selection(&clip_plus);\n\tif (!clip_isautosel_star()\n\t\t&& !clip_isautosel_plus()\n\t\t&& !((clip_unnamed | clip_unnamed_saved) == CLIP_UNNAMED_PLUS)\n\t\t&& !(deleting && (clip_unnamed | clip_unnamed_saved)\n\t\t\t\t\t == (CLIP_UNNAMED | CLIP_UNNAMED_PLUS))\n\t\t&& !did_star\n\t\t&& curr == &(y_regs[PLUS_REGISTER]))\n\t{\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\t    clip_own_selection(&clip_star);\n\t    clip_gen_set_selection(&clip_star);\n\t}\n    }\n# endif\n#endif\n\n#if defined(FEAT_EVAL)\n    if (!deleting && has_textyankpost())\n\tyank_do_autocmd(oap, y_current);\n#endif\n\n    return OK;\n\nfail:\t\t// free the allocated lines\n    free_yank(y_idx + 1);\n    y_current = curr;\n    return FAIL;\n}",
    "abstract_func_before": "int\nop_yank(oparg_T *VAR_0, int VAR_1, int VAR_2)\n{\n    long\t\tVAR_3;\t\t/* COMMENT_0 */\n    yankreg_T\t\t*VAR_4;\t\t/* COMMENT_1 */\n    yankreg_T\t\tVAR_5;\t\t/* COMMENT_2 */\n    char_u\t\t**VAR_6;\n    linenr_T\t\tVAR_7;\t\t/* COMMENT_3 */\n    long\t\tVAR_8;\n    int\t\t\tVAR_9 = VAR_0->motion_type;\n    long\t\tVAR_10 = VAR_0->line_count;\n    linenr_T\t\tVAR_11 = VAR_0->end.lnum;\n    char_u\t\t*VAR_12;\n    char_u\t\t*VAR_13;\n    struct block_def\tVAR_14;\n#if defined(VAR_15) && defined(VAR_16)\n    int\t\t\tVAR_17 = FALSE;\n#endif\n\n\t\t\t\t    /* COMMENT_4 */\n    if (VAR_0->regname != 0 && !valid_yank_reg(VAR_0->regname, TRUE))\n    {\n\tbeep_flush();\n\treturn VAR_18;\n    }\n    if (VAR_0->regname == '_')\t    /* COMMENT_5 */\n\treturn VAR_19;\n\n#ifdef VAR_15\n    if (!VAR_20.available && VAR_0->regname == '*')\n\tVAR_0->regname = 0;\n    else if (!VAR_21.available && VAR_0->regname == '+')\n\tVAR_0->regname = 0;\n#endif\n\n    if (!VAR_1)\t\t    /* COMMENT_6 */\n\tget_yank_register(VAR_0->regname, TRUE);\n\n    VAR_4 = VAR_22;\n\t\t\t\t    /* COMMENT_7 */\n    if (VAR_23 && VAR_22->y_array != NULL)\n\tVAR_22 = &VAR_5;\n    else\n\tfree_yank_all();\t    /* COMMENT_8 */\n\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    if (       VAR_0->motion_type == VAR_24\n\t    && VAR_0->start.col == 0\n\t    && !VAR_0->inclusive\n\t    && (!VAR_0->is_VIsual || *VAR_25 == 'o')\n\t    && !VAR_0->block_mode\n\t    && VAR_0->end.col == 0\n\t    && VAR_10 > 1)\n    {\n\tVAR_9 = VAR_26;\n\t--VAR_11;\n\t--VAR_10;\n    }\n\n    VAR_22->y_size = VAR_10;\n    VAR_22->y_type = VAR_9;   /* COMMENT_11 */\n    VAR_22->y_width = 0;\n    VAR_22->y_array = lalloc_clear(sizeof(char_u *) * VAR_10, TRUE);\n    if (VAR_22->y_array == NULL)\n    {\n\tVAR_22 = VAR_4;\n\treturn VAR_18;\n    }\n#ifdef VAR_27\n    VAR_22->y_time_set = vim_time();\n#endif\n\n    VAR_3 = 0;\n    VAR_7 = VAR_0->start.lnum;\n\n    if (VAR_0->block_mode)\n    {\n\t/* COMMENT_12 */\n\tVAR_22->y_type = VAR_28;\t    /* COMMENT_11 */\n\tVAR_22->y_width = VAR_0->end_vcol - VAR_0->start_vcol;\n\n\tif (VAR_29->w_curswant == VAR_30 && VAR_22->y_width > 0)\n\t    VAR_22->y_width--;\n    }\n\n    for ( ; VAR_7 <= VAR_11; VAR_7++, VAR_3++)\n    {\n\tswitch (VAR_22->y_type)\n\t{\n\t    case VAR_28:\n\t\tblock_prep(VAR_0, &VAR_14, VAR_7, FALSE);\n\t\tif (yank_copy_line(&VAR_14, VAR_3, VAR_0->excl_tr_ws) == VAR_18)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case VAR_26:\n\t\tif ((VAR_22->y_array[VAR_3] =\n\t\t\t\t\t    vim_strsave(ml_get(VAR_7))) == NULL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case VAR_24:\n\t\t{\n\t\t    colnr_T VAR_31 = 0, VAR_32 = VAR_30;\n\t\t    int\t    VAR_33 = FALSE;\n\t\t    colnr_T VAR_34, VAR_35;\n\n\t\t    VAR_12 = ml_get(VAR_7);\n\t\t    VAR_14.startspaces = 0;\n\t\t    VAR_14.endspaces = 0;\n\n\t\t    if (VAR_7 == VAR_0->start.lnum)\n\t\t    {\n\t\t\tVAR_31 = VAR_0->start.col;\n\t\t\tif (VAR_36)\n\t\t\t{\n\t\t\t    getvcol(VAR_29, &VAR_0->start, &VAR_34, NULL, &VAR_35);\n\t\t\t    if (VAR_35 != VAR_34 && VAR_0->start.coladd > 0)\n\t\t\t    {\n\t\t\t\t/* COMMENT_13 */\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tVAR_14.startspaces = (VAR_35 - VAR_34 + 1)\n\t\t\t\t\t\t\t  - VAR_0->start.coladd;\n\t\t\t\tVAR_31++;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    if (VAR_7 == VAR_0->end.lnum)\n\t\t    {\n\t\t\tVAR_32 = VAR_0->end.col;\n\t\t\tif (VAR_36)\n\t\t\t{\n\t\t\t    getvcol(VAR_29, &VAR_0->end, &VAR_34, NULL, &VAR_35);\n\t\t\t    if (VAR_12[VAR_32] == VAR_37 || (VAR_34 + VAR_0->end.coladd < VAR_35\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_16 */\n\t\t\t\t\t/* COMMENT_17 */\n\t\t\t\t\t&& (*VAR_38)(VAR_12, VAR_12 + VAR_32) == 0))\n\t\t\t    {\n\t\t\t\tif (VAR_0->start.lnum == VAR_0->end.lnum\n\t\t\t\t\t    && VAR_0->start.col == VAR_0->end.col)\n\t\t\t\t{\n\t\t\t\t    /* COMMENT_18 */\n\t\t\t\t    VAR_33 = TRUE;\n\t\t\t\t    VAR_14.startspaces = VAR_0->end.coladd\n\t\t\t\t\t - VAR_0->start.coladd + VAR_0->inclusive;\n\t\t\t\t    VAR_32 = VAR_31;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    VAR_14.endspaces = VAR_0->end.coladd\n\t\t\t\t\t\t\t     + VAR_0->inclusive;\n\t\t\t\t    VAR_32 -= VAR_0->inclusive;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (VAR_32 == VAR_30)\n\t\t\tVAR_32 = (colnr_T)STRLEN(VAR_12);\n\t\t    if (VAR_31 > VAR_32 || VAR_33)\n\t\t\tVAR_14.textlen = 0;\n\t\t    else\n\t\t\tVAR_14.textlen = VAR_32 - VAR_31 + VAR_0->inclusive;\n\t\t    VAR_14.textstart = VAR_12 + VAR_31;\n\t\t    if (yank_copy_line(&VAR_14, VAR_3, FALSE) == VAR_18)\n\t\t\tgoto fail;\n\t\t    break;\n\t\t}\n\t\t/* COMMENT_19 */\n\t}\n    }\n\n    if (VAR_4 != VAR_22)\t/* COMMENT_20 */\n    {\n\tVAR_6 = ALLOC_MULT(char_u *, VAR_4->y_size + VAR_22->y_size);\n\tif (VAR_6 == NULL)\n\t    goto fail;\n\tfor (VAR_8 = 0; VAR_8 < VAR_4->y_size; ++VAR_8)\n\t    VAR_6[VAR_8] = VAR_4->y_array[VAR_8];\n\tvim_free(VAR_4->y_array);\n\tVAR_4->y_array = VAR_6;\n#ifdef VAR_27\n\tVAR_4->y_time_set = vim_time();\n#endif\n\n\tif (VAR_9 == VAR_26)\t/* COMMENT_21 */\n\t    VAR_4->y_type = VAR_26;\n\n\t/* COMMENT_22 */\n\t/* COMMENT_23 */\n\tif (VAR_4->y_type == VAR_24 && vim_strchr(VAR_39, VAR_40) == NULL)\n\t{\n\t    VAR_13 = alloc(STRLEN(VAR_4->y_array[VAR_4->y_size - 1])\n\t\t\t\t\t  + STRLEN(VAR_22->y_array[0]) + 1);\n\t    if (VAR_13 == NULL)\n\t    {\n\t\tVAR_3 = VAR_22->y_size - 1;\n\t\tgoto fail;\n\t    }\n\t    STRCPY(VAR_13, VAR_4->y_array[--VAR_8]);\n\t    STRCAT(VAR_13, VAR_22->y_array[0]);\n\t    vim_free(VAR_4->y_array[VAR_8]);\n\t    vim_free(VAR_22->y_array[0]);\n\t    VAR_4->y_array[VAR_8++] = VAR_13;\n\t    VAR_3 = 1;\n\t}\n\telse\n\t    VAR_3 = 0;\n\twhile (VAR_3 < VAR_22->y_size)\n\t    VAR_4->y_array[VAR_8++] = VAR_22->y_array[VAR_3++];\n\tVAR_4->y_size = VAR_8;\n\tvim_free(VAR_22->y_array);\n\tVAR_22 = VAR_4;\n    }\n\n    if (VAR_2)\t\t\t/* COMMENT_24 */\n    {\n\tif (VAR_9 == VAR_24\n\t\t&& !VAR_0->block_mode\n\t\t&& VAR_10 == 1)\n\t    VAR_10 = 0;\n\t/* COMMENT_25 */\n\tif (VAR_10 > VAR_41)\n\t{\n\t    char VAR_42[100];\n\n\t    if (VAR_0->regname == VAR_37)\n\t\t*VAR_42 = VAR_37;\n\t    else\n\t\tvim_snprintf(VAR_42, sizeof(VAR_42),\n\t\t\t\t\t\t_(\" into \\\"%c\"), VAR_0->regname);\n\n\t    /* COMMENT_26 */\n\t    update_topline_redraw();\n\t    if (VAR_0->block_mode)\n\t    {\n\t\tsmsg(NGETTEXT(\"block of %ld line yanked%s\",\n\t\t\t\t     \"block of %ld lines yanked%s\", VAR_10),\n\t\t\tVAR_10, VAR_42);\n\t    }\n\t    else\n\t    {\n\t\tsmsg(NGETTEXT(\"%ld line yanked%s\",\n\t\t\t\t\t      \"%ld lines yanked%s\", VAR_10),\n\t\t\tVAR_10, VAR_42);\n\t    }\n\t}\n    }\n\n    if ((VAR_43.cmod_flags & VAR_44) == 0)\n    {\n\t/* COMMENT_27 */\n\tVAR_45->b_op_start = VAR_0->start;\n\tVAR_45->b_op_end = VAR_0->end;\n\tif (VAR_9 == VAR_26 && !VAR_0->block_mode)\n\t{\n\t    VAR_45->b_op_start.col = 0;\n\t    VAR_45->b_op_end.col = VAR_30;\n\t}\n    }\n\n#ifdef VAR_15\n    /* COMMENT_28 */\n    /* COMMENT_29 */\n    /* COMMENT_30 */\n    if (VAR_20.available\n\t    && (VAR_4 == &(VAR_46[VAR_47])\n\t\t|| (!VAR_1 && VAR_0->regname == 0\n\t\t   && ((VAR_48 | VAR_49) & VAR_50))))\n    {\n\tif (VAR_4 != &(VAR_46[VAR_47]))\n\t    /* COMMENT_31 */\n\t    copy_yank_reg(&(VAR_46[VAR_47]));\n\n\tclip_own_selection(&VAR_20);\n\tclip_gen_set_selection(&VAR_20);\n# ifdef VAR_16\n\tVAR_17 = TRUE;\n# endif\n    }\n\n# ifdef VAR_16\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    /* COMMENT_34 */\n    /* COMMENT_35 */\n    if (VAR_21.available\n\t    && (VAR_4 == &(VAR_46[VAR_51])\n\t\t|| (!VAR_1 && VAR_0->regname == 0\n\t\t  && ((VAR_48 | VAR_49) &\n\t\t\t\t\t\t\t  VAR_52))))\n    {\n\tif (VAR_4 != &(VAR_46[VAR_51]))\n\t    /* COMMENT_31 */\n\t    copy_yank_reg(&(VAR_46[VAR_51]));\n\n\tclip_own_selection(&VAR_21);\n\tclip_gen_set_selection(&VAR_21);\n\tif (!clip_isautosel_star()\n\t\t&& !clip_isautosel_plus()\n\t\t&& !((VAR_48 | VAR_49) == VAR_52)\n\t\t&& !(VAR_1 && (VAR_48 | VAR_49)\n\t\t\t\t\t == (VAR_50 | VAR_52))\n\t\t&& !VAR_17\n\t\t&& VAR_4 == &(VAR_46[VAR_51]))\n\t{\n\t    copy_yank_reg(&(VAR_46[VAR_47]));\n\t    clip_own_selection(&VAR_20);\n\t    clip_gen_set_selection(&VAR_20);\n\t}\n    }\n# endif\n#endif\n\n#if defined(VAR_53)\n    if (!VAR_1 && has_textyankpost())\n\tyank_do_autocmd(VAR_0, VAR_22);\n#endif\n\n    return VAR_19;\n\nfail:\t\t/* COMMENT_36 */\n    free_yank(VAR_3 + 1);\n    VAR_22 = VAR_4;\n    return VAR_18;\n}",
    "func_graph_path_before": "vim/c99cbf8f289bdda5d4a77d7ec415850a520330ba/register.c/vul/before/0.json",
    "func": "int\nop_yank(oparg_T *oap, int deleting, int mess)\n{\n    long\t\ty_idx;\t\t// index in y_array[]\n    yankreg_T\t\t*curr;\t\t// copy of y_current\n    yankreg_T\t\tnewreg;\t\t// new yank register when appending\n    char_u\t\t**new_ptr;\n    linenr_T\t\tlnum;\t\t// current line number\n    long\t\tj;\n    int\t\t\tyanktype = oap->motion_type;\n    long\t\tyanklines = oap->line_count;\n    linenr_T\t\tyankendlnum = oap->end.lnum;\n    char_u\t\t*p;\n    char_u\t\t*pnew;\n    struct block_def\tbd;\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    int\t\t\tdid_star = FALSE;\n#endif\n\n\t\t\t\t    // check for read-only register\n    if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n    if (oap->regname == '_')\t    // black hole: nothing to do\n\treturn OK;\n\n#ifdef FEAT_CLIPBOARD\n    if (!clip_star.available && oap->regname == '*')\n\toap->regname = 0;\n    else if (!clip_plus.available && oap->regname == '+')\n\toap->regname = 0;\n#endif\n\n    if (!deleting)\t\t    // op_delete() already set y_current\n\tget_yank_register(oap->regname, TRUE);\n\n    curr = y_current;\n\t\t\t\t    // append to existing contents\n    if (y_append && y_current->y_array != NULL)\n\ty_current = &newreg;\n    else\n\tfree_yank_all();\t    // free previously yanked lines\n\n    // If the cursor was in column 1 before and after the movement, and the\n    // operator is not inclusive, the yank is always linewise.\n    if (       oap->motion_type == MCHAR\n\t    && oap->start.col == 0\n\t    && !oap->inclusive\n\t    && (!oap->is_VIsual || *p_sel == 'o')\n\t    && !oap->block_mode\n\t    && oap->end.col == 0\n\t    && yanklines > 1)\n    {\n\tyanktype = MLINE;\n\t--yankendlnum;\n\t--yanklines;\n    }\n\n    y_current->y_size = yanklines;\n    y_current->y_type = yanktype;   // set the yank register type\n    y_current->y_width = 0;\n    y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);\n    if (y_current->y_array == NULL)\n    {\n\ty_current = curr;\n\treturn FAIL;\n    }\n#ifdef FEAT_VIMINFO\n    y_current->y_time_set = vim_time();\n#endif\n\n    y_idx = 0;\n    lnum = oap->start.lnum;\n\n    if (oap->block_mode)\n    {\n\t// Visual block mode\n\ty_current->y_type = MBLOCK;\t    // set the yank register type\n\ty_current->y_width = oap->end_vcol - oap->start_vcol;\n\n\tif (curwin->w_curswant == MAXCOL && y_current->y_width > 0)\n\t    y_current->y_width--;\n    }\n\n    for ( ; lnum <= yankendlnum; lnum++, y_idx++)\n    {\n\tswitch (y_current->y_type)\n\t{\n\t    case MBLOCK:\n\t\tblock_prep(oap, &bd, lnum, FALSE);\n\t\tif (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MLINE:\n\t\tif ((y_current->y_array[y_idx] =\n\t\t\t\t\t    vim_strsave(ml_get(lnum))) == NULL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MCHAR:\n\t\t{\n\t\t    colnr_T startcol = 0, endcol = MAXCOL;\n\t\t    int\t    is_oneChar = FALSE;\n\t\t    colnr_T cs, ce;\n\n\t\t    p = ml_get(lnum);\n\t\t    bd.startspaces = 0;\n\t\t    bd.endspaces = 0;\n\n\t\t    if (lnum == oap->start.lnum)\n\t\t    {\n\t\t\tstartcol = oap->start.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->start, &cs, NULL, &ce);\n\t\t\t    if (ce != cs && oap->start.coladd > 0)\n\t\t\t    {\n\t\t\t\t// Part of a tab selected -- but don't\n\t\t\t\t// double-count it.\n\t\t\t\tbd.startspaces = (ce - cs + 1)\n\t\t\t\t\t\t\t  - oap->start.coladd;\n\t\t\t\tif (bd.startspaces < 0)\n\t\t\t\t    bd.startspaces = 0;\n\t\t\t\tstartcol++;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    if (lnum == oap->end.lnum)\n\t\t    {\n\t\t\tendcol = oap->end.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->end, &cs, NULL, &ce);\n\t\t\t    if (p[endcol] == NUL || (cs + oap->end.coladd < ce\n\t\t\t\t\t// Don't add space for double-wide\n\t\t\t\t\t// char; endcol will be on last byte\n\t\t\t\t\t// of multi-byte char.\n\t\t\t\t\t&& (*mb_head_off)(p, p + endcol) == 0))\n\t\t\t    {\n\t\t\t\tif (oap->start.lnum == oap->end.lnum\n\t\t\t\t\t    && oap->start.col == oap->end.col)\n\t\t\t\t{\n\t\t\t\t    // Special case: inside a single char\n\t\t\t\t    is_oneChar = TRUE;\n\t\t\t\t    bd.startspaces = oap->end.coladd\n\t\t\t\t\t - oap->start.coladd + oap->inclusive;\n\t\t\t\t    endcol = startcol;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    bd.endspaces = oap->end.coladd\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\t\t\t    endcol -= oap->inclusive;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (endcol == MAXCOL)\n\t\t\tendcol = (colnr_T)STRLEN(p);\n\t\t    if (startcol > endcol || is_oneChar)\n\t\t\tbd.textlen = 0;\n\t\t    else\n\t\t\tbd.textlen = endcol - startcol + oap->inclusive;\n\t\t    bd.textstart = p + startcol;\n\t\t    if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)\n\t\t\tgoto fail;\n\t\t    break;\n\t\t}\n\t\t// NOTREACHED\n\t}\n    }\n\n    if (curr != y_current)\t// append the new block to the old block\n    {\n\tnew_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);\n\tif (new_ptr == NULL)\n\t    goto fail;\n\tfor (j = 0; j < curr->y_size; ++j)\n\t    new_ptr[j] = curr->y_array[j];\n\tvim_free(curr->y_array);\n\tcurr->y_array = new_ptr;\n#ifdef FEAT_VIMINFO\n\tcurr->y_time_set = vim_time();\n#endif\n\n\tif (yanktype == MLINE)\t// MLINE overrides MCHAR and MBLOCK\n\t    curr->y_type = MLINE;\n\n\t// Concatenate the last line of the old block with the first line of\n\t// the new block, unless being Vi compatible.\n\tif (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)\n\t{\n\t    pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])\n\t\t\t\t\t  + STRLEN(y_current->y_array[0]) + 1);\n\t    if (pnew == NULL)\n\t    {\n\t\ty_idx = y_current->y_size - 1;\n\t\tgoto fail;\n\t    }\n\t    STRCPY(pnew, curr->y_array[--j]);\n\t    STRCAT(pnew, y_current->y_array[0]);\n\t    vim_free(curr->y_array[j]);\n\t    vim_free(y_current->y_array[0]);\n\t    curr->y_array[j++] = pnew;\n\t    y_idx = 1;\n\t}\n\telse\n\t    y_idx = 0;\n\twhile (y_idx < y_current->y_size)\n\t    curr->y_array[j++] = y_current->y_array[y_idx++];\n\tcurr->y_size = j;\n\tvim_free(y_current->y_array);\n\ty_current = curr;\n    }\n\n    if (mess)\t\t\t// Display message about yank?\n    {\n\tif (yanktype == MCHAR\n\t\t&& !oap->block_mode\n\t\t&& yanklines == 1)\n\t    yanklines = 0;\n\t// Some versions of Vi use \">=\" here, some don't...\n\tif (yanklines > p_report)\n\t{\n\t    char namebuf[100];\n\n\t    if (oap->regname == NUL)\n\t\t*namebuf = NUL;\n\t    else\n\t\tvim_snprintf(namebuf, sizeof(namebuf),\n\t\t\t\t\t\t_(\" into \\\"%c\"), oap->regname);\n\n\t    // redisplay now, so message is not deleted\n\t    update_topline_redraw();\n\t    if (oap->block_mode)\n\t    {\n\t\tsmsg(NGETTEXT(\"block of %ld line yanked%s\",\n\t\t\t\t     \"block of %ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t    else\n\t    {\n\t\tsmsg(NGETTEXT(\"%ld line yanked%s\",\n\t\t\t\t\t      \"%ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t}\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (yanktype == MLINE && !oap->block_mode)\n\t{\n\t    curbuf->b_op_start.col = 0;\n\t    curbuf->b_op_end.col = MAXCOL;\n\t}\n    }\n\n#ifdef FEAT_CLIPBOARD\n    // If we were yanking to the '*' register, send result to clipboard.\n    // If no register was specified, and \"unnamed\" in 'clipboard', make a copy\n    // to the '*' register.\n    if (clip_star.available\n\t    && (curr == &(y_regs[STAR_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t   && ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))\n    {\n\tif (curr != &(y_regs[STAR_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\n\tclip_own_selection(&clip_star);\n\tclip_gen_set_selection(&clip_star);\n# ifdef FEAT_X11\n\tdid_star = TRUE;\n# endif\n    }\n\n# ifdef FEAT_X11\n    // If we were yanking to the '+' register, send result to selection.\n    // Also copy to the '*' register, in case auto-select is off.  But not when\n    // 'clipboard' has \"unnamedplus\" and not \"unnamed\"; and not when\n    // deleting and both \"unnamedplus\" and \"unnamed\".\n    if (clip_plus.available\n\t    && (curr == &(y_regs[PLUS_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t  && ((clip_unnamed | clip_unnamed_saved) &\n\t\t\t\t\t\t\t  CLIP_UNNAMED_PLUS))))\n    {\n\tif (curr != &(y_regs[PLUS_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[PLUS_REGISTER]));\n\n\tclip_own_selection(&clip_plus);\n\tclip_gen_set_selection(&clip_plus);\n\tif (!clip_isautosel_star()\n\t\t&& !clip_isautosel_plus()\n\t\t&& !((clip_unnamed | clip_unnamed_saved) == CLIP_UNNAMED_PLUS)\n\t\t&& !(deleting && (clip_unnamed | clip_unnamed_saved)\n\t\t\t\t\t == (CLIP_UNNAMED | CLIP_UNNAMED_PLUS))\n\t\t&& !did_star\n\t\t&& curr == &(y_regs[PLUS_REGISTER]))\n\t{\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\t    clip_own_selection(&clip_star);\n\t    clip_gen_set_selection(&clip_star);\n\t}\n    }\n# endif\n#endif\n\n#if defined(FEAT_EVAL)\n    if (!deleting && has_textyankpost())\n\tyank_do_autocmd(oap, y_current);\n#endif\n\n    return OK;\n\nfail:\t\t// free the allocated lines\n    free_yank(y_idx + 1);\n    y_current = curr;\n    return FAIL;\n}",
    "abstract_func": "int\nop_yank(oparg_T *VAR_0, int VAR_1, int VAR_2)\n{\n    long\t\tVAR_3;\t\t/* COMMENT_0 */\n    yankreg_T\t\t*VAR_4;\t\t/* COMMENT_1 */\n    yankreg_T\t\tVAR_5;\t\t/* COMMENT_2 */\n    char_u\t\t**VAR_6;\n    linenr_T\t\tVAR_7;\t\t/* COMMENT_3 */\n    long\t\tVAR_8;\n    int\t\t\tVAR_9 = VAR_0->motion_type;\n    long\t\tVAR_10 = VAR_0->line_count;\n    linenr_T\t\tVAR_11 = VAR_0->end.lnum;\n    char_u\t\t*VAR_12;\n    char_u\t\t*VAR_13;\n    struct block_def\tVAR_14;\n#if defined(VAR_15) && defined(VAR_16)\n    int\t\t\tVAR_17 = FALSE;\n#endif\n\n\t\t\t\t    /* COMMENT_4 */\n    if (VAR_0->regname != 0 && !valid_yank_reg(VAR_0->regname, TRUE))\n    {\n\tbeep_flush();\n\treturn VAR_18;\n    }\n    if (VAR_0->regname == '_')\t    /* COMMENT_5 */\n\treturn VAR_19;\n\n#ifdef VAR_15\n    if (!VAR_20.available && VAR_0->regname == '*')\n\tVAR_0->regname = 0;\n    else if (!VAR_21.available && VAR_0->regname == '+')\n\tVAR_0->regname = 0;\n#endif\n\n    if (!VAR_1)\t\t    /* COMMENT_6 */\n\tget_yank_register(VAR_0->regname, TRUE);\n\n    VAR_4 = VAR_22;\n\t\t\t\t    /* COMMENT_7 */\n    if (VAR_23 && VAR_22->y_array != NULL)\n\tVAR_22 = &VAR_5;\n    else\n\tfree_yank_all();\t    /* COMMENT_8 */\n\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    if (       VAR_0->motion_type == VAR_24\n\t    && VAR_0->start.col == 0\n\t    && !VAR_0->inclusive\n\t    && (!VAR_0->is_VIsual || *VAR_25 == 'o')\n\t    && !VAR_0->block_mode\n\t    && VAR_0->end.col == 0\n\t    && VAR_10 > 1)\n    {\n\tVAR_9 = VAR_26;\n\t--VAR_11;\n\t--VAR_10;\n    }\n\n    VAR_22->y_size = VAR_10;\n    VAR_22->y_type = VAR_9;   /* COMMENT_11 */\n    VAR_22->y_width = 0;\n    VAR_22->y_array = lalloc_clear(sizeof(char_u *) * VAR_10, TRUE);\n    if (VAR_22->y_array == NULL)\n    {\n\tVAR_22 = VAR_4;\n\treturn VAR_18;\n    }\n#ifdef VAR_27\n    VAR_22->y_time_set = vim_time();\n#endif\n\n    VAR_3 = 0;\n    VAR_7 = VAR_0->start.lnum;\n\n    if (VAR_0->block_mode)\n    {\n\t/* COMMENT_12 */\n\tVAR_22->y_type = VAR_28;\t    /* COMMENT_11 */\n\tVAR_22->y_width = VAR_0->end_vcol - VAR_0->start_vcol;\n\n\tif (VAR_29->w_curswant == VAR_30 && VAR_22->y_width > 0)\n\t    VAR_22->y_width--;\n    }\n\n    for ( ; VAR_7 <= VAR_11; VAR_7++, VAR_3++)\n    {\n\tswitch (VAR_22->y_type)\n\t{\n\t    case VAR_28:\n\t\tblock_prep(VAR_0, &VAR_14, VAR_7, FALSE);\n\t\tif (yank_copy_line(&VAR_14, VAR_3, VAR_0->excl_tr_ws) == VAR_18)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case VAR_26:\n\t\tif ((VAR_22->y_array[VAR_3] =\n\t\t\t\t\t    vim_strsave(ml_get(VAR_7))) == NULL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case VAR_24:\n\t\t{\n\t\t    colnr_T VAR_31 = 0, VAR_32 = VAR_30;\n\t\t    int\t    VAR_33 = FALSE;\n\t\t    colnr_T VAR_34, VAR_35;\n\n\t\t    VAR_12 = ml_get(VAR_7);\n\t\t    VAR_14.startspaces = 0;\n\t\t    VAR_14.endspaces = 0;\n\n\t\t    if (VAR_7 == VAR_0->start.lnum)\n\t\t    {\n\t\t\tVAR_31 = VAR_0->start.col;\n\t\t\tif (VAR_36)\n\t\t\t{\n\t\t\t    getvcol(VAR_29, &VAR_0->start, &VAR_34, NULL, &VAR_35);\n\t\t\t    if (VAR_35 != VAR_34 && VAR_0->start.coladd > 0)\n\t\t\t    {\n\t\t\t\t/* COMMENT_13 */\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tVAR_14.startspaces = (VAR_35 - VAR_34 + 1)\n\t\t\t\t\t\t\t  - VAR_0->start.coladd;\n\t\t\t\tif (VAR_14.startspaces < 0)\n\t\t\t\t    VAR_14.startspaces = 0;\n\t\t\t\tVAR_31++;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    if (VAR_7 == VAR_0->end.lnum)\n\t\t    {\n\t\t\tVAR_32 = VAR_0->end.col;\n\t\t\tif (VAR_36)\n\t\t\t{\n\t\t\t    getvcol(VAR_29, &VAR_0->end, &VAR_34, NULL, &VAR_35);\n\t\t\t    if (VAR_12[VAR_32] == VAR_37 || (VAR_34 + VAR_0->end.coladd < VAR_35\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_16 */\n\t\t\t\t\t/* COMMENT_17 */\n\t\t\t\t\t&& (*VAR_38)(VAR_12, VAR_12 + VAR_32) == 0))\n\t\t\t    {\n\t\t\t\tif (VAR_0->start.lnum == VAR_0->end.lnum\n\t\t\t\t\t    && VAR_0->start.col == VAR_0->end.col)\n\t\t\t\t{\n\t\t\t\t    /* COMMENT_18 */\n\t\t\t\t    VAR_33 = TRUE;\n\t\t\t\t    VAR_14.startspaces = VAR_0->end.coladd\n\t\t\t\t\t - VAR_0->start.coladd + VAR_0->inclusive;\n\t\t\t\t    VAR_32 = VAR_31;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    VAR_14.endspaces = VAR_0->end.coladd\n\t\t\t\t\t\t\t     + VAR_0->inclusive;\n\t\t\t\t    VAR_32 -= VAR_0->inclusive;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (VAR_32 == VAR_30)\n\t\t\tVAR_32 = (colnr_T)STRLEN(VAR_12);\n\t\t    if (VAR_31 > VAR_32 || VAR_33)\n\t\t\tVAR_14.textlen = 0;\n\t\t    else\n\t\t\tVAR_14.textlen = VAR_32 - VAR_31 + VAR_0->inclusive;\n\t\t    VAR_14.textstart = VAR_12 + VAR_31;\n\t\t    if (yank_copy_line(&VAR_14, VAR_3, FALSE) == VAR_18)\n\t\t\tgoto fail;\n\t\t    break;\n\t\t}\n\t\t/* COMMENT_19 */\n\t}\n    }\n\n    if (VAR_4 != VAR_22)\t/* COMMENT_20 */\n    {\n\tVAR_6 = ALLOC_MULT(char_u *, VAR_4->y_size + VAR_22->y_size);\n\tif (VAR_6 == NULL)\n\t    goto fail;\n\tfor (VAR_8 = 0; VAR_8 < VAR_4->y_size; ++VAR_8)\n\t    VAR_6[VAR_8] = VAR_4->y_array[VAR_8];\n\tvim_free(VAR_4->y_array);\n\tVAR_4->y_array = VAR_6;\n#ifdef VAR_27\n\tVAR_4->y_time_set = vim_time();\n#endif\n\n\tif (VAR_9 == VAR_26)\t/* COMMENT_21 */\n\t    VAR_4->y_type = VAR_26;\n\n\t/* COMMENT_22 */\n\t/* COMMENT_23 */\n\tif (VAR_4->y_type == VAR_24 && vim_strchr(VAR_39, VAR_40) == NULL)\n\t{\n\t    VAR_13 = alloc(STRLEN(VAR_4->y_array[VAR_4->y_size - 1])\n\t\t\t\t\t  + STRLEN(VAR_22->y_array[0]) + 1);\n\t    if (VAR_13 == NULL)\n\t    {\n\t\tVAR_3 = VAR_22->y_size - 1;\n\t\tgoto fail;\n\t    }\n\t    STRCPY(VAR_13, VAR_4->y_array[--VAR_8]);\n\t    STRCAT(VAR_13, VAR_22->y_array[0]);\n\t    vim_free(VAR_4->y_array[VAR_8]);\n\t    vim_free(VAR_22->y_array[0]);\n\t    VAR_4->y_array[VAR_8++] = VAR_13;\n\t    VAR_3 = 1;\n\t}\n\telse\n\t    VAR_3 = 0;\n\twhile (VAR_3 < VAR_22->y_size)\n\t    VAR_4->y_array[VAR_8++] = VAR_22->y_array[VAR_3++];\n\tVAR_4->y_size = VAR_8;\n\tvim_free(VAR_22->y_array);\n\tVAR_22 = VAR_4;\n    }\n\n    if (VAR_2)\t\t\t/* COMMENT_24 */\n    {\n\tif (VAR_9 == VAR_24\n\t\t&& !VAR_0->block_mode\n\t\t&& VAR_10 == 1)\n\t    VAR_10 = 0;\n\t/* COMMENT_25 */\n\tif (VAR_10 > VAR_41)\n\t{\n\t    char VAR_42[100];\n\n\t    if (VAR_0->regname == VAR_37)\n\t\t*VAR_42 = VAR_37;\n\t    else\n\t\tvim_snprintf(VAR_42, sizeof(VAR_42),\n\t\t\t\t\t\t_(\" into \\\"%c\"), VAR_0->regname);\n\n\t    /* COMMENT_26 */\n\t    update_topline_redraw();\n\t    if (VAR_0->block_mode)\n\t    {\n\t\tsmsg(NGETTEXT(\"block of %ld line yanked%s\",\n\t\t\t\t     \"block of %ld lines yanked%s\", VAR_10),\n\t\t\tVAR_10, VAR_42);\n\t    }\n\t    else\n\t    {\n\t\tsmsg(NGETTEXT(\"%ld line yanked%s\",\n\t\t\t\t\t      \"%ld lines yanked%s\", VAR_10),\n\t\t\tVAR_10, VAR_42);\n\t    }\n\t}\n    }\n\n    if ((VAR_43.cmod_flags & VAR_44) == 0)\n    {\n\t/* COMMENT_27 */\n\tVAR_45->b_op_start = VAR_0->start;\n\tVAR_45->b_op_end = VAR_0->end;\n\tif (VAR_9 == VAR_26 && !VAR_0->block_mode)\n\t{\n\t    VAR_45->b_op_start.col = 0;\n\t    VAR_45->b_op_end.col = VAR_30;\n\t}\n    }\n\n#ifdef VAR_15\n    /* COMMENT_28 */\n    /* COMMENT_29 */\n    /* COMMENT_30 */\n    if (VAR_20.available\n\t    && (VAR_4 == &(VAR_46[VAR_47])\n\t\t|| (!VAR_1 && VAR_0->regname == 0\n\t\t   && ((VAR_48 | VAR_49) & VAR_50))))\n    {\n\tif (VAR_4 != &(VAR_46[VAR_47]))\n\t    /* COMMENT_31 */\n\t    copy_yank_reg(&(VAR_46[VAR_47]));\n\n\tclip_own_selection(&VAR_20);\n\tclip_gen_set_selection(&VAR_20);\n# ifdef VAR_16\n\tVAR_17 = TRUE;\n# endif\n    }\n\n# ifdef VAR_16\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    /* COMMENT_34 */\n    /* COMMENT_35 */\n    if (VAR_21.available\n\t    && (VAR_4 == &(VAR_46[VAR_51])\n\t\t|| (!VAR_1 && VAR_0->regname == 0\n\t\t  && ((VAR_48 | VAR_49) &\n\t\t\t\t\t\t\t  VAR_52))))\n    {\n\tif (VAR_4 != &(VAR_46[VAR_51]))\n\t    /* COMMENT_31 */\n\t    copy_yank_reg(&(VAR_46[VAR_51]));\n\n\tclip_own_selection(&VAR_21);\n\tclip_gen_set_selection(&VAR_21);\n\tif (!clip_isautosel_star()\n\t\t&& !clip_isautosel_plus()\n\t\t&& !((VAR_48 | VAR_49) == VAR_52)\n\t\t&& !(VAR_1 && (VAR_48 | VAR_49)\n\t\t\t\t\t == (VAR_50 | VAR_52))\n\t\t&& !VAR_17\n\t\t&& VAR_4 == &(VAR_46[VAR_51]))\n\t{\n\t    copy_yank_reg(&(VAR_46[VAR_47]));\n\t    clip_own_selection(&VAR_20);\n\t    clip_gen_set_selection(&VAR_20);\n\t}\n    }\n# endif\n#endif\n\n#if defined(VAR_53)\n    if (!VAR_1 && has_textyankpost())\n\tyank_do_autocmd(VAR_0, VAR_22);\n#endif\n\n    return VAR_19;\n\nfail:\t\t/* COMMENT_36 */\n    free_yank(VAR_3 + 1);\n    VAR_22 = VAR_4;\n    return VAR_18;\n}",
    "func_graph_path": "vim/c99cbf8f289bdda5d4a77d7ec415850a520330ba/register.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -122,6 +122,8 @@\n \t\t\t\t// double-count it.\n \t\t\t\tbd.startspaces = (ce - cs + 1)\n \t\t\t\t\t\t\t  - oap->start.coladd;\n+\t\t\t\tif (bd.startspaces < 0)\n+\t\t\t\t    bd.startspaces = 0;\n \t\t\t\tstartcol++;\n \t\t\t    }\n \t\t\t}",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\t\t\tif (bd.startspaces < 0)",
            "\t\t\t\t    bd.startspaces = 0;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}