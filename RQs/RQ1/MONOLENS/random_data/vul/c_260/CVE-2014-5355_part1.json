{
    "cve_id": "CVE-2014-5355",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "krb5",
    "commit_msg": "Fix krb5_read_message handling [CVE-2014-5355]\n\nIn recvauth_common, do not use strcmp against the data fields of\nkrb5_data objects populated by krb5_read_message(), as there is no\nguarantee that they are C strings.  Instead, create an expected\nkrb5_data value and use data_eq().\n\nIn the sample user-to-user server application, check that the received\nclient principal name is null-terminated before using it with printf\nand krb5_parse_name.\n\nCVE-2014-5355:\n\nIn MIT krb5, when a server process uses the krb5_recvauth function, an\nunauthenticated remote attacker can cause a NULL dereference by\nsending a zero-byte version string, or a read beyond the end of\nallocated storage by sending a non-null-terminated version string.\nThe example user-to-user server application (uuserver) is similarly\nvulnerable to a zero-length or non-null-terminated principal name\nstring.\n\nThe krb5_recvauth function reads two version strings from the client\nusing krb5_read_message(), which produces a krb5_data structure\ncontaining a length and a pointer to an octet sequence.  krb5_recvauth\nassumes that the data pointer is a valid C string and passes it to\nstrcmp() to verify the versions.  If the client sends an empty octet\nsequence, the data pointer will be NULL and strcmp() will dereference\na NULL pointer, causing the process to crash.  If the client sends a\nnon-null-terminated octet sequence, strcmp() will read beyond the end\nof the allocated storage, possibly causing the process to crash.\n\nuuserver similarly uses krb5_read_message() to read a client principal\nname, and then passes it to printf() and krb5_parse_name() without\nverifying that it is a valid C string.\n\nThe krb5_recvauth function is used by kpropd and the Kerberized\nversions of the BSD rlogin and rsh daemons.  These daemons are usually\nrun out of inetd or in a mode which forks before processing incoming\nconnections, so a process crash will generally not result in a\ncomplete denial of service.\n\nThanks to Tim Uglow for discovering this issue.\n\nCVSSv2: AV:N/AC:L/Au:N/C:N/I:N/A:P/E:POC/RL:OF/RC:C\n\n[tlyu@mit.edu: CVSS score]\n\nticket: 8050 (new)\ntarget_version: 1.13.1\ntags: pullup",
    "commit_hash": "102bb6ebf20f9174130c85c3b052ae104e5073ec",
    "git_url": "https://github.com/krb5/krb5/commit/102bb6ebf20f9174130c85c3b052ae104e5073ec",
    "file_path": "src/lib/krb5/krb/recvauth.c",
    "func_name": "recvauth_common",
    "func_before": "static krb5_error_code\nrecvauth_common(krb5_context context,\n                krb5_auth_context * auth_context,\n                /* IN */\n                krb5_pointer fd,\n                char *appl_version,\n                krb5_principal server,\n                krb5_int32 flags,\n                krb5_keytab keytab,\n                /* OUT */\n                krb5_ticket ** ticket,\n                krb5_data *version)\n{\n    krb5_auth_context     new_auth_context;\n    krb5_flags            ap_option = 0;\n    krb5_error_code       retval, problem;\n    krb5_data             inbuf;\n    krb5_data             outbuf;\n    krb5_rcache           rcache = 0;\n    krb5_octet            response;\n    krb5_data             null_server;\n    int                   need_error_free = 0;\n    int                   local_rcache = 0, local_authcon = 0;\n\n    /*\n     * Zero out problem variable.  If problem is set at the end of\n     * the intial version negotiation section, it means that we\n     * need to send an error code back to the client application\n     * and exit.\n     */\n    problem = 0;\n    response = 0;\n\n    if (!(flags & KRB5_RECVAUTH_SKIP_VERSION)) {\n        /*\n         * First read the sendauth version string and check it.\n         */\n        if ((retval = krb5_read_message(context, fd, &inbuf)))\n            return(retval);\n        if (strcmp(inbuf.data, sendauth_version)) {\n            problem = KRB5_SENDAUTH_BADAUTHVERS;\n            response = 1;\n        }\n        free(inbuf.data);\n    }\n    if (flags & KRB5_RECVAUTH_BADAUTHVERS) {\n        problem = KRB5_SENDAUTH_BADAUTHVERS;\n        response = 1;\n    }\n\n    /*\n     * Do the same thing for the application version string.\n     */\n    if ((retval = krb5_read_message(context, fd, &inbuf)))\n        return(retval);\n    if (appl_version && strcmp(inbuf.data, appl_version)) {\n        if (!problem) {\n            problem = KRB5_SENDAUTH_BADAPPLVERS;\n            response = 2;\n        }\n    }\n    if (version && !problem)\n        *version = inbuf;\n    else\n        free(inbuf.data);\n\n    /*\n     * Now we actually write the response.  If the response is non-zero,\n     * exit with a return value of problem\n     */\n    if ((krb5_net_write(context, *((int *)fd), (char *)&response, 1)) < 0) {\n        return(problem); /* We'll return the top-level problem */\n    }\n    if (problem)\n        return(problem);\n\n    /* We are clear of errors here */\n\n    /*\n     * Now, let's read the AP_REQ message and decode it\n     */\n    if ((retval = krb5_read_message(context, fd, &inbuf)))\n        return retval;\n\n    if (*auth_context == NULL) {\n        problem = krb5_auth_con_init(context, &new_auth_context);\n        *auth_context = new_auth_context;\n        local_authcon = 1;\n    }\n    krb5_auth_con_getrcache(context, *auth_context, &rcache);\n    if ((!problem) && rcache == NULL) {\n        /*\n         * Setup the replay cache.\n         */\n        if (server != NULL && server->length > 0) {\n            problem = krb5_get_server_rcache(context, &server->data[0],\n                                             &rcache);\n        } else {\n            null_server.length = 7;\n            null_server.data = \"default\";\n            problem = krb5_get_server_rcache(context, &null_server, &rcache);\n        }\n        if (!problem)\n            problem = krb5_auth_con_setrcache(context, *auth_context, rcache);\n        local_rcache = 1;\n    }\n    if (!problem) {\n        problem = krb5_rd_req(context, auth_context, &inbuf, server,\n                              keytab, &ap_option, ticket);\n        free(inbuf.data);\n    }\n\n    /*\n     * If there was a problem, send back a krb5_error message,\n     * preceeded by the length of the krb5_error message.  If\n     * everything's ok, send back 0 for the length.\n     */\n    if (problem) {\n        krb5_error      error;\n        const   char *message;\n\n        memset(&error, 0, sizeof(error));\n        krb5_us_timeofday(context, &error.stime, &error.susec);\n        if(server)\n            error.server = server;\n        else {\n            /* If this fails - ie. ENOMEM we are hosed\n               we cannot even send the error if we wanted to... */\n            (void) krb5_parse_name(context, \"????\", &error.server);\n            need_error_free = 1;\n        }\n\n        error.error = problem - ERROR_TABLE_BASE_krb5;\n        if (error.error > 127)\n            error.error = KRB_ERR_GENERIC;\n        message = error_message(problem);\n        error.text.length  = strlen(message) + 1;\n        error.text.data = strdup(message);\n        if (!error.text.data) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        if ((retval = krb5_mk_error(context, &error, &outbuf))) {\n            free(error.text.data);\n            goto cleanup;\n        }\n        free(error.text.data);\n        if(need_error_free)\n            krb5_free_principal(context, error.server);\n\n    } else {\n        outbuf.length = 0;\n        outbuf.data = 0;\n    }\n\n    retval = krb5_write_message(context, fd, &outbuf);\n    if (outbuf.data) {\n        free(outbuf.data);\n        /* We sent back an error, we need cleanup then return */\n        retval = problem;\n        goto cleanup;\n    }\n    if (retval)\n        goto cleanup;\n\n    /* Here lies the mutual authentication stuff... */\n    if ((ap_option & AP_OPTS_MUTUAL_REQUIRED)) {\n        if ((retval = krb5_mk_rep(context, *auth_context, &outbuf))) {\n            return(retval);\n        }\n        retval = krb5_write_message(context, fd, &outbuf);\n        free(outbuf.data);\n    }\n\ncleanup:;\n    if (retval) {\n        if (local_authcon) {\n            krb5_auth_con_free(context, *auth_context);\n        } else if (local_rcache && rcache != NULL) {\n            krb5_rc_close(context, rcache);\n            krb5_auth_con_setrcache(context, *auth_context, NULL);\n        }\n    }\n    return retval;\n}",
    "abstract_func_before": "static krb5_error_code\nrecvauth_common(krb5_context VAR_0,\n                krb5_auth_context * VAR_1,\n                /* COMMENT_0 */\n                krb5_pointer VAR_2,\n                char *VAR_3,\n                krb5_principal VAR_4,\n                krb5_int32 VAR_5,\n                krb5_keytab VAR_6,\n                /* COMMENT_1 */\n                krb5_ticket ** VAR_7,\n                krb5_data *VAR_8)\n{\n    krb5_auth_context     VAR_9;\n    krb5_flags            VAR_10 = 0;\n    krb5_error_code       VAR_11, VAR_12;\n    krb5_data             VAR_13;\n    krb5_data             VAR_14;\n    krb5_rcache           VAR_15 = 0;\n    krb5_octet            VAR_16;\n    krb5_data             VAR_17;\n    int                   VAR_18 = 0;\n    int                   VAR_19 = 0, VAR_20 = 0;\n\n    /* COMMENT_2 */\n                                                                  \n                                                               \n                                                                \n                \n       \n    VAR_12 = 0;\n    VAR_16 = 0;\n\n    if (!(VAR_5 & VAR_21)) {\n        /* COMMENT_8 */\n                                                               \n           \n        if ((VAR_11 = krb5_read_message(VAR_0, VAR_2, &VAR_13)))\n            return(VAR_11);\n        if (strcmp(VAR_13.data, VAR_22)) {\n            VAR_12 = VAR_23;\n            VAR_16 = 1;\n        }\n        free(VAR_13.data);\n    }\n    if (VAR_5 & VAR_24) {\n        VAR_12 = VAR_23;\n        VAR_16 = 1;\n    }\n\n    /* COMMENT_11 */\n                                                            \n       \n    if ((VAR_11 = krb5_read_message(VAR_0, VAR_2, &VAR_13)))\n        return(VAR_11);\n    if (VAR_3 && strcmp(VAR_13.data, VAR_3)) {\n        if (!VAR_12) {\n            VAR_12 = VAR_25;\n            VAR_16 = 2;\n        }\n    }\n    if (VAR_8 && !VAR_12)\n        *VAR_8 = VAR_13;\n    else\n        free(VAR_13.data);\n\n    /* COMMENT_14 */\n                                                                        \n                                          \n       \n    if ((krb5_net_write(VAR_0, *((int *)VAR_2), (char *)&VAR_16, 1)) < 0) {\n        return(VAR_12); /* COMMENT_18 */\n    }\n    if (VAR_12)\n        return(VAR_12);\n\n    /* COMMENT_19 */\n\n    /* COMMENT_20 */\n                                                       \n       \n    if ((VAR_11 = krb5_read_message(VAR_0, VAR_2, &VAR_13)))\n        return VAR_11;\n\n    if (*VAR_1 == NULL) {\n        VAR_12 = krb5_auth_con_init(VAR_0, &VAR_9);\n        *VAR_1 = VAR_9;\n        VAR_20 = 1;\n    }\n    krb5_auth_con_getrcache(VAR_0, *VAR_1, &VAR_15);\n    if ((!VAR_12) && VAR_15 == NULL) {\n        /* COMMENT_23 */\n                                  \n           \n        if (VAR_4 != NULL && VAR_4->length > 0) {\n            VAR_12 = krb5_get_server_rcache(VAR_0, &VAR_4->data[0],\n                                             &VAR_15);\n        } else {\n            VAR_17.length = 7;\n            VAR_17.data = \"default\";\n            VAR_12 = krb5_get_server_rcache(VAR_0, &VAR_17, &VAR_15);\n        }\n        if (!VAR_12)\n            VAR_12 = krb5_auth_con_setrcache(VAR_0, *VAR_1, VAR_15);\n        VAR_19 = 1;\n    }\n    if (!VAR_12) {\n        VAR_12 = krb5_rd_req(VAR_0, VAR_1, &VAR_13, VAR_4,\n                              VAR_6, &VAR_10, VAR_7);\n        free(VAR_13.data);\n    }\n\n    /* COMMENT_26 */\n                                                              \n                                                             \n                                                   \n       \n    if (VAR_12) {\n        krb5_error      VAR_26;\n        const   char *VAR_27;\n\n        memset(&VAR_26, 0, sizeof(VAR_26));\n        krb5_us_timeofday(VAR_0, &VAR_26.stime, &VAR_26.susec);\n        if(VAR_4)\n            VAR_26.server = VAR_4;\n        else {\n            /* COMMENT_31 */\n                                                                  \n            (void) krb5_parse_name(VAR_0, \"????\", &VAR_26.server);\n            VAR_18 = 1;\n        }\n\n        VAR_26.error = VAR_12 - VAR_28;\n        if (VAR_26.error > 127)\n            VAR_26.error = VAR_29;\n        VAR_27 = error_message(VAR_12);\n        VAR_26.text.length  = strlen(VAR_27) + 1;\n        VAR_26.text.data = strdup(VAR_27);\n        if (!VAR_26.text.data) {\n            VAR_11 = VAR_30;\n            goto cleanup;\n        }\n        if ((VAR_11 = krb5_mk_error(VAR_0, &VAR_26, &VAR_14))) {\n            free(VAR_26.text.data);\n            goto cleanup;\n        }\n        free(VAR_26.text.data);\n        if(VAR_18)\n            krb5_free_principal(VAR_0, VAR_26.server);\n\n    } else {\n        VAR_14.length = 0;\n        VAR_14.data = 0;\n    }\n\n    VAR_11 = krb5_write_message(VAR_0, VAR_2, &VAR_14);\n    if (VAR_14.data) {\n        free(VAR_14.data);\n        /* COMMENT_33 */\n        VAR_11 = VAR_12;\n        goto cleanup;\n    }\n    if (VAR_11)\n        goto cleanup;\n\n    /* COMMENT_34 */\n    if ((VAR_10 & VAR_31)) {\n        if ((VAR_11 = krb5_mk_rep(VAR_0, *VAR_1, &VAR_14))) {\n            return(VAR_11);\n        }\n        VAR_11 = krb5_write_message(VAR_0, VAR_2, &VAR_14);\n        free(VAR_14.data);\n    }\n\ncleanup:;\n    if (VAR_11) {\n        if (VAR_20) {\n            krb5_auth_con_free(VAR_0, *VAR_1);\n        } else if (VAR_19 && VAR_15 != NULL) {\n            krb5_rc_close(VAR_0, VAR_15);\n            krb5_auth_con_setrcache(VAR_0, *VAR_1, NULL);\n        }\n    }\n    return VAR_11;\n}",
    "func_graph_path_before": "krb5/102bb6ebf20f9174130c85c3b052ae104e5073ec/recvauth.c/vul/before/0.json",
    "func": "static krb5_error_code\nrecvauth_common(krb5_context context,\n                krb5_auth_context * auth_context,\n                /* IN */\n                krb5_pointer fd,\n                char *appl_version,\n                krb5_principal server,\n                krb5_int32 flags,\n                krb5_keytab keytab,\n                /* OUT */\n                krb5_ticket ** ticket,\n                krb5_data *version)\n{\n    krb5_auth_context     new_auth_context;\n    krb5_flags            ap_option = 0;\n    krb5_error_code       retval, problem;\n    krb5_data             inbuf;\n    krb5_data             outbuf;\n    krb5_rcache           rcache = 0;\n    krb5_octet            response;\n    krb5_data             null_server;\n    krb5_data             d;\n    int                   need_error_free = 0;\n    int                   local_rcache = 0, local_authcon = 0;\n\n    /*\n     * Zero out problem variable.  If problem is set at the end of\n     * the intial version negotiation section, it means that we\n     * need to send an error code back to the client application\n     * and exit.\n     */\n    problem = 0;\n    response = 0;\n\n    if (!(flags & KRB5_RECVAUTH_SKIP_VERSION)) {\n        /*\n         * First read the sendauth version string and check it.\n         */\n        if ((retval = krb5_read_message(context, fd, &inbuf)))\n            return(retval);\n        d = make_data((char *)sendauth_version, strlen(sendauth_version) + 1);\n        if (!data_eq(inbuf, d)) {\n            problem = KRB5_SENDAUTH_BADAUTHVERS;\n            response = 1;\n        }\n        free(inbuf.data);\n    }\n    if (flags & KRB5_RECVAUTH_BADAUTHVERS) {\n        problem = KRB5_SENDAUTH_BADAUTHVERS;\n        response = 1;\n    }\n\n    /*\n     * Do the same thing for the application version string.\n     */\n    if ((retval = krb5_read_message(context, fd, &inbuf)))\n        return(retval);\n    if (appl_version != NULL && !problem) {\n        d = make_data(appl_version, strlen(appl_version) + 1);\n        if (!data_eq(inbuf, d)) {\n            problem = KRB5_SENDAUTH_BADAPPLVERS;\n            response = 2;\n        }\n    }\n    if (version && !problem)\n        *version = inbuf;\n    else\n        free(inbuf.data);\n\n    /*\n     * Now we actually write the response.  If the response is non-zero,\n     * exit with a return value of problem\n     */\n    if ((krb5_net_write(context, *((int *)fd), (char *)&response, 1)) < 0) {\n        return(problem); /* We'll return the top-level problem */\n    }\n    if (problem)\n        return(problem);\n\n    /* We are clear of errors here */\n\n    /*\n     * Now, let's read the AP_REQ message and decode it\n     */\n    if ((retval = krb5_read_message(context, fd, &inbuf)))\n        return retval;\n\n    if (*auth_context == NULL) {\n        problem = krb5_auth_con_init(context, &new_auth_context);\n        *auth_context = new_auth_context;\n        local_authcon = 1;\n    }\n    krb5_auth_con_getrcache(context, *auth_context, &rcache);\n    if ((!problem) && rcache == NULL) {\n        /*\n         * Setup the replay cache.\n         */\n        if (server != NULL && server->length > 0) {\n            problem = krb5_get_server_rcache(context, &server->data[0],\n                                             &rcache);\n        } else {\n            null_server.length = 7;\n            null_server.data = \"default\";\n            problem = krb5_get_server_rcache(context, &null_server, &rcache);\n        }\n        if (!problem)\n            problem = krb5_auth_con_setrcache(context, *auth_context, rcache);\n        local_rcache = 1;\n    }\n    if (!problem) {\n        problem = krb5_rd_req(context, auth_context, &inbuf, server,\n                              keytab, &ap_option, ticket);\n        free(inbuf.data);\n    }\n\n    /*\n     * If there was a problem, send back a krb5_error message,\n     * preceeded by the length of the krb5_error message.  If\n     * everything's ok, send back 0 for the length.\n     */\n    if (problem) {\n        krb5_error      error;\n        const   char *message;\n\n        memset(&error, 0, sizeof(error));\n        krb5_us_timeofday(context, &error.stime, &error.susec);\n        if(server)\n            error.server = server;\n        else {\n            /* If this fails - ie. ENOMEM we are hosed\n               we cannot even send the error if we wanted to... */\n            (void) krb5_parse_name(context, \"????\", &error.server);\n            need_error_free = 1;\n        }\n\n        error.error = problem - ERROR_TABLE_BASE_krb5;\n        if (error.error > 127)\n            error.error = KRB_ERR_GENERIC;\n        message = error_message(problem);\n        error.text.length  = strlen(message) + 1;\n        error.text.data = strdup(message);\n        if (!error.text.data) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        if ((retval = krb5_mk_error(context, &error, &outbuf))) {\n            free(error.text.data);\n            goto cleanup;\n        }\n        free(error.text.data);\n        if(need_error_free)\n            krb5_free_principal(context, error.server);\n\n    } else {\n        outbuf.length = 0;\n        outbuf.data = 0;\n    }\n\n    retval = krb5_write_message(context, fd, &outbuf);\n    if (outbuf.data) {\n        free(outbuf.data);\n        /* We sent back an error, we need cleanup then return */\n        retval = problem;\n        goto cleanup;\n    }\n    if (retval)\n        goto cleanup;\n\n    /* Here lies the mutual authentication stuff... */\n    if ((ap_option & AP_OPTS_MUTUAL_REQUIRED)) {\n        if ((retval = krb5_mk_rep(context, *auth_context, &outbuf))) {\n            return(retval);\n        }\n        retval = krb5_write_message(context, fd, &outbuf);\n        free(outbuf.data);\n    }\n\ncleanup:;\n    if (retval) {\n        if (local_authcon) {\n            krb5_auth_con_free(context, *auth_context);\n        } else if (local_rcache && rcache != NULL) {\n            krb5_rc_close(context, rcache);\n            krb5_auth_con_setrcache(context, *auth_context, NULL);\n        }\n    }\n    return retval;\n}",
    "abstract_func": "static krb5_error_code\nrecvauth_common(krb5_context VAR_0,\n                krb5_auth_context * VAR_1,\n                /* COMMENT_0 */\n                krb5_pointer VAR_2,\n                char *VAR_3,\n                krb5_principal VAR_4,\n                krb5_int32 VAR_5,\n                krb5_keytab VAR_6,\n                /* COMMENT_1 */\n                krb5_ticket ** VAR_7,\n                krb5_data *VAR_8)\n{\n    krb5_auth_context     VAR_9;\n    krb5_flags            VAR_10 = 0;\n    krb5_error_code       VAR_11, VAR_12;\n    krb5_data             VAR_13;\n    krb5_data             VAR_14;\n    krb5_rcache           VAR_15 = 0;\n    krb5_octet            VAR_16;\n    krb5_data             VAR_17;\n    krb5_data             VAR_18;\n    int                   VAR_19 = 0;\n    int                   VAR_20 = 0, VAR_21 = 0;\n\n    /* COMMENT_2 */\n                                                                  \n                                                               \n                                                                \n                \n       \n    VAR_12 = 0;\n    VAR_16 = 0;\n\n    if (!(VAR_5 & VAR_22)) {\n        /* COMMENT_8 */\n                                                               \n           \n        if ((VAR_11 = krb5_read_message(VAR_0, VAR_2, &VAR_13)))\n            return(VAR_11);\n        VAR_18 = make_data((char *)VAR_23, strlen(VAR_23) + 1);\n        if (!data_eq(VAR_13, VAR_18)) {\n            VAR_12 = VAR_24;\n            VAR_16 = 1;\n        }\n        free(VAR_13.data);\n    }\n    if (VAR_5 & VAR_25) {\n        VAR_12 = VAR_24;\n        VAR_16 = 1;\n    }\n\n    /* COMMENT_11 */\n                                                            \n       \n    if ((VAR_11 = krb5_read_message(VAR_0, VAR_2, &VAR_13)))\n        return(VAR_11);\n    if (VAR_3 != NULL && !VAR_12) {\n        VAR_18 = make_data(VAR_3, strlen(VAR_3) + 1);\n        if (!data_eq(VAR_13, VAR_18)) {\n            VAR_12 = VAR_26;\n            VAR_16 = 2;\n        }\n    }\n    if (VAR_8 && !VAR_12)\n        *VAR_8 = VAR_13;\n    else\n        free(VAR_13.data);\n\n    /* COMMENT_14 */\n                                                                        \n                                          \n       \n    if ((krb5_net_write(VAR_0, *((int *)VAR_2), (char *)&VAR_16, 1)) < 0) {\n        return(VAR_12); /* COMMENT_18 */\n    }\n    if (VAR_12)\n        return(VAR_12);\n\n    /* COMMENT_19 */\n\n    /* COMMENT_20 */\n                                                       \n       \n    if ((VAR_11 = krb5_read_message(VAR_0, VAR_2, &VAR_13)))\n        return VAR_11;\n\n    if (*VAR_1 == NULL) {\n        VAR_12 = krb5_auth_con_init(VAR_0, &VAR_9);\n        *VAR_1 = VAR_9;\n        VAR_21 = 1;\n    }\n    krb5_auth_con_getrcache(VAR_0, *VAR_1, &VAR_15);\n    if ((!VAR_12) && VAR_15 == NULL) {\n        /* COMMENT_23 */\n                                  \n           \n        if (VAR_4 != NULL && VAR_4->length > 0) {\n            VAR_12 = krb5_get_server_rcache(VAR_0, &VAR_4->data[0],\n                                             &VAR_15);\n        } else {\n            VAR_17.length = 7;\n            VAR_17.data = \"default\";\n            VAR_12 = krb5_get_server_rcache(VAR_0, &VAR_17, &VAR_15);\n        }\n        if (!VAR_12)\n            VAR_12 = krb5_auth_con_setrcache(VAR_0, *VAR_1, VAR_15);\n        VAR_20 = 1;\n    }\n    if (!VAR_12) {\n        VAR_12 = krb5_rd_req(VAR_0, VAR_1, &VAR_13, VAR_4,\n                              VAR_6, &VAR_10, VAR_7);\n        free(VAR_13.data);\n    }\n\n    /* COMMENT_26 */\n                                                              \n                                                             \n                                                   \n       \n    if (VAR_12) {\n        krb5_error      VAR_27;\n        const   char *VAR_28;\n\n        memset(&VAR_27, 0, sizeof(VAR_27));\n        krb5_us_timeofday(VAR_0, &VAR_27.stime, &VAR_27.susec);\n        if(VAR_4)\n            VAR_27.server = VAR_4;\n        else {\n            /* COMMENT_31 */\n                                                                  \n            (void) krb5_parse_name(VAR_0, \"????\", &VAR_27.server);\n            VAR_19 = 1;\n        }\n\n        VAR_27.error = VAR_12 - VAR_29;\n        if (VAR_27.error > 127)\n            VAR_27.error = VAR_30;\n        VAR_28 = error_message(VAR_12);\n        VAR_27.text.length  = strlen(VAR_28) + 1;\n        VAR_27.text.data = strdup(VAR_28);\n        if (!VAR_27.text.data) {\n            VAR_11 = VAR_31;\n            goto cleanup;\n        }\n        if ((VAR_11 = krb5_mk_error(VAR_0, &VAR_27, &VAR_14))) {\n            free(VAR_27.text.data);\n            goto cleanup;\n        }\n        free(VAR_27.text.data);\n        if(VAR_19)\n            krb5_free_principal(VAR_0, VAR_27.server);\n\n    } else {\n        VAR_14.length = 0;\n        VAR_14.data = 0;\n    }\n\n    VAR_11 = krb5_write_message(VAR_0, VAR_2, &VAR_14);\n    if (VAR_14.data) {\n        free(VAR_14.data);\n        /* COMMENT_33 */\n        VAR_11 = VAR_12;\n        goto cleanup;\n    }\n    if (VAR_11)\n        goto cleanup;\n\n    /* COMMENT_34 */\n    if ((VAR_10 & VAR_32)) {\n        if ((VAR_11 = krb5_mk_rep(VAR_0, *VAR_1, &VAR_14))) {\n            return(VAR_11);\n        }\n        VAR_11 = krb5_write_message(VAR_0, VAR_2, &VAR_14);\n        free(VAR_14.data);\n    }\n\ncleanup:;\n    if (VAR_11) {\n        if (VAR_21) {\n            krb5_auth_con_free(VAR_0, *VAR_1);\n        } else if (VAR_20 && VAR_15 != NULL) {\n            krb5_rc_close(VAR_0, VAR_15);\n            krb5_auth_con_setrcache(VAR_0, *VAR_1, NULL);\n        }\n    }\n    return VAR_11;\n}",
    "func_graph_path": "krb5/102bb6ebf20f9174130c85c3b052ae104e5073ec/recvauth.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,7 @@\n     krb5_rcache           rcache = 0;\n     krb5_octet            response;\n     krb5_data             null_server;\n+    krb5_data             d;\n     int                   need_error_free = 0;\n     int                   local_rcache = 0, local_authcon = 0;\n \n@@ -37,7 +38,8 @@\n          */\n         if ((retval = krb5_read_message(context, fd, &inbuf)))\n             return(retval);\n-        if (strcmp(inbuf.data, sendauth_version)) {\n+        d = make_data((char *)sendauth_version, strlen(sendauth_version) + 1);\n+        if (!data_eq(inbuf, d)) {\n             problem = KRB5_SENDAUTH_BADAUTHVERS;\n             response = 1;\n         }\n@@ -53,8 +55,9 @@\n      */\n     if ((retval = krb5_read_message(context, fd, &inbuf)))\n         return(retval);\n-    if (appl_version && strcmp(inbuf.data, appl_version)) {\n-        if (!problem) {\n+    if (appl_version != NULL && !problem) {\n+        d = make_data(appl_version, strlen(appl_version) + 1);\n+        if (!data_eq(inbuf, d)) {\n             problem = KRB5_SENDAUTH_BADAPPLVERS;\n             response = 2;\n         }",
    "diff_line_info": {
        "deleted_lines": [
            "        if (strcmp(inbuf.data, sendauth_version)) {",
            "    if (appl_version && strcmp(inbuf.data, appl_version)) {",
            "        if (!problem) {"
        ],
        "added_lines": [
            "    krb5_data             d;",
            "        d = make_data((char *)sendauth_version, strlen(sendauth_version) + 1);",
            "        if (!data_eq(inbuf, d)) {",
            "    if (appl_version != NULL && !problem) {",
            "        d = make_data(appl_version, strlen(appl_version) + 1);",
            "        if (!data_eq(inbuf, d)) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}