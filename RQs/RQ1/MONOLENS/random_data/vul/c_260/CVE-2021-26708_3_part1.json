{
    "cve_id": "CVE-2021-26708",
    "cwe_ids": [
        "CWE-667"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "There are multiple similar bugs implicitly introduced by the\ncommit c0cfa2d8a788fcf4 (\"vsock: add multi-transports support\") and\ncommit 6a2c0962105ae8ce (\"vsock: prevent transport modules unloading\").\n\nThe bug pattern:\n [1] vsock_sock.transport pointer is copied to a local variable,\n [2] lock_sock() is called,\n [3] the local variable is used.\nVSOCK multi-transport support introduced the race condition:\nvsock_sock.transport value may change between [1] and [2].\n\nLet's copy vsock_sock.transport pointer to local variables after\nthe lock_sock() call.\n\nFixes: c0cfa2d8a788fcf4 (\"vsock: add multi-transports support\")\nSigned-off-by: Alexander Popov <alex.popov@linux.com>\nReviewed-by: Stefano Garzarella <sgarzare@redhat.com>\nReviewed-by: Jorgen Hansen <jhansen@vmware.com>\nLink: https://lore.kernel.org/r/20210201084719.2257066-1-alex.popov@linux.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>\n",
    "commit_hash": "c518adafa39f37858697ac9309c6cf1805581446",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=c518adafa39f37858697ac9309c6cf1805581446",
    "file_path": "net/vmw_vsock/af_vsock.c",
    "func_name": "vsock_stream_recvmsg",
    "func_before": "static int\nvsock_stream_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t     int flags)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n\tint err;\n\tsize_t target;\n\tssize_t copied;\n\tlong timeout;\n\tstruct vsock_transport_recv_notify_data recv_data;\n\n\tDEFINE_WAIT(wait);\n\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\ttransport = vsk->transport;\n\terr = 0;\n\n\tlock_sock(sk);\n\n\tif (!transport || sk->sk_state != TCP_ESTABLISHED) {\n\t\t/* Recvmsg is supposed to return 0 if a peer performs an\n\t\t * orderly shutdown. Differentiate between that case and when a\n\t\t * peer has not connected or a local shutdown occured with the\n\t\t * SOCK_DONE flag.\n\t\t */\n\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -ENOTCONN;\n\n\t\tgoto out;\n\t}\n\n\tif (flags & MSG_OOB) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* We don't check peer_shutdown flag here since peer may actually shut\n\t * down, but there can be data in the queue that a local socket can\n\t * receive.\n\t */\n\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* It is valid on Linux to pass in a zero-length receive buffer.  This\n\t * is not an error.  We may as well bail out now.\n\t */\n\tif (!len) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* We must not copy less than target bytes into the user's buffer\n\t * before returning successfully, so we wait for the consume queue to\n\t * have that much data to consume before dequeueing.  Note that this\n\t * makes it impossible to handle cases where target is greater than the\n\t * queue size.\n\t */\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tif (target >= transport->stream_rcvhiwat(vsk)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tcopied = 0;\n\n\terr = transport->notify_recv_init(vsk, target, &recv_data);\n\tif (err < 0)\n\t\tgoto out;\n\n\n\twhile (1) {\n\t\ts64 ready;\n\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tready = vsock_stream_has_data(vsk);\n\n\t\tif (ready == 0) {\n\t\t\tif (sk->sk_err != 0 ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    (vsk->peer_shutdown & SEND_SHUTDOWN)) {\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Don't wait for non-blocking sockets. */\n\t\t\tif (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = transport->notify_recv_pre_block(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0) {\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trelease_sock(sk);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tlock_sock(sk);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeout);\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t} else if (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tssize_t read;\n\n\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\t\tif (ready < 0) {\n\t\t\t\t/* Invalid queue pair content. XXX This should\n\t\t\t\t* be changed to a connection reset in a later\n\t\t\t\t* change.\n\t\t\t\t*/\n\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = transport->notify_recv_pre_dequeue(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\tread = transport->stream_dequeue(\n\t\t\t\t\tvsk, msg,\n\t\t\t\t\tlen - copied, flags);\n\t\t\tif (read < 0) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopied += read;\n\n\t\t\terr = transport->notify_recv_post_dequeue(\n\t\t\t\t\tvsk, target, read,\n\t\t\t\t\t!(flags & MSG_PEEK), &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tif (read >= target || flags & MSG_PEEK)\n\t\t\t\tbreak;\n\n\t\t\ttarget -= read;\n\t\t}\n\t}\n\n\tif (sk->sk_err)\n\t\terr = -sk->sk_err;\n\telse if (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\terr = 0;\n\n\tif (copied > 0)\n\t\terr = copied;\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
    "abstract_func_before": "static int\nvsock_stream_recvmsg(struct socket *VAR_0, struct msghdr *VAR_1, size_t VAR_2,\n\t\t     int VAR_3)\n{\n\tstruct sock *VAR_4;\n\tstruct vsock_sock *VAR_5;\n\tconst struct vsock_transport *VAR_6;\n\tint VAR_7;\n\tsize_t VAR_8;\n\tssize_t VAR_9;\n\tlong VAR_10;\n\tstruct vsock_transport_recv_notify_data VAR_11;\n\n\tDEFINE_WAIT(VAR_12);\n\n\tVAR_4 = sock->sk;\n\tVAR_5 = vsock_sk(VAR_4);\n\tVAR_6 = VAR_5->transport;\n\tVAR_7 = 0;\n\n\tlock_sock(VAR_4);\n\n\tif (!VAR_6 || VAR_4->sk_state != VAR_13) {\n\t\t/* COMMENT_0 */\n                                                                 \n                                                                \n                    \n     \n\t\tif (sock_flag(VAR_4, VAR_14))\n\t\t\tVAR_7 = 0;\n\t\telse\n\t\t\tVAR_7 = -VAR_15;\n\n\t\tgoto out;\n\t}\n\n\tif (VAR_3 & VAR_16) {\n\t\tVAR_7 = -VAR_17;\n\t\tgoto out;\n\t}\n\n\t/* COMMENT_5 */\n                                                                    \n            \n    \n\tif (VAR_4->sk_shutdown & VAR_18) {\n\t\tVAR_7 = 0;\n\t\tgoto out;\n\t}\n\n\t/* COMMENT_9 */\n                                                  \n    \n\tif (!VAR_2) {\n\t\tVAR_7 = 0;\n\t\tgoto out;\n\t}\n\n\t/* COMMENT_12 */\n                                                                      \n                                                                     \n                                                                        \n               \n    \n\tVAR_8 = sock_rcvlowat(VAR_4, VAR_3 & VAR_19, VAR_2);\n\tif (VAR_8 >= VAR_6->stream_rcvhiwat(VAR_5)) {\n\t\tVAR_7 = -VAR_20;\n\t\tgoto out;\n\t}\n\tVAR_10 = sock_rcvtimeo(VAR_4, VAR_3 & VAR_21);\n\tVAR_9 = 0;\n\n\tVAR_7 = VAR_6->notify_recv_init(VAR_5, VAR_8, &VAR_11);\n\tif (VAR_7 < 0)\n\t\tgoto out;\n\n\n\twhile (1) {\n\t\ts64 VAR_22;\n\n\t\tprepare_to_wait(sk_sleep(VAR_4), &VAR_12, VAR_23);\n\t\tVAR_22 = vsock_stream_has_data(VAR_5);\n\n\t\tif (VAR_22 == 0) {\n\t\t\tif (VAR_4->sk_err != 0 ||\n\t\t\t    (VAR_4->sk_shutdown & VAR_18) ||\n\t\t\t    (VAR_5->peer_shutdown & VAR_24)) {\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* COMMENT_18 */\n\t\t\tif (VAR_10 == 0) {\n\t\t\t\tVAR_7 = -VAR_25;\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_7 = VAR_6->notify_recv_pre_block(\n\t\t\t\t\tVAR_5, VAR_8, &VAR_11);\n\t\t\tif (VAR_7 < 0) {\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trelease_sock(VAR_4);\n\t\t\tVAR_10 = schedule_timeout(VAR_10);\n\t\t\tlock_sock(VAR_4);\n\n\t\t\tif (signal_pending(VAR_26)) {\n\t\t\t\tVAR_7 = sock_intr_errno(VAR_10);\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t} else if (VAR_10 == 0) {\n\t\t\t\tVAR_7 = -VAR_25;\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tssize_t VAR_27;\n\n\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\n\t\t\tif (VAR_22 < 0) {\n\t\t\t\t/* COMMENT_19 */\n                                                 \n             \n      \n\n\t\t\t\tVAR_7 = -VAR_20;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tVAR_7 = VAR_6->notify_recv_pre_dequeue(\n\t\t\t\t\tVAR_5, VAR_8, &VAR_11);\n\t\t\tif (VAR_7 < 0)\n\t\t\t\tbreak;\n\n\t\t\tVAR_27 = VAR_6->stream_dequeue(\n\t\t\t\t\tVAR_5, VAR_1,\n\t\t\t\t\tVAR_2 - VAR_9, VAR_3);\n\t\t\tif (VAR_27 < 0) {\n\t\t\t\tVAR_7 = -VAR_20;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_9 += VAR_27;\n\n\t\t\tVAR_7 = VAR_6->notify_recv_post_dequeue(\n\t\t\t\t\tVAR_5, VAR_8, VAR_27,\n\t\t\t\t\t!(VAR_3 & VAR_28), &VAR_11);\n\t\t\tif (VAR_7 < 0)\n\t\t\t\tgoto out;\n\n\t\t\tif (VAR_27 >= VAR_8 || VAR_3 & VAR_28)\n\t\t\t\tbreak;\n\n\t\t\tVAR_8 -= VAR_27;\n\t\t}\n\t}\n\n\tif (VAR_4->sk_err)\n\t\tVAR_7 = -VAR_4->sk_err;\n\telse if (VAR_4->sk_shutdown & VAR_18)\n\t\tVAR_7 = 0;\n\n\tif (VAR_9 > 0)\n\t\tVAR_7 = VAR_9;\n\nout:\n\trelease_sock(VAR_4);\n\treturn VAR_7;\n}",
    "func_graph_path_before": "torvalds/linux/c518adafa39f37858697ac9309c6cf1805581446/af_vsock.c/vul/before/4.json",
    "func": "static int\nvsock_stream_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t     int flags)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n\tint err;\n\tsize_t target;\n\tssize_t copied;\n\tlong timeout;\n\tstruct vsock_transport_recv_notify_data recv_data;\n\n\tDEFINE_WAIT(wait);\n\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\terr = 0;\n\n\tlock_sock(sk);\n\n\ttransport = vsk->transport;\n\n\tif (!transport || sk->sk_state != TCP_ESTABLISHED) {\n\t\t/* Recvmsg is supposed to return 0 if a peer performs an\n\t\t * orderly shutdown. Differentiate between that case and when a\n\t\t * peer has not connected or a local shutdown occured with the\n\t\t * SOCK_DONE flag.\n\t\t */\n\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -ENOTCONN;\n\n\t\tgoto out;\n\t}\n\n\tif (flags & MSG_OOB) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* We don't check peer_shutdown flag here since peer may actually shut\n\t * down, but there can be data in the queue that a local socket can\n\t * receive.\n\t */\n\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* It is valid on Linux to pass in a zero-length receive buffer.  This\n\t * is not an error.  We may as well bail out now.\n\t */\n\tif (!len) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* We must not copy less than target bytes into the user's buffer\n\t * before returning successfully, so we wait for the consume queue to\n\t * have that much data to consume before dequeueing.  Note that this\n\t * makes it impossible to handle cases where target is greater than the\n\t * queue size.\n\t */\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tif (target >= transport->stream_rcvhiwat(vsk)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tcopied = 0;\n\n\terr = transport->notify_recv_init(vsk, target, &recv_data);\n\tif (err < 0)\n\t\tgoto out;\n\n\n\twhile (1) {\n\t\ts64 ready;\n\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tready = vsock_stream_has_data(vsk);\n\n\t\tif (ready == 0) {\n\t\t\tif (sk->sk_err != 0 ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    (vsk->peer_shutdown & SEND_SHUTDOWN)) {\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Don't wait for non-blocking sockets. */\n\t\t\tif (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = transport->notify_recv_pre_block(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0) {\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trelease_sock(sk);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tlock_sock(sk);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeout);\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t} else if (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tssize_t read;\n\n\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\t\tif (ready < 0) {\n\t\t\t\t/* Invalid queue pair content. XXX This should\n\t\t\t\t* be changed to a connection reset in a later\n\t\t\t\t* change.\n\t\t\t\t*/\n\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = transport->notify_recv_pre_dequeue(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\tread = transport->stream_dequeue(\n\t\t\t\t\tvsk, msg,\n\t\t\t\t\tlen - copied, flags);\n\t\t\tif (read < 0) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopied += read;\n\n\t\t\terr = transport->notify_recv_post_dequeue(\n\t\t\t\t\tvsk, target, read,\n\t\t\t\t\t!(flags & MSG_PEEK), &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tif (read >= target || flags & MSG_PEEK)\n\t\t\t\tbreak;\n\n\t\t\ttarget -= read;\n\t\t}\n\t}\n\n\tif (sk->sk_err)\n\t\terr = -sk->sk_err;\n\telse if (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\terr = 0;\n\n\tif (copied > 0)\n\t\terr = copied;\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
    "abstract_func": "static int\nvsock_stream_recvmsg(struct socket *VAR_0, struct msghdr *VAR_1, size_t VAR_2,\n\t\t     int VAR_3)\n{\n\tstruct sock *VAR_4;\n\tstruct vsock_sock *VAR_5;\n\tconst struct vsock_transport *VAR_6;\n\tint VAR_7;\n\tsize_t VAR_8;\n\tssize_t VAR_9;\n\tlong VAR_10;\n\tstruct vsock_transport_recv_notify_data VAR_11;\n\n\tDEFINE_WAIT(VAR_12);\n\n\tVAR_4 = sock->sk;\n\tVAR_5 = vsock_sk(VAR_4);\n\tVAR_7 = 0;\n\n\tlock_sock(VAR_4);\n\n\tVAR_6 = VAR_5->transport;\n\n\tif (!VAR_6 || VAR_4->sk_state != VAR_13) {\n\t\t/* COMMENT_0 */\n                                                                 \n                                                                \n                    \n     \n\t\tif (sock_flag(VAR_4, VAR_14))\n\t\t\tVAR_7 = 0;\n\t\telse\n\t\t\tVAR_7 = -VAR_15;\n\n\t\tgoto out;\n\t}\n\n\tif (VAR_3 & VAR_16) {\n\t\tVAR_7 = -VAR_17;\n\t\tgoto out;\n\t}\n\n\t/* COMMENT_5 */\n                                                                    \n            \n    \n\tif (VAR_4->sk_shutdown & VAR_18) {\n\t\tVAR_7 = 0;\n\t\tgoto out;\n\t}\n\n\t/* COMMENT_9 */\n                                                  \n    \n\tif (!VAR_2) {\n\t\tVAR_7 = 0;\n\t\tgoto out;\n\t}\n\n\t/* COMMENT_12 */\n                                                                      \n                                                                     \n                                                                        \n               \n    \n\tVAR_8 = sock_rcvlowat(VAR_4, VAR_3 & VAR_19, VAR_2);\n\tif (VAR_8 >= VAR_6->stream_rcvhiwat(VAR_5)) {\n\t\tVAR_7 = -VAR_20;\n\t\tgoto out;\n\t}\n\tVAR_10 = sock_rcvtimeo(VAR_4, VAR_3 & VAR_21);\n\tVAR_9 = 0;\n\n\tVAR_7 = VAR_6->notify_recv_init(VAR_5, VAR_8, &VAR_11);\n\tif (VAR_7 < 0)\n\t\tgoto out;\n\n\n\twhile (1) {\n\t\ts64 VAR_22;\n\n\t\tprepare_to_wait(sk_sleep(VAR_4), &VAR_12, VAR_23);\n\t\tVAR_22 = vsock_stream_has_data(VAR_5);\n\n\t\tif (VAR_22 == 0) {\n\t\t\tif (VAR_4->sk_err != 0 ||\n\t\t\t    (VAR_4->sk_shutdown & VAR_18) ||\n\t\t\t    (VAR_5->peer_shutdown & VAR_24)) {\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* COMMENT_18 */\n\t\t\tif (VAR_10 == 0) {\n\t\t\t\tVAR_7 = -VAR_25;\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_7 = VAR_6->notify_recv_pre_block(\n\t\t\t\t\tVAR_5, VAR_8, &VAR_11);\n\t\t\tif (VAR_7 < 0) {\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trelease_sock(VAR_4);\n\t\t\tVAR_10 = schedule_timeout(VAR_10);\n\t\t\tlock_sock(VAR_4);\n\n\t\t\tif (signal_pending(VAR_26)) {\n\t\t\t\tVAR_7 = sock_intr_errno(VAR_10);\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t} else if (VAR_10 == 0) {\n\t\t\t\tVAR_7 = -VAR_25;\n\t\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tssize_t VAR_27;\n\n\t\t\tfinish_wait(sk_sleep(VAR_4), &VAR_12);\n\n\t\t\tif (VAR_22 < 0) {\n\t\t\t\t/* COMMENT_19 */\n                                                 \n             \n      \n\n\t\t\t\tVAR_7 = -VAR_20;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tVAR_7 = VAR_6->notify_recv_pre_dequeue(\n\t\t\t\t\tVAR_5, VAR_8, &VAR_11);\n\t\t\tif (VAR_7 < 0)\n\t\t\t\tbreak;\n\n\t\t\tVAR_27 = VAR_6->stream_dequeue(\n\t\t\t\t\tVAR_5, VAR_1,\n\t\t\t\t\tVAR_2 - VAR_9, VAR_3);\n\t\t\tif (VAR_27 < 0) {\n\t\t\t\tVAR_7 = -VAR_20;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_9 += VAR_27;\n\n\t\t\tVAR_7 = VAR_6->notify_recv_post_dequeue(\n\t\t\t\t\tVAR_5, VAR_8, VAR_27,\n\t\t\t\t\t!(VAR_3 & VAR_28), &VAR_11);\n\t\t\tif (VAR_7 < 0)\n\t\t\t\tgoto out;\n\n\t\t\tif (VAR_27 >= VAR_8 || VAR_3 & VAR_28)\n\t\t\t\tbreak;\n\n\t\t\tVAR_8 -= VAR_27;\n\t\t}\n\t}\n\n\tif (VAR_4->sk_err)\n\t\tVAR_7 = -VAR_4->sk_err;\n\telse if (VAR_4->sk_shutdown & VAR_18)\n\t\tVAR_7 = 0;\n\n\tif (VAR_9 > 0)\n\t\tVAR_7 = VAR_9;\n\nout:\n\trelease_sock(VAR_4);\n\treturn VAR_7;\n}",
    "func_graph_path": "torvalds/linux/c518adafa39f37858697ac9309c6cf1805581446/af_vsock.c/vul/after/4.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -15,10 +15,11 @@\n \n \tsk = sock->sk;\n \tvsk = vsock_sk(sk);\n-\ttransport = vsk->transport;\n \terr = 0;\n \n \tlock_sock(sk);\n+\n+\ttransport = vsk->transport;\n \n \tif (!transport || sk->sk_state != TCP_ESTABLISHED) {\n \t\t/* Recvmsg is supposed to return 0 if a peer performs an",
    "diff_line_info": {
        "deleted_lines": [
            "\ttransport = vsk->transport;"
        ],
        "added_lines": [
            "",
            "\ttransport = vsk->transport;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}