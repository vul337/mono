{
    "cve_id": "CVE-2016-1619",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "pdfium",
    "commit_msg": "Merge to XFA: Fix integer and bounds issues in sycc4{22,44}_to_rgb.\n\nAlso clean up while we're here.\n\nBUG=557223\nTBR=tsepez@chromium.org\n\nOriginal Review URL: https://codereview.chromium.org/1512833008 .\n\n(cherry picked from commit 08750d0400f1635ac33c3234cb11b192f31a1eeb)\n\nReview URL: https://codereview.chromium.org/1521473003 .\n",
    "commit_hash": "b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032",
    "git_url": "https://pdfium.googlesource.com/pdfium/+/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032",
    "file_path": "core/src/fxcodec/codec/fx_codec_jpx_opj.cpp",
    "func_name": "sycc422_to_rgb",
    "func_before": "static void sycc422_to_rgb(opj_image_t* img) {\n  int *d0, *d1, *d2, *r, *g, *b;\n  const int *y, *cb, *cr;\n  int maxw, maxh, max, offset, upb;\n  int i, j;\n  i = (int)img->comps[0].prec;\n  offset = 1 << (i - 1);\n  upb = (1 << i) - 1;\n  maxw = (int)img->comps[0].w;\n  maxh = (int)img->comps[0].h;\n  max = maxw * maxh;\n  y = img->comps[0].data;\n  cb = img->comps[1].data;\n  cr = img->comps[2].data;\n  d0 = r = FX_Alloc(int, (size_t)max);\n  d1 = g = FX_Alloc(int, (size_t)max);\n  d2 = b = FX_Alloc(int, (size_t)max);\n  for (i = 0; i < maxh; ++i) {\n    for (j = 0; (OPJ_UINT32)j < (maxw & ~(OPJ_UINT32)1); j += 2) {\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      ++cb;\n      ++cr;\n    }\n    if (j < maxw) {\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      ++cb;\n      ++cr;\n    }\n  }\n  FX_Free(img->comps[0].data);\n  img->comps[0].data = d0;\n  FX_Free(img->comps[1].data);\n  img->comps[1].data = d1;\n  FX_Free(img->comps[2].data);\n  img->comps[2].data = d2;\n  img->comps[1].w = maxw;\n  img->comps[1].h = maxh;\n  img->comps[2].w = maxw;\n  img->comps[2].h = maxh;\n  img->comps[1].w = (OPJ_UINT32)maxw;\n  img->comps[1].h = (OPJ_UINT32)maxh;\n  img->comps[2].w = (OPJ_UINT32)maxw;\n  img->comps[2].h = (OPJ_UINT32)maxh;\n  img->comps[1].dx = img->comps[0].dx;\n  img->comps[2].dx = img->comps[0].dx;\n  img->comps[1].dy = img->comps[0].dy;\n  img->comps[2].dy = img->comps[0].dy;\n}",
    "abstract_func_before": "static void sycc422_to_rgb(opj_image_t* VAR_0) {\n  int *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6;\n  const int *VAR_7, *VAR_8, *VAR_9;\n  int VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;\n  int VAR_15, VAR_16;\n  VAR_15 = (int)VAR_0->comps[0].prec;\n  VAR_13 = 1 << (VAR_15 - 1);\n  VAR_14 = (1 << VAR_15) - 1;\n  VAR_10 = (int)VAR_0->comps[0].w;\n  VAR_11 = (int)VAR_0->comps[0].h;\n  VAR_12 = VAR_10 * VAR_11;\n  VAR_7 = VAR_0->comps[0].data;\n  VAR_8 = VAR_0->comps[1].data;\n  VAR_9 = VAR_0->comps[2].data;\n  VAR_1 = VAR_4 = VAR_17(int, (size_t)VAR_12);\n  VAR_2 = VAR_5 = VAR_17(int, (size_t)VAR_12);\n  VAR_3 = VAR_6 = VAR_17(int, (size_t)VAR_12);\n  for (VAR_15 = 0; VAR_15 < VAR_11; ++VAR_15) {\n    for (VAR_16 = 0; (OPJ_UINT32)VAR_16 < (VAR_10 & ~(OPJ_UINT32)1); VAR_16 += 2) {\n      sycc_to_rgb(VAR_13, VAR_14, *VAR_7, *VAR_8, *VAR_9, VAR_4, VAR_5, VAR_6);\n      ++VAR_7;\n      ++VAR_4;\n      ++VAR_5;\n      ++VAR_6;\n      sycc_to_rgb(VAR_13, VAR_14, *VAR_7, *VAR_8, *VAR_9, VAR_4, VAR_5, VAR_6);\n      ++VAR_7;\n      ++VAR_4;\n      ++VAR_5;\n      ++VAR_6;\n      ++VAR_8;\n      ++VAR_9;\n    }\n    if (VAR_16 < VAR_10) {\n      sycc_to_rgb(VAR_13, VAR_14, *VAR_7, *VAR_8, *VAR_9, VAR_4, VAR_5, VAR_6);\n      ++VAR_7;\n      ++VAR_4;\n      ++VAR_5;\n      ++VAR_6;\n      ++VAR_8;\n      ++VAR_9;\n    }\n  }\n  FX_Free(VAR_0->comps[0].data);\n  VAR_0->comps[0].data = VAR_1;\n  FX_Free(VAR_0->comps[1].data);\n  VAR_0->comps[1].data = VAR_2;\n  FX_Free(VAR_0->comps[2].data);\n  VAR_0->comps[2].data = VAR_3;\n  VAR_0->comps[1].w = VAR_10;\n  VAR_0->comps[1].h = VAR_11;\n  VAR_0->comps[2].w = VAR_10;\n  VAR_0->comps[2].h = VAR_11;\n  VAR_0->comps[1].w = (OPJ_UINT32)VAR_10;\n  VAR_0->comps[1].h = (OPJ_UINT32)VAR_11;\n  VAR_0->comps[2].w = (OPJ_UINT32)VAR_10;\n  VAR_0->comps[2].h = (OPJ_UINT32)VAR_11;\n  VAR_0->comps[1].dx = VAR_0->comps[0].dx;\n  VAR_0->comps[2].dx = VAR_0->comps[0].dx;\n  VAR_0->comps[1].dy = VAR_0->comps[0].dy;\n  VAR_0->comps[2].dy = VAR_0->comps[0].dy;\n}",
    "func_graph_path_before": "pdfium/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032/fx_codec_jpx_opj.cpp/vul/before/0.json",
    "func": "static void sycc422_to_rgb(opj_image_t* img) {\n  int prec = img->comps[0].prec;\n  int offset = 1 << (prec - 1);\n  int upb = (1 << prec) - 1;\n  OPJ_UINT32 maxw =\n      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);\n  OPJ_UINT32 maxh =\n      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);\n  FX_SAFE_SIZE_T max_size = maxw;\n  max_size *= maxh;\n  if (!max_size.IsValid())\n    return;\n\n  const int* y = img->comps[0].data;\n  const int* cb = img->comps[1].data;\n  const int* cr = img->comps[2].data;\n  int *d0, *d1, *d2, *r, *g, *b;\n  d0 = r = FX_Alloc(int, max_size.ValueOrDie());\n  d1 = g = FX_Alloc(int, max_size.ValueOrDie());\n  d2 = b = FX_Alloc(int, max_size.ValueOrDie());\n  for (uint32_t i = 0; i < maxh; ++i) {\n    OPJ_UINT32 j;\n    for (j = 0; j < (maxw & ~static_cast<OPJ_UINT32>(1)); j += 2) {\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      ++cb;\n      ++cr;\n    }\n    if (j < maxw) {\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      ++cb;\n      ++cr;\n    }\n  }\n  FX_Free(img->comps[0].data);\n  img->comps[0].data = d0;\n  FX_Free(img->comps[1].data);\n  img->comps[1].data = d1;\n  FX_Free(img->comps[2].data);\n  img->comps[2].data = d2;\n  img->comps[1].w = maxw;\n  img->comps[1].h = maxh;\n  img->comps[2].w = maxw;\n  img->comps[2].h = maxh;\n  img->comps[1].dx = img->comps[0].dx;\n  img->comps[2].dx = img->comps[0].dx;\n  img->comps[1].dy = img->comps[0].dy;\n  img->comps[2].dy = img->comps[0].dy;\n}",
    "abstract_func": "static void sycc422_to_rgb(opj_image_t* VAR_0) {\n  int VAR_1 = VAR_0->comps[0].prec;\n  int VAR_2 = 1 << (VAR_1 - 1);\n  int VAR_3 = (1 << VAR_1) - 1;\n  OPJ_UINT32 VAR_4 =\n      std::min(std::min(VAR_0->comps[0].w, VAR_0->comps[1].w), VAR_0->comps[2].w);\n  OPJ_UINT32 VAR_5 =\n      std::min(std::min(VAR_0->comps[0].h, VAR_0->comps[1].h), VAR_0->comps[2].h);\n  FX_SAFE_SIZE_T VAR_6 = VAR_4;\n  VAR_6 *= VAR_5;\n  if (!VAR_6.IsValid())\n    return;\n\n  const int* VAR_7 = VAR_0->comps[0].data;\n  const int* VAR_8 = VAR_0->comps[1].data;\n  const int* VAR_9 = VAR_0->comps[2].data;\n  int *VAR_10, *VAR_11, *VAR_12, *VAR_13, *VAR_14, *VAR_15;\n  VAR_10 = VAR_13 = FX_Alloc(int, VAR_6.ValueOrDie());\n  VAR_11 = VAR_14 = FX_Alloc(int, VAR_6.ValueOrDie());\n  VAR_12 = VAR_15 = FX_Alloc(int, VAR_6.ValueOrDie());\n  for (uint32_t VAR_16 = 0; VAR_16 < VAR_5; ++VAR_16) {\n    OPJ_UINT32 VAR_17;\n    for (VAR_17 = 0; VAR_17 < (VAR_4 & ~VAR_18<OPJ_UINT32>(1)); VAR_17 += 2) {\n      sycc_to_rgb(VAR_2, VAR_3, *VAR_7, *VAR_8, *VAR_9, VAR_13, VAR_14, VAR_15);\n      ++VAR_7;\n      ++VAR_13;\n      ++VAR_14;\n      ++VAR_15;\n      sycc_to_rgb(VAR_2, VAR_3, *VAR_7, *VAR_8, *VAR_9, VAR_13, VAR_14, VAR_15);\n      ++VAR_7;\n      ++VAR_13;\n      ++VAR_14;\n      ++VAR_15;\n      ++VAR_8;\n      ++VAR_9;\n    }\n    if (VAR_17 < VAR_4) {\n      sycc_to_rgb(VAR_2, VAR_3, *VAR_7, *VAR_8, *VAR_9, VAR_13, VAR_14, VAR_15);\n      ++VAR_7;\n      ++VAR_13;\n      ++VAR_14;\n      ++VAR_15;\n      ++VAR_8;\n      ++VAR_9;\n    }\n  }\n  FX_Free(VAR_0->comps[0].data);\n  VAR_0->comps[0].data = VAR_10;\n  FX_Free(VAR_0->comps[1].data);\n  VAR_0->comps[1].data = VAR_11;\n  FX_Free(VAR_0->comps[2].data);\n  VAR_0->comps[2].data = VAR_12;\n  VAR_0->comps[1].w = VAR_4;\n  VAR_0->comps[1].h = VAR_5;\n  VAR_0->comps[2].w = VAR_4;\n  VAR_0->comps[2].h = VAR_5;\n  VAR_0->comps[1].dx = VAR_0->comps[0].dx;\n  VAR_0->comps[2].dx = VAR_0->comps[0].dx;\n  VAR_0->comps[1].dy = VAR_0->comps[0].dy;\n  VAR_0->comps[2].dy = VAR_0->comps[0].dy;\n}",
    "func_graph_path": "pdfium/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032/fx_codec_jpx_opj.cpp/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,22 +1,26 @@\n static void sycc422_to_rgb(opj_image_t* img) {\n+  int prec = img->comps[0].prec;\n+  int offset = 1 << (prec - 1);\n+  int upb = (1 << prec) - 1;\n+  OPJ_UINT32 maxw =\n+      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);\n+  OPJ_UINT32 maxh =\n+      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);\n+  FX_SAFE_SIZE_T max_size = maxw;\n+  max_size *= maxh;\n+  if (!max_size.IsValid())\n+    return;\n+\n+  const int* y = img->comps[0].data;\n+  const int* cb = img->comps[1].data;\n+  const int* cr = img->comps[2].data;\n   int *d0, *d1, *d2, *r, *g, *b;\n-  const int *y, *cb, *cr;\n-  int maxw, maxh, max, offset, upb;\n-  int i, j;\n-  i = (int)img->comps[0].prec;\n-  offset = 1 << (i - 1);\n-  upb = (1 << i) - 1;\n-  maxw = (int)img->comps[0].w;\n-  maxh = (int)img->comps[0].h;\n-  max = maxw * maxh;\n-  y = img->comps[0].data;\n-  cb = img->comps[1].data;\n-  cr = img->comps[2].data;\n-  d0 = r = FX_Alloc(int, (size_t)max);\n-  d1 = g = FX_Alloc(int, (size_t)max);\n-  d2 = b = FX_Alloc(int, (size_t)max);\n-  for (i = 0; i < maxh; ++i) {\n-    for (j = 0; (OPJ_UINT32)j < (maxw & ~(OPJ_UINT32)1); j += 2) {\n+  d0 = r = FX_Alloc(int, max_size.ValueOrDie());\n+  d1 = g = FX_Alloc(int, max_size.ValueOrDie());\n+  d2 = b = FX_Alloc(int, max_size.ValueOrDie());\n+  for (uint32_t i = 0; i < maxh; ++i) {\n+    OPJ_UINT32 j;\n+    for (j = 0; j < (maxw & ~static_cast<OPJ_UINT32>(1)); j += 2) {\n       sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n       ++y;\n       ++r;\n@@ -50,10 +54,6 @@\n   img->comps[1].h = maxh;\n   img->comps[2].w = maxw;\n   img->comps[2].h = maxh;\n-  img->comps[1].w = (OPJ_UINT32)maxw;\n-  img->comps[1].h = (OPJ_UINT32)maxh;\n-  img->comps[2].w = (OPJ_UINT32)maxw;\n-  img->comps[2].h = (OPJ_UINT32)maxh;\n   img->comps[1].dx = img->comps[0].dx;\n   img->comps[2].dx = img->comps[0].dx;\n   img->comps[1].dy = img->comps[0].dy;",
    "diff_line_info": {
        "deleted_lines": [
            "  const int *y, *cb, *cr;",
            "  int maxw, maxh, max, offset, upb;",
            "  int i, j;",
            "  i = (int)img->comps[0].prec;",
            "  offset = 1 << (i - 1);",
            "  upb = (1 << i) - 1;",
            "  maxw = (int)img->comps[0].w;",
            "  maxh = (int)img->comps[0].h;",
            "  max = maxw * maxh;",
            "  y = img->comps[0].data;",
            "  cb = img->comps[1].data;",
            "  cr = img->comps[2].data;",
            "  d0 = r = FX_Alloc(int, (size_t)max);",
            "  d1 = g = FX_Alloc(int, (size_t)max);",
            "  d2 = b = FX_Alloc(int, (size_t)max);",
            "  for (i = 0; i < maxh; ++i) {",
            "    for (j = 0; (OPJ_UINT32)j < (maxw & ~(OPJ_UINT32)1); j += 2) {",
            "  img->comps[1].w = (OPJ_UINT32)maxw;",
            "  img->comps[1].h = (OPJ_UINT32)maxh;",
            "  img->comps[2].w = (OPJ_UINT32)maxw;",
            "  img->comps[2].h = (OPJ_UINT32)maxh;"
        ],
        "added_lines": [
            "  int prec = img->comps[0].prec;",
            "  int offset = 1 << (prec - 1);",
            "  int upb = (1 << prec) - 1;",
            "  OPJ_UINT32 maxw =",
            "      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);",
            "  OPJ_UINT32 maxh =",
            "      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);",
            "  FX_SAFE_SIZE_T max_size = maxw;",
            "  max_size *= maxh;",
            "  if (!max_size.IsValid())",
            "    return;",
            "",
            "  const int* y = img->comps[0].data;",
            "  const int* cb = img->comps[1].data;",
            "  const int* cr = img->comps[2].data;",
            "  d0 = r = FX_Alloc(int, max_size.ValueOrDie());",
            "  d1 = g = FX_Alloc(int, max_size.ValueOrDie());",
            "  d2 = b = FX_Alloc(int, max_size.ValueOrDie());",
            "  for (uint32_t i = 0; i < maxh; ++i) {",
            "    OPJ_UINT32 j;",
            "    for (j = 0; j < (maxw & ~static_cast<OPJ_UINT32>(1)); j += 2) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}