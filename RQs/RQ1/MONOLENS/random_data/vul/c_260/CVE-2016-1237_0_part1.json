{
    "cve_id": "CVE-2016-1237",
    "cwe_ids": [
        "CWE-284"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "nfsd: check permissions when setting ACLs\n\nUse set_posix_acl, which includes proper permission checks, instead of\ncalling ->set_acl directly.  Without this anyone may be able to grant\nthemselves permissions to a file by setting the ACL.\n\nLock the inode to make the new checks atomic with respect to set_acl.\n(Also, nfsd was the only caller of set_acl not locking the inode, so I\nsuspect this may fix other races.)\n\nThis also simplifies the code, and ensures our ACLs are checked by\nposix_acl_valid.\n\nThe permission checks and the inode locking were lost with commit\n4ac7249e, which changed nfsd to use the set_acl inode operation directly\ninstead of going through xattr handlers.\n\nReported-by: David Sinquin <david@sinquin.eu>\n[agreunba@redhat.com: use set_posix_acl]\nFixes: 4ac7249e\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>",
    "commit_hash": "999653786df6954a31044528ac3f7a5dadca08f4",
    "git_url": "https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4",
    "file_path": "fs/nfsd/nfs4acl.c",
    "func_name": "nfsd4_set_nfs4_acl",
    "func_before": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\n\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}",
    "abstract_func_before": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *VAR_0, struct svc_fh *VAR_1,\n\t\tstruct nfs4_acl *VAR_2)\n{\n\t__be32 VAR_3;\n\tint VAR_4;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *VAR_5 = NULL, *VAR_6 = NULL;\n\tunsigned int VAR_7 = 0;\n\n\t/* COMMENT_0 */\n\tVAR_3 = fh_verify(VAR_0, VAR_1, 0, VAR_8);\n\tif (VAR_3)\n\t\treturn VAR_3;\n\n\tdentry = VAR_1->fh_dentry;\n\tinode = d_inode(dentry);\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn VAR_9;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tVAR_7 = VAR_10;\n\n\tVAR_4 = nfs4_acl_nfsv4_to_posix(VAR_2, &VAR_5, &VAR_6, VAR_7);\n\tif (VAR_4 == -VAR_11)\n\t\treturn VAR_9;\n\tif (VAR_4 < 0)\n\t\tgoto out_nfserr;\n\n\tVAR_4 = inode->i_op->set_acl(inode, VAR_5, VAR_12);\n\tif (VAR_4 < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tVAR_4 = inode->i_op->set_acl(inode, VAR_6,\n\t\t\t\t\t\t  VAR_13);\n\t}\n\nout_release:\n\tposix_acl_release(VAR_5);\n\tposix_acl_release(VAR_6);\nout_nfserr:\n\tif (VAR_4 == -VAR_14)\n\t\treturn VAR_9;\n\telse\n\t\treturn nfserrno(VAR_4);\n}",
    "func_graph_path_before": "torvalds/linux/999653786df6954a31044528ac3f7a5dadca08f4/nfs4acl.c/vul/before/0.json",
    "func": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\tfh_lock(fhp);\n\n\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);\n\tif (host_error < 0)\n\t\tgoto out_drop_lock;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);\n\t}\n\nout_drop_lock:\n\tfh_unlock(fhp);\n\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}",
    "abstract_func": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *VAR_0, struct svc_fh *VAR_1,\n\t\tstruct nfs4_acl *VAR_2)\n{\n\t__be32 VAR_3;\n\tint VAR_4;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *VAR_5 = NULL, *VAR_6 = NULL;\n\tunsigned int VAR_7 = 0;\n\n\t/* COMMENT_0 */\n\tVAR_3 = fh_verify(VAR_0, VAR_1, 0, VAR_8);\n\tif (VAR_3)\n\t\treturn VAR_3;\n\n\tdentry = VAR_1->fh_dentry;\n\tinode = d_inode(dentry);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tVAR_7 = VAR_9;\n\n\tVAR_4 = nfs4_acl_nfsv4_to_posix(VAR_2, &VAR_5, &VAR_6, VAR_7);\n\tif (VAR_4 == -VAR_10)\n\t\treturn VAR_11;\n\tif (VAR_4 < 0)\n\t\tgoto out_nfserr;\n\n\tfh_lock(VAR_1);\n\n\tVAR_4 = set_posix_acl(inode, VAR_12, VAR_5);\n\tif (VAR_4 < 0)\n\t\tgoto out_drop_lock;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tVAR_4 = set_posix_acl(inode, VAR_13, VAR_6);\n\t}\n\nout_drop_lock:\n\tfh_unlock(VAR_1);\n\n\tposix_acl_release(VAR_5);\n\tposix_acl_release(VAR_6);\nout_nfserr:\n\tif (VAR_4 == -VAR_14)\n\t\treturn VAR_11;\n\telse\n\t\treturn nfserrno(VAR_4);\n}",
    "func_graph_path": "torvalds/linux/999653786df6954a31044528ac3f7a5dadca08f4/nfs4acl.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -17,9 +17,6 @@\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n \n-\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n-\t\treturn nfserr_attrnotsupp;\n-\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n \n@@ -29,16 +26,19 @@\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n \n-\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n+\tfh_lock(fhp);\n+\n+\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);\n \tif (host_error < 0)\n-\t\tgoto out_release;\n+\t\tgoto out_drop_lock;\n \n \tif (S_ISDIR(inode->i_mode)) {\n-\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n-\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n+\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);\n \t}\n \n-out_release:\n+out_drop_lock:\n+\tfh_unlock(fhp);\n+\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))",
            "\t\treturn nfserr_attrnotsupp;",
            "",
            "\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);",
            "\t\tgoto out_release;",
            "\t\thost_error = inode->i_op->set_acl(inode, dpacl,",
            "\t\t\t\t\t\t  ACL_TYPE_DEFAULT);",
            "out_release:"
        ],
        "added_lines": [
            "\tfh_lock(fhp);",
            "",
            "\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);",
            "\t\tgoto out_drop_lock;",
            "\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);",
            "out_drop_lock:",
            "\tfh_unlock(fhp);",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}