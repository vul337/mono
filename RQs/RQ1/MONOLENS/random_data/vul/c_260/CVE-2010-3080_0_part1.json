{
    "cve_id": "CVE-2010-3080",
    "cwe_ids": [
        "CWE-415"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "The error handling in snd_seq_oss_open() has several bad codes that\ndo dereferecing released pointers and double-free of kmalloc'ed data.\nThe object dp is release in free_devinfo() that is called via\nprivate_free callback.  The rest shouldn't touch this object any more.\n\nThe patch changes delete_port() to call kfree() in any case, and gets\nrid of unnecessary calls of destructors in snd_seq_oss_open().\n\nFixes CVE-2010-3080.\n\nReported-and-tested-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nCc: <stable@kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n",
    "commit_hash": "27f7ad53829f79e799a253285318bff79ece15bd",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=27f7ad53829f79e799a253285318bff79ece15bd",
    "file_path": "sound/core/seq/oss/seq_oss_init.c",
    "func_name": "snd_seq_oss_open",
    "func_before": "int\nsnd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", dp));\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t/* look up synth and midi devices */\n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t/* snd_printk(KERN_ERR \"no device found\\n\"); */\n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t/* create port */\n\tdebug_printk((\"create new port\\n\"));\n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* allocate queue */\n\tdebug_printk((\"allocate queue\\n\"));\n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t/* set address */\n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t/*dp->addr.queue = dp->queue;*/\n\t/*dp->addr.channel = 0;*/\n\n\tdp->seq_mode = level;\n\n\t/* set up file mode */\n\tdp->file_mode = translate_mode(file);\n\n\t/* initialize read queue */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize write queue */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize timer */\n\tdebug_printk((\"initialize timer\\n\"));\n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* set private data pointer */\n\tfile->private_data = dp;\n\n\t/* set up for mode2 */\n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_writeq_delete(dp->writeq);\n\tsnd_seq_oss_readq_delete(dp->readq);\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_port(dp);\n\tdelete_seq_queue(dp->queue);\n\tkfree(dp);\n\n\treturn rc;\n}",
    "abstract_func_before": "int\nsnd_seq_oss_open(struct file *file, int VAR_0)\n{\n\tint VAR_1, VAR_2;\n\tstruct seq_oss_devinfo *VAR_3;\n\n\tVAR_3 = kzalloc(sizeof(*VAR_3), VAR_4);\n\tif (!VAR_3) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -VAR_5;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", VAR_3));\n\n\tVAR_3->cseq = VAR_6;\n\tVAR_3->port = -1;\n\tVAR_3->queue = -1;\n\n\tfor (VAR_1 = 0; VAR_1 < VAR_7; VAR_1++) {\n\t\tif (VAR_8[VAR_1] == NULL)\n\t\t\tbreak;\n\t}\n\n\tVAR_3->index = VAR_1;\n\tif (VAR_1 >= VAR_7) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\tVAR_2 = -VAR_5;\n\t\tgoto _error;\n\t}\n\n\t/* COMMENT_0 */\n\tsnd_seq_oss_synth_setup(VAR_3);\n\tsnd_seq_oss_midi_setup(VAR_3);\n\n\tif (VAR_3->synth_opened == 0 && VAR_3->max_mididev == 0) {\n\t\t/* COMMENT_1 */\n\t\tVAR_2 = -VAR_9;\n\t\tgoto _error;\n\t}\n\n\t/* COMMENT_2 */\n\tdebug_printk((\"create new port\\n\"));\n\tVAR_2 = create_port(VAR_3);\n\tif (VAR_2 < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* COMMENT_3 */\n\tdebug_printk((\"allocate queue\\n\"));\n\tVAR_2 = alloc_seq_queue(VAR_3);\n\tif (VAR_2 < 0)\n\t\tgoto _error;\n\n\t/* COMMENT_4 */\n\tVAR_3->addr.client = VAR_3->cseq;\n\tVAR_3->addr.port = VAR_3->port;\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\n\tVAR_3->seq_mode = VAR_0;\n\n\t/* COMMENT_7 */\n\tVAR_3->file_mode = translate_mode(file);\n\n\t/* COMMENT_8 */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(VAR_3->file_mode)) {\n\t\tVAR_3->readq = snd_seq_oss_readq_new(VAR_3, VAR_10);\n\t\tif (!VAR_3->readq) {\n\t\t\tVAR_2 = -VAR_5;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* COMMENT_9 */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(VAR_3->file_mode)) {\n\t\tVAR_3->writeq = snd_seq_oss_writeq_new(VAR_3, VAR_10);\n\t\tif (!VAR_3->writeq) {\n\t\t\tVAR_2 = -VAR_5;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* COMMENT_10 */\n\tdebug_printk((\"initialize timer\\n\"));\n\tVAR_3->timer = snd_seq_oss_timer_new(VAR_3);\n\tif (!VAR_3->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\tVAR_2 = -VAR_5;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* COMMENT_11 */\n\tfile->private_data = VAR_3;\n\n\t/* COMMENT_12 */\n\tif (VAR_0 == VAR_11)\n\t\tsnd_seq_oss_synth_setup_midi(VAR_3);\n\telse if (is_read_mode(VAR_3->file_mode))\n\t\tsnd_seq_oss_midi_open_all(VAR_3, VAR_12);\n\n\tVAR_8[VAR_3->index] = VAR_3;\n\tVAR_13++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_writeq_delete(VAR_3->writeq);\n\tsnd_seq_oss_readq_delete(VAR_3->readq);\n\tsnd_seq_oss_synth_cleanup(VAR_3);\n\tsnd_seq_oss_midi_cleanup(VAR_3);\n\tdelete_port(VAR_3);\n\tdelete_seq_queue(VAR_3->queue);\n\tkfree(VAR_3);\n\n\treturn VAR_2;\n}",
    "func_graph_path_before": "torvalds/linux/27f7ad53829f79e799a253285318bff79ece15bd/seq_oss_init.c/vul/before/1.json",
    "func": "int\nsnd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", dp));\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t/* look up synth and midi devices */\n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t/* snd_printk(KERN_ERR \"no device found\\n\"); */\n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t/* create port */\n\tdebug_printk((\"create new port\\n\"));\n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* allocate queue */\n\tdebug_printk((\"allocate queue\\n\"));\n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t/* set address */\n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t/*dp->addr.queue = dp->queue;*/\n\t/*dp->addr.channel = 0;*/\n\n\tdp->seq_mode = level;\n\n\t/* set up file mode */\n\tdp->file_mode = translate_mode(file);\n\n\t/* initialize read queue */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize write queue */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize timer */\n\tdebug_printk((\"initialize timer\\n\"));\n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* set private data pointer */\n\tfile->private_data = dp;\n\n\t/* set up for mode2 */\n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_seq_queue(dp->queue);\n\tdelete_port(dp);\n\n\treturn rc;\n}",
    "abstract_func": "int\nsnd_seq_oss_open(struct file *file, int VAR_0)\n{\n\tint VAR_1, VAR_2;\n\tstruct seq_oss_devinfo *VAR_3;\n\n\tVAR_3 = kzalloc(sizeof(*VAR_3), VAR_4);\n\tif (!VAR_3) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -VAR_5;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", VAR_3));\n\n\tVAR_3->cseq = VAR_6;\n\tVAR_3->port = -1;\n\tVAR_3->queue = -1;\n\n\tfor (VAR_1 = 0; VAR_1 < VAR_7; VAR_1++) {\n\t\tif (VAR_8[VAR_1] == NULL)\n\t\t\tbreak;\n\t}\n\n\tVAR_3->index = VAR_1;\n\tif (VAR_1 >= VAR_7) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\tVAR_2 = -VAR_5;\n\t\tgoto _error;\n\t}\n\n\t/* COMMENT_0 */\n\tsnd_seq_oss_synth_setup(VAR_3);\n\tsnd_seq_oss_midi_setup(VAR_3);\n\n\tif (VAR_3->synth_opened == 0 && VAR_3->max_mididev == 0) {\n\t\t/* COMMENT_1 */\n\t\tVAR_2 = -VAR_9;\n\t\tgoto _error;\n\t}\n\n\t/* COMMENT_2 */\n\tdebug_printk((\"create new port\\n\"));\n\tVAR_2 = create_port(VAR_3);\n\tif (VAR_2 < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* COMMENT_3 */\n\tdebug_printk((\"allocate queue\\n\"));\n\tVAR_2 = alloc_seq_queue(VAR_3);\n\tif (VAR_2 < 0)\n\t\tgoto _error;\n\n\t/* COMMENT_4 */\n\tVAR_3->addr.client = VAR_3->cseq;\n\tVAR_3->addr.port = VAR_3->port;\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\n\tVAR_3->seq_mode = VAR_0;\n\n\t/* COMMENT_7 */\n\tVAR_3->file_mode = translate_mode(file);\n\n\t/* COMMENT_8 */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(VAR_3->file_mode)) {\n\t\tVAR_3->readq = snd_seq_oss_readq_new(VAR_3, VAR_10);\n\t\tif (!VAR_3->readq) {\n\t\t\tVAR_2 = -VAR_5;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* COMMENT_9 */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(VAR_3->file_mode)) {\n\t\tVAR_3->writeq = snd_seq_oss_writeq_new(VAR_3, VAR_10);\n\t\tif (!VAR_3->writeq) {\n\t\t\tVAR_2 = -VAR_5;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* COMMENT_10 */\n\tdebug_printk((\"initialize timer\\n\"));\n\tVAR_3->timer = snd_seq_oss_timer_new(VAR_3);\n\tif (!VAR_3->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\tVAR_2 = -VAR_5;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* COMMENT_11 */\n\tfile->private_data = VAR_3;\n\n\t/* COMMENT_12 */\n\tif (VAR_0 == VAR_11)\n\t\tsnd_seq_oss_synth_setup_midi(VAR_3);\n\telse if (is_read_mode(VAR_3->file_mode))\n\t\tsnd_seq_oss_midi_open_all(VAR_3, VAR_12);\n\n\tVAR_8[VAR_3->index] = VAR_3;\n\tVAR_13++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_synth_cleanup(VAR_3);\n\tsnd_seq_oss_midi_cleanup(VAR_3);\n\tdelete_seq_queue(VAR_3->queue);\n\tdelete_port(VAR_3);\n\n\treturn VAR_2;\n}",
    "func_graph_path": "torvalds/linux/27f7ad53829f79e799a253285318bff79ece15bd/seq_oss_init.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -108,13 +108,10 @@\n \treturn 0;\n \n  _error:\n-\tsnd_seq_oss_writeq_delete(dp->writeq);\n-\tsnd_seq_oss_readq_delete(dp->readq);\n \tsnd_seq_oss_synth_cleanup(dp);\n \tsnd_seq_oss_midi_cleanup(dp);\n+\tdelete_seq_queue(dp->queue);\n \tdelete_port(dp);\n-\tdelete_seq_queue(dp->queue);\n-\tkfree(dp);\n \n \treturn rc;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\tsnd_seq_oss_writeq_delete(dp->writeq);",
            "\tsnd_seq_oss_readq_delete(dp->readq);",
            "\tdelete_seq_queue(dp->queue);",
            "\tkfree(dp);"
        ],
        "added_lines": [
            "\tdelete_seq_queue(dp->queue);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}