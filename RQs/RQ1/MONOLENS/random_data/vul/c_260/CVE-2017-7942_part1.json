{
    "cve_id": "CVE-2017-7942",
    "cwe_ids": [
        "CWE-772"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "ImageMagick",
    "commit_msg": "Fixed memory leak reported in #429.",
    "commit_hash": "962282327f3a28ffb1138f3ad3fb0438b57ae6b1",
    "git_url": "https://github.com/ImageMagick/ImageMagick/commit/962282327f3a28ffb1138f3ad3fb0438b57ae6b1",
    "file_path": "coders/avs.c",
    "func_name": "ReadAVSImage",
    "func_before": "static Image *ReadAVSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    height,\n    length,\n    width;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read AVS X image.\n  */\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((width == 0UL) || (height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Convert AVS raster image to pixel packets.\n    */\n    image->columns=width;\n    image->rows=height;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    pixel_info=AcquireVirtualMemory(image->columns,4*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    length=(size_t) 4*image->columns;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=ReadBlob(image,length,pixels);\n      if ((size_t) count != length)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n        SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n        SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n        SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n        if (GetPixelAlpha(image,q) != OpaqueAlpha)\n          image->alpha_trait=BlendPixelTrait;\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    width=ReadBlobMSBLong(image);\n    height=ReadBlobMSBLong(image);\n    if ((width != 0UL) && (height != 0UL))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((width != 0UL) && (height != 0UL));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "abstract_func_before": "static Image *ReadAVSImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)\n{\n  Image\n    *VAR_2;\n\n  MagickBooleanType\n    VAR_3;\n\n  MemoryInfo\n    *VAR_4;\n\n  register Quantum\n    *VAR_5;\n\n  register ssize_t\n    VAR_6;\n\n  register unsigned char\n    *VAR_7;\n\n  size_t\n    VAR_8,\n    VAR_9,\n    VAR_10;\n\n  ssize_t\n    VAR_11,\n    VAR_12;\n\n  unsigned char\n    *VAR_13;\n\n  /* COMMENT_0 */\n                    \n    \n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_14);\n  if (VAR_0->debug != VAR_15)\n    (void) LogMagickEvent(VAR_16,GetMagickModule(),\"%s\",\n      VAR_0->filename);\n  assert(VAR_1 != (ExceptionInfo *) NULL);\n  assert(VAR_1->signature == VAR_14);\n  VAR_2=AcquireImage(VAR_0,VAR_1);\n  VAR_3=OpenBlob(VAR_0,VAR_2,VAR_17,VAR_1);\n  if (VAR_3 == VAR_15)\n    {\n      VAR_2=DestroyImageList(VAR_2);\n      return((Image *) NULL);\n    }\n  /* COMMENT_3 */\n                     \n    \n  VAR_10=ReadBlobMSBLong(VAR_2);\n  VAR_8=ReadBlobMSBLong(VAR_2);\n  if (EOFBlob(VAR_2) != VAR_15)\n    ThrowReaderException(VAR_18,\"ImproperImageHeader\");\n  if ((VAR_10 == 0UL) || (VAR_8 == 0UL))\n    ThrowReaderException(VAR_18,\"ImproperImageHeader\");\n  do\n  {\n    /* COMMENT_6 */\n                                                \n      \n    VAR_2->columns=VAR_10;\n    VAR_2->rows=VAR_8;\n    VAR_2->depth=8;\n    if ((VAR_0->ping != VAR_15) && (VAR_0->number_scenes != 0))\n      if (VAR_2->scene >= (VAR_0->scene+VAR_0->number_scenes-1))\n        break;\n    VAR_3=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows,VAR_1);\n    if (VAR_3 == VAR_15)\n      return(DestroyImageList(VAR_2));\n    VAR_4=AcquireVirtualMemory(VAR_2->columns,4*sizeof(*VAR_13));\n    if (VAR_4 == (MemoryInfo *) NULL)\n      ThrowReaderException(VAR_19,\"MemoryAllocationFailed\");\n    VAR_13=(unsigned char *) GetVirtualMemoryBlob(VAR_4);\n    VAR_9=(size_t) 4*VAR_2->columns;\n    for (VAR_12=0; VAR_12 < (ssize_t) VAR_2->rows; VAR_12++)\n    {\n      VAR_11=ReadBlob(VAR_2,VAR_9,VAR_13);\n      if ((size_t) VAR_11 != VAR_9)\n        ThrowReaderException(VAR_18,\"UnableToReadImageData\");\n      VAR_7=VAR_13;\n      VAR_5=QueueAuthenticPixels(VAR_2,0,VAR_12,VAR_2->columns,1,VAR_1);\n      if (VAR_5 == (Quantum *) NULL)\n        break;\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2->columns; VAR_6++)\n      {\n        SetPixelAlpha(VAR_2,ScaleCharToQuantum(*VAR_7++),VAR_5);\n        SetPixelRed(VAR_2,ScaleCharToQuantum(*VAR_7++),VAR_5);\n        SetPixelGreen(VAR_2,ScaleCharToQuantum(*VAR_7++),VAR_5);\n        SetPixelBlue(VAR_2,ScaleCharToQuantum(*VAR_7++),VAR_5);\n        if (GetPixelAlpha(VAR_2,VAR_5) != VAR_20)\n          VAR_2->alpha_trait=VAR_21;\n        VAR_5+=GetPixelChannels(VAR_2);\n      }\n      if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_15)\n        break;\n      if (VAR_2->previous == (Image *) NULL)\n        {\n          VAR_3=SetImageProgress(VAR_2,VAR_22,(MagickOffsetType) VAR_12,\n            VAR_2->rows);\n          if (VAR_3 == VAR_15)\n            break;\n        }\n    }\n    VAR_4=RelinquishVirtualMemory(VAR_4);\n    if (EOFBlob(VAR_2) != VAR_15)\n      {\n        ThrowFileException(VAR_1,VAR_18,\"UnexpectedEndOfFile\",\n          VAR_2->filename);\n        break;\n      }\n    /* COMMENT_9 */\n                            \n      \n    if (VAR_0->number_scenes != 0)\n      if (VAR_2->scene >= (VAR_0->scene+VAR_0->number_scenes-1))\n        break;\n    VAR_10=ReadBlobMSBLong(VAR_2);\n    VAR_8=ReadBlobMSBLong(VAR_2);\n    if ((VAR_10 != 0UL) && (VAR_8 != 0UL))\n      {\n        /* COMMENT_12 */\n                                        \n          \n        AcquireNextImage(VAR_0,VAR_2,VAR_1);\n        if (GetNextImageInList(VAR_2) == (Image *) NULL)\n          {\n            VAR_2=DestroyImageList(VAR_2);\n            return((Image *) NULL);\n          }\n        VAR_2=SyncNextImageInList(VAR_2);\n        VAR_3=SetImageProgress(VAR_2,VAR_23,TellBlob(VAR_2),\n          GetBlobSize(VAR_2));\n        if (VAR_3 == VAR_15)\n          break;\n      }\n  } while ((VAR_10 != 0UL) && (VAR_8 != 0UL));\n  (void) CloseBlob(VAR_2);\n  return(GetFirstImageInList(VAR_2));\n}",
    "func_graph_path_before": "ImageMagick/962282327f3a28ffb1138f3ad3fb0438b57ae6b1/avs.c/vul/before/0.json",
    "func": "static Image *ReadAVSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    height,\n    length,\n    width;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read AVS X image.\n  */\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((width == 0UL) || (height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Convert AVS raster image to pixel packets.\n    */\n    image->columns=width;\n    image->rows=height;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    pixel_info=AcquireVirtualMemory(image->columns,4*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    length=(size_t) 4*image->columns;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=ReadBlob(image,length,pixels);\n      if ((size_t) count != length)\n        {\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        }\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n        SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n        SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n        SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n        if (GetPixelAlpha(image,q) != OpaqueAlpha)\n          image->alpha_trait=BlendPixelTrait;\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    width=ReadBlobMSBLong(image);\n    height=ReadBlobMSBLong(image);\n    if ((width != 0UL) && (height != 0UL))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((width != 0UL) && (height != 0UL));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
    "abstract_func": "static Image *ReadAVSImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)\n{\n  Image\n    *VAR_2;\n\n  MagickBooleanType\n    VAR_3;\n\n  MemoryInfo\n    *VAR_4;\n\n  register Quantum\n    *VAR_5;\n\n  register ssize_t\n    VAR_6;\n\n  register unsigned char\n    *VAR_7;\n\n  size_t\n    VAR_8,\n    VAR_9,\n    VAR_10;\n\n  ssize_t\n    VAR_11,\n    VAR_12;\n\n  unsigned char\n    *VAR_13;\n\n  /* COMMENT_0 */\n                    \n    \n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_14);\n  if (VAR_0->debug != VAR_15)\n    (void) LogMagickEvent(VAR_16,GetMagickModule(),\"%s\",\n      VAR_0->filename);\n  assert(VAR_1 != (ExceptionInfo *) NULL);\n  assert(VAR_1->signature == VAR_14);\n  VAR_2=AcquireImage(VAR_0,VAR_1);\n  VAR_3=OpenBlob(VAR_0,VAR_2,VAR_17,VAR_1);\n  if (VAR_3 == VAR_15)\n    {\n      VAR_2=DestroyImageList(VAR_2);\n      return((Image *) NULL);\n    }\n  /* COMMENT_3 */\n                     \n    \n  VAR_10=ReadBlobMSBLong(VAR_2);\n  VAR_8=ReadBlobMSBLong(VAR_2);\n  if (EOFBlob(VAR_2) != VAR_15)\n    ThrowReaderException(VAR_18,\"ImproperImageHeader\");\n  if ((VAR_10 == 0UL) || (VAR_8 == 0UL))\n    ThrowReaderException(VAR_18,\"ImproperImageHeader\");\n  do\n  {\n    /* COMMENT_6 */\n                                                \n      \n    VAR_2->columns=VAR_10;\n    VAR_2->rows=VAR_8;\n    VAR_2->depth=8;\n    if ((VAR_0->ping != VAR_15) && (VAR_0->number_scenes != 0))\n      if (VAR_2->scene >= (VAR_0->scene+VAR_0->number_scenes-1))\n        break;\n    VAR_3=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows,VAR_1);\n    if (VAR_3 == VAR_15)\n      return(DestroyImageList(VAR_2));\n    VAR_4=AcquireVirtualMemory(VAR_2->columns,4*sizeof(*VAR_13));\n    if (VAR_4 == (MemoryInfo *) NULL)\n      ThrowReaderException(VAR_19,\"MemoryAllocationFailed\");\n    VAR_13=(unsigned char *) GetVirtualMemoryBlob(VAR_4);\n    VAR_9=(size_t) 4*VAR_2->columns;\n    for (VAR_12=0; VAR_12 < (ssize_t) VAR_2->rows; VAR_12++)\n    {\n      VAR_11=ReadBlob(VAR_2,VAR_9,VAR_13);\n      if ((size_t) VAR_11 != VAR_9)\n        {\n          VAR_4=RelinquishVirtualMemory(VAR_4);\n          ThrowReaderException(VAR_18,\"UnableToReadImageData\");\n        }\n      VAR_7=VAR_13;\n      VAR_5=QueueAuthenticPixels(VAR_2,0,VAR_12,VAR_2->columns,1,VAR_1);\n      if (VAR_5 == (Quantum *) NULL)\n        break;\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2->columns; VAR_6++)\n      {\n        SetPixelAlpha(VAR_2,ScaleCharToQuantum(*VAR_7++),VAR_5);\n        SetPixelRed(VAR_2,ScaleCharToQuantum(*VAR_7++),VAR_5);\n        SetPixelGreen(VAR_2,ScaleCharToQuantum(*VAR_7++),VAR_5);\n        SetPixelBlue(VAR_2,ScaleCharToQuantum(*VAR_7++),VAR_5);\n        if (GetPixelAlpha(VAR_2,VAR_5) != VAR_20)\n          VAR_2->alpha_trait=VAR_21;\n        VAR_5+=GetPixelChannels(VAR_2);\n      }\n      if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_15)\n        break;\n      if (VAR_2->previous == (Image *) NULL)\n        {\n          VAR_3=SetImageProgress(VAR_2,VAR_22,(MagickOffsetType) VAR_12,\n            VAR_2->rows);\n          if (VAR_3 == VAR_15)\n            break;\n        }\n    }\n    VAR_4=RelinquishVirtualMemory(VAR_4);\n    if (EOFBlob(VAR_2) != VAR_15)\n      {\n        ThrowFileException(VAR_1,VAR_18,\"UnexpectedEndOfFile\",\n          VAR_2->filename);\n        break;\n      }\n    /* COMMENT_9 */\n                            \n      \n    if (VAR_0->number_scenes != 0)\n      if (VAR_2->scene >= (VAR_0->scene+VAR_0->number_scenes-1))\n        break;\n    VAR_10=ReadBlobMSBLong(VAR_2);\n    VAR_8=ReadBlobMSBLong(VAR_2);\n    if ((VAR_10 != 0UL) && (VAR_8 != 0UL))\n      {\n        /* COMMENT_12 */\n                                        \n          \n        AcquireNextImage(VAR_0,VAR_2,VAR_1);\n        if (GetNextImageInList(VAR_2) == (Image *) NULL)\n          {\n            VAR_2=DestroyImageList(VAR_2);\n            return((Image *) NULL);\n          }\n        VAR_2=SyncNextImageInList(VAR_2);\n        VAR_3=SetImageProgress(VAR_2,VAR_23,TellBlob(VAR_2),\n          GetBlobSize(VAR_2));\n        if (VAR_3 == VAR_15)\n          break;\n      }\n  } while ((VAR_10 != 0UL) && (VAR_8 != 0UL));\n  (void) CloseBlob(VAR_2);\n  return(GetFirstImageInList(VAR_2));\n}",
    "func_graph_path": "ImageMagick/962282327f3a28ffb1138f3ad3fb0438b57ae6b1/avs.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -79,7 +79,10 @@\n     {\n       count=ReadBlob(image,length,pixels);\n       if ((size_t) count != length)\n-        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+        {\n+          pixel_info=RelinquishVirtualMemory(pixel_info);\n+          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+        }\n       p=pixels;\n       q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n       if (q == (Quantum *) NULL)",
    "diff_line_info": {
        "deleted_lines": [
            "        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");"
        ],
        "added_lines": [
            "        {",
            "          pixel_info=RelinquishVirtualMemory(pixel_info);",
            "          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");",
            "        }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}