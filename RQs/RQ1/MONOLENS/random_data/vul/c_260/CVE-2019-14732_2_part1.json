{
    "cve_id": "CVE-2019-14732",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "adplug",
    "commit_msg": "Fix invalid memory accesses while loading .a2m files\n\nMissing checks and wrong calculations in src/a2m.cpp cause\nmultiple heap-based buffer overflows and out-of-bounds reads\nin heap, stack, and static data.\n\nBugs addressed in this commit:\n* Check the number of patterns. Too big values can cause reads\n  past the end of the len array.\n* Reading a not packed data block with odd length will allocate\n  a buffer which is one byte too small and write past the end\n  of it (issue #88). Change the allocation/deallocation code\n  to fix that in both places.\n* Check that data blocks (afer unpacking if applicable) are big\n  enough for the expected data before accessing the memory.\n* Ensure that the length byte for author, song name, and instrument\n  names doesn't exceed the maximum size available.\n* Also change the accessor functions for these strings to call\n  the proper std::string constructors for char arrays.\n* Avoid reads past the end of convfx/newconvfx arrays while\n  converting track data.\n\nThis commit fixes CVE-2019-14732.\n\nFixes: https://github.com/adplug/adplug/issues/88",
    "commit_hash": "30ddcfe9bd1cce3e02f8135961bceb411419dbdb",
    "git_url": "https://github.com/adplug/adplug/commit/30ddcfe9bd1cce3e02f8135961bceb411419dbdb",
    "file_path": "src/a2m.cpp",
    "func_name": "Ca2mLoader::load",
    "func_before": "bool Ca2mLoader::load(const std::string &filename, const CFileProvider &fp)\n{\n  binistream *f = fp.open(filename); if(!f) return false;\n  char id[10];\n  int i,j,k,t;\n  unsigned int l;\n  unsigned char *org = NULL, *orgptr, flags = 0, numpats, version;\n  unsigned long crc, alength;\n  unsigned short len[9], *secdata, *secptr;\n  const unsigned char convfx[16] = {0,1,2,23,24,3,5,4,6,9,17,13,11,19,7,14};\n  const unsigned char convinf1[16] = {0,1,2,6,7,8,9,4,5,3,10,11,12,13,14,15};\n  const unsigned char newconvfx[] = {0,1,2,3,4,5,6,23,24,21,10,11,17,13,7,19,\n\t\t\t\t     255,255,22,25,255,15,255,255,255,255,255,\n\t\t\t\t     255,255,255,255,255,255,255,255,14,255};\n\n  // read header\n  f->readString(id, 10); crc = f->readInt(4);\n  version = f->readInt(1); numpats = f->readInt(1);\n\n  // file validation section\n  if(strncmp(id,\"_A2module_\",10) || (version != 1 && version != 5 &&\n\t\t\t\t     version != 4 && version != 8)) {\n    fp.close(f);\n    return false;\n  }\n\n  // load, depack & convert section\n  nop = numpats; length = 128; restartpos = 0;\n  if(version < 5) {\n    for(i=0;i<5;i++) len[i] = f->readInt(2);\n    t = 9;\n  } else {\t// version >= 5\n    for(i=0;i<9;i++) len[i] = f->readInt(2);\n    t = 18;\n  }\n\n  // block 0\n  secdata = new unsigned short [len[0] / 2];\n  if(version == 1 || version == 5) {\n    for(i=0;i<len[0]/2;i++) secdata[i] = f->readInt(2);\n    org = new unsigned char [MAXBUF]; orgptr = org;\n    sixdepak(secdata,org,len[0]);\n  } else {\n    orgptr = (unsigned char *)secdata;\n    for(i=0;i<len[0];i++) orgptr[i] = f->readInt(1);\n  }\n  memcpy(songname,orgptr,43); orgptr += 43;\n  memcpy(author,orgptr,43); orgptr += 43;\n  memcpy(instname,orgptr,250*33); orgptr += 250*33;\n\n  for(i=0;i<250;i++) {\t// instruments\n    inst[i].data[0] = *(orgptr+i*13+10);\n    inst[i].data[1] = *(orgptr+i*13);\n    inst[i].data[2] = *(orgptr+i*13+1);\n    inst[i].data[3] = *(orgptr+i*13+4);\n    inst[i].data[4] = *(orgptr+i*13+5);\n    inst[i].data[5] = *(orgptr+i*13+6);\n    inst[i].data[6] = *(orgptr+i*13+7);\n    inst[i].data[7] = *(orgptr+i*13+8);\n    inst[i].data[8] = *(orgptr+i*13+9);\n    inst[i].data[9] = *(orgptr+i*13+2);\n    inst[i].data[10] = *(orgptr+i*13+3);\n\n    if(version < 5)\n      inst[i].misc = *(orgptr+i*13+11);\n    else {\t// version >= 5 -> OPL3 format\n      int pan = *(orgptr+i*13+11);\n\n      if(pan)\n\tinst[i].data[0] |= (pan & 3) << 4;\t// set pan\n      else\n\tinst[i].data[0] |= 48;\t\t\t// enable both speakers\n    }\n\n    inst[i].slide = *(orgptr+i*13+12);\n  }\n\n  orgptr += 250*13;\n  memcpy(order,orgptr,128); orgptr += 128;\n  bpm = *orgptr; orgptr++;\n  initspeed = *orgptr; orgptr++;\n  if(version >= 5) flags = *orgptr;\n  if(version == 1 || version == 5) delete [] org;\n  delete [] secdata;\n\n  // blocks 1-4 or 1-8\n  alength = len[1];\n  for(i = 0; i < (version < 5 ? numpats / 16 : numpats / 8); i++)\n    alength += len[i+2];\n\n  secdata = new unsigned short [alength / 2];\n  if(version == 1 || version == 5) {\n    for(l=0;l<alength/2;l++) secdata[l] = f->readInt(2);\n    org = new unsigned char [MAXBUF * (numpats / (version == 1 ? 16 : 8) + 1)];\n    orgptr = org; secptr = secdata;\n    orgptr += sixdepak(secptr,orgptr,len[1]); secptr += len[1] / 2;\n    if(version == 1) {\n      if(numpats > 16)\n\torgptr += sixdepak(secptr,orgptr,len[2]); secptr += len[2] / 2;\n      if(numpats > 32)\n\torgptr += sixdepak(secptr,orgptr,len[3]); secptr += len[3] / 2;\n      if(numpats > 48)\n\tsixdepak(secptr,orgptr,len[4]);\n    } else {\n      if(numpats > 8)\n\torgptr += sixdepak(secptr,orgptr,len[2]); secptr += len[2] / 2;\n      if(numpats > 16)\n\torgptr += sixdepak(secptr,orgptr,len[3]); secptr += len[3] / 2;\n      if(numpats > 24)\n\torgptr += sixdepak(secptr,orgptr,len[4]); secptr += len[4] / 2;\n      if(numpats > 32)\n\torgptr += sixdepak(secptr,orgptr,len[5]); secptr += len[5] / 2;\n      if(numpats > 40)\n\torgptr += sixdepak(secptr,orgptr,len[6]); secptr += len[6] / 2;\n      if(numpats > 48)\n\torgptr += sixdepak(secptr,orgptr,len[7]); secptr += len[7] / 2;\n      if(numpats > 56)\n\tsixdepak(secptr,orgptr,len[8]);\n    }\n    delete [] secdata;\n  } else {\n    org = (unsigned char *)secdata;\n    for(l=0;l<alength;l++) org[l] = f->readInt(1);\n  }\n\n  if(version < 5) {\n    for(i=0;i<numpats;i++)\n      for(j=0;j<64;j++)\n\tfor(k=0;k<9;k++) {\n\t  struct Tracks\t*track = &tracks[i * 9 + k][j];\n\t  unsigned char\t*o = &org[i*64*t*4+j*t*4+k*4];\n\n\t  track->note = o[0] == 255 ? 127 : o[0];\n\t  track->inst = o[1];\n\t  track->command = convfx[o[2]];\n\t  track->param2 = o[3] & 0x0f;\n\t  if(track->command != 14)\n\t    track->param1 = o[3] >> 4;\n\t  else {\n\t    track->param1 = convinf1[o[3] >> 4];\n\t    if(track->param1 == 15 && !track->param2) {\t// convert key-off\n\t      track->command = 8;\n\t      track->param1 = 0;\n\t      track->param2 = 0;\n\t    }\n\t  }\n\t  if(track->command == 14) {\n\t    switch(track->param1) {\n\t    case 2: // convert define waveform\n\t      track->command = 25;\n\t      track->param1 = track->param2;\n\t      track->param2 = 0xf;\n\t      break;\n\t    case 8: // convert volume slide up\n\t      track->command = 26;\n\t      track->param1 = track->param2;\n\t      track->param2 = 0;\n\t      break;\n\t    case 9: // convert volume slide down\n\t      track->command = 26;\n\t      track->param1 = 0;\n\t      break;\n\t    }\n\t  }\n\t}\n  } else {\t// version >= 5\n    realloc_patterns(64, 64, 18);\n\n    for(i=0;i<numpats;i++)\n      for(j=0;j<18;j++)\n\tfor(k=0;k<64;k++) {\n\t  struct Tracks\t*track = &tracks[i * 18 + j][k];\n\t  unsigned char\t*o = &org[i*64*t*4+j*64*4+k*4];\n\n\t  track->note = o[0] == 255 ? 127 : o[0];\n\t  track->inst = o[1];\n\t  track->command = newconvfx[o[2]];\n\t  track->param1 = o[3] >> 4;\n\t  track->param2 = o[3] & 0x0f;\n\n\t  // Convert '&' command\n\t  if(o[2] == 36)\n\t    switch(track->param1) {\n\t    case 0:\t// pattern delay (frames)\n\t      track->command = 29;\n\t      track->param1 = 0;\n\t      // param2 already set correctly\n\t      break;\n\n\t    case 1:\t// pattern delay (rows)\n\t      track->command = 14;\n\t      track->param1 = 8;\n\t      // param2 already set correctly\n\t      break;\n\t    }\n\t}\n  }\n\n  init_trackord();\n\n  if(version == 1 || version == 5)\n    delete [] org;\n  else\n    delete [] secdata;\n\n  // Process flags\n  if(version >= 5) {\n    CmodPlayer::flags |= Opl3;\t\t\t\t// All versions >= 5 are OPL3\n    if(flags & 8) CmodPlayer::flags |= Tremolo;\t\t// Tremolo depth\n    if(flags & 16) CmodPlayer::flags |= Vibrato;\t// Vibrato depth\n  }\n\n  fp.close(f);\n  rewind(0);\n  return true;\n}",
    "abstract_func_before": "bool Ca2mLoader::load(const std::string &VAR_0, const CFileProvider &VAR_1)\n{\n  binistream *VAR_2 = VAR_1.open(VAR_0); if(!VAR_2) return false;\n  char VAR_3[10];\n  int VAR_4,VAR_5,VAR_6,VAR_7;\n  unsigned int VAR_8;\n  unsigned char *VAR_9 = NULL, *VAR_10, VAR_11 = 0, VAR_12, VAR_13;\n  unsigned long VAR_14, VAR_15;\n  unsigned short VAR_16[9], *VAR_17, *VAR_18;\n  const unsigned char VAR_19[16] = {0,1,2,23,24,3,5,4,6,9,17,13,11,19,7,14};\n  const unsigned char VAR_20[16] = {0,1,2,6,7,8,9,4,5,3,10,11,12,13,14,15};\n  const unsigned char VAR_21[] = {0,1,2,3,4,5,6,23,24,21,10,11,17,13,7,19,\n\t\t\t\t     255,255,22,25,255,15,255,255,255,255,255,\n\t\t\t\t     255,255,255,255,255,255,255,255,14,255};\n\n  /* COMMENT_0 */\n  VAR_2->readString(VAR_3, 10); VAR_14 = VAR_2->readInt(4);\n  VAR_13 = VAR_2->readInt(1); VAR_12 = VAR_2->readInt(1);\n\n  /* COMMENT_1 */\n  if(strncmp(VAR_3,\"_A2module_\",10) || (VAR_13 != 1 && VAR_13 != 5 &&\n\t\t\t\t     VAR_13 != 4 && VAR_13 != 8)) {\n    VAR_1.close(VAR_2);\n    return false;\n  }\n\n  /* COMMENT_2 */\n  VAR_22 = VAR_12; VAR_23 = 128; VAR_24 = 0;\n  if(VAR_13 < 5) {\n    for(VAR_4=0;VAR_4<5;VAR_4++) VAR_16[VAR_4] = VAR_2->readInt(2);\n    VAR_7 = 9;\n  } else {\t/* COMMENT_3 */\n    for(VAR_4=0;VAR_4<9;VAR_4++) VAR_16[VAR_4] = VAR_2->readInt(2);\n    VAR_7 = 18;\n  }\n\n  /* COMMENT_4 */\n  VAR_17 = new unsigned short [VAR_16[0] / 2];\n  if(VAR_13 == 1 || VAR_13 == 5) {\n    for(VAR_4=0;VAR_4<VAR_16[0]/2;VAR_4++) VAR_17[VAR_4] = VAR_2->readInt(2);\n    VAR_9 = new unsigned char [VAR_25]; VAR_10 = VAR_9;\n    sixdepak(VAR_17,VAR_9,VAR_16[0]);\n  } else {\n    VAR_10 = (unsigned char *)VAR_17;\n    for(VAR_4=0;VAR_4<VAR_16[0];VAR_4++) VAR_10[VAR_4] = VAR_2->readInt(1);\n  }\n  memcpy(VAR_26,VAR_10,43); VAR_10 += 43;\n  memcpy(VAR_27,VAR_10,43); VAR_10 += 43;\n  memcpy(VAR_28,VAR_10,250*33); VAR_10 += 250*33;\n\n  for(VAR_4=0;VAR_4<250;VAR_4++) {\t/* COMMENT_5 */\n    VAR_29[VAR_4].data[0] = *(VAR_10+VAR_4*13+10);\n    VAR_29[VAR_4].data[1] = *(VAR_10+VAR_4*13);\n    VAR_29[VAR_4].data[2] = *(VAR_10+VAR_4*13+1);\n    VAR_29[VAR_4].data[3] = *(VAR_10+VAR_4*13+4);\n    VAR_29[VAR_4].data[4] = *(VAR_10+VAR_4*13+5);\n    VAR_29[VAR_4].data[5] = *(VAR_10+VAR_4*13+6);\n    VAR_29[VAR_4].data[6] = *(VAR_10+VAR_4*13+7);\n    VAR_29[VAR_4].data[7] = *(VAR_10+VAR_4*13+8);\n    VAR_29[VAR_4].data[8] = *(VAR_10+VAR_4*13+9);\n    VAR_29[VAR_4].data[9] = *(VAR_10+VAR_4*13+2);\n    VAR_29[VAR_4].data[10] = *(VAR_10+VAR_4*13+3);\n\n    if(VAR_13 < 5)\n      VAR_29[VAR_4].misc = *(VAR_10+VAR_4*13+11);\n    else {\t/* COMMENT_6 */\n      int VAR_30 = *(VAR_10+VAR_4*13+11);\n\n      if(VAR_30)\n\tVAR_29[VAR_4].data[0] |= (VAR_30 & 3) << 4;\t/* COMMENT_7 */\n      else\n\tVAR_29[VAR_4].data[0] |= 48;\t\t\t/* COMMENT_8 */\n    }\n\n    VAR_29[VAR_4].slide = *(VAR_10+VAR_4*13+12);\n  }\n\n  VAR_10 += 250*13;\n  memcpy(VAR_31,VAR_10,128); VAR_10 += 128;\n  VAR_32 = *VAR_10; VAR_10++;\n  VAR_33 = *VAR_10; VAR_10++;\n  if(VAR_13 >= 5) VAR_11 = *VAR_10;\n  if(VAR_13 == 1 || VAR_13 == 5) delete [] VAR_9;\n  delete [] VAR_17;\n\n  /* COMMENT_9 */\n  VAR_15 = VAR_16[1];\n  for(VAR_4 = 0; VAR_4 < (VAR_13 < 5 ? VAR_12 / 16 : VAR_12 / 8); VAR_4++)\n    VAR_15 += VAR_16[VAR_4+2];\n\n  VAR_17 = new unsigned short [VAR_15 / 2];\n  if(VAR_13 == 1 || VAR_13 == 5) {\n    for(VAR_8=0;VAR_8<VAR_15/2;VAR_8++) VAR_17[VAR_8] = VAR_2->readInt(2);\n    VAR_9 = new unsigned char [VAR_25 * (VAR_12 / (VAR_13 == 1 ? 16 : 8) + 1)];\n    VAR_10 = VAR_9; VAR_18 = VAR_17;\n    VAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[1]); VAR_18 += VAR_16[1] / 2;\n    if(VAR_13 == 1) {\n      if(VAR_12 > 16)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[2]); VAR_18 += VAR_16[2] / 2;\n      if(VAR_12 > 32)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[3]); VAR_18 += VAR_16[3] / 2;\n      if(VAR_12 > 48)\n\tsixdepak(VAR_18,VAR_10,VAR_16[4]);\n    } else {\n      if(VAR_12 > 8)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[2]); VAR_18 += VAR_16[2] / 2;\n      if(VAR_12 > 16)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[3]); VAR_18 += VAR_16[3] / 2;\n      if(VAR_12 > 24)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[4]); VAR_18 += VAR_16[4] / 2;\n      if(VAR_12 > 32)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[5]); VAR_18 += VAR_16[5] / 2;\n      if(VAR_12 > 40)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[6]); VAR_18 += VAR_16[6] / 2;\n      if(VAR_12 > 48)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[7]); VAR_18 += VAR_16[7] / 2;\n      if(VAR_12 > 56)\n\tsixdepak(VAR_18,VAR_10,VAR_16[8]);\n    }\n    delete [] VAR_17;\n  } else {\n    VAR_9 = (unsigned char *)VAR_17;\n    for(VAR_8=0;VAR_8<VAR_15;VAR_8++) VAR_9[VAR_8] = VAR_2->readInt(1);\n  }\n\n  if(VAR_13 < 5) {\n    for(VAR_4=0;VAR_4<VAR_12;VAR_4++)\n      for(VAR_5=0;VAR_5<64;VAR_5++)\n\tfor(VAR_6=0;VAR_6<9;VAR_6++) {\n\t  struct Tracks\t*VAR_34 = &VAR_35[VAR_4 * 9 + VAR_6][VAR_5];\n\t  unsigned char\t*VAR_36 = &VAR_9[VAR_4*64*VAR_7*4+VAR_5*VAR_7*4+VAR_6*4];\n\n\t  VAR_34->note = VAR_36[0] == 255 ? 127 : VAR_36[0];\n\t  VAR_34->inst = VAR_36[1];\n\t  VAR_34->command = VAR_19[VAR_36[2]];\n\t  VAR_34->param2 = VAR_36[3] & 0x0f;\n\t  if(VAR_34->command != 14)\n\t    VAR_34->param1 = VAR_36[3] >> 4;\n\t  else {\n\t    VAR_34->param1 = VAR_20[VAR_36[3] >> 4];\n\t    if(VAR_34->param1 == 15 && !VAR_34->param2) {\t/* COMMENT_10 */\n\t      VAR_34->command = 8;\n\t      VAR_34->param1 = 0;\n\t      VAR_34->param2 = 0;\n\t    }\n\t  }\n\t  if(VAR_34->command == 14) {\n\t    switch(VAR_34->param1) {\n\t    case 2: /* COMMENT_11 */\n\t      VAR_34->command = 25;\n\t      VAR_34->param1 = VAR_34->param2;\n\t      VAR_34->param2 = 0xf;\n\t      break;\n\t    case 8: /* COMMENT_12 */\n\t      VAR_34->command = 26;\n\t      VAR_34->param1 = VAR_34->param2;\n\t      VAR_34->param2 = 0;\n\t      break;\n\t    case 9: /* COMMENT_13 */\n\t      VAR_34->command = 26;\n\t      VAR_34->param1 = 0;\n\t      break;\n\t    }\n\t  }\n\t}\n  } else {\t/* COMMENT_3 */\n    realloc_patterns(64, 64, 18);\n\n    for(VAR_4=0;VAR_4<VAR_12;VAR_4++)\n      for(VAR_5=0;VAR_5<18;VAR_5++)\n\tfor(VAR_6=0;VAR_6<64;VAR_6++) {\n\t  struct Tracks\t*VAR_34 = &VAR_35[VAR_4 * 18 + VAR_5][VAR_6];\n\t  unsigned char\t*VAR_36 = &VAR_9[VAR_4*64*VAR_7*4+VAR_5*64*4+VAR_6*4];\n\n\t  VAR_34->note = VAR_36[0] == 255 ? 127 : VAR_36[0];\n\t  VAR_34->inst = VAR_36[1];\n\t  VAR_34->command = VAR_21[VAR_36[2]];\n\t  VAR_34->param1 = VAR_36[3] >> 4;\n\t  VAR_34->param2 = VAR_36[3] & 0x0f;\n\n\t  /* COMMENT_14 */\n\t  if(VAR_36[2] == 36)\n\t    switch(VAR_34->param1) {\n\t    case 0:\t/* COMMENT_15 */\n\t      VAR_34->command = 29;\n\t      VAR_34->param1 = 0;\n\t      /* COMMENT_16 */\n\t      break;\n\n\t    case 1:\t/* COMMENT_17 */\n\t      VAR_34->command = 14;\n\t      VAR_34->param1 = 8;\n\t      /* COMMENT_16 */\n\t      break;\n\t    }\n\t}\n  }\n\n  init_trackord();\n\n  if(VAR_13 == 1 || VAR_13 == 5)\n    delete [] VAR_9;\n  else\n    delete [] VAR_17;\n\n  /* COMMENT_18 */\n  if(VAR_13 >= 5) {\n    CmodPlayer::flags |= VAR_37;\t\t\t\t/* COMMENT_19 */\n    if(VAR_11 & 8) CmodPlayer::flags |= VAR_38;\t\t/* COMMENT_20 */\n    if(VAR_11 & 16) CmodPlayer::flags |= VAR_39;\t/* COMMENT_21 */\n  }\n\n  VAR_1.close(VAR_2);\n  rewind(0);\n  return true;\n}",
    "func_graph_path_before": "adplug/30ddcfe9bd1cce3e02f8135961bceb411419dbdb/a2m.cpp/vul/before/0.json",
    "func": "bool Ca2mLoader::load(const std::string &filename, const CFileProvider &fp)\n{\n  binistream *f = fp.open(filename); if(!f) return false;\n  char id[10];\n  int i,j,k,t;\n  unsigned int l;\n  unsigned char *org, *orgptr, flags = 0, numpats, version;\n  unsigned long crc, alength;\n  unsigned short len[9], *secdata, *secptr;\n  const unsigned char convfx[16] = {0,1,2,23,24,3,5,4,6,9,17,13,11,19,7,14};\n  const unsigned char convinf1[16] = {0,1,2,6,7,8,9,4,5,3,10,11,12,13,14,15};\n  const unsigned char newconvfx[] = {0,1,2,3,4,5,6,23,24,21,10,11,17,13,7,19,\n\t\t\t\t     255,255,22,25,255,15,255,255,255,255,255,\n\t\t\t\t     255,255,255,255,255,255,255,255,14,255};\n\n  // read header\n  f->readString(id, 10); crc = f->readInt(4);\n  version = f->readInt(1); numpats = f->readInt(1);\n\n  // file validation section\n  if (memcmp(id, \"_A2module_\", 10) ||\n      (version != 1 && version != 5 && version != 4 && version != 8) ||\n      numpats > 64) {\n    fp.close(f);\n    return false;\n  }\n\n  // load, depack & convert section\n  nop = numpats; length = 128; restartpos = 0;\n  if(version < 5) {\n    for(i=0;i<5;i++) len[i] = f->readInt(2);\n    t = 9;\n  } else {\t// version >= 5\n    for(i=0;i<9;i++) len[i] = f->readInt(2);\n    t = 18;\n  }\n\n  // block 0\n  if(version == 1 || version == 5) {\n    orgptr = org = new unsigned char [MAXBUF];\n    secdata = new unsigned short [len[0] / 2];\n    for(i=0;i<len[0]/2;i++) secdata[i] = f->readInt(2);\n    // What if len[0] is odd: ignore, skip extra byte, or fail?\n    l = sixdepak(secdata,org,len[0]);\n    delete [] secdata;\n  } else {\n    orgptr = org = new unsigned char [len[0]];\n    for(l = 0; l < len[0]; l++) orgptr[l] = f->readInt(1);\n  }\n  if (l < 2*43 + 250*(33+13) + 128 + 2 + (version >= 5)) {\n    // Block is too short; fail.\n    delete [] org;\n    fp.close(f);\n    return false;\n  }\n\n  memcpy(songname,orgptr,43); orgptr += 43;\n  memcpy(author,orgptr,43); orgptr += 43;\n  memcpy(instname,orgptr,250*33); orgptr += 250*33;\n  // If string length is invalid, just use the maximum. Should we fail instead?\n  if (songname[0] > 42 || songname[0] < 0) songname[0] = 42;\n  if (author[0] > 42 || author[0] < 0) author[0] = 42;\n\n  for(i=0;i<250;i++) {\t// instruments\n    if (instname[i][0] > 32 || instname[i][0] < 0) instname[i][0] = 32;\n    inst[i].data[0] = *(orgptr+i*13+10);\n    inst[i].data[1] = *(orgptr+i*13);\n    inst[i].data[2] = *(orgptr+i*13+1);\n    inst[i].data[3] = *(orgptr+i*13+4);\n    inst[i].data[4] = *(orgptr+i*13+5);\n    inst[i].data[5] = *(orgptr+i*13+6);\n    inst[i].data[6] = *(orgptr+i*13+7);\n    inst[i].data[7] = *(orgptr+i*13+8);\n    inst[i].data[8] = *(orgptr+i*13+9);\n    inst[i].data[9] = *(orgptr+i*13+2);\n    inst[i].data[10] = *(orgptr+i*13+3);\n\n    if(version < 5)\n      inst[i].misc = *(orgptr+i*13+11);\n    else {\t// version >= 5 -> OPL3 format\n      int pan = *(orgptr+i*13+11);\n\n      if(pan)\n\tinst[i].data[0] |= (pan & 3) << 4;\t// set pan\n      else\n\tinst[i].data[0] |= 48;\t\t\t// enable both speakers\n    }\n\n    inst[i].slide = *(orgptr+i*13+12);\n  }\n\n  orgptr += 250*13;\n  memcpy(order,orgptr,128); orgptr += 128;\n  bpm = *orgptr; orgptr++;\n  initspeed = *orgptr; orgptr++;\n  if(version >= 5) flags = *orgptr;\n  delete [] org;\n\n  // blocks 1-4 or 1-8\n  alength = len[1];\n  for (i = 0; i < numpats / (version < 5 ? 16 : 8); i++)\n    alength += len[i+2];\n\n  if(version == 1 || version == 5) {\n    org = new unsigned char [MAXBUF * (numpats / (version < 5 ? 16 : 8) + 1)];\n    secdata = new unsigned short [alength / 2];\n    for(l=0;l<alength/2;l++) secdata[l] = f->readInt(2);\n    orgptr = org; secptr = secdata;\n    // FIXME: The number of depacked blocks is inconsistent with the\n    // lengths summed and the size of org (if numpats is a multiple of 16/8).\n    // Also the \"secptr += ...\" statements below are not guarded by the \"if\"s!\n    orgptr += sixdepak(secptr,orgptr,len[1]); secptr += len[1] / 2;\n    if(version == 1) {\n      if(numpats > 16)\n\torgptr += sixdepak(secptr,orgptr,len[2]); secptr += len[2] / 2;\n      if(numpats > 32)\n\torgptr += sixdepak(secptr,orgptr,len[3]); secptr += len[3] / 2;\n      if(numpats > 48)\n\torgptr += sixdepak(secptr,orgptr,len[4]);\n    } else {\n      if(numpats > 8)\n\torgptr += sixdepak(secptr,orgptr,len[2]); secptr += len[2] / 2;\n      if(numpats > 16)\n\torgptr += sixdepak(secptr,orgptr,len[3]); secptr += len[3] / 2;\n      if(numpats > 24)\n\torgptr += sixdepak(secptr,orgptr,len[4]); secptr += len[4] / 2;\n      if(numpats > 32)\n\torgptr += sixdepak(secptr,orgptr,len[5]); secptr += len[5] / 2;\n      if(numpats > 40)\n\torgptr += sixdepak(secptr,orgptr,len[6]); secptr += len[6] / 2;\n      if(numpats > 48)\n\torgptr += sixdepak(secptr,orgptr,len[7]); secptr += len[7] / 2;\n      if(numpats > 56)\n\torgptr += sixdepak(secptr,orgptr,len[8]);\n    }\n    delete [] secdata;\n  } else {\n    org = new unsigned char [alength];\n    for(l=0;l<alength;l++) org[l] = f->readInt(1);\n    orgptr = org + alength;\n  }\n\n  if (orgptr - org < numpats * 64 * t * 4) {\n    delete [] org;\n    fp.close(f);\n    return false;\n  }\n\n  if(version < 5) {\n    for(i=0;i<numpats;i++)\n      for(j=0;j<64;j++)\n\tfor(k=0;k<9;k++) {\n\t  struct Tracks\t*track = &tracks[i * 9 + k][j];\n\t  unsigned char\t*o = &org[i*64*t*4+j*t*4+k*4];\n\n\t  track->note = o[0] == 255 ? 127 : o[0];\n\t  track->inst = o[1];\n\t  track->command = o[2] < sizeof(convfx) ? convfx[o[2]] : 255;\n\t  track->param2 = o[3] & 0x0f;\n\t  if(track->command != 14)\n\t    track->param1 = o[3] >> 4;\n\t  else {\n\t    track->param1 = convinf1[o[3] >> 4];\n\t    if(track->param1 == 15 && !track->param2) {\t// convert key-off\n\t      track->command = 8;\n\t      track->param1 = 0;\n\t      track->param2 = 0;\n\t    }\n\t  }\n\t  if(track->command == 14) {\n\t    switch(track->param1) {\n\t    case 2: // convert define waveform\n\t      track->command = 25;\n\t      track->param1 = track->param2;\n\t      track->param2 = 0xf;\n\t      break;\n\t    case 8: // convert volume slide up\n\t      track->command = 26;\n\t      track->param1 = track->param2;\n\t      track->param2 = 0;\n\t      break;\n\t    case 9: // convert volume slide down\n\t      track->command = 26;\n\t      track->param1 = 0;\n\t      break;\n\t    }\n\t  }\n\t}\n  } else {\t// version >= 5\n    realloc_patterns(64, 64, 18);\n\n    for(i=0;i<numpats;i++)\n      for(j=0;j<18;j++)\n\tfor(k=0;k<64;k++) {\n\t  struct Tracks\t*track = &tracks[i * 18 + j][k];\n\t  unsigned char\t*o = &org[i*64*t*4+j*64*4+k*4];\n\n\t  track->note = o[0] == 255 ? 127 : o[0];\n\t  track->inst = o[1];\n\t  track->command = o[2] < sizeof(newconvfx) ? newconvfx[o[2]] : 255;\n\t  track->param1 = o[3] >> 4;\n\t  track->param2 = o[3] & 0x0f;\n\n\t  // Convert '&' command\n\t  if(o[2] == 36)\n\t    switch(track->param1) {\n\t    case 0:\t// pattern delay (frames)\n\t      track->command = 29;\n\t      track->param1 = 0;\n\t      // param2 already set correctly\n\t      break;\n\n\t    case 1:\t// pattern delay (rows)\n\t      track->command = 14;\n\t      track->param1 = 8;\n\t      // param2 already set correctly\n\t      break;\n\t    }\n\t}\n  }\n\n  init_trackord();\n\n  delete [] org;\n\n  // Process flags\n  if(version >= 5) {\n    CmodPlayer::flags |= Opl3;\t\t\t\t// All versions >= 5 are OPL3\n    if(flags & 8) CmodPlayer::flags |= Tremolo;\t\t// Tremolo depth\n    if(flags & 16) CmodPlayer::flags |= Vibrato;\t// Vibrato depth\n  }\n\n  // Note: crc value is not checked.\n\n  fp.close(f);\n  rewind(0);\n  return true;\n}",
    "abstract_func": "bool Ca2mLoader::load(const std::string &VAR_0, const CFileProvider &VAR_1)\n{\n  binistream *VAR_2 = VAR_1.open(VAR_0); if(!VAR_2) return false;\n  char VAR_3[10];\n  int VAR_4,VAR_5,VAR_6,VAR_7;\n  unsigned int VAR_8;\n  unsigned char *VAR_9, *VAR_10, VAR_11 = 0, VAR_12, VAR_13;\n  unsigned long VAR_14, VAR_15;\n  unsigned short VAR_16[9], *VAR_17, *VAR_18;\n  const unsigned char VAR_19[16] = {0,1,2,23,24,3,5,4,6,9,17,13,11,19,7,14};\n  const unsigned char VAR_20[16] = {0,1,2,6,7,8,9,4,5,3,10,11,12,13,14,15};\n  const unsigned char VAR_21[] = {0,1,2,3,4,5,6,23,24,21,10,11,17,13,7,19,\n\t\t\t\t     255,255,22,25,255,15,255,255,255,255,255,\n\t\t\t\t     255,255,255,255,255,255,255,255,14,255};\n\n  /* COMMENT_0 */\n  VAR_2->readString(VAR_3, 10); VAR_14 = VAR_2->readInt(4);\n  VAR_13 = VAR_2->readInt(1); VAR_12 = VAR_2->readInt(1);\n\n  /* COMMENT_1 */\n  if (memcmp(VAR_3, \"_A2module_\", 10) ||\n      (VAR_13 != 1 && VAR_13 != 5 && VAR_13 != 4 && VAR_13 != 8) ||\n      VAR_12 > 64) {\n    VAR_1.close(VAR_2);\n    return false;\n  }\n\n  /* COMMENT_2 */\n  VAR_22 = VAR_12; VAR_23 = 128; VAR_24 = 0;\n  if(VAR_13 < 5) {\n    for(VAR_4=0;VAR_4<5;VAR_4++) VAR_16[VAR_4] = VAR_2->readInt(2);\n    VAR_7 = 9;\n  } else {\t/* COMMENT_3 */\n    for(VAR_4=0;VAR_4<9;VAR_4++) VAR_16[VAR_4] = VAR_2->readInt(2);\n    VAR_7 = 18;\n  }\n\n  /* COMMENT_4 */\n  if(VAR_13 == 1 || VAR_13 == 5) {\n    VAR_10 = VAR_9 = new unsigned char [VAR_25];\n    VAR_17 = new unsigned short [VAR_16[0] / 2];\n    for(VAR_4=0;VAR_4<VAR_16[0]/2;VAR_4++) VAR_17[VAR_4] = VAR_2->readInt(2);\n    /* COMMENT_5 */\n    VAR_8 = sixdepak(VAR_17,VAR_9,VAR_16[0]);\n    delete [] VAR_17;\n  } else {\n    VAR_10 = VAR_9 = new unsigned char [VAR_16[0]];\n    for(VAR_8 = 0; VAR_8 < VAR_16[0]; VAR_8++) VAR_10[VAR_8] = VAR_2->readInt(1);\n  }\n  if (VAR_8 < 2*43 + 250*(33+13) + 128 + 2 + (VAR_13 >= 5)) {\n    /* COMMENT_6 */\n    delete [] VAR_9;\n    VAR_1.close(VAR_2);\n    return false;\n  }\n\n  memcpy(VAR_26,VAR_10,43); VAR_10 += 43;\n  memcpy(VAR_27,VAR_10,43); VAR_10 += 43;\n  memcpy(VAR_28,VAR_10,250*33); VAR_10 += 250*33;\n  /* COMMENT_7 */\n  if (VAR_26[0] > 42 || VAR_26[0] < 0) VAR_26[0] = 42;\n  if (VAR_27[0] > 42 || VAR_27[0] < 0) VAR_27[0] = 42;\n\n  for(VAR_4=0;VAR_4<250;VAR_4++) {\t/* COMMENT_8 */\n    if (VAR_28[VAR_4][0] > 32 || VAR_28[VAR_4][0] < 0) VAR_28[VAR_4][0] = 32;\n    VAR_29[VAR_4].data[0] = *(VAR_10+VAR_4*13+10);\n    VAR_29[VAR_4].data[1] = *(VAR_10+VAR_4*13);\n    VAR_29[VAR_4].data[2] = *(VAR_10+VAR_4*13+1);\n    VAR_29[VAR_4].data[3] = *(VAR_10+VAR_4*13+4);\n    VAR_29[VAR_4].data[4] = *(VAR_10+VAR_4*13+5);\n    VAR_29[VAR_4].data[5] = *(VAR_10+VAR_4*13+6);\n    VAR_29[VAR_4].data[6] = *(VAR_10+VAR_4*13+7);\n    VAR_29[VAR_4].data[7] = *(VAR_10+VAR_4*13+8);\n    VAR_29[VAR_4].data[8] = *(VAR_10+VAR_4*13+9);\n    VAR_29[VAR_4].data[9] = *(VAR_10+VAR_4*13+2);\n    VAR_29[VAR_4].data[10] = *(VAR_10+VAR_4*13+3);\n\n    if(VAR_13 < 5)\n      VAR_29[VAR_4].misc = *(VAR_10+VAR_4*13+11);\n    else {\t/* COMMENT_9 */\n      int VAR_30 = *(VAR_10+VAR_4*13+11);\n\n      if(VAR_30)\n\tVAR_29[VAR_4].data[0] |= (VAR_30 & 3) << 4;\t/* COMMENT_10 */\n      else\n\tVAR_29[VAR_4].data[0] |= 48;\t\t\t/* COMMENT_11 */\n    }\n\n    VAR_29[VAR_4].slide = *(VAR_10+VAR_4*13+12);\n  }\n\n  VAR_10 += 250*13;\n  memcpy(VAR_31,VAR_10,128); VAR_10 += 128;\n  VAR_32 = *VAR_10; VAR_10++;\n  VAR_33 = *VAR_10; VAR_10++;\n  if(VAR_13 >= 5) VAR_11 = *VAR_10;\n  delete [] VAR_9;\n\n  /* COMMENT_12 */\n  VAR_15 = VAR_16[1];\n  for (VAR_4 = 0; VAR_4 < VAR_12 / (VAR_13 < 5 ? 16 : 8); VAR_4++)\n    VAR_15 += VAR_16[VAR_4+2];\n\n  if(VAR_13 == 1 || VAR_13 == 5) {\n    VAR_9 = new unsigned char [VAR_25 * (VAR_12 / (VAR_13 < 5 ? 16 : 8) + 1)];\n    VAR_17 = new unsigned short [VAR_15 / 2];\n    for(VAR_8=0;VAR_8<VAR_15/2;VAR_8++) VAR_17[VAR_8] = VAR_2->readInt(2);\n    VAR_10 = VAR_9; VAR_18 = VAR_17;\n    /* COMMENT_13 */\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    VAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[1]); VAR_18 += VAR_16[1] / 2;\n    if(VAR_13 == 1) {\n      if(VAR_12 > 16)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[2]); VAR_18 += VAR_16[2] / 2;\n      if(VAR_12 > 32)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[3]); VAR_18 += VAR_16[3] / 2;\n      if(VAR_12 > 48)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[4]);\n    } else {\n      if(VAR_12 > 8)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[2]); VAR_18 += VAR_16[2] / 2;\n      if(VAR_12 > 16)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[3]); VAR_18 += VAR_16[3] / 2;\n      if(VAR_12 > 24)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[4]); VAR_18 += VAR_16[4] / 2;\n      if(VAR_12 > 32)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[5]); VAR_18 += VAR_16[5] / 2;\n      if(VAR_12 > 40)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[6]); VAR_18 += VAR_16[6] / 2;\n      if(VAR_12 > 48)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[7]); VAR_18 += VAR_16[7] / 2;\n      if(VAR_12 > 56)\n\tVAR_10 += sixdepak(VAR_18,VAR_10,VAR_16[8]);\n    }\n    delete [] VAR_17;\n  } else {\n    VAR_9 = new unsigned char [VAR_15];\n    for(VAR_8=0;VAR_8<VAR_15;VAR_8++) VAR_9[VAR_8] = VAR_2->readInt(1);\n    VAR_10 = VAR_9 + VAR_15;\n  }\n\n  if (VAR_10 - VAR_9 < VAR_12 * 64 * VAR_7 * 4) {\n    delete [] VAR_9;\n    VAR_1.close(VAR_2);\n    return false;\n  }\n\n  if(VAR_13 < 5) {\n    for(VAR_4=0;VAR_4<VAR_12;VAR_4++)\n      for(VAR_5=0;VAR_5<64;VAR_5++)\n\tfor(VAR_6=0;VAR_6<9;VAR_6++) {\n\t  struct Tracks\t*VAR_34 = &VAR_35[VAR_4 * 9 + VAR_6][VAR_5];\n\t  unsigned char\t*VAR_36 = &VAR_9[VAR_4*64*VAR_7*4+VAR_5*VAR_7*4+VAR_6*4];\n\n\t  VAR_34->note = VAR_36[0] == 255 ? 127 : VAR_36[0];\n\t  VAR_34->inst = VAR_36[1];\n\t  VAR_34->command = VAR_36[2] < sizeof(VAR_19) ? VAR_19[VAR_36[2]] : 255;\n\t  VAR_34->param2 = VAR_36[3] & 0x0f;\n\t  if(VAR_34->command != 14)\n\t    VAR_34->param1 = VAR_36[3] >> 4;\n\t  else {\n\t    VAR_34->param1 = VAR_20[VAR_36[3] >> 4];\n\t    if(VAR_34->param1 == 15 && !VAR_34->param2) {\t/* COMMENT_16 */\n\t      VAR_34->command = 8;\n\t      VAR_34->param1 = 0;\n\t      VAR_34->param2 = 0;\n\t    }\n\t  }\n\t  if(VAR_34->command == 14) {\n\t    switch(VAR_34->param1) {\n\t    case 2: /* COMMENT_17 */\n\t      VAR_34->command = 25;\n\t      VAR_34->param1 = VAR_34->param2;\n\t      VAR_34->param2 = 0xf;\n\t      break;\n\t    case 8: /* COMMENT_18 */\n\t      VAR_34->command = 26;\n\t      VAR_34->param1 = VAR_34->param2;\n\t      VAR_34->param2 = 0;\n\t      break;\n\t    case 9: /* COMMENT_19 */\n\t      VAR_34->command = 26;\n\t      VAR_34->param1 = 0;\n\t      break;\n\t    }\n\t  }\n\t}\n  } else {\t/* COMMENT_3 */\n    realloc_patterns(64, 64, 18);\n\n    for(VAR_4=0;VAR_4<VAR_12;VAR_4++)\n      for(VAR_5=0;VAR_5<18;VAR_5++)\n\tfor(VAR_6=0;VAR_6<64;VAR_6++) {\n\t  struct Tracks\t*VAR_34 = &VAR_35[VAR_4 * 18 + VAR_5][VAR_6];\n\t  unsigned char\t*VAR_36 = &VAR_9[VAR_4*64*VAR_7*4+VAR_5*64*4+VAR_6*4];\n\n\t  VAR_34->note = VAR_36[0] == 255 ? 127 : VAR_36[0];\n\t  VAR_34->inst = VAR_36[1];\n\t  VAR_34->command = VAR_36[2] < sizeof(VAR_21) ? VAR_21[VAR_36[2]] : 255;\n\t  VAR_34->param1 = VAR_36[3] >> 4;\n\t  VAR_34->param2 = VAR_36[3] & 0x0f;\n\n\t  /* COMMENT_20 */\n\t  if(VAR_36[2] == 36)\n\t    switch(VAR_34->param1) {\n\t    case 0:\t/* COMMENT_21 */\n\t      VAR_34->command = 29;\n\t      VAR_34->param1 = 0;\n\t      /* COMMENT_22 */\n\t      break;\n\n\t    case 1:\t/* COMMENT_23 */\n\t      VAR_34->command = 14;\n\t      VAR_34->param1 = 8;\n\t      /* COMMENT_22 */\n\t      break;\n\t    }\n\t}\n  }\n\n  init_trackord();\n\n  delete [] VAR_9;\n\n  /* COMMENT_24 */\n  if(VAR_13 >= 5) {\n    CmodPlayer::flags |= VAR_37;\t\t\t\t/* COMMENT_25 */\n    if(VAR_11 & 8) CmodPlayer::flags |= VAR_38;\t\t/* COMMENT_26 */\n    if(VAR_11 & 16) CmodPlayer::flags |= VAR_39;\t/* COMMENT_27 */\n  }\n\n  /* COMMENT_28 */\n\n  VAR_1.close(VAR_2);\n  rewind(0);\n  return true;\n}",
    "func_graph_path": "adplug/30ddcfe9bd1cce3e02f8135961bceb411419dbdb/a2m.cpp/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n   char id[10];\n   int i,j,k,t;\n   unsigned int l;\n-  unsigned char *org = NULL, *orgptr, flags = 0, numpats, version;\n+  unsigned char *org, *orgptr, flags = 0, numpats, version;\n   unsigned long crc, alength;\n   unsigned short len[9], *secdata, *secptr;\n   const unsigned char convfx[16] = {0,1,2,23,24,3,5,4,6,9,17,13,11,19,7,14};\n@@ -18,8 +18,9 @@\n   version = f->readInt(1); numpats = f->readInt(1);\n \n   // file validation section\n-  if(strncmp(id,\"_A2module_\",10) || (version != 1 && version != 5 &&\n-\t\t\t\t     version != 4 && version != 8)) {\n+  if (memcmp(id, \"_A2module_\", 10) ||\n+      (version != 1 && version != 5 && version != 4 && version != 8) ||\n+      numpats > 64) {\n     fp.close(f);\n     return false;\n   }\n@@ -35,20 +36,33 @@\n   }\n \n   // block 0\n-  secdata = new unsigned short [len[0] / 2];\n   if(version == 1 || version == 5) {\n+    orgptr = org = new unsigned char [MAXBUF];\n+    secdata = new unsigned short [len[0] / 2];\n     for(i=0;i<len[0]/2;i++) secdata[i] = f->readInt(2);\n-    org = new unsigned char [MAXBUF]; orgptr = org;\n-    sixdepak(secdata,org,len[0]);\n+    // What if len[0] is odd: ignore, skip extra byte, or fail?\n+    l = sixdepak(secdata,org,len[0]);\n+    delete [] secdata;\n   } else {\n-    orgptr = (unsigned char *)secdata;\n-    for(i=0;i<len[0];i++) orgptr[i] = f->readInt(1);\n-  }\n+    orgptr = org = new unsigned char [len[0]];\n+    for(l = 0; l < len[0]; l++) orgptr[l] = f->readInt(1);\n+  }\n+  if (l < 2*43 + 250*(33+13) + 128 + 2 + (version >= 5)) {\n+    // Block is too short; fail.\n+    delete [] org;\n+    fp.close(f);\n+    return false;\n+  }\n+\n   memcpy(songname,orgptr,43); orgptr += 43;\n   memcpy(author,orgptr,43); orgptr += 43;\n   memcpy(instname,orgptr,250*33); orgptr += 250*33;\n+  // If string length is invalid, just use the maximum. Should we fail instead?\n+  if (songname[0] > 42 || songname[0] < 0) songname[0] = 42;\n+  if (author[0] > 42 || author[0] < 0) author[0] = 42;\n \n   for(i=0;i<250;i++) {\t// instruments\n+    if (instname[i][0] > 32 || instname[i][0] < 0) instname[i][0] = 32;\n     inst[i].data[0] = *(orgptr+i*13+10);\n     inst[i].data[1] = *(orgptr+i*13);\n     inst[i].data[2] = *(orgptr+i*13+1);\n@@ -80,19 +94,21 @@\n   bpm = *orgptr; orgptr++;\n   initspeed = *orgptr; orgptr++;\n   if(version >= 5) flags = *orgptr;\n-  if(version == 1 || version == 5) delete [] org;\n-  delete [] secdata;\n+  delete [] org;\n \n   // blocks 1-4 or 1-8\n   alength = len[1];\n-  for(i = 0; i < (version < 5 ? numpats / 16 : numpats / 8); i++)\n+  for (i = 0; i < numpats / (version < 5 ? 16 : 8); i++)\n     alength += len[i+2];\n \n-  secdata = new unsigned short [alength / 2];\n   if(version == 1 || version == 5) {\n+    org = new unsigned char [MAXBUF * (numpats / (version < 5 ? 16 : 8) + 1)];\n+    secdata = new unsigned short [alength / 2];\n     for(l=0;l<alength/2;l++) secdata[l] = f->readInt(2);\n-    org = new unsigned char [MAXBUF * (numpats / (version == 1 ? 16 : 8) + 1)];\n     orgptr = org; secptr = secdata;\n+    // FIXME: The number of depacked blocks is inconsistent with the\n+    // lengths summed and the size of org (if numpats is a multiple of 16/8).\n+    // Also the \"secptr += ...\" statements below are not guarded by the \"if\"s!\n     orgptr += sixdepak(secptr,orgptr,len[1]); secptr += len[1] / 2;\n     if(version == 1) {\n       if(numpats > 16)\n@@ -100,7 +116,7 @@\n       if(numpats > 32)\n \torgptr += sixdepak(secptr,orgptr,len[3]); secptr += len[3] / 2;\n       if(numpats > 48)\n-\tsixdepak(secptr,orgptr,len[4]);\n+\torgptr += sixdepak(secptr,orgptr,len[4]);\n     } else {\n       if(numpats > 8)\n \torgptr += sixdepak(secptr,orgptr,len[2]); secptr += len[2] / 2;\n@@ -115,12 +131,19 @@\n       if(numpats > 48)\n \torgptr += sixdepak(secptr,orgptr,len[7]); secptr += len[7] / 2;\n       if(numpats > 56)\n-\tsixdepak(secptr,orgptr,len[8]);\n+\torgptr += sixdepak(secptr,orgptr,len[8]);\n     }\n     delete [] secdata;\n   } else {\n-    org = (unsigned char *)secdata;\n+    org = new unsigned char [alength];\n     for(l=0;l<alength;l++) org[l] = f->readInt(1);\n+    orgptr = org + alength;\n+  }\n+\n+  if (orgptr - org < numpats * 64 * t * 4) {\n+    delete [] org;\n+    fp.close(f);\n+    return false;\n   }\n \n   if(version < 5) {\n@@ -132,7 +155,7 @@\n \n \t  track->note = o[0] == 255 ? 127 : o[0];\n \t  track->inst = o[1];\n-\t  track->command = convfx[o[2]];\n+\t  track->command = o[2] < sizeof(convfx) ? convfx[o[2]] : 255;\n \t  track->param2 = o[3] & 0x0f;\n \t  if(track->command != 14)\n \t    track->param1 = o[3] >> 4;\n@@ -174,7 +197,7 @@\n \n \t  track->note = o[0] == 255 ? 127 : o[0];\n \t  track->inst = o[1];\n-\t  track->command = newconvfx[o[2]];\n+\t  track->command = o[2] < sizeof(newconvfx) ? newconvfx[o[2]] : 255;\n \t  track->param1 = o[3] >> 4;\n \t  track->param2 = o[3] & 0x0f;\n \n@@ -198,10 +221,7 @@\n \n   init_trackord();\n \n-  if(version == 1 || version == 5)\n-    delete [] org;\n-  else\n-    delete [] secdata;\n+  delete [] org;\n \n   // Process flags\n   if(version >= 5) {\n@@ -210,6 +230,8 @@\n     if(flags & 16) CmodPlayer::flags |= Vibrato;\t// Vibrato depth\n   }\n \n+  // Note: crc value is not checked.\n+\n   fp.close(f);\n   rewind(0);\n   return true;",
    "diff_line_info": {
        "deleted_lines": [
            "  unsigned char *org = NULL, *orgptr, flags = 0, numpats, version;",
            "  if(strncmp(id,\"_A2module_\",10) || (version != 1 && version != 5 &&",
            "\t\t\t\t     version != 4 && version != 8)) {",
            "  secdata = new unsigned short [len[0] / 2];",
            "    org = new unsigned char [MAXBUF]; orgptr = org;",
            "    sixdepak(secdata,org,len[0]);",
            "    orgptr = (unsigned char *)secdata;",
            "    for(i=0;i<len[0];i++) orgptr[i] = f->readInt(1);",
            "  }",
            "  if(version == 1 || version == 5) delete [] org;",
            "  delete [] secdata;",
            "  for(i = 0; i < (version < 5 ? numpats / 16 : numpats / 8); i++)",
            "  secdata = new unsigned short [alength / 2];",
            "    org = new unsigned char [MAXBUF * (numpats / (version == 1 ? 16 : 8) + 1)];",
            "\tsixdepak(secptr,orgptr,len[4]);",
            "\tsixdepak(secptr,orgptr,len[8]);",
            "    org = (unsigned char *)secdata;",
            "\t  track->command = convfx[o[2]];",
            "\t  track->command = newconvfx[o[2]];",
            "  if(version == 1 || version == 5)",
            "    delete [] org;",
            "  else",
            "    delete [] secdata;"
        ],
        "added_lines": [
            "  unsigned char *org, *orgptr, flags = 0, numpats, version;",
            "  if (memcmp(id, \"_A2module_\", 10) ||",
            "      (version != 1 && version != 5 && version != 4 && version != 8) ||",
            "      numpats > 64) {",
            "    orgptr = org = new unsigned char [MAXBUF];",
            "    secdata = new unsigned short [len[0] / 2];",
            "    // What if len[0] is odd: ignore, skip extra byte, or fail?",
            "    l = sixdepak(secdata,org,len[0]);",
            "    delete [] secdata;",
            "    orgptr = org = new unsigned char [len[0]];",
            "    for(l = 0; l < len[0]; l++) orgptr[l] = f->readInt(1);",
            "  }",
            "  if (l < 2*43 + 250*(33+13) + 128 + 2 + (version >= 5)) {",
            "    // Block is too short; fail.",
            "    delete [] org;",
            "    fp.close(f);",
            "    return false;",
            "  }",
            "",
            "  // If string length is invalid, just use the maximum. Should we fail instead?",
            "  if (songname[0] > 42 || songname[0] < 0) songname[0] = 42;",
            "  if (author[0] > 42 || author[0] < 0) author[0] = 42;",
            "    if (instname[i][0] > 32 || instname[i][0] < 0) instname[i][0] = 32;",
            "  delete [] org;",
            "  for (i = 0; i < numpats / (version < 5 ? 16 : 8); i++)",
            "    org = new unsigned char [MAXBUF * (numpats / (version < 5 ? 16 : 8) + 1)];",
            "    secdata = new unsigned short [alength / 2];",
            "    // FIXME: The number of depacked blocks is inconsistent with the",
            "    // lengths summed and the size of org (if numpats is a multiple of 16/8).",
            "    // Also the \"secptr += ...\" statements below are not guarded by the \"if\"s!",
            "\torgptr += sixdepak(secptr,orgptr,len[4]);",
            "\torgptr += sixdepak(secptr,orgptr,len[8]);",
            "    org = new unsigned char [alength];",
            "    orgptr = org + alength;",
            "  }",
            "",
            "  if (orgptr - org < numpats * 64 * t * 4) {",
            "    delete [] org;",
            "    fp.close(f);",
            "    return false;",
            "\t  track->command = o[2] < sizeof(convfx) ? convfx[o[2]] : 255;",
            "\t  track->command = o[2] < sizeof(newconvfx) ? newconvfx[o[2]] : 255;",
            "  delete [] org;",
            "  // Note: crc value is not checked.",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}