{
    "cve_id": "CVE-2019-17113",
    "cwe_ids": [
        "CWE-120"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "OpenMPT/openmpt",
    "commit_msg": "[Fix] libmodplug: C API: Limit the length of strings copied to the output buffer of ModPlug_InstrumentName() and ModPlug_SampleName() to 32 bytes (including terminating null) as is done by original libmodplug. This avoids potential buffer overflows in software relying on this limit instead of querying the required buffer size beforehand. libopenmpt can return strings longer than 32 bytes here beacuse the internal limit of 32 bytes applies to strings encoded in arbitrary character encodings but the API returns them converted to UTF-8, which can be longer. (reported by Antonio Morales Maldonado of Semmle Security Research Team)\n\ngit-svn-id: https://source.openmpt.org/svn/openmpt/trunk/OpenMPT@12127 56274372-70c3-4bfc-bfc3-4c3a0b034d27",
    "commit_hash": "927688ddab43c2b203569de79407a899e734fabe",
    "git_url": "https://github.com/OpenMPT/openmpt/commit/927688ddab43c2b203569de79407a899e734fabe",
    "file_path": "libopenmpt/libopenmpt_modplug.c",
    "func_name": "ModPlug_SampleName",
    "func_before": "int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}",
    "abstract_func_before": "int ModPlug_SampleName(ModPlugFile* VAR_0, unsigned int VAR_1, char* VAR_2)\n{\n\tconst char* VAR_3;\n\tunsigned int VAR_4;\n\tsize_t VAR_5;\n\tif(!VAR_0) return 0;\n\tVAR_3 = openmpt_module_get_sample_name(VAR_0->mod,VAR_1-1);\n\tif(!VAR_3){\n\t\tif(VAR_2){\n\t\t\t*VAR_2 = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\tVAR_5 = strlen(VAR_3);\n\tif(VAR_5>=VAR_6){\n\t\tVAR_5 = VAR_6-1;\n\t}\n\tVAR_4 = (int)VAR_5;\n\tif(VAR_2){\n\t\tmemcpy(VAR_2,VAR_3,VAR_4+1);\n\t\tVAR_2[VAR_4] = '\\0';\n\t}\n\topenmpt_free_string(VAR_3);\n\treturn VAR_4;\n}",
    "func_graph_path_before": "OpenMPT/openmpt/927688ddab43c2b203569de79407a899e734fabe/libopenmpt_modplug.c/vul/before/1.json",
    "func": "int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tchar buf[32];\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tmemset(buf,0,32);\n\tif(str){\n\t\tstrncpy(buf,str,31);\n\t\topenmpt_free_string(str);\n\t}\n\tif(buff){\n\t\tstrncpy(buff,buf,32);\n\t}\n\treturn (unsigned int)strlen(buf);\n}",
    "abstract_func": "int ModPlug_SampleName(ModPlugFile* VAR_0, unsigned int VAR_1, char* VAR_2)\n{\n\tconst char* VAR_3;\n\tchar VAR_4[32];\n\tif(!VAR_0) return 0;\n\tVAR_3 = openmpt_module_get_sample_name(VAR_0->mod,VAR_1-1);\n\tmemset(VAR_4,0,32);\n\tif(VAR_3){\n\t\tstrncpy(VAR_4,VAR_3,31);\n\t\topenmpt_free_string(VAR_3);\n\t}\n\tif(VAR_2){\n\t\tstrncpy(VAR_2,VAR_4,32);\n\t}\n\treturn (unsigned int)strlen(VAR_4);\n}",
    "func_graph_path": "OpenMPT/openmpt/927688ddab43c2b203569de79407a899e734fabe/libopenmpt_modplug.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,25 +1,16 @@\n int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n-\tunsigned int retval;\n-\tsize_t tmpretval;\n+\tchar buf[32];\n \tif(!file) return 0;\n \tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n-\tif(!str){\n-\t\tif(buff){\n-\t\t\t*buff = '\\0';\n-\t\t}\n-\t\treturn 0;\n+\tmemset(buf,0,32);\n+\tif(str){\n+\t\tstrncpy(buf,str,31);\n+\t\topenmpt_free_string(str);\n \t}\n-\ttmpretval = strlen(str);\n-\tif(tmpretval>=INT_MAX){\n-\t\ttmpretval = INT_MAX-1;\n+\tif(buff){\n+\t\tstrncpy(buff,buf,32);\n \t}\n-\tretval = (int)tmpretval;\n-\tif(buff){\n-\t\tmemcpy(buff,str,retval+1);\n-\t\tbuff[retval] = '\\0';\n-\t}\n-\topenmpt_free_string(str);\n-\treturn retval;\n+\treturn (unsigned int)strlen(buf);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\tunsigned int retval;",
            "\tsize_t tmpretval;",
            "\tif(!str){",
            "\t\tif(buff){",
            "\t\t\t*buff = '\\0';",
            "\t\t}",
            "\t\treturn 0;",
            "\ttmpretval = strlen(str);",
            "\tif(tmpretval>=INT_MAX){",
            "\t\ttmpretval = INT_MAX-1;",
            "\tretval = (int)tmpretval;",
            "\tif(buff){",
            "\t\tmemcpy(buff,str,retval+1);",
            "\t\tbuff[retval] = '\\0';",
            "\t}",
            "\topenmpt_free_string(str);",
            "\treturn retval;"
        ],
        "added_lines": [
            "\tchar buf[32];",
            "\tmemset(buf,0,32);",
            "\tif(str){",
            "\t\tstrncpy(buf,str,31);",
            "\t\topenmpt_free_string(str);",
            "\tif(buff){",
            "\t\tstrncpy(buff,buf,32);",
            "\treturn (unsigned int)strlen(buf);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}