{
    "cve_id": "CVE-2021-24036",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "facebook/folly",
    "commit_msg": "[folly] Add additional overflow checks to IOBuf - CVE-2021-24036\n\nSummary:\nAs per title\n\nCVE-2021-24036\n\nReviewed By: jan\n\nDifferential Revision: D27938605\n\nfbshipit-source-id: 7481c54ae6fbb7b67b15b3631d5357c2f7043f9c",
    "commit_hash": "4f304af1411e68851bdd00ef6140e9de4616f7d3",
    "git_url": "https://github.com/facebook/folly/commit/4f304af1411e68851bdd00ef6140e9de4616f7d3",
    "file_path": "folly/io/IOBuf.cpp",
    "func_name": "IOBuf::reserveSlow",
    "func_before": "void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n  size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom;\n  DCHECK_LT(newCapacity, UINT32_MAX);\n\n  // reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n  // reallocate and free the original buffer.  It should only ever be called if\n  // we are the only user of the buffer.\n  DCHECK(!isSharedOne());\n\n  // We'll need to reallocate the buffer.\n  // There are a few options.\n  // - If we have enough total room, move the data around in the buffer\n  //   and adjust the data_ pointer.\n  // - If we're using an internal buffer, we'll switch to an external\n  //   buffer with enough headroom and tailroom.\n  // - If we have enough headroom (headroom() >= minHeadroom) but not too much\n  //   (so we don't waste memory), we can try one of two things, depending on\n  //   whether we use jemalloc or not:\n  //   - If using jemalloc, we can try to expand in place, avoiding a memcpy()\n  //   - If not using jemalloc and we don't have too much to copy,\n  //     we'll use realloc() (note that realloc might have to copy\n  //     headroom + data + tailroom, see smartRealloc in folly/memory/Malloc.h)\n  // - Otherwise, bite the bullet and reallocate.\n  if (headroom() + tailroom() >= minHeadroom + minTailroom) {\n    uint8_t* newData = writableBuffer() + minHeadroom;\n    memmove(newData, data_, length_);\n    data_ = newData;\n    return;\n  }\n\n  size_t newAllocatedCapacity = 0;\n  uint8_t* newBuffer = nullptr;\n  std::size_t newHeadroom = 0;\n  std::size_t oldHeadroom = headroom();\n\n  // If we have a buffer allocated with malloc and we just need more tailroom,\n  // try to use realloc()/xallocx() to grow the buffer in place.\n  SharedInfo* info = sharedInfo();\n  bool useHeapFullStorage = info && info->useHeapFullStorage;\n  if (info && (info->freeFn == nullptr) && length_ != 0 &&\n      oldHeadroom >= minHeadroom) {\n    size_t headSlack = oldHeadroom - minHeadroom;\n    newAllocatedCapacity = goodExtBufferSize(newCapacity + headSlack);\n    if (usingJEMalloc()) {\n      // We assume that tailroom is more useful and more important than\n      // headroom (not least because realloc / xallocx allow us to grow the\n      // buffer at the tail, but not at the head)  So, if we have more headroom\n      // than we need, we consider that \"wasted\".  We arbitrarily define \"too\n      // much\" headroom to be 25% of the capacity.\n      if (headSlack * 4 <= newCapacity) {\n        size_t allocatedCapacity = capacity() + sizeof(SharedInfo);\n        void* p = buf_;\n        if (allocatedCapacity >= jemallocMinInPlaceExpandable) {\n          if (xallocx(p, newAllocatedCapacity, 0, 0) == newAllocatedCapacity) {\n            if (io_buf_free_cb) {\n              io_buf_free_cb(p, reinterpret_cast<size_t>(info->userData));\n            }\n            newBuffer = static_cast<uint8_t*>(p);\n            newHeadroom = oldHeadroom;\n            // update the userData\n            info->userData = reinterpret_cast<void*>(newAllocatedCapacity);\n            if (io_buf_alloc_cb) {\n              io_buf_alloc_cb(newBuffer, newAllocatedCapacity);\n            }\n          }\n          // if xallocx failed, do nothing, fall back to malloc/memcpy/free\n        }\n      }\n    } else { // Not using jemalloc\n      size_t copySlack = capacity() - length_;\n      if (copySlack * 2 <= length_) {\n        void* p = realloc(buf_, newAllocatedCapacity);\n        if (UNLIKELY(p == nullptr)) {\n          throw_exception<std::bad_alloc>();\n        }\n        newBuffer = static_cast<uint8_t*>(p);\n        newHeadroom = oldHeadroom;\n      }\n    }\n  }\n\n  // None of the previous reallocation strategies worked (or we're using\n  // an internal buffer).  malloc/copy/free.\n  if (newBuffer == nullptr) {\n    newAllocatedCapacity = goodExtBufferSize(newCapacity);\n    newBuffer = static_cast<uint8_t*>(checkedMalloc(newAllocatedCapacity));\n    if (length_ > 0) {\n      assert(data_ != nullptr);\n      memcpy(newBuffer + minHeadroom, data_, length_);\n    }\n    if (sharedInfo()) {\n      freeExtBuffer();\n    }\n    newHeadroom = minHeadroom;\n  }\n\n  std::size_t cap;\n  initExtBuffer(newBuffer, newAllocatedCapacity, &info, &cap);\n\n  if (flags() & kFlagFreeSharedInfo) {\n    delete sharedInfo();\n  } else {\n    if (useHeapFullStorage) {\n      SharedInfo::releaseStorage(sharedInfo());\n    }\n  }\n\n  setFlagsAndSharedInfo(0, info);\n  capacity_ = cap;\n  buf_ = newBuffer;\n  data_ = newBuffer + newHeadroom;\n  // length_ is unchanged\n}",
    "abstract_func_before": "void IOBuf::reserveSlow(std::size_t VAR_0, std::size_t VAR_1) {\n  size_t VAR_2 = (size_t)VAR_3 + VAR_0 + VAR_1;\n  DCHECK_LT(VAR_2, VAR_4);\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  DCHECK(!isSharedOne());\n\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  /* COMMENT_13 */\n  /* COMMENT_14 */\n  /* COMMENT_15 */\n  /* COMMENT_16 */\n  if (headroom() + tailroom() >= VAR_0 + VAR_1) {\n    uint8_t* VAR_5 = writableBuffer() + VAR_0;\n    memmove(VAR_5, VAR_6, VAR_3);\n    VAR_6 = VAR_5;\n    return;\n  }\n\n  size_t VAR_7 = 0;\n  uint8_t* VAR_8 = nullptr;\n  std::size_t VAR_9 = 0;\n  std::size_t VAR_10 = headroom();\n\n  /* COMMENT_17 */\n  /* COMMENT_18 */\n  SharedInfo* VAR_11 = sharedInfo();\n  bool VAR_12 = VAR_11 && VAR_11->useHeapFullStorage;\n  if (VAR_11 && (VAR_11->freeFn == nullptr) && VAR_3 != 0 &&\n      VAR_10 >= VAR_0) {\n    size_t VAR_13 = VAR_10 - VAR_0;\n    VAR_7 = goodExtBufferSize(VAR_2 + VAR_13);\n    if (usingJEMalloc()) {\n      /* COMMENT_19 */\n      /* COMMENT_20 */\n      /* COMMENT_21 */\n      /* COMMENT_22 */\n      /* COMMENT_23 */\n      if (VAR_13 * 4 <= VAR_2) {\n        size_t VAR_14 = capacity() + sizeof(SharedInfo);\n        void* VAR_15 = VAR_16;\n        if (VAR_14 >= VAR_17) {\n          if (xallocx(VAR_15, VAR_7, 0, 0) == VAR_7) {\n            if (VAR_18) {\n              VAR_18(VAR_15, VAR_19<size_t>(VAR_11->userData));\n            }\n            VAR_8 = VAR_20<uint8_t*>(VAR_15);\n            VAR_9 = VAR_10;\n            /* COMMENT_24 */\n            VAR_11->userData = VAR_19<void*>(VAR_7);\n            if (VAR_21) {\n              VAR_21(VAR_8, VAR_7);\n            }\n          }\n          /* COMMENT_25 */\n        }\n      }\n    } else { /* COMMENT_26 */\n      size_t VAR_22 = capacity() - VAR_3;\n      if (VAR_22 * 2 <= VAR_3) {\n        void* VAR_15 = realloc(VAR_16, VAR_7);\n        if (UNLIKELY(VAR_15 == nullptr)) {\n          VAR_23<std::bad_alloc>();\n        }\n        VAR_8 = VAR_20<uint8_t*>(VAR_15);\n        VAR_9 = VAR_10;\n      }\n    }\n  }\n\n  /* COMMENT_27 */\n  /* COMMENT_28 */\n  if (VAR_8 == nullptr) {\n    VAR_7 = goodExtBufferSize(VAR_2);\n    VAR_8 = VAR_20<uint8_t*>(checkedMalloc(VAR_7));\n    if (VAR_3 > 0) {\n      assert(VAR_6 != nullptr);\n      memcpy(VAR_8 + VAR_0, VAR_6, VAR_3);\n    }\n    if (sharedInfo()) {\n      freeExtBuffer();\n    }\n    VAR_9 = VAR_0;\n  }\n\n  std::size_t VAR_24;\n  initExtBuffer(VAR_8, VAR_7, &VAR_11, &VAR_24);\n\n  if (flags() & VAR_25) {\n    delete sharedInfo();\n  } else {\n    if (VAR_12) {\n      SharedInfo::releaseStorage(sharedInfo());\n    }\n  }\n\n  setFlagsAndSharedInfo(0, VAR_11);\n  VAR_26 = VAR_24;\n  VAR_16 = VAR_8;\n  VAR_6 = VAR_8 + VAR_9;\n  /* COMMENT_29 */\n}",
    "func_graph_path_before": "facebook/folly/4f304af1411e68851bdd00ef6140e9de4616f7d3/IOBuf.cpp/vul/before/4.json",
    "func": "void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n  size_t newCapacity = length_;\n  if (!checked_add(&newCapacity, newCapacity, minHeadroom) ||\n      !checked_add(&newCapacity, newCapacity, minTailroom) ||\n      newCapacity > kMaxIOBufSize) {\n    // overflow\n    throw_exception<std::bad_alloc>();\n  }\n\n  // reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n  // reallocate and free the original buffer.  It should only ever be called if\n  // we are the only user of the buffer.\n  DCHECK(!isSharedOne());\n\n  // We'll need to reallocate the buffer.\n  // There are a few options.\n  // - If we have enough total room, move the data around in the buffer\n  //   and adjust the data_ pointer.\n  // - If we're using an internal buffer, we'll switch to an external\n  //   buffer with enough headroom and tailroom.\n  // - If we have enough headroom (headroom() >= minHeadroom) but not too much\n  //   (so we don't waste memory), we can try one of two things, depending on\n  //   whether we use jemalloc or not:\n  //   - If using jemalloc, we can try to expand in place, avoiding a memcpy()\n  //   - If not using jemalloc and we don't have too much to copy,\n  //     we'll use realloc() (note that realloc might have to copy\n  //     headroom + data + tailroom, see smartRealloc in folly/memory/Malloc.h)\n  // - Otherwise, bite the bullet and reallocate.\n  if (headroom() + tailroom() >= minHeadroom + minTailroom) {\n    uint8_t* newData = writableBuffer() + minHeadroom;\n    memmove(newData, data_, length_);\n    data_ = newData;\n    return;\n  }\n\n  size_t newAllocatedCapacity = 0;\n  uint8_t* newBuffer = nullptr;\n  std::size_t newHeadroom = 0;\n  std::size_t oldHeadroom = headroom();\n\n  // If we have a buffer allocated with malloc and we just need more tailroom,\n  // try to use realloc()/xallocx() to grow the buffer in place.\n  SharedInfo* info = sharedInfo();\n  bool useHeapFullStorage = info && info->useHeapFullStorage;\n  if (info && (info->freeFn == nullptr) && length_ != 0 &&\n      oldHeadroom >= minHeadroom) {\n    size_t headSlack = oldHeadroom - minHeadroom;\n    newAllocatedCapacity = goodExtBufferSize(newCapacity + headSlack);\n    if (usingJEMalloc()) {\n      // We assume that tailroom is more useful and more important than\n      // headroom (not least because realloc / xallocx allow us to grow the\n      // buffer at the tail, but not at the head)  So, if we have more headroom\n      // than we need, we consider that \"wasted\".  We arbitrarily define \"too\n      // much\" headroom to be 25% of the capacity.\n      if (headSlack * 4 <= newCapacity) {\n        size_t allocatedCapacity = capacity() + sizeof(SharedInfo);\n        void* p = buf_;\n        if (allocatedCapacity >= jemallocMinInPlaceExpandable) {\n          if (xallocx(p, newAllocatedCapacity, 0, 0) == newAllocatedCapacity) {\n            if (io_buf_free_cb) {\n              io_buf_free_cb(p, reinterpret_cast<size_t>(info->userData));\n            }\n            newBuffer = static_cast<uint8_t*>(p);\n            newHeadroom = oldHeadroom;\n            // update the userData\n            info->userData = reinterpret_cast<void*>(newAllocatedCapacity);\n            if (io_buf_alloc_cb) {\n              io_buf_alloc_cb(newBuffer, newAllocatedCapacity);\n            }\n          }\n          // if xallocx failed, do nothing, fall back to malloc/memcpy/free\n        }\n      }\n    } else { // Not using jemalloc\n      size_t copySlack = capacity() - length_;\n      if (copySlack * 2 <= length_) {\n        void* p = realloc(buf_, newAllocatedCapacity);\n        if (UNLIKELY(p == nullptr)) {\n          throw_exception<std::bad_alloc>();\n        }\n        newBuffer = static_cast<uint8_t*>(p);\n        newHeadroom = oldHeadroom;\n      }\n    }\n  }\n\n  // None of the previous reallocation strategies worked (or we're using\n  // an internal buffer).  malloc/copy/free.\n  if (newBuffer == nullptr) {\n    newAllocatedCapacity = goodExtBufferSize(newCapacity);\n    newBuffer = static_cast<uint8_t*>(checkedMalloc(newAllocatedCapacity));\n    if (length_ > 0) {\n      assert(data_ != nullptr);\n      memcpy(newBuffer + minHeadroom, data_, length_);\n    }\n    if (sharedInfo()) {\n      freeExtBuffer();\n    }\n    newHeadroom = minHeadroom;\n  }\n\n  std::size_t cap;\n  initExtBuffer(newBuffer, newAllocatedCapacity, &info, &cap);\n\n  if (flags() & kFlagFreeSharedInfo) {\n    delete sharedInfo();\n  } else {\n    if (useHeapFullStorage) {\n      SharedInfo::releaseStorage(sharedInfo());\n    }\n  }\n\n  setFlagsAndSharedInfo(0, info);\n  capacity_ = cap;\n  buf_ = newBuffer;\n  data_ = newBuffer + newHeadroom;\n  // length_ is unchanged\n}",
    "abstract_func": "void IOBuf::reserveSlow(std::size_t VAR_0, std::size_t VAR_1) {\n  size_t VAR_2 = VAR_3;\n  if (!checked_add(&VAR_2, VAR_2, VAR_0) ||\n      !checked_add(&VAR_2, VAR_2, VAR_1) ||\n      VAR_2 > VAR_4) {\n    /* COMMENT_0 */\n    VAR_5<std::bad_alloc>();\n  }\n\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  DCHECK(!isSharedOne());\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  /* COMMENT_13 */\n  /* COMMENT_14 */\n  /* COMMENT_15 */\n  /* COMMENT_16 */\n  /* COMMENT_17 */\n  if (headroom() + tailroom() >= VAR_0 + VAR_1) {\n    uint8_t* VAR_6 = writableBuffer() + VAR_0;\n    memmove(VAR_6, VAR_7, VAR_3);\n    VAR_7 = VAR_6;\n    return;\n  }\n\n  size_t VAR_8 = 0;\n  uint8_t* VAR_9 = nullptr;\n  std::size_t VAR_10 = 0;\n  std::size_t VAR_11 = headroom();\n\n  /* COMMENT_18 */\n  /* COMMENT_19 */\n  SharedInfo* VAR_12 = sharedInfo();\n  bool VAR_13 = VAR_12 && VAR_12->useHeapFullStorage;\n  if (VAR_12 && (VAR_12->freeFn == nullptr) && VAR_3 != 0 &&\n      VAR_11 >= VAR_0) {\n    size_t VAR_14 = VAR_11 - VAR_0;\n    VAR_8 = goodExtBufferSize(VAR_2 + VAR_14);\n    if (usingJEMalloc()) {\n      /* COMMENT_20 */\n      /* COMMENT_21 */\n      /* COMMENT_22 */\n      /* COMMENT_23 */\n      /* COMMENT_24 */\n      if (VAR_14 * 4 <= VAR_2) {\n        size_t VAR_15 = capacity() + sizeof(SharedInfo);\n        void* VAR_16 = VAR_17;\n        if (VAR_15 >= VAR_18) {\n          if (xallocx(VAR_16, VAR_8, 0, 0) == VAR_8) {\n            if (VAR_19) {\n              VAR_19(VAR_16, VAR_20<size_t>(VAR_12->userData));\n            }\n            VAR_9 = VAR_21<uint8_t*>(VAR_16);\n            VAR_10 = VAR_11;\n            /* COMMENT_25 */\n            VAR_12->userData = VAR_20<void*>(VAR_8);\n            if (VAR_22) {\n              VAR_22(VAR_9, VAR_8);\n            }\n          }\n          /* COMMENT_26 */\n        }\n      }\n    } else { /* COMMENT_27 */\n      size_t VAR_23 = capacity() - VAR_3;\n      if (VAR_23 * 2 <= VAR_3) {\n        void* VAR_16 = realloc(VAR_17, VAR_8);\n        if (UNLIKELY(VAR_16 == nullptr)) {\n          VAR_5<std::bad_alloc>();\n        }\n        VAR_9 = VAR_21<uint8_t*>(VAR_16);\n        VAR_10 = VAR_11;\n      }\n    }\n  }\n\n  /* COMMENT_28 */\n  /* COMMENT_29 */\n  if (VAR_9 == nullptr) {\n    VAR_8 = goodExtBufferSize(VAR_2);\n    VAR_9 = VAR_21<uint8_t*>(checkedMalloc(VAR_8));\n    if (VAR_3 > 0) {\n      assert(VAR_7 != nullptr);\n      memcpy(VAR_9 + VAR_0, VAR_7, VAR_3);\n    }\n    if (sharedInfo()) {\n      freeExtBuffer();\n    }\n    VAR_10 = VAR_0;\n  }\n\n  std::size_t VAR_24;\n  initExtBuffer(VAR_9, VAR_8, &VAR_12, &VAR_24);\n\n  if (flags() & VAR_25) {\n    delete sharedInfo();\n  } else {\n    if (VAR_13) {\n      SharedInfo::releaseStorage(sharedInfo());\n    }\n  }\n\n  setFlagsAndSharedInfo(0, VAR_12);\n  VAR_26 = VAR_24;\n  VAR_17 = VAR_9;\n  VAR_7 = VAR_9 + VAR_10;\n  /* COMMENT_30 */\n}",
    "func_graph_path": "facebook/folly/4f304af1411e68851bdd00ef6140e9de4616f7d3/IOBuf.cpp/vul/after/4.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,11 @@\n void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n-  size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom;\n-  DCHECK_LT(newCapacity, UINT32_MAX);\n+  size_t newCapacity = length_;\n+  if (!checked_add(&newCapacity, newCapacity, minHeadroom) ||\n+      !checked_add(&newCapacity, newCapacity, minTailroom) ||\n+      newCapacity > kMaxIOBufSize) {\n+    // overflow\n+    throw_exception<std::bad_alloc>();\n+  }\n \n   // reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n   // reallocate and free the original buffer.  It should only ever be called if",
    "diff_line_info": {
        "deleted_lines": [
            "  size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom;",
            "  DCHECK_LT(newCapacity, UINT32_MAX);"
        ],
        "added_lines": [
            "  size_t newCapacity = length_;",
            "  if (!checked_add(&newCapacity, newCapacity, minHeadroom) ||",
            "      !checked_add(&newCapacity, newCapacity, minTailroom) ||",
            "      newCapacity > kMaxIOBufSize) {",
            "    // overflow",
            "    throw_exception<std::bad_alloc>();",
            "  }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}