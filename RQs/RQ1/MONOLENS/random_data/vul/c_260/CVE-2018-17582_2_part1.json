{
    "cve_id": "CVE-2018-17582",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "appneta/tcpreplay",
    "commit_msg": "Bug #486 CVE-2018-17974 realloc memory if packet size increases\n\nAlso added check for packet size > cap len, although this may\nbe never be hit since #484",
    "commit_hash": "9062a91125065314877e03fc1e6ebbea7fc01ee8",
    "git_url": "https://github.com/appneta/tcpreplay/commit/9062a91125065314877e03fc1e6ebbea7fc01ee8",
    "file_path": "src/tcpedit/plugins/dlt_en10mb/en10mb.c",
    "func_name": "dlt_en10mb_encode",
    "func_before": "int \ndlt_en10mb_encode(tcpeditdlt_t *ctx, u_char *packet, int pktlen, tcpr_dir_t dir)\n{\n    tcpeditdlt_plugin_t *plugin = NULL;\n    struct tcpr_ethernet_hdr *eth = NULL;\n    struct tcpr_802_1q_hdr *vlan = NULL;\n    en10mb_config_t *config = NULL;\n    en10mb_extra_t *extra = NULL;\n    \n    int newl2len = 0;\n\n    assert(ctx);\n    assert(packet);\n\n    if (pktlen < TCPR_802_1Q_H) {\n        tcpedit_seterr(ctx->tcpedit, \n                \"Unable to process packet #\" COUNTER_SPEC \" since it is less then 14 bytes.\", \n                ctx->tcpedit->runtime.packetnum);\n        return TCPEDIT_ERROR;\n    }\n\n    plugin = tcpedit_dlt_getplugin(ctx, dlt_value);\n    if (!plugin)\n        return TCPEDIT_ERROR;\n\n    config = plugin->config;\n    if (plugin->config_size < sizeof(*config))\n        return TCPEDIT_ERROR;\n\n    extra = (en10mb_extra_t *)ctx->decoded_extra;\n    if (ctx->decoded_extra_size < sizeof(*extra))\n        return TCPEDIT_ERROR;\n\n    /* figure out the new layer2 length, first for the case: ethernet -> ethernet? */\n    if (ctx->decoder->dlt == dlt_value) {\n        if ((ctx->l2len == TCPR_802_1Q_H && config->vlan == TCPEDIT_VLAN_OFF) ||\n            (config->vlan == TCPEDIT_VLAN_ADD)) {\n            newl2len = TCPR_802_1Q_H;\n        } else if ((ctx->l2len == TCPR_802_3_H && config->vlan == TCPEDIT_VLAN_OFF) ||\n            (config->vlan == TCPEDIT_VLAN_DEL)) {\n            newl2len = TCPR_802_3_H;\n        }\n    } \n    \n    /* newl2len for some other DLT -> ethernet */\n    else {\n        /* if add a vlan then 18, else 14 bytes */\n        newl2len = config->vlan == TCPEDIT_VLAN_ADD ? TCPR_802_1Q_H : TCPR_802_3_H;\n    }\n\n    if (pktlen < newl2len) {\n        tcpedit_seterr(ctx->tcpedit,\n                \"Unable to process packet #\" COUNTER_SPEC \" since its new length less then %d bytes.\",\n                ctx->tcpedit->runtime.packetnum, newl2len);\n        return TCPEDIT_ERROR;\n    }\n\n    /* Make space for our new L2 header */\n    if (newl2len != ctx->l2len)\n        memmove(packet + newl2len, packet + ctx->l2len, pktlen - ctx->l2len);\n\n    /* update the total packet length */\n    pktlen += newl2len - ctx->l2len;\n    \n    /* always set the src & dst address as the first 12 bytes */\n    eth = (struct tcpr_ethernet_hdr *)packet;\n    \n    if (dir == TCPR_DIR_C2S) {\n        /* copy user supplied SRC MAC if provided or from original packet */\n        if (config->mac_mask & TCPEDIT_MAC_MASK_SMAC1) {\n            if ((ctx->addr_type == ETHERNET && \n                    ((ctx->skip_broadcast && \n                      is_unicast_ethernet(ctx, ctx->srcaddr.ethernet)) || !ctx->skip_broadcast))\n                || ctx->addr_type != ETHERNET) {\n                memcpy(eth->ether_shost, config->intf1_smac, ETHER_ADDR_LEN);\n            } else {\n                memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);                \n            }\n        } else if (ctx->addr_type == ETHERNET) {\n            memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Please provide a source address\");\n            return TCPEDIT_ERROR;\n        }\n\n        /* copy user supplied DMAC MAC if provided or from original packet */        \n        if (config->mac_mask & TCPEDIT_MAC_MASK_DMAC1) {\n            if ((ctx->addr_type == ETHERNET && \n                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->dstaddr.ethernet)) || !ctx->skip_broadcast))\n                || ctx->addr_type != ETHERNET) {\n                memcpy(eth->ether_dhost, config->intf1_dmac, ETHER_ADDR_LEN);\n            } else {\n                memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);\n            }\n        } else if (ctx->addr_type == ETHERNET) {\n            memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Please provide a destination address\");\n            return TCPEDIT_ERROR;            \n        }\n    \n    } else if (dir == TCPR_DIR_S2C) {\n        /* copy user supplied SRC MAC if provided or from original packet */\n        if (config->mac_mask & TCPEDIT_MAC_MASK_SMAC2) {\n            if ((ctx->addr_type == ETHERNET && \n                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->srcaddr.ethernet)) || !ctx->skip_broadcast))\n                || ctx->addr_type != ETHERNET) {\n                memcpy(eth->ether_shost, config->intf2_smac, ETHER_ADDR_LEN);\n            } else {\n                memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);\n            }\n        } else if (ctx->addr_type == ETHERNET) {\n            memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);            \n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Please provide a source address\");\n            return TCPEDIT_ERROR;\n        }\n\n        \n        /* copy user supplied DMAC MAC if provided or from original packet */        \n        if (config->mac_mask & TCPEDIT_MAC_MASK_DMAC2) {\n            if ((ctx->addr_type == ETHERNET && \n                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->dstaddr.ethernet)) || !ctx->skip_broadcast))\n                || ctx->addr_type != ETHERNET) {\n                memcpy(eth->ether_dhost, config->intf2_dmac, ETHER_ADDR_LEN);\n            } else {\n                memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);                \n            }\n        } else if (ctx->addr_type == ETHERNET) {\n            memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Please provide a destination address\");\n            return TCPEDIT_ERROR;\n        }\n\n        \n    } else {\n        tcpedit_seterr(ctx->tcpedit, \"%s\", \"Encoders only support C2S or C2S!\");\n        return TCPEDIT_ERROR;\n    }\n\n    if (config->subs.entries) {\n      int  entry = 0;\n      for (entry = 0 ; entry < config->subs.count; entry++) {\n        en10mb_sub_entry_t *current = &config->subs.entries[entry];\n\n        if (!memcmp(eth->ether_dhost, current->target, ETHER_ADDR_LEN)) {\n          memcpy(eth->ether_dhost, current->rewrite, ETHER_ADDR_LEN);\n        }\n\n        if (!memcmp(eth->ether_shost, current->target, ETHER_ADDR_LEN)) {\n          memcpy(eth->ether_shost, current->rewrite, ETHER_ADDR_LEN);\n        }\n      }\n    }\n\n    if (config->random.set) {\n      int unicast_src = is_unicast_ethernet(ctx, eth->ether_shost);\n      int unicast_dst = is_unicast_ethernet(ctx, eth->ether_dhost);\n\n      int i = config->random.keep;\n      for ( ; i < ETHER_ADDR_LEN; i++) {\n        eth->ether_shost[i] = MAC_MASK_APPLY(eth->ether_shost[i], config->random.mask[i], unicast_src);\n        eth->ether_dhost[i] = MAC_MASK_APPLY(eth->ether_dhost[i], config->random.mask[i], unicast_dst);\n      }\n\n      /* avoid making unicast packets multicast */\n      if (!config->random.keep) {\n        eth->ether_shost[0] &= ~(0x01 * unicast_src);\n        eth->ether_dhost[0] &= ~(0x01 * unicast_dst);\n      }\n    }\n\n    if (newl2len == TCPR_802_3_H) {\n        /* all we need for 802.3 is the proto */\n        eth->ether_type = ctx->proto;\n        \n    } else if (newl2len == TCPR_802_1Q_H) {\n        /* VLAN tags need a bit more */\n        vlan = (struct tcpr_802_1q_hdr *)packet;\n        vlan->vlan_len = ctx->proto;\n        vlan->vlan_tpi = htons(ETHERTYPE_VLAN);\n        \n        /* are we changing VLAN info? */\n        if (config->vlan_tag < 65535) {\n            vlan->vlan_priority_c_vid = \n                htons((uint16_t)config->vlan_tag & TCPR_802_1Q_VIDMASK);\n        } else if (extra->vlan) {\n            vlan->vlan_priority_c_vid = extra->vlan_tag;\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-tag\");\n            return TCPEDIT_ERROR;\n        }\n        \n        if (config->vlan_pri < 255) {\n            vlan->vlan_priority_c_vid += htons((uint16_t)config->vlan_pri << 13);\n        } else if (extra->vlan) {\n            vlan->vlan_priority_c_vid += extra->vlan_pri;\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-pri\");\n            return TCPEDIT_ERROR;\n        }\n            \n        if (config->vlan_cfi < 255) {\n            vlan->vlan_priority_c_vid += htons((uint16_t)config->vlan_cfi << 12);\n        } else if (extra->vlan) {\n            vlan->vlan_priority_c_vid += extra->vlan_cfi;\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-cfi\");\n            return TCPEDIT_ERROR;            \n        }        \n        \n    } else {\n        tcpedit_seterr(ctx->tcpedit, \"Unsupported new layer 2 length: %d\", newl2len);\n        return TCPEDIT_ERROR;\n    }\n\n    return pktlen;\n}",
    "abstract_func_before": "int \ndlt_en10mb_encode(tcpeditdlt_t *VAR_0, u_char *VAR_1, int VAR_2, tcpr_dir_t VAR_3)\n{\n    tcpeditdlt_plugin_t *VAR_4 = NULL;\n    struct tcpr_ethernet_hdr *VAR_5 = NULL;\n    struct tcpr_802_1q_hdr *VAR_6 = NULL;\n    en10mb_config_t *VAR_7 = NULL;\n    en10mb_extra_t *VAR_8 = NULL;\n    \n    int VAR_9 = 0;\n\n    assert(VAR_0);\n    assert(VAR_1);\n\n    if (VAR_2 < VAR_10) {\n        tcpedit_seterr(VAR_0->tcpedit, \n                \"Unable to process packet #\" VAR_11 \" since it is less then 14 bytes.\", \n                VAR_0->tcpedit->runtime.packetnum);\n        return VAR_12;\n    }\n\n    VAR_4 = tcpedit_dlt_getplugin(VAR_0, VAR_13);\n    if (!VAR_4)\n        return VAR_12;\n\n    VAR_7 = VAR_4->config;\n    if (VAR_4->config_size < sizeof(*VAR_7))\n        return VAR_12;\n\n    VAR_8 = (en10mb_extra_t *)VAR_0->decoded_extra;\n    if (VAR_0->decoded_extra_size < sizeof(*VAR_8))\n        return VAR_12;\n\n    /* COMMENT_0 */\n    if (VAR_0->decoder->dlt == VAR_13) {\n        if ((VAR_0->l2len == VAR_10 && VAR_7->vlan == VAR_14) ||\n            (VAR_7->vlan == VAR_15)) {\n            VAR_9 = VAR_10;\n        } else if ((VAR_0->l2len == VAR_16 && VAR_7->vlan == VAR_14) ||\n            (VAR_7->vlan == VAR_17)) {\n            VAR_9 = VAR_16;\n        }\n    } \n    \n    /* COMMENT_1 */\n    else {\n        /* COMMENT_2 */\n        VAR_9 = VAR_7->vlan == VAR_15 ? VAR_10 : VAR_16;\n    }\n\n    if (VAR_2 < VAR_9) {\n        tcpedit_seterr(VAR_0->tcpedit,\n                \"Unable to process packet #\" VAR_11 \" since its new length less then %d bytes.\",\n                VAR_0->tcpedit->runtime.packetnum, VAR_9);\n        return VAR_12;\n    }\n\n    /* COMMENT_3 */\n    if (VAR_9 != VAR_0->l2len)\n        memmove(VAR_1 + VAR_9, VAR_1 + VAR_0->l2len, VAR_2 - VAR_0->l2len);\n\n    /* COMMENT_4 */\n    VAR_2 += VAR_9 - VAR_0->l2len;\n    \n    /* COMMENT_5 */\n    VAR_5 = (struct tcpr_ethernet_hdr *)VAR_1;\n    \n    if (VAR_3 == VAR_18) {\n        /* COMMENT_6 */\n        if (VAR_7->mac_mask & VAR_19) {\n            if ((VAR_0->addr_type == VAR_20 && \n                    ((VAR_0->skip_broadcast && \n                      is_unicast_ethernet(VAR_0, VAR_0->srcaddr.ethernet)) || !VAR_0->skip_broadcast))\n                || VAR_0->addr_type != VAR_20) {\n                memcpy(VAR_5->ether_shost, VAR_7->intf1_smac, VAR_21);\n            } else {\n                memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);                \n            }\n        } else if (VAR_0->addr_type == VAR_20) {\n            memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Please provide a source address\");\n            return VAR_12;\n        }\n\n        /* COMMENT_7 */        \n        if (VAR_7->mac_mask & VAR_22) {\n            if ((VAR_0->addr_type == VAR_20 && \n                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->dstaddr.ethernet)) || !VAR_0->skip_broadcast))\n                || VAR_0->addr_type != VAR_20) {\n                memcpy(VAR_5->ether_dhost, VAR_7->intf1_dmac, VAR_21);\n            } else {\n                memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);\n            }\n        } else if (VAR_0->addr_type == VAR_20) {\n            memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Please provide a destination address\");\n            return VAR_12;            \n        }\n    \n    } else if (VAR_3 == VAR_23) {\n        /* COMMENT_6 */\n        if (VAR_7->mac_mask & VAR_24) {\n            if ((VAR_0->addr_type == VAR_20 && \n                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->srcaddr.ethernet)) || !VAR_0->skip_broadcast))\n                || VAR_0->addr_type != VAR_20) {\n                memcpy(VAR_5->ether_shost, VAR_7->intf2_smac, VAR_21);\n            } else {\n                memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);\n            }\n        } else if (VAR_0->addr_type == VAR_20) {\n            memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);            \n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Please provide a source address\");\n            return VAR_12;\n        }\n\n        \n        /* COMMENT_7 */        \n        if (VAR_7->mac_mask & VAR_25) {\n            if ((VAR_0->addr_type == VAR_20 && \n                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->dstaddr.ethernet)) || !VAR_0->skip_broadcast))\n                || VAR_0->addr_type != VAR_20) {\n                memcpy(VAR_5->ether_dhost, VAR_7->intf2_dmac, VAR_21);\n            } else {\n                memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);                \n            }\n        } else if (VAR_0->addr_type == VAR_20) {\n            memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Please provide a destination address\");\n            return VAR_12;\n        }\n\n        \n    } else {\n        tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Encoders only support C2S or C2S!\");\n        return VAR_12;\n    }\n\n    if (VAR_7->subs.entries) {\n      int  VAR_26 = 0;\n      for (VAR_26 = 0 ; VAR_26 < VAR_7->subs.count; VAR_26++) {\n        en10mb_sub_entry_t *VAR_27 = &VAR_7->subs.entries[VAR_26];\n\n        if (!memcmp(VAR_5->ether_dhost, VAR_27->target, VAR_21)) {\n          memcpy(VAR_5->ether_dhost, VAR_27->rewrite, VAR_21);\n        }\n\n        if (!memcmp(VAR_5->ether_shost, VAR_27->target, VAR_21)) {\n          memcpy(VAR_5->ether_shost, VAR_27->rewrite, VAR_21);\n        }\n      }\n    }\n\n    if (VAR_7->random.set) {\n      int VAR_28 = is_unicast_ethernet(VAR_0, VAR_5->ether_shost);\n      int VAR_29 = is_unicast_ethernet(VAR_0, VAR_5->ether_dhost);\n\n      int VAR_30 = VAR_7->random.keep;\n      for ( ; VAR_30 < VAR_21; VAR_30++) {\n        VAR_5->ether_shost[VAR_30] = MAC_MASK_APPLY(VAR_5->ether_shost[VAR_30], VAR_7->random.mask[VAR_30], VAR_28);\n        VAR_5->ether_dhost[VAR_30] = MAC_MASK_APPLY(VAR_5->ether_dhost[VAR_30], VAR_7->random.mask[VAR_30], VAR_29);\n      }\n\n      /* COMMENT_8 */\n      if (!VAR_7->random.keep) {\n        VAR_5->ether_shost[0] &= ~(0x01 * VAR_28);\n        VAR_5->ether_dhost[0] &= ~(0x01 * VAR_29);\n      }\n    }\n\n    if (VAR_9 == VAR_16) {\n        /* COMMENT_9 */\n        VAR_5->ether_type = VAR_0->proto;\n        \n    } else if (VAR_9 == VAR_10) {\n        /* COMMENT_10 */\n        VAR_6 = (struct tcpr_802_1q_hdr *)VAR_1;\n        VAR_6->vlan_len = VAR_0->proto;\n        VAR_6->vlan_tpi = htons(VAR_31);\n        \n        /* COMMENT_11 */\n        if (VAR_7->vlan_tag < 65535) {\n            VAR_6->vlan_priority_c_vid = \n                htons((uint16_t)VAR_7->vlan_tag & VAR_32);\n        } else if (VAR_8->vlan) {\n            VAR_6->vlan_priority_c_vid = VAR_8->vlan_tag;\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-tag\");\n            return VAR_12;\n        }\n        \n        if (VAR_7->vlan_pri < 255) {\n            VAR_6->vlan_priority_c_vid += htons((uint16_t)VAR_7->vlan_pri << 13);\n        } else if (VAR_8->vlan) {\n            VAR_6->vlan_priority_c_vid += VAR_8->vlan_pri;\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-pri\");\n            return VAR_12;\n        }\n            \n        if (VAR_7->vlan_cfi < 255) {\n            VAR_6->vlan_priority_c_vid += htons((uint16_t)VAR_7->vlan_cfi << 12);\n        } else if (VAR_8->vlan) {\n            VAR_6->vlan_priority_c_vid += VAR_8->vlan_cfi;\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-cfi\");\n            return VAR_12;            \n        }        \n        \n    } else {\n        tcpedit_seterr(VAR_0->tcpedit, \"Unsupported new layer 2 length: %d\", VAR_9);\n        return VAR_12;\n    }\n\n    return VAR_2;\n}",
    "func_graph_path_before": "appneta/tcpreplay/9062a91125065314877e03fc1e6ebbea7fc01ee8/en10mb.c/vul/before/0.json",
    "func": "int \ndlt_en10mb_encode(tcpeditdlt_t *ctx, u_char *packet, int pktlen, tcpr_dir_t dir)\n{\n    tcpeditdlt_plugin_t *plugin = NULL;\n    struct tcpr_ethernet_hdr *eth = NULL;\n    struct tcpr_802_1q_hdr *vlan = NULL;\n    en10mb_config_t *config = NULL;\n    en10mb_extra_t *extra = NULL;\n    \n    int newl2len = 0;\n\n    assert(ctx);\n    assert(packet);\n\n    if (pktlen < TCPR_802_1Q_H) {\n        tcpedit_seterr(ctx->tcpedit, \n                \"Unable to process packet #\" COUNTER_SPEC \" since it is less then 14 bytes.\", \n                ctx->tcpedit->runtime.packetnum);\n        return TCPEDIT_ERROR;\n    }\n\n    plugin = tcpedit_dlt_getplugin(ctx, dlt_value);\n    if (!plugin)\n        return TCPEDIT_ERROR;\n\n    config = plugin->config;\n    if (plugin->config_size < sizeof(*config))\n        return TCPEDIT_ERROR;\n\n    extra = (en10mb_extra_t *)ctx->decoded_extra;\n    if (ctx->decoded_extra_size < sizeof(*extra))\n        return TCPEDIT_ERROR;\n\n    /* figure out the new layer2 length, first for the case: ethernet -> ethernet? */\n    if (ctx->decoder->dlt == dlt_value) {\n        if ((ctx->l2len == TCPR_802_1Q_H && config->vlan == TCPEDIT_VLAN_OFF) ||\n            (config->vlan == TCPEDIT_VLAN_ADD)) {\n            newl2len = TCPR_802_1Q_H;\n        } else if ((ctx->l2len == TCPR_802_3_H && config->vlan == TCPEDIT_VLAN_OFF) ||\n            (config->vlan == TCPEDIT_VLAN_DEL)) {\n            newl2len = TCPR_802_3_H;\n        }\n    } \n    \n    /* newl2len for some other DLT -> ethernet */\n    else {\n        /* if add a vlan then 18, else 14 bytes */\n        newl2len = config->vlan == TCPEDIT_VLAN_ADD ? TCPR_802_1Q_H : TCPR_802_3_H;\n    }\n\n    if (pktlen < newl2len) {\n        tcpedit_seterr(ctx->tcpedit,\n                \"Unable to process packet #\" COUNTER_SPEC \" since its new length less then %d bytes.\",\n                ctx->tcpedit->runtime.packetnum, newl2len);\n        return TCPEDIT_ERROR;\n    }\n\n    if (pktlen < ctx->l2len) {\n        tcpedit_seterr(ctx->tcpedit,\n                \"Unable to process packet #\" COUNTER_SPEC \" since its new length less then %d Layer 2 bytes.\",\n                ctx->tcpedit->runtime.packetnum, ctx->l2len);\n        return TCPEDIT_ERROR;\n    }\n\n    /* Make space for our new L2 header */\n    if (newl2len != ctx->l2len) {\n        if (newl2len > ctx->l2len)\n            packet = safe_realloc(packet, pktlen + (newl2len - ctx->l2len));\n\n        memmove(packet + newl2len, packet + ctx->l2len, pktlen - ctx->l2len);\n    }\n\n    /* update the total packet length */\n    pktlen += newl2len - ctx->l2len;\n    \n    /* always set the src & dst address as the first 12 bytes */\n    eth = (struct tcpr_ethernet_hdr *)packet;\n    \n    if (dir == TCPR_DIR_C2S) {\n        /* copy user supplied SRC MAC if provided or from original packet */\n        if (config->mac_mask & TCPEDIT_MAC_MASK_SMAC1) {\n            if ((ctx->addr_type == ETHERNET && \n                    ((ctx->skip_broadcast && \n                      is_unicast_ethernet(ctx, ctx->srcaddr.ethernet)) || !ctx->skip_broadcast))\n                || ctx->addr_type != ETHERNET) {\n                memcpy(eth->ether_shost, config->intf1_smac, ETHER_ADDR_LEN);\n            } else {\n                memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);                \n            }\n        } else if (ctx->addr_type == ETHERNET) {\n            memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Please provide a source address\");\n            return TCPEDIT_ERROR;\n        }\n\n        /* copy user supplied DMAC MAC if provided or from original packet */        \n        if (config->mac_mask & TCPEDIT_MAC_MASK_DMAC1) {\n            if ((ctx->addr_type == ETHERNET && \n                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->dstaddr.ethernet)) || !ctx->skip_broadcast))\n                || ctx->addr_type != ETHERNET) {\n                memcpy(eth->ether_dhost, config->intf1_dmac, ETHER_ADDR_LEN);\n            } else {\n                memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);\n            }\n        } else if (ctx->addr_type == ETHERNET) {\n            memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Please provide a destination address\");\n            return TCPEDIT_ERROR;            \n        }\n    \n    } else if (dir == TCPR_DIR_S2C) {\n        /* copy user supplied SRC MAC if provided or from original packet */\n        if (config->mac_mask & TCPEDIT_MAC_MASK_SMAC2) {\n            if ((ctx->addr_type == ETHERNET && \n                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->srcaddr.ethernet)) || !ctx->skip_broadcast))\n                || ctx->addr_type != ETHERNET) {\n                memcpy(eth->ether_shost, config->intf2_smac, ETHER_ADDR_LEN);\n            } else {\n                memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);\n            }\n        } else if (ctx->addr_type == ETHERNET) {\n            memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);            \n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Please provide a source address\");\n            return TCPEDIT_ERROR;\n        }\n\n        \n        /* copy user supplied DMAC MAC if provided or from original packet */        \n        if (config->mac_mask & TCPEDIT_MAC_MASK_DMAC2) {\n            if ((ctx->addr_type == ETHERNET && \n                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->dstaddr.ethernet)) || !ctx->skip_broadcast))\n                || ctx->addr_type != ETHERNET) {\n                memcpy(eth->ether_dhost, config->intf2_dmac, ETHER_ADDR_LEN);\n            } else {\n                memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);                \n            }\n        } else if (ctx->addr_type == ETHERNET) {\n            memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Please provide a destination address\");\n            return TCPEDIT_ERROR;\n        }\n\n        \n    } else {\n        tcpedit_seterr(ctx->tcpedit, \"%s\", \"Encoders only support C2S or C2S!\");\n        return TCPEDIT_ERROR;\n    }\n\n    if (config->subs.entries) {\n      int  entry = 0;\n      for (entry = 0 ; entry < config->subs.count; entry++) {\n        en10mb_sub_entry_t *current = &config->subs.entries[entry];\n\n        if (!memcmp(eth->ether_dhost, current->target, ETHER_ADDR_LEN)) {\n          memcpy(eth->ether_dhost, current->rewrite, ETHER_ADDR_LEN);\n        }\n\n        if (!memcmp(eth->ether_shost, current->target, ETHER_ADDR_LEN)) {\n          memcpy(eth->ether_shost, current->rewrite, ETHER_ADDR_LEN);\n        }\n      }\n    }\n\n    if (config->random.set) {\n      int unicast_src = is_unicast_ethernet(ctx, eth->ether_shost);\n      int unicast_dst = is_unicast_ethernet(ctx, eth->ether_dhost);\n\n      int i = config->random.keep;\n      for ( ; i < ETHER_ADDR_LEN; i++) {\n        eth->ether_shost[i] = MAC_MASK_APPLY(eth->ether_shost[i], config->random.mask[i], unicast_src);\n        eth->ether_dhost[i] = MAC_MASK_APPLY(eth->ether_dhost[i], config->random.mask[i], unicast_dst);\n      }\n\n      /* avoid making unicast packets multicast */\n      if (!config->random.keep) {\n        eth->ether_shost[0] &= ~(0x01 * unicast_src);\n        eth->ether_dhost[0] &= ~(0x01 * unicast_dst);\n      }\n    }\n\n    if (newl2len == TCPR_802_3_H) {\n        /* all we need for 802.3 is the proto */\n        eth->ether_type = ctx->proto;\n        \n    } else if (newl2len == TCPR_802_1Q_H) {\n        /* VLAN tags need a bit more */\n        vlan = (struct tcpr_802_1q_hdr *)packet;\n        vlan->vlan_len = ctx->proto;\n        vlan->vlan_tpi = htons(ETHERTYPE_VLAN);\n        \n        /* are we changing VLAN info? */\n        if (config->vlan_tag < 65535) {\n            vlan->vlan_priority_c_vid = \n                htons((uint16_t)config->vlan_tag & TCPR_802_1Q_VIDMASK);\n        } else if (extra->vlan) {\n            vlan->vlan_priority_c_vid = extra->vlan_tag;\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-tag\");\n            return TCPEDIT_ERROR;\n        }\n        \n        if (config->vlan_pri < 255) {\n            vlan->vlan_priority_c_vid += htons((uint16_t)config->vlan_pri << 13);\n        } else if (extra->vlan) {\n            vlan->vlan_priority_c_vid += extra->vlan_pri;\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-pri\");\n            return TCPEDIT_ERROR;\n        }\n            \n        if (config->vlan_cfi < 255) {\n            vlan->vlan_priority_c_vid += htons((uint16_t)config->vlan_cfi << 12);\n        } else if (extra->vlan) {\n            vlan->vlan_priority_c_vid += extra->vlan_cfi;\n        } else {\n            tcpedit_seterr(ctx->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-cfi\");\n            return TCPEDIT_ERROR;            \n        }        \n        \n    } else {\n        tcpedit_seterr(ctx->tcpedit, \"Unsupported new layer 2 length: %d\", newl2len);\n        return TCPEDIT_ERROR;\n    }\n\n    return pktlen;\n}",
    "abstract_func": "int \ndlt_en10mb_encode(tcpeditdlt_t *VAR_0, u_char *VAR_1, int VAR_2, tcpr_dir_t VAR_3)\n{\n    tcpeditdlt_plugin_t *VAR_4 = NULL;\n    struct tcpr_ethernet_hdr *VAR_5 = NULL;\n    struct tcpr_802_1q_hdr *VAR_6 = NULL;\n    en10mb_config_t *VAR_7 = NULL;\n    en10mb_extra_t *VAR_8 = NULL;\n    \n    int VAR_9 = 0;\n\n    assert(VAR_0);\n    assert(VAR_1);\n\n    if (VAR_2 < VAR_10) {\n        tcpedit_seterr(VAR_0->tcpedit, \n                \"Unable to process packet #\" VAR_11 \" since it is less then 14 bytes.\", \n                VAR_0->tcpedit->runtime.packetnum);\n        return VAR_12;\n    }\n\n    VAR_4 = tcpedit_dlt_getplugin(VAR_0, VAR_13);\n    if (!VAR_4)\n        return VAR_12;\n\n    VAR_7 = VAR_4->config;\n    if (VAR_4->config_size < sizeof(*VAR_7))\n        return VAR_12;\n\n    VAR_8 = (en10mb_extra_t *)VAR_0->decoded_extra;\n    if (VAR_0->decoded_extra_size < sizeof(*VAR_8))\n        return VAR_12;\n\n    /* COMMENT_0 */\n    if (VAR_0->decoder->dlt == VAR_13) {\n        if ((VAR_0->l2len == VAR_10 && VAR_7->vlan == VAR_14) ||\n            (VAR_7->vlan == VAR_15)) {\n            VAR_9 = VAR_10;\n        } else if ((VAR_0->l2len == VAR_16 && VAR_7->vlan == VAR_14) ||\n            (VAR_7->vlan == VAR_17)) {\n            VAR_9 = VAR_16;\n        }\n    } \n    \n    /* COMMENT_1 */\n    else {\n        /* COMMENT_2 */\n        VAR_9 = VAR_7->vlan == VAR_15 ? VAR_10 : VAR_16;\n    }\n\n    if (VAR_2 < VAR_9) {\n        tcpedit_seterr(VAR_0->tcpedit,\n                \"Unable to process packet #\" VAR_11 \" since its new length less then %d bytes.\",\n                VAR_0->tcpedit->runtime.packetnum, VAR_9);\n        return VAR_12;\n    }\n\n    if (VAR_2 < VAR_0->l2len) {\n        tcpedit_seterr(VAR_0->tcpedit,\n                \"Unable to process packet #\" VAR_11 \" since its new length less then %d Layer 2 bytes.\",\n                VAR_0->tcpedit->runtime.packetnum, VAR_0->l2len);\n        return VAR_12;\n    }\n\n    /* COMMENT_3 */\n    if (VAR_9 != VAR_0->l2len) {\n        if (VAR_9 > VAR_0->l2len)\n            VAR_1 = safe_realloc(VAR_1, VAR_2 + (VAR_9 - VAR_0->l2len));\n\n        memmove(VAR_1 + VAR_9, VAR_1 + VAR_0->l2len, VAR_2 - VAR_0->l2len);\n    }\n\n    /* COMMENT_4 */\n    VAR_2 += VAR_9 - VAR_0->l2len;\n    \n    /* COMMENT_5 */\n    VAR_5 = (struct tcpr_ethernet_hdr *)VAR_1;\n    \n    if (VAR_3 == VAR_18) {\n        /* COMMENT_6 */\n        if (VAR_7->mac_mask & VAR_19) {\n            if ((VAR_0->addr_type == VAR_20 && \n                    ((VAR_0->skip_broadcast && \n                      is_unicast_ethernet(VAR_0, VAR_0->srcaddr.ethernet)) || !VAR_0->skip_broadcast))\n                || VAR_0->addr_type != VAR_20) {\n                memcpy(VAR_5->ether_shost, VAR_7->intf1_smac, VAR_21);\n            } else {\n                memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);                \n            }\n        } else if (VAR_0->addr_type == VAR_20) {\n            memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Please provide a source address\");\n            return VAR_12;\n        }\n\n        /* COMMENT_7 */        \n        if (VAR_7->mac_mask & VAR_22) {\n            if ((VAR_0->addr_type == VAR_20 && \n                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->dstaddr.ethernet)) || !VAR_0->skip_broadcast))\n                || VAR_0->addr_type != VAR_20) {\n                memcpy(VAR_5->ether_dhost, VAR_7->intf1_dmac, VAR_21);\n            } else {\n                memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);\n            }\n        } else if (VAR_0->addr_type == VAR_20) {\n            memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Please provide a destination address\");\n            return VAR_12;            \n        }\n    \n    } else if (VAR_3 == VAR_23) {\n        /* COMMENT_6 */\n        if (VAR_7->mac_mask & VAR_24) {\n            if ((VAR_0->addr_type == VAR_20 && \n                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->srcaddr.ethernet)) || !VAR_0->skip_broadcast))\n                || VAR_0->addr_type != VAR_20) {\n                memcpy(VAR_5->ether_shost, VAR_7->intf2_smac, VAR_21);\n            } else {\n                memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);\n            }\n        } else if (VAR_0->addr_type == VAR_20) {\n            memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);            \n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Please provide a source address\");\n            return VAR_12;\n        }\n\n        \n        /* COMMENT_7 */        \n        if (VAR_7->mac_mask & VAR_25) {\n            if ((VAR_0->addr_type == VAR_20 && \n                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->dstaddr.ethernet)) || !VAR_0->skip_broadcast))\n                || VAR_0->addr_type != VAR_20) {\n                memcpy(VAR_5->ether_dhost, VAR_7->intf2_dmac, VAR_21);\n            } else {\n                memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);                \n            }\n        } else if (VAR_0->addr_type == VAR_20) {\n            memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Please provide a destination address\");\n            return VAR_12;\n        }\n\n        \n    } else {\n        tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Encoders only support C2S or C2S!\");\n        return VAR_12;\n    }\n\n    if (VAR_7->subs.entries) {\n      int  VAR_26 = 0;\n      for (VAR_26 = 0 ; VAR_26 < VAR_7->subs.count; VAR_26++) {\n        en10mb_sub_entry_t *VAR_27 = &VAR_7->subs.entries[VAR_26];\n\n        if (!memcmp(VAR_5->ether_dhost, VAR_27->target, VAR_21)) {\n          memcpy(VAR_5->ether_dhost, VAR_27->rewrite, VAR_21);\n        }\n\n        if (!memcmp(VAR_5->ether_shost, VAR_27->target, VAR_21)) {\n          memcpy(VAR_5->ether_shost, VAR_27->rewrite, VAR_21);\n        }\n      }\n    }\n\n    if (VAR_7->random.set) {\n      int VAR_28 = is_unicast_ethernet(VAR_0, VAR_5->ether_shost);\n      int VAR_29 = is_unicast_ethernet(VAR_0, VAR_5->ether_dhost);\n\n      int VAR_30 = VAR_7->random.keep;\n      for ( ; VAR_30 < VAR_21; VAR_30++) {\n        VAR_5->ether_shost[VAR_30] = MAC_MASK_APPLY(VAR_5->ether_shost[VAR_30], VAR_7->random.mask[VAR_30], VAR_28);\n        VAR_5->ether_dhost[VAR_30] = MAC_MASK_APPLY(VAR_5->ether_dhost[VAR_30], VAR_7->random.mask[VAR_30], VAR_29);\n      }\n\n      /* COMMENT_8 */\n      if (!VAR_7->random.keep) {\n        VAR_5->ether_shost[0] &= ~(0x01 * VAR_28);\n        VAR_5->ether_dhost[0] &= ~(0x01 * VAR_29);\n      }\n    }\n\n    if (VAR_9 == VAR_16) {\n        /* COMMENT_9 */\n        VAR_5->ether_type = VAR_0->proto;\n        \n    } else if (VAR_9 == VAR_10) {\n        /* COMMENT_10 */\n        VAR_6 = (struct tcpr_802_1q_hdr *)VAR_1;\n        VAR_6->vlan_len = VAR_0->proto;\n        VAR_6->vlan_tpi = htons(VAR_31);\n        \n        /* COMMENT_11 */\n        if (VAR_7->vlan_tag < 65535) {\n            VAR_6->vlan_priority_c_vid = \n                htons((uint16_t)VAR_7->vlan_tag & VAR_32);\n        } else if (VAR_8->vlan) {\n            VAR_6->vlan_priority_c_vid = VAR_8->vlan_tag;\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-tag\");\n            return VAR_12;\n        }\n        \n        if (VAR_7->vlan_pri < 255) {\n            VAR_6->vlan_priority_c_vid += htons((uint16_t)VAR_7->vlan_pri << 13);\n        } else if (VAR_8->vlan) {\n            VAR_6->vlan_priority_c_vid += VAR_8->vlan_pri;\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-pri\");\n            return VAR_12;\n        }\n            \n        if (VAR_7->vlan_cfi < 255) {\n            VAR_6->vlan_priority_c_vid += htons((uint16_t)VAR_7->vlan_cfi << 12);\n        } else if (VAR_8->vlan) {\n            VAR_6->vlan_priority_c_vid += VAR_8->vlan_cfi;\n        } else {\n            tcpedit_seterr(VAR_0->tcpedit, \"%s\", \"Non-VLAN tagged packet requires --enet-vlan-cfi\");\n            return VAR_12;            \n        }        \n        \n    } else {\n        tcpedit_seterr(VAR_0->tcpedit, \"Unsupported new layer 2 length: %d\", VAR_9);\n        return VAR_12;\n    }\n\n    return VAR_2;\n}",
    "func_graph_path": "appneta/tcpreplay/9062a91125065314877e03fc1e6ebbea7fc01ee8/en10mb.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -55,9 +55,20 @@\n         return TCPEDIT_ERROR;\n     }\n \n+    if (pktlen < ctx->l2len) {\n+        tcpedit_seterr(ctx->tcpedit,\n+                \"Unable to process packet #\" COUNTER_SPEC \" since its new length less then %d Layer 2 bytes.\",\n+                ctx->tcpedit->runtime.packetnum, ctx->l2len);\n+        return TCPEDIT_ERROR;\n+    }\n+\n     /* Make space for our new L2 header */\n-    if (newl2len != ctx->l2len)\n+    if (newl2len != ctx->l2len) {\n+        if (newl2len > ctx->l2len)\n+            packet = safe_realloc(packet, pktlen + (newl2len - ctx->l2len));\n+\n         memmove(packet + newl2len, packet + ctx->l2len, pktlen - ctx->l2len);\n+    }\n \n     /* update the total packet length */\n     pktlen += newl2len - ctx->l2len;",
    "diff_line_info": {
        "deleted_lines": [
            "    if (newl2len != ctx->l2len)"
        ],
        "added_lines": [
            "    if (pktlen < ctx->l2len) {",
            "        tcpedit_seterr(ctx->tcpedit,",
            "                \"Unable to process packet #\" COUNTER_SPEC \" since its new length less then %d Layer 2 bytes.\",",
            "                ctx->tcpedit->runtime.packetnum, ctx->l2len);",
            "        return TCPEDIT_ERROR;",
            "    }",
            "",
            "    if (newl2len != ctx->l2len) {",
            "        if (newl2len > ctx->l2len)",
            "            packet = safe_realloc(packet, pktlen + (newl2len - ctx->l2len));",
            "",
            "    }"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/appneta/tcpreplay/pull/492",
    "description": "Also added check for packet size > cap len, although this may\r\nbe never be hit since #484"
}