{
    "cve_id": "CVE-2020-35538",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "libjpeg-turbo",
    "commit_msg": "Fix jpeg_skip_scanlines() segfault w/merged upsamp\n\nThe additional segfault mentioned in #244 was due to the fact that\nthe merged upsamplers use a different private structure than the\nnon-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so\nwhen merged upsampling was enabled, jpeg_skip_scanlines() clobbered one\nof the IDCT method pointers in the merged upsampler's private structure.\n\nFor reasons unknown, the test image in #441 did not encounter this\nsegfault (too small?), but it encountered an issue similar to the one\nfixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was\nnecessary to set up a dummy postprocessing function in\nread_and_discard_scanlines() when merged upsampling was enabled.\nFailing to do so caused either a segfault in merged_2v_upsample() (due\nto a NULL pointer being passed to jcopy_sample_rows()) or an error\n(\"Corrupt JPEG data: premature end of data segment\"), depending on the\nnumber of scanlines skipped and whether the first scanline skipped was\nan odd- or even-numbered row.\n\nFixes #441\nFixes #244 (for real this time)",
    "commit_hash": "9120a247436e84c0b4eea828cb11e8f665fcde30",
    "git_url": "https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30",
    "file_path": "jdapistd.c",
    "func_name": "jpeg_skip_scanlines",
    "func_before": "GLOBAL(JDIMENSION)\njpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JDIMENSION i, x;\n  int y;\n  JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n  JDIMENSION lines_to_skip, lines_to_read;\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Do not skip past the bottom of the image. */\n  if (cinfo->output_scanline + num_lines >= cinfo->output_height) {\n    cinfo->output_scanline = cinfo->output_height;\n    (*cinfo->inputctl->finish_input_pass) (cinfo);\n    cinfo->inputctl->eoi_reached = TRUE;\n    return cinfo->output_height - cinfo->output_scanline;\n  }\n\n  if (num_lines == 0)\n    return 0;\n\n  lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;\n  lines_left_in_iMCU_row =\n    (lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %\n    lines_per_iMCU_row;\n  lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;\n\n  /* Skip the lines remaining in the current iMCU row.  When upsampling\n   * requires context rows, we need the previous and next rows in order to read\n   * the current row.  This adds some complexity.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    /* If the skipped lines would not move us past the current iMCU row, we\n     * read the lines and ignore them.  There might be a faster way of doing\n     * this, but we are facing increasing complexity for diminishing returns.\n     * The increasing complexity would be a by-product of meddling with the\n     * state machine used to skip context rows.  Near the end of an iMCU row,\n     * the next iMCU row may have already been entropy-decoded.  In this unique\n     * case, we will read the next iMCU row if we cannot skip past it as well.\n     */\n    if ((num_lines < lines_left_in_iMCU_row + 1) ||\n        (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&\n         lines_after_iMCU_row < lines_per_iMCU_row + 1)) {\n      read_and_discard_scanlines(cinfo, num_lines);\n      return num_lines;\n    }\n\n    /* If the next iMCU row has already been entropy-decoded, make sure that\n     * we do not skip too far.\n     */\n    if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {\n      cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;\n      lines_after_iMCU_row -= lines_per_iMCU_row;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n    }\n\n    /* If we have just completed the first block, adjust the buffer pointers */\n    if (main_ptr->iMCU_row_ctr == 0 ||\n        (main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))\n      set_wraparound_pointers(cinfo);\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n    upsample->next_row_out = cinfo->max_v_samp_factor;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  }\n\n  /* Skipping is much simpler when context rows are not required. */\n  else {\n    if (num_lines < lines_left_in_iMCU_row) {\n      increment_simple_rowgroup_ctr(cinfo, num_lines);\n      return num_lines;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n      main_ptr->buffer_full = FALSE;\n      main_ptr->rowgroup_ctr = 0;\n      upsample->next_row_out = cinfo->max_v_samp_factor;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n  }\n\n  /* Calculate how many full iMCU rows we can skip. */\n  if (cinfo->upsample->need_context_rows)\n    lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  else\n    lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  /* Calculate the number of lines that remain to be skipped after skipping all\n   * of the full iMCU rows that we can.  We will not read these lines unless we\n   * have to.\n   */\n  lines_to_read = lines_after_iMCU_row - lines_to_skip;\n\n  /* For images requiring multiple scans (progressive, non-interleaved, etc.),\n   * all of the entropy decoding occurs in jpeg_start_decompress(), assuming\n   * that the input data source is non-suspending.  This makes skipping easy.\n   */\n  if (cinfo->inputctl->has_multiple_scans) {\n    if (cinfo->upsample->need_context_rows) {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n      /* It is complex to properly move to the middle of a context block, so\n       * read the remaining lines instead of skipping them.\n       */\n      read_and_discard_scanlines(cinfo, lines_to_read);\n    } else {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n    }\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    return num_lines;\n  }\n\n  /* Skip the iMCU rows that we can safely skip. */\n  for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {\n    for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {\n      for (x = 0; x < cinfo->MCUs_per_row; x++) {\n        /* Calling decode_mcu() with a NULL pointer causes it to discard the\n         * decoded coefficients.  This is ~5% faster for large subsets, but\n         * it's tough to tell a difference for smaller images.\n         */\n        (*cinfo->entropy->decode_mcu) (cinfo, NULL);\n      }\n    }\n    cinfo->input_iMCU_row++;\n    cinfo->output_iMCU_row++;\n    if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)\n      start_iMCU_row(cinfo);\n    else\n      (*cinfo->inputctl->finish_input_pass) (cinfo);\n  }\n  cinfo->output_scanline += lines_to_skip;\n\n  if (cinfo->upsample->need_context_rows) {\n    /* Context-based upsampling keeps track of iMCU rows. */\n    main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n\n    /* It is complex to properly move to the middle of a context block, so\n     * read the remaining lines instead of skipping them.\n     */\n    read_and_discard_scanlines(cinfo, lines_to_read);\n  } else {\n    increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n  }\n\n  /* Since skipping lines involves skipping the upsampling step, the value of\n   * \"rows_to_go\" will become invalid unless we set it here.  NOTE: This is a\n   * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n   * output_scanline.\n   */\n  upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n\n  /* Always skip the requested number of lines. */\n  return num_lines;\n}",
    "abstract_func_before": "VAR_0(JDIMENSION)\njpeg_skip_scanlines(j_decompress_ptr VAR_1, JDIMENSION VAR_2)\n{\n  my_main_ptr VAR_3 = (my_main_ptr)VAR_1->main;\n  my_coef_ptr VAR_4 = (my_coef_ptr)VAR_1->coef;\n  my_upsample_ptr VAR_5 = (my_upsample_ptr)VAR_1->upsample;\n  JDIMENSION VAR_6, VAR_7;\n  int VAR_8;\n  JDIMENSION VAR_9, VAR_10, VAR_11;\n  JDIMENSION VAR_12, VAR_13;\n\n  if (VAR_1->global_state != VAR_14)\n    ERREXIT1(VAR_1, VAR_15, VAR_1->global_state);\n\n  /* COMMENT_0 */\n  if (VAR_1->output_scanline + VAR_2 >= VAR_1->output_height) {\n    VAR_1->output_scanline = VAR_1->output_height;\n    (*VAR_1->inputctl->finish_input_pass) (VAR_1);\n    VAR_1->inputctl->eoi_reached = TRUE;\n    return VAR_1->output_height - VAR_1->output_scanline;\n  }\n\n  if (VAR_2 == 0)\n    return 0;\n\n  VAR_9 = VAR_1->_min_DCT_scaled_size * VAR_1->max_v_samp_factor;\n  VAR_10 =\n    (VAR_9 - (VAR_1->output_scanline % VAR_9)) %\n    VAR_9;\n  VAR_11 = VAR_2 - VAR_10;\n\n  /* COMMENT_1 */\n                                                                               \n                                                 \n     \n  if (VAR_1->upsample->need_context_rows) {\n    /* COMMENT_5 */\n                                                                            \n                                                                             \n                                                                           \n                                                                             \n                                                                               \n                                                                              \n       \n    if ((VAR_2 < VAR_10 + 1) ||\n        (VAR_10 <= 1 && VAR_3->buffer_full &&\n         VAR_11 < VAR_9 + 1)) {\n      read_and_discard_scanlines(VAR_1, VAR_2);\n      return VAR_2;\n    }\n\n    /* COMMENT_13 */\n                              \n       \n    if (VAR_10 <= 1 && VAR_3->buffer_full) {\n      VAR_1->output_scanline += VAR_10 + VAR_9;\n      VAR_11 -= VAR_9;\n    } else {\n      VAR_1->output_scanline += VAR_10;\n    }\n\n    /* COMMENT_16 */\n    if (VAR_3->iMCU_row_ctr == 0 ||\n        (VAR_3->iMCU_row_ctr == 1 && VAR_10 > 2))\n      set_wraparound_pointers(VAR_1);\n    VAR_3->buffer_full = FALSE;\n    VAR_3->rowgroup_ctr = 0;\n    VAR_3->context_state = VAR_16;\n    VAR_5->next_row_out = VAR_1->max_v_samp_factor;\n    VAR_5->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n  }\n\n  /* COMMENT_17 */\n  else {\n    if (VAR_2 < VAR_10) {\n      increment_simple_rowgroup_ctr(VAR_1, VAR_2);\n      return VAR_2;\n    } else {\n      VAR_1->output_scanline += VAR_10;\n      VAR_3->buffer_full = FALSE;\n      VAR_3->rowgroup_ctr = 0;\n      VAR_5->next_row_out = VAR_1->max_v_samp_factor;\n      VAR_5->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n    }\n  }\n\n  /* COMMENT_18 */\n  if (VAR_1->upsample->need_context_rows)\n    VAR_12 = ((VAR_11 - 1) / VAR_9) *\n                    VAR_9;\n  else\n    VAR_12 = (VAR_11 / VAR_9) *\n                    VAR_9;\n  /* COMMENT_19 */\n                                                                               \n             \n     \n  VAR_13 = VAR_11 - VAR_12;\n\n  /* COMMENT_23 */\n                                                                            \n                                                                             \n     \n  if (VAR_1->inputctl->has_multiple_scans) {\n    if (VAR_1->upsample->need_context_rows) {\n      VAR_1->output_scanline += VAR_12;\n      VAR_1->output_iMCU_row += VAR_12 / VAR_9;\n      VAR_3->iMCU_row_ctr += VAR_12 / VAR_9;\n      /* COMMENT_27 */\n                                                           \n         \n      read_and_discard_scanlines(VAR_1, VAR_13);\n    } else {\n      VAR_1->output_scanline += VAR_12;\n      VAR_1->output_iMCU_row += VAR_12 / VAR_9;\n      increment_simple_rowgroup_ctr(VAR_1, VAR_13);\n    }\n    VAR_5->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n    return VAR_2;\n  }\n\n  /* COMMENT_30 */\n  for (VAR_6 = 0; VAR_6 < VAR_12; VAR_6 += VAR_9) {\n    for (VAR_8 = 0; VAR_8 < VAR_4->MCU_rows_per_iMCU_row; VAR_8++) {\n      for (VAR_7 = 0; VAR_7 < VAR_1->MCUs_per_row; VAR_7++) {\n        /* COMMENT_31 */\n                                                                           \n                                                              \n           \n        (*VAR_1->entropy->decode_mcu) (VAR_1, NULL);\n      }\n    }\n    VAR_1->input_iMCU_row++;\n    VAR_1->output_iMCU_row++;\n    if (VAR_1->input_iMCU_row < VAR_1->total_iMCU_rows)\n      start_iMCU_row(VAR_1);\n    else\n      (*VAR_1->inputctl->finish_input_pass) (VAR_1);\n  }\n  VAR_1->output_scanline += VAR_12;\n\n  if (VAR_1->upsample->need_context_rows) {\n    /* COMMENT_35 */\n    VAR_3->iMCU_row_ctr += VAR_12 / VAR_9;\n\n    /* COMMENT_36 */\n                                                         \n       \n    read_and_discard_scanlines(VAR_1, VAR_13);\n  } else {\n    increment_simple_rowgroup_ctr(VAR_1, VAR_13);\n  }\n\n  /* COMMENT_39 */\n                                                                             \n                                                                         \n                     \n     \n  VAR_5->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n\n  /* COMMENT_44 */\n  return VAR_2;\n}",
    "func_graph_path_before": null,
    "func": "GLOBAL(JDIMENSION)\njpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  JDIMENSION i, x;\n  int y;\n  JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n  JDIMENSION lines_to_skip, lines_to_read;\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Do not skip past the bottom of the image. */\n  if (cinfo->output_scanline + num_lines >= cinfo->output_height) {\n    cinfo->output_scanline = cinfo->output_height;\n    (*cinfo->inputctl->finish_input_pass) (cinfo);\n    cinfo->inputctl->eoi_reached = TRUE;\n    return cinfo->output_height - cinfo->output_scanline;\n  }\n\n  if (num_lines == 0)\n    return 0;\n\n  lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;\n  lines_left_in_iMCU_row =\n    (lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %\n    lines_per_iMCU_row;\n  lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;\n\n  /* Skip the lines remaining in the current iMCU row.  When upsampling\n   * requires context rows, we need the previous and next rows in order to read\n   * the current row.  This adds some complexity.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    /* If the skipped lines would not move us past the current iMCU row, we\n     * read the lines and ignore them.  There might be a faster way of doing\n     * this, but we are facing increasing complexity for diminishing returns.\n     * The increasing complexity would be a by-product of meddling with the\n     * state machine used to skip context rows.  Near the end of an iMCU row,\n     * the next iMCU row may have already been entropy-decoded.  In this unique\n     * case, we will read the next iMCU row if we cannot skip past it as well.\n     */\n    if ((num_lines < lines_left_in_iMCU_row + 1) ||\n        (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&\n         lines_after_iMCU_row < lines_per_iMCU_row + 1)) {\n      read_and_discard_scanlines(cinfo, num_lines);\n      return num_lines;\n    }\n\n    /* If the next iMCU row has already been entropy-decoded, make sure that\n     * we do not skip too far.\n     */\n    if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {\n      cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;\n      lines_after_iMCU_row -= lines_per_iMCU_row;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n    }\n\n    /* If we have just completed the first block, adjust the buffer pointers */\n    if (main_ptr->iMCU_row_ctr == 0 ||\n        (main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))\n      set_wraparound_pointers(cinfo);\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n    if (master->using_merged_upsample) {\n      my_merged_upsample_ptr upsample =\n        (my_merged_upsample_ptr)cinfo->upsample;\n      upsample->spare_full = FALSE;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    } else {\n      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n      upsample->next_row_out = cinfo->max_v_samp_factor;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n  }\n\n  /* Skipping is much simpler when context rows are not required. */\n  else {\n    if (num_lines < lines_left_in_iMCU_row) {\n      increment_simple_rowgroup_ctr(cinfo, num_lines);\n      return num_lines;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n      main_ptr->buffer_full = FALSE;\n      main_ptr->rowgroup_ctr = 0;\n      if (master->using_merged_upsample) {\n        my_merged_upsample_ptr upsample =\n          (my_merged_upsample_ptr)cinfo->upsample;\n        upsample->spare_full = FALSE;\n        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n      } else {\n        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n        upsample->next_row_out = cinfo->max_v_samp_factor;\n        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n      }\n    }\n  }\n\n  /* Calculate how many full iMCU rows we can skip. */\n  if (cinfo->upsample->need_context_rows)\n    lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  else\n    lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  /* Calculate the number of lines that remain to be skipped after skipping all\n   * of the full iMCU rows that we can.  We will not read these lines unless we\n   * have to.\n   */\n  lines_to_read = lines_after_iMCU_row - lines_to_skip;\n\n  /* For images requiring multiple scans (progressive, non-interleaved, etc.),\n   * all of the entropy decoding occurs in jpeg_start_decompress(), assuming\n   * that the input data source is non-suspending.  This makes skipping easy.\n   */\n  if (cinfo->inputctl->has_multiple_scans) {\n    if (cinfo->upsample->need_context_rows) {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n      /* It is complex to properly move to the middle of a context block, so\n       * read the remaining lines instead of skipping them.\n       */\n      read_and_discard_scanlines(cinfo, lines_to_read);\n    } else {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n    }\n    if (master->using_merged_upsample) {\n      my_merged_upsample_ptr upsample =\n        (my_merged_upsample_ptr)cinfo->upsample;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    } else {\n      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n    return num_lines;\n  }\n\n  /* Skip the iMCU rows that we can safely skip. */\n  for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {\n    for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {\n      for (x = 0; x < cinfo->MCUs_per_row; x++) {\n        /* Calling decode_mcu() with a NULL pointer causes it to discard the\n         * decoded coefficients.  This is ~5% faster for large subsets, but\n         * it's tough to tell a difference for smaller images.\n         */\n        (*cinfo->entropy->decode_mcu) (cinfo, NULL);\n      }\n    }\n    cinfo->input_iMCU_row++;\n    cinfo->output_iMCU_row++;\n    if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)\n      start_iMCU_row(cinfo);\n    else\n      (*cinfo->inputctl->finish_input_pass) (cinfo);\n  }\n  cinfo->output_scanline += lines_to_skip;\n\n  if (cinfo->upsample->need_context_rows) {\n    /* Context-based upsampling keeps track of iMCU rows. */\n    main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n\n    /* It is complex to properly move to the middle of a context block, so\n     * read the remaining lines instead of skipping them.\n     */\n    read_and_discard_scanlines(cinfo, lines_to_read);\n  } else {\n    increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n  }\n\n  /* Since skipping lines involves skipping the upsampling step, the value of\n   * \"rows_to_go\" will become invalid unless we set it here.  NOTE: This is a\n   * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n   * output_scanline.\n   */\n  if (master->using_merged_upsample) {\n    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  } else {\n    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n  }\n\n  /* Always skip the requested number of lines. */\n  return num_lines;\n}",
    "abstract_func": "VAR_0(JDIMENSION)\njpeg_skip_scanlines(j_decompress_ptr VAR_1, JDIMENSION VAR_2)\n{\n  my_main_ptr VAR_3 = (my_main_ptr)VAR_1->main;\n  my_coef_ptr VAR_4 = (my_coef_ptr)VAR_1->coef;\n  my_master_ptr VAR_5 = (my_master_ptr)VAR_1->master;\n  JDIMENSION VAR_6, VAR_7;\n  int VAR_8;\n  JDIMENSION VAR_9, VAR_10, VAR_11;\n  JDIMENSION VAR_12, VAR_13;\n\n  if (VAR_1->global_state != VAR_14)\n    ERREXIT1(VAR_1, VAR_15, VAR_1->global_state);\n\n  /* COMMENT_0 */\n  if (VAR_1->output_scanline + VAR_2 >= VAR_1->output_height) {\n    VAR_1->output_scanline = VAR_1->output_height;\n    (*VAR_1->inputctl->finish_input_pass) (VAR_1);\n    VAR_1->inputctl->eoi_reached = TRUE;\n    return VAR_1->output_height - VAR_1->output_scanline;\n  }\n\n  if (VAR_2 == 0)\n    return 0;\n\n  VAR_9 = VAR_1->_min_DCT_scaled_size * VAR_1->max_v_samp_factor;\n  VAR_10 =\n    (VAR_9 - (VAR_1->output_scanline % VAR_9)) %\n    VAR_9;\n  VAR_11 = VAR_2 - VAR_10;\n\n  /* COMMENT_1 */\n                                                                               \n                                                 \n     \n  if (VAR_1->upsample->need_context_rows) {\n    /* COMMENT_5 */\n                                                                            \n                                                                             \n                                                                           \n                                                                             \n                                                                               \n                                                                              \n       \n    if ((VAR_2 < VAR_10 + 1) ||\n        (VAR_10 <= 1 && VAR_3->buffer_full &&\n         VAR_11 < VAR_9 + 1)) {\n      read_and_discard_scanlines(VAR_1, VAR_2);\n      return VAR_2;\n    }\n\n    /* COMMENT_13 */\n                              \n       \n    if (VAR_10 <= 1 && VAR_3->buffer_full) {\n      VAR_1->output_scanline += VAR_10 + VAR_9;\n      VAR_11 -= VAR_9;\n    } else {\n      VAR_1->output_scanline += VAR_10;\n    }\n\n    /* COMMENT_16 */\n    if (VAR_3->iMCU_row_ctr == 0 ||\n        (VAR_3->iMCU_row_ctr == 1 && VAR_10 > 2))\n      set_wraparound_pointers(VAR_1);\n    VAR_3->buffer_full = FALSE;\n    VAR_3->rowgroup_ctr = 0;\n    VAR_3->context_state = VAR_16;\n    if (VAR_5->using_merged_upsample) {\n      my_merged_upsample_ptr VAR_17 =\n        (my_merged_upsample_ptr)VAR_1->upsample;\n      VAR_17->spare_full = FALSE;\n      VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n    } else {\n      my_upsample_ptr VAR_17 = (my_upsample_ptr)VAR_1->upsample;\n      VAR_17->next_row_out = VAR_1->max_v_samp_factor;\n      VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n    }\n  }\n\n  /* COMMENT_17 */\n  else {\n    if (VAR_2 < VAR_10) {\n      increment_simple_rowgroup_ctr(VAR_1, VAR_2);\n      return VAR_2;\n    } else {\n      VAR_1->output_scanline += VAR_10;\n      VAR_3->buffer_full = FALSE;\n      VAR_3->rowgroup_ctr = 0;\n      if (VAR_5->using_merged_upsample) {\n        my_merged_upsample_ptr VAR_17 =\n          (my_merged_upsample_ptr)VAR_1->upsample;\n        VAR_17->spare_full = FALSE;\n        VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n      } else {\n        my_upsample_ptr VAR_17 = (my_upsample_ptr)VAR_1->upsample;\n        VAR_17->next_row_out = VAR_1->max_v_samp_factor;\n        VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n      }\n    }\n  }\n\n  /* COMMENT_18 */\n  if (VAR_1->upsample->need_context_rows)\n    VAR_12 = ((VAR_11 - 1) / VAR_9) *\n                    VAR_9;\n  else\n    VAR_12 = (VAR_11 / VAR_9) *\n                    VAR_9;\n  /* COMMENT_19 */\n                                                                               \n             \n     \n  VAR_13 = VAR_11 - VAR_12;\n\n  /* COMMENT_23 */\n                                                                            \n                                                                             \n     \n  if (VAR_1->inputctl->has_multiple_scans) {\n    if (VAR_1->upsample->need_context_rows) {\n      VAR_1->output_scanline += VAR_12;\n      VAR_1->output_iMCU_row += VAR_12 / VAR_9;\n      VAR_3->iMCU_row_ctr += VAR_12 / VAR_9;\n      /* COMMENT_27 */\n                                                           \n         \n      read_and_discard_scanlines(VAR_1, VAR_13);\n    } else {\n      VAR_1->output_scanline += VAR_12;\n      VAR_1->output_iMCU_row += VAR_12 / VAR_9;\n      increment_simple_rowgroup_ctr(VAR_1, VAR_13);\n    }\n    if (VAR_5->using_merged_upsample) {\n      my_merged_upsample_ptr VAR_17 =\n        (my_merged_upsample_ptr)VAR_1->upsample;\n      VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n    } else {\n      my_upsample_ptr VAR_17 = (my_upsample_ptr)VAR_1->upsample;\n      VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n    }\n    return VAR_2;\n  }\n\n  /* COMMENT_30 */\n  for (VAR_6 = 0; VAR_6 < VAR_12; VAR_6 += VAR_9) {\n    for (VAR_8 = 0; VAR_8 < VAR_4->MCU_rows_per_iMCU_row; VAR_8++) {\n      for (VAR_7 = 0; VAR_7 < VAR_1->MCUs_per_row; VAR_7++) {\n        /* COMMENT_31 */\n                                                                           \n                                                              \n           \n        (*VAR_1->entropy->decode_mcu) (VAR_1, NULL);\n      }\n    }\n    VAR_1->input_iMCU_row++;\n    VAR_1->output_iMCU_row++;\n    if (VAR_1->input_iMCU_row < VAR_1->total_iMCU_rows)\n      start_iMCU_row(VAR_1);\n    else\n      (*VAR_1->inputctl->finish_input_pass) (VAR_1);\n  }\n  VAR_1->output_scanline += VAR_12;\n\n  if (VAR_1->upsample->need_context_rows) {\n    /* COMMENT_35 */\n    VAR_3->iMCU_row_ctr += VAR_12 / VAR_9;\n\n    /* COMMENT_36 */\n                                                         \n       \n    read_and_discard_scanlines(VAR_1, VAR_13);\n  } else {\n    increment_simple_rowgroup_ctr(VAR_1, VAR_13);\n  }\n\n  /* COMMENT_39 */\n                                                                             \n                                                                         \n                     \n     \n  if (VAR_5->using_merged_upsample) {\n    my_merged_upsample_ptr VAR_17 = (my_merged_upsample_ptr)VAR_1->upsample;\n    VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n  } else {\n    my_upsample_ptr VAR_17 = (my_upsample_ptr)VAR_1->upsample;\n    VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;\n  }\n\n  /* COMMENT_44 */\n  return VAR_2;\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n   my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n   my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_master_ptr master = (my_master_ptr)cinfo->master;\n   JDIMENSION i, x;\n   int y;\n   JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n@@ -66,8 +66,16 @@\n     main_ptr->buffer_full = FALSE;\n     main_ptr->rowgroup_ctr = 0;\n     main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n-    upsample->next_row_out = cinfo->max_v_samp_factor;\n-    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    if (master->using_merged_upsample) {\n+      my_merged_upsample_ptr upsample =\n+        (my_merged_upsample_ptr)cinfo->upsample;\n+      upsample->spare_full = FALSE;\n+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    } else {\n+      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+      upsample->next_row_out = cinfo->max_v_samp_factor;\n+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    }\n   }\n \n   /* Skipping is much simpler when context rows are not required. */\n@@ -79,8 +87,16 @@\n       cinfo->output_scanline += lines_left_in_iMCU_row;\n       main_ptr->buffer_full = FALSE;\n       main_ptr->rowgroup_ctr = 0;\n-      upsample->next_row_out = cinfo->max_v_samp_factor;\n-      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+      if (master->using_merged_upsample) {\n+        my_merged_upsample_ptr upsample =\n+          (my_merged_upsample_ptr)cinfo->upsample;\n+        upsample->spare_full = FALSE;\n+        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+      } else {\n+        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+        upsample->next_row_out = cinfo->max_v_samp_factor;\n+        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+      }\n     }\n   }\n \n@@ -115,7 +131,14 @@\n       cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n       increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n     }\n-    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    if (master->using_merged_upsample) {\n+      my_merged_upsample_ptr upsample =\n+        (my_merged_upsample_ptr)cinfo->upsample;\n+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    } else {\n+      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+    }\n     return num_lines;\n   }\n \n@@ -156,7 +179,13 @@\n    * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n    * output_scanline.\n    */\n-  upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+  if (master->using_merged_upsample) {\n+    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n+    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+  } else {\n+    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n+  }\n \n   /* Always skip the requested number of lines. */\n   return num_lines;",
    "diff_line_info": {
        "deleted_lines": [
            "  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;",
            "    upsample->next_row_out = cinfo->max_v_samp_factor;",
            "    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "      upsample->next_row_out = cinfo->max_v_samp_factor;",
            "      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "  upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;"
        ],
        "added_lines": [
            "  my_master_ptr master = (my_master_ptr)cinfo->master;",
            "    if (master->using_merged_upsample) {",
            "      my_merged_upsample_ptr upsample =",
            "        (my_merged_upsample_ptr)cinfo->upsample;",
            "      upsample->spare_full = FALSE;",
            "      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "    } else {",
            "      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;",
            "      upsample->next_row_out = cinfo->max_v_samp_factor;",
            "      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "    }",
            "      if (master->using_merged_upsample) {",
            "        my_merged_upsample_ptr upsample =",
            "          (my_merged_upsample_ptr)cinfo->upsample;",
            "        upsample->spare_full = FALSE;",
            "        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "      } else {",
            "        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;",
            "        upsample->next_row_out = cinfo->max_v_samp_factor;",
            "        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "      }",
            "    if (master->using_merged_upsample) {",
            "      my_merged_upsample_ptr upsample =",
            "        (my_merged_upsample_ptr)cinfo->upsample;",
            "      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "    } else {",
            "      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;",
            "      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "    }",
            "  if (master->using_merged_upsample) {",
            "    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;",
            "    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "  } else {",
            "    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;",
            "    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;",
            "  }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}