{
    "cve_id": "CVE-2019-20636",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "Input: add safety guards to input_set_keycode()\n\nIf we happen to have a garbage in input device's keycode table with values\ntoo big we'll end up doing clear_bit() with offset way outside of our\nbitmaps, damaging other objects within an input device or even outside of\nit. Let's add sanity checks to the returned old keycodes.\n\nReported-by: syzbot+c769968809f9359b07aa@syzkaller.appspotmail.com\nReported-by: syzbot+76f3a30e88d256644c78@syzkaller.appspotmail.com\nLink: https://lore.kernel.org/r/20191207212757.GA245964@dtor-ws\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",
    "commit_hash": "cb222aed03d798fc074be55e59d9a112338ee784",
    "git_url": "https://github.com/torvalds/linux/commit/cb222aed03d798fc074be55e59d9a112338ee784",
    "file_path": "drivers/input/input.c",
    "func_name": "input_set_keycode",
    "func_before": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\n\t/* Make sure KEY_RESERVED did not get enabled. */\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\t/*\n\t * Simulate keyup event if keycode is not present\n\t * in the keymap anymore\n\t */\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn retval;\n}",
    "abstract_func_before": "int input_set_keycode(struct input_dev *VAR_0,\n\t\t      const struct input_keymap_entry *VAR_1)\n{\n\tunsigned long VAR_2;\n\tunsigned int VAR_3;\n\tint VAR_4;\n\n\tif (VAR_1->keycode > VAR_5)\n\t\treturn -VAR_6;\n\n\tspin_lock_irqsave(&VAR_0->event_lock, VAR_2);\n\n\tVAR_4 = VAR_0->setkeycode(VAR_0, VAR_1, &VAR_3);\n\tif (VAR_4)\n\t\tgoto out;\n\n\t/* COMMENT_0 */\n\t__clear_bit(VAR_7, VAR_0->keybit);\n\n\t/* COMMENT_1 */\n                                                  \n                         \n    \n\tif (test_bit(VAR_8, VAR_0->evbit) &&\n\t    !is_event_supported(VAR_3, VAR_0->keybit, VAR_5) &&\n\t    __test_and_clear_bit(VAR_3, VAR_0->key)) {\n\t\tstruct input_value VAR_9[] =  {\n\t\t\t{ VAR_8, VAR_3, 0 },\n\t\t\tVAR_10\n\t\t};\n\n\t\tinput_pass_values(VAR_0, VAR_9, ARRAY_SIZE(VAR_9));\n\t}\n\n out:\n\tspin_unlock_irqrestore(&VAR_0->event_lock, VAR_2);\n\n\treturn VAR_4;\n}",
    "func_graph_path_before": "torvalds/linux/cb222aed03d798fc074be55e59d9a112338ee784/input.c/vul/before/0.json",
    "func": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\n\t/* Make sure KEY_RESERVED did not get enabled. */\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\t/*\n\t * Simulate keyup event if keycode is not present\n\t * in the keymap anymore\n\t */\n\tif (old_keycode > KEY_MAX) {\n\t\tdev_warn(dev->dev.parent ?: &dev->dev,\n\t\t\t \"%s: got too big old keycode %#x\\n\",\n\t\t\t __func__, old_keycode);\n\t} else if (test_bit(EV_KEY, dev->evbit) &&\n\t\t   !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t\t   __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn retval;\n}",
    "abstract_func": "int input_set_keycode(struct input_dev *VAR_0,\n\t\t      const struct input_keymap_entry *VAR_1)\n{\n\tunsigned long VAR_2;\n\tunsigned int VAR_3;\n\tint VAR_4;\n\n\tif (VAR_1->keycode > VAR_5)\n\t\treturn -VAR_6;\n\n\tspin_lock_irqsave(&VAR_0->event_lock, VAR_2);\n\n\tVAR_4 = VAR_0->setkeycode(VAR_0, VAR_1, &VAR_3);\n\tif (VAR_4)\n\t\tgoto out;\n\n\t/* COMMENT_0 */\n\t__clear_bit(VAR_7, VAR_0->keybit);\n\n\t/* COMMENT_1 */\n                                                  \n                         \n    \n\tif (VAR_3 > VAR_5) {\n\t\tdev_warn(VAR_0->dev.parent ?VAR_8: &VAR_0->dev,\n\t\t\t \"%s: got too big old keycode %#x\\n\",\n\t\t\t VAR_9, VAR_3);\n\t} else if (test_bit(VAR_10, VAR_0->evbit) &&\n\t\t   !is_event_supported(VAR_3, VAR_0->keybit, VAR_5) &&\n\t\t   __test_and_clear_bit(VAR_3, VAR_0->key)) {\n\t\tstruct input_value VAR_11[] =  {\n\t\t\t{ VAR_10, VAR_3, 0 },\n\t\t\tVAR_12\n\t\t};\n\n\t\tinput_pass_values(VAR_0, VAR_11, ARRAY_SIZE(VAR_11));\n\t}\n\n out:\n\tspin_unlock_irqrestore(&VAR_0->event_lock, VAR_2);\n\n\treturn VAR_4;\n}",
    "func_graph_path": "torvalds/linux/cb222aed03d798fc074be55e59d9a112338ee784/input.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -21,9 +21,13 @@\n \t * Simulate keyup event if keycode is not present\n \t * in the keymap anymore\n \t */\n-\tif (test_bit(EV_KEY, dev->evbit) &&\n-\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n-\t    __test_and_clear_bit(old_keycode, dev->key)) {\n+\tif (old_keycode > KEY_MAX) {\n+\t\tdev_warn(dev->dev.parent ?: &dev->dev,\n+\t\t\t \"%s: got too big old keycode %#x\\n\",\n+\t\t\t __func__, old_keycode);\n+\t} else if (test_bit(EV_KEY, dev->evbit) &&\n+\t\t   !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n+\t\t   __test_and_clear_bit(old_keycode, dev->key)) {\n \t\tstruct input_value vals[] =  {\n \t\t\t{ EV_KEY, old_keycode, 0 },\n \t\t\tinput_value_sync",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (test_bit(EV_KEY, dev->evbit) &&",
            "\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&",
            "\t    __test_and_clear_bit(old_keycode, dev->key)) {"
        ],
        "added_lines": [
            "\tif (old_keycode > KEY_MAX) {",
            "\t\tdev_warn(dev->dev.parent ?: &dev->dev,",
            "\t\t\t \"%s: got too big old keycode %#x\\n\",",
            "\t\t\t __func__, old_keycode);",
            "\t} else if (test_bit(EV_KEY, dev->evbit) &&",
            "\t\t   !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&",
            "\t\t   __test_and_clear_bit(old_keycode, dev->key)) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}