{
    "cve_id": "CVE-2018-10853",
    "cwe_ids": [
        "CWE-269"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "The functions that were used in the emulation of fxrstor, fxsave, sgdt and\nsidt were originally meant for task switching, and as such they did not\ncheck privilege levels.  This is very bad when the same functions are used\nin the emulation of unprivileged instructions.  This is CVE-2018-10853.\n\nThe obvious fix is to add a new argument to ops->read_std and ops->write_std,\nwhich decides whether the access is a \"system\" access or should use the\nprocessor's CPL.\n\nFixes: 129a72a0d3c8 (\"KVM: x86: Introduce segmented_write_std\", 2017-01-12)\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n",
    "commit_hash": "3c9fa24ca7c9c47605672916491f79e8ccacb9e6",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3c9fa24ca7c9c47605672916491f79e8ccacb9e6",
    "file_path": "arch/x86/kvm/emulate.c",
    "func_name": "emulator_io_port_access_allowed",
    "func_before": "static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\t/*\n\t * VMware allows access to these ports even if denied\n\t * by TSS I/O permission bitmap. Mimic behavior.\n\t */\n\tif (enable_vmware_backdoor &&\n\t    ((port == VMWARE_PORT_VMPORT) || (port == VMWARE_PORT_VMRPC)))\n\t\treturn true;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}",
    "abstract_func_before": "static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *VAR_0,\n\t\t\t\t\t    u16 VAR_1, u16 VAR_2)\n{\n\tconst struct x86_emulate_ops *VAR_3 = VAR_0->ops;\n\tstruct desc_struct VAR_4;\n\tu32 VAR_5;\n\tint VAR_6;\n\tu16 VAR_7, VAR_8, VAR_9, VAR_10 = VAR_1 & 0x7;\n\tunsigned VAR_11 = (1 << VAR_2) - 1;\n\tunsigned long VAR_12;\n\n\t/* COMMENT_0 */\n                                                      \n                                                 \n    \n\tif (VAR_13 &&\n\t    ((VAR_1 == VAR_14) || (VAR_1 == VAR_15)))\n\t\treturn true;\n\n\tVAR_3->get_segment(VAR_0, &VAR_7, &VAR_4, &VAR_5, VAR_16);\n\tif (!VAR_4.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&VAR_4) < 103)\n\t\treturn false;\n\tVAR_12 = get_desc_base(&VAR_4);\n#ifdef VAR_17\n\tVAR_12 |= ((u64)VAR_5) << 32;\n#endif\n\tVAR_6 = VAR_3->read_std(VAR_0, VAR_12 + 102, &VAR_8, 2, NULL);\n\tif (VAR_6 != VAR_18)\n\t\treturn false;\n\tif (VAR_8 + VAR_1/8 > desc_limit_scaled(&VAR_4))\n\t\treturn false;\n\tVAR_6 = VAR_3->read_std(VAR_0, VAR_12 + VAR_8 + VAR_1/8, &VAR_9, 2, NULL);\n\tif (VAR_6 != VAR_18)\n\t\treturn false;\n\tif ((VAR_9 >> VAR_10) & VAR_11)\n\t\treturn false;\n\treturn true;\n}",
    "func_graph_path_before": "torvalds/linux/3c9fa24ca7c9c47605672916491f79e8ccacb9e6/emulate.c/vul/before/3.json",
    "func": "static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\t/*\n\t * VMware allows access to these ports even if denied\n\t * by TSS I/O permission bitmap. Mimic behavior.\n\t */\n\tif (enable_vmware_backdoor &&\n\t    ((port == VMWARE_PORT_VMPORT) || (port == VMWARE_PORT_VMRPC)))\n\t\treturn true;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL, true);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL, true);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}",
    "abstract_func": "static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *VAR_0,\n\t\t\t\t\t    u16 VAR_1, u16 VAR_2)\n{\n\tconst struct x86_emulate_ops *VAR_3 = VAR_0->ops;\n\tstruct desc_struct VAR_4;\n\tu32 VAR_5;\n\tint VAR_6;\n\tu16 VAR_7, VAR_8, VAR_9, VAR_10 = VAR_1 & 0x7;\n\tunsigned VAR_11 = (1 << VAR_2) - 1;\n\tunsigned long VAR_12;\n\n\t/* COMMENT_0 */\n                                                      \n                                                 \n    \n\tif (VAR_13 &&\n\t    ((VAR_1 == VAR_14) || (VAR_1 == VAR_15)))\n\t\treturn true;\n\n\tVAR_3->get_segment(VAR_0, &VAR_7, &VAR_4, &VAR_5, VAR_16);\n\tif (!VAR_4.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&VAR_4) < 103)\n\t\treturn false;\n\tVAR_12 = get_desc_base(&VAR_4);\n#ifdef VAR_17\n\tVAR_12 |= ((u64)VAR_5) << 32;\n#endif\n\tVAR_6 = VAR_3->read_std(VAR_0, VAR_12 + 102, &VAR_8, 2, NULL, true);\n\tif (VAR_6 != VAR_18)\n\t\treturn false;\n\tif (VAR_8 + VAR_1/8 > desc_limit_scaled(&VAR_4))\n\t\treturn false;\n\tVAR_6 = VAR_3->read_std(VAR_0, VAR_12 + VAR_8 + VAR_1/8, &VAR_9, 2, NULL, true);\n\tif (VAR_6 != VAR_18)\n\t\treturn false;\n\tif ((VAR_9 >> VAR_10) & VAR_11)\n\t\treturn false;\n\treturn true;\n}",
    "func_graph_path": "torvalds/linux/3c9fa24ca7c9c47605672916491f79e8ccacb9e6/emulate.c/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -26,12 +26,12 @@\n #ifdef CONFIG_X86_64\n \tbase |= ((u64)base3) << 32;\n #endif\n-\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n+\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL, true);\n \tif (r != X86EMUL_CONTINUE)\n \t\treturn false;\n \tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n \t\treturn false;\n-\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n+\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL, true);\n \tif (r != X86EMUL_CONTINUE)\n \t\treturn false;\n \tif ((perm >> bit_idx) & mask)",
    "diff_line_info": {
        "deleted_lines": [
            "\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);",
            "\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);"
        ],
        "added_lines": [
            "\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL, true);",
            "\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL, true);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}