{
    "cve_id": "CVE-2020-13113",
    "cwe_ids": [
        "CWE-908"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "libexif",
    "commit_msg": "Ensure the MakerNote data pointers are initialized with NULL.\n\nThis ensures that an uninitialized pointer isn't dereferenced later in\nthe case where the number of components (and therefore size) is 0.\n\nThis fixes the second issue reported at\nhttps://sourceforge.net/p/libexif/bugs/125/\n\nCVE-2020-13113",
    "commit_hash": "ec412aa4583ad71ecabb967d3c77162760169d1f",
    "git_url": "https://github.com/libexif/libexif/commit/ec412aa4583ad71ecabb967d3c77162760169d1f",
    "file_path": "libexif/pentax/exif-mnote-data-pentax.c",
    "func_name": "exif_mnote_data_pentax_load",
    "func_before": "static void\nexif_mnote_data_pentax_load (ExifMnoteData *en,\n\t\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;\n\tsize_t i, tcount, o, datao, base = 0;\n\tExifShort c;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 8)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Detect variant of Pentax/Casio MakerNote found */\n\tif (!memcmp(buf + datao, \"AOC\", 4)) {\n\t\tif ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t} else {\n\t\t\t/* Uses Casio v2 tags */\n\t\t\tn->version = pentaxV2;\n\t\t}\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v%d...\", (int)n->version);\n\t\tdatao += 4 + 2;\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t} else if (!memcmp(buf + datao, \"QVC\", 4)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Casio maker note v2...\");\n\t\tn->version = casioV2;\n\t\tbase = MNOTE_CASIO2_TAG_BASE;\n\t\tdatao += 4 + 2;\n\t} else {\n\t\t/* probably assert(!memcmp(buf + datao, \"\\x00\\x1b\", 2)) */\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v1...\");\n\t\tn->version = pentaxV1;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_pentax_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", sizeof (MnotePentaxEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnotePentax\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t  mnote_pentax_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) *\n                                      n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4)\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t   \tdataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag data past end \"\n\t\t\t\t\t  \"of buffer (%u > %u)\", (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}",
    "abstract_func_before": "static void\nexif_mnote_data_pentax_load (ExifMnoteData *VAR_0,\n\t\tconst unsigned char *VAR_1, unsigned int VAR_2)\n{\n\tExifMnoteDataPentax *VAR_3 = (ExifMnoteDataPentax *) VAR_0;\n\tsize_t VAR_4, VAR_5, VAR_6, VAR_7, VAR_8 = 0;\n\tExifShort VAR_9;\n\n\tif (!VAR_3 || !VAR_1 || !VAR_2) {\n\t\texif_log (VAR_0->log, VAR_10,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tVAR_7 = 6 + VAR_3->offset;\n\tif (CHECKOVERFLOW(VAR_7, VAR_2, 8)) {\n\t\texif_log (VAR_0->log, VAR_10,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* COMMENT_0 */\n\tif (!memcmp(VAR_1 + VAR_7, \"AOC\", 4)) {\n\t\tif ((VAR_1[VAR_7 + 4] == 'I') && (VAR_1[VAR_7 + 5] == 'I')) {\n\t\t\tVAR_3->version = VAR_11;\n\t\t\tVAR_3->order = VAR_12;\n\t\t} else if ((VAR_1[VAR_7 + 4] == 'M') && (VAR_1[VAR_7 + 5] == 'M')) {\n\t\t\tVAR_3->version = VAR_11;\n\t\t\tVAR_3->order = VAR_13;\n\t\t} else {\n\t\t\t/* COMMENT_1 */\n\t\t\tVAR_3->version = VAR_14;\n\t\t}\n\t\texif_log (VAR_0->log, VAR_15, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v%d...\", (int)VAR_3->version);\n\t\tVAR_7 += 4 + 2;\n\t\tVAR_8 = VAR_16;\n\t} else if (!memcmp(VAR_1 + VAR_7, \"QVC\", 4)) {\n\t\texif_log (VAR_0->log, VAR_15, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Casio maker note v2...\");\n\t\tVAR_3->version = VAR_17;\n\t\tVAR_8 = VAR_18;\n\t\tVAR_7 += 4 + 2;\n\t} else {\n\t\t/* COMMENT_2 */\n\t\texif_log (VAR_0->log, VAR_15, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v1...\");\n\t\tVAR_3->version = VAR_19;\n\t}\n\n\t/* COMMENT_3 */\n\tVAR_9 = exif_get_short (VAR_1 + VAR_7, VAR_3->order);\n\tVAR_7 += 2;\n\n\t/* COMMENT_4 */\n\texif_mnote_data_pentax_clear (VAR_3);\n\n\t/* COMMENT_5 */\n\tVAR_3->entries = exif_mem_alloc (VAR_0->mem, sizeof (VAR_20) * VAR_9);\n\tif (!VAR_3->entries) {\n\t\tEXIF_LOG_NO_MEMORY(VAR_0->log, \"ExifMnoteDataPentax\", sizeof (VAR_20) * VAR_9);\n\t\treturn;\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_5 = 0;\n\tfor (VAR_4 = VAR_9, VAR_6 = VAR_7; VAR_4; --VAR_4, VAR_6 += 12) {\n\t\tsize_t VAR_21;\n\n\t\tif (CHECKOVERFLOW(VAR_6,VAR_2,12)) {\n\t\t\texif_log (VAR_0->log, VAR_10,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_3->entries[VAR_5].tag        = exif_get_short (VAR_1 + VAR_6 + 0, VAR_3->order) + VAR_8;\n\t\tVAR_3->entries[VAR_5].format     = exif_get_short (VAR_1 + VAR_6 + 2, VAR_3->order);\n\t\tVAR_3->entries[VAR_5].components = exif_get_long  (VAR_1 + VAR_6 + 4, VAR_3->order);\n\t\tVAR_3->entries[VAR_5].order      = VAR_3->order;\n\n\t\texif_log (VAR_0->log, VAR_15, \"ExifMnotePentax\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", VAR_3->entries[VAR_5].tag,\n\t\t\t  mnote_pentax_tag_get_name (VAR_3->entries[VAR_5].tag));\n\n\t\t/* COMMENT_7 */\n                                                    \n\t\tif (\texif_format_get_size (VAR_3->entries[VAR_5].format) &&\n\t\t\tVAR_2 / exif_format_get_size (VAR_3->entries[VAR_5].format) < VAR_3->entries[VAR_5].components\n\t\t) {\n\t\t\texif_log (VAR_0->log, VAR_10,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (VAR_3->entries[VAR_5].format), VAR_3->entries[VAR_5].components);\n\t\t\tbreak;\n\t\t}\n\t\t/* COMMENT_9 */\n                                                         \n                                              \n     \n\t\tVAR_21 = exif_format_get_size (VAR_3->entries[VAR_5].format) *\n                                      VAR_3->entries[VAR_5].components;\n\t\tVAR_3->entries[VAR_5].size = VAR_21;\n\t\tif (VAR_21) {\n\t\t\tsize_t VAR_22 = VAR_6 + 8;\n\t\t\tif (VAR_21 > 4)\n\t\t\t\t/* COMMENT_13 */\n\t\t\t   \tVAR_22 = exif_get_long (VAR_1 + VAR_22, VAR_3->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(VAR_22, VAR_2, VAR_21)) {\n\t\t\t\texif_log (VAR_0->log, VAR_15,\n\t\t\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag data past end \"\n\t\t\t\t\t  \"of buffer (%u > %u)\", (unsigned)(VAR_22 + VAR_21), VAR_2);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tVAR_3->entries[VAR_5].data = exif_mem_alloc (VAR_0->mem, VAR_21);\n\t\t\tif (!VAR_3->entries[VAR_5].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(VAR_0->log, \"ExifMnoteDataPentax\", VAR_21);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (VAR_3->entries[VAR_5].data, VAR_1 + VAR_22, VAR_21);\n\t\t}\n\n\t\t/* COMMENT_14 */\n\t\t++VAR_5;\n\t}\n\t/* COMMENT_15 */\n\tVAR_3->count = VAR_5;\n}",
    "func_graph_path_before": "libexif/ec412aa4583ad71ecabb967d3c77162760169d1f/exif-mnote-data-pentax.c/vul/before/0.json",
    "func": "static void\nexif_mnote_data_pentax_load (ExifMnoteData *en,\n\t\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;\n\tsize_t i, tcount, o, datao, base = 0;\n\tExifShort c;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 8)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Detect variant of Pentax/Casio MakerNote found */\n\tif (!memcmp(buf + datao, \"AOC\", 4)) {\n\t\tif ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t} else {\n\t\t\t/* Uses Casio v2 tags */\n\t\t\tn->version = pentaxV2;\n\t\t}\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v%d...\", (int)n->version);\n\t\tdatao += 4 + 2;\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t} else if (!memcmp(buf + datao, \"QVC\", 4)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Casio maker note v2...\");\n\t\tn->version = casioV2;\n\t\tbase = MNOTE_CASIO2_TAG_BASE;\n\t\tdatao += 4 + 2;\n\t} else {\n\t\t/* probably assert(!memcmp(buf + datao, \"\\x00\\x1b\", 2)) */\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v1...\");\n\t\tn->version = pentaxV1;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_pentax_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", sizeof (MnotePentaxEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnotePentaxEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnotePentax\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t  mnote_pentax_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) *\n                                      n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4)\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t   \tdataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag data past end \"\n\t\t\t\t\t  \"of buffer (%u > %u)\", (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}",
    "abstract_func": "static void\nexif_mnote_data_pentax_load (ExifMnoteData *VAR_0,\n\t\tconst unsigned char *VAR_1, unsigned int VAR_2)\n{\n\tExifMnoteDataPentax *VAR_3 = (ExifMnoteDataPentax *) VAR_0;\n\tsize_t VAR_4, VAR_5, VAR_6, VAR_7, VAR_8 = 0;\n\tExifShort VAR_9;\n\n\tif (!VAR_3 || !VAR_1 || !VAR_2) {\n\t\texif_log (VAR_0->log, VAR_10,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tVAR_7 = 6 + VAR_3->offset;\n\tif (CHECKOVERFLOW(VAR_7, VAR_2, 8)) {\n\t\texif_log (VAR_0->log, VAR_10,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* COMMENT_0 */\n\tif (!memcmp(VAR_1 + VAR_7, \"AOC\", 4)) {\n\t\tif ((VAR_1[VAR_7 + 4] == 'I') && (VAR_1[VAR_7 + 5] == 'I')) {\n\t\t\tVAR_3->version = VAR_11;\n\t\t\tVAR_3->order = VAR_12;\n\t\t} else if ((VAR_1[VAR_7 + 4] == 'M') && (VAR_1[VAR_7 + 5] == 'M')) {\n\t\t\tVAR_3->version = VAR_11;\n\t\t\tVAR_3->order = VAR_13;\n\t\t} else {\n\t\t\t/* COMMENT_1 */\n\t\t\tVAR_3->version = VAR_14;\n\t\t}\n\t\texif_log (VAR_0->log, VAR_15, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v%d...\", (int)VAR_3->version);\n\t\tVAR_7 += 4 + 2;\n\t\tVAR_8 = VAR_16;\n\t} else if (!memcmp(VAR_1 + VAR_7, \"QVC\", 4)) {\n\t\texif_log (VAR_0->log, VAR_15, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Casio maker note v2...\");\n\t\tVAR_3->version = VAR_17;\n\t\tVAR_8 = VAR_18;\n\t\tVAR_7 += 4 + 2;\n\t} else {\n\t\t/* COMMENT_2 */\n\t\texif_log (VAR_0->log, VAR_15, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v1...\");\n\t\tVAR_3->version = VAR_19;\n\t}\n\n\t/* COMMENT_3 */\n\tVAR_9 = exif_get_short (VAR_1 + VAR_7, VAR_3->order);\n\tVAR_7 += 2;\n\n\t/* COMMENT_4 */\n\texif_mnote_data_pentax_clear (VAR_3);\n\n\t/* COMMENT_5 */\n\tVAR_3->entries = exif_mem_alloc (VAR_0->mem, sizeof (VAR_20) * VAR_9);\n\tif (!VAR_3->entries) {\n\t\tEXIF_LOG_NO_MEMORY(VAR_0->log, \"ExifMnoteDataPentax\", sizeof (VAR_20) * VAR_9);\n\t\treturn;\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_5 = 0;\n\tfor (VAR_4 = VAR_9, VAR_6 = VAR_7; VAR_4; --VAR_4, VAR_6 += 12) {\n\t\tsize_t VAR_21;\n\n\t\tmemset(&VAR_3->entries[VAR_5], 0, sizeof(VAR_20));\n\t\tif (CHECKOVERFLOW(VAR_6,VAR_2,12)) {\n\t\t\texif_log (VAR_0->log, VAR_10,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_3->entries[VAR_5].tag        = exif_get_short (VAR_1 + VAR_6 + 0, VAR_3->order) + VAR_8;\n\t\tVAR_3->entries[VAR_5].format     = exif_get_short (VAR_1 + VAR_6 + 2, VAR_3->order);\n\t\tVAR_3->entries[VAR_5].components = exif_get_long  (VAR_1 + VAR_6 + 4, VAR_3->order);\n\t\tVAR_3->entries[VAR_5].order      = VAR_3->order;\n\n\t\texif_log (VAR_0->log, VAR_15, \"ExifMnotePentax\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", VAR_3->entries[VAR_5].tag,\n\t\t\t  mnote_pentax_tag_get_name (VAR_3->entries[VAR_5].tag));\n\n\t\t/* COMMENT_7 */\n                                                    \n\t\tif (\texif_format_get_size (VAR_3->entries[VAR_5].format) &&\n\t\t\tVAR_2 / exif_format_get_size (VAR_3->entries[VAR_5].format) < VAR_3->entries[VAR_5].components\n\t\t) {\n\t\t\texif_log (VAR_0->log, VAR_10,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (VAR_3->entries[VAR_5].format), VAR_3->entries[VAR_5].components);\n\t\t\tbreak;\n\t\t}\n\t\t/* COMMENT_9 */\n                                                         \n                                              \n     \n\t\tVAR_21 = exif_format_get_size (VAR_3->entries[VAR_5].format) *\n                                      VAR_3->entries[VAR_5].components;\n\t\tVAR_3->entries[VAR_5].size = VAR_21;\n\t\tif (VAR_21) {\n\t\t\tsize_t VAR_22 = VAR_6 + 8;\n\t\t\tif (VAR_21 > 4)\n\t\t\t\t/* COMMENT_13 */\n\t\t\t   \tVAR_22 = exif_get_long (VAR_1 + VAR_22, VAR_3->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(VAR_22, VAR_2, VAR_21)) {\n\t\t\t\texif_log (VAR_0->log, VAR_15,\n\t\t\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag data past end \"\n\t\t\t\t\t  \"of buffer (%u > %u)\", (unsigned)(VAR_22 + VAR_21), VAR_2);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tVAR_3->entries[VAR_5].data = exif_mem_alloc (VAR_0->mem, VAR_21);\n\t\t\tif (!VAR_3->entries[VAR_5].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(VAR_0->log, \"ExifMnoteDataPentax\", VAR_21);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (VAR_3->entries[VAR_5].data, VAR_1 + VAR_22, VAR_21);\n\t\t}\n\n\t\t/* COMMENT_14 */\n\t\t++VAR_5;\n\t}\n\t/* COMMENT_15 */\n\tVAR_3->count = VAR_5;\n}",
    "func_graph_path": "libexif/ec412aa4583ad71ecabb967d3c77162760169d1f/exif-mnote-data-pentax.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -66,6 +66,7 @@\n \tfor (i = c, o = datao; i; --i, o += 12) {\n \t\tsize_t s;\n \n+\t\tmemset(&n->entries[tcount], 0, sizeof(MnotePentaxEntry));\n \t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n \t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\tmemset(&n->entries[tcount], 0, sizeof(MnotePentaxEntry));"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}