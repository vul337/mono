{
    "cve_id": "CVE-2022-21656",
    "cwe_ids": [
        "CWE-843"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "envoyproxy/envoy",
    "commit_msg": "Specify type for matching Subject Alternative Name. (#18628)\n\n\r\nSigned-off-by: Pradeep Rao <pcrao@google.com>",
    "commit_hash": "bb95af848c939cfe5b5ee33c5b1770558077e64e",
    "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
    "file_path": "source/extensions/transport_sockets/tls/cert_validator/default_validator.cc",
    "func_name": "DefaultCertValidator::initializeSslContexts",
    "func_before": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                                bool provides_certificates) {\n\n  int verify_mode = SSL_VERIFY_NONE;\n  int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n  if (config_ != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification verification = config_->trustChainVerification();\n    if (verification == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      verify_mode = SSL_VERIFY_PEER; // Ensure client-certs will be requested even if we have\n                                     // nothing to verify against\n      verify_mode_validation_context = SSL_VERIFY_PEER;\n    }\n  }\n\n  if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) {\n    ca_file_path_ = config_->caCertPath();\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      bool has_crl = false;\n      for (const X509_INFO* item : list.get()) {\n        if (item->x509) {\n          X509_STORE_add_cert(store, item->x509);\n          if (ca_cert_ == nullptr) {\n            X509_up_ref(item->x509);\n            ca_cert_.reset(item->x509);\n          }\n        }\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n          has_crl = true;\n        }\n      }\n      if (ca_cert_ == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n      }\n      if (has_crl) {\n        X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                        ? X509_V_FLAG_CRL_CHECK\n                                        : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n      }\n      verify_mode = SSL_VERIFY_PEER;\n      verify_trusted_ca_ = true;\n\n      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()\n      // directly. However, our new callback is still calling X509_verify_cert() under\n      // the hood. Therefore, to ignore cert expiration, we need to set the callback\n      // for X509_verify_cert to ignore that error.\n      if (config_->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (config_ != nullptr && !config_->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()),\n                        config_->certificateRevocationList().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", config_->certificateRevocationListPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      for (const X509_INFO* item : list.get()) {\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n        }\n      }\n      X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                      ? X509_V_FLAG_CRL_CHECK\n                                      : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n  if (cert_validation_config != nullptr) {\n    if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n      for (const envoy::type::matcher::v3::StringMatcher& matcher :\n           cert_validation_config->subjectAltNameMatchers()) {\n        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateHashList().empty()) {\n      for (auto hash : cert_validation_config->verifyCertificateHashList()) {\n        // Remove colons from the 95 chars long colon-separated \"fingerprint\"\n        // in order to get the hex-encoded string.\n        if (hash.size() == 95) {\n          hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end());\n        }\n        const auto& decoded = Hex::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", hash));\n        }\n        verify_certificate_hash_list_.push_back(decoded);\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateSpkiList().empty()) {\n      for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) {\n        const auto decoded = Base64::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", hash));\n        }\n        verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end());\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n  }\n\n  return verify_mode;\n}",
    "abstract_func_before": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> VAR_0,\n                                                bool VAR_1) {\n\n  int VAR_2 = VAR_3;\n  int VAR_4 = VAR_5 | VAR_6;\n\n  if (VAR_7 != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification VAR_8 = VAR_7->trustChainVerification();\n    if (VAR_8 == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      VAR_2 = VAR_5; /* COMMENT_0 */\n                                     /* COMMENT_1 */\n      VAR_4 = VAR_5;\n    }\n  }\n\n  if (VAR_7 != nullptr && !VAR_7->caCert().empty() && !VAR_1) {\n    VAR_9 = VAR_7->caCertPath();\n    bssl::UniquePtr<BIO> VAR_10(\n        BIO_new_mem_buf(VAR_11<char*>(VAR_7->caCert().data()), VAR_7->caCert().size()));\n    RELEASE_ASSERT(VAR_10 != nullptr, \"\");\n    /* COMMENT_2 */\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_12(\n        PEM_X509_INFO_read_bio(VAR_10.get(), nullptr, nullptr, nullptr));\n    if (VAR_12 == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", VAR_7->caCertPath()));\n    }\n\n    for (auto& VAR_13 : VAR_0) {\n      X509_STORE* VAR_14 = SSL_CTX_get_cert_store(VAR_13);\n      bool VAR_15 = false;\n      for (const X509_INFO* VAR_16 : VAR_12.get()) {\n        if (VAR_16->x509) {\n          X509_STORE_add_cert(VAR_14, VAR_16->x509);\n          if (VAR_17 == nullptr) {\n            X509_up_ref(VAR_16->x509);\n            VAR_17.reset(VAR_16->x509);\n          }\n        }\n        if (VAR_16->crl) {\n          X509_STORE_add_crl(VAR_14, VAR_16->crl);\n          VAR_15 = true;\n        }\n      }\n      if (VAR_17 == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", VAR_7->caCertPath()));\n      }\n      if (VAR_15) {\n        X509_STORE_set_flags(VAR_14, VAR_7->onlyVerifyLeafCertificateCrl()\n                                        ? VAR_18\n                                        : VAR_18 | VAR_19);\n      }\n      VAR_2 = VAR_5;\n      VAR_20 = true;\n\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n      if (VAR_7->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(VAR_14, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (VAR_7 != nullptr && !VAR_7->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> VAR_10(\n        BIO_new_mem_buf(VAR_11<char*>(VAR_7->certificateRevocationList().data()),\n                        VAR_7->certificateRevocationList().size()));\n    RELEASE_ASSERT(VAR_10 != nullptr, \"\");\n\n    /* COMMENT_2 */\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_12(\n        PEM_X509_INFO_read_bio(VAR_10.get(), nullptr, nullptr, nullptr));\n    if (VAR_12 == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", VAR_7->certificateRevocationListPath()));\n    }\n\n    for (auto& VAR_13 : VAR_0) {\n      X509_STORE* VAR_14 = SSL_CTX_get_cert_store(VAR_13);\n      for (const X509_INFO* VAR_16 : VAR_12.get()) {\n        if (VAR_16->crl) {\n          X509_STORE_add_crl(VAR_14, VAR_16->crl);\n        }\n      }\n      X509_STORE_set_flags(VAR_14, VAR_7->onlyVerifyLeafCertificateCrl()\n                                      ? VAR_18\n                                      : VAR_18 | VAR_19);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* VAR_21 = VAR_7;\n  if (VAR_21 != nullptr) {\n    if (!VAR_21->subjectAltNameMatchers().empty()) {\n      for (const envoy::type::matcher::v3::StringMatcher& VAR_22 :\n           VAR_21->subjectAltNameMatchers()) {\n        VAR_23.push_back(Matchers::StringMatcherImpl(VAR_22));\n      }\n      VAR_2 = VAR_4;\n    }\n\n    if (!VAR_21->verifyCertificateHashList().empty()) {\n      for (auto VAR_24 : VAR_21->verifyCertificateHashList()) {\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_24.size() == 95) {\n          VAR_24.erase(std::remove(VAR_24.begin(), VAR_24.end(), ':'), VAR_24.end());\n        }\n        const auto& VAR_25 = Hex::decode(VAR_24);\n        if (VAR_25.size() != VAR_26) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", VAR_24));\n        }\n        VAR_27.push_back(VAR_25);\n      }\n      VAR_2 = VAR_4;\n    }\n\n    if (!VAR_21->verifyCertificateSpkiList().empty()) {\n      for (const auto& VAR_24 : VAR_21->verifyCertificateSpkiList()) {\n        const auto VAR_25 = Base64::decode(VAR_24);\n        if (VAR_25.size() != VAR_26) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", VAR_24));\n        }\n        VAR_28.emplace_back(VAR_25.begin(), VAR_25.end());\n      }\n      VAR_2 = VAR_4;\n    }\n  }\n\n  return VAR_2;\n}",
    "func_graph_path_before": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/default_validator.cc/vul/before/1.json",
    "func": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                                bool provides_certificates) {\n\n  int verify_mode = SSL_VERIFY_NONE;\n  int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n  if (config_ != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification verification = config_->trustChainVerification();\n    if (verification == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      verify_mode = SSL_VERIFY_PEER; // Ensure client-certs will be requested even if we have\n                                     // nothing to verify against\n      verify_mode_validation_context = SSL_VERIFY_PEER;\n    }\n  }\n\n  if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) {\n    ca_file_path_ = config_->caCertPath();\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      bool has_crl = false;\n      for (const X509_INFO* item : list.get()) {\n        if (item->x509) {\n          X509_STORE_add_cert(store, item->x509);\n          if (ca_cert_ == nullptr) {\n            X509_up_ref(item->x509);\n            ca_cert_.reset(item->x509);\n          }\n        }\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n          has_crl = true;\n        }\n      }\n      if (ca_cert_ == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n      }\n      if (has_crl) {\n        X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                        ? X509_V_FLAG_CRL_CHECK\n                                        : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n      }\n      verify_mode = SSL_VERIFY_PEER;\n      verify_trusted_ca_ = true;\n\n      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()\n      // directly. However, our new callback is still calling X509_verify_cert() under\n      // the hood. Therefore, to ignore cert expiration, we need to set the callback\n      // for X509_verify_cert to ignore that error.\n      if (config_->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (config_ != nullptr && !config_->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()),\n                        config_->certificateRevocationList().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", config_->certificateRevocationListPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      for (const X509_INFO* item : list.get()) {\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n        }\n      }\n      X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                      ? X509_V_FLAG_CRL_CHECK\n                                      : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n  if (cert_validation_config != nullptr) {\n    if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :\n           cert_validation_config->subjectAltNameMatchers()) {\n        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateHashList().empty()) {\n      for (auto hash : cert_validation_config->verifyCertificateHashList()) {\n        // Remove colons from the 95 chars long colon-separated \"fingerprint\"\n        // in order to get the hex-encoded string.\n        if (hash.size() == 95) {\n          hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end());\n        }\n        const auto& decoded = Hex::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", hash));\n        }\n        verify_certificate_hash_list_.push_back(decoded);\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateSpkiList().empty()) {\n      for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) {\n        const auto decoded = Base64::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", hash));\n        }\n        verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end());\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n  }\n\n  return verify_mode;\n}",
    "abstract_func": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> VAR_0,\n                                                bool VAR_1) {\n\n  int VAR_2 = VAR_3;\n  int VAR_4 = VAR_5 | VAR_6;\n\n  if (VAR_7 != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification VAR_8 = VAR_7->trustChainVerification();\n    if (VAR_8 == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      VAR_2 = VAR_5; /* COMMENT_0 */\n                                     /* COMMENT_1 */\n      VAR_4 = VAR_5;\n    }\n  }\n\n  if (VAR_7 != nullptr && !VAR_7->caCert().empty() && !VAR_1) {\n    VAR_9 = VAR_7->caCertPath();\n    bssl::UniquePtr<BIO> VAR_10(\n        BIO_new_mem_buf(VAR_11<char*>(VAR_7->caCert().data()), VAR_7->caCert().size()));\n    RELEASE_ASSERT(VAR_10 != nullptr, \"\");\n    /* COMMENT_2 */\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_12(\n        PEM_X509_INFO_read_bio(VAR_10.get(), nullptr, nullptr, nullptr));\n    if (VAR_12 == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", VAR_7->caCertPath()));\n    }\n\n    for (auto& VAR_13 : VAR_0) {\n      X509_STORE* VAR_14 = SSL_CTX_get_cert_store(VAR_13);\n      bool VAR_15 = false;\n      for (const X509_INFO* VAR_16 : VAR_12.get()) {\n        if (VAR_16->x509) {\n          X509_STORE_add_cert(VAR_14, VAR_16->x509);\n          if (VAR_17 == nullptr) {\n            X509_up_ref(VAR_16->x509);\n            VAR_17.reset(VAR_16->x509);\n          }\n        }\n        if (VAR_16->crl) {\n          X509_STORE_add_crl(VAR_14, VAR_16->crl);\n          VAR_15 = true;\n        }\n      }\n      if (VAR_17 == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", VAR_7->caCertPath()));\n      }\n      if (VAR_15) {\n        X509_STORE_set_flags(VAR_14, VAR_7->onlyVerifyLeafCertificateCrl()\n                                        ? VAR_18\n                                        : VAR_18 | VAR_19);\n      }\n      VAR_2 = VAR_5;\n      VAR_20 = true;\n\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n      if (VAR_7->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(VAR_14, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (VAR_7 != nullptr && !VAR_7->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> VAR_10(\n        BIO_new_mem_buf(VAR_11<char*>(VAR_7->certificateRevocationList().data()),\n                        VAR_7->certificateRevocationList().size()));\n    RELEASE_ASSERT(VAR_10 != nullptr, \"\");\n\n    /* COMMENT_2 */\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_12(\n        PEM_X509_INFO_read_bio(VAR_10.get(), nullptr, nullptr, nullptr));\n    if (VAR_12 == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", VAR_7->certificateRevocationListPath()));\n    }\n\n    for (auto& VAR_13 : VAR_0) {\n      X509_STORE* VAR_14 = SSL_CTX_get_cert_store(VAR_13);\n      for (const X509_INFO* VAR_16 : VAR_12.get()) {\n        if (VAR_16->crl) {\n          X509_STORE_add_crl(VAR_14, VAR_16->crl);\n        }\n      }\n      X509_STORE_set_flags(VAR_14, VAR_7->onlyVerifyLeafCertificateCrl()\n                                      ? VAR_18\n                                      : VAR_18 | VAR_19);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* VAR_21 = VAR_7;\n  if (VAR_21 != nullptr) {\n    if (!VAR_21->subjectAltNameMatchers().empty()) {\n      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& VAR_22 :\n           VAR_21->subjectAltNameMatchers()) {\n        VAR_23.emplace_back(createStringSanMatcher(VAR_22));\n      }\n      VAR_2 = VAR_4;\n    }\n\n    if (!VAR_21->verifyCertificateHashList().empty()) {\n      for (auto VAR_24 : VAR_21->verifyCertificateHashList()) {\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_24.size() == 95) {\n          VAR_24.erase(std::remove(VAR_24.begin(), VAR_24.end(), ':'), VAR_24.end());\n        }\n        const auto& VAR_25 = Hex::decode(VAR_24);\n        if (VAR_25.size() != VAR_26) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", VAR_24));\n        }\n        VAR_27.push_back(VAR_25);\n      }\n      VAR_2 = VAR_4;\n    }\n\n    if (!VAR_21->verifyCertificateSpkiList().empty()) {\n      for (const auto& VAR_24 : VAR_21->verifyCertificateSpkiList()) {\n        const auto VAR_25 = Base64::decode(VAR_24);\n        if (VAR_25.size() != VAR_26) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", VAR_24));\n        }\n        VAR_28.emplace_back(VAR_25.begin(), VAR_25.end());\n      }\n      VAR_2 = VAR_4;\n    }\n  }\n\n  return VAR_2;\n}",
    "func_graph_path": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/default_validator.cc/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -96,9 +96,9 @@\n   const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n   if (cert_validation_config != nullptr) {\n     if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n-      for (const envoy::type::matcher::v3::StringMatcher& matcher :\n+      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :\n            cert_validation_config->subjectAltNameMatchers()) {\n-        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n+        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n       }\n       verify_mode = verify_mode_validation_context;\n     }",
    "diff_line_info": {
        "deleted_lines": [
            "      for (const envoy::type::matcher::v3::StringMatcher& matcher :",
            "        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));"
        ],
        "added_lines": [
            "      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :",
            "        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/envoyproxy/envoy/pull/18628",
    "description": "Fixes #18259 \r\n\r\nSigned-off-by: Pradeep Rao <pcrao@google.com>\r\n\r\nCommit Message:\r\nAdditional Description:\r\nRisk Level: Low\r\nTesting: Added test\r\nDocs Changes: \r\nRelease Notes:\r\nPlatform Specific Features:\r\n\r\n"
}