{
    "cve_id": "CVE-2013-4514",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "staging: wlags49_h2: buffer overflow setting station name\n\nWe need to check the length parameter before doing the memcpy().  I've\nactually changed it to strlcpy() as well so that it's NUL terminated.\n\nYou need CAP_NET_ADMIN to trigger these so it's not the end of the\nworld.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "commit_hash": "b5e2f339865fb443107e5b10603e53bbc92dc054",
    "git_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054",
    "file_path": "drivers/staging/wlags49_h2/wl_priv.c",
    "func_name": "wvlan_uil_put_info",
    "func_before": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n}",
    "abstract_func_before": "int wvlan_uil_put_info(struct uilreq *VAR_0, struct wl_private *VAR_1)\n{\n\tint                     VAR_2 = 0;\n\tltv_t                   *VAR_3;\n\tbool_t                  VAR_4 = FALSE;\n\tENCSTRCT                VAR_5;\n\n#ifdef VAR_6\n\thcf_16                  VAR_7  = VAR_8;\n#endif  /* COMMENT_0 */\n\t/* COMMENT_1 */\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(VAR_9);\n\n\n\tif (VAR_0->hcfCtx == &(VAR_1->hcfCtx)) {\n\t\tif (capable(VAR_10)) {\n\t\t\tif ((VAR_0->data != NULL) && (VAR_0->len != 0)) {\n\t\t\t\t/* COMMENT_2 */\n\t\t\t\tif (VAR_0->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\tVAR_0->len = sizeof(VAR_1->ltvRecord);\n\t\t\t\t\tVAR_0->result = VAR_11;\n\t\t\t\t\tDBG_ERROR(VAR_9, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(VAR_9, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(VAR_9);\n\t\t\t\t\treturn VAR_2;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tVAR_2 = verify_area(VAR_12, VAR_0->data, VAR_0->len);\n\t\t\t\tif (VAR_2 != 0) {\n\t\t\t\t\tVAR_0->result = VAR_13;\n\t\t\t\t\tDBG_ERROR(VAR_9, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(VAR_9);\n\t\t\t\t\treturn VAR_2;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tcopy_from_user(&(VAR_1->ltvRecord), VAR_0->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* COMMENT_5 */\n                      \n\t\t\t\tif (((VAR_1->ltvRecord.len + 1) * sizeof(hcf_16)) > VAR_0->len) {\n\t\t\t\t\tVAR_0->len = sizeof(VAR_1->ltvRecord);\n\t\t\t\t\tVAR_0->result = VAR_11;\n\t\t\t\t\tDBG_ERROR(VAR_9, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(VAR_9);\n\t\t\t\t\treturn VAR_2;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_7 */\n                                                            \n                                                      \n\t\t\t\tif (VAR_0->len > sizeof(VAR_1->ltvRecord)) {\n\t\t\t\t\tVAR_3 = kmalloc(VAR_0->len, VAR_14);\n\t\t\t\t\tif (VAR_3 != NULL) {\n\t\t\t\t\t\tVAR_4 = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(VAR_9, \"Alloc FAILED\\n\");\n\t\t\t\t\t\tVAR_0->len = sizeof(VAR_1->ltvRecord);\n\t\t\t\t\t\tVAR_0->result = VAR_11;\n\t\t\t\t\t\tVAR_2 = -VAR_15;\n\t\t\t\t\t\tDBG_LEAVE(VAR_9);\n\t\t\t\t\t\treturn VAR_2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tVAR_3 = &(VAR_1->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_10 */\n                           \n\t\t\t\tcopy_from_user(VAR_3, VAR_0->data, VAR_0->len);\n\n\n\t\t\t\t/* COMMENT_12 */\n                                                              \n                                                        \n\t\t\t\tswitch (VAR_3->typ) {\n\t\t\t\tcase VAR_16:\n\t\t\t\t\tVAR_1->PortType    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_17:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_18:\n\t\t\t\t\tVAR_1->Channel     = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_16 */\n                                         \n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tcase VAR_19:\n\t\t\t\t\tVAR_1->atimWindow  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_20:\n\t\t\t\t\tVAR_1->DistanceBetweenAPs  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\n\t\t\t\tcase VAR_21:\n\t\t\t\t\t/* COMMENT_19 */\n                  \n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_22:\n\t\t\t\t\tVAR_1->PMEnabled   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_23:\n\t\t\t\t\tVAR_1->MulticastReceive    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_24:\n\t\t\t\t\tVAR_1->MaxSleepDuration    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_25:\n\t\t\t\t\tVAR_1->holdoverDuration    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_26:\n\t\t\t\t\tmemset(VAR_1->StationName, 0, sizeof(VAR_1->StationName));\n\t\t\t\t\tmemcpy((void *)VAR_1->StationName, (void *)&VAR_3->u.u8[2], (size_t)VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[0] = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_27:\n\t\t\t\t\tVAR_1->loadBalancing       = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_28:\n\t\t\t\t\tVAR_1->mediumDistribution  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef VAR_29\n\t\t\t\tcase VAR_30:\n\t\t\t\t\tVAR_1->txPowLevel          = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_21 */ /* COMMENT_22 */\n\t\t\t\t/* COMMENT_23 */   /* COMMENT_24 */\n\t\t\t\tcase VAR_31:        /* COMMENT_25 */\n\t\t\t\t\tVAR_1->srsc[0]             = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_1->srsc[1]             = VAR_3->u.u16[1];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[1]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_32:        /* COMMENT_26 */\n\t\t\t\t\tVAR_1->brsc[0]             = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_1->brsc[1]             = VAR_3->u.u16[1];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[1]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_33:\n\t\t\t\t\tVAR_1->connectionControl   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_27 */\n#endif  /* COMMENT_28 */\n\n#if 1 /* COMMENT_29 */\n\t\t/* COMMENT_30 */\n\n\t\t\t\tcase VAR_34:\n\t\t\t\t\tVAR_1->DTIMPeriod  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef VAR_29\n\t\t\t\tcase VAR_35:        /* COMMENT_31 */\n\t\t\t\t\tVAR_1->ownBeaconInterval   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* COMMENT_32 */\n\t\t\t\tcase VAR_36:         /* COMMENT_33 */\n\t\t\t\t\tVAR_1->coexistence         = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef VAR_6\n\t\t\t\tcase VAR_37:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[0].wdsAddress, &VAR_3->u.u8[0], VAR_38);\n\t\t\t\t\tVAR_7 = VAR_39;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_40:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[1].wdsAddress, &VAR_3->u.u8[0], VAR_38);\n\t\t\t\t\tVAR_7 = VAR_41;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_42:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[2].wdsAddress, &VAR_3->u.u8[0], VAR_38);\n\t\t\t\t\tVAR_7 = VAR_43;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_44:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[3].wdsAddress, &VAR_3->u.u8[0], VAR_38);\n\t\t\t\t\tVAR_7 = VAR_45;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_46:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[4].wdsAddress, &VAR_3->u.u8[0], VAR_38);\n\t\t\t\t\tVAR_7 = VAR_47;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_48:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[5].wdsAddress, &VAR_3->u.u8[0], VAR_38);\n\t\t\t\t\tVAR_7 = VAR_49;\n\t\t\t\t\tbreak;\n#endif  /* COMMENT_0 */\n\n\t\t\t\tcase VAR_50:\n\t\t\t\t\tVAR_1->multicastPMBuffering    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_51:\n\t\t\t\t\tVAR_1->RejectAny   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase VAR_52:\n\t\t\t\t\tVAR_1->EnableEncryption    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_53:\n\t\t\t\t\tVAR_1->authentication  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* COMMENT_29 */\n\t\t/* COMMENT_30 */\n\n\t\t\t\t/* COMMENT_34 */\n                                              \n                                                                 \n              \n\t\t\t\tcase VAR_54:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_55:\n\t\t\t\t\tVAR_1->intraBSSRelay   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase VAR_56:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_38 */\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_39 */\n\t\t\t\t/* COMMENT_40 */\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_39 */\n\t\t\t\t/* COMMENT_41 */\n\t\t\t\t\t/* COMMENT_42 */\n\t\t\t\t\t/* COMMENT_39 */\n\t\t\t\t/* COMMENT_43 */\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_39 */\n\t\t\t\tcase VAR_57:\n\t\t\t\t/* COMMENT_44 */\n\t\t\t\tcase VAR_58:\n\t\t\t\t\tmemset(VAR_1->NetworkName, 0, sizeof(VAR_1->NetworkName));\n\t\t\t\t\tmemcpy((void *)VAR_1->NetworkName, (void *)&VAR_3->u.u8[2], (size_t)VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[0] = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\n\t\t\t\t\t/* COMMENT_45 */\n\t\t\t\t\tif ((strlen(&VAR_3->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&VAR_3->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&VAR_3->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* COMMENT_46 */\n                                          \n\t\t\t\t\t\tVAR_3->u.u16[0] = 0;\n\t\t\t\t\t\tVAR_3->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_59:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_60:\n\t\t\t\t\tVAR_1->CreateIBSS  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_61:\n\t\t\t\t\tVAR_1->RTSThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_62:\n\t\t\t\t\tVAR_1->TxRateControl[0]    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_1->TxRateControl[1]    = VAR_3->u.u16[1];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[1]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_63:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_48 */\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_39 */\n#if 1 /* COMMENT_49 */\n\t\t/* COMMENT_30 */\n\t\t\t\tcase VAR_64:\n\t\t\t\t\tVAR_1->RTSThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_65:\n/* COMMENT_50 */\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef VAR_6\n\t\t\t\tcase VAR_66:\n\t\t\t\t\tVAR_1->wds_port[0].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                         = VAR_39;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_67:\n\t\t\t\t\tVAR_1->wds_port[1].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                         = VAR_41;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_68:\n\t\t\t\t\tVAR_1->wds_port[2].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                         = VAR_43;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_69:\n\t\t\t\t\tVAR_1->wds_port[3].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                         = VAR_45;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_70:\n\t\t\t\t\tVAR_1->wds_port[4].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                         = VAR_47;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_71:\n\t\t\t\t\tVAR_1->wds_port[5].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                         = VAR_49;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_72:\n\t\t\t\t\tVAR_1->wds_port[0].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                     = VAR_39;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_73:\n\t\t\t\t\tVAR_1->wds_port[1].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                     = VAR_41;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_74:\n\t\t\t\t\tVAR_1->wds_port[2].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                     = VAR_43;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_75:\n\t\t\t\t\tVAR_1->wds_port[3].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                     = VAR_45;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_76:\n\t\t\t\t\tVAR_1->wds_port[4].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                     = VAR_47;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_77:\n\t\t\t\t\tVAR_1->wds_port[5].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_7                     = VAR_49;\n\t\t\t\t\tbreak;\n#endif  /* COMMENT_0 */\n#endif  /* COMMENT_51 */\n\n\t\t\t\tcase VAR_78:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *VAR_79 = (CFG_DEFAULT_KEYS_STRCT *)VAR_3;\n\n\t\t\t\t\t\tVAR_79->key[0].len = CNV_INT_TO_LITTLE(VAR_79->key[0].len);\n\t\t\t\t\t\tVAR_79->key[1].len = CNV_INT_TO_LITTLE(VAR_79->key[1].len);\n\t\t\t\t\t\tVAR_79->key[2].len = CNV_INT_TO_LITTLE(VAR_79->key[2].len);\n\t\t\t\t\t\tVAR_79->key[3].len = CNV_INT_TO_LITTLE(VAR_79->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(VAR_1->DefaultKeys), (void *)VAR_79,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_80:\n\t\t\t\t\tVAR_1->TransmitKeyID   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_81:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_82:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_52 */\n\t\t\t\tcase VAR_83:\n\t\t\t\tcase VAR_84:\n\t\t\t\t/* COMMENT_53 */\n\t\t\t\tcase VAR_85:\n\t\t\t\tcase VAR_86:\n\t\t\t\tcase VAR_87:\n\t\t\t\tcase VAR_88:\n\t\t\t\tcase VAR_89:\n\t\t\t\tcase VAR_90:\n\t\t\t\tcase VAR_91:\n\t\t\t\tcase VAR_92:\n\t\t\t\tcase VAR_93:\n\t\t\t\tcase VAR_94:\n\t\t\t\tcase VAR_95:\n\t\t\t\tcase VAR_96:\n\t\t\t\tcase VAR_97:\n\t\t\t\tcase VAR_98:\n\t\t\t\tcase VAR_99:\n\t\t\t\tcase VAR_100:\n\t\t\t\tcase VAR_101:\n\t\t\t\tcase VAR_102:\n\t\t\t\tcase VAR_103:\n\t\t\t\tcase VAR_104:\n\t\t\t\tcase VAR_105:\n\t\t\t\tcase VAR_106:\n\t\t\t\tcase VAR_107:\n\t\t\t\tcase VAR_108:\n\t\t\t\tcase VAR_109:\n\t\t\t\t/* COMMENT_54 */\n\t\t\t\t/* COMMENT_55 */\n\t\t\t\t/* COMMENT_56 */\n\t\t\t\t/* COMMENT_57 */\n\t\t\t\t/* COMMENT_58 */\n\t\t\t\t/* COMMENT_59 */\n\t\t\t\t/* COMMENT_60 */\n\t\t\t\t/* COMMENT_61 */\n\t\t\t\t/* COMMENT_62 */\n\t\t\t\tcase VAR_110:\n\t\t\t\tcase VAR_111:\n\t\t\t\t/* COMMENT_63 */\n\t\t\t\tcase VAR_112:\n\t\t\t\tcase VAR_113:\n\t\t\t\t/* COMMENT_64 */\n\t\t\t\t/* COMMENT_65 */\n\t\t\t\tcase VAR_114:\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_115:\n/* COMMENT_66 */\n\t\t\t\t\tDBG_ERROR(VAR_9, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_116:\n\t\t\t\t\t/* COMMENT_67 */\n\t\t\t\t\tmemset(VAR_1->szEncryption, 0, sizeof(VAR_1->szEncryption));\n\t\t\t\t\tmemcpy((void *)VAR_1->szEncryption,  (void *)&VAR_3->u.u8[0],\n\t\t\t\t\t\t\t(VAR_3->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(VAR_117, &VAR_5,\n\t\t\t\t\t\t\t\t    VAR_1->szEncryption);\n\n\t\t\t\t\t/* COMMENT_68 */\n                                                               \n                                                                  \n                                                                   \n                                                                      \n                                                                  \n                                                                         \n\t\t\t\t\tVAR_1->TransmitKeyID    = VAR_5.wTxKeyID + 1;\n\t\t\t\t\tVAR_1->EnableEncryption = VAR_5.wEnabled;\n\n\t\t\t\t\tmemcpy(&VAR_1->DefaultKeys, &VAR_5.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_75 */\n                                                             \n                                                                                       \n           \n      \n\n\t\t\t\tcase VAR_118:\n\t\t\t\t\tVAR_1->driverEnable    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_119:\n\t\t\t\t\tVAR_1->wolasEnable = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_120:\n\t\t\t\t\tVAR_1->AuthKeyMgmtSuite = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_121:\n\t\t\t\t\tVAR_3->u.u16[VAR_38 / 2] = CNV_INT_TO_LITTLE(VAR_3->u.u16[VAR_38 / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_122:\n\t\t\t\tcase VAR_123:\n\t\t\t\t\t/* COMMENT_80 */\n\t\t\t\t\tVAR_3->u.u16[0] = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_124:\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_125:\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_81 */\n\t\t\t\tcase VAR_126:\n\t\t\t\tcase VAR_127:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_82 */\n                                                        \n                                                                  \n                     \n\t\t\t\tswitch (VAR_3->typ) {\n\t\t\t\tcase VAR_16:\n\t\t\t\tcase VAR_17:\n\t\t\t\tcase VAR_18:\n\t\t\t\tcase VAR_57:\n\t\t\t\tcase VAR_19:\n\t\t\t\tcase VAR_20:\n\t\t\t\tcase VAR_21:\n\t\t\t\tcase VAR_22:\n\t\t\t\tcase VAR_23:\n\t\t\t\tcase VAR_24:\n\t\t\t\tcase VAR_25:\n\t\t\t\tcase VAR_26:\n\t\t\t\tcase VAR_27:\n\t\t\t\tcase VAR_28:\n#ifdef VAR_29\n\t\t\t\tcase VAR_30:\n\t\t\t\tcase VAR_33:\n\t\t\t\t/* COMMENT_86 */\n#endif /* COMMENT_28 */\n#if 1 /* COMMENT_87 */\n\t\t/* COMMENT_88 */\n\t\t\t\tcase VAR_34:\n#ifdef VAR_29\n\t\t\t\tcase VAR_35:                    /* COMMENT_31 */\n#endif /* COMMENT_32 */\n#ifdef VAR_6\n\t\t\t\tcase VAR_37:\n\t\t\t\tcase VAR_40:\n\t\t\t\tcase VAR_42:\n\t\t\t\tcase VAR_44:\n\t\t\t\tcase VAR_46:\n\t\t\t\tcase VAR_48:\n#endif\n\t\t\t\tcase VAR_50:\n\t\t\t\tcase VAR_51:\n#endif\n\n\t\t\t\tcase VAR_52:\n\t\t\t\tcase VAR_53:\n#if 1 /* COMMENT_29 */\n\t\t/* COMMENT_30 */\n\n\t\t\t\tcase VAR_128:\n\t\t\t\tcase VAR_54:\n\t\t\t\tcase VAR_55:\n#endif\n\n\t\t\t\tcase VAR_56:\n\t\t\t\t/* COMMENT_89 */\n\t\t\t\t/* COMMENT_40 */\n\t\t\t\t/* COMMENT_41 */\n\t\t\t\t/* COMMENT_43 */\n\t\t\t\t/* COMMENT_90 */\n\t\t\t\tcase VAR_115:\n\t\t\t\tcase VAR_116:\n\t\t\t\t/* COMMENT_91 */\n\t\t\t\tcase VAR_119:\n\t\t\t\tcase VAR_126:\n\t\t\t\tcase VAR_127:\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_92 */\n\t\t\t\tcase VAR_118:\n\t\t\t\t\tif (VAR_1->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(VAR_1->hcfCtx), VAR_129 | VAR_8);\n\t\t\t\t\t\thcf_cntl(&(VAR_1->hcfCtx), VAR_130);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(VAR_1->hcfCtx), VAR_131 | VAR_8);\n\t\t\t\t\t\thcf_cntl(&(VAR_1->hcfCtx), VAR_132);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(VAR_1);\n\t\t\t\t\tVAR_0->result = hcf_put_info(&(VAR_1->hcfCtx), (LTVP) VAR_3);\n\t\t\t\t\twl_act_int_on(VAR_1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_4)\n\t\t\t\t\tkfree(VAR_3);\n\t\t\t} else {\n\t\t\t\tVAR_0->result = VAR_13;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(VAR_9, \"EPERM\\n\");\n\t\t\tVAR_0->result = VAR_13;\n\t\t\tVAR_2 = -VAR_133;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(VAR_9, \"UIL_ERR_WRONG_IFB\\n\");\n\t\tVAR_0->result = VAR_134;\n\t}\n\n\tDBG_LEAVE(VAR_9);\n\treturn VAR_2;\n}",
    "func_graph_path_before": "torvalds/linux/b5e2f339865fb443107e5b10603e53bbc92dc054/wl_priv.c/vul/before/0.json",
    "func": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n}",
    "abstract_func": "int wvlan_uil_put_info(struct uilreq *VAR_0, struct wl_private *VAR_1)\n{\n\tint                     VAR_2 = 0;\n\tltv_t                   *VAR_3;\n\tbool_t                  VAR_4 = FALSE;\n\tENCSTRCT                VAR_5;\n\tsize_t\t\t\tVAR_6;\n\n#ifdef VAR_7\n\thcf_16                  VAR_8  = VAR_9;\n#endif  /* COMMENT_0 */\n\t/* COMMENT_1 */\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(VAR_10);\n\n\n\tif (VAR_0->hcfCtx == &(VAR_1->hcfCtx)) {\n\t\tif (capable(VAR_11)) {\n\t\t\tif ((VAR_0->data != NULL) && (VAR_0->len != 0)) {\n\t\t\t\t/* COMMENT_2 */\n\t\t\t\tif (VAR_0->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\tVAR_0->len = sizeof(VAR_1->ltvRecord);\n\t\t\t\t\tVAR_0->result = VAR_12;\n\t\t\t\t\tDBG_ERROR(VAR_10, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(VAR_10, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(VAR_10);\n\t\t\t\t\treturn VAR_2;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tVAR_2 = verify_area(VAR_13, VAR_0->data, VAR_0->len);\n\t\t\t\tif (VAR_2 != 0) {\n\t\t\t\t\tVAR_0->result = VAR_14;\n\t\t\t\t\tDBG_ERROR(VAR_10, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(VAR_10);\n\t\t\t\t\treturn VAR_2;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tcopy_from_user(&(VAR_1->ltvRecord), VAR_0->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* COMMENT_5 */\n                      \n\t\t\t\tif (((VAR_1->ltvRecord.len + 1) * sizeof(hcf_16)) > VAR_0->len) {\n\t\t\t\t\tVAR_0->len = sizeof(VAR_1->ltvRecord);\n\t\t\t\t\tVAR_0->result = VAR_12;\n\t\t\t\t\tDBG_ERROR(VAR_10, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(VAR_10);\n\t\t\t\t\treturn VAR_2;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_7 */\n                                                            \n                                                      \n\t\t\t\tif (VAR_0->len > sizeof(VAR_1->ltvRecord)) {\n\t\t\t\t\tVAR_3 = kmalloc(VAR_0->len, VAR_15);\n\t\t\t\t\tif (VAR_3 != NULL) {\n\t\t\t\t\t\tVAR_4 = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(VAR_10, \"Alloc FAILED\\n\");\n\t\t\t\t\t\tVAR_0->len = sizeof(VAR_1->ltvRecord);\n\t\t\t\t\t\tVAR_0->result = VAR_12;\n\t\t\t\t\t\tVAR_2 = -VAR_16;\n\t\t\t\t\t\tDBG_LEAVE(VAR_10);\n\t\t\t\t\t\treturn VAR_2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tVAR_3 = &(VAR_1->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_10 */\n                           \n\t\t\t\tcopy_from_user(VAR_3, VAR_0->data, VAR_0->len);\n\n\n\t\t\t\t/* COMMENT_12 */\n                                                              \n                                                        \n\t\t\t\tswitch (VAR_3->typ) {\n\t\t\t\tcase VAR_17:\n\t\t\t\t\tVAR_1->PortType    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_18:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_19:\n\t\t\t\t\tVAR_1->Channel     = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_16 */\n                                         \n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tcase VAR_20:\n\t\t\t\t\tVAR_1->atimWindow  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_21:\n\t\t\t\t\tVAR_1->DistanceBetweenAPs  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\n\t\t\t\tcase VAR_22:\n\t\t\t\t\t/* COMMENT_19 */\n                  \n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_23:\n\t\t\t\t\tVAR_1->PMEnabled   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_24:\n\t\t\t\t\tVAR_1->MulticastReceive    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_25:\n\t\t\t\t\tVAR_1->MaxSleepDuration    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_26:\n\t\t\t\t\tVAR_1->holdoverDuration    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_27:\n\t\t\t\t\tmemset(VAR_1->StationName, 0, sizeof(VAR_1->StationName));\n\t\t\t\t\tVAR_6 = min_t(size_t, VAR_3->u.u16[0], sizeof(VAR_1->StationName));\n\t\t\t\t\tstrlcpy(VAR_1->StationName, &VAR_3->u.u8[2], VAR_6);\n\t\t\t\t\tVAR_3->u.u16[0] = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_28:\n\t\t\t\t\tVAR_1->loadBalancing       = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_29:\n\t\t\t\t\tVAR_1->mediumDistribution  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef VAR_30\n\t\t\t\tcase VAR_31:\n\t\t\t\t\tVAR_1->txPowLevel          = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_21 */ /* COMMENT_22 */\n\t\t\t\t/* COMMENT_23 */   /* COMMENT_24 */\n\t\t\t\tcase VAR_32:        /* COMMENT_25 */\n\t\t\t\t\tVAR_1->srsc[0]             = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_1->srsc[1]             = VAR_3->u.u16[1];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[1]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_33:        /* COMMENT_26 */\n\t\t\t\t\tVAR_1->brsc[0]             = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_1->brsc[1]             = VAR_3->u.u16[1];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[1]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_34:\n\t\t\t\t\tVAR_1->connectionControl   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_27 */\n#endif  /* COMMENT_28 */\n\n#if 1 /* COMMENT_29 */\n\t\t/* COMMENT_30 */\n\n\t\t\t\tcase VAR_35:\n\t\t\t\t\tVAR_1->DTIMPeriod  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef VAR_30\n\t\t\t\tcase VAR_36:        /* COMMENT_31 */\n\t\t\t\t\tVAR_1->ownBeaconInterval   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* COMMENT_32 */\n\t\t\t\tcase VAR_37:         /* COMMENT_33 */\n\t\t\t\t\tVAR_1->coexistence         = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef VAR_7\n\t\t\t\tcase VAR_38:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[0].wdsAddress, &VAR_3->u.u8[0], VAR_39);\n\t\t\t\t\tVAR_8 = VAR_40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_41:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[1].wdsAddress, &VAR_3->u.u8[0], VAR_39);\n\t\t\t\t\tVAR_8 = VAR_42;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_43:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[2].wdsAddress, &VAR_3->u.u8[0], VAR_39);\n\t\t\t\t\tVAR_8 = VAR_44;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_45:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[3].wdsAddress, &VAR_3->u.u8[0], VAR_39);\n\t\t\t\t\tVAR_8 = VAR_46;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_47:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[4].wdsAddress, &VAR_3->u.u8[0], VAR_39);\n\t\t\t\t\tVAR_8 = VAR_48;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_49:\n\t\t\t\t\tmemcpy(&VAR_1->wds_port[5].wdsAddress, &VAR_3->u.u8[0], VAR_39);\n\t\t\t\t\tVAR_8 = VAR_50;\n\t\t\t\t\tbreak;\n#endif  /* COMMENT_0 */\n\n\t\t\t\tcase VAR_51:\n\t\t\t\t\tVAR_1->multicastPMBuffering    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_52:\n\t\t\t\t\tVAR_1->RejectAny   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase VAR_53:\n\t\t\t\t\tVAR_1->EnableEncryption    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_54:\n\t\t\t\t\tVAR_1->authentication  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* COMMENT_29 */\n\t\t/* COMMENT_30 */\n\n\t\t\t\t/* COMMENT_34 */\n                                              \n                                                                 \n              \n\t\t\t\tcase VAR_55:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_56:\n\t\t\t\t\tVAR_1->intraBSSRelay   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase VAR_57:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_38 */\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_39 */\n\t\t\t\t/* COMMENT_40 */\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_39 */\n\t\t\t\t/* COMMENT_41 */\n\t\t\t\t\t/* COMMENT_42 */\n\t\t\t\t\t/* COMMENT_39 */\n\t\t\t\t/* COMMENT_43 */\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_39 */\n\t\t\t\tcase VAR_58:\n\t\t\t\t/* COMMENT_44 */\n\t\t\t\tcase VAR_59:\n\t\t\t\t\tmemset(VAR_1->NetworkName, 0, sizeof(VAR_1->NetworkName));\n\t\t\t\t\tmemcpy((void *)VAR_1->NetworkName, (void *)&VAR_3->u.u8[2], (size_t)VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[0] = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\n\t\t\t\t\t/* COMMENT_45 */\n\t\t\t\t\tif ((strlen(&VAR_3->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&VAR_3->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&VAR_3->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* COMMENT_46 */\n                                          \n\t\t\t\t\t\tVAR_3->u.u16[0] = 0;\n\t\t\t\t\t\tVAR_3->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_60:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_61:\n\t\t\t\t\tVAR_1->CreateIBSS  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_62:\n\t\t\t\t\tVAR_1->RTSThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_63:\n\t\t\t\t\tVAR_1->TxRateControl[0]    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_1->TxRateControl[1]    = VAR_3->u.u16[1];\n\t\t\t\t\tVAR_3->u.u16[0]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_3->u.u16[1]          = CNV_INT_TO_LITTLE(VAR_3->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_64:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_48 */\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\t/* COMMENT_39 */\n#if 1 /* COMMENT_49 */\n\t\t/* COMMENT_30 */\n\t\t\t\tcase VAR_65:\n\t\t\t\t\tVAR_1->RTSThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_66:\n/* COMMENT_50 */\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef VAR_7\n\t\t\t\tcase VAR_67:\n\t\t\t\t\tVAR_1->wds_port[0].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                         = VAR_40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_68:\n\t\t\t\t\tVAR_1->wds_port[1].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                         = VAR_42;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_69:\n\t\t\t\t\tVAR_1->wds_port[2].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                         = VAR_44;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_70:\n\t\t\t\t\tVAR_1->wds_port[3].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                         = VAR_46;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_71:\n\t\t\t\t\tVAR_1->wds_port[4].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                         = VAR_48;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_72:\n\t\t\t\t\tVAR_1->wds_port[5].rtsThreshold    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]                  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                         = VAR_50;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_73:\n\t\t\t\t\tVAR_1->wds_port[0].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                     = VAR_40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_74:\n\t\t\t\t\tVAR_1->wds_port[1].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                     = VAR_42;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_75:\n\t\t\t\t\tVAR_1->wds_port[2].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                     = VAR_44;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_76:\n\t\t\t\t\tVAR_1->wds_port[3].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                     = VAR_46;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_77:\n\t\t\t\t\tVAR_1->wds_port[4].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                     = VAR_48;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_78:\n\t\t\t\t\tVAR_1->wds_port[5].txRateCntl  = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]              = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tVAR_8                     = VAR_50;\n\t\t\t\t\tbreak;\n#endif  /* COMMENT_0 */\n#endif  /* COMMENT_51 */\n\n\t\t\t\tcase VAR_79:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *VAR_80 = (CFG_DEFAULT_KEYS_STRCT *)VAR_3;\n\n\t\t\t\t\t\tVAR_80->key[0].len = CNV_INT_TO_LITTLE(VAR_80->key[0].len);\n\t\t\t\t\t\tVAR_80->key[1].len = CNV_INT_TO_LITTLE(VAR_80->key[1].len);\n\t\t\t\t\t\tVAR_80->key[2].len = CNV_INT_TO_LITTLE(VAR_80->key[2].len);\n\t\t\t\t\t\tVAR_80->key[3].len = CNV_INT_TO_LITTLE(VAR_80->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(VAR_1->DefaultKeys), (void *)VAR_80,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_81:\n\t\t\t\t\tVAR_1->TransmitKeyID   = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_82:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_83:\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_52 */\n\t\t\t\tcase VAR_84:\n\t\t\t\tcase VAR_85:\n\t\t\t\t/* COMMENT_53 */\n\t\t\t\tcase VAR_86:\n\t\t\t\tcase VAR_87:\n\t\t\t\tcase VAR_88:\n\t\t\t\tcase VAR_89:\n\t\t\t\tcase VAR_90:\n\t\t\t\tcase VAR_91:\n\t\t\t\tcase VAR_92:\n\t\t\t\tcase VAR_93:\n\t\t\t\tcase VAR_94:\n\t\t\t\tcase VAR_95:\n\t\t\t\tcase VAR_96:\n\t\t\t\tcase VAR_97:\n\t\t\t\tcase VAR_98:\n\t\t\t\tcase VAR_99:\n\t\t\t\tcase VAR_100:\n\t\t\t\tcase VAR_101:\n\t\t\t\tcase VAR_102:\n\t\t\t\tcase VAR_103:\n\t\t\t\tcase VAR_104:\n\t\t\t\tcase VAR_105:\n\t\t\t\tcase VAR_106:\n\t\t\t\tcase VAR_107:\n\t\t\t\tcase VAR_108:\n\t\t\t\tcase VAR_109:\n\t\t\t\tcase VAR_110:\n\t\t\t\t/* COMMENT_54 */\n\t\t\t\t/* COMMENT_55 */\n\t\t\t\t/* COMMENT_56 */\n\t\t\t\t/* COMMENT_57 */\n\t\t\t\t/* COMMENT_58 */\n\t\t\t\t/* COMMENT_59 */\n\t\t\t\t/* COMMENT_60 */\n\t\t\t\t/* COMMENT_61 */\n\t\t\t\t/* COMMENT_62 */\n\t\t\t\tcase VAR_111:\n\t\t\t\tcase VAR_112:\n\t\t\t\t/* COMMENT_63 */\n\t\t\t\tcase VAR_113:\n\t\t\t\tcase VAR_114:\n\t\t\t\t/* COMMENT_64 */\n\t\t\t\t/* COMMENT_65 */\n\t\t\t\tcase VAR_115:\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_116:\n/* COMMENT_66 */\n\t\t\t\t\tDBG_ERROR(VAR_10, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_117:\n\t\t\t\t\t/* COMMENT_67 */\n\t\t\t\t\tmemset(VAR_1->szEncryption, 0, sizeof(VAR_1->szEncryption));\n\t\t\t\t\tmemcpy((void *)VAR_1->szEncryption,  (void *)&VAR_3->u.u8[0],\n\t\t\t\t\t\t\t(VAR_3->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(VAR_118, &VAR_5,\n\t\t\t\t\t\t\t\t    VAR_1->szEncryption);\n\n\t\t\t\t\t/* COMMENT_68 */\n                                                               \n                                                                  \n                                                                   \n                                                                      \n                                                                  \n                                                                         \n\t\t\t\t\tVAR_1->TransmitKeyID    = VAR_5.wTxKeyID + 1;\n\t\t\t\t\tVAR_1->EnableEncryption = VAR_5.wEnabled;\n\n\t\t\t\t\tmemcpy(&VAR_1->DefaultKeys, &VAR_5.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_75 */\n                                                             \n                                                                                       \n           \n      \n\n\t\t\t\tcase VAR_119:\n\t\t\t\t\tVAR_1->driverEnable    = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]      = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_120:\n\t\t\t\t\tVAR_1->wolasEnable = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_121:\n\t\t\t\t\tVAR_1->AuthKeyMgmtSuite = VAR_3->u.u16[0];\n\t\t\t\t\tVAR_3->u.u16[0]  = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_122:\n\t\t\t\t\tVAR_3->u.u16[VAR_39 / 2] = CNV_INT_TO_LITTLE(VAR_3->u.u16[VAR_39 / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_123:\n\t\t\t\tcase VAR_124:\n\t\t\t\t\t/* COMMENT_80 */\n\t\t\t\t\tVAR_3->u.u16[0] = CNV_INT_TO_LITTLE(VAR_3->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_125:\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_126:\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_81 */\n\t\t\t\tcase VAR_127:\n\t\t\t\tcase VAR_128:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_82 */\n                                                        \n                                                                  \n                     \n\t\t\t\tswitch (VAR_3->typ) {\n\t\t\t\tcase VAR_17:\n\t\t\t\tcase VAR_18:\n\t\t\t\tcase VAR_19:\n\t\t\t\tcase VAR_58:\n\t\t\t\tcase VAR_20:\n\t\t\t\tcase VAR_21:\n\t\t\t\tcase VAR_22:\n\t\t\t\tcase VAR_23:\n\t\t\t\tcase VAR_24:\n\t\t\t\tcase VAR_25:\n\t\t\t\tcase VAR_26:\n\t\t\t\tcase VAR_27:\n\t\t\t\tcase VAR_28:\n\t\t\t\tcase VAR_29:\n#ifdef VAR_30\n\t\t\t\tcase VAR_31:\n\t\t\t\tcase VAR_34:\n\t\t\t\t/* COMMENT_86 */\n#endif /* COMMENT_28 */\n#if 1 /* COMMENT_87 */\n\t\t/* COMMENT_88 */\n\t\t\t\tcase VAR_35:\n#ifdef VAR_30\n\t\t\t\tcase VAR_36:                    /* COMMENT_31 */\n#endif /* COMMENT_32 */\n#ifdef VAR_7\n\t\t\t\tcase VAR_38:\n\t\t\t\tcase VAR_41:\n\t\t\t\tcase VAR_43:\n\t\t\t\tcase VAR_45:\n\t\t\t\tcase VAR_47:\n\t\t\t\tcase VAR_49:\n#endif\n\t\t\t\tcase VAR_51:\n\t\t\t\tcase VAR_52:\n#endif\n\n\t\t\t\tcase VAR_53:\n\t\t\t\tcase VAR_54:\n#if 1 /* COMMENT_29 */\n\t\t/* COMMENT_30 */\n\n\t\t\t\tcase VAR_129:\n\t\t\t\tcase VAR_55:\n\t\t\t\tcase VAR_56:\n#endif\n\n\t\t\t\tcase VAR_57:\n\t\t\t\t/* COMMENT_89 */\n\t\t\t\t/* COMMENT_40 */\n\t\t\t\t/* COMMENT_41 */\n\t\t\t\t/* COMMENT_43 */\n\t\t\t\t/* COMMENT_90 */\n\t\t\t\tcase VAR_116:\n\t\t\t\tcase VAR_117:\n\t\t\t\t/* COMMENT_91 */\n\t\t\t\tcase VAR_120:\n\t\t\t\tcase VAR_127:\n\t\t\t\tcase VAR_128:\n\t\t\t\t\tbreak;\n\t\t\t\t/* COMMENT_92 */\n\t\t\t\tcase VAR_119:\n\t\t\t\t\tif (VAR_1->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(VAR_1->hcfCtx), VAR_130 | VAR_9);\n\t\t\t\t\t\thcf_cntl(&(VAR_1->hcfCtx), VAR_131);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(VAR_1->hcfCtx), VAR_132 | VAR_9);\n\t\t\t\t\t\thcf_cntl(&(VAR_1->hcfCtx), VAR_133);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(VAR_1);\n\t\t\t\t\tVAR_0->result = hcf_put_info(&(VAR_1->hcfCtx), (LTVP) VAR_3);\n\t\t\t\t\twl_act_int_on(VAR_1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_4)\n\t\t\t\t\tkfree(VAR_3);\n\t\t\t} else {\n\t\t\t\tVAR_0->result = VAR_14;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(VAR_10, \"EPERM\\n\");\n\t\t\tVAR_0->result = VAR_14;\n\t\t\tVAR_2 = -VAR_134;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(VAR_10, \"UIL_ERR_WRONG_IFB\\n\");\n\t\tVAR_0->result = VAR_135;\n\t}\n\n\tDBG_LEAVE(VAR_10);\n\treturn VAR_2;\n}",
    "func_graph_path": "torvalds/linux/b5e2f339865fb443107e5b10603e53bbc92dc054/wl_priv.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n+\tsize_t\t\t\tlen;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n@@ -120,7 +121,8 @@\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n-\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n+\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n+\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);"
        ],
        "added_lines": [
            "\tsize_t\t\t\tlen;",
            "\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));",
            "\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}