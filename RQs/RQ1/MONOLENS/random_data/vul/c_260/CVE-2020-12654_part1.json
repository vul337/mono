{
    "cve_id": "CVE-2020-12654",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:A/AC:H/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "mwifiex: Fix possible buffer overflows in mwifiex_ret_wmm_get_status()\n\nmwifiex_ret_wmm_get_status() calls memcpy() without checking the\ndestination size.Since the source is given from remote AP which\ncontains illegal wmm elements , this may trigger a heap buffer\noverflow.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Qing Xu <m1s5p6688@gmail.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>",
    "commit_hash": "3a9b153c5591548612c3955c9600a98150c81875",
    "git_url": "https://github.com/torvalds/linux/commit/3a9b153c5591548612c3955c9600a98150c81875",
    "file_path": "drivers/net/wireless/marvell/mwifiex/wmm.c",
    "func_name": "mwifiex_ret_wmm_get_status",
    "func_before": "int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\n\t\t\t       const struct host_cmd_ds_command *resp)\n{\n\tu8 *curr = (u8 *) &resp->params.get_wmm_status;\n\tuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\n\tint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\n\tbool valid = true;\n\n\tstruct mwifiex_ie_types_data *tlv_hdr;\n\tstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\n\tstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    resp_len);\n\n\twhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\n\t\ttlv_hdr = (struct mwifiex_ie_types_data *) curr;\n\t\ttlv_len = le16_to_cpu(tlv_hdr->header.len);\n\n\t\tif (resp_len < tlv_len + sizeof(tlv_hdr->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(tlv_hdr->header.type)) {\n\t\tcase TLV_TYPE_WMMQSTATUS:\n\t\t\ttlv_wmm_qstatus =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\ttlv_hdr;\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    tlv_wmm_qstatus->queue_index,\n\t\t\t\t    tlv_wmm_qstatus->flow_required,\n\t\t\t\t    tlv_wmm_qstatus->disabled);\n\n\t\t\tac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tac_status->disabled = tlv_wmm_qstatus->disabled;\n\t\t\tac_status->flow_required =\n\t\t\t\t\t\ttlv_wmm_qstatus->flow_required;\n\t\t\tac_status->flow_created = tlv_wmm_qstatus->flow_created;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t/*\n\t\t\t * Point the regular IEEE IE 2 bytes into the Marvell IE\n\t\t\t *   and setup the IEEE IE type and length byte fields\n\t\t\t */\n\n\t\t\twmm_param_ie =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (curr +\n\t\t\t\t\t\t\t\t    2);\n\t\t\twmm_param_ie->vend_hdr.len = (u8) tlv_len;\n\t\t\twmm_param_ie->vend_hdr.element_id =\n\t\t\t\t\t\tWLAN_EID_VENDOR_SPECIFIC;\n\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n\n\t\t\tmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, wmm_param_ie,\n\t\t\t       wmm_param_ie->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (tlv_len + sizeof(tlv_hdr->header));\n\t\tresp_len -= (tlv_len + sizeof(tlv_hdr->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\n\tmwifiex_wmm_setup_ac_downgrade(priv);\n\n\treturn 0;\n}",
    "abstract_func_before": "int mwifiex_ret_wmm_get_status(struct mwifiex_private *VAR_0,\n\t\t\t       const struct host_cmd_ds_command *VAR_1)\n{\n\tu8 *VAR_2 = (u8 *) &VAR_1->params.get_wmm_status;\n\tuint16_t VAR_3 = le16_to_cpu(VAR_1->size), VAR_4;\n\tint VAR_5 = VAR_6;\n\tbool VAR_7 = true;\n\n\tstruct mwifiex_ie_types_data *VAR_8;\n\tstruct mwifiex_ie_types_wmm_queue_status *VAR_9;\n\tstruct ieee_types_wmm_parameter *VAR_10 = NULL;\n\tstruct mwifiex_wmm_ac_status *VAR_11;\n\n\tmwifiex_dbg(VAR_0->adapter, VAR_12,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    VAR_3);\n\n\twhile ((VAR_3 >= sizeof(VAR_8->header)) && VAR_7) {\n\t\tVAR_8 = (struct mwifiex_ie_types_data *) VAR_2;\n\t\tVAR_4 = le16_to_cpu(VAR_8->header.len);\n\n\t\tif (VAR_3 < VAR_4 + sizeof(VAR_8->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(VAR_8->header.type)) {\n\t\tcase VAR_13:\n\t\t\tVAR_9 =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\tVAR_8;\n\t\t\tmwifiex_dbg(VAR_0->adapter, VAR_14,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    VAR_9->queue_index,\n\t\t\t\t    VAR_9->flow_required,\n\t\t\t\t    VAR_9->disabled);\n\n\t\t\tVAR_11 = &VAR_0->wmm.ac_status[VAR_9->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tVAR_11->disabled = VAR_9->disabled;\n\t\t\tVAR_11->flow_required =\n\t\t\t\t\t\tVAR_9->flow_required;\n\t\t\tVAR_11->flow_created = VAR_9->flow_created;\n\t\t\tbreak;\n\n\t\tcase VAR_15:\n\t\t\t/* COMMENT_0 */\n                                                           \n                                                         \n      \n\n\t\t\tVAR_10 =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (VAR_2 +\n\t\t\t\t\t\t\t\t    2);\n\t\t\tVAR_10->vend_hdr.len = (u8) VAR_4;\n\t\t\tVAR_10->vend_hdr.element_id =\n\t\t\t\t\t\tVAR_15;\n\n\t\t\tmwifiex_dbg(VAR_0->adapter, VAR_14,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    VAR_10->qos_info_bitmap & VAR_5);\n\n\t\t\tmemcpy((u8 *) &VAR_0->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, VAR_10,\n\t\t\t       VAR_10->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tVAR_7 = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_2 += (VAR_4 + sizeof(VAR_8->header));\n\t\tVAR_3 -= (VAR_4 + sizeof(VAR_8->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(VAR_0, VAR_10);\n\tmwifiex_wmm_setup_ac_downgrade(VAR_0);\n\n\treturn 0;\n}",
    "func_graph_path_before": "torvalds/linux/3a9b153c5591548612c3955c9600a98150c81875/wmm.c/vul/before/0.json",
    "func": "int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\n\t\t\t       const struct host_cmd_ds_command *resp)\n{\n\tu8 *curr = (u8 *) &resp->params.get_wmm_status;\n\tuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\n\tint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\n\tbool valid = true;\n\n\tstruct mwifiex_ie_types_data *tlv_hdr;\n\tstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\n\tstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    resp_len);\n\n\twhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\n\t\ttlv_hdr = (struct mwifiex_ie_types_data *) curr;\n\t\ttlv_len = le16_to_cpu(tlv_hdr->header.len);\n\n\t\tif (resp_len < tlv_len + sizeof(tlv_hdr->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(tlv_hdr->header.type)) {\n\t\tcase TLV_TYPE_WMMQSTATUS:\n\t\t\ttlv_wmm_qstatus =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\ttlv_hdr;\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    tlv_wmm_qstatus->queue_index,\n\t\t\t\t    tlv_wmm_qstatus->flow_required,\n\t\t\t\t    tlv_wmm_qstatus->disabled);\n\n\t\t\tac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tac_status->disabled = tlv_wmm_qstatus->disabled;\n\t\t\tac_status->flow_required =\n\t\t\t\t\t\ttlv_wmm_qstatus->flow_required;\n\t\t\tac_status->flow_created = tlv_wmm_qstatus->flow_created;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t/*\n\t\t\t * Point the regular IEEE IE 2 bytes into the Marvell IE\n\t\t\t *   and setup the IEEE IE type and length byte fields\n\t\t\t */\n\n\t\t\twmm_param_ie =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (curr +\n\t\t\t\t\t\t\t\t    2);\n\t\t\twmm_param_ie->vend_hdr.len = (u8) tlv_len;\n\t\t\twmm_param_ie->vend_hdr.element_id =\n\t\t\t\t\t\tWLAN_EID_VENDOR_SPECIFIC;\n\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n\n\t\t\tif (wmm_param_ie->vend_hdr.len + 2 >\n\t\t\t\tsizeof(struct ieee_types_wmm_parameter))\n\t\t\t\tbreak;\n\n\t\t\tmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, wmm_param_ie,\n\t\t\t       wmm_param_ie->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (tlv_len + sizeof(tlv_hdr->header));\n\t\tresp_len -= (tlv_len + sizeof(tlv_hdr->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\n\tmwifiex_wmm_setup_ac_downgrade(priv);\n\n\treturn 0;\n}",
    "abstract_func": "int mwifiex_ret_wmm_get_status(struct mwifiex_private *VAR_0,\n\t\t\t       const struct host_cmd_ds_command *VAR_1)\n{\n\tu8 *VAR_2 = (u8 *) &VAR_1->params.get_wmm_status;\n\tuint16_t VAR_3 = le16_to_cpu(VAR_1->size), VAR_4;\n\tint VAR_5 = VAR_6;\n\tbool VAR_7 = true;\n\n\tstruct mwifiex_ie_types_data *VAR_8;\n\tstruct mwifiex_ie_types_wmm_queue_status *VAR_9;\n\tstruct ieee_types_wmm_parameter *VAR_10 = NULL;\n\tstruct mwifiex_wmm_ac_status *VAR_11;\n\n\tmwifiex_dbg(VAR_0->adapter, VAR_12,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    VAR_3);\n\n\twhile ((VAR_3 >= sizeof(VAR_8->header)) && VAR_7) {\n\t\tVAR_8 = (struct mwifiex_ie_types_data *) VAR_2;\n\t\tVAR_4 = le16_to_cpu(VAR_8->header.len);\n\n\t\tif (VAR_3 < VAR_4 + sizeof(VAR_8->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(VAR_8->header.type)) {\n\t\tcase VAR_13:\n\t\t\tVAR_9 =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\tVAR_8;\n\t\t\tmwifiex_dbg(VAR_0->adapter, VAR_14,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    VAR_9->queue_index,\n\t\t\t\t    VAR_9->flow_required,\n\t\t\t\t    VAR_9->disabled);\n\n\t\t\tVAR_11 = &VAR_0->wmm.ac_status[VAR_9->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tVAR_11->disabled = VAR_9->disabled;\n\t\t\tVAR_11->flow_required =\n\t\t\t\t\t\tVAR_9->flow_required;\n\t\t\tVAR_11->flow_created = VAR_9->flow_created;\n\t\t\tbreak;\n\n\t\tcase VAR_15:\n\t\t\t/* COMMENT_0 */\n                                                           \n                                                         \n      \n\n\t\t\tVAR_10 =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (VAR_2 +\n\t\t\t\t\t\t\t\t    2);\n\t\t\tVAR_10->vend_hdr.len = (u8) VAR_4;\n\t\t\tVAR_10->vend_hdr.element_id =\n\t\t\t\t\t\tVAR_15;\n\n\t\t\tmwifiex_dbg(VAR_0->adapter, VAR_14,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    VAR_10->qos_info_bitmap & VAR_5);\n\n\t\t\tif (VAR_10->vend_hdr.len + 2 >\n\t\t\t\tsizeof(struct ieee_types_wmm_parameter))\n\t\t\t\tbreak;\n\n\t\t\tmemcpy((u8 *) &VAR_0->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, VAR_10,\n\t\t\t       VAR_10->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tVAR_7 = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_2 += (VAR_4 + sizeof(VAR_8->header));\n\t\tVAR_3 -= (VAR_4 + sizeof(VAR_8->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(VAR_0, VAR_10);\n\tmwifiex_wmm_setup_ac_downgrade(VAR_0);\n\n\treturn 0;\n}",
    "func_graph_path": "torvalds/linux/3a9b153c5591548612c3955c9600a98150c81875/wmm.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -60,6 +60,10 @@\n \t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n \t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n \n+\t\t\tif (wmm_param_ie->vend_hdr.len + 2 >\n+\t\t\t\tsizeof(struct ieee_types_wmm_parameter))\n+\t\t\t\tbreak;\n+\n \t\t\tmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\n \t\t\t       wmm_ie, wmm_param_ie,\n \t\t\t       wmm_param_ie->vend_hdr.len + 2);",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\t\tif (wmm_param_ie->vend_hdr.len + 2 >",
            "\t\t\t\tsizeof(struct ieee_types_wmm_parameter))",
            "\t\t\t\tbreak;",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}