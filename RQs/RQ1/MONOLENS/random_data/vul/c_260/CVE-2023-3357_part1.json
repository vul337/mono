{
    "cve_id": "CVE-2023-3357",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "Add check for the return value of the dma_alloc_coherent since\nit may return NULL pointer if allocation fails.\n\nFixes: 4b2c53d93a4b (\"SFH:Transport Driver to add support of AMD Sensor Fusion Hub (SFH)\")\nSigned-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>\nAcked-by: Basavaraj Natikar <Basavaraj.Natikar@amd.com>\nSigned-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nLink: https://lore.kernel.org/r/20221220024921.21992-1-jiasheng@iscas.ac.cn\n",
    "commit_hash": "53ffa6a9f83b2170c60591da1ead8791d5a42e81",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=53ffa6a9f83b2170c60591da1ead8791d5a42e81",
    "file_path": "drivers/hid/amd-sfh-hid/amd_sfh_client.c",
    "func_name": "amd_sfh_hid_client_init",
    "func_before": "int amd_sfh_hid_client_init(struct amd_mp2_dev *privdata)\n{\n\tstruct amd_input_data *in_data = &privdata->in_data;\n\tstruct amdtp_cl_data *cl_data = privdata->cl_data;\n\tstruct amd_mp2_ops *mp2_ops = privdata->mp2_ops;\n\tstruct amd_mp2_sensor_info info;\n\tstruct request_list *req_list;\n\tstruct device *dev;\n\tu32 feature_report_size;\n\tu32 input_report_size;\n\tint rc, i, status;\n\tu8 cl_idx;\n\n\treq_list = &cl_data->req_list;\n\tdev = &privdata->pdev->dev;\n\tamd_sfh_set_desc_ops(mp2_ops);\n\n\tmp2_ops->suspend = amd_sfh_suspend;\n\tmp2_ops->resume = amd_sfh_resume;\n\n\tcl_data->num_hid_devices = amd_mp2_get_sensor_num(privdata, &cl_data->sensor_idx[0]);\n\tif (cl_data->num_hid_devices == 0)\n\t\treturn -ENODEV;\n\n\tINIT_DELAYED_WORK(&cl_data->work, amd_sfh_work);\n\tINIT_DELAYED_WORK(&cl_data->work_buffer, amd_sfh_work_buffer);\n\tINIT_LIST_HEAD(&req_list->list);\n\tcl_data->in_data = in_data;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tin_data->sensor_virt_addr[i] = dma_alloc_coherent(dev, sizeof(int) * 8,\n\t\t\t\t\t\t\t\t  &cl_data->sensor_dma_addr[i],\n\t\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\tcl_data->sensor_requested_cnt[i] = 0;\n\t\tcl_data->cur_hid_dev = i;\n\t\tcl_idx = cl_data->sensor_idx[i];\n\t\tcl_data->report_descr_sz[i] = mp2_ops->get_desc_sz(cl_idx, descr_size);\n\t\tif (!cl_data->report_descr_sz[i]) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfeature_report_size = mp2_ops->get_desc_sz(cl_idx, feature_size);\n\t\tif (!feature_report_size) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinput_report_size =  mp2_ops->get_desc_sz(cl_idx, input_size);\n\t\tif (!input_report_size) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcl_data->feature_report[i] = devm_kzalloc(dev, feature_report_size, GFP_KERNEL);\n\t\tif (!cl_data->feature_report[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tin_data->input_report[i] = devm_kzalloc(dev, input_report_size, GFP_KERNEL);\n\t\tif (!in_data->input_report[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo.period = AMD_SFH_IDLE_LOOP;\n\t\tinfo.sensor_idx = cl_idx;\n\t\tinfo.dma_address = cl_data->sensor_dma_addr[i];\n\n\t\tcl_data->report_descr[i] =\n\t\t\tdevm_kzalloc(dev, cl_data->report_descr_sz[i], GFP_KERNEL);\n\t\tif (!cl_data->report_descr[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\trc = mp2_ops->get_rep_desc(cl_idx, cl_data->report_descr[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tmp2_ops->start(privdata, info);\n\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t(privdata, cl_data->sensor_idx[i], SENSOR_ENABLED);\n\t\tif (status == SENSOR_ENABLED) {\n\t\t\tcl_data->sensor_sts[i] = SENSOR_ENABLED;\n\t\t\trc = amdtp_hid_probe(cl_data->cur_hid_dev, cl_data);\n\t\t\tif (rc) {\n\t\t\t\tmp2_ops->stop(privdata, cl_data->sensor_idx[i]);\n\t\t\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t\t(privdata, cl_data->sensor_idx[i], SENSOR_DISABLED);\n\t\t\t\tif (status != SENSOR_ENABLED)\n\t\t\t\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\t\t\tdev_dbg(dev, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\t\tcl_data->sensor_idx[i],\n\t\t\t\t\tget_sensor_name(cl_data->sensor_idx[i]),\n\t\t\t\t\tcl_data->sensor_sts[i]);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tdev_dbg(dev, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\tcl_data->sensor_sts[i]);\n\t}\n\tif (mp2_ops->discovery_status && mp2_ops->discovery_status(privdata) == 0) {\n\t\tamd_sfh_hid_client_deinit(privdata);\n\t\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\t\tdevm_kfree(dev, cl_data->feature_report[i]);\n\t\t\tdevm_kfree(dev, in_data->input_report[i]);\n\t\t\tdevm_kfree(dev, cl_data->report_descr[i]);\n\t\t}\n\t\tdev_warn(dev, \"Failed to discover, sensors not enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tschedule_delayed_work(&cl_data->work_buffer, msecs_to_jiffies(AMD_SFH_IDLE_LOOP));\n\treturn 0;\n\ncleanup:\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (in_data->sensor_virt_addr[i]) {\n\t\t\tdma_free_coherent(&privdata->pdev->dev, 8 * sizeof(int),\n\t\t\t\t\t  in_data->sensor_virt_addr[i],\n\t\t\t\t\t  cl_data->sensor_dma_addr[i]);\n\t\t}\n\t\tdevm_kfree(dev, cl_data->feature_report[i]);\n\t\tdevm_kfree(dev, in_data->input_report[i]);\n\t\tdevm_kfree(dev, cl_data->report_descr[i]);\n\t}\n\treturn rc;\n}",
    "abstract_func_before": "int amd_sfh_hid_client_init(struct amd_mp2_dev *VAR_0)\n{\n\tstruct amd_input_data *VAR_1 = &VAR_0->in_data;\n\tstruct amdtp_cl_data *VAR_2 = VAR_0->cl_data;\n\tstruct amd_mp2_ops *VAR_3 = VAR_0->mp2_ops;\n\tstruct amd_mp2_sensor_info VAR_4;\n\tstruct request_list *VAR_5;\n\tstruct device *VAR_6;\n\tu32 VAR_7;\n\tu32 VAR_8;\n\tint VAR_9, VAR_10, VAR_11;\n\tu8 VAR_12;\n\n\tVAR_5 = &VAR_2->req_list;\n\tVAR_6 = &VAR_0->pdev->dev;\n\tamd_sfh_set_desc_ops(VAR_3);\n\n\tVAR_3->suspend = VAR_13;\n\tVAR_3->resume = VAR_14;\n\n\tVAR_2->num_hid_devices = amd_mp2_get_sensor_num(VAR_0, &VAR_2->sensor_idx[0]);\n\tif (VAR_2->num_hid_devices == 0)\n\t\treturn -VAR_15;\n\n\tINIT_DELAYED_WORK(&VAR_2->work, VAR_16);\n\tINIT_DELAYED_WORK(&VAR_2->work_buffer, VAR_17);\n\tINIT_LIST_HEAD(&VAR_5->list);\n\tVAR_2->in_data = VAR_1;\n\n\tfor (VAR_10 = 0; VAR_10 < VAR_2->num_hid_devices; VAR_10++) {\n\t\tVAR_1->sensor_virt_addr[VAR_10] = dma_alloc_coherent(VAR_6, sizeof(int) * 8,\n\t\t\t\t\t\t\t\t  &VAR_2->sensor_dma_addr[VAR_10],\n\t\t\t\t\t\t\t\t  VAR_18);\n\t\tVAR_2->sensor_sts[VAR_10] = VAR_19;\n\t\tVAR_2->sensor_requested_cnt[VAR_10] = 0;\n\t\tVAR_2->cur_hid_dev = VAR_10;\n\t\tVAR_12 = VAR_2->sensor_idx[VAR_10];\n\t\tVAR_2->report_descr_sz[VAR_10] = VAR_3->get_desc_sz(VAR_12, VAR_20);\n\t\tif (!VAR_2->report_descr_sz[VAR_10]) {\n\t\t\tVAR_9 = -VAR_21;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_7 = VAR_3->get_desc_sz(VAR_12, VAR_22);\n\t\tif (!VAR_7) {\n\t\t\tVAR_9 = -VAR_21;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_8 =  VAR_3->get_desc_sz(VAR_12, VAR_23);\n\t\tif (!VAR_8) {\n\t\t\tVAR_9 = -VAR_21;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_2->feature_report[VAR_10] = devm_kzalloc(VAR_6, VAR_7, VAR_18);\n\t\tif (!VAR_2->feature_report[VAR_10]) {\n\t\t\tVAR_9 = -VAR_24;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_1->input_report[VAR_10] = devm_kzalloc(VAR_6, VAR_8, VAR_18);\n\t\tif (!VAR_1->input_report[VAR_10]) {\n\t\t\tVAR_9 = -VAR_24;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_4.period = VAR_25;\n\t\tVAR_4.sensor_idx = VAR_12;\n\t\tVAR_4.dma_address = VAR_2->sensor_dma_addr[VAR_10];\n\n\t\tVAR_2->report_descr[VAR_10] =\n\t\t\tdevm_kzalloc(VAR_6, VAR_2->report_descr_sz[VAR_10], VAR_18);\n\t\tif (!VAR_2->report_descr[VAR_10]) {\n\t\t\tVAR_9 = -VAR_24;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_9 = VAR_3->get_rep_desc(VAR_12, VAR_2->report_descr[VAR_10]);\n\t\tif (VAR_9)\n\t\t\treturn VAR_9;\n\t\tVAR_3->start(VAR_0, VAR_4);\n\t\tVAR_11 = amd_sfh_wait_for_response\n\t\t\t\t(VAR_0, VAR_2->sensor_idx[VAR_10], VAR_26);\n\t\tif (VAR_11 == VAR_26) {\n\t\t\tVAR_2->sensor_sts[VAR_10] = VAR_26;\n\t\t\tVAR_9 = amdtp_hid_probe(VAR_2->cur_hid_dev, VAR_2);\n\t\t\tif (VAR_9) {\n\t\t\t\tVAR_3->stop(VAR_0, VAR_2->sensor_idx[VAR_10]);\n\t\t\t\tVAR_11 = amd_sfh_wait_for_response\n\t\t\t\t\t(VAR_0, VAR_2->sensor_idx[VAR_10], VAR_19);\n\t\t\t\tif (VAR_11 != VAR_26)\n\t\t\t\t\tVAR_2->sensor_sts[VAR_10] = VAR_19;\n\t\t\t\tdev_dbg(VAR_6, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\t\tVAR_2->sensor_idx[VAR_10],\n\t\t\t\t\tget_sensor_name(VAR_2->sensor_idx[VAR_10]),\n\t\t\t\t\tVAR_2->sensor_sts[VAR_10]);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tdev_dbg(VAR_6, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\tVAR_2->sensor_idx[VAR_10], get_sensor_name(VAR_2->sensor_idx[VAR_10]),\n\t\t\tVAR_2->sensor_sts[VAR_10]);\n\t}\n\tif (VAR_3->discovery_status && VAR_3->discovery_status(VAR_0) == 0) {\n\t\tamd_sfh_hid_client_deinit(VAR_0);\n\t\tfor (VAR_10 = 0; VAR_10 < VAR_2->num_hid_devices; VAR_10++) {\n\t\t\tdevm_kfree(VAR_6, VAR_2->feature_report[VAR_10]);\n\t\t\tdevm_kfree(VAR_6, VAR_1->input_report[VAR_10]);\n\t\t\tdevm_kfree(VAR_6, VAR_2->report_descr[VAR_10]);\n\t\t}\n\t\tdev_warn(VAR_6, \"Failed to discover, sensors not enabled\\n\");\n\t\treturn -VAR_27;\n\t}\n\tschedule_delayed_work(&VAR_2->work_buffer, msecs_to_jiffies(VAR_25));\n\treturn 0;\n\ncleanup:\n\tfor (VAR_10 = 0; VAR_10 < VAR_2->num_hid_devices; VAR_10++) {\n\t\tif (VAR_1->sensor_virt_addr[VAR_10]) {\n\t\t\tdma_free_coherent(&VAR_0->pdev->dev, 8 * sizeof(int),\n\t\t\t\t\t  VAR_1->sensor_virt_addr[VAR_10],\n\t\t\t\t\t  VAR_2->sensor_dma_addr[VAR_10]);\n\t\t}\n\t\tdevm_kfree(VAR_6, VAR_2->feature_report[VAR_10]);\n\t\tdevm_kfree(VAR_6, VAR_1->input_report[VAR_10]);\n\t\tdevm_kfree(VAR_6, VAR_2->report_descr[VAR_10]);\n\t}\n\treturn VAR_9;\n}",
    "func_graph_path_before": "torvalds/linux/53ffa6a9f83b2170c60591da1ead8791d5a42e81/amd_sfh_client.c/vul/before/0.json",
    "func": "int amd_sfh_hid_client_init(struct amd_mp2_dev *privdata)\n{\n\tstruct amd_input_data *in_data = &privdata->in_data;\n\tstruct amdtp_cl_data *cl_data = privdata->cl_data;\n\tstruct amd_mp2_ops *mp2_ops = privdata->mp2_ops;\n\tstruct amd_mp2_sensor_info info;\n\tstruct request_list *req_list;\n\tstruct device *dev;\n\tu32 feature_report_size;\n\tu32 input_report_size;\n\tint rc, i, status;\n\tu8 cl_idx;\n\n\treq_list = &cl_data->req_list;\n\tdev = &privdata->pdev->dev;\n\tamd_sfh_set_desc_ops(mp2_ops);\n\n\tmp2_ops->suspend = amd_sfh_suspend;\n\tmp2_ops->resume = amd_sfh_resume;\n\n\tcl_data->num_hid_devices = amd_mp2_get_sensor_num(privdata, &cl_data->sensor_idx[0]);\n\tif (cl_data->num_hid_devices == 0)\n\t\treturn -ENODEV;\n\n\tINIT_DELAYED_WORK(&cl_data->work, amd_sfh_work);\n\tINIT_DELAYED_WORK(&cl_data->work_buffer, amd_sfh_work_buffer);\n\tINIT_LIST_HEAD(&req_list->list);\n\tcl_data->in_data = in_data;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tin_data->sensor_virt_addr[i] = dma_alloc_coherent(dev, sizeof(int) * 8,\n\t\t\t\t\t\t\t\t  &cl_data->sensor_dma_addr[i],\n\t\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!in_data->sensor_virt_addr[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\tcl_data->sensor_requested_cnt[i] = 0;\n\t\tcl_data->cur_hid_dev = i;\n\t\tcl_idx = cl_data->sensor_idx[i];\n\t\tcl_data->report_descr_sz[i] = mp2_ops->get_desc_sz(cl_idx, descr_size);\n\t\tif (!cl_data->report_descr_sz[i]) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfeature_report_size = mp2_ops->get_desc_sz(cl_idx, feature_size);\n\t\tif (!feature_report_size) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinput_report_size =  mp2_ops->get_desc_sz(cl_idx, input_size);\n\t\tif (!input_report_size) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcl_data->feature_report[i] = devm_kzalloc(dev, feature_report_size, GFP_KERNEL);\n\t\tif (!cl_data->feature_report[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tin_data->input_report[i] = devm_kzalloc(dev, input_report_size, GFP_KERNEL);\n\t\tif (!in_data->input_report[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo.period = AMD_SFH_IDLE_LOOP;\n\t\tinfo.sensor_idx = cl_idx;\n\t\tinfo.dma_address = cl_data->sensor_dma_addr[i];\n\n\t\tcl_data->report_descr[i] =\n\t\t\tdevm_kzalloc(dev, cl_data->report_descr_sz[i], GFP_KERNEL);\n\t\tif (!cl_data->report_descr[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\trc = mp2_ops->get_rep_desc(cl_idx, cl_data->report_descr[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tmp2_ops->start(privdata, info);\n\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t(privdata, cl_data->sensor_idx[i], SENSOR_ENABLED);\n\t\tif (status == SENSOR_ENABLED) {\n\t\t\tcl_data->sensor_sts[i] = SENSOR_ENABLED;\n\t\t\trc = amdtp_hid_probe(cl_data->cur_hid_dev, cl_data);\n\t\t\tif (rc) {\n\t\t\t\tmp2_ops->stop(privdata, cl_data->sensor_idx[i]);\n\t\t\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t\t(privdata, cl_data->sensor_idx[i], SENSOR_DISABLED);\n\t\t\t\tif (status != SENSOR_ENABLED)\n\t\t\t\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\t\t\tdev_dbg(dev, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\t\tcl_data->sensor_idx[i],\n\t\t\t\t\tget_sensor_name(cl_data->sensor_idx[i]),\n\t\t\t\t\tcl_data->sensor_sts[i]);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tdev_dbg(dev, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\tcl_data->sensor_sts[i]);\n\t}\n\tif (mp2_ops->discovery_status && mp2_ops->discovery_status(privdata) == 0) {\n\t\tamd_sfh_hid_client_deinit(privdata);\n\t\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\t\tdevm_kfree(dev, cl_data->feature_report[i]);\n\t\t\tdevm_kfree(dev, in_data->input_report[i]);\n\t\t\tdevm_kfree(dev, cl_data->report_descr[i]);\n\t\t}\n\t\tdev_warn(dev, \"Failed to discover, sensors not enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tschedule_delayed_work(&cl_data->work_buffer, msecs_to_jiffies(AMD_SFH_IDLE_LOOP));\n\treturn 0;\n\ncleanup:\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (in_data->sensor_virt_addr[i]) {\n\t\t\tdma_free_coherent(&privdata->pdev->dev, 8 * sizeof(int),\n\t\t\t\t\t  in_data->sensor_virt_addr[i],\n\t\t\t\t\t  cl_data->sensor_dma_addr[i]);\n\t\t}\n\t\tdevm_kfree(dev, cl_data->feature_report[i]);\n\t\tdevm_kfree(dev, in_data->input_report[i]);\n\t\tdevm_kfree(dev, cl_data->report_descr[i]);\n\t}\n\treturn rc;\n}",
    "abstract_func": "int amd_sfh_hid_client_init(struct amd_mp2_dev *VAR_0)\n{\n\tstruct amd_input_data *VAR_1 = &VAR_0->in_data;\n\tstruct amdtp_cl_data *VAR_2 = VAR_0->cl_data;\n\tstruct amd_mp2_ops *VAR_3 = VAR_0->mp2_ops;\n\tstruct amd_mp2_sensor_info VAR_4;\n\tstruct request_list *VAR_5;\n\tstruct device *VAR_6;\n\tu32 VAR_7;\n\tu32 VAR_8;\n\tint VAR_9, VAR_10, VAR_11;\n\tu8 VAR_12;\n\n\tVAR_5 = &VAR_2->req_list;\n\tVAR_6 = &VAR_0->pdev->dev;\n\tamd_sfh_set_desc_ops(VAR_3);\n\n\tVAR_3->suspend = VAR_13;\n\tVAR_3->resume = VAR_14;\n\n\tVAR_2->num_hid_devices = amd_mp2_get_sensor_num(VAR_0, &VAR_2->sensor_idx[0]);\n\tif (VAR_2->num_hid_devices == 0)\n\t\treturn -VAR_15;\n\n\tINIT_DELAYED_WORK(&VAR_2->work, VAR_16);\n\tINIT_DELAYED_WORK(&VAR_2->work_buffer, VAR_17);\n\tINIT_LIST_HEAD(&VAR_5->list);\n\tVAR_2->in_data = VAR_1;\n\n\tfor (VAR_10 = 0; VAR_10 < VAR_2->num_hid_devices; VAR_10++) {\n\t\tVAR_1->sensor_virt_addr[VAR_10] = dma_alloc_coherent(VAR_6, sizeof(int) * 8,\n\t\t\t\t\t\t\t\t  &VAR_2->sensor_dma_addr[VAR_10],\n\t\t\t\t\t\t\t\t  VAR_18);\n\t\tif (!VAR_1->sensor_virt_addr[VAR_10]) {\n\t\t\tVAR_9 = -VAR_19;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_2->sensor_sts[VAR_10] = VAR_20;\n\t\tVAR_2->sensor_requested_cnt[VAR_10] = 0;\n\t\tVAR_2->cur_hid_dev = VAR_10;\n\t\tVAR_12 = VAR_2->sensor_idx[VAR_10];\n\t\tVAR_2->report_descr_sz[VAR_10] = VAR_3->get_desc_sz(VAR_12, VAR_21);\n\t\tif (!VAR_2->report_descr_sz[VAR_10]) {\n\t\t\tVAR_9 = -VAR_22;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_7 = VAR_3->get_desc_sz(VAR_12, VAR_23);\n\t\tif (!VAR_7) {\n\t\t\tVAR_9 = -VAR_22;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_8 =  VAR_3->get_desc_sz(VAR_12, VAR_24);\n\t\tif (!VAR_8) {\n\t\t\tVAR_9 = -VAR_22;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_2->feature_report[VAR_10] = devm_kzalloc(VAR_6, VAR_7, VAR_18);\n\t\tif (!VAR_2->feature_report[VAR_10]) {\n\t\t\tVAR_9 = -VAR_19;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_1->input_report[VAR_10] = devm_kzalloc(VAR_6, VAR_8, VAR_18);\n\t\tif (!VAR_1->input_report[VAR_10]) {\n\t\t\tVAR_9 = -VAR_19;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_4.period = VAR_25;\n\t\tVAR_4.sensor_idx = VAR_12;\n\t\tVAR_4.dma_address = VAR_2->sensor_dma_addr[VAR_10];\n\n\t\tVAR_2->report_descr[VAR_10] =\n\t\t\tdevm_kzalloc(VAR_6, VAR_2->report_descr_sz[VAR_10], VAR_18);\n\t\tif (!VAR_2->report_descr[VAR_10]) {\n\t\t\tVAR_9 = -VAR_19;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tVAR_9 = VAR_3->get_rep_desc(VAR_12, VAR_2->report_descr[VAR_10]);\n\t\tif (VAR_9)\n\t\t\treturn VAR_9;\n\t\tVAR_3->start(VAR_0, VAR_4);\n\t\tVAR_11 = amd_sfh_wait_for_response\n\t\t\t\t(VAR_0, VAR_2->sensor_idx[VAR_10], VAR_26);\n\t\tif (VAR_11 == VAR_26) {\n\t\t\tVAR_2->sensor_sts[VAR_10] = VAR_26;\n\t\t\tVAR_9 = amdtp_hid_probe(VAR_2->cur_hid_dev, VAR_2);\n\t\t\tif (VAR_9) {\n\t\t\t\tVAR_3->stop(VAR_0, VAR_2->sensor_idx[VAR_10]);\n\t\t\t\tVAR_11 = amd_sfh_wait_for_response\n\t\t\t\t\t(VAR_0, VAR_2->sensor_idx[VAR_10], VAR_20);\n\t\t\t\tif (VAR_11 != VAR_26)\n\t\t\t\t\tVAR_2->sensor_sts[VAR_10] = VAR_20;\n\t\t\t\tdev_dbg(VAR_6, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\t\tVAR_2->sensor_idx[VAR_10],\n\t\t\t\t\tget_sensor_name(VAR_2->sensor_idx[VAR_10]),\n\t\t\t\t\tVAR_2->sensor_sts[VAR_10]);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\tdev_dbg(VAR_6, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\tVAR_2->sensor_idx[VAR_10], get_sensor_name(VAR_2->sensor_idx[VAR_10]),\n\t\t\tVAR_2->sensor_sts[VAR_10]);\n\t}\n\tif (VAR_3->discovery_status && VAR_3->discovery_status(VAR_0) == 0) {\n\t\tamd_sfh_hid_client_deinit(VAR_0);\n\t\tfor (VAR_10 = 0; VAR_10 < VAR_2->num_hid_devices; VAR_10++) {\n\t\t\tdevm_kfree(VAR_6, VAR_2->feature_report[VAR_10]);\n\t\t\tdevm_kfree(VAR_6, VAR_1->input_report[VAR_10]);\n\t\t\tdevm_kfree(VAR_6, VAR_2->report_descr[VAR_10]);\n\t\t}\n\t\tdev_warn(VAR_6, \"Failed to discover, sensors not enabled\\n\");\n\t\treturn -VAR_27;\n\t}\n\tschedule_delayed_work(&VAR_2->work_buffer, msecs_to_jiffies(VAR_25));\n\treturn 0;\n\ncleanup:\n\tfor (VAR_10 = 0; VAR_10 < VAR_2->num_hid_devices; VAR_10++) {\n\t\tif (VAR_1->sensor_virt_addr[VAR_10]) {\n\t\t\tdma_free_coherent(&VAR_0->pdev->dev, 8 * sizeof(int),\n\t\t\t\t\t  VAR_1->sensor_virt_addr[VAR_10],\n\t\t\t\t\t  VAR_2->sensor_dma_addr[VAR_10]);\n\t\t}\n\t\tdevm_kfree(VAR_6, VAR_2->feature_report[VAR_10]);\n\t\tdevm_kfree(VAR_6, VAR_1->input_report[VAR_10]);\n\t\tdevm_kfree(VAR_6, VAR_2->report_descr[VAR_10]);\n\t}\n\treturn VAR_9;\n}",
    "func_graph_path": "torvalds/linux/53ffa6a9f83b2170c60591da1ead8791d5a42e81/amd_sfh_client.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,10 @@\n \t\tin_data->sensor_virt_addr[i] = dma_alloc_coherent(dev, sizeof(int) * 8,\n \t\t\t\t\t\t\t\t  &cl_data->sensor_dma_addr[i],\n \t\t\t\t\t\t\t\t  GFP_KERNEL);\n+\t\tif (!in_data->sensor_virt_addr[i]) {\n+\t\t\trc = -ENOMEM;\n+\t\t\tgoto cleanup;\n+\t\t}\n \t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n \t\tcl_data->sensor_requested_cnt[i] = 0;\n \t\tcl_data->cur_hid_dev = i;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\tif (!in_data->sensor_virt_addr[i]) {",
            "\t\t\trc = -ENOMEM;",
            "\t\t\tgoto cleanup;",
            "\t\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}