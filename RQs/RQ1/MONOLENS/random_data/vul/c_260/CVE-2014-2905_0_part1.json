{
    "cve_id": "CVE-2014-2905",
    "cwe_ids": [
        "CWE-264"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "fish-shell",
    "commit_msg": "Check effective credentials of socket peers\n\nFix for CVE-2014-2905.\n\nCode for getpeereid() on non-BSD systems imported from the PostgreSQL\nproject under a BSD-style license.\n\nCloses #1436",
    "commit_hash": "ba1b5e34a77369e28ff563e47c088c55664a8a11",
    "git_url": "https://github.com/fish-shell/fish-shell/commit/ba1b5e34a77369e28ff563e47c088c55664a8a11",
    "file_path": "env_universal.cpp",
    "func_name": "try_get_socket_once",
    "func_before": "static int try_get_socket_once(void)\n{\n    int s;\n\n    wchar_t *wdir;\n    wchar_t *wuname;\n    char *dir = 0;\n\n    wdir = path;\n    wuname = user;\n\n    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n    {\n        wperror(L\"socket\");\n        return -1;\n    }\n\n    if (wdir)\n        dir = wcs2str(wdir);\n    else\n        dir = strdup(\"/tmp\");\n\n    std::string uname;\n    if (wuname)\n    {\n        uname = wcs2string(wuname);\n    }\n    else\n    {\n        struct passwd *pw = getpwuid(getuid());\n        if (pw && pw->pw_name)\n        {\n            uname = pw->pw_name;\n        }\n    }\n\n    std::string name;\n    name.reserve(strlen(dir) + uname.size() + strlen(SOCK_FILENAME) + 2);\n    name.append(dir);\n    name.append(\"/\");\n    name.append(SOCK_FILENAME);\n    name.append(uname);\n\n    free(dir);\n\n    debug(3, L\"Connect to socket %s at fd %d\", name.c_str(), s);\n\n    struct sockaddr_un local = {};\n    local.sun_family = AF_UNIX;\n    strncpy(local.sun_path, name.c_str(), (sizeof local.sun_path) - 1);\n\n    if (connect(s, (struct sockaddr *)&local, sizeof local) == -1)\n    {\n        close(s);\n\n        /* If it fails on first try, it's probably no serious error, but fishd hasn't been launched yet.\n         This happens (at least) on the first concurrent session. */\n        if (get_socket_count > 1)\n            wperror(L\"connect\");\n\n        return -1;\n    }\n\n    if ((make_fd_nonblocking(s) != 0) || (fcntl(s, F_SETFD, FD_CLOEXEC) != 0))\n    {\n        wperror(L\"fcntl\");\n        close(s);\n\n        return -1;\n    }\n\n    debug(3, L\"Connected to fd %d\", s);\n\n    return s;\n}",
    "abstract_func_before": "static int try_get_socket_once(void)\n{\n    int VAR_0;\n\n    wchar_t *VAR_1;\n    wchar_t *VAR_2;\n    char *VAR_3 = 0;\n\n    VAR_1 = VAR_4;\n    VAR_2 = VAR_5;\n\n    if ((VAR_0 = socket(VAR_6, VAR_7, 0)) == -1)\n    {\n        wperror(L\"socket\");\n        return -1;\n    }\n\n    if (VAR_1)\n        VAR_3 = wcs2str(VAR_1);\n    else\n        VAR_3 = strdup(\"/tmp\");\n\n    std::string VAR_8;\n    if (VAR_2)\n    {\n        VAR_8 = wcs2string(VAR_2);\n    }\n    else\n    {\n        struct passwd *VAR_9 = getpwuid(getuid());\n        if (VAR_9 && VAR_9->pw_name)\n        {\n            VAR_8 = VAR_9->pw_name;\n        }\n    }\n\n    std::string VAR_10;\n    VAR_10.reserve(strlen(VAR_3) + VAR_8.size() + strlen(VAR_11) + 2);\n    VAR_10.append(VAR_3);\n    VAR_10.append(\"/\");\n    VAR_10.append(VAR_11);\n    VAR_10.append(VAR_8);\n\n    free(VAR_3);\n\n    debug(3, L\"Connect to socket %s at fd %d\", VAR_10.c_str(), VAR_0);\n\n    struct sockaddr_un VAR_12 = {};\n    VAR_12.sun_family = VAR_6;\n    strncpy(VAR_12.sun_path, VAR_10.c_str(), (sizeof VAR_12.sun_path) - 1);\n\n    if (connect(VAR_0, (struct sockaddr *)&VAR_12, sizeof VAR_12) == -1)\n    {\n        close(VAR_0);\n\n        /* COMMENT_0 */\n                                                                    \n        if (VAR_13 > 1)\n            wperror(L\"connect\");\n\n        return -1;\n    }\n\n    if ((make_fd_nonblocking(VAR_0) != 0) || (fcntl(VAR_0, VAR_14, VAR_15) != 0))\n    {\n        wperror(L\"fcntl\");\n        close(VAR_0);\n\n        return -1;\n    }\n\n    debug(3, L\"Connected to fd %d\", VAR_0);\n\n    return VAR_0;\n}",
    "func_graph_path_before": "fish-shell/ba1b5e34a77369e28ff563e47c088c55664a8a11/env_universal.cpp/vul/before/0.json",
    "func": "static int try_get_socket_once(void)\n{\n    int s;\n\n    wchar_t *wdir;\n    wchar_t *wuname;\n    char *dir = 0;\n\n    wdir = path;\n    wuname = user;\n    uid_t seuid;\n    gid_t segid;\n\n    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n    {\n        wperror(L\"socket\");\n        return -1;\n    }\n\n    if (wdir)\n        dir = wcs2str(wdir);\n    else\n        dir = strdup(\"/tmp\");\n\n    std::string uname;\n    if (wuname)\n    {\n        uname = wcs2string(wuname);\n    }\n    else\n    {\n        struct passwd *pw = getpwuid(getuid());\n        if (pw && pw->pw_name)\n        {\n            uname = pw->pw_name;\n        }\n    }\n\n    std::string name;\n    name.reserve(strlen(dir) + uname.size() + strlen(SOCK_FILENAME) + 2);\n    name.append(dir);\n    name.append(\"/\");\n    name.append(SOCK_FILENAME);\n    name.append(uname);\n\n    free(dir);\n\n    debug(3, L\"Connect to socket %s at fd %d\", name.c_str(), s);\n\n    struct sockaddr_un local = {};\n    local.sun_family = AF_UNIX;\n    strncpy(local.sun_path, name.c_str(), (sizeof local.sun_path) - 1);\n\n    if (connect(s, (struct sockaddr *)&local, sizeof local) == -1)\n    {\n        close(s);\n\n        /* If it fails on first try, it's probably no serious error, but fishd hasn't been launched yet.\n         This happens (at least) on the first concurrent session. */\n        if (get_socket_count > 1)\n            wperror(L\"connect\");\n\n        return -1;\n    }\n\n    if ((getpeereid(s, &seuid, &segid) != 0) || seuid != geteuid())\n    {\n        debug(1, L\"Wrong credentials for socket %s at fd %d\", name.c_str(), s);\n        close(s);\n        return -1;\n    }\n\n    if ((make_fd_nonblocking(s) != 0) || (fcntl(s, F_SETFD, FD_CLOEXEC) != 0))\n    {\n        wperror(L\"fcntl\");\n        close(s);\n\n        return -1;\n    }\n\n    debug(3, L\"Connected to fd %d\", s);\n\n    return s;\n}",
    "abstract_func": "static int try_get_socket_once(void)\n{\n    int VAR_0;\n\n    wchar_t *VAR_1;\n    wchar_t *VAR_2;\n    char *VAR_3 = 0;\n\n    VAR_1 = VAR_4;\n    VAR_2 = VAR_5;\n    uid_t VAR_6;\n    gid_t VAR_7;\n\n    if ((VAR_0 = socket(VAR_8, VAR_9, 0)) == -1)\n    {\n        wperror(L\"socket\");\n        return -1;\n    }\n\n    if (VAR_1)\n        VAR_3 = wcs2str(VAR_1);\n    else\n        VAR_3 = strdup(\"/tmp\");\n\n    std::string VAR_10;\n    if (VAR_2)\n    {\n        VAR_10 = wcs2string(VAR_2);\n    }\n    else\n    {\n        struct passwd *VAR_11 = getpwuid(getuid());\n        if (VAR_11 && VAR_11->pw_name)\n        {\n            VAR_10 = VAR_11->pw_name;\n        }\n    }\n\n    std::string VAR_12;\n    VAR_12.reserve(strlen(VAR_3) + VAR_10.size() + strlen(VAR_13) + 2);\n    VAR_12.append(VAR_3);\n    VAR_12.append(\"/\");\n    VAR_12.append(VAR_13);\n    VAR_12.append(VAR_10);\n\n    free(VAR_3);\n\n    debug(3, L\"Connect to socket %s at fd %d\", VAR_12.c_str(), VAR_0);\n\n    struct sockaddr_un VAR_14 = {};\n    VAR_14.sun_family = VAR_8;\n    strncpy(VAR_14.sun_path, VAR_12.c_str(), (sizeof VAR_14.sun_path) - 1);\n\n    if (connect(VAR_0, (struct sockaddr *)&VAR_14, sizeof VAR_14) == -1)\n    {\n        close(VAR_0);\n\n        /* COMMENT_0 */\n                                                                    \n        if (VAR_15 > 1)\n            wperror(L\"connect\");\n\n        return -1;\n    }\n\n    if ((getpeereid(VAR_0, &VAR_6, &VAR_7) != 0) || VAR_6 != geteuid())\n    {\n        debug(1, L\"Wrong credentials for socket %s at fd %d\", VAR_12.c_str(), VAR_0);\n        close(VAR_0);\n        return -1;\n    }\n\n    if ((make_fd_nonblocking(VAR_0) != 0) || (fcntl(VAR_0, VAR_16, VAR_17) != 0))\n    {\n        wperror(L\"fcntl\");\n        close(VAR_0);\n\n        return -1;\n    }\n\n    debug(3, L\"Connected to fd %d\", VAR_0);\n\n    return VAR_0;\n}",
    "func_graph_path": "fish-shell/ba1b5e34a77369e28ff563e47c088c55664a8a11/env_universal.cpp/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,8 @@\n \n     wdir = path;\n     wuname = user;\n+    uid_t seuid;\n+    gid_t segid;\n \n     if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n     {\n@@ -61,6 +63,13 @@\n         return -1;\n     }\n \n+    if ((getpeereid(s, &seuid, &segid) != 0) || seuid != geteuid())\n+    {\n+        debug(1, L\"Wrong credentials for socket %s at fd %d\", name.c_str(), s);\n+        close(s);\n+        return -1;\n+    }\n+\n     if ((make_fd_nonblocking(s) != 0) || (fcntl(s, F_SETFD, FD_CLOEXEC) != 0))\n     {\n         wperror(L\"fcntl\");",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "    uid_t seuid;",
            "    gid_t segid;",
            "    if ((getpeereid(s, &seuid, &segid) != 0) || seuid != geteuid())",
            "    {",
            "        debug(1, L\"Wrong credentials for socket %s at fd %d\", name.c_str(), s);",
            "        close(s);",
            "        return -1;",
            "    }",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}