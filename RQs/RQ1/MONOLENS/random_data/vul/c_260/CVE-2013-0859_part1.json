{
    "cve_id": "CVE-2013-0859",
    "cwe_ids": [
        "CWE-189"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "ffmpeg",
    "commit_msg": "\ntiffdec: check count in metadata reading.\n\nFixes out of array access\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n",
    "commit_hash": "6d1c5ea04af3e345232aa70c944de961061dab2d",
    "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=6d1c5ea04af3e345232aa70c944de961061dab2d",
    "file_path": "libavcodec/tiff.c",
    "func_name": "add_shorts_metadata",
    "func_before": "static int add_shorts_metadata(int count, const char *name,\n                               const char *sep, TiffContext *s)\n{\n    char *ap;\n    int i;\n    int16_t *sp;\n\n    if (count >= INT_MAX / sizeof(int16_t))\n        return AVERROR_INVALIDDATA;\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n        return AVERROR_INVALIDDATA;\n\n    sp = av_malloc(count * sizeof(int16_t));\n    if (!sp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        sp[i] = tget_short(&s->gb, s->le);\n    ap = shorts2str(sp, count, sep);\n    av_freep(&sp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}",
    "abstract_func_before": "static int add_shorts_metadata(int VAR_0, const char *VAR_1,\n                               const char *VAR_2, TiffContext *VAR_3)\n{\n    char *VAR_4;\n    int VAR_5;\n    int16_t *VAR_6;\n\n    if (VAR_0 >= VAR_7 / sizeof(int16_t))\n        return VAR_8;\n    if (bytestream2_get_bytes_left(&VAR_3->gb) < VAR_0 * sizeof(int16_t))\n        return VAR_8;\n\n    VAR_6 = av_malloc(VAR_0 * sizeof(int16_t));\n    if (!VAR_6)\n        return AVERROR(VAR_9);\n\n    for (VAR_5 = 0; VAR_5 < VAR_0; VAR_5++)\n        VAR_6[VAR_5] = tget_short(&VAR_3->gb, VAR_3->le);\n    VAR_4 = shorts2str(VAR_6, VAR_0, VAR_2);\n    av_freep(&VAR_6);\n    if (!VAR_4)\n        return AVERROR(VAR_9);\n    av_dict_set(&VAR_3->picture.metadata, VAR_1, VAR_4, VAR_10);\n    return 0;\n}",
    "func_graph_path_before": "ffmpeg/6d1c5ea04af3e345232aa70c944de961061dab2d/tiff.c/vul/before/0.json",
    "func": "static int add_shorts_metadata(int count, const char *name,\n                               const char *sep, TiffContext *s)\n{\n    char *ap;\n    int i;\n    int16_t *sp;\n\n    if (count >= INT_MAX / sizeof(int16_t) || count <= 0)\n        return AVERROR_INVALIDDATA;\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n        return AVERROR_INVALIDDATA;\n\n    sp = av_malloc(count * sizeof(int16_t));\n    if (!sp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        sp[i] = tget_short(&s->gb, s->le);\n    ap = shorts2str(sp, count, sep);\n    av_freep(&sp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}",
    "abstract_func": "static int add_shorts_metadata(int VAR_0, const char *VAR_1,\n                               const char *VAR_2, TiffContext *VAR_3)\n{\n    char *VAR_4;\n    int VAR_5;\n    int16_t *VAR_6;\n\n    if (VAR_0 >= VAR_7 / sizeof(int16_t) || VAR_0 <= 0)\n        return VAR_8;\n    if (bytestream2_get_bytes_left(&VAR_3->gb) < VAR_0 * sizeof(int16_t))\n        return VAR_8;\n\n    VAR_6 = av_malloc(VAR_0 * sizeof(int16_t));\n    if (!VAR_6)\n        return AVERROR(VAR_9);\n\n    for (VAR_5 = 0; VAR_5 < VAR_0; VAR_5++)\n        VAR_6[VAR_5] = tget_short(&VAR_3->gb, VAR_3->le);\n    VAR_4 = shorts2str(VAR_6, VAR_0, VAR_2);\n    av_freep(&VAR_6);\n    if (!VAR_4)\n        return AVERROR(VAR_9);\n    av_dict_set(&VAR_3->picture.metadata, VAR_1, VAR_4, VAR_10);\n    return 0;\n}",
    "func_graph_path": "ffmpeg/6d1c5ea04af3e345232aa70c944de961061dab2d/tiff.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     int i;\n     int16_t *sp;\n \n-    if (count >= INT_MAX / sizeof(int16_t))\n+    if (count >= INT_MAX / sizeof(int16_t) || count <= 0)\n         return AVERROR_INVALIDDATA;\n     if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n         return AVERROR_INVALIDDATA;",
    "diff_line_info": {
        "deleted_lines": [
            "    if (count >= INT_MAX / sizeof(int16_t))"
        ],
        "added_lines": [
            "    if (count >= INT_MAX / sizeof(int16_t) || count <= 0)"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}