{
    "cve_id": "CVE-2023-48795",
    "cwe_ids": [
        "CWE-354"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cvss_is_v3": true,
    "repo_name": "TeraTermProject/teraterm",
    "commit_msg": "Strict KEX \u5bfe\u5fdc (CVE-2023-48795)\n\n\u3068\u308a\u3042\u3048\u305a Strict KEX \u306e\u30cd\u30b4\u30b7\u30a8\u30fc\u30b7\u30e7\u30f3\u3068\u30b7\u30fc\u30b1\u30f3\u30b9\u756a\u53f7\u306e\u30ea\u30bb\u30c3\u30c8\u306b\u5bfe\u5fdc\u3002",
    "commit_hash": "7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0",
    "git_url": "https://github.com/TeraTermProject/teraterm/commit/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0",
    "file_path": "ttssh2/ttxssh/ssh.c",
    "func_name": "handle_SSH2_kexinit",
    "func_before": "static BOOL handle_SSH2_kexinit(PTInstVar pvar)\n{\n\tchar buf[1024];\n\tchar *data;\n\tint len, size;\n\tchar *msg = NULL;\n\tchar tmp[1024+512];\n\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXINIT was received.\");\n\n\t// \u3059\u3067\u306b\u30ad\u30fc\u4ea4\u63db\u304c\u7d42\u308f\u3063\u3066\u3044\u308b\u306b\u3082\u95a2\u308f\u3089\u305a\u3001\u30b5\u30fc\u30d0\u304b\u3089 SSH2_MSG_KEXINIT \u304c\n\t// \u9001\u3089\u308c\u3066\u304f\u308b\u5834\u5408\u306f\u3001\u30ad\u30fc\u518d\u4f5c\u6210\u3092\u884c\u3046\u3002(2004.10.24 yutaka)\n\tif (pvar->kex_status == KEX_FLAG_KEXDONE) {\n\t\tpvar->kex_status = KEX_FLAG_REKEYING;\n\n\t\t// \u30ad\u30fc\u518d\u4f5c\u6210\u6642\u306f myproposal \u304b\u3089 \",ext-info-c\" \u3092\u524a\u9664\u3059\u308b\n\t\t// \u66f4\u65b0\u3059\u308b\u306e\u306f KEX \u306e\u307f\u3067\u3088\u3044\n\t\tSSH2_update_kex_myproposal(pvar);\n\n\t\t// \u30b5\u30fc\u30d0\u3078SSH2_MSG_KEXINIT \u3092\u9001\u308b\n\t\tSSH2_send_kexinit(pvar);\n\t}\n\n\tdata = remained_payload(pvar);\n\tlen = remained_payloadlen(pvar);\n\n\t// KEX \u306e\u6700\u5f8c\u3067 exchange-hash (session-id) \u3092\u8a08\u7b97\u3059\u308b\u306e\u306b\u4f7f\u3046\u306e\u3067\u4fdd\u5b58\u3057\u3066\u304a\u304f\n\tif (pvar->peer_kex != NULL) {\n\t\t// already allocated\n\t\tbuffer_clear(pvar->peer_kex);\n\t}\n\telse {\n\t\tpvar->peer_kex = buffer_init();\n\t\tif (pvar->peer_kex == NULL) {\n\t\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\t\"%s: Out of memory\", __FUNCTION__);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tbuffer_append(pvar->peer_kex, data, len);\n\n\tpush_memdump(\"KEXINIT\", \"exchange algorithm list: receiving\", data, len);\n\n\t// cookie\n\tif (! get_bytearray_from_payload(pvar, buf, SSH2_COOKIE_LENGTH)) {\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (cookie)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\tCRYPT_set_server_cookie(pvar, buf);\n\n\t// \u5404\u8981\u7d20(\u9375\u4ea4\u63db,\u6697\u53f7\u5316\u7b49)\u3067\u4f7f\u7528\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u6c7a\u5b9a\u3002\n\t// \u30b5\u30fc\u30d0\u304b\u3089\u306f\u30ab\u30f3\u30de\u533a\u5207\u308a\u3067\u306e\u30ea\u30b9\u30c8\u304c\u9001\u3089\u308c\u3066\u6765\u308b\u3002\n\t// \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u3068\u30b5\u30fc\u30d0\u4e21\u65b9\u304c\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u7269\u306e\u3046\u3061\u3001\n\t// \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5074\u3067\u6700\u3082\u524d\u306b\u6307\u5b9a\u3057\u305f\u7269\u304c\u4f7f\u308f\u308c\u308b\u3002\n\n\t// \u9375\u4ea4\u63db\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (kex algorithms)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed kex algorithms is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: KEX algorithm: %s\", buf);\n\n\tpvar->kex_type = choose_SSH2_kex_algorithm(buf, myproposal[PROPOSAL_KEX_ALGS]);\n\tif (pvar->kex_type == KEX_DH_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown KEX algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u30db\u30b9\u30c8\u9375\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (hostkey algorithms)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed hostkey algorithms is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: server host key algorithm: %s\", buf);\n\n\tpvar->hostkey_type = choose_SSH2_host_key_algorithm(buf, myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]);\n\tif (pvar->hostkey_type == KEY_ALGO_UNSPEC) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown host KEY algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u6697\u53f7\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm client to server: %s\", buf);\n\n\tpvar->ciphers[MODE_OUT] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_CTOS]);\n\tif (pvar->ciphers[MODE_OUT] == NULL) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(client to server): \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u6697\u53f7\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30b5\u30fc\u30d0 -> \u30af\u30e9\u30a4\u30a2\u30f3\u30c8)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm server to client: %s\", buf);\n\n\tpvar->ciphers[MODE_IN] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_STOC]);\n\tif (pvar->ciphers[MODE_IN] == NULL) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(server to client): \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// MAC\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm client to server: %s\", buf);\n\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_OUT]) > 0) {\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (client to server)\");\n\t\tpvar->macs[MODE_OUT] = get_ssh2_mac(HMAC_IMPLICIT);\n\t}\n\telse {\n\t\tpvar->macs[MODE_OUT] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_CTOS]);\n\t\tif (pvar->macs[MODE_OUT] == NULL) { // not match\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// MAC\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30b5\u30fc\u30d0 -> \u30af\u30e9\u30a4\u30a2\u30f3\u30c8)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm server to client: %s\", buf);\n\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_IN]) > 0) {\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (server to client)\");\n\t\tpvar->macs[MODE_IN] = get_ssh2_mac(HMAC_IMPLICIT);\n\t}\n\telse {\n\t\tpvar->macs[MODE_IN] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_STOC]);\n\t\tif (pvar->macs[MODE_IN] == NULL) { // not match\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// \u5727\u7e2e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm client to server: %s\", buf);\n\n\tpvar->ctos_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_CTOS]);\n\tif (pvar->ctos_compression == COMP_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u5727\u7e2e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30b5\u30fc\u30d0 -> \u30af\u30e9\u30a4\u30a2\u30f3\u30c8)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm server to client: %s\", buf);\n\n\tpvar->stoc_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_STOC]);\n\tif (pvar->stoc_compression == COMP_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u8a00\u8a9e(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0)\n\t// \u73fe\u72b6\u3067\u306f\u672a\u4f7f\u7528\u3002\u30ed\u30b0\u306b\u8a18\u9332\u3059\u308b\u3060\u3051\u3002\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t// \u8a00\u8a9e\u306e name-list \u304c\u53d6\u308c\u306a\u3044\u3068\u3044\u3046\u4e8b\u306f KEXINIT \u30d1\u30b1\u30c3\u30c8\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u81ea\u4f53\u304c\u60f3\u5b9a\u5916\u3067\u3042\u308a\n\t\t// \u7570\u5e38\u306a\u72b6\u614b\u3067\u3042\u308b\u304c\u3001\u901a\u4fe1\u306b\u5fc5\u8981\u306a\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u3059\u3067\u306b\u30cd\u30b4\u6e08\u307f\u3067\u901a\u4fe1\u81ea\u4f53\u306f\u884c\u3048\u308b\u3002\n\t\t// \u4eca\u307e\u3067\u306f\u3053\u306e\u90e8\u5206\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3063\u3066\u3044\u306a\u304b\u3063\u305f\u306e\u3067\u3001\u8b66\u544a\u3092\u8a18\u9332\u3059\u308b\u306e\u307f\u3067\u51e6\u7406\u3092\u7d9a\u884c\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language client to server)\", __FUNCTION__);\n\t\tgoto skip;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language client to server: %s\", buf);\n\n\t// \u8a00\u8a9e(\u30b5\u30fc\u30d0 -> \u30af\u30e9\u30a4\u30a2\u30f3\u30c8)\n\t// \u73fe\u72b6\u3067\u306f\u672a\u4f7f\u7528\u3002\u30ed\u30b0\u306b\u8a18\u9332\u3059\u308b\u3060\u3051\u3002\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t// \u8a00\u8a9e(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0) \u3068\u540c\u69d8\u306b\u3001\u554f\u984c\u304c\u3042\u3063\u3066\u3082\u8b66\u544a\u306e\u307f\u3068\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language server to client)\", __FUNCTION__);\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language server to client: %s\", buf);\n\n\t// first_kex_packet_follows:\n\t// KEXINIT \u30d1\u30b1\u30c3\u30c8\u306e\u5f8c\u306b\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30cd\u30b4\u7d50\u679c\u3092\u63a8\u6e2c\u3057\u3066\u9375\u4ea4\u63db\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u3063\u3066\u3044\u308b\u304b\u3002\n\t// SSH_MSG_KEXINIT \u306e\u5f8c\u306e\u9375\u4ea4\u63db\u306f\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5074\u304b\u3089\u9001\u308b\u306e\u3067\u30b5\u30fc\u30d0\u5074\u304c 1 \u306b\u3059\u308b\u4e8b\u306f\u306a\u3044\u306f\u305a\u3002\n\tif (!get_boolean_from_payload(pvar, buf)) {\n\t\t// \u8a00\u8a9e(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0) \u3068\u540c\u69d8\u306b\u3001\u554f\u984c\u304c\u3042\u3063\u3066\u3082\u8b66\u544a\u306e\u307f\u3068\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (first_kex_packet_follows)\", __FUNCTION__);\n\t\tgoto skip;\n\t}\n\tif (buf[0] != 0) {\n\t\t// \u524d\u8ff0\u306e\u3088\u3046\u306b\u30b5\u30fc\u30d0\u5074\u306f 0 \u4ee5\u5916\u306b\u3059\u308b\u4e8b\u306f\u306a\u3044\u306f\u305a\u306a\u306e\u3067\u3001\u8b66\u544a\u3092\u8a18\u9332\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: first_kex_packet_follows is not 0. (%d)\", __FUNCTION__, buf[0]);\n\t}\n\n\t// reserved: \u73fe\u72b6\u306f\u5e38\u306b 0 \u3068\u306a\u308b\u3002\n\tif (!get_uint32_from_payload(pvar, &size)) {\n\t\t// \u8a00\u8a9e(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0) \u3068\u540c\u69d8\u306b\u3001\u554f\u984c\u304c\u3042\u3063\u3066\u3082\u8b66\u544a\u306e\u307f\u3068\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (reserved)\", __FUNCTION__ );\n\t\tgoto skip;\n\t}\n\tif (size != 0) {\n\t\tlogprintf(LOG_LEVEL_INFO, \"%s: reserved data is not 0. (%d)\", __FUNCTION__, size);\n\t}\n\nskip:\n\t// \u6c7a\u5b9a\u3057\u305f\u65b9\u5f0f\u3092\u30ed\u30b0\u306b\u51fa\u529b\n\tlogprintf(LOG_LEVEL_VERBOSE, \"KEX algorithm: %s\",\n\t\tget_kex_algorithm_name(pvar->kex_type));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server host key algorithm: %s\",\n\t\tget_ssh2_hostkey_algorithm_name(pvar->hostkey_type));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm client to server: %s\",\n\t\tget_cipher_string(pvar->ciphers[MODE_OUT]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm server to client: %s\",\n\t\tget_cipher_string(pvar->ciphers[MODE_IN]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm client to server: %s\",\n\t\tget_ssh2_mac_name(pvar->macs[MODE_OUT]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm server to client: %s\",\n\t\tget_ssh2_mac_name(pvar->macs[MODE_IN]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm client to server: %s\",\n\t\tget_ssh2_comp_name(pvar->ctos_compression));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm server to client: %s\",\n\t\tget_ssh2_comp_name(pvar->stoc_compression));\n\n\t// we_need\u306e\u6c7a\u5b9a (2004.11.6 yutaka)\n\t// \u30ad\u30fc\u518d\u4f5c\u6210\u306e\u5834\u5408\u306f\u30b9\u30ad\u30c3\u30d7\u3059\u308b\u3002\n\tif ((pvar->kex_status & KEX_FLAG_REKEYING) == 0) {\n\t\tchoose_SSH2_key_maxlength(pvar);\n\t}\n\n\t// send DH kex init\n\tswitch (pvar->kex_type) {\n\t\tcase KEX_DH_GRP1_SHA1:\n\t\tcase KEX_DH_GRP14_SHA1:\n\t\tcase KEX_DH_GRP14_SHA256:\n\t\tcase KEX_DH_GRP16_SHA512:\n\t\tcase KEX_DH_GRP18_SHA512:\n\t\t\tSSH2_dh_kex_init(pvar);\n\t\t\tbreak;\n\t\tcase KEX_DH_GEX_SHA1:\n\t\tcase KEX_DH_GEX_SHA256:\n\t\t\tSSH2_dh_gex_kex_init(pvar);\n\t\t\tbreak;\n\t\tcase KEX_ECDH_SHA2_256:\n\t\tcase KEX_ECDH_SHA2_384:\n\t\tcase KEX_ECDH_SHA2_521:\n\t\t\tSSH2_ecdh_kex_init(pvar);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n\nerror:;\n\tbuffer_free(pvar->peer_kex);\n\tpvar->peer_kex = NULL;\n\n\tnotify_fatal_error(pvar, msg, TRUE);\n\n\treturn FALSE;\n}",
    "abstract_func_before": "static BOOL handle_SSH2_kexinit(PTInstVar VAR_0)\n{\n\tchar VAR_1[1024];\n\tchar *VAR_2;\n\tint VAR_3, VAR_4;\n\tchar *VAR_5 = NULL;\n\tchar VAR_6[1024+512];\n\n\tlogputs(VAR_7, \"SSH2_MSG_KEXINIT was received.\");\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tif (VAR_0->kex_status == VAR_8) {\n\t\tVAR_0->kex_status = VAR_9;\n\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tSSH2_update_kex_myproposal(VAR_0);\n\n\t\t/* COMMENT_4 */\n\t\tSSH2_send_kexinit(VAR_0);\n\t}\n\n\tVAR_2 = remained_payload(VAR_0);\n\tVAR_3 = remained_payloadlen(VAR_0);\n\n\t/* COMMENT_5 */\n\tif (VAR_0->peer_kex != NULL) {\n\t\t/* COMMENT_6 */\n\t\tbuffer_clear(VAR_0->peer_kex);\n\t}\n\telse {\n\t\tVAR_0->peer_kex = buffer_init();\n\t\tif (VAR_0->peer_kex == NULL) {\n\t\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\t\"%s: Out of memory\", VAR_11);\n\t\t\tVAR_5 = VAR_6;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tbuffer_append(VAR_0->peer_kex, VAR_2, VAR_3);\n\n\tpush_memdump(\"KEXINIT\", \"exchange algorithm list: receiving\", VAR_2, VAR_3);\n\n\t/* COMMENT_7 */\n\tif (! get_bytearray_from_payload(VAR_0, VAR_1, VAR_12)) {\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (cookie)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\tCRYPT_set_server_cookie(VAR_0, VAR_1);\n\n\t/* COMMENT_8 */\n\t/* COMMENT_9 */\n\t/* COMMENT_10 */\n\t/* COMMENT_11 */\n\n\t/* COMMENT_12 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (kex algorithms)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed kex algorithms is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: KEX algorithm: %s\", VAR_1);\n\n\tVAR_0->kex_type = choose_SSH2_kex_algorithm(VAR_1, VAR_16[VAR_17]);\n\tif (VAR_0->kex_type == VAR_18) { /* COMMENT_13 */\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown KEX algorithm: \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_14 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (hostkey algorithms)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed hostkey algorithms is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: server host key algorithm: %s\", VAR_1);\n\n\tVAR_0->hostkey_type = choose_SSH2_host_key_algorithm(VAR_1, VAR_16[VAR_19]);\n\tif (VAR_0->hostkey_type == VAR_20) {\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown host KEY algorithm: \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_15 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms client to server)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed encryption algorithms (client to server) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: encryption algorithm client to server: %s\", VAR_1);\n\n\tVAR_0->ciphers[VAR_21] = choose_SSH2_cipher_algorithm(VAR_1, VAR_16[VAR_22]);\n\tif (VAR_0->ciphers[VAR_21] == NULL) {\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown Encrypt algorithm(client to server): \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_16 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms server to client)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed encryption algorithms (server to client) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: encryption algorithm server to client: %s\", VAR_1);\n\n\tVAR_0->ciphers[VAR_23] = choose_SSH2_cipher_algorithm(VAR_1, VAR_16[VAR_24]);\n\tif (VAR_0->ciphers[VAR_23] == NULL) {\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown Encrypt algorithm(server to client): \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_17 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms client to server)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed MAC algorithms (client to server) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: MAC algorithm client to server: %s\", VAR_1);\n\n\tif (get_cipher_auth_len(VAR_0->ciphers[VAR_21]) > 0) {\n\t\tlogputs(VAR_7, \"AEAD cipher is selected, ignoring MAC algorithms. (client to server)\");\n\t\tVAR_0->macs[VAR_21] = get_ssh2_mac(VAR_25);\n\t}\n\telse {\n\t\tVAR_0->macs[VAR_21] = choose_SSH2_mac_algorithm(VAR_1, VAR_16[VAR_26]);\n\t\tif (VAR_0->macs[VAR_21] == NULL) { /* COMMENT_13 */\n\t\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown MAC algorithm: \", VAR_10);\n\t\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\t\tVAR_5 = VAR_6;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* COMMENT_18 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms server to client)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed MAC algorithms (server to client) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: MAC algorithm server to client: %s\", VAR_1);\n\n\tif (get_cipher_auth_len(VAR_0->ciphers[VAR_23]) > 0) {\n\t\tlogputs(VAR_7, \"AEAD cipher is selected, ignoring MAC algorithms. (server to client)\");\n\t\tVAR_0->macs[VAR_23] = get_ssh2_mac(VAR_25);\n\t}\n\telse {\n\t\tVAR_0->macs[VAR_23] = choose_SSH2_mac_algorithm(VAR_1, VAR_16[VAR_27]);\n\t\tif (VAR_0->macs[VAR_23] == NULL) { /* COMMENT_13 */\n\t\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown MAC algorithm: \", VAR_10);\n\t\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\t\tVAR_5 = VAR_6;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* COMMENT_19 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms client to server)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed compression algorithms (client to server) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: compression algorithm client to server: %s\", VAR_1);\n\n\tVAR_0->ctos_compression = choose_SSH2_compression_algorithm(VAR_1, VAR_16[VAR_28]);\n\tif (VAR_0->ctos_compression == VAR_29) { /* COMMENT_13 */\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown Packet Compression algorithm: \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_20 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms server to client)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed compression algorithms (server to client) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: compression algorithm server to client: %s\", VAR_1);\n\n\tVAR_0->stoc_compression = choose_SSH2_compression_algorithm(VAR_1, VAR_16[VAR_30]);\n\tif (VAR_0->stoc_compression == VAR_29) { /* COMMENT_13 */\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown Packet Compression algorithm: \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_21 */\n\t/* COMMENT_22 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t/* COMMENT_23 */\n\t\t/* COMMENT_24 */\n\t\t/* COMMENT_25 */\n\t\tlogprintf(VAR_15, \"%s: truncated packet (language client to server)\", VAR_11);\n\t\tgoto skip;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed language (client to server) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: language client to server: %s\", VAR_1);\n\n\t/* COMMENT_26 */\n\t/* COMMENT_22 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t/* COMMENT_27 */\n\t\tlogprintf(VAR_15, \"%s: truncated packet (language server to client)\", VAR_11);\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed language (server to client) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: language server to client: %s\", VAR_1);\n\n\t/* COMMENT_28 */\n\t/* COMMENT_29 */\n\t/* COMMENT_30 */\n\tif (!get_boolean_from_payload(VAR_0, VAR_1)) {\n\t\t/* COMMENT_27 */\n\t\tlogprintf(VAR_15, \"%s: truncated packet (first_kex_packet_follows)\", VAR_11);\n\t\tgoto skip;\n\t}\n\tif (VAR_1[0] != 0) {\n\t\t/* COMMENT_31 */\n\t\tlogprintf(VAR_15, \"%s: first_kex_packet_follows is not 0. (%d)\", VAR_11, VAR_1[0]);\n\t}\n\n\t/* COMMENT_32 */\n\tif (!get_uint32_from_payload(VAR_0, &VAR_4)) {\n\t\t/* COMMENT_27 */\n\t\tlogprintf(VAR_15, \"%s: truncated packet (reserved)\", VAR_11 );\n\t\tgoto skip;\n\t}\n\tif (VAR_4 != 0) {\n\t\tlogprintf(VAR_31, \"%s: reserved data is not 0. (%d)\", VAR_11, VAR_4);\n\t}\n\nskip:\n\t/* COMMENT_33 */\n\tlogprintf(VAR_7, \"KEX algorithm: %s\",\n\t\tget_kex_algorithm_name(VAR_0->kex_type));\n\n\tlogprintf(VAR_7, \"server host key algorithm: %s\",\n\t\tget_ssh2_hostkey_algorithm_name(VAR_0->hostkey_type));\n\n\tlogprintf(VAR_7, \"encryption algorithm client to server: %s\",\n\t\tget_cipher_string(VAR_0->ciphers[VAR_21]));\n\n\tlogprintf(VAR_7, \"encryption algorithm server to client: %s\",\n\t\tget_cipher_string(VAR_0->ciphers[VAR_23]));\n\n\tlogprintf(VAR_7, \"MAC algorithm client to server: %s\",\n\t\tget_ssh2_mac_name(VAR_0->macs[VAR_21]));\n\n\tlogprintf(VAR_7, \"MAC algorithm server to client: %s\",\n\t\tget_ssh2_mac_name(VAR_0->macs[VAR_23]));\n\n\tlogprintf(VAR_7, \"compression algorithm client to server: %s\",\n\t\tget_ssh2_comp_name(VAR_0->ctos_compression));\n\n\tlogprintf(VAR_7, \"compression algorithm server to client: %s\",\n\t\tget_ssh2_comp_name(VAR_0->stoc_compression));\n\n\t/* COMMENT_34 */\n\t/* COMMENT_35 */\n\tif ((VAR_0->kex_status & VAR_9) == 0) {\n\t\tchoose_SSH2_key_maxlength(VAR_0);\n\t}\n\n\t/* COMMENT_36 */\n\tswitch (VAR_0->kex_type) {\n\t\tcase VAR_32:\n\t\tcase VAR_33:\n\t\tcase VAR_34:\n\t\tcase VAR_35:\n\t\tcase VAR_36:\n\t\t\tSSH2_dh_kex_init(VAR_0);\n\t\t\tbreak;\n\t\tcase VAR_37:\n\t\tcase VAR_38:\n\t\t\tSSH2_dh_gex_kex_init(VAR_0);\n\t\t\tbreak;\n\t\tcase VAR_39:\n\t\tcase VAR_40:\n\t\tcase VAR_41:\n\t\t\tSSH2_ecdh_kex_init(VAR_0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* COMMENT_37 */\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n\nerror:;\n\tbuffer_free(VAR_0->peer_kex);\n\tVAR_0->peer_kex = NULL;\n\n\tnotify_fatal_error(VAR_0, VAR_5, TRUE);\n\n\treturn FALSE;\n}",
    "func_graph_path_before": "TeraTermProject/teraterm/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0/ssh.c/vul/before/1.json",
    "func": "static BOOL handle_SSH2_kexinit(PTInstVar pvar)\n{\n\tchar buf[1024];\n\tchar *data;\n\tint len, size;\n\tchar *msg = NULL;\n\tchar tmp[1024+512];\n\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXINIT was received.\");\n\n\t// \u3059\u3067\u306b\u30ad\u30fc\u4ea4\u63db\u304c\u7d42\u308f\u3063\u3066\u3044\u308b\u306b\u3082\u95a2\u308f\u3089\u305a\u3001\u30b5\u30fc\u30d0\u304b\u3089 SSH2_MSG_KEXINIT \u304c\n\t// \u9001\u3089\u308c\u3066\u304f\u308b\u5834\u5408\u306f\u3001\u30ad\u30fc\u518d\u4f5c\u6210\u3092\u884c\u3046\u3002(2004.10.24 yutaka)\n\tif (pvar->kex_status == KEX_FLAG_KEXDONE) {\n\t\tpvar->kex_status = KEX_FLAG_REKEYING;\n\n\t\t// \u30ad\u30fc\u518d\u4f5c\u6210\u6642\u306f myproposal \u304b\u3089 \",ext-info-c,kex-strict-c-v00@openssh.com\" \u3092\u524a\u9664\u3059\u308b\n\t\t// \u66f4\u65b0\u3059\u308b\u306e\u306f KEX \u306e\u307f\u3067\u3088\u3044\n\t\tSSH2_update_kex_myproposal(pvar);\n\n\t\t// \u30b5\u30fc\u30d0\u3078SSH2_MSG_KEXINIT \u3092\u9001\u308b\n\t\tSSH2_send_kexinit(pvar);\n\t}\n\n\tdata = remained_payload(pvar);\n\tlen = remained_payloadlen(pvar);\n\n\t// KEX \u306e\u6700\u5f8c\u3067 exchange-hash (session-id) \u3092\u8a08\u7b97\u3059\u308b\u306e\u306b\u4f7f\u3046\u306e\u3067\u4fdd\u5b58\u3057\u3066\u304a\u304f\n\tif (pvar->peer_kex != NULL) {\n\t\t// already allocated\n\t\tbuffer_clear(pvar->peer_kex);\n\t}\n\telse {\n\t\tpvar->peer_kex = buffer_init();\n\t\tif (pvar->peer_kex == NULL) {\n\t\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\t\"%s: Out of memory\", __FUNCTION__);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tbuffer_append(pvar->peer_kex, data, len);\n\n\tpush_memdump(\"KEXINIT\", \"exchange algorithm list: receiving\", data, len);\n\n\t// cookie\n\tif (! get_bytearray_from_payload(pvar, buf, SSH2_COOKIE_LENGTH)) {\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (cookie)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\tCRYPT_set_server_cookie(pvar, buf);\n\n\t// \u5404\u8981\u7d20(\u9375\u4ea4\u63db,\u6697\u53f7\u5316\u7b49)\u3067\u4f7f\u7528\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u6c7a\u5b9a\u3002\n\t// \u30b5\u30fc\u30d0\u304b\u3089\u306f\u30ab\u30f3\u30de\u533a\u5207\u308a\u3067\u306e\u30ea\u30b9\u30c8\u304c\u9001\u3089\u308c\u3066\u6765\u308b\u3002\n\t// \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u3068\u30b5\u30fc\u30d0\u4e21\u65b9\u304c\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u7269\u306e\u3046\u3061\u3001\n\t// \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5074\u3067\u6700\u3082\u524d\u306b\u6307\u5b9a\u3057\u305f\u7269\u304c\u4f7f\u308f\u308c\u308b\u3002\n\n\t// \u9375\u4ea4\u63db\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (kex algorithms)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed kex algorithms is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: KEX algorithm: %s\", buf);\n\n\tpvar->kex_type = choose_SSH2_kex_algorithm(buf, myproposal[PROPOSAL_KEX_ALGS]);\n\tif (pvar->kex_type == KEX_DH_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown KEX algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u30b5\u30fc\u30d0\u30fc\u5074\u304cStrict KEX\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u304b\u306e\u78ba\u8a8d\n\tchoose_SSH2_proposal(buf, \"kex-strict-s-v00@openssh.com\", tmp, sizeof(tmp));\n\tif (tmp[0] != '\\0') {\n\t\tpvar->server_strict_kex = TRUE;\n\t\tlogprintf(LOG_LEVEL_INFO, \"Server supports strict kex. Strict kex will be enabled.\");\n\t}\n\n\t// \u30db\u30b9\u30c8\u9375\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (hostkey algorithms)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed hostkey algorithms is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: server host key algorithm: %s\", buf);\n\n\tpvar->hostkey_type = choose_SSH2_host_key_algorithm(buf, myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]);\n\tif (pvar->hostkey_type == KEY_ALGO_UNSPEC) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown host KEY algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u6697\u53f7\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm client to server: %s\", buf);\n\n\tpvar->ciphers[MODE_OUT] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_CTOS]);\n\tif (pvar->ciphers[MODE_OUT] == NULL) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(client to server): \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u6697\u53f7\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30b5\u30fc\u30d0 -> \u30af\u30e9\u30a4\u30a2\u30f3\u30c8)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm server to client: %s\", buf);\n\n\tpvar->ciphers[MODE_IN] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_STOC]);\n\tif (pvar->ciphers[MODE_IN] == NULL) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(server to client): \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// MAC\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm client to server: %s\", buf);\n\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_OUT]) > 0) {\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (client to server)\");\n\t\tpvar->macs[MODE_OUT] = get_ssh2_mac(HMAC_IMPLICIT);\n\t}\n\telse {\n\t\tpvar->macs[MODE_OUT] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_CTOS]);\n\t\tif (pvar->macs[MODE_OUT] == NULL) { // not match\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// MAC\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30b5\u30fc\u30d0 -> \u30af\u30e9\u30a4\u30a2\u30f3\u30c8)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm server to client: %s\", buf);\n\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_IN]) > 0) {\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (server to client)\");\n\t\tpvar->macs[MODE_IN] = get_ssh2_mac(HMAC_IMPLICIT);\n\t}\n\telse {\n\t\tpvar->macs[MODE_IN] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_STOC]);\n\t\tif (pvar->macs[MODE_IN] == NULL) { // not match\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// \u5727\u7e2e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm client to server: %s\", buf);\n\n\tpvar->ctos_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_CTOS]);\n\tif (pvar->ctos_compression == COMP_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u5727\u7e2e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(\u30b5\u30fc\u30d0 -> \u30af\u30e9\u30a4\u30a2\u30f3\u30c8)\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm server to client: %s\", buf);\n\n\tpvar->stoc_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_STOC]);\n\tif (pvar->stoc_compression == COMP_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \u8a00\u8a9e(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0)\n\t// \u73fe\u72b6\u3067\u306f\u672a\u4f7f\u7528\u3002\u30ed\u30b0\u306b\u8a18\u9332\u3059\u308b\u3060\u3051\u3002\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t// \u8a00\u8a9e\u306e name-list \u304c\u53d6\u308c\u306a\u3044\u3068\u3044\u3046\u4e8b\u306f KEXINIT \u30d1\u30b1\u30c3\u30c8\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u81ea\u4f53\u304c\u60f3\u5b9a\u5916\u3067\u3042\u308a\n\t\t// \u7570\u5e38\u306a\u72b6\u614b\u3067\u3042\u308b\u304c\u3001\u901a\u4fe1\u306b\u5fc5\u8981\u306a\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u3059\u3067\u306b\u30cd\u30b4\u6e08\u307f\u3067\u901a\u4fe1\u81ea\u4f53\u306f\u884c\u3048\u308b\u3002\n\t\t// \u4eca\u307e\u3067\u306f\u3053\u306e\u90e8\u5206\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3063\u3066\u3044\u306a\u304b\u3063\u305f\u306e\u3067\u3001\u8b66\u544a\u3092\u8a18\u9332\u3059\u308b\u306e\u307f\u3067\u51e6\u7406\u3092\u7d9a\u884c\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language client to server)\", __FUNCTION__);\n\t\tgoto skip;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language client to server: %s\", buf);\n\n\t// \u8a00\u8a9e(\u30b5\u30fc\u30d0 -> \u30af\u30e9\u30a4\u30a2\u30f3\u30c8)\n\t// \u73fe\u72b6\u3067\u306f\u672a\u4f7f\u7528\u3002\u30ed\u30b0\u306b\u8a18\u9332\u3059\u308b\u3060\u3051\u3002\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t// \u8a00\u8a9e(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0) \u3068\u540c\u69d8\u306b\u3001\u554f\u984c\u304c\u3042\u3063\u3066\u3082\u8b66\u544a\u306e\u307f\u3068\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language server to client)\", __FUNCTION__);\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language server to client: %s\", buf);\n\n\t// first_kex_packet_follows:\n\t// KEXINIT \u30d1\u30b1\u30c3\u30c8\u306e\u5f8c\u306b\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30cd\u30b4\u7d50\u679c\u3092\u63a8\u6e2c\u3057\u3066\u9375\u4ea4\u63db\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u3063\u3066\u3044\u308b\u304b\u3002\n\t// SSH_MSG_KEXINIT \u306e\u5f8c\u306e\u9375\u4ea4\u63db\u306f\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5074\u304b\u3089\u9001\u308b\u306e\u3067\u30b5\u30fc\u30d0\u5074\u304c 1 \u306b\u3059\u308b\u4e8b\u306f\u306a\u3044\u306f\u305a\u3002\n\tif (!get_boolean_from_payload(pvar, buf)) {\n\t\t// \u8a00\u8a9e(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0) \u3068\u540c\u69d8\u306b\u3001\u554f\u984c\u304c\u3042\u3063\u3066\u3082\u8b66\u544a\u306e\u307f\u3068\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (first_kex_packet_follows)\", __FUNCTION__);\n\t\tgoto skip;\n\t}\n\tif (buf[0] != 0) {\n\t\t// \u524d\u8ff0\u306e\u3088\u3046\u306b\u30b5\u30fc\u30d0\u5074\u306f 0 \u4ee5\u5916\u306b\u3059\u308b\u4e8b\u306f\u306a\u3044\u306f\u305a\u306a\u306e\u3067\u3001\u8b66\u544a\u3092\u8a18\u9332\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: first_kex_packet_follows is not 0. (%d)\", __FUNCTION__, buf[0]);\n\t}\n\n\t// reserved: \u73fe\u72b6\u306f\u5e38\u306b 0 \u3068\u306a\u308b\u3002\n\tif (!get_uint32_from_payload(pvar, &size)) {\n\t\t// \u8a00\u8a9e(\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 -> \u30b5\u30fc\u30d0) \u3068\u540c\u69d8\u306b\u3001\u554f\u984c\u304c\u3042\u3063\u3066\u3082\u8b66\u544a\u306e\u307f\u3068\u3059\u308b\u3002\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (reserved)\", __FUNCTION__ );\n\t\tgoto skip;\n\t}\n\tif (size != 0) {\n\t\tlogprintf(LOG_LEVEL_INFO, \"%s: reserved data is not 0. (%d)\", __FUNCTION__, size);\n\t}\n\nskip:\n\t// \u6c7a\u5b9a\u3057\u305f\u65b9\u5f0f\u3092\u30ed\u30b0\u306b\u51fa\u529b\n\tlogprintf(LOG_LEVEL_VERBOSE, \"KEX algorithm: %s\",\n\t\tget_kex_algorithm_name(pvar->kex_type));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server host key algorithm: %s\",\n\t\tget_ssh2_hostkey_algorithm_name(pvar->hostkey_type));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm client to server: %s\",\n\t\tget_cipher_string(pvar->ciphers[MODE_OUT]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm server to client: %s\",\n\t\tget_cipher_string(pvar->ciphers[MODE_IN]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm client to server: %s\",\n\t\tget_ssh2_mac_name(pvar->macs[MODE_OUT]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm server to client: %s\",\n\t\tget_ssh2_mac_name(pvar->macs[MODE_IN]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm client to server: %s\",\n\t\tget_ssh2_comp_name(pvar->ctos_compression));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm server to client: %s\",\n\t\tget_ssh2_comp_name(pvar->stoc_compression));\n\n\t// we_need\u306e\u6c7a\u5b9a (2004.11.6 yutaka)\n\t// \u30ad\u30fc\u518d\u4f5c\u6210\u306e\u5834\u5408\u306f\u30b9\u30ad\u30c3\u30d7\u3059\u308b\u3002\n\tif ((pvar->kex_status & KEX_FLAG_REKEYING) == 0) {\n\t\tchoose_SSH2_key_maxlength(pvar);\n\t}\n\n\t// send DH kex init\n\tswitch (pvar->kex_type) {\n\t\tcase KEX_DH_GRP1_SHA1:\n\t\tcase KEX_DH_GRP14_SHA1:\n\t\tcase KEX_DH_GRP14_SHA256:\n\t\tcase KEX_DH_GRP16_SHA512:\n\t\tcase KEX_DH_GRP18_SHA512:\n\t\t\tSSH2_dh_kex_init(pvar);\n\t\t\tbreak;\n\t\tcase KEX_DH_GEX_SHA1:\n\t\tcase KEX_DH_GEX_SHA256:\n\t\t\tSSH2_dh_gex_kex_init(pvar);\n\t\t\tbreak;\n\t\tcase KEX_ECDH_SHA2_256:\n\t\tcase KEX_ECDH_SHA2_384:\n\t\tcase KEX_ECDH_SHA2_521:\n\t\t\tSSH2_ecdh_kex_init(pvar);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n\nerror:;\n\tbuffer_free(pvar->peer_kex);\n\tpvar->peer_kex = NULL;\n\n\tnotify_fatal_error(pvar, msg, TRUE);\n\n\treturn FALSE;\n}",
    "abstract_func": "static BOOL handle_SSH2_kexinit(PTInstVar VAR_0)\n{\n\tchar VAR_1[1024];\n\tchar *VAR_2;\n\tint VAR_3, VAR_4;\n\tchar *VAR_5 = NULL;\n\tchar VAR_6[1024+512];\n\n\tlogputs(VAR_7, \"SSH2_MSG_KEXINIT was received.\");\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tif (VAR_0->kex_status == VAR_8) {\n\t\tVAR_0->kex_status = VAR_9;\n\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tSSH2_update_kex_myproposal(VAR_0);\n\n\t\t/* COMMENT_4 */\n\t\tSSH2_send_kexinit(VAR_0);\n\t}\n\n\tVAR_2 = remained_payload(VAR_0);\n\tVAR_3 = remained_payloadlen(VAR_0);\n\n\t/* COMMENT_5 */\n\tif (VAR_0->peer_kex != NULL) {\n\t\t/* COMMENT_6 */\n\t\tbuffer_clear(VAR_0->peer_kex);\n\t}\n\telse {\n\t\tVAR_0->peer_kex = buffer_init();\n\t\tif (VAR_0->peer_kex == NULL) {\n\t\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\t\"%s: Out of memory\", VAR_11);\n\t\t\tVAR_5 = VAR_6;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tbuffer_append(VAR_0->peer_kex, VAR_2, VAR_3);\n\n\tpush_memdump(\"KEXINIT\", \"exchange algorithm list: receiving\", VAR_2, VAR_3);\n\n\t/* COMMENT_7 */\n\tif (! get_bytearray_from_payload(VAR_0, VAR_1, VAR_12)) {\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (cookie)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\tCRYPT_set_server_cookie(VAR_0, VAR_1);\n\n\t/* COMMENT_8 */\n\t/* COMMENT_9 */\n\t/* COMMENT_10 */\n\t/* COMMENT_11 */\n\n\t/* COMMENT_12 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (kex algorithms)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed kex algorithms is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: KEX algorithm: %s\", VAR_1);\n\n\tVAR_0->kex_type = choose_SSH2_kex_algorithm(VAR_1, VAR_16[VAR_17]);\n\tif (VAR_0->kex_type == VAR_18) { /* COMMENT_13 */\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown KEX algorithm: \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_14 */\n\tchoose_SSH2_proposal(VAR_1, \"kex-strict-s-v00@openssh.com\", VAR_6, sizeof(VAR_6));\n\tif (VAR_6[0] != '\\0') {\n\t\tVAR_0->server_strict_kex = TRUE;\n\t\tlogprintf(VAR_19, \"Server supports strict kex. Strict kex will be enabled.\");\n\t}\n\n\t/* COMMENT_15 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (hostkey algorithms)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed hostkey algorithms is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: server host key algorithm: %s\", VAR_1);\n\n\tVAR_0->hostkey_type = choose_SSH2_host_key_algorithm(VAR_1, VAR_16[VAR_20]);\n\tif (VAR_0->hostkey_type == VAR_21) {\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown host KEY algorithm: \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_16 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms client to server)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed encryption algorithms (client to server) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: encryption algorithm client to server: %s\", VAR_1);\n\n\tVAR_0->ciphers[VAR_22] = choose_SSH2_cipher_algorithm(VAR_1, VAR_16[VAR_23]);\n\tif (VAR_0->ciphers[VAR_22] == NULL) {\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown Encrypt algorithm(client to server): \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_17 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms server to client)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed encryption algorithms (server to client) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: encryption algorithm server to client: %s\", VAR_1);\n\n\tVAR_0->ciphers[VAR_24] = choose_SSH2_cipher_algorithm(VAR_1, VAR_16[VAR_25]);\n\tif (VAR_0->ciphers[VAR_24] == NULL) {\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown Encrypt algorithm(server to client): \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_18 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms client to server)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed MAC algorithms (client to server) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: MAC algorithm client to server: %s\", VAR_1);\n\n\tif (get_cipher_auth_len(VAR_0->ciphers[VAR_22]) > 0) {\n\t\tlogputs(VAR_7, \"AEAD cipher is selected, ignoring MAC algorithms. (client to server)\");\n\t\tVAR_0->macs[VAR_22] = get_ssh2_mac(VAR_26);\n\t}\n\telse {\n\t\tVAR_0->macs[VAR_22] = choose_SSH2_mac_algorithm(VAR_1, VAR_16[VAR_27]);\n\t\tif (VAR_0->macs[VAR_22] == NULL) { /* COMMENT_13 */\n\t\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown MAC algorithm: \", VAR_10);\n\t\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\t\tVAR_5 = VAR_6;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* COMMENT_19 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms server to client)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed MAC algorithms (server to client) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: MAC algorithm server to client: %s\", VAR_1);\n\n\tif (get_cipher_auth_len(VAR_0->ciphers[VAR_24]) > 0) {\n\t\tlogputs(VAR_7, \"AEAD cipher is selected, ignoring MAC algorithms. (server to client)\");\n\t\tVAR_0->macs[VAR_24] = get_ssh2_mac(VAR_26);\n\t}\n\telse {\n\t\tVAR_0->macs[VAR_24] = choose_SSH2_mac_algorithm(VAR_1, VAR_16[VAR_28]);\n\t\tif (VAR_0->macs[VAR_24] == NULL) { /* COMMENT_13 */\n\t\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown MAC algorithm: \", VAR_10);\n\t\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\t\tVAR_5 = VAR_6;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* COMMENT_20 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms client to server)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed compression algorithms (client to server) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: compression algorithm client to server: %s\", VAR_1);\n\n\tVAR_0->ctos_compression = choose_SSH2_compression_algorithm(VAR_1, VAR_16[VAR_29]);\n\tif (VAR_0->ctos_compression == VAR_30) { /* COMMENT_13 */\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown Packet Compression algorithm: \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_21 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t_snprintf_s(VAR_6, sizeof(VAR_6), VAR_10,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms server to client)\", VAR_11);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed compression algorithms (server to client) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: compression algorithm server to client: %s\", VAR_1);\n\n\tVAR_0->stoc_compression = choose_SSH2_compression_algorithm(VAR_1, VAR_16[VAR_31]);\n\tif (VAR_0->stoc_compression == VAR_30) { /* COMMENT_13 */\n\t\tstrncpy_s(VAR_6, sizeof(VAR_6), \"unknown Packet Compression algorithm: \", VAR_10);\n\t\tstrncat_s(VAR_6, sizeof(VAR_6), VAR_1, VAR_10);\n\t\tVAR_5 = VAR_6;\n\t\tgoto error;\n\t}\n\n\t/* COMMENT_22 */\n\t/* COMMENT_23 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t/* COMMENT_24 */\n\t\t/* COMMENT_25 */\n\t\t/* COMMENT_26 */\n\t\tlogprintf(VAR_15, \"%s: truncated packet (language client to server)\", VAR_11);\n\t\tgoto skip;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed language (client to server) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: language client to server: %s\", VAR_1);\n\n\t/* COMMENT_27 */\n\t/* COMMENT_23 */\n\tswitch (get_namelist_from_payload(VAR_0, VAR_1, sizeof(VAR_1), &VAR_4)) {\n\tcase VAR_13:\n\t\t/* COMMENT_28 */\n\t\tlogprintf(VAR_15, \"%s: truncated packet (language server to client)\", VAR_11);\n\t\tgoto error;\n\tcase VAR_14:\n\t\tlogprintf(VAR_15, \"%s: server proposed language (server to client) is too long.\", VAR_11);\n\t\tbreak;\n\t}\n\n\tlogprintf(VAR_7, \"server proposal: language server to client: %s\", VAR_1);\n\n\t/* COMMENT_29 */\n\t/* COMMENT_30 */\n\t/* COMMENT_31 */\n\tif (!get_boolean_from_payload(VAR_0, VAR_1)) {\n\t\t/* COMMENT_28 */\n\t\tlogprintf(VAR_15, \"%s: truncated packet (first_kex_packet_follows)\", VAR_11);\n\t\tgoto skip;\n\t}\n\tif (VAR_1[0] != 0) {\n\t\t/* COMMENT_32 */\n\t\tlogprintf(VAR_15, \"%s: first_kex_packet_follows is not 0. (%d)\", VAR_11, VAR_1[0]);\n\t}\n\n\t/* COMMENT_33 */\n\tif (!get_uint32_from_payload(VAR_0, &VAR_4)) {\n\t\t/* COMMENT_28 */\n\t\tlogprintf(VAR_15, \"%s: truncated packet (reserved)\", VAR_11 );\n\t\tgoto skip;\n\t}\n\tif (VAR_4 != 0) {\n\t\tlogprintf(VAR_19, \"%s: reserved data is not 0. (%d)\", VAR_11, VAR_4);\n\t}\n\nskip:\n\t/* COMMENT_34 */\n\tlogprintf(VAR_7, \"KEX algorithm: %s\",\n\t\tget_kex_algorithm_name(VAR_0->kex_type));\n\n\tlogprintf(VAR_7, \"server host key algorithm: %s\",\n\t\tget_ssh2_hostkey_algorithm_name(VAR_0->hostkey_type));\n\n\tlogprintf(VAR_7, \"encryption algorithm client to server: %s\",\n\t\tget_cipher_string(VAR_0->ciphers[VAR_22]));\n\n\tlogprintf(VAR_7, \"encryption algorithm server to client: %s\",\n\t\tget_cipher_string(VAR_0->ciphers[VAR_24]));\n\n\tlogprintf(VAR_7, \"MAC algorithm client to server: %s\",\n\t\tget_ssh2_mac_name(VAR_0->macs[VAR_22]));\n\n\tlogprintf(VAR_7, \"MAC algorithm server to client: %s\",\n\t\tget_ssh2_mac_name(VAR_0->macs[VAR_24]));\n\n\tlogprintf(VAR_7, \"compression algorithm client to server: %s\",\n\t\tget_ssh2_comp_name(VAR_0->ctos_compression));\n\n\tlogprintf(VAR_7, \"compression algorithm server to client: %s\",\n\t\tget_ssh2_comp_name(VAR_0->stoc_compression));\n\n\t/* COMMENT_35 */\n\t/* COMMENT_36 */\n\tif ((VAR_0->kex_status & VAR_9) == 0) {\n\t\tchoose_SSH2_key_maxlength(VAR_0);\n\t}\n\n\t/* COMMENT_37 */\n\tswitch (VAR_0->kex_type) {\n\t\tcase VAR_32:\n\t\tcase VAR_33:\n\t\tcase VAR_34:\n\t\tcase VAR_35:\n\t\tcase VAR_36:\n\t\t\tSSH2_dh_kex_init(VAR_0);\n\t\t\tbreak;\n\t\tcase VAR_37:\n\t\tcase VAR_38:\n\t\t\tSSH2_dh_gex_kex_init(VAR_0);\n\t\t\tbreak;\n\t\tcase VAR_39:\n\t\tcase VAR_40:\n\t\tcase VAR_41:\n\t\t\tSSH2_ecdh_kex_init(VAR_0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* COMMENT_38 */\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n\nerror:;\n\tbuffer_free(VAR_0->peer_kex);\n\tVAR_0->peer_kex = NULL;\n\n\tnotify_fatal_error(VAR_0, VAR_5, TRUE);\n\n\treturn FALSE;\n}",
    "func_graph_path": "TeraTermProject/teraterm/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0/ssh.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \tif (pvar->kex_status == KEX_FLAG_KEXDONE) {\n \t\tpvar->kex_status = KEX_FLAG_REKEYING;\n \n-\t\t// \u30ad\u30fc\u518d\u4f5c\u6210\u6642\u306f myproposal \u304b\u3089 \",ext-info-c\" \u3092\u524a\u9664\u3059\u308b\n+\t\t// \u30ad\u30fc\u518d\u4f5c\u6210\u6642\u306f myproposal \u304b\u3089 \",ext-info-c,kex-strict-c-v00@openssh.com\" \u3092\u524a\u9664\u3059\u308b\n \t\t// \u66f4\u65b0\u3059\u308b\u306e\u306f KEX \u306e\u307f\u3067\u3088\u3044\n \t\tSSH2_update_kex_myproposal(pvar);\n \n@@ -76,6 +76,13 @@\n \t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n \t\tmsg = tmp;\n \t\tgoto error;\n+\t}\n+\n+\t// \u30b5\u30fc\u30d0\u30fc\u5074\u304cStrict KEX\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u304b\u306e\u78ba\u8a8d\n+\tchoose_SSH2_proposal(buf, \"kex-strict-s-v00@openssh.com\", tmp, sizeof(tmp));\n+\tif (tmp[0] != '\\0') {\n+\t\tpvar->server_strict_kex = TRUE;\n+\t\tlogprintf(LOG_LEVEL_INFO, \"Server supports strict kex. Strict kex will be enabled.\");\n \t}\n \n \t// \u30db\u30b9\u30c8\u9375\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t// \u30ad\u30fc\u518d\u4f5c\u6210\u6642\u306f myproposal \u304b\u3089 \",ext-info-c\" \u3092\u524a\u9664\u3059\u308b"
        ],
        "added_lines": [
            "\t\t// \u30ad\u30fc\u518d\u4f5c\u6210\u6642\u306f myproposal \u304b\u3089 \",ext-info-c,kex-strict-c-v00@openssh.com\" \u3092\u524a\u9664\u3059\u308b",
            "\t}",
            "",
            "\t// \u30b5\u30fc\u30d0\u30fc\u5074\u304cStrict KEX\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u304b\u306e\u78ba\u8a8d",
            "\tchoose_SSH2_proposal(buf, \"kex-strict-s-v00@openssh.com\", tmp, sizeof(tmp));",
            "\tif (tmp[0] != '\\0') {",
            "\t\tpvar->server_strict_kex = TRUE;",
            "\t\tlogprintf(LOG_LEVEL_INFO, \"Server supports strict kex. Strict kex will be enabled.\");"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/TeraTermProject/teraterm/pull/54",
    "description": "OpenSSH\u306estrice KEX\u306b\u5bfe\u5fdc\u3057\u305f\u3002\r\nTerrapin Attack\u3078\u306e\u5bfe\u5fdc\u3002https://www.terrapin-attack.com"
}