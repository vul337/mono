{
    "cve_id": "CVE-2023-0464",
    "cwe_ids": [
        "CWE-295"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "openssl",
    "commit_msg": "\nx509: excessive resource use verifying policy constraints\n\nA security vulnerability has been identified in all supported versions\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nFixes CVE-2023-0464\n\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/20569)\n",
    "commit_hash": "879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
    "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
    "file_path": "crypto/x509v3/pcy_node.c",
    "func_name": "level_add_node",
    "func_before": "X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,\n                                 X509_POLICY_DATA *data,\n                                 X509_POLICY_NODE *parent,\n                                 X509_POLICY_TREE *tree)\n{\n    X509_POLICY_NODE *node;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (tree) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    policy_node_free(node);\n    return NULL;\n}",
    "abstract_func_before": "X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *VAR_0,\n                                 X509_POLICY_DATA *VAR_1,\n                                 X509_POLICY_NODE *VAR_2,\n                                 X509_POLICY_TREE *VAR_3)\n{\n    X509_POLICY_NODE *VAR_4;\n\n    VAR_4 = OPENSSL_zalloc(sizeof(*VAR_4));\n    if (VAR_4 == NULL) {\n        X509V3err(VAR_5, VAR_6);\n        return NULL;\n    }\n    VAR_4->data = VAR_1;\n    VAR_4->parent = VAR_2;\n    if (VAR_0) {\n        if (OBJ_obj2nid(VAR_1->valid_policy) == VAR_7) {\n            if (VAR_0->anyPolicy)\n                goto node_error;\n            VAR_0->anyPolicy = VAR_4;\n        } else {\n\n            if (VAR_0->nodes == NULL)\n                VAR_0->nodes = policy_node_cmp_new();\n            if (VAR_0->nodes == NULL) {\n                X509V3err(VAR_5, VAR_6);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(VAR_0->nodes, VAR_4)) {\n                X509V3err(VAR_5, VAR_6);\n                goto node_error;\n            }\n        }\n    }\n\n    if (VAR_3) {\n        if (VAR_3->extra_data == NULL)\n            VAR_3->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (VAR_3->extra_data == NULL){\n            X509V3err(VAR_5, VAR_6);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(VAR_3->extra_data, VAR_1)) {\n            X509V3err(VAR_5, VAR_6);\n            goto node_error;\n        }\n    }\n\n    if (VAR_2)\n        VAR_2->nchild++;\n\n    return VAR_4;\n\n node_error:\n    policy_node_free(VAR_4);\n    return NULL;\n}",
    "func_graph_path_before": "openssl/879f7080d7e141f415c79eaa3a8ac4a3dad0348b/pcy_node.c/vul/before/0.json",
    "func": "X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,\n                                 X509_POLICY_DATA *data,\n                                 X509_POLICY_NODE *parent,\n                                 X509_POLICY_TREE *tree,\n                                 int extra_data)\n{\n    X509_POLICY_NODE *node;\n\n    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n        return NULL;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level != NULL) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (extra_data) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    tree->node_count++;\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    policy_node_free(node);\n    return NULL;\n}",
    "abstract_func": "X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *VAR_0,\n                                 X509_POLICY_DATA *VAR_1,\n                                 X509_POLICY_NODE *VAR_2,\n                                 X509_POLICY_TREE *VAR_3,\n                                 int VAR_4)\n{\n    X509_POLICY_NODE *VAR_5;\n\n    /* COMMENT_0 */\n    if (VAR_3->node_maximum > 0 && VAR_3->node_count >= VAR_3->node_maximum)\n        return NULL;\n\n    VAR_5 = OPENSSL_zalloc(sizeof(*VAR_5));\n    if (VAR_5 == NULL) {\n        X509V3err(VAR_6, VAR_7);\n        return NULL;\n    }\n    VAR_5->data = VAR_1;\n    VAR_5->parent = VAR_2;\n    if (VAR_0 != NULL) {\n        if (OBJ_obj2nid(VAR_1->valid_policy) == VAR_8) {\n            if (VAR_0->anyPolicy)\n                goto node_error;\n            VAR_0->anyPolicy = VAR_5;\n        } else {\n\n            if (VAR_0->nodes == NULL)\n                VAR_0->nodes = policy_node_cmp_new();\n            if (VAR_0->nodes == NULL) {\n                X509V3err(VAR_6, VAR_7);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(VAR_0->nodes, VAR_5)) {\n                X509V3err(VAR_6, VAR_7);\n                goto node_error;\n            }\n        }\n    }\n\n    if (VAR_4) {\n        if (VAR_3->extra_data == NULL)\n            VAR_3->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (VAR_3->extra_data == NULL){\n            X509V3err(VAR_6, VAR_7);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(VAR_3->extra_data, VAR_1)) {\n            X509V3err(VAR_6, VAR_7);\n            goto node_error;\n        }\n    }\n\n    VAR_3->node_count++;\n    if (VAR_2)\n        VAR_2->nchild++;\n\n    return VAR_5;\n\n node_error:\n    policy_node_free(VAR_5);\n    return NULL;\n}",
    "func_graph_path": "openssl/879f7080d7e141f415c79eaa3a8ac4a3dad0348b/pcy_node.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,14 @@\n X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,\n                                  X509_POLICY_DATA *data,\n                                  X509_POLICY_NODE *parent,\n-                                 X509_POLICY_TREE *tree)\n+                                 X509_POLICY_TREE *tree,\n+                                 int extra_data)\n {\n     X509_POLICY_NODE *node;\n+\n+    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n+    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n+        return NULL;\n \n     node = OPENSSL_zalloc(sizeof(*node));\n     if (node == NULL) {\n@@ -12,7 +17,7 @@\n     }\n     node->data = data;\n     node->parent = parent;\n-    if (level) {\n+    if (level != NULL) {\n         if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n             if (level->anyPolicy)\n                 goto node_error;\n@@ -32,7 +37,7 @@\n         }\n     }\n \n-    if (tree) {\n+    if (extra_data) {\n         if (tree->extra_data == NULL)\n             tree->extra_data = sk_X509_POLICY_DATA_new_null();\n         if (tree->extra_data == NULL){\n@@ -45,6 +50,7 @@\n         }\n     }\n \n+    tree->node_count++;\n     if (parent)\n         parent->nchild++;\n ",
    "diff_line_info": {
        "deleted_lines": [
            "                                 X509_POLICY_TREE *tree)",
            "    if (level) {",
            "    if (tree) {"
        ],
        "added_lines": [
            "                                 X509_POLICY_TREE *tree,",
            "                                 int extra_data)",
            "",
            "    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */",
            "    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)",
            "        return NULL;",
            "    if (level != NULL) {",
            "    if (extra_data) {",
            "    tree->node_count++;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}