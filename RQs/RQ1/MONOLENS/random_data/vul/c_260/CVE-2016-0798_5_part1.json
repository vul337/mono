{
    "cve_id": "CVE-2016-0798",
    "cwe_ids": [
        "CWE-399"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "openssl",
    "commit_msg": "\nCVE-2016-0798: avoid memory leak in SRP\n\nThe SRP user database lookup method SRP_VBASE_get_by_user had confusing\nmemory management semantics; the returned pointer was sometimes newly\nallocated, and sometimes owned by the callee. The calling code has no\nway of distinguishing these two cases.\n\nSpecifically, SRP servers that configure a secret seed to hide valid\nlogin information are vulnerable to a memory leak: an attacker\nconnecting with an invalid username can cause a memory leak of around\n300 bytes per connection.\n\nServers that do not configure SRP, or configure SRP but do not configure\na seed are not vulnerable.\n\nIn Apache, the seed directive is known as SSLSRPUnknownUserSeed.\n\nTo mitigate the memory leak, the seed handling in SRP_VBASE_get_by_user\nis now disabled even if the user has configured a seed.\n\nApplications are advised to migrate to SRP_VBASE_get1_by_user. However,\nnote that OpenSSL makes no strong guarantees about the\nindistinguishability of valid and invalid logins. In particular,\ncomputations are currently not carried out in constant time.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n",
    "commit_hash": "259b664f950c2ba66fbf4b0fe5281327904ead21",
    "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=259b664f950c2ba66fbf4b0fe5281327904ead21",
    "file_path": "crypto/srp/srp_vfy.c",
    "func_name": "SRP_VBASE_get_by_user",
    "func_before": "SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\n{\n    int i;\n    SRP_user_pwd *user;\n    unsigned char digv[SHA_DIGEST_LENGTH];\n    unsigned char digs[SHA_DIGEST_LENGTH];\n    EVP_MD_CTX ctxt;\n\n    if (vb == NULL)\n        return NULL;\n    for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {\n        user = sk_SRP_user_pwd_value(vb->users_pwd, i);\n        if (strcmp(user->id, username) == 0)\n            return user;\n    }\n    if ((vb->seed_key == NULL) ||\n        (vb->default_g == NULL) || (vb->default_N == NULL))\n        return NULL;\n\n/* if the user is unknown we set parameters as well if we have a seed_key */\n\n    if ((user = SRP_user_pwd_new()) == NULL)\n        return NULL;\n\n    SRP_user_pwd_set_gN(user, vb->default_g, vb->default_N);\n\n    if (!SRP_user_pwd_set_ids(user, username, NULL))\n        goto err;\n\n    if (RAND_pseudo_bytes(digv, SHA_DIGEST_LENGTH) < 0)\n        goto err;\n    EVP_MD_CTX_init(&ctxt);\n    EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\n    EVP_DigestUpdate(&ctxt, vb->seed_key, strlen(vb->seed_key));\n    EVP_DigestUpdate(&ctxt, username, strlen(username));\n    EVP_DigestFinal_ex(&ctxt, digs, NULL);\n    EVP_MD_CTX_cleanup(&ctxt);\n    if (SRP_user_pwd_set_sv_BN\n        (user, BN_bin2bn(digs, SHA_DIGEST_LENGTH, NULL),\n         BN_bin2bn(digv, SHA_DIGEST_LENGTH, NULL)))\n        return user;\n\n err:SRP_user_pwd_free(user);\n    return NULL;\n}",
    "abstract_func_before": "SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *VAR_0, char *VAR_1)\n{\n    int VAR_2;\n    SRP_user_pwd *VAR_3;\n    unsigned char VAR_4[VAR_5];\n    unsigned char VAR_6[VAR_5];\n    EVP_MD_CTX VAR_7;\n\n    if (VAR_0 == NULL)\n        return NULL;\n    for (VAR_2 = 0; VAR_2 < sk_SRP_user_pwd_num(VAR_0->users_pwd); VAR_2++) {\n        VAR_3 = sk_SRP_user_pwd_value(VAR_0->users_pwd, VAR_2);\n        if (strcmp(VAR_3->id, VAR_1) == 0)\n            return VAR_3;\n    }\n    if ((VAR_0->seed_key == NULL) ||\n        (VAR_0->default_g == NULL) || (VAR_0->default_N == NULL))\n        return NULL;\n\n/* COMMENT_0 */\n\n    if ((VAR_3 = SRP_user_pwd_new()) == NULL)\n        return NULL;\n\n    SRP_user_pwd_set_gN(VAR_3, VAR_0->default_g, VAR_0->default_N);\n\n    if (!SRP_user_pwd_set_ids(VAR_3, VAR_1, NULL))\n        goto err;\n\n    if (RAND_pseudo_bytes(VAR_4, VAR_5) < 0)\n        goto err;\n    EVP_MD_CTX_init(&VAR_7);\n    EVP_DigestInit_ex(&VAR_7, EVP_sha1(), NULL);\n    EVP_DigestUpdate(&VAR_7, VAR_0->seed_key, strlen(VAR_0->seed_key));\n    EVP_DigestUpdate(&VAR_7, VAR_1, strlen(VAR_1));\n    EVP_DigestFinal_ex(&VAR_7, VAR_6, NULL);\n    EVP_MD_CTX_cleanup(&VAR_7);\n    if (SRP_user_pwd_set_sv_BN\n        (VAR_3, BN_bin2bn(VAR_6, VAR_5, NULL),\n         BN_bin2bn(VAR_4, VAR_5, NULL)))\n        return VAR_3;\n\n err:SRP_user_pwd_free(VAR_3);\n    return NULL;\n}",
    "func_graph_path_before": "openssl/259b664f950c2ba66fbf4b0fe5281327904ead21/srp_vfy.c/vul/before/1.json",
    "func": "SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\n{\n    return find_user(vb, username);\n}",
    "abstract_func": "SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *VAR_0, char *VAR_1)\n{\n    return find_user(VAR_0, VAR_1);\n}",
    "func_graph_path": "openssl/259b664f950c2ba66fbf4b0fe5281327904ead21/srp_vfy.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,45 +1,4 @@\n SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\n {\n-    int i;\n-    SRP_user_pwd *user;\n-    unsigned char digv[SHA_DIGEST_LENGTH];\n-    unsigned char digs[SHA_DIGEST_LENGTH];\n-    EVP_MD_CTX ctxt;\n-\n-    if (vb == NULL)\n-        return NULL;\n-    for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {\n-        user = sk_SRP_user_pwd_value(vb->users_pwd, i);\n-        if (strcmp(user->id, username) == 0)\n-            return user;\n-    }\n-    if ((vb->seed_key == NULL) ||\n-        (vb->default_g == NULL) || (vb->default_N == NULL))\n-        return NULL;\n-\n-/* if the user is unknown we set parameters as well if we have a seed_key */\n-\n-    if ((user = SRP_user_pwd_new()) == NULL)\n-        return NULL;\n-\n-    SRP_user_pwd_set_gN(user, vb->default_g, vb->default_N);\n-\n-    if (!SRP_user_pwd_set_ids(user, username, NULL))\n-        goto err;\n-\n-    if (RAND_pseudo_bytes(digv, SHA_DIGEST_LENGTH) < 0)\n-        goto err;\n-    EVP_MD_CTX_init(&ctxt);\n-    EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\n-    EVP_DigestUpdate(&ctxt, vb->seed_key, strlen(vb->seed_key));\n-    EVP_DigestUpdate(&ctxt, username, strlen(username));\n-    EVP_DigestFinal_ex(&ctxt, digs, NULL);\n-    EVP_MD_CTX_cleanup(&ctxt);\n-    if (SRP_user_pwd_set_sv_BN\n-        (user, BN_bin2bn(digs, SHA_DIGEST_LENGTH, NULL),\n-         BN_bin2bn(digv, SHA_DIGEST_LENGTH, NULL)))\n-        return user;\n-\n- err:SRP_user_pwd_free(user);\n-    return NULL;\n+    return find_user(vb, username);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "    int i;",
            "    SRP_user_pwd *user;",
            "    unsigned char digv[SHA_DIGEST_LENGTH];",
            "    unsigned char digs[SHA_DIGEST_LENGTH];",
            "    EVP_MD_CTX ctxt;",
            "",
            "    if (vb == NULL)",
            "        return NULL;",
            "    for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {",
            "        user = sk_SRP_user_pwd_value(vb->users_pwd, i);",
            "        if (strcmp(user->id, username) == 0)",
            "            return user;",
            "    }",
            "    if ((vb->seed_key == NULL) ||",
            "        (vb->default_g == NULL) || (vb->default_N == NULL))",
            "        return NULL;",
            "",
            "/* if the user is unknown we set parameters as well if we have a seed_key */",
            "",
            "    if ((user = SRP_user_pwd_new()) == NULL)",
            "        return NULL;",
            "",
            "    SRP_user_pwd_set_gN(user, vb->default_g, vb->default_N);",
            "",
            "    if (!SRP_user_pwd_set_ids(user, username, NULL))",
            "        goto err;",
            "",
            "    if (RAND_pseudo_bytes(digv, SHA_DIGEST_LENGTH) < 0)",
            "        goto err;",
            "    EVP_MD_CTX_init(&ctxt);",
            "    EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);",
            "    EVP_DigestUpdate(&ctxt, vb->seed_key, strlen(vb->seed_key));",
            "    EVP_DigestUpdate(&ctxt, username, strlen(username));",
            "    EVP_DigestFinal_ex(&ctxt, digs, NULL);",
            "    EVP_MD_CTX_cleanup(&ctxt);",
            "    if (SRP_user_pwd_set_sv_BN",
            "        (user, BN_bin2bn(digs, SHA_DIGEST_LENGTH, NULL),",
            "         BN_bin2bn(digv, SHA_DIGEST_LENGTH, NULL)))",
            "        return user;",
            "",
            " err:SRP_user_pwd_free(user);",
            "    return NULL;"
        ],
        "added_lines": [
            "    return find_user(vb, username);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}