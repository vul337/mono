{
    "cve_id": "CVE-2014-0101",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "net: sctp: fix sctp_sf_do_5_1D_ce to verify if we/peer is AUTH capable\n\nRFC4895 introduced AUTH chunks for SCTP; during the SCTP\nhandshake RANDOM; CHUNKS; HMAC-ALGO are negotiated (CHUNKS\nbeing optional though):\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nA special case is when an endpoint requires COOKIE-ECHO\nchunks to be authenticated:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  ------------------ AUTH; COOKIE-ECHO ---------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nRFC4895, section 6.3. Receiving Authenticated Chunks says:\n\n  The receiver MUST use the HMAC algorithm indicated in\n  the HMAC Identifier field. If this algorithm was not\n  specified by the receiver in the HMAC-ALGO parameter in\n  the INIT or INIT-ACK chunk during association setup, the\n  AUTH chunk and all the chunks after it MUST be discarded\n  and an ERROR chunk SHOULD be sent with the error cause\n  defined in Section 4.1. [...] If no endpoint pair shared\n  key has been configured for that Shared Key Identifier,\n  all authenticated chunks MUST be silently discarded. [...]\n\n  When an endpoint requires COOKIE-ECHO chunks to be\n  authenticated, some special procedures have to be followed\n  because the reception of a COOKIE-ECHO chunk might result\n  in the creation of an SCTP association. If a packet arrives\n  containing an AUTH chunk as a first chunk, a COOKIE-ECHO\n  chunk as the second chunk, and possibly more chunks after\n  them, and the receiver does not have an STCB for that\n  packet, then authentication is based on the contents of\n  the COOKIE-ECHO chunk. In this situation, the receiver MUST\n  authenticate the chunks in the packet by using the RANDOM\n  parameters, CHUNKS parameters and HMAC_ALGO parameters\n  obtained from the COOKIE-ECHO chunk, and possibly a local\n  shared secret as inputs to the authentication procedure\n  specified in Section 6.3. If authentication fails, then\n  the packet is discarded. If the authentication is successful,\n  the COOKIE-ECHO and all the chunks after the COOKIE-ECHO\n  MUST be processed. If the receiver has an STCB, it MUST\n  process the AUTH chunk as described above using the STCB\n  from the existing association to authenticate the\n  COOKIE-ECHO chunk and all the chunks after it. [...]\n\nCommit bbd0d59809f9 introduced the possibility to receive\nand verification of AUTH chunk, including the edge case for\nauthenticated COOKIE-ECHO. On reception of COOKIE-ECHO,\nthe function sctp_sf_do_5_1D_ce() handles processing,\nunpacks and creates a new association if it passed sanity\nchecks and also tests for authentication chunks being\npresent. After a new association has been processed, it\ninvokes sctp_process_init() on the new association and\nwalks through the parameter list it received from the INIT\nchunk. It checks SCTP_PARAM_RANDOM, SCTP_PARAM_HMAC_ALGO\nand SCTP_PARAM_CHUNKS, and copies them into asoc->peer\nmeta data (peer_random, peer_hmacs, peer_chunks) in case\nsysctl -w net.sctp.auth_enable=1 is set. If in INIT's\nSCTP_PARAM_SUPPORTED_EXT parameter SCTP_CID_AUTH is set,\npeer_random != NULL and peer_hmacs != NULL the peer is to be\nassumed asoc->peer.auth_capable=1, in any other case\nasoc->peer.auth_capable=0.\n\nNow, if in sctp_sf_do_5_1D_ce() chunk->auth_chunk is\navailable, we set up a fake auth chunk and pass that on to\nsctp_sf_authenticate(), which at latest in\nsctp_auth_calculate_hmac() reliably dereferences a NULL pointer\nat position 0..0008 when setting up the crypto key in\ncrypto_hash_setkey() by using asoc->asoc_shared_key that is\nNULL as condition key_id == asoc->active_key_id is true if\nthe AUTH chunk was injected correctly from remote. This\nhappens no matter what net.sctp.auth_enable sysctl says.\n\nThe fix is to check for net->sctp.auth_enable and for\nasoc->peer.auth_capable before doing any operations like\nsctp_sf_authenticate() as no key is activated in\nsctp_auth_asoc_init_active_key() for each case.\n\nNow as RFC4895 section 6.3 states that if the used HMAC-ALGO\npassed from the INIT chunk was not used in the AUTH chunk, we\nSHOULD send an error; however in this case it would be better\nto just silently discard such a maliciously prepared handshake\nas we didn't even receive a parameter at all. Also, as our\nendpoint has no shared key configured, section 6.3 says that\nMUST silently discard, which we are doing from now onwards.\n\nBefore calling sctp_sf_pdiscard(), we need not only to free\nthe association, but also the chunk->auth_chunk skb, as\ncommit bbd0d59809f9 created a skb clone in that case.\n\nI have tested this locally by using netfilter's nfqueue and\nre-injecting packets into the local stack after maliciously\nmodifying the INIT chunk (removing RANDOM; HMAC-ALGO param)\nand the SCTP packet containing the COOKIE_ECHO (injecting\nAUTH chunk before COOKIE_ECHO). Fixed with this patch applied.\n\nFixes: bbd0d59809f9 (\"[SCTP]: Implement the receive and verification of AUTH chunk\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Vlad Yasevich <yasevich@gmail.com>\nCc: Neil Horman <nhorman@tuxdriver.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "commit_hash": "ec0223ec48a90cb605244b45f7c62de856403729",
    "git_url": "https://github.com/torvalds/linux/commit/ec0223ec48a90cb605244b45f7c62de856403729",
    "file_path": "net/sctp/sm_statefuns.c",
    "func_name": "sctp_sf_do_5_1D_ce",
    "func_before": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n\t\tstruct sctp_chunk auth;\n\t\tsctp_ierror_t ret;\n\n\t\t/* set-up our fake chunk so that we can process it */\n\t\tauth.skb = chunk->auth_chunk;\n\t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\n\t\t/* We can now safely free the auth_chunk clone */\n\t\tkfree_skb(chunk->auth_chunk);\n\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}",
    "abstract_func_before": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *VAR_0,\n\t\t\t\t      const struct sctp_association *VAR_1,\n\t\t\t\t      const sctp_subtype_t VAR_2, void *VAR_3,\n\t\t\t\t      sctp_cmd_seq_t *VAR_4)\n{\n\tstruct sctp_chunk *VAR_5 = VAR_3;\n\tstruct sctp_association *VAR_6;\n\tsctp_init_chunk_t *VAR_7;\n\tstruct sctp_chunk *VAR_8;\n\tstruct sctp_ulpevent *VAR_9, *VAR_10 = NULL;\n\tint VAR_11 = 0;\n\tstruct sctp_chunk *VAR_12;\n\tstruct sock *VAR_13;\n\n\t/* COMMENT_0 */\n                                            \n    \n\tif (VAR_0 == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, VAR_14);\n\t\treturn sctp_sf_tabort_8_4_8(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\t}\n\n\t/* COMMENT_3 */\n                                                             \n                                                     \n                            \n    \n\tif (!sctp_chunk_length_valid(VAR_5, sizeof(VAR_15)))\n\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n\t/* COMMENT_8 */\n                                                                   \n          \n    \n\tVAR_13 = VAR_0->base.sk;\n\tif (!sctp_sstate(VAR_13, VAR_16) ||\n\t    (sctp_style(VAR_13, VAR_17) && sk_acceptq_is_full(VAR_13)))\n\t\treturn sctp_sf_tabort_8_4_8(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n\t/* COMMENT_12 */\n                      \n    \n\tVAR_5->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)VAR_5->skb->data;\n\tif (!pskb_pull(VAR_5->skb, ntohs(VAR_5->chunk_hdr->length) -\n\t\t\t\t\t sizeof(VAR_15)))\n\t\tgoto nomem;\n\n\t/* COMMENT_15 */\n                                                               \n                                        \n    \n\tVAR_6 = sctp_unpack_cookie(VAR_0, VAR_1, VAR_5, VAR_18, &VAR_11,\n\t\t\t\t      &VAR_12);\n\n\t/* COMMENT_19 */\n                                                         \n              \n   \n                                              \n    \n\tif (!VAR_6) {\n\t\t/* COMMENT_25 */\n                                                           \n     \n\t\tswitch (VAR_11) {\n\t\tcase -VAR_19:\n\t\t\tgoto nomem;\n\n\t\tcase -VAR_20:\n\t\t\tsctp_send_stale_cookie_err(net, VAR_0, VAR_1, VAR_5, VAR_4,\n\t\t\t\t\t\t   VAR_12);\n\t\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n\t\tcase -VAR_21:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\t\t}\n\t}\n\n\n\t/* COMMENT_28 */\n   \n                                                            \n                                     \n    \n\t/* COMMENT_33 */\n                                         \n    \n\tVAR_7 = &VAR_5->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(VAR_6, VAR_5,\n\t\t\t       &VAR_5->subh.cookie_hdr->c.peer_addr,\n\t\t\t       VAR_7, VAR_18))\n\t\tgoto nomem_init;\n\n\t/* COMMENT_36 */\n                                                            \n                                                             \n    \n\tVAR_11 = sctp_auth_asoc_init_active_key(VAR_6, VAR_18);\n\tif (VAR_11)\n\t\tgoto nomem_init;\n\n\t/* COMMENT_40 */\n                                                             \n                                                               \n                                                             \n                          \n    \n\tif (VAR_5->auth_chunk) {\n\t\tstruct sctp_chunk VAR_22;\n\t\tsctp_ierror_t VAR_23;\n\n\t\t/* COMMENT_46 */\n\t\tVAR_22.skb = VAR_5->auth_chunk;\n\t\tVAR_22.asoc = VAR_5->asoc;\n\t\tVAR_22.sctp_hdr = VAR_5->sctp_hdr;\n\t\tVAR_22.chunk_hdr = (sctp_chunkhdr_t *)skb_push(VAR_5->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(VAR_5->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tVAR_22.transport = VAR_5->transport;\n\n\t\tVAR_23 = sctp_sf_authenticate(net, VAR_0, VAR_6, VAR_2, &VAR_22);\n\n\t\t/* COMMENT_47 */\n\t\tkfree_skb(VAR_5->auth_chunk);\n\n\t\tif (VAR_23 != VAR_24) {\n\t\t\tsctp_association_free(VAR_6);\n\t\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\t\t}\n\t}\n\n\tVAR_8 = sctp_make_cookie_ack(VAR_6, VAR_5);\n\tif (!VAR_8)\n\t\tgoto nomem_init;\n\n\t/* COMMENT_48 */\n   \n                                                           \n                                                           \n                                                \n    \n\tVAR_9 = sctp_ulpevent_make_assoc_change(VAR_6, 0, VAR_25, 0,\n\t\t\t\t\t     VAR_6->c.sinit_num_ostreams,\n\t\t\t\t\t     VAR_6->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, VAR_18);\n\tif (!VAR_9)\n\t\tgoto nomem_ev;\n\n\t/* COMMENT_54 */\n                                                                    \n                                                                    \n                                     \n    \n\tif (VAR_6->peer.adaptation_ind) {\n\t\tVAR_10 = sctp_ulpevent_make_adaptation_indication(VAR_6,\n\t\t\t\t\t\t\t    VAR_18);\n\t\tif (!VAR_10)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* COMMENT_59 */\n                                                               \n                                                                 \n                 \n    \n\tsctp_add_cmd_sf(VAR_4, VAR_26, SCTP_ASOC(VAR_6));\n\tsctp_add_cmd_sf(VAR_4, VAR_27,\n\t\t\tSCTP_STATE(VAR_28));\n\tSCTP_INC_STATS(net, VAR_29);\n\tSCTP_INC_STATS(net, VAR_30);\n\tsctp_add_cmd_sf(VAR_4, VAR_31, SCTP_NULL());\n\n\tif (VAR_6->timeouts[VAR_32])\n\t\tsctp_add_cmd_sf(VAR_4, VAR_33,\n\t\t\t\tSCTP_TO(VAR_32));\n\n\t/* COMMENT_64 */\n\tsctp_add_cmd_sf(VAR_4, VAR_34, SCTP_CHUNK(VAR_8));\n\n\t/* COMMENT_65 */\n\tsctp_add_cmd_sf(VAR_4, VAR_35, SCTP_ULPEVENT(VAR_9));\n\n\t/* COMMENT_66 */\n\tif (VAR_10)\n\t\tsctp_add_cmd_sf(VAR_4, VAR_35,\n\t\t\t\tSCTP_ULPEVENT(VAR_10));\n\n\treturn VAR_36;\n\nnomem_aiev:\n\tsctp_ulpevent_free(VAR_9);\nnomem_ev:\n\tsctp_chunk_free(VAR_8);\nnomem_init:\n\tsctp_association_free(VAR_6);\nnomem:\n\treturn VAR_37;\n}",
    "func_graph_path_before": "torvalds/linux/ec0223ec48a90cb605244b45f7c62de856403729/sm_statefuns.c/vul/before/0.json",
    "func": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n\t\tstruct sctp_chunk auth;\n\t\tsctp_ierror_t ret;\n\n\t\t/* Make sure that we and the peer are AUTH capable */\n\t\tif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\n\t\t\tkfree_skb(chunk->auth_chunk);\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\n\t\t/* set-up our fake chunk so that we can process it */\n\t\tauth.skb = chunk->auth_chunk;\n\t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\n\t\t/* We can now safely free the auth_chunk clone */\n\t\tkfree_skb(chunk->auth_chunk);\n\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}",
    "abstract_func": "sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *VAR_0,\n\t\t\t\t      const struct sctp_association *VAR_1,\n\t\t\t\t      const sctp_subtype_t VAR_2, void *VAR_3,\n\t\t\t\t      sctp_cmd_seq_t *VAR_4)\n{\n\tstruct sctp_chunk *VAR_5 = VAR_3;\n\tstruct sctp_association *VAR_6;\n\tsctp_init_chunk_t *VAR_7;\n\tstruct sctp_chunk *VAR_8;\n\tstruct sctp_ulpevent *VAR_9, *VAR_10 = NULL;\n\tint VAR_11 = 0;\n\tstruct sctp_chunk *VAR_12;\n\tstruct sock *VAR_13;\n\n\t/* COMMENT_0 */\n                                            \n    \n\tif (VAR_0 == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, VAR_14);\n\t\treturn sctp_sf_tabort_8_4_8(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\t}\n\n\t/* COMMENT_3 */\n                                                             \n                                                     \n                            \n    \n\tif (!sctp_chunk_length_valid(VAR_5, sizeof(VAR_15)))\n\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n\t/* COMMENT_8 */\n                                                                   \n          \n    \n\tVAR_13 = VAR_0->base.sk;\n\tif (!sctp_sstate(VAR_13, VAR_16) ||\n\t    (sctp_style(VAR_13, VAR_17) && sk_acceptq_is_full(VAR_13)))\n\t\treturn sctp_sf_tabort_8_4_8(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n\t/* COMMENT_12 */\n                      \n    \n\tVAR_5->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)VAR_5->skb->data;\n\tif (!pskb_pull(VAR_5->skb, ntohs(VAR_5->chunk_hdr->length) -\n\t\t\t\t\t sizeof(VAR_15)))\n\t\tgoto nomem;\n\n\t/* COMMENT_15 */\n                                                               \n                                        \n    \n\tVAR_6 = sctp_unpack_cookie(VAR_0, VAR_1, VAR_5, VAR_18, &VAR_11,\n\t\t\t\t      &VAR_12);\n\n\t/* COMMENT_19 */\n                                                         \n              \n   \n                                              \n    \n\tif (!VAR_6) {\n\t\t/* COMMENT_25 */\n                                                           \n     \n\t\tswitch (VAR_11) {\n\t\tcase -VAR_19:\n\t\t\tgoto nomem;\n\n\t\tcase -VAR_20:\n\t\t\tsctp_send_stale_cookie_err(net, VAR_0, VAR_1, VAR_5, VAR_4,\n\t\t\t\t\t\t   VAR_12);\n\t\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n\t\tcase -VAR_21:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\t\t}\n\t}\n\n\n\t/* COMMENT_28 */\n   \n                                                            \n                                     \n    \n\t/* COMMENT_33 */\n                                         \n    \n\tVAR_7 = &VAR_5->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(VAR_6, VAR_5,\n\t\t\t       &VAR_5->subh.cookie_hdr->c.peer_addr,\n\t\t\t       VAR_7, VAR_18))\n\t\tgoto nomem_init;\n\n\t/* COMMENT_36 */\n                                                            \n                                                             \n    \n\tVAR_11 = sctp_auth_asoc_init_active_key(VAR_6, VAR_18);\n\tif (VAR_11)\n\t\tgoto nomem_init;\n\n\t/* COMMENT_40 */\n                                                             \n                                                               \n                                                             \n                          \n    \n\tif (VAR_5->auth_chunk) {\n\t\tstruct sctp_chunk VAR_22;\n\t\tsctp_ierror_t VAR_23;\n\n\t\t/* COMMENT_46 */\n\t\tif (!net->sctp.auth_enable || !VAR_6->peer.auth_capable) {\n\t\t\tkfree_skb(VAR_5->auth_chunk);\n\t\t\tsctp_association_free(VAR_6);\n\t\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\t\t}\n\n\t\t/* COMMENT_47 */\n\t\tVAR_22.skb = VAR_5->auth_chunk;\n\t\tVAR_22.asoc = VAR_5->asoc;\n\t\tVAR_22.sctp_hdr = VAR_5->sctp_hdr;\n\t\tVAR_22.chunk_hdr = (sctp_chunkhdr_t *)skb_push(VAR_5->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(VAR_5->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tVAR_22.transport = VAR_5->transport;\n\n\t\tVAR_23 = sctp_sf_authenticate(net, VAR_0, VAR_6, VAR_2, &VAR_22);\n\n\t\t/* COMMENT_48 */\n\t\tkfree_skb(VAR_5->auth_chunk);\n\n\t\tif (VAR_23 != VAR_24) {\n\t\t\tsctp_association_free(VAR_6);\n\t\t\treturn sctp_sf_pdiscard(net, VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\t\t}\n\t}\n\n\tVAR_8 = sctp_make_cookie_ack(VAR_6, VAR_5);\n\tif (!VAR_8)\n\t\tgoto nomem_init;\n\n\t/* COMMENT_49 */\n   \n                                                           \n                                                           \n                                                \n    \n\tVAR_9 = sctp_ulpevent_make_assoc_change(VAR_6, 0, VAR_25, 0,\n\t\t\t\t\t     VAR_6->c.sinit_num_ostreams,\n\t\t\t\t\t     VAR_6->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, VAR_18);\n\tif (!VAR_9)\n\t\tgoto nomem_ev;\n\n\t/* COMMENT_55 */\n                                                                    \n                                                                    \n                                     \n    \n\tif (VAR_6->peer.adaptation_ind) {\n\t\tVAR_10 = sctp_ulpevent_make_adaptation_indication(VAR_6,\n\t\t\t\t\t\t\t    VAR_18);\n\t\tif (!VAR_10)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* COMMENT_60 */\n                                                               \n                                                                 \n                 \n    \n\tsctp_add_cmd_sf(VAR_4, VAR_26, SCTP_ASOC(VAR_6));\n\tsctp_add_cmd_sf(VAR_4, VAR_27,\n\t\t\tSCTP_STATE(VAR_28));\n\tSCTP_INC_STATS(net, VAR_29);\n\tSCTP_INC_STATS(net, VAR_30);\n\tsctp_add_cmd_sf(VAR_4, VAR_31, SCTP_NULL());\n\n\tif (VAR_6->timeouts[VAR_32])\n\t\tsctp_add_cmd_sf(VAR_4, VAR_33,\n\t\t\t\tSCTP_TO(VAR_32));\n\n\t/* COMMENT_65 */\n\tsctp_add_cmd_sf(VAR_4, VAR_34, SCTP_CHUNK(VAR_8));\n\n\t/* COMMENT_66 */\n\tsctp_add_cmd_sf(VAR_4, VAR_35, SCTP_ULPEVENT(VAR_9));\n\n\t/* COMMENT_67 */\n\tif (VAR_10)\n\t\tsctp_add_cmd_sf(VAR_4, VAR_35,\n\t\t\t\tSCTP_ULPEVENT(VAR_10));\n\n\treturn VAR_36;\n\nnomem_aiev:\n\tsctp_ulpevent_free(VAR_9);\nnomem_ev:\n\tsctp_chunk_free(VAR_8);\nnomem_init:\n\tsctp_association_free(VAR_6);\nnomem:\n\treturn VAR_37;\n}",
    "func_graph_path": "torvalds/linux/ec0223ec48a90cb605244b45f7c62de856403729/sm_statefuns.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -113,6 +113,13 @@\n \t\tstruct sctp_chunk auth;\n \t\tsctp_ierror_t ret;\n \n+\t\t/* Make sure that we and the peer are AUTH capable */\n+\t\tif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\n+\t\t\tkfree_skb(chunk->auth_chunk);\n+\t\t\tsctp_association_free(new_asoc);\n+\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n+\t\t}\n+\n \t\t/* set-up our fake chunk so that we can process it */\n \t\tauth.skb = chunk->auth_chunk;\n \t\tauth.asoc = chunk->asoc;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\t/* Make sure that we and the peer are AUTH capable */",
            "\t\tif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {",
            "\t\t\tkfree_skb(chunk->auth_chunk);",
            "\t\t\tsctp_association_free(new_asoc);",
            "\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);",
            "\t\t}",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}