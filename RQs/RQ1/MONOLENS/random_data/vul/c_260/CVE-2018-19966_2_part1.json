{
    "cve_id": "CVE-2018-19966",
    "cwe_ids": [
        "CWE-436"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "xen-project/xen",
    "commit_msg": "x86/shadow: shrink struct page_info's shadow_flags to 16 bits\n\nThis is to avoid it overlapping the linear_pt_count field needed for PV\ndomains. Introduce a separate, HVM-only pagetable_dying field to replace\nthe sole one left in the upper 16 bits.\n\nNote that the accesses to ->shadow_flags in shadow_{pro,de}mote() get\nswitched to non-atomic, non-bitops operations, as {test,set,clear}_bit()\nare not allowed on uint16_t fields and hence their use would have\nrequired ugly casts. This is fine because all updates of the field ought\nto occur with the paging lock held, and other updates of it use |= and\n&= as well (i.e. using atomic operations here didn't really guard\nagainst potentially racing updates elsewhere).\n\nThis is part of XSA-280.\n\nReported-by: Prgmr.com Security <security@prgmr.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Tim Deegan <tim@xen.org>",
    "commit_hash": "789589968ed90e82a832dbc60e958c76b787be7e",
    "git_url": "https://github.com/xen-project/xen/commit/789589968ed90e82a832dbc60e958c76b787be7e",
    "file_path": "xen/arch/x86/mm/shadow/common.c",
    "func_name": "sh_remove_shadows",
    "func_before": "void sh_remove_shadows(struct domain *d, mfn_t gmfn, int fast, int all)\n/* Remove the shadows of this guest page.\n * If fast != 0, just try the quick heuristic, which will remove\n * at most one reference to each shadow of the page.  Otherwise, walk\n * all the shadow tables looking for refs to shadows of this gmfn.\n * If all != 0, kill the domain if we can't find all the shadows.\n * (all != 0 implies fast == 0)\n */\n{\n    struct page_info *pg = mfn_to_page(gmfn);\n    mfn_t smfn;\n    unsigned char t;\n\n    /* Dispatch table for getting per-type functions: each level must\n     * be called with the function to remove a lower-level shadow. */\n    static const hash_domain_callback_t callbacks[SH_type_unused] = {\n        NULL, /* none    */\n        NULL, /* l1_32   */\n        NULL, /* fl1_32  */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 2), /* l2_32   */\n        NULL, /* l1_pae  */\n        NULL, /* fl1_pae */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3), /* l2_pae  */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3), /* l2h_pae */\n        NULL, /* l1_64   */\n        NULL, /* fl1_64  */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4), /* l2_64   */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4), /* l2h_64  */\n        SHADOW_INTERNAL_NAME(sh_remove_l2_shadow, 4), /* l3_64   */\n        SHADOW_INTERNAL_NAME(sh_remove_l3_shadow, 4), /* l4_64   */\n        NULL, /* p2m     */\n        NULL  /* unused  */\n    };\n\n    /* Another lookup table, for choosing which mask to use */\n    static const unsigned int masks[SH_type_unused] = {\n        0, /* none    */\n        SHF_L2_32, /* l1_32   */\n        0, /* fl1_32  */\n        0, /* l2_32   */\n        SHF_L2H_PAE | SHF_L2_PAE, /* l1_pae  */\n        0, /* fl1_pae */\n        0, /* l2_pae  */\n        0, /* l2h_pae  */\n        SHF_L2H_64 | SHF_L2_64, /* l1_64   */\n        0, /* fl1_64  */\n        SHF_L3_64, /* l2_64   */\n        SHF_L3_64, /* l2h_64  */\n        SHF_L4_64, /* l3_64   */\n        0, /* l4_64   */\n        0, /* p2m     */\n        0  /* unused  */\n    };\n\n    ASSERT(!(all && fast));\n    ASSERT(mfn_valid(gmfn));\n\n    /* Although this is an externally visible function, we do not know\n     * whether the paging lock will be held when it is called (since it\n     * can be called via put_page_type when we clear a shadow l1e).*/\n    paging_lock_recursive(d);\n\n    SHADOW_PRINTK(\"d%d gmfn=%\"PRI_mfn\"\\n\", d->domain_id, mfn_x(gmfn));\n\n    /* Bail out now if the page is not shadowed */\n    if ( (pg->count_info & PGC_page_table) == 0 )\n    {\n        paging_unlock(d);\n        return;\n    }\n\n    /* Search for this shadow in all appropriate shadows */\n    perfc_incr(shadow_unshadow);\n\n    /* Lower-level shadows need to be excised from upper-level shadows.\n     * This call to hash_vcpu_foreach() looks dangerous but is in fact OK: each\n     * call will remove at most one shadow, and terminate immediately when\n     * it does remove it, so we never walk the hash after doing a deletion.  */\n#define DO_UNSHADOW(_type) do {                                         \\\n    t = (_type);                                                        \\\n    if( !(pg->count_info & PGC_page_table)                              \\\n        || !(pg->shadow_flags & (1 << t)) )                             \\\n        break;                                                          \\\n    smfn = shadow_hash_lookup(d, mfn_x(gmfn), t);                       \\\n    if ( unlikely(!mfn_valid(smfn)) )                                   \\\n    {                                                                   \\\n        printk(XENLOG_G_ERR \"gmfn %\"PRI_mfn\" has flags %#x\"             \\\n               \" but no type-%#x shadow\\n\",                             \\\n               mfn_x(gmfn), pg->shadow_flags, t);                       \\\n        break;                                                          \\\n    }                                                                   \\\n    if ( sh_type_is_pinnable(d, t) )                                    \\\n        sh_unpin(d, smfn);                                              \\\n    else if ( sh_type_has_up_pointer(d, t) )                            \\\n        sh_remove_shadow_via_pointer(d, smfn);                          \\\n    if( !fast                                                           \\\n        && (pg->count_info & PGC_page_table)                            \\\n        && (pg->shadow_flags & (1 << t)) )                              \\\n        hash_domain_foreach(d, masks[t], callbacks, smfn);              \\\n} while (0)\n\n    DO_UNSHADOW(SH_type_l2_32_shadow);\n    DO_UNSHADOW(SH_type_l1_32_shadow);\n    DO_UNSHADOW(SH_type_l2h_pae_shadow);\n    DO_UNSHADOW(SH_type_l2_pae_shadow);\n    DO_UNSHADOW(SH_type_l1_pae_shadow);\n    DO_UNSHADOW(SH_type_l4_64_shadow);\n    DO_UNSHADOW(SH_type_l3_64_shadow);\n    DO_UNSHADOW(SH_type_l2h_64_shadow);\n    DO_UNSHADOW(SH_type_l2_64_shadow);\n    DO_UNSHADOW(SH_type_l1_64_shadow);\n\n#undef DO_UNSHADOW\n\n    /* If that didn't catch the shadows, something is wrong */\n    if ( !fast && all && (pg->count_info & PGC_page_table) )\n    {\n        printk(XENLOG_G_ERR \"can't find all shadows of mfn %\"PRI_mfn\n               \" (shadow_flags=%08x)\\n\", mfn_x(gmfn), pg->shadow_flags);\n        domain_crash(d);\n    }\n\n    /* Need to flush TLBs now, so that linear maps are safe next time we\n     * take a fault. */\n    flush_tlb_mask(d->dirty_cpumask);\n\n    paging_unlock(d);\n}",
    "abstract_func_before": "void sh_remove_shadows(struct domain *VAR_0, mfn_t VAR_1, int VAR_2, int VAR_3)\n/* COMMENT_0 */\n                                                                \n                                                                     \n                                                                  \n                                                                 \n                               \n   \n{\n    struct page_info *VAR_4 = mfn_to_page(VAR_1);\n    mfn_t VAR_5;\n    unsigned char VAR_6;\n\n    /* COMMENT_7 */\n                                                                     \n    static const hash_domain_callback_t VAR_7[VAR_8] = {\n        NULL, /* COMMENT_9 */\n        NULL, /* COMMENT_10 */\n        NULL, /* COMMENT_11 */\n        SHADOW_INTERNAL_NAME(VAR_9, 2), /* COMMENT_12 */\n        NULL, /* COMMENT_13 */\n        NULL, /* COMMENT_14 */\n        SHADOW_INTERNAL_NAME(VAR_9, 3), /* COMMENT_15 */\n        SHADOW_INTERNAL_NAME(VAR_9, 3), /* COMMENT_16 */\n        NULL, /* COMMENT_17 */\n        NULL, /* COMMENT_18 */\n        SHADOW_INTERNAL_NAME(VAR_9, 4), /* COMMENT_19 */\n        SHADOW_INTERNAL_NAME(VAR_9, 4), /* COMMENT_20 */\n        SHADOW_INTERNAL_NAME(VAR_10, 4), /* COMMENT_21 */\n        SHADOW_INTERNAL_NAME(VAR_11, 4), /* COMMENT_22 */\n        NULL, /* COMMENT_23 */\n        NULL  /* COMMENT_24 */\n    };\n\n    /* COMMENT_25 */\n    static const unsigned int VAR_12[VAR_8] = {\n        0, /* COMMENT_9 */\n        VAR_13, /* COMMENT_10 */\n        0, /* COMMENT_11 */\n        0, /* COMMENT_12 */\n        VAR_14 | VAR_15, /* COMMENT_13 */\n        0, /* COMMENT_14 */\n        0, /* COMMENT_15 */\n        0, /* COMMENT_26 */\n        VAR_16 | VAR_17, /* COMMENT_17 */\n        0, /* COMMENT_18 */\n        VAR_18, /* COMMENT_19 */\n        VAR_18, /* COMMENT_20 */\n        VAR_19, /* COMMENT_21 */\n        0, /* COMMENT_22 */\n        0, /* COMMENT_23 */\n        0  /* COMMENT_24 */\n    };\n\n    ASSERT(!(VAR_3 && VAR_2));\n    ASSERT(mfn_valid(VAR_1));\n\n    /* COMMENT_27 */\n                                                                       \n                                                                     \n    paging_lock_recursive(VAR_0);\n\n    SHADOW_PRINTK(\"d%d gmfn=%\"VAR_20\"\\n\", VAR_0->domain_id, mfn_x(VAR_1));\n\n    /* COMMENT_30 */\n    if ( (VAR_4->count_info & VAR_21) == 0 )\n    {\n        paging_unlock(VAR_0);\n        return;\n    }\n\n    /* COMMENT_31 */\n    perfc_incr(VAR_22);\n\n    /* COMMENT_32 */\n                                                                               \n                                                                          \n                                                                               \n#define DO_UNSHADOW(VAR_23) do {                                         \\\n    t = (_type);                                                        \\\n    if( !(pg->count_info & PGC_page_table)                              \\\n        || !(pg->shadow_flags & (1 << t)) )                             \\\n        break;                                                          \\\n    smfn = shadow_hash_lookup(d, mfn_x(gmfn), t);                       \\\n    if ( unlikely(!mfn_valid(smfn)) )                                   \\\n    {                                                                   \\\n        printk(XENLOG_G_ERR \"gmfn %\"PRI_mfn\" has flags %#x\"             \\\n               \" but no type-%#x shadow\\n\",                             \\\n               mfn_x(gmfn), pg->shadow_flags, t);                       \\\n        break;                                                          \\\n    }                                                                   \\\n    if ( sh_type_is_pinnable(d, t) )                                    \\\n        sh_unpin(d, smfn);                                              \\\n    else if ( sh_type_has_up_pointer(d, t) )                            \\\n        sh_remove_shadow_via_pointer(d, smfn);                          \\\n    if( !fast                                                           \\\n        && (pg->count_info & PGC_page_table)                            \\\n        && (pg->shadow_flags & (1 << t)) )                              \\\n        hash_domain_foreach(d, masks[t], callbacks, smfn);              \\\n} while (0)\n\n    DO_UNSHADOW(VAR_24);\n    DO_UNSHADOW(VAR_25);\n    DO_UNSHADOW(VAR_26);\n    DO_UNSHADOW(VAR_27);\n    DO_UNSHADOW(VAR_28);\n    DO_UNSHADOW(VAR_29);\n    DO_UNSHADOW(VAR_30);\n    DO_UNSHADOW(VAR_31);\n    DO_UNSHADOW(VAR_32);\n    DO_UNSHADOW(VAR_33);\n\n#undef DO_UNSHADOW\n\n    /* COMMENT_36 */\n    if ( !VAR_2 && VAR_3 && (VAR_4->count_info & VAR_21) )\n    {\n        printk(XENLOG_G_ERR \"can't find all shadows of mfn %\"VAR_20\n               \" (shadow_flags=%08x)\\n\", mfn_x(VAR_1), VAR_4->shadow_flags);\n        domain_crash(VAR_0);\n    }\n\n    /* COMMENT_37 */\n                       \n    flush_tlb_mask(VAR_0->dirty_cpumask);\n\n    paging_unlock(VAR_0);\n}",
    "func_graph_path_before": "xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/common.c/vul/before/1.json",
    "func": "void sh_remove_shadows(struct domain *d, mfn_t gmfn, int fast, int all)\n/* Remove the shadows of this guest page.\n * If fast != 0, just try the quick heuristic, which will remove\n * at most one reference to each shadow of the page.  Otherwise, walk\n * all the shadow tables looking for refs to shadows of this gmfn.\n * If all != 0, kill the domain if we can't find all the shadows.\n * (all != 0 implies fast == 0)\n */\n{\n    struct page_info *pg = mfn_to_page(gmfn);\n    mfn_t smfn;\n    unsigned char t;\n\n    /* Dispatch table for getting per-type functions: each level must\n     * be called with the function to remove a lower-level shadow. */\n    static const hash_domain_callback_t callbacks[SH_type_unused] = {\n        NULL, /* none    */\n        NULL, /* l1_32   */\n        NULL, /* fl1_32  */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 2), /* l2_32   */\n        NULL, /* l1_pae  */\n        NULL, /* fl1_pae */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3), /* l2_pae  */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 3), /* l2h_pae */\n        NULL, /* l1_64   */\n        NULL, /* fl1_64  */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4), /* l2_64   */\n        SHADOW_INTERNAL_NAME(sh_remove_l1_shadow, 4), /* l2h_64  */\n        SHADOW_INTERNAL_NAME(sh_remove_l2_shadow, 4), /* l3_64   */\n        SHADOW_INTERNAL_NAME(sh_remove_l3_shadow, 4), /* l4_64   */\n        NULL, /* p2m     */\n        NULL  /* unused  */\n    };\n\n    /* Another lookup table, for choosing which mask to use */\n    static const unsigned int masks[SH_type_unused] = {\n        0, /* none    */\n        SHF_L2_32, /* l1_32   */\n        0, /* fl1_32  */\n        0, /* l2_32   */\n        SHF_L2H_PAE | SHF_L2_PAE, /* l1_pae  */\n        0, /* fl1_pae */\n        0, /* l2_pae  */\n        0, /* l2h_pae  */\n        SHF_L2H_64 | SHF_L2_64, /* l1_64   */\n        0, /* fl1_64  */\n        SHF_L3_64, /* l2_64   */\n        SHF_L3_64, /* l2h_64  */\n        SHF_L4_64, /* l3_64   */\n        0, /* l4_64   */\n        0, /* p2m     */\n        0  /* unused  */\n    };\n\n    ASSERT(!(all && fast));\n    ASSERT(mfn_valid(gmfn));\n\n    /* Although this is an externally visible function, we do not know\n     * whether the paging lock will be held when it is called (since it\n     * can be called via put_page_type when we clear a shadow l1e).*/\n    paging_lock_recursive(d);\n\n    SHADOW_PRINTK(\"d%d gmfn=%\"PRI_mfn\"\\n\", d->domain_id, mfn_x(gmfn));\n\n    /* Bail out now if the page is not shadowed */\n    if ( (pg->count_info & PGC_page_table) == 0 )\n    {\n        paging_unlock(d);\n        return;\n    }\n\n    /* Search for this shadow in all appropriate shadows */\n    perfc_incr(shadow_unshadow);\n\n    /* Lower-level shadows need to be excised from upper-level shadows.\n     * This call to hash_vcpu_foreach() looks dangerous but is in fact OK: each\n     * call will remove at most one shadow, and terminate immediately when\n     * it does remove it, so we never walk the hash after doing a deletion.  */\n#define DO_UNSHADOW(_type) do {                                         \\\n    t = (_type);                                                        \\\n    if( !(pg->count_info & PGC_page_table)                              \\\n        || !(pg->shadow_flags & (1 << t)) )                             \\\n        break;                                                          \\\n    smfn = shadow_hash_lookup(d, mfn_x(gmfn), t);                       \\\n    if ( unlikely(!mfn_valid(smfn)) )                                   \\\n    {                                                                   \\\n        printk(XENLOG_G_ERR \"gmfn %\"PRI_mfn\" has flags %#x\"             \\\n               \" but no type-%#x shadow\\n\",                             \\\n               mfn_x(gmfn), pg->shadow_flags, t);                       \\\n        break;                                                          \\\n    }                                                                   \\\n    if ( sh_type_is_pinnable(d, t) )                                    \\\n        sh_unpin(d, smfn);                                              \\\n    else if ( sh_type_has_up_pointer(d, t) )                            \\\n        sh_remove_shadow_via_pointer(d, smfn);                          \\\n    if( !fast                                                           \\\n        && (pg->count_info & PGC_page_table)                            \\\n        && (pg->shadow_flags & (1 << t)) )                              \\\n        hash_domain_foreach(d, masks[t], callbacks, smfn);              \\\n} while (0)\n\n    DO_UNSHADOW(SH_type_l2_32_shadow);\n    DO_UNSHADOW(SH_type_l1_32_shadow);\n    DO_UNSHADOW(SH_type_l2h_pae_shadow);\n    DO_UNSHADOW(SH_type_l2_pae_shadow);\n    DO_UNSHADOW(SH_type_l1_pae_shadow);\n    DO_UNSHADOW(SH_type_l4_64_shadow);\n    DO_UNSHADOW(SH_type_l3_64_shadow);\n    DO_UNSHADOW(SH_type_l2h_64_shadow);\n    DO_UNSHADOW(SH_type_l2_64_shadow);\n    DO_UNSHADOW(SH_type_l1_64_shadow);\n\n#undef DO_UNSHADOW\n\n    /* If that didn't catch the shadows, something is wrong */\n    if ( !fast && all && (pg->count_info & PGC_page_table) )\n    {\n        printk(XENLOG_G_ERR \"can't find all shadows of mfn %\"PRI_mfn\n               \" (shadow_flags=%04x)\\n\", mfn_x(gmfn), pg->shadow_flags);\n        domain_crash(d);\n    }\n\n    /* Need to flush TLBs now, so that linear maps are safe next time we\n     * take a fault. */\n    flush_tlb_mask(d->dirty_cpumask);\n\n    paging_unlock(d);\n}",
    "abstract_func": "void sh_remove_shadows(struct domain *VAR_0, mfn_t VAR_1, int VAR_2, int VAR_3)\n/* COMMENT_0 */\n                                                                \n                                                                     \n                                                                  \n                                                                 \n                               \n   \n{\n    struct page_info *VAR_4 = mfn_to_page(VAR_1);\n    mfn_t VAR_5;\n    unsigned char VAR_6;\n\n    /* COMMENT_7 */\n                                                                     \n    static const hash_domain_callback_t VAR_7[VAR_8] = {\n        NULL, /* COMMENT_9 */\n        NULL, /* COMMENT_10 */\n        NULL, /* COMMENT_11 */\n        SHADOW_INTERNAL_NAME(VAR_9, 2), /* COMMENT_12 */\n        NULL, /* COMMENT_13 */\n        NULL, /* COMMENT_14 */\n        SHADOW_INTERNAL_NAME(VAR_9, 3), /* COMMENT_15 */\n        SHADOW_INTERNAL_NAME(VAR_9, 3), /* COMMENT_16 */\n        NULL, /* COMMENT_17 */\n        NULL, /* COMMENT_18 */\n        SHADOW_INTERNAL_NAME(VAR_9, 4), /* COMMENT_19 */\n        SHADOW_INTERNAL_NAME(VAR_9, 4), /* COMMENT_20 */\n        SHADOW_INTERNAL_NAME(VAR_10, 4), /* COMMENT_21 */\n        SHADOW_INTERNAL_NAME(VAR_11, 4), /* COMMENT_22 */\n        NULL, /* COMMENT_23 */\n        NULL  /* COMMENT_24 */\n    };\n\n    /* COMMENT_25 */\n    static const unsigned int VAR_12[VAR_8] = {\n        0, /* COMMENT_9 */\n        VAR_13, /* COMMENT_10 */\n        0, /* COMMENT_11 */\n        0, /* COMMENT_12 */\n        VAR_14 | VAR_15, /* COMMENT_13 */\n        0, /* COMMENT_14 */\n        0, /* COMMENT_15 */\n        0, /* COMMENT_26 */\n        VAR_16 | VAR_17, /* COMMENT_17 */\n        0, /* COMMENT_18 */\n        VAR_18, /* COMMENT_19 */\n        VAR_18, /* COMMENT_20 */\n        VAR_19, /* COMMENT_21 */\n        0, /* COMMENT_22 */\n        0, /* COMMENT_23 */\n        0  /* COMMENT_24 */\n    };\n\n    ASSERT(!(VAR_3 && VAR_2));\n    ASSERT(mfn_valid(VAR_1));\n\n    /* COMMENT_27 */\n                                                                       \n                                                                     \n    paging_lock_recursive(VAR_0);\n\n    SHADOW_PRINTK(\"d%d gmfn=%\"VAR_20\"\\n\", VAR_0->domain_id, mfn_x(VAR_1));\n\n    /* COMMENT_30 */\n    if ( (VAR_4->count_info & VAR_21) == 0 )\n    {\n        paging_unlock(VAR_0);\n        return;\n    }\n\n    /* COMMENT_31 */\n    perfc_incr(VAR_22);\n\n    /* COMMENT_32 */\n                                                                               \n                                                                          \n                                                                               \n#define DO_UNSHADOW(VAR_23) do {                                         \\\n    t = (_type);                                                        \\\n    if( !(pg->count_info & PGC_page_table)                              \\\n        || !(pg->shadow_flags & (1 << t)) )                             \\\n        break;                                                          \\\n    smfn = shadow_hash_lookup(d, mfn_x(gmfn), t);                       \\\n    if ( unlikely(!mfn_valid(smfn)) )                                   \\\n    {                                                                   \\\n        printk(XENLOG_G_ERR \"gmfn %\"PRI_mfn\" has flags %#x\"             \\\n               \" but no type-%#x shadow\\n\",                             \\\n               mfn_x(gmfn), pg->shadow_flags, t);                       \\\n        break;                                                          \\\n    }                                                                   \\\n    if ( sh_type_is_pinnable(d, t) )                                    \\\n        sh_unpin(d, smfn);                                              \\\n    else if ( sh_type_has_up_pointer(d, t) )                            \\\n        sh_remove_shadow_via_pointer(d, smfn);                          \\\n    if( !fast                                                           \\\n        && (pg->count_info & PGC_page_table)                            \\\n        && (pg->shadow_flags & (1 << t)) )                              \\\n        hash_domain_foreach(d, masks[t], callbacks, smfn);              \\\n} while (0)\n\n    DO_UNSHADOW(VAR_24);\n    DO_UNSHADOW(VAR_25);\n    DO_UNSHADOW(VAR_26);\n    DO_UNSHADOW(VAR_27);\n    DO_UNSHADOW(VAR_28);\n    DO_UNSHADOW(VAR_29);\n    DO_UNSHADOW(VAR_30);\n    DO_UNSHADOW(VAR_31);\n    DO_UNSHADOW(VAR_32);\n    DO_UNSHADOW(VAR_33);\n\n#undef DO_UNSHADOW\n\n    /* COMMENT_36 */\n    if ( !VAR_2 && VAR_3 && (VAR_4->count_info & VAR_21) )\n    {\n        printk(XENLOG_G_ERR \"can't find all shadows of mfn %\"VAR_20\n               \" (shadow_flags=%04x)\\n\", mfn_x(VAR_1), VAR_4->shadow_flags);\n        domain_crash(VAR_0);\n    }\n\n    /* COMMENT_37 */\n                       \n    flush_tlb_mask(VAR_0->dirty_cpumask);\n\n    paging_unlock(VAR_0);\n}",
    "func_graph_path": "xen-project/xen/789589968ed90e82a832dbc60e958c76b787be7e/common.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -116,7 +116,7 @@\n     if ( !fast && all && (pg->count_info & PGC_page_table) )\n     {\n         printk(XENLOG_G_ERR \"can't find all shadows of mfn %\"PRI_mfn\n-               \" (shadow_flags=%08x)\\n\", mfn_x(gmfn), pg->shadow_flags);\n+               \" (shadow_flags=%04x)\\n\", mfn_x(gmfn), pg->shadow_flags);\n         domain_crash(d);\n     }\n ",
    "diff_line_info": {
        "deleted_lines": [
            "               \" (shadow_flags=%08x)\\n\", mfn_x(gmfn), pg->shadow_flags);"
        ],
        "added_lines": [
            "               \" (shadow_flags=%04x)\\n\", mfn_x(gmfn), pg->shadow_flags);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}