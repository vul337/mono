{
    "cve_id": "CVE-2015-1335",
    "cwe_ids": [
        "CWE-59"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "lxc",
    "commit_msg": "CVE-2015-1335: Protect container mounts against symlinks\n\nWhen a container starts up, lxc sets up the container's inital fstree\nby doing a bunch of mounting, guided by the container configuration\nfile.  The container config is owned by the admin or user on the host,\nso we do not try to guard against bad entries.  However, since the\nmount target is in the container, it's possible that the container admin\ncould divert the mount with symbolic links.  This could bypass proper\ncontainer startup (i.e. confinement of a root-owned container by the\nrestrictive apparmor policy, by diverting the required write to\n/proc/self/attr/current), or bypass the (path-based) apparmor policy\nby diverting, say, /proc to /mnt in the container.\n\nTo prevent this,\n\n1. do not allow mounts to paths containing symbolic links\n\n2. do not allow bind mounts from relative paths containing symbolic\nlinks.\n\nDetails:\n\nDefine safe_mount which ensures that the container has not inserted any\nsymbolic links into any mount targets for mounts to be done during\ncontainer setup.\n\nThe host's mount path may contain symbolic links.  As it is under the\ncontrol of the administrator, that's ok.  So safe_mount begins the check\nfor symbolic links after the rootfs->mount, by opening that directory.\n\nIt opens each directory along the path using openat() relative to the\nparent directory using O_NOFOLLOW.  When the target is reached, it\nmounts onto /proc/self/fd/<targetfd>.\n\nUse safe_mount() in mount_entry(), when mounting container proc,\nand when needed.  In particular, safe_mount() need not be used in\nany case where:\n\n1. the mount is done in the container's namespace\n2. the mount is for the container's rootfs\n3. the mount is relative to a tmpfs or proc/sysfs which we have\n   just safe_mount()ed ourselves\n\nSince we were using proc/net as a temporary placeholder for /proc/sys/net\nduring container startup, and proc/net is a symbolic link, use proc/tty\ninstead.\n\nUpdate the lxc.container.conf manpage with details about the new\nrestrictions.\n\nFinally, add a testcase to test some symbolic link possibilities.\n\nReported-by: Roman Fiedler\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\nAcked-by: St\u00e9phane Graber <stgraber@ubuntu.com>",
    "commit_hash": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "file_path": "src/lxc/conf.c",
    "func_name": "lxc_execute_bind_init",
    "func_before": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
    "abstract_func_before": "void lxc_execute_bind_init(struct lxc_conf *VAR_0)\n{\n\tint VAR_1;\n\tchar VAR_2[VAR_3], VAR_4[VAR_3], *VAR_5;\n\n\t/* COMMENT_0 */\n\tVAR_5 = choose_init(VAR_0->rootfs.mount);\n\tif (VAR_5) {\n\t\tfree(VAR_5);\n\t\treturn;\n\t}\n\n\tVAR_1 = snprintf(VAR_2, VAR_3, VAR_6 \"/init.lxc.static\");\n\tif (VAR_1 < 0 || VAR_1 >= VAR_3) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(VAR_2)) {\n\t\tINFO(\"%s does not exist on host\", VAR_2);\n\t\treturn;\n\t}\n\n\tVAR_1 = snprintf(VAR_4, VAR_3, \"%s%s\", VAR_0->rootfs.mount, \"/init.lxc.static\");\n\tif (VAR_1 < 0 || VAR_1 >= VAR_3) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(VAR_4)) {\n\t\tFILE * VAR_7 = fopen(VAR_4, \"wb\");\n\t\tif (!VAR_7) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", VAR_4);\n\t\t\treturn;\n\t\t}\n\t\tfclose(VAR_7);\n\t}\n\n\tVAR_1 = mount(VAR_2, VAR_4, \"none\", VAR_8, NULL);\n\tif (VAR_1 < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", VAR_2);\n}",
    "func_graph_path_before": "lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be/conf.c/vul/before/7.json",
    "func": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
    "abstract_func": "void lxc_execute_bind_init(struct lxc_conf *VAR_0)\n{\n\tint VAR_1;\n\tchar VAR_2[VAR_3], VAR_4[VAR_3], *VAR_5;\n\n\t/* COMMENT_0 */\n\tVAR_5 = choose_init(VAR_0->rootfs.mount);\n\tif (VAR_5) {\n\t\tfree(VAR_5);\n\t\treturn;\n\t}\n\n\tVAR_1 = snprintf(VAR_2, VAR_3, VAR_6 \"/init.lxc.static\");\n\tif (VAR_1 < 0 || VAR_1 >= VAR_3) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(VAR_2)) {\n\t\tINFO(\"%s does not exist on host\", VAR_2);\n\t\treturn;\n\t}\n\n\tVAR_1 = snprintf(VAR_4, VAR_3, \"%s%s\", VAR_0->rootfs.mount, \"/init.lxc.static\");\n\tif (VAR_1 < 0 || VAR_1 >= VAR_3) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(VAR_4)) {\n\t\tFILE * VAR_7 = fopen(VAR_4, \"wb\");\n\t\tif (!VAR_7) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", VAR_4);\n\t\t\treturn;\n\t\t}\n\t\tfclose(VAR_7);\n\t}\n\n\tVAR_1 = safe_mount(VAR_2, VAR_4, \"none\", VAR_8, NULL, VAR_0->rootfs.mount);\n\tif (VAR_1 < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", VAR_2);\n}",
    "func_graph_path": "lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be/conf.c/vul/after/7.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n \tINFO(\"lxc.init.static bound into container at %s\", path);",
    "diff_line_info": {
        "deleted_lines": [
            "\tret = mount(path, destpath, \"none\", MS_BIND, NULL);"
        ],
        "added_lines": [
            "\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}