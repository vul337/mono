{
    "cve_id": "CVE-2021-46328",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "Moddable-OpenSource/moddable",
    "commit_msg": "XS: #751",
    "commit_hash": "6c88625e020649ebdfdd12862c44f5bf4ef5d994",
    "git_url": "https://github.com/Moddable-OpenSource/moddable/commit/6c88625e020649ebdfdd12862c44f5bf4ef5d994",
    "file_path": "xs/sources/xsString.c",
    "func_name": "fxPushSubstitutionString",
    "func_before": "void fxPushSubstitutionString(txMachine* the, txSlot* string, txInteger size, txInteger offset, txSlot* match, txInteger length, txInteger count, txSlot* captures, txSlot* groups, txSlot* replace)\n{\n\ttxString r;\n\ttxInteger l;\n\ttxBoolean flag;\n\ttxByte c, d;\n\ttxInteger i, j;\n\ttxSlot* capture;\n\ttxString s;\n\tr = replace->value.string;\n\tl = 0;\n\tflag = 0;\n\twhile ((c = c_read8(r++))) {\n\t\tif (c == '$') {\n\t\t\tc = c_read8(r++);\n\t\t\tswitch (c) {\n\t\t\tcase '$':\n\t\t\t\tl++;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tl += length;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\tcase '`':\n\t\t\t\tl += offset;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\tl += size - (offset + length);\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tif (groups && mxIsReference(groups)) {\n\t\t\t\t\ttxString t = r;\n\t\t\t\t\twhile ((d = c_read8(r))) {\n\t\t\t\t\t\tif (d == '>')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tr++;\n\t\t\t\t\t}\n\t\t\t\t\tif (d) {\n\t\t\t\t\t\ttxInteger n = mxPtrDiff(r - t);\n\t\t\t\t\t\ttxID name;\n\t\t\t\t\t\tif (n > 255)\n\t\t\t\t\t\t\tfxJump(the);\n\t\t\t\t\t\tc_memcpy(the->nameBuffer, t, n);\n\t\t\t\t\t\tthe->nameBuffer[n] = 0;\n\t\t\t\t\t\tname = fxFindName(the, the->nameBuffer);\n\t\t\t\t\t\tif (name) {\n \t\t\t\t\t\t\tmxPushSlot(groups);\n\t\t\t\t\t\t\tmxGetID(name);\n\t\t\t\t\t\t\tif (!mxIsUndefined(the->stack)) {\n\t\t\t\t\t\t\t\tfxToString(the, the->stack);\n\t\t\t\t\t\t\t\tl += mxStringLength(the->stack->value.string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmxPop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr++;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tr = t;\n\t\t\t\t\t\tl += 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (('0' <= c) && (c <= '9')) {\n\t\t\t\t\ti = c - '0';\n\t\t\t\t\td = c_read8(r);\n\t\t\t\t\tif (('0' <= d) && (d <= '9')) {\n\t\t\t\t\t\tj = (i * 10) + d - '0';\n\t\t\t\t\t\tif ((0 < j) && (j <= count)) {\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\td = 0;\n\t\t\t\t\tif ((0 < i) && (i <= count)) {\n\t\t\t\t\t\tcapture = (captures + count - i);\n\t\t\t\t\t\tif (capture->kind != XS_UNDEFINED_KIND)\n\t\t\t\t\t\t\tl += mxStringLength(capture->value.string);\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tif (d)\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl++;\n\t\t\t\t\tif (c)\n\t\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tl++;\n\t}\n\tif (flag) {\n\t\tmxPushUndefined();\n\t\tthe->stack->value.string = (txString)fxNewChunk(the, l + 1);\n\t\tthe->stack->kind = XS_STRING_KIND;\n\t\tr = replace->value.string;\n\t\ts = the->stack->value.string;\n\t\twhile ((c = c_read8(r++))) {\n\t\t\tif (c == '$') {\n\t\t\t\tc = c_read8(r++);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '$':\n\t\t\t\t\t*s++ = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tl = length;\n\t\t\t\t\tc_memcpy(s, match->value.string, l);\n\t\t\t\t\ts += l;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '`':\n\t\t\t\t\tl = offset;\n\t\t\t\t\tc_memcpy(s, string->value.string, l);\n\t\t\t\t\ts += l;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tl = size - (offset + length);\n                    if (l > 0) {\n                        c_memcpy(s, string->value.string + offset + length, l);\n                        s += l;\n                    }\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tif (groups && mxIsReference(groups)) {\n\t\t\t\t\t\ttxString t = r;\n\t\t\t\t\t\twhile ((d = c_read8(r))) {\n\t\t\t\t\t\t\tif (d == '>')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (d) {\n\t\t\t\t\t\t\ttxInteger n = mxPtrDiff(r - t);\n\t\t\t\t\t\t\ttxID name;\n\t\t\t\t\t\t\tif (n > 255)\n\t\t\t\t\t\t\t\tfxJump(the);\n\t\t\t\t\t\t\tc_memcpy(the->nameBuffer, t, n);\n\t\t\t\t\t\t\tthe->nameBuffer[n] = 0;\n\t\t\t\t\t\t\tname = fxFindName(the, the->nameBuffer);\n\t\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\t\tmxPushSlot(groups);\n\t\t\t\t\t\t\t\tmxGetID(name);\n\t\t\t\t\t\t\t\tif (!mxIsUndefined(the->stack)) {\n\t\t\t\t\t\t\t\t\tfxToString(the, the->stack);\n\t\t\t\t\t\t\t\t\tl = mxStringLength(the->stack->value.string);\n\t\t\t\t\t\t\t\t\tc_memcpy(s, the->stack->value.string, l);\n\t\t\t\t\t\t\t\t\ts += l;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmxPop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tr = t;\n\t\t\t\t\t\t\t*s++ = '$';\n\t\t\t\t\t\t\t*s++ = '<';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*s++ = '$';\n\t\t\t\t\t\t*s++ = '<';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (('0' <= c) && (c <= '9')) {\n\t\t\t\t\t\ti = c - '0';\n\t\t\t\t\t\td = c_read8(r);\n\t\t\t\t\t\tif (('0' <= d) && (d <= '9')) {\n\t\t\t\t\t\t\tj = (i * 10) + d - '0';\n\t\t\t\t\t\t\tif ((0 < j) && (j <= count)) {\n\t\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\tif ((0 < i) && (i <= count)) {\n\t\t\t\t\t\t\tcapture = (captures + count - i);\n\t\t\t\t\t\t\tif (capture->kind != XS_UNDEFINED_KIND) {\n\t\t\t\t\t\t\t\tl = mxStringLength(capture->value.string);\n\t\t\t\t\t\t\t\tc_memcpy(s, capture->value.string, l);\n\t\t\t\t\t\t\t\ts += l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t*s++ = '$';\n\t\t\t\t\t\t\t*s++ = c;\n\t\t\t\t\t\t\tif (d)\n\t\t\t\t\t\t\t\t*s++ = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*s++ = '$';\n\t\t\t\t\t\tif (c)\n\t\t\t\t\t\t\t*s++ = c;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\t*s++ = c;\n\t\t}\n\t\t*s = 0;\n\t}\n\telse\n\t\tmxPushSlot(replace);\n}",
    "abstract_func_before": "void fxPushSubstitutionString(txMachine* VAR_0, txSlot* VAR_1, txInteger VAR_2, txInteger VAR_3, txSlot* VAR_4, txInteger VAR_5, txInteger VAR_6, txSlot* VAR_7, txSlot* VAR_8, txSlot* VAR_9)\n{\n\ttxString VAR_10;\n\ttxInteger VAR_11;\n\ttxBoolean VAR_12;\n\ttxByte VAR_13, VAR_14;\n\ttxInteger VAR_15, VAR_16;\n\ttxSlot* VAR_17;\n\ttxString VAR_18;\n\tVAR_10 = VAR_9->value.string;\n\tVAR_11 = 0;\n\tVAR_12 = 0;\n\twhile ((VAR_13 = c_read8(VAR_10++))) {\n\t\tif (VAR_13 == '$') {\n\t\t\tVAR_13 = c_read8(VAR_10++);\n\t\t\tswitch (VAR_13) {\n\t\t\tcase '$':\n\t\t\t\tVAR_11++;\n\t\t\t\tVAR_12 = 1;\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tVAR_11 += VAR_5;\n\t\t\t\tVAR_12 = 1;\n\t\t\t\tbreak;\n\t\t\tcase '`':\n\t\t\t\tVAR_11 += VAR_3;\n\t\t\t\tVAR_12 = 1;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\tVAR_11 += VAR_2 - (VAR_3 + VAR_5);\n\t\t\t\tVAR_12 = 1;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tif (VAR_8 && mxIsReference(VAR_8)) {\n\t\t\t\t\ttxString VAR_19 = VAR_10;\n\t\t\t\t\twhile ((VAR_14 = c_read8(VAR_10))) {\n\t\t\t\t\t\tif (VAR_14 == '>')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\ttxInteger VAR_20 = mxPtrDiff(VAR_10 - VAR_19);\n\t\t\t\t\t\ttxID VAR_21;\n\t\t\t\t\t\tif (VAR_20 > 255)\n\t\t\t\t\t\t\tfxJump(VAR_0);\n\t\t\t\t\t\tc_memcpy(VAR_0->nameBuffer, VAR_19, VAR_20);\n\t\t\t\t\t\tVAR_0->nameBuffer[VAR_20] = 0;\n\t\t\t\t\t\tVAR_21 = fxFindName(VAR_0, VAR_0->nameBuffer);\n\t\t\t\t\t\tif (VAR_21) {\n \t\t\t\t\t\t\tmxPushSlot(VAR_8);\n\t\t\t\t\t\t\tmxGetID(VAR_21);\n\t\t\t\t\t\t\tif (!mxIsUndefined(VAR_0->stack)) {\n\t\t\t\t\t\t\t\tfxToString(VAR_0, VAR_0->stack);\n\t\t\t\t\t\t\t\tVAR_11 += mxStringLength(VAR_0->stack->value.string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmxPop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\tVAR_12 = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tVAR_10 = VAR_19;\n\t\t\t\t\t\tVAR_11 += 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tVAR_11 += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (('0' <= VAR_13) && (VAR_13 <= '9')) {\n\t\t\t\t\tVAR_15 = VAR_13 - '0';\n\t\t\t\t\tVAR_14 = c_read8(VAR_10);\n\t\t\t\t\tif (('0' <= VAR_14) && (VAR_14 <= '9')) {\n\t\t\t\t\t\tVAR_16 = (VAR_15 * 10) + VAR_14 - '0';\n\t\t\t\t\t\tif ((0 < VAR_16) && (VAR_16 <= VAR_6)) {\n\t\t\t\t\t\t\tVAR_15 = VAR_16;\n\t\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tVAR_14 = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tVAR_14 = 0;\n\t\t\t\t\tif ((0 < VAR_15) && (VAR_15 <= VAR_6)) {\n\t\t\t\t\t\tVAR_17 = (VAR_7 + VAR_6 - VAR_15);\n\t\t\t\t\t\tif (VAR_17->kind != VAR_22)\n\t\t\t\t\t\t\tVAR_11 += mxStringLength(VAR_17->value.string);\n\t\t\t\t\t\tVAR_12 = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tVAR_11++;\n\t\t\t\t\t\tVAR_11++;\n\t\t\t\t\t\tif (VAR_14)\n\t\t\t\t\t\t\tVAR_11++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tVAR_11++;\n\t\t\t\t\tif (VAR_13)\n\t\t\t\t\t\tVAR_11++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!VAR_13)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tVAR_11++;\n\t}\n\tif (VAR_12) {\n\t\tmxPushUndefined();\n\t\tVAR_0->stack->value.string = (txString)fxNewChunk(VAR_0, VAR_11 + 1);\n\t\tVAR_0->stack->kind = VAR_23;\n\t\tVAR_10 = VAR_9->value.string;\n\t\tVAR_18 = VAR_0->stack->value.string;\n\t\twhile ((VAR_13 = c_read8(VAR_10++))) {\n\t\t\tif (VAR_13 == '$') {\n\t\t\t\tVAR_13 = c_read8(VAR_10++);\n\t\t\t\tswitch (VAR_13) {\n\t\t\t\tcase '$':\n\t\t\t\t\t*VAR_18++ = VAR_13;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tVAR_11 = VAR_5;\n\t\t\t\t\tc_memcpy(VAR_18, VAR_4->value.string, VAR_11);\n\t\t\t\t\tVAR_18 += VAR_11;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '`':\n\t\t\t\t\tVAR_11 = VAR_3;\n\t\t\t\t\tc_memcpy(VAR_18, VAR_1->value.string, VAR_11);\n\t\t\t\t\tVAR_18 += VAR_11;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tVAR_11 = VAR_2 - (VAR_3 + VAR_5);\n                    if (VAR_11 > 0) {\n                        c_memcpy(VAR_18, VAR_1->value.string + VAR_3 + VAR_5, VAR_11);\n                        VAR_18 += VAR_11;\n                    }\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tif (VAR_8 && mxIsReference(VAR_8)) {\n\t\t\t\t\t\ttxString VAR_19 = VAR_10;\n\t\t\t\t\t\twhile ((VAR_14 = c_read8(VAR_10))) {\n\t\t\t\t\t\t\tif (VAR_14 == '>')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\ttxInteger VAR_20 = mxPtrDiff(VAR_10 - VAR_19);\n\t\t\t\t\t\t\ttxID VAR_21;\n\t\t\t\t\t\t\tif (VAR_20 > 255)\n\t\t\t\t\t\t\t\tfxJump(VAR_0);\n\t\t\t\t\t\t\tc_memcpy(VAR_0->nameBuffer, VAR_19, VAR_20);\n\t\t\t\t\t\t\tVAR_0->nameBuffer[VAR_20] = 0;\n\t\t\t\t\t\t\tVAR_21 = fxFindName(VAR_0, VAR_0->nameBuffer);\n\t\t\t\t\t\t\tif (VAR_21) {\n\t\t\t\t\t\t\t\tmxPushSlot(VAR_8);\n\t\t\t\t\t\t\t\tmxGetID(VAR_21);\n\t\t\t\t\t\t\t\tif (!mxIsUndefined(VAR_0->stack)) {\n\t\t\t\t\t\t\t\t\tfxToString(VAR_0, VAR_0->stack);\n\t\t\t\t\t\t\t\t\tVAR_11 = mxStringLength(VAR_0->stack->value.string);\n\t\t\t\t\t\t\t\t\tc_memcpy(VAR_18, VAR_0->stack->value.string, VAR_11);\n\t\t\t\t\t\t\t\t\tVAR_18 += VAR_11;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmxPop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tVAR_10 = VAR_19;\n\t\t\t\t\t\t\t*VAR_18++ = '$';\n\t\t\t\t\t\t\t*VAR_18++ = '<';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*VAR_18++ = '$';\n\t\t\t\t\t\t*VAR_18++ = '<';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (('0' <= VAR_13) && (VAR_13 <= '9')) {\n\t\t\t\t\t\tVAR_15 = VAR_13 - '0';\n\t\t\t\t\t\tVAR_14 = c_read8(VAR_10);\n\t\t\t\t\t\tif (('0' <= VAR_14) && (VAR_14 <= '9')) {\n\t\t\t\t\t\t\tVAR_16 = (VAR_15 * 10) + VAR_14 - '0';\n\t\t\t\t\t\t\tif ((0 < VAR_16) && (VAR_16 <= VAR_6)) {\n\t\t\t\t\t\t\t\tVAR_15 = VAR_16;\n\t\t\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tVAR_14 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tVAR_14 = 0;\n\t\t\t\t\t\tif ((0 < VAR_15) && (VAR_15 <= VAR_6)) {\n\t\t\t\t\t\t\tVAR_17 = (VAR_7 + VAR_6 - VAR_15);\n\t\t\t\t\t\t\tif (VAR_17->kind != VAR_22) {\n\t\t\t\t\t\t\t\tVAR_11 = mxStringLength(VAR_17->value.string);\n\t\t\t\t\t\t\t\tc_memcpy(VAR_18, VAR_17->value.string, VAR_11);\n\t\t\t\t\t\t\t\tVAR_18 += VAR_11;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t*VAR_18++ = '$';\n\t\t\t\t\t\t\t*VAR_18++ = VAR_13;\n\t\t\t\t\t\t\tif (VAR_14)\n\t\t\t\t\t\t\t\t*VAR_18++ = VAR_14;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*VAR_18++ = '$';\n\t\t\t\t\t\tif (VAR_13)\n\t\t\t\t\t\t\t*VAR_18++ = VAR_13;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!VAR_13)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\t*VAR_18++ = VAR_13;\n\t\t}\n\t\t*VAR_18 = 0;\n\t}\n\telse\n\t\tmxPushSlot(VAR_9);\n}",
    "func_graph_path_before": "Moddable-OpenSource/moddable/6c88625e020649ebdfdd12862c44f5bf4ef5d994/xsString.c/vul/before/0.json",
    "func": "void fxPushSubstitutionString(txMachine* the, txSlot* string, txInteger size, txInteger offset, txSlot* match, txInteger length, txInteger count, txSlot* captures, txSlot* groups, txSlot* replace)\n{\n\ttxString r;\n\ttxInteger m;\n\ttxInteger l;\n\ttxBoolean flag;\n\ttxByte c, d;\n\ttxInteger i, j;\n\ttxSlot* capture;\n\ttxString s;\n\tr = replace->value.string;\n\tm = 0;\n\tl = 0;\n\tflag = 0;\n\twhile ((c = c_read8(r++))) {\n\t\tif (m <= l)\n\t\t\tm = l;\n\t\telse\n\t\t\tfxAbort(the, XS_NOT_ENOUGH_MEMORY_EXIT);\n\t\tif (c == '$') {\n\t\t\tc = c_read8(r++);\n\t\t\tswitch (c) {\n\t\t\tcase '$':\n\t\t\t\tl++;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tl += length;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\tcase '`':\n\t\t\t\tl += offset;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\tl += size - (offset + length);\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tif (groups && mxIsReference(groups)) {\n\t\t\t\t\ttxString t = r;\n\t\t\t\t\twhile ((d = c_read8(r))) {\n\t\t\t\t\t\tif (d == '>')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tr++;\n\t\t\t\t\t}\n\t\t\t\t\tif (d) {\n\t\t\t\t\t\ttxInteger n = mxPtrDiff(r - t);\n\t\t\t\t\t\ttxID name;\n\t\t\t\t\t\tif (n > 255)\n\t\t\t\t\t\t\tfxJump(the);\n\t\t\t\t\t\tc_memcpy(the->nameBuffer, t, n);\n\t\t\t\t\t\tthe->nameBuffer[n] = 0;\n\t\t\t\t\t\tname = fxFindName(the, the->nameBuffer);\n\t\t\t\t\t\tif (name) {\n \t\t\t\t\t\t\tmxPushSlot(groups);\n\t\t\t\t\t\t\tmxGetID(name);\n\t\t\t\t\t\t\tif (!mxIsUndefined(the->stack)) {\n\t\t\t\t\t\t\t\tfxToString(the, the->stack);\n\t\t\t\t\t\t\t\tl += mxStringLength(the->stack->value.string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmxPop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr++;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tr = t;\n\t\t\t\t\t\tl += 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (('0' <= c) && (c <= '9')) {\n\t\t\t\t\ti = c - '0';\n\t\t\t\t\td = c_read8(r);\n\t\t\t\t\tif (('0' <= d) && (d <= '9')) {\n\t\t\t\t\t\tj = (i * 10) + d - '0';\n\t\t\t\t\t\tif ((0 < j) && (j <= count)) {\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\td = 0;\n\t\t\t\t\tif ((0 < i) && (i <= count)) {\n\t\t\t\t\t\tcapture = (captures + count - i);\n\t\t\t\t\t\tif (capture->kind != XS_UNDEFINED_KIND)\n\t\t\t\t\t\t\tl += mxStringLength(capture->value.string);\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tif (d)\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl++;\n\t\t\t\t\tif (c)\n\t\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tl++;\n\t}\n\tif (flag) {\n\t\tmxPushUndefined();\n\t\tthe->stack->value.string = (txString)fxNewChunk(the, fxAddChunkSizes(the, l, 1));\n\t\tthe->stack->kind = XS_STRING_KIND;\n\t\tr = replace->value.string;\n\t\ts = the->stack->value.string;\n\t\twhile ((c = c_read8(r++))) {\n\t\t\tif (c == '$') {\n\t\t\t\tc = c_read8(r++);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '$':\n\t\t\t\t\t*s++ = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tl = length;\n\t\t\t\t\tc_memcpy(s, match->value.string, l);\n\t\t\t\t\ts += l;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '`':\n\t\t\t\t\tl = offset;\n\t\t\t\t\tc_memcpy(s, string->value.string, l);\n\t\t\t\t\ts += l;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tl = size - (offset + length);\n                    if (l > 0) {\n                        c_memcpy(s, string->value.string + offset + length, l);\n                        s += l;\n                    }\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tif (groups && mxIsReference(groups)) {\n\t\t\t\t\t\ttxString t = r;\n\t\t\t\t\t\twhile ((d = c_read8(r))) {\n\t\t\t\t\t\t\tif (d == '>')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (d) {\n\t\t\t\t\t\t\ttxInteger n = mxPtrDiff(r - t);\n\t\t\t\t\t\t\ttxID name;\n\t\t\t\t\t\t\tif (n > 255)\n\t\t\t\t\t\t\t\tfxJump(the);\n\t\t\t\t\t\t\tc_memcpy(the->nameBuffer, t, n);\n\t\t\t\t\t\t\tthe->nameBuffer[n] = 0;\n\t\t\t\t\t\t\tname = fxFindName(the, the->nameBuffer);\n\t\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\t\tmxPushSlot(groups);\n\t\t\t\t\t\t\t\tmxGetID(name);\n\t\t\t\t\t\t\t\tif (!mxIsUndefined(the->stack)) {\n\t\t\t\t\t\t\t\t\tfxToString(the, the->stack);\n\t\t\t\t\t\t\t\t\tl = mxStringLength(the->stack->value.string);\n\t\t\t\t\t\t\t\t\tc_memcpy(s, the->stack->value.string, l);\n\t\t\t\t\t\t\t\t\ts += l;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmxPop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tr = t;\n\t\t\t\t\t\t\t*s++ = '$';\n\t\t\t\t\t\t\t*s++ = '<';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*s++ = '$';\n\t\t\t\t\t\t*s++ = '<';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (('0' <= c) && (c <= '9')) {\n\t\t\t\t\t\ti = c - '0';\n\t\t\t\t\t\td = c_read8(r);\n\t\t\t\t\t\tif (('0' <= d) && (d <= '9')) {\n\t\t\t\t\t\t\tj = (i * 10) + d - '0';\n\t\t\t\t\t\t\tif ((0 < j) && (j <= count)) {\n\t\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\tif ((0 < i) && (i <= count)) {\n\t\t\t\t\t\t\tcapture = (captures + count - i);\n\t\t\t\t\t\t\tif (capture->kind != XS_UNDEFINED_KIND) {\n\t\t\t\t\t\t\t\tl = mxStringLength(capture->value.string);\n\t\t\t\t\t\t\t\tc_memcpy(s, capture->value.string, l);\n\t\t\t\t\t\t\t\ts += l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t*s++ = '$';\n\t\t\t\t\t\t\t*s++ = c;\n\t\t\t\t\t\t\tif (d)\n\t\t\t\t\t\t\t\t*s++ = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*s++ = '$';\n\t\t\t\t\t\tif (c)\n\t\t\t\t\t\t\t*s++ = c;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\t*s++ = c;\n\t\t}\n\t\t*s = 0;\n\t}\n\telse\n\t\tmxPushSlot(replace);\n}",
    "abstract_func": "void fxPushSubstitutionString(txMachine* VAR_0, txSlot* VAR_1, txInteger VAR_2, txInteger VAR_3, txSlot* VAR_4, txInteger VAR_5, txInteger VAR_6, txSlot* VAR_7, txSlot* VAR_8, txSlot* VAR_9)\n{\n\ttxString VAR_10;\n\ttxInteger VAR_11;\n\ttxInteger VAR_12;\n\ttxBoolean VAR_13;\n\ttxByte VAR_14, VAR_15;\n\ttxInteger VAR_16, VAR_17;\n\ttxSlot* VAR_18;\n\ttxString VAR_19;\n\tVAR_10 = VAR_9->value.string;\n\tVAR_11 = 0;\n\tVAR_12 = 0;\n\tVAR_13 = 0;\n\twhile ((VAR_14 = c_read8(VAR_10++))) {\n\t\tif (VAR_11 <= VAR_12)\n\t\t\tVAR_11 = VAR_12;\n\t\telse\n\t\t\tfxAbort(VAR_0, VAR_20);\n\t\tif (VAR_14 == '$') {\n\t\t\tVAR_14 = c_read8(VAR_10++);\n\t\t\tswitch (VAR_14) {\n\t\t\tcase '$':\n\t\t\t\tVAR_12++;\n\t\t\t\tVAR_13 = 1;\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tVAR_12 += VAR_5;\n\t\t\t\tVAR_13 = 1;\n\t\t\t\tbreak;\n\t\t\tcase '`':\n\t\t\t\tVAR_12 += VAR_3;\n\t\t\t\tVAR_13 = 1;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\tVAR_12 += VAR_2 - (VAR_3 + VAR_5);\n\t\t\t\tVAR_13 = 1;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tif (VAR_8 && mxIsReference(VAR_8)) {\n\t\t\t\t\ttxString VAR_21 = VAR_10;\n\t\t\t\t\twhile ((VAR_15 = c_read8(VAR_10))) {\n\t\t\t\t\t\tif (VAR_15 == '>')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_15) {\n\t\t\t\t\t\ttxInteger VAR_22 = mxPtrDiff(VAR_10 - VAR_21);\n\t\t\t\t\t\ttxID VAR_23;\n\t\t\t\t\t\tif (VAR_22 > 255)\n\t\t\t\t\t\t\tfxJump(VAR_0);\n\t\t\t\t\t\tc_memcpy(VAR_0->nameBuffer, VAR_21, VAR_22);\n\t\t\t\t\t\tVAR_0->nameBuffer[VAR_22] = 0;\n\t\t\t\t\t\tVAR_23 = fxFindName(VAR_0, VAR_0->nameBuffer);\n\t\t\t\t\t\tif (VAR_23) {\n \t\t\t\t\t\t\tmxPushSlot(VAR_8);\n\t\t\t\t\t\t\tmxGetID(VAR_23);\n\t\t\t\t\t\t\tif (!mxIsUndefined(VAR_0->stack)) {\n\t\t\t\t\t\t\t\tfxToString(VAR_0, VAR_0->stack);\n\t\t\t\t\t\t\t\tVAR_12 += mxStringLength(VAR_0->stack->value.string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmxPop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\tVAR_13 = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tVAR_10 = VAR_21;\n\t\t\t\t\t\tVAR_12 += 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tVAR_12 += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (('0' <= VAR_14) && (VAR_14 <= '9')) {\n\t\t\t\t\tVAR_16 = VAR_14 - '0';\n\t\t\t\t\tVAR_15 = c_read8(VAR_10);\n\t\t\t\t\tif (('0' <= VAR_15) && (VAR_15 <= '9')) {\n\t\t\t\t\t\tVAR_17 = (VAR_16 * 10) + VAR_15 - '0';\n\t\t\t\t\t\tif ((0 < VAR_17) && (VAR_17 <= VAR_6)) {\n\t\t\t\t\t\t\tVAR_16 = VAR_17;\n\t\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tVAR_15 = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tVAR_15 = 0;\n\t\t\t\t\tif ((0 < VAR_16) && (VAR_16 <= VAR_6)) {\n\t\t\t\t\t\tVAR_18 = (VAR_7 + VAR_6 - VAR_16);\n\t\t\t\t\t\tif (VAR_18->kind != VAR_24)\n\t\t\t\t\t\t\tVAR_12 += mxStringLength(VAR_18->value.string);\n\t\t\t\t\t\tVAR_13 = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tVAR_12++;\n\t\t\t\t\t\tVAR_12++;\n\t\t\t\t\t\tif (VAR_15)\n\t\t\t\t\t\t\tVAR_12++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tVAR_12++;\n\t\t\t\t\tif (VAR_14)\n\t\t\t\t\t\tVAR_12++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!VAR_14)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tVAR_12++;\n\t}\n\tif (VAR_13) {\n\t\tmxPushUndefined();\n\t\tVAR_0->stack->value.string = (txString)fxNewChunk(VAR_0, fxAddChunkSizes(VAR_0, VAR_12, 1));\n\t\tVAR_0->stack->kind = VAR_25;\n\t\tVAR_10 = VAR_9->value.string;\n\t\tVAR_19 = VAR_0->stack->value.string;\n\t\twhile ((VAR_14 = c_read8(VAR_10++))) {\n\t\t\tif (VAR_14 == '$') {\n\t\t\t\tVAR_14 = c_read8(VAR_10++);\n\t\t\t\tswitch (VAR_14) {\n\t\t\t\tcase '$':\n\t\t\t\t\t*VAR_19++ = VAR_14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '&':\n\t\t\t\t\tVAR_12 = VAR_5;\n\t\t\t\t\tc_memcpy(VAR_19, VAR_4->value.string, VAR_12);\n\t\t\t\t\tVAR_19 += VAR_12;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '`':\n\t\t\t\t\tVAR_12 = VAR_3;\n\t\t\t\t\tc_memcpy(VAR_19, VAR_1->value.string, VAR_12);\n\t\t\t\t\tVAR_19 += VAR_12;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tVAR_12 = VAR_2 - (VAR_3 + VAR_5);\n                    if (VAR_12 > 0) {\n                        c_memcpy(VAR_19, VAR_1->value.string + VAR_3 + VAR_5, VAR_12);\n                        VAR_19 += VAR_12;\n                    }\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tif (VAR_8 && mxIsReference(VAR_8)) {\n\t\t\t\t\t\ttxString VAR_21 = VAR_10;\n\t\t\t\t\t\twhile ((VAR_15 = c_read8(VAR_10))) {\n\t\t\t\t\t\t\tif (VAR_15 == '>')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (VAR_15) {\n\t\t\t\t\t\t\ttxInteger VAR_22 = mxPtrDiff(VAR_10 - VAR_21);\n\t\t\t\t\t\t\ttxID VAR_23;\n\t\t\t\t\t\t\tif (VAR_22 > 255)\n\t\t\t\t\t\t\t\tfxJump(VAR_0);\n\t\t\t\t\t\t\tc_memcpy(VAR_0->nameBuffer, VAR_21, VAR_22);\n\t\t\t\t\t\t\tVAR_0->nameBuffer[VAR_22] = 0;\n\t\t\t\t\t\t\tVAR_23 = fxFindName(VAR_0, VAR_0->nameBuffer);\n\t\t\t\t\t\t\tif (VAR_23) {\n\t\t\t\t\t\t\t\tmxPushSlot(VAR_8);\n\t\t\t\t\t\t\t\tmxGetID(VAR_23);\n\t\t\t\t\t\t\t\tif (!mxIsUndefined(VAR_0->stack)) {\n\t\t\t\t\t\t\t\t\tfxToString(VAR_0, VAR_0->stack);\n\t\t\t\t\t\t\t\t\tVAR_12 = mxStringLength(VAR_0->stack->value.string);\n\t\t\t\t\t\t\t\t\tc_memcpy(VAR_19, VAR_0->stack->value.string, VAR_12);\n\t\t\t\t\t\t\t\t\tVAR_19 += VAR_12;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmxPop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tVAR_10 = VAR_21;\n\t\t\t\t\t\t\t*VAR_19++ = '$';\n\t\t\t\t\t\t\t*VAR_19++ = '<';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*VAR_19++ = '$';\n\t\t\t\t\t\t*VAR_19++ = '<';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (('0' <= VAR_14) && (VAR_14 <= '9')) {\n\t\t\t\t\t\tVAR_16 = VAR_14 - '0';\n\t\t\t\t\t\tVAR_15 = c_read8(VAR_10);\n\t\t\t\t\t\tif (('0' <= VAR_15) && (VAR_15 <= '9')) {\n\t\t\t\t\t\t\tVAR_17 = (VAR_16 * 10) + VAR_15 - '0';\n\t\t\t\t\t\t\tif ((0 < VAR_17) && (VAR_17 <= VAR_6)) {\n\t\t\t\t\t\t\t\tVAR_16 = VAR_17;\n\t\t\t\t\t\t\t\tVAR_10++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tVAR_15 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tVAR_15 = 0;\n\t\t\t\t\t\tif ((0 < VAR_16) && (VAR_16 <= VAR_6)) {\n\t\t\t\t\t\t\tVAR_18 = (VAR_7 + VAR_6 - VAR_16);\n\t\t\t\t\t\t\tif (VAR_18->kind != VAR_24) {\n\t\t\t\t\t\t\t\tVAR_12 = mxStringLength(VAR_18->value.string);\n\t\t\t\t\t\t\t\tc_memcpy(VAR_19, VAR_18->value.string, VAR_12);\n\t\t\t\t\t\t\t\tVAR_19 += VAR_12;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t*VAR_19++ = '$';\n\t\t\t\t\t\t\t*VAR_19++ = VAR_14;\n\t\t\t\t\t\t\tif (VAR_15)\n\t\t\t\t\t\t\t\t*VAR_19++ = VAR_15;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*VAR_19++ = '$';\n\t\t\t\t\t\tif (VAR_14)\n\t\t\t\t\t\t\t*VAR_19++ = VAR_14;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!VAR_14)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\t*VAR_19++ = VAR_14;\n\t\t}\n\t\t*VAR_19 = 0;\n\t}\n\telse\n\t\tmxPushSlot(VAR_9);\n}",
    "func_graph_path": "Moddable-OpenSource/moddable/6c88625e020649ebdfdd12862c44f5bf4ef5d994/xsString.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n void fxPushSubstitutionString(txMachine* the, txSlot* string, txInteger size, txInteger offset, txSlot* match, txInteger length, txInteger count, txSlot* captures, txSlot* groups, txSlot* replace)\n {\n \ttxString r;\n+\ttxInteger m;\n \ttxInteger l;\n \ttxBoolean flag;\n \ttxByte c, d;\n@@ -8,9 +9,14 @@\n \ttxSlot* capture;\n \ttxString s;\n \tr = replace->value.string;\n+\tm = 0;\n \tl = 0;\n \tflag = 0;\n \twhile ((c = c_read8(r++))) {\n+\t\tif (m <= l)\n+\t\t\tm = l;\n+\t\telse\n+\t\t\tfxAbort(the, XS_NOT_ENOUGH_MEMORY_EXIT);\n \t\tif (c == '$') {\n \t\t\tc = c_read8(r++);\n \t\t\tswitch (c) {\n@@ -110,7 +116,7 @@\n \t}\n \tif (flag) {\n \t\tmxPushUndefined();\n-\t\tthe->stack->value.string = (txString)fxNewChunk(the, l + 1);\n+\t\tthe->stack->value.string = (txString)fxNewChunk(the, fxAddChunkSizes(the, l, 1));\n \t\tthe->stack->kind = XS_STRING_KIND;\n \t\tr = replace->value.string;\n \t\ts = the->stack->value.string;",
    "diff_line_info": {
        "deleted_lines": [
            "\t\tthe->stack->value.string = (txString)fxNewChunk(the, l + 1);"
        ],
        "added_lines": [
            "\ttxInteger m;",
            "\tm = 0;",
            "\t\tif (m <= l)",
            "\t\t\tm = l;",
            "\t\telse",
            "\t\t\tfxAbort(the, XS_NOT_ENOUGH_MEMORY_EXIT);",
            "\t\tthe->stack->value.string = (txString)fxNewChunk(the, fxAddChunkSizes(the, l, 1));"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}