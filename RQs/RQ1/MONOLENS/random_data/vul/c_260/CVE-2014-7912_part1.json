{
    "cve_id": "CVE-2014-7912",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "android",
    "commit_msg": "Fun with buffer overrruns.\n\nIn get_option(): don't read past the end of the option buffer.\n\nAlso add a small unittest to verify sane behaviour for the above.\nThe dhcpcd code is not easily refactored into a library, nor is it\nentirely possible to include some header files directly since some\nstructures use C++ reserved keywords (\"new\") for variable names.\n\nIn print_option(): use of snprintf() returns the length that\n/would/ have been written.  Add checks that the output buffer\nis not overrun when printing.\n\nThis fixes CVE-2014-7912 and CVE-2014-7913\n\nBug: 18356137\nBug: 18356135\nChange-Id: I0f907b8a952208749226ba034a416d773e068f8a\n",
    "commit_hash": "73c09dd8067250734511d955d8f792b41c7213f0",
    "git_url": "https://android.googlesource.com/platform/external/dhcpcd/+/73c09dd8067250734511d955d8f792b41c7213f0",
    "file_path": "dhcp.c",
    "func_name": "get_option",
    "func_before": "static const uint8_t *\nget_option(const struct dhcp_message *dhcp, uint8_t opt, int *len, int *type)\n{\n\tconst uint8_t *p = dhcp->options;\n\tconst uint8_t *e = p + sizeof(dhcp->options);\n\tuint8_t l, ol = 0;\n\tuint8_t o = 0;\n\tuint8_t overl = 0;\n\tuint8_t *bp = NULL;\n\tconst uint8_t *op = NULL;\n\tint bl = 0;\n\n\twhile (p < e) {\n\t\to = *p++;\n\t\tif (o == opt) {\n\t\t\tif (op) {\n\t\t\t\tif (!opt_buffer) {\n\t\t\t\t\topt_buffer = xmalloc(sizeof(*dhcp));\n#ifdef DEBUG_MEMORY\n\t\t\t\t\tatexit(free_option_buffer);\n#endif\n\t\t\t\t}\n\t\t\t\tif (!bp) \n\t\t\t\t\tbp = opt_buffer;\n\t\t\t\tmemcpy(bp, op, ol);\n\t\t\t\tbp += ol;\n\t\t\t}\n\t\t\tol = *p;\n\t\t\top = p + 1;\n\t\t\tbl += ol;\n\t\t}\n\t\tswitch (o) {\n\t\tcase DHO_PAD:\n\t\t\tcontinue;\n\t\tcase DHO_END:\n\t\t\tif (overl & 1) {\n\t\t\t\t/* bit 1 set means parse boot file */\n\t\t\t\toverl &= ~1;\n\t\t\t\tp = dhcp->bootfile;\n\t\t\t\te = p + sizeof(dhcp->bootfile);\n\t\t\t} else if (overl & 2) {\n\t\t\t\t/* bit 2 set means parse server name */\n\t\t\t\toverl &= ~2;\n\t\t\t\tp = dhcp->servername;\n\t\t\t\te = p + sizeof(dhcp->servername);\n\t\t\t} else\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase DHO_OPTIONSOVERLOADED:\n\t\t\t/* Ensure we only get this option once */\n\t\t\tif (!overl)\n\t\t\t\toverl = 0x80 | p[1];\n\t\t\tbreak;\n\t\t}\n\t\tl = *p++;\n\t\tp += l;\n\t}\n\nexit:\n\tif (valid_length(opt, bl, type) == -1) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif (len)\n\t\t*len = bl;\n\tif (bp) {\n\t\tmemcpy(bp, op, ol);\n\t\treturn (const uint8_t *)opt_buffer;\n\t}\n\tif (op)\n\t\treturn op;\n\terrno = ENOENT;\n\treturn NULL;\n}",
    "abstract_func_before": "static const uint8_t *\nget_option(const struct dhcp_message *VAR_0, uint8_t VAR_1, int *VAR_2, int *VAR_3)\n{\n\tconst uint8_t *VAR_4 = VAR_0->options;\n\tconst uint8_t *VAR_5 = VAR_4 + sizeof(VAR_0->options);\n\tuint8_t VAR_6, VAR_7 = 0;\n\tuint8_t VAR_8 = 0;\n\tuint8_t VAR_9 = 0;\n\tuint8_t *VAR_10 = NULL;\n\tconst uint8_t *VAR_11 = NULL;\n\tint VAR_12 = 0;\n\n\twhile (VAR_4 < VAR_5) {\n\t\tVAR_8 = *VAR_4++;\n\t\tif (VAR_8 == VAR_1) {\n\t\t\tif (VAR_11) {\n\t\t\t\tif (!VAR_13) {\n\t\t\t\t\tVAR_13 = xmalloc(sizeof(*VAR_0));\n#ifdef VAR_14\n\t\t\t\t\tatexit(VAR_15);\n#endif\n\t\t\t\t}\n\t\t\t\tif (!VAR_10) \n\t\t\t\t\tVAR_10 = VAR_13;\n\t\t\t\tmemcpy(VAR_10, VAR_11, VAR_7);\n\t\t\t\tVAR_10 += VAR_7;\n\t\t\t}\n\t\t\tVAR_7 = *VAR_4;\n\t\t\tVAR_11 = VAR_4 + 1;\n\t\t\tVAR_12 += VAR_7;\n\t\t}\n\t\tswitch (VAR_8) {\n\t\tcase VAR_16:\n\t\t\tcontinue;\n\t\tcase VAR_17:\n\t\t\tif (VAR_9 & 1) {\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tVAR_9 &= ~1;\n\t\t\t\tVAR_4 = VAR_0->bootfile;\n\t\t\t\tVAR_5 = VAR_4 + sizeof(VAR_0->bootfile);\n\t\t\t} else if (VAR_9 & 2) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tVAR_9 &= ~2;\n\t\t\t\tVAR_4 = VAR_0->servername;\n\t\t\t\tVAR_5 = VAR_4 + sizeof(VAR_0->servername);\n\t\t\t} else\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase VAR_18:\n\t\t\t/* COMMENT_2 */\n\t\t\tif (!VAR_9)\n\t\t\t\tVAR_9 = 0x80 | VAR_4[1];\n\t\t\tbreak;\n\t\t}\n\t\tVAR_6 = *VAR_4++;\n\t\tVAR_4 += VAR_6;\n\t}\n\nexit:\n\tif (valid_length(VAR_1, VAR_12, VAR_3) == -1) {\n\t\tVAR_19 = VAR_20;\n\t\treturn NULL;\n\t}\n\tif (VAR_2)\n\t\t*VAR_2 = VAR_12;\n\tif (VAR_10) {\n\t\tmemcpy(VAR_10, VAR_11, VAR_7);\n\t\treturn (const uint8_t *)VAR_13;\n\t}\n\tif (VAR_11)\n\t\treturn VAR_11;\n\tVAR_19 = VAR_21;\n\treturn NULL;\n}",
    "func_graph_path_before": "android/73c09dd8067250734511d955d8f792b41c7213f0/dhcp.c/vul/before/0.json",
    "func": "static const uint8_t *\nget_option(const struct dhcp_message *dhcp, uint8_t opt, int *len, int *type)\n{\n\tconst uint8_t *p = dhcp->options;\n\tconst uint8_t *e = p + sizeof(dhcp->options);\n\tuint8_t l, ol = 0;\n\tuint8_t o = 0;\n\tuint8_t overl = 0;\n\tuint8_t *bp = NULL;\n\tconst uint8_t *op = NULL;\n\tint bl = 0;\n\n\t/* DHCP Options are in TLV format with T and L each being a single\n\t * byte.  In general, here we have p -> T, ol=p+1 -> L, op -> V.\n\t * We must make sure there is enough room to read both T and L.\n\t */\n\twhile (p + 1 < e) {\n\t\to = *p++;\n\t\tif (o == opt) {\n\t\t\tif (op) {\n\t\t\t\tif (!opt_buffer) {\n\t\t\t\t\topt_buffer = xmalloc(sizeof(*dhcp));\n#ifdef DEBUG_MEMORY\n\t\t\t\t\tatexit(free_option_buffer);\n#endif\n\t\t\t\t}\n\t\t\t\tif (!bp) \n\t\t\t\t\tbp = opt_buffer;\n\t\t\t\tmemcpy(bp, op, ol);\n\t\t\t\tbp += ol;\n\t\t\t}\n\t\t\tol = (p + *p < e) ? *p : e - (p + 1);\n\t\t\top = p + 1;\n\t\t\tbl += ol;\n\t\t}\n\t\tswitch (o) {\n\t\tcase DHO_PAD:\n\t\t\tcontinue;\n\t\tcase DHO_END:\n\t\t\tif (overl & 1) {\n\t\t\t\t/* bit 1 set means parse boot file */\n\t\t\t\toverl &= ~1;\n\t\t\t\tp = dhcp->bootfile;\n\t\t\t\te = p + sizeof(dhcp->bootfile);\n\t\t\t} else if (overl & 2) {\n\t\t\t\t/* bit 2 set means parse server name */\n\t\t\t\toverl &= ~2;\n\t\t\t\tp = dhcp->servername;\n\t\t\t\te = p + sizeof(dhcp->servername);\n\t\t\t} else\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase DHO_OPTIONSOVERLOADED:\n\t\t\t/* Ensure we only get this option once */\n\t\t\tif (!overl)\n\t\t\t\toverl = 0x80 | p[1];\n\t\t\tbreak;\n\t\t}\n\t\tl = *p++;\n\t\tp += l;\n\t}\n\nexit:\n\tif (valid_length(opt, bl, type) == -1) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif (len)\n\t\t*len = bl;\n\tif (bp) {\n\t\tmemcpy(bp, op, ol);\n\t\treturn (const uint8_t *)opt_buffer;\n\t}\n\tif (op)\n\t\treturn op;\n\terrno = ENOENT;\n\treturn NULL;\n}",
    "abstract_func": "static const uint8_t *\nget_option(const struct dhcp_message *VAR_0, uint8_t VAR_1, int *VAR_2, int *VAR_3)\n{\n\tconst uint8_t *VAR_4 = VAR_0->options;\n\tconst uint8_t *VAR_5 = VAR_4 + sizeof(VAR_0->options);\n\tuint8_t VAR_6, VAR_7 = 0;\n\tuint8_t VAR_8 = 0;\n\tuint8_t VAR_9 = 0;\n\tuint8_t *VAR_10 = NULL;\n\tconst uint8_t *VAR_11 = NULL;\n\tint VAR_12 = 0;\n\n\t/* COMMENT_0 */\n                                                                 \n                                                                \n    \n\twhile (VAR_4 + 1 < VAR_5) {\n\t\tVAR_8 = *VAR_4++;\n\t\tif (VAR_8 == VAR_1) {\n\t\t\tif (VAR_11) {\n\t\t\t\tif (!VAR_13) {\n\t\t\t\t\tVAR_13 = xmalloc(sizeof(*VAR_0));\n#ifdef VAR_14\n\t\t\t\t\tatexit(VAR_15);\n#endif\n\t\t\t\t}\n\t\t\t\tif (!VAR_10) \n\t\t\t\t\tVAR_10 = VAR_13;\n\t\t\t\tmemcpy(VAR_10, VAR_11, VAR_7);\n\t\t\t\tVAR_10 += VAR_7;\n\t\t\t}\n\t\t\tVAR_7 = (VAR_4 + *VAR_4 < VAR_5) ? *VAR_4 : VAR_5 - (VAR_4 + 1);\n\t\t\tVAR_11 = VAR_4 + 1;\n\t\t\tVAR_12 += VAR_7;\n\t\t}\n\t\tswitch (VAR_8) {\n\t\tcase VAR_16:\n\t\t\tcontinue;\n\t\tcase VAR_17:\n\t\t\tif (VAR_9 & 1) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tVAR_9 &= ~1;\n\t\t\t\tVAR_4 = VAR_0->bootfile;\n\t\t\t\tVAR_5 = VAR_4 + sizeof(VAR_0->bootfile);\n\t\t\t} else if (VAR_9 & 2) {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tVAR_9 &= ~2;\n\t\t\t\tVAR_4 = VAR_0->servername;\n\t\t\t\tVAR_5 = VAR_4 + sizeof(VAR_0->servername);\n\t\t\t} else\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase VAR_18:\n\t\t\t/* COMMENT_6 */\n\t\t\tif (!VAR_9)\n\t\t\t\tVAR_9 = 0x80 | VAR_4[1];\n\t\t\tbreak;\n\t\t}\n\t\tVAR_6 = *VAR_4++;\n\t\tVAR_4 += VAR_6;\n\t}\n\nexit:\n\tif (valid_length(VAR_1, VAR_12, VAR_3) == -1) {\n\t\tVAR_19 = VAR_20;\n\t\treturn NULL;\n\t}\n\tif (VAR_2)\n\t\t*VAR_2 = VAR_12;\n\tif (VAR_10) {\n\t\tmemcpy(VAR_10, VAR_11, VAR_7);\n\t\treturn (const uint8_t *)VAR_13;\n\t}\n\tif (VAR_11)\n\t\treturn VAR_11;\n\tVAR_19 = VAR_21;\n\treturn NULL;\n}",
    "func_graph_path": "android/73c09dd8067250734511d955d8f792b41c7213f0/dhcp.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,11 @@\n \tconst uint8_t *op = NULL;\n \tint bl = 0;\n \n-\twhile (p < e) {\n+\t/* DHCP Options are in TLV format with T and L each being a single\n+\t * byte.  In general, here we have p -> T, ol=p+1 -> L, op -> V.\n+\t * We must make sure there is enough room to read both T and L.\n+\t */\n+\twhile (p + 1 < e) {\n \t\to = *p++;\n \t\tif (o == opt) {\n \t\t\tif (op) {\n@@ -25,7 +29,7 @@\n \t\t\t\tmemcpy(bp, op, ol);\n \t\t\t\tbp += ol;\n \t\t\t}\n-\t\t\tol = *p;\n+\t\t\tol = (p + *p < e) ? *p : e - (p + 1);\n \t\t\top = p + 1;\n \t\t\tbl += ol;\n \t\t}",
    "diff_line_info": {
        "deleted_lines": [
            "\twhile (p < e) {",
            "\t\t\tol = *p;"
        ],
        "added_lines": [
            "\t/* DHCP Options are in TLV format with T and L each being a single",
            "\t * byte.  In general, here we have p -> T, ol=p+1 -> L, op -> V.",
            "\t * We must make sure there is enough room to read both T and L.",
            "\t */",
            "\twhile (p + 1 < e) {",
            "\t\t\tol = (p + *p < e) ? *p : e - (p + 1);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}