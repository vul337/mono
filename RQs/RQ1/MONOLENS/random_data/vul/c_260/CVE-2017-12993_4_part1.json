{
    "cve_id": "CVE-2017-12993",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "the-tcpdump-group/tcpdump",
    "commit_msg": "CVE-2017-12993/Juniper: Add more bounds checks.\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd tests using the capture files supplied by the reporter(s).",
    "commit_hash": "b534e304568585707c4a92422aeca25cf908ff02",
    "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02",
    "file_path": "print-juniper.c",
    "func_name": "juniper_ggsn_print",
    "func_before": "u_int\njuniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n        gh = (struct juniper_ggsn_header *)&l2info.cookie;\n\n        if (ndo->ndo_eflag) {\n            ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                   tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n        }\n\n        return l2info.header_len;\n}",
    "abstract_func_before": "u_int\njuniper_ggsn_print(netdissect_options *VAR_0,\n                   const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)\n{\n        struct juniper_l2info_t VAR_3;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *VAR_4;\n\n        VAR_3.pictype = VAR_5;\n        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)\n            return VAR_3.header_len;\n\n        VAR_2+=VAR_3.header_len;\n        VAR_4 = (struct juniper_ggsn_header *)&VAR_3.cookie;\n\n        if (VAR_0->ndo_eflag) {\n            ND_PRINT((VAR_0, \"proto %s (%u), vlan %u: \",\n                   tok2str(VAR_6,\"Unknown\",VAR_4->proto),\n                   VAR_4->proto,\n                   EXTRACT_16BITS(&VAR_4->vlan_id[0])));\n        }\n\n        switch (VAR_4->proto) {\n        case VAR_7:\n            ip_print(VAR_0, VAR_2, VAR_3.length);\n            break;\n        case VAR_8:\n            ip6_print(VAR_0, VAR_2, VAR_3.length);\n            break;\n        default:\n            if (!VAR_0->ndo_eflag)\n                ND_PRINT((VAR_0, \"unknown GGSN proto (%u)\", VAR_4->proto));\n        }\n\n        return VAR_3.header_len;\n}",
    "func_graph_path_before": "the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/5.json",
    "func": "u_int\njuniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n        gh = (struct juniper_ggsn_header *)&l2info.cookie;\n\n        ND_TCHECK(*gh);\n        if (ndo->ndo_eflag) {\n            ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                   tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n        }\n\n        return l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}",
    "abstract_func": "u_int\njuniper_ggsn_print(netdissect_options *VAR_0,\n                   const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)\n{\n        struct juniper_l2info_t VAR_3;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *VAR_4;\n\n        VAR_3.pictype = VAR_5;\n        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)\n            return VAR_3.header_len;\n\n        VAR_2+=VAR_3.header_len;\n        VAR_4 = (struct juniper_ggsn_header *)&VAR_3.cookie;\n\n        ND_TCHECK(*VAR_4);\n        if (VAR_0->ndo_eflag) {\n            ND_PRINT((VAR_0, \"proto %s (%u), vlan %u: \",\n                   tok2str(VAR_6,\"Unknown\",VAR_4->proto),\n                   VAR_4->proto,\n                   EXTRACT_16BITS(&VAR_4->vlan_id[0])));\n        }\n\n        switch (VAR_4->proto) {\n        case VAR_7:\n            ip_print(VAR_0, VAR_2, VAR_3.length);\n            break;\n        case VAR_8:\n            ip6_print(VAR_0, VAR_2, VAR_3.length);\n            break;\n        default:\n            if (!VAR_0->ndo_eflag)\n                ND_PRINT((VAR_0, \"unknown GGSN proto (%u)\", VAR_4->proto));\n        }\n\n        return VAR_3.header_len;\n\ntrunc:\n\tND_PRINT((VAR_0, \"[|juniper_services]\"));\n\treturn VAR_3.header_len;\n}",
    "func_graph_path": "the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/5.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,7 @@\n         p+=l2info.header_len;\n         gh = (struct juniper_ggsn_header *)&l2info.cookie;\n \n+        ND_TCHECK(*gh);\n         if (ndo->ndo_eflag) {\n             ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                    tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n@@ -40,4 +41,8 @@\n         }\n \n         return l2info.header_len;\n+\n+trunc:\n+\tND_PRINT((ndo, \"[|juniper_services]\"));\n+\treturn l2info.header_len;\n }",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "        ND_TCHECK(*gh);",
            "",
            "trunc:",
            "\tND_PRINT((ndo, \"[|juniper_services]\"));",
            "\treturn l2info.header_len;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}