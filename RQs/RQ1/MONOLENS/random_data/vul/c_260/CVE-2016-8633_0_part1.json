{
    "cve_id": "CVE-2016-8633",
    "cwe_ids": [
        "CWE-119",
        "CWE-284"
    ],
    "cvss_vector": "AV:L/AC:H/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "firewire: net: guard against rx buffer overflows\n\nThe IP-over-1394 driver firewire-net lacked input validation when\nhandling incoming fragmented datagrams.  A maliciously formed fragment\nwith a respectively large datagram_offset would cause a memcpy past the\ndatagram buffer.\n\nSo, drop any packets carrying a fragment with offset + length larger\nthan datagram_size.\n\nIn addition, ensure that\n  - GASP header, unfragmented encapsulation header, or fragment\n    encapsulation header actually exists before we access it,\n  - the encapsulated datagram or fragment is of nonzero size.\n\nReported-by: Eyal Itkin <eyal.itkin@gmail.com>\nReviewed-by: Eyal Itkin <eyal.itkin@gmail.com>\nFixes: CVE 2016-8633\nCc: stable@vger.kernel.org\nSigned-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>",
    "commit_hash": "667121ace9dbafb368618dbabcf07901c962ddac",
    "git_url": "https://github.com/torvalds/linux/commit/667121ace9dbafb368618dbabcf07901c962ddac",
    "file_path": "drivers/firewire/net.c",
    "func_name": "fwnet_incoming_packet",
    "func_before": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\t/* A datagram fragment has been received, now the fun begins. */\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
    "abstract_func_before": "static int fwnet_incoming_packet(struct fwnet_device *VAR_0, __be32 *VAR_1, int VAR_2,\n\t\t\t\t int VAR_3, int VAR_4,\n\t\t\t\t bool VAR_5)\n{\n\tstruct sk_buff *VAR_6;\n\tstruct net_device *VAR_7 = VAR_0->netdev;\n\tstruct rfc2734_header VAR_8;\n\tunsigned VAR_9;\n\tunsigned long VAR_10;\n\tstruct fwnet_peer *VAR_11;\n\tstruct fwnet_partial_datagram *VAR_12;\n\tint VAR_13;\n\tint VAR_14;\n\tu16 VAR_15;\n\tint VAR_16;\n\tu16 VAR_17;\n\n\tVAR_8.w0 = be32_to_cpu(VAR_1[0]);\n\tVAR_9 = fwnet_get_hdr_lf(&VAR_8);\n\tif (VAR_9 == VAR_18) {\n\t\t/* COMMENT_0 */\n                                                               \n                                                            \n                              \n     \n\t\tVAR_17 = fwnet_get_hdr_ether_type(&VAR_8);\n\t\tVAR_1++;\n\t\tVAR_2 -= VAR_19;\n\n\t\tVAR_6 = dev_alloc_skb(VAR_2 + LL_RESERVED_SPACE(VAR_7));\n\t\tif (unlikely(!VAR_6)) {\n\t\t\tVAR_7->stats.rx_dropped++;\n\n\t\t\treturn -VAR_20;\n\t\t}\n\t\tskb_reserve(VAR_6, LL_RESERVED_SPACE(VAR_7));\n\t\tmemcpy(skb_put(VAR_6, VAR_2), VAR_1, VAR_2);\n\n\t\treturn fwnet_finish_incoming_packet(VAR_7, VAR_6, VAR_3,\n\t\t\t\t\t\t    VAR_5, VAR_17);\n\t}\n\t/* COMMENT_5 */\n\tVAR_8.w1 = ntohl(VAR_1[1]);\n\tVAR_1 += 2;\n\tVAR_2 -= VAR_21;\n\tif (VAR_9 == VAR_22) {\n\t\tVAR_17 = fwnet_get_hdr_ether_type(&VAR_8);\n\t\tVAR_13 = 0;\n\t} else {\n\t\tVAR_17 = 0;\n\t\tVAR_13 = fwnet_get_hdr_fg_off(&VAR_8);\n\t}\n\tVAR_15 = fwnet_get_hdr_dgl(&VAR_8);\n\tVAR_14 = fwnet_get_hdr_dg_size(&VAR_8); /* COMMENT_6 */\n\n\tspin_lock_irqsave(&VAR_0->lock, VAR_10);\n\n\tVAR_11 = fwnet_peer_find_by_node_id(VAR_0, VAR_3, VAR_4);\n\tif (!VAR_11) {\n\t\tVAR_16 = -VAR_23;\n\t\tgoto fail;\n\t}\n\n\tVAR_12 = fwnet_pd_find(VAR_11, VAR_15);\n\tif (VAR_12 == NULL) {\n\t\twhile (VAR_11->pdg_size >= VAR_24) {\n\t\t\t/* COMMENT_7 */\n\t\t\tfwnet_pd_delete(list_first_entry(&VAR_11->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, VAR_25));\n\t\t\tVAR_11->pdg_size--;\n\t\t}\n\t\tVAR_12 = fwnet_pd_new(VAR_7, VAR_11, VAR_15,\n\t\t\t\t  VAR_14, VAR_1, VAR_13, VAR_2);\n\t\tif (VAR_12 == NULL) {\n\t\t\tVAR_16 = -VAR_20;\n\t\t\tgoto fail;\n\t\t}\n\t\tVAR_11->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(VAR_12, VAR_13, VAR_2) ||\n\t\t    VAR_12->datagram_size != VAR_14) {\n\t\t\t/* COMMENT_8 */\n                                                        \n                                               \n      \n\t\t\tfwnet_pd_delete(VAR_12);\n\t\t\tVAR_12 = fwnet_pd_new(VAR_7, VAR_11, VAR_15,\n\t\t\t\t\t  VAR_14, VAR_1, VAR_13, VAR_2);\n\t\t\tif (VAR_12 == NULL) {\n\t\t\t\tVAR_11->pdg_size--;\n\t\t\t\tVAR_16 = -VAR_20;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(VAR_11, VAR_12, VAR_1, VAR_13, VAR_2)) {\n\t\t\t\t/* COMMENT_12 */\n                                        \n                                      \n                    \n       \n\t\t\t\tfwnet_pd_delete(VAR_12);\n\t\t\t\tVAR_11->pdg_size--;\n\t\t\t\tVAR_16 = -VAR_20;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* COMMENT_17 */\n\n\tif (VAR_9 == VAR_22)\n\t\tVAR_12->ether_type = VAR_17;\n\n\tif (fwnet_pd_is_complete(VAR_12)) {\n\t\tVAR_17 = VAR_12->ether_type;\n\t\tVAR_11->pdg_size--;\n\t\tVAR_6 = skb_get(VAR_12->skb);\n\t\tfwnet_pd_delete(VAR_12);\n\n\t\tspin_unlock_irqrestore(&VAR_0->lock, VAR_10);\n\n\t\treturn fwnet_finish_incoming_packet(VAR_7, VAR_6, VAR_3,\n\t\t\t\t\t\t    false, VAR_17);\n\t}\n\t/* COMMENT_18 */\n                                                \n           \n    \n\tVAR_16 = 0;\n fail:\n\tspin_unlock_irqrestore(&VAR_0->lock, VAR_10);\n\n\treturn VAR_16;\n}",
    "func_graph_path_before": "torvalds/linux/667121ace9dbafb368618dbabcf07901c962ddac/net.c/vul/before/1.json",
    "func": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\n\t/* A datagram fragment has been received, now the fun begins. */\n\n\tif (len <= RFC2374_FRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tif (fg_off + len > dg_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
    "abstract_func": "static int fwnet_incoming_packet(struct fwnet_device *VAR_0, __be32 *VAR_1, int VAR_2,\n\t\t\t\t int VAR_3, int VAR_4,\n\t\t\t\t bool VAR_5)\n{\n\tstruct sk_buff *VAR_6;\n\tstruct net_device *VAR_7 = VAR_0->netdev;\n\tstruct rfc2734_header VAR_8;\n\tunsigned VAR_9;\n\tunsigned long VAR_10;\n\tstruct fwnet_peer *VAR_11;\n\tstruct fwnet_partial_datagram *VAR_12;\n\tint VAR_13;\n\tint VAR_14;\n\tu16 VAR_15;\n\tint VAR_16;\n\tu16 VAR_17;\n\n\tif (VAR_2 <= VAR_18)\n\t\treturn 0;\n\n\tVAR_8.w0 = be32_to_cpu(VAR_1[0]);\n\tVAR_9 = fwnet_get_hdr_lf(&VAR_8);\n\tif (VAR_9 == VAR_19) {\n\t\t/* COMMENT_0 */\n                                                               \n                                                            \n                              \n     \n\t\tVAR_17 = fwnet_get_hdr_ether_type(&VAR_8);\n\t\tVAR_1++;\n\t\tVAR_2 -= VAR_18;\n\n\t\tVAR_6 = dev_alloc_skb(VAR_2 + LL_RESERVED_SPACE(VAR_7));\n\t\tif (unlikely(!VAR_6)) {\n\t\t\tVAR_7->stats.rx_dropped++;\n\n\t\t\treturn -VAR_20;\n\t\t}\n\t\tskb_reserve(VAR_6, LL_RESERVED_SPACE(VAR_7));\n\t\tmemcpy(skb_put(VAR_6, VAR_2), VAR_1, VAR_2);\n\n\t\treturn fwnet_finish_incoming_packet(VAR_7, VAR_6, VAR_3,\n\t\t\t\t\t\t    VAR_5, VAR_17);\n\t}\n\n\t/* COMMENT_5 */\n\n\tif (VAR_2 <= VAR_21)\n\t\treturn 0;\n\n\tVAR_8.w1 = ntohl(VAR_1[1]);\n\tVAR_1 += 2;\n\tVAR_2 -= VAR_21;\n\tif (VAR_9 == VAR_22) {\n\t\tVAR_17 = fwnet_get_hdr_ether_type(&VAR_8);\n\t\tVAR_13 = 0;\n\t} else {\n\t\tVAR_17 = 0;\n\t\tVAR_13 = fwnet_get_hdr_fg_off(&VAR_8);\n\t}\n\tVAR_15 = fwnet_get_hdr_dgl(&VAR_8);\n\tVAR_14 = fwnet_get_hdr_dg_size(&VAR_8); /* COMMENT_6 */\n\n\tif (VAR_13 + VAR_2 > VAR_14)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&VAR_0->lock, VAR_10);\n\n\tVAR_11 = fwnet_peer_find_by_node_id(VAR_0, VAR_3, VAR_4);\n\tif (!VAR_11) {\n\t\tVAR_16 = -VAR_23;\n\t\tgoto fail;\n\t}\n\n\tVAR_12 = fwnet_pd_find(VAR_11, VAR_15);\n\tif (VAR_12 == NULL) {\n\t\twhile (VAR_11->pdg_size >= VAR_24) {\n\t\t\t/* COMMENT_7 */\n\t\t\tfwnet_pd_delete(list_first_entry(&VAR_11->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, VAR_25));\n\t\t\tVAR_11->pdg_size--;\n\t\t}\n\t\tVAR_12 = fwnet_pd_new(VAR_7, VAR_11, VAR_15,\n\t\t\t\t  VAR_14, VAR_1, VAR_13, VAR_2);\n\t\tif (VAR_12 == NULL) {\n\t\t\tVAR_16 = -VAR_20;\n\t\t\tgoto fail;\n\t\t}\n\t\tVAR_11->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(VAR_12, VAR_13, VAR_2) ||\n\t\t    VAR_12->datagram_size != VAR_14) {\n\t\t\t/* COMMENT_8 */\n                                                        \n                                               \n      \n\t\t\tfwnet_pd_delete(VAR_12);\n\t\t\tVAR_12 = fwnet_pd_new(VAR_7, VAR_11, VAR_15,\n\t\t\t\t\t  VAR_14, VAR_1, VAR_13, VAR_2);\n\t\t\tif (VAR_12 == NULL) {\n\t\t\t\tVAR_11->pdg_size--;\n\t\t\t\tVAR_16 = -VAR_20;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(VAR_11, VAR_12, VAR_1, VAR_13, VAR_2)) {\n\t\t\t\t/* COMMENT_12 */\n                                        \n                                      \n                    \n       \n\t\t\t\tfwnet_pd_delete(VAR_12);\n\t\t\t\tVAR_11->pdg_size--;\n\t\t\t\tVAR_16 = -VAR_20;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* COMMENT_17 */\n\n\tif (VAR_9 == VAR_22)\n\t\tVAR_12->ether_type = VAR_17;\n\n\tif (fwnet_pd_is_complete(VAR_12)) {\n\t\tVAR_17 = VAR_12->ether_type;\n\t\tVAR_11->pdg_size--;\n\t\tVAR_6 = skb_get(VAR_12->skb);\n\t\tfwnet_pd_delete(VAR_12);\n\n\t\tspin_unlock_irqrestore(&VAR_0->lock, VAR_10);\n\n\t\treturn fwnet_finish_incoming_packet(VAR_7, VAR_6, VAR_3,\n\t\t\t\t\t\t    false, VAR_17);\n\t}\n\t/* COMMENT_18 */\n                                                \n           \n    \n\tVAR_16 = 0;\n fail:\n\tspin_unlock_irqrestore(&VAR_0->lock, VAR_10);\n\n\treturn VAR_16;\n}",
    "func_graph_path": "torvalds/linux/667121ace9dbafb368618dbabcf07901c962ddac/net.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,9 @@\n \tu16 datagram_label;\n \tint retval;\n \tu16 ether_type;\n+\n+\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n+\t\treturn 0;\n \n \thdr.w0 = be32_to_cpu(buf[0]);\n \tlf = fwnet_get_hdr_lf(&hdr);\n@@ -39,7 +42,12 @@\n \t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n \t\t\t\t\t\t    is_broadcast, ether_type);\n \t}\n+\n \t/* A datagram fragment has been received, now the fun begins. */\n+\n+\tif (len <= RFC2374_FRAG_HDR_SIZE)\n+\t\treturn 0;\n+\n \thdr.w1 = ntohl(buf[1]);\n \tbuf += 2;\n \tlen -= RFC2374_FRAG_HDR_SIZE;\n@@ -52,6 +60,9 @@\n \t}\n \tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n \tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n+\n+\tif (fg_off + len > dg_size)\n+\t\treturn 0;\n \n \tspin_lock_irqsave(&dev->lock, flags);\n ",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "",
            "\tif (len <= RFC2374_UNFRAG_HDR_SIZE)",
            "\t\treturn 0;",
            "",
            "",
            "\tif (len <= RFC2374_FRAG_HDR_SIZE)",
            "\t\treturn 0;",
            "",
            "",
            "\tif (fg_off + len > dg_size)",
            "\t\treturn 0;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}