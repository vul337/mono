{
    "cve_id": "CVE-2016-3863",
    "cwe_ids": [
        "CWE-284"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "android",
    "commit_msg": "stagefright: fix possible stack overflow in AVCC reassemble\n\nAdditionally, remove use of variable length array which is\nnon-standard in C++.\n\nBug: 29161888\nChange-Id: Ifdc3e7435f2225214c053b13f3bfe71c7d0ff506\n",
    "commit_hash": "119a012b2a9a186655da4bef3ed4ed8dd9b94c26",
    "git_url": "https://android.googlesource.com/platform/frameworks/av/+/119a012b2a9a186655da4bef3ed4ed8dd9b94c26",
    "file_path": "media/libstagefright/Utils.cpp",
    "func_name": "convertMessageToMetaData",
    "func_before": "void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {\n    AString mime;\n    if (msg->findString(\"mime\", &mime)) {\n        meta->setCString(kKeyMIMEType, mime.c_str());\n    } else {\n        ALOGW(\"did not find mime type\");\n    }\n\n    int64_t durationUs;\n    if (msg->findInt64(\"durationUs\", &durationUs)) {\n        meta->setInt64(kKeyDuration, durationUs);\n    }\n\n    int32_t isSync;\n    if (msg->findInt32(\"is-sync-frame\", &isSync) && isSync != 0) {\n        meta->setInt32(kKeyIsSyncFrame, 1);\n    }\n\n    int32_t avgBitrate = 0;\n    int32_t maxBitrate;\n    if (msg->findInt32(\"bitrate\", &avgBitrate) && avgBitrate > 0) {\n        meta->setInt32(kKeyBitRate, avgBitrate);\n    }\n    if (msg->findInt32(\"max-bitrate\", &maxBitrate) && maxBitrate > 0 && maxBitrate >= avgBitrate) {\n        meta->setInt32(kKeyMaxBitRate, maxBitrate);\n    }\n\n    if (mime.startsWith(\"video/\")) {\n        int32_t width;\n        int32_t height;\n        if (msg->findInt32(\"width\", &width) && msg->findInt32(\"height\", &height)) {\n            meta->setInt32(kKeyWidth, width);\n            meta->setInt32(kKeyHeight, height);\n        } else {\n            ALOGW(\"did not find width and/or height\");\n        }\n\n        int32_t sarWidth, sarHeight;\n        if (msg->findInt32(\"sar-width\", &sarWidth)\n                && msg->findInt32(\"sar-height\", &sarHeight)) {\n            meta->setInt32(kKeySARWidth, sarWidth);\n            meta->setInt32(kKeySARHeight, sarHeight);\n        }\n\n        int32_t colorFormat;\n        if (msg->findInt32(\"color-format\", &colorFormat)) {\n            meta->setInt32(kKeyColorFormat, colorFormat);\n        }\n\n        int32_t cropLeft, cropTop, cropRight, cropBottom;\n        if (msg->findRect(\"crop\",\n                          &cropLeft,\n                          &cropTop,\n                          &cropRight,\n                          &cropBottom)) {\n            meta->setRect(kKeyCropRect, cropLeft, cropTop, cropRight, cropBottom);\n        }\n\n        int32_t rotationDegrees;\n        if (msg->findInt32(\"rotation-degrees\", &rotationDegrees)) {\n            meta->setInt32(kKeyRotation, rotationDegrees);\n        }\n\n        if (msg->contains(\"hdr-static-info\")) {\n            HDRStaticInfo info;\n            if (ColorUtils::getHDRStaticInfoFromFormat(msg, &info)) {\n                meta->setData(kKeyHdrStaticInfo, 'hdrS', &info, sizeof(info));\n            }\n        }\n\n        convertMessageToMetaDataColorAspects(msg, meta);\n    } else if (mime.startsWith(\"audio/\")) {\n        int32_t numChannels;\n        if (msg->findInt32(\"channel-count\", &numChannels)) {\n            meta->setInt32(kKeyChannelCount, numChannels);\n        }\n        int32_t sampleRate;\n        if (msg->findInt32(\"sample-rate\", &sampleRate)) {\n            meta->setInt32(kKeySampleRate, sampleRate);\n        }\n        int32_t channelMask;\n        if (msg->findInt32(\"channel-mask\", &channelMask)) {\n            meta->setInt32(kKeyChannelMask, channelMask);\n        }\n        int32_t delay = 0;\n        if (msg->findInt32(\"encoder-delay\", &delay)) {\n            meta->setInt32(kKeyEncoderDelay, delay);\n        }\n        int32_t padding = 0;\n        if (msg->findInt32(\"encoder-padding\", &padding)) {\n            meta->setInt32(kKeyEncoderPadding, padding);\n        }\n\n        int32_t isADTS;\n        if (msg->findInt32(\"is-adts\", &isADTS)) {\n            meta->setInt32(kKeyIsADTS, isADTS);\n        }\n\n        int32_t pcmEncoding;\n        if (msg->findInt32(\"pcm-encoding\", &pcmEncoding)) {\n            meta->setInt32(kKeyPcmEncoding, pcmEncoding);\n        }\n    }\n\n    int32_t maxInputSize;\n    if (msg->findInt32(\"max-input-size\", &maxInputSize)) {\n        meta->setInt32(kKeyMaxInputSize, maxInputSize);\n    }\n\n    int32_t maxWidth;\n    if (msg->findInt32(\"max-width\", &maxWidth)) {\n        meta->setInt32(kKeyMaxWidth, maxWidth);\n    }\n\n    int32_t maxHeight;\n    if (msg->findInt32(\"max-height\", &maxHeight)) {\n        meta->setInt32(kKeyMaxHeight, maxHeight);\n    }\n\n    int32_t fps;\n    float fpsFloat;\n    if (msg->findInt32(\"frame-rate\", &fps) && fps > 0) {\n        meta->setInt32(kKeyFrameRate, fps);\n    } else if (msg->findFloat(\"frame-rate\", &fpsFloat)\n            && fpsFloat >= 1 && fpsFloat <= INT32_MAX) {\n        // truncate values to distinguish between e.g. 24 vs 23.976 fps\n        meta->setInt32(kKeyFrameRate, (int32_t)fpsFloat);\n    }\n\n    // reassemble the csd data into its original form\n    sp<ABuffer> csd0, csd1, csd2;\n    if (msg->findBuffer(\"csd-0\", &csd0)) {\n        if (mime == MEDIA_MIMETYPE_VIDEO_AVC) {\n            sp<ABuffer> csd1;\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                char avcc[1024]; // that oughta be enough, right?\n                size_t outsize = reassembleAVCC(csd0, csd1, avcc);\n                meta->setData(kKeyAVCC, kKeyAVCC, avcc, outsize);\n            }\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_AAC || mime == MEDIA_MIMETYPE_VIDEO_MPEG4) {\n            int csd0size = csd0->size();\n            char esds[csd0size + 31];\n            // The written ESDS is actually for an audio stream, but it's enough\n            // for transporting the CSD to muxers.\n            reassembleESDS(csd0, esds);\n            meta->setData(kKeyESDS, kKeyESDS, esds, sizeof(esds));\n        } else if (mime == MEDIA_MIMETYPE_VIDEO_HEVC) {\n            uint8_t hvcc[1024]; // that oughta be enough, right?\n            size_t outsize = reassembleHVCC(csd0, hvcc, 1024, 4);\n            meta->setData(kKeyHVCC, kKeyHVCC, hvcc, outsize);\n        } else if (mime == MEDIA_MIMETYPE_VIDEO_VP9) {\n            meta->setData(kKeyVp9CodecPrivate, 0, csd0->data(), csd0->size());\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_OPUS) {\n            meta->setData(kKeyOpusHeader, 0, csd0->data(), csd0->size());\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                meta->setData(kKeyOpusCodecDelay, 0, csd1->data(), csd1->size());\n            }\n            if (msg->findBuffer(\"csd-2\", &csd2)) {\n                meta->setData(kKeyOpusSeekPreRoll, 0, csd2->data(), csd2->size());\n            }\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_VORBIS) {\n            meta->setData(kKeyVorbisInfo, 0, csd0->data(), csd0->size());\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                meta->setData(kKeyVorbisBooks, 0, csd1->data(), csd1->size());\n            }\n        }\n    }\n\n    int32_t timeScale;\n    if (msg->findInt32(\"time-scale\", &timeScale)) {\n        meta->setInt32(kKeyTimeScale, timeScale);\n    }\n\n    // XXX TODO add whatever other keys there are\n\n#if 0\n    ALOGI(\"converted %s to:\", msg->debugString(0).c_str());\n    meta->dumpToLog();\n#endif\n}",
    "abstract_func_before": "void convertMessageToMetaData(const sp<AMessage> &VAR_0, sp<MetaData> &VAR_1) {\n    AString VAR_2;\n    if (VAR_0->findString(\"mime\", &VAR_2)) {\n        VAR_1->setCString(VAR_3, VAR_2.c_str());\n    } else {\n        ALOGW(\"did not find mime type\");\n    }\n\n    int64_t VAR_4;\n    if (VAR_0->findInt64(\"durationUs\", &VAR_4)) {\n        VAR_1->setInt64(VAR_5, VAR_4);\n    }\n\n    int32_t VAR_6;\n    if (VAR_0->findInt32(\"is-sync-frame\", &VAR_6) && VAR_6 != 0) {\n        VAR_1->setInt32(VAR_7, 1);\n    }\n\n    int32_t VAR_8 = 0;\n    int32_t VAR_9;\n    if (VAR_0->findInt32(\"bitrate\", &VAR_8) && VAR_8 > 0) {\n        VAR_1->setInt32(VAR_10, VAR_8);\n    }\n    if (VAR_0->findInt32(\"max-bitrate\", &VAR_9) && VAR_9 > 0 && VAR_9 >= VAR_8) {\n        VAR_1->setInt32(VAR_11, VAR_9);\n    }\n\n    if (VAR_2.startsWith(\"video/\")) {\n        int32_t VAR_12;\n        int32_t VAR_13;\n        if (VAR_0->findInt32(\"width\", &VAR_12) && VAR_0->findInt32(\"height\", &VAR_13)) {\n            VAR_1->setInt32(VAR_14, VAR_12);\n            VAR_1->setInt32(VAR_15, VAR_13);\n        } else {\n            ALOGW(\"did not find width and/or height\");\n        }\n\n        int32_t VAR_16, VAR_17;\n        if (VAR_0->findInt32(\"sar-width\", &VAR_16)\n                && VAR_0->findInt32(\"sar-height\", &VAR_17)) {\n            VAR_1->setInt32(VAR_18, VAR_16);\n            VAR_1->setInt32(VAR_19, VAR_17);\n        }\n\n        int32_t VAR_20;\n        if (VAR_0->findInt32(\"color-format\", &VAR_20)) {\n            VAR_1->setInt32(VAR_21, VAR_20);\n        }\n\n        int32_t VAR_22, VAR_23, VAR_24, VAR_25;\n        if (VAR_0->findRect(\"crop\",\n                          &VAR_22,\n                          &VAR_23,\n                          &VAR_24,\n                          &VAR_25)) {\n            VAR_1->setRect(VAR_26, VAR_22, VAR_23, VAR_24, VAR_25);\n        }\n\n        int32_t VAR_27;\n        if (VAR_0->findInt32(\"rotation-degrees\", &VAR_27)) {\n            VAR_1->setInt32(VAR_28, VAR_27);\n        }\n\n        if (VAR_0->contains(\"hdr-static-info\")) {\n            HDRStaticInfo VAR_29;\n            if (ColorUtils::getHDRStaticInfoFromFormat(VAR_0, &VAR_29)) {\n                VAR_1->setData(VAR_30, 'hVAR_31', &VAR_29, sizeof(VAR_29));\n            }\n        }\n\n        convertMessageToMetaDataColorAspects(VAR_0, VAR_1);\n    } else if (VAR_2.startsWith(\"audio/\")) {\n        int32_t VAR_32;\n        if (VAR_0->findInt32(\"channel-count\", &VAR_32)) {\n            VAR_1->setInt32(VAR_33, VAR_32);\n        }\n        int32_t VAR_34;\n        if (VAR_0->findInt32(\"sample-rate\", &VAR_34)) {\n            VAR_1->setInt32(VAR_35, VAR_34);\n        }\n        int32_t VAR_36;\n        if (VAR_0->findInt32(\"channel-mask\", &VAR_36)) {\n            VAR_1->setInt32(VAR_37, VAR_36);\n        }\n        int32_t VAR_38 = 0;\n        if (VAR_0->findInt32(\"encoder-delay\", &VAR_38)) {\n            VAR_1->setInt32(VAR_39, VAR_38);\n        }\n        int32_t VAR_40 = 0;\n        if (VAR_0->findInt32(\"encoder-padding\", &VAR_40)) {\n            VAR_1->setInt32(VAR_41, VAR_40);\n        }\n\n        int32_t VAR_42;\n        if (VAR_0->findInt32(\"is-adts\", &VAR_42)) {\n            VAR_1->setInt32(VAR_43, VAR_42);\n        }\n\n        int32_t VAR_44;\n        if (VAR_0->findInt32(\"pcm-encoding\", &VAR_44)) {\n            VAR_1->setInt32(VAR_45, VAR_44);\n        }\n    }\n\n    int32_t VAR_46;\n    if (VAR_0->findInt32(\"max-input-size\", &VAR_46)) {\n        VAR_1->setInt32(VAR_47, VAR_46);\n    }\n\n    int32_t VAR_48;\n    if (VAR_0->findInt32(\"max-width\", &VAR_48)) {\n        VAR_1->setInt32(VAR_49, VAR_48);\n    }\n\n    int32_t VAR_50;\n    if (VAR_0->findInt32(\"max-height\", &VAR_50)) {\n        VAR_1->setInt32(VAR_51, VAR_50);\n    }\n\n    int32_t VAR_52;\n    float VAR_53;\n    if (VAR_0->findInt32(\"frame-rate\", &VAR_52) && VAR_52 > 0) {\n        VAR_1->setInt32(VAR_54, VAR_52);\n    } else if (VAR_0->findFloat(\"frame-rate\", &VAR_53)\n            && VAR_53 >= 1 && VAR_53 <= VAR_55) {\n        /* COMMENT_0 */\n        VAR_1->setInt32(VAR_54, (int32_t)VAR_53);\n    }\n\n    /* COMMENT_1 */\n    sp<ABuffer> VAR_56, VAR_57, VAR_58;\n    if (VAR_0->findBuffer(\"csd-0\", &VAR_56)) {\n        if (VAR_2 == VAR_59) {\n            sp<ABuffer> VAR_57;\n            if (VAR_0->findBuffer(\"csd-1\", &VAR_57)) {\n                char VAR_60[1024]; /* COMMENT_2 */\n                size_t VAR_61 = reassembleAVCC(VAR_56, VAR_57, VAR_60);\n                VAR_1->setData(VAR_62, VAR_62, VAR_60, VAR_61);\n            }\n        } else if (VAR_2 == VAR_63 || VAR_2 == VAR_64) {\n            int VAR_65 = VAR_56->size();\n            char VAR_66[VAR_65 + 31];\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            reassembleESDS(VAR_56, VAR_66);\n            VAR_1->setData(VAR_67, VAR_67, VAR_66, sizeof(VAR_66));\n        } else if (VAR_2 == VAR_68) {\n            uint8_t VAR_69[1024]; /* COMMENT_2 */\n            size_t VAR_61 = reassembleHVCC(VAR_56, VAR_69, 1024, 4);\n            VAR_1->setData(VAR_70, VAR_70, VAR_69, VAR_61);\n        } else if (VAR_2 == VAR_71) {\n            VAR_1->setData(VAR_72, 0, VAR_56->data(), VAR_56->size());\n        } else if (VAR_2 == VAR_73) {\n            VAR_1->setData(VAR_74, 0, VAR_56->data(), VAR_56->size());\n            if (VAR_0->findBuffer(\"csd-1\", &VAR_57)) {\n                VAR_1->setData(VAR_75, 0, VAR_57->data(), VAR_57->size());\n            }\n            if (VAR_0->findBuffer(\"csd-2\", &VAR_58)) {\n                VAR_1->setData(VAR_76, 0, VAR_58->data(), VAR_58->size());\n            }\n        } else if (VAR_2 == VAR_77) {\n            VAR_1->setData(VAR_78, 0, VAR_56->data(), VAR_56->size());\n            if (VAR_0->findBuffer(\"csd-1\", &VAR_57)) {\n                VAR_1->setData(VAR_79, 0, VAR_57->data(), VAR_57->size());\n            }\n        }\n    }\n\n    int32_t VAR_80;\n    if (VAR_0->findInt32(\"time-scale\", &VAR_80)) {\n        VAR_1->setInt32(VAR_81, VAR_80);\n    }\n\n    /* COMMENT_5 */\n\n#if 0\n    ALOGI(\"converted %s to:\", VAR_0->debugString(0).c_str());\n    VAR_1->dumpToLog();\n#endif\n}",
    "func_graph_path_before": "android/119a012b2a9a186655da4bef3ed4ed8dd9b94c26/Utils.cpp/vul/before/0.json",
    "func": "void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {\n    AString mime;\n    if (msg->findString(\"mime\", &mime)) {\n        meta->setCString(kKeyMIMEType, mime.c_str());\n    } else {\n        ALOGW(\"did not find mime type\");\n    }\n\n    int64_t durationUs;\n    if (msg->findInt64(\"durationUs\", &durationUs)) {\n        meta->setInt64(kKeyDuration, durationUs);\n    }\n\n    int32_t isSync;\n    if (msg->findInt32(\"is-sync-frame\", &isSync) && isSync != 0) {\n        meta->setInt32(kKeyIsSyncFrame, 1);\n    }\n\n    int32_t avgBitrate = 0;\n    int32_t maxBitrate;\n    if (msg->findInt32(\"bitrate\", &avgBitrate) && avgBitrate > 0) {\n        meta->setInt32(kKeyBitRate, avgBitrate);\n    }\n    if (msg->findInt32(\"max-bitrate\", &maxBitrate) && maxBitrate > 0 && maxBitrate >= avgBitrate) {\n        meta->setInt32(kKeyMaxBitRate, maxBitrate);\n    }\n\n    if (mime.startsWith(\"video/\")) {\n        int32_t width;\n        int32_t height;\n        if (msg->findInt32(\"width\", &width) && msg->findInt32(\"height\", &height)) {\n            meta->setInt32(kKeyWidth, width);\n            meta->setInt32(kKeyHeight, height);\n        } else {\n            ALOGW(\"did not find width and/or height\");\n        }\n\n        int32_t sarWidth, sarHeight;\n        if (msg->findInt32(\"sar-width\", &sarWidth)\n                && msg->findInt32(\"sar-height\", &sarHeight)) {\n            meta->setInt32(kKeySARWidth, sarWidth);\n            meta->setInt32(kKeySARHeight, sarHeight);\n        }\n\n        int32_t colorFormat;\n        if (msg->findInt32(\"color-format\", &colorFormat)) {\n            meta->setInt32(kKeyColorFormat, colorFormat);\n        }\n\n        int32_t cropLeft, cropTop, cropRight, cropBottom;\n        if (msg->findRect(\"crop\",\n                          &cropLeft,\n                          &cropTop,\n                          &cropRight,\n                          &cropBottom)) {\n            meta->setRect(kKeyCropRect, cropLeft, cropTop, cropRight, cropBottom);\n        }\n\n        int32_t rotationDegrees;\n        if (msg->findInt32(\"rotation-degrees\", &rotationDegrees)) {\n            meta->setInt32(kKeyRotation, rotationDegrees);\n        }\n\n        if (msg->contains(\"hdr-static-info\")) {\n            HDRStaticInfo info;\n            if (ColorUtils::getHDRStaticInfoFromFormat(msg, &info)) {\n                meta->setData(kKeyHdrStaticInfo, 'hdrS', &info, sizeof(info));\n            }\n        }\n\n        convertMessageToMetaDataColorAspects(msg, meta);\n    } else if (mime.startsWith(\"audio/\")) {\n        int32_t numChannels;\n        if (msg->findInt32(\"channel-count\", &numChannels)) {\n            meta->setInt32(kKeyChannelCount, numChannels);\n        }\n        int32_t sampleRate;\n        if (msg->findInt32(\"sample-rate\", &sampleRate)) {\n            meta->setInt32(kKeySampleRate, sampleRate);\n        }\n        int32_t channelMask;\n        if (msg->findInt32(\"channel-mask\", &channelMask)) {\n            meta->setInt32(kKeyChannelMask, channelMask);\n        }\n        int32_t delay = 0;\n        if (msg->findInt32(\"encoder-delay\", &delay)) {\n            meta->setInt32(kKeyEncoderDelay, delay);\n        }\n        int32_t padding = 0;\n        if (msg->findInt32(\"encoder-padding\", &padding)) {\n            meta->setInt32(kKeyEncoderPadding, padding);\n        }\n\n        int32_t isADTS;\n        if (msg->findInt32(\"is-adts\", &isADTS)) {\n            meta->setInt32(kKeyIsADTS, isADTS);\n        }\n\n        int32_t pcmEncoding;\n        if (msg->findInt32(\"pcm-encoding\", &pcmEncoding)) {\n            meta->setInt32(kKeyPcmEncoding, pcmEncoding);\n        }\n    }\n\n    int32_t maxInputSize;\n    if (msg->findInt32(\"max-input-size\", &maxInputSize)) {\n        meta->setInt32(kKeyMaxInputSize, maxInputSize);\n    }\n\n    int32_t maxWidth;\n    if (msg->findInt32(\"max-width\", &maxWidth)) {\n        meta->setInt32(kKeyMaxWidth, maxWidth);\n    }\n\n    int32_t maxHeight;\n    if (msg->findInt32(\"max-height\", &maxHeight)) {\n        meta->setInt32(kKeyMaxHeight, maxHeight);\n    }\n\n    int32_t fps;\n    float fpsFloat;\n    if (msg->findInt32(\"frame-rate\", &fps) && fps > 0) {\n        meta->setInt32(kKeyFrameRate, fps);\n    } else if (msg->findFloat(\"frame-rate\", &fpsFloat)\n            && fpsFloat >= 1 && fpsFloat <= INT32_MAX) {\n        // truncate values to distinguish between e.g. 24 vs 23.976 fps\n        meta->setInt32(kKeyFrameRate, (int32_t)fpsFloat);\n    }\n\n    // reassemble the csd data into its original form\n    sp<ABuffer> csd0, csd1, csd2;\n    if (msg->findBuffer(\"csd-0\", &csd0)) {\n        int csd0size = csd0->size();\n        if (mime == MEDIA_MIMETYPE_VIDEO_AVC) {\n            sp<ABuffer> csd1;\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                std::vector<char> avcc(csd0size + csd1->size() + 1024);\n                size_t outsize = reassembleAVCC(csd0, csd1, avcc.data());\n                meta->setData(kKeyAVCC, kKeyAVCC, avcc.data(), outsize);\n            }\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_AAC || mime == MEDIA_MIMETYPE_VIDEO_MPEG4) {\n            std::vector<char> esds(csd0size + 31);\n            // The written ESDS is actually for an audio stream, but it's enough\n            // for transporting the CSD to muxers.\n            reassembleESDS(csd0, esds.data());\n            meta->setData(kKeyESDS, kKeyESDS, esds.data(), esds.size());\n        } else if (mime == MEDIA_MIMETYPE_VIDEO_HEVC) {\n            std::vector<uint8_t> hvcc(csd0size + 1024);\n            size_t outsize = reassembleHVCC(csd0, hvcc.data(), hvcc.size(), 4);\n            meta->setData(kKeyHVCC, kKeyHVCC, hvcc.data(), outsize);\n        } else if (mime == MEDIA_MIMETYPE_VIDEO_VP9) {\n            meta->setData(kKeyVp9CodecPrivate, 0, csd0->data(), csd0->size());\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_OPUS) {\n            meta->setData(kKeyOpusHeader, 0, csd0->data(), csd0->size());\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                meta->setData(kKeyOpusCodecDelay, 0, csd1->data(), csd1->size());\n            }\n            if (msg->findBuffer(\"csd-2\", &csd2)) {\n                meta->setData(kKeyOpusSeekPreRoll, 0, csd2->data(), csd2->size());\n            }\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_VORBIS) {\n            meta->setData(kKeyVorbisInfo, 0, csd0->data(), csd0->size());\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                meta->setData(kKeyVorbisBooks, 0, csd1->data(), csd1->size());\n            }\n        }\n    }\n\n    int32_t timeScale;\n    if (msg->findInt32(\"time-scale\", &timeScale)) {\n        meta->setInt32(kKeyTimeScale, timeScale);\n    }\n\n    // XXX TODO add whatever other keys there are\n\n#if 0\n    ALOGI(\"converted %s to:\", msg->debugString(0).c_str());\n    meta->dumpToLog();\n#endif\n}",
    "abstract_func": "void convertMessageToMetaData(const sp<AMessage> &VAR_0, sp<MetaData> &VAR_1) {\n    AString VAR_2;\n    if (VAR_0->findString(\"mime\", &VAR_2)) {\n        VAR_1->setCString(VAR_3, VAR_2.c_str());\n    } else {\n        ALOGW(\"did not find mime type\");\n    }\n\n    int64_t VAR_4;\n    if (VAR_0->findInt64(\"durationUs\", &VAR_4)) {\n        VAR_1->setInt64(VAR_5, VAR_4);\n    }\n\n    int32_t VAR_6;\n    if (VAR_0->findInt32(\"is-sync-frame\", &VAR_6) && VAR_6 != 0) {\n        VAR_1->setInt32(VAR_7, 1);\n    }\n\n    int32_t VAR_8 = 0;\n    int32_t VAR_9;\n    if (VAR_0->findInt32(\"bitrate\", &VAR_8) && VAR_8 > 0) {\n        VAR_1->setInt32(VAR_10, VAR_8);\n    }\n    if (VAR_0->findInt32(\"max-bitrate\", &VAR_9) && VAR_9 > 0 && VAR_9 >= VAR_8) {\n        VAR_1->setInt32(VAR_11, VAR_9);\n    }\n\n    if (VAR_2.startsWith(\"video/\")) {\n        int32_t VAR_12;\n        int32_t VAR_13;\n        if (VAR_0->findInt32(\"width\", &VAR_12) && VAR_0->findInt32(\"height\", &VAR_13)) {\n            VAR_1->setInt32(VAR_14, VAR_12);\n            VAR_1->setInt32(VAR_15, VAR_13);\n        } else {\n            ALOGW(\"did not find width and/or height\");\n        }\n\n        int32_t VAR_16, VAR_17;\n        if (VAR_0->findInt32(\"sar-width\", &VAR_16)\n                && VAR_0->findInt32(\"sar-height\", &VAR_17)) {\n            VAR_1->setInt32(VAR_18, VAR_16);\n            VAR_1->setInt32(VAR_19, VAR_17);\n        }\n\n        int32_t VAR_20;\n        if (VAR_0->findInt32(\"color-format\", &VAR_20)) {\n            VAR_1->setInt32(VAR_21, VAR_20);\n        }\n\n        int32_t VAR_22, VAR_23, VAR_24, VAR_25;\n        if (VAR_0->findRect(\"crop\",\n                          &VAR_22,\n                          &VAR_23,\n                          &VAR_24,\n                          &VAR_25)) {\n            VAR_1->setRect(VAR_26, VAR_22, VAR_23, VAR_24, VAR_25);\n        }\n\n        int32_t VAR_27;\n        if (VAR_0->findInt32(\"rotation-degrees\", &VAR_27)) {\n            VAR_1->setInt32(VAR_28, VAR_27);\n        }\n\n        if (VAR_0->contains(\"hdr-static-info\")) {\n            HDRStaticInfo VAR_29;\n            if (ColorUtils::getHDRStaticInfoFromFormat(VAR_0, &VAR_29)) {\n                VAR_1->setData(VAR_30, 'hVAR_31', &VAR_29, sizeof(VAR_29));\n            }\n        }\n\n        convertMessageToMetaDataColorAspects(VAR_0, VAR_1);\n    } else if (VAR_2.startsWith(\"audio/\")) {\n        int32_t VAR_32;\n        if (VAR_0->findInt32(\"channel-count\", &VAR_32)) {\n            VAR_1->setInt32(VAR_33, VAR_32);\n        }\n        int32_t VAR_34;\n        if (VAR_0->findInt32(\"sample-rate\", &VAR_34)) {\n            VAR_1->setInt32(VAR_35, VAR_34);\n        }\n        int32_t VAR_36;\n        if (VAR_0->findInt32(\"channel-mask\", &VAR_36)) {\n            VAR_1->setInt32(VAR_37, VAR_36);\n        }\n        int32_t VAR_38 = 0;\n        if (VAR_0->findInt32(\"encoder-delay\", &VAR_38)) {\n            VAR_1->setInt32(VAR_39, VAR_38);\n        }\n        int32_t VAR_40 = 0;\n        if (VAR_0->findInt32(\"encoder-padding\", &VAR_40)) {\n            VAR_1->setInt32(VAR_41, VAR_40);\n        }\n\n        int32_t VAR_42;\n        if (VAR_0->findInt32(\"is-adts\", &VAR_42)) {\n            VAR_1->setInt32(VAR_43, VAR_42);\n        }\n\n        int32_t VAR_44;\n        if (VAR_0->findInt32(\"pcm-encoding\", &VAR_44)) {\n            VAR_1->setInt32(VAR_45, VAR_44);\n        }\n    }\n\n    int32_t VAR_46;\n    if (VAR_0->findInt32(\"max-input-size\", &VAR_46)) {\n        VAR_1->setInt32(VAR_47, VAR_46);\n    }\n\n    int32_t VAR_48;\n    if (VAR_0->findInt32(\"max-width\", &VAR_48)) {\n        VAR_1->setInt32(VAR_49, VAR_48);\n    }\n\n    int32_t VAR_50;\n    if (VAR_0->findInt32(\"max-height\", &VAR_50)) {\n        VAR_1->setInt32(VAR_51, VAR_50);\n    }\n\n    int32_t VAR_52;\n    float VAR_53;\n    if (VAR_0->findInt32(\"frame-rate\", &VAR_52) && VAR_52 > 0) {\n        VAR_1->setInt32(VAR_54, VAR_52);\n    } else if (VAR_0->findFloat(\"frame-rate\", &VAR_53)\n            && VAR_53 >= 1 && VAR_53 <= VAR_55) {\n        /* COMMENT_0 */\n        VAR_1->setInt32(VAR_54, (int32_t)VAR_53);\n    }\n\n    /* COMMENT_1 */\n    sp<ABuffer> VAR_56, VAR_57, VAR_58;\n    if (VAR_0->findBuffer(\"csd-0\", &VAR_56)) {\n        int VAR_59 = VAR_56->size();\n        if (VAR_2 == VAR_60) {\n            sp<ABuffer> VAR_57;\n            if (VAR_0->findBuffer(\"csd-1\", &VAR_57)) {\n                std::vector<char> VAR_61(VAR_59 + VAR_57->size() + 1024);\n                size_t VAR_62 = reassembleAVCC(VAR_56, VAR_57, VAR_61.data());\n                VAR_1->setData(VAR_63, VAR_63, VAR_61.data(), VAR_62);\n            }\n        } else if (VAR_2 == VAR_64 || VAR_2 == VAR_65) {\n            std::vector<char> VAR_66(VAR_59 + 31);\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            reassembleESDS(VAR_56, VAR_66.data());\n            VAR_1->setData(VAR_67, VAR_67, VAR_66.data(), VAR_66.size());\n        } else if (VAR_2 == VAR_68) {\n            std::vector<uint8_t> VAR_69(VAR_59 + 1024);\n            size_t VAR_62 = reassembleHVCC(VAR_56, VAR_69.data(), VAR_69.size(), 4);\n            VAR_1->setData(VAR_70, VAR_70, VAR_69.data(), VAR_62);\n        } else if (VAR_2 == VAR_71) {\n            VAR_1->setData(VAR_72, 0, VAR_56->data(), VAR_56->size());\n        } else if (VAR_2 == VAR_73) {\n            VAR_1->setData(VAR_74, 0, VAR_56->data(), VAR_56->size());\n            if (VAR_0->findBuffer(\"csd-1\", &VAR_57)) {\n                VAR_1->setData(VAR_75, 0, VAR_57->data(), VAR_57->size());\n            }\n            if (VAR_0->findBuffer(\"csd-2\", &VAR_58)) {\n                VAR_1->setData(VAR_76, 0, VAR_58->data(), VAR_58->size());\n            }\n        } else if (VAR_2 == VAR_77) {\n            VAR_1->setData(VAR_78, 0, VAR_56->data(), VAR_56->size());\n            if (VAR_0->findBuffer(\"csd-1\", &VAR_57)) {\n                VAR_1->setData(VAR_79, 0, VAR_57->data(), VAR_57->size());\n            }\n        }\n    }\n\n    int32_t VAR_80;\n    if (VAR_0->findInt32(\"time-scale\", &VAR_80)) {\n        VAR_1->setInt32(VAR_81, VAR_80);\n    }\n\n    /* COMMENT_4 */\n\n#if 0\n    ALOGI(\"converted %s to:\", VAR_0->debugString(0).c_str());\n    VAR_1->dumpToLog();\n#endif\n}",
    "func_graph_path": "android/119a012b2a9a186655da4bef3ed4ed8dd9b94c26/Utils.cpp/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -130,24 +130,24 @@\n     // reassemble the csd data into its original form\n     sp<ABuffer> csd0, csd1, csd2;\n     if (msg->findBuffer(\"csd-0\", &csd0)) {\n+        int csd0size = csd0->size();\n         if (mime == MEDIA_MIMETYPE_VIDEO_AVC) {\n             sp<ABuffer> csd1;\n             if (msg->findBuffer(\"csd-1\", &csd1)) {\n-                char avcc[1024]; // that oughta be enough, right?\n-                size_t outsize = reassembleAVCC(csd0, csd1, avcc);\n-                meta->setData(kKeyAVCC, kKeyAVCC, avcc, outsize);\n+                std::vector<char> avcc(csd0size + csd1->size() + 1024);\n+                size_t outsize = reassembleAVCC(csd0, csd1, avcc.data());\n+                meta->setData(kKeyAVCC, kKeyAVCC, avcc.data(), outsize);\n             }\n         } else if (mime == MEDIA_MIMETYPE_AUDIO_AAC || mime == MEDIA_MIMETYPE_VIDEO_MPEG4) {\n-            int csd0size = csd0->size();\n-            char esds[csd0size + 31];\n+            std::vector<char> esds(csd0size + 31);\n             // The written ESDS is actually for an audio stream, but it's enough\n             // for transporting the CSD to muxers.\n-            reassembleESDS(csd0, esds);\n-            meta->setData(kKeyESDS, kKeyESDS, esds, sizeof(esds));\n+            reassembleESDS(csd0, esds.data());\n+            meta->setData(kKeyESDS, kKeyESDS, esds.data(), esds.size());\n         } else if (mime == MEDIA_MIMETYPE_VIDEO_HEVC) {\n-            uint8_t hvcc[1024]; // that oughta be enough, right?\n-            size_t outsize = reassembleHVCC(csd0, hvcc, 1024, 4);\n-            meta->setData(kKeyHVCC, kKeyHVCC, hvcc, outsize);\n+            std::vector<uint8_t> hvcc(csd0size + 1024);\n+            size_t outsize = reassembleHVCC(csd0, hvcc.data(), hvcc.size(), 4);\n+            meta->setData(kKeyHVCC, kKeyHVCC, hvcc.data(), outsize);\n         } else if (mime == MEDIA_MIMETYPE_VIDEO_VP9) {\n             meta->setData(kKeyVp9CodecPrivate, 0, csd0->data(), csd0->size());\n         } else if (mime == MEDIA_MIMETYPE_AUDIO_OPUS) {",
    "diff_line_info": {
        "deleted_lines": [
            "                char avcc[1024]; // that oughta be enough, right?",
            "                size_t outsize = reassembleAVCC(csd0, csd1, avcc);",
            "                meta->setData(kKeyAVCC, kKeyAVCC, avcc, outsize);",
            "            int csd0size = csd0->size();",
            "            char esds[csd0size + 31];",
            "            reassembleESDS(csd0, esds);",
            "            meta->setData(kKeyESDS, kKeyESDS, esds, sizeof(esds));",
            "            uint8_t hvcc[1024]; // that oughta be enough, right?",
            "            size_t outsize = reassembleHVCC(csd0, hvcc, 1024, 4);",
            "            meta->setData(kKeyHVCC, kKeyHVCC, hvcc, outsize);"
        ],
        "added_lines": [
            "        int csd0size = csd0->size();",
            "                std::vector<char> avcc(csd0size + csd1->size() + 1024);",
            "                size_t outsize = reassembleAVCC(csd0, csd1, avcc.data());",
            "                meta->setData(kKeyAVCC, kKeyAVCC, avcc.data(), outsize);",
            "            std::vector<char> esds(csd0size + 31);",
            "            reassembleESDS(csd0, esds.data());",
            "            meta->setData(kKeyESDS, kKeyESDS, esds.data(), esds.size());",
            "            std::vector<uint8_t> hvcc(csd0size + 1024);",
            "            size_t outsize = reassembleHVCC(csd0, hvcc.data(), hvcc.size(), 4);",
            "            meta->setData(kKeyHVCC, kKeyHVCC, hvcc.data(), outsize);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}