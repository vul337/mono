{
    "cve_id": "CVE-2020-12826",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "signal: Extend exec_id to 64bits\n\ncommit d1e7fd6462ca9fc76650fbe6ca800e35b24267da upstream.\n\nReplace the 32bit exec_id with a 64bit exec_id to make it impossible\nto wrap the exec_id counter.  With care an attacker can cause exec_id\nwrap and send arbitrary signals to a newly exec'd parent.  This\nbypasses the signal sending checks if the parent changes their\ncredentials during exec.\n\nThe severity of this problem can been seen that in my limited testing\nof a 32bit exec_id it can take as little as 19s to exec 65536 times.\nWhich means that it can take as little as 14 days to wrap a 32bit\nexec_id.  Adam Zabrocki has succeeded wrapping the self_exe_id in 7\ndays.  Even my slower timing is in the uptime of a typical server.\nWhich means self_exec_id is simply a speed bump today, and if exec\ngets noticably faster self_exec_id won't even be a speed bump.\n\nExtending self_exec_id to 64bits introduces a problem on 32bit\narchitectures where reading self_exec_id is no longer atomic and can\ntake two read instructions.  Which means that is is possible to hit\na window where the read value of exec_id does not match the written\nvalue.  So with very lucky timing after this change this still\nremains expoiltable.\n\nI have updated the update of exec_id on exec to use WRITE_ONCE\nand the read of exec_id in do_notify_parent to use READ_ONCE\nto make it clear that there is no locking between these two\nlocations.\n\nLink: https://lore.kernel.org/kernel-hardening/20200324215049.GA3710@pi3.com.pl\nFixes: 2.3.23pre2\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "commit_hash": "7395ea4e65c2a00d23185a3f63ad315756ba9cef",
    "git_url": "https://github.com/torvalds/linux/commit/7395ea4e65c2a00d23185a3f63ad315756ba9cef",
    "file_path": "fs/exec.c",
    "func_name": "setup_new_exec",
    "func_before": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}",
    "abstract_func_before": "void setup_new_exec(struct linux_binprm * VAR_0)\n{\n\t/* COMMENT_0 */\n                                                               \n                                                                  \n                    \n    \n\tVAR_0->secureexec |= VAR_0->cap_elevated;\n\n\tif (VAR_0->secureexec) {\n\t\t/* COMMENT_5 */\n\t\tVAR_1->pdeath_signal = 0;\n\n\t\t/* COMMENT_6 */\n                                                             \n                                                           \n                                                          \n                                                            \n                                               \n     \n\t\tif (VAR_0->rlim_stack.rlim_cur > VAR_2)\n\t\t\tVAR_0->rlim_stack.rlim_cur = VAR_2;\n\t}\n\n\tarch_pick_mmap_layout(VAR_1->mm, &VAR_0->rlim_stack);\n\n\tVAR_1->sas_ss_sp = VAR_1->sas_ss_size = 0;\n\n\t/* COMMENT_13 */\n                                                                   \n                                                                 \n                             \n    \n\tif (VAR_0->interp_flags & VAR_3 ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(VAR_1->mm, VAR_4);\n\telse\n\t\tset_dumpable(VAR_1->mm, VAR_5);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(VAR_1, kbasename(VAR_0->filename), true);\n\n\t/* COMMENT_18 */\n                                                                  \n                                   \n    \n\tVAR_1->mm->task_size = VAR_6;\n\n\t/* COMMENT_22 */\n            \n\tVAR_1->self_exec_id++;\n\tflush_signal_handlers(VAR_1, 0);\n}",
    "func_graph_path_before": "torvalds/linux/7395ea4e65c2a00d23185a3f63ad315756ba9cef/exec.c/vul/before/0.json",
    "func": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tWRITE_ONCE(current->self_exec_id, current->self_exec_id + 1);\n\tflush_signal_handlers(current, 0);\n}",
    "abstract_func": "void setup_new_exec(struct linux_binprm * VAR_0)\n{\n\t/* COMMENT_0 */\n                                                               \n                                                                  \n                    \n    \n\tVAR_0->secureexec |= VAR_0->cap_elevated;\n\n\tif (VAR_0->secureexec) {\n\t\t/* COMMENT_5 */\n\t\tVAR_1->pdeath_signal = 0;\n\n\t\t/* COMMENT_6 */\n                                                             \n                                                           \n                                                          \n                                                            \n                                               \n     \n\t\tif (VAR_0->rlim_stack.rlim_cur > VAR_2)\n\t\t\tVAR_0->rlim_stack.rlim_cur = VAR_2;\n\t}\n\n\tarch_pick_mmap_layout(VAR_1->mm, &VAR_0->rlim_stack);\n\n\tVAR_1->sas_ss_sp = VAR_1->sas_ss_size = 0;\n\n\t/* COMMENT_13 */\n                                                                   \n                                                                 \n                             \n    \n\tif (VAR_0->interp_flags & VAR_3 ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(VAR_1->mm, VAR_4);\n\telse\n\t\tset_dumpable(VAR_1->mm, VAR_5);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(VAR_1, kbasename(VAR_0->filename), true);\n\n\t/* COMMENT_18 */\n                                                                  \n                                   \n    \n\tVAR_1->mm->task_size = VAR_6;\n\n\t/* COMMENT_22 */\n            \n\tWRITE_ONCE(VAR_1->self_exec_id, VAR_1->self_exec_id + 1);\n\tflush_signal_handlers(VAR_1, 0);\n}",
    "func_graph_path": "torvalds/linux/7395ea4e65c2a00d23185a3f63ad315756ba9cef/exec.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -50,6 +50,6 @@\n \n \t/* An exec changes our domain. We are no longer part of the thread\n \t   group */\n-\tcurrent->self_exec_id++;\n+\tWRITE_ONCE(current->self_exec_id, current->self_exec_id + 1);\n \tflush_signal_handlers(current, 0);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\tcurrent->self_exec_id++;"
        ],
        "added_lines": [
            "\tWRITE_ONCE(current->self_exec_id, current->self_exec_id + 1);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}