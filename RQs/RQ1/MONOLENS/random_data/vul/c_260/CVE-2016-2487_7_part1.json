{
    "cve_id": "CVE-2016-2487",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "android",
    "commit_msg": "codecs: check OMX buffer size before use in (h263|h264)dec\n\nBug: 27833616\nChange-Id: I0fd599b3da431425d89236ffdd9df423c11947c0\n",
    "commit_hash": "d2f47191538837e796e2b10c1ff7e1ee35f6e0ab",
    "git_url": "https://android.googlesource.com/platform/frameworks/av/+/d2f47191538837e796e2b10c1ff7e1ee35f6e0ab",
    "file_path": "media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp",
    "func_name": "SoftMPEG4::onQueueFilled",
    "func_before": "void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {\n    if (mSignalledError || mOutputPortSettingsChange != NONE) {\n        return;\n    }\n\n    List<BufferInfo *> &inQueue = getPortQueue(0);\n    List<BufferInfo *> &outQueue = getPortQueue(1);\n\n    while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n        BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n        if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            continue;\n        }\n\n        PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n        if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            ++mInputBufferCount;\n\n            if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n                List<BufferInfo *>::iterator it = outQueue.begin();\n                while ((*it)->mHeader != outHeader) {\n                    ++it;\n                }\n\n                BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n            }\n            return;\n        }\n\n        uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n        uint32_t *start_code = (uint32_t *)bitstream;\n        bool volHeader = *start_code == 0xB0010000;\n        if (volHeader) {\n            PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n        }\n\n        if (!mInitialized) {\n            uint8_t *vol_data[1];\n            int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n            if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n            }\n\n            MP4DecodingMode mode =\n                (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n            Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n            if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n            if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n            bool hasFrameData = false;\n            if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n            } else if (volHeader) {\n                hasFrameData = true;\n            }\n\n            mInitialized = true;\n\n            if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n                return;\n            }\n\n            if (!hasFrameData) {\n                continue;\n            }\n        }\n\n        if (!mFramesConfigured) {\n            PortInfo *port = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n\n            PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n\n            mFramesConfigured = true;\n        }\n\n        uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n        // decoder deals in ms (int32_t), OMX in us (int64_t)\n        // so use fake timestamp instead\n        uint32_t timestamp = 0xFFFFFFFF;\n        if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n        }\n\n        int32_t bufferSize = inHeader->nFilledLen;\n        int32_t tmp = bufferSize;\n\n        // The PV decoder is lying to us, sometimes it'll claim to only have\n        // consumed a subset of the buffer when it clearly consumed all of it.\n        // ignore whatever it says...\n        if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n                    &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n            return;\n        }\n\n        // H263 doesn't have VOL header, the frame size information is in short header, i.e. the\n        // decoder may detect size change after PVDecodeVideoFrame.\n        if (handlePortSettingsChange()) {\n            return;\n        }\n\n        // decoder deals in ms, OMX in us.\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n        if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n        } else {\n            outHeader->nFlags = 0;\n        }\n\n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n        }\n\n        ++mInputBufferCount;\n\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = (mWidth * mHeight * 3) / 2;\n\n        List<BufferInfo *>::iterator it = outQueue.begin();\n        while ((*it)->mHeader != outHeader) {\n            ++it;\n        }\n\n        BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n        ++mNumSamplesOutput;\n    }\n}",
    "abstract_func_before": "void SoftMPEG4::onQueueFilled(OMX_U32 /* COMMENT_0 */) {\n    if (VAR_0 || VAR_1 != VAR_2) {\n        return;\n    }\n\n    List<BufferInfo *> &VAR_3 = getPortQueue(0);\n    List<BufferInfo *> &VAR_4 = getPortQueue(1);\n\n    while (!VAR_3.empty() && VAR_4.size() == VAR_5) {\n        BufferInfo *VAR_6 = *VAR_3.begin();\n        OMX_BUFFERHEADERTYPE *VAR_7 = VAR_6->mHeader;\n        if (VAR_7 == NULL) {\n            VAR_3.erase(VAR_3.begin());\n            VAR_6->mOwnedByUs = false;\n            continue;\n        }\n\n        PortInfo *VAR_8 = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *VAR_9 =\n            VAR_8->mBuffers.editItemAt(VAR_10 & 1).mHeader;\n\n        if (VAR_7->nFilledLen == 0) {\n            VAR_3.erase(VAR_3.begin());\n            VAR_6->mOwnedByUs = false;\n            notifyEmptyBufferDone(VAR_7);\n\n            ++VAR_11;\n\n            if (VAR_7->nFlags & VAR_12) {\n                VAR_9->nFilledLen = 0;\n                VAR_9->nFlags = VAR_12;\n\n                List<BufferInfo *>::iterator VAR_13 = VAR_4.begin();\n                while ((*VAR_13)->mHeader != VAR_9) {\n                    ++VAR_13;\n                }\n\n                BufferInfo *VAR_14 = *VAR_13;\n                VAR_14->mOwnedByUs = false;\n                VAR_4.erase(VAR_13);\n                VAR_14 = NULL;\n\n                notifyFillBufferDone(VAR_9);\n                VAR_9 = NULL;\n            }\n            return;\n        }\n\n        uint8_t *VAR_15 = VAR_7->pBuffer + VAR_7->nOffset;\n        uint32_t *VAR_16 = (uint32_t *)VAR_15;\n        bool VAR_17 = *VAR_16 == 0xB0010000;\n        if (VAR_17) {\n            PVCleanUpVideoDecoder(VAR_18);\n            VAR_19 = false;\n        }\n\n        if (!VAR_19) {\n            uint8_t *VAR_20[1];\n            int32_t VAR_21 = 0;\n\n            VAR_20[0] = NULL;\n\n            if ((VAR_7->nFlags & VAR_22) || VAR_17) {\n                VAR_20[0] = VAR_15;\n                VAR_21 = VAR_7->nFilledLen;\n            }\n\n            MP4DecodingMode VAR_23 =\n                (VAR_24 == VAR_25) ? VAR_26 : VAR_27;\n\n            Bool VAR_28 = PVInitVideoDecoder(\n                    VAR_18, VAR_20, &VAR_21, 1,\n                    outputBufferWidth(), outputBufferHeight(), VAR_23);\n\n            if (!VAR_28) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(VAR_29, VAR_30, 0, NULL);\n                VAR_0 = true;\n                return;\n            }\n\n            MP4DecodingMode VAR_31 = PVGetDecBitstreamMode(VAR_18);\n            if (VAR_23 != VAR_31) {\n                notify(VAR_29, VAR_30, 0, NULL);\n                VAR_0 = true;\n                return;\n            }\n\n            PVSetPostProcType((VideoDecControls *) VAR_18, 0);\n\n            bool VAR_32 = false;\n            if (VAR_7->nFlags & VAR_22) {\n                VAR_6->mOwnedByUs = false;\n                VAR_3.erase(VAR_3.begin());\n                VAR_6 = NULL;\n                notifyEmptyBufferDone(VAR_7);\n                VAR_7 = NULL;\n            } else if (VAR_17) {\n                VAR_32 = true;\n            }\n\n            VAR_19 = true;\n\n            if (VAR_23 == VAR_26 && handlePortSettingsChange()) {\n                return;\n            }\n\n            if (!VAR_32) {\n                continue;\n            }\n        }\n\n        if (!VAR_33) {\n            PortInfo *VAR_8 = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *VAR_9 = VAR_8->mBuffers.editItemAt(1).mHeader;\n\n            PVSetReferenceYUV(VAR_18, VAR_9->pBuffer);\n\n            VAR_33 = true;\n        }\n\n        uint32_t VAR_34 = (VAR_7->nOffset == 0);\n\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        uint32_t VAR_35 = 0xFFFFFFFF;\n        if (VAR_34) {\n            VAR_36.add(VAR_37, VAR_7->nTimeStamp);\n            VAR_35 = VAR_37;\n            VAR_37++;\n        }\n\n        int32_t VAR_38 = VAR_7->nFilledLen;\n        int32_t VAR_39 = VAR_38;\n\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        if (PVDecodeVideoFrame(\n                    VAR_18, &VAR_15, &VAR_35, &VAR_39,\n                    &VAR_34,\n                    VAR_9->pBuffer) != VAR_40) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(VAR_29, VAR_30, 0, NULL);\n            VAR_0 = true;\n            return;\n        }\n\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        if (handlePortSettingsChange()) {\n            return;\n        }\n\n        /* COMMENT_8 */\n        VAR_9->nTimeStamp = VAR_36.valueFor(VAR_35);\n        VAR_36.removeItem(VAR_35);\n\n        VAR_7->nOffset += VAR_38;\n        VAR_7->nFilledLen = 0;\n        if (VAR_7->nFlags & VAR_12) {\n            VAR_9->nFlags = VAR_12;\n        } else {\n            VAR_9->nFlags = 0;\n        }\n\n        if (VAR_7->nFilledLen == 0) {\n            VAR_6->mOwnedByUs = false;\n            VAR_3.erase(VAR_3.begin());\n            VAR_6 = NULL;\n            notifyEmptyBufferDone(VAR_7);\n            VAR_7 = NULL;\n        }\n\n        ++VAR_11;\n\n        VAR_9->nOffset = 0;\n        VAR_9->nFilledLen = (VAR_41 * VAR_42 * 3) / 2;\n\n        List<BufferInfo *>::iterator VAR_13 = VAR_4.begin();\n        while ((*VAR_13)->mHeader != VAR_9) {\n            ++VAR_13;\n        }\n\n        BufferInfo *VAR_14 = *VAR_13;\n        VAR_14->mOwnedByUs = false;\n        VAR_4.erase(VAR_13);\n        VAR_14 = NULL;\n\n        notifyFillBufferDone(VAR_9);\n        VAR_9 = NULL;\n\n        ++VAR_10;\n    }\n}",
    "func_graph_path_before": "android/d2f47191538837e796e2b10c1ff7e1ee35f6e0ab/SoftMPEG4.cpp/vul/before/0.json",
    "func": "void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {\n    if (mSignalledError || mOutputPortSettingsChange != NONE) {\n        return;\n    }\n\n    List<BufferInfo *> &inQueue = getPortQueue(0);\n    List<BufferInfo *> &outQueue = getPortQueue(1);\n\n    while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n        BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n        if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            continue;\n        }\n\n        PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n        if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            ++mInputBufferCount;\n\n            if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n                List<BufferInfo *>::iterator it = outQueue.begin();\n                while ((*it)->mHeader != outHeader) {\n                    ++it;\n                }\n\n                BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n            }\n            return;\n        }\n\n        uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n        uint32_t *start_code = (uint32_t *)bitstream;\n        bool volHeader = *start_code == 0xB0010000;\n        if (volHeader) {\n            PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n        }\n\n        if (!mInitialized) {\n            uint8_t *vol_data[1];\n            int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n            if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n            }\n\n            MP4DecodingMode mode =\n                (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n            Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n            if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n            if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n            bool hasFrameData = false;\n            if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n            } else if (volHeader) {\n                hasFrameData = true;\n            }\n\n            mInitialized = true;\n\n            if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n                return;\n            }\n\n            if (!hasFrameData) {\n                continue;\n            }\n        }\n\n        if (!mFramesConfigured) {\n            PortInfo *port = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n\n            PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n\n            mFramesConfigured = true;\n        }\n\n        uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n        // decoder deals in ms (int32_t), OMX in us (int64_t)\n        // so use fake timestamp instead\n        uint32_t timestamp = 0xFFFFFFFF;\n        if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n        }\n\n        int32_t bufferSize = inHeader->nFilledLen;\n        int32_t tmp = bufferSize;\n\n        OMX_U32 frameSize = (mWidth * mHeight * 3) / 2;\n        if (outHeader->nAllocLen < frameSize) {\n            android_errorWriteLog(0x534e4554, \"27833616\");\n            ALOGE(\"Insufficient output buffer size\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n            return;\n        }\n        // The PV decoder is lying to us, sometimes it'll claim to only have\n        // consumed a subset of the buffer when it clearly consumed all of it.\n        // ignore whatever it says...\n        if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n                    &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n            return;\n        }\n\n        // H263 doesn't have VOL header, the frame size information is in short header, i.e. the\n        // decoder may detect size change after PVDecodeVideoFrame.\n        if (handlePortSettingsChange()) {\n            return;\n        }\n\n        // decoder deals in ms, OMX in us.\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n        if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n        } else {\n            outHeader->nFlags = 0;\n        }\n\n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n        }\n\n        ++mInputBufferCount;\n\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = frameSize;\n\n        List<BufferInfo *>::iterator it = outQueue.begin();\n        while ((*it)->mHeader != outHeader) {\n            ++it;\n        }\n\n        BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n        ++mNumSamplesOutput;\n    }\n}",
    "abstract_func": "void SoftMPEG4::onQueueFilled(OMX_U32 /* COMMENT_0 */) {\n    if (VAR_0 || VAR_1 != VAR_2) {\n        return;\n    }\n\n    List<BufferInfo *> &VAR_3 = getPortQueue(0);\n    List<BufferInfo *> &VAR_4 = getPortQueue(1);\n\n    while (!VAR_3.empty() && VAR_4.size() == VAR_5) {\n        BufferInfo *VAR_6 = *VAR_3.begin();\n        OMX_BUFFERHEADERTYPE *VAR_7 = VAR_6->mHeader;\n        if (VAR_7 == NULL) {\n            VAR_3.erase(VAR_3.begin());\n            VAR_6->mOwnedByUs = false;\n            continue;\n        }\n\n        PortInfo *VAR_8 = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *VAR_9 =\n            VAR_8->mBuffers.editItemAt(VAR_10 & 1).mHeader;\n\n        if (VAR_7->nFilledLen == 0) {\n            VAR_3.erase(VAR_3.begin());\n            VAR_6->mOwnedByUs = false;\n            notifyEmptyBufferDone(VAR_7);\n\n            ++VAR_11;\n\n            if (VAR_7->nFlags & VAR_12) {\n                VAR_9->nFilledLen = 0;\n                VAR_9->nFlags = VAR_12;\n\n                List<BufferInfo *>::iterator VAR_13 = VAR_4.begin();\n                while ((*VAR_13)->mHeader != VAR_9) {\n                    ++VAR_13;\n                }\n\n                BufferInfo *VAR_14 = *VAR_13;\n                VAR_14->mOwnedByUs = false;\n                VAR_4.erase(VAR_13);\n                VAR_14 = NULL;\n\n                notifyFillBufferDone(VAR_9);\n                VAR_9 = NULL;\n            }\n            return;\n        }\n\n        uint8_t *VAR_15 = VAR_7->pBuffer + VAR_7->nOffset;\n        uint32_t *VAR_16 = (uint32_t *)VAR_15;\n        bool VAR_17 = *VAR_16 == 0xB0010000;\n        if (VAR_17) {\n            PVCleanUpVideoDecoder(VAR_18);\n            VAR_19 = false;\n        }\n\n        if (!VAR_19) {\n            uint8_t *VAR_20[1];\n            int32_t VAR_21 = 0;\n\n            VAR_20[0] = NULL;\n\n            if ((VAR_7->nFlags & VAR_22) || VAR_17) {\n                VAR_20[0] = VAR_15;\n                VAR_21 = VAR_7->nFilledLen;\n            }\n\n            MP4DecodingMode VAR_23 =\n                (VAR_24 == VAR_25) ? VAR_26 : VAR_27;\n\n            Bool VAR_28 = PVInitVideoDecoder(\n                    VAR_18, VAR_20, &VAR_21, 1,\n                    outputBufferWidth(), outputBufferHeight(), VAR_23);\n\n            if (!VAR_28) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(VAR_29, VAR_30, 0, NULL);\n                VAR_0 = true;\n                return;\n            }\n\n            MP4DecodingMode VAR_31 = PVGetDecBitstreamMode(VAR_18);\n            if (VAR_23 != VAR_31) {\n                notify(VAR_29, VAR_30, 0, NULL);\n                VAR_0 = true;\n                return;\n            }\n\n            PVSetPostProcType((VideoDecControls *) VAR_18, 0);\n\n            bool VAR_32 = false;\n            if (VAR_7->nFlags & VAR_22) {\n                VAR_6->mOwnedByUs = false;\n                VAR_3.erase(VAR_3.begin());\n                VAR_6 = NULL;\n                notifyEmptyBufferDone(VAR_7);\n                VAR_7 = NULL;\n            } else if (VAR_17) {\n                VAR_32 = true;\n            }\n\n            VAR_19 = true;\n\n            if (VAR_23 == VAR_26 && handlePortSettingsChange()) {\n                return;\n            }\n\n            if (!VAR_32) {\n                continue;\n            }\n        }\n\n        if (!VAR_33) {\n            PortInfo *VAR_8 = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *VAR_9 = VAR_8->mBuffers.editItemAt(1).mHeader;\n\n            PVSetReferenceYUV(VAR_18, VAR_9->pBuffer);\n\n            VAR_33 = true;\n        }\n\n        uint32_t VAR_34 = (VAR_7->nOffset == 0);\n\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        uint32_t VAR_35 = 0xFFFFFFFF;\n        if (VAR_34) {\n            VAR_36.add(VAR_37, VAR_7->nTimeStamp);\n            VAR_35 = VAR_37;\n            VAR_37++;\n        }\n\n        int32_t VAR_38 = VAR_7->nFilledLen;\n        int32_t VAR_39 = VAR_38;\n\n        OMX_U32 VAR_40 = (VAR_41 * VAR_42 * 3) / 2;\n        if (VAR_9->nAllocLen < VAR_40) {\n            android_errorWriteLog(0x534e4554, \"27833616\");\n            ALOGE(\"Insufficient output buffer size\");\n            notify(VAR_29, VAR_30, 0, NULL);\n            VAR_0 = true;\n            return;\n        }\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        if (PVDecodeVideoFrame(\n                    VAR_18, &VAR_15, &VAR_35, &VAR_39,\n                    &VAR_34,\n                    VAR_9->pBuffer) != VAR_43) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(VAR_29, VAR_30, 0, NULL);\n            VAR_0 = true;\n            return;\n        }\n\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        if (handlePortSettingsChange()) {\n            return;\n        }\n\n        /* COMMENT_8 */\n        VAR_9->nTimeStamp = VAR_36.valueFor(VAR_35);\n        VAR_36.removeItem(VAR_35);\n\n        VAR_7->nOffset += VAR_38;\n        VAR_7->nFilledLen = 0;\n        if (VAR_7->nFlags & VAR_12) {\n            VAR_9->nFlags = VAR_12;\n        } else {\n            VAR_9->nFlags = 0;\n        }\n\n        if (VAR_7->nFilledLen == 0) {\n            VAR_6->mOwnedByUs = false;\n            VAR_3.erase(VAR_3.begin());\n            VAR_6 = NULL;\n            notifyEmptyBufferDone(VAR_7);\n            VAR_7 = NULL;\n        }\n\n        ++VAR_11;\n\n        VAR_9->nOffset = 0;\n        VAR_9->nFilledLen = VAR_40;\n\n        List<BufferInfo *>::iterator VAR_13 = VAR_4.begin();\n        while ((*VAR_13)->mHeader != VAR_9) {\n            ++VAR_13;\n        }\n\n        BufferInfo *VAR_14 = *VAR_13;\n        VAR_14->mOwnedByUs = false;\n        VAR_4.erase(VAR_13);\n        VAR_14 = NULL;\n\n        notifyFillBufferDone(VAR_9);\n        VAR_9 = NULL;\n\n        ++VAR_10;\n    }\n}",
    "func_graph_path": "android/d2f47191538837e796e2b10c1ff7e1ee35f6e0ab/SoftMPEG4.cpp/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -135,6 +135,14 @@\n         int32_t bufferSize = inHeader->nFilledLen;\n         int32_t tmp = bufferSize;\n \n+        OMX_U32 frameSize = (mWidth * mHeight * 3) / 2;\n+        if (outHeader->nAllocLen < frameSize) {\n+            android_errorWriteLog(0x534e4554, \"27833616\");\n+            ALOGE(\"Insufficient output buffer size\");\n+            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n+            mSignalledError = true;\n+            return;\n+        }\n         // The PV decoder is lying to us, sometimes it'll claim to only have\n         // consumed a subset of the buffer when it clearly consumed all of it.\n         // ignore whatever it says...\n@@ -178,7 +186,7 @@\n         ++mInputBufferCount;\n \n         outHeader->nOffset = 0;\n-        outHeader->nFilledLen = (mWidth * mHeight * 3) / 2;\n+        outHeader->nFilledLen = frameSize;\n \n         List<BufferInfo *>::iterator it = outQueue.begin();\n         while ((*it)->mHeader != outHeader) {",
    "diff_line_info": {
        "deleted_lines": [
            "        outHeader->nFilledLen = (mWidth * mHeight * 3) / 2;"
        ],
        "added_lines": [
            "        OMX_U32 frameSize = (mWidth * mHeight * 3) / 2;",
            "        if (outHeader->nAllocLen < frameSize) {",
            "            android_errorWriteLog(0x534e4554, \"27833616\");",
            "            ALOGE(\"Insufficient output buffer size\");",
            "            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);",
            "            mSignalledError = true;",
            "            return;",
            "        }",
            "        outHeader->nFilledLen = frameSize;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}