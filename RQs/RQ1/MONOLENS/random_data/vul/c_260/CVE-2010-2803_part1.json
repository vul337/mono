{
    "cve_id": "CVE-2010-2803",
    "cwe_ids": [
        "CWE-200"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "non-critical issue, CVE-2010-2803\n\nUserspace controls the amount of memory to be allocate, so it can\nget the ioctl to allocate more memory than the kernel uses, and get\naccess to kernel stack. This can only be done for processes authenticated\nto the X server for DRI access, and if the user has DRI access.\n\nFix is to just memset the data to 0 if the user doesn't copy into\nit in the first place.\n\nReported-by: Kees Cook <kees@ubuntu.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n",
    "commit_hash": "b9f0aee83335db1f3915f4e42a5e21b351740afd",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=b9f0aee83335db1f3915f4e42a5e21b351740afd",
    "file_path": "drivers/gpu/drm/drm_drv.c",
    "func_name": "drm_ioctl",
    "func_before": "long drm_ioctl(struct file *filp,\n\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev;\n\tstruct drm_ioctl_desc *ioctl;\n\tdrm_ioctl_t *func;\n\tunsigned int nr = DRM_IOCTL_NR(cmd);\n\tint retcode = -EINVAL;\n\tchar stack_kdata[128];\n\tchar *kdata = NULL;\n\n\tdev = file_priv->minor->dev;\n\tatomic_inc(&dev->ioctl_count);\n\tatomic_inc(&dev->counts[_DRM_STAT_IOCTLS]);\n\t++file_priv->ioctl_count;\n\n\tDRM_DEBUG(\"pid=%d, cmd=0x%02x, nr=0x%02x, dev 0x%lx, auth=%d\\n\",\n\t\t  task_pid_nr(current), cmd, nr,\n\t\t  (long)old_encode_dev(file_priv->minor->device),\n\t\t  file_priv->authenticated);\n\n\tif ((nr >= DRM_CORE_IOCTL_COUNT) &&\n\t    ((nr < DRM_COMMAND_BASE) || (nr >= DRM_COMMAND_END)))\n\t\tgoto err_i1;\n\tif ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_END) &&\n\t    (nr < DRM_COMMAND_BASE + dev->driver->num_ioctls))\n\t\tioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];\n\telse if ((nr >= DRM_COMMAND_END) || (nr < DRM_COMMAND_BASE)) {\n\t\tioctl = &drm_ioctls[nr];\n\t\tcmd = ioctl->cmd;\n\t} else\n\t\tgoto err_i1;\n\n\t/* Do not trust userspace, use our own definition */\n\tfunc = ioctl->func;\n\t/* is there a local override? */\n\tif ((nr == DRM_IOCTL_NR(DRM_IOCTL_DMA)) && dev->driver->dma_ioctl)\n\t\tfunc = dev->driver->dma_ioctl;\n\n\tif (!func) {\n\t\tDRM_DEBUG(\"no function\\n\");\n\t\tretcode = -EINVAL;\n\t} else if (((ioctl->flags & DRM_ROOT_ONLY) && !capable(CAP_SYS_ADMIN)) ||\n\t\t   ((ioctl->flags & DRM_AUTH) && !file_priv->authenticated) ||\n\t\t   ((ioctl->flags & DRM_MASTER) && !file_priv->is_master) ||\n\t\t   (!(ioctl->flags & DRM_CONTROL_ALLOW) && (file_priv->minor->type == DRM_MINOR_CONTROL))) {\n\t\tretcode = -EACCES;\n\t} else {\n\t\tif (cmd & (IOC_IN | IOC_OUT)) {\n\t\t\tif (_IOC_SIZE(cmd) <= sizeof(stack_kdata)) {\n\t\t\t\tkdata = stack_kdata;\n\t\t\t} else {\n\t\t\t\tkdata = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\t\tif (!kdata) {\n\t\t\t\t\tretcode = -ENOMEM;\n\t\t\t\t\tgoto err_i1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cmd & IOC_IN) {\n\t\t\tif (copy_from_user(kdata, (void __user *)arg,\n\t\t\t\t\t   _IOC_SIZE(cmd)) != 0) {\n\t\t\t\tretcode = -EFAULT;\n\t\t\t\tgoto err_i1;\n\t\t\t}\n\t\t}\n\t\tif (ioctl->flags & DRM_UNLOCKED)\n\t\t\tretcode = func(dev, kdata, file_priv);\n\t\telse {\n\t\t\tmutex_lock(&drm_global_mutex);\n\t\t\tretcode = func(dev, kdata, file_priv);\n\t\t\tmutex_unlock(&drm_global_mutex);\n\t\t}\n\n\t\tif (cmd & IOC_OUT) {\n\t\t\tif (copy_to_user((void __user *)arg, kdata,\n\t\t\t\t\t _IOC_SIZE(cmd)) != 0)\n\t\t\t\tretcode = -EFAULT;\n\t\t}\n\t}\n\n      err_i1:\n\tif (kdata != stack_kdata)\n\t\tkfree(kdata);\n\tatomic_dec(&dev->ioctl_count);\n\tif (retcode)\n\t\tDRM_DEBUG(\"ret = %x\\n\", retcode);\n\treturn retcode;\n}",
    "abstract_func_before": "long drm_ioctl(struct file *VAR_0,\n\t      unsigned int VAR_1, unsigned long VAR_2)\n{\n\tstruct drm_file *VAR_3 = VAR_0->private_data;\n\tstruct drm_device *VAR_4;\n\tstruct drm_ioctl_desc *VAR_5;\n\tdrm_ioctl_t *VAR_6;\n\tunsigned int VAR_7 = DRM_IOCTL_NR(VAR_1);\n\tint VAR_8 = -VAR_9;\n\tchar VAR_10[128];\n\tchar *VAR_11 = NULL;\n\n\tVAR_4 = VAR_3->minor->dev;\n\tatomic_inc(&VAR_4->ioctl_count);\n\tatomic_inc(&VAR_4->counts[VAR_12]);\n\t++VAR_3->ioctl_count;\n\n\tDRM_DEBUG(\"pid=%d, cmd=0x%02x, nr=0x%02x, dev 0x%lx, auth=%d\\n\",\n\t\t  task_pid_nr(VAR_13), VAR_1, VAR_7,\n\t\t  (long)old_encode_dev(VAR_3->minor->device),\n\t\t  VAR_3->authenticated);\n\n\tif ((VAR_7 >= VAR_14) &&\n\t    ((VAR_7 < VAR_15) || (VAR_7 >= VAR_16)))\n\t\tgoto err_i1;\n\tif ((VAR_7 >= VAR_15) && (VAR_7 < VAR_16) &&\n\t    (VAR_7 < VAR_15 + VAR_4->driver->num_ioctls))\n\t\tVAR_5 = &VAR_4->driver->ioctls[VAR_7 - VAR_15];\n\telse if ((VAR_7 >= VAR_16) || (VAR_7 < VAR_15)) {\n\t\tVAR_5 = &VAR_17[VAR_7];\n\t\tVAR_1 = VAR_5->cmd;\n\t} else\n\t\tgoto err_i1;\n\n\t/* COMMENT_0 */\n\tVAR_6 = VAR_5->func;\n\t/* COMMENT_1 */\n\tif ((VAR_7 == DRM_IOCTL_NR(VAR_18)) && VAR_4->driver->dma_ioctl)\n\t\tVAR_6 = VAR_4->driver->dma_ioctl;\n\n\tif (!VAR_6) {\n\t\tDRM_DEBUG(\"no function\\n\");\n\t\tVAR_8 = -VAR_9;\n\t} else if (((VAR_5->flags & VAR_19) && !capable(VAR_20)) ||\n\t\t   ((VAR_5->flags & VAR_21) && !VAR_3->authenticated) ||\n\t\t   ((VAR_5->flags & VAR_22) && !VAR_3->is_master) ||\n\t\t   (!(VAR_5->flags & VAR_23) && (VAR_3->minor->type == VAR_24))) {\n\t\tVAR_8 = -VAR_25;\n\t} else {\n\t\tif (VAR_1 & (VAR_26 | VAR_27)) {\n\t\t\tif (_IOC_SIZE(VAR_1) <= sizeof(VAR_10)) {\n\t\t\t\tVAR_11 = VAR_10;\n\t\t\t} else {\n\t\t\t\tVAR_11 = kmalloc(_IOC_SIZE(VAR_1), VAR_28);\n\t\t\t\tif (!VAR_11) {\n\t\t\t\t\tVAR_8 = -VAR_29;\n\t\t\t\t\tgoto err_i1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (VAR_1 & VAR_26) {\n\t\t\tif (copy_from_user(VAR_11, (void __user *)VAR_2,\n\t\t\t\t\t   _IOC_SIZE(VAR_1)) != 0) {\n\t\t\t\tVAR_8 = -VAR_30;\n\t\t\t\tgoto err_i1;\n\t\t\t}\n\t\t}\n\t\tif (VAR_5->flags & VAR_31)\n\t\t\tVAR_8 = VAR_6(VAR_4, VAR_11, VAR_3);\n\t\telse {\n\t\t\tmutex_lock(&VAR_32);\n\t\t\tVAR_8 = VAR_6(VAR_4, VAR_11, VAR_3);\n\t\t\tmutex_unlock(&VAR_32);\n\t\t}\n\n\t\tif (VAR_1 & VAR_27) {\n\t\t\tif (copy_to_user((void __user *)VAR_2, VAR_11,\n\t\t\t\t\t _IOC_SIZE(VAR_1)) != 0)\n\t\t\t\tVAR_8 = -VAR_30;\n\t\t}\n\t}\n\n      err_i1:\n\tif (VAR_11 != VAR_10)\n\t\tkfree(VAR_11);\n\tatomic_dec(&VAR_4->ioctl_count);\n\tif (VAR_8)\n\t\tDRM_DEBUG(\"ret = %x\\n\", VAR_8);\n\treturn VAR_8;\n}",
    "func_graph_path_before": "torvalds/linux/b9f0aee83335db1f3915f4e42a5e21b351740afd/drm_drv.c/vul/before/0.json",
    "func": "long drm_ioctl(struct file *filp,\n\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev;\n\tstruct drm_ioctl_desc *ioctl;\n\tdrm_ioctl_t *func;\n\tunsigned int nr = DRM_IOCTL_NR(cmd);\n\tint retcode = -EINVAL;\n\tchar stack_kdata[128];\n\tchar *kdata = NULL;\n\n\tdev = file_priv->minor->dev;\n\tatomic_inc(&dev->ioctl_count);\n\tatomic_inc(&dev->counts[_DRM_STAT_IOCTLS]);\n\t++file_priv->ioctl_count;\n\n\tDRM_DEBUG(\"pid=%d, cmd=0x%02x, nr=0x%02x, dev 0x%lx, auth=%d\\n\",\n\t\t  task_pid_nr(current), cmd, nr,\n\t\t  (long)old_encode_dev(file_priv->minor->device),\n\t\t  file_priv->authenticated);\n\n\tif ((nr >= DRM_CORE_IOCTL_COUNT) &&\n\t    ((nr < DRM_COMMAND_BASE) || (nr >= DRM_COMMAND_END)))\n\t\tgoto err_i1;\n\tif ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_END) &&\n\t    (nr < DRM_COMMAND_BASE + dev->driver->num_ioctls))\n\t\tioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];\n\telse if ((nr >= DRM_COMMAND_END) || (nr < DRM_COMMAND_BASE)) {\n\t\tioctl = &drm_ioctls[nr];\n\t\tcmd = ioctl->cmd;\n\t} else\n\t\tgoto err_i1;\n\n\t/* Do not trust userspace, use our own definition */\n\tfunc = ioctl->func;\n\t/* is there a local override? */\n\tif ((nr == DRM_IOCTL_NR(DRM_IOCTL_DMA)) && dev->driver->dma_ioctl)\n\t\tfunc = dev->driver->dma_ioctl;\n\n\tif (!func) {\n\t\tDRM_DEBUG(\"no function\\n\");\n\t\tretcode = -EINVAL;\n\t} else if (((ioctl->flags & DRM_ROOT_ONLY) && !capable(CAP_SYS_ADMIN)) ||\n\t\t   ((ioctl->flags & DRM_AUTH) && !file_priv->authenticated) ||\n\t\t   ((ioctl->flags & DRM_MASTER) && !file_priv->is_master) ||\n\t\t   (!(ioctl->flags & DRM_CONTROL_ALLOW) && (file_priv->minor->type == DRM_MINOR_CONTROL))) {\n\t\tretcode = -EACCES;\n\t} else {\n\t\tif (cmd & (IOC_IN | IOC_OUT)) {\n\t\t\tif (_IOC_SIZE(cmd) <= sizeof(stack_kdata)) {\n\t\t\t\tkdata = stack_kdata;\n\t\t\t} else {\n\t\t\t\tkdata = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\t\tif (!kdata) {\n\t\t\t\t\tretcode = -ENOMEM;\n\t\t\t\t\tgoto err_i1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cmd & IOC_IN) {\n\t\t\tif (copy_from_user(kdata, (void __user *)arg,\n\t\t\t\t\t   _IOC_SIZE(cmd)) != 0) {\n\t\t\t\tretcode = -EFAULT;\n\t\t\t\tgoto err_i1;\n\t\t\t}\n\t\t} else\n\t\t\tmemset(kdata, 0, _IOC_SIZE(cmd));\n\n\t\tif (ioctl->flags & DRM_UNLOCKED)\n\t\t\tretcode = func(dev, kdata, file_priv);\n\t\telse {\n\t\t\tmutex_lock(&drm_global_mutex);\n\t\t\tretcode = func(dev, kdata, file_priv);\n\t\t\tmutex_unlock(&drm_global_mutex);\n\t\t}\n\n\t\tif (cmd & IOC_OUT) {\n\t\t\tif (copy_to_user((void __user *)arg, kdata,\n\t\t\t\t\t _IOC_SIZE(cmd)) != 0)\n\t\t\t\tretcode = -EFAULT;\n\t\t}\n\t}\n\n      err_i1:\n\tif (kdata != stack_kdata)\n\t\tkfree(kdata);\n\tatomic_dec(&dev->ioctl_count);\n\tif (retcode)\n\t\tDRM_DEBUG(\"ret = %x\\n\", retcode);\n\treturn retcode;\n}",
    "abstract_func": "long drm_ioctl(struct file *VAR_0,\n\t      unsigned int VAR_1, unsigned long VAR_2)\n{\n\tstruct drm_file *VAR_3 = VAR_0->private_data;\n\tstruct drm_device *VAR_4;\n\tstruct drm_ioctl_desc *VAR_5;\n\tdrm_ioctl_t *VAR_6;\n\tunsigned int VAR_7 = DRM_IOCTL_NR(VAR_1);\n\tint VAR_8 = -VAR_9;\n\tchar VAR_10[128];\n\tchar *VAR_11 = NULL;\n\n\tVAR_4 = VAR_3->minor->dev;\n\tatomic_inc(&VAR_4->ioctl_count);\n\tatomic_inc(&VAR_4->counts[VAR_12]);\n\t++VAR_3->ioctl_count;\n\n\tDRM_DEBUG(\"pid=%d, cmd=0x%02x, nr=0x%02x, dev 0x%lx, auth=%d\\n\",\n\t\t  task_pid_nr(VAR_13), VAR_1, VAR_7,\n\t\t  (long)old_encode_dev(VAR_3->minor->device),\n\t\t  VAR_3->authenticated);\n\n\tif ((VAR_7 >= VAR_14) &&\n\t    ((VAR_7 < VAR_15) || (VAR_7 >= VAR_16)))\n\t\tgoto err_i1;\n\tif ((VAR_7 >= VAR_15) && (VAR_7 < VAR_16) &&\n\t    (VAR_7 < VAR_15 + VAR_4->driver->num_ioctls))\n\t\tVAR_5 = &VAR_4->driver->ioctls[VAR_7 - VAR_15];\n\telse if ((VAR_7 >= VAR_16) || (VAR_7 < VAR_15)) {\n\t\tVAR_5 = &VAR_17[VAR_7];\n\t\tVAR_1 = VAR_5->cmd;\n\t} else\n\t\tgoto err_i1;\n\n\t/* COMMENT_0 */\n\tVAR_6 = VAR_5->func;\n\t/* COMMENT_1 */\n\tif ((VAR_7 == DRM_IOCTL_NR(VAR_18)) && VAR_4->driver->dma_ioctl)\n\t\tVAR_6 = VAR_4->driver->dma_ioctl;\n\n\tif (!VAR_6) {\n\t\tDRM_DEBUG(\"no function\\n\");\n\t\tVAR_8 = -VAR_9;\n\t} else if (((VAR_5->flags & VAR_19) && !capable(VAR_20)) ||\n\t\t   ((VAR_5->flags & VAR_21) && !VAR_3->authenticated) ||\n\t\t   ((VAR_5->flags & VAR_22) && !VAR_3->is_master) ||\n\t\t   (!(VAR_5->flags & VAR_23) && (VAR_3->minor->type == VAR_24))) {\n\t\tVAR_8 = -VAR_25;\n\t} else {\n\t\tif (VAR_1 & (VAR_26 | VAR_27)) {\n\t\t\tif (_IOC_SIZE(VAR_1) <= sizeof(VAR_10)) {\n\t\t\t\tVAR_11 = VAR_10;\n\t\t\t} else {\n\t\t\t\tVAR_11 = kmalloc(_IOC_SIZE(VAR_1), VAR_28);\n\t\t\t\tif (!VAR_11) {\n\t\t\t\t\tVAR_8 = -VAR_29;\n\t\t\t\t\tgoto err_i1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (VAR_1 & VAR_26) {\n\t\t\tif (copy_from_user(VAR_11, (void __user *)VAR_2,\n\t\t\t\t\t   _IOC_SIZE(VAR_1)) != 0) {\n\t\t\t\tVAR_8 = -VAR_30;\n\t\t\t\tgoto err_i1;\n\t\t\t}\n\t\t} else\n\t\t\tmemset(VAR_11, 0, _IOC_SIZE(VAR_1));\n\n\t\tif (VAR_5->flags & VAR_31)\n\t\t\tVAR_8 = VAR_6(VAR_4, VAR_11, VAR_3);\n\t\telse {\n\t\t\tmutex_lock(&VAR_32);\n\t\t\tVAR_8 = VAR_6(VAR_4, VAR_11, VAR_3);\n\t\t\tmutex_unlock(&VAR_32);\n\t\t}\n\n\t\tif (VAR_1 & VAR_27) {\n\t\t\tif (copy_to_user((void __user *)VAR_2, VAR_11,\n\t\t\t\t\t _IOC_SIZE(VAR_1)) != 0)\n\t\t\t\tVAR_8 = -VAR_30;\n\t\t}\n\t}\n\n      err_i1:\n\tif (VAR_11 != VAR_10)\n\t\tkfree(VAR_11);\n\tatomic_dec(&VAR_4->ioctl_count);\n\tif (VAR_8)\n\t\tDRM_DEBUG(\"ret = %x\\n\", VAR_8);\n\treturn VAR_8;\n}",
    "func_graph_path": "torvalds/linux/b9f0aee83335db1f3915f4e42a5e21b351740afd/drm_drv.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -65,7 +65,9 @@\n \t\t\t\tretcode = -EFAULT;\n \t\t\t\tgoto err_i1;\n \t\t\t}\n-\t\t}\n+\t\t} else\n+\t\t\tmemset(kdata, 0, _IOC_SIZE(cmd));\n+\n \t\tif (ioctl->flags & DRM_UNLOCKED)\n \t\t\tretcode = func(dev, kdata, file_priv);\n \t\telse {",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t}"
        ],
        "added_lines": [
            "\t\t} else",
            "\t\t\tmemset(kdata, 0, _IOC_SIZE(cmd));",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}