{
    "cve_id": "CVE-2019-13362",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "michaelrsweet/codedoc",
    "commit_msg": "Fix a buffer overflow issue with fuzzer-generated code (Issue #5)",
    "commit_hash": "19532db97af1eccb1ed74b7ea4c41eb822ae9964",
    "git_url": "https://github.com/michaelrsweet/codedoc/commit/19532db97af1eccb1ed74b7ea4c41eb822ae9964",
    "file_path": "codedoc.c",
    "func_name": "add_variable",
    "func_before": "static mxml_node_t *\t\t\t/* O - New variable/argument */\nadd_variable(mxml_node_t *parent,\t/* I - Parent node */\n             const char  *name,\t\t/* I - \"argument\" or \"variable\" */\n             mxml_node_t *type)\t\t/* I - Type nodes */\n{\n  mxml_node_t\t*variable,\t\t/* New variable */\n\t\t*node,\t\t\t/* Current node */\n\t\t*next;\t\t\t/* Next node */\n  char\t\tbuffer[16384],\t\t/* String buffer */\n\t\t*bufptr;\t\t/* Pointer into buffer */\n  int\t\twhitespace = 0;\t\t/* Whitespace before string? */\n  const char\t*string = NULL;\t\t/* String value */\n\n\n  DEBUG_printf(\"add_variable(parent=%p, name=\\\"%s\\\", type=%p)\\n\", parent, name, type);\n\n /*\n  * Range check input...\n  */\n\n  if (!type || !mxmlGetFirstChild(type))\n    return (NULL);\n\n /*\n  * Create the variable/argument node...\n  */\n\n  variable = mxmlNewElement(parent, name);\n\n /*\n  * Check for a default value...\n  */\n\n  for (node = mxmlGetFirstChild(type); node; node = mxmlGetNextSibling(node))\n  {\n    string = mxmlGetText(node, &whitespace);\n\n    if (!strcmp(string, \"=\"))\n      break;\n  }\n\n  if (node)\n  {\n   /*\n    * Default value found, copy it and add as a \"default\" attribute...\n    */\n\n    for (bufptr = buffer; node; bufptr += strlen(bufptr))\n    {\n      string = mxmlGetText(node, &whitespace);\n\n      if (whitespace && bufptr > buffer)\n\t*bufptr++ = ' ';\n\n      strlcpy(bufptr, string, sizeof(buffer) - (size_t)(bufptr - buffer));\n\n      next = mxmlGetNextSibling(node);\n      mxmlDelete(node);\n      node = next;\n    }\n\n    mxmlElementSetAttr(variable, \"default\", buffer);\n  }\n\n /*\n  * Extract the argument/variable name...\n  */\n\n  string = mxmlGetText(mxmlGetLastChild(type), &whitespace);\n\n  if (*string == ')')\n  {\n   /*\n    * Handle \"type (*name)(args)\"...\n    */\n\n    for (node = mxmlGetFirstChild(type); node; node = mxmlGetNextSibling(node))\n    {\n      string = mxmlGetText(node, &whitespace);\n      if (*string == '(')\n\tbreak;\n    }\n\n    for (bufptr = buffer; node; bufptr += strlen(bufptr))\n    {\n      string = mxmlGetText(node, &whitespace);\n\n      if (whitespace && bufptr > buffer)\n\t*bufptr++ = ' ';\n\n      strlcpy(bufptr, string, sizeof(buffer) - (size_t)(bufptr - buffer));\n\n      next = mxmlGetNextSibling(node);\n      mxmlDelete(node);\n      node = next;\n    }\n  }\n  else\n  {\n   /*\n    * Handle \"type name\"...\n    */\n\n    strlcpy(buffer, string, sizeof(buffer));\n    mxmlDelete(mxmlGetLastChild(type));\n  }\n\n /*\n  * Set the name...\n  */\n\n  mxmlElementSetAttr(variable, \"name\", buffer);\n\n /*\n  * Add the remaining type information to the variable node...\n  */\n\n  mxmlAdd(variable, MXML_ADD_AFTER, MXML_ADD_TO_PARENT, type);\n\n /*\n  * Add new new variable node...\n  */\n\n  return (variable);\n}",
    "abstract_func_before": "static mxml_node_t *\t\t\t/* COMMENT_0 */\nadd_variable(mxml_node_t *VAR_0,\t/* COMMENT_1 */\n             const char  *VAR_1,\t\t/* COMMENT_2 */\n             mxml_node_t *VAR_2)\t\t/* COMMENT_3 */\n{\n  mxml_node_t\t*VAR_3,\t\t/* COMMENT_4 */\n\t\t*VAR_4,\t\t\t/* COMMENT_5 */\n\t\t*VAR_5;\t\t\t/* COMMENT_6 */\n  char\t\tVAR_6[16384],\t\t/* COMMENT_7 */\n\t\t*VAR_7;\t\t/* COMMENT_8 */\n  int\t\tVAR_8 = 0;\t\t/* COMMENT_9 */\n  const char\t*VAR_9 = NULL;\t\t/* COMMENT_10 */\n\n\n  DEBUG_printf(\"add_variable(parent=%p, name=\\\"%s\\\", type=%p)\\n\", VAR_0, VAR_1, VAR_2);\n\n /* COMMENT_11 */\n                        \n    \n\n  if (!VAR_2 || !mxmlGetFirstChild(VAR_2))\n    return (NULL);\n\n /* COMMENT_14 */\n                                        \n    \n\n  VAR_3 = mxmlNewElement(VAR_0, VAR_1);\n\n /* COMMENT_17 */\n                                \n    \n\n  for (VAR_4 = mxmlGetFirstChild(VAR_2); VAR_4; VAR_4 = mxmlGetNextSibling(VAR_4))\n  {\n    VAR_9 = mxmlGetText(VAR_4, &VAR_8);\n\n    if (!strcmp(VAR_9, \"=\"))\n      break;\n  }\n\n  if (VAR_4)\n  {\n   /* COMMENT_20 */\n                                                                      \n      \n\n    for (VAR_7 = VAR_6; VAR_4; VAR_7 += strlen(VAR_7))\n    {\n      VAR_9 = mxmlGetText(VAR_4, &VAR_8);\n\n      if (VAR_8 && VAR_7 > VAR_6)\n\t*VAR_7++ = ' ';\n\n      strlcpy(VAR_7, VAR_9, sizeof(VAR_6) - (size_t)(VAR_7 - VAR_6));\n\n      VAR_5 = mxmlGetNextSibling(VAR_4);\n      mxmlDelete(VAR_4);\n      VAR_4 = VAR_5;\n    }\n\n    mxmlElementSetAttr(VAR_3, \"default\", VAR_6);\n  }\n\n /* COMMENT_23 */\n                                         \n    \n\n  VAR_9 = mxmlGetText(mxmlGetLastChild(VAR_2), &VAR_8);\n\n  if (*VAR_9 == ')')\n  {\n   /* COMMENT_26 */\n                                    \n      \n\n    for (VAR_4 = mxmlGetFirstChild(VAR_2); VAR_4; VAR_4 = mxmlGetNextSibling(VAR_4))\n    {\n      VAR_9 = mxmlGetText(VAR_4, &VAR_8);\n      if (*VAR_9 == '(')\n\tbreak;\n    }\n\n    for (VAR_7 = VAR_6; VAR_4; VAR_7 += strlen(VAR_7))\n    {\n      VAR_9 = mxmlGetText(VAR_4, &VAR_8);\n\n      if (VAR_8 && VAR_7 > VAR_6)\n\t*VAR_7++ = ' ';\n\n      strlcpy(VAR_7, VAR_9, sizeof(VAR_6) - (size_t)(VAR_7 - VAR_6));\n\n      VAR_5 = mxmlGetNextSibling(VAR_4);\n      mxmlDelete(VAR_4);\n      VAR_4 = VAR_5;\n    }\n  }\n  else\n  {\n   /* COMMENT_29 */\n                           \n      \n\n    strlcpy(VAR_6, VAR_9, sizeof(VAR_6));\n    mxmlDelete(mxmlGetLastChild(VAR_2));\n  }\n\n /* COMMENT_32 */\n                   \n    \n\n  mxmlElementSetAttr(VAR_3, \"name\", VAR_6);\n\n /* COMMENT_35 */\n                                                              \n    \n\n  mxmlAdd(VAR_3, VAR_10, VAR_11, VAR_2);\n\n /* COMMENT_38 */\n                                \n    \n\n  return (VAR_3);\n}",
    "func_graph_path_before": "michaelrsweet/codedoc/19532db97af1eccb1ed74b7ea4c41eb822ae9964/codedoc.c/vul/before/0.json",
    "func": "static mxml_node_t *\t\t\t/* O - New variable/argument */\nadd_variable(mxml_node_t *parent,\t/* I - Parent node */\n             const char  *name,\t\t/* I - \"argument\" or \"variable\" */\n             mxml_node_t *type)\t\t/* I - Type nodes */\n{\n  mxml_node_t\t*variable,\t\t/* New variable */\n\t\t*node,\t\t\t/* Current node */\n\t\t*next;\t\t\t/* Next node */\n  char\t\tbuffer[16384],\t\t/* String buffer */\n\t\t*bufptr;\t\t/* Pointer into buffer */\n  int\t\twhitespace = 0;\t\t/* Whitespace before string? */\n  const char\t*string = NULL;\t\t/* String value */\n\n\n  DEBUG_printf(\"add_variable(parent=%p, name=\\\"%s\\\", type=%p)\\n\", parent, name, type);\n\n /*\n  * Range check input...\n  */\n\n  if (!type || !mxmlGetFirstChild(type))\n    return (NULL);\n\n /*\n  * Create the variable/argument node...\n  */\n\n  variable = mxmlNewElement(parent, name);\n\n /*\n  * Check for a default value...\n  */\n\n  for (node = mxmlGetFirstChild(type); node; node = mxmlGetNextSibling(node))\n  {\n    string = mxmlGetText(node, &whitespace);\n\n    if (!strcmp(string, \"=\"))\n      break;\n  }\n\n  if (node)\n  {\n   /*\n    * Default value found, copy it and add as a \"default\" attribute...\n    */\n\n    for (bufptr = buffer; node; bufptr += strlen(bufptr))\n    {\n      string = mxmlGetText(node, &whitespace);\n\n      if (whitespace && bufptr > buffer && bufptr < (buffer + sizeof(buffer) - 1))\n\t*bufptr++ = ' ';\n\n      strlcpy(bufptr, string, sizeof(buffer) - (size_t)(bufptr - buffer));\n\n      next = mxmlGetNextSibling(node);\n      mxmlDelete(node);\n      node = next;\n    }\n\n    mxmlElementSetAttr(variable, \"default\", buffer);\n  }\n\n /*\n  * Extract the argument/variable name...\n  */\n\n  string = mxmlGetText(mxmlGetLastChild(type), &whitespace);\n\n  if (*string == ')')\n  {\n   /*\n    * Handle \"type (*name)(args)\"...\n    */\n\n    for (node = mxmlGetFirstChild(type); node; node = mxmlGetNextSibling(node))\n    {\n      string = mxmlGetText(node, &whitespace);\n      if (*string == '(')\n\tbreak;\n    }\n\n    for (bufptr = buffer; node; bufptr += strlen(bufptr))\n    {\n      string = mxmlGetText(node, &whitespace);\n\n      if (whitespace && bufptr > buffer)\n\t*bufptr++ = ' ';\n\n      strlcpy(bufptr, string, sizeof(buffer) - (size_t)(bufptr - buffer));\n\n      next = mxmlGetNextSibling(node);\n      mxmlDelete(node);\n      node = next;\n    }\n  }\n  else\n  {\n   /*\n    * Handle \"type name\"...\n    */\n\n    strlcpy(buffer, string, sizeof(buffer));\n    mxmlDelete(mxmlGetLastChild(type));\n  }\n\n /*\n  * Set the name...\n  */\n\n  mxmlElementSetAttr(variable, \"name\", buffer);\n\n /*\n  * Add the remaining type information to the variable node...\n  */\n\n  mxmlAdd(variable, MXML_ADD_AFTER, MXML_ADD_TO_PARENT, type);\n\n /*\n  * Add new new variable node...\n  */\n\n  return (variable);\n}",
    "abstract_func": "static mxml_node_t *\t\t\t/* COMMENT_0 */\nadd_variable(mxml_node_t *VAR_0,\t/* COMMENT_1 */\n             const char  *VAR_1,\t\t/* COMMENT_2 */\n             mxml_node_t *VAR_2)\t\t/* COMMENT_3 */\n{\n  mxml_node_t\t*VAR_3,\t\t/* COMMENT_4 */\n\t\t*VAR_4,\t\t\t/* COMMENT_5 */\n\t\t*VAR_5;\t\t\t/* COMMENT_6 */\n  char\t\tVAR_6[16384],\t\t/* COMMENT_7 */\n\t\t*VAR_7;\t\t/* COMMENT_8 */\n  int\t\tVAR_8 = 0;\t\t/* COMMENT_9 */\n  const char\t*VAR_9 = NULL;\t\t/* COMMENT_10 */\n\n\n  DEBUG_printf(\"add_variable(parent=%p, name=\\\"%s\\\", type=%p)\\n\", VAR_0, VAR_1, VAR_2);\n\n /* COMMENT_11 */\n                        \n    \n\n  if (!VAR_2 || !mxmlGetFirstChild(VAR_2))\n    return (NULL);\n\n /* COMMENT_14 */\n                                        \n    \n\n  VAR_3 = mxmlNewElement(VAR_0, VAR_1);\n\n /* COMMENT_17 */\n                                \n    \n\n  for (VAR_4 = mxmlGetFirstChild(VAR_2); VAR_4; VAR_4 = mxmlGetNextSibling(VAR_4))\n  {\n    VAR_9 = mxmlGetText(VAR_4, &VAR_8);\n\n    if (!strcmp(VAR_9, \"=\"))\n      break;\n  }\n\n  if (VAR_4)\n  {\n   /* COMMENT_20 */\n                                                                      \n      \n\n    for (VAR_7 = VAR_6; VAR_4; VAR_7 += strlen(VAR_7))\n    {\n      VAR_9 = mxmlGetText(VAR_4, &VAR_8);\n\n      if (VAR_8 && VAR_7 > VAR_6 && VAR_7 < (VAR_6 + sizeof(VAR_6) - 1))\n\t*VAR_7++ = ' ';\n\n      strlcpy(VAR_7, VAR_9, sizeof(VAR_6) - (size_t)(VAR_7 - VAR_6));\n\n      VAR_5 = mxmlGetNextSibling(VAR_4);\n      mxmlDelete(VAR_4);\n      VAR_4 = VAR_5;\n    }\n\n    mxmlElementSetAttr(VAR_3, \"default\", VAR_6);\n  }\n\n /* COMMENT_23 */\n                                         \n    \n\n  VAR_9 = mxmlGetText(mxmlGetLastChild(VAR_2), &VAR_8);\n\n  if (*VAR_9 == ')')\n  {\n   /* COMMENT_26 */\n                                    \n      \n\n    for (VAR_4 = mxmlGetFirstChild(VAR_2); VAR_4; VAR_4 = mxmlGetNextSibling(VAR_4))\n    {\n      VAR_9 = mxmlGetText(VAR_4, &VAR_8);\n      if (*VAR_9 == '(')\n\tbreak;\n    }\n\n    for (VAR_7 = VAR_6; VAR_4; VAR_7 += strlen(VAR_7))\n    {\n      VAR_9 = mxmlGetText(VAR_4, &VAR_8);\n\n      if (VAR_8 && VAR_7 > VAR_6)\n\t*VAR_7++ = ' ';\n\n      strlcpy(VAR_7, VAR_9, sizeof(VAR_6) - (size_t)(VAR_7 - VAR_6));\n\n      VAR_5 = mxmlGetNextSibling(VAR_4);\n      mxmlDelete(VAR_4);\n      VAR_4 = VAR_5;\n    }\n  }\n  else\n  {\n   /* COMMENT_29 */\n                           \n      \n\n    strlcpy(VAR_6, VAR_9, sizeof(VAR_6));\n    mxmlDelete(mxmlGetLastChild(VAR_2));\n  }\n\n /* COMMENT_32 */\n                   \n    \n\n  mxmlElementSetAttr(VAR_3, \"name\", VAR_6);\n\n /* COMMENT_35 */\n                                                              \n    \n\n  mxmlAdd(VAR_3, VAR_10, VAR_11, VAR_2);\n\n /* COMMENT_38 */\n                                \n    \n\n  return (VAR_3);\n}",
    "func_graph_path": "michaelrsweet/codedoc/19532db97af1eccb1ed74b7ea4c41eb822ae9964/codedoc.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n     {\n       string = mxmlGetText(node, &whitespace);\n \n-      if (whitespace && bufptr > buffer)\n+      if (whitespace && bufptr > buffer && bufptr < (buffer + sizeof(buffer) - 1))\n \t*bufptr++ = ' ';\n \n       strlcpy(bufptr, string, sizeof(buffer) - (size_t)(bufptr - buffer));",
    "diff_line_info": {
        "deleted_lines": [
            "      if (whitespace && bufptr > buffer)"
        ],
        "added_lines": [
            "      if (whitespace && bufptr > buffer && bufptr < (buffer + sizeof(buffer) - 1))"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}