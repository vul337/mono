{
    "cve_id": "CVE-2010-2962",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "Move the access control up from the fast paths, which are no longer\nuniversally taken first, up into the caller. This then duplicates some\nsanity checking along the slow paths, but is much simpler.\nTracked as CVE-2010-2962.\n\nReported-by: Kees Cook <kees@ubuntu.com>\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@kernel.org\n",
    "commit_hash": "ce9d419dbecc292cc3e06e8b1d6d123d3fa813a4",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=ce9d419dbecc292cc3e06e8b1d6d123d3fa813a4",
    "file_path": "drivers/gpu/drm/i915/i915_gem.c",
    "func_name": "i915_gem_pwrite_ioctl",
    "func_before": "int\ni915_gem_pwrite_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_i915_gem_pwrite *args = data;\n\tstruct drm_gem_object *obj;\n\tstruct drm_i915_gem_object *obj_priv;\n\tint ret = 0;\n\n\tobj = drm_gem_object_lookup(dev, file_priv, args->handle);\n\tif (obj == NULL)\n\t\treturn -ENOENT;\n\tobj_priv = to_intel_bo(obj);\n\n\t/* Bounds check destination.\n\t *\n\t * XXX: This could use review for overflow issues...\n\t */\n\tif (args->offset > obj->size || args->size > obj->size ||\n\t    args->offset + args->size > obj->size) {\n\t\tdrm_gem_object_unreference_unlocked(obj);\n\t\treturn -EINVAL;\n\t}\n\n\t/* We can only do the GTT pwrite on untiled buffers, as otherwise\n\t * it would end up going through the fenced access, and we'll get\n\t * different detiling behavior between reading and writing.\n\t * pread/pwrite currently are reading and writing from the CPU\n\t * perspective, requiring manual detiling by the client.\n\t */\n\tif (obj_priv->phys_obj)\n\t\tret = i915_gem_phys_pwrite(dev, obj, args, file_priv);\n\telse if (obj_priv->tiling_mode == I915_TILING_NONE &&\n\t\t dev->gtt_total != 0 &&\n\t\t obj->write_domain != I915_GEM_DOMAIN_CPU) {\n\t\tret = i915_gem_gtt_pwrite_fast(dev, obj, args, file_priv);\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_gtt_pwrite_slow(dev, obj, args,\n\t\t\t\t\t\t       file_priv);\n\t\t}\n\t} else if (i915_gem_object_needs_bit17_swizzle(obj)) {\n\t\tret = i915_gem_shmem_pwrite_slow(dev, obj, args, file_priv);\n\t} else {\n\t\tret = i915_gem_shmem_pwrite_fast(dev, obj, args, file_priv);\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_shmem_pwrite_slow(dev, obj, args,\n\t\t\t\t\t\t\t file_priv);\n\t\t}\n\t}\n\n#if WATCH_PWRITE\n\tif (ret)\n\t\tDRM_INFO(\"pwrite failed %d\\n\", ret);\n#endif\n\n\tdrm_gem_object_unreference_unlocked(obj);\n\n\treturn ret;\n}",
    "abstract_func_before": "int\ni915_gem_pwrite_ioctl(struct drm_device *VAR_0, void *VAR_1,\n\t\t      struct drm_file *VAR_2)\n{\n\tstruct drm_i915_gem_pwrite *VAR_3 = VAR_1;\n\tstruct drm_gem_object *VAR_4;\n\tstruct drm_i915_gem_object *VAR_5;\n\tint VAR_6 = 0;\n\n\tVAR_4 = drm_gem_object_lookup(VAR_0, VAR_2, VAR_3->handle);\n\tif (VAR_4 == NULL)\n\t\treturn -VAR_7;\n\tVAR_5 = to_intel_bo(VAR_4);\n\n\t/* COMMENT_0 */\n   \n                                                     \n    \n\tif (VAR_3->offset > VAR_4->size || VAR_3->size > VAR_4->size ||\n\t    VAR_3->offset + VAR_3->size > VAR_4->size) {\n\t\tdrm_gem_object_unreference_unlocked(VAR_4);\n\t\treturn -VAR_8;\n\t}\n\n\t/* COMMENT_4 */\n                                                                  \n                                                            \n                                                               \n                                                         \n    \n\tif (VAR_5->phys_obj)\n\t\tVAR_6 = i915_gem_phys_pwrite(VAR_0, VAR_4, VAR_3, VAR_2);\n\telse if (VAR_5->tiling_mode == VAR_9 &&\n\t\t VAR_0->gtt_total != 0 &&\n\t\t VAR_4->write_domain != VAR_10) {\n\t\tVAR_6 = i915_gem_gtt_pwrite_fast(VAR_0, VAR_4, VAR_3, VAR_2);\n\t\tif (VAR_6 == -VAR_11) {\n\t\t\tVAR_6 = i915_gem_gtt_pwrite_slow(VAR_0, VAR_4, VAR_3,\n\t\t\t\t\t\t       VAR_2);\n\t\t}\n\t} else if (i915_gem_object_needs_bit17_swizzle(VAR_4)) {\n\t\tVAR_6 = i915_gem_shmem_pwrite_slow(VAR_0, VAR_4, VAR_3, VAR_2);\n\t} else {\n\t\tVAR_6 = i915_gem_shmem_pwrite_fast(VAR_0, VAR_4, VAR_3, VAR_2);\n\t\tif (VAR_6 == -VAR_11) {\n\t\t\tVAR_6 = i915_gem_shmem_pwrite_slow(VAR_0, VAR_4, VAR_3,\n\t\t\t\t\t\t\t VAR_2);\n\t\t}\n\t}\n\n#if VAR_12\n\tif (VAR_6)\n\t\tDRM_INFO(\"pwrite failed %d\\n\", VAR_6);\n#endif\n\n\tdrm_gem_object_unreference_unlocked(VAR_4);\n\n\treturn VAR_6;\n}",
    "func_graph_path_before": "torvalds/linux/ce9d419dbecc292cc3e06e8b1d6d123d3fa813a4/i915_gem.c/vul/before/0.json",
    "func": "int\ni915_gem_pwrite_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_i915_gem_pwrite *args = data;\n\tstruct drm_gem_object *obj;\n\tstruct drm_i915_gem_object *obj_priv;\n\tint ret = 0;\n\n\tobj = drm_gem_object_lookup(dev, file_priv, args->handle);\n\tif (obj == NULL)\n\t\treturn -ENOENT;\n\tobj_priv = to_intel_bo(obj);\n\n\t/* Bounds check destination.\n\t *\n\t * XXX: This could use review for overflow issues...\n\t */\n\tif (args->offset > obj->size || args->size > obj->size ||\n\t    args->offset + args->size > obj->size) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (!access_ok(VERIFY_READ,\n\t\t       (char __user *)(uintptr_t)args->data_ptr,\n\t\t       args->size)) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\t/* We can only do the GTT pwrite on untiled buffers, as otherwise\n\t * it would end up going through the fenced access, and we'll get\n\t * different detiling behavior between reading and writing.\n\t * pread/pwrite currently are reading and writing from the CPU\n\t * perspective, requiring manual detiling by the client.\n\t */\n\tif (obj_priv->phys_obj)\n\t\tret = i915_gem_phys_pwrite(dev, obj, args, file_priv);\n\telse if (obj_priv->tiling_mode == I915_TILING_NONE &&\n\t\t dev->gtt_total != 0 &&\n\t\t obj->write_domain != I915_GEM_DOMAIN_CPU) {\n\t\tret = i915_gem_gtt_pwrite_fast(dev, obj, args, file_priv);\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_gtt_pwrite_slow(dev, obj, args,\n\t\t\t\t\t\t       file_priv);\n\t\t}\n\t} else if (i915_gem_object_needs_bit17_swizzle(obj)) {\n\t\tret = i915_gem_shmem_pwrite_slow(dev, obj, args, file_priv);\n\t} else {\n\t\tret = i915_gem_shmem_pwrite_fast(dev, obj, args, file_priv);\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_shmem_pwrite_slow(dev, obj, args,\n\t\t\t\t\t\t\t file_priv);\n\t\t}\n\t}\n\n#if WATCH_PWRITE\n\tif (ret)\n\t\tDRM_INFO(\"pwrite failed %d\\n\", ret);\n#endif\n\nerr:\n\tdrm_gem_object_unreference_unlocked(obj);\n\treturn ret;\n}",
    "abstract_func": "int\ni915_gem_pwrite_ioctl(struct drm_device *VAR_0, void *VAR_1,\n\t\t      struct drm_file *VAR_2)\n{\n\tstruct drm_i915_gem_pwrite *VAR_3 = VAR_1;\n\tstruct drm_gem_object *VAR_4;\n\tstruct drm_i915_gem_object *VAR_5;\n\tint VAR_6 = 0;\n\n\tVAR_4 = drm_gem_object_lookup(VAR_0, VAR_2, VAR_3->handle);\n\tif (VAR_4 == NULL)\n\t\treturn -VAR_7;\n\tVAR_5 = to_intel_bo(VAR_4);\n\n\t/* COMMENT_0 */\n   \n                                                     \n    \n\tif (VAR_3->offset > VAR_4->size || VAR_3->size > VAR_4->size ||\n\t    VAR_3->offset + VAR_3->size > VAR_4->size) {\n\t\tVAR_6 = -VAR_8;\n\t\tgoto err;\n\t}\n\n\tif (!access_ok(VAR_9,\n\t\t       (char __user *)(uintptr_t)VAR_3->data_ptr,\n\t\t       VAR_3->size)) {\n\t\tVAR_6 = -VAR_10;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_4 */\n                                                                  \n                                                            \n                                                               \n                                                         \n    \n\tif (VAR_5->phys_obj)\n\t\tVAR_6 = i915_gem_phys_pwrite(VAR_0, VAR_4, VAR_3, VAR_2);\n\telse if (VAR_5->tiling_mode == VAR_11 &&\n\t\t VAR_0->gtt_total != 0 &&\n\t\t VAR_4->write_domain != VAR_12) {\n\t\tVAR_6 = i915_gem_gtt_pwrite_fast(VAR_0, VAR_4, VAR_3, VAR_2);\n\t\tif (VAR_6 == -VAR_10) {\n\t\t\tVAR_6 = i915_gem_gtt_pwrite_slow(VAR_0, VAR_4, VAR_3,\n\t\t\t\t\t\t       VAR_2);\n\t\t}\n\t} else if (i915_gem_object_needs_bit17_swizzle(VAR_4)) {\n\t\tVAR_6 = i915_gem_shmem_pwrite_slow(VAR_0, VAR_4, VAR_3, VAR_2);\n\t} else {\n\t\tVAR_6 = i915_gem_shmem_pwrite_fast(VAR_0, VAR_4, VAR_3, VAR_2);\n\t\tif (VAR_6 == -VAR_10) {\n\t\t\tVAR_6 = i915_gem_shmem_pwrite_slow(VAR_0, VAR_4, VAR_3,\n\t\t\t\t\t\t\t VAR_2);\n\t\t}\n\t}\n\n#if VAR_13\n\tif (VAR_6)\n\t\tDRM_INFO(\"pwrite failed %d\\n\", VAR_6);\n#endif\n\nerr:\n\tdrm_gem_object_unreference_unlocked(VAR_4);\n\treturn VAR_6;\n}",
    "func_graph_path": "torvalds/linux/ce9d419dbecc292cc3e06e8b1d6d123d3fa813a4/i915_gem.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -18,8 +18,15 @@\n \t */\n \tif (args->offset > obj->size || args->size > obj->size ||\n \t    args->offset + args->size > obj->size) {\n-\t\tdrm_gem_object_unreference_unlocked(obj);\n-\t\treturn -EINVAL;\n+\t\tret = -EINVAL;\n+\t\tgoto err;\n+\t}\n+\n+\tif (!access_ok(VERIFY_READ,\n+\t\t       (char __user *)(uintptr_t)args->data_ptr,\n+\t\t       args->size)) {\n+\t\tret = -EFAULT;\n+\t\tgoto err;\n \t}\n \n \t/* We can only do the GTT pwrite on untiled buffers, as otherwise\n@@ -53,7 +60,7 @@\n \t\tDRM_INFO(\"pwrite failed %d\\n\", ret);\n #endif\n \n+err:\n \tdrm_gem_object_unreference_unlocked(obj);\n-\n \treturn ret;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\t\tdrm_gem_object_unreference_unlocked(obj);",
            "\t\treturn -EINVAL;",
            ""
        ],
        "added_lines": [
            "\t\tret = -EINVAL;",
            "\t\tgoto err;",
            "\t}",
            "",
            "\tif (!access_ok(VERIFY_READ,",
            "\t\t       (char __user *)(uintptr_t)args->data_ptr,",
            "\t\t       args->size)) {",
            "\t\tret = -EFAULT;",
            "\t\tgoto err;",
            "err:"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}