{
    "cve_id": "CVE-2019-18282",
    "cwe_ids": [
        "CWE-330"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "UDP IPv6 packets auto flowlabels are using a 32bit secret\n(static u32 hashrnd in net/core/flow_dissector.c) and\napply jhash() over fields known by the receivers.\n\nAttackers can easily infer the 32bit secret and use this information\nto identify a device and/or user, since this 32bit secret is only\nset at boot time.\n\nReally, using jhash() to generate cookies sent on the wire\nis a serious security concern.\n\nTrying to change the rol32(hash, 16) in ip6_make_flowlabel() would be\na dead end. Trying to periodically change the secret (like in sch_sfq.c)\ncould change paths taken in the network for long lived flows.\n\nLet's switch to siphash, as we did in commit df453700e8d8\n(\"inet: switch IP ID generator to siphash\")\n\nUsing a cryptographically strong pseudo random function will solve this\nprivacy issue and more generally remove other weak points in the stack.\n\nPacket schedulers using skb_get_hash_perturb() benefit from this change.\n\nFixes: b56774163f99 (\"ipv6: Enable auto flow labels by default\")\nFixes: 42240901f7c4 (\"ipv6: Implement different admin modes for automatic flow labels\")\nFixes: 67800f9b1f4e (\"ipv6: Call skb_get_hash_flowi6 to get skb->hash in ip6_make_flowlabel\")\nFixes: cb1ce2ef387b (\"ipv6: Implement automatic flow label generation on transmit\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Jonathan Berger <jonathann1@walla.com>\nReported-by: Amit Klein <aksecurity@gmail.com>\nReported-by: Benny Pinkas <benny@pinkas.net>\nCc: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n",
    "commit_hash": "55667441c84fa5e0911a0aac44fb059c15ba6da2",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
    "file_path": "net/core/flow_dissector.c",
    "func_name": "flow_hash_from_keys",
    "func_before": "u32 flow_hash_from_keys(struct flow_keys *keys)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(keys, hashrnd);\n}",
    "abstract_func_before": "u32 flow_hash_from_keys(struct flow_keys *VAR_0)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(VAR_0, VAR_1);\n}",
    "func_graph_path_before": "torvalds/linux/55667441c84fa5e0911a0aac44fb059c15ba6da2/flow_dissector.c/vul/before/4.json",
    "func": "u32 flow_hash_from_keys(struct flow_keys *keys)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(keys, &hashrnd);\n}",
    "abstract_func": "u32 flow_hash_from_keys(struct flow_keys *VAR_0)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(VAR_0, &VAR_1);\n}",
    "func_graph_path": "torvalds/linux/55667441c84fa5e0911a0aac44fb059c15ba6da2/flow_dissector.c/vul/after/4.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n u32 flow_hash_from_keys(struct flow_keys *keys)\n {\n \t__flow_hash_secret_init();\n-\treturn __flow_hash_from_keys(keys, hashrnd);\n+\treturn __flow_hash_from_keys(keys, &hashrnd);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\treturn __flow_hash_from_keys(keys, hashrnd);"
        ],
        "added_lines": [
            "\treturn __flow_hash_from_keys(keys, &hashrnd);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}