{
    "cve_id": "CVE-2023-46813",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "A virt scenario can be constructed where MMIO memory can be user memory.\nWhen that happens, a race condition opens between when the hardware\nraises the #VC and when the #VC handler gets to emulate the instruction.\n\nIf the MOVS is replaced with a MOVS accessing kernel memory in that\nsmall race window, then write to kernel memory happens as the access\nchecks are not done at emulation time.\n\nDisable MMIO emulation in user mode temporarily until a sensible use\ncase appears and justifies properly handling the race window.\n\nFixes: 0118b604c2c9 (\"x86/sev-es: Handle MMIO String Instructions\")\nReported-by: Tom Dohrmann <erbse.13@gmx.de>\nSigned-off-by: Borislav Petkov (AMD) <bp@alien8.de>\nTested-by: Tom Dohrmann <erbse.13@gmx.de>\nCc: <stable@kernel.org>\n",
    "commit_hash": "a37cd2a59d0cb270b1bba568fd3a3b8668b9d3ba",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a37cd2a59d0cb270b1bba568fd3a3b8668b9d3ba",
    "file_path": "arch/x86/kernel/sev.c",
    "func_name": "vc_handle_mmio",
    "func_before": "static enum es_result vc_handle_mmio(struct ghcb *ghcb, struct es_em_ctxt *ctxt)\n{\n\tstruct insn *insn = &ctxt->insn;\n\tenum insn_mmio_type mmio;\n\tunsigned int bytes = 0;\n\tenum es_result ret;\n\tu8 sign_byte;\n\tlong *reg_data;\n\n\tmmio = insn_decode_mmio(insn, &bytes);\n\tif (mmio == INSN_MMIO_DECODE_FAILED)\n\t\treturn ES_DECODE_FAILED;\n\n\tif (mmio != INSN_MMIO_WRITE_IMM && mmio != INSN_MMIO_MOVS) {\n\t\treg_data = insn_get_modrm_reg_ptr(insn, ctxt->regs);\n\t\tif (!reg_data)\n\t\t\treturn ES_DECODE_FAILED;\n\t}\n\n\tswitch (mmio) {\n\tcase INSN_MMIO_WRITE:\n\t\tmemcpy(ghcb->shared_buffer, reg_data, bytes);\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, false);\n\t\tbreak;\n\tcase INSN_MMIO_WRITE_IMM:\n\t\tmemcpy(ghcb->shared_buffer, insn->immediate1.bytes, bytes);\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, false);\n\t\tbreak;\n\tcase INSN_MMIO_READ:\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, true);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* Zero-extend for 32-bit operation */\n\t\tif (bytes == 4)\n\t\t\t*reg_data = 0;\n\n\t\tmemcpy(reg_data, ghcb->shared_buffer, bytes);\n\t\tbreak;\n\tcase INSN_MMIO_READ_ZERO_EXTEND:\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, true);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* Zero extend based on operand size */\n\t\tmemset(reg_data, 0, insn->opnd_bytes);\n\t\tmemcpy(reg_data, ghcb->shared_buffer, bytes);\n\t\tbreak;\n\tcase INSN_MMIO_READ_SIGN_EXTEND:\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, true);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (bytes == 1) {\n\t\t\tu8 *val = (u8 *)ghcb->shared_buffer;\n\n\t\t\tsign_byte = (*val & 0x80) ? 0xff : 0x00;\n\t\t} else {\n\t\t\tu16 *val = (u16 *)ghcb->shared_buffer;\n\n\t\t\tsign_byte = (*val & 0x8000) ? 0xff : 0x00;\n\t\t}\n\n\t\t/* Sign extend based on operand size */\n\t\tmemset(reg_data, sign_byte, insn->opnd_bytes);\n\t\tmemcpy(reg_data, ghcb->shared_buffer, bytes);\n\t\tbreak;\n\tcase INSN_MMIO_MOVS:\n\t\tret = vc_handle_mmio_movs(ctxt, bytes);\n\t\tbreak;\n\tdefault:\n\t\tret = ES_UNSUPPORTED;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "abstract_func_before": "static enum es_result vc_handle_mmio(struct ghcb *ghcb, struct es_em_ctxt *VAR_0)\n{\n\tstruct insn *insn = &VAR_0->insn;\n\tenum insn_mmio_type VAR_1;\n\tunsigned int VAR_2 = 0;\n\tenum es_result VAR_3;\n\tu8 VAR_4;\n\tlong *VAR_5;\n\n\tVAR_1 = insn_decode_mmio(insn, &VAR_2);\n\tif (VAR_1 == VAR_6)\n\t\treturn VAR_7;\n\n\tif (VAR_1 != VAR_8 && VAR_1 != VAR_9) {\n\t\tVAR_5 = insn_get_modrm_reg_ptr(insn, VAR_0->regs);\n\t\tif (!VAR_5)\n\t\t\treturn VAR_7;\n\t}\n\n\tswitch (VAR_1) {\n\tcase VAR_10:\n\t\tmemcpy(ghcb->shared_buffer, VAR_5, VAR_2);\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, false);\n\t\tbreak;\n\tcase VAR_8:\n\t\tmemcpy(ghcb->shared_buffer, insn->immediate1.bytes, VAR_2);\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, false);\n\t\tbreak;\n\tcase VAR_11:\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, true);\n\t\tif (VAR_3)\n\t\t\tbreak;\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_2 == 4)\n\t\t\t*VAR_5 = 0;\n\n\t\tmemcpy(VAR_5, ghcb->shared_buffer, VAR_2);\n\t\tbreak;\n\tcase VAR_12:\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, true);\n\t\tif (VAR_3)\n\t\t\tbreak;\n\n\t\t/* COMMENT_1 */\n\t\tmemset(VAR_5, 0, insn->opnd_bytes);\n\t\tmemcpy(VAR_5, ghcb->shared_buffer, VAR_2);\n\t\tbreak;\n\tcase VAR_13:\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, true);\n\t\tif (VAR_3)\n\t\t\tbreak;\n\n\t\tif (VAR_2 == 1) {\n\t\t\tu8 *VAR_14 = (u8 *)ghcb->shared_buffer;\n\n\t\t\tVAR_4 = (*VAR_14 & 0x80) ? 0xff : 0x00;\n\t\t} else {\n\t\t\tu16 *VAR_14 = (u16 *)ghcb->shared_buffer;\n\n\t\t\tVAR_4 = (*VAR_14 & 0x8000) ? 0xff : 0x00;\n\t\t}\n\n\t\t/* COMMENT_2 */\n\t\tmemset(VAR_5, VAR_4, insn->opnd_bytes);\n\t\tmemcpy(VAR_5, ghcb->shared_buffer, VAR_2);\n\t\tbreak;\n\tcase VAR_9:\n\t\tVAR_3 = vc_handle_mmio_movs(VAR_0, VAR_2);\n\t\tbreak;\n\tdefault:\n\t\tVAR_3 = VAR_15;\n\t\tbreak;\n\t}\n\n\treturn VAR_3;\n}",
    "func_graph_path_before": "torvalds/linux/a37cd2a59d0cb270b1bba568fd3a3b8668b9d3ba/sev.c/vul/before/0.json",
    "func": "static enum es_result vc_handle_mmio(struct ghcb *ghcb, struct es_em_ctxt *ctxt)\n{\n\tstruct insn *insn = &ctxt->insn;\n\tenum insn_mmio_type mmio;\n\tunsigned int bytes = 0;\n\tenum es_result ret;\n\tu8 sign_byte;\n\tlong *reg_data;\n\n\tmmio = insn_decode_mmio(insn, &bytes);\n\tif (mmio == INSN_MMIO_DECODE_FAILED)\n\t\treturn ES_DECODE_FAILED;\n\n\tif (mmio != INSN_MMIO_WRITE_IMM && mmio != INSN_MMIO_MOVS) {\n\t\treg_data = insn_get_modrm_reg_ptr(insn, ctxt->regs);\n\t\tif (!reg_data)\n\t\t\treturn ES_DECODE_FAILED;\n\t}\n\n\tif (user_mode(ctxt->regs))\n\t\treturn ES_UNSUPPORTED;\n\n\tswitch (mmio) {\n\tcase INSN_MMIO_WRITE:\n\t\tmemcpy(ghcb->shared_buffer, reg_data, bytes);\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, false);\n\t\tbreak;\n\tcase INSN_MMIO_WRITE_IMM:\n\t\tmemcpy(ghcb->shared_buffer, insn->immediate1.bytes, bytes);\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, false);\n\t\tbreak;\n\tcase INSN_MMIO_READ:\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, true);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* Zero-extend for 32-bit operation */\n\t\tif (bytes == 4)\n\t\t\t*reg_data = 0;\n\n\t\tmemcpy(reg_data, ghcb->shared_buffer, bytes);\n\t\tbreak;\n\tcase INSN_MMIO_READ_ZERO_EXTEND:\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, true);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* Zero extend based on operand size */\n\t\tmemset(reg_data, 0, insn->opnd_bytes);\n\t\tmemcpy(reg_data, ghcb->shared_buffer, bytes);\n\t\tbreak;\n\tcase INSN_MMIO_READ_SIGN_EXTEND:\n\t\tret = vc_do_mmio(ghcb, ctxt, bytes, true);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (bytes == 1) {\n\t\t\tu8 *val = (u8 *)ghcb->shared_buffer;\n\n\t\t\tsign_byte = (*val & 0x80) ? 0xff : 0x00;\n\t\t} else {\n\t\t\tu16 *val = (u16 *)ghcb->shared_buffer;\n\n\t\t\tsign_byte = (*val & 0x8000) ? 0xff : 0x00;\n\t\t}\n\n\t\t/* Sign extend based on operand size */\n\t\tmemset(reg_data, sign_byte, insn->opnd_bytes);\n\t\tmemcpy(reg_data, ghcb->shared_buffer, bytes);\n\t\tbreak;\n\tcase INSN_MMIO_MOVS:\n\t\tret = vc_handle_mmio_movs(ctxt, bytes);\n\t\tbreak;\n\tdefault:\n\t\tret = ES_UNSUPPORTED;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "abstract_func": "static enum es_result vc_handle_mmio(struct ghcb *ghcb, struct es_em_ctxt *VAR_0)\n{\n\tstruct insn *insn = &VAR_0->insn;\n\tenum insn_mmio_type VAR_1;\n\tunsigned int VAR_2 = 0;\n\tenum es_result VAR_3;\n\tu8 VAR_4;\n\tlong *VAR_5;\n\n\tVAR_1 = insn_decode_mmio(insn, &VAR_2);\n\tif (VAR_1 == VAR_6)\n\t\treturn VAR_7;\n\n\tif (VAR_1 != VAR_8 && VAR_1 != VAR_9) {\n\t\tVAR_5 = insn_get_modrm_reg_ptr(insn, VAR_0->regs);\n\t\tif (!VAR_5)\n\t\t\treturn VAR_7;\n\t}\n\n\tif (user_mode(VAR_0->regs))\n\t\treturn VAR_10;\n\n\tswitch (VAR_1) {\n\tcase VAR_11:\n\t\tmemcpy(ghcb->shared_buffer, VAR_5, VAR_2);\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, false);\n\t\tbreak;\n\tcase VAR_8:\n\t\tmemcpy(ghcb->shared_buffer, insn->immediate1.bytes, VAR_2);\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, false);\n\t\tbreak;\n\tcase VAR_12:\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, true);\n\t\tif (VAR_3)\n\t\t\tbreak;\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_2 == 4)\n\t\t\t*VAR_5 = 0;\n\n\t\tmemcpy(VAR_5, ghcb->shared_buffer, VAR_2);\n\t\tbreak;\n\tcase VAR_13:\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, true);\n\t\tif (VAR_3)\n\t\t\tbreak;\n\n\t\t/* COMMENT_1 */\n\t\tmemset(VAR_5, 0, insn->opnd_bytes);\n\t\tmemcpy(VAR_5, ghcb->shared_buffer, VAR_2);\n\t\tbreak;\n\tcase VAR_14:\n\t\tVAR_3 = vc_do_mmio(ghcb, VAR_0, VAR_2, true);\n\t\tif (VAR_3)\n\t\t\tbreak;\n\n\t\tif (VAR_2 == 1) {\n\t\t\tu8 *VAR_15 = (u8 *)ghcb->shared_buffer;\n\n\t\t\tVAR_4 = (*VAR_15 & 0x80) ? 0xff : 0x00;\n\t\t} else {\n\t\t\tu16 *VAR_15 = (u16 *)ghcb->shared_buffer;\n\n\t\t\tVAR_4 = (*VAR_15 & 0x8000) ? 0xff : 0x00;\n\t\t}\n\n\t\t/* COMMENT_2 */\n\t\tmemset(VAR_5, VAR_4, insn->opnd_bytes);\n\t\tmemcpy(VAR_5, ghcb->shared_buffer, VAR_2);\n\t\tbreak;\n\tcase VAR_9:\n\t\tVAR_3 = vc_handle_mmio_movs(VAR_0, VAR_2);\n\t\tbreak;\n\tdefault:\n\t\tVAR_3 = VAR_10;\n\t\tbreak;\n\t}\n\n\treturn VAR_3;\n}",
    "func_graph_path": "torvalds/linux/a37cd2a59d0cb270b1bba568fd3a3b8668b9d3ba/sev.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,9 @@\n \t\tif (!reg_data)\n \t\t\treturn ES_DECODE_FAILED;\n \t}\n+\n+\tif (user_mode(ctxt->regs))\n+\t\treturn ES_UNSUPPORTED;\n \n \tswitch (mmio) {\n \tcase INSN_MMIO_WRITE:",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "",
            "\tif (user_mode(ctxt->regs))",
            "\t\treturn ES_UNSUPPORTED;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}