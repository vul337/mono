{
    "cve_id": "CVE-2022-24792",
    "cwe_ids": [
        "CWE-835"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "pjsip/pjproject",
    "commit_msg": "Merge pull request from GHSA-rwgw-vwxg-q799\n\n* Prevent potential infinite loop when parsing WAV format file\n\n* Check if subchunk is negative.\n\n* Fix and add checks\n\n* Change data type from pj_ssize_t to long.\n\n* Modify check\n\n* Fix leak file descriptor and modify check on wav_playlist\n\n* Move overflow/underflow check to pj_file_setpos()\n\n* Use macro to simplify check\n\n* modification based on comments\n\n* Remove unnecessary casting\n\n* Modification based on comments",
    "commit_hash": "947bc1ee6d05be10204b918df75a503415fd3213",
    "git_url": "https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213",
    "file_path": "pjmedia/src/pjmedia/avi_player.c",
    "func_name": "pjmedia_avi_player_create_streams",
    "func_before": "PJ_DEF(pj_status_t)\npjmedia_avi_player_create_streams(pj_pool_t *pool,\n                                  const char *filename,\n\t\t\t\t  unsigned options,\n\t\t\t\t  pjmedia_avi_streams **p_streams)\n{\n    pjmedia_avi_hdr avi_hdr;\n    struct avi_reader_port *fport[PJMEDIA_AVI_MAX_NUM_STREAMS];\n    pj_off_t pos;\n    unsigned i, nstr = 0;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_streams, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Create fport instance. */\n    fport[0] = create_avi_port(pool);\n    if (!fport[0]) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Get the file size. */\n    fport[0]->fsize = pj_file_size(filename);\n\n    /* Size must be more than AVI header size */\n    if (fport[0]->fsize <= sizeof(riff_hdr_t) + sizeof(avih_hdr_t) + \n                           sizeof(strl_hdr_t))\n    {\n\treturn PJMEDIA_EINVALIMEDIATYPE;\n    }\n\n    /* Open file. */\n    status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[0]->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the RIFF + AVIH header. */\n    status = file_read(fport[0]->fd, &avi_hdr,\n                       sizeof(riff_hdr_t) + sizeof(avih_hdr_t));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Validate AVI file. */\n    if (!COMPARE_TAG(avi_hdr.riff_hdr.riff, PJMEDIA_AVI_RIFF_TAG) ||\n\t!COMPARE_TAG(avi_hdr.riff_hdr.avi, PJMEDIA_AVI_AVI_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.list_tag, PJMEDIA_AVI_LIST_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.hdrl_tag, PJMEDIA_AVI_HDRL_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.avih, PJMEDIA_AVI_AVIH_TAG))\n    {\n\tstatus = PJMEDIA_EINVALIMEDIATYPE;\n        goto on_error;\n    }\n\n    PJ_LOG(5, (THIS_FILE, \"The AVI file has %d streams.\",\n               avi_hdr.avih_hdr.num_streams));\n\n    /* Unsupported AVI format. */\n    if (avi_hdr.avih_hdr.num_streams > PJMEDIA_AVI_MAX_NUM_STREAMS) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    /** \n     * TODO: Possibly unsupported AVI format.\n     * If you encounter this warning, verify whether the avi player\n     * is working properly.\n     */\n    if (avi_hdr.avih_hdr.flags & AVIF_MUSTUSEINDEX ||\n        avi_hdr.avih_hdr.pad > 1)\n    {\n        PJ_LOG(3, (THIS_FILE, \"Warning!!! Possibly unsupported AVI format: \"\n                   \"flags:%d, pad:%d\", avi_hdr.avih_hdr.flags, \n                   avi_hdr.avih_hdr.pad));\n    }\n\n    /* Read the headers of each stream. */\n    for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n        pj_size_t elem = 0;\n        pj_ssize_t size_to_read;\n\n        /* Read strl header */\n        status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n                           sizeof(strl_hdr_t));\n        if (status != PJ_SUCCESS)\n            goto on_error;\n        \n        elem = COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_VIDS_TAG) ? \n               sizeof(strf_video_hdr_t) :\n               COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_AUDS_TAG) ?\n               sizeof(strf_audio_hdr_t) : 0;\n\n        /* Read strf header */\n        status = file_read2(fport[0]->fd, &avi_hdr.strf_hdr[i],\n                            elem, 0);\n        if (status != PJ_SUCCESS)\n            goto on_error;\n\n        /* Normalize the endian */\n        if (elem == sizeof(strf_video_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_video_hdr_sizes)/\n                          sizeof(strf_video_hdr_sizes[0]),\n                          strf_video_hdr_sizes);\n        else if (elem == sizeof(strf_audio_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_audio_hdr_sizes)/\n                          sizeof(strf_audio_hdr_sizes[0]),\n                          strf_audio_hdr_sizes);\n\n        /* Skip the remainder of the header */\n        size_to_read = avi_hdr.strl_hdr[i].list_sz - (sizeof(strl_hdr_t) -\n                       8) - elem;\n\tstatus = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n            goto on_error;\n\t}\n    }\n\n    /* Finish reading the AVIH header */\n    status = pj_file_setpos(fport[0]->fd, avi_hdr.avih_hdr.list_sz +\n                            sizeof(riff_hdr_t) + 8, PJ_SEEK_SET);\n    if (status != PJ_SUCCESS) {\n        goto on_error;\n    }\n\n    /* Skip any JUNK or LIST INFO until we get MOVI tag */\n    do {\n        pjmedia_avi_subchunk ch;\n        int read = 0;\n\n        status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n\n        if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n        {\n            read = 4;\n            status = file_read(fport[0]->fd, &ch, read);\n            if (COMPARE_TAG(ch.id, PJMEDIA_AVI_MOVI_TAG))\n                break;\n        }\n\n        status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n    } while(1);\n\n    status = pj_file_getpos(fport[0]->fd, &pos);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    for (i = 0, nstr = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n\tpjmedia_format_id fmt_id;\n\n        /* Skip non-audio, non-video, or disabled streams) */\n        if ((!COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_VIDS_TAG) &&\n             !COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_AUDS_TAG)) ||\n            avi_hdr.strl_hdr[i].flags & AVISF_DISABLED)\n        {\n            continue;\n        }\n\n        if (COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                        PJMEDIA_AVI_VIDS_TAG))\n        {\n            int j;\n\n            if (avi_hdr.strl_hdr[i].flags & AVISF_VIDEO_PALCHANGES) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n\n            fmt_id = avi_hdr.strl_hdr[i].codec;\n            for (j = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; j >= 0; j--) {\n                /* Check supported video formats here */\n                if (fmt_id == avi_fmts[j].fmt_id) {\n                    if (avi_fmts[j].eff_fmt_id)\n                        fmt_id = avi_fmts[j].eff_fmt_id;\n                    break;\n                }\n            }\n            \n            if (j < 0) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n        } else {\n            /* Check supported audio formats here */\n\t    strf_audio_hdr_t *hdr = (strf_audio_hdr_t*)\n\t\t\t\t    &avi_hdr.strf_hdr[i].strf_audio_hdr;\n            if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM &&\n\t\thdr->bits_per_sample == 16)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCM;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMA;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMU;\n\t    }\n\t    else\n            {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported audio stream\"));\n                continue;\n            }\n        }\n\n        if (nstr > 0) {\n            /* Create fport instance. */\n            fport[nstr] = create_avi_port(pool);\n            if (!fport[nstr]) {\n\t        status = PJ_ENOMEM;\n                goto on_error;\n            }\n\n            /* Open file. */\n            status = pj_file_open(pool, filename, PJ_O_RDONLY,\n                                  &fport[nstr]->fd);\n            if (status != PJ_SUCCESS)\n                goto on_error;\n\n            /* Set the file position */\n            status = pj_file_setpos(fport[nstr]->fd, pos, PJ_SEEK_SET);\n            if (status != PJ_SUCCESS) {\n                goto on_error;\n            }\n        }\n\n        fport[nstr]->stream_id = i;\n        fport[nstr]->fmt_id = fmt_id;\n\n        nstr++;\n    }\n\n    if (nstr == 0) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    for (i = 0; i < nstr; i++) {\n        strl_hdr_t *strl_hdr = &avi_hdr.strl_hdr[fport[i]->stream_id];\n\n        /* Initialize */\n        fport[i]->options = options;\n        fport[i]->fsize = fport[0]->fsize;\n        /* Current file position now points to start of data */\n        fport[i]->start_data = pos;\n        \n        if (COMPARE_TAG(strl_hdr->data_type, PJMEDIA_AVI_VIDS_TAG)) {\n            strf_video_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_video_hdr;\n            const pjmedia_video_format_info *vfi;\n\n            vfi = pjmedia_get_video_format_info(\n                pjmedia_video_format_mgr_instance(),\n                strl_hdr->codec);\n\n            fport[i]->bits_per_sample = (vfi ? vfi->bpp : 0);\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_video(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->biWidth,\n                                      strf_hdr->biHeight,\n                                      strl_hdr->rate,\n                                      strl_hdr->scale);\n#if 0\n            /* The calculation below is wrong. strf_hdr->biSizeImage shows\n             * uncompressed size. Looks like we need to go the ugly way to\n             * get the bitrage:\n             *    http://www.virtualdub.org/blog/pivot/entry.php?id=159\n             */\n            bps = strf_hdr->biSizeImage * 8 * strl_hdr->rate / strl_hdr->scale;\n            if (bps==0) {\n        \t/* strf_hdr->biSizeImage may be zero for uncompressed RGB */\n        \tbps = strf_hdr->biWidth * strf_hdr->biHeight *\n        \t\tstrf_hdr->biBitCount *\n        \t\tstrl_hdr->rate / strl_hdr->scale;\n            }\n            fport[i]->base.info.fmt.det.vid.avg_bps = bps;\n            fport[i]->base.info.fmt.det.vid.max_bps = bps;\n#endif\n        } else {\n            strf_audio_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_audio_hdr;\n\n            fport[i]->bits_per_sample = strf_hdr->bits_per_sample;\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_audio(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->sample_rate,\n                                      strf_hdr->nchannels,\n                                      strf_hdr->bits_per_sample,\n                                      20000 /* fport[i]->usec_per_frame */,\n                                      strf_hdr->bytes_per_sec * 8,\n                                      strf_hdr->bytes_per_sec * 8);\n\n\t    /* Set format to PCM (we will decode PCMA/U) */\n\t    if (fport[i]->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t\tfport[i]->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t    {\n\t\tfport[i]->base.info.fmt.id = PJMEDIA_FORMAT_PCM;\n\t\tfport[i]->base.info.fmt.det.aud.bits_per_sample = 16;\n\t    }\n\t}\n\n        pj_strdup2(pool, &fport[i]->base.info.name, filename);\n    }\n\n    /* Done. */\n    *p_streams = pj_pool_alloc(pool, sizeof(pjmedia_avi_streams));\n    (*p_streams)->num_streams = nstr;\n    (*p_streams)->streams = pj_pool_calloc(pool, (*p_streams)->num_streams,\n                                           sizeof(pjmedia_port *));\n    for (i = 0; i < nstr; i++)\n        (*p_streams)->streams[i] = &fport[i]->base;\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"AVI file player '%.*s' created with \"\n\t      \"%d media ports\",\n\t      (int)fport[0]->base.info.name.slen,\n\t      fport[0]->base.info.name.ptr,\n              (*p_streams)->num_streams));\n\n    return PJ_SUCCESS;\n\non_error:\n    fport[0]->base.on_destroy(&fport[0]->base);\n    for (i = 1; i < nstr; i++)\n        fport[i]->base.on_destroy(&fport[i]->base);\n    if (status == AVI_EOF)\n        return PJMEDIA_EINVALIMEDIATYPE;\n    return status;\n}",
    "abstract_func_before": "VAR_0(pj_status_t)\npjmedia_avi_player_create_streams(pj_pool_t *VAR_1,\n                                  const char *VAR_2,\n\t\t\t\t  unsigned VAR_3,\n\t\t\t\t  pjmedia_avi_streams **VAR_4)\n{\n    pjmedia_avi_hdr VAR_5;\n    struct avi_reader_port *VAR_6[VAR_7];\n    pj_off_t VAR_8;\n    unsigned VAR_9, VAR_10 = 0;\n    pj_status_t VAR_11 = VAR_12;\n\n    /* COMMENT_0 */\n    PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_4, VAR_13);\n\n    /* COMMENT_1 */\n    if (!pj_file_exists(VAR_2)) {\n\treturn VAR_14;\n    }\n\n    /* COMMENT_2 */\n    VAR_6[0] = create_avi_port(VAR_1);\n    if (!VAR_6[0]) {\n\treturn VAR_15;\n    }\n\n    /* COMMENT_3 */\n    VAR_6[0]->fsize = pj_file_size(VAR_2);\n\n    /* COMMENT_4 */\n    if (VAR_6[0]->fsize <= sizeof(VAR_16) + sizeof(VAR_17) + \n                           sizeof(VAR_18))\n    {\n\treturn VAR_19;\n    }\n\n    /* COMMENT_5 */\n    VAR_11 = pj_file_open(VAR_1, VAR_2, VAR_20, &VAR_6[0]->fd);\n    if (VAR_11 != VAR_12)\n\treturn VAR_11;\n\n    /* COMMENT_6 */\n    VAR_11 = file_read(VAR_6[0]->fd, &VAR_5,\n                       sizeof(VAR_16) + sizeof(VAR_17));\n    if (VAR_11 != VAR_12)\n        goto on_error;\n\n    /* COMMENT_7 */\n    if (!COMPARE_TAG(VAR_5.riff_hdr.riff, VAR_21) ||\n\t!COMPARE_TAG(VAR_5.riff_hdr.avi, VAR_22) ||\n        !COMPARE_TAG(VAR_5.avih_hdr.list_tag, VAR_23) ||\n        !COMPARE_TAG(VAR_5.avih_hdr.hdrl_tag, VAR_24) ||\n        !COMPARE_TAG(VAR_5.avih_hdr.avih, VAR_25))\n    {\n\tVAR_11 = VAR_19;\n        goto on_error;\n    }\n\n    PJ_LOG(5, (VAR_26, \"The AVI file has %d streams.\",\n               VAR_5.avih_hdr.num_streams));\n\n    /* COMMENT_8 */\n    if (VAR_5.avih_hdr.num_streams > VAR_7) {\n        VAR_11 = VAR_27;\n        goto on_error;\n    }\n\n    /* COMMENT_9 */\n                                             \n                                                                   \n                           \n       \n    if (VAR_5.avih_hdr.flags & VAR_28 ||\n        VAR_5.avih_hdr.pad > 1)\n    {\n        PJ_LOG(3, (VAR_26, \"Warning!!! Possibly unsupported AVI format: \"\n                   \"flags:%d, pad:%d\", VAR_5.avih_hdr.flags, \n                   VAR_5.avih_hdr.pad));\n    }\n\n    /* COMMENT_14 */\n    for (VAR_9 = 0; VAR_9 < VAR_5.avih_hdr.num_streams; VAR_9++) {\n        pj_size_t VAR_29 = 0;\n        pj_ssize_t VAR_30;\n\n        /* COMMENT_15 */\n        VAR_11 = file_read(VAR_6[0]->fd, &VAR_5.strl_hdr[VAR_9],\n                           sizeof(VAR_18));\n        if (VAR_11 != VAR_12)\n            goto on_error;\n        \n        VAR_29 = COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                           VAR_31) ? \n               sizeof(VAR_32) :\n               COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                           VAR_33) ?\n               sizeof(VAR_34) : 0;\n\n        /* COMMENT_16 */\n        VAR_11 = file_read2(VAR_6[0]->fd, &VAR_5.strf_hdr[VAR_9],\n                            VAR_29, 0);\n        if (VAR_11 != VAR_12)\n            goto on_error;\n\n        /* COMMENT_17 */\n        if (VAR_29 == sizeof(VAR_32))\n            data_to_host2(&VAR_5.strf_hdr[VAR_9],\n                          sizeof(strf_video_hdr_sizes)/\n                          sizeof(strf_video_hdr_sizes[0]),\n                          strf_video_hdr_sizes);\n        else if (VAR_29 == sizeof(VAR_34))\n            data_to_host2(&VAR_5.strf_hdr[VAR_9],\n                          sizeof(strf_audio_hdr_sizes)/\n                          sizeof(strf_audio_hdr_sizes[0]),\n                          strf_audio_hdr_sizes);\n\n        /* COMMENT_18 */\n        VAR_30 = VAR_5.strl_hdr[VAR_9].list_sz - (sizeof(VAR_18) -\n                       8) - VAR_29;\n\tVAR_11 = pj_file_setpos(VAR_6[0]->fd, VAR_30, VAR_35);\n\tif (VAR_11 != VAR_12) {\n            goto on_error;\n\t}\n    }\n\n    /* COMMENT_19 */\n    VAR_11 = pj_file_setpos(VAR_6[0]->fd, VAR_5.avih_hdr.list_sz +\n                            sizeof(VAR_16) + 8, VAR_36);\n    if (VAR_11 != VAR_12) {\n        goto on_error;\n    }\n\n    /* COMMENT_20 */\n    do {\n        pjmedia_avi_subchunk VAR_37;\n        int VAR_38 = 0;\n\n        VAR_11 = file_read(VAR_6[0]->fd, &VAR_37, sizeof(pjmedia_avi_subchunk));\n        if (VAR_11 != VAR_12) {\n            goto on_error;\n        }\n\n        if (COMPARE_TAG(VAR_37.id, VAR_23))\n        {\n            VAR_38 = 4;\n            VAR_11 = file_read(VAR_6[0]->fd, &VAR_37, VAR_38);\n            if (COMPARE_TAG(VAR_37.id, VAR_39))\n                break;\n        }\n\n        VAR_11 = pj_file_setpos(VAR_6[0]->fd, VAR_37.len-VAR_38, VAR_35);\n        if (VAR_11 != VAR_12) {\n            goto on_error;\n        }\n    } while(1);\n\n    VAR_11 = pj_file_getpos(VAR_6[0]->fd, &VAR_8);\n    if (VAR_11 != VAR_12)\n        goto on_error;\n\n    for (VAR_9 = 0, VAR_10 = 0; VAR_9 < VAR_5.avih_hdr.num_streams; VAR_9++) {\n\tpjmedia_format_id VAR_40;\n\n        /* COMMENT_21 */\n        if ((!COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                          VAR_31) &&\n             !COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                          VAR_33)) ||\n            VAR_5.strl_hdr[VAR_9].flags & VAR_41)\n        {\n            continue;\n        }\n\n        if (COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                        VAR_31))\n        {\n            int VAR_42;\n\n            if (VAR_5.strl_hdr[VAR_9].flags & VAR_43) {\n                PJ_LOG(4, (VAR_26, \"Unsupported video stream\"));\n                continue;\n            }\n\n            VAR_40 = VAR_5.strl_hdr[VAR_9].codec;\n            for (VAR_42 = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; VAR_42 >= 0; VAR_42--) {\n                /* COMMENT_22 */\n                if (VAR_40 == avi_fmts[VAR_42].fmt_id) {\n                    if (avi_fmts[VAR_42].eff_fmt_id)\n                        VAR_40 = avi_fmts[VAR_42].eff_fmt_id;\n                    break;\n                }\n            }\n            \n            if (VAR_42 < 0) {\n                PJ_LOG(4, (VAR_26, \"Unsupported video stream\"));\n                continue;\n            }\n        } else {\n            /* COMMENT_23 */\n\t    strf_audio_hdr_t *VAR_44 = (strf_audio_hdr_t*)\n\t\t\t\t    &VAR_5.strf_hdr[VAR_9].strf_audio_hdr;\n            if (VAR_44->fmt_tag == VAR_45 &&\n\t\tVAR_44->bits_per_sample == 16)\n\t    {\n\t\tVAR_40 = VAR_46;\n\t    }\n\t    else if (VAR_44->fmt_tag == VAR_47)\n\t    {\n\t\tVAR_40 = VAR_48;\n\t    }\n\t    else if (VAR_44->fmt_tag == VAR_49)\n\t    {\n\t\tVAR_40 = VAR_50;\n\t    }\n\t    else\n            {\n                PJ_LOG(4, (VAR_26, \"Unsupported audio stream\"));\n                continue;\n            }\n        }\n\n        if (VAR_10 > 0) {\n            /* COMMENT_2 */\n            VAR_6[VAR_10] = create_avi_port(VAR_1);\n            if (!VAR_6[VAR_10]) {\n\t        VAR_11 = VAR_15;\n                goto on_error;\n            }\n\n            /* COMMENT_5 */\n            VAR_11 = pj_file_open(VAR_1, VAR_2, VAR_20,\n                                  &VAR_6[VAR_10]->fd);\n            if (VAR_11 != VAR_12)\n                goto on_error;\n\n            /* COMMENT_24 */\n            VAR_11 = pj_file_setpos(VAR_6[VAR_10]->fd, VAR_8, VAR_36);\n            if (VAR_11 != VAR_12) {\n                goto on_error;\n            }\n        }\n\n        VAR_6[VAR_10]->stream_id = VAR_9;\n        VAR_6[VAR_10]->fmt_id = VAR_40;\n\n        VAR_10++;\n    }\n\n    if (VAR_10 == 0) {\n        VAR_11 = VAR_27;\n        goto on_error;\n    }\n\n    for (VAR_9 = 0; VAR_9 < VAR_10; VAR_9++) {\n        strl_hdr_t *VAR_51 = &VAR_5.strl_hdr[VAR_6[VAR_9]->stream_id];\n\n        /* COMMENT_25 */\n        VAR_6[VAR_9]->options = VAR_3;\n        VAR_6[VAR_9]->fsize = VAR_6[0]->fsize;\n        /* COMMENT_26 */\n        VAR_6[VAR_9]->start_data = VAR_8;\n        \n        if (COMPARE_TAG(VAR_51->data_type, VAR_31)) {\n            strf_video_hdr_t *VAR_52 =\n                &VAR_5.strf_hdr[VAR_6[VAR_9]->stream_id].strf_video_hdr;\n            const pjmedia_video_format_info *VAR_53;\n\n            VAR_53 = pjmedia_get_video_format_info(\n                pjmedia_video_format_mgr_instance(),\n                VAR_51->codec);\n\n            VAR_6[VAR_9]->bits_per_sample = (VAR_53 ? VAR_53->bpp : 0);\n            VAR_6[VAR_9]->usec_per_frame = VAR_5.avih_hdr.usec_per_frame;\n            pjmedia_format_init_video(&VAR_6[VAR_9]->base.info.fmt,\n                                      VAR_6[VAR_9]->fmt_id,\n                                      VAR_52->biWidth,\n                                      VAR_52->biHeight,\n                                      VAR_51->rate,\n                                      VAR_51->scale);\n#if 0\n            /* COMMENT_27 */\n                                                                          \n                               \n                                                                       \n               \n            VAR_54 = VAR_52->biSizeImage * 8 * VAR_51->rate / VAR_51->scale;\n            if (VAR_54==0) {\n        \t/* COMMENT_32 */\n        \tVAR_54 = VAR_52->biWidth * VAR_52->biHeight *\n        \t\tVAR_52->biBitCount *\n        \t\tVAR_51->rate / VAR_51->scale;\n            }\n            VAR_6[VAR_9]->base.info.fmt.det.vid.avg_bps = VAR_54;\n            VAR_6[VAR_9]->base.info.fmt.det.vid.max_bps = VAR_54;\n#endif\n        } else {\n            strf_audio_hdr_t *VAR_52 =\n                &VAR_5.strf_hdr[VAR_6[VAR_9]->stream_id].strf_audio_hdr;\n\n            VAR_6[VAR_9]->bits_per_sample = VAR_52->bits_per_sample;\n            VAR_6[VAR_9]->usec_per_frame = VAR_5.avih_hdr.usec_per_frame;\n            pjmedia_format_init_audio(&VAR_6[VAR_9]->base.info.fmt,\n                                      VAR_6[VAR_9]->fmt_id,\n                                      VAR_52->sample_rate,\n                                      VAR_52->nchannels,\n                                      VAR_52->bits_per_sample,\n                                      20000 /* COMMENT_33 */,\n                                      VAR_52->bytes_per_sec * 8,\n                                      VAR_52->bytes_per_sec * 8);\n\n\t    /* COMMENT_34 */\n\t    if (VAR_6[VAR_9]->fmt_id == VAR_48 ||\n\t\tVAR_6[VAR_9]->fmt_id == VAR_50)\n\t    {\n\t\tVAR_6[VAR_9]->base.info.fmt.id = VAR_46;\n\t\tVAR_6[VAR_9]->base.info.fmt.det.aud.bits_per_sample = 16;\n\t    }\n\t}\n\n        pj_strdup2(VAR_1, &VAR_6[VAR_9]->base.info.name, VAR_2);\n    }\n\n    /* COMMENT_35 */\n    *VAR_4 = pj_pool_alloc(VAR_1, sizeof(pjmedia_avi_streams));\n    (*VAR_4)->num_streams = VAR_10;\n    (*VAR_4)->streams = pj_pool_calloc(VAR_1, (*VAR_4)->num_streams,\n                                           sizeof(pjmedia_port *));\n    for (VAR_9 = 0; VAR_9 < VAR_10; VAR_9++)\n        (*VAR_4)->streams[VAR_9] = &VAR_6[VAR_9]->base;\n\n    PJ_LOG(4,(VAR_26, \n\t      \"AVI file player '%.*s' created with \"\n\t      \"%d media ports\",\n\t      (int)VAR_6[0]->base.info.name.slen,\n\t      VAR_6[0]->base.info.name.ptr,\n              (*VAR_4)->num_streams));\n\n    return VAR_12;\n\non_error:\n    VAR_6[0]->base.on_destroy(&VAR_6[0]->base);\n    for (VAR_9 = 1; VAR_9 < VAR_10; VAR_9++)\n        VAR_6[VAR_9]->base.on_destroy(&VAR_6[VAR_9]->base);\n    if (VAR_11 == VAR_55)\n        return VAR_19;\n    return VAR_11;\n}",
    "func_graph_path_before": null,
    "func": "PJ_DEF(pj_status_t)\npjmedia_avi_player_create_streams(pj_pool_t *pool,\n                                  const char *filename,\n\t\t\t\t  unsigned options,\n\t\t\t\t  pjmedia_avi_streams **p_streams)\n{\n    pjmedia_avi_hdr avi_hdr;\n    struct avi_reader_port *fport[PJMEDIA_AVI_MAX_NUM_STREAMS];\n    pj_off_t pos;\n    unsigned i, nstr = 0;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_streams, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Create fport instance. */\n    fport[0] = create_avi_port(pool);\n    if (!fport[0]) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Get the file size. */\n    fport[0]->fsize = pj_file_size(filename);\n\n    /* Size must be more than AVI header size */\n    if (fport[0]->fsize <= sizeof(riff_hdr_t) + sizeof(avih_hdr_t) + \n                           sizeof(strl_hdr_t))\n    {\n\treturn PJMEDIA_EINVALIMEDIATYPE;\n    }\n\n    /* Open file. */\n    status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[0]->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the RIFF + AVIH header. */\n    status = file_read(fport[0]->fd, &avi_hdr,\n                       sizeof(riff_hdr_t) + sizeof(avih_hdr_t));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Validate AVI file. */\n    if (!COMPARE_TAG(avi_hdr.riff_hdr.riff, PJMEDIA_AVI_RIFF_TAG) ||\n\t!COMPARE_TAG(avi_hdr.riff_hdr.avi, PJMEDIA_AVI_AVI_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.list_tag, PJMEDIA_AVI_LIST_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.hdrl_tag, PJMEDIA_AVI_HDRL_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.avih, PJMEDIA_AVI_AVIH_TAG))\n    {\n\tstatus = PJMEDIA_EINVALIMEDIATYPE;\n        goto on_error;\n    }\n\n    PJ_LOG(5, (THIS_FILE, \"The AVI file has %d streams.\",\n               avi_hdr.avih_hdr.num_streams));\n\n    /* Unsupported AVI format. */\n    if (avi_hdr.avih_hdr.num_streams > PJMEDIA_AVI_MAX_NUM_STREAMS) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    /** \n     * TODO: Possibly unsupported AVI format.\n     * If you encounter this warning, verify whether the avi player\n     * is working properly.\n     */\n    if (avi_hdr.avih_hdr.flags & AVIF_MUSTUSEINDEX ||\n        avi_hdr.avih_hdr.pad > 1)\n    {\n        PJ_LOG(3, (THIS_FILE, \"Warning!!! Possibly unsupported AVI format: \"\n                   \"flags:%d, pad:%d\", avi_hdr.avih_hdr.flags, \n                   avi_hdr.avih_hdr.pad));\n    }\n\n    /* Read the headers of each stream. */\n    for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n        pj_size_t elem = 0;\n        pj_off_t size_to_read;\n\n        /* Read strl header */\n        status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n                           sizeof(strl_hdr_t));\n        if (status != PJ_SUCCESS)\n            goto on_error;\n        \n        elem = COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_VIDS_TAG) ? \n               sizeof(strf_video_hdr_t) :\n               COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_AUDS_TAG) ?\n               sizeof(strf_audio_hdr_t) : 0;\n\n        /* Read strf header */\n        status = file_read2(fport[0]->fd, &avi_hdr.strf_hdr[i],\n                            elem, 0);\n        if (status != PJ_SUCCESS)\n            goto on_error;\n\n        /* Normalize the endian */\n        if (elem == sizeof(strf_video_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_video_hdr_sizes)/\n                          sizeof(strf_video_hdr_sizes[0]),\n                          strf_video_hdr_sizes);\n        else if (elem == sizeof(strf_audio_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_audio_hdr_sizes)/\n                          sizeof(strf_audio_hdr_sizes[0]),\n                          strf_audio_hdr_sizes);\n\n        /* Skip the remainder of the header */\n        size_to_read = avi_hdr.strl_hdr[i].list_sz - (sizeof(strl_hdr_t) -\n                       8) - elem;\n\tstatus = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n            goto on_error;\n\t}\n    }\n\n    /* Finish reading the AVIH header */\n    status = pj_file_setpos(fport[0]->fd, avi_hdr.avih_hdr.list_sz +\n                            sizeof(riff_hdr_t) + 8, PJ_SEEK_SET);\n    if (status != PJ_SUCCESS) {\n        goto on_error;\n    }\n\n    /* Skip any JUNK or LIST INFO until we get MOVI tag */\n    do {\n        pjmedia_avi_subchunk ch;\n        int read = 0;\n        pj_off_t size_to_read;\n\n        status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n\n        if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n        {\n            read = 4;\n            status = file_read(fport[0]->fd, &ch, read);\n            if (COMPARE_TAG(ch.id, PJMEDIA_AVI_MOVI_TAG))\n                break;\n        }\n\n        if (ch.len < read) {\n            status = PJ_EINVAL;\n            goto on_error;\n        }\n        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, \n                                         status = PJ_EINVAL; goto on_error;);\n        size_to_read = (pj_off_t)ch.len - read;\n\n        status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n    } while(1);\n\n    status = pj_file_getpos(fport[0]->fd, &pos);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    for (i = 0, nstr = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n\tpjmedia_format_id fmt_id;\n\n        /* Skip non-audio, non-video, or disabled streams) */\n        if ((!COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_VIDS_TAG) &&\n             !COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_AUDS_TAG)) ||\n            avi_hdr.strl_hdr[i].flags & AVISF_DISABLED)\n        {\n            continue;\n        }\n\n        if (COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                        PJMEDIA_AVI_VIDS_TAG))\n        {\n            int j;\n\n            if (avi_hdr.strl_hdr[i].flags & AVISF_VIDEO_PALCHANGES) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n\n            fmt_id = avi_hdr.strl_hdr[i].codec;\n            for (j = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; j >= 0; j--) {\n                /* Check supported video formats here */\n                if (fmt_id == avi_fmts[j].fmt_id) {\n                    if (avi_fmts[j].eff_fmt_id)\n                        fmt_id = avi_fmts[j].eff_fmt_id;\n                    break;\n                }\n            }\n            \n            if (j < 0) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n        } else {\n            /* Check supported audio formats here */\n\t    strf_audio_hdr_t *hdr = (strf_audio_hdr_t*)\n\t\t\t\t    &avi_hdr.strf_hdr[i].strf_audio_hdr;\n            if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM &&\n\t\thdr->bits_per_sample == 16)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCM;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMA;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMU;\n\t    }\n\t    else\n            {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported audio stream\"));\n                continue;\n            }\n        }\n\n        if (nstr > 0) {\n            /* Create fport instance. */\n            fport[nstr] = create_avi_port(pool);\n            if (!fport[nstr]) {\n\t        status = PJ_ENOMEM;\n                goto on_error;\n            }\n\n            /* Open file. */\n            status = pj_file_open(pool, filename, PJ_O_RDONLY,\n                                  &fport[nstr]->fd);\n            if (status != PJ_SUCCESS)\n                goto on_error;\n\n            /* Set the file position */\n            status = pj_file_setpos(fport[nstr]->fd, pos, PJ_SEEK_SET);\n            if (status != PJ_SUCCESS) {\n                goto on_error;\n            }\n        }\n\n        fport[nstr]->stream_id = i;\n        fport[nstr]->fmt_id = fmt_id;\n\n        nstr++;\n    }\n\n    if (nstr == 0) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    for (i = 0; i < nstr; i++) {\n        strl_hdr_t *strl_hdr = &avi_hdr.strl_hdr[fport[i]->stream_id];\n\n        /* Initialize */\n        fport[i]->options = options;\n        fport[i]->fsize = fport[0]->fsize;\n        /* Current file position now points to start of data */\n        fport[i]->start_data = pos;\n        \n        if (COMPARE_TAG(strl_hdr->data_type, PJMEDIA_AVI_VIDS_TAG)) {\n            strf_video_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_video_hdr;\n            const pjmedia_video_format_info *vfi;\n\n            vfi = pjmedia_get_video_format_info(\n                pjmedia_video_format_mgr_instance(),\n                strl_hdr->codec);\n\n            fport[i]->bits_per_sample = (vfi ? vfi->bpp : 0);\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_video(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->biWidth,\n                                      strf_hdr->biHeight,\n                                      strl_hdr->rate,\n                                      strl_hdr->scale);\n#if 0\n            /* The calculation below is wrong. strf_hdr->biSizeImage shows\n             * uncompressed size. Looks like we need to go the ugly way to\n             * get the bitrage:\n             *    http://www.virtualdub.org/blog/pivot/entry.php?id=159\n             */\n            bps = strf_hdr->biSizeImage * 8 * strl_hdr->rate / strl_hdr->scale;\n            if (bps==0) {\n        \t/* strf_hdr->biSizeImage may be zero for uncompressed RGB */\n        \tbps = strf_hdr->biWidth * strf_hdr->biHeight *\n        \t\tstrf_hdr->biBitCount *\n        \t\tstrl_hdr->rate / strl_hdr->scale;\n            }\n            fport[i]->base.info.fmt.det.vid.avg_bps = bps;\n            fport[i]->base.info.fmt.det.vid.max_bps = bps;\n#endif\n        } else {\n            strf_audio_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_audio_hdr;\n\n            fport[i]->bits_per_sample = strf_hdr->bits_per_sample;\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_audio(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->sample_rate,\n                                      strf_hdr->nchannels,\n                                      strf_hdr->bits_per_sample,\n                                      20000 /* fport[i]->usec_per_frame */,\n                                      strf_hdr->bytes_per_sec * 8,\n                                      strf_hdr->bytes_per_sec * 8);\n\n\t    /* Set format to PCM (we will decode PCMA/U) */\n\t    if (fport[i]->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t\tfport[i]->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t    {\n\t\tfport[i]->base.info.fmt.id = PJMEDIA_FORMAT_PCM;\n\t\tfport[i]->base.info.fmt.det.aud.bits_per_sample = 16;\n\t    }\n\t}\n\n        pj_strdup2(pool, &fport[i]->base.info.name, filename);\n    }\n\n    /* Done. */\n    *p_streams = pj_pool_alloc(pool, sizeof(pjmedia_avi_streams));\n    (*p_streams)->num_streams = nstr;\n    (*p_streams)->streams = pj_pool_calloc(pool, (*p_streams)->num_streams,\n                                           sizeof(pjmedia_port *));\n    for (i = 0; i < nstr; i++)\n        (*p_streams)->streams[i] = &fport[i]->base;\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"AVI file player '%.*s' created with \"\n\t      \"%d media ports\",\n\t      (int)fport[0]->base.info.name.slen,\n\t      fport[0]->base.info.name.ptr,\n              (*p_streams)->num_streams));\n\n    return PJ_SUCCESS;\n\non_error:\n    fport[0]->base.on_destroy(&fport[0]->base);\n    for (i = 1; i < nstr; i++)\n        fport[i]->base.on_destroy(&fport[i]->base);\n    if (status == AVI_EOF)\n        return PJMEDIA_EINVALIMEDIATYPE;\n    return status;\n}",
    "abstract_func": "VAR_0(pj_status_t)\npjmedia_avi_player_create_streams(pj_pool_t *VAR_1,\n                                  const char *VAR_2,\n\t\t\t\t  unsigned VAR_3,\n\t\t\t\t  pjmedia_avi_streams **VAR_4)\n{\n    pjmedia_avi_hdr VAR_5;\n    struct avi_reader_port *VAR_6[VAR_7];\n    pj_off_t VAR_8;\n    unsigned VAR_9, VAR_10 = 0;\n    pj_status_t VAR_11 = VAR_12;\n\n    /* COMMENT_0 */\n    PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_4, VAR_13);\n\n    /* COMMENT_1 */\n    if (!pj_file_exists(VAR_2)) {\n\treturn VAR_14;\n    }\n\n    /* COMMENT_2 */\n    VAR_6[0] = create_avi_port(VAR_1);\n    if (!VAR_6[0]) {\n\treturn VAR_15;\n    }\n\n    /* COMMENT_3 */\n    VAR_6[0]->fsize = pj_file_size(VAR_2);\n\n    /* COMMENT_4 */\n    if (VAR_6[0]->fsize <= sizeof(VAR_16) + sizeof(VAR_17) + \n                           sizeof(VAR_18))\n    {\n\treturn VAR_19;\n    }\n\n    /* COMMENT_5 */\n    VAR_11 = pj_file_open(VAR_1, VAR_2, VAR_20, &VAR_6[0]->fd);\n    if (VAR_11 != VAR_12)\n\treturn VAR_11;\n\n    /* COMMENT_6 */\n    VAR_11 = file_read(VAR_6[0]->fd, &VAR_5,\n                       sizeof(VAR_16) + sizeof(VAR_17));\n    if (VAR_11 != VAR_12)\n        goto on_error;\n\n    /* COMMENT_7 */\n    if (!COMPARE_TAG(VAR_5.riff_hdr.riff, VAR_21) ||\n\t!COMPARE_TAG(VAR_5.riff_hdr.avi, VAR_22) ||\n        !COMPARE_TAG(VAR_5.avih_hdr.list_tag, VAR_23) ||\n        !COMPARE_TAG(VAR_5.avih_hdr.hdrl_tag, VAR_24) ||\n        !COMPARE_TAG(VAR_5.avih_hdr.avih, VAR_25))\n    {\n\tVAR_11 = VAR_19;\n        goto on_error;\n    }\n\n    PJ_LOG(5, (VAR_26, \"The AVI file has %d streams.\",\n               VAR_5.avih_hdr.num_streams));\n\n    /* COMMENT_8 */\n    if (VAR_5.avih_hdr.num_streams > VAR_7) {\n        VAR_11 = VAR_27;\n        goto on_error;\n    }\n\n    /* COMMENT_9 */\n                                             \n                                                                   \n                           \n       \n    if (VAR_5.avih_hdr.flags & VAR_28 ||\n        VAR_5.avih_hdr.pad > 1)\n    {\n        PJ_LOG(3, (VAR_26, \"Warning!!! Possibly unsupported AVI format: \"\n                   \"flags:%d, pad:%d\", VAR_5.avih_hdr.flags, \n                   VAR_5.avih_hdr.pad));\n    }\n\n    /* COMMENT_14 */\n    for (VAR_9 = 0; VAR_9 < VAR_5.avih_hdr.num_streams; VAR_9++) {\n        pj_size_t VAR_29 = 0;\n        pj_off_t VAR_30;\n\n        /* COMMENT_15 */\n        VAR_11 = file_read(VAR_6[0]->fd, &VAR_5.strl_hdr[VAR_9],\n                           sizeof(VAR_18));\n        if (VAR_11 != VAR_12)\n            goto on_error;\n        \n        VAR_29 = COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                           VAR_31) ? \n               sizeof(VAR_32) :\n               COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                           VAR_33) ?\n               sizeof(VAR_34) : 0;\n\n        /* COMMENT_16 */\n        VAR_11 = file_read2(VAR_6[0]->fd, &VAR_5.strf_hdr[VAR_9],\n                            VAR_29, 0);\n        if (VAR_11 != VAR_12)\n            goto on_error;\n\n        /* COMMENT_17 */\n        if (VAR_29 == sizeof(VAR_32))\n            data_to_host2(&VAR_5.strf_hdr[VAR_9],\n                          sizeof(strf_video_hdr_sizes)/\n                          sizeof(strf_video_hdr_sizes[0]),\n                          strf_video_hdr_sizes);\n        else if (VAR_29 == sizeof(VAR_34))\n            data_to_host2(&VAR_5.strf_hdr[VAR_9],\n                          sizeof(strf_audio_hdr_sizes)/\n                          sizeof(strf_audio_hdr_sizes[0]),\n                          strf_audio_hdr_sizes);\n\n        /* COMMENT_18 */\n        VAR_30 = VAR_5.strl_hdr[VAR_9].list_sz - (sizeof(VAR_18) -\n                       8) - VAR_29;\n\tVAR_11 = pj_file_setpos(VAR_6[0]->fd, VAR_30, VAR_35);\n\tif (VAR_11 != VAR_12) {\n            goto on_error;\n\t}\n    }\n\n    /* COMMENT_19 */\n    VAR_11 = pj_file_setpos(VAR_6[0]->fd, VAR_5.avih_hdr.list_sz +\n                            sizeof(VAR_16) + 8, VAR_36);\n    if (VAR_11 != VAR_12) {\n        goto on_error;\n    }\n\n    /* COMMENT_20 */\n    do {\n        pjmedia_avi_subchunk VAR_37;\n        int VAR_38 = 0;\n        pj_off_t VAR_30;\n\n        VAR_11 = file_read(VAR_6[0]->fd, &VAR_37, sizeof(pjmedia_avi_subchunk));\n        if (VAR_11 != VAR_12) {\n            goto on_error;\n        }\n\n        if (COMPARE_TAG(VAR_37.id, VAR_23))\n        {\n            VAR_38 = 4;\n            VAR_11 = file_read(VAR_6[0]->fd, &VAR_37, VAR_38);\n            if (COMPARE_TAG(VAR_37.id, VAR_39))\n                break;\n        }\n\n        if (VAR_37.len < VAR_38) {\n            VAR_11 = VAR_13;\n            goto on_error;\n        }\n        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(VAR_37.len - VAR_38, \n                                         VAR_11 = VAR_13; goto on_error;);\n        VAR_30 = (pj_off_t)VAR_37.len - VAR_38;\n\n        VAR_11 = pj_file_setpos(VAR_6[0]->fd, VAR_30, VAR_35);\n        if (VAR_11 != VAR_12) {\n            goto on_error;\n        }\n    } while(1);\n\n    VAR_11 = pj_file_getpos(VAR_6[0]->fd, &VAR_8);\n    if (VAR_11 != VAR_12)\n        goto on_error;\n\n    for (VAR_9 = 0, VAR_10 = 0; VAR_9 < VAR_5.avih_hdr.num_streams; VAR_9++) {\n\tpjmedia_format_id VAR_40;\n\n        /* COMMENT_21 */\n        if ((!COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                          VAR_31) &&\n             !COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                          VAR_33)) ||\n            VAR_5.strl_hdr[VAR_9].flags & VAR_41)\n        {\n            continue;\n        }\n\n        if (COMPARE_TAG(VAR_5.strl_hdr[VAR_9].data_type, \n                        VAR_31))\n        {\n            int VAR_42;\n\n            if (VAR_5.strl_hdr[VAR_9].flags & VAR_43) {\n                PJ_LOG(4, (VAR_26, \"Unsupported video stream\"));\n                continue;\n            }\n\n            VAR_40 = VAR_5.strl_hdr[VAR_9].codec;\n            for (VAR_42 = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; VAR_42 >= 0; VAR_42--) {\n                /* COMMENT_22 */\n                if (VAR_40 == avi_fmts[VAR_42].fmt_id) {\n                    if (avi_fmts[VAR_42].eff_fmt_id)\n                        VAR_40 = avi_fmts[VAR_42].eff_fmt_id;\n                    break;\n                }\n            }\n            \n            if (VAR_42 < 0) {\n                PJ_LOG(4, (VAR_26, \"Unsupported video stream\"));\n                continue;\n            }\n        } else {\n            /* COMMENT_23 */\n\t    strf_audio_hdr_t *VAR_44 = (strf_audio_hdr_t*)\n\t\t\t\t    &VAR_5.strf_hdr[VAR_9].strf_audio_hdr;\n            if (VAR_44->fmt_tag == VAR_45 &&\n\t\tVAR_44->bits_per_sample == 16)\n\t    {\n\t\tVAR_40 = VAR_46;\n\t    }\n\t    else if (VAR_44->fmt_tag == VAR_47)\n\t    {\n\t\tVAR_40 = VAR_48;\n\t    }\n\t    else if (VAR_44->fmt_tag == VAR_49)\n\t    {\n\t\tVAR_40 = VAR_50;\n\t    }\n\t    else\n            {\n                PJ_LOG(4, (VAR_26, \"Unsupported audio stream\"));\n                continue;\n            }\n        }\n\n        if (VAR_10 > 0) {\n            /* COMMENT_2 */\n            VAR_6[VAR_10] = create_avi_port(VAR_1);\n            if (!VAR_6[VAR_10]) {\n\t        VAR_11 = VAR_15;\n                goto on_error;\n            }\n\n            /* COMMENT_5 */\n            VAR_11 = pj_file_open(VAR_1, VAR_2, VAR_20,\n                                  &VAR_6[VAR_10]->fd);\n            if (VAR_11 != VAR_12)\n                goto on_error;\n\n            /* COMMENT_24 */\n            VAR_11 = pj_file_setpos(VAR_6[VAR_10]->fd, VAR_8, VAR_36);\n            if (VAR_11 != VAR_12) {\n                goto on_error;\n            }\n        }\n\n        VAR_6[VAR_10]->stream_id = VAR_9;\n        VAR_6[VAR_10]->fmt_id = VAR_40;\n\n        VAR_10++;\n    }\n\n    if (VAR_10 == 0) {\n        VAR_11 = VAR_27;\n        goto on_error;\n    }\n\n    for (VAR_9 = 0; VAR_9 < VAR_10; VAR_9++) {\n        strl_hdr_t *VAR_51 = &VAR_5.strl_hdr[VAR_6[VAR_9]->stream_id];\n\n        /* COMMENT_25 */\n        VAR_6[VAR_9]->options = VAR_3;\n        VAR_6[VAR_9]->fsize = VAR_6[0]->fsize;\n        /* COMMENT_26 */\n        VAR_6[VAR_9]->start_data = VAR_8;\n        \n        if (COMPARE_TAG(VAR_51->data_type, VAR_31)) {\n            strf_video_hdr_t *VAR_52 =\n                &VAR_5.strf_hdr[VAR_6[VAR_9]->stream_id].strf_video_hdr;\n            const pjmedia_video_format_info *VAR_53;\n\n            VAR_53 = pjmedia_get_video_format_info(\n                pjmedia_video_format_mgr_instance(),\n                VAR_51->codec);\n\n            VAR_6[VAR_9]->bits_per_sample = (VAR_53 ? VAR_53->bpp : 0);\n            VAR_6[VAR_9]->usec_per_frame = VAR_5.avih_hdr.usec_per_frame;\n            pjmedia_format_init_video(&VAR_6[VAR_9]->base.info.fmt,\n                                      VAR_6[VAR_9]->fmt_id,\n                                      VAR_52->biWidth,\n                                      VAR_52->biHeight,\n                                      VAR_51->rate,\n                                      VAR_51->scale);\n#if 0\n            /* COMMENT_27 */\n                                                                          \n                               \n                                                                       \n               \n            VAR_54 = VAR_52->biSizeImage * 8 * VAR_51->rate / VAR_51->scale;\n            if (VAR_54==0) {\n        \t/* COMMENT_32 */\n        \tVAR_54 = VAR_52->biWidth * VAR_52->biHeight *\n        \t\tVAR_52->biBitCount *\n        \t\tVAR_51->rate / VAR_51->scale;\n            }\n            VAR_6[VAR_9]->base.info.fmt.det.vid.avg_bps = VAR_54;\n            VAR_6[VAR_9]->base.info.fmt.det.vid.max_bps = VAR_54;\n#endif\n        } else {\n            strf_audio_hdr_t *VAR_52 =\n                &VAR_5.strf_hdr[VAR_6[VAR_9]->stream_id].strf_audio_hdr;\n\n            VAR_6[VAR_9]->bits_per_sample = VAR_52->bits_per_sample;\n            VAR_6[VAR_9]->usec_per_frame = VAR_5.avih_hdr.usec_per_frame;\n            pjmedia_format_init_audio(&VAR_6[VAR_9]->base.info.fmt,\n                                      VAR_6[VAR_9]->fmt_id,\n                                      VAR_52->sample_rate,\n                                      VAR_52->nchannels,\n                                      VAR_52->bits_per_sample,\n                                      20000 /* COMMENT_33 */,\n                                      VAR_52->bytes_per_sec * 8,\n                                      VAR_52->bytes_per_sec * 8);\n\n\t    /* COMMENT_34 */\n\t    if (VAR_6[VAR_9]->fmt_id == VAR_48 ||\n\t\tVAR_6[VAR_9]->fmt_id == VAR_50)\n\t    {\n\t\tVAR_6[VAR_9]->base.info.fmt.id = VAR_46;\n\t\tVAR_6[VAR_9]->base.info.fmt.det.aud.bits_per_sample = 16;\n\t    }\n\t}\n\n        pj_strdup2(VAR_1, &VAR_6[VAR_9]->base.info.name, VAR_2);\n    }\n\n    /* COMMENT_35 */\n    *VAR_4 = pj_pool_alloc(VAR_1, sizeof(pjmedia_avi_streams));\n    (*VAR_4)->num_streams = VAR_10;\n    (*VAR_4)->streams = pj_pool_calloc(VAR_1, (*VAR_4)->num_streams,\n                                           sizeof(pjmedia_port *));\n    for (VAR_9 = 0; VAR_9 < VAR_10; VAR_9++)\n        (*VAR_4)->streams[VAR_9] = &VAR_6[VAR_9]->base;\n\n    PJ_LOG(4,(VAR_26, \n\t      \"AVI file player '%.*s' created with \"\n\t      \"%d media ports\",\n\t      (int)VAR_6[0]->base.info.name.slen,\n\t      VAR_6[0]->base.info.name.ptr,\n              (*VAR_4)->num_streams));\n\n    return VAR_12;\n\non_error:\n    VAR_6[0]->base.on_destroy(&VAR_6[0]->base);\n    for (VAR_9 = 1; VAR_9 < VAR_10; VAR_9++)\n        VAR_6[VAR_9]->base.on_destroy(&VAR_6[VAR_9]->base);\n    if (VAR_11 == VAR_55)\n        return VAR_19;\n    return VAR_11;\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -81,7 +81,7 @@\n     /* Read the headers of each stream. */\n     for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n         pj_size_t elem = 0;\n-        pj_ssize_t size_to_read;\n+        pj_off_t size_to_read;\n \n         /* Read strl header */\n         status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n@@ -134,6 +134,7 @@\n     do {\n         pjmedia_avi_subchunk ch;\n         int read = 0;\n+        pj_off_t size_to_read;\n \n         status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));\n         if (status != PJ_SUCCESS) {\n@@ -148,7 +149,15 @@\n                 break;\n         }\n \n-        status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);\n+        if (ch.len < read) {\n+            status = PJ_EINVAL;\n+            goto on_error;\n+        }\n+        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, \n+                                         status = PJ_EINVAL; goto on_error;);\n+        size_to_read = (pj_off_t)ch.len - read;\n+\n+        status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n         if (status != PJ_SUCCESS) {\n             goto on_error;\n         }",
    "diff_line_info": {
        "deleted_lines": [
            "        pj_ssize_t size_to_read;",
            "        status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);"
        ],
        "added_lines": [
            "        pj_off_t size_to_read;",
            "        pj_off_t size_to_read;",
            "        if (ch.len < read) {",
            "            status = PJ_EINVAL;",
            "            goto on_error;",
            "        }",
            "        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, ",
            "                                         status = PJ_EINVAL; goto on_error;);",
            "        size_to_read = (pj_off_t)ch.len - read;",
            "",
            "        status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}