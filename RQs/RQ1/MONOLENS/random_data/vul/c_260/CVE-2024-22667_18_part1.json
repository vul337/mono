{
    "cve_id": "CVE-2024-22667",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "vim",
    "commit_msg": "patch 9.0.2142: [security]: stack-buffer-overflow in option callback functions\n\nProblem:  [security]: stack-buffer-overflow in option callback functions\nSolution: pass size of errbuf down the call stack, use snprintf()\n          instead of sprintf()\n\nWe pass the error buffer down to the option callback functions, but in\nsome parts of the code, we simply use sprintf(buf) to write into the error\nbuffer, which can overflow.\n\nSo let's pass down the length of the error buffer and use sprintf(buf, size)\ninstead.\n\nReported by @henices, thanks!\n\nSigned-off-by: Christian Brabandt <cb@256bit.org>",
    "commit_hash": "b39b240c386a5a29241415541f1c99e2e6b8ce47",
    "git_url": "https://github.com/vim/vim/commit/b39b240c386a5a29241415541f1c99e2e6b8ce47",
    "file_path": "src/optionstr.c",
    "func_name": "set_string_option",
    "func_before": "char *\nset_string_option(\n    int\t\topt_idx,\n    char_u\t*value,\n    int\t\topt_flags,\t// OPT_LOCAL and/or OPT_GLOBAL\n    char\t*errbuf)\n{\n    char_u\t*s;\n    char_u\t**varp;\n    char_u\t*oldval;\n#if defined(FEAT_EVAL)\n    char_u\t*oldval_l = NULL;\n    char_u\t*oldval_g = NULL;\n    char_u\t*saved_oldval = NULL;\n    char_u\t*saved_oldval_l = NULL;\n    char_u\t*saved_oldval_g = NULL;\n    char_u\t*saved_newval = NULL;\n#endif\n    char\t*errmsg = NULL;\n    int\t\tvalue_checked = FALSE;\n\n    if (is_hidden_option(opt_idx))\t// don't set hidden option\n\treturn NULL;\n\n    s = vim_strsave(value == NULL ? (char_u *)\"\" : value);\n    if (s == NULL)\n\treturn NULL;\n\n    varp = (char_u **)get_option_varp_scope(opt_idx,\n\t    (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t    ? (is_global_local_option(opt_idx)\n\t\t? OPT_GLOBAL : OPT_LOCAL)\n\t    : opt_flags);\n    oldval = *varp;\n#if defined(FEAT_EVAL)\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    {\n\toldval_l = *(char_u **)get_option_varp_scope(opt_idx, OPT_LOCAL);\n\toldval_g = *(char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);\n    }\n#endif\n    *varp = s;\n\n#if defined(FEAT_EVAL)\n    if (!starting\n# ifdef FEAT_CRYPT\n\t    && !is_crypt_key_option(opt_idx)\n# endif\n       )\n    {\n\tif (oldval_l != NULL)\n\t    saved_oldval_l = vim_strsave(oldval_l);\n\tif (oldval_g != NULL)\n\t    saved_oldval_g = vim_strsave(oldval_g);\n\tsaved_oldval = vim_strsave(oldval);\n\tsaved_newval = vim_strsave(s);\n    }\n#endif\n    if ((errmsg = did_set_string_option(opt_idx, varp, oldval, value, errbuf,\n\t\t    opt_flags, OP_NONE, &value_checked)) == NULL)\n\tdid_set_option(opt_idx, opt_flags, TRUE, value_checked);\n\n#if defined(FEAT_EVAL)\n    // call autocommand after handling side effects\n    if (errmsg == NULL)\n\ttrigger_optionset_string(opt_idx, opt_flags,\n\t\tsaved_oldval, saved_oldval_l,\n\t\tsaved_oldval_g, saved_newval);\n    vim_free(saved_oldval);\n    vim_free(saved_oldval_l);\n    vim_free(saved_oldval_g);\n    vim_free(saved_newval);\n#endif\n    return errmsg;\n}",
    "abstract_func_before": "char *\nset_string_option(\n    int\t\tVAR_0,\n    char_u\t*VAR_1,\n    int\t\tVAR_2,\t/* COMMENT_0 */\n    char\t*VAR_3)\n{\n    char_u\t*VAR_4;\n    char_u\t**VAR_5;\n    char_u\t*VAR_6;\n#if defined(VAR_7)\n    char_u\t*VAR_8 = NULL;\n    char_u\t*VAR_9 = NULL;\n    char_u\t*VAR_10 = NULL;\n    char_u\t*VAR_11 = NULL;\n    char_u\t*VAR_12 = NULL;\n    char_u\t*VAR_13 = NULL;\n#endif\n    char\t*VAR_14 = NULL;\n    int\t\tVAR_15 = FALSE;\n\n    if (is_hidden_option(VAR_0))\t/* COMMENT_1 */\n\treturn NULL;\n\n    VAR_4 = vim_strsave(VAR_1 == NULL ? (char_u *)\"\" : VAR_1);\n    if (VAR_4 == NULL)\n\treturn NULL;\n\n    VAR_5 = (char_u **)get_option_varp_scope(VAR_0,\n\t    (VAR_2 & (VAR_16 | VAR_17)) == 0\n\t    ? (is_global_local_option(VAR_0)\n\t\t? VAR_17 : VAR_16)\n\t    : VAR_2);\n    VAR_6 = *VAR_5;\n#if defined(VAR_7)\n    if ((VAR_2 & (VAR_16 | VAR_17)) == 0)\n    {\n\tVAR_8 = *(char_u **)get_option_varp_scope(VAR_0, VAR_16);\n\tVAR_9 = *(char_u **)get_option_varp_scope(VAR_0, VAR_17);\n    }\n#endif\n    *VAR_5 = VAR_4;\n\n#if defined(VAR_7)\n    if (!VAR_18\n# ifdef VAR_19\n\t    && !is_crypt_key_option(VAR_0)\n# endif\n       )\n    {\n\tif (VAR_8 != NULL)\n\t    VAR_11 = vim_strsave(VAR_8);\n\tif (VAR_9 != NULL)\n\t    VAR_12 = vim_strsave(VAR_9);\n\tVAR_10 = vim_strsave(VAR_6);\n\tVAR_13 = vim_strsave(VAR_4);\n    }\n#endif\n    if ((VAR_14 = did_set_string_option(VAR_0, VAR_5, VAR_6, VAR_1, VAR_3,\n\t\t    VAR_2, VAR_20, &VAR_15)) == NULL)\n\tdid_set_option(VAR_0, VAR_2, TRUE, VAR_15);\n\n#if defined(VAR_7)\n    /* COMMENT_2 */\n    if (VAR_14 == NULL)\n\ttrigger_optionset_string(VAR_0, VAR_2,\n\t\tVAR_10, VAR_11,\n\t\tVAR_12, VAR_13);\n    vim_free(VAR_10);\n    vim_free(VAR_11);\n    vim_free(VAR_12);\n    vim_free(VAR_13);\n#endif\n    return VAR_14;\n}",
    "func_graph_path_before": "vim/b39b240c386a5a29241415541f1c99e2e6b8ce47/optionstr.c/vul/before/14.json",
    "func": "char *\nset_string_option(\n    int\t\topt_idx,\n    char_u\t*value,\n    int\t\topt_flags,\t// OPT_LOCAL and/or OPT_GLOBAL\n    char\t*errbuf,\n    int\t\terrbuflen)\n{\n    char_u\t*s;\n    char_u\t**varp;\n    char_u\t*oldval;\n#if defined(FEAT_EVAL)\n    char_u\t*oldval_l = NULL;\n    char_u\t*oldval_g = NULL;\n    char_u\t*saved_oldval = NULL;\n    char_u\t*saved_oldval_l = NULL;\n    char_u\t*saved_oldval_g = NULL;\n    char_u\t*saved_newval = NULL;\n#endif\n    char\t*errmsg = NULL;\n    int\t\tvalue_checked = FALSE;\n\n    if (is_hidden_option(opt_idx))\t// don't set hidden option\n\treturn NULL;\n\n    s = vim_strsave(value == NULL ? (char_u *)\"\" : value);\n    if (s == NULL)\n\treturn NULL;\n\n    varp = (char_u **)get_option_varp_scope(opt_idx,\n\t    (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t    ? (is_global_local_option(opt_idx)\n\t\t? OPT_GLOBAL : OPT_LOCAL)\n\t    : opt_flags);\n    oldval = *varp;\n#if defined(FEAT_EVAL)\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    {\n\toldval_l = *(char_u **)get_option_varp_scope(opt_idx, OPT_LOCAL);\n\toldval_g = *(char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);\n    }\n#endif\n    *varp = s;\n\n#if defined(FEAT_EVAL)\n    if (!starting\n# ifdef FEAT_CRYPT\n\t    && !is_crypt_key_option(opt_idx)\n# endif\n       )\n    {\n\tif (oldval_l != NULL)\n\t    saved_oldval_l = vim_strsave(oldval_l);\n\tif (oldval_g != NULL)\n\t    saved_oldval_g = vim_strsave(oldval_g);\n\tsaved_oldval = vim_strsave(oldval);\n\tsaved_newval = vim_strsave(s);\n    }\n#endif\n    if ((errmsg = did_set_string_option(opt_idx, varp, oldval, value, errbuf,\n\t\t    errbuflen, opt_flags, OP_NONE, &value_checked)) == NULL)\n\tdid_set_option(opt_idx, opt_flags, TRUE, value_checked);\n\n#if defined(FEAT_EVAL)\n    // call autocommand after handling side effects\n    if (errmsg == NULL)\n\ttrigger_optionset_string(opt_idx, opt_flags,\n\t\tsaved_oldval, saved_oldval_l,\n\t\tsaved_oldval_g, saved_newval);\n    vim_free(saved_oldval);\n    vim_free(saved_oldval_l);\n    vim_free(saved_oldval_g);\n    vim_free(saved_newval);\n#endif\n    return errmsg;\n}",
    "abstract_func": "char *\nset_string_option(\n    int\t\tVAR_0,\n    char_u\t*VAR_1,\n    int\t\tVAR_2,\t/* COMMENT_0 */\n    char\t*VAR_3,\n    int\t\tVAR_4)\n{\n    char_u\t*VAR_5;\n    char_u\t**VAR_6;\n    char_u\t*VAR_7;\n#if defined(VAR_8)\n    char_u\t*VAR_9 = NULL;\n    char_u\t*VAR_10 = NULL;\n    char_u\t*VAR_11 = NULL;\n    char_u\t*VAR_12 = NULL;\n    char_u\t*VAR_13 = NULL;\n    char_u\t*VAR_14 = NULL;\n#endif\n    char\t*VAR_15 = NULL;\n    int\t\tVAR_16 = FALSE;\n\n    if (is_hidden_option(VAR_0))\t/* COMMENT_1 */\n\treturn NULL;\n\n    VAR_5 = vim_strsave(VAR_1 == NULL ? (char_u *)\"\" : VAR_1);\n    if (VAR_5 == NULL)\n\treturn NULL;\n\n    VAR_6 = (char_u **)get_option_varp_scope(VAR_0,\n\t    (VAR_2 & (VAR_17 | VAR_18)) == 0\n\t    ? (is_global_local_option(VAR_0)\n\t\t? VAR_18 : VAR_17)\n\t    : VAR_2);\n    VAR_7 = *VAR_6;\n#if defined(VAR_8)\n    if ((VAR_2 & (VAR_17 | VAR_18)) == 0)\n    {\n\tVAR_9 = *(char_u **)get_option_varp_scope(VAR_0, VAR_17);\n\tVAR_10 = *(char_u **)get_option_varp_scope(VAR_0, VAR_18);\n    }\n#endif\n    *VAR_6 = VAR_5;\n\n#if defined(VAR_8)\n    if (!VAR_19\n# ifdef VAR_20\n\t    && !is_crypt_key_option(VAR_0)\n# endif\n       )\n    {\n\tif (VAR_9 != NULL)\n\t    VAR_12 = vim_strsave(VAR_9);\n\tif (VAR_10 != NULL)\n\t    VAR_13 = vim_strsave(VAR_10);\n\tVAR_11 = vim_strsave(VAR_7);\n\tVAR_14 = vim_strsave(VAR_5);\n    }\n#endif\n    if ((VAR_15 = did_set_string_option(VAR_0, VAR_6, VAR_7, VAR_1, VAR_3,\n\t\t    VAR_4, VAR_2, VAR_21, &VAR_16)) == NULL)\n\tdid_set_option(VAR_0, VAR_2, TRUE, VAR_16);\n\n#if defined(VAR_8)\n    /* COMMENT_2 */\n    if (VAR_15 == NULL)\n\ttrigger_optionset_string(VAR_0, VAR_2,\n\t\tVAR_11, VAR_12,\n\t\tVAR_13, VAR_14);\n    vim_free(VAR_11);\n    vim_free(VAR_12);\n    vim_free(VAR_13);\n    vim_free(VAR_14);\n#endif\n    return VAR_15;\n}",
    "func_graph_path": "vim/b39b240c386a5a29241415541f1c99e2e6b8ce47/optionstr.c/vul/after/14.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,8 @@\n     int\t\topt_idx,\n     char_u\t*value,\n     int\t\topt_flags,\t// OPT_LOCAL and/or OPT_GLOBAL\n-    char\t*errbuf)\n+    char\t*errbuf,\n+    int\t\terrbuflen)\n {\n     char_u\t*s;\n     char_u\t**varp;\n@@ -57,7 +58,7 @@\n     }\n #endif\n     if ((errmsg = did_set_string_option(opt_idx, varp, oldval, value, errbuf,\n-\t\t    opt_flags, OP_NONE, &value_checked)) == NULL)\n+\t\t    errbuflen, opt_flags, OP_NONE, &value_checked)) == NULL)\n \tdid_set_option(opt_idx, opt_flags, TRUE, value_checked);\n \n #if defined(FEAT_EVAL)",
    "diff_line_info": {
        "deleted_lines": [
            "    char\t*errbuf)",
            "\t\t    opt_flags, OP_NONE, &value_checked)) == NULL)"
        ],
        "added_lines": [
            "    char\t*errbuf,",
            "    int\t\terrbuflen)",
            "\t\t    errbuflen, opt_flags, OP_NONE, &value_checked)) == NULL)"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}