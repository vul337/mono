{
    "cve_id": "CVE-2014-125005",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "ffmpeg",
    "commit_msg": "\navcodec/mpeg4videodec: Check for bitstream overread in decode_vol_header()\n\nFixes out of array read\nFixes: 08e48e9daae7d8f8ab6dbe3919e797e5-asan_heap-oob_157461c_5295_cov_1266798650_firefing.mpg\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n",
    "commit_hash": "3edc3b159503d512c919b3d5902f7026e961823a",
    "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3edc3b159503d512c919b3d5902f7026e961823a",
    "file_path": "libavcodec/mpeg4videodec.c",
    "func_name": "decode_vol_header",
    "func_before": "static int decode_vol_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int width, height, vo_ver_id;\n\n    /* vol header */\n    skip_bits(gb, 1);                   /* random access */\n    s->vo_type = get_bits(gb, 8);\n    if (get_bits1(gb) != 0) {           /* is_ol_id */\n        vo_ver_id = get_bits(gb, 4);    /* vo_ver_id */\n        skip_bits(gb, 3);               /* vo_priority */\n    } else {\n        vo_ver_id = 1;\n    }\n    s->aspect_ratio_info = get_bits(gb, 4);\n    if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n        s->avctx->sample_aspect_ratio.num = get_bits(gb, 8);  // par_width\n        s->avctx->sample_aspect_ratio.den = get_bits(gb, 8);  // par_height\n    } else {\n        s->avctx->sample_aspect_ratio = ff_h263_pixel_aspect[s->aspect_ratio_info];\n    }\n\n    if ((s->vol_control_parameters = get_bits1(gb))) { /* vol control parameter */\n        int chroma_format = get_bits(gb, 2);\n        if (chroma_format != CHROMA_420)\n            av_log(s->avctx, AV_LOG_ERROR, \"illegal chroma format\\n\");\n\n        s->low_delay = get_bits1(gb);\n        if (get_bits1(gb)) {    /* vbv parameters */\n            get_bits(gb, 15);   /* first_half_bitrate */\n            skip_bits1(gb);     /* marker */\n            get_bits(gb, 15);   /* latter_half_bitrate */\n            skip_bits1(gb);     /* marker */\n            get_bits(gb, 15);   /* first_half_vbv_buffer_size */\n            skip_bits1(gb);     /* marker */\n            get_bits(gb, 3);    /* latter_half_vbv_buffer_size */\n            get_bits(gb, 11);   /* first_half_vbv_occupancy */\n            skip_bits1(gb);     /* marker */\n            get_bits(gb, 15);   /* latter_half_vbv_occupancy */\n            skip_bits1(gb);     /* marker */\n        }\n    } else {\n        /* is setting low delay flag only once the smartest thing to do?\n         * low delay detection won't be overriden. */\n        if (s->picture_number == 0)\n            s->low_delay = 0;\n    }\n\n    ctx->shape = get_bits(gb, 2); /* vol shape */\n    if (ctx->shape != RECT_SHAPE)\n        av_log(s->avctx, AV_LOG_ERROR, \"only rectangular vol supported\\n\");\n    if (ctx->shape == GRAY_SHAPE && vo_ver_id != 1) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Gray shape not supported\\n\");\n        skip_bits(gb, 4);  /* video_object_layer_shape_extension */\n    }\n\n    check_marker(gb, \"before time_increment_resolution\");\n\n    s->avctx->time_base.den = get_bits(gb, 16);\n    if (!s->avctx->time_base.den) {\n        av_log(s->avctx, AV_LOG_ERROR, \"time_base.den==0\\n\");\n        s->avctx->time_base.num = 0;\n        return -1;\n    }\n\n    ctx->time_increment_bits = av_log2(s->avctx->time_base.den - 1) + 1;\n    if (ctx->time_increment_bits < 1)\n        ctx->time_increment_bits = 1;\n\n    check_marker(gb, \"before fixed_vop_rate\");\n\n    if (get_bits1(gb) != 0)     /* fixed_vop_rate  */\n        s->avctx->time_base.num = get_bits(gb, ctx->time_increment_bits);\n    else\n        s->avctx->time_base.num = 1;\n\n    ctx->t_frame = 0;\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        if (ctx->shape == RECT_SHAPE) {\n            check_marker(gb, \"before width\");\n            width = get_bits(gb, 13);\n            check_marker(gb, \"before height\");\n            height = get_bits(gb, 13);\n            check_marker(gb, \"after height\");\n            if (width && height &&  /* they should be non zero but who knows */\n                !(s->width && s->codec_tag == AV_RL32(\"MP4S\"))) {\n                if (s->width && s->height &&\n                    (s->width != width || s->height != height))\n                    s->context_reinit = 1;\n                s->width  = width;\n                s->height = height;\n            }\n        }\n\n        s->progressive_sequence  =\n        s->progressive_frame     = get_bits1(gb) ^ 1;\n        s->interlaced_dct        = 0;\n        if (!get_bits1(gb) && (s->avctx->debug & FF_DEBUG_PICT_INFO))\n            av_log(s->avctx, AV_LOG_INFO,           /* OBMC Disable */\n                   \"MPEG4 OBMC not supported (very likely buggy encoder)\\n\");\n        if (vo_ver_id == 1)\n            ctx->vol_sprite_usage = get_bits1(gb);    /* vol_sprite_usage */\n        else\n            ctx->vol_sprite_usage = get_bits(gb, 2);  /* vol_sprite_usage */\n\n        if (ctx->vol_sprite_usage == STATIC_SPRITE)\n            av_log(s->avctx, AV_LOG_ERROR, \"Static Sprites not supported\\n\");\n        if (ctx->vol_sprite_usage == STATIC_SPRITE ||\n            ctx->vol_sprite_usage == GMC_SPRITE) {\n            if (ctx->vol_sprite_usage == STATIC_SPRITE) {\n                skip_bits(gb, 13); // sprite_width\n                skip_bits1(gb); /* marker */\n                skip_bits(gb, 13); // sprite_height\n                skip_bits1(gb); /* marker */\n                skip_bits(gb, 13); // sprite_left\n                skip_bits1(gb); /* marker */\n                skip_bits(gb, 13); // sprite_top\n                skip_bits1(gb); /* marker */\n            }\n            ctx->num_sprite_warping_points = get_bits(gb, 6);\n            if (ctx->num_sprite_warping_points > 3) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"%d sprite_warping_points\\n\",\n                       ctx->num_sprite_warping_points);\n                ctx->num_sprite_warping_points = 0;\n                return -1;\n            }\n            s->sprite_warping_accuracy  = get_bits(gb, 2);\n            ctx->sprite_brightness_change = get_bits1(gb);\n            if (ctx->vol_sprite_usage == STATIC_SPRITE)\n                skip_bits1(gb); // low_latency_sprite\n        }\n        // FIXME sadct disable bit if verid!=1 && shape not rect\n\n        if (get_bits1(gb) == 1) {                   /* not_8_bit */\n            s->quant_precision = get_bits(gb, 4);   /* quant_precision */\n            if (get_bits(gb, 4) != 8)               /* bits_per_pixel */\n                av_log(s->avctx, AV_LOG_ERROR, \"N-bit not supported\\n\");\n            if (s->quant_precision != 5)\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"quant precision %d\\n\", s->quant_precision);\n            if (s->quant_precision<3 || s->quant_precision>9) {\n                s->quant_precision = 5;\n            }\n        } else {\n            s->quant_precision = 5;\n        }\n\n        // FIXME a bunch of grayscale shape things\n\n        if ((s->mpeg_quant = get_bits1(gb))) { /* vol_quant_type */\n            int i, v;\n\n            /* load default matrixes */\n            for (i = 0; i < 64; i++) {\n                int j = s->dsp.idct_permutation[i];\n                v = ff_mpeg4_default_intra_matrix[i];\n                s->intra_matrix[j]        = v;\n                s->chroma_intra_matrix[j] = v;\n\n                v = ff_mpeg4_default_non_intra_matrix[i];\n                s->inter_matrix[j]        = v;\n                s->chroma_inter_matrix[j] = v;\n            }\n\n            /* load custom intra matrix */\n            if (get_bits1(gb)) {\n                int last = 0;\n                for (i = 0; i < 64; i++) {\n                    int j;\n                    v = get_bits(gb, 8);\n                    if (v == 0)\n                        break;\n\n                    last = v;\n                    j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->intra_matrix[j]        = last;\n                    s->chroma_intra_matrix[j] = last;\n                }\n\n                /* replicate last value */\n                for (; i < 64; i++) {\n                    int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->intra_matrix[j]        = last;\n                    s->chroma_intra_matrix[j] = last;\n                }\n            }\n\n            /* load custom non intra matrix */\n            if (get_bits1(gb)) {\n                int last = 0;\n                for (i = 0; i < 64; i++) {\n                    int j;\n                    v = get_bits(gb, 8);\n                    if (v == 0)\n                        break;\n\n                    last = v;\n                    j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->inter_matrix[j]        = v;\n                    s->chroma_inter_matrix[j] = v;\n                }\n\n                /* replicate last value */\n                for (; i < 64; i++) {\n                    int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->inter_matrix[j]        = last;\n                    s->chroma_inter_matrix[j] = last;\n                }\n            }\n\n            // FIXME a bunch of grayscale shape things\n        }\n\n        if (vo_ver_id != 1)\n            s->quarter_sample = get_bits1(gb);\n        else\n            s->quarter_sample = 0;\n\n        if (!get_bits1(gb)) {\n            int pos               = get_bits_count(gb);\n            int estimation_method = get_bits(gb, 2);\n            if (estimation_method < 2) {\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* opaque */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* transparent */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* intra_cae */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* inter_cae */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* no_update */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* upampling */\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* intra_blocks */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* inter_blocks */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* inter4v_blocks */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* not coded blocks */\n                }\n                if (!check_marker(gb, \"in complexity estimation part 1\")) {\n                    skip_bits_long(gb, pos - get_bits_count(gb));\n                    goto no_cplx_est;\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* dct_coeffs */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* dct_lines */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* vlc_syms */\n                    ctx->cplx_estimation_trash_i += 4 * get_bits1(gb);  /* vlc_bits */\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* apm */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* npm */\n                    ctx->cplx_estimation_trash_b += 8 * get_bits1(gb);  /* interpolate_mc_q */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* forwback_mc_q */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* halfpel2 */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* halfpel4 */\n                }\n                if (!check_marker(gb, \"in complexity estimation part 2\")) {\n                    skip_bits_long(gb, pos - get_bits_count(gb));\n                    goto no_cplx_est;\n                }\n                if (estimation_method == 1) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* sadct */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* qpel */\n                }\n            } else\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Invalid Complexity estimation method %d\\n\",\n                       estimation_method);\n        } else {\n\nno_cplx_est:\n            ctx->cplx_estimation_trash_i =\n            ctx->cplx_estimation_trash_p =\n            ctx->cplx_estimation_trash_b = 0;\n        }\n\n        ctx->resync_marker = !get_bits1(gb); /* resync_marker_disabled */\n\n        s->data_partitioning = get_bits1(gb);\n        if (s->data_partitioning)\n            ctx->rvlc = get_bits1(gb);\n\n        if (vo_ver_id != 1) {\n            ctx->new_pred = get_bits1(gb);\n            if (ctx->new_pred) {\n                av_log(s->avctx, AV_LOG_ERROR, \"new pred not supported\\n\");\n                skip_bits(gb, 2); /* requested upstream message type */\n                skip_bits1(gb);   /* newpred segment type */\n            }\n            if (get_bits1(gb)) // reduced_res_vop\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"reduced resolution VOP not supported\\n\");\n        } else {\n            ctx->new_pred = 0;\n        }\n\n        ctx->scalability = get_bits1(gb);\n\n        if (ctx->scalability) {\n            GetBitContext bak = *gb;\n            int h_sampling_factor_n;\n            int h_sampling_factor_m;\n            int v_sampling_factor_n;\n            int v_sampling_factor_m;\n\n            skip_bits1(gb);    // hierarchy_type\n            skip_bits(gb, 4);  /* ref_layer_id */\n            skip_bits1(gb);    /* ref_layer_sampling_dir */\n            h_sampling_factor_n = get_bits(gb, 5);\n            h_sampling_factor_m = get_bits(gb, 5);\n            v_sampling_factor_n = get_bits(gb, 5);\n            v_sampling_factor_m = get_bits(gb, 5);\n            ctx->enhancement_type = get_bits1(gb);\n\n            if (h_sampling_factor_n == 0 || h_sampling_factor_m == 0 ||\n                v_sampling_factor_n == 0 || v_sampling_factor_m == 0) {\n                /* illegal scalability header (VERY broken encoder),\n                 * trying to workaround */\n                ctx->scalability = 0;\n                *gb            = bak;\n            } else\n                av_log(s->avctx, AV_LOG_ERROR, \"scalability not supported\\n\");\n\n            // bin shape stuff FIXME\n        }\n    }\n\n    if (s->avctx->debug&FF_DEBUG_PICT_INFO) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d,  %s%s%s%s\\n\",\n               s->avctx->time_base.num, s->avctx->time_base.den,\n               ctx->time_increment_bits,\n               s->quant_precision,\n               s->progressive_sequence,\n               ctx->scalability ? \"scalability \" :\"\" , s->quarter_sample ? \"qpel \" : \"\",\n               s->data_partitioning ? \"partition \" : \"\", ctx->rvlc ? \"rvlc \" : \"\"\n        );\n    }\n\n    return 0;\n}",
    "abstract_func_before": "static int decode_vol_header(Mpeg4DecContext *VAR_0, GetBitContext *VAR_1)\n{\n    MpegEncContext *VAR_2 = &VAR_0->m;\n    int VAR_3, VAR_4, VAR_5;\n\n    /* COMMENT_0 */\n    skip_bits(VAR_1, 1);                   /* COMMENT_1 */\n    VAR_2->vo_type = get_bits(VAR_1, 8);\n    if (get_bits1(VAR_1) != 0) {           /* COMMENT_2 */\n        VAR_5 = get_bits(VAR_1, 4);    /* COMMENT_3 */\n        skip_bits(VAR_1, 3);               /* COMMENT_4 */\n    } else {\n        VAR_5 = 1;\n    }\n    VAR_2->aspect_ratio_info = get_bits(VAR_1, 4);\n    if (VAR_2->aspect_ratio_info == VAR_6) {\n        VAR_2->avctx->sample_aspect_ratio.num = get_bits(VAR_1, 8);  /* COMMENT_5 */\n        VAR_2->avctx->sample_aspect_ratio.den = get_bits(VAR_1, 8);  /* COMMENT_6 */\n    } else {\n        VAR_2->avctx->sample_aspect_ratio = VAR_7[VAR_2->aspect_ratio_info];\n    }\n\n    if ((VAR_2->vol_control_parameters = get_bits1(VAR_1))) { /* COMMENT_7 */\n        int VAR_8 = get_bits(VAR_1, 2);\n        if (VAR_8 != VAR_9)\n            av_log(VAR_2->avctx, VAR_10, \"illegal chroma format\\n\");\n\n        VAR_2->low_delay = get_bits1(VAR_1);\n        if (get_bits1(VAR_1)) {    /* COMMENT_8 */\n            get_bits(VAR_1, 15);   /* COMMENT_9 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n            get_bits(VAR_1, 15);   /* COMMENT_11 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n            get_bits(VAR_1, 15);   /* COMMENT_12 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n            get_bits(VAR_1, 3);    /* COMMENT_13 */\n            get_bits(VAR_1, 11);   /* COMMENT_14 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n            get_bits(VAR_1, 15);   /* COMMENT_15 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n        }\n    } else {\n        /* COMMENT_16 */\n                                                     \n        if (VAR_2->picture_number == 0)\n            VAR_2->low_delay = 0;\n    }\n\n    VAR_0->shape = get_bits(VAR_1, 2); /* COMMENT_18 */\n    if (VAR_0->shape != VAR_11)\n        av_log(VAR_2->avctx, VAR_10, \"only rectangular vol supported\\n\");\n    if (VAR_0->shape == VAR_12 && VAR_5 != 1) {\n        av_log(VAR_2->avctx, VAR_10, \"Gray shape not supported\\n\");\n        skip_bits(VAR_1, 4);  /* COMMENT_19 */\n    }\n\n    check_marker(VAR_1, \"before time_increment_resolution\");\n\n    VAR_2->avctx->time_base.den = get_bits(VAR_1, 16);\n    if (!VAR_2->avctx->time_base.den) {\n        av_log(VAR_2->avctx, VAR_10, \"time_base.den==0\\n\");\n        VAR_2->avctx->time_base.num = 0;\n        return -1;\n    }\n\n    VAR_0->time_increment_bits = av_log2(VAR_2->avctx->time_base.den - 1) + 1;\n    if (VAR_0->time_increment_bits < 1)\n        VAR_0->time_increment_bits = 1;\n\n    check_marker(VAR_1, \"before fixed_vop_rate\");\n\n    if (get_bits1(VAR_1) != 0)     /* COMMENT_20 */\n        VAR_2->avctx->time_base.num = get_bits(VAR_1, VAR_0->time_increment_bits);\n    else\n        VAR_2->avctx->time_base.num = 1;\n\n    VAR_0->t_frame = 0;\n\n    if (VAR_0->shape != VAR_13) {\n        if (VAR_0->shape == VAR_11) {\n            check_marker(VAR_1, \"before width\");\n            VAR_3 = get_bits(VAR_1, 13);\n            check_marker(VAR_1, \"before height\");\n            VAR_4 = get_bits(VAR_1, 13);\n            check_marker(VAR_1, \"after height\");\n            if (VAR_3 && VAR_4 &&  /* COMMENT_21 */\n                !(VAR_2->width && VAR_2->codec_tag == AV_RL32(\"MP4S\"))) {\n                if (VAR_2->width && VAR_2->height &&\n                    (VAR_2->width != VAR_3 || VAR_2->height != VAR_4))\n                    VAR_2->context_reinit = 1;\n                VAR_2->width  = VAR_3;\n                VAR_2->height = VAR_4;\n            }\n        }\n\n        VAR_2->progressive_sequence  =\n        VAR_2->progressive_frame     = get_bits1(VAR_1) ^ 1;\n        VAR_2->interlaced_dct        = 0;\n        if (!get_bits1(VAR_1) && (VAR_2->avctx->debug & VAR_14))\n            av_log(VAR_2->avctx, VAR_15,           /* COMMENT_22 */\n                   \"MPEG4 OBMC not supported (very likely buggy encoder)\\n\");\n        if (VAR_5 == 1)\n            VAR_0->vol_sprite_usage = get_bits1(VAR_1);    /* COMMENT_23 */\n        else\n            VAR_0->vol_sprite_usage = get_bits(VAR_1, 2);  /* COMMENT_23 */\n\n        if (VAR_0->vol_sprite_usage == VAR_16)\n            av_log(VAR_2->avctx, VAR_10, \"Static Sprites not supported\\n\");\n        if (VAR_0->vol_sprite_usage == VAR_16 ||\n            VAR_0->vol_sprite_usage == VAR_17) {\n            if (VAR_0->vol_sprite_usage == VAR_16) {\n                skip_bits(VAR_1, 13); /* COMMENT_24 */\n                skip_bits1(VAR_1); /* COMMENT_10 */\n                skip_bits(VAR_1, 13); /* COMMENT_25 */\n                skip_bits1(VAR_1); /* COMMENT_10 */\n                skip_bits(VAR_1, 13); /* COMMENT_26 */\n                skip_bits1(VAR_1); /* COMMENT_10 */\n                skip_bits(VAR_1, 13); /* COMMENT_27 */\n                skip_bits1(VAR_1); /* COMMENT_10 */\n            }\n            VAR_0->num_sprite_warping_points = get_bits(VAR_1, 6);\n            if (VAR_0->num_sprite_warping_points > 3) {\n                av_log(VAR_2->avctx, VAR_10,\n                       \"%d sprite_warping_points\\n\",\n                       VAR_0->num_sprite_warping_points);\n                VAR_0->num_sprite_warping_points = 0;\n                return -1;\n            }\n            VAR_2->sprite_warping_accuracy  = get_bits(VAR_1, 2);\n            VAR_0->sprite_brightness_change = get_bits1(VAR_1);\n            if (VAR_0->vol_sprite_usage == VAR_16)\n                skip_bits1(VAR_1); /* COMMENT_28 */\n        }\n        /* COMMENT_29 */\n\n        if (get_bits1(VAR_1) == 1) {                   /* COMMENT_30 */\n            VAR_2->quant_precision = get_bits(VAR_1, 4);   /* COMMENT_31 */\n            if (get_bits(VAR_1, 4) != 8)               /* COMMENT_32 */\n                av_log(VAR_2->avctx, VAR_10, \"N-bit not supported\\n\");\n            if (VAR_2->quant_precision != 5)\n                av_log(VAR_2->avctx, VAR_10,\n                       \"quant precision %d\\n\", VAR_2->quant_precision);\n            if (VAR_2->quant_precision<3 || VAR_2->quant_precision>9) {\n                VAR_2->quant_precision = 5;\n            }\n        } else {\n            VAR_2->quant_precision = 5;\n        }\n\n        /* COMMENT_33 */\n\n        if ((VAR_2->mpeg_quant = get_bits1(VAR_1))) { /* COMMENT_34 */\n            int VAR_18, VAR_19;\n\n            /* COMMENT_35 */\n            for (VAR_18 = 0; VAR_18 < 64; VAR_18++) {\n                int VAR_20 = VAR_2->dsp.idct_permutation[VAR_18];\n                VAR_19 = VAR_21[VAR_18];\n                VAR_2->intra_matrix[VAR_20]        = VAR_19;\n                VAR_2->chroma_intra_matrix[VAR_20] = VAR_19;\n\n                VAR_19 = VAR_22[VAR_18];\n                VAR_2->inter_matrix[VAR_20]        = VAR_19;\n                VAR_2->chroma_inter_matrix[VAR_20] = VAR_19;\n            }\n\n            /* COMMENT_36 */\n            if (get_bits1(VAR_1)) {\n                int VAR_23 = 0;\n                for (VAR_18 = 0; VAR_18 < 64; VAR_18++) {\n                    int VAR_20;\n                    VAR_19 = get_bits(VAR_1, 8);\n                    if (VAR_19 == 0)\n                        break;\n\n                    VAR_23 = VAR_19;\n                    VAR_20 = VAR_2->dsp.idct_permutation[VAR_24[VAR_18]];\n                    VAR_2->intra_matrix[VAR_20]        = VAR_23;\n                    VAR_2->chroma_intra_matrix[VAR_20] = VAR_23;\n                }\n\n                /* COMMENT_37 */\n                for (; VAR_18 < 64; VAR_18++) {\n                    int VAR_20 = VAR_2->dsp.idct_permutation[VAR_24[VAR_18]];\n                    VAR_2->intra_matrix[VAR_20]        = VAR_23;\n                    VAR_2->chroma_intra_matrix[VAR_20] = VAR_23;\n                }\n            }\n\n            /* COMMENT_38 */\n            if (get_bits1(VAR_1)) {\n                int VAR_23 = 0;\n                for (VAR_18 = 0; VAR_18 < 64; VAR_18++) {\n                    int VAR_20;\n                    VAR_19 = get_bits(VAR_1, 8);\n                    if (VAR_19 == 0)\n                        break;\n\n                    VAR_23 = VAR_19;\n                    VAR_20 = VAR_2->dsp.idct_permutation[VAR_24[VAR_18]];\n                    VAR_2->inter_matrix[VAR_20]        = VAR_19;\n                    VAR_2->chroma_inter_matrix[VAR_20] = VAR_19;\n                }\n\n                /* COMMENT_37 */\n                for (; VAR_18 < 64; VAR_18++) {\n                    int VAR_20 = VAR_2->dsp.idct_permutation[VAR_24[VAR_18]];\n                    VAR_2->inter_matrix[VAR_20]        = VAR_23;\n                    VAR_2->chroma_inter_matrix[VAR_20] = VAR_23;\n                }\n            }\n\n            /* COMMENT_33 */\n        }\n\n        if (VAR_5 != 1)\n            VAR_2->quarter_sample = get_bits1(VAR_1);\n        else\n            VAR_2->quarter_sample = 0;\n\n        if (!get_bits1(VAR_1)) {\n            int VAR_25               = get_bits_count(VAR_1);\n            int VAR_26 = get_bits(VAR_1, 2);\n            if (VAR_26 < 2) {\n                if (!get_bits1(VAR_1)) {\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_39 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_40 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_41 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_42 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_43 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_44 */\n                }\n                if (!get_bits1(VAR_1)) {\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_45 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_46 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_47 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_48 */\n                }\n                if (!check_marker(VAR_1, \"in complexity estimation part 1\")) {\n                    skip_bits_long(VAR_1, VAR_25 - get_bits_count(VAR_1));\n                    goto no_cplx_est;\n                }\n                if (!get_bits1(VAR_1)) {\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_49 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_50 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_51 */\n                    VAR_0->cplx_estimation_trash_i += 4 * get_bits1(VAR_1);  /* COMMENT_52 */\n                }\n                if (!get_bits1(VAR_1)) {\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_53 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_54 */\n                    VAR_0->cplx_estimation_trash_b += 8 * get_bits1(VAR_1);  /* COMMENT_55 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_56 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_57 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_58 */\n                }\n                if (!check_marker(VAR_1, \"in complexity estimation part 2\")) {\n                    skip_bits_long(VAR_1, VAR_25 - get_bits_count(VAR_1));\n                    goto no_cplx_est;\n                }\n                if (VAR_26 == 1) {\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_59 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_60 */\n                }\n            } else\n                av_log(VAR_2->avctx, VAR_10,\n                       \"Invalid Complexity estimation method %d\\n\",\n                       VAR_26);\n        } else {\n\nno_cplx_est:\n            VAR_0->cplx_estimation_trash_i =\n            VAR_0->cplx_estimation_trash_p =\n            VAR_0->cplx_estimation_trash_b = 0;\n        }\n\n        VAR_0->resync_marker = !get_bits1(VAR_1); /* COMMENT_61 */\n\n        VAR_2->data_partitioning = get_bits1(VAR_1);\n        if (VAR_2->data_partitioning)\n            VAR_0->rvlc = get_bits1(VAR_1);\n\n        if (VAR_5 != 1) {\n            VAR_0->new_pred = get_bits1(VAR_1);\n            if (VAR_0->new_pred) {\n                av_log(VAR_2->avctx, VAR_10, \"new pred not supported\\n\");\n                skip_bits(VAR_1, 2); /* COMMENT_62 */\n                skip_bits1(VAR_1);   /* COMMENT_63 */\n            }\n            if (get_bits1(VAR_1)) /* COMMENT_64 */\n                av_log(VAR_2->avctx, VAR_10,\n                       \"reduced resolution VOP not supported\\n\");\n        } else {\n            VAR_0->new_pred = 0;\n        }\n\n        VAR_0->scalability = get_bits1(VAR_1);\n\n        if (VAR_0->scalability) {\n            GetBitContext VAR_27 = *VAR_1;\n            int VAR_28;\n            int VAR_29;\n            int VAR_30;\n            int VAR_31;\n\n            skip_bits1(VAR_1);    /* COMMENT_65 */\n            skip_bits(VAR_1, 4);  /* COMMENT_66 */\n            skip_bits1(VAR_1);    /* COMMENT_67 */\n            VAR_28 = get_bits(VAR_1, 5);\n            VAR_29 = get_bits(VAR_1, 5);\n            VAR_30 = get_bits(VAR_1, 5);\n            VAR_31 = get_bits(VAR_1, 5);\n            VAR_0->enhancement_type = get_bits1(VAR_1);\n\n            if (VAR_28 == 0 || VAR_29 == 0 ||\n                VAR_30 == 0 || VAR_31 == 0) {\n                /* COMMENT_68 */\n                                          \n                VAR_0->scalability = 0;\n                *VAR_1            = VAR_27;\n            } else\n                av_log(VAR_2->avctx, VAR_10, \"scalability not supported\\n\");\n\n            /* COMMENT_70 */\n        }\n    }\n\n    if (VAR_2->avctx->debug&VAR_14) {\n        av_log(VAR_2->avctx, VAR_32, \"tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d,  %s%s%s%s\\n\",\n               VAR_2->avctx->time_base.num, VAR_2->avctx->time_base.den,\n               VAR_0->time_increment_bits,\n               VAR_2->quant_precision,\n               VAR_2->progressive_sequence,\n               VAR_0->scalability ? \"scalability \" :\"\" , VAR_2->quarter_sample ? \"qpel \" : \"\",\n               VAR_2->data_partitioning ? \"partition \" : \"\", VAR_0->rvlc ? \"rvlc \" : \"\"\n        );\n    }\n\n    return 0;\n}",
    "func_graph_path_before": "ffmpeg/3edc3b159503d512c919b3d5902f7026e961823a/mpeg4videodec.c/vul/before/0.json",
    "func": "static int decode_vol_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int width, height, vo_ver_id;\n\n    /* vol header */\n    skip_bits(gb, 1);                   /* random access */\n    s->vo_type = get_bits(gb, 8);\n    if (get_bits1(gb) != 0) {           /* is_ol_id */\n        vo_ver_id = get_bits(gb, 4);    /* vo_ver_id */\n        skip_bits(gb, 3);               /* vo_priority */\n    } else {\n        vo_ver_id = 1;\n    }\n    s->aspect_ratio_info = get_bits(gb, 4);\n    if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n        s->avctx->sample_aspect_ratio.num = get_bits(gb, 8);  // par_width\n        s->avctx->sample_aspect_ratio.den = get_bits(gb, 8);  // par_height\n    } else {\n        s->avctx->sample_aspect_ratio = ff_h263_pixel_aspect[s->aspect_ratio_info];\n    }\n\n    if ((s->vol_control_parameters = get_bits1(gb))) { /* vol control parameter */\n        int chroma_format = get_bits(gb, 2);\n        if (chroma_format != CHROMA_420)\n            av_log(s->avctx, AV_LOG_ERROR, \"illegal chroma format\\n\");\n\n        s->low_delay = get_bits1(gb);\n        if (get_bits1(gb)) {    /* vbv parameters */\n            get_bits(gb, 15);   /* first_half_bitrate */\n            skip_bits1(gb);     /* marker */\n            get_bits(gb, 15);   /* latter_half_bitrate */\n            skip_bits1(gb);     /* marker */\n            get_bits(gb, 15);   /* first_half_vbv_buffer_size */\n            skip_bits1(gb);     /* marker */\n            get_bits(gb, 3);    /* latter_half_vbv_buffer_size */\n            get_bits(gb, 11);   /* first_half_vbv_occupancy */\n            skip_bits1(gb);     /* marker */\n            get_bits(gb, 15);   /* latter_half_vbv_occupancy */\n            skip_bits1(gb);     /* marker */\n        }\n    } else {\n        /* is setting low delay flag only once the smartest thing to do?\n         * low delay detection won't be overriden. */\n        if (s->picture_number == 0)\n            s->low_delay = 0;\n    }\n\n    ctx->shape = get_bits(gb, 2); /* vol shape */\n    if (ctx->shape != RECT_SHAPE)\n        av_log(s->avctx, AV_LOG_ERROR, \"only rectangular vol supported\\n\");\n    if (ctx->shape == GRAY_SHAPE && vo_ver_id != 1) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Gray shape not supported\\n\");\n        skip_bits(gb, 4);  /* video_object_layer_shape_extension */\n    }\n\n    check_marker(gb, \"before time_increment_resolution\");\n\n    s->avctx->time_base.den = get_bits(gb, 16);\n    if (!s->avctx->time_base.den) {\n        av_log(s->avctx, AV_LOG_ERROR, \"time_base.den==0\\n\");\n        s->avctx->time_base.num = 0;\n        return -1;\n    }\n\n    ctx->time_increment_bits = av_log2(s->avctx->time_base.den - 1) + 1;\n    if (ctx->time_increment_bits < 1)\n        ctx->time_increment_bits = 1;\n\n    check_marker(gb, \"before fixed_vop_rate\");\n\n    if (get_bits1(gb) != 0)     /* fixed_vop_rate  */\n        s->avctx->time_base.num = get_bits(gb, ctx->time_increment_bits);\n    else\n        s->avctx->time_base.num = 1;\n\n    ctx->t_frame = 0;\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        if (ctx->shape == RECT_SHAPE) {\n            check_marker(gb, \"before width\");\n            width = get_bits(gb, 13);\n            check_marker(gb, \"before height\");\n            height = get_bits(gb, 13);\n            check_marker(gb, \"after height\");\n            if (width && height &&  /* they should be non zero but who knows */\n                !(s->width && s->codec_tag == AV_RL32(\"MP4S\"))) {\n                if (s->width && s->height &&\n                    (s->width != width || s->height != height))\n                    s->context_reinit = 1;\n                s->width  = width;\n                s->height = height;\n            }\n        }\n\n        s->progressive_sequence  =\n        s->progressive_frame     = get_bits1(gb) ^ 1;\n        s->interlaced_dct        = 0;\n        if (!get_bits1(gb) && (s->avctx->debug & FF_DEBUG_PICT_INFO))\n            av_log(s->avctx, AV_LOG_INFO,           /* OBMC Disable */\n                   \"MPEG4 OBMC not supported (very likely buggy encoder)\\n\");\n        if (vo_ver_id == 1)\n            ctx->vol_sprite_usage = get_bits1(gb);    /* vol_sprite_usage */\n        else\n            ctx->vol_sprite_usage = get_bits(gb, 2);  /* vol_sprite_usage */\n\n        if (ctx->vol_sprite_usage == STATIC_SPRITE)\n            av_log(s->avctx, AV_LOG_ERROR, \"Static Sprites not supported\\n\");\n        if (ctx->vol_sprite_usage == STATIC_SPRITE ||\n            ctx->vol_sprite_usage == GMC_SPRITE) {\n            if (ctx->vol_sprite_usage == STATIC_SPRITE) {\n                skip_bits(gb, 13); // sprite_width\n                skip_bits1(gb); /* marker */\n                skip_bits(gb, 13); // sprite_height\n                skip_bits1(gb); /* marker */\n                skip_bits(gb, 13); // sprite_left\n                skip_bits1(gb); /* marker */\n                skip_bits(gb, 13); // sprite_top\n                skip_bits1(gb); /* marker */\n            }\n            ctx->num_sprite_warping_points = get_bits(gb, 6);\n            if (ctx->num_sprite_warping_points > 3) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"%d sprite_warping_points\\n\",\n                       ctx->num_sprite_warping_points);\n                ctx->num_sprite_warping_points = 0;\n                return -1;\n            }\n            s->sprite_warping_accuracy  = get_bits(gb, 2);\n            ctx->sprite_brightness_change = get_bits1(gb);\n            if (ctx->vol_sprite_usage == STATIC_SPRITE)\n                skip_bits1(gb); // low_latency_sprite\n        }\n        // FIXME sadct disable bit if verid!=1 && shape not rect\n\n        if (get_bits1(gb) == 1) {                   /* not_8_bit */\n            s->quant_precision = get_bits(gb, 4);   /* quant_precision */\n            if (get_bits(gb, 4) != 8)               /* bits_per_pixel */\n                av_log(s->avctx, AV_LOG_ERROR, \"N-bit not supported\\n\");\n            if (s->quant_precision != 5)\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"quant precision %d\\n\", s->quant_precision);\n            if (s->quant_precision<3 || s->quant_precision>9) {\n                s->quant_precision = 5;\n            }\n        } else {\n            s->quant_precision = 5;\n        }\n\n        // FIXME a bunch of grayscale shape things\n\n        if ((s->mpeg_quant = get_bits1(gb))) { /* vol_quant_type */\n            int i, v;\n\n            /* load default matrixes */\n            for (i = 0; i < 64; i++) {\n                int j = s->dsp.idct_permutation[i];\n                v = ff_mpeg4_default_intra_matrix[i];\n                s->intra_matrix[j]        = v;\n                s->chroma_intra_matrix[j] = v;\n\n                v = ff_mpeg4_default_non_intra_matrix[i];\n                s->inter_matrix[j]        = v;\n                s->chroma_inter_matrix[j] = v;\n            }\n\n            /* load custom intra matrix */\n            if (get_bits1(gb)) {\n                int last = 0;\n                for (i = 0; i < 64; i++) {\n                    int j;\n                    v = get_bits(gb, 8);\n                    if (v == 0)\n                        break;\n\n                    last = v;\n                    j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->intra_matrix[j]        = last;\n                    s->chroma_intra_matrix[j] = last;\n                }\n\n                /* replicate last value */\n                for (; i < 64; i++) {\n                    int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->intra_matrix[j]        = last;\n                    s->chroma_intra_matrix[j] = last;\n                }\n            }\n\n            /* load custom non intra matrix */\n            if (get_bits1(gb)) {\n                int last = 0;\n                for (i = 0; i < 64; i++) {\n                    int j;\n                    v = get_bits(gb, 8);\n                    if (v == 0)\n                        break;\n\n                    last = v;\n                    j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->inter_matrix[j]        = v;\n                    s->chroma_inter_matrix[j] = v;\n                }\n\n                /* replicate last value */\n                for (; i < 64; i++) {\n                    int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->inter_matrix[j]        = last;\n                    s->chroma_inter_matrix[j] = last;\n                }\n            }\n\n            // FIXME a bunch of grayscale shape things\n        }\n\n        if (vo_ver_id != 1)\n            s->quarter_sample = get_bits1(gb);\n        else\n            s->quarter_sample = 0;\n\n        if (get_bits_left(gb) < 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"VOL Header truncated\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!get_bits1(gb)) {\n            int pos               = get_bits_count(gb);\n            int estimation_method = get_bits(gb, 2);\n            if (estimation_method < 2) {\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* opaque */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* transparent */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* intra_cae */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* inter_cae */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* no_update */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* upampling */\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* intra_blocks */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* inter_blocks */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* inter4v_blocks */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* not coded blocks */\n                }\n                if (!check_marker(gb, \"in complexity estimation part 1\")) {\n                    skip_bits_long(gb, pos - get_bits_count(gb));\n                    goto no_cplx_est;\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* dct_coeffs */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* dct_lines */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* vlc_syms */\n                    ctx->cplx_estimation_trash_i += 4 * get_bits1(gb);  /* vlc_bits */\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* apm */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* npm */\n                    ctx->cplx_estimation_trash_b += 8 * get_bits1(gb);  /* interpolate_mc_q */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* forwback_mc_q */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* halfpel2 */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* halfpel4 */\n                }\n                if (!check_marker(gb, \"in complexity estimation part 2\")) {\n                    skip_bits_long(gb, pos - get_bits_count(gb));\n                    goto no_cplx_est;\n                }\n                if (estimation_method == 1) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* sadct */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* qpel */\n                }\n            } else\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Invalid Complexity estimation method %d\\n\",\n                       estimation_method);\n        } else {\n\nno_cplx_est:\n            ctx->cplx_estimation_trash_i =\n            ctx->cplx_estimation_trash_p =\n            ctx->cplx_estimation_trash_b = 0;\n        }\n\n        ctx->resync_marker = !get_bits1(gb); /* resync_marker_disabled */\n\n        s->data_partitioning = get_bits1(gb);\n        if (s->data_partitioning)\n            ctx->rvlc = get_bits1(gb);\n\n        if (vo_ver_id != 1) {\n            ctx->new_pred = get_bits1(gb);\n            if (ctx->new_pred) {\n                av_log(s->avctx, AV_LOG_ERROR, \"new pred not supported\\n\");\n                skip_bits(gb, 2); /* requested upstream message type */\n                skip_bits1(gb);   /* newpred segment type */\n            }\n            if (get_bits1(gb)) // reduced_res_vop\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"reduced resolution VOP not supported\\n\");\n        } else {\n            ctx->new_pred = 0;\n        }\n\n        ctx->scalability = get_bits1(gb);\n\n        if (ctx->scalability) {\n            GetBitContext bak = *gb;\n            int h_sampling_factor_n;\n            int h_sampling_factor_m;\n            int v_sampling_factor_n;\n            int v_sampling_factor_m;\n\n            skip_bits1(gb);    // hierarchy_type\n            skip_bits(gb, 4);  /* ref_layer_id */\n            skip_bits1(gb);    /* ref_layer_sampling_dir */\n            h_sampling_factor_n = get_bits(gb, 5);\n            h_sampling_factor_m = get_bits(gb, 5);\n            v_sampling_factor_n = get_bits(gb, 5);\n            v_sampling_factor_m = get_bits(gb, 5);\n            ctx->enhancement_type = get_bits1(gb);\n\n            if (h_sampling_factor_n == 0 || h_sampling_factor_m == 0 ||\n                v_sampling_factor_n == 0 || v_sampling_factor_m == 0) {\n                /* illegal scalability header (VERY broken encoder),\n                 * trying to workaround */\n                ctx->scalability = 0;\n                *gb            = bak;\n            } else\n                av_log(s->avctx, AV_LOG_ERROR, \"scalability not supported\\n\");\n\n            // bin shape stuff FIXME\n        }\n    }\n\n    if (s->avctx->debug&FF_DEBUG_PICT_INFO) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d,  %s%s%s%s\\n\",\n               s->avctx->time_base.num, s->avctx->time_base.den,\n               ctx->time_increment_bits,\n               s->quant_precision,\n               s->progressive_sequence,\n               ctx->scalability ? \"scalability \" :\"\" , s->quarter_sample ? \"qpel \" : \"\",\n               s->data_partitioning ? \"partition \" : \"\", ctx->rvlc ? \"rvlc \" : \"\"\n        );\n    }\n\n    return 0;\n}",
    "abstract_func": "static int decode_vol_header(Mpeg4DecContext *VAR_0, GetBitContext *VAR_1)\n{\n    MpegEncContext *VAR_2 = &VAR_0->m;\n    int VAR_3, VAR_4, VAR_5;\n\n    /* COMMENT_0 */\n    skip_bits(VAR_1, 1);                   /* COMMENT_1 */\n    VAR_2->vo_type = get_bits(VAR_1, 8);\n    if (get_bits1(VAR_1) != 0) {           /* COMMENT_2 */\n        VAR_5 = get_bits(VAR_1, 4);    /* COMMENT_3 */\n        skip_bits(VAR_1, 3);               /* COMMENT_4 */\n    } else {\n        VAR_5 = 1;\n    }\n    VAR_2->aspect_ratio_info = get_bits(VAR_1, 4);\n    if (VAR_2->aspect_ratio_info == VAR_6) {\n        VAR_2->avctx->sample_aspect_ratio.num = get_bits(VAR_1, 8);  /* COMMENT_5 */\n        VAR_2->avctx->sample_aspect_ratio.den = get_bits(VAR_1, 8);  /* COMMENT_6 */\n    } else {\n        VAR_2->avctx->sample_aspect_ratio = VAR_7[VAR_2->aspect_ratio_info];\n    }\n\n    if ((VAR_2->vol_control_parameters = get_bits1(VAR_1))) { /* COMMENT_7 */\n        int VAR_8 = get_bits(VAR_1, 2);\n        if (VAR_8 != VAR_9)\n            av_log(VAR_2->avctx, VAR_10, \"illegal chroma format\\n\");\n\n        VAR_2->low_delay = get_bits1(VAR_1);\n        if (get_bits1(VAR_1)) {    /* COMMENT_8 */\n            get_bits(VAR_1, 15);   /* COMMENT_9 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n            get_bits(VAR_1, 15);   /* COMMENT_11 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n            get_bits(VAR_1, 15);   /* COMMENT_12 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n            get_bits(VAR_1, 3);    /* COMMENT_13 */\n            get_bits(VAR_1, 11);   /* COMMENT_14 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n            get_bits(VAR_1, 15);   /* COMMENT_15 */\n            skip_bits1(VAR_1);     /* COMMENT_10 */\n        }\n    } else {\n        /* COMMENT_16 */\n                                                     \n        if (VAR_2->picture_number == 0)\n            VAR_2->low_delay = 0;\n    }\n\n    VAR_0->shape = get_bits(VAR_1, 2); /* COMMENT_18 */\n    if (VAR_0->shape != VAR_11)\n        av_log(VAR_2->avctx, VAR_10, \"only rectangular vol supported\\n\");\n    if (VAR_0->shape == VAR_12 && VAR_5 != 1) {\n        av_log(VAR_2->avctx, VAR_10, \"Gray shape not supported\\n\");\n        skip_bits(VAR_1, 4);  /* COMMENT_19 */\n    }\n\n    check_marker(VAR_1, \"before time_increment_resolution\");\n\n    VAR_2->avctx->time_base.den = get_bits(VAR_1, 16);\n    if (!VAR_2->avctx->time_base.den) {\n        av_log(VAR_2->avctx, VAR_10, \"time_base.den==0\\n\");\n        VAR_2->avctx->time_base.num = 0;\n        return -1;\n    }\n\n    VAR_0->time_increment_bits = av_log2(VAR_2->avctx->time_base.den - 1) + 1;\n    if (VAR_0->time_increment_bits < 1)\n        VAR_0->time_increment_bits = 1;\n\n    check_marker(VAR_1, \"before fixed_vop_rate\");\n\n    if (get_bits1(VAR_1) != 0)     /* COMMENT_20 */\n        VAR_2->avctx->time_base.num = get_bits(VAR_1, VAR_0->time_increment_bits);\n    else\n        VAR_2->avctx->time_base.num = 1;\n\n    VAR_0->t_frame = 0;\n\n    if (VAR_0->shape != VAR_13) {\n        if (VAR_0->shape == VAR_11) {\n            check_marker(VAR_1, \"before width\");\n            VAR_3 = get_bits(VAR_1, 13);\n            check_marker(VAR_1, \"before height\");\n            VAR_4 = get_bits(VAR_1, 13);\n            check_marker(VAR_1, \"after height\");\n            if (VAR_3 && VAR_4 &&  /* COMMENT_21 */\n                !(VAR_2->width && VAR_2->codec_tag == AV_RL32(\"MP4S\"))) {\n                if (VAR_2->width && VAR_2->height &&\n                    (VAR_2->width != VAR_3 || VAR_2->height != VAR_4))\n                    VAR_2->context_reinit = 1;\n                VAR_2->width  = VAR_3;\n                VAR_2->height = VAR_4;\n            }\n        }\n\n        VAR_2->progressive_sequence  =\n        VAR_2->progressive_frame     = get_bits1(VAR_1) ^ 1;\n        VAR_2->interlaced_dct        = 0;\n        if (!get_bits1(VAR_1) && (VAR_2->avctx->debug & VAR_14))\n            av_log(VAR_2->avctx, VAR_15,           /* COMMENT_22 */\n                   \"MPEG4 OBMC not supported (very likely buggy encoder)\\n\");\n        if (VAR_5 == 1)\n            VAR_0->vol_sprite_usage = get_bits1(VAR_1);    /* COMMENT_23 */\n        else\n            VAR_0->vol_sprite_usage = get_bits(VAR_1, 2);  /* COMMENT_23 */\n\n        if (VAR_0->vol_sprite_usage == VAR_16)\n            av_log(VAR_2->avctx, VAR_10, \"Static Sprites not supported\\n\");\n        if (VAR_0->vol_sprite_usage == VAR_16 ||\n            VAR_0->vol_sprite_usage == VAR_17) {\n            if (VAR_0->vol_sprite_usage == VAR_16) {\n                skip_bits(VAR_1, 13); /* COMMENT_24 */\n                skip_bits1(VAR_1); /* COMMENT_10 */\n                skip_bits(VAR_1, 13); /* COMMENT_25 */\n                skip_bits1(VAR_1); /* COMMENT_10 */\n                skip_bits(VAR_1, 13); /* COMMENT_26 */\n                skip_bits1(VAR_1); /* COMMENT_10 */\n                skip_bits(VAR_1, 13); /* COMMENT_27 */\n                skip_bits1(VAR_1); /* COMMENT_10 */\n            }\n            VAR_0->num_sprite_warping_points = get_bits(VAR_1, 6);\n            if (VAR_0->num_sprite_warping_points > 3) {\n                av_log(VAR_2->avctx, VAR_10,\n                       \"%d sprite_warping_points\\n\",\n                       VAR_0->num_sprite_warping_points);\n                VAR_0->num_sprite_warping_points = 0;\n                return -1;\n            }\n            VAR_2->sprite_warping_accuracy  = get_bits(VAR_1, 2);\n            VAR_0->sprite_brightness_change = get_bits1(VAR_1);\n            if (VAR_0->vol_sprite_usage == VAR_16)\n                skip_bits1(VAR_1); /* COMMENT_28 */\n        }\n        /* COMMENT_29 */\n\n        if (get_bits1(VAR_1) == 1) {                   /* COMMENT_30 */\n            VAR_2->quant_precision = get_bits(VAR_1, 4);   /* COMMENT_31 */\n            if (get_bits(VAR_1, 4) != 8)               /* COMMENT_32 */\n                av_log(VAR_2->avctx, VAR_10, \"N-bit not supported\\n\");\n            if (VAR_2->quant_precision != 5)\n                av_log(VAR_2->avctx, VAR_10,\n                       \"quant precision %d\\n\", VAR_2->quant_precision);\n            if (VAR_2->quant_precision<3 || VAR_2->quant_precision>9) {\n                VAR_2->quant_precision = 5;\n            }\n        } else {\n            VAR_2->quant_precision = 5;\n        }\n\n        /* COMMENT_33 */\n\n        if ((VAR_2->mpeg_quant = get_bits1(VAR_1))) { /* COMMENT_34 */\n            int VAR_18, VAR_19;\n\n            /* COMMENT_35 */\n            for (VAR_18 = 0; VAR_18 < 64; VAR_18++) {\n                int VAR_20 = VAR_2->dsp.idct_permutation[VAR_18];\n                VAR_19 = VAR_21[VAR_18];\n                VAR_2->intra_matrix[VAR_20]        = VAR_19;\n                VAR_2->chroma_intra_matrix[VAR_20] = VAR_19;\n\n                VAR_19 = VAR_22[VAR_18];\n                VAR_2->inter_matrix[VAR_20]        = VAR_19;\n                VAR_2->chroma_inter_matrix[VAR_20] = VAR_19;\n            }\n\n            /* COMMENT_36 */\n            if (get_bits1(VAR_1)) {\n                int VAR_23 = 0;\n                for (VAR_18 = 0; VAR_18 < 64; VAR_18++) {\n                    int VAR_20;\n                    VAR_19 = get_bits(VAR_1, 8);\n                    if (VAR_19 == 0)\n                        break;\n\n                    VAR_23 = VAR_19;\n                    VAR_20 = VAR_2->dsp.idct_permutation[VAR_24[VAR_18]];\n                    VAR_2->intra_matrix[VAR_20]        = VAR_23;\n                    VAR_2->chroma_intra_matrix[VAR_20] = VAR_23;\n                }\n\n                /* COMMENT_37 */\n                for (; VAR_18 < 64; VAR_18++) {\n                    int VAR_20 = VAR_2->dsp.idct_permutation[VAR_24[VAR_18]];\n                    VAR_2->intra_matrix[VAR_20]        = VAR_23;\n                    VAR_2->chroma_intra_matrix[VAR_20] = VAR_23;\n                }\n            }\n\n            /* COMMENT_38 */\n            if (get_bits1(VAR_1)) {\n                int VAR_23 = 0;\n                for (VAR_18 = 0; VAR_18 < 64; VAR_18++) {\n                    int VAR_20;\n                    VAR_19 = get_bits(VAR_1, 8);\n                    if (VAR_19 == 0)\n                        break;\n\n                    VAR_23 = VAR_19;\n                    VAR_20 = VAR_2->dsp.idct_permutation[VAR_24[VAR_18]];\n                    VAR_2->inter_matrix[VAR_20]        = VAR_19;\n                    VAR_2->chroma_inter_matrix[VAR_20] = VAR_19;\n                }\n\n                /* COMMENT_37 */\n                for (; VAR_18 < 64; VAR_18++) {\n                    int VAR_20 = VAR_2->dsp.idct_permutation[VAR_24[VAR_18]];\n                    VAR_2->inter_matrix[VAR_20]        = VAR_23;\n                    VAR_2->chroma_inter_matrix[VAR_20] = VAR_23;\n                }\n            }\n\n            /* COMMENT_33 */\n        }\n\n        if (VAR_5 != 1)\n            VAR_2->quarter_sample = get_bits1(VAR_1);\n        else\n            VAR_2->quarter_sample = 0;\n\n        if (get_bits_left(VAR_1) < 4) {\n            av_log(VAR_2->avctx, VAR_10, \"VOL Header truncated\\n\");\n            return VAR_25;\n        }\n\n        if (!get_bits1(VAR_1)) {\n            int VAR_26               = get_bits_count(VAR_1);\n            int VAR_27 = get_bits(VAR_1, 2);\n            if (VAR_27 < 2) {\n                if (!get_bits1(VAR_1)) {\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_39 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_40 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_41 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_42 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_43 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_44 */\n                }\n                if (!get_bits1(VAR_1)) {\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_45 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_46 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_47 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_48 */\n                }\n                if (!check_marker(VAR_1, \"in complexity estimation part 1\")) {\n                    skip_bits_long(VAR_1, VAR_26 - get_bits_count(VAR_1));\n                    goto no_cplx_est;\n                }\n                if (!get_bits1(VAR_1)) {\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_49 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_50 */\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_51 */\n                    VAR_0->cplx_estimation_trash_i += 4 * get_bits1(VAR_1);  /* COMMENT_52 */\n                }\n                if (!get_bits1(VAR_1)) {\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_53 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_54 */\n                    VAR_0->cplx_estimation_trash_b += 8 * get_bits1(VAR_1);  /* COMMENT_55 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_56 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_57 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_58 */\n                }\n                if (!check_marker(VAR_1, \"in complexity estimation part 2\")) {\n                    skip_bits_long(VAR_1, VAR_26 - get_bits_count(VAR_1));\n                    goto no_cplx_est;\n                }\n                if (VAR_27 == 1) {\n                    VAR_0->cplx_estimation_trash_i += 8 * get_bits1(VAR_1);  /* COMMENT_59 */\n                    VAR_0->cplx_estimation_trash_p += 8 * get_bits1(VAR_1);  /* COMMENT_60 */\n                }\n            } else\n                av_log(VAR_2->avctx, VAR_10,\n                       \"Invalid Complexity estimation method %d\\n\",\n                       VAR_27);\n        } else {\n\nno_cplx_est:\n            VAR_0->cplx_estimation_trash_i =\n            VAR_0->cplx_estimation_trash_p =\n            VAR_0->cplx_estimation_trash_b = 0;\n        }\n\n        VAR_0->resync_marker = !get_bits1(VAR_1); /* COMMENT_61 */\n\n        VAR_2->data_partitioning = get_bits1(VAR_1);\n        if (VAR_2->data_partitioning)\n            VAR_0->rvlc = get_bits1(VAR_1);\n\n        if (VAR_5 != 1) {\n            VAR_0->new_pred = get_bits1(VAR_1);\n            if (VAR_0->new_pred) {\n                av_log(VAR_2->avctx, VAR_10, \"new pred not supported\\n\");\n                skip_bits(VAR_1, 2); /* COMMENT_62 */\n                skip_bits1(VAR_1);   /* COMMENT_63 */\n            }\n            if (get_bits1(VAR_1)) /* COMMENT_64 */\n                av_log(VAR_2->avctx, VAR_10,\n                       \"reduced resolution VOP not supported\\n\");\n        } else {\n            VAR_0->new_pred = 0;\n        }\n\n        VAR_0->scalability = get_bits1(VAR_1);\n\n        if (VAR_0->scalability) {\n            GetBitContext VAR_28 = *VAR_1;\n            int VAR_29;\n            int VAR_30;\n            int VAR_31;\n            int VAR_32;\n\n            skip_bits1(VAR_1);    /* COMMENT_65 */\n            skip_bits(VAR_1, 4);  /* COMMENT_66 */\n            skip_bits1(VAR_1);    /* COMMENT_67 */\n            VAR_29 = get_bits(VAR_1, 5);\n            VAR_30 = get_bits(VAR_1, 5);\n            VAR_31 = get_bits(VAR_1, 5);\n            VAR_32 = get_bits(VAR_1, 5);\n            VAR_0->enhancement_type = get_bits1(VAR_1);\n\n            if (VAR_29 == 0 || VAR_30 == 0 ||\n                VAR_31 == 0 || VAR_32 == 0) {\n                /* COMMENT_68 */\n                                          \n                VAR_0->scalability = 0;\n                *VAR_1            = VAR_28;\n            } else\n                av_log(VAR_2->avctx, VAR_10, \"scalability not supported\\n\");\n\n            /* COMMENT_70 */\n        }\n    }\n\n    if (VAR_2->avctx->debug&VAR_14) {\n        av_log(VAR_2->avctx, VAR_33, \"tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d,  %s%s%s%s\\n\",\n               VAR_2->avctx->time_base.num, VAR_2->avctx->time_base.den,\n               VAR_0->time_increment_bits,\n               VAR_2->quant_precision,\n               VAR_2->progressive_sequence,\n               VAR_0->scalability ? \"scalability \" :\"\" , VAR_2->quarter_sample ? \"qpel \" : \"\",\n               VAR_2->data_partitioning ? \"partition \" : \"\", VAR_0->rvlc ? \"rvlc \" : \"\"\n        );\n    }\n\n    return 0;\n}",
    "func_graph_path": "ffmpeg/3edc3b159503d512c919b3d5902f7026e961823a/mpeg4videodec.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -218,6 +218,11 @@\n         else\n             s->quarter_sample = 0;\n \n+        if (get_bits_left(gb) < 4) {\n+            av_log(s->avctx, AV_LOG_ERROR, \"VOL Header truncated\\n\");\n+            return AVERROR_INVALIDDATA;\n+        }\n+\n         if (!get_bits1(gb)) {\n             int pos               = get_bits_count(gb);\n             int estimation_method = get_bits(gb, 2);",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "        if (get_bits_left(gb) < 4) {",
            "            av_log(s->avctx, AV_LOG_ERROR, \"VOL Header truncated\\n\");",
            "            return AVERROR_INVALIDDATA;",
            "        }",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}