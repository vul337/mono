{
    "cve_id": "CVE-2019-1010297",
    "cwe_ids": [
        "CWE-190",
        "CWE-787"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "OP-TEE/optee_os",
    "commit_msg": "svc: check for allocation overflow in crypto calls\n\nWithout checking for overflow there is a risk of allocating a buffer\nwith size smaller than anticipated and as a consequence of that it might\nlead to a heap based overflow with attacker controlled data written\noutside the boundaries of the buffer.\n\nFixes: OP-TEE-2018-0010: \"Integer overflow in crypto system calls (x2)\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
    "commit_hash": "a637243270fc1faae16de059091795c32d86e65e",
    "git_url": "https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e",
    "file_path": "core/tee/tee_svc_cryp.c",
    "func_name": "syscall_obj_generate_key",
    "func_before": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
    "abstract_func_before": "TEE_Result syscall_obj_generate_key(unsigned long VAR_0, unsigned long VAR_1,\n\t\t\tconst struct utee_attribute *VAR_2,\n\t\t\tunsigned long VAR_3)\n{\n\tTEE_Result VAR_4;\n\tstruct tee_ta_session *VAR_5;\n\tconst struct tee_cryp_obj_type_props *VAR_6;\n\tstruct tee_obj *VAR_7;\n\tstruct tee_cryp_obj_secret *VAR_8;\n\tsize_t VAR_9;\n\tTEE_Attribute *VAR_10 = NULL;\n\n\tVAR_4 = tee_ta_get_current_session(&VAR_5);\n\tif (VAR_4 != VAR_11)\n\t\treturn VAR_4;\n\n\tVAR_4 = tee_obj_get(to_user_ta_ctx(VAR_5->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(VAR_0), &VAR_7);\n\tif (VAR_4 != VAR_11)\n\t\treturn VAR_4;\n\n\t/* COMMENT_0 */\n\tif ((VAR_7->info.handleFlags & VAR_12) != 0)\n\t\treturn VAR_13;\n\n\t/* COMMENT_1 */\n\tif ((VAR_7->info.handleFlags & VAR_14) != 0)\n\t\treturn VAR_13;\n\n\t/* COMMENT_2 */\n\tVAR_6 = tee_svc_find_type_props(VAR_7->info.objectType);\n\tif (!VAR_6)\n\t\treturn VAR_15;\n\n\t/* COMMENT_3 */\n\tif (VAR_1 % VAR_6->quanta != 0)\n\t\treturn VAR_15;\n\tif (VAR_1 < VAR_6->min_size)\n\t\treturn VAR_15;\n\tif (VAR_1 > VAR_6->max_size)\n\t\treturn VAR_15;\n\n\tVAR_10 = malloc(sizeof(TEE_Attribute) * VAR_3);\n\tif (!VAR_10)\n\t\treturn VAR_16;\n\tVAR_4 = copy_in_attrs(to_user_ta_ctx(VAR_5->ctx), VAR_2, VAR_3,\n\t\t\t    VAR_10);\n\tif (VAR_4 != VAR_11)\n\t\tgoto out;\n\n\tVAR_4 = tee_svc_cryp_check_attr(VAR_17, VAR_6,\n\t\t\t\t      VAR_10, VAR_3);\n\tif (VAR_4 != VAR_11)\n\t\tgoto out;\n\n\tswitch (VAR_7->info.objectType) {\n\tcase VAR_18:\n\tcase VAR_19:\n\tcase VAR_20:\n\tcase VAR_21:\n\tcase VAR_22:\n\tcase VAR_23:\n\tcase VAR_24:\n\tcase VAR_25:\n\tcase VAR_26:\n\tcase VAR_27:\n\t\tVAR_9 = VAR_1 / 8;\n\n\t\t/* COMMENT_4 */\n                                                              \n                                                      \n     \n\t\tif (VAR_7->info.objectType == VAR_19 ||\n\t\t    VAR_7->info.objectType == VAR_20) {\n\t\t\tVAR_9 = (VAR_1 + VAR_1 / 7) / 8;\n\t\t}\n\n\t\tVAR_8 = (struct tee_cryp_obj_secret *)VAR_7->attr;\n\t\tif (VAR_9 > VAR_8->alloc_size) {\n\t\t\tVAR_4 = VAR_28;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_4 = crypto_rng_read((void *)(VAR_8 + 1), VAR_9);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\n\t\tVAR_8->key_size = VAR_9;\n\n\t\t/* COMMENT_8 */\n\t\tVAR_7->have_attrs = (1 << VAR_6->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase VAR_29:\n\t\tVAR_4 = tee_svc_obj_generate_key_rsa(VAR_7, VAR_6, VAR_1,\n\t\t\t\t\t\t   VAR_10, VAR_3);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase VAR_30:\n\t\tVAR_4 = tee_svc_obj_generate_key_dsa(VAR_7, VAR_6, VAR_1);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase VAR_31:\n\t\tVAR_4 = tee_svc_obj_generate_key_dh(VAR_7, VAR_6, VAR_1,\n\t\t\t\t\t\t  VAR_10, VAR_3);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase VAR_32:\n\tcase VAR_33:\n\t\tVAR_4 = tee_svc_obj_generate_key_ecc(VAR_7, VAR_6, VAR_1,\n\t\t\t\t\t\t  VAR_10, VAR_3);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tVAR_4 = VAR_34;\n\t}\n\nout:\n\tfree(VAR_10);\n\tif (VAR_4 == VAR_11) {\n\t\tVAR_7->info.keySize = VAR_1;\n\t\tVAR_7->info.handleFlags |= VAR_14;\n\t}\n\treturn VAR_4;\n}",
    "func_graph_path_before": "OP-TEE/optee_os/a637243270fc1faae16de059091795c32d86e65e/tee_svc_cryp.c/vul/before/1.json",
    "func": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
    "abstract_func": "TEE_Result syscall_obj_generate_key(unsigned long VAR_0, unsigned long VAR_1,\n\t\t\tconst struct utee_attribute *VAR_2,\n\t\t\tunsigned long VAR_3)\n{\n\tTEE_Result VAR_4;\n\tstruct tee_ta_session *VAR_5;\n\tconst struct tee_cryp_obj_type_props *VAR_6;\n\tstruct tee_obj *VAR_7;\n\tstruct tee_cryp_obj_secret *VAR_8;\n\tsize_t VAR_9;\n\tTEE_Attribute *VAR_10 = NULL;\n\n\tVAR_4 = tee_ta_get_current_session(&VAR_5);\n\tif (VAR_4 != VAR_11)\n\t\treturn VAR_4;\n\n\tVAR_4 = tee_obj_get(to_user_ta_ctx(VAR_5->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(VAR_0), &VAR_7);\n\tif (VAR_4 != VAR_11)\n\t\treturn VAR_4;\n\n\t/* COMMENT_0 */\n\tif ((VAR_7->info.handleFlags & VAR_12) != 0)\n\t\treturn VAR_13;\n\n\t/* COMMENT_1 */\n\tif ((VAR_7->info.handleFlags & VAR_14) != 0)\n\t\treturn VAR_13;\n\n\t/* COMMENT_2 */\n\tVAR_6 = tee_svc_find_type_props(VAR_7->info.objectType);\n\tif (!VAR_6)\n\t\treturn VAR_15;\n\n\t/* COMMENT_3 */\n\tif (VAR_1 % VAR_6->quanta != 0)\n\t\treturn VAR_15;\n\tif (VAR_1 < VAR_6->min_size)\n\t\treturn VAR_15;\n\tif (VAR_1 > VAR_6->max_size)\n\t\treturn VAR_15;\n\n\tsize_t VAR_16 = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), VAR_3, &VAR_16))\n\t\treturn VAR_17;\n\n\tVAR_10 = malloc(VAR_16);\n\tif (!VAR_10)\n\t\treturn VAR_18;\n\tVAR_4 = copy_in_attrs(to_user_ta_ctx(VAR_5->ctx), VAR_2, VAR_3,\n\t\t\t    VAR_10);\n\tif (VAR_4 != VAR_11)\n\t\tgoto out;\n\n\tVAR_4 = tee_svc_cryp_check_attr(VAR_19, VAR_6,\n\t\t\t\t      VAR_10, VAR_3);\n\tif (VAR_4 != VAR_11)\n\t\tgoto out;\n\n\tswitch (VAR_7->info.objectType) {\n\tcase VAR_20:\n\tcase VAR_21:\n\tcase VAR_22:\n\tcase VAR_23:\n\tcase VAR_24:\n\tcase VAR_25:\n\tcase VAR_26:\n\tcase VAR_27:\n\tcase VAR_28:\n\tcase VAR_29:\n\t\tVAR_9 = VAR_1 / 8;\n\n\t\t/* COMMENT_4 */\n                                                              \n                                                      \n     \n\t\tif (VAR_7->info.objectType == VAR_21 ||\n\t\t    VAR_7->info.objectType == VAR_22) {\n\t\t\tVAR_9 = (VAR_1 + VAR_1 / 7) / 8;\n\t\t}\n\n\t\tVAR_8 = (struct tee_cryp_obj_secret *)VAR_7->attr;\n\t\tif (VAR_9 > VAR_8->alloc_size) {\n\t\t\tVAR_4 = VAR_30;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_4 = crypto_rng_read((void *)(VAR_8 + 1), VAR_9);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\n\t\tVAR_8->key_size = VAR_9;\n\n\t\t/* COMMENT_8 */\n\t\tVAR_7->have_attrs = (1 << VAR_6->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase VAR_31:\n\t\tVAR_4 = tee_svc_obj_generate_key_rsa(VAR_7, VAR_6, VAR_1,\n\t\t\t\t\t\t   VAR_10, VAR_3);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase VAR_32:\n\t\tVAR_4 = tee_svc_obj_generate_key_dsa(VAR_7, VAR_6, VAR_1);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase VAR_33:\n\t\tVAR_4 = tee_svc_obj_generate_key_dh(VAR_7, VAR_6, VAR_1,\n\t\t\t\t\t\t  VAR_10, VAR_3);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase VAR_34:\n\tcase VAR_35:\n\t\tVAR_4 = tee_svc_obj_generate_key_ecc(VAR_7, VAR_6, VAR_1,\n\t\t\t\t\t\t  VAR_10, VAR_3);\n\t\tif (VAR_4 != VAR_11)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tVAR_4 = VAR_36;\n\t}\n\nout:\n\tfree(VAR_10);\n\tif (VAR_4 == VAR_11) {\n\t\tVAR_7->info.keySize = VAR_1;\n\t\tVAR_7->info.handleFlags |= VAR_14;\n\t}\n\treturn VAR_4;\n}",
    "func_graph_path": "OP-TEE/optee_os/a637243270fc1faae16de059091795c32d86e65e/tee_svc_cryp.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,12 @@\n \tif (key_size > type_props->max_size)\n \t\treturn TEE_ERROR_NOT_SUPPORTED;\n \n-\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n+\tsize_t alloc_size = 0;\n+\n+\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n+\t\treturn TEE_ERROR_OVERFLOW;\n+\n+\tparams = malloc(alloc_size);\n \tif (!params)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,",
    "diff_line_info": {
        "deleted_lines": [
            "\tparams = malloc(sizeof(TEE_Attribute) * param_count);"
        ],
        "added_lines": [
            "\tsize_t alloc_size = 0;",
            "",
            "\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))",
            "\t\treturn TEE_ERROR_OVERFLOW;",
            "",
            "\tparams = malloc(alloc_size);"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/OP-TEE/optee_os/pull/2745",
    "description": "This patch series address a list of potential security issues and (lack of) hardening as identified by [Riscure](https://www.riscure.com/). More details about the issues themselves will be submitted to https://www.op-tee.org/security-advisories in the coming weeks. \r\n\r\nNote that patches here are already \"pre-reviewed\" (internally at Linaro) and the reason for that is that all patches have already been circulated to trustworthy stakeholders according to our disclosure plan (see the draft [here](https://optee.readthedocs.io/general/disclousure.html)). Having that said, we encourage OP-TEE maintainers and other users to chime in and do a final review here on GitHub.\r\n\r\nI've just rebased it on top of master and all tests in xtest passes. "
}