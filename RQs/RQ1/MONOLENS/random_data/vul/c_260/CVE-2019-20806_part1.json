{
    "cve_id": "CVE-2019-20806",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "media: tw5864: Fix possible NULL pointer dereference in tw5864_handle_frame\n\n'vb' null check should be done before dereferencing it in\ntw5864_handle_frame, otherwise a NULL pointer dereference\nmay occur.\n\nFixes: 34d1324edd31 (\"[media] pci: Add tw5864 driver\")\n\nSigned-off-by: YueHaibing <yuehaibing@huawei.com>\nSigned-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>\nSigned-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>",
    "commit_hash": "2e7682ebfc750177a4944eeb56e97a3f05734528",
    "git_url": "https://github.com/torvalds/linux/commit/2e7682ebfc750177a4944eeb56e97a3f05734528",
    "file_path": "drivers/media/pci/tw5864/tw5864-video.c",
    "func_name": "tw5864_handle_frame",
    "func_before": "static void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}",
    "abstract_func_before": "static void tw5864_handle_frame(struct tw5864_h264_frame *VAR_0)\n{\n#define VAR_1 3\n\tstruct tw5864_input *VAR_2 = VAR_0->input;\n\tstruct tw5864_dev *VAR_3 = VAR_2->root;\n\tstruct tw5864_buf *VAR_4;\n\tstruct vb2_v4l2_buffer *VAR_5;\n\tint VAR_6 = VAR_0->vlc_len - VAR_1;\n\tu8 *VAR_7 = VAR_2->buf_cur_ptr;\n\tu8 VAR_8, VAR_9 = 0;\n\tint VAR_10;\n\tu8 VAR_11 = ((u8 *)(VAR_0->vlc.addr + VAR_1))[0];\n\tunsigned long VAR_12;\n\tint VAR_13;\n\tu8 *VAR_14;\n\tu8 *VAR_15;\n\n#ifdef VAR_16\n\tif (VAR_0->checksum !=\n\t    tw5864_vlc_checksum((u32 *)VAR_0->vlc.addr, VAR_6))\n\t\tdev_err(&VAR_3->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&VAR_2->slock, VAR_12);\n\tVAR_4 = VAR_2->vb;\n\tVAR_2->vb = NULL;\n\tspin_unlock_irqrestore(&VAR_2->slock, VAR_12);\n\n\tVAR_5 = to_vb2_v4l2_buffer(&VAR_4->vb.vb2_buf);\n\n\tif (!VAR_4) { /* COMMENT_0 */\n\t\tdev_dbg(&VAR_3->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\t/* COMMENT_1 */\n                    \n                                                        \n    \n\tif (VAR_2->buf_cur_space_left < VAR_6 * 5 / 4) {\n\t\tdev_err_once(&VAR_3->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     VAR_2->buf_cur_space_left, VAR_6);\n\t\treturn;\n\t}\n\n\tfor (VAR_10 = 0; VAR_10 < 8 - VAR_2->tail_nb_bits; VAR_10++)\n\t\tVAR_9 |= 1 << VAR_10;\n\tVAR_8 = (~VAR_9) & 0xff;\n\n\tVAR_7[0] = (VAR_2->tail & VAR_8) | (VAR_11 & VAR_9);\n\tVAR_6--;\n\tVAR_7++;\n\n\t/* COMMENT_5 */\n\tVAR_14 = VAR_0->vlc.addr + VAR_1 + 1;\n\tVAR_15 = VAR_14 + VAR_6;\n\tVAR_13 = 0;\n\tfor (; VAR_14 < VAR_15; VAR_14++) {\n\t\tif (VAR_13 < 2) {\n\t\t\tif (*VAR_14 == 0)\n\t\t\t\t++VAR_13;\n\t\t\telse\n\t\t\t\tVAR_13 = 0;\n\t\t} else {\n\t\t\tif ((*VAR_14 & ~0x03) == 0)\n\t\t\t\t*VAR_7++ = 0x03;\n\t\t\tVAR_13 = *VAR_14 == 0;\n\t\t}\n\t\t*VAR_7++ = *VAR_14;\n\t}\n\n\tvb2_set_plane_payload(&VAR_4->vb.vb2_buf, 0,\n\t\t\t      VAR_7 - (u8 *)vb2_plane_vaddr(&VAR_4->vb.vb2_buf, 0));\n\n\tVAR_4->vb.vb2_buf.timestamp = VAR_0->timestamp;\n\tVAR_5->field = VAR_17;\n\tVAR_5->sequence = VAR_0->seqno;\n\n\t/* COMMENT_6 */\n\tif (VAR_0->gop_seqno /* COMMENT_7 */ &&\n\t    tw5864_is_motion_triggered(VAR_0)) {\n\t\tstruct v4l2_event VAR_18 = {\n\t\t\t.type = VAR_19,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = VAR_20,\n\t\t\t\t.frame_sequence = VAR_5->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&VAR_2->vdev, &VAR_18);\n\t}\n\n\tvb2_buffer_done(&VAR_4->vb.vb2_buf, VAR_21);\n}",
    "func_graph_path_before": "torvalds/linux/2e7682ebfc750177a4944eeb56e97a3f05734528/tw5864-video.c/vul/before/0.json",
    "func": "static void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}",
    "abstract_func": "static void tw5864_handle_frame(struct tw5864_h264_frame *VAR_0)\n{\n#define VAR_1 3\n\tstruct tw5864_input *VAR_2 = VAR_0->input;\n\tstruct tw5864_dev *VAR_3 = VAR_2->root;\n\tstruct tw5864_buf *VAR_4;\n\tstruct vb2_v4l2_buffer *VAR_5;\n\tint VAR_6 = VAR_0->vlc_len - VAR_1;\n\tu8 *VAR_7 = VAR_2->buf_cur_ptr;\n\tu8 VAR_8, VAR_9 = 0;\n\tint VAR_10;\n\tu8 VAR_11 = ((u8 *)(VAR_0->vlc.addr + VAR_1))[0];\n\tunsigned long VAR_12;\n\tint VAR_13;\n\tu8 *VAR_14;\n\tu8 *VAR_15;\n\n#ifdef VAR_16\n\tif (VAR_0->checksum !=\n\t    tw5864_vlc_checksum((u32 *)VAR_0->vlc.addr, VAR_6))\n\t\tdev_err(&VAR_3->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&VAR_2->slock, VAR_12);\n\tVAR_4 = VAR_2->vb;\n\tVAR_2->vb = NULL;\n\tspin_unlock_irqrestore(&VAR_2->slock, VAR_12);\n\n\tif (!VAR_4) { /* COMMENT_0 */\n\t\tdev_dbg(&VAR_3->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\tVAR_5 = to_vb2_v4l2_buffer(&VAR_4->vb.vb2_buf);\n\n\t/* COMMENT_1 */\n                    \n                                                        \n    \n\tif (VAR_2->buf_cur_space_left < VAR_6 * 5 / 4) {\n\t\tdev_err_once(&VAR_3->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     VAR_2->buf_cur_space_left, VAR_6);\n\t\treturn;\n\t}\n\n\tfor (VAR_10 = 0; VAR_10 < 8 - VAR_2->tail_nb_bits; VAR_10++)\n\t\tVAR_9 |= 1 << VAR_10;\n\tVAR_8 = (~VAR_9) & 0xff;\n\n\tVAR_7[0] = (VAR_2->tail & VAR_8) | (VAR_11 & VAR_9);\n\tVAR_6--;\n\tVAR_7++;\n\n\t/* COMMENT_5 */\n\tVAR_14 = VAR_0->vlc.addr + VAR_1 + 1;\n\tVAR_15 = VAR_14 + VAR_6;\n\tVAR_13 = 0;\n\tfor (; VAR_14 < VAR_15; VAR_14++) {\n\t\tif (VAR_13 < 2) {\n\t\t\tif (*VAR_14 == 0)\n\t\t\t\t++VAR_13;\n\t\t\telse\n\t\t\t\tVAR_13 = 0;\n\t\t} else {\n\t\t\tif ((*VAR_14 & ~0x03) == 0)\n\t\t\t\t*VAR_7++ = 0x03;\n\t\t\tVAR_13 = *VAR_14 == 0;\n\t\t}\n\t\t*VAR_7++ = *VAR_14;\n\t}\n\n\tvb2_set_plane_payload(&VAR_4->vb.vb2_buf, 0,\n\t\t\t      VAR_7 - (u8 *)vb2_plane_vaddr(&VAR_4->vb.vb2_buf, 0));\n\n\tVAR_4->vb.vb2_buf.timestamp = VAR_0->timestamp;\n\tVAR_5->field = VAR_17;\n\tVAR_5->sequence = VAR_0->seqno;\n\n\t/* COMMENT_6 */\n\tif (VAR_0->gop_seqno /* COMMENT_7 */ &&\n\t    tw5864_is_motion_triggered(VAR_0)) {\n\t\tstruct v4l2_event VAR_18 = {\n\t\t\t.type = VAR_19,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = VAR_20,\n\t\t\t\t.frame_sequence = VAR_5->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&VAR_2->vdev, &VAR_18);\n\t}\n\n\tvb2_buffer_done(&VAR_4->vb.vb2_buf, VAR_21);\n}",
    "func_graph_path": "torvalds/linux/2e7682ebfc750177a4944eeb56e97a3f05734528/tw5864-video.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -27,12 +27,12 @@\n \tinput->vb = NULL;\n \tspin_unlock_irqrestore(&input->slock, flags);\n \n-\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n-\n \tif (!vb) { /* Gone because of disabling */\n \t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n \t\treturn;\n \t}\n+\n+\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n \n \t/*\n \t * Check for space.",
    "diff_line_info": {
        "deleted_lines": [
            "\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);",
            ""
        ],
        "added_lines": [
            "",
            "\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}