{
    "cve_id": "CVE-2019-17347",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "xen-project/xen",
    "commit_msg": "x86/pv: Rewrite guest %cr4 handling from scratch\n\nThe PV cr4 logic is almost impossible to follow, and leaks bits into guest\ncontext which definitely shouldn't be visible (in particular, VMXE).\n\nThe biggest problem however, and source of the complexity, is that it derives\nnew real and guest cr4 values from the current value in hardware - this is\ncontext dependent and an inappropriate source of information.\n\nRewrite the cr4 logic to be invariant of the current value in hardware.\n\nFirst of all, modify write_ptbase() to always use mmu_cr4_features for IDLE\nand HVM contexts.  mmu_cr4_features *is* the correct value to use, and makes\nthe ASSERT() obviously redundant.\n\nFor PV guests, curr->arch.pv.ctrlreg[4] remains the guests view of cr4, but\nall logic gets reworked in terms of this and mmu_cr4_features only.\n\nTwo masks are introduced; bits which the guest has control over, and bits\nwhich are forwarded from Xen's settings.  One guest-visible change here is\nthat Xen's VMXE setting is no longer visible at all.\n\npv_make_cr4() follows fairly closely from pv_guest_cr4_to_real_cr4(), but\ndeliberately starts with mmu_cr4_features, and only alters the minimal subset\nof bits.\n\nThe boot-time {compat_,}pv_cr4_mask variables are removed, as they are a\nremnant of the pre-CPUID policy days.  pv_fixup_guest_cr4() gains a related\nderivation from the policy.\n\nAnother guest visible change here is that a 32bit PV guest can now flip\nFSGSBASE in its view of CR4.  While the {RD,WR}{FS,GS}BASE instructions are\nunusable outside of a 64bit code segment, the ability to modify FSGSBASE\nmatches real hardware behaviour, and avoids the need for any 32bit/64bit\ndifferences in the logic.\n\nOverall, this patch shouldn't have a practical change in guest behaviour.\nVMXE will disappear from view, and an inquisitive 32bit kernel can now see\nFSGSBASE changing, but this new logic is otherwise bug-compatible with before.\n\nThis is part of XSA-293.\n\nSigned-off-by: Andrew Cooper <andrew.cooper3@citrix.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>",
    "commit_hash": "b2dd00574a4fc87ca964177f8e752a968c27efb2",
    "git_url": "https://github.com/xen-project/xen/commit/b2dd00574a4fc87ca964177f8e752a968c27efb2",
    "file_path": "xen/arch/x86/pv/emul-priv-op.c",
    "func_name": "write_cr",
    "func_before": "static int write_cr(unsigned int reg, unsigned long val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n\n    switch ( reg )\n    {\n    case 0: /* Write CR0 */\n        if ( (val ^ read_cr0()) & ~X86_CR0_TS )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Attempt to change unmodifiable CR0 flags\\n\");\n            break;\n        }\n        do_fpu_taskswitch(!!(val & X86_CR0_TS));\n        return X86EMUL_OKAY;\n\n    case 2: /* Write CR2 */\n        curr->arch.pv.ctrlreg[2] = val;\n        arch_set_cr2(curr, val);\n        return X86EMUL_OKAY;\n\n    case 3: /* Write CR3 */\n    {\n        struct domain *currd = curr->domain;\n        unsigned long gfn;\n        struct page_info *page;\n        int rc;\n\n        gfn = !is_pv_32bit_domain(currd)\n              ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);\n        page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);\n        if ( !page )\n            break;\n        rc = new_guest_cr3(page_to_mfn(page));\n        put_page(page);\n\n        switch ( rc )\n        {\n        case 0:\n            return X86EMUL_OKAY;\n        case -ERESTART: /* retry after preemption */\n            return X86EMUL_RETRY;\n        }\n        break;\n    }\n\n    case 4: /* Write CR4 */\n        curr->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(curr, val);\n        write_cr4(pv_guest_cr4_to_real_cr4(curr));\n        ctxt_switch_levelling(curr);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}",
    "abstract_func_before": "static int write_cr(unsigned int VAR_0, unsigned long VAR_1,\n                    struct x86_emulate_ctxt *VAR_2)\n{\n    struct vcpu *VAR_3 = VAR_4;\n\n    switch ( VAR_0 )\n    {\n    case 0: /* COMMENT_0 */\n        if ( (VAR_1 ^ read_cr0()) & ~VAR_5 )\n        {\n            gdprintk(VAR_6,\n                     \"Attempt to change unmodifiable CR0 flags\\n\");\n            break;\n        }\n        do_fpu_taskswitch(!!(VAR_1 & VAR_5));\n        return VAR_7;\n\n    case 2: /* COMMENT_1 */\n        VAR_3->arch.pv.ctrlreg[2] = VAR_1;\n        arch_set_cr2(VAR_3, VAR_1);\n        return VAR_7;\n\n    case 3: /* COMMENT_2 */\n    {\n        struct domain *VAR_8 = VAR_3->domain;\n        unsigned long VAR_9;\n        struct page_info *VAR_10;\n        int VAR_11;\n\n        VAR_9 = !is_pv_32bit_domain(VAR_8)\n              ? xen_cr3_to_pfn(VAR_1) : compat_cr3_to_pfn(VAR_1);\n        VAR_10 = get_page_from_gfn(VAR_8, VAR_9, NULL, VAR_12);\n        if ( !VAR_10 )\n            break;\n        VAR_11 = new_guest_cr3(page_to_mfn(VAR_10));\n        put_page(VAR_10);\n\n        switch ( VAR_11 )\n        {\n        case 0:\n            return VAR_7;\n        case -VAR_13: /* COMMENT_3 */\n            return VAR_14;\n        }\n        break;\n    }\n\n    case 4: /* COMMENT_4 */\n        VAR_3->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(VAR_3, VAR_1);\n        write_cr4(pv_guest_cr4_to_real_cr4(VAR_3));\n        ctxt_switch_levelling(VAR_3);\n        return VAR_7;\n    }\n\n    return VAR_15;\n}",
    "func_graph_path_before": "xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/emul-priv-op.c/vul/before/0.json",
    "func": "static int write_cr(unsigned int reg, unsigned long val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n\n    switch ( reg )\n    {\n    case 0: /* Write CR0 */\n        if ( (val ^ read_cr0()) & ~X86_CR0_TS )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Attempt to change unmodifiable CR0 flags\\n\");\n            break;\n        }\n        do_fpu_taskswitch(!!(val & X86_CR0_TS));\n        return X86EMUL_OKAY;\n\n    case 2: /* Write CR2 */\n        curr->arch.pv.ctrlreg[2] = val;\n        arch_set_cr2(curr, val);\n        return X86EMUL_OKAY;\n\n    case 3: /* Write CR3 */\n    {\n        struct domain *currd = curr->domain;\n        unsigned long gfn;\n        struct page_info *page;\n        int rc;\n\n        gfn = !is_pv_32bit_domain(currd)\n              ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);\n        page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);\n        if ( !page )\n            break;\n        rc = new_guest_cr3(page_to_mfn(page));\n        put_page(page);\n\n        switch ( rc )\n        {\n        case 0:\n            return X86EMUL_OKAY;\n        case -ERESTART: /* retry after preemption */\n            return X86EMUL_RETRY;\n        }\n        break;\n    }\n\n    case 4: /* Write CR4 */\n        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);\n        write_cr4(pv_make_cr4(curr));\n        ctxt_switch_levelling(curr);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}",
    "abstract_func": "static int write_cr(unsigned int VAR_0, unsigned long VAR_1,\n                    struct x86_emulate_ctxt *VAR_2)\n{\n    struct vcpu *VAR_3 = VAR_4;\n\n    switch ( VAR_0 )\n    {\n    case 0: /* COMMENT_0 */\n        if ( (VAR_1 ^ read_cr0()) & ~VAR_5 )\n        {\n            gdprintk(VAR_6,\n                     \"Attempt to change unmodifiable CR0 flags\\n\");\n            break;\n        }\n        do_fpu_taskswitch(!!(VAR_1 & VAR_5));\n        return VAR_7;\n\n    case 2: /* COMMENT_1 */\n        VAR_3->arch.pv.ctrlreg[2] = VAR_1;\n        arch_set_cr2(VAR_3, VAR_1);\n        return VAR_7;\n\n    case 3: /* COMMENT_2 */\n    {\n        struct domain *VAR_8 = VAR_3->domain;\n        unsigned long VAR_9;\n        struct page_info *VAR_10;\n        int VAR_11;\n\n        VAR_9 = !is_pv_32bit_domain(VAR_8)\n              ? xen_cr3_to_pfn(VAR_1) : compat_cr3_to_pfn(VAR_1);\n        VAR_10 = get_page_from_gfn(VAR_8, VAR_9, NULL, VAR_12);\n        if ( !VAR_10 )\n            break;\n        VAR_11 = new_guest_cr3(page_to_mfn(VAR_10));\n        put_page(VAR_10);\n\n        switch ( VAR_11 )\n        {\n        case 0:\n            return VAR_7;\n        case -VAR_13: /* COMMENT_3 */\n            return VAR_14;\n        }\n        break;\n    }\n\n    case 4: /* COMMENT_4 */\n        VAR_3->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(VAR_3, VAR_1);\n        write_cr4(pv_make_cr4(VAR_3));\n        ctxt_switch_levelling(VAR_3);\n        return VAR_7;\n    }\n\n    return VAR_15;\n}",
    "func_graph_path": "xen-project/xen/b2dd00574a4fc87ca964177f8e752a968c27efb2/emul-priv-op.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -46,8 +46,8 @@\n     }\n \n     case 4: /* Write CR4 */\n-        curr->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(curr, val);\n-        write_cr4(pv_guest_cr4_to_real_cr4(curr));\n+        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);\n+        write_cr4(pv_make_cr4(curr));\n         ctxt_switch_levelling(curr);\n         return X86EMUL_OKAY;\n     }",
    "diff_line_info": {
        "deleted_lines": [
            "        curr->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(curr, val);",
            "        write_cr4(pv_guest_cr4_to_real_cr4(curr));"
        ],
        "added_lines": [
            "        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);",
            "        write_cr4(pv_make_cr4(curr));"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}