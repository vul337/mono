{
    "cve_id": "CVE-2013-6657",
    "cwe_ids": [
        "CWE-264"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "chromium",
    "commit_msg": "Use data:, rather than about:blank as a substitute form action so the resulting blank page will have an unique origin.\n\nThis is similar to the work we did in XSSAuditorDelegate for the mode=block\ncase, where we used the SecurityOrigin::urlWithUniqueOrign constant.  We can't\nuse that here due to threading.\n\nTesting is covered by rebasing the existing test cases.\nBUG=331060\nR=abarth@chromium.org\n\nReview URL: https://codereview.chromium.org/124973004\n\ngit-svn-id: svn://svn.chromium.org/blink/trunk@164538 bbb929c8-8fbe-4397-9dbb-9b2b20218538",
    "commit_hash": "a6d23b1b720689b2247e9e046f0be4e1eaf8f314",
    "git_url": "https://github.com/chromium/chromium/commit/a6d23b1b720689b2247e9e046f0be4e1eaf8f314",
    "file_path": "third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp",
    "func_name": "XSSAuditor::filterFormToken",
    "func_before": "bool XSSAuditor::filterFormToken(const FilterTokenRequest& request)\n{\n    ASSERT(request.token.type() == HTMLToken::StartTag);\n    ASSERT(hasName(request.token, formTag));\n\n    return eraseAttributeIfInjected(request, actionAttr, blankURL().string());\n}",
    "abstract_func_before": "bool XSSAuditor::filterFormToken(const FilterTokenRequest& VAR_0)\n{\n    ASSERT(VAR_0.token.type() == HTMLToken::StartTag);\n    ASSERT(hasName(VAR_0.token, VAR_1));\n\n    return eraseAttributeIfInjected(VAR_0, VAR_2, blankURL().string());\n}",
    "func_graph_path_before": "chromium/a6d23b1b720689b2247e9e046f0be4e1eaf8f314/XSSAuditor.cpp/vul/before/1.json",
    "func": "bool XSSAuditor::filterFormToken(const FilterTokenRequest& request)\n{\n    ASSERT(request.token.type() == HTMLToken::StartTag);\n    ASSERT(hasName(request.token, formTag));\n\n    return eraseAttributeIfInjected(request, actionAttr, kURLWithUniqueOrigin);\n}",
    "abstract_func": "bool XSSAuditor::filterFormToken(const FilterTokenRequest& VAR_0)\n{\n    ASSERT(VAR_0.token.type() == HTMLToken::StartTag);\n    ASSERT(hasName(VAR_0.token, VAR_1));\n\n    return eraseAttributeIfInjected(VAR_0, VAR_2, VAR_3);\n}",
    "func_graph_path": "chromium/a6d23b1b720689b2247e9e046f0be4e1eaf8f314/XSSAuditor.cpp/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -3,5 +3,5 @@\n     ASSERT(request.token.type() == HTMLToken::StartTag);\n     ASSERT(hasName(request.token, formTag));\n \n-    return eraseAttributeIfInjected(request, actionAttr, blankURL().string());\n+    return eraseAttributeIfInjected(request, actionAttr, kURLWithUniqueOrigin);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "    return eraseAttributeIfInjected(request, actionAttr, blankURL().string());"
        ],
        "added_lines": [
            "    return eraseAttributeIfInjected(request, actionAttr, kURLWithUniqueOrigin);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}