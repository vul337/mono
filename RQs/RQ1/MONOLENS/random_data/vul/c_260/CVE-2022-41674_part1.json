{
    "cve_id": "CVE-2022-41674",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "kernel/git/wireless/wireless",
    "commit_msg": "In the copy code of the elements, we do the following calculation\nto reach the end of the MBSSID element:\n\n\t/* copy the IEs after MBSSID */\n\tcpy_len = mbssid[1] + 2;\n\nThis looks fine, however, cpy_len is a u8, the same as mbssid[1],\nso the addition of two can overflow. In this case the subsequent\nmemcpy() will overflow the allocated buffer, since it copies 256\nbytes too much due to the way the allocation and memcpy() sizes\nare calculated.\n\nFix this by using size_t for the cpy_len variable.\n\nThis fixes CVE-2022-41674.\n\nReported-by: Soenke Huster <shuster@seemoo.tu-darmstadt.de>\nTested-by: Soenke Huster <shuster@seemoo.tu-darmstadt.de>\nFixes: 0b8fb8235be8 (\"cfg80211: Parsing of Multiple BSSID information in scanning\")\nReviewed-by: Kees Cook <keescook@chromium.org>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>\n",
    "commit_hash": "aebe9f4639b13a1f4e9a6b42cdd2e38c617b442d",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/wireless/wireless.git/commit/?h=aebe9f4639b13a1f4e9a6b42cdd2e38c617b442d",
    "file_path": "net/wireless/scan.c",
    "func_name": "cfg80211_update_notlisted_nontrans",
    "func_before": "static void\ncfg80211_update_notlisted_nontrans(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_bss *nontrans_bss,\n\t\t\t\t   struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tu8 *ie, *new_ie, *pos;\n\tconst struct element *nontrans_ssid;\n\tconst u8 *trans_ssid, *mbssid;\n\tsize_t ielen = len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t      u.probe_resp.variable);\n\tsize_t new_ie_len;\n\tstruct cfg80211_bss_ies *new_ies;\n\tconst struct cfg80211_bss_ies *old;\n\tu8 cpy_len;\n\n\tlockdep_assert_held(&wiphy_to_rdev(wiphy)->bss_lock);\n\n\tie = mgmt->u.probe_resp.variable;\n\n\tnew_ie_len = ielen;\n\ttrans_ssid = cfg80211_find_ie(WLAN_EID_SSID, ie, ielen);\n\tif (!trans_ssid)\n\t\treturn;\n\tnew_ie_len -= trans_ssid[1];\n\tmbssid = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen);\n\t/*\n\t * It's not valid to have the MBSSID element before SSID\n\t * ignore if that happens - the code below assumes it is\n\t * after (while copying things inbetween).\n\t */\n\tif (!mbssid || mbssid < trans_ssid)\n\t\treturn;\n\tnew_ie_len -= mbssid[1];\n\n\tnontrans_ssid = ieee80211_bss_get_elem(nontrans_bss, WLAN_EID_SSID);\n\tif (!nontrans_ssid)\n\t\treturn;\n\n\tnew_ie_len += nontrans_ssid->datalen;\n\n\t/* generate new ie for nontrans BSS\n\t * 1. replace SSID with nontrans BSS' SSID\n\t * 2. skip MBSSID IE\n\t */\n\tnew_ie = kzalloc(new_ie_len, GFP_ATOMIC);\n\tif (!new_ie)\n\t\treturn;\n\n\tnew_ies = kzalloc(sizeof(*new_ies) + new_ie_len, GFP_ATOMIC);\n\tif (!new_ies)\n\t\tgoto out_free;\n\n\tpos = new_ie;\n\n\t/* copy the nontransmitted SSID */\n\tcpy_len = nontrans_ssid->datalen + 2;\n\tmemcpy(pos, nontrans_ssid, cpy_len);\n\tpos += cpy_len;\n\t/* copy the IEs between SSID and MBSSID */\n\tcpy_len = trans_ssid[1] + 2;\n\tmemcpy(pos, (trans_ssid + cpy_len), (mbssid - (trans_ssid + cpy_len)));\n\tpos += (mbssid - (trans_ssid + cpy_len));\n\t/* copy the IEs after MBSSID */\n\tcpy_len = mbssid[1] + 2;\n\tmemcpy(pos, mbssid + cpy_len, ((ie + ielen) - (mbssid + cpy_len)));\n\n\t/* update ie */\n\tnew_ies->len = new_ie_len;\n\tnew_ies->tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);\n\tnew_ies->from_beacon = ieee80211_is_beacon(mgmt->frame_control);\n\tmemcpy(new_ies->data, new_ie, new_ie_len);\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\told = rcu_access_pointer(nontrans_bss->proberesp_ies);\n\t\trcu_assign_pointer(nontrans_bss->proberesp_ies, new_ies);\n\t\trcu_assign_pointer(nontrans_bss->ies, new_ies);\n\t\tif (old)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);\n\t} else {\n\t\told = rcu_access_pointer(nontrans_bss->beacon_ies);\n\t\trcu_assign_pointer(nontrans_bss->beacon_ies, new_ies);\n\t\trcu_assign_pointer(nontrans_bss->ies, new_ies);\n\t\tif (old)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);\n\t}\n\nout_free:\n\tkfree(new_ie);\n}",
    "abstract_func_before": "static void\ncfg80211_update_notlisted_nontrans(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_bss *VAR_0,\n\t\t\t\t   struct ieee80211_mgmt *VAR_1, size_t VAR_2)\n{\n\tu8 *VAR_3, *VAR_4, *VAR_5;\n\tconst struct element *VAR_6;\n\tconst u8 *VAR_7, *VAR_8;\n\tsize_t VAR_9 = VAR_2 - offsetof(struct ieee80211_mgmt,\n\t\t\t\t      VAR_10.probe_resp.variable);\n\tsize_t VAR_11;\n\tstruct cfg80211_bss_ies *VAR_12;\n\tconst struct cfg80211_bss_ies *VAR_13;\n\tu8 VAR_14;\n\n\tlockdep_assert_held(&wiphy_to_rdev(wiphy)->bss_lock);\n\n\tVAR_3 = VAR_1->u.probe_resp.variable;\n\n\tVAR_11 = VAR_9;\n\tVAR_7 = cfg80211_find_ie(VAR_15, VAR_3, VAR_9);\n\tif (!VAR_7)\n\t\treturn;\n\tVAR_11 -= VAR_7[1];\n\tVAR_8 = cfg80211_find_ie(VAR_16, VAR_3, VAR_9);\n\t/* COMMENT_0 */\n                                                         \n                                                         \n                                           \n    \n\tif (!VAR_8 || VAR_8 < VAR_7)\n\t\treturn;\n\tVAR_11 -= VAR_8[1];\n\n\tVAR_6 = ieee80211_bss_get_elem(VAR_0, VAR_15);\n\tif (!VAR_6)\n\t\treturn;\n\n\tVAR_11 += VAR_6->datalen;\n\n\t/* COMMENT_5 */\n                                           \n                     \n    \n\tVAR_4 = kzalloc(VAR_11, VAR_17);\n\tif (!VAR_4)\n\t\treturn;\n\n\tVAR_12 = kzalloc(sizeof(*VAR_12) + VAR_11, VAR_17);\n\tif (!VAR_12)\n\t\tgoto out_free;\n\n\tVAR_5 = VAR_4;\n\n\t/* COMMENT_9 */\n\tVAR_14 = VAR_6->datalen + 2;\n\tmemcpy(VAR_5, VAR_6, VAR_14);\n\tVAR_5 += VAR_14;\n\t/* COMMENT_10 */\n\tVAR_14 = VAR_7[1] + 2;\n\tmemcpy(VAR_5, (VAR_7 + VAR_14), (VAR_8 - (VAR_7 + VAR_14)));\n\tVAR_5 += (VAR_8 - (VAR_7 + VAR_14));\n\t/* COMMENT_11 */\n\tVAR_14 = VAR_8[1] + 2;\n\tmemcpy(VAR_5, VAR_8 + VAR_14, ((VAR_3 + VAR_9) - (VAR_8 + VAR_14)));\n\n\t/* COMMENT_12 */\n\tVAR_12->len = VAR_11;\n\tVAR_12->tsf = le64_to_cpu(VAR_1->u.probe_resp.timestamp);\n\tVAR_12->from_beacon = ieee80211_is_beacon(VAR_1->frame_control);\n\tmemcpy(VAR_12->data, VAR_4, VAR_11);\n\tif (ieee80211_is_probe_resp(VAR_1->frame_control)) {\n\t\tVAR_13 = rcu_access_pointer(VAR_0->proberesp_ies);\n\t\trcu_assign_pointer(VAR_0->proberesp_ies, VAR_12);\n\t\trcu_assign_pointer(VAR_0->ies, VAR_12);\n\t\tif (VAR_13)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)VAR_13, VAR_18);\n\t} else {\n\t\tVAR_13 = rcu_access_pointer(VAR_0->beacon_ies);\n\t\trcu_assign_pointer(VAR_0->beacon_ies, VAR_12);\n\t\trcu_assign_pointer(VAR_0->ies, VAR_12);\n\t\tif (VAR_13)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)VAR_13, VAR_18);\n\t}\n\nout_free:\n\tkfree(VAR_4);\n}",
    "func_graph_path_before": "kernel/git/wireless/wireless/aebe9f4639b13a1f4e9a6b42cdd2e38c617b442d/scan.c/vul/before/0.json",
    "func": "static void\ncfg80211_update_notlisted_nontrans(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_bss *nontrans_bss,\n\t\t\t\t   struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tu8 *ie, *new_ie, *pos;\n\tconst struct element *nontrans_ssid;\n\tconst u8 *trans_ssid, *mbssid;\n\tsize_t ielen = len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t      u.probe_resp.variable);\n\tsize_t new_ie_len;\n\tstruct cfg80211_bss_ies *new_ies;\n\tconst struct cfg80211_bss_ies *old;\n\tsize_t cpy_len;\n\n\tlockdep_assert_held(&wiphy_to_rdev(wiphy)->bss_lock);\n\n\tie = mgmt->u.probe_resp.variable;\n\n\tnew_ie_len = ielen;\n\ttrans_ssid = cfg80211_find_ie(WLAN_EID_SSID, ie, ielen);\n\tif (!trans_ssid)\n\t\treturn;\n\tnew_ie_len -= trans_ssid[1];\n\tmbssid = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen);\n\t/*\n\t * It's not valid to have the MBSSID element before SSID\n\t * ignore if that happens - the code below assumes it is\n\t * after (while copying things inbetween).\n\t */\n\tif (!mbssid || mbssid < trans_ssid)\n\t\treturn;\n\tnew_ie_len -= mbssid[1];\n\n\tnontrans_ssid = ieee80211_bss_get_elem(nontrans_bss, WLAN_EID_SSID);\n\tif (!nontrans_ssid)\n\t\treturn;\n\n\tnew_ie_len += nontrans_ssid->datalen;\n\n\t/* generate new ie for nontrans BSS\n\t * 1. replace SSID with nontrans BSS' SSID\n\t * 2. skip MBSSID IE\n\t */\n\tnew_ie = kzalloc(new_ie_len, GFP_ATOMIC);\n\tif (!new_ie)\n\t\treturn;\n\n\tnew_ies = kzalloc(sizeof(*new_ies) + new_ie_len, GFP_ATOMIC);\n\tif (!new_ies)\n\t\tgoto out_free;\n\n\tpos = new_ie;\n\n\t/* copy the nontransmitted SSID */\n\tcpy_len = nontrans_ssid->datalen + 2;\n\tmemcpy(pos, nontrans_ssid, cpy_len);\n\tpos += cpy_len;\n\t/* copy the IEs between SSID and MBSSID */\n\tcpy_len = trans_ssid[1] + 2;\n\tmemcpy(pos, (trans_ssid + cpy_len), (mbssid - (trans_ssid + cpy_len)));\n\tpos += (mbssid - (trans_ssid + cpy_len));\n\t/* copy the IEs after MBSSID */\n\tcpy_len = mbssid[1] + 2;\n\tmemcpy(pos, mbssid + cpy_len, ((ie + ielen) - (mbssid + cpy_len)));\n\n\t/* update ie */\n\tnew_ies->len = new_ie_len;\n\tnew_ies->tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);\n\tnew_ies->from_beacon = ieee80211_is_beacon(mgmt->frame_control);\n\tmemcpy(new_ies->data, new_ie, new_ie_len);\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\told = rcu_access_pointer(nontrans_bss->proberesp_ies);\n\t\trcu_assign_pointer(nontrans_bss->proberesp_ies, new_ies);\n\t\trcu_assign_pointer(nontrans_bss->ies, new_ies);\n\t\tif (old)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);\n\t} else {\n\t\told = rcu_access_pointer(nontrans_bss->beacon_ies);\n\t\trcu_assign_pointer(nontrans_bss->beacon_ies, new_ies);\n\t\trcu_assign_pointer(nontrans_bss->ies, new_ies);\n\t\tif (old)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);\n\t}\n\nout_free:\n\tkfree(new_ie);\n}",
    "abstract_func": "static void\ncfg80211_update_notlisted_nontrans(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_bss *VAR_0,\n\t\t\t\t   struct ieee80211_mgmt *VAR_1, size_t VAR_2)\n{\n\tu8 *VAR_3, *VAR_4, *VAR_5;\n\tconst struct element *VAR_6;\n\tconst u8 *VAR_7, *VAR_8;\n\tsize_t VAR_9 = VAR_2 - offsetof(struct ieee80211_mgmt,\n\t\t\t\t      VAR_10.probe_resp.variable);\n\tsize_t VAR_11;\n\tstruct cfg80211_bss_ies *VAR_12;\n\tconst struct cfg80211_bss_ies *VAR_13;\n\tsize_t VAR_14;\n\n\tlockdep_assert_held(&wiphy_to_rdev(wiphy)->bss_lock);\n\n\tVAR_3 = VAR_1->u.probe_resp.variable;\n\n\tVAR_11 = VAR_9;\n\tVAR_7 = cfg80211_find_ie(VAR_15, VAR_3, VAR_9);\n\tif (!VAR_7)\n\t\treturn;\n\tVAR_11 -= VAR_7[1];\n\tVAR_8 = cfg80211_find_ie(VAR_16, VAR_3, VAR_9);\n\t/* COMMENT_0 */\n                                                         \n                                                         \n                                           \n    \n\tif (!VAR_8 || VAR_8 < VAR_7)\n\t\treturn;\n\tVAR_11 -= VAR_8[1];\n\n\tVAR_6 = ieee80211_bss_get_elem(VAR_0, VAR_15);\n\tif (!VAR_6)\n\t\treturn;\n\n\tVAR_11 += VAR_6->datalen;\n\n\t/* COMMENT_5 */\n                                           \n                     \n    \n\tVAR_4 = kzalloc(VAR_11, VAR_17);\n\tif (!VAR_4)\n\t\treturn;\n\n\tVAR_12 = kzalloc(sizeof(*VAR_12) + VAR_11, VAR_17);\n\tif (!VAR_12)\n\t\tgoto out_free;\n\n\tVAR_5 = VAR_4;\n\n\t/* COMMENT_9 */\n\tVAR_14 = VAR_6->datalen + 2;\n\tmemcpy(VAR_5, VAR_6, VAR_14);\n\tVAR_5 += VAR_14;\n\t/* COMMENT_10 */\n\tVAR_14 = VAR_7[1] + 2;\n\tmemcpy(VAR_5, (VAR_7 + VAR_14), (VAR_8 - (VAR_7 + VAR_14)));\n\tVAR_5 += (VAR_8 - (VAR_7 + VAR_14));\n\t/* COMMENT_11 */\n\tVAR_14 = VAR_8[1] + 2;\n\tmemcpy(VAR_5, VAR_8 + VAR_14, ((VAR_3 + VAR_9) - (VAR_8 + VAR_14)));\n\n\t/* COMMENT_12 */\n\tVAR_12->len = VAR_11;\n\tVAR_12->tsf = le64_to_cpu(VAR_1->u.probe_resp.timestamp);\n\tVAR_12->from_beacon = ieee80211_is_beacon(VAR_1->frame_control);\n\tmemcpy(VAR_12->data, VAR_4, VAR_11);\n\tif (ieee80211_is_probe_resp(VAR_1->frame_control)) {\n\t\tVAR_13 = rcu_access_pointer(VAR_0->proberesp_ies);\n\t\trcu_assign_pointer(VAR_0->proberesp_ies, VAR_12);\n\t\trcu_assign_pointer(VAR_0->ies, VAR_12);\n\t\tif (VAR_13)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)VAR_13, VAR_18);\n\t} else {\n\t\tVAR_13 = rcu_access_pointer(VAR_0->beacon_ies);\n\t\trcu_assign_pointer(VAR_0->beacon_ies, VAR_12);\n\t\trcu_assign_pointer(VAR_0->ies, VAR_12);\n\t\tif (VAR_13)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)VAR_13, VAR_18);\n\t}\n\nout_free:\n\tkfree(VAR_4);\n}",
    "func_graph_path": "kernel/git/wireless/wireless/aebe9f4639b13a1f4e9a6b42cdd2e38c617b442d/scan.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \tsize_t new_ie_len;\n \tstruct cfg80211_bss_ies *new_ies;\n \tconst struct cfg80211_bss_ies *old;\n-\tu8 cpy_len;\n+\tsize_t cpy_len;\n \n \tlockdep_assert_held(&wiphy_to_rdev(wiphy)->bss_lock);\n ",
    "diff_line_info": {
        "deleted_lines": [
            "\tu8 cpy_len;"
        ],
        "added_lines": [
            "\tsize_t cpy_len;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}