{
    "cve_id": "CVE-2016-0798",
    "cwe_ids": [
        "CWE-399"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "openssl",
    "commit_msg": "\nCVE-2016-0798: avoid memory leak in SRP\n\nThe SRP user database lookup method SRP_VBASE_get_by_user had confusing\nmemory management semantics; the returned pointer was sometimes newly\nallocated, and sometimes owned by the callee. The calling code has no\nway of distinguishing these two cases.\n\nSpecifically, SRP servers that configure a secret seed to hide valid\nlogin information are vulnerable to a memory leak: an attacker\nconnecting with an invalid username can cause a memory leak of around\n300 bytes per connection.\n\nServers that do not configure SRP, or configure SRP but do not configure\na seed are not vulnerable.\n\nIn Apache, the seed directive is known as SSLSRPUnknownUserSeed.\n\nTo mitigate the memory leak, the seed handling in SRP_VBASE_get_by_user\nis now disabled even if the user has configured a seed.\n\nApplications are advised to migrate to SRP_VBASE_get1_by_user. However,\nnote that OpenSSL makes no strong guarantees about the\nindistinguishability of valid and invalid logins. In particular,\ncomputations are currently not carried out in constant time.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n",
    "commit_hash": "259b664f950c2ba66fbf4b0fe5281327904ead21",
    "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=259b664f950c2ba66fbf4b0fe5281327904ead21",
    "file_path": "apps/s_server.c",
    "func_name": "sv_body",
    "func_before": "static int sv_body(char *hostname, int s, int stype, unsigned char *context)\n{\n    char *buf = NULL;\n    fd_set readfds;\n    int ret = 1, width;\n    int k, i;\n    unsigned long l;\n    SSL *con = NULL;\n    BIO *sbio;\n#ifndef OPENSSL_NO_KRB5\n    KSSL_CTX *kctx;\n#endif\n    struct timeval timeout;\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)\n    struct timeval tv;\n#else\n    struct timeval *timeoutp;\n#endif\n\n    if ((buf = OPENSSL_malloc(bufsize)) == NULL) {\n        BIO_printf(bio_err, \"out of memory\\n\");\n        goto err;\n    }\n#ifdef FIONBIO\n    if (s_nbio) {\n        unsigned long sl = 1;\n\n        if (!s_quiet)\n            BIO_printf(bio_err, \"turning on non blocking io\\n\");\n        if (BIO_socket_ioctl(s, FIONBIO, &sl) < 0)\n            ERR_print_errors(bio_err);\n    }\n#endif\n\n    if (con == NULL) {\n        con = SSL_new(ctx);\n#ifndef OPENSSL_NO_TLSEXT\n        if (s_tlsextdebug) {\n            SSL_set_tlsext_debug_callback(con, tlsext_cb);\n            SSL_set_tlsext_debug_arg(con, bio_s_out);\n        }\n        if (s_tlsextstatus) {\n            SSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);\n            tlscstatp.err = bio_err;\n            SSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);\n        }\n#endif\n#ifndef OPENSSL_NO_KRB5\n        if ((kctx = kssl_ctx_new()) != NULL) {\n            SSL_set0_kssl_ctx(con, kctx);\n            kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);\n            kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);\n        }\n#endif                          /* OPENSSL_NO_KRB5 */\n        if (context)\n            SSL_set_session_id_context(con, context, strlen((char *)context));\n    }\n    SSL_clear(con);\n#if 0\n# ifdef TLSEXT_TYPE_opaque_prf_input\n    SSL_set_tlsext_opaque_prf_input(con, \"Test server\", 11);\n# endif\n#endif\n\n    if (stype == SOCK_DGRAM) {\n\n        sbio = BIO_new_dgram(s, BIO_NOCLOSE);\n\n        if (enable_timeouts) {\n            timeout.tv_sec = 0;\n            timeout.tv_usec = DGRAM_RCV_TIMEOUT;\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);\n\n            timeout.tv_sec = 0;\n            timeout.tv_usec = DGRAM_SND_TIMEOUT;\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);\n        }\n\n        if (socket_mtu) {\n            if (socket_mtu < DTLS_get_link_min_mtu(con)) {\n                BIO_printf(bio_err, \"MTU too small. Must be at least %ld\\n\",\n                           DTLS_get_link_min_mtu(con));\n                ret = -1;\n                BIO_free(sbio);\n                goto err;\n            }\n            SSL_set_options(con, SSL_OP_NO_QUERY_MTU);\n            if (!DTLS_set_link_mtu(con, socket_mtu)) {\n                BIO_printf(bio_err, \"Failed to set MTU\\n\");\n                ret = -1;\n                BIO_free(sbio);\n                goto err;\n            }\n        } else\n            /* want to do MTU discovery */\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);\n\n        /* turn on cookie exchange */\n        SSL_set_options(con, SSL_OP_COOKIE_EXCHANGE);\n    } else\n        sbio = BIO_new_socket(s, BIO_NOCLOSE);\n\n    if (s_nbio_test) {\n        BIO *test;\n\n        test = BIO_new(BIO_f_nbio_test());\n        sbio = BIO_push(test, sbio);\n    }\n#ifndef OPENSSL_NO_JPAKE\n    if (jpake_secret)\n        jpake_server_auth(bio_s_out, sbio, jpake_secret);\n#endif\n\n    SSL_set_bio(con, sbio, sbio);\n    SSL_set_accept_state(con);\n    /* SSL_set_fd(con,s); */\n\n    if (s_debug) {\n        SSL_set_debug(con, 1);\n        BIO_set_callback(SSL_get_rbio(con), bio_dump_callback);\n        BIO_set_callback_arg(SSL_get_rbio(con), (char *)bio_s_out);\n    }\n    if (s_msg) {\n#ifndef OPENSSL_NO_SSL_TRACE\n        if (s_msg == 2)\n            SSL_set_msg_callback(con, SSL_trace);\n        else\n#endif\n            SSL_set_msg_callback(con, msg_cb);\n        SSL_set_msg_callback_arg(con, bio_s_msg ? bio_s_msg : bio_s_out);\n    }\n#ifndef OPENSSL_NO_TLSEXT\n    if (s_tlsextdebug) {\n        SSL_set_tlsext_debug_callback(con, tlsext_cb);\n        SSL_set_tlsext_debug_arg(con, bio_s_out);\n    }\n#endif\n\n    width = s + 1;\n    for (;;) {\n        int read_from_terminal;\n        int read_from_sslcon;\n\n        read_from_terminal = 0;\n        read_from_sslcon = SSL_pending(con);\n\n        if (!read_from_sslcon) {\n            FD_ZERO(&readfds);\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined(OPENSSL_SYS_BEOS_R5)\n            openssl_fdset(fileno(stdin), &readfds);\n#endif\n            openssl_fdset(s, &readfds);\n            /*\n             * Note: under VMS with SOCKETSHR the second parameter is\n             * currently of type (int *) whereas under other systems it is\n             * (void *) if you don't have a cast it will choke the compiler:\n             * if you do have a cast then you can either go for (int *) or\n             * (void *).\n             */\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)\n            /*\n             * Under DOS (non-djgpp) and Windows we can't select on stdin:\n             * only on sockets. As a workaround we timeout the select every\n             * second and check for any keypress. In a proper Windows\n             * application we wouldn't do this because it is inefficient.\n             */\n            tv.tv_sec = 1;\n            tv.tv_usec = 0;\n            i = select(width, (void *)&readfds, NULL, NULL, &tv);\n            if ((i < 0) || (!i && !_kbhit()))\n                continue;\n            if (_kbhit())\n                read_from_terminal = 1;\n#elif defined(OPENSSL_SYS_BEOS_R5)\n            /* Under BeOS-R5 the situation is similar to DOS */\n            tv.tv_sec = 1;\n            tv.tv_usec = 0;\n            (void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);\n            i = select(width, (void *)&readfds, NULL, NULL, &tv);\n            if ((i < 0) || (!i && read(fileno(stdin), buf, 0) < 0))\n                continue;\n            if (read(fileno(stdin), buf, 0) >= 0)\n                read_from_terminal = 1;\n            (void)fcntl(fileno(stdin), F_SETFL, 0);\n#else\n            if ((SSL_version(con) == DTLS1_VERSION) &&\n                DTLSv1_get_timeout(con, &timeout))\n                timeoutp = &timeout;\n            else\n                timeoutp = NULL;\n\n            i = select(width, (void *)&readfds, NULL, NULL, timeoutp);\n\n            if ((SSL_version(con) == DTLS1_VERSION)\n                && DTLSv1_handle_timeout(con) > 0) {\n                BIO_printf(bio_err, \"TIMEOUT occured\\n\");\n            }\n\n            if (i <= 0)\n                continue;\n            if (FD_ISSET(fileno(stdin), &readfds))\n                read_from_terminal = 1;\n#endif\n            if (FD_ISSET(s, &readfds))\n                read_from_sslcon = 1;\n        }\n        if (read_from_terminal) {\n            if (s_crlf) {\n                int j, lf_num;\n\n                i = raw_read_stdin(buf, bufsize / 2);\n                lf_num = 0;\n                /* both loops are skipped when i <= 0 */\n                for (j = 0; j < i; j++)\n                    if (buf[j] == '\\n')\n                        lf_num++;\n                for (j = i - 1; j >= 0; j--) {\n                    buf[j + lf_num] = buf[j];\n                    if (buf[j] == '\\n') {\n                        lf_num--;\n                        i++;\n                        buf[j + lf_num] = '\\r';\n                    }\n                }\n                assert(lf_num == 0);\n            } else\n                i = raw_read_stdin(buf, bufsize);\n            if (!s_quiet && !s_brief) {\n                if ((i <= 0) || (buf[0] == 'Q')) {\n                    BIO_printf(bio_s_out, \"DONE\\n\");\n                    SHUTDOWN(s);\n                    close_accept_socket();\n                    ret = -11;\n                    goto err;\n                }\n                if ((i <= 0) || (buf[0] == 'q')) {\n                    BIO_printf(bio_s_out, \"DONE\\n\");\n                    if (SSL_version(con) != DTLS1_VERSION)\n                        SHUTDOWN(s);\n                    /*\n                     * close_accept_socket(); ret= -11;\n                     */\n                    goto err;\n                }\n#ifndef OPENSSL_NO_HEARTBEATS\n                if ((buf[0] == 'B') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\n                    BIO_printf(bio_err, \"HEARTBEATING\\n\");\n                    SSL_heartbeat(con);\n                    i = 0;\n                    continue;\n                }\n#endif\n                if ((buf[0] == 'r') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\n                    SSL_renegotiate(con);\n                    i = SSL_do_handshake(con);\n                    printf(\"SSL_do_handshake -> %d\\n\", i);\n                    i = 0;      /* 13; */\n                    continue;\n                    /*\n                     * strcpy(buf,\"server side RE-NEGOTIATE\\n\");\n                     */\n                }\n                if ((buf[0] == 'R') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\n                    SSL_set_verify(con,\n                                   SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE,\n                                   NULL);\n                    SSL_renegotiate(con);\n                    i = SSL_do_handshake(con);\n                    printf(\"SSL_do_handshake -> %d\\n\", i);\n                    i = 0;      /* 13; */\n                    continue;\n                    /*\n                     * strcpy(buf,\"server side RE-NEGOTIATE asking for client\n                     * cert\\n\");\n                     */\n                }\n                if (buf[0] == 'P') {\n                    static const char *str = \"Lets print some clear text\\n\";\n                    BIO_write(SSL_get_wbio(con), str, strlen(str));\n                }\n                if (buf[0] == 'S') {\n                    print_stats(bio_s_out, SSL_get_SSL_CTX(con));\n                }\n            }\n#ifdef CHARSET_EBCDIC\n            ebcdic2ascii(buf, buf, i);\n#endif\n            l = k = 0;\n            for (;;) {\n                /* should do a select for the write */\n#ifdef RENEG\n                {\n                    static count = 0;\n                    if (++count == 100) {\n                        count = 0;\n                        SSL_renegotiate(con);\n                    }\n                }\n#endif\n                k = SSL_write(con, &(buf[l]), (unsigned int)i);\n#ifndef OPENSSL_NO_SRP\n                while (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) {\n                    BIO_printf(bio_s_out, \"LOOKUP renego during write\\n\");\n                    srp_callback_parm.user =\n                        SRP_VBASE_get_by_user(srp_callback_parm.vb,\n                                              srp_callback_parm.login);\n                    if (srp_callback_parm.user)\n                        BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                   srp_callback_parm.user->info);\n                    else\n                        BIO_printf(bio_s_out, \"LOOKUP not successful\\n\");\n                    k = SSL_write(con, &(buf[l]), (unsigned int)i);\n                }\n#endif\n                switch (SSL_get_error(con, k)) {\n                case SSL_ERROR_NONE:\n                    break;\n                case SSL_ERROR_WANT_WRITE:\n                case SSL_ERROR_WANT_READ:\n                case SSL_ERROR_WANT_X509_LOOKUP:\n                    BIO_printf(bio_s_out, \"Write BLOCK\\n\");\n                    break;\n                case SSL_ERROR_SYSCALL:\n                case SSL_ERROR_SSL:\n                    BIO_printf(bio_s_out, \"ERROR\\n\");\n                    ERR_print_errors(bio_err);\n                    ret = 1;\n                    goto err;\n                    /* break; */\n                case SSL_ERROR_ZERO_RETURN:\n                    BIO_printf(bio_s_out, \"DONE\\n\");\n                    ret = 1;\n                    goto err;\n                }\n                if (k > 0) {\n                    l += k;\n                    i -= k;\n                }\n                if (i <= 0)\n                    break;\n            }\n        }\n        if (read_from_sslcon) {\n            if (!SSL_is_init_finished(con)) {\n                i = init_ssl_connection(con);\n\n                if (i < 0) {\n                    ret = 0;\n                    goto err;\n                } else if (i == 0) {\n                    ret = 1;\n                    goto err;\n                }\n            } else {\n again:\n                i = SSL_read(con, (char *)buf, bufsize);\n#ifndef OPENSSL_NO_SRP\n                while (SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\n                    BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");\n                    srp_callback_parm.user =\n                        SRP_VBASE_get_by_user(srp_callback_parm.vb,\n                                              srp_callback_parm.login);\n                    if (srp_callback_parm.user)\n                        BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                   srp_callback_parm.user->info);\n                    else\n                        BIO_printf(bio_s_out, \"LOOKUP not successful\\n\");\n                    i = SSL_read(con, (char *)buf, bufsize);\n                }\n#endif\n                switch (SSL_get_error(con, i)) {\n                case SSL_ERROR_NONE:\n#ifdef CHARSET_EBCDIC\n                    ascii2ebcdic(buf, buf, i);\n#endif\n                    raw_write_stdout(buf, (unsigned int)i);\n                    if (SSL_pending(con))\n                        goto again;\n                    break;\n                case SSL_ERROR_WANT_WRITE:\n                case SSL_ERROR_WANT_READ:\n                    BIO_printf(bio_s_out, \"Read BLOCK\\n\");\n                    break;\n                case SSL_ERROR_SYSCALL:\n                case SSL_ERROR_SSL:\n                    BIO_printf(bio_s_out, \"ERROR\\n\");\n                    ERR_print_errors(bio_err);\n                    ret = 1;\n                    goto err;\n                case SSL_ERROR_ZERO_RETURN:\n                    BIO_printf(bio_s_out, \"DONE\\n\");\n                    ret = 1;\n                    goto err;\n                }\n            }\n        }\n    }\n err:\n    if (con != NULL) {\n        BIO_printf(bio_s_out, \"shutting down SSL\\n\");\n#if 1\n        SSL_set_shutdown(con, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\n#else\n        SSL_shutdown(con);\n#endif\n        SSL_free(con);\n    }\n    BIO_printf(bio_s_out, \"CONNECTION CLOSED\\n\");\n    if (buf != NULL) {\n        OPENSSL_cleanse(buf, bufsize);\n        OPENSSL_free(buf);\n    }\n    if (ret >= 0)\n        BIO_printf(bio_s_out, \"ACCEPT\\n\");\n    return (ret);\n}",
    "abstract_func_before": "static int sv_body(char *VAR_0, int VAR_1, int VAR_2, unsigned char *VAR_3)\n{\n    char *VAR_4 = NULL;\n    fd_set VAR_5;\n    int VAR_6 = 1, VAR_7;\n    int VAR_8, VAR_9;\n    unsigned long VAR_10;\n    SSL *VAR_11 = NULL;\n    BIO *VAR_12;\n#ifndef VAR_13\n    KSSL_CTX *VAR_14;\n#endif\n    struct timeval VAR_15;\n#if defined(VAR_16) || defined(VAR_17) || defined(VAR_18) || defined(VAR_19)\n    struct timeval VAR_20;\n#else\n    struct timeval *VAR_21;\n#endif\n\n    if ((VAR_4 = OPENSSL_malloc(VAR_22)) == NULL) {\n        BIO_printf(VAR_23, \"out of memory\\n\");\n        goto err;\n    }\n#ifdef VAR_24\n    if (VAR_25) {\n        unsigned long VAR_26 = 1;\n\n        if (!VAR_27)\n            BIO_printf(VAR_23, \"turning on non blocking io\\n\");\n        if (BIO_socket_ioctl(VAR_1, VAR_24, &VAR_26) < 0)\n            ERR_print_errors(VAR_23);\n    }\n#endif\n\n    if (VAR_11 == NULL) {\n        VAR_11 = SSL_new(VAR_28);\n#ifndef VAR_29\n        if (VAR_30) {\n            SSL_set_tlsext_debug_callback(VAR_11, VAR_31);\n            SSL_set_tlsext_debug_arg(VAR_11, VAR_32);\n        }\n        if (VAR_33) {\n            SSL_CTX_set_tlsext_status_cb(VAR_28, VAR_34);\n            VAR_35.err = VAR_23;\n            SSL_CTX_set_tlsext_status_arg(VAR_28, &VAR_35);\n        }\n#endif\n#ifndef VAR_13\n        if ((VAR_14 = kssl_ctx_new()) != NULL) {\n            SSL_set0_kssl_ctx(VAR_11, VAR_14);\n            kssl_ctx_setstring(VAR_14, VAR_36, VAR_37);\n            kssl_ctx_setstring(VAR_14, VAR_38, VAR_39);\n        }\n#endif                          /* COMMENT_0 */\n        if (VAR_3)\n            SSL_set_session_id_context(VAR_11, VAR_3, strlen((char *)VAR_3));\n    }\n    SSL_clear(VAR_11);\n#if 0\n# ifdef VAR_40\n    SSL_set_tlsext_opaque_prf_input(VAR_11, \"Test server\", 11);\n# endif\n#endif\n\n    if (VAR_2 == VAR_41) {\n\n        VAR_12 = BIO_new_dgram(VAR_1, VAR_42);\n\n        if (VAR_43) {\n            VAR_15.tv_sec = 0;\n            VAR_15.tv_usec = VAR_44;\n            BIO_ctrl(VAR_12, VAR_45, 0, &VAR_15);\n\n            VAR_15.tv_sec = 0;\n            VAR_15.tv_usec = VAR_46;\n            BIO_ctrl(VAR_12, VAR_47, 0, &VAR_15);\n        }\n\n        if (VAR_48) {\n            if (VAR_48 < DTLS_get_link_min_mtu(VAR_11)) {\n                BIO_printf(VAR_23, \"MTU too small. Must be at least %ld\\n\",\n                           DTLS_get_link_min_mtu(VAR_11));\n                VAR_6 = -1;\n                BIO_free(VAR_12);\n                goto err;\n            }\n            SSL_set_options(VAR_11, VAR_49);\n            if (!DTLS_set_link_mtu(VAR_11, VAR_48)) {\n                BIO_printf(VAR_23, \"Failed to set MTU\\n\");\n                VAR_6 = -1;\n                BIO_free(VAR_12);\n                goto err;\n            }\n        } else\n            /* COMMENT_1 */\n            BIO_ctrl(VAR_12, VAR_50, 0, NULL);\n\n        /* COMMENT_2 */\n        SSL_set_options(VAR_11, VAR_51);\n    } else\n        VAR_12 = BIO_new_socket(VAR_1, VAR_42);\n\n    if (VAR_52) {\n        BIO *VAR_53;\n\n        VAR_53 = BIO_new(BIO_f_nbio_test());\n        VAR_12 = BIO_push(VAR_53, VAR_12);\n    }\n#ifndef VAR_54\n    if (VAR_55)\n        jpake_server_auth(VAR_32, VAR_12, VAR_55);\n#endif\n\n    SSL_set_bio(VAR_11, VAR_12, VAR_12);\n    SSL_set_accept_state(VAR_11);\n    /* COMMENT_3 */\n\n    if (VAR_56) {\n        SSL_set_debug(VAR_11, 1);\n        BIO_set_callback(SSL_get_rbio(VAR_11), VAR_57);\n        BIO_set_callback_arg(SSL_get_rbio(VAR_11), (char *)VAR_32);\n    }\n    if (VAR_58) {\n#ifndef VAR_59\n        if (VAR_58 == 2)\n            SSL_set_msg_callback(VAR_11, VAR_60);\n        else\n#endif\n            SSL_set_msg_callback(VAR_11, VAR_61);\n        SSL_set_msg_callback_arg(VAR_11, VAR_62 ? VAR_62 : VAR_32);\n    }\n#ifndef VAR_29\n    if (VAR_30) {\n        SSL_set_tlsext_debug_callback(VAR_11, VAR_31);\n        SSL_set_tlsext_debug_arg(VAR_11, VAR_32);\n    }\n#endif\n\n    VAR_7 = VAR_1 + 1;\n    for (;;) {\n        int VAR_63;\n        int VAR_64;\n\n        VAR_63 = 0;\n        VAR_64 = SSL_pending(VAR_11);\n\n        if (!VAR_64) {\n            FD_ZERO(&VAR_5);\n#if !defined(VAR_16) && !defined(VAR_17) && !defined(VAR_18) && !defined(VAR_19)\n            openssl_fdset(fileno(VAR_65), &VAR_5);\n#endif\n            openssl_fdset(VAR_1, &VAR_5);\n            /* COMMENT_4 */\n                                                                     \n                                                                          \n                                                                            \n                                                                          \n                        \n               \n#if defined(VAR_16) || defined(VAR_17) || defined(VAR_18)\n            /* COMMENT_11 */\n                                                                          \n                                                                           \n                                                                     \n                                                                         \n               \n            VAR_20.tv_sec = 1;\n            VAR_20.tv_usec = 0;\n            VAR_9 = select(VAR_7, (void *)&VAR_5, NULL, NULL, &VAR_20);\n            if ((VAR_9 < 0) || (!VAR_9 && !_kbhit()))\n                continue;\n            if (_kbhit())\n                VAR_63 = 1;\n#elif defined(VAR_19)\n            /* COMMENT_17 */\n            VAR_20.tv_sec = 1;\n            VAR_20.tv_usec = 0;\n            (void)fcntl(fileno(VAR_65), VAR_66, VAR_67);\n            VAR_9 = select(VAR_7, (void *)&VAR_5, NULL, NULL, &VAR_20);\n            if ((VAR_9 < 0) || (!VAR_9 && read(fileno(VAR_65), VAR_4, 0) < 0))\n                continue;\n            if (read(fileno(VAR_65), VAR_4, 0) >= 0)\n                VAR_63 = 1;\n            (void)fcntl(fileno(VAR_65), VAR_66, 0);\n#else\n            if ((SSL_version(VAR_11) == VAR_68) &&\n                DTLSv1_get_timeout(VAR_11, &VAR_15))\n                VAR_21 = &VAR_15;\n            else\n                VAR_21 = NULL;\n\n            VAR_9 = select(VAR_7, (void *)&VAR_5, NULL, NULL, VAR_21);\n\n            if ((SSL_version(VAR_11) == VAR_68)\n                && DTLSv1_handle_timeout(VAR_11) > 0) {\n                BIO_printf(VAR_23, \"TIMEOUT occured\\n\");\n            }\n\n            if (VAR_9 <= 0)\n                continue;\n            if (FD_ISSET(fileno(VAR_65), &VAR_5))\n                VAR_63 = 1;\n#endif\n            if (FD_ISSET(VAR_1, &VAR_5))\n                VAR_64 = 1;\n        }\n        if (VAR_63) {\n            if (VAR_69) {\n                int VAR_70, VAR_71;\n\n                VAR_9 = raw_read_stdin(VAR_4, VAR_22 / 2);\n                VAR_71 = 0;\n                /* COMMENT_18 */\n                for (VAR_70 = 0; VAR_70 < VAR_9; VAR_70++)\n                    if (VAR_4[VAR_70] == '\\n')\n                        VAR_71++;\n                for (VAR_70 = VAR_9 - 1; VAR_70 >= 0; VAR_70--) {\n                    VAR_4[VAR_70 + VAR_71] = VAR_4[VAR_70];\n                    if (VAR_4[VAR_70] == '\\n') {\n                        VAR_71--;\n                        VAR_9++;\n                        VAR_4[VAR_70 + VAR_71] = '\\r';\n                    }\n                }\n                assert(VAR_71 == 0);\n            } else\n                VAR_9 = raw_read_stdin(VAR_4, VAR_22);\n            if (!VAR_27 && !VAR_72) {\n                if ((VAR_9 <= 0) || (VAR_4[0] == 'Q')) {\n                    BIO_printf(VAR_32, \"DONE\\n\");\n                    SHUTDOWN(VAR_1);\n                    close_accept_socket();\n                    VAR_6 = -11;\n                    goto err;\n                }\n                if ((VAR_9 <= 0) || (VAR_4[0] == 'q')) {\n                    BIO_printf(VAR_32, \"DONE\\n\");\n                    if (SSL_version(VAR_11) != VAR_68)\n                        SHUTDOWN(VAR_1);\n                    /* COMMENT_19 */\n                                                       \n                       \n                    goto err;\n                }\n#ifndef VAR_73\n                if ((VAR_4[0] == 'B') && ((VAR_4[1] == '\\n') || (VAR_4[1] == '\\r'))) {\n                    BIO_printf(VAR_23, \"HEARTBEATING\\n\");\n                    SSL_heartbeat(VAR_11);\n                    VAR_9 = 0;\n                    continue;\n                }\n#endif\n                if ((VAR_4[0] == 'r') && ((VAR_4[1] == '\\n') || (VAR_4[1] == '\\r'))) {\n                    SSL_renegotiate(VAR_11);\n                    VAR_9 = SSL_do_handshake(VAR_11);\n                    printf(\"SSL_do_handshake -> %d\\n\", VAR_9);\n                    VAR_9 = 0;      /* COMMENT_22 */\n                    continue;\n                    /* COMMENT_23 */\n                                                                \n                       \n                }\n                if ((VAR_4[0] == 'R') && ((VAR_4[1] == '\\n') || (VAR_4[1] == '\\r'))) {\n                    SSL_set_verify(VAR_11,\n                                   VAR_74 | VAR_75,\n                                   NULL);\n                    SSL_renegotiate(VAR_11);\n                    VAR_9 = SSL_do_handshake(VAR_11);\n                    printf(\"SSL_do_handshake -> %d\\n\", VAR_9);\n                    VAR_9 = 0;      /* COMMENT_22 */\n                    continue;\n                    /* COMMENT_26 */\n                                                                             \n                                \n                       \n                }\n                if (VAR_4[0] == 'P') {\n                    static const char *VAR_76 = \"Lets print some clear text\\n\";\n                    BIO_write(SSL_get_wbio(VAR_11), VAR_76, strlen(VAR_76));\n                }\n                if (VAR_4[0] == 'S') {\n                    print_stats(VAR_32, SSL_get_SSL_CTX(VAR_11));\n                }\n            }\n#ifdef VAR_77\n            ebcdic2ascii(VAR_4, VAR_4, VAR_9);\n#endif\n            VAR_10 = VAR_8 = 0;\n            for (;;) {\n                /* COMMENT_30 */\n#ifdef VAR_78\n                {\n                    static countVAR_79 = 0;\n                    if (++count == 100) {\n                        count = 0;\n                        SSL_renegotiate(VAR_11);\n                    }\n                }\n#endif\n                VAR_8 = SSL_write(VAR_11, &(VAR_4[VAR_10]), (unsigned int)VAR_9);\n#ifndef VAR_80\n                while (SSL_get_error(VAR_11, VAR_8) == VAR_81) {\n                    BIO_printf(VAR_32, \"LOOKUP renego during write\\n\");\n                    VAR_82.user =\n                        SRP_VBASE_get_by_user(VAR_82.vb,\n                                              VAR_82.login);\n                    if (VAR_82.user)\n                        BIO_printf(VAR_32, \"LOOKUP done %s\\n\",\n                                   VAR_82.user->info);\n                    else\n                        BIO_printf(VAR_32, \"LOOKUP not successful\\n\");\n                    VAR_8 = SSL_write(VAR_11, &(VAR_4[VAR_10]), (unsigned int)VAR_9);\n                }\n#endif\n                switch (SSL_get_error(VAR_11, VAR_8)) {\n                case VAR_83:\n                    break;\n                case VAR_84:\n                case VAR_85:\n                case VAR_81:\n                    BIO_printf(VAR_32, \"Write BLOCK\\n\");\n                    break;\n                case VAR_86:\n                case VAR_87:\n                    BIO_printf(VAR_32, \"ERROR\\n\");\n                    ERR_print_errors(VAR_23);\n                    VAR_6 = 1;\n                    goto err;\n                    /* COMMENT_31 */\n                case VAR_88:\n                    BIO_printf(VAR_32, \"DONE\\n\");\n                    VAR_6 = 1;\n                    goto err;\n                }\n                if (VAR_8 > 0) {\n                    VAR_10 += VAR_8;\n                    VAR_9 -= VAR_8;\n                }\n                if (VAR_9 <= 0)\n                    break;\n            }\n        }\n        if (VAR_64) {\n            if (!SSL_is_init_finished(VAR_11)) {\n                VAR_9 = init_ssl_connection(VAR_11);\n\n                if (VAR_9 < 0) {\n                    VAR_6 = 0;\n                    goto err;\n                } else if (VAR_9 == 0) {\n                    VAR_6 = 1;\n                    goto err;\n                }\n            } else {\n again:\n                VAR_9 = SSL_read(VAR_11, (char *)VAR_4, VAR_22);\n#ifndef VAR_80\n                while (SSL_get_error(VAR_11, VAR_9) == VAR_81) {\n                    BIO_printf(VAR_32, \"LOOKUP renego during read\\n\");\n                    VAR_82.user =\n                        SRP_VBASE_get_by_user(VAR_82.vb,\n                                              VAR_82.login);\n                    if (VAR_82.user)\n                        BIO_printf(VAR_32, \"LOOKUP done %s\\n\",\n                                   VAR_82.user->info);\n                    else\n                        BIO_printf(VAR_32, \"LOOKUP not successful\\n\");\n                    VAR_9 = SSL_read(VAR_11, (char *)VAR_4, VAR_22);\n                }\n#endif\n                switch (SSL_get_error(VAR_11, VAR_9)) {\n                case VAR_83:\n#ifdef VAR_77\n                    ascii2ebcdic(VAR_4, VAR_4, VAR_9);\n#endif\n                    raw_write_stdout(VAR_4, (unsigned int)VAR_9);\n                    if (SSL_pending(VAR_11))\n                        goto again;\n                    break;\n                case VAR_84:\n                case VAR_85:\n                    BIO_printf(VAR_32, \"Read BLOCK\\n\");\n                    break;\n                case VAR_86:\n                case VAR_87:\n                    BIO_printf(VAR_32, \"ERROR\\n\");\n                    ERR_print_errors(VAR_23);\n                    VAR_6 = 1;\n                    goto err;\n                case VAR_88:\n                    BIO_printf(VAR_32, \"DONE\\n\");\n                    VAR_6 = 1;\n                    goto err;\n                }\n            }\n        }\n    }\n err:\n    if (VAR_11 != NULL) {\n        BIO_printf(VAR_32, \"shutting down SSL\\n\");\n#if 1\n        SSL_set_shutdown(VAR_11, VAR_89 | VAR_90);\n#else\n        SSL_shutdown(VAR_11);\n#endif\n        SSL_free(VAR_11);\n    }\n    BIO_printf(VAR_32, \"CONNECTION CLOSED\\n\");\n    if (VAR_4 != NULL) {\n        OPENSSL_cleanse(VAR_4, VAR_22);\n        OPENSSL_free(VAR_4);\n    }\n    if (VAR_6 >= 0)\n        BIO_printf(VAR_32, \"ACCEPT\\n\");\n    return (VAR_6);\n}",
    "func_graph_path_before": "openssl/259b664f950c2ba66fbf4b0fe5281327904ead21/s_server.c/vul/before/4.json",
    "func": "static int sv_body(char *hostname, int s, int stype, unsigned char *context)\n{\n    char *buf = NULL;\n    fd_set readfds;\n    int ret = 1, width;\n    int k, i;\n    unsigned long l;\n    SSL *con = NULL;\n    BIO *sbio;\n#ifndef OPENSSL_NO_KRB5\n    KSSL_CTX *kctx;\n#endif\n    struct timeval timeout;\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)\n    struct timeval tv;\n#else\n    struct timeval *timeoutp;\n#endif\n\n    if ((buf = OPENSSL_malloc(bufsize)) == NULL) {\n        BIO_printf(bio_err, \"out of memory\\n\");\n        goto err;\n    }\n#ifdef FIONBIO\n    if (s_nbio) {\n        unsigned long sl = 1;\n\n        if (!s_quiet)\n            BIO_printf(bio_err, \"turning on non blocking io\\n\");\n        if (BIO_socket_ioctl(s, FIONBIO, &sl) < 0)\n            ERR_print_errors(bio_err);\n    }\n#endif\n\n    if (con == NULL) {\n        con = SSL_new(ctx);\n#ifndef OPENSSL_NO_TLSEXT\n        if (s_tlsextdebug) {\n            SSL_set_tlsext_debug_callback(con, tlsext_cb);\n            SSL_set_tlsext_debug_arg(con, bio_s_out);\n        }\n        if (s_tlsextstatus) {\n            SSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);\n            tlscstatp.err = bio_err;\n            SSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);\n        }\n#endif\n#ifndef OPENSSL_NO_KRB5\n        if ((kctx = kssl_ctx_new()) != NULL) {\n            SSL_set0_kssl_ctx(con, kctx);\n            kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);\n            kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);\n        }\n#endif                          /* OPENSSL_NO_KRB5 */\n        if (context)\n            SSL_set_session_id_context(con, context, strlen((char *)context));\n    }\n    SSL_clear(con);\n#if 0\n# ifdef TLSEXT_TYPE_opaque_prf_input\n    SSL_set_tlsext_opaque_prf_input(con, \"Test server\", 11);\n# endif\n#endif\n\n    if (stype == SOCK_DGRAM) {\n\n        sbio = BIO_new_dgram(s, BIO_NOCLOSE);\n\n        if (enable_timeouts) {\n            timeout.tv_sec = 0;\n            timeout.tv_usec = DGRAM_RCV_TIMEOUT;\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);\n\n            timeout.tv_sec = 0;\n            timeout.tv_usec = DGRAM_SND_TIMEOUT;\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);\n        }\n\n        if (socket_mtu) {\n            if (socket_mtu < DTLS_get_link_min_mtu(con)) {\n                BIO_printf(bio_err, \"MTU too small. Must be at least %ld\\n\",\n                           DTLS_get_link_min_mtu(con));\n                ret = -1;\n                BIO_free(sbio);\n                goto err;\n            }\n            SSL_set_options(con, SSL_OP_NO_QUERY_MTU);\n            if (!DTLS_set_link_mtu(con, socket_mtu)) {\n                BIO_printf(bio_err, \"Failed to set MTU\\n\");\n                ret = -1;\n                BIO_free(sbio);\n                goto err;\n            }\n        } else\n            /* want to do MTU discovery */\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);\n\n        /* turn on cookie exchange */\n        SSL_set_options(con, SSL_OP_COOKIE_EXCHANGE);\n    } else\n        sbio = BIO_new_socket(s, BIO_NOCLOSE);\n\n    if (s_nbio_test) {\n        BIO *test;\n\n        test = BIO_new(BIO_f_nbio_test());\n        sbio = BIO_push(test, sbio);\n    }\n#ifndef OPENSSL_NO_JPAKE\n    if (jpake_secret)\n        jpake_server_auth(bio_s_out, sbio, jpake_secret);\n#endif\n\n    SSL_set_bio(con, sbio, sbio);\n    SSL_set_accept_state(con);\n    /* SSL_set_fd(con,s); */\n\n    if (s_debug) {\n        SSL_set_debug(con, 1);\n        BIO_set_callback(SSL_get_rbio(con), bio_dump_callback);\n        BIO_set_callback_arg(SSL_get_rbio(con), (char *)bio_s_out);\n    }\n    if (s_msg) {\n#ifndef OPENSSL_NO_SSL_TRACE\n        if (s_msg == 2)\n            SSL_set_msg_callback(con, SSL_trace);\n        else\n#endif\n            SSL_set_msg_callback(con, msg_cb);\n        SSL_set_msg_callback_arg(con, bio_s_msg ? bio_s_msg : bio_s_out);\n    }\n#ifndef OPENSSL_NO_TLSEXT\n    if (s_tlsextdebug) {\n        SSL_set_tlsext_debug_callback(con, tlsext_cb);\n        SSL_set_tlsext_debug_arg(con, bio_s_out);\n    }\n#endif\n\n    width = s + 1;\n    for (;;) {\n        int read_from_terminal;\n        int read_from_sslcon;\n\n        read_from_terminal = 0;\n        read_from_sslcon = SSL_pending(con);\n\n        if (!read_from_sslcon) {\n            FD_ZERO(&readfds);\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined(OPENSSL_SYS_BEOS_R5)\n            openssl_fdset(fileno(stdin), &readfds);\n#endif\n            openssl_fdset(s, &readfds);\n            /*\n             * Note: under VMS with SOCKETSHR the second parameter is\n             * currently of type (int *) whereas under other systems it is\n             * (void *) if you don't have a cast it will choke the compiler:\n             * if you do have a cast then you can either go for (int *) or\n             * (void *).\n             */\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)\n            /*\n             * Under DOS (non-djgpp) and Windows we can't select on stdin:\n             * only on sockets. As a workaround we timeout the select every\n             * second and check for any keypress. In a proper Windows\n             * application we wouldn't do this because it is inefficient.\n             */\n            tv.tv_sec = 1;\n            tv.tv_usec = 0;\n            i = select(width, (void *)&readfds, NULL, NULL, &tv);\n            if ((i < 0) || (!i && !_kbhit()))\n                continue;\n            if (_kbhit())\n                read_from_terminal = 1;\n#elif defined(OPENSSL_SYS_BEOS_R5)\n            /* Under BeOS-R5 the situation is similar to DOS */\n            tv.tv_sec = 1;\n            tv.tv_usec = 0;\n            (void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);\n            i = select(width, (void *)&readfds, NULL, NULL, &tv);\n            if ((i < 0) || (!i && read(fileno(stdin), buf, 0) < 0))\n                continue;\n            if (read(fileno(stdin), buf, 0) >= 0)\n                read_from_terminal = 1;\n            (void)fcntl(fileno(stdin), F_SETFL, 0);\n#else\n            if ((SSL_version(con) == DTLS1_VERSION) &&\n                DTLSv1_get_timeout(con, &timeout))\n                timeoutp = &timeout;\n            else\n                timeoutp = NULL;\n\n            i = select(width, (void *)&readfds, NULL, NULL, timeoutp);\n\n            if ((SSL_version(con) == DTLS1_VERSION)\n                && DTLSv1_handle_timeout(con) > 0) {\n                BIO_printf(bio_err, \"TIMEOUT occured\\n\");\n            }\n\n            if (i <= 0)\n                continue;\n            if (FD_ISSET(fileno(stdin), &readfds))\n                read_from_terminal = 1;\n#endif\n            if (FD_ISSET(s, &readfds))\n                read_from_sslcon = 1;\n        }\n        if (read_from_terminal) {\n            if (s_crlf) {\n                int j, lf_num;\n\n                i = raw_read_stdin(buf, bufsize / 2);\n                lf_num = 0;\n                /* both loops are skipped when i <= 0 */\n                for (j = 0; j < i; j++)\n                    if (buf[j] == '\\n')\n                        lf_num++;\n                for (j = i - 1; j >= 0; j--) {\n                    buf[j + lf_num] = buf[j];\n                    if (buf[j] == '\\n') {\n                        lf_num--;\n                        i++;\n                        buf[j + lf_num] = '\\r';\n                    }\n                }\n                assert(lf_num == 0);\n            } else\n                i = raw_read_stdin(buf, bufsize);\n            if (!s_quiet && !s_brief) {\n                if ((i <= 0) || (buf[0] == 'Q')) {\n                    BIO_printf(bio_s_out, \"DONE\\n\");\n                    SHUTDOWN(s);\n                    close_accept_socket();\n                    ret = -11;\n                    goto err;\n                }\n                if ((i <= 0) || (buf[0] == 'q')) {\n                    BIO_printf(bio_s_out, \"DONE\\n\");\n                    if (SSL_version(con) != DTLS1_VERSION)\n                        SHUTDOWN(s);\n                    /*\n                     * close_accept_socket(); ret= -11;\n                     */\n                    goto err;\n                }\n#ifndef OPENSSL_NO_HEARTBEATS\n                if ((buf[0] == 'B') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\n                    BIO_printf(bio_err, \"HEARTBEATING\\n\");\n                    SSL_heartbeat(con);\n                    i = 0;\n                    continue;\n                }\n#endif\n                if ((buf[0] == 'r') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\n                    SSL_renegotiate(con);\n                    i = SSL_do_handshake(con);\n                    printf(\"SSL_do_handshake -> %d\\n\", i);\n                    i = 0;      /* 13; */\n                    continue;\n                    /*\n                     * strcpy(buf,\"server side RE-NEGOTIATE\\n\");\n                     */\n                }\n                if ((buf[0] == 'R') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\n                    SSL_set_verify(con,\n                                   SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE,\n                                   NULL);\n                    SSL_renegotiate(con);\n                    i = SSL_do_handshake(con);\n                    printf(\"SSL_do_handshake -> %d\\n\", i);\n                    i = 0;      /* 13; */\n                    continue;\n                    /*\n                     * strcpy(buf,\"server side RE-NEGOTIATE asking for client\n                     * cert\\n\");\n                     */\n                }\n                if (buf[0] == 'P') {\n                    static const char *str = \"Lets print some clear text\\n\";\n                    BIO_write(SSL_get_wbio(con), str, strlen(str));\n                }\n                if (buf[0] == 'S') {\n                    print_stats(bio_s_out, SSL_get_SSL_CTX(con));\n                }\n            }\n#ifdef CHARSET_EBCDIC\n            ebcdic2ascii(buf, buf, i);\n#endif\n            l = k = 0;\n            for (;;) {\n                /* should do a select for the write */\n#ifdef RENEG\n                {\n                    static count = 0;\n                    if (++count == 100) {\n                        count = 0;\n                        SSL_renegotiate(con);\n                    }\n                }\n#endif\n                k = SSL_write(con, &(buf[l]), (unsigned int)i);\n#ifndef OPENSSL_NO_SRP\n                while (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) {\n                    BIO_printf(bio_s_out, \"LOOKUP renego during write\\n\");\n                    SRP_user_pwd_free(srp_callback_parm.user);\n                    srp_callback_parm.user =\n                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n                                               srp_callback_parm.login);\n                    if (srp_callback_parm.user)\n                        BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                   srp_callback_parm.user->info);\n                    else\n                        BIO_printf(bio_s_out, \"LOOKUP not successful\\n\");\n                    k = SSL_write(con, &(buf[l]), (unsigned int)i);\n                }\n#endif\n                switch (SSL_get_error(con, k)) {\n                case SSL_ERROR_NONE:\n                    break;\n                case SSL_ERROR_WANT_WRITE:\n                case SSL_ERROR_WANT_READ:\n                case SSL_ERROR_WANT_X509_LOOKUP:\n                    BIO_printf(bio_s_out, \"Write BLOCK\\n\");\n                    break;\n                case SSL_ERROR_SYSCALL:\n                case SSL_ERROR_SSL:\n                    BIO_printf(bio_s_out, \"ERROR\\n\");\n                    ERR_print_errors(bio_err);\n                    ret = 1;\n                    goto err;\n                    /* break; */\n                case SSL_ERROR_ZERO_RETURN:\n                    BIO_printf(bio_s_out, \"DONE\\n\");\n                    ret = 1;\n                    goto err;\n                }\n                if (k > 0) {\n                    l += k;\n                    i -= k;\n                }\n                if (i <= 0)\n                    break;\n            }\n        }\n        if (read_from_sslcon) {\n            if (!SSL_is_init_finished(con)) {\n                i = init_ssl_connection(con);\n\n                if (i < 0) {\n                    ret = 0;\n                    goto err;\n                } else if (i == 0) {\n                    ret = 1;\n                    goto err;\n                }\n            } else {\n again:\n                i = SSL_read(con, (char *)buf, bufsize);\n#ifndef OPENSSL_NO_SRP\n                while (SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\n                    BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");\n                    SRP_user_pwd_free(srp_callback_parm.user);\n                    srp_callback_parm.user =\n                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n                                               srp_callback_parm.login);\n                    if (srp_callback_parm.user)\n                        BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                   srp_callback_parm.user->info);\n                    else\n                        BIO_printf(bio_s_out, \"LOOKUP not successful\\n\");\n                    i = SSL_read(con, (char *)buf, bufsize);\n                }\n#endif\n                switch (SSL_get_error(con, i)) {\n                case SSL_ERROR_NONE:\n#ifdef CHARSET_EBCDIC\n                    ascii2ebcdic(buf, buf, i);\n#endif\n                    raw_write_stdout(buf, (unsigned int)i);\n                    if (SSL_pending(con))\n                        goto again;\n                    break;\n                case SSL_ERROR_WANT_WRITE:\n                case SSL_ERROR_WANT_READ:\n                    BIO_printf(bio_s_out, \"Read BLOCK\\n\");\n                    break;\n                case SSL_ERROR_SYSCALL:\n                case SSL_ERROR_SSL:\n                    BIO_printf(bio_s_out, \"ERROR\\n\");\n                    ERR_print_errors(bio_err);\n                    ret = 1;\n                    goto err;\n                case SSL_ERROR_ZERO_RETURN:\n                    BIO_printf(bio_s_out, \"DONE\\n\");\n                    ret = 1;\n                    goto err;\n                }\n            }\n        }\n    }\n err:\n    if (con != NULL) {\n        BIO_printf(bio_s_out, \"shutting down SSL\\n\");\n#if 1\n        SSL_set_shutdown(con, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\n#else\n        SSL_shutdown(con);\n#endif\n        SSL_free(con);\n    }\n    BIO_printf(bio_s_out, \"CONNECTION CLOSED\\n\");\n    if (buf != NULL) {\n        OPENSSL_cleanse(buf, bufsize);\n        OPENSSL_free(buf);\n    }\n    if (ret >= 0)\n        BIO_printf(bio_s_out, \"ACCEPT\\n\");\n    return (ret);\n}",
    "abstract_func": "static int sv_body(char *VAR_0, int VAR_1, int VAR_2, unsigned char *VAR_3)\n{\n    char *VAR_4 = NULL;\n    fd_set VAR_5;\n    int VAR_6 = 1, VAR_7;\n    int VAR_8, VAR_9;\n    unsigned long VAR_10;\n    SSL *VAR_11 = NULL;\n    BIO *VAR_12;\n#ifndef VAR_13\n    KSSL_CTX *VAR_14;\n#endif\n    struct timeval VAR_15;\n#if defined(VAR_16) || defined(VAR_17) || defined(VAR_18) || defined(VAR_19)\n    struct timeval VAR_20;\n#else\n    struct timeval *VAR_21;\n#endif\n\n    if ((VAR_4 = OPENSSL_malloc(VAR_22)) == NULL) {\n        BIO_printf(VAR_23, \"out of memory\\n\");\n        goto err;\n    }\n#ifdef VAR_24\n    if (VAR_25) {\n        unsigned long VAR_26 = 1;\n\n        if (!VAR_27)\n            BIO_printf(VAR_23, \"turning on non blocking io\\n\");\n        if (BIO_socket_ioctl(VAR_1, VAR_24, &VAR_26) < 0)\n            ERR_print_errors(VAR_23);\n    }\n#endif\n\n    if (VAR_11 == NULL) {\n        VAR_11 = SSL_new(VAR_28);\n#ifndef VAR_29\n        if (VAR_30) {\n            SSL_set_tlsext_debug_callback(VAR_11, VAR_31);\n            SSL_set_tlsext_debug_arg(VAR_11, VAR_32);\n        }\n        if (VAR_33) {\n            SSL_CTX_set_tlsext_status_cb(VAR_28, VAR_34);\n            VAR_35.err = VAR_23;\n            SSL_CTX_set_tlsext_status_arg(VAR_28, &VAR_35);\n        }\n#endif\n#ifndef VAR_13\n        if ((VAR_14 = kssl_ctx_new()) != NULL) {\n            SSL_set0_kssl_ctx(VAR_11, VAR_14);\n            kssl_ctx_setstring(VAR_14, VAR_36, VAR_37);\n            kssl_ctx_setstring(VAR_14, VAR_38, VAR_39);\n        }\n#endif                          /* COMMENT_0 */\n        if (VAR_3)\n            SSL_set_session_id_context(VAR_11, VAR_3, strlen((char *)VAR_3));\n    }\n    SSL_clear(VAR_11);\n#if 0\n# ifdef VAR_40\n    SSL_set_tlsext_opaque_prf_input(VAR_11, \"Test server\", 11);\n# endif\n#endif\n\n    if (VAR_2 == VAR_41) {\n\n        VAR_12 = BIO_new_dgram(VAR_1, VAR_42);\n\n        if (VAR_43) {\n            VAR_15.tv_sec = 0;\n            VAR_15.tv_usec = VAR_44;\n            BIO_ctrl(VAR_12, VAR_45, 0, &VAR_15);\n\n            VAR_15.tv_sec = 0;\n            VAR_15.tv_usec = VAR_46;\n            BIO_ctrl(VAR_12, VAR_47, 0, &VAR_15);\n        }\n\n        if (VAR_48) {\n            if (VAR_48 < DTLS_get_link_min_mtu(VAR_11)) {\n                BIO_printf(VAR_23, \"MTU too small. Must be at least %ld\\n\",\n                           DTLS_get_link_min_mtu(VAR_11));\n                VAR_6 = -1;\n                BIO_free(VAR_12);\n                goto err;\n            }\n            SSL_set_options(VAR_11, VAR_49);\n            if (!DTLS_set_link_mtu(VAR_11, VAR_48)) {\n                BIO_printf(VAR_23, \"Failed to set MTU\\n\");\n                VAR_6 = -1;\n                BIO_free(VAR_12);\n                goto err;\n            }\n        } else\n            /* COMMENT_1 */\n            BIO_ctrl(VAR_12, VAR_50, 0, NULL);\n\n        /* COMMENT_2 */\n        SSL_set_options(VAR_11, VAR_51);\n    } else\n        VAR_12 = BIO_new_socket(VAR_1, VAR_42);\n\n    if (VAR_52) {\n        BIO *VAR_53;\n\n        VAR_53 = BIO_new(BIO_f_nbio_test());\n        VAR_12 = BIO_push(VAR_53, VAR_12);\n    }\n#ifndef VAR_54\n    if (VAR_55)\n        jpake_server_auth(VAR_32, VAR_12, VAR_55);\n#endif\n\n    SSL_set_bio(VAR_11, VAR_12, VAR_12);\n    SSL_set_accept_state(VAR_11);\n    /* COMMENT_3 */\n\n    if (VAR_56) {\n        SSL_set_debug(VAR_11, 1);\n        BIO_set_callback(SSL_get_rbio(VAR_11), VAR_57);\n        BIO_set_callback_arg(SSL_get_rbio(VAR_11), (char *)VAR_32);\n    }\n    if (VAR_58) {\n#ifndef VAR_59\n        if (VAR_58 == 2)\n            SSL_set_msg_callback(VAR_11, VAR_60);\n        else\n#endif\n            SSL_set_msg_callback(VAR_11, VAR_61);\n        SSL_set_msg_callback_arg(VAR_11, VAR_62 ? VAR_62 : VAR_32);\n    }\n#ifndef VAR_29\n    if (VAR_30) {\n        SSL_set_tlsext_debug_callback(VAR_11, VAR_31);\n        SSL_set_tlsext_debug_arg(VAR_11, VAR_32);\n    }\n#endif\n\n    VAR_7 = VAR_1 + 1;\n    for (;;) {\n        int VAR_63;\n        int VAR_64;\n\n        VAR_63 = 0;\n        VAR_64 = SSL_pending(VAR_11);\n\n        if (!VAR_64) {\n            FD_ZERO(&VAR_5);\n#if !defined(VAR_16) && !defined(VAR_17) && !defined(VAR_18) && !defined(VAR_19)\n            openssl_fdset(fileno(VAR_65), &VAR_5);\n#endif\n            openssl_fdset(VAR_1, &VAR_5);\n            /* COMMENT_4 */\n                                                                     \n                                                                          \n                                                                            \n                                                                          \n                        \n               \n#if defined(VAR_16) || defined(VAR_17) || defined(VAR_18)\n            /* COMMENT_11 */\n                                                                          \n                                                                           \n                                                                     \n                                                                         \n               \n            VAR_20.tv_sec = 1;\n            VAR_20.tv_usec = 0;\n            VAR_9 = select(VAR_7, (void *)&VAR_5, NULL, NULL, &VAR_20);\n            if ((VAR_9 < 0) || (!VAR_9 && !_kbhit()))\n                continue;\n            if (_kbhit())\n                VAR_63 = 1;\n#elif defined(VAR_19)\n            /* COMMENT_17 */\n            VAR_20.tv_sec = 1;\n            VAR_20.tv_usec = 0;\n            (void)fcntl(fileno(VAR_65), VAR_66, VAR_67);\n            VAR_9 = select(VAR_7, (void *)&VAR_5, NULL, NULL, &VAR_20);\n            if ((VAR_9 < 0) || (!VAR_9 && read(fileno(VAR_65), VAR_4, 0) < 0))\n                continue;\n            if (read(fileno(VAR_65), VAR_4, 0) >= 0)\n                VAR_63 = 1;\n            (void)fcntl(fileno(VAR_65), VAR_66, 0);\n#else\n            if ((SSL_version(VAR_11) == VAR_68) &&\n                DTLSv1_get_timeout(VAR_11, &VAR_15))\n                VAR_21 = &VAR_15;\n            else\n                VAR_21 = NULL;\n\n            VAR_9 = select(VAR_7, (void *)&VAR_5, NULL, NULL, VAR_21);\n\n            if ((SSL_version(VAR_11) == VAR_68)\n                && DTLSv1_handle_timeout(VAR_11) > 0) {\n                BIO_printf(VAR_23, \"TIMEOUT occured\\n\");\n            }\n\n            if (VAR_9 <= 0)\n                continue;\n            if (FD_ISSET(fileno(VAR_65), &VAR_5))\n                VAR_63 = 1;\n#endif\n            if (FD_ISSET(VAR_1, &VAR_5))\n                VAR_64 = 1;\n        }\n        if (VAR_63) {\n            if (VAR_69) {\n                int VAR_70, VAR_71;\n\n                VAR_9 = raw_read_stdin(VAR_4, VAR_22 / 2);\n                VAR_71 = 0;\n                /* COMMENT_18 */\n                for (VAR_70 = 0; VAR_70 < VAR_9; VAR_70++)\n                    if (VAR_4[VAR_70] == '\\n')\n                        VAR_71++;\n                for (VAR_70 = VAR_9 - 1; VAR_70 >= 0; VAR_70--) {\n                    VAR_4[VAR_70 + VAR_71] = VAR_4[VAR_70];\n                    if (VAR_4[VAR_70] == '\\n') {\n                        VAR_71--;\n                        VAR_9++;\n                        VAR_4[VAR_70 + VAR_71] = '\\r';\n                    }\n                }\n                assert(VAR_71 == 0);\n            } else\n                VAR_9 = raw_read_stdin(VAR_4, VAR_22);\n            if (!VAR_27 && !VAR_72) {\n                if ((VAR_9 <= 0) || (VAR_4[0] == 'Q')) {\n                    BIO_printf(VAR_32, \"DONE\\n\");\n                    SHUTDOWN(VAR_1);\n                    close_accept_socket();\n                    VAR_6 = -11;\n                    goto err;\n                }\n                if ((VAR_9 <= 0) || (VAR_4[0] == 'q')) {\n                    BIO_printf(VAR_32, \"DONE\\n\");\n                    if (SSL_version(VAR_11) != VAR_68)\n                        SHUTDOWN(VAR_1);\n                    /* COMMENT_19 */\n                                                       \n                       \n                    goto err;\n                }\n#ifndef VAR_73\n                if ((VAR_4[0] == 'B') && ((VAR_4[1] == '\\n') || (VAR_4[1] == '\\r'))) {\n                    BIO_printf(VAR_23, \"HEARTBEATING\\n\");\n                    SSL_heartbeat(VAR_11);\n                    VAR_9 = 0;\n                    continue;\n                }\n#endif\n                if ((VAR_4[0] == 'r') && ((VAR_4[1] == '\\n') || (VAR_4[1] == '\\r'))) {\n                    SSL_renegotiate(VAR_11);\n                    VAR_9 = SSL_do_handshake(VAR_11);\n                    printf(\"SSL_do_handshake -> %d\\n\", VAR_9);\n                    VAR_9 = 0;      /* COMMENT_22 */\n                    continue;\n                    /* COMMENT_23 */\n                                                                \n                       \n                }\n                if ((VAR_4[0] == 'R') && ((VAR_4[1] == '\\n') || (VAR_4[1] == '\\r'))) {\n                    SSL_set_verify(VAR_11,\n                                   VAR_74 | VAR_75,\n                                   NULL);\n                    SSL_renegotiate(VAR_11);\n                    VAR_9 = SSL_do_handshake(VAR_11);\n                    printf(\"SSL_do_handshake -> %d\\n\", VAR_9);\n                    VAR_9 = 0;      /* COMMENT_22 */\n                    continue;\n                    /* COMMENT_26 */\n                                                                             \n                                \n                       \n                }\n                if (VAR_4[0] == 'P') {\n                    static const char *VAR_76 = \"Lets print some clear text\\n\";\n                    BIO_write(SSL_get_wbio(VAR_11), VAR_76, strlen(VAR_76));\n                }\n                if (VAR_4[0] == 'S') {\n                    print_stats(VAR_32, SSL_get_SSL_CTX(VAR_11));\n                }\n            }\n#ifdef VAR_77\n            ebcdic2ascii(VAR_4, VAR_4, VAR_9);\n#endif\n            VAR_10 = VAR_8 = 0;\n            for (;;) {\n                /* COMMENT_30 */\n#ifdef VAR_78\n                {\n                    static countVAR_79 = 0;\n                    if (++count == 100) {\n                        count = 0;\n                        SSL_renegotiate(VAR_11);\n                    }\n                }\n#endif\n                VAR_8 = SSL_write(VAR_11, &(VAR_4[VAR_10]), (unsigned int)VAR_9);\n#ifndef VAR_80\n                while (SSL_get_error(VAR_11, VAR_8) == VAR_81) {\n                    BIO_printf(VAR_32, \"LOOKUP renego during write\\n\");\n                    SRP_user_pwd_free(VAR_82.user);\n                    VAR_82.user =\n                        SRP_VBASE_get1_by_user(VAR_82.vb,\n                                               VAR_82.login);\n                    if (VAR_82.user)\n                        BIO_printf(VAR_32, \"LOOKUP done %s\\n\",\n                                   VAR_82.user->info);\n                    else\n                        BIO_printf(VAR_32, \"LOOKUP not successful\\n\");\n                    VAR_8 = SSL_write(VAR_11, &(VAR_4[VAR_10]), (unsigned int)VAR_9);\n                }\n#endif\n                switch (SSL_get_error(VAR_11, VAR_8)) {\n                case VAR_83:\n                    break;\n                case VAR_84:\n                case VAR_85:\n                case VAR_81:\n                    BIO_printf(VAR_32, \"Write BLOCK\\n\");\n                    break;\n                case VAR_86:\n                case VAR_87:\n                    BIO_printf(VAR_32, \"ERROR\\n\");\n                    ERR_print_errors(VAR_23);\n                    VAR_6 = 1;\n                    goto err;\n                    /* COMMENT_31 */\n                case VAR_88:\n                    BIO_printf(VAR_32, \"DONE\\n\");\n                    VAR_6 = 1;\n                    goto err;\n                }\n                if (VAR_8 > 0) {\n                    VAR_10 += VAR_8;\n                    VAR_9 -= VAR_8;\n                }\n                if (VAR_9 <= 0)\n                    break;\n            }\n        }\n        if (VAR_64) {\n            if (!SSL_is_init_finished(VAR_11)) {\n                VAR_9 = init_ssl_connection(VAR_11);\n\n                if (VAR_9 < 0) {\n                    VAR_6 = 0;\n                    goto err;\n                } else if (VAR_9 == 0) {\n                    VAR_6 = 1;\n                    goto err;\n                }\n            } else {\n again:\n                VAR_9 = SSL_read(VAR_11, (char *)VAR_4, VAR_22);\n#ifndef VAR_80\n                while (SSL_get_error(VAR_11, VAR_9) == VAR_81) {\n                    BIO_printf(VAR_32, \"LOOKUP renego during read\\n\");\n                    SRP_user_pwd_free(VAR_82.user);\n                    VAR_82.user =\n                        SRP_VBASE_get1_by_user(VAR_82.vb,\n                                               VAR_82.login);\n                    if (VAR_82.user)\n                        BIO_printf(VAR_32, \"LOOKUP done %s\\n\",\n                                   VAR_82.user->info);\n                    else\n                        BIO_printf(VAR_32, \"LOOKUP not successful\\n\");\n                    VAR_9 = SSL_read(VAR_11, (char *)VAR_4, VAR_22);\n                }\n#endif\n                switch (SSL_get_error(VAR_11, VAR_9)) {\n                case VAR_83:\n#ifdef VAR_77\n                    ascii2ebcdic(VAR_4, VAR_4, VAR_9);\n#endif\n                    raw_write_stdout(VAR_4, (unsigned int)VAR_9);\n                    if (SSL_pending(VAR_11))\n                        goto again;\n                    break;\n                case VAR_84:\n                case VAR_85:\n                    BIO_printf(VAR_32, \"Read BLOCK\\n\");\n                    break;\n                case VAR_86:\n                case VAR_87:\n                    BIO_printf(VAR_32, \"ERROR\\n\");\n                    ERR_print_errors(VAR_23);\n                    VAR_6 = 1;\n                    goto err;\n                case VAR_88:\n                    BIO_printf(VAR_32, \"DONE\\n\");\n                    VAR_6 = 1;\n                    goto err;\n                }\n            }\n        }\n    }\n err:\n    if (VAR_11 != NULL) {\n        BIO_printf(VAR_32, \"shutting down SSL\\n\");\n#if 1\n        SSL_set_shutdown(VAR_11, VAR_89 | VAR_90);\n#else\n        SSL_shutdown(VAR_11);\n#endif\n        SSL_free(VAR_11);\n    }\n    BIO_printf(VAR_32, \"CONNECTION CLOSED\\n\");\n    if (VAR_4 != NULL) {\n        OPENSSL_cleanse(VAR_4, VAR_22);\n        OPENSSL_free(VAR_4);\n    }\n    if (VAR_6 >= 0)\n        BIO_printf(VAR_32, \"ACCEPT\\n\");\n    return (VAR_6);\n}",
    "func_graph_path": "openssl/259b664f950c2ba66fbf4b0fe5281327904ead21/s_server.c/vul/after/4.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -301,9 +301,10 @@\n #ifndef OPENSSL_NO_SRP\n                 while (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) {\n                     BIO_printf(bio_s_out, \"LOOKUP renego during write\\n\");\n+                    SRP_user_pwd_free(srp_callback_parm.user);\n                     srp_callback_parm.user =\n-                        SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                              srp_callback_parm.login);\n+                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                               srp_callback_parm.login);\n                     if (srp_callback_parm.user)\n                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                    srp_callback_parm.user->info);\n@@ -357,9 +358,10 @@\n #ifndef OPENSSL_NO_SRP\n                 while (SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\n                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");\n+                    SRP_user_pwd_free(srp_callback_parm.user);\n                     srp_callback_parm.user =\n-                        SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                              srp_callback_parm.login);\n+                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                               srp_callback_parm.login);\n                     if (srp_callback_parm.user)\n                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                    srp_callback_parm.user->info);",
    "diff_line_info": {
        "deleted_lines": [
            "                        SRP_VBASE_get_by_user(srp_callback_parm.vb,",
            "                                              srp_callback_parm.login);",
            "                        SRP_VBASE_get_by_user(srp_callback_parm.vb,",
            "                                              srp_callback_parm.login);"
        ],
        "added_lines": [
            "                    SRP_user_pwd_free(srp_callback_parm.user);",
            "                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
            "                                               srp_callback_parm.login);",
            "                    SRP_user_pwd_free(srp_callback_parm.user);",
            "                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,",
            "                                               srp_callback_parm.login);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}