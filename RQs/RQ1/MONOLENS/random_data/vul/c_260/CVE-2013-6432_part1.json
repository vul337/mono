{
    "cve_id": "CVE-2013-6432",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:L/AC:L/Au:S/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "ping: prevent NULL pointer dereference on write to msg_name\n\nA plain read() on a socket does set msg->msg_name to NULL. So check for\nNULL pointer first.\n\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "commit_hash": "cf970c002d270c36202bd5b9c2804d3097a52da0",
    "git_url": "https://github.com/torvalds/linux/commit/cf970c002d270c36202bd5b9c2804d3097a52da0",
    "file_path": "net/ipv4/ping.c",
    "func_name": "ping_recvmsg",
    "func_before": "int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tint family = sk->sk_family;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tpr_debug(\"ping_recvmsg(sk=%p,sk->num=%u)\\n\", isk, isk->inet_num);\n\n\terr = -EOPNOTSUPP;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\tif (family == AF_INET) {\n\t\t\treturn ip_recv_error(sk, msg, len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (family == AF_INET6) {\n\t\t\treturn pingv6_ops.ipv6_recv_error(sk, msg, len);\n#endif\n\t\t}\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* Don't bother checking the checksum */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ip6->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tif (np->sndflow)\n\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t\t*addr_len = sizeof(*sin6);\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tpr_debug(\"ping_recvmsg -> %d\\n\", err);\n\treturn err;\n}",
    "abstract_func_before": "int ping_recvmsg(struct kiocb *VAR_0, struct sock *VAR_1, struct msghdr *VAR_2,\n\t\t size_t VAR_3, int VAR_4, int VAR_5, int *VAR_6)\n{\n\tstruct inet_sock *VAR_7 = inet_sk(VAR_1);\n\tint VAR_8 = VAR_1->sk_family;\n\tstruct sk_buff *VAR_9;\n\tint VAR_10, VAR_11;\n\n\tpr_debug(\"ping_recvmsg(sk=%p,sk->num=%u)\\n\", VAR_7, VAR_7->inet_num);\n\n\tVAR_11 = -VAR_12;\n\tif (VAR_5 & VAR_13)\n\t\tgoto out;\n\n\tif (VAR_5 & VAR_14) {\n\t\tif (VAR_8 == VAR_15) {\n\t\t\treturn ip_recv_error(VAR_1, VAR_2, VAR_3);\n#if IS_ENABLED(VAR_16)\n\t\t} else if (VAR_8 == VAR_17) {\n\t\t\treturn VAR_18.ipv6_recv_error(VAR_1, VAR_2, VAR_3);\n#endif\n\t\t}\n\t}\n\n\tVAR_9 = skb_recv_datagram(VAR_1, VAR_5, VAR_4, &VAR_11);\n\tif (!VAR_9)\n\t\tgoto out;\n\n\tVAR_10 = VAR_9->len;\n\tif (VAR_10 > VAR_3) {\n\t\tVAR_2->msg_flags |= VAR_19;\n\t\tVAR_10 = VAR_3;\n\t}\n\n\t/* COMMENT_0 */\n\tVAR_11 = skb_copy_datagram_iovec(VAR_9, 0, VAR_2->msg_iov, VAR_10);\n\tif (VAR_11)\n\t\tgoto done;\n\n\tsock_recv_timestamp(VAR_2, VAR_1, VAR_9);\n\n\t/* COMMENT_1 */\n\tif (VAR_8 == VAR_15) {\n\t\tstruct sockaddr_in *VAR_20 = (struct sockaddr_in *)VAR_2->msg_name;\n\n\t\tVAR_20->sin_family = VAR_15;\n\t\tVAR_20->sin_port = 0 /* COMMENT_2 */;\n\t\tVAR_20->sin_addr.s_addr = ip_hdr(VAR_9)->saddr;\n\t\tmemset(VAR_20->sin_zero, 0, sizeof(VAR_20->sin_zero));\n\t\t*VAR_6 = sizeof(*VAR_20);\n\n\t\tif (VAR_7->cmsg_flags)\n\t\t\tip_cmsg_recv(VAR_2, VAR_9);\n\n#if IS_ENABLED(VAR_16)\n\t} else if (VAR_8 == VAR_17) {\n\t\tstruct ipv6_pinfo *VAR_21 = inet6_sk(VAR_1);\n\t\tstruct ipv6hdr *VAR_22 = ipv6_hdr(VAR_9);\n\t\tstruct sockaddr_in6 *VAR_23 =\n\t\t\t(struct sockaddr_in6 *)VAR_2->msg_name;\n\n\t\tVAR_23->sin6_family = VAR_17;\n\t\tVAR_23->sin6_port = 0;\n\t\tVAR_23->sin6_addr = VAR_22->saddr;\n\t\tVAR_23->sin6_flowinfo = 0;\n\t\tif (VAR_21->sndflow)\n\t\t\tVAR_23->sin6_flowinfo = ip6_flowinfo(VAR_22);\n\n\t\tVAR_23->sin6_scope_id = ipv6_iface_scope_id(&VAR_23->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(VAR_9)->iif);\n\t\t*VAR_6 = sizeof(*VAR_23);\n\n\t\tif (inet6_sk(VAR_1)->rxopt.all)\n\t\t\tVAR_18.ip6_datagram_recv_ctl(VAR_1, VAR_2, VAR_9);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\tVAR_11 = VAR_10;\n\ndone:\n\tskb_free_datagram(VAR_1, VAR_9);\nout:\n\tpr_debug(\"ping_recvmsg -> %d\\n\", VAR_11);\n\treturn VAR_11;\n}",
    "func_graph_path_before": "torvalds/linux/cf970c002d270c36202bd5b9c2804d3097a52da0/ping.c/vul/before/0.json",
    "func": "int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tint family = sk->sk_family;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tpr_debug(\"ping_recvmsg(sk=%p,sk->num=%u)\\n\", isk, isk->inet_num);\n\n\terr = -EOPNOTSUPP;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\tif (family == AF_INET) {\n\t\t\treturn ip_recv_error(sk, msg, len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (family == AF_INET6) {\n\t\t\treturn pingv6_ops.ipv6_recv_error(sk, msg, len);\n#endif\n\t\t}\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* Don't bother checking the checksum */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\t*addr_len = sizeof(*sin);\n\t\t}\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tif (sin6) {\n\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\tsin6->sin6_port = 0;\n\t\t\tsin6->sin6_addr = ip6->saddr;\n\t\t\tsin6->sin6_flowinfo = 0;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t\t*addr_len = sizeof(*sin6);\n\t\t}\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tpr_debug(\"ping_recvmsg -> %d\\n\", err);\n\treturn err;\n}",
    "abstract_func": "int ping_recvmsg(struct kiocb *VAR_0, struct sock *VAR_1, struct msghdr *VAR_2,\n\t\t size_t VAR_3, int VAR_4, int VAR_5, int *VAR_6)\n{\n\tstruct inet_sock *VAR_7 = inet_sk(VAR_1);\n\tint VAR_8 = VAR_1->sk_family;\n\tstruct sk_buff *VAR_9;\n\tint VAR_10, VAR_11;\n\n\tpr_debug(\"ping_recvmsg(sk=%p,sk->num=%u)\\n\", VAR_7, VAR_7->inet_num);\n\n\tVAR_11 = -VAR_12;\n\tif (VAR_5 & VAR_13)\n\t\tgoto out;\n\n\tif (VAR_5 & VAR_14) {\n\t\tif (VAR_8 == VAR_15) {\n\t\t\treturn ip_recv_error(VAR_1, VAR_2, VAR_3);\n#if IS_ENABLED(VAR_16)\n\t\t} else if (VAR_8 == VAR_17) {\n\t\t\treturn VAR_18.ipv6_recv_error(VAR_1, VAR_2, VAR_3);\n#endif\n\t\t}\n\t}\n\n\tVAR_9 = skb_recv_datagram(VAR_1, VAR_5, VAR_4, &VAR_11);\n\tif (!VAR_9)\n\t\tgoto out;\n\n\tVAR_10 = VAR_9->len;\n\tif (VAR_10 > VAR_3) {\n\t\tVAR_2->msg_flags |= VAR_19;\n\t\tVAR_10 = VAR_3;\n\t}\n\n\t/* COMMENT_0 */\n\tVAR_11 = skb_copy_datagram_iovec(VAR_9, 0, VAR_2->msg_iov, VAR_10);\n\tif (VAR_11)\n\t\tgoto done;\n\n\tsock_recv_timestamp(VAR_2, VAR_1, VAR_9);\n\n\t/* COMMENT_1 */\n\tif (VAR_8 == VAR_15) {\n\t\tstruct sockaddr_in *VAR_20 = (struct sockaddr_in *)VAR_2->msg_name;\n\n\t\tif (VAR_20) {\n\t\t\tVAR_20->sin_family = VAR_15;\n\t\t\tVAR_20->sin_port = 0 /* COMMENT_2 */;\n\t\t\tVAR_20->sin_addr.s_addr = ip_hdr(VAR_9)->saddr;\n\t\t\tmemset(VAR_20->sin_zero, 0, sizeof(VAR_20->sin_zero));\n\t\t\t*VAR_6 = sizeof(*VAR_20);\n\t\t}\n\n\t\tif (VAR_7->cmsg_flags)\n\t\t\tip_cmsg_recv(VAR_2, VAR_9);\n\n#if IS_ENABLED(VAR_16)\n\t} else if (VAR_8 == VAR_17) {\n\t\tstruct ipv6_pinfo *VAR_21 = inet6_sk(VAR_1);\n\t\tstruct ipv6hdr *VAR_22 = ipv6_hdr(VAR_9);\n\t\tstruct sockaddr_in6 *VAR_23 =\n\t\t\t(struct sockaddr_in6 *)VAR_2->msg_name;\n\n\t\tif (VAR_23) {\n\t\t\tVAR_23->sin6_family = VAR_17;\n\t\t\tVAR_23->sin6_port = 0;\n\t\t\tVAR_23->sin6_addr = VAR_22->saddr;\n\t\t\tVAR_23->sin6_flowinfo = 0;\n\t\t\tif (VAR_21->sndflow)\n\t\t\t\tVAR_23->sin6_flowinfo = ip6_flowinfo(VAR_22);\n\t\t\tVAR_23->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&VAR_23->sin6_addr,\n\t\t\t\t\t\t    IP6CB(VAR_9)->iif);\n\t\t\t*VAR_6 = sizeof(*VAR_23);\n\t\t}\n\n\t\tif (inet6_sk(VAR_1)->rxopt.all)\n\t\t\tVAR_18.ip6_datagram_recv_ctl(VAR_1, VAR_2, VAR_9);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\tVAR_11 = VAR_10;\n\ndone:\n\tskb_free_datagram(VAR_1, VAR_9);\nout:\n\tpr_debug(\"ping_recvmsg -> %d\\n\", VAR_11);\n\treturn VAR_11;\n}",
    "func_graph_path": "torvalds/linux/cf970c002d270c36202bd5b9c2804d3097a52da0/ping.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -43,11 +43,13 @@\n \tif (family == AF_INET) {\n \t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n \n-\t\tsin->sin_family = AF_INET;\n-\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n-\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n-\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n-\t\t*addr_len = sizeof(*sin);\n+\t\tif (sin) {\n+\t\t\tsin->sin_family = AF_INET;\n+\t\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n+\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n+\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t\t*addr_len = sizeof(*sin);\n+\t\t}\n \n \t\tif (isk->cmsg_flags)\n \t\t\tip_cmsg_recv(msg, skb);\n@@ -59,16 +61,18 @@\n \t\tstruct sockaddr_in6 *sin6 =\n \t\t\t(struct sockaddr_in6 *)msg->msg_name;\n \n-\t\tsin6->sin6_family = AF_INET6;\n-\t\tsin6->sin6_port = 0;\n-\t\tsin6->sin6_addr = ip6->saddr;\n-\t\tsin6->sin6_flowinfo = 0;\n-\t\tif (np->sndflow)\n-\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n-\n-\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n-\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n-\t\t*addr_len = sizeof(*sin6);\n+\t\tif (sin6) {\n+\t\t\tsin6->sin6_family = AF_INET6;\n+\t\t\tsin6->sin6_port = 0;\n+\t\t\tsin6->sin6_addr = ip6->saddr;\n+\t\t\tsin6->sin6_flowinfo = 0;\n+\t\t\tif (np->sndflow)\n+\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n+\t\t\tsin6->sin6_scope_id =\n+\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n+\t\t\t\t\t\t    IP6CB(skb)->iif);\n+\t\t\t*addr_len = sizeof(*sin6);\n+\t\t}\n \n \t\tif (inet6_sk(sk)->rxopt.all)\n \t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);",
    "diff_line_info": {
        "deleted_lines": [
            "\t\tsin->sin_family = AF_INET;",
            "\t\tsin->sin_port = 0 /* skb->h.uh->source */;",
            "\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;",
            "\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));",
            "\t\t*addr_len = sizeof(*sin);",
            "\t\tsin6->sin6_family = AF_INET6;",
            "\t\tsin6->sin6_port = 0;",
            "\t\tsin6->sin6_addr = ip6->saddr;",
            "\t\tsin6->sin6_flowinfo = 0;",
            "\t\tif (np->sndflow)",
            "\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);",
            "",
            "\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,",
            "\t\t\t\t\t\t\t  IP6CB(skb)->iif);",
            "\t\t*addr_len = sizeof(*sin6);"
        ],
        "added_lines": [
            "\t\tif (sin) {",
            "\t\t\tsin->sin_family = AF_INET;",
            "\t\t\tsin->sin_port = 0 /* skb->h.uh->source */;",
            "\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;",
            "\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));",
            "\t\t\t*addr_len = sizeof(*sin);",
            "\t\t}",
            "\t\tif (sin6) {",
            "\t\t\tsin6->sin6_family = AF_INET6;",
            "\t\t\tsin6->sin6_port = 0;",
            "\t\t\tsin6->sin6_addr = ip6->saddr;",
            "\t\t\tsin6->sin6_flowinfo = 0;",
            "\t\t\tif (np->sndflow)",
            "\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);",
            "\t\t\tsin6->sin6_scope_id =",
            "\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,",
            "\t\t\t\t\t\t    IP6CB(skb)->iif);",
            "\t\t\t*addr_len = sizeof(*sin6);",
            "\t\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}