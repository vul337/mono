{
    "cve_id": "CVE-2009-2903",
    "cwe_ids": [
        "CWE-772"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "kernel/git/netdev/net-next",
    "commit_msg": "And also do a better job of returning proper NET_{RX,XMIT}_ values.\n\nBased on a patch and suggestions by Mark Smith.\n\nThis fixes CVE-2009-2903\n\nReported-by: Mark Smith <lk-netdev@lk-netdev.nosense.org>\nSigned-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n",
    "commit_hash": "ffcfb8db540ff879c2a85bf7e404954281443414",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net-next.git;a=commit;h=ffcfb8db540ff879c2a85bf7e404954281443414",
    "file_path": "net/appletalk/ddp.c",
    "func_name": "atalk_sendmsg",
    "func_before": "static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *usat = (struct sockaddr_at *)msg->msg_name;\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tif (usat) {\n\t\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\treturn -EBUSY;\n\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\n\t\t/* netatalk didn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\treturn -EPERM;\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t}\n\tif (!rt)\n\t\treturn -ENETUNREACH;\n\n\tdev = rt->dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tif (!skb)\n\t\treturn err;\n\n\tskb->sk = sk;\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_len_hops  = htons(len + sizeof(*ddp));\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%Zd bytes).\\n\", sk, len);\n\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sk->sk_no_check == 1)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\tif (aarp_send_ddp(dev, skb2,\n\t\t\t\t\t  &usat->sat_addr, NULL) == -1)\n\t\t\t\tkfree_skb(skb2);\n\t\t\t\t/* else queued/sent above in the aarp queue */\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tif (ddp->deh_dnode == ATADDR_BCAST) {\n\t\t\tstruct atalk_addr at_lo;\n\n\t\t\tat_lo.s_node = 0;\n\t\t\tat_lo.s_net  = 0;\n\n\t\t\trt = atrtr_find(&at_lo);\n\t\t\tif (!rt) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENETUNREACH;\n\t\t\t}\n\t\t\tdev = rt->dev;\n\t\t\tskb->dev = dev;\n\t\t}\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)\n\t\t\tkfree_skb(skb);\n\t\t/* else queued/sent above in the aarp queue */\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%Zd).\\n\", sk, len);\n\n\treturn len;\n}",
    "abstract_func_before": "static int atalk_sendmsg(struct kiocb *VAR_0, struct socket *VAR_1, struct msghdr *VAR_2,\n\t\t\t size_t VAR_3)\n{\n\tstruct sock *VAR_4 = sock->sk;\n\tstruct atalk_sock *VAR_5 = at_sk(VAR_4);\n\tstruct sockaddr_at *VAR_6 = (struct sockaddr_at *)VAR_2->msg_name;\n\tint VAR_7 = VAR_2->msg_flags;\n\tint VAR_8 = 0;\n\tstruct sockaddr_at VAR_9, VAR_10;\n\tstruct sk_buff *VAR_11;\n\tstruct net_device *VAR_12;\n\tstruct ddpehdr *VAR_13;\n\tint VAR_14;\n\tstruct atalk_route *VAR_15;\n\tint VAR_16;\n\n\tif (VAR_7 & ~(VAR_17|VAR_18))\n\t\treturn -VAR_19;\n\n\tif (VAR_3 > VAR_20)\n\t\treturn -VAR_21;\n\n\tif (VAR_6) {\n\t\tif (sock_flag(VAR_4, VAR_22))\n\t\t\tif (atalk_autobind(VAR_4) < 0)\n\t\t\t\treturn -VAR_23;\n\n\t\tif (VAR_2->msg_namelen < sizeof(*VAR_6) ||\n\t\t    VAR_6->sat_family != VAR_24)\n\t\t\treturn -VAR_19;\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_6->sat_addr.s_node == VAR_25 &&\n\t\t    !sock_flag(VAR_4, VAR_26)) {\n\t\t\treturn -VAR_27;\n\t\t}\n\t} else {\n\t\tif (VAR_4->sk_state != VAR_28)\n\t\t\treturn -VAR_29;\n\t\tVAR_6 = &VAR_9;\n\t\tVAR_6->sat_family      = VAR_24;\n\t\tVAR_6->sat_port\t      = VAR_5->dest_port;\n\t\tVAR_6->sat_addr.s_node = VAR_5->dest_node;\n\t\tVAR_6->sat_addr.s_net  = VAR_5->dest_net;\n\t}\n\n\t/* COMMENT_1 */\n\tSOCK_DEBUG(VAR_4, \"SK %p: Got address.\\n\", VAR_4);\n\n\t/* COMMENT_2 */\n\tVAR_14 = sizeof(struct ddpehdr) + VAR_3 + VAR_30->header_length;\n\n\tif (VAR_6->sat_addr.s_net || VAR_6->sat_addr.s_node == VAR_31) {\n\t\tVAR_15 = atrtr_find(&VAR_6->sat_addr);\n\t} else {\n\t\tstruct atalk_addr VAR_32;\n\n\t\tVAR_32.s_node = 0;\n\t\tVAR_32.s_net  = VAR_5->src_net;\n\n\t\tVAR_15 = atrtr_find(&VAR_32);\n\t}\n\tif (!VAR_15)\n\t\treturn -VAR_33;\n\n\tVAR_12 = VAR_15->dev;\n\n\tSOCK_DEBUG(VAR_4, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tVAR_4, VAR_14, VAR_12->name);\n\n\tVAR_14 += VAR_12->hard_header_len;\n\tVAR_11 = sock_alloc_send_skb(VAR_4, VAR_14, (VAR_7 & VAR_17), &VAR_16);\n\tif (!VAR_11)\n\t\treturn VAR_16;\n\n\tVAR_11->sk = VAR_4;\n\tskb_reserve(VAR_11, VAR_30->header_length);\n\tskb_reserve(VAR_11, VAR_12->hard_header_len);\n\tVAR_11->dev = VAR_12;\n\n\tSOCK_DEBUG(VAR_4, \"SK %p: Begin build.\\n\", VAR_4);\n\n\tVAR_13 = (struct ddpehdr *)skb_put(VAR_11, sizeof(struct ddpehdr));\n\tVAR_13->deh_len_hops  = htons(VAR_3 + sizeof(*VAR_13));\n\tVAR_13->deh_dnet  = VAR_6->sat_addr.s_net;\n\tVAR_13->deh_snet  = VAR_5->src_net;\n\tVAR_13->deh_dnode = VAR_6->sat_addr.s_node;\n\tVAR_13->deh_snode = VAR_5->src_node;\n\tVAR_13->deh_dport = VAR_6->sat_port;\n\tVAR_13->deh_sport = VAR_5->src_port;\n\n\tSOCK_DEBUG(VAR_4, \"SK %p: Copy user data (%Zd bytes).\\n\", VAR_4, VAR_3);\n\n\tVAR_16 = memcpy_fromiovec(skb_put(VAR_11, VAR_3), VAR_2->msg_iov, VAR_3);\n\tif (VAR_16) {\n\t\tkfree_skb(VAR_11);\n\t\treturn -VAR_34;\n\t}\n\n\tif (VAR_4->sk_no_check == 1)\n\t\tVAR_13->deh_sum = 0;\n\telse\n\t\tVAR_13->deh_sum = atalk_checksum(VAR_11, VAR_3 + sizeof(*VAR_13));\n\n\t/* COMMENT_3 */\n                                                                \n                       \n    \n\tif (VAR_13->deh_dnode == VAR_25 &&\n\t    !(VAR_15->flags & VAR_35) && !(VAR_12->flags & VAR_36)) {\n\t\tstruct sk_buff *VAR_37 = skb_copy(VAR_11, VAR_38);\n\n\t\tif (VAR_37) {\n\t\t\tVAR_8 = 1;\n\t\t\tSOCK_DEBUG(VAR_4, \"SK %p: send out(copy).\\n\", VAR_4);\n\t\t\tif (aarp_send_ddp(VAR_12, VAR_37,\n\t\t\t\t\t  &VAR_6->sat_addr, NULL) == -1)\n\t\t\t\tkfree_skb(VAR_37);\n\t\t\t\t/* COMMENT_7 */\n\t\t}\n\t}\n\n\tif (VAR_12->flags & VAR_36 || VAR_8) {\n\t\tSOCK_DEBUG(VAR_4, \"SK %p: Loop back.\\n\", VAR_4);\n\t\t/* COMMENT_8 */\n\t\tskb_orphan(VAR_11);\n\t\tif (VAR_13->deh_dnode == VAR_25) {\n\t\t\tstruct atalk_addr VAR_39;\n\n\t\t\tVAR_39.s_node = 0;\n\t\t\tVAR_39.s_net  = 0;\n\n\t\t\tVAR_15 = atrtr_find(&VAR_39);\n\t\t\tif (!VAR_15) {\n\t\t\t\tkfree_skb(VAR_11);\n\t\t\t\treturn -VAR_33;\n\t\t\t}\n\t\t\tVAR_12 = VAR_15->dev;\n\t\t\tVAR_11->dev = VAR_12;\n\t\t}\n\t\tVAR_30->request(VAR_30, VAR_11, VAR_12->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(VAR_4, \"SK %p: send out.\\n\", VAR_4);\n\t\tif (VAR_15->flags & VAR_35) {\n\t\t    VAR_10.sat_addr = VAR_15->gateway;\n\t\t    VAR_6 = &VAR_10;\n\t\t}\n\n\t\tif (aarp_send_ddp(VAR_12, VAR_11, &VAR_6->sat_addr, NULL) == -1)\n\t\t\tkfree_skb(VAR_11);\n\t\t/* COMMENT_7 */\n\t}\n\tSOCK_DEBUG(VAR_4, \"SK %p: Done write (%Zd).\\n\", VAR_4, VAR_3);\n\n\treturn VAR_3;\n}",
    "func_graph_path_before": "kernel/git/netdev/net-next/ffcfb8db540ff879c2a85bf7e404954281443414/ddp.c/vul/before/3.json",
    "func": "static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *usat = (struct sockaddr_at *)msg->msg_name;\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tif (usat) {\n\t\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\treturn -EBUSY;\n\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\n\t\t/* netatalk didn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\treturn -EPERM;\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t}\n\tif (!rt)\n\t\treturn -ENETUNREACH;\n\n\tdev = rt->dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tif (!skb)\n\t\treturn err;\n\n\tskb->sk = sk;\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_len_hops  = htons(len + sizeof(*ddp));\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%Zd bytes).\\n\", sk, len);\n\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sk->sk_no_check == 1)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\t/*\n\t\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t\t */\n\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tif (ddp->deh_dnode == ATADDR_BCAST) {\n\t\t\tstruct atalk_addr at_lo;\n\n\t\t\tat_lo.s_node = 0;\n\t\t\tat_lo.s_net  = 0;\n\n\t\t\trt = atrtr_find(&at_lo);\n\t\t\tif (!rt) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENETUNREACH;\n\t\t\t}\n\t\t\tdev = rt->dev;\n\t\t\tskb->dev = dev;\n\t\t}\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\t/*\n\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t */\n\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%Zd).\\n\", sk, len);\n\n\treturn len;\n}",
    "abstract_func": "static int atalk_sendmsg(struct kiocb *VAR_0, struct socket *VAR_1, struct msghdr *VAR_2,\n\t\t\t size_t VAR_3)\n{\n\tstruct sock *VAR_4 = sock->sk;\n\tstruct atalk_sock *VAR_5 = at_sk(VAR_4);\n\tstruct sockaddr_at *VAR_6 = (struct sockaddr_at *)VAR_2->msg_name;\n\tint VAR_7 = VAR_2->msg_flags;\n\tint VAR_8 = 0;\n\tstruct sockaddr_at VAR_9, VAR_10;\n\tstruct sk_buff *VAR_11;\n\tstruct net_device *VAR_12;\n\tstruct ddpehdr *VAR_13;\n\tint VAR_14;\n\tstruct atalk_route *VAR_15;\n\tint VAR_16;\n\n\tif (VAR_7 & ~(VAR_17|VAR_18))\n\t\treturn -VAR_19;\n\n\tif (VAR_3 > VAR_20)\n\t\treturn -VAR_21;\n\n\tif (VAR_6) {\n\t\tif (sock_flag(VAR_4, VAR_22))\n\t\t\tif (atalk_autobind(VAR_4) < 0)\n\t\t\t\treturn -VAR_23;\n\n\t\tif (VAR_2->msg_namelen < sizeof(*VAR_6) ||\n\t\t    VAR_6->sat_family != VAR_24)\n\t\t\treturn -VAR_19;\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_6->sat_addr.s_node == VAR_25 &&\n\t\t    !sock_flag(VAR_4, VAR_26)) {\n\t\t\treturn -VAR_27;\n\t\t}\n\t} else {\n\t\tif (VAR_4->sk_state != VAR_28)\n\t\t\treturn -VAR_29;\n\t\tVAR_6 = &VAR_9;\n\t\tVAR_6->sat_family      = VAR_24;\n\t\tVAR_6->sat_port\t      = VAR_5->dest_port;\n\t\tVAR_6->sat_addr.s_node = VAR_5->dest_node;\n\t\tVAR_6->sat_addr.s_net  = VAR_5->dest_net;\n\t}\n\n\t/* COMMENT_1 */\n\tSOCK_DEBUG(VAR_4, \"SK %p: Got address.\\n\", VAR_4);\n\n\t/* COMMENT_2 */\n\tVAR_14 = sizeof(struct ddpehdr) + VAR_3 + VAR_30->header_length;\n\n\tif (VAR_6->sat_addr.s_net || VAR_6->sat_addr.s_node == VAR_31) {\n\t\tVAR_15 = atrtr_find(&VAR_6->sat_addr);\n\t} else {\n\t\tstruct atalk_addr VAR_32;\n\n\t\tVAR_32.s_node = 0;\n\t\tVAR_32.s_net  = VAR_5->src_net;\n\n\t\tVAR_15 = atrtr_find(&VAR_32);\n\t}\n\tif (!VAR_15)\n\t\treturn -VAR_33;\n\n\tVAR_12 = VAR_15->dev;\n\n\tSOCK_DEBUG(VAR_4, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tVAR_4, VAR_14, VAR_12->name);\n\n\tVAR_14 += VAR_12->hard_header_len;\n\tVAR_11 = sock_alloc_send_skb(VAR_4, VAR_14, (VAR_7 & VAR_17), &VAR_16);\n\tif (!VAR_11)\n\t\treturn VAR_16;\n\n\tVAR_11->sk = VAR_4;\n\tskb_reserve(VAR_11, VAR_30->header_length);\n\tskb_reserve(VAR_11, VAR_12->hard_header_len);\n\tVAR_11->dev = VAR_12;\n\n\tSOCK_DEBUG(VAR_4, \"SK %p: Begin build.\\n\", VAR_4);\n\n\tVAR_13 = (struct ddpehdr *)skb_put(VAR_11, sizeof(struct ddpehdr));\n\tVAR_13->deh_len_hops  = htons(VAR_3 + sizeof(*VAR_13));\n\tVAR_13->deh_dnet  = VAR_6->sat_addr.s_net;\n\tVAR_13->deh_snet  = VAR_5->src_net;\n\tVAR_13->deh_dnode = VAR_6->sat_addr.s_node;\n\tVAR_13->deh_snode = VAR_5->src_node;\n\tVAR_13->deh_dport = VAR_6->sat_port;\n\tVAR_13->deh_sport = VAR_5->src_port;\n\n\tSOCK_DEBUG(VAR_4, \"SK %p: Copy user data (%Zd bytes).\\n\", VAR_4, VAR_3);\n\n\tVAR_16 = memcpy_fromiovec(skb_put(VAR_11, VAR_3), VAR_2->msg_iov, VAR_3);\n\tif (VAR_16) {\n\t\tkfree_skb(VAR_11);\n\t\treturn -VAR_34;\n\t}\n\n\tif (VAR_4->sk_no_check == 1)\n\t\tVAR_13->deh_sum = 0;\n\telse\n\t\tVAR_13->deh_sum = atalk_checksum(VAR_11, VAR_3 + sizeof(*VAR_13));\n\n\t/* COMMENT_3 */\n                                                                \n                       \n    \n\tif (VAR_13->deh_dnode == VAR_25 &&\n\t    !(VAR_15->flags & VAR_35) && !(VAR_12->flags & VAR_36)) {\n\t\tstruct sk_buff *VAR_37 = skb_copy(VAR_11, VAR_38);\n\n\t\tif (VAR_37) {\n\t\t\tVAR_8 = 1;\n\t\t\tSOCK_DEBUG(VAR_4, \"SK %p: send out(copy).\\n\", VAR_4);\n\t\t\t/* COMMENT_7 */\n                                                           \n      \n\t\t\taarp_send_ddp(VAR_12, VAR_37, &VAR_6->sat_addr, NULL);\n\t\t}\n\t}\n\n\tif (VAR_12->flags & VAR_36 || VAR_8) {\n\t\tSOCK_DEBUG(VAR_4, \"SK %p: Loop back.\\n\", VAR_4);\n\t\t/* COMMENT_10 */\n\t\tskb_orphan(VAR_11);\n\t\tif (VAR_13->deh_dnode == VAR_25) {\n\t\t\tstruct atalk_addr VAR_39;\n\n\t\t\tVAR_39.s_node = 0;\n\t\t\tVAR_39.s_net  = 0;\n\n\t\t\tVAR_15 = atrtr_find(&VAR_39);\n\t\t\tif (!VAR_15) {\n\t\t\t\tkfree_skb(VAR_11);\n\t\t\t\treturn -VAR_33;\n\t\t\t}\n\t\t\tVAR_12 = VAR_15->dev;\n\t\t\tVAR_11->dev = VAR_12;\n\t\t}\n\t\tVAR_30->request(VAR_30, VAR_11, VAR_12->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(VAR_4, \"SK %p: send out.\\n\", VAR_4);\n\t\tif (VAR_15->flags & VAR_35) {\n\t\t    VAR_10.sat_addr = VAR_15->gateway;\n\t\t    VAR_6 = &VAR_10;\n\t\t}\n\n\t\t/* COMMENT_11 */\n                                                          \n     \n\t\taarp_send_ddp(VAR_12, VAR_11, &VAR_6->sat_addr, NULL);\n\t}\n\tSOCK_DEBUG(VAR_4, \"SK %p: Done write (%Zd).\\n\", VAR_4, VAR_3);\n\n\treturn VAR_3;\n}",
    "func_graph_path": "kernel/git/netdev/net-next/ffcfb8db540ff879c2a85bf7e404954281443414/ddp.c/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -113,10 +113,10 @@\n \t\tif (skb2) {\n \t\t\tloopback = 1;\n \t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n-\t\t\tif (aarp_send_ddp(dev, skb2,\n-\t\t\t\t\t  &usat->sat_addr, NULL) == -1)\n-\t\t\t\tkfree_skb(skb2);\n-\t\t\t\t/* else queued/sent above in the aarp queue */\n+\t\t\t/*\n+\t\t\t * If it fails it is queued/sent above in the aarp queue\n+\t\t\t */\n+\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\n \t\t}\n \t}\n \n@@ -146,9 +146,10 @@\n \t\t    usat = &gsat;\n \t\t}\n \n-\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)\n-\t\t\tkfree_skb(skb);\n-\t\t/* else queued/sent above in the aarp queue */\n+\t\t/*\n+\t\t * If it fails it is queued/sent above in the aarp queue\n+\t\t */\n+\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\n \t}\n \tSOCK_DEBUG(sk, \"SK %p: Done write (%Zd).\\n\", sk, len);\n ",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t\tif (aarp_send_ddp(dev, skb2,",
            "\t\t\t\t\t  &usat->sat_addr, NULL) == -1)",
            "\t\t\t\tkfree_skb(skb2);",
            "\t\t\t\t/* else queued/sent above in the aarp queue */",
            "\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)",
            "\t\t\tkfree_skb(skb);",
            "\t\t/* else queued/sent above in the aarp queue */"
        ],
        "added_lines": [
            "\t\t\t/*",
            "\t\t\t * If it fails it is queued/sent above in the aarp queue",
            "\t\t\t */",
            "\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);",
            "\t\t/*",
            "\t\t * If it fails it is queued/sent above in the aarp queue",
            "\t\t */",
            "\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}