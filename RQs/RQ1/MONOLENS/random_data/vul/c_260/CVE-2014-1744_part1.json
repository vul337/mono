{
    "cve_id": "CVE-2014-1744",
    "cwe_ids": [
        "CWE-189"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "chromium",
    "commit_msg": "Check shared memory size before allocating it.\n\nThis will prevent overflow from multiplication.\n\nBUG=359454\n\nReview URL: https://codereview.chromium.org/214343006\n\ngit-svn-id: svn://svn.chromium.org/chrome/trunk/src@261549 0039d316-1c4b-4281-b951-d872f2087c98",
    "commit_hash": "223bb3e377e68427087569142cd72c18be28e114",
    "git_url": "https://github.com/chromium/chromium/commit/223bb3e377e68427087569142cd72c18be28e114",
    "file_path": "content/browser/renderer_host/media/audio_input_renderer_host.cc",
    "func_name": "AudioInputRendererHost::OnCreateStream",
    "func_before": "void AudioInputRendererHost::OnCreateStream(\n    int stream_id,\n    int render_view_id,\n    int session_id,\n    const AudioInputHostMsg_CreateStream_Config& config) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  DVLOG(1) << \"AudioInputRendererHost@\" << this\n           << \"::OnCreateStream(stream_id=\" << stream_id\n           << \", render_view_id=\" << render_view_id\n           << \", session_id=\" << session_id << \")\";\n  DCHECK_GT(render_view_id, 0);\n\n  // media::AudioParameters is validated in the deserializer.\n  if (LookupById(stream_id) != NULL) {\n    SendErrorMessage(stream_id, STREAM_ALREADY_EXISTS);\n    return;\n  }\n\n  media::AudioParameters audio_params(config.params);\n  if (media_stream_manager_->audio_input_device_manager()->\n      ShouldUseFakeDevice()) {\n    audio_params.Reset(\n        media::AudioParameters::AUDIO_FAKE,\n        config.params.channel_layout(), config.params.channels(), 0,\n        config.params.sample_rate(), config.params.bits_per_sample(),\n        config.params.frames_per_buffer());\n  }\n\n  // Check if we have the permission to open the device and which device to use.\n  std::string device_id = media::AudioManagerBase::kDefaultDeviceId;\n  if (audio_params.format() != media::AudioParameters::AUDIO_FAKE) {\n    const StreamDeviceInfo* info = media_stream_manager_->\n        audio_input_device_manager()->GetOpenedDeviceInfoById(session_id);\n    if (!info) {\n      SendErrorMessage(stream_id, PERMISSION_DENIED);\n      DLOG(WARNING) << \"No permission has been granted to input stream with \"\n                    << \"session_id=\" << session_id;\n      return;\n    }\n\n    device_id = info->device.id;\n  }\n\n  // Create a new AudioEntry structure.\n  scoped_ptr<AudioEntry> entry(new AudioEntry());\n\n  const uint32 segment_size = (sizeof(media::AudioInputBufferParameters) +\n                               audio_params.GetBytesPerBuffer());\n  entry->shared_memory_segment_count = config.shared_memory_count;\n\n  // Create the shared memory and share it with the renderer process\n  // using a new SyncWriter object.\n  if (!entry->shared_memory.CreateAndMapAnonymous(\n      segment_size * entry->shared_memory_segment_count)) {\n    // If creation of shared memory failed then send an error message.\n    SendErrorMessage(stream_id, SHARED_MEMORY_CREATE_FAILED);\n    return;\n  }\n\n  scoped_ptr<AudioInputSyncWriter> writer(\n      new AudioInputSyncWriter(&entry->shared_memory,\n                               entry->shared_memory_segment_count));\n\n  if (!writer->Init()) {\n    SendErrorMessage(stream_id, SYNC_WRITER_INIT_FAILED);\n    return;\n  }\n\n  // If we have successfully created the SyncWriter then assign it to the\n  // entry and construct an AudioInputController.\n  entry->writer.reset(writer.release());\n  if (WebContentsCaptureUtil::IsWebContentsDeviceId(device_id)) {\n    entry->controller = media::AudioInputController::CreateForStream(\n        audio_manager_->GetTaskRunner(),\n        this,\n        WebContentsAudioInputStream::Create(\n            device_id,\n            audio_params,\n            audio_manager_->GetWorkerTaskRunner(),\n            audio_mirroring_manager_),\n        entry->writer.get(),\n        user_input_monitor_);\n  } else {\n    // TODO(henrika): replace CreateLowLatency() with Create() as soon\n    // as satish has ensured that Speech Input also uses the default low-\n    // latency path. See crbug.com/112472 for details.\n    entry->controller =\n        media::AudioInputController::CreateLowLatency(audio_manager_,\n                                                      this,\n                                                      audio_params,\n                                                      device_id,\n                                                      entry->writer.get(),\n                                                      user_input_monitor_);\n  }\n\n  if (!entry->controller.get()) {\n    SendErrorMessage(stream_id, STREAM_CREATE_ERROR);\n    return;\n  }\n\n  // Set the initial AGC state for the audio input stream. Note that, the AGC\n  // is only supported in AUDIO_PCM_LOW_LATENCY mode.\n  if (config.params.format() == media::AudioParameters::AUDIO_PCM_LOW_LATENCY)\n    entry->controller->SetAutomaticGainControl(config.automatic_gain_control);\n\n  // Since the controller was created successfully, create an entry and add it\n  // to the map.\n  entry->stream_id = stream_id;\n  audio_entries_.insert(std::make_pair(stream_id, entry.release()));\n\n  MediaStreamManager::SendMessageToNativeLog(\n      \"Audio input stream created successfully.\");\n  audio_log_->OnCreated(stream_id, audio_params, device_id);\n}",
    "abstract_func_before": "void AudioInputRendererHost::OnCreateStream(\n    int VAR_0,\n    int VAR_1,\n    int VAR_2,\n    const AudioInputHostMsg_CreateStream_Config& VAR_3) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  DVLOG(1) << \"AudioInputRendererHost@\" << this\n           << \"::OnCreateStream(stream_id=\" << VAR_0\n           << \", render_view_id=\" << VAR_1\n           << \", session_id=\" << VAR_2 << \")\";\n  DCHECK_GT(VAR_1, 0);\n\n  /* COMMENT_0 */\n  if (LookupById(VAR_0) != NULL) {\n    SendErrorMessage(VAR_0, VAR_4);\n    return;\n  }\n\n  media::AudioParameters VAR_5(VAR_3.params);\n  if (VAR_6->audio_input_device_manager()->\n      ShouldUseFakeDevice()) {\n    VAR_5.Reset(\n        media::AudioParameters::AUDIO_FAKE,\n        VAR_3.params.channel_layout(), VAR_3.params.channels(), 0,\n        VAR_3.params.sample_rate(), VAR_3.params.bits_per_sample(),\n        VAR_3.params.frames_per_buffer());\n  }\n\n  /* COMMENT_1 */\n  std::string VAR_7 = media::AudioManagerBase::kDefaultDeviceId;\n  if (VAR_5.format() != media::AudioParameters::AUDIO_FAKE) {\n    const StreamDeviceInfo* VAR_8 = VAR_6->\n        audio_input_device_manager()->GetOpenedDeviceInfoById(VAR_2);\n    if (!VAR_8) {\n      SendErrorMessage(VAR_0, VAR_9);\n      DLOG(VAR_10) << \"No permission has been granted to input stream with \"\n                    << \"session_id=\" << VAR_2;\n      return;\n    }\n\n    VAR_7 = VAR_8->device.id;\n  }\n\n  /* COMMENT_2 */\n  scoped_ptr<AudioEntry> VAR_11(new AudioEntry());\n\n  const uint32 VAR_12 = (sizeof(media::AudioInputBufferParameters) +\n                               VAR_5.GetBytesPerBuffer());\n  VAR_11->shared_memory_segment_count = VAR_3.shared_memory_count;\n\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  if (!VAR_11->shared_memory.CreateAndMapAnonymous(\n      VAR_12 * VAR_11->shared_memory_segment_count)) {\n    /* COMMENT_5 */\n    SendErrorMessage(VAR_0, VAR_13);\n    return;\n  }\n\n  scoped_ptr<AudioInputSyncWriter> VAR_14(\n      new AudioInputSyncWriter(&VAR_11->shared_memory,\n                               VAR_11->shared_memory_segment_count));\n\n  if (!VAR_14->Init()) {\n    SendErrorMessage(VAR_0, VAR_15);\n    return;\n  }\n\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  VAR_11->writer.reset(VAR_14.release());\n  if (WebContentsCaptureUtil::IsWebContentsDeviceId(VAR_7)) {\n    VAR_11->controller = media::AudioInputController::CreateForStream(\n        VAR_16->GetTaskRunner(),\n        this,\n        WebContentsAudioInputStream::Create(\n            VAR_7,\n            VAR_5,\n            VAR_16->GetWorkerTaskRunner(),\n            VAR_17),\n        VAR_11->writer.get(),\n        VAR_18);\n  } else {\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    VAR_11->controller =\n        media::AudioInputController::CreateLowLatency(VAR_16,\n                                                      this,\n                                                      VAR_5,\n                                                      VAR_7,\n                                                      VAR_11->writer.get(),\n                                                      VAR_18);\n  }\n\n  if (!VAR_11->controller.get()) {\n    SendErrorMessage(VAR_0, VAR_19);\n    return;\n  }\n\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  if (VAR_3.params.format() == media::AudioParameters::AUDIO_PCM_LOW_LATENCY)\n    VAR_11->controller->SetAutomaticGainControl(VAR_3.automatic_gain_control);\n\n  /* COMMENT_13 */\n  /* COMMENT_14 */\n  VAR_11->stream_id = VAR_0;\n  VAR_20.insert(std::make_pair(VAR_0, VAR_11.release()));\n\n  MediaStreamManager::SendMessageToNativeLog(\n      \"Audio input stream created successfully.\");\n  VAR_21->OnCreated(VAR_0, VAR_5, VAR_7);\n}",
    "func_graph_path_before": "chromium/223bb3e377e68427087569142cd72c18be28e114/audio_input_renderer_host.cc/vul/before/0.json",
    "func": "void AudioInputRendererHost::OnCreateStream(\n    int stream_id,\n    int render_view_id,\n    int session_id,\n    const AudioInputHostMsg_CreateStream_Config& config) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  DVLOG(1) << \"AudioInputRendererHost@\" << this\n           << \"::OnCreateStream(stream_id=\" << stream_id\n           << \", render_view_id=\" << render_view_id\n           << \", session_id=\" << session_id << \")\";\n  DCHECK_GT(render_view_id, 0);\n\n  // media::AudioParameters is validated in the deserializer.\n  if (LookupById(stream_id) != NULL) {\n    SendErrorMessage(stream_id, STREAM_ALREADY_EXISTS);\n    return;\n  }\n\n  media::AudioParameters audio_params(config.params);\n  if (media_stream_manager_->audio_input_device_manager()->\n      ShouldUseFakeDevice()) {\n    audio_params.Reset(\n        media::AudioParameters::AUDIO_FAKE,\n        config.params.channel_layout(), config.params.channels(), 0,\n        config.params.sample_rate(), config.params.bits_per_sample(),\n        config.params.frames_per_buffer());\n  }\n\n  // Check if we have the permission to open the device and which device to use.\n  std::string device_id = media::AudioManagerBase::kDefaultDeviceId;\n  if (audio_params.format() != media::AudioParameters::AUDIO_FAKE) {\n    const StreamDeviceInfo* info = media_stream_manager_->\n        audio_input_device_manager()->GetOpenedDeviceInfoById(session_id);\n    if (!info) {\n      SendErrorMessage(stream_id, PERMISSION_DENIED);\n      DLOG(WARNING) << \"No permission has been granted to input stream with \"\n                    << \"session_id=\" << session_id;\n      return;\n    }\n\n    device_id = info->device.id;\n  }\n\n  // Create a new AudioEntry structure.\n  scoped_ptr<AudioEntry> entry(new AudioEntry());\n\n  const uint32 segment_size = (sizeof(media::AudioInputBufferParameters) +\n                               audio_params.GetBytesPerBuffer());\n  entry->shared_memory_segment_count = config.shared_memory_count;\n\n  // Create the shared memory and share it with the renderer process\n  // using a new SyncWriter object.\n  base::CheckedNumeric<uint32> size = segment_size;\n  size *= entry->shared_memory_segment_count;\n  if (!size.IsValid() ||\n      !entry->shared_memory.CreateAndMapAnonymous(size.ValueOrDie())) {\n    // If creation of shared memory failed then send an error message.\n    SendErrorMessage(stream_id, SHARED_MEMORY_CREATE_FAILED);\n    return;\n  }\n\n  scoped_ptr<AudioInputSyncWriter> writer(\n      new AudioInputSyncWriter(&entry->shared_memory,\n                               entry->shared_memory_segment_count));\n\n  if (!writer->Init()) {\n    SendErrorMessage(stream_id, SYNC_WRITER_INIT_FAILED);\n    return;\n  }\n\n  // If we have successfully created the SyncWriter then assign it to the\n  // entry and construct an AudioInputController.\n  entry->writer.reset(writer.release());\n  if (WebContentsCaptureUtil::IsWebContentsDeviceId(device_id)) {\n    entry->controller = media::AudioInputController::CreateForStream(\n        audio_manager_->GetTaskRunner(),\n        this,\n        WebContentsAudioInputStream::Create(\n            device_id,\n            audio_params,\n            audio_manager_->GetWorkerTaskRunner(),\n            audio_mirroring_manager_),\n        entry->writer.get(),\n        user_input_monitor_);\n  } else {\n    // TODO(henrika): replace CreateLowLatency() with Create() as soon\n    // as satish has ensured that Speech Input also uses the default low-\n    // latency path. See crbug.com/112472 for details.\n    entry->controller =\n        media::AudioInputController::CreateLowLatency(audio_manager_,\n                                                      this,\n                                                      audio_params,\n                                                      device_id,\n                                                      entry->writer.get(),\n                                                      user_input_monitor_);\n  }\n\n  if (!entry->controller.get()) {\n    SendErrorMessage(stream_id, STREAM_CREATE_ERROR);\n    return;\n  }\n\n  // Set the initial AGC state for the audio input stream. Note that, the AGC\n  // is only supported in AUDIO_PCM_LOW_LATENCY mode.\n  if (config.params.format() == media::AudioParameters::AUDIO_PCM_LOW_LATENCY)\n    entry->controller->SetAutomaticGainControl(config.automatic_gain_control);\n\n  // Since the controller was created successfully, create an entry and add it\n  // to the map.\n  entry->stream_id = stream_id;\n  audio_entries_.insert(std::make_pair(stream_id, entry.release()));\n\n  MediaStreamManager::SendMessageToNativeLog(\n      \"Audio input stream created successfully.\");\n  audio_log_->OnCreated(stream_id, audio_params, device_id);\n}",
    "abstract_func": "void AudioInputRendererHost::OnCreateStream(\n    int VAR_0,\n    int VAR_1,\n    int VAR_2,\n    const AudioInputHostMsg_CreateStream_Config& VAR_3) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  DVLOG(1) << \"AudioInputRendererHost@\" << this\n           << \"::OnCreateStream(stream_id=\" << VAR_0\n           << \", render_view_id=\" << VAR_1\n           << \", session_id=\" << VAR_2 << \")\";\n  DCHECK_GT(VAR_1, 0);\n\n  /* COMMENT_0 */\n  if (LookupById(VAR_0) != NULL) {\n    SendErrorMessage(VAR_0, VAR_4);\n    return;\n  }\n\n  media::AudioParameters VAR_5(VAR_3.params);\n  if (VAR_6->audio_input_device_manager()->\n      ShouldUseFakeDevice()) {\n    VAR_5.Reset(\n        media::AudioParameters::AUDIO_FAKE,\n        VAR_3.params.channel_layout(), VAR_3.params.channels(), 0,\n        VAR_3.params.sample_rate(), VAR_3.params.bits_per_sample(),\n        VAR_3.params.frames_per_buffer());\n  }\n\n  /* COMMENT_1 */\n  std::string VAR_7 = media::AudioManagerBase::kDefaultDeviceId;\n  if (VAR_5.format() != media::AudioParameters::AUDIO_FAKE) {\n    const StreamDeviceInfo* VAR_8 = VAR_6->\n        audio_input_device_manager()->GetOpenedDeviceInfoById(VAR_2);\n    if (!VAR_8) {\n      SendErrorMessage(VAR_0, VAR_9);\n      DLOG(VAR_10) << \"No permission has been granted to input stream with \"\n                    << \"session_id=\" << VAR_2;\n      return;\n    }\n\n    VAR_7 = VAR_8->device.id;\n  }\n\n  /* COMMENT_2 */\n  scoped_ptr<AudioEntry> VAR_11(new AudioEntry());\n\n  const uint32 VAR_12 = (sizeof(media::AudioInputBufferParameters) +\n                               VAR_5.GetBytesPerBuffer());\n  VAR_11->shared_memory_segment_count = VAR_3.shared_memory_count;\n\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  base::CheckedNumeric<uint32> VAR_13 = VAR_12;\n  VAR_13 *= VAR_11->shared_memory_segment_count;\n  if (!VAR_13.IsValid() ||\n      !VAR_11->shared_memory.CreateAndMapAnonymous(VAR_13.ValueOrDie())) {\n    /* COMMENT_5 */\n    SendErrorMessage(VAR_0, VAR_14);\n    return;\n  }\n\n  scoped_ptr<AudioInputSyncWriter> VAR_15(\n      new AudioInputSyncWriter(&VAR_11->shared_memory,\n                               VAR_11->shared_memory_segment_count));\n\n  if (!VAR_15->Init()) {\n    SendErrorMessage(VAR_0, VAR_16);\n    return;\n  }\n\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  VAR_11->writer.reset(VAR_15.release());\n  if (WebContentsCaptureUtil::IsWebContentsDeviceId(VAR_7)) {\n    VAR_11->controller = media::AudioInputController::CreateForStream(\n        VAR_17->GetTaskRunner(),\n        this,\n        WebContentsAudioInputStream::Create(\n            VAR_7,\n            VAR_5,\n            VAR_17->GetWorkerTaskRunner(),\n            VAR_18),\n        VAR_11->writer.get(),\n        VAR_19);\n  } else {\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    VAR_11->controller =\n        media::AudioInputController::CreateLowLatency(VAR_17,\n                                                      this,\n                                                      VAR_5,\n                                                      VAR_7,\n                                                      VAR_11->writer.get(),\n                                                      VAR_19);\n  }\n\n  if (!VAR_11->controller.get()) {\n    SendErrorMessage(VAR_0, VAR_20);\n    return;\n  }\n\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  if (VAR_3.params.format() == media::AudioParameters::AUDIO_PCM_LOW_LATENCY)\n    VAR_11->controller->SetAutomaticGainControl(VAR_3.automatic_gain_control);\n\n  /* COMMENT_13 */\n  /* COMMENT_14 */\n  VAR_11->stream_id = VAR_0;\n  VAR_21.insert(std::make_pair(VAR_0, VAR_11.release()));\n\n  MediaStreamManager::SendMessageToNativeLog(\n      \"Audio input stream created successfully.\");\n  VAR_22->OnCreated(VAR_0, VAR_5, VAR_7);\n}",
    "func_graph_path": "chromium/223bb3e377e68427087569142cd72c18be28e114/audio_input_renderer_host.cc/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -51,8 +51,10 @@\n \n   // Create the shared memory and share it with the renderer process\n   // using a new SyncWriter object.\n-  if (!entry->shared_memory.CreateAndMapAnonymous(\n-      segment_size * entry->shared_memory_segment_count)) {\n+  base::CheckedNumeric<uint32> size = segment_size;\n+  size *= entry->shared_memory_segment_count;\n+  if (!size.IsValid() ||\n+      !entry->shared_memory.CreateAndMapAnonymous(size.ValueOrDie())) {\n     // If creation of shared memory failed then send an error message.\n     SendErrorMessage(stream_id, SHARED_MEMORY_CREATE_FAILED);\n     return;",
    "diff_line_info": {
        "deleted_lines": [
            "  if (!entry->shared_memory.CreateAndMapAnonymous(",
            "      segment_size * entry->shared_memory_segment_count)) {"
        ],
        "added_lines": [
            "  base::CheckedNumeric<uint32> size = segment_size;",
            "  size *= entry->shared_memory_segment_count;",
            "  if (!size.IsValid() ||",
            "      !entry->shared_memory.CreateAndMapAnonymous(size.ValueOrDie())) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}