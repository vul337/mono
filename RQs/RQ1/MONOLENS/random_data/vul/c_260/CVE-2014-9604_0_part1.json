{
    "cve_id": "CVE-2014-9604",
    "cwe_ids": [
        "CWE-189"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "ffmpeg",
    "commit_msg": "\navcodec/utvideodec: Fix handling of slice_height=0\n\nFixes out of array accesses\nFixes: asan_heap-oob_25bcd7e_3783_cov_3553517262_utvideo_rgba_median.avi\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n",
    "commit_hash": "3881606240953b9275a247a1c98a567f3c44890f",
    "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3881606240953b9275a247a1c98a567f3c44890f",
    "file_path": "libavcodec/utvideodec.c",
    "func_name": "restore_median_il",
    "func_before": "static void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}",
    "abstract_func_before": "static void restore_median_il(uint8_t *VAR_0, int VAR_1, int VAR_2,\n                              int VAR_3, int VAR_4, int VAR_5, int VAR_6)\n{\n    int VAR_7, VAR_8, VAR_9;\n    int VAR_10, VAR_11, VAR_12;\n    uint8_t *VAR_13;\n    int VAR_14, VAR_15;\n    const int VAR_16   = ~(VAR_6 ? 3 : 1);\n    const int VAR_17 = VAR_2 << 1;\n\n    for (VAR_9 = 0; VAR_9 < VAR_5; VAR_9++) {\n        VAR_14    = ((VAR_9 * VAR_4) / VAR_5) & VAR_16;\n        VAR_15   = ((((VAR_9 + 1) * VAR_4) / VAR_5) & VAR_16) -\n                         VAR_14;\n        VAR_15 >>= 1;\n\n        VAR_13 = VAR_0 + VAR_14 * VAR_2;\n\n        /* COMMENT_0 */\n        VAR_13[0] += 0x80;\n        VAR_10        = VAR_13[0];\n        for (VAR_7 = VAR_1; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n            VAR_13[VAR_7] += VAR_10;\n            VAR_10        = VAR_13[VAR_7];\n        }\n        for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n            VAR_13[VAR_2 + VAR_7] += VAR_10;\n            VAR_10                 = VAR_13[VAR_2 + VAR_7];\n        }\n        VAR_13 += VAR_17;\n        if (VAR_15 <= 1)\n            continue;\n        /* COMMENT_1 */\n        VAR_12        = VAR_13[-VAR_17];\n        VAR_13[0] += VAR_12;\n        VAR_10        = VAR_13[0];\n        for (VAR_7 = VAR_1; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n            VAR_11        = VAR_13[VAR_7 - VAR_17];\n            VAR_13[VAR_7] += mid_pred(VAR_10, VAR_11, (uint8_t)(VAR_10 + VAR_11 - VAR_12));\n            VAR_12        = VAR_11;\n            VAR_10        = VAR_13[VAR_7];\n        }\n        for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n            VAR_11                 = VAR_13[VAR_7 - VAR_2];\n            VAR_13[VAR_2 + VAR_7] += mid_pred(VAR_10, VAR_11, (uint8_t)(VAR_10 + VAR_11 - VAR_12));\n            VAR_12                 = VAR_11;\n            VAR_10                 = VAR_13[VAR_2 + VAR_7];\n        }\n        VAR_13 += VAR_17;\n        /* COMMENT_2 */\n        for (VAR_8 = 2; VAR_8 < VAR_15; VAR_8++) {\n            for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n                VAR_11        = VAR_13[VAR_7 - VAR_17];\n                VAR_13[VAR_7] += mid_pred(VAR_10, VAR_11, (uint8_t)(VAR_10 + VAR_11 - VAR_12));\n                VAR_12        = VAR_11;\n                VAR_10        = VAR_13[VAR_7];\n            }\n            for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n                VAR_11                 = VAR_13[VAR_7 - VAR_2];\n                VAR_13[VAR_7 + VAR_2] += mid_pred(VAR_10, VAR_11, (uint8_t)(VAR_10 + VAR_11 - VAR_12));\n                VAR_12                 = VAR_11;\n                VAR_10                 = VAR_13[VAR_7 + VAR_2];\n            }\n            VAR_13 += VAR_17;\n        }\n    }\n}",
    "func_graph_path_before": "ffmpeg/3881606240953b9275a247a1c98a567f3c44890f/utvideodec.c/vul/before/1.json",
    "func": "static void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n        if (!slice_height)\n            continue;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}",
    "abstract_func": "static void restore_median_il(uint8_t *VAR_0, int VAR_1, int VAR_2,\n                              int VAR_3, int VAR_4, int VAR_5, int VAR_6)\n{\n    int VAR_7, VAR_8, VAR_9;\n    int VAR_10, VAR_11, VAR_12;\n    uint8_t *VAR_13;\n    int VAR_14, VAR_15;\n    const int VAR_16   = ~(VAR_6 ? 3 : 1);\n    const int VAR_17 = VAR_2 << 1;\n\n    for (VAR_9 = 0; VAR_9 < VAR_5; VAR_9++) {\n        VAR_14    = ((VAR_9 * VAR_4) / VAR_5) & VAR_16;\n        VAR_15   = ((((VAR_9 + 1) * VAR_4) / VAR_5) & VAR_16) -\n                         VAR_14;\n        VAR_15 >>= 1;\n        if (!VAR_15)\n            continue;\n\n        VAR_13 = VAR_0 + VAR_14 * VAR_2;\n\n        /* COMMENT_0 */\n        VAR_13[0] += 0x80;\n        VAR_10        = VAR_13[0];\n        for (VAR_7 = VAR_1; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n            VAR_13[VAR_7] += VAR_10;\n            VAR_10        = VAR_13[VAR_7];\n        }\n        for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n            VAR_13[VAR_2 + VAR_7] += VAR_10;\n            VAR_10                 = VAR_13[VAR_2 + VAR_7];\n        }\n        VAR_13 += VAR_17;\n        if (VAR_15 <= 1)\n            continue;\n        /* COMMENT_1 */\n        VAR_12        = VAR_13[-VAR_17];\n        VAR_13[0] += VAR_12;\n        VAR_10        = VAR_13[0];\n        for (VAR_7 = VAR_1; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n            VAR_11        = VAR_13[VAR_7 - VAR_17];\n            VAR_13[VAR_7] += mid_pred(VAR_10, VAR_11, (uint8_t)(VAR_10 + VAR_11 - VAR_12));\n            VAR_12        = VAR_11;\n            VAR_10        = VAR_13[VAR_7];\n        }\n        for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n            VAR_11                 = VAR_13[VAR_7 - VAR_2];\n            VAR_13[VAR_2 + VAR_7] += mid_pred(VAR_10, VAR_11, (uint8_t)(VAR_10 + VAR_11 - VAR_12));\n            VAR_12                 = VAR_11;\n            VAR_10                 = VAR_13[VAR_2 + VAR_7];\n        }\n        VAR_13 += VAR_17;\n        /* COMMENT_2 */\n        for (VAR_8 = 2; VAR_8 < VAR_15; VAR_8++) {\n            for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n                VAR_11        = VAR_13[VAR_7 - VAR_17];\n                VAR_13[VAR_7] += mid_pred(VAR_10, VAR_11, (uint8_t)(VAR_10 + VAR_11 - VAR_12));\n                VAR_12        = VAR_11;\n                VAR_10        = VAR_13[VAR_7];\n            }\n            for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_1; VAR_7 += VAR_1) {\n                VAR_11                 = VAR_13[VAR_7 - VAR_2];\n                VAR_13[VAR_7 + VAR_2] += mid_pred(VAR_10, VAR_11, (uint8_t)(VAR_10 + VAR_11 - VAR_12));\n                VAR_12                 = VAR_11;\n                VAR_10                 = VAR_13[VAR_7 + VAR_2];\n            }\n            VAR_13 += VAR_17;\n        }\n    }\n}",
    "func_graph_path": "ffmpeg/3881606240953b9275a247a1c98a567f3c44890f/utvideodec.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n         slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                          slice_start;\n         slice_height >>= 1;\n+        if (!slice_height)\n+            continue;\n \n         bsrc = src + slice_start * stride;\n ",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "        if (!slice_height)",
            "            continue;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}