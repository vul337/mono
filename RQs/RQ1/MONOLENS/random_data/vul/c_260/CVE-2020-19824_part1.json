{
    "cve_id": "CVE-2020-19824",
    "cwe_ids": [
        "CWE-362"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "mpv-player/mpv",
    "commit_msg": "audio: fix use-after-free with fuzzed file\n\nreinit_audio_filters_and_output() can fully shutdown the audio chain on\nfailure. Specifically, it will deallocate mpctx->ao_chain. The value of\nthat field was cached in ao_c. The code after the call did not account\nthat the audio chain can be shutdown, and used the stale ao_c value.\n\nFixes: #6808",
    "commit_hash": "5858e3cdbd6fbae3ed80366912dd5df0af4fa126",
    "git_url": "https://github.com/mpv-player/mpv/commit/5858e3cdbd6fbae3ed80366912dd5df0af4fa126",
    "file_path": "player/audio.c",
    "func_name": "fill_audio_out_buffers",
    "func_before": "void fill_audio_out_buffers(struct MPContext *mpctx)\n{\n    struct MPOpts *opts = mpctx->opts;\n    bool was_eof = mpctx->audio_status == STATUS_EOF;\n\n    dump_audio_stats(mpctx);\n\n    if (mpctx->ao && ao_query_and_reset_events(mpctx->ao, AO_EVENT_RELOAD))\n        reload_audio_output(mpctx);\n\n    if (mpctx->ao && ao_query_and_reset_events(mpctx->ao,\n                                               AO_EVENT_INITIAL_UNBLOCK))\n        ao_unblock(mpctx->ao);\n\n    struct ao_chain *ao_c = mpctx->ao_chain;\n    if (!ao_c)\n        return;\n\n    if (ao_c->filter->failed_output_conversion) {\n        error_on_track(mpctx, ao_c->track);\n        return;\n    }\n\n    // (if AO is set due to gapless from previous file, then we can try to\n    // filter normally until the filter tells us to change the AO)\n    if (!mpctx->ao) {\n        // Probe the initial audio format.\n        mp_pin_out_request_data(ao_c->filter->f->pins[1]);\n        reinit_audio_filters_and_output(mpctx);\n        if (ao_c->filter->got_output_eof &&\n            mpctx->audio_status != STATUS_EOF)\n        {\n            mpctx->audio_status = STATUS_EOF;\n            MP_VERBOSE(mpctx, \"audio EOF without any data\\n\");\n            mp_filter_reset(ao_c->filter->f);\n            encode_lavc_stream_eof(mpctx->encode_lavc_ctx, STREAM_AUDIO);\n        }\n        return; // try again next iteration\n    }\n\n    if (ao_c->ao_resume_time > mp_time_sec()) {\n        double remaining = ao_c->ao_resume_time - mp_time_sec();\n        mp_set_timeout(mpctx, remaining);\n        return;\n    }\n\n    if (mpctx->vo_chain && ao_c->track && ao_c->track->dec &&\n        ao_c->track->dec->pts_reset)\n    {\n        MP_VERBOSE(mpctx, \"Reset playback due to audio timestamp reset.\\n\");\n        reset_playback_state(mpctx);\n        mp_wakeup_core(mpctx);\n        return;\n    }\n\n    int ao_rate;\n    int ao_format;\n    struct mp_chmap ao_channels;\n    ao_get_format(mpctx->ao, &ao_rate, &ao_format, &ao_channels);\n    double play_samplerate = ao_rate / mpctx->audio_speed;\n    int align = af_format_sample_alignment(ao_format);\n\n    // If audio is infinitely fast, somehow try keeping approximate A/V sync.\n    if (mpctx->audio_status == STATUS_PLAYING && ao_untimed(mpctx->ao) &&\n        mpctx->video_status != STATUS_EOF && mpctx->delay > 0)\n        return;\n\n    int playsize = ao_get_space(mpctx->ao);\n\n    int skip = 0;\n    bool sync_known = get_sync_samples(mpctx, &skip);\n    if (skip > 0) {\n        playsize = MPMIN(skip + 1, MPMAX(playsize, 2500)); // buffer extra data\n    } else if (skip < 0) {\n        playsize = MPMAX(1, playsize + skip); // silence will be prepended\n    }\n\n    int skip_duplicate = 0; // >0: skip, <0: duplicate\n    double drop_limit =\n        (opts->sync_max_audio_change + opts->sync_max_video_change) / 100;\n    if (mpctx->display_sync_active && opts->video_sync == VS_DISP_ADROP &&\n        fabs(mpctx->last_av_difference) >= opts->sync_audio_drop_size &&\n        mpctx->audio_drop_throttle < drop_limit &&\n        mpctx->audio_status == STATUS_PLAYING)\n    {\n        int samples = ceil(opts->sync_audio_drop_size * play_samplerate);\n        samples = (samples + align / 2) / align * align;\n\n        skip_duplicate = mpctx->last_av_difference >= 0 ? -samples : samples;\n\n        playsize = MPMAX(playsize, samples);\n\n        mpctx->audio_drop_throttle += 1 - drop_limit - samples / play_samplerate;\n    }\n\n    playsize = playsize / align * align;\n\n    int status = mpctx->audio_status >= STATUS_DRAINING ? AD_EOF : AD_OK;\n    bool working = false;\n    if (playsize > mp_audio_buffer_samples(ao_c->ao_buffer)) {\n        status = filter_audio(mpctx, ao_c->ao_buffer, playsize);\n        if (ao_c->filter->ao_needs_update) {\n            reinit_audio_filters_and_output(mpctx);\n            mp_wakeup_core(mpctx);\n            return; // retry on next iteration\n        }\n        if (status == AD_WAIT)\n            return;\n        working = true;\n    }\n\n    // If EOF was reached before, but now something can be decoded, try to\n    // restart audio properly. This helps with video files where audio starts\n    // later. Retrying is needed to get the correct sync PTS.\n    if (mpctx->audio_status >= STATUS_DRAINING &&\n        mp_audio_buffer_samples(ao_c->ao_buffer) > 0)\n    {\n        mpctx->audio_status = STATUS_SYNCING;\n        return; // retry on next iteration\n    }\n\n    bool end_sync = false;\n    if (skip >= 0) {\n        int max = mp_audio_buffer_samples(ao_c->ao_buffer);\n        mp_audio_buffer_skip(ao_c->ao_buffer, MPMIN(skip, max));\n        // If something is left, we definitely reached the target time.\n        end_sync |= sync_known && skip < max;\n        working |= skip > 0;\n    } else if (skip < 0) {\n        if (-skip > playsize) { // heuristic against making the buffer too large\n            ao_reset(mpctx->ao); // some AOs repeat data on underflow\n            mpctx->audio_status = STATUS_DRAINING;\n            mpctx->delay = 0;\n            return;\n        }\n        mp_audio_buffer_prepend_silence(ao_c->ao_buffer, -skip);\n        end_sync = true;\n    }\n\n    if (skip_duplicate) {\n        int max = mp_audio_buffer_samples(ao_c->ao_buffer);\n        if (abs(skip_duplicate) > max)\n            skip_duplicate = skip_duplicate >= 0 ? max : -max;\n        mpctx->last_av_difference += skip_duplicate / play_samplerate;\n        if (skip_duplicate >= 0) {\n            mp_audio_buffer_skip(ao_c->ao_buffer, skip_duplicate);\n            MP_STATS(mpctx, \"drop-audio\");\n        } else {\n            mp_audio_buffer_duplicate(ao_c->ao_buffer, -skip_duplicate);\n            MP_STATS(mpctx, \"duplicate-audio\");\n        }\n        MP_VERBOSE(mpctx, \"audio skip_duplicate=%d\\n\", skip_duplicate);\n    }\n\n    if (mpctx->audio_status == STATUS_SYNCING) {\n        if (end_sync)\n            mpctx->audio_status = STATUS_FILLING;\n        if (status != AD_OK && !mp_audio_buffer_samples(ao_c->ao_buffer))\n            mpctx->audio_status = STATUS_EOF;\n        if (working || end_sync)\n            mp_wakeup_core(mpctx);\n        return; // continue on next iteration\n    }\n\n    assert(mpctx->audio_status >= STATUS_FILLING);\n\n    // We already have as much data as the audio device wants, and can start\n    // writing it any time.\n    if (mpctx->audio_status == STATUS_FILLING)\n        mpctx->audio_status = STATUS_READY;\n\n    // Even if we're done decoding and syncing, let video start first - this is\n    // required, because sending audio to the AO already starts playback.\n    if (mpctx->audio_status == STATUS_READY) {\n        // Warning: relies on handle_playback_restart() being called afterwards.\n        return;\n    }\n\n    bool audio_eof = status == AD_EOF;\n    bool partial_fill = false;\n    int playflags = 0;\n\n    if (playsize > mp_audio_buffer_samples(ao_c->ao_buffer)) {\n        playsize = mp_audio_buffer_samples(ao_c->ao_buffer);\n        partial_fill = true;\n    }\n\n    audio_eof &= partial_fill;\n\n    // With gapless audio, delay this to ao_uninit. There must be only\n    // 1 final chunk, and that is handled when calling ao_uninit().\n    if (audio_eof && !opts->gapless_audio)\n        playflags |= AOPLAY_FINAL_CHUNK;\n\n    uint8_t **planes;\n    int samples;\n    mp_audio_buffer_peek(ao_c->ao_buffer, &planes, &samples);\n    if (audio_eof || samples >= align)\n        samples = samples / align * align;\n    samples = MPMIN(samples, mpctx->paused ? 0 : playsize);\n    int played = write_to_ao(mpctx, planes, samples, playflags);\n    assert(played >= 0 && played <= samples);\n    mp_audio_buffer_skip(ao_c->ao_buffer, played);\n\n    mpctx->audio_drop_throttle =\n        MPMAX(0, mpctx->audio_drop_throttle - played / play_samplerate);\n\n    dump_audio_stats(mpctx);\n\n    mpctx->audio_status = STATUS_PLAYING;\n    if (audio_eof && !playsize) {\n        mpctx->audio_status = STATUS_DRAINING;\n        // Wait until the AO has played all queued data. In the gapless case,\n        // we trigger EOF immediately, and let it play asynchronously.\n        if (ao_eof_reached(mpctx->ao) || opts->gapless_audio) {\n            mpctx->audio_status = STATUS_EOF;\n            if (!was_eof) {\n                MP_VERBOSE(mpctx, \"audio EOF reached\\n\");\n                mp_wakeup_core(mpctx);\n                encode_lavc_stream_eof(mpctx->encode_lavc_ctx, STREAM_AUDIO);\n            }\n        }\n    }\n}",
    "abstract_func_before": "void fill_audio_out_buffers(struct MPContext *VAR_0)\n{\n    struct MPOpts *VAR_1 = VAR_0->opts;\n    bool VAR_2 = VAR_0->audio_status == VAR_3;\n\n    dump_audio_stats(VAR_0);\n\n    if (VAR_0->ao && ao_query_and_reset_events(VAR_0->ao, VAR_4))\n        reload_audio_output(VAR_0);\n\n    if (VAR_0->ao && ao_query_and_reset_events(VAR_0->ao,\n                                               VAR_5))\n        ao_unblock(VAR_0->ao);\n\n    struct ao_chain *VAR_6 = VAR_0->ao_chain;\n    if (!VAR_6)\n        return;\n\n    if (VAR_6->filter->failed_output_conversion) {\n        error_on_track(VAR_0, VAR_6->track);\n        return;\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    if (!VAR_0->ao) {\n        /* COMMENT_2 */\n        mp_pin_out_request_data(VAR_6->filter->f->pins[1]);\n        reinit_audio_filters_and_output(VAR_0);\n        if (VAR_6->filter->got_output_eof &&\n            VAR_0->audio_status != VAR_3)\n        {\n            VAR_0->audio_status = VAR_3;\n            MP_VERBOSE(VAR_0, \"audio EOF without any data\\n\");\n            mp_filter_reset(VAR_6->filter->f);\n            encode_lavc_stream_eof(VAR_0->encode_lavc_ctx, VAR_7);\n        }\n        return; /* COMMENT_3 */\n    }\n\n    if (VAR_6->ao_resume_time > mp_time_sec()) {\n        double VAR_8 = VAR_6->ao_resume_time - mp_time_sec();\n        mp_set_timeout(VAR_0, VAR_8);\n        return;\n    }\n\n    if (VAR_0->vo_chain && VAR_6->track && VAR_6->track->dec &&\n        VAR_6->track->dec->pts_reset)\n    {\n        MP_VERBOSE(VAR_0, \"Reset playback due to audio timestamp reset.\\n\");\n        reset_playback_state(VAR_0);\n        mp_wakeup_core(VAR_0);\n        return;\n    }\n\n    int VAR_9;\n    int VAR_10;\n    struct mp_chmap VAR_11;\n    ao_get_format(VAR_0->ao, &VAR_9, &VAR_10, &VAR_11);\n    double VAR_12 = VAR_9 / VAR_0->audio_speed;\n    int VAR_13 = af_format_sample_alignment(VAR_10);\n\n    /* COMMENT_4 */\n    if (VAR_0->audio_status == VAR_14 && ao_untimed(VAR_0->ao) &&\n        VAR_0->video_status != VAR_3 && VAR_0->delay > 0)\n        return;\n\n    int VAR_15 = ao_get_space(VAR_0->ao);\n\n    int VAR_16 = 0;\n    bool VAR_17 = get_sync_samples(VAR_0, &VAR_16);\n    if (VAR_16 > 0) {\n        VAR_15 = MPMIN(VAR_16 + 1, MPMAX(VAR_15, 2500)); /* COMMENT_5 */\n    } else if (VAR_16 < 0) {\n        VAR_15 = MPMAX(1, VAR_15 + VAR_16); /* COMMENT_6 */\n    }\n\n    int VAR_18 = 0; /* COMMENT_7 */\n    double VAR_19 =\n        (VAR_1->sync_max_audio_change + VAR_1->sync_max_video_change) / 100;\n    if (VAR_0->display_sync_active && VAR_1->video_sync == VAR_20 &&\n        fabs(VAR_0->last_av_difference) >= VAR_1->sync_audio_drop_size &&\n        VAR_0->audio_drop_throttle < VAR_19 &&\n        VAR_0->audio_status == VAR_14)\n    {\n        int VAR_21 = ceil(VAR_1->sync_audio_drop_size * VAR_12);\n        VAR_21 = (VAR_21 + VAR_13 / 2) / VAR_13 * VAR_13;\n\n        VAR_18 = VAR_0->last_av_difference >= 0 ? -VAR_21 : VAR_21;\n\n        VAR_15 = MPMAX(VAR_15, VAR_21);\n\n        VAR_0->audio_drop_throttle += 1 - VAR_19 - VAR_21 / VAR_12;\n    }\n\n    VAR_15 = VAR_15 / VAR_13 * VAR_13;\n\n    int VAR_22 = VAR_0->audio_status >= VAR_23 ? VAR_24 : VAR_25;\n    bool VAR_26 = false;\n    if (VAR_15 > mp_audio_buffer_samples(VAR_6->ao_buffer)) {\n        VAR_22 = filter_audio(VAR_0, VAR_6->ao_buffer, VAR_15);\n        if (VAR_6->filter->ao_needs_update) {\n            reinit_audio_filters_and_output(VAR_0);\n            mp_wakeup_core(VAR_0);\n            return; /* COMMENT_8 */\n        }\n        if (VAR_22 == VAR_27)\n            return;\n        VAR_26 = true;\n    }\n\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    if (VAR_0->audio_status >= VAR_23 &&\n        mp_audio_buffer_samples(VAR_6->ao_buffer) > 0)\n    {\n        VAR_0->audio_status = VAR_28;\n        return; /* COMMENT_8 */\n    }\n\n    bool VAR_29 = false;\n    if (VAR_16 >= 0) {\n        int VAR_30 = mp_audio_buffer_samples(VAR_6->ao_buffer);\n        mp_audio_buffer_skip(VAR_6->ao_buffer, MPMIN(VAR_16, VAR_30));\n        /* COMMENT_12 */\n        VAR_29 |= VAR_17 && VAR_16 < VAR_30;\n        VAR_26 |= VAR_16 > 0;\n    } else if (VAR_16 < 0) {\n        if (-VAR_16 > VAR_15) { /* COMMENT_13 */\n            ao_reset(VAR_0->ao); /* COMMENT_14 */\n            VAR_0->audio_status = VAR_23;\n            VAR_0->delay = 0;\n            return;\n        }\n        mp_audio_buffer_prepend_silence(VAR_6->ao_buffer, -VAR_16);\n        VAR_29 = true;\n    }\n\n    if (VAR_18) {\n        int VAR_30 = mp_audio_buffer_samples(VAR_6->ao_buffer);\n        if (abs(VAR_18) > VAR_30)\n            VAR_18 = VAR_18 >= 0 ? VAR_30 : -VAR_30;\n        VAR_0->last_av_difference += VAR_18 / VAR_12;\n        if (VAR_18 >= 0) {\n            mp_audio_buffer_skip(VAR_6->ao_buffer, VAR_18);\n            MP_STATS(VAR_0, \"drop-audio\");\n        } else {\n            mp_audio_buffer_duplicate(VAR_6->ao_buffer, -VAR_18);\n            MP_STATS(VAR_0, \"duplicate-audio\");\n        }\n        MP_VERBOSE(VAR_0, \"audio skip_duplicate=%d\\n\", VAR_18);\n    }\n\n    if (VAR_0->audio_status == VAR_28) {\n        if (VAR_29)\n            VAR_0->audio_status = VAR_31;\n        if (VAR_22 != VAR_25 && !mp_audio_buffer_samples(VAR_6->ao_buffer))\n            VAR_0->audio_status = VAR_3;\n        if (VAR_26 || VAR_29)\n            mp_wakeup_core(VAR_0);\n        return; /* COMMENT_15 */\n    }\n\n    assert(VAR_0->audio_status >= VAR_31);\n\n    /* COMMENT_16 */\n    /* COMMENT_17 */\n    if (VAR_0->audio_status == VAR_31)\n        VAR_0->audio_status = VAR_32;\n\n    /* COMMENT_18 */\n    /* COMMENT_19 */\n    if (VAR_0->audio_status == VAR_32) {\n        /* COMMENT_20 */\n        return;\n    }\n\n    bool VAR_33 = VAR_22 == VAR_24;\n    bool VAR_34 = false;\n    int VAR_35 = 0;\n\n    if (VAR_15 > mp_audio_buffer_samples(VAR_6->ao_buffer)) {\n        VAR_15 = mp_audio_buffer_samples(VAR_6->ao_buffer);\n        VAR_34 = true;\n    }\n\n    VAR_33 &= VAR_34;\n\n    /* COMMENT_21 */\n    /* COMMENT_22 */\n    if (VAR_33 && !VAR_1->gapless_audio)\n        VAR_35 |= VAR_36;\n\n    uint8_t **VAR_37;\n    int VAR_21;\n    mp_audio_buffer_peek(VAR_6->ao_buffer, &VAR_37, &VAR_21);\n    if (VAR_33 || VAR_21 >= VAR_13)\n        VAR_21 = VAR_21 / VAR_13 * VAR_13;\n    VAR_21 = MPMIN(VAR_21, VAR_0->paused ? 0 : VAR_15);\n    int VAR_38 = write_to_ao(VAR_0, VAR_37, VAR_21, VAR_35);\n    assert(VAR_38 >= 0 && VAR_38 <= VAR_21);\n    mp_audio_buffer_skip(VAR_6->ao_buffer, VAR_38);\n\n    VAR_0->audio_drop_throttle =\n        MPMAX(0, VAR_0->audio_drop_throttle - VAR_38 / VAR_12);\n\n    dump_audio_stats(VAR_0);\n\n    VAR_0->audio_status = VAR_14;\n    if (VAR_33 && !VAR_15) {\n        VAR_0->audio_status = VAR_23;\n        /* COMMENT_23 */\n        /* COMMENT_24 */\n        if (ao_eof_reached(VAR_0->ao) || VAR_1->gapless_audio) {\n            VAR_0->audio_status = VAR_3;\n            if (!VAR_2) {\n                MP_VERBOSE(VAR_0, \"audio EOF reached\\n\");\n                mp_wakeup_core(VAR_0);\n                encode_lavc_stream_eof(VAR_0->encode_lavc_ctx, VAR_7);\n            }\n        }\n    }\n}",
    "func_graph_path_before": "mpv-player/mpv/5858e3cdbd6fbae3ed80366912dd5df0af4fa126/audio.c/vul/before/0.json",
    "func": "void fill_audio_out_buffers(struct MPContext *mpctx)\n{\n    struct MPOpts *opts = mpctx->opts;\n    bool was_eof = mpctx->audio_status == STATUS_EOF;\n\n    dump_audio_stats(mpctx);\n\n    if (mpctx->ao && ao_query_and_reset_events(mpctx->ao, AO_EVENT_RELOAD))\n        reload_audio_output(mpctx);\n\n    if (mpctx->ao && ao_query_and_reset_events(mpctx->ao,\n                                               AO_EVENT_INITIAL_UNBLOCK))\n        ao_unblock(mpctx->ao);\n\n    struct ao_chain *ao_c = mpctx->ao_chain;\n    if (!ao_c)\n        return;\n\n    if (ao_c->filter->failed_output_conversion) {\n        error_on_track(mpctx, ao_c->track);\n        return;\n    }\n\n    // (if AO is set due to gapless from previous file, then we can try to\n    // filter normally until the filter tells us to change the AO)\n    if (!mpctx->ao) {\n        // Probe the initial audio format.\n        mp_pin_out_request_data(ao_c->filter->f->pins[1]);\n        reinit_audio_filters_and_output(mpctx);\n        if (!mpctx->ao_chain)\n            return;\n        if (ao_c->filter->got_output_eof &&\n            mpctx->audio_status != STATUS_EOF)\n        {\n            mpctx->audio_status = STATUS_EOF;\n            MP_VERBOSE(mpctx, \"audio EOF without any data\\n\");\n            mp_filter_reset(ao_c->filter->f);\n            encode_lavc_stream_eof(mpctx->encode_lavc_ctx, STREAM_AUDIO);\n        }\n        return; // try again next iteration\n    }\n\n    if (ao_c->ao_resume_time > mp_time_sec()) {\n        double remaining = ao_c->ao_resume_time - mp_time_sec();\n        mp_set_timeout(mpctx, remaining);\n        return;\n    }\n\n    if (mpctx->vo_chain && ao_c->track && ao_c->track->dec &&\n        ao_c->track->dec->pts_reset)\n    {\n        MP_VERBOSE(mpctx, \"Reset playback due to audio timestamp reset.\\n\");\n        reset_playback_state(mpctx);\n        mp_wakeup_core(mpctx);\n        return;\n    }\n\n    int ao_rate;\n    int ao_format;\n    struct mp_chmap ao_channels;\n    ao_get_format(mpctx->ao, &ao_rate, &ao_format, &ao_channels);\n    double play_samplerate = ao_rate / mpctx->audio_speed;\n    int align = af_format_sample_alignment(ao_format);\n\n    // If audio is infinitely fast, somehow try keeping approximate A/V sync.\n    if (mpctx->audio_status == STATUS_PLAYING && ao_untimed(mpctx->ao) &&\n        mpctx->video_status != STATUS_EOF && mpctx->delay > 0)\n        return;\n\n    int playsize = ao_get_space(mpctx->ao);\n\n    int skip = 0;\n    bool sync_known = get_sync_samples(mpctx, &skip);\n    if (skip > 0) {\n        playsize = MPMIN(skip + 1, MPMAX(playsize, 2500)); // buffer extra data\n    } else if (skip < 0) {\n        playsize = MPMAX(1, playsize + skip); // silence will be prepended\n    }\n\n    int skip_duplicate = 0; // >0: skip, <0: duplicate\n    double drop_limit =\n        (opts->sync_max_audio_change + opts->sync_max_video_change) / 100;\n    if (mpctx->display_sync_active && opts->video_sync == VS_DISP_ADROP &&\n        fabs(mpctx->last_av_difference) >= opts->sync_audio_drop_size &&\n        mpctx->audio_drop_throttle < drop_limit &&\n        mpctx->audio_status == STATUS_PLAYING)\n    {\n        int samples = ceil(opts->sync_audio_drop_size * play_samplerate);\n        samples = (samples + align / 2) / align * align;\n\n        skip_duplicate = mpctx->last_av_difference >= 0 ? -samples : samples;\n\n        playsize = MPMAX(playsize, samples);\n\n        mpctx->audio_drop_throttle += 1 - drop_limit - samples / play_samplerate;\n    }\n\n    playsize = playsize / align * align;\n\n    int status = mpctx->audio_status >= STATUS_DRAINING ? AD_EOF : AD_OK;\n    bool working = false;\n    if (playsize > mp_audio_buffer_samples(ao_c->ao_buffer)) {\n        status = filter_audio(mpctx, ao_c->ao_buffer, playsize);\n        if (ao_c->filter->ao_needs_update) {\n            reinit_audio_filters_and_output(mpctx);\n            mp_wakeup_core(mpctx);\n            return; // retry on next iteration\n        }\n        if (status == AD_WAIT)\n            return;\n        working = true;\n    }\n\n    // If EOF was reached before, but now something can be decoded, try to\n    // restart audio properly. This helps with video files where audio starts\n    // later. Retrying is needed to get the correct sync PTS.\n    if (mpctx->audio_status >= STATUS_DRAINING &&\n        mp_audio_buffer_samples(ao_c->ao_buffer) > 0)\n    {\n        mpctx->audio_status = STATUS_SYNCING;\n        return; // retry on next iteration\n    }\n\n    bool end_sync = false;\n    if (skip >= 0) {\n        int max = mp_audio_buffer_samples(ao_c->ao_buffer);\n        mp_audio_buffer_skip(ao_c->ao_buffer, MPMIN(skip, max));\n        // If something is left, we definitely reached the target time.\n        end_sync |= sync_known && skip < max;\n        working |= skip > 0;\n    } else if (skip < 0) {\n        if (-skip > playsize) { // heuristic against making the buffer too large\n            ao_reset(mpctx->ao); // some AOs repeat data on underflow\n            mpctx->audio_status = STATUS_DRAINING;\n            mpctx->delay = 0;\n            return;\n        }\n        mp_audio_buffer_prepend_silence(ao_c->ao_buffer, -skip);\n        end_sync = true;\n    }\n\n    if (skip_duplicate) {\n        int max = mp_audio_buffer_samples(ao_c->ao_buffer);\n        if (abs(skip_duplicate) > max)\n            skip_duplicate = skip_duplicate >= 0 ? max : -max;\n        mpctx->last_av_difference += skip_duplicate / play_samplerate;\n        if (skip_duplicate >= 0) {\n            mp_audio_buffer_skip(ao_c->ao_buffer, skip_duplicate);\n            MP_STATS(mpctx, \"drop-audio\");\n        } else {\n            mp_audio_buffer_duplicate(ao_c->ao_buffer, -skip_duplicate);\n            MP_STATS(mpctx, \"duplicate-audio\");\n        }\n        MP_VERBOSE(mpctx, \"audio skip_duplicate=%d\\n\", skip_duplicate);\n    }\n\n    if (mpctx->audio_status == STATUS_SYNCING) {\n        if (end_sync)\n            mpctx->audio_status = STATUS_FILLING;\n        if (status != AD_OK && !mp_audio_buffer_samples(ao_c->ao_buffer))\n            mpctx->audio_status = STATUS_EOF;\n        if (working || end_sync)\n            mp_wakeup_core(mpctx);\n        return; // continue on next iteration\n    }\n\n    assert(mpctx->audio_status >= STATUS_FILLING);\n\n    // We already have as much data as the audio device wants, and can start\n    // writing it any time.\n    if (mpctx->audio_status == STATUS_FILLING)\n        mpctx->audio_status = STATUS_READY;\n\n    // Even if we're done decoding and syncing, let video start first - this is\n    // required, because sending audio to the AO already starts playback.\n    if (mpctx->audio_status == STATUS_READY) {\n        // Warning: relies on handle_playback_restart() being called afterwards.\n        return;\n    }\n\n    bool audio_eof = status == AD_EOF;\n    bool partial_fill = false;\n    int playflags = 0;\n\n    if (playsize > mp_audio_buffer_samples(ao_c->ao_buffer)) {\n        playsize = mp_audio_buffer_samples(ao_c->ao_buffer);\n        partial_fill = true;\n    }\n\n    audio_eof &= partial_fill;\n\n    // With gapless audio, delay this to ao_uninit. There must be only\n    // 1 final chunk, and that is handled when calling ao_uninit().\n    if (audio_eof && !opts->gapless_audio)\n        playflags |= AOPLAY_FINAL_CHUNK;\n\n    uint8_t **planes;\n    int samples;\n    mp_audio_buffer_peek(ao_c->ao_buffer, &planes, &samples);\n    if (audio_eof || samples >= align)\n        samples = samples / align * align;\n    samples = MPMIN(samples, mpctx->paused ? 0 : playsize);\n    int played = write_to_ao(mpctx, planes, samples, playflags);\n    assert(played >= 0 && played <= samples);\n    mp_audio_buffer_skip(ao_c->ao_buffer, played);\n\n    mpctx->audio_drop_throttle =\n        MPMAX(0, mpctx->audio_drop_throttle - played / play_samplerate);\n\n    dump_audio_stats(mpctx);\n\n    mpctx->audio_status = STATUS_PLAYING;\n    if (audio_eof && !playsize) {\n        mpctx->audio_status = STATUS_DRAINING;\n        // Wait until the AO has played all queued data. In the gapless case,\n        // we trigger EOF immediately, and let it play asynchronously.\n        if (ao_eof_reached(mpctx->ao) || opts->gapless_audio) {\n            mpctx->audio_status = STATUS_EOF;\n            if (!was_eof) {\n                MP_VERBOSE(mpctx, \"audio EOF reached\\n\");\n                mp_wakeup_core(mpctx);\n                encode_lavc_stream_eof(mpctx->encode_lavc_ctx, STREAM_AUDIO);\n            }\n        }\n    }\n}",
    "abstract_func": "void fill_audio_out_buffers(struct MPContext *VAR_0)\n{\n    struct MPOpts *VAR_1 = VAR_0->opts;\n    bool VAR_2 = VAR_0->audio_status == VAR_3;\n\n    dump_audio_stats(VAR_0);\n\n    if (VAR_0->ao && ao_query_and_reset_events(VAR_0->ao, VAR_4))\n        reload_audio_output(VAR_0);\n\n    if (VAR_0->ao && ao_query_and_reset_events(VAR_0->ao,\n                                               VAR_5))\n        ao_unblock(VAR_0->ao);\n\n    struct ao_chain *VAR_6 = VAR_0->ao_chain;\n    if (!VAR_6)\n        return;\n\n    if (VAR_6->filter->failed_output_conversion) {\n        error_on_track(VAR_0, VAR_6->track);\n        return;\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    if (!VAR_0->ao) {\n        /* COMMENT_2 */\n        mp_pin_out_request_data(VAR_6->filter->f->pins[1]);\n        reinit_audio_filters_and_output(VAR_0);\n        if (!VAR_0->ao_chain)\n            return;\n        if (VAR_6->filter->got_output_eof &&\n            VAR_0->audio_status != VAR_3)\n        {\n            VAR_0->audio_status = VAR_3;\n            MP_VERBOSE(VAR_0, \"audio EOF without any data\\n\");\n            mp_filter_reset(VAR_6->filter->f);\n            encode_lavc_stream_eof(VAR_0->encode_lavc_ctx, VAR_7);\n        }\n        return; /* COMMENT_3 */\n    }\n\n    if (VAR_6->ao_resume_time > mp_time_sec()) {\n        double VAR_8 = VAR_6->ao_resume_time - mp_time_sec();\n        mp_set_timeout(VAR_0, VAR_8);\n        return;\n    }\n\n    if (VAR_0->vo_chain && VAR_6->track && VAR_6->track->dec &&\n        VAR_6->track->dec->pts_reset)\n    {\n        MP_VERBOSE(VAR_0, \"Reset playback due to audio timestamp reset.\\n\");\n        reset_playback_state(VAR_0);\n        mp_wakeup_core(VAR_0);\n        return;\n    }\n\n    int VAR_9;\n    int VAR_10;\n    struct mp_chmap VAR_11;\n    ao_get_format(VAR_0->ao, &VAR_9, &VAR_10, &VAR_11);\n    double VAR_12 = VAR_9 / VAR_0->audio_speed;\n    int VAR_13 = af_format_sample_alignment(VAR_10);\n\n    /* COMMENT_4 */\n    if (VAR_0->audio_status == VAR_14 && ao_untimed(VAR_0->ao) &&\n        VAR_0->video_status != VAR_3 && VAR_0->delay > 0)\n        return;\n\n    int VAR_15 = ao_get_space(VAR_0->ao);\n\n    int VAR_16 = 0;\n    bool VAR_17 = get_sync_samples(VAR_0, &VAR_16);\n    if (VAR_16 > 0) {\n        VAR_15 = MPMIN(VAR_16 + 1, MPMAX(VAR_15, 2500)); /* COMMENT_5 */\n    } else if (VAR_16 < 0) {\n        VAR_15 = MPMAX(1, VAR_15 + VAR_16); /* COMMENT_6 */\n    }\n\n    int VAR_18 = 0; /* COMMENT_7 */\n    double VAR_19 =\n        (VAR_1->sync_max_audio_change + VAR_1->sync_max_video_change) / 100;\n    if (VAR_0->display_sync_active && VAR_1->video_sync == VAR_20 &&\n        fabs(VAR_0->last_av_difference) >= VAR_1->sync_audio_drop_size &&\n        VAR_0->audio_drop_throttle < VAR_19 &&\n        VAR_0->audio_status == VAR_14)\n    {\n        int VAR_21 = ceil(VAR_1->sync_audio_drop_size * VAR_12);\n        VAR_21 = (VAR_21 + VAR_13 / 2) / VAR_13 * VAR_13;\n\n        VAR_18 = VAR_0->last_av_difference >= 0 ? -VAR_21 : VAR_21;\n\n        VAR_15 = MPMAX(VAR_15, VAR_21);\n\n        VAR_0->audio_drop_throttle += 1 - VAR_19 - VAR_21 / VAR_12;\n    }\n\n    VAR_15 = VAR_15 / VAR_13 * VAR_13;\n\n    int VAR_22 = VAR_0->audio_status >= VAR_23 ? VAR_24 : VAR_25;\n    bool VAR_26 = false;\n    if (VAR_15 > mp_audio_buffer_samples(VAR_6->ao_buffer)) {\n        VAR_22 = filter_audio(VAR_0, VAR_6->ao_buffer, VAR_15);\n        if (VAR_6->filter->ao_needs_update) {\n            reinit_audio_filters_and_output(VAR_0);\n            mp_wakeup_core(VAR_0);\n            return; /* COMMENT_8 */\n        }\n        if (VAR_22 == VAR_27)\n            return;\n        VAR_26 = true;\n    }\n\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    if (VAR_0->audio_status >= VAR_23 &&\n        mp_audio_buffer_samples(VAR_6->ao_buffer) > 0)\n    {\n        VAR_0->audio_status = VAR_28;\n        return; /* COMMENT_8 */\n    }\n\n    bool VAR_29 = false;\n    if (VAR_16 >= 0) {\n        int VAR_30 = mp_audio_buffer_samples(VAR_6->ao_buffer);\n        mp_audio_buffer_skip(VAR_6->ao_buffer, MPMIN(VAR_16, VAR_30));\n        /* COMMENT_12 */\n        VAR_29 |= VAR_17 && VAR_16 < VAR_30;\n        VAR_26 |= VAR_16 > 0;\n    } else if (VAR_16 < 0) {\n        if (-VAR_16 > VAR_15) { /* COMMENT_13 */\n            ao_reset(VAR_0->ao); /* COMMENT_14 */\n            VAR_0->audio_status = VAR_23;\n            VAR_0->delay = 0;\n            return;\n        }\n        mp_audio_buffer_prepend_silence(VAR_6->ao_buffer, -VAR_16);\n        VAR_29 = true;\n    }\n\n    if (VAR_18) {\n        int VAR_30 = mp_audio_buffer_samples(VAR_6->ao_buffer);\n        if (abs(VAR_18) > VAR_30)\n            VAR_18 = VAR_18 >= 0 ? VAR_30 : -VAR_30;\n        VAR_0->last_av_difference += VAR_18 / VAR_12;\n        if (VAR_18 >= 0) {\n            mp_audio_buffer_skip(VAR_6->ao_buffer, VAR_18);\n            MP_STATS(VAR_0, \"drop-audio\");\n        } else {\n            mp_audio_buffer_duplicate(VAR_6->ao_buffer, -VAR_18);\n            MP_STATS(VAR_0, \"duplicate-audio\");\n        }\n        MP_VERBOSE(VAR_0, \"audio skip_duplicate=%d\\n\", VAR_18);\n    }\n\n    if (VAR_0->audio_status == VAR_28) {\n        if (VAR_29)\n            VAR_0->audio_status = VAR_31;\n        if (VAR_22 != VAR_25 && !mp_audio_buffer_samples(VAR_6->ao_buffer))\n            VAR_0->audio_status = VAR_3;\n        if (VAR_26 || VAR_29)\n            mp_wakeup_core(VAR_0);\n        return; /* COMMENT_15 */\n    }\n\n    assert(VAR_0->audio_status >= VAR_31);\n\n    /* COMMENT_16 */\n    /* COMMENT_17 */\n    if (VAR_0->audio_status == VAR_31)\n        VAR_0->audio_status = VAR_32;\n\n    /* COMMENT_18 */\n    /* COMMENT_19 */\n    if (VAR_0->audio_status == VAR_32) {\n        /* COMMENT_20 */\n        return;\n    }\n\n    bool VAR_33 = VAR_22 == VAR_24;\n    bool VAR_34 = false;\n    int VAR_35 = 0;\n\n    if (VAR_15 > mp_audio_buffer_samples(VAR_6->ao_buffer)) {\n        VAR_15 = mp_audio_buffer_samples(VAR_6->ao_buffer);\n        VAR_34 = true;\n    }\n\n    VAR_33 &= VAR_34;\n\n    /* COMMENT_21 */\n    /* COMMENT_22 */\n    if (VAR_33 && !VAR_1->gapless_audio)\n        VAR_35 |= VAR_36;\n\n    uint8_t **VAR_37;\n    int VAR_21;\n    mp_audio_buffer_peek(VAR_6->ao_buffer, &VAR_37, &VAR_21);\n    if (VAR_33 || VAR_21 >= VAR_13)\n        VAR_21 = VAR_21 / VAR_13 * VAR_13;\n    VAR_21 = MPMIN(VAR_21, VAR_0->paused ? 0 : VAR_15);\n    int VAR_38 = write_to_ao(VAR_0, VAR_37, VAR_21, VAR_35);\n    assert(VAR_38 >= 0 && VAR_38 <= VAR_21);\n    mp_audio_buffer_skip(VAR_6->ao_buffer, VAR_38);\n\n    VAR_0->audio_drop_throttle =\n        MPMAX(0, VAR_0->audio_drop_throttle - VAR_38 / VAR_12);\n\n    dump_audio_stats(VAR_0);\n\n    VAR_0->audio_status = VAR_14;\n    if (VAR_33 && !VAR_15) {\n        VAR_0->audio_status = VAR_23;\n        /* COMMENT_23 */\n        /* COMMENT_24 */\n        if (ao_eof_reached(VAR_0->ao) || VAR_1->gapless_audio) {\n            VAR_0->audio_status = VAR_3;\n            if (!VAR_2) {\n                MP_VERBOSE(VAR_0, \"audio EOF reached\\n\");\n                mp_wakeup_core(VAR_0);\n                encode_lavc_stream_eof(VAR_0->encode_lavc_ctx, VAR_7);\n            }\n        }\n    }\n}",
    "func_graph_path": "mpv-player/mpv/5858e3cdbd6fbae3ed80366912dd5df0af4fa126/audio.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,8 @@\n         // Probe the initial audio format.\n         mp_pin_out_request_data(ao_c->filter->f->pins[1]);\n         reinit_audio_filters_and_output(mpctx);\n+        if (!mpctx->ao_chain)\n+            return;\n         if (ao_c->filter->got_output_eof &&\n             mpctx->audio_status != STATUS_EOF)\n         {",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "        if (!mpctx->ao_chain)",
            "            return;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}