{
    "cve_id": "CVE-2013-3232",
    "cwe_ids": [
        "CWE-200"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "netrom: fix info leak via msg_name in nr_recvmsg()\n\nIn case msg_name is set the sockaddr info gets filled out, as\nrequested, but the code fails to initialize the padding bytes of\nstruct sockaddr_ax25 inserted by the compiler for alignment. Also\nthe sax25_ndigis member does not get assigned, leaking four more\nbytes.\n\nBoth issues lead to the fact that the code will leak uninitialized\nkernel stack bytes in net/socket.c.\n\nFix both issues by initializing the memory with memset(0).\n\nCc: Ralf Baechle <ralf@linux-mips.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "commit_hash": "3ce5efad47b62c57a4f5c54248347085a750ce0e",
    "git_url": "https://github.com/torvalds/linux/commit/3ce5efad47b62c57a4f5c54248347085a750ce0e",
    "file_path": "net/netrom/af_netrom.c",
    "func_name": "nr_recvmsg",
    "func_before": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t/* Now we can treat all alike */\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\n\tmsg->msg_namelen = sizeof(*sax);\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}",
    "abstract_func_before": "static int nr_recvmsg(struct kiocb *VAR_0, struct socket *VAR_1,\n\t\t      struct msghdr *VAR_2, size_t VAR_3, int VAR_4)\n{\n\tstruct sock *VAR_5 = sock->sk;\n\tstruct sockaddr_ax25 *VAR_6 = (struct sockaddr_ax25 *)VAR_2->msg_name;\n\tsize_t VAR_7;\n\tstruct sk_buff *VAR_8;\n\tint VAR_9;\n\n\t/* COMMENT_0 */\n                                                                        \n                                          \n    \n\n\tlock_sock(VAR_5);\n\tif (VAR_5->sk_state != VAR_10) {\n\t\trelease_sock(VAR_5);\n\t\treturn -VAR_11;\n\t}\n\n\t/* COMMENT_4 */\n\tif ((VAR_8 = skb_recv_datagram(VAR_5, VAR_4 & ~VAR_12, VAR_4 & VAR_12, &VAR_9)) == NULL) {\n\t\trelease_sock(VAR_5);\n\t\treturn VAR_9;\n\t}\n\n\tskb_reset_transport_header(VAR_8);\n\tVAR_7     = VAR_8->len;\n\n\tif (VAR_7 > VAR_3) {\n\t\tVAR_7 = VAR_3;\n\t\tVAR_2->msg_flags |= VAR_13;\n\t}\n\n\tVAR_9 = skb_copy_datagram_iovec(VAR_8, 0, VAR_2->msg_iov, VAR_7);\n\tif (VAR_9 < 0) {\n\t\tskb_free_datagram(VAR_5, VAR_8);\n\t\trelease_sock(VAR_5);\n\t\treturn VAR_9;\n\t}\n\n\tif (VAR_6 != NULL) {\n\t\tVAR_6->sax25_family = VAR_14;\n\t\tskb_copy_from_linear_data_offset(VAR_8, 7, VAR_6->sax25_call.ax25_call,\n\t\t\t      VAR_15);\n\t}\n\n\tVAR_2->msg_namelen = sizeof(*VAR_6);\n\n\tskb_free_datagram(VAR_5, VAR_8);\n\n\trelease_sock(VAR_5);\n\treturn VAR_7;\n}",
    "func_graph_path_before": "torvalds/linux/3ce5efad47b62c57a4f5c54248347085a750ce0e/af_netrom.c/vul/before/0.json",
    "func": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t/* Now we can treat all alike */\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\n\tmsg->msg_namelen = sizeof(*sax);\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}",
    "abstract_func": "static int nr_recvmsg(struct kiocb *VAR_0, struct socket *VAR_1,\n\t\t      struct msghdr *VAR_2, size_t VAR_3, int VAR_4)\n{\n\tstruct sock *VAR_5 = sock->sk;\n\tstruct sockaddr_ax25 *VAR_6 = (struct sockaddr_ax25 *)VAR_2->msg_name;\n\tsize_t VAR_7;\n\tstruct sk_buff *VAR_8;\n\tint VAR_9;\n\n\t/* COMMENT_0 */\n                                                                        \n                                          \n    \n\n\tlock_sock(VAR_5);\n\tif (VAR_5->sk_state != VAR_10) {\n\t\trelease_sock(VAR_5);\n\t\treturn -VAR_11;\n\t}\n\n\t/* COMMENT_4 */\n\tif ((VAR_8 = skb_recv_datagram(VAR_5, VAR_4 & ~VAR_12, VAR_4 & VAR_12, &VAR_9)) == NULL) {\n\t\trelease_sock(VAR_5);\n\t\treturn VAR_9;\n\t}\n\n\tskb_reset_transport_header(VAR_8);\n\tVAR_7     = VAR_8->len;\n\n\tif (VAR_7 > VAR_3) {\n\t\tVAR_7 = VAR_3;\n\t\tVAR_2->msg_flags |= VAR_13;\n\t}\n\n\tVAR_9 = skb_copy_datagram_iovec(VAR_8, 0, VAR_2->msg_iov, VAR_7);\n\tif (VAR_9 < 0) {\n\t\tskb_free_datagram(VAR_5, VAR_8);\n\t\trelease_sock(VAR_5);\n\t\treturn VAR_9;\n\t}\n\n\tif (VAR_6 != NULL) {\n\t\tmemset(VAR_6, 0, sizeof(VAR_6));\n\t\tVAR_6->sax25_family = VAR_14;\n\t\tskb_copy_from_linear_data_offset(VAR_8, 7, VAR_6->sax25_call.ax25_call,\n\t\t\t      VAR_15);\n\t}\n\n\tVAR_2->msg_namelen = sizeof(*VAR_6);\n\n\tskb_free_datagram(VAR_5, VAR_8);\n\n\trelease_sock(VAR_5);\n\treturn VAR_7;\n}",
    "func_graph_path": "torvalds/linux/3ce5efad47b62c57a4f5c54248347085a750ce0e/af_netrom.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,7 @@\n \t}\n \n \tif (sax != NULL) {\n+\t\tmemset(sax, 0, sizeof(sax));\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\tmemset(sax, 0, sizeof(sax));"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}