{
    "cve_id": "CVE-2018-12891",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "xen-project/xen",
    "commit_msg": "x86/mm: don't bypass preemption checks\n\nWhile unlikely, it is not impossible for a multi-vCPU guest to leverage\nbypasses of preemption checks to drive Xen into an unbounded loop.\n\nThis is XSA-264.\n\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",
    "commit_hash": "17608703c65bf080b0a9f024f9b370872b9f2c05",
    "git_url": "https://github.com/xen-project/xen/commit/17608703c65bf080b0a9f024f9b370872b9f2c05",
    "file_path": "xen/arch/x86/mm.c",
    "func_name": "_put_page_type",
    "func_before": "static int _put_page_type(struct page_info *page, bool preemptible,\n                          struct page_info *ptpg)\n{\n    unsigned long nx, x, y = page->u.inuse.type_info;\n\n    ASSERT(current_locked_page_ne_check(page));\n\n    for ( ; ; )\n    {\n        x  = y;\n        nx = x - 1;\n\n        ASSERT((x & PGT_count_mask) != 0);\n\n        switch ( nx & (PGT_locked | PGT_count_mask) )\n        {\n        case 0:\n            if ( unlikely((nx & PGT_type_mask) <= PGT_l4_page_table) &&\n                 likely(nx & (PGT_validated|PGT_partial)) )\n            {\n                int rc;\n\n                /*\n                 * Page-table pages must be unvalidated when count is zero. The\n                 * 'free' is safe because the refcnt is non-zero and validated\n                 * bit is clear => other ops will spin or fail.\n                 */\n                nx = x & ~(PGT_validated|PGT_partial);\n                if ( unlikely((y = cmpxchg(&page->u.inuse.type_info,\n                                           x, nx)) != x) )\n                    continue;\n                /* We cleared the 'valid bit' so we do the clean up. */\n                rc = _put_final_page_type(page, x, preemptible, ptpg);\n                if ( x & PGT_partial )\n                    put_page(page);\n\n                return rc;\n            }\n\n            if ( !ptpg || !PGT_type_equal(x, ptpg->u.inuse.type_info) )\n            {\n                /*\n                 * set_tlbflush_timestamp() accesses the same union\n                 * linear_pt_count lives in. Pages (including page table ones),\n                 * however, don't need their flush time stamp set except when\n                 * the last reference is being dropped. For page table pages\n                 * this happens in _put_final_page_type().\n                 */\n                set_tlbflush_timestamp(page);\n            }\n            else\n                BUG_ON(!IS_ENABLED(CONFIG_PV_LINEAR_PT));\n\n            break;\n\n        case PGT_locked:\n            ASSERT_UNREACHABLE();\n            return -EILSEQ;\n\n        case PGT_locked | 1:\n            /*\n             * We must not drop the second to last reference when the page is\n             * locked, as page_unlock() doesn't do any cleanup of the type.\n             */\n            cpu_relax();\n            y = page->u.inuse.type_info;\n            continue;\n        }\n\n        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )\n            break;\n\n        if ( preemptible && hypercall_preempt_check() )\n            return -EINTR;\n    }\n\n    if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n    {\n        dec_linear_uses(page);\n        dec_linear_entries(ptpg);\n    }\n\n    return 0;\n}",
    "abstract_func_before": "static int _put_page_type(struct page_info *VAR_0, bool VAR_1,\n                          struct page_info *VAR_2)\n{\n    unsigned long VAR_3, VAR_4, VAR_5 = VAR_0->u.inuse.type_info;\n\n    ASSERT(current_locked_page_ne_check(VAR_0));\n\n    for ( ; ; )\n    {\n        VAR_4  = VAR_5;\n        VAR_3 = VAR_4 - 1;\n\n        ASSERT((VAR_4 & VAR_6) != 0);\n\n        switch ( VAR_3 & (VAR_7 | VAR_6) )\n        {\n        case 0:\n            if ( unlikely((VAR_3 & VAR_8) <= VAR_9) &&\n                 likely(VAR_3 & (VAR_10|VAR_11)) )\n            {\n                int VAR_12;\n\n                /* COMMENT_0 */\n                                                                               \n                                                                              \n                                                               \n                   \n                VAR_3 = VAR_4 & ~(VAR_10|VAR_11);\n                if ( unlikely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info,\n                                           VAR_4, VAR_3)) != VAR_4) )\n                    continue;\n                /* COMMENT_5 */\n                VAR_12 = _put_final_page_type(VAR_0, VAR_4, VAR_1, VAR_2);\n                if ( VAR_4 & VAR_11 )\n                    put_page(VAR_0);\n\n                return VAR_12;\n            }\n\n            if ( !VAR_2 || !PGT_type_equal(VAR_4, VAR_2->u.inuse.type_info) )\n            {\n                /* COMMENT_6 */\n                                                                   \n                                                                               \n                                                                             \n                                                                            \n                                                          \n                   \n                set_tlbflush_timestamp(VAR_0);\n            }\n            else\n                BUG_ON(!IS_ENABLED(VAR_13));\n\n            break;\n\n        case VAR_7:\n            ASSERT_UNREACHABLE();\n            return -VAR_14;\n\n        case VAR_7 | 1:\n            /* COMMENT_13 */\n                                                                             \n                                                                           \n               \n            cpu_relax();\n            VAR_5 = VAR_0->u.inuse.type_info;\n            continue;\n        }\n\n        if ( likely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )\n            break;\n\n        if ( VAR_1 && hypercall_preempt_check() )\n            return -VAR_15;\n    }\n\n    if ( VAR_2 && PGT_type_equal(VAR_4, VAR_2->u.inuse.type_info) )\n    {\n        dec_linear_uses(VAR_0);\n        dec_linear_entries(VAR_2);\n    }\n\n    return 0;\n}",
    "func_graph_path_before": "xen-project/xen/17608703c65bf080b0a9f024f9b370872b9f2c05/mm.c/vul/before/1.json",
    "func": "static int _put_page_type(struct page_info *page, bool preemptible,\n                          struct page_info *ptpg)\n{\n    unsigned long nx, x, y = page->u.inuse.type_info;\n\n    ASSERT(current_locked_page_ne_check(page));\n\n    for ( ; ; )\n    {\n        x  = y;\n        nx = x - 1;\n\n        ASSERT((x & PGT_count_mask) != 0);\n\n        switch ( nx & (PGT_locked | PGT_count_mask) )\n        {\n        case 0:\n            if ( unlikely((nx & PGT_type_mask) <= PGT_l4_page_table) &&\n                 likely(nx & (PGT_validated|PGT_partial)) )\n            {\n                int rc;\n\n                /*\n                 * Page-table pages must be unvalidated when count is zero. The\n                 * 'free' is safe because the refcnt is non-zero and validated\n                 * bit is clear => other ops will spin or fail.\n                 */\n                nx = x & ~(PGT_validated|PGT_partial);\n                if ( unlikely((y = cmpxchg(&page->u.inuse.type_info,\n                                           x, nx)) != x) )\n                    break;\n                /* We cleared the 'valid bit' so we do the clean up. */\n                rc = _put_final_page_type(page, x, preemptible, ptpg);\n                if ( x & PGT_partial )\n                    put_page(page);\n\n                return rc;\n            }\n\n            if ( !ptpg || !PGT_type_equal(x, ptpg->u.inuse.type_info) )\n            {\n                /*\n                 * set_tlbflush_timestamp() accesses the same union\n                 * linear_pt_count lives in. Pages (including page table ones),\n                 * however, don't need their flush time stamp set except when\n                 * the last reference is being dropped. For page table pages\n                 * this happens in _put_final_page_type().\n                 */\n                set_tlbflush_timestamp(page);\n            }\n            else\n                BUG_ON(!IS_ENABLED(CONFIG_PV_LINEAR_PT));\n\n            /* fall through */\n        default:\n            if ( unlikely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) != x) )\n                break;\n\n            if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n            {\n                dec_linear_uses(page);\n                dec_linear_entries(ptpg);\n            }\n\n            return 0;\n\n        case PGT_locked:\n            ASSERT_UNREACHABLE();\n            return -EILSEQ;\n\n        case PGT_locked | 1:\n            /*\n             * We must not drop the second to last reference when the page is\n             * locked, as page_unlock() doesn't do any cleanup of the type.\n             */\n            cpu_relax();\n            y = page->u.inuse.type_info;\n            break;\n        }\n\n        if ( preemptible && hypercall_preempt_check() )\n            return -EINTR;\n    }\n}",
    "abstract_func": "static int _put_page_type(struct page_info *VAR_0, bool VAR_1,\n                          struct page_info *VAR_2)\n{\n    unsigned long VAR_3, VAR_4, VAR_5 = VAR_0->u.inuse.type_info;\n\n    ASSERT(current_locked_page_ne_check(VAR_0));\n\n    for ( ; ; )\n    {\n        VAR_4  = VAR_5;\n        VAR_3 = VAR_4 - 1;\n\n        ASSERT((VAR_4 & VAR_6) != 0);\n\n        switch ( VAR_3 & (VAR_7 | VAR_6) )\n        {\n        case 0:\n            if ( unlikely((VAR_3 & VAR_8) <= VAR_9) &&\n                 likely(VAR_3 & (VAR_10|VAR_11)) )\n            {\n                int VAR_12;\n\n                /* COMMENT_0 */\n                                                                               \n                                                                              \n                                                               \n                   \n                VAR_3 = VAR_4 & ~(VAR_10|VAR_11);\n                if ( unlikely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info,\n                                           VAR_4, VAR_3)) != VAR_4) )\n                    break;\n                /* COMMENT_5 */\n                VAR_12 = _put_final_page_type(VAR_0, VAR_4, VAR_1, VAR_2);\n                if ( VAR_4 & VAR_11 )\n                    put_page(VAR_0);\n\n                return VAR_12;\n            }\n\n            if ( !VAR_2 || !PGT_type_equal(VAR_4, VAR_2->u.inuse.type_info) )\n            {\n                /* COMMENT_6 */\n                                                                   \n                                                                               \n                                                                             \n                                                                            \n                                                          \n                   \n                set_tlbflush_timestamp(VAR_0);\n            }\n            else\n                BUG_ON(!IS_ENABLED(VAR_13));\n\n            /* COMMENT_13 */\n        default:\n            if ( unlikely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) != VAR_4) )\n                break;\n\n            if ( VAR_2 && PGT_type_equal(VAR_4, VAR_2->u.inuse.type_info) )\n            {\n                dec_linear_uses(VAR_0);\n                dec_linear_entries(VAR_2);\n            }\n\n            return 0;\n\n        case VAR_7:\n            ASSERT_UNREACHABLE();\n            return -VAR_14;\n\n        case VAR_7 | 1:\n            /* COMMENT_14 */\n                                                                             \n                                                                           \n               \n            cpu_relax();\n            VAR_5 = VAR_0->u.inuse.type_info;\n            break;\n        }\n\n        if ( VAR_1 && hypercall_preempt_check() )\n            return -VAR_15;\n    }\n}",
    "func_graph_path": "xen-project/xen/17608703c65bf080b0a9f024f9b370872b9f2c05/mm.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n                 nx = x & ~(PGT_validated|PGT_partial);\n                 if ( unlikely((y = cmpxchg(&page->u.inuse.type_info,\n                                            x, nx)) != x) )\n-                    continue;\n+                    break;\n                 /* We cleared the 'valid bit' so we do the clean up. */\n                 rc = _put_final_page_type(page, x, preemptible, ptpg);\n                 if ( x & PGT_partial )\n@@ -51,7 +51,18 @@\n             else\n                 BUG_ON(!IS_ENABLED(CONFIG_PV_LINEAR_PT));\n \n-            break;\n+            /* fall through */\n+        default:\n+            if ( unlikely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) != x) )\n+                break;\n+\n+            if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n+            {\n+                dec_linear_uses(page);\n+                dec_linear_entries(ptpg);\n+            }\n+\n+            return 0;\n \n         case PGT_locked:\n             ASSERT_UNREACHABLE();\n@@ -64,21 +75,10 @@\n              */\n             cpu_relax();\n             y = page->u.inuse.type_info;\n-            continue;\n+            break;\n         }\n-\n-        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )\n-            break;\n \n         if ( preemptible && hypercall_preempt_check() )\n             return -EINTR;\n     }\n-\n-    if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n-    {\n-        dec_linear_uses(page);\n-        dec_linear_entries(ptpg);\n-    }\n-\n-    return 0;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "                    continue;",
            "            break;",
            "            continue;",
            "",
            "        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )",
            "            break;",
            "",
            "    if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )",
            "    {",
            "        dec_linear_uses(page);",
            "        dec_linear_entries(ptpg);",
            "    }",
            "",
            "    return 0;"
        ],
        "added_lines": [
            "                    break;",
            "            /* fall through */",
            "        default:",
            "            if ( unlikely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) != x) )",
            "                break;",
            "",
            "            if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )",
            "            {",
            "                dec_linear_uses(page);",
            "                dec_linear_entries(ptpg);",
            "            }",
            "",
            "            return 0;",
            "            break;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}