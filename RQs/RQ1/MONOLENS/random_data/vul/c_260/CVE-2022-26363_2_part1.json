{
    "cve_id": "CVE-2022-26363",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "xen-project/xen",
    "commit_msg": "x86: Split cache_flush() out of cache_writeback()\n\nSubsequent changes will want a fully flushing version.\n\nUse the new helper rather than opencoding it in flush_area_local().  This\nresolves an outstanding issue where the conditional sfence is on the wrong\nside of the clflushopt loop.  clflushopt is ordered with respect to older\nstores, not to younger stores.\n\nRename gnttab_cache_flush()'s helper to avoid colliding in name.\ngrant_table.c can see the prototype from cache.h so the build fails\notherwise.\n\nThis is part of XSA-402.\n\nSigned-off-by: Andrew Cooper <andrew.cooper3@citrix.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>",
    "commit_hash": "9a67ffee3371506e1cbfdfff5b90658d4828f6a2",
    "git_url": "https://github.com/xen-project/xen/commit/9a67ffee3371506e1cbfdfff5b90658d4828f6a2",
    "file_path": "xen/arch/x86/flushtlb.c",
    "func_name": "flush_area_local",
    "func_before": "unsigned int flush_area_local(const void *va, unsigned int flags)\n{\n    unsigned int order = (flags - 1) & FLUSH_ORDER_MASK;\n\n    if ( flags & (FLUSH_TLB|FLUSH_TLB_GLOBAL) )\n    {\n        if ( order == 0 )\n        {\n            /*\n             * We don't INVLPG multi-page regions because the 2M/4M/1G\n             * region may not have been mapped with a superpage. Also there\n             * are various errata surrounding INVLPG usage on superpages, and\n             * a full flush is in any case not *that* expensive.\n             */\n            if ( read_cr4() & X86_CR4_PCIDE )\n            {\n                unsigned long addr = (unsigned long)va;\n\n                /*\n                 * Flush the addresses for all potential address spaces.\n                 * We can't check the current domain for being subject to\n                 * XPTI as current might be the idle vcpu while we still have\n                 * some XPTI domain TLB entries.\n                 * Using invpcid is okay here, as with PCID enabled we always\n                 * have global pages disabled.\n                 */\n                invpcid_flush_one(PCID_PV_PRIV, addr);\n                invpcid_flush_one(PCID_PV_USER, addr);\n                if ( opt_xpti_hwdom || opt_xpti_domu )\n                {\n                    invpcid_flush_one(PCID_PV_PRIV | PCID_PV_XPTI, addr);\n                    invpcid_flush_one(PCID_PV_USER | PCID_PV_XPTI, addr);\n                }\n            }\n            else\n                asm volatile ( \"invlpg %0\"\n                               : : \"m\" (*(const char *)(va)) : \"memory\" );\n        }\n        else\n            do_tlb_flush();\n    }\n\n    if ( flags & FLUSH_HVM_ASID_CORE )\n        hvm_flush_guest_tlbs();\n\n    if ( flags & FLUSH_CACHE )\n    {\n        const struct cpuinfo_x86 *c = &current_cpu_data;\n        unsigned long i, sz = 0;\n\n        if ( order < (BITS_PER_LONG - PAGE_SHIFT) )\n            sz = 1UL << (order + PAGE_SHIFT);\n\n        if ( (!(flags & (FLUSH_TLB|FLUSH_TLB_GLOBAL)) ||\n              (flags & FLUSH_VA_VALID)) &&\n             c->x86_clflush_size && c->x86_cache_size && sz &&\n             ((sz >> 10) < c->x86_cache_size) )\n        {\n            alternative(\"\", \"sfence\", X86_FEATURE_CLFLUSHOPT);\n            for ( i = 0; i < sz; i += c->x86_clflush_size )\n                alternative_input(\"ds; clflush %0\",\n                                  \"data16 clflush %0\",      /* clflushopt */\n                                  X86_FEATURE_CLFLUSHOPT,\n                                  \"m\" (((const char *)va)[i]));\n            flags &= ~FLUSH_CACHE;\n        }\n        else\n        {\n            wbinvd();\n        }\n    }\n\n    if ( flags & FLUSH_ROOT_PGTBL )\n        get_cpu_info()->root_pgt_changed = true;\n\n    return flags;\n}",
    "abstract_func_before": "unsigned int flush_area_local(const void *VAR_0, unsigned int VAR_1)\n{\n    unsigned int VAR_2 = (VAR_1 - 1) & VAR_3;\n\n    if ( VAR_1 & (VAR_4|VAR_5) )\n    {\n        if ( VAR_2 == 0 )\n        {\n            /* COMMENT_0 */\n                                                                      \n                                                                           \n                                                                             \n                                                                \n               \n            if ( read_cr4() & VAR_6 )\n            {\n                unsigned long VAR_7 = (unsigned long)VAR_0;\n\n                /* COMMENT_6 */\n                                                                        \n                                                                         \n                                                                             \n                                                \n                                                                             \n                                              \n                   \n                invpcid_flush_one(VAR_8, VAR_7);\n                invpcid_flush_one(VAR_9, VAR_7);\n                if ( VAR_10 || VAR_11 )\n                {\n                    invpcid_flush_one(VAR_8 | VAR_12, VAR_7);\n                    invpcid_flush_one(VAR_9 | VAR_12, VAR_7);\n                }\n            }\n            else\n                VAR_13 volatile ( \"invlpg %0\"\n                               : : \"m\" (*(const char *)(VAR_0)) : \"memory\" );\n        }\n        else\n            do_tlb_flush();\n    }\n\n    if ( VAR_1 & VAR_14 )\n        hvm_flush_guest_tlbs();\n\n    if ( VAR_1 & VAR_15 )\n    {\n        const struct cpuinfo_x86 *VAR_16 = &VAR_17;\n        unsigned long VAR_18, VAR_19 = 0;\n\n        if ( VAR_2 < (VAR_20 - VAR_21) )\n            VAR_19 = 1UL << (VAR_2 + VAR_21);\n\n        if ( (!(VAR_1 & (VAR_4|VAR_5)) ||\n              (VAR_1 & VAR_22)) &&\n             VAR_16->x86_clflush_size && VAR_16->x86_cache_size && VAR_19 &&\n             ((VAR_19 >> 10) < VAR_16->x86_cache_size) )\n        {\n            alternative(\"\", \"sfence\", VAR_23);\n            for ( VAR_18 = 0; VAR_18 < VAR_19; VAR_18 += VAR_16->x86_clflush_size )\n                alternative_input(\"ds; clflush %0\",\n                                  \"data16 clflush %0\",      /* COMMENT_14 */\n                                  VAR_23,\n                                  \"m\" (((const char *)VAR_0)[VAR_18]));\n            VAR_1 &= ~VAR_15;\n        }\n        else\n        {\n            wbinvd();\n        }\n    }\n\n    if ( VAR_1 & VAR_24 )\n        get_cpu_info()->root_pgt_changed = true;\n\n    return VAR_1;\n}",
    "func_graph_path_before": "xen-project/xen/9a67ffee3371506e1cbfdfff5b90658d4828f6a2/flushtlb.c/vul/before/0.json",
    "func": "unsigned int flush_area_local(const void *va, unsigned int flags)\n{\n    unsigned int order = (flags - 1) & FLUSH_ORDER_MASK;\n\n    if ( flags & (FLUSH_TLB|FLUSH_TLB_GLOBAL) )\n    {\n        if ( order == 0 )\n        {\n            /*\n             * We don't INVLPG multi-page regions because the 2M/4M/1G\n             * region may not have been mapped with a superpage. Also there\n             * are various errata surrounding INVLPG usage on superpages, and\n             * a full flush is in any case not *that* expensive.\n             */\n            if ( read_cr4() & X86_CR4_PCIDE )\n            {\n                unsigned long addr = (unsigned long)va;\n\n                /*\n                 * Flush the addresses for all potential address spaces.\n                 * We can't check the current domain for being subject to\n                 * XPTI as current might be the idle vcpu while we still have\n                 * some XPTI domain TLB entries.\n                 * Using invpcid is okay here, as with PCID enabled we always\n                 * have global pages disabled.\n                 */\n                invpcid_flush_one(PCID_PV_PRIV, addr);\n                invpcid_flush_one(PCID_PV_USER, addr);\n                if ( opt_xpti_hwdom || opt_xpti_domu )\n                {\n                    invpcid_flush_one(PCID_PV_PRIV | PCID_PV_XPTI, addr);\n                    invpcid_flush_one(PCID_PV_USER | PCID_PV_XPTI, addr);\n                }\n            }\n            else\n                asm volatile ( \"invlpg %0\"\n                               : : \"m\" (*(const char *)(va)) : \"memory\" );\n        }\n        else\n            do_tlb_flush();\n    }\n\n    if ( flags & FLUSH_HVM_ASID_CORE )\n        hvm_flush_guest_tlbs();\n\n    if ( flags & FLUSH_CACHE )\n    {\n        const struct cpuinfo_x86 *c = &current_cpu_data;\n        unsigned long sz = 0;\n\n        if ( order < (BITS_PER_LONG - PAGE_SHIFT) )\n            sz = 1UL << (order + PAGE_SHIFT);\n\n        if ( (!(flags & (FLUSH_TLB|FLUSH_TLB_GLOBAL)) ||\n              (flags & FLUSH_VA_VALID)) &&\n             c->x86_clflush_size && c->x86_cache_size && sz &&\n             ((sz >> 10) < c->x86_cache_size) )\n        {\n            cache_flush(va, sz);\n            flags &= ~FLUSH_CACHE;\n        }\n        else\n        {\n            wbinvd();\n        }\n    }\n\n    if ( flags & FLUSH_ROOT_PGTBL )\n        get_cpu_info()->root_pgt_changed = true;\n\n    return flags;\n}",
    "abstract_func": "unsigned int flush_area_local(const void *VAR_0, unsigned int VAR_1)\n{\n    unsigned int VAR_2 = (VAR_1 - 1) & VAR_3;\n\n    if ( VAR_1 & (VAR_4|VAR_5) )\n    {\n        if ( VAR_2 == 0 )\n        {\n            /* COMMENT_0 */\n                                                                      \n                                                                           \n                                                                             \n                                                                \n               \n            if ( read_cr4() & VAR_6 )\n            {\n                unsigned long VAR_7 = (unsigned long)VAR_0;\n\n                /* COMMENT_6 */\n                                                                        \n                                                                         \n                                                                             \n                                                \n                                                                             \n                                              \n                   \n                invpcid_flush_one(VAR_8, VAR_7);\n                invpcid_flush_one(VAR_9, VAR_7);\n                if ( VAR_10 || VAR_11 )\n                {\n                    invpcid_flush_one(VAR_8 | VAR_12, VAR_7);\n                    invpcid_flush_one(VAR_9 | VAR_12, VAR_7);\n                }\n            }\n            else\n                VAR_13 volatile ( \"invlpg %0\"\n                               : : \"m\" (*(const char *)(VAR_0)) : \"memory\" );\n        }\n        else\n            do_tlb_flush();\n    }\n\n    if ( VAR_1 & VAR_14 )\n        hvm_flush_guest_tlbs();\n\n    if ( VAR_1 & VAR_15 )\n    {\n        const struct cpuinfo_x86 *VAR_16 = &VAR_17;\n        unsigned long VAR_18 = 0;\n\n        if ( VAR_2 < (VAR_19 - VAR_20) )\n            VAR_18 = 1UL << (VAR_2 + VAR_20);\n\n        if ( (!(VAR_1 & (VAR_4|VAR_5)) ||\n              (VAR_1 & VAR_21)) &&\n             VAR_16->x86_clflush_size && VAR_16->x86_cache_size && VAR_18 &&\n             ((VAR_18 >> 10) < VAR_16->x86_cache_size) )\n        {\n            cache_flush(VAR_0, VAR_18);\n            VAR_1 &= ~VAR_15;\n        }\n        else\n        {\n            wbinvd();\n        }\n    }\n\n    if ( VAR_1 & VAR_22 )\n        get_cpu_info()->root_pgt_changed = true;\n\n    return VAR_1;\n}",
    "func_graph_path": "xen-project/xen/9a67ffee3371506e1cbfdfff5b90658d4828f6a2/flushtlb.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -46,7 +46,7 @@\n     if ( flags & FLUSH_CACHE )\n     {\n         const struct cpuinfo_x86 *c = &current_cpu_data;\n-        unsigned long i, sz = 0;\n+        unsigned long sz = 0;\n \n         if ( order < (BITS_PER_LONG - PAGE_SHIFT) )\n             sz = 1UL << (order + PAGE_SHIFT);\n@@ -56,12 +56,7 @@\n              c->x86_clflush_size && c->x86_cache_size && sz &&\n              ((sz >> 10) < c->x86_cache_size) )\n         {\n-            alternative(\"\", \"sfence\", X86_FEATURE_CLFLUSHOPT);\n-            for ( i = 0; i < sz; i += c->x86_clflush_size )\n-                alternative_input(\"ds; clflush %0\",\n-                                  \"data16 clflush %0\",      /* clflushopt */\n-                                  X86_FEATURE_CLFLUSHOPT,\n-                                  \"m\" (((const char *)va)[i]));\n+            cache_flush(va, sz);\n             flags &= ~FLUSH_CACHE;\n         }\n         else",
    "diff_line_info": {
        "deleted_lines": [
            "        unsigned long i, sz = 0;",
            "            alternative(\"\", \"sfence\", X86_FEATURE_CLFLUSHOPT);",
            "            for ( i = 0; i < sz; i += c->x86_clflush_size )",
            "                alternative_input(\"ds; clflush %0\",",
            "                                  \"data16 clflush %0\",      /* clflushopt */",
            "                                  X86_FEATURE_CLFLUSHOPT,",
            "                                  \"m\" (((const char *)va)[i]));"
        ],
        "added_lines": [
            "        unsigned long sz = 0;",
            "            cache_flush(va, sz);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}