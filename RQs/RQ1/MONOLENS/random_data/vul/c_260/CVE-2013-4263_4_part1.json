{
    "cve_id": "CVE-2013-4263",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "ffmpeg",
    "commit_msg": "avfilter: fix plane validity checks\n\nFixes out of array accesses\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "commit_hash": "e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
    "git_url": "https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
    "file_path": "libavfilter/vf_fieldorder.c",
    "func_name": "filter_frame",
    "func_before": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext   *ctx     = inlink->dst;\n    FieldOrderContext *s       = ctx->priv;\n    AVFilterLink      *outlink = ctx->outputs[0];\n    int h, plane, line_step, line_size, line;\n    uint8_t *data;\n\n    if (!frame->interlaced_frame ||\n        frame->top_field_first == s->dst_tff)\n        return ff_filter_frame(outlink, frame);\n\n    av_dlog(ctx,\n            \"picture will move %s one line\\n\",\n            s->dst_tff ? \"up\" : \"down\");\n    h = frame->height;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        line_step = frame->linesize[plane];\n        line_size = s->line_size[plane];\n        data = frame->data[plane];\n        if (s->dst_tff) {\n            /** Move every line up one line, working from\n             *  the top to the bottom of the frame.\n             *  The original top line is lost.\n             *  The new last line is created as a copy of the\n             *  penultimate line from that field. */\n            for (line = 0; line < h; line++) {\n                if (1 + line < frame->height) {\n                    memcpy(data, data + line_step, line_size);\n                } else {\n                    memcpy(data, data - line_step - line_step, line_size);\n                }\n                data += line_step;\n            }\n        } else {\n            /** Move every line down one line, working from\n             *  the bottom to the top of the frame.\n             *  The original bottom line is lost.\n             *  The new first line is created as a copy of the\n             *  second line from that field. */\n            data += (h - 1) * line_step;\n            for (line = h - 1; line >= 0 ; line--) {\n                if (line > 0) {\n                    memcpy(data, data - line_step, line_size);\n                } else {\n                    memcpy(data, data + line_step + line_step, line_size);\n                }\n                data -= line_step;\n            }\n        }\n    }\n    frame->top_field_first = s->dst_tff;\n\n    return ff_filter_frame(outlink, frame);\n}",
    "abstract_func_before": "static int filter_frame(AVFilterLink *VAR_0, AVFrame *VAR_1)\n{\n    AVFilterContext   *VAR_2     = VAR_0->dst;\n    FieldOrderContext *VAR_3       = VAR_2->priv;\n    AVFilterLink      *VAR_4 = VAR_2->outputs[0];\n    int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;\n    uint8_t *VAR_10;\n\n    if (!VAR_1->interlaced_frame ||\n        VAR_1->top_field_first == VAR_3->dst_tff)\n        return ff_filter_frame(VAR_4, VAR_1);\n\n    av_dlog(VAR_2,\n            \"picture will move %s one line\\n\",\n            VAR_3->dst_tff ? \"up\" : \"down\");\n    VAR_5 = VAR_1->height;\n    for (VAR_6 = 0; VAR_6 < 4 && VAR_1->data[VAR_6]; VAR_6++) {\n        VAR_7 = VAR_1->linesize[VAR_6];\n        VAR_8 = VAR_3->line_size[VAR_6];\n        VAR_10 = VAR_1->data[VAR_6];\n        if (VAR_3->dst_tff) {\n            /* COMMENT_0 */\n                                                   \n                                              \n                                                             \n                                                    \n            for (VAR_9 = 0; VAR_9 < VAR_5; VAR_9++) {\n                if (1 + VAR_9 < VAR_1->height) {\n                    memcpy(VAR_10, VAR_10 + VAR_7, VAR_8);\n                } else {\n                    memcpy(VAR_10, VAR_10 - VAR_7 - VAR_7, VAR_8);\n                }\n                VAR_10 += VAR_7;\n            }\n        } else {\n            /* COMMENT_5 */\n                                                   \n                                                 \n                                                              \n                                               \n            VAR_10 += (VAR_5 - 1) * VAR_7;\n            for (VAR_9 = VAR_5 - 1; VAR_9 >= 0 ; VAR_9--) {\n                if (VAR_9 > 0) {\n                    memcpy(VAR_10, VAR_10 - VAR_7, VAR_8);\n                } else {\n                    memcpy(VAR_10, VAR_10 + VAR_7 + VAR_7, VAR_8);\n                }\n                VAR_10 -= VAR_7;\n            }\n        }\n    }\n    VAR_1->top_field_first = VAR_3->dst_tff;\n\n    return ff_filter_frame(VAR_4, VAR_1);\n}",
    "func_graph_path_before": "ffmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc/vf_fieldorder.c/vul/before/0.json",
    "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext   *ctx     = inlink->dst;\n    FieldOrderContext *s       = ctx->priv;\n    AVFilterLink      *outlink = ctx->outputs[0];\n    int h, plane, line_step, line_size, line;\n    uint8_t *data;\n\n    if (!frame->interlaced_frame ||\n        frame->top_field_first == s->dst_tff)\n        return ff_filter_frame(outlink, frame);\n\n    av_dlog(ctx,\n            \"picture will move %s one line\\n\",\n            s->dst_tff ? \"up\" : \"down\");\n    h = frame->height;\n    for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {\n        line_step = frame->linesize[plane];\n        line_size = s->line_size[plane];\n        data = frame->data[plane];\n        if (s->dst_tff) {\n            /** Move every line up one line, working from\n             *  the top to the bottom of the frame.\n             *  The original top line is lost.\n             *  The new last line is created as a copy of the\n             *  penultimate line from that field. */\n            for (line = 0; line < h; line++) {\n                if (1 + line < frame->height) {\n                    memcpy(data, data + line_step, line_size);\n                } else {\n                    memcpy(data, data - line_step - line_step, line_size);\n                }\n                data += line_step;\n            }\n        } else {\n            /** Move every line down one line, working from\n             *  the bottom to the top of the frame.\n             *  The original bottom line is lost.\n             *  The new first line is created as a copy of the\n             *  second line from that field. */\n            data += (h - 1) * line_step;\n            for (line = h - 1; line >= 0 ; line--) {\n                if (line > 0) {\n                    memcpy(data, data - line_step, line_size);\n                } else {\n                    memcpy(data, data + line_step + line_step, line_size);\n                }\n                data -= line_step;\n            }\n        }\n    }\n    frame->top_field_first = s->dst_tff;\n\n    return ff_filter_frame(outlink, frame);\n}",
    "abstract_func": "static int filter_frame(AVFilterLink *VAR_0, AVFrame *VAR_1)\n{\n    AVFilterContext   *VAR_2     = VAR_0->dst;\n    FieldOrderContext *VAR_3       = VAR_2->priv;\n    AVFilterLink      *VAR_4 = VAR_2->outputs[0];\n    int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;\n    uint8_t *VAR_10;\n\n    if (!VAR_1->interlaced_frame ||\n        VAR_1->top_field_first == VAR_3->dst_tff)\n        return ff_filter_frame(VAR_4, VAR_1);\n\n    av_dlog(VAR_2,\n            \"picture will move %s one line\\n\",\n            VAR_3->dst_tff ? \"up\" : \"down\");\n    VAR_5 = VAR_1->height;\n    for (VAR_6 = 0; VAR_6 < 4 && VAR_1->data[VAR_6] && VAR_1->linesize[VAR_6]; VAR_6++) {\n        VAR_7 = VAR_1->linesize[VAR_6];\n        VAR_8 = VAR_3->line_size[VAR_6];\n        VAR_10 = VAR_1->data[VAR_6];\n        if (VAR_3->dst_tff) {\n            /* COMMENT_0 */\n                                                   \n                                              \n                                                             \n                                                    \n            for (VAR_9 = 0; VAR_9 < VAR_5; VAR_9++) {\n                if (1 + VAR_9 < VAR_1->height) {\n                    memcpy(VAR_10, VAR_10 + VAR_7, VAR_8);\n                } else {\n                    memcpy(VAR_10, VAR_10 - VAR_7 - VAR_7, VAR_8);\n                }\n                VAR_10 += VAR_7;\n            }\n        } else {\n            /* COMMENT_5 */\n                                                   \n                                                 \n                                                              \n                                               \n            VAR_10 += (VAR_5 - 1) * VAR_7;\n            for (VAR_9 = VAR_5 - 1; VAR_9 >= 0 ; VAR_9--) {\n                if (VAR_9 > 0) {\n                    memcpy(VAR_10, VAR_10 - VAR_7, VAR_8);\n                } else {\n                    memcpy(VAR_10, VAR_10 + VAR_7 + VAR_7, VAR_8);\n                }\n                VAR_10 -= VAR_7;\n            }\n        }\n    }\n    VAR_1->top_field_first = VAR_3->dst_tff;\n\n    return ff_filter_frame(VAR_4, VAR_1);\n}",
    "func_graph_path": "ffmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc/vf_fieldorder.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n             \"picture will move %s one line\\n\",\n             s->dst_tff ? \"up\" : \"down\");\n     h = frame->height;\n-    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n+    for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {\n         line_step = frame->linesize[plane];\n         line_size = s->line_size[plane];\n         data = frame->data[plane];",
    "diff_line_info": {
        "deleted_lines": [
            "    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {"
        ],
        "added_lines": [
            "    for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}