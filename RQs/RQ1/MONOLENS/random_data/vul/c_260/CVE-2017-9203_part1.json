{
    "cve_id": "CVE-2017-9203",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "jsummers/imageworsener",
    "commit_msg": "Fixed a bug that could cause invalid memory to be accessed\n\nThe bug could happen when transparency is removed from an image.\nAlso fixed a semi-related BMP error handling logic bug.\nFixes issue #21",
    "commit_hash": "a4f247707f08e322f0b41e82c3e06e224240a654",
    "git_url": "https://github.com/jsummers/imageworsener/commit/a4f247707f08e322f0b41e82c3e06e224240a654",
    "file_path": "src/imagew-main.c",
    "func_name": "iw_process_rows_intermediate_to_final",
    "func_before": "static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,\n\tconst struct iw_csdescr *out_csdescr)\n{\n\tint i,j;\n\tint z;\n\tint k;\n\tint retval=0;\n\tiw_tmpsample tmpsamp;\n\tiw_tmpsample alphasamp = 0.0;\n\tiw_tmpsample *inpix_tofree = NULL; // Used if we need a separate temp buffer for input samples\n\tiw_tmpsample *outpix_tofree = NULL; // Used if we need a separate temp buffer for output samples\n\t// Do any of the output channels use error-diffusion dithering?\n\tint using_errdiffdither = 0;\n\tint output_channel;\n\tint is_alpha_channel;\n\tint bkgd_has_transparency;\n\tdouble tmpbkgdalpha=0.0;\n\tint alt_bkgd = 0; // Nonzero if we should use bkgd2 for this sample\n\tstruct iw_resize_settings *rs = NULL;\n\tint ditherfamily, dithersubtype;\n\tstruct iw_channelinfo_intermed *int_ci;\n\tstruct iw_channelinfo_out *out_ci;\n\n\tiw_tmpsample *in_pix = NULL;\n\tiw_tmpsample *out_pix = NULL;\n\tint num_in_pix;\n\tint num_out_pix;\n\n\tnum_in_pix = ctx->intermed_canvas_width;\n\tnum_out_pix = ctx->img2.width;\n\n\tint_ci = &ctx->intermed_ci[intermed_channel];\n\toutput_channel = int_ci->corresponding_output_channel;\n\tout_ci = &ctx->img2_ci[output_channel];\n\tis_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);\n\tbkgd_has_transparency = iw_bkgd_has_transparency(ctx);\n\n\tinpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));\n\tin_pix = inpix_tofree;\n\n\t// We need an output buffer.\n\toutpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));\n\tif(!outpix_tofree) goto done;\n\tout_pix = outpix_tofree;\n\n\t// Decide if the 'nearest color table' optimization can be used\n\tif(ctx->nearest_color_table && !is_alpha_channel &&\n\t   out_ci->ditherfamily==IW_DITHERFAMILY_NONE &&\n\t   out_ci->color_count==0)\n\t{\n\t\tout_ci->use_nearest_color_table = 1;\n\t}\n\telse {\n\t\tout_ci->use_nearest_color_table = 0;\n\t}\n\n\t// Seed the PRNG, if necessary.\n\tditherfamily = out_ci->ditherfamily;\n\tdithersubtype = out_ci->dithersubtype;\n\tif(ditherfamily==IW_DITHERFAMILY_RANDOM) {\n\t\t// Decide what random seed to use. The alpha channel always has its own\n\t\t// seed. If using \"r\" (not \"r2\") dithering, every channel has its own seed.\n\t\tif(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)\n\t\t{\n\t\t\tiwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed);\n\t\t}\n\t\telse {\n\t\t\tiwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype);\n\t\t}\n\t}\n\n\t// Initialize Floyd-Steinberg dithering.\n\tif(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) {\n\t\tusing_errdiffdither = 1;\n\t\tfor(i=0;i<ctx->img2.width;i++) {\n\t\t\tfor(k=0;k<IW_DITHER_MAXROWS;k++) {\n\t\t\t\tctx->dither_errors[k][i] = 0.0;\n\t\t\t}\n\t\t}\n\t}\n\n\trs=&ctx->resize_settings[IW_DIMENSION_H];\n\n\t// If the resize context for this dimension already exists, we should be\n\t// able to reuse it. Otherwise, create a new one.\n\tif(!rs->rrctx) {\n\t\trs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,\n\t\t\tnum_in_pix, num_out_pix);\n\t\tif(!rs->rrctx) goto done;\n\t}\n\n\tfor(j=0;j<ctx->intermed_canvas_height;j++) {\n\n\t\t// As needed, either copy the input pixels to a temp buffer (inpix, which\n\t\t// ctx->in_pix already points to), or point ctx->in_pix directly to the\n\t\t// intermediate data.\n\t\tif(is_alpha_channel) {\n\t\t\tfor(i=0;i<num_in_pix;i++) {\n\t\t\t\tinpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(i=0;i<num_in_pix;i++) {\n\t\t\t\tinpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i];\n\t\t\t}\n\t\t}\n\n\t\t// Resize ctx->in_pix to ctx->out_pix.\n\t\tiwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);\n\n\t\tif(ctx->intclamp)\n\t\t\tclamp_output_samples(ctx,out_pix,num_out_pix);\n\n\t\t// If necessary, copy the resized samples to the final_alpha image\n\t\tif(is_alpha_channel && outpix_tofree && ctx->final_alpha32) {\n\t\t\tfor(i=0;i<num_out_pix;i++) {\n\t\t\t\tctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i];\n\t\t\t}\n\t\t}\n\n\t\t// Now convert the out_pix and put them in the final image.\n\n\t\tif(output_channel == -1) {\n\t\t\t// No corresponding output channel.\n\t\t\t// (Presumably because this is an alpha channel that's being\n\t\t\t// removed because we're applying a background.)\n\t\t\tgoto here;\n\t\t}\n\n\t\tfor(z=0;z<ctx->img2.width;z++) {\n\t\t\t// For decent Floyd-Steinberg dithering, we need to process alternate\n\t\t\t// rows in reverse order.\n\t\t\tif(using_errdiffdither && (j%2))\n\t\t\t\ti=ctx->img2.width-1-z;\n\t\t\telse\n\t\t\t\ti=z;\n\n\t\t\ttmpsamp = out_pix[i];\n\n\t\t\tif(ctx->bkgd_checkerboard) {\n\t\t\t\talt_bkgd = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) !=\n\t\t\t\t\t(((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);\n\t\t\t}\n\n\t\t\tif(bkgd_has_transparency) {\n\t\t\t\ttmpbkgdalpha = alt_bkgd ? ctx->bkgd2alpha : ctx->bkgd1alpha;\n\t\t\t}\n\n\t\t\tif(int_ci->need_unassoc_alpha_processing) {\n\t\t\t\t// Convert color samples back to unassociated alpha.\n\t\t\t\talphasamp = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i];\n\n\t\t\t\tif(alphasamp!=0.0) {\n\t\t\t\t\ttmpsamp /= alphasamp;\n\t\t\t\t}\n\n\t\t\t\tif(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {\n\t\t\t\t\t// Apply a background color (or checkerboard pattern).\n\t\t\t\t\tdouble bkcolor;\n\t\t\t\t\tbkcolor = alt_bkgd ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin;\n\n\t\t\t\t\tif(bkgd_has_transparency) {\n\t\t\t\t\t\ttmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(is_alpha_channel && bkgd_has_transparency) {\n\t\t\t\t// Composite the alpha of the foreground over the alpha of the background.\n\t\t\t\ttmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp);\n\t\t\t}\n\n\t\t\tif(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)\n\t\t\t\tput_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);\n\t\t\telse\n\t\t\t\tput_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);\n\n\t\t}\n\n\t\tif(using_errdiffdither) {\n\t\t\t// Move \"next row\" error data to \"this row\", and clear the \"next row\".\n\t\t\t// TODO: Obviously, it would be more efficient to just swap pointers\n\t\t\t// to the rows.\n\t\t\tfor(i=0;i<ctx->img2.width;i++) {\n\t\t\t\t// Move data in all rows but the first row up one row.\n\t\t\t\tfor(k=0;k<IW_DITHER_MAXROWS-1;k++) {\n\t\t\t\t\tctx->dither_errors[k][i] = ctx->dither_errors[k+1][i];\n\t\t\t\t}\n\t\t\t\t// Clear the last row.\n\t\t\t\tctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;\n\t\t\t}\n\t\t}\n\nhere:\n\t\t;\n\t}\n\n\tretval=1;\n\ndone:\n\tif(rs && rs->disable_rrctx_cache && rs->rrctx) {\n\t\t// In some cases, the channels may need different resize contexts.\n\t\t// Delete the current context, so that it doesn't get reused.\n\t\tiwpvt_resize_rows_done(rs->rrctx);\n\t\trs->rrctx = NULL;\n\t}\n\tif(inpix_tofree) iw_free(ctx,inpix_tofree);\n\tif(outpix_tofree) iw_free(ctx,outpix_tofree);\n\n\treturn retval;\n}",
    "abstract_func_before": "static int iw_process_rows_intermediate_to_final(struct iw_context *VAR_0, int VAR_1,\n\tconst struct iw_csdescr *VAR_2)\n{\n\tint VAR_3,VAR_4;\n\tint VAR_5;\n\tint VAR_6;\n\tint VAR_7=0;\n\tiw_tmpsample VAR_8;\n\tiw_tmpsample VAR_9 = 0.0;\n\tiw_tmpsample *VAR_10 = NULL; /* COMMENT_0 */\n\tiw_tmpsample *VAR_11 = NULL; /* COMMENT_1 */\n\t/* COMMENT_2 */\n\tint VAR_12 = 0;\n\tint VAR_13;\n\tint VAR_14;\n\tint VAR_15;\n\tdouble VAR_16=0.0;\n\tint VAR_17 = 0; /* COMMENT_3 */\n\tstruct iw_resize_settings *VAR_18 = NULL;\n\tint VAR_19, VAR_20;\n\tstruct iw_channelinfo_intermed *VAR_21;\n\tstruct iw_channelinfo_out *VAR_22;\n\n\tiw_tmpsample *VAR_23 = NULL;\n\tiw_tmpsample *VAR_24 = NULL;\n\tint VAR_25;\n\tint VAR_26;\n\n\tVAR_25 = VAR_0->intermed_canvas_width;\n\tVAR_26 = VAR_0->img2.width;\n\n\tVAR_21 = &VAR_0->intermed_ci[VAR_1];\n\tVAR_13 = VAR_21->corresponding_output_channel;\n\tVAR_22 = &VAR_0->img2_ci[VAR_13];\n\tVAR_14 = (VAR_21->channeltype==VAR_27);\n\tVAR_15 = iw_bkgd_has_transparency(VAR_0);\n\n\tVAR_10 = (iw_tmpsample*)iw_malloc(VAR_0, VAR_25 * sizeof(iw_tmpsample));\n\tVAR_23 = VAR_10;\n\n\t/* COMMENT_4 */\n\tVAR_11 = (iw_tmpsample*)iw_malloc(VAR_0, VAR_26 * sizeof(iw_tmpsample));\n\tif(!VAR_11) goto done;\n\tVAR_24 = VAR_11;\n\n\t/* COMMENT_5 */\n\tif(VAR_0->nearest_color_table && !VAR_14 &&\n\t   VAR_22->ditherfamily==VAR_28 &&\n\t   VAR_22->color_count==0)\n\t{\n\t\tVAR_22->use_nearest_color_table = 1;\n\t}\n\telse {\n\t\tVAR_22->use_nearest_color_table = 0;\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_19 = VAR_22->ditherfamily;\n\tVAR_20 = VAR_22->dithersubtype;\n\tif(VAR_19==VAR_29) {\n\t\t/* COMMENT_7 */\n\t\t/* COMMENT_8 */\n\t\tif(VAR_20==VAR_30 && VAR_22->channeltype!=VAR_27)\n\t\t{\n\t\t\tiwpvt_prng_set_random_seed(VAR_0->prng,VAR_0->random_seed);\n\t\t}\n\t\telse {\n\t\t\tiwpvt_prng_set_random_seed(VAR_0->prng,VAR_0->random_seed+VAR_22->channeltype);\n\t\t}\n\t}\n\n\t/* COMMENT_9 */\n\tif(VAR_13>=0 && VAR_22->ditherfamily==VAR_31) {\n\t\tVAR_12 = 1;\n\t\tfor(VAR_3=0;VAR_3<VAR_0->img2.width;VAR_3++) {\n\t\t\tfor(VAR_6=0;VAR_6<VAR_32;VAR_6++) {\n\t\t\t\tVAR_0->dither_errors[VAR_6][VAR_3] = 0.0;\n\t\t\t}\n\t\t}\n\t}\n\n\tVAR_18=&VAR_0->resize_settings[VAR_33];\n\n\t/* COMMENT_10 */\n\t/* COMMENT_11 */\n\tif(!VAR_18->rrctx) {\n\t\tVAR_18->rrctx = iwpvt_resize_rows_init(VAR_0,VAR_18,VAR_21->channeltype,\n\t\t\tVAR_25, VAR_26);\n\t\tif(!VAR_18->rrctx) goto done;\n\t}\n\n\tfor(VAR_4=0;VAR_4<VAR_0->intermed_canvas_height;VAR_4++) {\n\n\t\t/* COMMENT_12 */\n\t\t/* COMMENT_13 */\n\t\t/* COMMENT_14 */\n\t\tif(VAR_14) {\n\t\t\tfor(VAR_3=0;VAR_3<VAR_25;VAR_3++) {\n\t\t\t\tVAR_10[VAR_3] = VAR_0->intermediate_alpha32[((size_t)VAR_4)*VAR_0->intermed_canvas_width+VAR_3];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(VAR_3=0;VAR_3<VAR_25;VAR_3++) {\n\t\t\t\tVAR_10[VAR_3] = VAR_0->intermediate32[((size_t)VAR_4)*VAR_0->intermed_canvas_width+VAR_3];\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_15 */\n\t\tiwpvt_resize_row_main(VAR_18->rrctx,VAR_23,VAR_24);\n\n\t\tif(VAR_0->intclamp)\n\t\t\tclamp_output_samples(VAR_0,VAR_24,VAR_26);\n\n\t\t/* COMMENT_16 */\n\t\tif(VAR_14 && VAR_11 && VAR_0->final_alpha32) {\n\t\t\tfor(VAR_3=0;VAR_3<VAR_26;VAR_3++) {\n\t\t\t\tVAR_0->final_alpha32[((size_t)VAR_4)*VAR_0->img2.width+VAR_3] = (iw_float32)VAR_11[VAR_3];\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_17 */\n\n\t\tif(VAR_13 == -1) {\n\t\t\t/* COMMENT_18 */\n\t\t\t/* COMMENT_19 */\n\t\t\t/* COMMENT_20 */\n\t\t\tgoto here;\n\t\t}\n\n\t\tfor(VAR_5=0;VAR_5<VAR_0->img2.width;VAR_5++) {\n\t\t\t/* COMMENT_21 */\n\t\t\t/* COMMENT_22 */\n\t\t\tif(VAR_12 && (VAR_4%2))\n\t\t\t\tVAR_3=VAR_0->img2.width-1-VAR_5;\n\t\t\telse\n\t\t\t\tVAR_3=VAR_5;\n\n\t\t\tVAR_8 = VAR_24[VAR_3];\n\n\t\t\tif(VAR_0->bkgd_checkerboard) {\n\t\t\t\tVAR_17 = (((VAR_0->bkgd_check_origin[VAR_33]+VAR_3)/VAR_0->bkgd_check_size)%2) !=\n\t\t\t\t\t(((VAR_0->bkgd_check_origin[VAR_34]+VAR_4)/VAR_0->bkgd_check_size)%2);\n\t\t\t}\n\n\t\t\tif(VAR_15) {\n\t\t\t\tVAR_16 = VAR_17 ? VAR_0->bkgd2alpha : VAR_0->bkgd1alpha;\n\t\t\t}\n\n\t\t\tif(VAR_21->need_unassoc_alpha_processing) {\n\t\t\t\t/* COMMENT_23 */\n\t\t\t\tVAR_9 = VAR_0->final_alpha32[((size_t)VAR_4)*VAR_0->img2.width + VAR_3];\n\n\t\t\t\tif(VAR_9!=0.0) {\n\t\t\t\t\tVAR_8 /= VAR_9;\n\t\t\t\t}\n\n\t\t\t\tif(VAR_0->apply_bkgd && VAR_0->apply_bkgd_strategy==VAR_35) {\n\t\t\t\t\t/* COMMENT_24 */\n\t\t\t\t\tdouble VAR_36;\n\t\t\t\t\tVAR_36 = VAR_17 ? VAR_22->bkgd2_color_lin : VAR_22->bkgd1_color_lin;\n\n\t\t\t\t\tif(VAR_15) {\n\t\t\t\t\t\tVAR_8 = VAR_8*VAR_9 + VAR_36*VAR_16*(1.0-VAR_9);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tVAR_8 = VAR_8*VAR_9 + VAR_36*(1.0-VAR_9);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(VAR_14 && VAR_15) {\n\t\t\t\t/* COMMENT_25 */\n\t\t\t\tVAR_8 = VAR_8 + VAR_16*(1.0-VAR_8);\n\t\t\t}\n\n\t\t\tif(VAR_0->img2.sampletype==VAR_37)\n\t\t\t\tput_sample_convert_from_linear_flt(VAR_0,VAR_8,VAR_3,VAR_4,VAR_13,VAR_2);\n\t\t\telse\n\t\t\t\tput_sample_convert_from_linear(VAR_0,VAR_8,VAR_3,VAR_4,VAR_13,VAR_2);\n\n\t\t}\n\n\t\tif(VAR_12) {\n\t\t\t/* COMMENT_26 */\n\t\t\t/* COMMENT_27 */\n\t\t\t/* COMMENT_28 */\n\t\t\tfor(VAR_3=0;VAR_3<VAR_0->img2.width;VAR_3++) {\n\t\t\t\t/* COMMENT_29 */\n\t\t\t\tfor(VAR_6=0;VAR_6<VAR_32-1;VAR_6++) {\n\t\t\t\t\tVAR_0->dither_errors[VAR_6][VAR_3] = VAR_0->dither_errors[VAR_6+1][VAR_3];\n\t\t\t\t}\n\t\t\t\t/* COMMENT_30 */\n\t\t\t\tVAR_0->dither_errors[VAR_32-1][VAR_3] = 0.0;\n\t\t\t}\n\t\t}\n\nhere:\n\t\t;\n\t}\n\n\tVAR_7=1;\n\ndone:\n\tif(VAR_18 && VAR_18->disable_rrctx_cache && VAR_18->rrctx) {\n\t\t/* COMMENT_31 */\n\t\t/* COMMENT_32 */\n\t\tiwpvt_resize_rows_done(VAR_18->rrctx);\n\t\tVAR_18->rrctx = NULL;\n\t}\n\tif(VAR_10) iw_free(VAR_0,VAR_10);\n\tif(VAR_11) iw_free(VAR_0,VAR_11);\n\n\treturn VAR_7;\n}",
    "func_graph_path_before": "jsummers/imageworsener/a4f247707f08e322f0b41e82c3e06e224240a654/imagew-main.c/vul/before/0.json",
    "func": "static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,\n\tconst struct iw_csdescr *out_csdescr)\n{\n\tint i,j;\n\tint z;\n\tint k;\n\tint retval=0;\n\tiw_tmpsample tmpsamp;\n\tiw_tmpsample alphasamp = 0.0;\n\tiw_tmpsample *inpix_tofree = NULL; // Used if we need a separate temp buffer for input samples\n\tiw_tmpsample *outpix_tofree = NULL; // Used if we need a separate temp buffer for output samples\n\t// Do any of the output channels use error-diffusion dithering?\n\tint using_errdiffdither = 0;\n\tint output_channel;\n\tint is_alpha_channel;\n\tint bkgd_has_transparency;\n\tdouble tmpbkgdalpha=0.0;\n\tint alt_bkgd = 0; // Nonzero if we should use bkgd2 for this sample\n\tstruct iw_resize_settings *rs = NULL;\n\tint ditherfamily, dithersubtype;\n\tstruct iw_channelinfo_intermed *int_ci;\n\tstruct iw_channelinfo_out *out_ci;\n\n\tiw_tmpsample *in_pix = NULL;\n\tiw_tmpsample *out_pix = NULL;\n\tint num_in_pix;\n\tint num_out_pix;\n\tstruct iw_channelinfo_out default_ci_out;\n\n\tnum_in_pix = ctx->intermed_canvas_width;\n\tnum_out_pix = ctx->img2.width;\n\n\tint_ci = &ctx->intermed_ci[intermed_channel];\n\toutput_channel = int_ci->corresponding_output_channel;\n\tif(output_channel>=0) {\n\t\tout_ci = &ctx->img2_ci[output_channel];\n\t}\n\telse {\n\t\t// If there is no output channelinfo struct, create a temporary one to\n\t\t// use.\n\t\t// TODO: This is admittedly ugly, but we use these settings for a few\n\t\t// things even when there is no corresponding output channel, and I\n\t\t// don't remember exactly why.\n\t\tiw_zeromem(&default_ci_out, sizeof(struct iw_channelinfo_out));\n\t\tdefault_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;\n\t\tout_ci = &default_ci_out;\n\t}\n\n\tis_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);\n\tbkgd_has_transparency = iw_bkgd_has_transparency(ctx);\n\n\tinpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));\n\tin_pix = inpix_tofree;\n\n\t// We need an output buffer.\n\toutpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));\n\tif(!outpix_tofree) goto done;\n\tout_pix = outpix_tofree;\n\n\t// Decide if the 'nearest color table' optimization can be used\n\tif(ctx->nearest_color_table && !is_alpha_channel &&\n\t   out_ci->ditherfamily==IW_DITHERFAMILY_NONE &&\n\t   out_ci->color_count==0)\n\t{\n\t\tout_ci->use_nearest_color_table = 1;\n\t}\n\telse {\n\t\tout_ci->use_nearest_color_table = 0;\n\t}\n\n\t// Seed the PRNG, if necessary.\n\tditherfamily = out_ci->ditherfamily;\n\tdithersubtype = out_ci->dithersubtype;\n\tif(ditherfamily==IW_DITHERFAMILY_RANDOM) {\n\t\t// Decide what random seed to use. The alpha channel always has its own\n\t\t// seed. If using \"r\" (not \"r2\") dithering, every channel has its own seed.\n\t\tif(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)\n\t\t{\n\t\t\tiwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed);\n\t\t}\n\t\telse {\n\t\t\tiwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype);\n\t\t}\n\t}\n\n\t// Initialize Floyd-Steinberg dithering.\n\tif(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) {\n\t\tusing_errdiffdither = 1;\n\t\tfor(i=0;i<ctx->img2.width;i++) {\n\t\t\tfor(k=0;k<IW_DITHER_MAXROWS;k++) {\n\t\t\t\tctx->dither_errors[k][i] = 0.0;\n\t\t\t}\n\t\t}\n\t}\n\n\trs=&ctx->resize_settings[IW_DIMENSION_H];\n\n\t// If the resize context for this dimension already exists, we should be\n\t// able to reuse it. Otherwise, create a new one.\n\tif(!rs->rrctx) {\n\t\trs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,\n\t\t\tnum_in_pix, num_out_pix);\n\t\tif(!rs->rrctx) goto done;\n\t}\n\n\tfor(j=0;j<ctx->intermed_canvas_height;j++) {\n\n\t\t// As needed, either copy the input pixels to a temp buffer (inpix, which\n\t\t// ctx->in_pix already points to), or point ctx->in_pix directly to the\n\t\t// intermediate data.\n\t\tif(is_alpha_channel) {\n\t\t\tfor(i=0;i<num_in_pix;i++) {\n\t\t\t\tinpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(i=0;i<num_in_pix;i++) {\n\t\t\t\tinpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i];\n\t\t\t}\n\t\t}\n\n\t\t// Resize ctx->in_pix to ctx->out_pix.\n\t\tiwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);\n\n\t\tif(ctx->intclamp)\n\t\t\tclamp_output_samples(ctx,out_pix,num_out_pix);\n\n\t\t// If necessary, copy the resized samples to the final_alpha image\n\t\tif(is_alpha_channel && outpix_tofree && ctx->final_alpha32) {\n\t\t\tfor(i=0;i<num_out_pix;i++) {\n\t\t\t\tctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i];\n\t\t\t}\n\t\t}\n\n\t\t// Now convert the out_pix and put them in the final image.\n\n\t\tif(output_channel == -1) {\n\t\t\t// No corresponding output channel.\n\t\t\t// (Presumably because this is an alpha channel that's being\n\t\t\t// removed because we're applying a background.)\n\t\t\tgoto here;\n\t\t}\n\n\t\tfor(z=0;z<ctx->img2.width;z++) {\n\t\t\t// For decent Floyd-Steinberg dithering, we need to process alternate\n\t\t\t// rows in reverse order.\n\t\t\tif(using_errdiffdither && (j%2))\n\t\t\t\ti=ctx->img2.width-1-z;\n\t\t\telse\n\t\t\t\ti=z;\n\n\t\t\ttmpsamp = out_pix[i];\n\n\t\t\tif(ctx->bkgd_checkerboard) {\n\t\t\t\talt_bkgd = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) !=\n\t\t\t\t\t(((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);\n\t\t\t}\n\n\t\t\tif(bkgd_has_transparency) {\n\t\t\t\ttmpbkgdalpha = alt_bkgd ? ctx->bkgd2alpha : ctx->bkgd1alpha;\n\t\t\t}\n\n\t\t\tif(int_ci->need_unassoc_alpha_processing) {\n\t\t\t\t// Convert color samples back to unassociated alpha.\n\t\t\t\talphasamp = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i];\n\n\t\t\t\tif(alphasamp!=0.0) {\n\t\t\t\t\ttmpsamp /= alphasamp;\n\t\t\t\t}\n\n\t\t\t\tif(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {\n\t\t\t\t\t// Apply a background color (or checkerboard pattern).\n\t\t\t\t\tdouble bkcolor;\n\t\t\t\t\tbkcolor = alt_bkgd ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin;\n\n\t\t\t\t\tif(bkgd_has_transparency) {\n\t\t\t\t\t\ttmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(is_alpha_channel && bkgd_has_transparency) {\n\t\t\t\t// Composite the alpha of the foreground over the alpha of the background.\n\t\t\t\ttmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp);\n\t\t\t}\n\n\t\t\tif(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)\n\t\t\t\tput_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);\n\t\t\telse\n\t\t\t\tput_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);\n\n\t\t}\n\n\t\tif(using_errdiffdither) {\n\t\t\t// Move \"next row\" error data to \"this row\", and clear the \"next row\".\n\t\t\t// TODO: Obviously, it would be more efficient to just swap pointers\n\t\t\t// to the rows.\n\t\t\tfor(i=0;i<ctx->img2.width;i++) {\n\t\t\t\t// Move data in all rows but the first row up one row.\n\t\t\t\tfor(k=0;k<IW_DITHER_MAXROWS-1;k++) {\n\t\t\t\t\tctx->dither_errors[k][i] = ctx->dither_errors[k+1][i];\n\t\t\t\t}\n\t\t\t\t// Clear the last row.\n\t\t\t\tctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;\n\t\t\t}\n\t\t}\n\nhere:\n\t\t;\n\t}\n\n\tretval=1;\n\ndone:\n\tif(rs && rs->disable_rrctx_cache && rs->rrctx) {\n\t\t// In some cases, the channels may need different resize contexts.\n\t\t// Delete the current context, so that it doesn't get reused.\n\t\tiwpvt_resize_rows_done(rs->rrctx);\n\t\trs->rrctx = NULL;\n\t}\n\tif(inpix_tofree) iw_free(ctx,inpix_tofree);\n\tif(outpix_tofree) iw_free(ctx,outpix_tofree);\n\n\treturn retval;\n}",
    "abstract_func": "static int iw_process_rows_intermediate_to_final(struct iw_context *VAR_0, int VAR_1,\n\tconst struct iw_csdescr *VAR_2)\n{\n\tint VAR_3,VAR_4;\n\tint VAR_5;\n\tint VAR_6;\n\tint VAR_7=0;\n\tiw_tmpsample VAR_8;\n\tiw_tmpsample VAR_9 = 0.0;\n\tiw_tmpsample *VAR_10 = NULL; /* COMMENT_0 */\n\tiw_tmpsample *VAR_11 = NULL; /* COMMENT_1 */\n\t/* COMMENT_2 */\n\tint VAR_12 = 0;\n\tint VAR_13;\n\tint VAR_14;\n\tint VAR_15;\n\tdouble VAR_16=0.0;\n\tint VAR_17 = 0; /* COMMENT_3 */\n\tstruct iw_resize_settings *VAR_18 = NULL;\n\tint VAR_19, VAR_20;\n\tstruct iw_channelinfo_intermed *VAR_21;\n\tstruct iw_channelinfo_out *VAR_22;\n\n\tiw_tmpsample *VAR_23 = NULL;\n\tiw_tmpsample *VAR_24 = NULL;\n\tint VAR_25;\n\tint VAR_26;\n\tstruct iw_channelinfo_out VAR_27;\n\n\tVAR_25 = VAR_0->intermed_canvas_width;\n\tVAR_26 = VAR_0->img2.width;\n\n\tVAR_21 = &VAR_0->intermed_ci[VAR_1];\n\tVAR_13 = VAR_21->corresponding_output_channel;\n\tif(VAR_13>=0) {\n\t\tVAR_22 = &VAR_0->img2_ci[VAR_13];\n\t}\n\telse {\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\t\t/* COMMENT_6 */\n\t\t/* COMMENT_7 */\n\t\t/* COMMENT_8 */\n\t\tiw_zeromem(&VAR_27, sizeof(struct iw_channelinfo_out));\n\t\tVAR_27.channeltype = VAR_28;\n\t\tVAR_22 = &VAR_27;\n\t}\n\n\tVAR_14 = (VAR_21->channeltype==VAR_29);\n\tVAR_15 = iw_bkgd_has_transparency(VAR_0);\n\n\tVAR_10 = (iw_tmpsample*)iw_malloc(VAR_0, VAR_25 * sizeof(iw_tmpsample));\n\tVAR_23 = VAR_10;\n\n\t/* COMMENT_9 */\n\tVAR_11 = (iw_tmpsample*)iw_malloc(VAR_0, VAR_26 * sizeof(iw_tmpsample));\n\tif(!VAR_11) goto done;\n\tVAR_24 = VAR_11;\n\n\t/* COMMENT_10 */\n\tif(VAR_0->nearest_color_table && !VAR_14 &&\n\t   VAR_22->ditherfamily==VAR_30 &&\n\t   VAR_22->color_count==0)\n\t{\n\t\tVAR_22->use_nearest_color_table = 1;\n\t}\n\telse {\n\t\tVAR_22->use_nearest_color_table = 0;\n\t}\n\n\t/* COMMENT_11 */\n\tVAR_19 = VAR_22->ditherfamily;\n\tVAR_20 = VAR_22->dithersubtype;\n\tif(VAR_19==VAR_31) {\n\t\t/* COMMENT_12 */\n\t\t/* COMMENT_13 */\n\t\tif(VAR_20==VAR_32 && VAR_22->channeltype!=VAR_29)\n\t\t{\n\t\t\tiwpvt_prng_set_random_seed(VAR_0->prng,VAR_0->random_seed);\n\t\t}\n\t\telse {\n\t\t\tiwpvt_prng_set_random_seed(VAR_0->prng,VAR_0->random_seed+VAR_22->channeltype);\n\t\t}\n\t}\n\n\t/* COMMENT_14 */\n\tif(VAR_13>=0 && VAR_22->ditherfamily==VAR_33) {\n\t\tVAR_12 = 1;\n\t\tfor(VAR_3=0;VAR_3<VAR_0->img2.width;VAR_3++) {\n\t\t\tfor(VAR_6=0;VAR_6<VAR_34;VAR_6++) {\n\t\t\t\tVAR_0->dither_errors[VAR_6][VAR_3] = 0.0;\n\t\t\t}\n\t\t}\n\t}\n\n\tVAR_18=&VAR_0->resize_settings[VAR_35];\n\n\t/* COMMENT_15 */\n\t/* COMMENT_16 */\n\tif(!VAR_18->rrctx) {\n\t\tVAR_18->rrctx = iwpvt_resize_rows_init(VAR_0,VAR_18,VAR_21->channeltype,\n\t\t\tVAR_25, VAR_26);\n\t\tif(!VAR_18->rrctx) goto done;\n\t}\n\n\tfor(VAR_4=0;VAR_4<VAR_0->intermed_canvas_height;VAR_4++) {\n\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\t/* COMMENT_19 */\n\t\tif(VAR_14) {\n\t\t\tfor(VAR_3=0;VAR_3<VAR_25;VAR_3++) {\n\t\t\t\tVAR_10[VAR_3] = VAR_0->intermediate_alpha32[((size_t)VAR_4)*VAR_0->intermed_canvas_width+VAR_3];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(VAR_3=0;VAR_3<VAR_25;VAR_3++) {\n\t\t\t\tVAR_10[VAR_3] = VAR_0->intermediate32[((size_t)VAR_4)*VAR_0->intermed_canvas_width+VAR_3];\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_20 */\n\t\tiwpvt_resize_row_main(VAR_18->rrctx,VAR_23,VAR_24);\n\n\t\tif(VAR_0->intclamp)\n\t\t\tclamp_output_samples(VAR_0,VAR_24,VAR_26);\n\n\t\t/* COMMENT_21 */\n\t\tif(VAR_14 && VAR_11 && VAR_0->final_alpha32) {\n\t\t\tfor(VAR_3=0;VAR_3<VAR_26;VAR_3++) {\n\t\t\t\tVAR_0->final_alpha32[((size_t)VAR_4)*VAR_0->img2.width+VAR_3] = (iw_float32)VAR_11[VAR_3];\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_22 */\n\n\t\tif(VAR_13 == -1) {\n\t\t\t/* COMMENT_23 */\n\t\t\t/* COMMENT_24 */\n\t\t\t/* COMMENT_25 */\n\t\t\tgoto here;\n\t\t}\n\n\t\tfor(VAR_5=0;VAR_5<VAR_0->img2.width;VAR_5++) {\n\t\t\t/* COMMENT_26 */\n\t\t\t/* COMMENT_27 */\n\t\t\tif(VAR_12 && (VAR_4%2))\n\t\t\t\tVAR_3=VAR_0->img2.width-1-VAR_5;\n\t\t\telse\n\t\t\t\tVAR_3=VAR_5;\n\n\t\t\tVAR_8 = VAR_24[VAR_3];\n\n\t\t\tif(VAR_0->bkgd_checkerboard) {\n\t\t\t\tVAR_17 = (((VAR_0->bkgd_check_origin[VAR_35]+VAR_3)/VAR_0->bkgd_check_size)%2) !=\n\t\t\t\t\t(((VAR_0->bkgd_check_origin[VAR_36]+VAR_4)/VAR_0->bkgd_check_size)%2);\n\t\t\t}\n\n\t\t\tif(VAR_15) {\n\t\t\t\tVAR_16 = VAR_17 ? VAR_0->bkgd2alpha : VAR_0->bkgd1alpha;\n\t\t\t}\n\n\t\t\tif(VAR_21->need_unassoc_alpha_processing) {\n\t\t\t\t/* COMMENT_28 */\n\t\t\t\tVAR_9 = VAR_0->final_alpha32[((size_t)VAR_4)*VAR_0->img2.width + VAR_3];\n\n\t\t\t\tif(VAR_9!=0.0) {\n\t\t\t\t\tVAR_8 /= VAR_9;\n\t\t\t\t}\n\n\t\t\t\tif(VAR_0->apply_bkgd && VAR_0->apply_bkgd_strategy==VAR_37) {\n\t\t\t\t\t/* COMMENT_29 */\n\t\t\t\t\tdouble VAR_38;\n\t\t\t\t\tVAR_38 = VAR_17 ? VAR_22->bkgd2_color_lin : VAR_22->bkgd1_color_lin;\n\n\t\t\t\t\tif(VAR_15) {\n\t\t\t\t\t\tVAR_8 = VAR_8*VAR_9 + VAR_38*VAR_16*(1.0-VAR_9);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tVAR_8 = VAR_8*VAR_9 + VAR_38*(1.0-VAR_9);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(VAR_14 && VAR_15) {\n\t\t\t\t/* COMMENT_30 */\n\t\t\t\tVAR_8 = VAR_8 + VAR_16*(1.0-VAR_8);\n\t\t\t}\n\n\t\t\tif(VAR_0->img2.sampletype==VAR_39)\n\t\t\t\tput_sample_convert_from_linear_flt(VAR_0,VAR_8,VAR_3,VAR_4,VAR_13,VAR_2);\n\t\t\telse\n\t\t\t\tput_sample_convert_from_linear(VAR_0,VAR_8,VAR_3,VAR_4,VAR_13,VAR_2);\n\n\t\t}\n\n\t\tif(VAR_12) {\n\t\t\t/* COMMENT_31 */\n\t\t\t/* COMMENT_32 */\n\t\t\t/* COMMENT_33 */\n\t\t\tfor(VAR_3=0;VAR_3<VAR_0->img2.width;VAR_3++) {\n\t\t\t\t/* COMMENT_34 */\n\t\t\t\tfor(VAR_6=0;VAR_6<VAR_34-1;VAR_6++) {\n\t\t\t\t\tVAR_0->dither_errors[VAR_6][VAR_3] = VAR_0->dither_errors[VAR_6+1][VAR_3];\n\t\t\t\t}\n\t\t\t\t/* COMMENT_35 */\n\t\t\t\tVAR_0->dither_errors[VAR_34-1][VAR_3] = 0.0;\n\t\t\t}\n\t\t}\n\nhere:\n\t\t;\n\t}\n\n\tVAR_7=1;\n\ndone:\n\tif(VAR_18 && VAR_18->disable_rrctx_cache && VAR_18->rrctx) {\n\t\t/* COMMENT_36 */\n\t\t/* COMMENT_37 */\n\t\tiwpvt_resize_rows_done(VAR_18->rrctx);\n\t\tVAR_18->rrctx = NULL;\n\t}\n\tif(VAR_10) iw_free(VAR_0,VAR_10);\n\tif(VAR_11) iw_free(VAR_0,VAR_11);\n\n\treturn VAR_7;\n}",
    "func_graph_path": "jsummers/imageworsener/a4f247707f08e322f0b41e82c3e06e224240a654/imagew-main.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -25,13 +25,27 @@\n \tiw_tmpsample *out_pix = NULL;\n \tint num_in_pix;\n \tint num_out_pix;\n+\tstruct iw_channelinfo_out default_ci_out;\n \n \tnum_in_pix = ctx->intermed_canvas_width;\n \tnum_out_pix = ctx->img2.width;\n \n \tint_ci = &ctx->intermed_ci[intermed_channel];\n \toutput_channel = int_ci->corresponding_output_channel;\n-\tout_ci = &ctx->img2_ci[output_channel];\n+\tif(output_channel>=0) {\n+\t\tout_ci = &ctx->img2_ci[output_channel];\n+\t}\n+\telse {\n+\t\t// If there is no output channelinfo struct, create a temporary one to\n+\t\t// use.\n+\t\t// TODO: This is admittedly ugly, but we use these settings for a few\n+\t\t// things even when there is no corresponding output channel, and I\n+\t\t// don't remember exactly why.\n+\t\tiw_zeromem(&default_ci_out, sizeof(struct iw_channelinfo_out));\n+\t\tdefault_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;\n+\t\tout_ci = &default_ci_out;\n+\t}\n+\n \tis_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);\n \tbkgd_has_transparency = iw_bkgd_has_transparency(ctx);\n ",
    "diff_line_info": {
        "deleted_lines": [
            "\tout_ci = &ctx->img2_ci[output_channel];"
        ],
        "added_lines": [
            "\tstruct iw_channelinfo_out default_ci_out;",
            "\tif(output_channel>=0) {",
            "\t\tout_ci = &ctx->img2_ci[output_channel];",
            "\t}",
            "\telse {",
            "\t\t// If there is no output channelinfo struct, create a temporary one to",
            "\t\t// use.",
            "\t\t// TODO: This is admittedly ugly, but we use these settings for a few",
            "\t\t// things even when there is no corresponding output channel, and I",
            "\t\t// don't remember exactly why.",
            "\t\tiw_zeromem(&default_ci_out, sizeof(struct iw_channelinfo_out));",
            "\t\tdefault_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;",
            "\t\tout_ci = &default_ci_out;",
            "\t}",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}