{
    "cve_id": "CVE-2014-9421",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:N/AC:L/Au:S/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "krb5",
    "commit_msg": "Fix kadm5/gssrpc XDR double free [CVE-2014-9421]\n\n[MITKRB5-SA-2015-001] In auth_gssapi_unwrap_data(), do not free\npartial deserialization results upon failure to deserialize.  This\nresponsibility belongs to the callers, svctcp_getargs() and\nsvcudp_getargs(); doing it in the unwrap function results in freeing\nthe results twice.\n\nIn xdr_krb5_tl_data() and xdr_krb5_principal(), null out the pointers\nwe are freeing, as other XDR functions such as xdr_bytes() and\nxdr_string().\n\nticket: 8056 (new)\ntarget_version: 1.13.1\ntags: pullup",
    "commit_hash": "a197e92349a4aa2141b5dff12e9dd44c2a2166e3",
    "git_url": "https://github.com/krb5/krb5/commit/a197e92349a4aa2141b5dff12e9dd44c2a2166e3",
    "file_path": "src/lib/kadm5/kadm_rpc_xdr.c",
    "func_name": "xdr_krb5_tl_data",
    "func_before": "bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  break;\n\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}",
    "abstract_func_before": "bool_t xdr_krb5_tl_data(XDR *VAR_0, krb5_tl_data **VAR_1)\n{\n     krb5_tl_data *VAR_2, *VAR_3;\n     bool_t VAR_4;\n     unsigned int VAR_5;\n\n     switch (VAR_0->x_op) {\n     case VAR_6:\n\t  VAR_2 = VAR_3 = *VAR_1;\n\t  while (VAR_2) {\n\t       VAR_3 = VAR_2->tl_data_next;\n\t       free(VAR_2->tl_data_contents);\n\t       free(VAR_2);\n\t       VAR_2 = VAR_3;\n\t  }\n\t  break;\n\n     case VAR_7:\n\t  VAR_2 = *VAR_1;\n\t  while (1) {\n\t       VAR_4 = (VAR_2 != NULL);\n\t       if (!xdr_bool(VAR_0, &VAR_4))\n\t\t    return FALSE;\n\t       if (VAR_2 == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(VAR_0, &VAR_2->tl_data_type))\n\t\t    return FALSE;\n\t       VAR_5 = VAR_2->tl_data_length;\n\t       if (!xdr_bytes(VAR_0, (char **) &VAR_2->tl_data_contents, &VAR_5, ~0))\n\t\t    return FALSE;\n\t       VAR_2 = VAR_2->tl_data_next;\n\t  }\n\t  break;\n\n     case VAR_8:\n\t  VAR_2 = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(VAR_0, &VAR_4))\n\t\t    return FALSE;\n\t       if (VAR_4 == FALSE)\n\t\t    break;\n\t       VAR_3 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (VAR_3 == NULL)\n\t\t    return FALSE;\n\t       memset(VAR_3, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(VAR_0, &VAR_3->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(VAR_0, (char **)&VAR_3->tl_data_contents, &VAR_5, ~0))\n\t\t    return FALSE;\n\t       VAR_3->tl_data_length = VAR_5;\n\n\t       VAR_3->tl_data_next = VAR_2;\n\t       VAR_2 = VAR_3;\n\t  }\n\n\t  *VAR_1 = VAR_2;\n\t  break;\n     }\n\n     return TRUE;\n}",
    "func_graph_path_before": "krb5/a197e92349a4aa2141b5dff12e9dd44c2a2166e3/kadm_rpc_xdr.c/vul/before/1.json",
    "func": "bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}",
    "abstract_func": "bool_t xdr_krb5_tl_data(XDR *VAR_0, krb5_tl_data **VAR_1)\n{\n     krb5_tl_data *VAR_2, *VAR_3;\n     bool_t VAR_4;\n     unsigned int VAR_5;\n\n     switch (VAR_0->x_op) {\n     case VAR_6:\n\t  VAR_2 = VAR_3 = *VAR_1;\n\t  while (VAR_2) {\n\t       VAR_3 = VAR_2->tl_data_next;\n\t       free(VAR_2->tl_data_contents);\n\t       free(VAR_2);\n\t       VAR_2 = VAR_3;\n\t  }\n\t  *VAR_1 = NULL;\n\t  break;\n\n     case VAR_7:\n\t  VAR_2 = *VAR_1;\n\t  while (1) {\n\t       VAR_4 = (VAR_2 != NULL);\n\t       if (!xdr_bool(VAR_0, &VAR_4))\n\t\t    return FALSE;\n\t       if (VAR_2 == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(VAR_0, &VAR_2->tl_data_type))\n\t\t    return FALSE;\n\t       VAR_5 = VAR_2->tl_data_length;\n\t       if (!xdr_bytes(VAR_0, (char **) &VAR_2->tl_data_contents, &VAR_5, ~0))\n\t\t    return FALSE;\n\t       VAR_2 = VAR_2->tl_data_next;\n\t  }\n\t  break;\n\n     case VAR_8:\n\t  VAR_2 = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(VAR_0, &VAR_4))\n\t\t    return FALSE;\n\t       if (VAR_4 == FALSE)\n\t\t    break;\n\t       VAR_3 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (VAR_3 == NULL)\n\t\t    return FALSE;\n\t       memset(VAR_3, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(VAR_0, &VAR_3->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(VAR_0, (char **)&VAR_3->tl_data_contents, &VAR_5, ~0))\n\t\t    return FALSE;\n\t       VAR_3->tl_data_length = VAR_5;\n\n\t       VAR_3->tl_data_next = VAR_2;\n\t       VAR_2 = VAR_3;\n\t  }\n\n\t  *VAR_1 = VAR_2;\n\t  break;\n     }\n\n     return TRUE;\n}",
    "func_graph_path": "krb5/a197e92349a4aa2141b5dff12e9dd44c2a2166e3/kadm_rpc_xdr.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \t       free(tl);\n \t       tl = tl2;\n \t  }\n+\t  *tl_data_head = NULL;\n \t  break;\n \n      case XDR_ENCODE:",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t  *tl_data_head = NULL;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}