{
    "cve_id": "CVE-2018-6191",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "ArtifexSoftware/mujs",
    "commit_msg": "Fix 698920: Guard jsdtoa from integer overflow wreaking havoc.",
    "commit_hash": "25821e6d74fab5fcc200fe5e818362e03e114428",
    "git_url": "https://github.com/ArtifexSoftware/mujs/commit/25821e6d74fab5fcc200fe5e818362e03e114428",
    "file_path": "jsdtoa.c",
    "func_name": "js_strtod",
    "func_before": "double\njs_strtod(const char *string, char **endPtr)\n{\n\tint sign, expSign = FALSE;\n\tdouble fraction, dblExp, *d;\n\tregister const char *p;\n\tregister int c;\n\n\t/* Exponent read from \"EX\" field. */\n\tint exp = 0;\n\n\t/* Exponent that derives from the fractional part. Under normal\n\t * circumstances, it is the negative of the number of digits in F.\n\t * However, if I is very long, the last digits of I get dropped\n\t * (otherwise a long I with a large negative exponent could cause an\n\t * unnecessary overflow on I alone). In this case, fracExp is\n\t * incremented one for each dropped digit.\n\t */\n\tint fracExp = 0;\n\n\t/* Number of digits in mantissa. */\n\tint mantSize;\n\n\t/* Number of mantissa digits BEFORE decimal point. */\n\tint decPt;\n\n\t/* Temporarily holds location of exponent in string. */\n\tconst char *pExp;\n\n\t/*\n\t * Strip off leading blanks and check for a sign.\n\t */\n\n\tp = string;\n\twhile (*p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r') {\n\t\tp += 1;\n\t}\n\tif (*p == '-') {\n\t\tsign = TRUE;\n\t\tp += 1;\n\t} else {\n\t\tif (*p == '+') {\n\t\t\tp += 1;\n\t\t}\n\t\tsign = FALSE;\n\t}\n\n\t/*\n\t * Count the number of digits in the mantissa (including the decimal\n\t * point), and also locate the decimal point.\n\t */\n\n\tdecPt = -1;\n\tfor (mantSize = 0; ; mantSize += 1)\n\t{\n\t\tc = *p;\n\t\tif (!(c>='0'&&c<='9')) {\n\t\t\tif ((c != '.') || (decPt >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecPt = mantSize;\n\t\t}\n\t\tp += 1;\n\t}\n\n\t/*\n\t * Now suck up the digits in the mantissa. Use two integers to\n\t * collect 9 digits each (this is faster than using floating-point).\n\t * If the mantissa has more than 18 digits, ignore the extras, since\n\t * they can't affect the value anyway.\n\t */\n\n\tpExp = p;\n\tp -= mantSize;\n\tif (decPt < 0) {\n\t\tdecPt = mantSize;\n\t} else {\n\t\tmantSize -= 1;\t\t\t/* One of the digits was the point. */\n\t}\n\tif (mantSize > 18) {\n\t\tfracExp = decPt - 18;\n\t\tmantSize = 18;\n\t} else {\n\t\tfracExp = decPt - mantSize;\n\t}\n\tif (mantSize == 0) {\n\t\tfraction = 0.0;\n\t\tp = string;\n\t\tgoto done;\n\t} else {\n\t\tint frac1, frac2;\n\t\tfrac1 = 0;\n\t\tfor ( ; mantSize > 9; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac1 = 10*frac1 + (c - '0');\n\t\t}\n\t\tfrac2 = 0;\n\t\tfor (; mantSize > 0; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac2 = 10*frac2 + (c - '0');\n\t\t}\n\t\tfraction = (1.0e9 * frac1) + frac2;\n\t}\n\n\t/*\n\t * Skim off the exponent.\n\t */\n\n\tp = pExp;\n\tif ((*p == 'E') || (*p == 'e')) {\n\t\tp += 1;\n\t\tif (*p == '-') {\n\t\t\texpSign = TRUE;\n\t\t\tp += 1;\n\t\t} else {\n\t\t\tif (*p == '+') {\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\texpSign = FALSE;\n\t\t}\n\t\twhile ((*p >= '0') && (*p <= '9')) {\n\t\t\texp = exp * 10 + (*p - '0');\n\t\t\tp += 1;\n\t\t}\n\t}\n\tif (expSign) {\n\t\texp = fracExp - exp;\n\t} else {\n\t\texp = fracExp + exp;\n\t}\n\n\t/*\n\t * Generate a floating-point number that represents the exponent.\n\t * Do this by processing the exponent one bit at a time to combine\n\t * many powers of 2 of 10. Then combine the exponent with the\n\t * fraction.\n\t */\n\n\tif (exp < 0) {\n\t\texpSign = TRUE;\n\t\texp = -exp;\n\t} else {\n\t\texpSign = FALSE;\n\t}\n\tif (exp > maxExponent) {\n\t\texp = maxExponent;\n\t\terrno = ERANGE;\n\t}\n\tdblExp = 1.0;\n\tfor (d = powersOf10; exp != 0; exp >>= 1, d += 1) {\n\t\tif (exp & 01) {\n\t\t\tdblExp *= *d;\n\t\t}\n\t}\n\tif (expSign) {\n\t\tfraction /= dblExp;\n\t} else {\n\t\tfraction *= dblExp;\n\t}\n\ndone:\n\tif (endPtr != NULL) {\n\t\t*endPtr = (char *) p;\n\t}\n\n\tif (sign) {\n\t\treturn -fraction;\n\t}\n\treturn fraction;\n}",
    "abstract_func_before": "double\njs_strtod(const char *VAR_0, char **VAR_1)\n{\n\tint VAR_2, VAR_3 = FALSE;\n\tdouble VAR_4, VAR_5, *VAR_6;\n\tregister const char *VAR_7;\n\tregister int VAR_8;\n\n\t/* COMMENT_0 */\n\tint VAR_9 = 0;\n\n\t/* COMMENT_1 */\n                                                                   \n                                                                \n                                                                     \n                                                              \n                                           \n    \n\tint VAR_10 = 0;\n\n\t/* COMMENT_8 */\n\tint VAR_11;\n\n\t/* COMMENT_9 */\n\tint VAR_12;\n\n\t/* COMMENT_10 */\n\tconst char *VAR_13;\n\n\t/* COMMENT_11 */\n                                                  \n    \n\n\tVAR_7 = VAR_0;\n\twhile (*VAR_7 == ' ' || *VAR_7 == '\\t' || *VAR_7 == '\\n' || *VAR_7 == '\\r') {\n\t\tVAR_7 += 1;\n\t}\n\tif (*VAR_7 == '-') {\n\t\tVAR_2 = TRUE;\n\t\tVAR_7 += 1;\n\t} else {\n\t\tif (*VAR_7 == '+') {\n\t\t\tVAR_7 += 1;\n\t\t}\n\t\tVAR_2 = FALSE;\n\t}\n\n\t/* COMMENT_14 */\n                                                                     \n                                              \n    \n\n\tVAR_12 = -1;\n\tfor (VAR_11 = 0; ; VAR_11 += 1)\n\t{\n\t\tVAR_8 = *VAR_7;\n\t\tif (!(VAR_8>='0'&&VAR_8<='9')) {\n\t\t\tif ((VAR_8 != '.') || (VAR_12 >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_12 = VAR_11;\n\t\t}\n\t\tVAR_7 += 1;\n\t}\n\n\t/* COMMENT_18 */\n                                                               \n                                                                     \n                                                                     \n                                       \n    \n\n\tVAR_13 = VAR_7;\n\tVAR_7 -= VAR_11;\n\tif (VAR_12 < 0) {\n\t\tVAR_12 = VAR_11;\n\t} else {\n\t\tVAR_11 -= 1;\t\t\t/* COMMENT_24 */\n\t}\n\tif (VAR_11 > 18) {\n\t\tVAR_10 = VAR_12 - 18;\n\t\tVAR_11 = 18;\n\t} else {\n\t\tVAR_10 = VAR_12 - VAR_11;\n\t}\n\tif (VAR_11 == 0) {\n\t\tVAR_4 = 0.0;\n\t\tVAR_7 = VAR_0;\n\t\tgoto done;\n\t} else {\n\t\tint VAR_14, VAR_15;\n\t\tVAR_14 = 0;\n\t\tfor ( ; VAR_11 > 9; VAR_11 -= 1)\n\t\t{\n\t\t\tVAR_8 = *VAR_7;\n\t\t\tVAR_7 += 1;\n\t\t\tif (VAR_8 == '.') {\n\t\t\t\tVAR_8 = *VAR_7;\n\t\t\t\tVAR_7 += 1;\n\t\t\t}\n\t\t\tVAR_14 = 10*VAR_14 + (VAR_8 - '0');\n\t\t}\n\t\tVAR_15 = 0;\n\t\tfor (; VAR_11 > 0; VAR_11 -= 1)\n\t\t{\n\t\t\tVAR_8 = *VAR_7;\n\t\t\tVAR_7 += 1;\n\t\t\tif (VAR_8 == '.') {\n\t\t\t\tVAR_8 = *VAR_7;\n\t\t\t\tVAR_7 += 1;\n\t\t\t}\n\t\t\tVAR_15 = 10*VAR_15 + (VAR_8 - '0');\n\t\t}\n\t\tVAR_4 = (1.0e9 * VAR_14) + VAR_15;\n\t}\n\n\t/* COMMENT_25 */\n                          \n    \n\n\tVAR_7 = VAR_13;\n\tif ((*VAR_7 == 'E') || (*VAR_7 == 'e')) {\n\t\tVAR_7 += 1;\n\t\tif (*VAR_7 == '-') {\n\t\t\tVAR_3 = TRUE;\n\t\t\tVAR_7 += 1;\n\t\t} else {\n\t\t\tif (*VAR_7 == '+') {\n\t\t\t\tVAR_7 += 1;\n\t\t\t}\n\t\t\tVAR_3 = FALSE;\n\t\t}\n\t\twhile ((*VAR_7 >= '0') && (*VAR_7 <= '9')) {\n\t\t\tVAR_9 = VAR_9 * 10 + (*VAR_7 - '0');\n\t\t\tVAR_7 += 1;\n\t\t}\n\t}\n\tif (VAR_3) {\n\t\tVAR_9 = VAR_10 - VAR_9;\n\t} else {\n\t\tVAR_9 = VAR_10 + VAR_9;\n\t}\n\n\t/* COMMENT_28 */\n                                                                  \n                                                                   \n                                                              \n             \n    \n\n\tif (VAR_9 < 0) {\n\t\tVAR_3 = TRUE;\n\t\tVAR_9 = -VAR_9;\n\t} else {\n\t\tVAR_3 = FALSE;\n\t}\n\tif (VAR_9 > VAR_16) {\n\t\tVAR_9 = VAR_16;\n\t\tVAR_17 = VAR_18;\n\t}\n\tVAR_5 = 1.0;\n\tfor (VAR_6 = VAR_19; VAR_9 != 0; VAR_9 >>= 1, VAR_6 += 1) {\n\t\tif (VAR_9 & 01) {\n\t\t\tVAR_5 *= *VAR_6;\n\t\t}\n\t}\n\tif (VAR_3) {\n\t\tVAR_4 /= VAR_5;\n\t} else {\n\t\tVAR_4 *= VAR_5;\n\t}\n\ndone:\n\tif (VAR_1 != NULL) {\n\t\t*VAR_1 = (char *) VAR_7;\n\t}\n\n\tif (VAR_2) {\n\t\treturn -VAR_4;\n\t}\n\treturn VAR_4;\n}",
    "func_graph_path_before": "ArtifexSoftware/mujs/25821e6d74fab5fcc200fe5e818362e03e114428/jsdtoa.c/vul/before/0.json",
    "func": "double\njs_strtod(const char *string, char **endPtr)\n{\n\tint sign, expSign = FALSE;\n\tdouble fraction, dblExp, *d;\n\tregister const char *p;\n\tregister int c;\n\n\t/* Exponent read from \"EX\" field. */\n\tint exp = 0;\n\n\t/* Exponent that derives from the fractional part. Under normal\n\t * circumstances, it is the negative of the number of digits in F.\n\t * However, if I is very long, the last digits of I get dropped\n\t * (otherwise a long I with a large negative exponent could cause an\n\t * unnecessary overflow on I alone). In this case, fracExp is\n\t * incremented one for each dropped digit.\n\t */\n\tint fracExp = 0;\n\n\t/* Number of digits in mantissa. */\n\tint mantSize;\n\n\t/* Number of mantissa digits BEFORE decimal point. */\n\tint decPt;\n\n\t/* Temporarily holds location of exponent in string. */\n\tconst char *pExp;\n\n\t/*\n\t * Strip off leading blanks and check for a sign.\n\t */\n\n\tp = string;\n\twhile (*p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r') {\n\t\tp += 1;\n\t}\n\tif (*p == '-') {\n\t\tsign = TRUE;\n\t\tp += 1;\n\t} else {\n\t\tif (*p == '+') {\n\t\t\tp += 1;\n\t\t}\n\t\tsign = FALSE;\n\t}\n\n\t/*\n\t * Count the number of digits in the mantissa (including the decimal\n\t * point), and also locate the decimal point.\n\t */\n\n\tdecPt = -1;\n\tfor (mantSize = 0; ; mantSize += 1)\n\t{\n\t\tc = *p;\n\t\tif (!(c>='0'&&c<='9')) {\n\t\t\tif ((c != '.') || (decPt >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecPt = mantSize;\n\t\t}\n\t\tp += 1;\n\t}\n\n\t/*\n\t * Now suck up the digits in the mantissa. Use two integers to\n\t * collect 9 digits each (this is faster than using floating-point).\n\t * If the mantissa has more than 18 digits, ignore the extras, since\n\t * they can't affect the value anyway.\n\t */\n\n\tpExp = p;\n\tp -= mantSize;\n\tif (decPt < 0) {\n\t\tdecPt = mantSize;\n\t} else {\n\t\tmantSize -= 1;\t\t\t/* One of the digits was the point. */\n\t}\n\tif (mantSize > 18) {\n\t\tfracExp = decPt - 18;\n\t\tmantSize = 18;\n\t} else {\n\t\tfracExp = decPt - mantSize;\n\t}\n\tif (mantSize == 0) {\n\t\tfraction = 0.0;\n\t\tp = string;\n\t\tgoto done;\n\t} else {\n\t\tint frac1, frac2;\n\t\tfrac1 = 0;\n\t\tfor ( ; mantSize > 9; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac1 = 10*frac1 + (c - '0');\n\t\t}\n\t\tfrac2 = 0;\n\t\tfor (; mantSize > 0; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac2 = 10*frac2 + (c - '0');\n\t\t}\n\t\tfraction = (1.0e9 * frac1) + frac2;\n\t}\n\n\t/*\n\t * Skim off the exponent.\n\t */\n\n\tp = pExp;\n\tif ((*p == 'E') || (*p == 'e')) {\n\t\tp += 1;\n\t\tif (*p == '-') {\n\t\t\texpSign = TRUE;\n\t\t\tp += 1;\n\t\t} else {\n\t\t\tif (*p == '+') {\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\texpSign = FALSE;\n\t\t}\n\t\twhile ((*p >= '0') && (*p <= '9')) {\n\t\t\texp = exp * 10 + (*p - '0');\n\t\t\tp += 1;\n\t\t}\n\t}\n\tif (expSign) {\n\t\texp = fracExp - exp;\n\t} else {\n\t\texp = fracExp + exp;\n\t}\n\n\t/*\n\t * Generate a floating-point number that represents the exponent.\n\t * Do this by processing the exponent one bit at a time to combine\n\t * many powers of 2 of 10. Then combine the exponent with the\n\t * fraction.\n\t */\n\n\tif (exp < -maxExponent) {\n\t\texp = maxExponent;\n\t\texpSign = TRUE;\n\t\terrno = ERANGE;\n\t} else if (exp > maxExponent) {\n\t\texp = maxExponent;\n\t\texpSign = FALSE;\n\t\terrno = ERANGE;\n\t} else if (exp < 0) {\n\t\texpSign = TRUE;\n\t\texp = -exp;\n\t} else {\n\t\texpSign = FALSE;\n\t}\n\tdblExp = 1.0;\n\tfor (d = powersOf10; exp != 0; exp >>= 1, d += 1) {\n\t\tif (exp & 01) {\n\t\t\tdblExp *= *d;\n\t\t}\n\t}\n\tif (expSign) {\n\t\tfraction /= dblExp;\n\t} else {\n\t\tfraction *= dblExp;\n\t}\n\ndone:\n\tif (endPtr != NULL) {\n\t\t*endPtr = (char *) p;\n\t}\n\n\tif (sign) {\n\t\treturn -fraction;\n\t}\n\treturn fraction;\n}",
    "abstract_func": "double\njs_strtod(const char *VAR_0, char **VAR_1)\n{\n\tint VAR_2, VAR_3 = FALSE;\n\tdouble VAR_4, VAR_5, *VAR_6;\n\tregister const char *VAR_7;\n\tregister int VAR_8;\n\n\t/* COMMENT_0 */\n\tint VAR_9 = 0;\n\n\t/* COMMENT_1 */\n                                                                   \n                                                                \n                                                                     \n                                                              \n                                           \n    \n\tint VAR_10 = 0;\n\n\t/* COMMENT_8 */\n\tint VAR_11;\n\n\t/* COMMENT_9 */\n\tint VAR_12;\n\n\t/* COMMENT_10 */\n\tconst char *VAR_13;\n\n\t/* COMMENT_11 */\n                                                  \n    \n\n\tVAR_7 = VAR_0;\n\twhile (*VAR_7 == ' ' || *VAR_7 == '\\t' || *VAR_7 == '\\n' || *VAR_7 == '\\r') {\n\t\tVAR_7 += 1;\n\t}\n\tif (*VAR_7 == '-') {\n\t\tVAR_2 = TRUE;\n\t\tVAR_7 += 1;\n\t} else {\n\t\tif (*VAR_7 == '+') {\n\t\t\tVAR_7 += 1;\n\t\t}\n\t\tVAR_2 = FALSE;\n\t}\n\n\t/* COMMENT_14 */\n                                                                     \n                                              \n    \n\n\tVAR_12 = -1;\n\tfor (VAR_11 = 0; ; VAR_11 += 1)\n\t{\n\t\tVAR_8 = *VAR_7;\n\t\tif (!(VAR_8>='0'&&VAR_8<='9')) {\n\t\t\tif ((VAR_8 != '.') || (VAR_12 >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_12 = VAR_11;\n\t\t}\n\t\tVAR_7 += 1;\n\t}\n\n\t/* COMMENT_18 */\n                                                               \n                                                                     \n                                                                     \n                                       \n    \n\n\tVAR_13 = VAR_7;\n\tVAR_7 -= VAR_11;\n\tif (VAR_12 < 0) {\n\t\tVAR_12 = VAR_11;\n\t} else {\n\t\tVAR_11 -= 1;\t\t\t/* COMMENT_24 */\n\t}\n\tif (VAR_11 > 18) {\n\t\tVAR_10 = VAR_12 - 18;\n\t\tVAR_11 = 18;\n\t} else {\n\t\tVAR_10 = VAR_12 - VAR_11;\n\t}\n\tif (VAR_11 == 0) {\n\t\tVAR_4 = 0.0;\n\t\tVAR_7 = VAR_0;\n\t\tgoto done;\n\t} else {\n\t\tint VAR_14, VAR_15;\n\t\tVAR_14 = 0;\n\t\tfor ( ; VAR_11 > 9; VAR_11 -= 1)\n\t\t{\n\t\t\tVAR_8 = *VAR_7;\n\t\t\tVAR_7 += 1;\n\t\t\tif (VAR_8 == '.') {\n\t\t\t\tVAR_8 = *VAR_7;\n\t\t\t\tVAR_7 += 1;\n\t\t\t}\n\t\t\tVAR_14 = 10*VAR_14 + (VAR_8 - '0');\n\t\t}\n\t\tVAR_15 = 0;\n\t\tfor (; VAR_11 > 0; VAR_11 -= 1)\n\t\t{\n\t\t\tVAR_8 = *VAR_7;\n\t\t\tVAR_7 += 1;\n\t\t\tif (VAR_8 == '.') {\n\t\t\t\tVAR_8 = *VAR_7;\n\t\t\t\tVAR_7 += 1;\n\t\t\t}\n\t\t\tVAR_15 = 10*VAR_15 + (VAR_8 - '0');\n\t\t}\n\t\tVAR_4 = (1.0e9 * VAR_14) + VAR_15;\n\t}\n\n\t/* COMMENT_25 */\n                          \n    \n\n\tVAR_7 = VAR_13;\n\tif ((*VAR_7 == 'E') || (*VAR_7 == 'e')) {\n\t\tVAR_7 += 1;\n\t\tif (*VAR_7 == '-') {\n\t\t\tVAR_3 = TRUE;\n\t\t\tVAR_7 += 1;\n\t\t} else {\n\t\t\tif (*VAR_7 == '+') {\n\t\t\t\tVAR_7 += 1;\n\t\t\t}\n\t\t\tVAR_3 = FALSE;\n\t\t}\n\t\twhile ((*VAR_7 >= '0') && (*VAR_7 <= '9')) {\n\t\t\tVAR_9 = VAR_9 * 10 + (*VAR_7 - '0');\n\t\t\tVAR_7 += 1;\n\t\t}\n\t}\n\tif (VAR_3) {\n\t\tVAR_9 = VAR_10 - VAR_9;\n\t} else {\n\t\tVAR_9 = VAR_10 + VAR_9;\n\t}\n\n\t/* COMMENT_28 */\n                                                                  \n                                                                   \n                                                              \n             \n    \n\n\tif (VAR_9 < -VAR_16) {\n\t\tVAR_9 = VAR_16;\n\t\tVAR_3 = TRUE;\n\t\tVAR_17 = VAR_18;\n\t} else if (VAR_9 > VAR_16) {\n\t\tVAR_9 = VAR_16;\n\t\tVAR_3 = FALSE;\n\t\tVAR_17 = VAR_18;\n\t} else if (VAR_9 < 0) {\n\t\tVAR_3 = TRUE;\n\t\tVAR_9 = -VAR_9;\n\t} else {\n\t\tVAR_3 = FALSE;\n\t}\n\tVAR_5 = 1.0;\n\tfor (VAR_6 = VAR_19; VAR_9 != 0; VAR_9 >>= 1, VAR_6 += 1) {\n\t\tif (VAR_9 & 01) {\n\t\t\tVAR_5 *= *VAR_6;\n\t\t}\n\t}\n\tif (VAR_3) {\n\t\tVAR_4 /= VAR_5;\n\t} else {\n\t\tVAR_4 *= VAR_5;\n\t}\n\ndone:\n\tif (VAR_1 != NULL) {\n\t\t*VAR_1 = (char *) VAR_7;\n\t}\n\n\tif (VAR_2) {\n\t\treturn -VAR_4;\n\t}\n\treturn VAR_4;\n}",
    "func_graph_path": "ArtifexSoftware/mujs/25821e6d74fab5fcc200fe5e818362e03e114428/jsdtoa.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -148,15 +148,19 @@\n \t * fraction.\n \t */\n \n-\tif (exp < 0) {\n+\tif (exp < -maxExponent) {\n+\t\texp = maxExponent;\n+\t\texpSign = TRUE;\n+\t\terrno = ERANGE;\n+\t} else if (exp > maxExponent) {\n+\t\texp = maxExponent;\n+\t\texpSign = FALSE;\n+\t\terrno = ERANGE;\n+\t} else if (exp < 0) {\n \t\texpSign = TRUE;\n \t\texp = -exp;\n \t} else {\n \t\texpSign = FALSE;\n-\t}\n-\tif (exp > maxExponent) {\n-\t\texp = maxExponent;\n-\t\terrno = ERANGE;\n \t}\n \tdblExp = 1.0;\n \tfor (d = powersOf10; exp != 0; exp >>= 1, d += 1) {",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (exp < 0) {",
            "\t}",
            "\tif (exp > maxExponent) {",
            "\t\texp = maxExponent;",
            "\t\terrno = ERANGE;"
        ],
        "added_lines": [
            "\tif (exp < -maxExponent) {",
            "\t\texp = maxExponent;",
            "\t\texpSign = TRUE;",
            "\t\terrno = ERANGE;",
            "\t} else if (exp > maxExponent) {",
            "\t\texp = maxExponent;",
            "\t\texpSign = FALSE;",
            "\t\terrno = ERANGE;",
            "\t} else if (exp < 0) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}