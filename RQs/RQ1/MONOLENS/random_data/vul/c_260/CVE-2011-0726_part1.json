{
    "cve_id": "CVE-2011-0726",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "While mm->start_stack was protected from cross-uid viewing (commit\nf83ce3e6b02d5 (\"proc: avoid information leaks to non-privileged\nprocesses\")), the start_code and end_code values were not.  This would\nallow the text location of a PIE binary to leak, defeating ASLR.\n\nNote that the value \"1\" is used instead of \"0\" for a protected value since\n\"ps\", \"killall\", and likely other readers of /proc/pid/stat, take\nstart_code of \"0\" to mean a kernel thread and will misbehave.  Thanks to\nBrad Spengler for pointing this out.\n\nAddresses CVE-2011-0726\n\nSigned-off-by: Kees Cook <kees.cook@canonical.com>\nCc: <stable@kernel.org>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: David Howells <dhowells@redhat.com>\nCc: Eugene Teo <eugeneteo@kernel.sg>\nCc: Martin Schwidefsky <schwidefsky@de.ibm.com>\nCc: Brad Spengler <spender@grsecurity.net>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n",
    "commit_hash": "5883f57ca0008ffc93e09cbb9847a1928e50c6f3",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=5883f57ca0008ffc93e09cbb9847a1928e50c6f3",
    "file_path": "fs/proc/array.c",
    "func_name": "do_task_stat",
    "func_before": "static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\tstruct pid *pid, struct task_struct *task, int whole)\n{\n\tunsigned long vsize, eip, esp, wchan = ~0UL;\n\tlong priority, nice;\n\tint tty_pgrp = -1, tty_nr = 0;\n\tsigset_t sigign, sigcatch;\n\tchar state;\n\tpid_t ppid = 0, pgid = -1, sid = -1;\n\tint num_threads = 0;\n\tint permitted;\n\tstruct mm_struct *mm;\n\tunsigned long long start_time;\n\tunsigned long cmin_flt = 0, cmaj_flt = 0;\n\tunsigned long  min_flt = 0,  maj_flt = 0;\n\tcputime_t cutime, cstime, utime, stime;\n\tcputime_t cgtime, gtime;\n\tunsigned long rsslim = 0;\n\tchar tcomm[sizeof(task->comm)];\n\tunsigned long flags;\n\n\tstate = *get_task_state(task);\n\tvsize = eip = esp = 0;\n\tpermitted = ptrace_may_access(task, PTRACE_MODE_READ);\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tvsize = task_vsize(mm);\n\t\tif (permitted) {\n\t\t\teip = KSTK_EIP(task);\n\t\t\tesp = KSTK_ESP(task);\n\t\t}\n\t}\n\n\tget_task_comm(tcomm, task);\n\n\tsigemptyset(&sigign);\n\tsigemptyset(&sigcatch);\n\tcutime = cstime = utime = stime = cputime_zero;\n\tcgtime = gtime = cputime_zero;\n\n\tif (lock_task_sighand(task, &flags)) {\n\t\tstruct signal_struct *sig = task->signal;\n\n\t\tif (sig->tty) {\n\t\t\tstruct pid *pgrp = tty_get_pgrp(sig->tty);\n\t\t\ttty_pgrp = pid_nr_ns(pgrp, ns);\n\t\t\tput_pid(pgrp);\n\t\t\ttty_nr = new_encode_dev(tty_devnum(sig->tty));\n\t\t}\n\n\t\tnum_threads = get_nr_threads(task);\n\t\tcollect_sigign_sigcatch(task, &sigign, &sigcatch);\n\n\t\tcmin_flt = sig->cmin_flt;\n\t\tcmaj_flt = sig->cmaj_flt;\n\t\tcutime = sig->cutime;\n\t\tcstime = sig->cstime;\n\t\tcgtime = sig->cgtime;\n\t\trsslim = ACCESS_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);\n\n\t\t/* add up live thread stats at the group level */\n\t\tif (whole) {\n\t\t\tstruct task_struct *t = task;\n\t\t\tdo {\n\t\t\t\tmin_flt += t->min_flt;\n\t\t\t\tmaj_flt += t->maj_flt;\n\t\t\t\tgtime = cputime_add(gtime, t->gtime);\n\t\t\t\tt = next_thread(t);\n\t\t\t} while (t != task);\n\n\t\t\tmin_flt += sig->min_flt;\n\t\t\tmaj_flt += sig->maj_flt;\n\t\t\tthread_group_times(task, &utime, &stime);\n\t\t\tgtime = cputime_add(gtime, sig->gtime);\n\t\t}\n\n\t\tsid = task_session_nr_ns(task, ns);\n\t\tppid = task_tgid_nr_ns(task->real_parent, ns);\n\t\tpgid = task_pgrp_nr_ns(task, ns);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\n\tif (permitted && (!whole || num_threads < 2))\n\t\twchan = get_wchan(task);\n\tif (!whole) {\n\t\tmin_flt = task->min_flt;\n\t\tmaj_flt = task->maj_flt;\n\t\ttask_times(task, &utime, &stime);\n\t\tgtime = task->gtime;\n\t}\n\n\t/* scale priority and nice values from timeslices to -20..20 */\n\t/* to make it look like a \"normal\" Unix priority/nice value  */\n\tpriority = task_prio(task);\n\tnice = task_nice(task);\n\n\t/* Temporary variable needed for gcc-2.96 */\n\t/* convert timespec -> nsec*/\n\tstart_time =\n\t\t(unsigned long long)task->real_start_time.tv_sec * NSEC_PER_SEC\n\t\t\t\t+ task->real_start_time.tv_nsec;\n\t/* convert nsec -> ticks */\n\tstart_time = nsec_to_clock_t(start_time);\n\n\tseq_printf(m, \"%d (%s) %c %d %d %d %d %d %u %lu \\\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\\n\",\n\t\tpid_nr_ns(pid, ns),\n\t\ttcomm,\n\t\tstate,\n\t\tppid,\n\t\tpgid,\n\t\tsid,\n\t\ttty_nr,\n\t\ttty_pgrp,\n\t\ttask->flags,\n\t\tmin_flt,\n\t\tcmin_flt,\n\t\tmaj_flt,\n\t\tcmaj_flt,\n\t\tcputime_to_clock_t(utime),\n\t\tcputime_to_clock_t(stime),\n\t\tcputime_to_clock_t(cutime),\n\t\tcputime_to_clock_t(cstime),\n\t\tpriority,\n\t\tnice,\n\t\tnum_threads,\n\t\tstart_time,\n\t\tvsize,\n\t\tmm ? get_mm_rss(mm) : 0,\n\t\trsslim,\n\t\tmm ? mm->start_code : 0,\n\t\tmm ? mm->end_code : 0,\n\t\t(permitted && mm) ? mm->start_stack : 0,\n\t\tesp,\n\t\teip,\n\t\t/* The signal information here is obsolete.\n\t\t * It must be decimal for Linux 2.0 compatibility.\n\t\t * Use /proc/#/status for real-time signals.\n\t\t */\n\t\ttask->pending.signal.sig[0] & 0x7fffffffUL,\n\t\ttask->blocked.sig[0] & 0x7fffffffUL,\n\t\tsigign      .sig[0] & 0x7fffffffUL,\n\t\tsigcatch    .sig[0] & 0x7fffffffUL,\n\t\twchan,\n\t\t0UL,\n\t\t0UL,\n\t\ttask->exit_signal,\n\t\ttask_cpu(task),\n\t\ttask->rt_priority,\n\t\ttask->policy,\n\t\t(unsigned long long)delayacct_blkio_ticks(task),\n\t\tcputime_to_clock_t(gtime),\n\t\tcputime_to_clock_t(cgtime));\n\tif (mm)\n\t\tmmput(mm);\n\treturn 0;\n}",
    "abstract_func_before": "static int do_task_stat(struct seq_file *VAR_0, struct pid_namespace *VAR_1,\n\t\t\tstruct pid *pid, struct task_struct *VAR_2, int VAR_3)\n{\n\tunsigned long VAR_4, VAR_5, VAR_6, VAR_7 = ~0UL;\n\tlong VAR_8, VAR_9;\n\tint VAR_10 = -1, VAR_11 = 0;\n\tsigset_t VAR_12, VAR_13;\n\tchar VAR_14;\n\tpid_t VAR_15 = 0, VAR_16 = -1, VAR_17 = -1;\n\tint VAR_18 = 0;\n\tint VAR_19;\n\tstruct mm_struct *VAR_20;\n\tunsigned long long VAR_21;\n\tunsigned long VAR_22 = 0, VAR_23 = 0;\n\tunsigned long  VAR_24 = 0,  VAR_25 = 0;\n\tcputime_t VAR_26, VAR_27, VAR_28, VAR_29;\n\tcputime_t VAR_30, VAR_31;\n\tunsigned long VAR_32 = 0;\n\tchar VAR_33[sizeof(VAR_2->comm)];\n\tunsigned long VAR_34;\n\n\tVAR_14 = *get_task_state(VAR_2);\n\tVAR_4 = VAR_5 = VAR_6 = 0;\n\tVAR_19 = ptrace_may_access(VAR_2, VAR_35);\n\tVAR_20 = get_task_mm(VAR_2);\n\tif (VAR_20) {\n\t\tVAR_4 = task_vsize(VAR_20);\n\t\tif (VAR_19) {\n\t\t\tVAR_5 = KSTK_EIP(VAR_2);\n\t\t\tVAR_6 = KSTK_ESP(VAR_2);\n\t\t}\n\t}\n\n\tget_task_comm(VAR_33, VAR_2);\n\n\tsigemptyset(&VAR_12);\n\tsigemptyset(&VAR_13);\n\tVAR_26 = VAR_27 = VAR_28 = VAR_29 = VAR_36;\n\tVAR_30 = VAR_31 = VAR_36;\n\n\tif (lock_task_sighand(VAR_2, &VAR_34)) {\n\t\tstruct signal_struct *VAR_37 = VAR_2->signal;\n\n\t\tif (VAR_37->tty) {\n\t\t\tstruct pid *VAR_38 = tty_get_pgrp(VAR_37->tty);\n\t\t\tVAR_10 = pid_nr_ns(VAR_38, VAR_1);\n\t\t\tput_pid(VAR_38);\n\t\t\tVAR_11 = new_encode_dev(tty_devnum(VAR_37->tty));\n\t\t}\n\n\t\tVAR_18 = get_nr_threads(VAR_2);\n\t\tcollect_sigign_sigcatch(VAR_2, &VAR_12, &VAR_13);\n\n\t\tVAR_22 = VAR_37->cmin_flt;\n\t\tVAR_23 = VAR_37->cmaj_flt;\n\t\tVAR_26 = VAR_37->cutime;\n\t\tVAR_27 = VAR_37->cstime;\n\t\tVAR_30 = VAR_37->cgtime;\n\t\tVAR_32 = ACCESS_ONCE(VAR_37->rlim[VAR_39].rlim_cur);\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_3) {\n\t\t\tstruct task_struct *VAR_40 = VAR_2;\n\t\t\tdo {\n\t\t\t\tVAR_24 += VAR_40->min_flt;\n\t\t\t\tVAR_25 += VAR_40->maj_flt;\n\t\t\t\tVAR_31 = cputime_add(VAR_31, VAR_40->gtime);\n\t\t\t\tVAR_40 = next_thread(VAR_40);\n\t\t\t} while (VAR_40 != VAR_2);\n\n\t\t\tVAR_24 += VAR_37->min_flt;\n\t\t\tVAR_25 += VAR_37->maj_flt;\n\t\t\tthread_group_times(VAR_2, &VAR_28, &VAR_29);\n\t\t\tVAR_31 = cputime_add(VAR_31, VAR_37->gtime);\n\t\t}\n\n\t\tVAR_17 = task_session_nr_ns(VAR_2, VAR_1);\n\t\tVAR_15 = task_tgid_nr_ns(VAR_2->real_parent, VAR_1);\n\t\tVAR_16 = task_pgrp_nr_ns(VAR_2, VAR_1);\n\n\t\tunlock_task_sighand(VAR_2, &VAR_34);\n\t}\n\n\tif (VAR_19 && (!VAR_3 || VAR_18 < 2))\n\t\tVAR_7 = get_wchan(VAR_2);\n\tif (!VAR_3) {\n\t\tVAR_24 = VAR_2->min_flt;\n\t\tVAR_25 = VAR_2->maj_flt;\n\t\ttask_times(VAR_2, &VAR_28, &VAR_29);\n\t\tVAR_31 = VAR_2->gtime;\n\t}\n\n\t/* COMMENT_1 */\n\t/* COMMENT_2 */\n\tVAR_8 = task_prio(VAR_2);\n\tVAR_9 = task_nice(VAR_2);\n\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\tVAR_21 =\n\t\t(unsigned long long)VAR_2->real_start_time.tv_sec * VAR_41\n\t\t\t\t+ VAR_2->real_start_time.tv_nsec;\n\t/* COMMENT_5 */\n\tVAR_21 = nsec_to_clock_t(VAR_21);\n\n\tseq_printf(VAR_0, \"%d (%s) %c %d %d %d %d %d %u %lu \\\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\\n\",\n\t\tpid_nr_ns(pid, VAR_1),\n\t\tVAR_33,\n\t\tVAR_14,\n\t\tVAR_15,\n\t\tVAR_16,\n\t\tVAR_17,\n\t\tVAR_11,\n\t\tVAR_10,\n\t\tVAR_2->flags,\n\t\tVAR_24,\n\t\tVAR_22,\n\t\tVAR_25,\n\t\tVAR_23,\n\t\tcputime_to_clock_t(VAR_28),\n\t\tcputime_to_clock_t(VAR_29),\n\t\tcputime_to_clock_t(VAR_26),\n\t\tcputime_to_clock_t(VAR_27),\n\t\tVAR_8,\n\t\tVAR_9,\n\t\tVAR_18,\n\t\tVAR_21,\n\t\tVAR_4,\n\t\tVAR_20 ? get_mm_rss(VAR_20) : 0,\n\t\tVAR_32,\n\t\tVAR_20 ? VAR_20->start_code : 0,\n\t\tVAR_20 ? VAR_20->end_code : 0,\n\t\t(VAR_19 && VAR_20) ? VAR_20->start_stack : 0,\n\t\tVAR_6,\n\t\tVAR_5,\n\t\t/* COMMENT_6 */\n                                                    \n                                              \n     \n\t\tVAR_2->pending.signal.sig[0] & 0x7fffffffUL,\n\t\tVAR_2->blocked.sig[0] & 0x7fffffffUL,\n\t\tVAR_12      .sig[0] & 0x7fffffffUL,\n\t\tVAR_13    .sig[0] & 0x7fffffffUL,\n\t\tVAR_7,\n\t\t0UL,\n\t\t0UL,\n\t\tVAR_2->exit_signal,\n\t\ttask_cpu(VAR_2),\n\t\tVAR_2->rt_priority,\n\t\tVAR_2->policy,\n\t\t(unsigned long long)delayacct_blkio_ticks(VAR_2),\n\t\tcputime_to_clock_t(VAR_31),\n\t\tcputime_to_clock_t(VAR_30));\n\tif (VAR_20)\n\t\tmmput(VAR_20);\n\treturn 0;\n}",
    "func_graph_path_before": "torvalds/linux/5883f57ca0008ffc93e09cbb9847a1928e50c6f3/array.c/vul/before/0.json",
    "func": "static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\tstruct pid *pid, struct task_struct *task, int whole)\n{\n\tunsigned long vsize, eip, esp, wchan = ~0UL;\n\tlong priority, nice;\n\tint tty_pgrp = -1, tty_nr = 0;\n\tsigset_t sigign, sigcatch;\n\tchar state;\n\tpid_t ppid = 0, pgid = -1, sid = -1;\n\tint num_threads = 0;\n\tint permitted;\n\tstruct mm_struct *mm;\n\tunsigned long long start_time;\n\tunsigned long cmin_flt = 0, cmaj_flt = 0;\n\tunsigned long  min_flt = 0,  maj_flt = 0;\n\tcputime_t cutime, cstime, utime, stime;\n\tcputime_t cgtime, gtime;\n\tunsigned long rsslim = 0;\n\tchar tcomm[sizeof(task->comm)];\n\tunsigned long flags;\n\n\tstate = *get_task_state(task);\n\tvsize = eip = esp = 0;\n\tpermitted = ptrace_may_access(task, PTRACE_MODE_READ);\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tvsize = task_vsize(mm);\n\t\tif (permitted) {\n\t\t\teip = KSTK_EIP(task);\n\t\t\tesp = KSTK_ESP(task);\n\t\t}\n\t}\n\n\tget_task_comm(tcomm, task);\n\n\tsigemptyset(&sigign);\n\tsigemptyset(&sigcatch);\n\tcutime = cstime = utime = stime = cputime_zero;\n\tcgtime = gtime = cputime_zero;\n\n\tif (lock_task_sighand(task, &flags)) {\n\t\tstruct signal_struct *sig = task->signal;\n\n\t\tif (sig->tty) {\n\t\t\tstruct pid *pgrp = tty_get_pgrp(sig->tty);\n\t\t\ttty_pgrp = pid_nr_ns(pgrp, ns);\n\t\t\tput_pid(pgrp);\n\t\t\ttty_nr = new_encode_dev(tty_devnum(sig->tty));\n\t\t}\n\n\t\tnum_threads = get_nr_threads(task);\n\t\tcollect_sigign_sigcatch(task, &sigign, &sigcatch);\n\n\t\tcmin_flt = sig->cmin_flt;\n\t\tcmaj_flt = sig->cmaj_flt;\n\t\tcutime = sig->cutime;\n\t\tcstime = sig->cstime;\n\t\tcgtime = sig->cgtime;\n\t\trsslim = ACCESS_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);\n\n\t\t/* add up live thread stats at the group level */\n\t\tif (whole) {\n\t\t\tstruct task_struct *t = task;\n\t\t\tdo {\n\t\t\t\tmin_flt += t->min_flt;\n\t\t\t\tmaj_flt += t->maj_flt;\n\t\t\t\tgtime = cputime_add(gtime, t->gtime);\n\t\t\t\tt = next_thread(t);\n\t\t\t} while (t != task);\n\n\t\t\tmin_flt += sig->min_flt;\n\t\t\tmaj_flt += sig->maj_flt;\n\t\t\tthread_group_times(task, &utime, &stime);\n\t\t\tgtime = cputime_add(gtime, sig->gtime);\n\t\t}\n\n\t\tsid = task_session_nr_ns(task, ns);\n\t\tppid = task_tgid_nr_ns(task->real_parent, ns);\n\t\tpgid = task_pgrp_nr_ns(task, ns);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\n\tif (permitted && (!whole || num_threads < 2))\n\t\twchan = get_wchan(task);\n\tif (!whole) {\n\t\tmin_flt = task->min_flt;\n\t\tmaj_flt = task->maj_flt;\n\t\ttask_times(task, &utime, &stime);\n\t\tgtime = task->gtime;\n\t}\n\n\t/* scale priority and nice values from timeslices to -20..20 */\n\t/* to make it look like a \"normal\" Unix priority/nice value  */\n\tpriority = task_prio(task);\n\tnice = task_nice(task);\n\n\t/* Temporary variable needed for gcc-2.96 */\n\t/* convert timespec -> nsec*/\n\tstart_time =\n\t\t(unsigned long long)task->real_start_time.tv_sec * NSEC_PER_SEC\n\t\t\t\t+ task->real_start_time.tv_nsec;\n\t/* convert nsec -> ticks */\n\tstart_time = nsec_to_clock_t(start_time);\n\n\tseq_printf(m, \"%d (%s) %c %d %d %d %d %d %u %lu \\\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\\n\",\n\t\tpid_nr_ns(pid, ns),\n\t\ttcomm,\n\t\tstate,\n\t\tppid,\n\t\tpgid,\n\t\tsid,\n\t\ttty_nr,\n\t\ttty_pgrp,\n\t\ttask->flags,\n\t\tmin_flt,\n\t\tcmin_flt,\n\t\tmaj_flt,\n\t\tcmaj_flt,\n\t\tcputime_to_clock_t(utime),\n\t\tcputime_to_clock_t(stime),\n\t\tcputime_to_clock_t(cutime),\n\t\tcputime_to_clock_t(cstime),\n\t\tpriority,\n\t\tnice,\n\t\tnum_threads,\n\t\tstart_time,\n\t\tvsize,\n\t\tmm ? get_mm_rss(mm) : 0,\n\t\trsslim,\n\t\tmm ? (permitted ? mm->start_code : 1) : 0,\n\t\tmm ? (permitted ? mm->end_code : 1) : 0,\n\t\t(permitted && mm) ? mm->start_stack : 0,\n\t\tesp,\n\t\teip,\n\t\t/* The signal information here is obsolete.\n\t\t * It must be decimal for Linux 2.0 compatibility.\n\t\t * Use /proc/#/status for real-time signals.\n\t\t */\n\t\ttask->pending.signal.sig[0] & 0x7fffffffUL,\n\t\ttask->blocked.sig[0] & 0x7fffffffUL,\n\t\tsigign      .sig[0] & 0x7fffffffUL,\n\t\tsigcatch    .sig[0] & 0x7fffffffUL,\n\t\twchan,\n\t\t0UL,\n\t\t0UL,\n\t\ttask->exit_signal,\n\t\ttask_cpu(task),\n\t\ttask->rt_priority,\n\t\ttask->policy,\n\t\t(unsigned long long)delayacct_blkio_ticks(task),\n\t\tcputime_to_clock_t(gtime),\n\t\tcputime_to_clock_t(cgtime));\n\tif (mm)\n\t\tmmput(mm);\n\treturn 0;\n}",
    "abstract_func": "static int do_task_stat(struct seq_file *VAR_0, struct pid_namespace *VAR_1,\n\t\t\tstruct pid *pid, struct task_struct *VAR_2, int VAR_3)\n{\n\tunsigned long VAR_4, VAR_5, VAR_6, VAR_7 = ~0UL;\n\tlong VAR_8, VAR_9;\n\tint VAR_10 = -1, VAR_11 = 0;\n\tsigset_t VAR_12, VAR_13;\n\tchar VAR_14;\n\tpid_t VAR_15 = 0, VAR_16 = -1, VAR_17 = -1;\n\tint VAR_18 = 0;\n\tint VAR_19;\n\tstruct mm_struct *VAR_20;\n\tunsigned long long VAR_21;\n\tunsigned long VAR_22 = 0, VAR_23 = 0;\n\tunsigned long  VAR_24 = 0,  VAR_25 = 0;\n\tcputime_t VAR_26, VAR_27, VAR_28, VAR_29;\n\tcputime_t VAR_30, VAR_31;\n\tunsigned long VAR_32 = 0;\n\tchar VAR_33[sizeof(VAR_2->comm)];\n\tunsigned long VAR_34;\n\n\tVAR_14 = *get_task_state(VAR_2);\n\tVAR_4 = VAR_5 = VAR_6 = 0;\n\tVAR_19 = ptrace_may_access(VAR_2, VAR_35);\n\tVAR_20 = get_task_mm(VAR_2);\n\tif (VAR_20) {\n\t\tVAR_4 = task_vsize(VAR_20);\n\t\tif (VAR_19) {\n\t\t\tVAR_5 = KSTK_EIP(VAR_2);\n\t\t\tVAR_6 = KSTK_ESP(VAR_2);\n\t\t}\n\t}\n\n\tget_task_comm(VAR_33, VAR_2);\n\n\tsigemptyset(&VAR_12);\n\tsigemptyset(&VAR_13);\n\tVAR_26 = VAR_27 = VAR_28 = VAR_29 = VAR_36;\n\tVAR_30 = VAR_31 = VAR_36;\n\n\tif (lock_task_sighand(VAR_2, &VAR_34)) {\n\t\tstruct signal_struct *VAR_37 = VAR_2->signal;\n\n\t\tif (VAR_37->tty) {\n\t\t\tstruct pid *VAR_38 = tty_get_pgrp(VAR_37->tty);\n\t\t\tVAR_10 = pid_nr_ns(VAR_38, VAR_1);\n\t\t\tput_pid(VAR_38);\n\t\t\tVAR_11 = new_encode_dev(tty_devnum(VAR_37->tty));\n\t\t}\n\n\t\tVAR_18 = get_nr_threads(VAR_2);\n\t\tcollect_sigign_sigcatch(VAR_2, &VAR_12, &VAR_13);\n\n\t\tVAR_22 = VAR_37->cmin_flt;\n\t\tVAR_23 = VAR_37->cmaj_flt;\n\t\tVAR_26 = VAR_37->cutime;\n\t\tVAR_27 = VAR_37->cstime;\n\t\tVAR_30 = VAR_37->cgtime;\n\t\tVAR_32 = ACCESS_ONCE(VAR_37->rlim[VAR_39].rlim_cur);\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_3) {\n\t\t\tstruct task_struct *VAR_40 = VAR_2;\n\t\t\tdo {\n\t\t\t\tVAR_24 += VAR_40->min_flt;\n\t\t\t\tVAR_25 += VAR_40->maj_flt;\n\t\t\t\tVAR_31 = cputime_add(VAR_31, VAR_40->gtime);\n\t\t\t\tVAR_40 = next_thread(VAR_40);\n\t\t\t} while (VAR_40 != VAR_2);\n\n\t\t\tVAR_24 += VAR_37->min_flt;\n\t\t\tVAR_25 += VAR_37->maj_flt;\n\t\t\tthread_group_times(VAR_2, &VAR_28, &VAR_29);\n\t\t\tVAR_31 = cputime_add(VAR_31, VAR_37->gtime);\n\t\t}\n\n\t\tVAR_17 = task_session_nr_ns(VAR_2, VAR_1);\n\t\tVAR_15 = task_tgid_nr_ns(VAR_2->real_parent, VAR_1);\n\t\tVAR_16 = task_pgrp_nr_ns(VAR_2, VAR_1);\n\n\t\tunlock_task_sighand(VAR_2, &VAR_34);\n\t}\n\n\tif (VAR_19 && (!VAR_3 || VAR_18 < 2))\n\t\tVAR_7 = get_wchan(VAR_2);\n\tif (!VAR_3) {\n\t\tVAR_24 = VAR_2->min_flt;\n\t\tVAR_25 = VAR_2->maj_flt;\n\t\ttask_times(VAR_2, &VAR_28, &VAR_29);\n\t\tVAR_31 = VAR_2->gtime;\n\t}\n\n\t/* COMMENT_1 */\n\t/* COMMENT_2 */\n\tVAR_8 = task_prio(VAR_2);\n\tVAR_9 = task_nice(VAR_2);\n\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\tVAR_21 =\n\t\t(unsigned long long)VAR_2->real_start_time.tv_sec * VAR_41\n\t\t\t\t+ VAR_2->real_start_time.tv_nsec;\n\t/* COMMENT_5 */\n\tVAR_21 = nsec_to_clock_t(VAR_21);\n\n\tseq_printf(VAR_0, \"%d (%s) %c %d %d %d %d %d %u %lu \\\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\\n\",\n\t\tpid_nr_ns(pid, VAR_1),\n\t\tVAR_33,\n\t\tVAR_14,\n\t\tVAR_15,\n\t\tVAR_16,\n\t\tVAR_17,\n\t\tVAR_11,\n\t\tVAR_10,\n\t\tVAR_2->flags,\n\t\tVAR_24,\n\t\tVAR_22,\n\t\tVAR_25,\n\t\tVAR_23,\n\t\tcputime_to_clock_t(VAR_28),\n\t\tcputime_to_clock_t(VAR_29),\n\t\tcputime_to_clock_t(VAR_26),\n\t\tcputime_to_clock_t(VAR_27),\n\t\tVAR_8,\n\t\tVAR_9,\n\t\tVAR_18,\n\t\tVAR_21,\n\t\tVAR_4,\n\t\tVAR_20 ? get_mm_rss(VAR_20) : 0,\n\t\tVAR_32,\n\t\tVAR_20 ? (VAR_19 ? VAR_20->start_code : 1) : 0,\n\t\tVAR_20 ? (VAR_19 ? VAR_20->end_code : 1) : 0,\n\t\t(VAR_19 && VAR_20) ? VAR_20->start_stack : 0,\n\t\tVAR_6,\n\t\tVAR_5,\n\t\t/* COMMENT_6 */\n                                                    \n                                              \n     \n\t\tVAR_2->pending.signal.sig[0] & 0x7fffffffUL,\n\t\tVAR_2->blocked.sig[0] & 0x7fffffffUL,\n\t\tVAR_12      .sig[0] & 0x7fffffffUL,\n\t\tVAR_13    .sig[0] & 0x7fffffffUL,\n\t\tVAR_7,\n\t\t0UL,\n\t\t0UL,\n\t\tVAR_2->exit_signal,\n\t\ttask_cpu(VAR_2),\n\t\tVAR_2->rt_priority,\n\t\tVAR_2->policy,\n\t\t(unsigned long long)delayacct_blkio_ticks(VAR_2),\n\t\tcputime_to_clock_t(VAR_31),\n\t\tcputime_to_clock_t(VAR_30));\n\tif (VAR_20)\n\t\tmmput(VAR_20);\n\treturn 0;\n}",
    "func_graph_path": "torvalds/linux/5883f57ca0008ffc93e09cbb9847a1928e50c6f3/array.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -130,8 +130,8 @@\n \t\tvsize,\n \t\tmm ? get_mm_rss(mm) : 0,\n \t\trsslim,\n-\t\tmm ? mm->start_code : 0,\n-\t\tmm ? mm->end_code : 0,\n+\t\tmm ? (permitted ? mm->start_code : 1) : 0,\n+\t\tmm ? (permitted ? mm->end_code : 1) : 0,\n \t\t(permitted && mm) ? mm->start_stack : 0,\n \t\tesp,\n \t\teip,",
    "diff_line_info": {
        "deleted_lines": [
            "\t\tmm ? mm->start_code : 0,",
            "\t\tmm ? mm->end_code : 0,"
        ],
        "added_lines": [
            "\t\tmm ? (permitted ? mm->start_code : 1) : 0,",
            "\t\tmm ? (permitted ? mm->end_code : 1) : 0,"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}