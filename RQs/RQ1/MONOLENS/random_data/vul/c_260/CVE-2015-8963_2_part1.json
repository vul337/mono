{
    "cve_id": "CVE-2015-8963",
    "cwe_ids": [
        "CWE-362",
        "CWE-416"
    ],
    "cvss_vector": "AV:N/AC:H/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "perf: Fix race in swevent hash\n\nThere's a race on CPU unplug where we free the swevent hash array\nwhile it can still have events on. This will result in a\nuse-after-free which is BAD.\n\nSimply do not free the hash array on unplug. This leaves the thing\naround and no use-after-free takes place.\n\nWhen the last swevent dies, we do a for_each_possible_cpu() iteration\nanyway to clean these up, at which time we'll free it, so no leakage\nwill occur.\n\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nTested-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "commit_hash": "12ca6ad2e3a896256f086497a7c7406a547ee373",
    "git_url": "https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373",
    "file_path": "kernel/events/core.c",
    "func_name": "perf_event_init_cpu",
    "func_before": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}",
    "abstract_func_before": "static void perf_event_init_cpu(int VAR_0)\n{\n\tstruct swevent_htable *VAR_1 = &per_cpu(swevent_htable, VAR_0);\n\n\tmutex_lock(&VAR_1->hlist_mutex);\n\tVAR_1->online = true;\n\tif (VAR_1->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *VAR_2;\n\n\t\tVAR_2 = kzalloc_node(sizeof(*VAR_2), VAR_3, cpu_to_node(VAR_0));\n\t\tWARN_ON(!VAR_2);\n\t\trcu_assign_pointer(VAR_1->swevent_hlist, VAR_2);\n\t}\n\tmutex_unlock(&VAR_1->hlist_mutex);\n}",
    "func_graph_path_before": "torvalds/linux/12ca6ad2e3a896256f086497a7c7406a547ee373/core.c/vul/before/3.json",
    "func": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}",
    "abstract_func": "static void perf_event_init_cpu(int VAR_0)\n{\n\tstruct swevent_htable *VAR_1 = &per_cpu(swevent_htable, VAR_0);\n\n\tmutex_lock(&VAR_1->hlist_mutex);\n\tif (VAR_1->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *VAR_2;\n\n\t\tVAR_2 = kzalloc_node(sizeof(*VAR_2), VAR_3, cpu_to_node(VAR_0));\n\t\tWARN_ON(!VAR_2);\n\t\trcu_assign_pointer(VAR_1->swevent_hlist, VAR_2);\n\t}\n\tmutex_unlock(&VAR_1->hlist_mutex);\n}",
    "func_graph_path": "torvalds/linux/12ca6ad2e3a896256f086497a7c7406a547ee373/core.c/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,6 @@\n \tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n \n \tmutex_lock(&swhash->hlist_mutex);\n-\tswhash->online = true;\n \tif (swhash->hlist_refcount > 0) {\n \t\tstruct swevent_hlist *hlist;\n ",
    "diff_line_info": {
        "deleted_lines": [
            "\tswhash->online = true;"
        ],
        "added_lines": []
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}