{
    "cve_id": "CVE-2014-9731",
    "cwe_ids": [
        "CWE-17"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "udf: Check path length when reading symlink\n\nSymlink reading code does not check whether the resulting path fits into\nthe page provided by the generic code. This isn't as easy as just\nchecking the symlink size because of various encoding conversions we\nperform on path. So we have to check whether there is still enough space\nin the buffer on the fly.\n\nCC: stable@vger.kernel.org\nReported-by: Carl Henrik Lunde <chlunde@ping.uio.no>\nSigned-off-by: Jan Kara <jack@suse.cz>",
    "commit_hash": "0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14",
    "git_url": "https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14",
    "file_path": "fs/udf/symlink.c",
    "func_name": "udf_pc_to_char",
    "func_before": "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t   int fromlen, unsigned char *to)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tunsigned char *p = to;\n\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n\t\t\t\t\t      pc->lengthComponentIdent);\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n}",
    "abstract_func_before": "static void udf_pc_to_char(struct super_block *VAR_0, unsigned char *VAR_1,\n\t\t\t   int VAR_2, unsigned char *VAR_3)\n{\n\tstruct pathComponent *VAR_4;\n\tint VAR_5 = 0;\n\tunsigned char *VAR_6 = VAR_3;\n\n\twhile (VAR_5 < VAR_2) {\n\t\tVAR_4 = (struct pathComponent *)(VAR_1 + VAR_5);\n\t\tswitch (VAR_4->componentType) {\n\t\tcase 1:\n\t\t\t/* COMMENT_0 */\n                                                         \n                                                                 \n      \n\t\t\tif (VAR_4->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* COMMENT_4 */\n\t\tcase 2:\n\t\t\tVAR_6 = VAR_3;\n\t\t\t*VAR_6++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(VAR_6, \"../\", 3);\n\t\t\tVAR_6 += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(VAR_6, \"./\", 2);\n\t\t\tVAR_6 += 2;\n\t\t\t/* COMMENT_5 */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tVAR_6 += udf_get_filename(VAR_0, VAR_4->componentIdent, VAR_6,\n\t\t\t\t\t      VAR_4->lengthComponentIdent);\n\t\t\t*VAR_6++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\tVAR_5 += sizeof(struct pathComponent) + VAR_4->lengthComponentIdent;\n\t}\n\tif (VAR_6 > VAR_3 + 1)\n\t\tVAR_6[-1] = '\\0';\n\telse\n\t\tVAR_6[0] = '\\0';\n}",
    "func_graph_path_before": "torvalds/linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/symlink.c/vul/before/1.json",
    "func": "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}",
    "abstract_func": "static int udf_pc_to_char(struct super_block *VAR_0, unsigned char *VAR_1,\n\t\t\t  int VAR_2, unsigned char *VAR_3, int VAR_4)\n{\n\tstruct pathComponent *VAR_5;\n\tint VAR_6 = 0;\n\tint VAR_7;\n\tunsigned char *VAR_8 = VAR_3;\n\n\t/* COMMENT_0 */\n\tVAR_4--;\n\twhile (VAR_6 < VAR_2) {\n\t\tVAR_5 = (struct pathComponent *)(VAR_1 + VAR_6);\n\t\tswitch (VAR_5->componentType) {\n\t\tcase 1:\n\t\t\t/* COMMENT_1 */\n                                                         \n                                                                 \n      \n\t\t\tif (VAR_5->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* COMMENT_5 */\n\t\tcase 2:\n\t\t\tif (VAR_4 == 0)\n\t\t\t\treturn -VAR_9;\n\t\t\tVAR_8 = VAR_3;\n\t\t\t*VAR_8++ = '/';\n\t\t\tVAR_4--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (VAR_4 < 3)\n\t\t\t\treturn -VAR_9;\n\t\t\tmemcpy(VAR_8, \"../\", 3);\n\t\t\tVAR_8 += 3;\n\t\t\tVAR_4 -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (VAR_4 < 2)\n\t\t\t\treturn -VAR_9;\n\t\t\tmemcpy(VAR_8, \"./\", 2);\n\t\t\tVAR_8 += 2;\n\t\t\tVAR_4 -= 2;\n\t\t\t/* COMMENT_6 */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tVAR_7 = udf_get_filename(VAR_0, VAR_5->componentIdent,\n\t\t\t\t\t\t    VAR_5->lengthComponentIdent,\n\t\t\t\t\t\t    VAR_8, VAR_4);\n\t\t\tVAR_8 += VAR_7;\n\t\t\tVAR_4 -= VAR_7;\n\t\t\tif (VAR_4 == 0)\n\t\t\t\treturn -VAR_9;\n\t\t\t*VAR_8++ = '/';\n\t\t\tVAR_4--;\n\t\t\tbreak;\n\t\t}\n\t\tVAR_6 += sizeof(struct pathComponent) + VAR_5->lengthComponentIdent;\n\t}\n\tif (VAR_8 > VAR_3 + 1)\n\t\tVAR_8[-1] = '\\0';\n\telse\n\t\tVAR_8[0] = '\\0';\n\treturn 0;\n}",
    "func_graph_path": "torvalds/linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14/symlink.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,13 @@\n-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n-\t\t\t   int fromlen, unsigned char *to)\n+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n+\t\t\t  int fromlen, unsigned char *to, int tolen)\n {\n \tstruct pathComponent *pc;\n \tint elen = 0;\n+\tint comp_len;\n \tunsigned char *p = to;\n \n+\t/* Reserve one byte for terminating \\0 */\n+\ttolen--;\n \twhile (elen < fromlen) {\n \t\tpc = (struct pathComponent *)(from + elen);\n \t\tswitch (pc->componentType) {\n@@ -17,22 +20,37 @@\n \t\t\t\tbreak;\n \t\t\t/* Fall through */\n \t\tcase 2:\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tp = to;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\tcase 3:\n+\t\t\tif (tolen < 3)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \"../\", 3);\n \t\t\tp += 3;\n+\t\t\ttolen -= 3;\n \t\t\tbreak;\n \t\tcase 4:\n+\t\t\tif (tolen < 2)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\tmemcpy(p, \"./\", 2);\n \t\t\tp += 2;\n+\t\t\ttolen -= 2;\n \t\t\t/* that would be . - just ignore */\n \t\t\tbreak;\n \t\tcase 5:\n-\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n-\t\t\t\t\t      pc->lengthComponentIdent);\n+\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n+\t\t\t\t\t\t    pc->lengthComponentIdent,\n+\t\t\t\t\t\t    p, tolen);\n+\t\t\tp += comp_len;\n+\t\t\ttolen -= comp_len;\n+\t\t\tif (tolen == 0)\n+\t\t\t\treturn -ENAMETOOLONG;\n \t\t\t*p++ = '/';\n+\t\t\ttolen--;\n \t\t\tbreak;\n \t\t}\n \t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n@@ -41,4 +59,5 @@\n \t\tp[-1] = '\\0';\n \telse\n \t\tp[0] = '\\0';\n+\treturn 0;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,",
            "\t\t\t   int fromlen, unsigned char *to)",
            "\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,",
            "\t\t\t\t\t      pc->lengthComponentIdent);"
        ],
        "added_lines": [
            "static int udf_pc_to_char(struct super_block *sb, unsigned char *from,",
            "\t\t\t  int fromlen, unsigned char *to, int tolen)",
            "\tint comp_len;",
            "\t/* Reserve one byte for terminating \\0 */",
            "\ttolen--;",
            "\t\t\tif (tolen == 0)",
            "\t\t\t\treturn -ENAMETOOLONG;",
            "\t\t\ttolen--;",
            "\t\t\tif (tolen < 3)",
            "\t\t\t\treturn -ENAMETOOLONG;",
            "\t\t\ttolen -= 3;",
            "\t\t\tif (tolen < 2)",
            "\t\t\t\treturn -ENAMETOOLONG;",
            "\t\t\ttolen -= 2;",
            "\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,",
            "\t\t\t\t\t\t    pc->lengthComponentIdent,",
            "\t\t\t\t\t\t    p, tolen);",
            "\t\t\tp += comp_len;",
            "\t\t\ttolen -= comp_len;",
            "\t\t\tif (tolen == 0)",
            "\t\t\t\treturn -ENAMETOOLONG;",
            "\t\t\ttolen--;",
            "\treturn 0;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}