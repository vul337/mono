{
    "cve_id": "CVE-2016-6823",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "ImageMagick",
    "commit_msg": "Prevent buffer overflow in BMP coder (bug report from pwchen of tencent).",
    "commit_hash": "4cc6ec8a4197d4c008577127736bf7985d632323",
    "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4cc6ec8a4197d4c008577127736bf7985d632323",
    "file_path": "coders/bmp.c",
    "func_name": "WriteBMPImage",
    "func_before": "static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n\n  scene=0;\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\"bmp3:alpha\");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%lu)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%lu\",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */\n        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */\n        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */\n        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %lu bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "abstract_func_before": "static MagickBooleanType WriteBMPImage(const ImageInfo *VAR_0,Image *VAR_1,\n  ExceptionInfo *VAR_2)\n{\n  BMPInfo\n    VAR_3;\n\n  const char\n    *VAR_4;\n\n  const StringInfo\n    *VAR_5;\n\n  MagickBooleanType\n    VAR_6,\n    VAR_7;\n\n  MagickOffsetType\n    VAR_8;\n\n  MemoryInfo\n    *VAR_9;\n\n  register const Quantum\n    *VAR_10;\n\n  register ssize_t\n    VAR_11,\n    VAR_12;\n\n  register unsigned char\n    *VAR_13;\n\n  size_t\n    VAR_14,\n    VAR_15;\n\n  ssize_t\n    VAR_16;\n\n  unsigned char\n    *VAR_17,\n    *VAR_18;\n\n  /* COMMENT_0 */\n                           \n    \n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_19);\n  assert(VAR_1 != (Image *) NULL);\n  assert(VAR_1->signature == VAR_19);\n  if (VAR_1->debug != VAR_20)\n    (void) LogMagickEvent(VAR_21,GetMagickModule(),\"%s\",VAR_1->filename);\n  assert(VAR_2 != (ExceptionInfo *) NULL);\n  assert(VAR_2->signature == VAR_19);\n  VAR_7=OpenBlob(VAR_0,VAR_1,VAR_22,VAR_2);\n  if (VAR_7 == VAR_20)\n    return(VAR_7);\n  VAR_15=4;\n  if (LocaleCompare(VAR_0->magick,\"BMP2\") == 0)\n    VAR_15=2;\n  else\n    if (LocaleCompare(VAR_0->magick,\"BMP3\") == 0)\n      VAR_15=3;\n\n  VAR_4=GetImageOption(VAR_0,\"bmp:format\");\n  if (VAR_4 != (char *) NULL)\n    {\n      (void) LogMagickEvent(VAR_23,GetMagickModule(),\n          \"  Format=%s\",VAR_4);\n\n      if (LocaleCompare(VAR_4,\"bmp2\") == 0)\n        VAR_15=2;\n      if (LocaleCompare(VAR_4,\"bmp3\") == 0)\n        VAR_15=3;\n      if (LocaleCompare(VAR_4,\"bmp4\") == 0)\n        VAR_15=4;\n    }\n\n  VAR_8=0;\n  do\n  {\n    /* COMMENT_3 */\n                                        \n      \n    (void) TransformImageColorspace(VAR_1,VAR_24,VAR_2);\n    (void) ResetMagickMemory(&VAR_3,0,sizeof(VAR_3));\n    VAR_3.file_size=14+12;\n    if (VAR_15 > 2)\n      VAR_3.file_size+=28;\n    VAR_3.offset_bits=VAR_3.file_size;\n    VAR_3.compression=VAR_25;\n    if ((VAR_1->storage_class == VAR_26) && (VAR_1->colors > 256))\n      (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);\n    if (VAR_1->storage_class != VAR_27)\n      {\n        /* COMMENT_6 */\n                                 \n          \n        VAR_3.bits_per_pixel=8;\n        if (VAR_1->colors <= 2)\n          VAR_3.bits_per_pixel=1;\n        else\n          if (VAR_1->colors <= 16)\n            VAR_3.bits_per_pixel=4;\n          else\n            if (VAR_1->colors <= 256)\n              VAR_3.bits_per_pixel=8;\n        if (VAR_0->compression == VAR_28)\n          VAR_3.bits_per_pixel=8;\n        VAR_3.number_colors=1U << VAR_3.bits_per_pixel;\n        if (VAR_1->alpha_trait != VAR_29)\n          (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);\n        else\n          if ((size_t) VAR_3.number_colors < VAR_1->colors)\n            (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);\n          else\n            {\n              VAR_3.file_size+=3*(1UL << VAR_3.bits_per_pixel);\n              VAR_3.offset_bits+=3*(1UL << VAR_3.bits_per_pixel);\n              if (VAR_15 > 2)\n                {\n                  VAR_3.file_size+=(1UL << VAR_3.bits_per_pixel);\n                  VAR_3.offset_bits+=(1UL << VAR_3.bits_per_pixel);\n                }\n            }\n      }\n    if (VAR_1->storage_class == VAR_27)\n      {\n        /* COMMENT_9 */\n                                \n          \n        VAR_3.number_colors=0;\n        VAR_3.bits_per_pixel=(unsigned short)\n          ((VAR_15 > 3) && (VAR_1->alpha_trait != VAR_29) ? 32 : 24);\n        VAR_3.compression=(unsigned int) ((VAR_15 > 3) &&\n          (VAR_1->alpha_trait != VAR_29) ?  VAR_30 : VAR_25);\n        if ((VAR_15 == 3) && (VAR_1->alpha_trait != VAR_29))\n          {\n            VAR_4=GetImageOption(VAR_0,\"bmp3:alpha\");\n            if (IsStringTrue(VAR_4))\n              VAR_3.bits_per_pixel=32;\n          }\n      }\n    VAR_14=4*((VAR_1->columns*VAR_3.bits_per_pixel+31)/32);\n    VAR_3.ba_offset=0;\n    VAR_5=GetImageProfile(VAR_1,\"icc\");\n    VAR_6=(VAR_1->rendering_intent != VAR_31) ||\n      (VAR_5 != (StringInfo *) NULL) || (VAR_1->gamma != 0.0) ?  VAR_32 :\n      VAR_20;\n    if (VAR_15 == 2)\n      VAR_3.size=12;\n    else\n      if ((VAR_15 == 3) || ((VAR_1->alpha_trait == VAR_29) &&\n          (VAR_6 == VAR_20)))\n        {\n          VAR_15=3;\n          VAR_3.size=40;\n        }\n      else\n        {\n          int\n            VAR_33;\n\n          VAR_3.size=108;\n          VAR_33=68;\n          if ((VAR_1->rendering_intent != VAR_31) ||\n              (VAR_5 != (StringInfo *) NULL))\n            {\n              VAR_3.size=124;\n              VAR_33+=16;\n            }\n          VAR_3.file_size+=VAR_33;\n          VAR_3.offset_bits+=VAR_33;\n        }\n    VAR_3.width=(ssize_t) VAR_1->columns;\n    VAR_3.height=(ssize_t) VAR_1->rows;\n    VAR_3.planes=1;\n    VAR_3.image_size=(unsigned int) (VAR_14*VAR_1->rows);\n    VAR_3.file_size+=VAR_3.image_size;\n    VAR_3.x_pixels=75*39;\n    VAR_3.y_pixels=75*39;\n    switch (VAR_1->units)\n    {\n      case VAR_34:\n      case VAR_35:\n      {\n        VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x/2.54);\n        VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y/2.54);\n        break;\n      }\n      case VAR_36:\n      {\n        VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x);\n        VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y);\n        break;\n      }\n    }\n    VAR_3.colors_important=VAR_3.number_colors;\n    /* COMMENT_12 */\n                                        \n      \n    VAR_9=AcquireVirtualMemory((size_t) VAR_3.image_size,\n      sizeof(*VAR_18));\n    if (VAR_9 == (MemoryInfo *) NULL)\n      ThrowWriterException(VAR_37,\"MemoryAllocationFailed\");\n    VAR_18=(unsigned char *) GetVirtualMemoryBlob(VAR_9);\n    (void) ResetMagickMemory(VAR_18,0,(size_t) VAR_3.image_size);\n    switch (VAR_3.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          VAR_38,\n          VAR_39;\n\n        /* COMMENT_15 */\n                                                              \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          ssize_t\n            VAR_40;\n\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          VAR_38=0;\n          VAR_39=0;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            VAR_39<<=1;\n            VAR_39|=GetPixelIndex(VAR_1,VAR_10) != 0 ? 0x01 : 0x00;\n            VAR_38++;\n            if (VAR_38 == 8)\n              {\n                *VAR_13++=(unsigned char) VAR_39;\n                VAR_38=0;\n                VAR_39=0;\n              }\n             VAR_10+=GetPixelChannels(VAR_1);\n           }\n           if (VAR_38 != 0)\n             {\n               *VAR_13++=(unsigned char) (VAR_39 << (8-VAR_38));\n               VAR_12++;\n             }\n          VAR_40=(ssize_t) (VAR_1->columns+7)/8;\n          for (VAR_12=VAR_40; VAR_12 < (ssize_t) VAR_14; VAR_12++)\n            *VAR_13++=0x00;\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          VAR_39,\n          VAR_42;\n\n        ssize_t\n          VAR_40;\n\n        /* COMMENT_18 */\n                                                              \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          VAR_42=0;\n          VAR_39=0;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            VAR_39<<=4;\n            VAR_39|=((size_t) GetPixelIndex(VAR_1,VAR_10) & 0x0f);\n            VAR_42++;\n            if (VAR_42 == 2)\n              {\n                *VAR_13++=(unsigned char) VAR_39;\n                VAR_42=0;\n                VAR_39=0;\n              }\n            VAR_10+=GetPixelChannels(VAR_1);\n          }\n          if (VAR_42 != 0)\n            {\n              *VAR_13++=(unsigned char) (VAR_39 << 4);\n              VAR_12++;\n            }\n          VAR_40=(ssize_t) (VAR_1->columns+1)/2;\n          for (VAR_12=VAR_40; VAR_12 < (ssize_t) VAR_14; VAR_12++)\n            *VAR_13++=0x00;\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /* COMMENT_21 */\n                                                  \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            *VAR_13++=(unsigned char) GetPixelIndex(VAR_1,VAR_10);\n            VAR_10+=GetPixelChannels(VAR_1);\n          }\n          for ( ; VAR_12 < (ssize_t) VAR_14; VAR_12++)\n            *VAR_13++=0x00;\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /* COMMENT_24 */\n                                                   \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            *VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));\n            VAR_10+=GetPixelChannels(VAR_1);\n          }\n          for (VAR_12=3L*(ssize_t) VAR_1->columns; VAR_12 < (ssize_t) VAR_14; VAR_12++)\n            *VAR_13++=0x00;\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /* COMMENT_27 */\n                                                       \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            *VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_10));\n            VAR_10+=GetPixelChannels(VAR_1);\n          }\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((VAR_15 > 2) && (VAR_3.bits_per_pixel == 8))\n      if (VAR_0->compression != VAR_43)\n        {\n          MemoryInfo\n            *VAR_44;\n\n          /* COMMENT_30 */\n                                                     \n            \n          VAR_44=AcquireVirtualMemory((size_t) (2*(VAR_14+2)+2),\n            (VAR_1->rows+2)*sizeof(*VAR_18));\n          if (VAR_44 == (MemoryInfo *) NULL)\n            {\n              VAR_9=RelinquishVirtualMemory(VAR_9);\n              ThrowWriterException(VAR_37,\"MemoryAllocationFailed\");\n            }\n          VAR_17=(unsigned char *) GetVirtualMemoryBlob(VAR_44);\n          VAR_3.file_size-=VAR_3.image_size;\n          VAR_3.image_size=(unsigned int) EncodeImage(VAR_1,VAR_14,\n            VAR_18,VAR_17);\n          VAR_3.file_size+=VAR_3.image_size;\n          VAR_9=RelinquishVirtualMemory(VAR_9);\n          VAR_9=VAR_44;\n          VAR_18=VAR_17;\n          VAR_3.compression=VAR_45;\n        }\n    /* COMMENT_33 */\n                                                          \n      \n    if (VAR_1->debug != VAR_20)\n      {\n        (void) LogMagickEvent(VAR_23,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) VAR_15);\n        if (VAR_1->storage_class == VAR_27)\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(VAR_23,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) VAR_1->depth);\n        if (VAR_1->alpha_trait != VAR_29)\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(VAR_23,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) VAR_3.bits_per_pixel);\n        switch ((int) VAR_3.compression)\n        {\n           case VAR_25:\n           {\n             (void) LogMagickEvent(VAR_23,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case VAR_45:\n           {\n             (void) LogMagickEvent(VAR_23,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case VAR_30:\n           {\n             (void) LogMagickEvent(VAR_23,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(VAR_23,GetMagickModule(),\n               \"   Compression=UNKNOWN (%lu)\",VAR_3.compression);\n             break;\n           }\n        }\n        if (VAR_3.number_colors == 0)\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Number_colors=%lu\",VAR_3.number_colors);\n      }\n    (void) WriteBlob(VAR_1,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(VAR_1,VAR_3.file_size);\n    (void) WriteBlobLSBLong(VAR_1,VAR_3.ba_offset);  /* COMMENT_36 */\n    (void) WriteBlobLSBLong(VAR_1,VAR_3.offset_bits);\n    if (VAR_15 == 2)\n      {\n        /* COMMENT_37 */\n                                                \n          \n        (void) WriteBlobLSBLong(VAR_1,VAR_3.size);\n        (void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.width);\n        (void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.height);\n        (void) WriteBlobLSBShort(VAR_1,VAR_3.planes);\n        (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);\n      }\n    else\n      {\n        /* COMMENT_40 */\n                                                 \n          \n        (void) WriteBlobLSBLong(VAR_1,VAR_3.size);\n        (void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.width);\n        (void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.height);\n        (void) WriteBlobLSBShort(VAR_1,VAR_3.planes);\n        (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.compression);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.image_size);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.x_pixels);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.y_pixels);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.number_colors);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.colors_important);\n      }\n    if ((VAR_15 > 3) && ((VAR_1->alpha_trait != VAR_29) ||\n        (VAR_6 != VAR_20)))\n      {\n        /* COMMENT_43 */\n                                                              \n          \n        (void) WriteBlobLSBLong(VAR_1,0x00ff0000U);  /* COMMENT_46 */\n        (void) WriteBlobLSBLong(VAR_1,0x0000ff00U);  /* COMMENT_47 */\n        (void) WriteBlobLSBLong(VAR_1,0x000000ffU);  /* COMMENT_48 */\n        (void) WriteBlobLSBLong(VAR_1,0xff000000U);  /* COMMENT_49 */\n        (void) WriteBlobLSBLong(VAR_1,0x73524742U);  /* COMMENT_50 */\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          ((1.000f-(VAR_1->chromaticity.red_primary.x+\n          VAR_1->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          ((1.000f-(VAR_1->chromaticity.green_primary.x+\n          VAR_1->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          ((1.000f-(VAR_1->chromaticity.blue_primary.x+\n          VAR_1->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_3.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_3.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_3.gamma_scale.z*0x10000));\n        if ((VAR_1->rendering_intent != VAR_31) ||\n            (VAR_5 != (StringInfo *) NULL))\n          {\n            ssize_t\n              VAR_46;\n\n            switch ((int) VAR_1->rendering_intent)\n            {\n              case VAR_47:\n              {\n                VAR_46=VAR_48;\n                break;\n              }\n              case VAR_49:\n              {\n                VAR_46=VAR_50;\n                break;\n              }\n              case VAR_51:\n              {\n                VAR_46=VAR_52;\n                break;\n              }\n              case VAR_53:\n              {\n                VAR_46=VAR_54;\n                break;\n              }\n              default:\n              {\n                VAR_46=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_46);\n            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_51 */\n            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_52 */\n            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_53 */\n          }\n      }\n    if (VAR_1->storage_class == VAR_26)\n      {\n        unsigned char\n          *VAR_55;\n\n        /* COMMENT_54 */\n                                \n          \n        if (VAR_1->debug != VAR_20)\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) VAR_1->colors);\n        VAR_55=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          VAR_3.bits_per_pixel),4*sizeof(*VAR_55));\n        if (VAR_55 == (unsigned char *) NULL)\n          ThrowWriterException(VAR_37,\"MemoryAllocationFailed\");\n        VAR_13=VAR_55;\n        for (VAR_11=0; VAR_11 < (ssize_t) MagickMin((ssize_t) VAR_1->colors,(ssize_t) VAR_3.number_colors); VAR_11++)\n        {\n          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].blue));\n          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].green));\n          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].red));\n          if (VAR_15 > 2)\n            *VAR_13++=(unsigned char) 0x0;\n        }\n        for ( ; VAR_11 < (ssize_t) (1UL << VAR_3.bits_per_pixel); VAR_11++)\n        {\n          *VAR_13++=(unsigned char) 0x00;\n          *VAR_13++=(unsigned char) 0x00;\n          *VAR_13++=(unsigned char) 0x00;\n          if (VAR_15 > 2)\n            *VAR_13++=(unsigned char) 0x00;\n        }\n        if (VAR_15 <= 2)\n          (void) WriteBlob(VAR_1,(size_t) (3*(1L << VAR_3.bits_per_pixel)),\n            VAR_55);\n        else\n          (void) WriteBlob(VAR_1,(size_t) (4*(1L << VAR_3.bits_per_pixel)),\n            VAR_55);\n        VAR_55=(unsigned char *) RelinquishMagickMemory(VAR_55);\n      }\n    if (VAR_1->debug != VAR_20)\n      (void) LogMagickEvent(VAR_23,GetMagickModule(),\n        \"  Pixels:  %lu bytes\",VAR_3.image_size);\n    (void) WriteBlob(VAR_1,(size_t) VAR_3.image_size,VAR_18);\n    VAR_9=RelinquishVirtualMemory(VAR_9);\n    if (GetNextImageInList(VAR_1) == (Image *) NULL)\n      break;\n    VAR_1=SyncNextImageInList(VAR_1);\n    VAR_7=SetImageProgress(VAR_1,VAR_56,VAR_8++,\n      GetImageListLength(VAR_1));\n    if (VAR_7 == VAR_20)\n      break;\n  } while (VAR_0->adjoin != VAR_20);\n  (void) CloseBlob(VAR_1);\n  return(VAR_32);\n}",
    "func_graph_path_before": "ImageMagick/4cc6ec8a4197d4c008577127736bf7985d632323/bmp.c/vul/before/0.json",
    "func": "static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n\n  scene=0;\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\"bmp3:alpha\");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    if ((image->columns != (signed int) image->columns) ||\n        (image->rows != (signed int) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%lu)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%lu\",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */\n        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */\n        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */\n        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %lu bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "abstract_func": "static MagickBooleanType WriteBMPImage(const ImageInfo *VAR_0,Image *VAR_1,\n  ExceptionInfo *VAR_2)\n{\n  BMPInfo\n    VAR_3;\n\n  const char\n    *VAR_4;\n\n  const StringInfo\n    *VAR_5;\n\n  MagickBooleanType\n    VAR_6,\n    VAR_7;\n\n  MagickOffsetType\n    VAR_8;\n\n  MemoryInfo\n    *VAR_9;\n\n  register const Quantum\n    *VAR_10;\n\n  register ssize_t\n    VAR_11,\n    VAR_12;\n\n  register unsigned char\n    *VAR_13;\n\n  size_t\n    VAR_14,\n    VAR_15;\n\n  ssize_t\n    VAR_16;\n\n  unsigned char\n    *VAR_17,\n    *VAR_18;\n\n  /* COMMENT_0 */\n                           \n    \n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_19);\n  assert(VAR_1 != (Image *) NULL);\n  assert(VAR_1->signature == VAR_19);\n  if (VAR_1->debug != VAR_20)\n    (void) LogMagickEvent(VAR_21,GetMagickModule(),\"%s\",VAR_1->filename);\n  assert(VAR_2 != (ExceptionInfo *) NULL);\n  assert(VAR_2->signature == VAR_19);\n  VAR_7=OpenBlob(VAR_0,VAR_1,VAR_22,VAR_2);\n  if (VAR_7 == VAR_20)\n    return(VAR_7);\n  VAR_15=4;\n  if (LocaleCompare(VAR_0->magick,\"BMP2\") == 0)\n    VAR_15=2;\n  else\n    if (LocaleCompare(VAR_0->magick,\"BMP3\") == 0)\n      VAR_15=3;\n\n  VAR_4=GetImageOption(VAR_0,\"bmp:format\");\n  if (VAR_4 != (char *) NULL)\n    {\n      (void) LogMagickEvent(VAR_23,GetMagickModule(),\n          \"  Format=%s\",VAR_4);\n\n      if (LocaleCompare(VAR_4,\"bmp2\") == 0)\n        VAR_15=2;\n      if (LocaleCompare(VAR_4,\"bmp3\") == 0)\n        VAR_15=3;\n      if (LocaleCompare(VAR_4,\"bmp4\") == 0)\n        VAR_15=4;\n    }\n\n  VAR_8=0;\n  do\n  {\n    /* COMMENT_3 */\n                                        \n      \n    (void) TransformImageColorspace(VAR_1,VAR_24,VAR_2);\n    (void) ResetMagickMemory(&VAR_3,0,sizeof(VAR_3));\n    VAR_3.file_size=14+12;\n    if (VAR_15 > 2)\n      VAR_3.file_size+=28;\n    VAR_3.offset_bits=VAR_3.file_size;\n    VAR_3.compression=VAR_25;\n    if ((VAR_1->storage_class == VAR_26) && (VAR_1->colors > 256))\n      (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);\n    if (VAR_1->storage_class != VAR_27)\n      {\n        /* COMMENT_6 */\n                                 \n          \n        VAR_3.bits_per_pixel=8;\n        if (VAR_1->colors <= 2)\n          VAR_3.bits_per_pixel=1;\n        else\n          if (VAR_1->colors <= 16)\n            VAR_3.bits_per_pixel=4;\n          else\n            if (VAR_1->colors <= 256)\n              VAR_3.bits_per_pixel=8;\n        if (VAR_0->compression == VAR_28)\n          VAR_3.bits_per_pixel=8;\n        VAR_3.number_colors=1U << VAR_3.bits_per_pixel;\n        if (VAR_1->alpha_trait != VAR_29)\n          (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);\n        else\n          if ((size_t) VAR_3.number_colors < VAR_1->colors)\n            (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);\n          else\n            {\n              VAR_3.file_size+=3*(1UL << VAR_3.bits_per_pixel);\n              VAR_3.offset_bits+=3*(1UL << VAR_3.bits_per_pixel);\n              if (VAR_15 > 2)\n                {\n                  VAR_3.file_size+=(1UL << VAR_3.bits_per_pixel);\n                  VAR_3.offset_bits+=(1UL << VAR_3.bits_per_pixel);\n                }\n            }\n      }\n    if (VAR_1->storage_class == VAR_27)\n      {\n        /* COMMENT_9 */\n                                \n          \n        VAR_3.number_colors=0;\n        VAR_3.bits_per_pixel=(unsigned short)\n          ((VAR_15 > 3) && (VAR_1->alpha_trait != VAR_29) ? 32 : 24);\n        VAR_3.compression=(unsigned int) ((VAR_15 > 3) &&\n          (VAR_1->alpha_trait != VAR_29) ?  VAR_30 : VAR_25);\n        if ((VAR_15 == 3) && (VAR_1->alpha_trait != VAR_29))\n          {\n            VAR_4=GetImageOption(VAR_0,\"bmp3:alpha\");\n            if (IsStringTrue(VAR_4))\n              VAR_3.bits_per_pixel=32;\n          }\n      }\n    VAR_14=4*((VAR_1->columns*VAR_3.bits_per_pixel+31)/32);\n    VAR_3.ba_offset=0;\n    VAR_5=GetImageProfile(VAR_1,\"icc\");\n    VAR_6=(VAR_1->rendering_intent != VAR_31) ||\n      (VAR_5 != (StringInfo *) NULL) || (VAR_1->gamma != 0.0) ?  VAR_32 :\n      VAR_20;\n    if (VAR_15 == 2)\n      VAR_3.size=12;\n    else\n      if ((VAR_15 == 3) || ((VAR_1->alpha_trait == VAR_29) &&\n          (VAR_6 == VAR_20)))\n        {\n          VAR_15=3;\n          VAR_3.size=40;\n        }\n      else\n        {\n          int\n            VAR_33;\n\n          VAR_3.size=108;\n          VAR_33=68;\n          if ((VAR_1->rendering_intent != VAR_31) ||\n              (VAR_5 != (StringInfo *) NULL))\n            {\n              VAR_3.size=124;\n              VAR_33+=16;\n            }\n          VAR_3.file_size+=VAR_33;\n          VAR_3.offset_bits+=VAR_33;\n        }\n    if ((VAR_1->columns != (signed int) VAR_1->columns) ||\n        (VAR_1->rows != (signed int) VAR_1->rows))\n      ThrowWriterException(VAR_34,\"WidthOrHeightExceedsLimit\");\n    VAR_3.width=(ssize_t) VAR_1->columns;\n    VAR_3.height=(ssize_t) VAR_1->rows;\n    VAR_3.planes=1;\n    VAR_3.image_size=(unsigned long) (VAR_14*VAR_1->rows);\n    VAR_3.file_size+=VAR_3.image_size;\n    VAR_3.x_pixels=75*39;\n    VAR_3.y_pixels=75*39;\n    switch (VAR_1->units)\n    {\n      case VAR_35:\n      case VAR_36:\n      {\n        VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x/2.54);\n        VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y/2.54);\n        break;\n      }\n      case VAR_37:\n      {\n        VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x);\n        VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y);\n        break;\n      }\n    }\n    VAR_3.colors_important=VAR_3.number_colors;\n    /* COMMENT_12 */\n                                        \n      \n    VAR_9=AcquireVirtualMemory((size_t) VAR_3.image_size,\n      sizeof(*VAR_18));\n    if (VAR_9 == (MemoryInfo *) NULL)\n      ThrowWriterException(VAR_38,\"MemoryAllocationFailed\");\n    VAR_18=(unsigned char *) GetVirtualMemoryBlob(VAR_9);\n    (void) ResetMagickMemory(VAR_18,0,(size_t) VAR_3.image_size);\n    switch (VAR_3.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          VAR_39,\n          VAR_40;\n\n        /* COMMENT_15 */\n                                                              \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          ssize_t\n            VAR_41;\n\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          VAR_39=0;\n          VAR_40=0;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            VAR_40<<=1;\n            VAR_40|=GetPixelIndex(VAR_1,VAR_10) != 0 ? 0x01 : 0x00;\n            VAR_39++;\n            if (VAR_39 == 8)\n              {\n                *VAR_13++=(unsigned char) VAR_40;\n                VAR_39=0;\n                VAR_40=0;\n              }\n             VAR_10+=GetPixelChannels(VAR_1);\n           }\n           if (VAR_39 != 0)\n             {\n               *VAR_13++=(unsigned char) (VAR_40 << (8-VAR_39));\n               VAR_12++;\n             }\n          VAR_41=(ssize_t) (VAR_1->columns+7)/8;\n          for (VAR_12=VAR_41; VAR_12 < (ssize_t) VAR_14; VAR_12++)\n            *VAR_13++=0x00;\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          VAR_40,\n          VAR_43;\n\n        ssize_t\n          VAR_41;\n\n        /* COMMENT_18 */\n                                                              \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          VAR_43=0;\n          VAR_40=0;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            VAR_40<<=4;\n            VAR_40|=((size_t) GetPixelIndex(VAR_1,VAR_10) & 0x0f);\n            VAR_43++;\n            if (VAR_43 == 2)\n              {\n                *VAR_13++=(unsigned char) VAR_40;\n                VAR_43=0;\n                VAR_40=0;\n              }\n            VAR_10+=GetPixelChannels(VAR_1);\n          }\n          if (VAR_43 != 0)\n            {\n              *VAR_13++=(unsigned char) (VAR_40 << 4);\n              VAR_12++;\n            }\n          VAR_41=(ssize_t) (VAR_1->columns+1)/2;\n          for (VAR_12=VAR_41; VAR_12 < (ssize_t) VAR_14; VAR_12++)\n            *VAR_13++=0x00;\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /* COMMENT_21 */\n                                                  \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            *VAR_13++=(unsigned char) GetPixelIndex(VAR_1,VAR_10);\n            VAR_10+=GetPixelChannels(VAR_1);\n          }\n          for ( ; VAR_12 < (ssize_t) VAR_14; VAR_12++)\n            *VAR_13++=0x00;\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /* COMMENT_24 */\n                                                   \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            *VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));\n            VAR_10+=GetPixelChannels(VAR_1);\n          }\n          for (VAR_12=3L*(ssize_t) VAR_1->columns; VAR_12 < (ssize_t) VAR_14; VAR_12++)\n            *VAR_13++=0x00;\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /* COMMENT_27 */\n                                                       \n          \n        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)\n        {\n          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);\n          if (VAR_10 == (const Quantum *) NULL)\n            break;\n          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;\n          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)\n          {\n            *VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));\n            *VAR_13++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_10));\n            VAR_10+=GetPixelChannels(VAR_1);\n          }\n          if (VAR_1->previous == (Image *) NULL)\n            {\n              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,\n                VAR_1->rows);\n              if (VAR_7 == VAR_20)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((VAR_15 > 2) && (VAR_3.bits_per_pixel == 8))\n      if (VAR_0->compression != VAR_44)\n        {\n          MemoryInfo\n            *VAR_45;\n\n          /* COMMENT_30 */\n                                                     \n            \n          VAR_45=AcquireVirtualMemory((size_t) (2*(VAR_14+2)+2),\n            (VAR_1->rows+2)*sizeof(*VAR_18));\n          if (VAR_45 == (MemoryInfo *) NULL)\n            {\n              VAR_9=RelinquishVirtualMemory(VAR_9);\n              ThrowWriterException(VAR_38,\"MemoryAllocationFailed\");\n            }\n          VAR_17=(unsigned char *) GetVirtualMemoryBlob(VAR_45);\n          VAR_3.file_size-=VAR_3.image_size;\n          VAR_3.image_size=(unsigned int) EncodeImage(VAR_1,VAR_14,\n            VAR_18,VAR_17);\n          VAR_3.file_size+=VAR_3.image_size;\n          VAR_9=RelinquishVirtualMemory(VAR_9);\n          VAR_9=VAR_45;\n          VAR_18=VAR_17;\n          VAR_3.compression=VAR_46;\n        }\n    /* COMMENT_33 */\n                                                          \n      \n    if (VAR_1->debug != VAR_20)\n      {\n        (void) LogMagickEvent(VAR_23,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) VAR_15);\n        if (VAR_1->storage_class == VAR_27)\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(VAR_23,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) VAR_1->depth);\n        if (VAR_1->alpha_trait != VAR_29)\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(VAR_23,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) VAR_3.bits_per_pixel);\n        switch ((int) VAR_3.compression)\n        {\n           case VAR_25:\n           {\n             (void) LogMagickEvent(VAR_23,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case VAR_46:\n           {\n             (void) LogMagickEvent(VAR_23,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case VAR_30:\n           {\n             (void) LogMagickEvent(VAR_23,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(VAR_23,GetMagickModule(),\n               \"   Compression=UNKNOWN (%lu)\",VAR_3.compression);\n             break;\n           }\n        }\n        if (VAR_3.number_colors == 0)\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"   Number_colors=%lu\",VAR_3.number_colors);\n      }\n    (void) WriteBlob(VAR_1,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(VAR_1,VAR_3.file_size);\n    (void) WriteBlobLSBLong(VAR_1,VAR_3.ba_offset);  /* COMMENT_36 */\n    (void) WriteBlobLSBLong(VAR_1,VAR_3.offset_bits);\n    if (VAR_15 == 2)\n      {\n        /* COMMENT_37 */\n                                                \n          \n        (void) WriteBlobLSBLong(VAR_1,VAR_3.size);\n        (void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.width);\n        (void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.height);\n        (void) WriteBlobLSBShort(VAR_1,VAR_3.planes);\n        (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);\n      }\n    else\n      {\n        /* COMMENT_40 */\n                                                 \n          \n        (void) WriteBlobLSBLong(VAR_1,VAR_3.size);\n        (void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.width);\n        (void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.height);\n        (void) WriteBlobLSBShort(VAR_1,VAR_3.planes);\n        (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.compression);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.image_size);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.x_pixels);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.y_pixels);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.number_colors);\n        (void) WriteBlobLSBLong(VAR_1,VAR_3.colors_important);\n      }\n    if ((VAR_15 > 3) && ((VAR_1->alpha_trait != VAR_29) ||\n        (VAR_6 != VAR_20)))\n      {\n        /* COMMENT_43 */\n                                                              \n          \n        (void) WriteBlobLSBLong(VAR_1,0x00ff0000U);  /* COMMENT_46 */\n        (void) WriteBlobLSBLong(VAR_1,0x0000ff00U);  /* COMMENT_47 */\n        (void) WriteBlobLSBLong(VAR_1,0x000000ffU);  /* COMMENT_48 */\n        (void) WriteBlobLSBLong(VAR_1,0xff000000U);  /* COMMENT_49 */\n        (void) WriteBlobLSBLong(VAR_1,0x73524742U);  /* COMMENT_50 */\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          ((1.000f-(VAR_1->chromaticity.red_primary.x+\n          VAR_1->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          ((1.000f-(VAR_1->chromaticity.green_primary.x+\n          VAR_1->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_1->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          ((1.000f-(VAR_1->chromaticity.blue_primary.x+\n          VAR_1->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_3.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_3.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(VAR_1,(unsigned int)\n          (VAR_3.gamma_scale.z*0x10000));\n        if ((VAR_1->rendering_intent != VAR_31) ||\n            (VAR_5 != (StringInfo *) NULL))\n          {\n            ssize_t\n              VAR_47;\n\n            switch ((int) VAR_1->rendering_intent)\n            {\n              case VAR_48:\n              {\n                VAR_47=VAR_49;\n                break;\n              }\n              case VAR_50:\n              {\n                VAR_47=VAR_51;\n                break;\n              }\n              case VAR_52:\n              {\n                VAR_47=VAR_53;\n                break;\n              }\n              case VAR_54:\n              {\n                VAR_47=VAR_55;\n                break;\n              }\n              default:\n              {\n                VAR_47=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_47);\n            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_51 */\n            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_52 */\n            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_53 */\n          }\n      }\n    if (VAR_1->storage_class == VAR_26)\n      {\n        unsigned char\n          *VAR_56;\n\n        /* COMMENT_54 */\n                                \n          \n        if (VAR_1->debug != VAR_20)\n          (void) LogMagickEvent(VAR_23,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) VAR_1->colors);\n        VAR_56=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          VAR_3.bits_per_pixel),4*sizeof(*VAR_56));\n        if (VAR_56 == (unsigned char *) NULL)\n          ThrowWriterException(VAR_38,\"MemoryAllocationFailed\");\n        VAR_13=VAR_56;\n        for (VAR_11=0; VAR_11 < (ssize_t) MagickMin((ssize_t) VAR_1->colors,(ssize_t) VAR_3.number_colors); VAR_11++)\n        {\n          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].blue));\n          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].green));\n          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].red));\n          if (VAR_15 > 2)\n            *VAR_13++=(unsigned char) 0x0;\n        }\n        for ( ; VAR_11 < (ssize_t) (1UL << VAR_3.bits_per_pixel); VAR_11++)\n        {\n          *VAR_13++=(unsigned char) 0x00;\n          *VAR_13++=(unsigned char) 0x00;\n          *VAR_13++=(unsigned char) 0x00;\n          if (VAR_15 > 2)\n            *VAR_13++=(unsigned char) 0x00;\n        }\n        if (VAR_15 <= 2)\n          (void) WriteBlob(VAR_1,(size_t) (3*(1L << VAR_3.bits_per_pixel)),\n            VAR_56);\n        else\n          (void) WriteBlob(VAR_1,(size_t) (4*(1L << VAR_3.bits_per_pixel)),\n            VAR_56);\n        VAR_56=(unsigned char *) RelinquishMagickMemory(VAR_56);\n      }\n    if (VAR_1->debug != VAR_20)\n      (void) LogMagickEvent(VAR_23,GetMagickModule(),\n        \"  Pixels:  %lu bytes\",VAR_3.image_size);\n    (void) WriteBlob(VAR_1,(size_t) VAR_3.image_size,VAR_18);\n    VAR_9=RelinquishVirtualMemory(VAR_9);\n    if (GetNextImageInList(VAR_1) == (Image *) NULL)\n      break;\n    VAR_1=SyncNextImageInList(VAR_1);\n    VAR_7=SetImageProgress(VAR_1,VAR_57,VAR_8++,\n      GetImageListLength(VAR_1));\n    if (VAR_7 == VAR_20)\n      break;\n  } while (VAR_0->adjoin != VAR_20);\n  (void) CloseBlob(VAR_1);\n  return(VAR_32);\n}",
    "func_graph_path": "ImageMagick/4cc6ec8a4197d4c008577127736bf7985d632323/bmp.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -172,10 +172,13 @@\n           bmp_info.file_size+=extra_size;\n           bmp_info.offset_bits+=extra_size;\n         }\n+    if ((image->columns != (signed int) image->columns) ||\n+        (image->rows != (signed int) image->rows))\n+      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n     bmp_info.width=(ssize_t) image->columns;\n     bmp_info.height=(ssize_t) image->rows;\n     bmp_info.planes=1;\n-    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n+    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);\n     bmp_info.file_size+=bmp_info.image_size;\n     bmp_info.x_pixels=75*39;\n     bmp_info.y_pixels=75*39;",
    "diff_line_info": {
        "deleted_lines": [
            "    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);"
        ],
        "added_lines": [
            "    if ((image->columns != (signed int) image->columns) ||",
            "        (image->rows != (signed int) image->rows))",
            "      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");",
            "    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}