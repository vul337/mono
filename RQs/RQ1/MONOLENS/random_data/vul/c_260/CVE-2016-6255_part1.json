{
    "cve_id": "CVE-2016-6255",
    "cwe_ids": [
        "CWE-284"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "mjg59/pupnp-code",
    "commit_msg": "Don't allow unhandled POSTs to write to the filesystem by default\n\nIf there's no registered handler for a POST request, the default behaviour\nis to write it to the filesystem. Several million deployed devices appear\nto have this behaviour, making it possible to (at least) store arbitrary\ndata on them. Add a configure option that enables this behaviour, and change\nthe default to just drop POSTs that aren't directly handled.",
    "commit_hash": "be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd",
    "git_url": "https://github.com/mjg59/pupnp-code/commit/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd",
    "file_path": "upnp/src/genlib/net/http/webserver.c",
    "func_name": "http_RecvPostMessage",
    "func_before": "static int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}",
    "abstract_func_before": "static int http_RecvPostMessage(\n\t/* COMMENT_0 */\n\thttp_parser_t *VAR_0,\n\t/* COMMENT_1 */\n\tSOCKINFO *VAR_1,\n\t/* COMMENT_2 */\n\tchar *VAR_2,\n\t/* COMMENT_3 */\n                                \n\tstruct SendInstruction *VAR_3)\n{\n\tsize_t VAR_4 = 1024;\n\tchar VAR_5[1024];\n\tint VAR_6 = -1;\n\tFILE *VAR_7;\n\tparse_status_t VAR_8 = VAR_9;\n\tint VAR_10 = FALSE;\n\tsize_t VAR_11 = 0;\n\tint VAR_12 = 0;\n\tint VAR_13 = VAR_14;\n\n\tif (VAR_3 && VAR_3->IsVirtualFile) {\n\t\tVAR_7 = (VAR_15.open) (VAR_2, VAR_16);\n\t\tif (VAR_7 == NULL)\n\t\t\treturn VAR_17;\n\t} else {\n\t\tVAR_7 = fopen(VAR_2, \"wb\");\n\t\tif (VAR_7 == NULL)\n\t\t\treturn VAR_18;\n\t}\n\tVAR_0->position = VAR_19;\n\tdo {\n\t\t/* COMMENT_5 */\n\t\tif (VAR_0->position != VAR_20)\n\t\t\tVAR_8 = parser_parse_entity(VAR_0);\n\t\tif (VAR_8 == VAR_21) {\n\t\t\t/* COMMENT_6 */\n\t\t\tVAR_10 = TRUE;\n\t\t} else if ((VAR_8 != VAR_22)\n\t\t\t   && (VAR_8 != VAR_23)\n\t\t\t   && (VAR_8 != VAR_24)) {\n\t\t\t/* COMMENT_7 */\n\t\t\tVAR_13 = VAR_25;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* COMMENT_8 */\n\t\twhile (VAR_11 + VAR_4 > VAR_0->msg.entity.length &&\n\t\t       VAR_0->position != VAR_20) {\n\t\t\tVAR_12 = sock_read(VAR_1, VAR_5, sizeof(VAR_5), &VAR_6);\n\t\t\tif (VAR_12 > 0) {\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\tif (membuffer_append(&VAR_0->msg.msg,\n\t\t\t\t\tVAR_5, (size_t)VAR_12) != 0) {\n\t\t\t\t\t/* COMMENT_10 */\n\t\t\t\t\tVAR_0->http_error_code =\n\t\t\t\t\t    VAR_17;\n\t\t\t\t\tVAR_13 = VAR_17;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tVAR_8 = parser_parse_entity(VAR_0);\n\t\t\t\tif (VAR_8 == VAR_21) {\n\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\tVAR_10 = TRUE;\n\t\t\t\t} else if ((VAR_8 != VAR_22)\n\t\t\t\t\t   && (VAR_8 != VAR_23)\n\t\t\t\t\t   && (VAR_8 != VAR_24)) {\n\t\t\t\t\tVAR_13 = VAR_25;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (VAR_12 == 0) {\n\t\t\t\tif (VAR_10) {\n\t\t\t\t\tUpnpPrintf(VAR_26, VAR_27, VAR_28, VAR_29,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tVAR_0->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&VAR_0->msg);\n\t\t\t\t\tVAR_0->position = VAR_20;\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\tVAR_0->http_error_code = VAR_25;\n\t\t\t\t\tVAR_13 = VAR_25;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((VAR_11 + VAR_4) > VAR_0->msg.entity.length) {\n\t\t\tVAR_4 =\n\t\t\t    VAR_0->msg.entity.length - VAR_11;\n\t\t}\n\t\tmemcpy(VAR_5,\n\t\t       &VAR_0->msg.msg.buf[VAR_0->entity_start_position + VAR_11],\n\t\t       VAR_4);\n\t\tVAR_11 += VAR_4;\n\t\tif (VAR_3 && VAR_3->IsVirtualFile) {\n\t\t\tint VAR_31 = VAR_15.write(VAR_7, VAR_5, VAR_4);\n\t\t\tif (VAR_31 < 0) {\n\t\t\t\tVAR_13 = VAR_17;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t VAR_31 = fwrite(VAR_5, 1, VAR_4, VAR_7);\n\t\t\tif (VAR_31 != VAR_4) {\n\t\t\t\tVAR_13 = VAR_17;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (VAR_0->position != VAR_20 ||\n\t\t VAR_11 != VAR_0->msg.entity.length);\nExitFunction:\n\tif (VAR_3 && VAR_3->IsVirtualFile) {\n\t\tVAR_15.close(VAR_7);\n\t} else {\n\t\tfclose(VAR_7);\n\t}\n\n\treturn VAR_13;\n}",
    "func_graph_path_before": "mjg59/pupnp-code/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd/webserver.c/vul/before/0.json",
    "func": "static int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n#ifdef UPNP_ENABLE_POST_WRITE\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n#else\n\t\treturn HTTP_NOT_FOUND;\n#endif\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}",
    "abstract_func": "static int http_RecvPostMessage(\n\t/* COMMENT_0 */\n\thttp_parser_t *VAR_0,\n\t/* COMMENT_1 */\n\tSOCKINFO *VAR_1,\n\t/* COMMENT_2 */\n\tchar *VAR_2,\n\t/* COMMENT_3 */\n                                \n\tstruct SendInstruction *VAR_3)\n{\n\tsize_t VAR_4 = 1024;\n\tchar VAR_5[1024];\n\tint VAR_6 = -1;\n\tFILE *VAR_7;\n\tparse_status_t VAR_8 = VAR_9;\n\tint VAR_10 = FALSE;\n\tsize_t VAR_11 = 0;\n\tint VAR_12 = 0;\n\tint VAR_13 = VAR_14;\n\n\tif (VAR_3 && VAR_3->IsVirtualFile) {\n\t\tVAR_7 = (VAR_15.open) (VAR_2, VAR_16);\n\t\tif (VAR_7 == NULL)\n\t\t\treturn VAR_17;\n\t} else {\n#ifdef VAR_18\n\t\tVAR_7 = fopen(VAR_2, \"wb\");\n\t\tif (VAR_7 == NULL)\n\t\t\treturn VAR_19;\n#else\n\t\treturn VAR_20;\n#endif\n\t}\n\tVAR_0->position = VAR_21;\n\tdo {\n\t\t/* COMMENT_5 */\n\t\tif (VAR_0->position != VAR_22)\n\t\t\tVAR_8 = parser_parse_entity(VAR_0);\n\t\tif (VAR_8 == VAR_23) {\n\t\t\t/* COMMENT_6 */\n\t\t\tVAR_10 = TRUE;\n\t\t} else if ((VAR_8 != VAR_24)\n\t\t\t   && (VAR_8 != VAR_25)\n\t\t\t   && (VAR_8 != VAR_26)) {\n\t\t\t/* COMMENT_7 */\n\t\t\tVAR_13 = VAR_27;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* COMMENT_8 */\n\t\twhile (VAR_11 + VAR_4 > VAR_0->msg.entity.length &&\n\t\t       VAR_0->position != VAR_22) {\n\t\t\tVAR_12 = sock_read(VAR_1, VAR_5, sizeof(VAR_5), &VAR_6);\n\t\t\tif (VAR_12 > 0) {\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\tif (membuffer_append(&VAR_0->msg.msg,\n\t\t\t\t\tVAR_5, (size_t)VAR_12) != 0) {\n\t\t\t\t\t/* COMMENT_10 */\n\t\t\t\t\tVAR_0->http_error_code =\n\t\t\t\t\t    VAR_17;\n\t\t\t\t\tVAR_13 = VAR_17;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tVAR_8 = parser_parse_entity(VAR_0);\n\t\t\t\tif (VAR_8 == VAR_23) {\n\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\tVAR_10 = TRUE;\n\t\t\t\t} else if ((VAR_8 != VAR_24)\n\t\t\t\t\t   && (VAR_8 != VAR_25)\n\t\t\t\t\t   && (VAR_8 != VAR_26)) {\n\t\t\t\t\tVAR_13 = VAR_27;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (VAR_12 == 0) {\n\t\t\t\tif (VAR_10) {\n\t\t\t\t\tUpnpPrintf(VAR_28, VAR_29, VAR_30, VAR_31,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tVAR_0->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&VAR_0->msg);\n\t\t\t\t\tVAR_0->position = VAR_22;\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\tVAR_0->http_error_code = VAR_27;\n\t\t\t\t\tVAR_13 = VAR_27;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVAR_13 = VAR_32;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((VAR_11 + VAR_4) > VAR_0->msg.entity.length) {\n\t\t\tVAR_4 =\n\t\t\t    VAR_0->msg.entity.length - VAR_11;\n\t\t}\n\t\tmemcpy(VAR_5,\n\t\t       &VAR_0->msg.msg.buf[VAR_0->entity_start_position + VAR_11],\n\t\t       VAR_4);\n\t\tVAR_11 += VAR_4;\n\t\tif (VAR_3 && VAR_3->IsVirtualFile) {\n\t\t\tint VAR_33 = VAR_15.write(VAR_7, VAR_5, VAR_4);\n\t\t\tif (VAR_33 < 0) {\n\t\t\t\tVAR_13 = VAR_17;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t VAR_33 = fwrite(VAR_5, 1, VAR_4, VAR_7);\n\t\t\tif (VAR_33 != VAR_4) {\n\t\t\t\tVAR_13 = VAR_17;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (VAR_0->position != VAR_22 ||\n\t\t VAR_11 != VAR_0->msg.entity.length);\nExitFunction:\n\tif (VAR_3 && VAR_3->IsVirtualFile) {\n\t\tVAR_15.close(VAR_7);\n\t} else {\n\t\tfclose(VAR_7);\n\t}\n\n\treturn VAR_13;\n}",
    "func_graph_path": "mjg59/pupnp-code/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd/webserver.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -24,9 +24,13 @@\n \t\tif (Fp == NULL)\n \t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n \t} else {\n+#ifdef UPNP_ENABLE_POST_WRITE\n \t\tFp = fopen(filename, \"wb\");\n \t\tif (Fp == NULL)\n \t\t\treturn HTTP_UNAUTHORIZED;\n+#else\n+\t\treturn HTTP_NOT_FOUND;\n+#endif\n \t}\n \tparser->position = POS_ENTITY;\n \tdo {",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "#ifdef UPNP_ENABLE_POST_WRITE",
            "#else",
            "\t\treturn HTTP_NOT_FOUND;",
            "#endif"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}