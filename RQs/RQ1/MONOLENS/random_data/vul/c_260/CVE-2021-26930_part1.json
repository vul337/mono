{
    "cve_id": "CVE-2021-26930",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "The function uses a goto-based loop, which may lead to an earlier error\ngetting discarded by a later iteration. Exit this ad-hoc loop when an\nerror was encountered.\n\nThe out-of-memory error path additionally fails to fill a structure\nfield looked at by xen_blkbk_unmap_prepare() before inspecting the\nhandle which does get properly set (to BLKBACK_INVALID_HANDLE).\n\nSince the earlier exiting from the ad-hoc loop requires the same field\nfilling (invalidation) as that on the out-of-memory path, fold both\npaths. While doing so, drop the pr_alert(), as extra log messages aren't\ngoing to help the situation (the kernel will log oom conditions already\nanyway).\n\nThis is XSA-365.\n\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Juergen Gross <jgross@suse.com>\nReviewed-by: Julien Grall <julien@xen.org>\nSigned-off-by: Juergen Gross <jgross@suse.com>\n",
    "commit_hash": "871997bc9e423f05c7da7c9178e62dde5df2a7f8",
    "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=871997bc9e423f05c7da7c9178e62dde5df2a7f8",
    "file_path": "drivers/block/xen-blkback/blkback.c",
    "func_name": "xen_blkbk_map",
    "func_before": "static int xen_blkbk_map(struct xen_blkif_ring *ring,\n\t\t\t struct grant_page *pages[],\n\t\t\t int num, bool ro)\n{\n\tstruct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt = NULL;\n\tphys_addr_t addr = 0;\n\tint i, seg_idx, new_map_idx;\n\tint segs_to_map = 0;\n\tint ret = 0;\n\tint last_map = 0, map_until = 0;\n\tint use_persistent_gnts;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tuse_persistent_gnts = (blkif->vbd.feature_gnt_persistent);\n\n\t/*\n\t * Fill out preq.nr_sects with proper amount of sectors, and setup\n\t * assign map[..] with the PFN of the page in our domain with the\n\t * corresponding grant reference for each page.\n\t */\nagain:\n\tfor (i = map_until; i < num; i++) {\n\t\tuint32_t flags;\n\n\t\tif (use_persistent_gnts) {\n\t\t\tpersistent_gnt = get_persistent_gnt(\n\t\t\t\tring,\n\t\t\t\tpages[i]->gref);\n\t\t}\n\n\t\tif (persistent_gnt) {\n\t\t\t/*\n\t\t\t * We are using persistent grants and\n\t\t\t * the grant is already mapped\n\t\t\t */\n\t\t\tpages[i]->page = persistent_gnt->page;\n\t\t\tpages[i]->persistent_gnt = persistent_gnt;\n\t\t} else {\n\t\t\tif (gnttab_page_cache_get(&ring->free_pages,\n\t\t\t\t\t\t  &pages[i]->page))\n\t\t\t\tgoto out_of_memory;\n\t\t\taddr = vaddr(pages[i]->page);\n\t\t\tpages_to_gnt[segs_to_map] = pages[i]->page;\n\t\t\tpages[i]->persistent_gnt = NULL;\n\t\t\tflags = GNTMAP_host_map;\n\t\t\tif (!use_persistent_gnts && ro)\n\t\t\t\tflags |= GNTMAP_readonly;\n\t\t\tgnttab_set_map_op(&map[segs_to_map++], addr,\n\t\t\t\t\t  flags, pages[i]->gref,\n\t\t\t\t\t  blkif->domid);\n\t\t}\n\t\tmap_until = i + 1;\n\t\tif (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)\n\t\t\tbreak;\n\t}\n\n\tif (segs_to_map)\n\t\tret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);\n\n\t/*\n\t * Now swizzle the MFN in our domain with the MFN from the other domain\n\t * so that when we access vaddr(pending_req,i) it has the contents of\n\t * the page from the other domain.\n\t */\n\tfor (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {\n\t\tif (!pages[seg_idx]->persistent_gnt) {\n\t\t\t/* This is a newly mapped grant */\n\t\t\tBUG_ON(new_map_idx >= segs_to_map);\n\t\t\tif (unlikely(map[new_map_idx].status != 0)) {\n\t\t\t\tpr_debug(\"invalid buffer -- could not remap it\\n\");\n\t\t\t\tgnttab_page_cache_put(&ring->free_pages,\n\t\t\t\t\t\t      &pages[seg_idx]->page, 1);\n\t\t\t\tpages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;\n\t\t\t\tret |= !ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->handle = map[new_map_idx].handle;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (use_persistent_gnts &&\n\t\t    ring->persistent_gnt_c < max_pgrants) {\n\t\t\t/*\n\t\t\t * We are using persistent grants, the grant is\n\t\t\t * not mapped but we might have room for it.\n\t\t\t */\n\t\t\tpersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\n\t\t\t\t                 GFP_KERNEL);\n\t\t\tif (!persistent_gnt) {\n\t\t\t\t/*\n\t\t\t\t * If we don't have enough memory to\n\t\t\t\t * allocate the persistent_gnt struct\n\t\t\t\t * map this grant non-persistenly\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpersistent_gnt->gnt = map[new_map_idx].ref;\n\t\t\tpersistent_gnt->handle = map[new_map_idx].handle;\n\t\t\tpersistent_gnt->page = pages[seg_idx]->page;\n\t\t\tif (add_persistent_gnt(ring,\n\t\t\t                       persistent_gnt)) {\n\t\t\t\tkfree(persistent_gnt);\n\t\t\t\tpersistent_gnt = NULL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->persistent_gnt = persistent_gnt;\n\t\t\tpr_debug(\"grant %u added to the tree of persistent grants, using %u/%u\\n\",\n\t\t\t\t persistent_gnt->gnt, ring->persistent_gnt_c,\n\t\t\t\t max_pgrants);\n\t\t\tgoto next;\n\t\t}\n\t\tif (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {\n\t\t\tblkif->vbd.overflow_max_grants = 1;\n\t\t\tpr_debug(\"domain %u, device %#x is using maximum number of persistent grants\\n\",\n\t\t\t         blkif->domid, blkif->vbd.handle);\n\t\t}\n\t\t/*\n\t\t * We could not map this grant persistently, so use it as\n\t\t * a non-persistent grant.\n\t\t */\nnext:\n\t\tnew_map_idx++;\n\t}\n\tsegs_to_map = 0;\n\tlast_map = map_until;\n\tif (map_until != num)\n\t\tgoto again;\n\n\treturn ret;\n\nout_of_memory:\n\tpr_alert(\"%s: out of memory\\n\", __func__);\n\tgnttab_page_cache_put(&ring->free_pages, pages_to_gnt, segs_to_map);\n\tfor (i = last_map; i < num; i++)\n\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;\n\treturn -ENOMEM;\n}",
    "abstract_func_before": "static int xen_blkbk_map(struct xen_blkif_ring *VAR_0,\n\t\t\t struct grant_page *VAR_1[],\n\t\t\t int VAR_2, bool VAR_3)\n{\n\tstruct gnttab_map_grant_ref VAR_4[VAR_5];\n\tstruct page *VAR_6[VAR_5];\n\tstruct persistent_gnt *persistent_gnt = NULL;\n\tphys_addr_t VAR_7 = 0;\n\tint VAR_8, VAR_9, VAR_10;\n\tint VAR_11 = 0;\n\tint VAR_12 = 0;\n\tint VAR_13 = 0, VAR_14 = 0;\n\tint VAR_15;\n\tstruct xen_blkif *VAR_16 = VAR_0->blkif;\n\n\tVAR_15 = (VAR_16->vbd.feature_gnt_persistent);\n\n\t/* COMMENT_0 */\n                                                                   \n                                                                  \n                                                \n    \nagain:\n\tfor (VAR_8 = VAR_14; VAR_8 < VAR_2; VAR_8++) {\n\t\tuint32_t VAR_17;\n\n\t\tif (VAR_15) {\n\t\t\tpersistent_gnt = get_persistent_gnt(\n\t\t\t\tVAR_0,\n\t\t\t\tVAR_1[VAR_8]->gref);\n\t\t}\n\n\t\tif (persistent_gnt) {\n\t\t\t/* COMMENT_5 */\n                                        \n                                 \n      \n\t\t\tVAR_1[VAR_8]->page = persistent_gnt->page;\n\t\t\tVAR_1[VAR_8]->persistent_gnt = persistent_gnt;\n\t\t} else {\n\t\t\tif (gnttab_page_cache_get(&VAR_0->free_pages,\n\t\t\t\t\t\t  &VAR_1[VAR_8]->page))\n\t\t\t\tgoto out_of_memory;\n\t\t\tVAR_7 = vaddr(VAR_1[VAR_8]->page);\n\t\t\tVAR_6[VAR_11] = VAR_1[VAR_8]->page;\n\t\t\tVAR_1[VAR_8]->persistent_gnt = NULL;\n\t\t\tVAR_17 = VAR_18;\n\t\t\tif (!VAR_15 && VAR_3)\n\t\t\t\tVAR_17 |= VAR_19;\n\t\t\tgnttab_set_map_op(&VAR_4[VAR_11++], VAR_7,\n\t\t\t\t\t  VAR_17, VAR_1[VAR_8]->gref,\n\t\t\t\t\t  VAR_16->domid);\n\t\t}\n\t\tVAR_14 = VAR_8 + 1;\n\t\tif (VAR_11 == VAR_5)\n\t\t\tbreak;\n\t}\n\n\tif (VAR_11)\n\t\tVAR_12 = gnttab_map_refs(VAR_4, NULL, VAR_6, VAR_11);\n\n\t/* COMMENT_9 */\n                                                                        \n                                                                      \n                                   \n    \n\tfor (VAR_9 = VAR_13, VAR_10 = 0; VAR_9 < VAR_14; VAR_9++) {\n\t\tif (!VAR_1[VAR_9]->persistent_gnt) {\n\t\t\t/* COMMENT_14 */\n\t\t\tBUG_ON(VAR_10 >= VAR_11);\n\t\t\tif (unlikely(VAR_4[VAR_10].status != 0)) {\n\t\t\t\tpr_debug(\"invalid buffer -- could not remap it\\n\");\n\t\t\t\tgnttab_page_cache_put(&VAR_0->free_pages,\n\t\t\t\t\t\t      &VAR_1[VAR_9]->page, 1);\n\t\t\t\tVAR_1[VAR_9]->handle = VAR_20;\n\t\t\t\tVAR_12 |= !VAR_12;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tVAR_1[VAR_9]->handle = VAR_4[VAR_10].handle;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_15 &&\n\t\t    VAR_0->persistent_gnt_c < VAR_21) {\n\t\t\t/* COMMENT_15 */\n                                                  \n                                               \n      \n\t\t\tpersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\n\t\t\t\t                 VAR_22);\n\t\t\tif (!persistent_gnt) {\n\t\t\t\t/* COMMENT_19 */\n                                        \n                                         \n                                     \n       \n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpersistent_gnt->gnt = VAR_4[VAR_10].ref;\n\t\t\tpersistent_gnt->handle = VAR_4[VAR_10].handle;\n\t\t\tpersistent_gnt->page = VAR_1[VAR_9]->page;\n\t\t\tif (add_persistent_gnt(VAR_0,\n\t\t\t                       persistent_gnt)) {\n\t\t\t\tkfree(persistent_gnt);\n\t\t\t\tpersistent_gnt = NULL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tVAR_1[VAR_9]->persistent_gnt = persistent_gnt;\n\t\t\tpr_debug(\"grant %u added to the tree of persistent grants, using %u/%u\\n\",\n\t\t\t\t persistent_gnt->gnt, VAR_0->persistent_gnt_c,\n\t\t\t\t VAR_21);\n\t\t\tgoto next;\n\t\t}\n\t\tif (VAR_15 && !VAR_16->vbd.overflow_max_grants) {\n\t\t\tVAR_16->vbd.overflow_max_grants = 1;\n\t\t\tpr_debug(\"domain %u, device %#x is using maximum number of persistent grants\\n\",\n\t\t\t         VAR_16->domid, VAR_16->vbd.handle);\n\t\t}\n\t\t/* COMMENT_24 */\n                                                           \n                            \n     \nnext:\n\t\tVAR_10++;\n\t}\n\tVAR_11 = 0;\n\tVAR_13 = VAR_14;\n\tif (VAR_14 != VAR_2)\n\t\tgoto again;\n\n\treturn VAR_12;\n\nout_of_memory:\n\tpr_alert(\"%s: out of memory\\n\", VAR_23);\n\tgnttab_page_cache_put(&VAR_0->free_pages, VAR_6, VAR_11);\n\tfor (VAR_8 = VAR_13; VAR_8 < VAR_2; VAR_8++)\n\t\tVAR_1[VAR_8]->handle = VAR_20;\n\treturn -VAR_24;\n}",
    "func_graph_path_before": "torvalds/linux/871997bc9e423f05c7da7c9178e62dde5df2a7f8/blkback.c/vul/before/0.json",
    "func": "static int xen_blkbk_map(struct xen_blkif_ring *ring,\n\t\t\t struct grant_page *pages[],\n\t\t\t int num, bool ro)\n{\n\tstruct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt = NULL;\n\tphys_addr_t addr = 0;\n\tint i, seg_idx, new_map_idx;\n\tint segs_to_map = 0;\n\tint ret = 0;\n\tint last_map = 0, map_until = 0;\n\tint use_persistent_gnts;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tuse_persistent_gnts = (blkif->vbd.feature_gnt_persistent);\n\n\t/*\n\t * Fill out preq.nr_sects with proper amount of sectors, and setup\n\t * assign map[..] with the PFN of the page in our domain with the\n\t * corresponding grant reference for each page.\n\t */\nagain:\n\tfor (i = map_until; i < num; i++) {\n\t\tuint32_t flags;\n\n\t\tif (use_persistent_gnts) {\n\t\t\tpersistent_gnt = get_persistent_gnt(\n\t\t\t\tring,\n\t\t\t\tpages[i]->gref);\n\t\t}\n\n\t\tif (persistent_gnt) {\n\t\t\t/*\n\t\t\t * We are using persistent grants and\n\t\t\t * the grant is already mapped\n\t\t\t */\n\t\t\tpages[i]->page = persistent_gnt->page;\n\t\t\tpages[i]->persistent_gnt = persistent_gnt;\n\t\t} else {\n\t\t\tif (gnttab_page_cache_get(&ring->free_pages,\n\t\t\t\t\t\t  &pages[i]->page)) {\n\t\t\t\tgnttab_page_cache_put(&ring->free_pages,\n\t\t\t\t\t\t      pages_to_gnt,\n\t\t\t\t\t\t      segs_to_map);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\taddr = vaddr(pages[i]->page);\n\t\t\tpages_to_gnt[segs_to_map] = pages[i]->page;\n\t\t\tpages[i]->persistent_gnt = NULL;\n\t\t\tflags = GNTMAP_host_map;\n\t\t\tif (!use_persistent_gnts && ro)\n\t\t\t\tflags |= GNTMAP_readonly;\n\t\t\tgnttab_set_map_op(&map[segs_to_map++], addr,\n\t\t\t\t\t  flags, pages[i]->gref,\n\t\t\t\t\t  blkif->domid);\n\t\t}\n\t\tmap_until = i + 1;\n\t\tif (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)\n\t\t\tbreak;\n\t}\n\n\tif (segs_to_map)\n\t\tret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);\n\n\t/*\n\t * Now swizzle the MFN in our domain with the MFN from the other domain\n\t * so that when we access vaddr(pending_req,i) it has the contents of\n\t * the page from the other domain.\n\t */\n\tfor (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {\n\t\tif (!pages[seg_idx]->persistent_gnt) {\n\t\t\t/* This is a newly mapped grant */\n\t\t\tBUG_ON(new_map_idx >= segs_to_map);\n\t\t\tif (unlikely(map[new_map_idx].status != 0)) {\n\t\t\t\tpr_debug(\"invalid buffer -- could not remap it\\n\");\n\t\t\t\tgnttab_page_cache_put(&ring->free_pages,\n\t\t\t\t\t\t      &pages[seg_idx]->page, 1);\n\t\t\t\tpages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;\n\t\t\t\tret |= !ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->handle = map[new_map_idx].handle;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (use_persistent_gnts &&\n\t\t    ring->persistent_gnt_c < max_pgrants) {\n\t\t\t/*\n\t\t\t * We are using persistent grants, the grant is\n\t\t\t * not mapped but we might have room for it.\n\t\t\t */\n\t\t\tpersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\n\t\t\t\t                 GFP_KERNEL);\n\t\t\tif (!persistent_gnt) {\n\t\t\t\t/*\n\t\t\t\t * If we don't have enough memory to\n\t\t\t\t * allocate the persistent_gnt struct\n\t\t\t\t * map this grant non-persistenly\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpersistent_gnt->gnt = map[new_map_idx].ref;\n\t\t\tpersistent_gnt->handle = map[new_map_idx].handle;\n\t\t\tpersistent_gnt->page = pages[seg_idx]->page;\n\t\t\tif (add_persistent_gnt(ring,\n\t\t\t                       persistent_gnt)) {\n\t\t\t\tkfree(persistent_gnt);\n\t\t\t\tpersistent_gnt = NULL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->persistent_gnt = persistent_gnt;\n\t\t\tpr_debug(\"grant %u added to the tree of persistent grants, using %u/%u\\n\",\n\t\t\t\t persistent_gnt->gnt, ring->persistent_gnt_c,\n\t\t\t\t max_pgrants);\n\t\t\tgoto next;\n\t\t}\n\t\tif (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {\n\t\t\tblkif->vbd.overflow_max_grants = 1;\n\t\t\tpr_debug(\"domain %u, device %#x is using maximum number of persistent grants\\n\",\n\t\t\t         blkif->domid, blkif->vbd.handle);\n\t\t}\n\t\t/*\n\t\t * We could not map this grant persistently, so use it as\n\t\t * a non-persistent grant.\n\t\t */\nnext:\n\t\tnew_map_idx++;\n\t}\n\tsegs_to_map = 0;\n\tlast_map = map_until;\n\tif (!ret && map_until != num)\n\t\tgoto again;\n\nout:\n\tfor (i = last_map; i < num; i++) {\n\t\t/* Don't zap current batch's valid persistent grants. */\n\t\tif(i >= last_map + segs_to_map)\n\t\t\tpages[i]->persistent_gnt = NULL;\n\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;\n\t}\n\n\treturn ret;\n}",
    "abstract_func": "static int xen_blkbk_map(struct xen_blkif_ring *VAR_0,\n\t\t\t struct grant_page *VAR_1[],\n\t\t\t int VAR_2, bool VAR_3)\n{\n\tstruct gnttab_map_grant_ref VAR_4[VAR_5];\n\tstruct page *VAR_6[VAR_5];\n\tstruct persistent_gnt *persistent_gnt = NULL;\n\tphys_addr_t VAR_7 = 0;\n\tint VAR_8, VAR_9, VAR_10;\n\tint VAR_11 = 0;\n\tint VAR_12 = 0;\n\tint VAR_13 = 0, VAR_14 = 0;\n\tint VAR_15;\n\tstruct xen_blkif *VAR_16 = VAR_0->blkif;\n\n\tVAR_15 = (VAR_16->vbd.feature_gnt_persistent);\n\n\t/* COMMENT_0 */\n                                                                   \n                                                                  \n                                                \n    \nagain:\n\tfor (VAR_8 = VAR_14; VAR_8 < VAR_2; VAR_8++) {\n\t\tuint32_t VAR_17;\n\n\t\tif (VAR_15) {\n\t\t\tpersistent_gnt = get_persistent_gnt(\n\t\t\t\tVAR_0,\n\t\t\t\tVAR_1[VAR_8]->gref);\n\t\t}\n\n\t\tif (persistent_gnt) {\n\t\t\t/* COMMENT_5 */\n                                        \n                                 \n      \n\t\t\tVAR_1[VAR_8]->page = persistent_gnt->page;\n\t\t\tVAR_1[VAR_8]->persistent_gnt = persistent_gnt;\n\t\t} else {\n\t\t\tif (gnttab_page_cache_get(&VAR_0->free_pages,\n\t\t\t\t\t\t  &VAR_1[VAR_8]->page)) {\n\t\t\t\tgnttab_page_cache_put(&VAR_0->free_pages,\n\t\t\t\t\t\t      VAR_6,\n\t\t\t\t\t\t      VAR_11);\n\t\t\t\tVAR_12 = -VAR_18;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tVAR_7 = vaddr(VAR_1[VAR_8]->page);\n\t\t\tVAR_6[VAR_11] = VAR_1[VAR_8]->page;\n\t\t\tVAR_1[VAR_8]->persistent_gnt = NULL;\n\t\t\tVAR_17 = VAR_19;\n\t\t\tif (!VAR_15 && VAR_3)\n\t\t\t\tVAR_17 |= VAR_20;\n\t\t\tgnttab_set_map_op(&VAR_4[VAR_11++], VAR_7,\n\t\t\t\t\t  VAR_17, VAR_1[VAR_8]->gref,\n\t\t\t\t\t  VAR_16->domid);\n\t\t}\n\t\tVAR_14 = VAR_8 + 1;\n\t\tif (VAR_11 == VAR_5)\n\t\t\tbreak;\n\t}\n\n\tif (VAR_11)\n\t\tVAR_12 = gnttab_map_refs(VAR_4, NULL, VAR_6, VAR_11);\n\n\t/* COMMENT_9 */\n                                                                        \n                                                                      \n                                   \n    \n\tfor (VAR_9 = VAR_13, VAR_10 = 0; VAR_9 < VAR_14; VAR_9++) {\n\t\tif (!VAR_1[VAR_9]->persistent_gnt) {\n\t\t\t/* COMMENT_14 */\n\t\t\tBUG_ON(VAR_10 >= VAR_11);\n\t\t\tif (unlikely(VAR_4[VAR_10].status != 0)) {\n\t\t\t\tpr_debug(\"invalid buffer -- could not remap it\\n\");\n\t\t\t\tgnttab_page_cache_put(&VAR_0->free_pages,\n\t\t\t\t\t\t      &VAR_1[VAR_9]->page, 1);\n\t\t\t\tVAR_1[VAR_9]->handle = VAR_21;\n\t\t\t\tVAR_12 |= !VAR_12;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tVAR_1[VAR_9]->handle = VAR_4[VAR_10].handle;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_15 &&\n\t\t    VAR_0->persistent_gnt_c < VAR_22) {\n\t\t\t/* COMMENT_15 */\n                                                  \n                                               \n      \n\t\t\tpersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\n\t\t\t\t                 VAR_23);\n\t\t\tif (!persistent_gnt) {\n\t\t\t\t/* COMMENT_19 */\n                                        \n                                         \n                                     \n       \n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpersistent_gnt->gnt = VAR_4[VAR_10].ref;\n\t\t\tpersistent_gnt->handle = VAR_4[VAR_10].handle;\n\t\t\tpersistent_gnt->page = VAR_1[VAR_9]->page;\n\t\t\tif (add_persistent_gnt(VAR_0,\n\t\t\t                       persistent_gnt)) {\n\t\t\t\tkfree(persistent_gnt);\n\t\t\t\tpersistent_gnt = NULL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tVAR_1[VAR_9]->persistent_gnt = persistent_gnt;\n\t\t\tpr_debug(\"grant %u added to the tree of persistent grants, using %u/%u\\n\",\n\t\t\t\t persistent_gnt->gnt, VAR_0->persistent_gnt_c,\n\t\t\t\t VAR_22);\n\t\t\tgoto next;\n\t\t}\n\t\tif (VAR_15 && !VAR_16->vbd.overflow_max_grants) {\n\t\t\tVAR_16->vbd.overflow_max_grants = 1;\n\t\t\tpr_debug(\"domain %u, device %#x is using maximum number of persistent grants\\n\",\n\t\t\t         VAR_16->domid, VAR_16->vbd.handle);\n\t\t}\n\t\t/* COMMENT_24 */\n                                                           \n                            \n     \nnext:\n\t\tVAR_10++;\n\t}\n\tVAR_11 = 0;\n\tVAR_13 = VAR_14;\n\tif (!VAR_12 && VAR_14 != VAR_2)\n\t\tgoto again;\n\nout:\n\tfor (VAR_8 = VAR_13; VAR_8 < VAR_2; VAR_8++) {\n\t\t/* COMMENT_28 */\n\t\tif(VAR_8 >= VAR_13 + VAR_11)\n\t\t\tVAR_1[VAR_8]->persistent_gnt = NULL;\n\t\tVAR_1[VAR_8]->handle = VAR_21;\n\t}\n\n\treturn VAR_12;\n}",
    "func_graph_path": "torvalds/linux/871997bc9e423f05c7da7c9178e62dde5df2a7f8/blkback.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -39,8 +39,13 @@\n \t\t\tpages[i]->persistent_gnt = persistent_gnt;\n \t\t} else {\n \t\t\tif (gnttab_page_cache_get(&ring->free_pages,\n-\t\t\t\t\t\t  &pages[i]->page))\n-\t\t\t\tgoto out_of_memory;\n+\t\t\t\t\t\t  &pages[i]->page)) {\n+\t\t\t\tgnttab_page_cache_put(&ring->free_pages,\n+\t\t\t\t\t\t      pages_to_gnt,\n+\t\t\t\t\t\t      segs_to_map);\n+\t\t\t\tret = -ENOMEM;\n+\t\t\t\tgoto out;\n+\t\t\t}\n \t\t\taddr = vaddr(pages[i]->page);\n \t\t\tpages_to_gnt[segs_to_map] = pages[i]->page;\n \t\t\tpages[i]->persistent_gnt = NULL;\n@@ -125,15 +130,16 @@\n \t}\n \tsegs_to_map = 0;\n \tlast_map = map_until;\n-\tif (map_until != num)\n+\tif (!ret && map_until != num)\n \t\tgoto again;\n \n+out:\n+\tfor (i = last_map; i < num; i++) {\n+\t\t/* Don't zap current batch's valid persistent grants. */\n+\t\tif(i >= last_map + segs_to_map)\n+\t\t\tpages[i]->persistent_gnt = NULL;\n+\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;\n+\t}\n+\n \treturn ret;\n-\n-out_of_memory:\n-\tpr_alert(\"%s: out of memory\\n\", __func__);\n-\tgnttab_page_cache_put(&ring->free_pages, pages_to_gnt, segs_to_map);\n-\tfor (i = last_map; i < num; i++)\n-\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;\n-\treturn -ENOMEM;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t\t\t\t\t  &pages[i]->page))",
            "\t\t\t\tgoto out_of_memory;",
            "\tif (map_until != num)",
            "",
            "out_of_memory:",
            "\tpr_alert(\"%s: out of memory\\n\", __func__);",
            "\tgnttab_page_cache_put(&ring->free_pages, pages_to_gnt, segs_to_map);",
            "\tfor (i = last_map; i < num; i++)",
            "\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;",
            "\treturn -ENOMEM;"
        ],
        "added_lines": [
            "\t\t\t\t\t\t  &pages[i]->page)) {",
            "\t\t\t\tgnttab_page_cache_put(&ring->free_pages,",
            "\t\t\t\t\t\t      pages_to_gnt,",
            "\t\t\t\t\t\t      segs_to_map);",
            "\t\t\t\tret = -ENOMEM;",
            "\t\t\t\tgoto out;",
            "\t\t\t}",
            "\tif (!ret && map_until != num)",
            "out:",
            "\tfor (i = last_map; i < num; i++) {",
            "\t\t/* Don't zap current batch's valid persistent grants. */",
            "\t\tif(i >= last_map + segs_to_map)",
            "\t\t\tpages[i]->persistent_gnt = NULL;",
            "\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;",
            "\t}",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}