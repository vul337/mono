{
    "cve_id": "CVE-2009-0746",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "Make sure the rec_len field in the '..' entry is sane, lest we overrun\nthe directory block and cause a kernel oops on a purposefully\ncorrupted filesystem.\n\nThanks to Sami Liedes for reporting this bug.\n\nhttp://bugzilla.kernel.org/show_bug.cgi?id=12430\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org\n",
    "commit_hash": "e6b8bc09ba2075cd91fbffefcd2778b1a00bd76f",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=e6b8bc09ba2075cd91fbffefcd2778b1a00bd76f",
    "file_path": "fs/ext4/namei.c",
    "func_name": "make_indexed_dir",
    "func_before": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\tbh2 = ext4_append(handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len));\n\tlen = ((char *) root) + blocksize - (char *) de;\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tdx_release (frames);\n\tif (!(de))\n\t\treturn retval;\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
    "abstract_func_before": "static int make_indexed_dir(handle_t *VAR_0, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *VAR_1)\n{\n\tstruct inode\t*VAR_2 = dentry->d_parent->d_inode;\n\tconst char\t*VAR_3 = dentry->d_name.name;\n\tint\t\tVAR_4 = dentry->d_name.len;\n\tstruct buffer_head *VAR_5;\n\tstruct dx_root\t*VAR_6;\n\tstruct dx_frame\tVAR_7[2], *VAR_8;\n\tstruct dx_entry *VAR_9;\n\tstruct ext4_dir_entry_2\t*VAR_10, *VAR_11;\n\tchar\t\t*VAR_12, *VAR_13;\n\tunsigned\tVAR_14;\n\tint\t\tVAR_15;\n\tunsigned\tVAR_16;\n\tstruct dx_hash_info VAR_17;\n\text4_lblk_t  VAR_18;\n\tstruct fake_dirent *VAR_19;\n\n\tVAR_16 =  VAR_2->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));\n\tVAR_15 = ext4_journal_get_write_access(VAR_0, VAR_1);\n\tif (VAR_15) {\n\t\text4_std_error(VAR_2->i_sb, VAR_15);\n\t\tbrelse(VAR_1);\n\t\treturn VAR_15;\n\t}\n\tVAR_6 = (struct dx_root *) VAR_1->b_data;\n\n\tVAR_5 = ext4_append(VAR_0, VAR_2, &VAR_18, &VAR_15);\n\tif (!(VAR_5)) {\n\t\tbrelse(VAR_1);\n\t\treturn VAR_15;\n\t}\n\tEXT4_I(VAR_2)->i_flags |= VAR_20;\n\tVAR_12 = VAR_5->b_data;\n\n\t/* COMMENT_0 */\n\tVAR_19 = &VAR_6->dotdot;\n\tVAR_10 = (struct ext4_dir_entry_2 *)((char *)VAR_19 +\n\t\text4_rec_len_from_disk(VAR_19->rec_len));\n\tVAR_14 = ((char *) VAR_6) + VAR_16 - (char *) VAR_10;\n\tmemcpy (VAR_12, VAR_10, VAR_14);\n\tVAR_10 = (struct ext4_dir_entry_2 *) VAR_12;\n\tVAR_13 = VAR_12 + VAR_14;\n\twhile ((char *)(VAR_11 = ext4_next_entry(VAR_10)) < VAR_13)\n\t\tVAR_10 = VAR_11;\n\tVAR_10->rec_len = ext4_rec_len_to_disk(VAR_12 + VAR_16 - (char *) VAR_10);\n\t/* COMMENT_1 */\n\tVAR_10 = (struct ext4_dir_entry_2 *) (&VAR_6->dotdot);\n\tVAR_10->rec_len = ext4_rec_len_to_disk(VAR_16 - EXT4_DIR_REC_LEN(2));\n\tmemset (&VAR_6->info, 0, sizeof(VAR_6->info));\n\tVAR_6->info.info_length = sizeof(VAR_6->info);\n\tVAR_6->info.hash_version = EXT4_SB(VAR_2->i_sb)->s_def_hash_version;\n\tVAR_9 = VAR_6->entries;\n\tdx_set_block(VAR_9, 1);\n\tdx_set_count(VAR_9, 1);\n\tdx_set_limit(VAR_9, dx_root_limit(VAR_2, sizeof(VAR_6->info)));\n\n\t/* COMMENT_2 */\n\tVAR_17.hash_version = VAR_6->info.hash_version;\n\tif (VAR_17.hash_version <= VAR_21)\n\t\tVAR_17.hash_version += EXT4_SB(VAR_2->i_sb)->s_hash_unsigned;\n\tVAR_17.seed = EXT4_SB(VAR_2->i_sb)->s_hash_seed;\n\text4fs_dirhash(VAR_3, VAR_4, &VAR_17);\n\tVAR_8 = VAR_7;\n\tVAR_8->entries = VAR_9;\n\tVAR_8->at = VAR_9;\n\tVAR_8->bh = VAR_1;\n\tVAR_1 = VAR_5;\n\tVAR_10 = do_split(VAR_0,VAR_2, &VAR_1, VAR_8, &VAR_17, &VAR_15);\n\tdx_release (VAR_7);\n\tif (!(VAR_10))\n\t\treturn VAR_15;\n\n\treturn add_dirent_to_buf(VAR_0, dentry, inode, VAR_10, VAR_1);\n}",
    "func_graph_path_before": "torvalds/linux/e6b8bc09ba2075cd91fbffefcd2778b1a00bd76f/namei.c/vul/before/0.json",
    "func": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\text4_error(dir->i_sb, __func__,\n\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n\t\t\t   dir->i_ino);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + blocksize - (char *) de;\n\n\t/* Allocate new block for the 0th block's dirents */\n\tbh2 = ext4_append(handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tdx_release (frames);\n\tif (!(de))\n\t\treturn retval;\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
    "abstract_func": "static int make_indexed_dir(handle_t *VAR_0, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *VAR_1)\n{\n\tstruct inode\t*VAR_2 = dentry->d_parent->d_inode;\n\tconst char\t*VAR_3 = dentry->d_name.name;\n\tint\t\tVAR_4 = dentry->d_name.len;\n\tstruct buffer_head *VAR_5;\n\tstruct dx_root\t*VAR_6;\n\tstruct dx_frame\tVAR_7[2], *VAR_8;\n\tstruct dx_entry *VAR_9;\n\tstruct ext4_dir_entry_2\t*VAR_10, *VAR_11;\n\tchar\t\t*VAR_12, *VAR_13;\n\tunsigned\tVAR_14;\n\tint\t\tVAR_15;\n\tunsigned\tVAR_16;\n\tstruct dx_hash_info VAR_17;\n\text4_lblk_t  VAR_18;\n\tstruct fake_dirent *VAR_19;\n\n\tVAR_16 =  VAR_2->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", VAR_2->i_ino));\n\tVAR_15 = ext4_journal_get_write_access(VAR_0, VAR_1);\n\tif (VAR_15) {\n\t\text4_std_error(VAR_2->i_sb, VAR_15);\n\t\tbrelse(VAR_1);\n\t\treturn VAR_15;\n\t}\n\tVAR_6 = (struct dx_root *) VAR_1->b_data;\n\n\t/* COMMENT_0 */\n\tVAR_19 = &VAR_6->dotdot;\n\tVAR_10 = (struct ext4_dir_entry_2 *)((char *)VAR_19 +\n\t\text4_rec_len_from_disk(VAR_19->rec_len));\n\tif ((char *) VAR_10 >= (((char *) VAR_6) + VAR_16)) {\n\t\text4_error(VAR_2->i_sb, VAR_20,\n\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n\t\t\t   VAR_2->i_ino);\n\t\tbrelse(VAR_1);\n\t\treturn -VAR_21;\n\t}\n\tVAR_14 = ((char *) VAR_6) + VAR_16 - (char *) VAR_10;\n\n\t/* COMMENT_1 */\n\tVAR_5 = ext4_append(VAR_0, VAR_2, &VAR_18, &VAR_15);\n\tif (!(VAR_5)) {\n\t\tbrelse(VAR_1);\n\t\treturn VAR_15;\n\t}\n\tEXT4_I(VAR_2)->i_flags |= VAR_22;\n\tVAR_12 = VAR_5->b_data;\n\n\tmemcpy (VAR_12, VAR_10, VAR_14);\n\tVAR_10 = (struct ext4_dir_entry_2 *) VAR_12;\n\tVAR_13 = VAR_12 + VAR_14;\n\twhile ((char *)(VAR_11 = ext4_next_entry(VAR_10)) < VAR_13)\n\t\tVAR_10 = VAR_11;\n\tVAR_10->rec_len = ext4_rec_len_to_disk(VAR_12 + VAR_16 - (char *) VAR_10);\n\t/* COMMENT_2 */\n\tVAR_10 = (struct ext4_dir_entry_2 *) (&VAR_6->dotdot);\n\tVAR_10->rec_len = ext4_rec_len_to_disk(VAR_16 - EXT4_DIR_REC_LEN(2));\n\tmemset (&VAR_6->info, 0, sizeof(VAR_6->info));\n\tVAR_6->info.info_length = sizeof(VAR_6->info);\n\tVAR_6->info.hash_version = EXT4_SB(VAR_2->i_sb)->s_def_hash_version;\n\tVAR_9 = VAR_6->entries;\n\tdx_set_block(VAR_9, 1);\n\tdx_set_count(VAR_9, 1);\n\tdx_set_limit(VAR_9, dx_root_limit(VAR_2, sizeof(VAR_6->info)));\n\n\t/* COMMENT_3 */\n\tVAR_17.hash_version = VAR_6->info.hash_version;\n\tif (VAR_17.hash_version <= VAR_23)\n\t\tVAR_17.hash_version += EXT4_SB(VAR_2->i_sb)->s_hash_unsigned;\n\tVAR_17.seed = EXT4_SB(VAR_2->i_sb)->s_hash_seed;\n\text4fs_dirhash(VAR_3, VAR_4, &VAR_17);\n\tVAR_8 = VAR_7;\n\tVAR_8->entries = VAR_9;\n\tVAR_8->at = VAR_9;\n\tVAR_8->bh = VAR_1;\n\tVAR_1 = VAR_5;\n\tVAR_10 = do_split(VAR_0,VAR_2, &VAR_1, VAR_8, &VAR_17, &VAR_15);\n\tdx_release (VAR_7);\n\tif (!(VAR_10))\n\t\treturn VAR_15;\n\n\treturn add_dirent_to_buf(VAR_0, dentry, inode, VAR_10, VAR_1);\n}",
    "func_graph_path": "torvalds/linux/e6b8bc09ba2075cd91fbffefcd2778b1a00bd76f/namei.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n \tstruct fake_dirent *fde;\n \n \tblocksize =  dir->i_sb->s_blocksize;\n-\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));\n+\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n \tretval = ext4_journal_get_write_access(handle, bh);\n \tif (retval) {\n \t\text4_std_error(dir->i_sb, retval);\n@@ -27,6 +27,20 @@\n \t}\n \troot = (struct dx_root *) bh->b_data;\n \n+\t/* The 0th block becomes the root, move the dirents out */\n+\tfde = &root->dotdot;\n+\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n+\t\text4_rec_len_from_disk(fde->rec_len));\n+\tif ((char *) de >= (((char *) root) + blocksize)) {\n+\t\text4_error(dir->i_sb, __func__,\n+\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n+\t\t\t   dir->i_ino);\n+\t\tbrelse(bh);\n+\t\treturn -EIO;\n+\t}\n+\tlen = ((char *) root) + blocksize - (char *) de;\n+\n+\t/* Allocate new block for the 0th block's dirents */\n \tbh2 = ext4_append(handle, dir, &block, &retval);\n \tif (!(bh2)) {\n \t\tbrelse(bh);\n@@ -35,11 +49,6 @@\n \tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n \tdata1 = bh2->b_data;\n \n-\t/* The 0th block becomes the root, move the dirents out */\n-\tfde = &root->dotdot;\n-\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n-\t\text4_rec_len_from_disk(fde->rec_len));\n-\tlen = ((char *) root) + blocksize - (char *) de;\n \tmemcpy (data1, de, len);\n \tde = (struct ext4_dir_entry_2 *) data1;\n \ttop = data1 + len;",
    "diff_line_info": {
        "deleted_lines": [
            "\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));",
            "\t/* The 0th block becomes the root, move the dirents out */",
            "\tfde = &root->dotdot;",
            "\tde = (struct ext4_dir_entry_2 *)((char *)fde +",
            "\t\text4_rec_len_from_disk(fde->rec_len));",
            "\tlen = ((char *) root) + blocksize - (char *) de;"
        ],
        "added_lines": [
            "\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));",
            "\t/* The 0th block becomes the root, move the dirents out */",
            "\tfde = &root->dotdot;",
            "\tde = (struct ext4_dir_entry_2 *)((char *)fde +",
            "\t\text4_rec_len_from_disk(fde->rec_len));",
            "\tif ((char *) de >= (((char *) root) + blocksize)) {",
            "\t\text4_error(dir->i_sb, __func__,",
            "\t\t\t   \"invalid rec_len for '..' in inode %lu\",",
            "\t\t\t   dir->i_ino);",
            "\t\tbrelse(bh);",
            "\t\treturn -EIO;",
            "\t}",
            "\tlen = ((char *) root) + blocksize - (char *) de;",
            "",
            "\t/* Allocate new block for the 0th block's dirents */"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}