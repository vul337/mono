{
    "cve_id": "CVE-2014-0181",
    "cwe_ids": [
        "CWE-264"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "kernel/git/netdev/net",
    "commit_msg": "It is possible by passing a netlink socket to a more privileged\nexecutable and then to fool that executable into writing to the socket\ndata that happens to be valid netlink message to do something that\nprivileged executable did not intend to do.\n\nTo keep this from happening replace bare capable and ns_capable calls\nwith netlink_capable, netlink_net_calls and netlink_ns_capable calls.\nWhich act the same as the previous calls except they verify that the\nopener of the socket had the desired permissions as well.\n\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n",
    "commit_hash": "90f62cf30a78721641e08737bda787552428061e",
    "git_url": "https://git.kernel.org/cgit/linux/kernel/git/davem/net.git/commit/?h=90f62cf30a78721641e08737bda787552428061e",
    "file_path": "net/netlink/genetlink.c",
    "func_name": "genl_family_rcv_msg",
    "func_before": "static int genl_family_rcv_msg(struct genl_family *family,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct nlmsghdr *nlh)\n{\n\tconst struct genl_ops *ops;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct genl_info info;\n\tstruct genlmsghdr *hdr = nlmsg_data(nlh);\n\tstruct nlattr **attrbuf;\n\tint hdrlen, err;\n\n\t/* this family doesn't exist in this netns */\n\tif (!family->netnsok && !net_eq(net, &init_net))\n\t\treturn -ENOENT;\n\n\thdrlen = GENL_HDRLEN + family->hdrsize;\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\n\tops = genl_get_cmd(hdr->cmd, family);\n\tif (ops == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((ops->flags & GENL_ADMIN_PERM) &&\n\t    !capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {\n\t\tint rc;\n\n\t\tif (ops->dumpit == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!family->parallel_ops) {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.module = family->module,\n\t\t\t\t/* we have const, but the netlink API doesn't */\n\t\t\t\t.data = (void *)ops,\n\t\t\t\t.dump = genl_lock_dumpit,\n\t\t\t\t.done = genl_lock_done,\n\t\t\t};\n\n\t\t\tgenl_unlock();\n\t\t\trc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\t\t\tgenl_lock();\n\n\t\t} else {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.module = family->module,\n\t\t\t\t.dump = ops->dumpit,\n\t\t\t\t.done = ops->done,\n\t\t\t};\n\n\t\t\trc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tif (ops->doit == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (family->maxattr && family->parallel_ops) {\n\t\tattrbuf = kmalloc((family->maxattr+1) *\n\t\t\t\t\tsizeof(struct nlattr *), GFP_KERNEL);\n\t\tif (attrbuf == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tattrbuf = family->attrbuf;\n\n\tif (attrbuf) {\n\t\terr = nlmsg_parse(nlh, hdrlen, attrbuf, family->maxattr,\n\t\t\t\t  ops->policy);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tinfo.snd_seq = nlh->nlmsg_seq;\n\tinfo.snd_portid = NETLINK_CB(skb).portid;\n\tinfo.nlhdr = nlh;\n\tinfo.genlhdr = nlmsg_data(nlh);\n\tinfo.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;\n\tinfo.attrs = attrbuf;\n\tinfo.dst_sk = skb->sk;\n\tgenl_info_net_set(&info, net);\n\tmemset(&info.user_ptr, 0, sizeof(info.user_ptr));\n\n\tif (family->pre_doit) {\n\t\terr = family->pre_doit(ops, skb, &info);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = ops->doit(skb, &info);\n\n\tif (family->post_doit)\n\t\tfamily->post_doit(ops, skb, &info);\n\nout:\n\tif (family->parallel_ops)\n\t\tkfree(attrbuf);\n\n\treturn err;\n}",
    "abstract_func_before": "static int genl_family_rcv_msg(struct genl_family *VAR_0,\n\t\t\t       struct sk_buff *VAR_1,\n\t\t\t       struct nlmsghdr *VAR_2)\n{\n\tconst struct genl_ops *VAR_3;\n\tstruct net *net = sock_net(VAR_1->sk);\n\tstruct genl_info VAR_4;\n\tstruct genlmsghdr *VAR_5 = nlmsg_data(VAR_2);\n\tstruct nlattr **VAR_6;\n\tint VAR_7, VAR_8;\n\n\t/* COMMENT_0 */\n\tif (!VAR_0->netnsok && !net_eq(net, &VAR_9))\n\t\treturn -VAR_10;\n\n\tVAR_7 = VAR_11 + VAR_0->hdrsize;\n\tif (VAR_2->nlmsg_len < nlmsg_msg_size(VAR_7))\n\t\treturn -VAR_12;\n\n\tVAR_3 = genl_get_cmd(VAR_5->cmd, VAR_0);\n\tif (VAR_3 == NULL)\n\t\treturn -VAR_13;\n\n\tif ((VAR_3->flags & VAR_14) &&\n\t    !capable(VAR_15))\n\t\treturn -VAR_16;\n\n\tif ((VAR_2->nlmsg_flags & VAR_17) == VAR_17) {\n\t\tint VAR_18;\n\n\t\tif (VAR_3->dumpit == NULL)\n\t\t\treturn -VAR_13;\n\n\t\tif (!VAR_0->parallel_ops) {\n\t\t\tstruct netlink_dump_control VAR_19 = {\n\t\t\t\t.module = VAR_0->module,\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\t.data = (void *)VAR_3,\n\t\t\t\t.dump = VAR_20,\n\t\t\t\t.done = VAR_21,\n\t\t\t};\n\n\t\t\tgenl_unlock();\n\t\t\tVAR_18 = __netlink_dump_start(net->genl_sock, VAR_1, VAR_2, &VAR_19);\n\t\t\tgenl_lock();\n\n\t\t} else {\n\t\t\tstruct netlink_dump_control VAR_19 = {\n\t\t\t\t.module = VAR_0->module,\n\t\t\t\t.dump = VAR_3->dumpit,\n\t\t\t\t.done = VAR_3->done,\n\t\t\t};\n\n\t\t\tVAR_18 = __netlink_dump_start(net->genl_sock, VAR_1, VAR_2, &VAR_19);\n\t\t}\n\n\t\treturn VAR_18;\n\t}\n\n\tif (VAR_3->doit == NULL)\n\t\treturn -VAR_13;\n\n\tif (VAR_0->maxattr && VAR_0->parallel_ops) {\n\t\tVAR_6 = kmalloc((VAR_0->maxattr+1) *\n\t\t\t\t\tsizeof(struct nlattr *), VAR_22);\n\t\tif (VAR_6 == NULL)\n\t\t\treturn -VAR_23;\n\t} else\n\t\tVAR_6 = VAR_0->attrbuf;\n\n\tif (VAR_6) {\n\t\tVAR_8 = nlmsg_parse(VAR_2, VAR_7, VAR_6, VAR_0->maxattr,\n\t\t\t\t  VAR_3->policy);\n\t\tif (VAR_8 < 0)\n\t\t\tgoto out;\n\t}\n\n\tVAR_4.snd_seq = VAR_2->nlmsg_seq;\n\tVAR_4.snd_portid = NETLINK_CB(VAR_1).portid;\n\tVAR_4.nlhdr = VAR_2;\n\tVAR_4.genlhdr = nlmsg_data(VAR_2);\n\tVAR_4.userhdr = nlmsg_data(VAR_2) + VAR_11;\n\tVAR_4.attrs = VAR_6;\n\tVAR_4.dst_sk = VAR_1->sk;\n\tgenl_info_net_set(&VAR_4, net);\n\tmemset(&VAR_4.user_ptr, 0, sizeof(VAR_4.user_ptr));\n\n\tif (VAR_0->pre_doit) {\n\t\tVAR_8 = VAR_0->pre_doit(VAR_3, VAR_1, &VAR_4);\n\t\tif (VAR_8)\n\t\t\tgoto out;\n\t}\n\n\tVAR_8 = VAR_3->doit(VAR_1, &VAR_4);\n\n\tif (VAR_0->post_doit)\n\t\tVAR_0->post_doit(VAR_3, VAR_1, &VAR_4);\n\nout:\n\tif (VAR_0->parallel_ops)\n\t\tkfree(VAR_6);\n\n\treturn VAR_8;\n}",
    "func_graph_path_before": "kernel/git/netdev/net/90f62cf30a78721641e08737bda787552428061e/genetlink.c/vul/before/0.json",
    "func": "static int genl_family_rcv_msg(struct genl_family *family,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct nlmsghdr *nlh)\n{\n\tconst struct genl_ops *ops;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct genl_info info;\n\tstruct genlmsghdr *hdr = nlmsg_data(nlh);\n\tstruct nlattr **attrbuf;\n\tint hdrlen, err;\n\n\t/* this family doesn't exist in this netns */\n\tif (!family->netnsok && !net_eq(net, &init_net))\n\t\treturn -ENOENT;\n\n\thdrlen = GENL_HDRLEN + family->hdrsize;\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\n\tops = genl_get_cmd(hdr->cmd, family);\n\tif (ops == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((ops->flags & GENL_ADMIN_PERM) &&\n\t    !netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {\n\t\tint rc;\n\n\t\tif (ops->dumpit == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!family->parallel_ops) {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.module = family->module,\n\t\t\t\t/* we have const, but the netlink API doesn't */\n\t\t\t\t.data = (void *)ops,\n\t\t\t\t.dump = genl_lock_dumpit,\n\t\t\t\t.done = genl_lock_done,\n\t\t\t};\n\n\t\t\tgenl_unlock();\n\t\t\trc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\t\t\tgenl_lock();\n\n\t\t} else {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.module = family->module,\n\t\t\t\t.dump = ops->dumpit,\n\t\t\t\t.done = ops->done,\n\t\t\t};\n\n\t\t\trc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tif (ops->doit == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (family->maxattr && family->parallel_ops) {\n\t\tattrbuf = kmalloc((family->maxattr+1) *\n\t\t\t\t\tsizeof(struct nlattr *), GFP_KERNEL);\n\t\tif (attrbuf == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tattrbuf = family->attrbuf;\n\n\tif (attrbuf) {\n\t\terr = nlmsg_parse(nlh, hdrlen, attrbuf, family->maxattr,\n\t\t\t\t  ops->policy);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tinfo.snd_seq = nlh->nlmsg_seq;\n\tinfo.snd_portid = NETLINK_CB(skb).portid;\n\tinfo.nlhdr = nlh;\n\tinfo.genlhdr = nlmsg_data(nlh);\n\tinfo.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;\n\tinfo.attrs = attrbuf;\n\tinfo.dst_sk = skb->sk;\n\tgenl_info_net_set(&info, net);\n\tmemset(&info.user_ptr, 0, sizeof(info.user_ptr));\n\n\tif (family->pre_doit) {\n\t\terr = family->pre_doit(ops, skb, &info);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = ops->doit(skb, &info);\n\n\tif (family->post_doit)\n\t\tfamily->post_doit(ops, skb, &info);\n\nout:\n\tif (family->parallel_ops)\n\t\tkfree(attrbuf);\n\n\treturn err;\n}",
    "abstract_func": "static int genl_family_rcv_msg(struct genl_family *VAR_0,\n\t\t\t       struct sk_buff *VAR_1,\n\t\t\t       struct nlmsghdr *VAR_2)\n{\n\tconst struct genl_ops *VAR_3;\n\tstruct net *net = sock_net(VAR_1->sk);\n\tstruct genl_info VAR_4;\n\tstruct genlmsghdr *VAR_5 = nlmsg_data(VAR_2);\n\tstruct nlattr **VAR_6;\n\tint VAR_7, VAR_8;\n\n\t/* COMMENT_0 */\n\tif (!VAR_0->netnsok && !net_eq(net, &VAR_9))\n\t\treturn -VAR_10;\n\n\tVAR_7 = VAR_11 + VAR_0->hdrsize;\n\tif (VAR_2->nlmsg_len < nlmsg_msg_size(VAR_7))\n\t\treturn -VAR_12;\n\n\tVAR_3 = genl_get_cmd(VAR_5->cmd, VAR_0);\n\tif (VAR_3 == NULL)\n\t\treturn -VAR_13;\n\n\tif ((VAR_3->flags & VAR_14) &&\n\t    !netlink_capable(VAR_1, VAR_15))\n\t\treturn -VAR_16;\n\n\tif ((VAR_2->nlmsg_flags & VAR_17) == VAR_17) {\n\t\tint VAR_18;\n\n\t\tif (VAR_3->dumpit == NULL)\n\t\t\treturn -VAR_13;\n\n\t\tif (!VAR_0->parallel_ops) {\n\t\t\tstruct netlink_dump_control VAR_19 = {\n\t\t\t\t.module = VAR_0->module,\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\t.data = (void *)VAR_3,\n\t\t\t\t.dump = VAR_20,\n\t\t\t\t.done = VAR_21,\n\t\t\t};\n\n\t\t\tgenl_unlock();\n\t\t\tVAR_18 = __netlink_dump_start(net->genl_sock, VAR_1, VAR_2, &VAR_19);\n\t\t\tgenl_lock();\n\n\t\t} else {\n\t\t\tstruct netlink_dump_control VAR_19 = {\n\t\t\t\t.module = VAR_0->module,\n\t\t\t\t.dump = VAR_3->dumpit,\n\t\t\t\t.done = VAR_3->done,\n\t\t\t};\n\n\t\t\tVAR_18 = __netlink_dump_start(net->genl_sock, VAR_1, VAR_2, &VAR_19);\n\t\t}\n\n\t\treturn VAR_18;\n\t}\n\n\tif (VAR_3->doit == NULL)\n\t\treturn -VAR_13;\n\n\tif (VAR_0->maxattr && VAR_0->parallel_ops) {\n\t\tVAR_6 = kmalloc((VAR_0->maxattr+1) *\n\t\t\t\t\tsizeof(struct nlattr *), VAR_22);\n\t\tif (VAR_6 == NULL)\n\t\t\treturn -VAR_23;\n\t} else\n\t\tVAR_6 = VAR_0->attrbuf;\n\n\tif (VAR_6) {\n\t\tVAR_8 = nlmsg_parse(VAR_2, VAR_7, VAR_6, VAR_0->maxattr,\n\t\t\t\t  VAR_3->policy);\n\t\tif (VAR_8 < 0)\n\t\t\tgoto out;\n\t}\n\n\tVAR_4.snd_seq = VAR_2->nlmsg_seq;\n\tVAR_4.snd_portid = NETLINK_CB(VAR_1).portid;\n\tVAR_4.nlhdr = VAR_2;\n\tVAR_4.genlhdr = nlmsg_data(VAR_2);\n\tVAR_4.userhdr = nlmsg_data(VAR_2) + VAR_11;\n\tVAR_4.attrs = VAR_6;\n\tVAR_4.dst_sk = VAR_1->sk;\n\tgenl_info_net_set(&VAR_4, net);\n\tmemset(&VAR_4.user_ptr, 0, sizeof(VAR_4.user_ptr));\n\n\tif (VAR_0->pre_doit) {\n\t\tVAR_8 = VAR_0->pre_doit(VAR_3, VAR_1, &VAR_4);\n\t\tif (VAR_8)\n\t\t\tgoto out;\n\t}\n\n\tVAR_8 = VAR_3->doit(VAR_1, &VAR_4);\n\n\tif (VAR_0->post_doit)\n\t\tVAR_0->post_doit(VAR_3, VAR_1, &VAR_4);\n\nout:\n\tif (VAR_0->parallel_ops)\n\t\tkfree(VAR_6);\n\n\treturn VAR_8;\n}",
    "func_graph_path": "kernel/git/netdev/net/90f62cf30a78721641e08737bda787552428061e/genetlink.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n \t\treturn -EOPNOTSUPP;\n \n \tif ((ops->flags & GENL_ADMIN_PERM) &&\n-\t    !capable(CAP_NET_ADMIN))\n+\t    !netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {",
    "diff_line_info": {
        "deleted_lines": [
            "\t    !capable(CAP_NET_ADMIN))"
        ],
        "added_lines": [
            "\t    !netlink_capable(skb, CAP_NET_ADMIN))"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}