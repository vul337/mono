{
    "cve_id": "CVE-2016-2550",
    "cwe_ids": [
        "CWE-399"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "unix: correctly track in-flight fds in sending process user_struct\n\nThe commit referenced in the Fixes tag incorrectly accounted the number\nof in-flight fds over a unix domain socket to the original opener\nof the file-descriptor. This allows another process to arbitrary\ndeplete the original file-openers resource limit for the maximum of\nopen files. Instead the sending processes and its struct cred should\nbe credited.\n\nTo do so, we add a reference counted struct user_struct pointer to the\nscm_fp_list and use it to account for the number of inflight unix fds.\n\nFixes: 712f4aad406bb1 (\"unix: properly account for FDs passed over unix sockets\")\nReported-by: David Herrmann <dh.herrmann@gmail.com>\nCc: David Herrmann <dh.herrmann@gmail.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "commit_hash": "415e3d3e90ce9e18727e8843ae343eda5a58fad6",
    "git_url": "https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6",
    "file_path": "net/core/scm.c",
    "func_name": "scm_fp_copy",
    "func_before": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (num <= 0)\n\t\treturn 0;\n\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t\tfpl->max = SCM_MAX_FD;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\n\tif (fpl->count + num > fpl->max)\n\t\treturn -EINVAL;\n\n\t/*\n\t *\tVerify the descriptors and increment the usage count.\n\t */\n\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\n\t\tif (fd < 0 || !(file = fget_raw(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\treturn num;\n}",
    "abstract_func_before": "static int scm_fp_copy(struct cmsghdr *VAR_0, struct scm_fp_list **VAR_1)\n{\n\tint *VAR_2 = (int*)CMSG_DATA(VAR_0);\n\tstruct scm_fp_list *VAR_3 = *VAR_1;\n\tstruct file **VAR_4;\n\tint VAR_5, VAR_6;\n\n\tVAR_6 = (VAR_0->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (VAR_6 <= 0)\n\t\treturn 0;\n\n\tif (VAR_6 > VAR_7)\n\t\treturn -VAR_8;\n\n\tif (!VAR_3)\n\t{\n\t\tVAR_3 = kmalloc(sizeof(struct scm_fp_list), VAR_9);\n\t\tif (!VAR_3)\n\t\t\treturn -VAR_10;\n\t\t*VAR_1 = VAR_3;\n\t\tVAR_3->count = 0;\n\t\tVAR_3->max = VAR_7;\n\t}\n\tVAR_4 = &VAR_3->fp[VAR_3->count];\n\n\tif (VAR_3->count + VAR_6 > VAR_3->max)\n\t\treturn -VAR_8;\n\n\t/* COMMENT_0 */\n                                                         \n    \n\n\tfor (VAR_5=0; VAR_5< VAR_6; VAR_5++)\n\t{\n\t\tint VAR_11 = VAR_2[VAR_5];\n\t\tstruct file *file;\n\n\t\tif (VAR_11 < 0 || !(file = fget_raw(VAR_11)))\n\t\t\treturn -VAR_12;\n\t\t*VAR_4++ = file;\n\t\tVAR_3->count++;\n\t}\n\treturn VAR_6;\n}",
    "func_graph_path_before": "torvalds/linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6/scm.c/vul/before/1.json",
    "func": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (num <= 0)\n\t\treturn 0;\n\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->user = NULL;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\n\tif (fpl->count + num > fpl->max)\n\t\treturn -EINVAL;\n\n\t/*\n\t *\tVerify the descriptors and increment the usage count.\n\t */\n\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\n\t\tif (fd < 0 || !(file = fget_raw(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\n\tif (!fpl->user)\n\t\tfpl->user = get_uid(current_user());\n\n\treturn num;\n}",
    "abstract_func": "static int scm_fp_copy(struct cmsghdr *VAR_0, struct scm_fp_list **VAR_1)\n{\n\tint *VAR_2 = (int*)CMSG_DATA(VAR_0);\n\tstruct scm_fp_list *VAR_3 = *VAR_1;\n\tstruct file **VAR_4;\n\tint VAR_5, VAR_6;\n\n\tVAR_6 = (VAR_0->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (VAR_6 <= 0)\n\t\treturn 0;\n\n\tif (VAR_6 > VAR_7)\n\t\treturn -VAR_8;\n\n\tif (!VAR_3)\n\t{\n\t\tVAR_3 = kmalloc(sizeof(struct scm_fp_list), VAR_9);\n\t\tif (!VAR_3)\n\t\t\treturn -VAR_10;\n\t\t*VAR_1 = VAR_3;\n\t\tVAR_3->count = 0;\n\t\tVAR_3->max = VAR_7;\n\t\tVAR_3->user = NULL;\n\t}\n\tVAR_4 = &VAR_3->fp[VAR_3->count];\n\n\tif (VAR_3->count + VAR_6 > VAR_3->max)\n\t\treturn -VAR_8;\n\n\t/* COMMENT_0 */\n                                                         \n    \n\n\tfor (VAR_5=0; VAR_5< VAR_6; VAR_5++)\n\t{\n\t\tint VAR_11 = VAR_2[VAR_5];\n\t\tstruct file *file;\n\n\t\tif (VAR_11 < 0 || !(file = fget_raw(VAR_11)))\n\t\t\treturn -VAR_12;\n\t\t*VAR_4++ = file;\n\t\tVAR_3->count++;\n\t}\n\n\tif (!VAR_3->user)\n\t\tVAR_3->user = get_uid(current_user());\n\n\treturn VAR_6;\n}",
    "func_graph_path": "torvalds/linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6/scm.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,7 @@\n \t\t*fplp = fpl;\n \t\tfpl->count = 0;\n \t\tfpl->max = SCM_MAX_FD;\n+\t\tfpl->user = NULL;\n \t}\n \tfpp = &fpl->fp[fpl->count];\n \n@@ -41,5 +42,9 @@\n \t\t*fpp++ = file;\n \t\tfpl->count++;\n \t}\n+\n+\tif (!fpl->user)\n+\t\tfpl->user = get_uid(current_user());\n+\n \treturn num;\n }",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\tfpl->user = NULL;",
            "",
            "\tif (!fpl->user)",
            "\t\tfpl->user = get_uid(current_user());",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}