{
    "cve_id": "CVE-2021-45293",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "WebAssembly/binaryen",
    "commit_msg": "Add requireFunctionContext in necessary places",
    "commit_hash": "27135d613f929214dd2f74ca106f32310bc7e65b",
    "git_url": "https://github.com/WebAssembly/binaryen/commit/27135d613f929214dd2f74ca106f32310bc7e65b",
    "file_path": "src/wasm/wasm-binary.cpp",
    "func_name": "WasmBinaryBuilder::pushExpression",
    "func_before": "void WasmBinaryBuilder::pushExpression(Expression* curr) {\n  auto type = curr->type;\n  if (type.isTuple()) {\n    // Store tuple to local and push individual extracted values\n    Builder builder(wasm);\n    // Non-nullable types require special handling as they cannot be stored to\n    // a local.\n    std::vector<Type> finalTypes;\n    if (!wasm.features.hasGCNNLocals()) {\n      for (auto t : type) {\n        if (t.isNonNullable()) {\n          t = Type(t.getHeapType(), Nullable);\n        }\n        finalTypes.push_back(t);\n      }\n    }\n    auto nullableType = Type(Tuple(finalTypes));\n    Index tuple = builder.addVar(currFunction, nullableType);\n    expressionStack.push_back(builder.makeLocalSet(tuple, curr));\n    for (Index i = 0; i < nullableType.size(); ++i) {\n      Expression* value =\n        builder.makeTupleExtract(builder.makeLocalGet(tuple, nullableType), i);\n      if (nullableType[i] != type[i]) {\n        // We modified this to be nullable; undo that.\n        value = builder.makeRefAs(RefAsNonNull, value);\n      }\n      expressionStack.push_back(value);\n    }\n  } else {\n    expressionStack.push_back(curr);\n  }\n}",
    "abstract_func_before": "void WasmBinaryBuilder::pushExpression(Expression* VAR_0) {\n  auto VAR_1 = VAR_0->type;\n  if (VAR_1.isTuple()) {\n    /* COMMENT_0 */\n    Builder builder(wasm);\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    std::vector<Type> VAR_2;\n    if (!wasm.features.hasGCNNLocals()) {\n      for (auto VAR_3 : VAR_1) {\n        if (VAR_3.isNonNullable()) {\n          VAR_3 = Type(VAR_3.getHeapType(), VAR_4);\n        }\n        VAR_2.push_back(VAR_3);\n      }\n    }\n    auto VAR_5 = Type(Tuple(VAR_2));\n    Index VAR_6 = VAR_7.addVar(VAR_8, VAR_5);\n    VAR_9.push_back(VAR_7.makeLocalSet(VAR_6, VAR_0));\n    for (Index VAR_10 = 0; VAR_10 < VAR_5.size(); ++VAR_10) {\n      Expression* VAR_11 =\n        VAR_7.makeTupleExtract(VAR_7.makeLocalGet(VAR_6, VAR_5), VAR_10);\n      if (VAR_5[VAR_10] != VAR_1[VAR_10]) {\n        /* COMMENT_3 */\n        VAR_11 = VAR_7.makeRefAs(VAR_12, VAR_11);\n      }\n      VAR_9.push_back(VAR_11);\n    }\n  } else {\n    VAR_9.push_back(VAR_0);\n  }\n}",
    "func_graph_path_before": "WebAssembly/binaryen/27135d613f929214dd2f74ca106f32310bc7e65b/wasm-binary.cpp/vul/before/3.json",
    "func": "void WasmBinaryBuilder::pushExpression(Expression* curr) {\n  auto type = curr->type;\n  if (type.isTuple()) {\n    // Store tuple to local and push individual extracted values\n    Builder builder(wasm);\n    // Non-nullable types require special handling as they cannot be stored to\n    // a local.\n    std::vector<Type> finalTypes;\n    if (!wasm.features.hasGCNNLocals()) {\n      for (auto t : type) {\n        if (t.isNonNullable()) {\n          t = Type(t.getHeapType(), Nullable);\n        }\n        finalTypes.push_back(t);\n      }\n    }\n    auto nullableType = Type(Tuple(finalTypes));\n    requireFunctionContext(\"pushExpression-tuple\");\n    Index tuple = builder.addVar(currFunction, nullableType);\n    expressionStack.push_back(builder.makeLocalSet(tuple, curr));\n    for (Index i = 0; i < nullableType.size(); ++i) {\n      Expression* value =\n        builder.makeTupleExtract(builder.makeLocalGet(tuple, nullableType), i);\n      if (nullableType[i] != type[i]) {\n        // We modified this to be nullable; undo that.\n        value = builder.makeRefAs(RefAsNonNull, value);\n      }\n      expressionStack.push_back(value);\n    }\n  } else {\n    expressionStack.push_back(curr);\n  }\n}",
    "abstract_func": "void WasmBinaryBuilder::pushExpression(Expression* VAR_0) {\n  auto VAR_1 = VAR_0->type;\n  if (VAR_1.isTuple()) {\n    /* COMMENT_0 */\n    Builder builder(wasm);\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    std::vector<Type> VAR_2;\n    if (!wasm.features.hasGCNNLocals()) {\n      for (auto VAR_3 : VAR_1) {\n        if (VAR_3.isNonNullable()) {\n          VAR_3 = Type(VAR_3.getHeapType(), VAR_4);\n        }\n        VAR_2.push_back(VAR_3);\n      }\n    }\n    auto VAR_5 = Type(Tuple(VAR_2));\n    requireFunctionContext(\"pushExpression-tuple\");\n    Index VAR_6 = VAR_7.addVar(VAR_8, VAR_5);\n    VAR_9.push_back(VAR_7.makeLocalSet(VAR_6, VAR_0));\n    for (Index VAR_10 = 0; VAR_10 < VAR_5.size(); ++VAR_10) {\n      Expression* VAR_11 =\n        VAR_7.makeTupleExtract(VAR_7.makeLocalGet(VAR_6, VAR_5), VAR_10);\n      if (VAR_5[VAR_10] != VAR_1[VAR_10]) {\n        /* COMMENT_3 */\n        VAR_11 = VAR_7.makeRefAs(VAR_12, VAR_11);\n      }\n      VAR_9.push_back(VAR_11);\n    }\n  } else {\n    VAR_9.push_back(VAR_0);\n  }\n}",
    "func_graph_path": "WebAssembly/binaryen/27135d613f929214dd2f74ca106f32310bc7e65b/wasm-binary.cpp/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,7 @@\n       }\n     }\n     auto nullableType = Type(Tuple(finalTypes));\n+    requireFunctionContext(\"pushExpression-tuple\");\n     Index tuple = builder.addVar(currFunction, nullableType);\n     expressionStack.push_back(builder.makeLocalSet(tuple, curr));\n     for (Index i = 0; i < nullableType.size(); ++i) {",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "    requireFunctionContext(\"pushExpression-tuple\");"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/WebAssembly/binaryen/pull/4388",
    "description": "Fixes #4384 "
}