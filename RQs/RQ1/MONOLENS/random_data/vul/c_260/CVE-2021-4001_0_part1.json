{
    "cve_id": "CVE-2021-4001",
    "cwe_ids": [
        "CWE-367"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:N/I:C/A:N",
    "cvss_is_v3": false,
    "repo_name": "kernel/git/bpf/bpf",
    "commit_msg": "Commit a23740ec43ba (\"bpf: Track contents of read-only maps as scalars\") is\nchecking whether maps are read-only both from BPF program side and user space\nside, and then, given their content is constant, reading out their data via\nmap->ops->map_direct_value_addr() which is then subsequently used as known\nscalar value for the register, that is, it is marked as __mark_reg_known()\nwith the read value at verification time. Before a23740ec43ba, the register\ncontent was marked as an unknown scalar so the verifier could not make any\nassumptions about the map content.\n\nThe current implementation however is prone to a TOCTOU race, meaning, the\nvalue read as known scalar for the register is not guaranteed to be exactly\nthe same at a later point when the program is executed, and as such, the\nprior made assumptions of the verifier with regards to the program will be\ninvalid which can cause issues such as OOB access, etc.\n\nWhile the BPF_F_RDONLY_PROG map flag is always fixed and required to be\nspecified at map creation time, the map->frozen property is initially set to\nfalse for the map given the map value needs to be populated, e.g. for global\ndata sections. Once complete, the loader \"freezes\" the map from user space\nsuch that no subsequent updates/deletes are possible anymore. For the rest\nof the lifetime of the map, this freeze one-time trigger cannot be undone\nanymore after a successful BPF_MAP_FREEZE cmd return. Meaning, any new BPF_*\ncmd calls which would update/delete map entries will be rejected with -EPERM\nsince map_get_sys_perms() removes the FMODE_CAN_WRITE permission. This also\nmeans that pending update/delete map entries must still complete before this\nguarantee is given. This corner case is not an issue for loaders since they\ncreate and prepare such program private map in successive steps.\n\nHowever, a malicious user is able to trigger this TOCTOU race in two different\nways: i) via userfaultfd, and ii) via batched updates. For i) userfaultfd is\nused to expand the competition interval, so that map_update_elem() can modify\nthe contents of the map after map_freeze() and bpf_prog_load() were executed.\nThis works, because userfaultfd halts the parallel thread which triggered a\nmap_update_elem() at the time where we copy key/value from the user buffer and\nthis already passed the FMODE_CAN_WRITE capability test given at that time the\nmap was not \"frozen\". Then, the main thread performs the map_freeze() and\nbpf_prog_load(), and once that had completed successfully, the other thread\nis woken up to complete the pending map_update_elem() which then changes the\nmap content. For ii) the idea of the batched update is similar, meaning, when\nthere are a large number of updates to be processed, it can increase the\ncompetition interval between the two. It is therefore possible in practice to\nmodify the contents of the map after executing map_freeze() and bpf_prog_load().\n\nOne way to fix both i) and ii) at the same time is to expand the use of the\nmap's map->writecnt. The latter was introduced in fc9702273e2e (\"bpf: Add mmap()\nsupport for BPF_MAP_TYPE_ARRAY\") and further refined in 1f6cb19be2e2 (\"bpf:\nPrevent re-mmap()'ing BPF map as writable for initially r/o mapping\") with\nthe rationale to make a writable mmap()'ing of a map mutually exclusive with\nread-only freezing. The counter indicates writable mmap() mappings and then\nprevents/fails the freeze operation. Its semantics can be expanded beyond\njust mmap() by generally indicating ongoing write phases. This would essentially\nspan any parallel regular and batched flavor of update/delete operation and\nthen also have map_freeze() fail with -EBUSY. For the check_mem_access() in\nthe verifier we expand upon the bpf_map_is_rdonly() check ensuring that all\nlast pending writes have completed via bpf_map_write_active() test. Once the\nmap->frozen is set and bpf_map_write_active() indicates a map->writecnt of 0\nonly then we are really guaranteed to use the map's data as known constants.\nFor map->frozen being set and pending writes in process of still being completed\nwe fall back to marking that register as unknown scalar so we don't end up\nmaking assumptions about it. With this, both TOCTOU reproducers from i) and\nii) are fixed.\n\nNote that the map->writecnt has been converted into a atomic64 in the fix in\norder to avoid a double freeze_mutex mutex_{un,}lock() pair when updating\nmap->writecnt in the various map update/delete BPF_* cmd flavors. Spanning\nthe freeze_mutex over entire map update/delete operations in syscall side\nwould not be possible due to then causing everything to be serialized.\nSimilarly, something like synchronize_rcu() after setting map->frozen to wait\nfor update/deletes to complete is not possible either since it would also\nhave to span the user copy which can sleep. On the libbpf side, this won't\nbreak d66562fba1ce (\"libbpf: Add BPF object skeleton support\") as the\nanonymous mmap()-ed \"map initialization image\" is remapped as a BPF map-backed\nmmap()-ed memory where for .rodata it's non-writable.\n\nFixes: a23740ec43ba (\"bpf: Track contents of read-only maps as scalars\")\nReported-by: w1tcher.bupt@gmail.com\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Andrii Nakryiko <andrii@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\n",
    "commit_hash": "353050be4c19e102178ccc05988101887c25ae53",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?h=353050be4c19e102178ccc05988101887c25ae53",
    "file_path": "kernel/bpf/syscall.c",
    "func_name": "bpf_map_mmap_open",
    "func_before": "static void bpf_map_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE) {\n\t\tmutex_lock(&map->freeze_mutex);\n\t\tmap->writecnt++;\n\t\tmutex_unlock(&map->freeze_mutex);\n\t}\n}",
    "abstract_func_before": "static void bpf_map_mmap_open(struct vm_area_struct *VAR_0)\n{\n\tstruct bpf_map *VAR_1 = VAR_0->vm_file->private_data;\n\n\tif (VAR_0->vm_flags & VAR_2) {\n\t\tmutex_lock(&VAR_1->freeze_mutex);\n\t\tVAR_1->writecnt++;\n\t\tmutex_unlock(&VAR_1->freeze_mutex);\n\t}\n}",
    "func_graph_path_before": "kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/before/1.json",
    "func": "static void bpf_map_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE)\n\t\tbpf_map_write_active_inc(map);\n}",
    "abstract_func": "static void bpf_map_mmap_open(struct vm_area_struct *VAR_0)\n{\n\tstruct bpf_map *VAR_1 = VAR_0->vm_file->private_data;\n\n\tif (VAR_0->vm_flags & VAR_2)\n\t\tbpf_map_write_active_inc(VAR_1);\n}",
    "func_graph_path": "kernel/git/bpf/bpf/353050be4c19e102178ccc05988101887c25ae53/syscall.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,6 @@\n {\n \tstruct bpf_map *map = vma->vm_file->private_data;\n \n-\tif (vma->vm_flags & VM_MAYWRITE) {\n-\t\tmutex_lock(&map->freeze_mutex);\n-\t\tmap->writecnt++;\n-\t\tmutex_unlock(&map->freeze_mutex);\n-\t}\n+\tif (vma->vm_flags & VM_MAYWRITE)\n+\t\tbpf_map_write_active_inc(map);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (vma->vm_flags & VM_MAYWRITE) {",
            "\t\tmutex_lock(&map->freeze_mutex);",
            "\t\tmap->writecnt++;",
            "\t\tmutex_unlock(&map->freeze_mutex);",
            "\t}"
        ],
        "added_lines": [
            "\tif (vma->vm_flags & VM_MAYWRITE)",
            "\t\tbpf_map_write_active_inc(map);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}