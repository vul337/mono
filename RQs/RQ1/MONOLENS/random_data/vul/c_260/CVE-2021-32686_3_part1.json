{
    "cve_id": "CVE-2021-32686",
    "cwe_ids": [
        "CWE-362"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "pjsip/pjproject",
    "commit_msg": "Merge pull request from GHSA-cv8x-p47p-99wr\n\n* - Avoid SSL socket parent/listener getting destroyed during handshake by increasing parent's reference count.\n- Add missing SSL socket close when the newly accepted SSL socket is discarded in SIP TLS transport.\n\n* - Fix silly mistake: accepted active socket created without group lock in SSL socket.\n- Replace assertion with normal validation check of SSL socket instance in OpenSSL verification callback (verify_cb()) to avoid crash, e.g: if somehow race condition with SSL socket destroy happens or OpenSSL application data index somehow gets corrupted.",
    "commit_hash": "d5f95aa066f878b0aef6a64e60b61e8626e664cd",
    "git_url": "https://github.com/pjsip/pjproject/commit/d5f95aa066f878b0aef6a64e60b61e8626e664cd",
    "file_path": "pjlib/src/pj/ssl_sock_ossl.c",
    "func_name": "init_openssl",
    "func_before": "static pj_status_t init_openssl(void)\n{\n    pj_status_t status;\n\n    if (openssl_init_count)\n\treturn PJ_SUCCESS;\n\n    openssl_init_count = 1;\n\n    /* Register error subsystem */\n    status = pj_register_strerror(PJ_SSL_ERRNO_START, \n\t\t\t\t  PJ_SSL_ERRNO_SPACE_SIZE, \n\t\t\t\t  &ssl_strerror);\n    pj_assert(status == PJ_SUCCESS);\n\n    /* Init OpenSSL lib */\n#if USING_LIBRESSL || OPENSSL_VERSION_NUMBER < 0x10100000L\n    SSL_library_init();\n    SSL_load_error_strings();\n#else\n    OPENSSL_init_ssl(0, NULL);\n#endif\n#if OPENSSL_VERSION_NUMBER < 0x009080ffL\n    /* This is now synonym of SSL_library_init() */\n    OpenSSL_add_all_algorithms();\n#endif\n\n    /* Init available ciphers */\n    if (ssl_cipher_num == 0 || ssl_curves_num == 0) {\n\tSSL_METHOD *meth = NULL;\n\tSSL_CTX *ctx;\n\tSSL *ssl;\n\tSTACK_OF(SSL_CIPHER) *sk_cipher;\n\tSSL_SESSION *ssl_sess;\n\tunsigned i, n;\n\tint nid;\n\tconst char *cname;\n\n#if (USING_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x2020100fL)\\\n    || OPENSSL_VERSION_NUMBER < 0x10100000L\n\n\tmeth = (SSL_METHOD*)SSLv23_server_method();\n\tif (!meth)\n\t    meth = (SSL_METHOD*)TLSv1_server_method();\n#ifndef OPENSSL_NO_SSL3_METHOD\n\tif (!meth)\n\t    meth = (SSL_METHOD*)SSLv3_server_method();\n#endif\n#ifndef OPENSSL_NO_SSL2\n\tif (!meth)\n\t    meth = (SSL_METHOD*)SSLv2_server_method();\n#endif\n\n#else\n\t/* Specific version methods are deprecated in 1.1.0 */\n\tmeth = (SSL_METHOD*)TLS_method();\n#endif\n\n\tpj_assert(meth);\n\n\tctx=SSL_CTX_new(meth);\n\tSSL_CTX_set_cipher_list(ctx, \"ALL:COMPLEMENTOFALL\");\n\n\tssl = SSL_new(ctx);\n\n\tsk_cipher = SSL_get_ciphers(ssl);\n\n\tn = sk_SSL_CIPHER_num(sk_cipher);\n\tif (n > PJ_ARRAY_SIZE(ssl_ciphers) - ADDITIONAL_CIPHER_COUNT)\n\t    n = PJ_ARRAY_SIZE(ssl_ciphers) - ADDITIONAL_CIPHER_COUNT;\n\n\tfor (i = 0; i < n; ++i) {\n\t    const SSL_CIPHER *c;\n\t    c = sk_SSL_CIPHER_value(sk_cipher,i);\n\t    ssl_ciphers[i].id = (pj_ssl_cipher)\n\t\t\t\t    (pj_uint32_t)SSL_CIPHER_get_id(c) &\n\t\t\t\t    0x00FFFFFF;\n\t    ssl_ciphers[i].name = SSL_CIPHER_get_name(c);\n\t}\n\n\t/* Add cipher aliases not returned from SSL_get_ciphers() */\n\tfor (i = 0; i < ADDITIONAL_CIPHER_COUNT; ++i) {\n\t    ssl_ciphers[n++] = ADDITIONAL_CIPHERS[i];\n\t}\n\tssl_cipher_num = n;\n\n\tssl_sess = SSL_SESSION_new();\n\tSSL_set_session(ssl, ssl_sess);\n\n#if !USING_LIBRESSL && !defined(OPENSSL_NO_EC) \\\n    && OPENSSL_VERSION_NUMBER >= 0x1000200fL\n#if OPENSSL_VERSION_NUMBER >= 0x1010100fL\n\tssl_curves_num = EC_get_builtin_curves(NULL, 0);\n#else\n\tssl_curves_num = SSL_get_shared_curve(ssl,-1);\n\n\tif (ssl_curves_num > PJ_ARRAY_SIZE(ssl_curves))\n\t    ssl_curves_num = PJ_ARRAY_SIZE(ssl_curves);\n#endif\n\n\tif( ssl_curves_num > 0 ) {\n#if OPENSSL_VERSION_NUMBER >= 0x1010100fL\n\t    EC_builtin_curve * curves = NULL;\n\n\t    curves = OPENSSL_malloc((int)sizeof(*curves) * ssl_curves_num);\n\t    if (!EC_get_builtin_curves(curves, ssl_curves_num)) {\n\t\tOPENSSL_free(curves);\n\t\tcurves = NULL;\n\t\tssl_curves_num = 0;\n\t    }\n\n\t    n = ssl_curves_num;\n\t    ssl_curves_num = 0;\n\n\t    for (i = 0; i < n; i++) {\n\t\tnid = curves[i].nid;\n\n\t\tif ( 0 != get_cid_from_nid(nid) ) {\n\t\t    cname = OBJ_nid2sn(nid);\n\n\t\t    if (!cname)\n\t\t\tcname = OBJ_nid2sn(nid);\n\n\t\t    if (cname) {\n\t\t\tssl_curves[ssl_curves_num].id = get_cid_from_nid(nid);\n\t\t\tssl_curves[ssl_curves_num].name = cname;\n\n\t\t\tssl_curves_num++;\n\n\t\t\tif (ssl_curves_num >= PJ_SSL_SOCK_MAX_CURVES )\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if(curves)\n\t\tOPENSSL_free(curves);\n#else\n\tfor (i = 0; i < ssl_curves_num; i++) {\n\t    nid = SSL_get_shared_curve(ssl, i);\n\n\t    if (nid & TLSEXT_nid_unknown) {\n\t\tcname = \"curve unknown\";\n\t\tnid &= 0xFFFF;\n\t    } else {\n\t\tcname = EC_curve_nid2nist(nid);\n\t\tif (!cname)\n\t\t    cname = OBJ_nid2sn(nid);\n\t    }\n\n\t    ssl_curves[i].id   = get_cid_from_nid(nid);\n\t    ssl_curves[i].name = cname;\n\t}\n#endif\n\n\t}\n#else\n\tPJ_UNUSED_ARG(nid);\n\tPJ_UNUSED_ARG(cname);\n\tssl_curves_num = 0;\n#endif\n\n\tSSL_free(ssl);\n\n\t/* On OpenSSL 1.1.1, omitting SSL_SESSION_free() will cause \n\t * memory leak (e.g: as reported by Address Sanitizer). But using\n\t * SSL_SESSION_free() may cause crash (due to double free?) on 1.0.x.\n\t * As OpenSSL docs specifies to not calling SSL_SESSION_free() after\n\t * SSL_free(), perhaps it is safer to obey this, the leak amount seems\n\t * to be relatively small (<500 bytes) and should occur once only in\n\t * the library lifetime.\n#if OPENSSL_VERSION_NUMBER >= 0x10101000L\n\tSSL_SESSION_free(ssl_sess);\n#endif\n\t */\n\n\tSSL_CTX_free(ctx);\n    }\n\n    /* Create OpenSSL application data index for SSL socket */\n    sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);\n\n#if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\\n    PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n    status = init_ossl_lock();\n    if (status != PJ_SUCCESS)\n        return status;\n#endif\n\n    return status;\n}",
    "abstract_func_before": "static pj_status_t init_openssl(void)\n{\n    pj_status_t VAR_0;\n\n    if (VAR_1)\n\treturn VAR_2;\n\n    VAR_1 = 1;\n\n    /* COMMENT_0 */\n    VAR_0 = pj_register_strerror(VAR_3, \n\t\t\t\t  VAR_4, \n\t\t\t\t  &VAR_5);\n    pj_assert(VAR_0 == VAR_2);\n\n    /* COMMENT_1 */\n#if VAR_6 || VAR_7 < 0x10100000L\n    SSL_library_init();\n    SSL_load_error_strings();\n#else\n    OPENSSL_init_ssl(0, NULL);\n#endif\n#if VAR_7 < 0x009080ffL\n    /* COMMENT_2 */\n    OpenSSL_add_all_algorithms();\n#endif\n\n    /* COMMENT_3 */\n    if (VAR_8 == 0 || VAR_9 == 0) {\n\tSSL_METHOD *VAR_10 = NULL;\n\tSSL_CTX *VAR_11;\n\tSSL *VAR_12;\n\tSTACK_OF(VAR_13) *VAR_14;\n\tSSL_SESSION *VAR_15;\n\tunsigned VAR_16, VAR_17;\n\tint VAR_18;\n\tconst char *VAR_19;\n\n#if (VAR_6 && VAR_20 < 0x2020100fL)\\\n    || VAR_7 < 0x10100000L\n\n\tVAR_10 = (SSL_METHOD*)SSLv23_server_method();\n\tif (!VAR_10)\n\t    VAR_10 = (SSL_METHOD*)TLSv1_server_method();\n#ifndef VAR_21\n\tif (!VAR_10)\n\t    VAR_10 = (SSL_METHOD*)SSLv3_server_method();\n#endif\n#ifndef VAR_22\n\tif (!VAR_10)\n\t    VAR_10 = (SSL_METHOD*)SSLv2_server_method();\n#endif\n\n#else\n\t/* COMMENT_4 */\n\tVAR_10 = (SSL_METHOD*)TLS_method();\n#endif\n\n\tpj_assert(VAR_10);\n\n\tVAR_11=SSL_CTX_new(VAR_10);\n\tSSL_CTX_set_cipher_list(VAR_11, \"ALL:COMPLEMENTOFALL\");\n\n\tVAR_12 = SSL_new(VAR_11);\n\n\tVAR_14 = SSL_get_ciphers(VAR_12);\n\n\tVAR_17 = sk_SSL_CIPHER_num(VAR_14);\n\tif (VAR_17 > PJ_ARRAY_SIZE(VAR_23) - VAR_24)\n\t    VAR_17 = PJ_ARRAY_SIZE(VAR_23) - VAR_24;\n\n\tfor (VAR_16 = 0; VAR_16 < VAR_17; ++VAR_16) {\n\t    const SSL_CIPHER *VAR_25;\n\t    VAR_25 = sk_SSL_CIPHER_value(VAR_14,VAR_16);\n\t    VAR_23[VAR_16].id = (pj_ssl_cipher)\n\t\t\t\t    (pj_uint32_t)SSL_CIPHER_get_id(VAR_25) &\n\t\t\t\t    0x00FFFFFF;\n\t    VAR_23[VAR_16].name = SSL_CIPHER_get_name(VAR_25);\n\t}\n\n\t/* COMMENT_5 */\n\tfor (VAR_16 = 0; VAR_16 < VAR_24; ++VAR_16) {\n\t    VAR_23[VAR_17++] = VAR_26[VAR_16];\n\t}\n\tVAR_8 = VAR_17;\n\n\tVAR_15 = SSL_SESSION_new();\n\tSSL_set_session(VAR_12, VAR_15);\n\n#if !VAR_6 && !defined(VAR_27) \\\n    && VAR_7 >= 0x1000200fL\n#if VAR_7 >= 0x1010100fL\n\tVAR_9 = EC_get_builtin_curves(NULL, 0);\n#else\n\tVAR_9 = SSL_get_shared_curve(VAR_12,-1);\n\n\tif (VAR_9 > PJ_ARRAY_SIZE(VAR_28))\n\t    VAR_9 = PJ_ARRAY_SIZE(VAR_28);\n#endif\n\n\tif( VAR_9 > 0 ) {\n#if VAR_7 >= 0x1010100fL\n\t    EC_builtin_curve * VAR_29 = NULL;\n\n\t    VAR_29 = OPENSSL_malloc((int)sizeof(*VAR_29) * VAR_9);\n\t    if (!EC_get_builtin_curves(VAR_29, VAR_9)) {\n\t\tOPENSSL_free(VAR_29);\n\t\tVAR_29 = NULL;\n\t\tVAR_9 = 0;\n\t    }\n\n\t    VAR_17 = VAR_9;\n\t    VAR_9 = 0;\n\n\t    for (VAR_16 = 0; VAR_16 < VAR_17; VAR_16++) {\n\t\tVAR_18 = VAR_29[VAR_16].nid;\n\n\t\tif ( 0 != get_cid_from_nid(VAR_18) ) {\n\t\t    VAR_19 = OBJ_nid2sn(VAR_18);\n\n\t\t    if (!VAR_19)\n\t\t\tVAR_19 = OBJ_nid2sn(VAR_18);\n\n\t\t    if (VAR_19) {\n\t\t\tVAR_28[VAR_9].id = get_cid_from_nid(VAR_18);\n\t\t\tVAR_28[VAR_9].name = VAR_19;\n\n\t\t\tVAR_9++;\n\n\t\t\tif (VAR_9 >= VAR_30 )\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if(VAR_29)\n\t\tOPENSSL_free(VAR_29);\n#else\n\tfor (VAR_16 = 0; VAR_16 < VAR_9; VAR_16++) {\n\t    VAR_18 = SSL_get_shared_curve(VAR_12, VAR_16);\n\n\t    if (VAR_18 & VAR_31) {\n\t\tVAR_19 = \"curve unknown\";\n\t\tVAR_18 &= 0xFFFF;\n\t    } else {\n\t\tVAR_19 = EC_curve_nid2nist(VAR_18);\n\t\tif (!VAR_19)\n\t\t    VAR_19 = OBJ_nid2sn(VAR_18);\n\t    }\n\n\t    VAR_28[VAR_16].id   = get_cid_from_nid(VAR_18);\n\t    VAR_28[VAR_16].name = VAR_19;\n\t}\n#endif\n\n\t}\n#else\n\tPJ_UNUSED_ARG(VAR_18);\n\tPJ_UNUSED_ARG(VAR_19);\n\tVAR_9 = 0;\n#endif\n\n\tSSL_free(VAR_12);\n\n\t/* COMMENT_6 */\n                                                                  \n                                                                      \n                                                                     \n                                                                       \n                                                                     \n                         \n                                         \n                            \n      \n    \n\n\tSSL_CTX_free(VAR_11);\n    }\n\n    /* COMMENT_17 */\n    VAR_32 = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);\n\n#if defined(VAR_33) && \\\n    VAR_33 != 0 && VAR_7 < 0x10100000L\n\n    VAR_0 = init_ossl_lock();\n    if (VAR_0 != VAR_2)\n        return VAR_0;\n#endif\n\n    return VAR_0;\n}",
    "func_graph_path_before": "pjsip/pjproject/d5f95aa066f878b0aef6a64e60b61e8626e664cd/ssl_sock_ossl.c/vul/before/3.json",
    "func": "static pj_status_t init_openssl(void)\n{\n    pj_status_t status;\n\n    if (openssl_init_count)\n\treturn PJ_SUCCESS;\n\n    openssl_init_count = 1;\n\n    /* Register error subsystem */\n    status = pj_register_strerror(PJ_SSL_ERRNO_START, \n\t\t\t\t  PJ_SSL_ERRNO_SPACE_SIZE, \n\t\t\t\t  &ssl_strerror);\n    pj_assert(status == PJ_SUCCESS);\n\n    /* Init OpenSSL lib */\n#if USING_LIBRESSL || OPENSSL_VERSION_NUMBER < 0x10100000L\n    SSL_library_init();\n    SSL_load_error_strings();\n#else\n    OPENSSL_init_ssl(0, NULL);\n#endif\n#if OPENSSL_VERSION_NUMBER < 0x009080ffL\n    /* This is now synonym of SSL_library_init() */\n    OpenSSL_add_all_algorithms();\n#endif\n\n    /* Init available ciphers */\n    if (ssl_cipher_num == 0 || ssl_curves_num == 0) {\n\tSSL_METHOD *meth = NULL;\n\tSSL_CTX *ctx;\n\tSSL *ssl;\n\tSTACK_OF(SSL_CIPHER) *sk_cipher;\n\tSSL_SESSION *ssl_sess;\n\tunsigned i, n;\n\tint nid;\n\tconst char *cname;\n\n#if (USING_LIBRESSL && LIBRESSL_VERSION_NUMBER < 0x2020100fL)\\\n    || OPENSSL_VERSION_NUMBER < 0x10100000L\n\n\tmeth = (SSL_METHOD*)SSLv23_server_method();\n\tif (!meth)\n\t    meth = (SSL_METHOD*)TLSv1_server_method();\n#ifndef OPENSSL_NO_SSL3_METHOD\n\tif (!meth)\n\t    meth = (SSL_METHOD*)SSLv3_server_method();\n#endif\n#ifndef OPENSSL_NO_SSL2\n\tif (!meth)\n\t    meth = (SSL_METHOD*)SSLv2_server_method();\n#endif\n\n#else\n\t/* Specific version methods are deprecated in 1.1.0 */\n\tmeth = (SSL_METHOD*)TLS_method();\n#endif\n\n\tpj_assert(meth);\n\n\tctx=SSL_CTX_new(meth);\n\tSSL_CTX_set_cipher_list(ctx, \"ALL:COMPLEMENTOFALL\");\n\n\tssl = SSL_new(ctx);\n\n\tsk_cipher = SSL_get_ciphers(ssl);\n\n\tn = sk_SSL_CIPHER_num(sk_cipher);\n\tif (n > PJ_ARRAY_SIZE(ssl_ciphers) - ADDITIONAL_CIPHER_COUNT)\n\t    n = PJ_ARRAY_SIZE(ssl_ciphers) - ADDITIONAL_CIPHER_COUNT;\n\n\tfor (i = 0; i < n; ++i) {\n\t    const SSL_CIPHER *c;\n\t    c = sk_SSL_CIPHER_value(sk_cipher,i);\n\t    ssl_ciphers[i].id = (pj_ssl_cipher)\n\t\t\t\t    (pj_uint32_t)SSL_CIPHER_get_id(c) &\n\t\t\t\t    0x00FFFFFF;\n\t    ssl_ciphers[i].name = SSL_CIPHER_get_name(c);\n\t}\n\n\t/* Add cipher aliases not returned from SSL_get_ciphers() */\n\tfor (i = 0; i < ADDITIONAL_CIPHER_COUNT; ++i) {\n\t    ssl_ciphers[n++] = ADDITIONAL_CIPHERS[i];\n\t}\n\tssl_cipher_num = n;\n\n\tssl_sess = SSL_SESSION_new();\n\tSSL_set_session(ssl, ssl_sess);\n\n#if !USING_LIBRESSL && !defined(OPENSSL_NO_EC) \\\n    && OPENSSL_VERSION_NUMBER >= 0x1000200fL\n#if OPENSSL_VERSION_NUMBER >= 0x1010100fL\n\tssl_curves_num = EC_get_builtin_curves(NULL, 0);\n#else\n\tssl_curves_num = SSL_get_shared_curve(ssl,-1);\n\n\tif (ssl_curves_num > PJ_ARRAY_SIZE(ssl_curves))\n\t    ssl_curves_num = PJ_ARRAY_SIZE(ssl_curves);\n#endif\n\n\tif( ssl_curves_num > 0 ) {\n#if OPENSSL_VERSION_NUMBER >= 0x1010100fL\n\t    EC_builtin_curve * curves = NULL;\n\n\t    curves = OPENSSL_malloc((int)sizeof(*curves) * ssl_curves_num);\n\t    if (!EC_get_builtin_curves(curves, ssl_curves_num)) {\n\t\tOPENSSL_free(curves);\n\t\tcurves = NULL;\n\t\tssl_curves_num = 0;\n\t    }\n\n\t    n = ssl_curves_num;\n\t    ssl_curves_num = 0;\n\n\t    for (i = 0; i < n; i++) {\n\t\tnid = curves[i].nid;\n\n\t\tif ( 0 != get_cid_from_nid(nid) ) {\n\t\t    cname = OBJ_nid2sn(nid);\n\n\t\t    if (!cname)\n\t\t\tcname = OBJ_nid2sn(nid);\n\n\t\t    if (cname) {\n\t\t\tssl_curves[ssl_curves_num].id = get_cid_from_nid(nid);\n\t\t\tssl_curves[ssl_curves_num].name = cname;\n\n\t\t\tssl_curves_num++;\n\n\t\t\tif (ssl_curves_num >= PJ_SSL_SOCK_MAX_CURVES )\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if(curves)\n\t\tOPENSSL_free(curves);\n#else\n\tfor (i = 0; i < ssl_curves_num; i++) {\n\t    nid = SSL_get_shared_curve(ssl, i);\n\n\t    if (nid & TLSEXT_nid_unknown) {\n\t\tcname = \"curve unknown\";\n\t\tnid &= 0xFFFF;\n\t    } else {\n\t\tcname = EC_curve_nid2nist(nid);\n\t\tif (!cname)\n\t\t    cname = OBJ_nid2sn(nid);\n\t    }\n\n\t    ssl_curves[i].id   = get_cid_from_nid(nid);\n\t    ssl_curves[i].name = cname;\n\t}\n#endif\n\n\t}\n#else\n\tPJ_UNUSED_ARG(nid);\n\tPJ_UNUSED_ARG(cname);\n\tssl_curves_num = 0;\n#endif\n\n\tSSL_free(ssl);\n\n\t/* On OpenSSL 1.1.1, omitting SSL_SESSION_free() will cause \n\t * memory leak (e.g: as reported by Address Sanitizer). But using\n\t * SSL_SESSION_free() may cause crash (due to double free?) on 1.0.x.\n\t * As OpenSSL docs specifies to not calling SSL_SESSION_free() after\n\t * SSL_free(), perhaps it is safer to obey this, the leak amount seems\n\t * to be relatively small (<500 bytes) and should occur once only in\n\t * the library lifetime.\n#if OPENSSL_VERSION_NUMBER >= 0x10101000L\n\tSSL_SESSION_free(ssl_sess);\n#endif\n\t */\n\n\tSSL_CTX_free(ctx);\n    }\n\n    /* Create OpenSSL application data index for SSL socket */\n    sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);\n    if (sslsock_idx == -1) {\n\tstatus = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);\n\tPJ_LOG(1,(THIS_FILE,\n\t       \"Fatal error: failed to get application data index for \"\n\t       \"SSL socket\"));\n\treturn status;\n    }\n\n#if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\\n    PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L\n\n    status = init_ossl_lock();\n    if (status != PJ_SUCCESS)\n        return status;\n#endif\n\n    return status;\n}",
    "abstract_func": "static pj_status_t init_openssl(void)\n{\n    pj_status_t VAR_0;\n\n    if (VAR_1)\n\treturn VAR_2;\n\n    VAR_1 = 1;\n\n    /* COMMENT_0 */\n    VAR_0 = pj_register_strerror(VAR_3, \n\t\t\t\t  VAR_4, \n\t\t\t\t  &VAR_5);\n    pj_assert(VAR_0 == VAR_2);\n\n    /* COMMENT_1 */\n#if VAR_6 || VAR_7 < 0x10100000L\n    SSL_library_init();\n    SSL_load_error_strings();\n#else\n    OPENSSL_init_ssl(0, NULL);\n#endif\n#if VAR_7 < 0x009080ffL\n    /* COMMENT_2 */\n    OpenSSL_add_all_algorithms();\n#endif\n\n    /* COMMENT_3 */\n    if (VAR_8 == 0 || VAR_9 == 0) {\n\tSSL_METHOD *VAR_10 = NULL;\n\tSSL_CTX *VAR_11;\n\tSSL *VAR_12;\n\tSTACK_OF(VAR_13) *VAR_14;\n\tSSL_SESSION *VAR_15;\n\tunsigned VAR_16, VAR_17;\n\tint VAR_18;\n\tconst char *VAR_19;\n\n#if (VAR_6 && VAR_20 < 0x2020100fL)\\\n    || VAR_7 < 0x10100000L\n\n\tVAR_10 = (SSL_METHOD*)SSLv23_server_method();\n\tif (!VAR_10)\n\t    VAR_10 = (SSL_METHOD*)TLSv1_server_method();\n#ifndef VAR_21\n\tif (!VAR_10)\n\t    VAR_10 = (SSL_METHOD*)SSLv3_server_method();\n#endif\n#ifndef VAR_22\n\tif (!VAR_10)\n\t    VAR_10 = (SSL_METHOD*)SSLv2_server_method();\n#endif\n\n#else\n\t/* COMMENT_4 */\n\tVAR_10 = (SSL_METHOD*)TLS_method();\n#endif\n\n\tpj_assert(VAR_10);\n\n\tVAR_11=SSL_CTX_new(VAR_10);\n\tSSL_CTX_set_cipher_list(VAR_11, \"ALL:COMPLEMENTOFALL\");\n\n\tVAR_12 = SSL_new(VAR_11);\n\n\tVAR_14 = SSL_get_ciphers(VAR_12);\n\n\tVAR_17 = sk_SSL_CIPHER_num(VAR_14);\n\tif (VAR_17 > PJ_ARRAY_SIZE(VAR_23) - VAR_24)\n\t    VAR_17 = PJ_ARRAY_SIZE(VAR_23) - VAR_24;\n\n\tfor (VAR_16 = 0; VAR_16 < VAR_17; ++VAR_16) {\n\t    const SSL_CIPHER *VAR_25;\n\t    VAR_25 = sk_SSL_CIPHER_value(VAR_14,VAR_16);\n\t    VAR_23[VAR_16].id = (pj_ssl_cipher)\n\t\t\t\t    (pj_uint32_t)SSL_CIPHER_get_id(VAR_25) &\n\t\t\t\t    0x00FFFFFF;\n\t    VAR_23[VAR_16].name = SSL_CIPHER_get_name(VAR_25);\n\t}\n\n\t/* COMMENT_5 */\n\tfor (VAR_16 = 0; VAR_16 < VAR_24; ++VAR_16) {\n\t    VAR_23[VAR_17++] = VAR_26[VAR_16];\n\t}\n\tVAR_8 = VAR_17;\n\n\tVAR_15 = SSL_SESSION_new();\n\tSSL_set_session(VAR_12, VAR_15);\n\n#if !VAR_6 && !defined(VAR_27) \\\n    && VAR_7 >= 0x1000200fL\n#if VAR_7 >= 0x1010100fL\n\tVAR_9 = EC_get_builtin_curves(NULL, 0);\n#else\n\tVAR_9 = SSL_get_shared_curve(VAR_12,-1);\n\n\tif (VAR_9 > PJ_ARRAY_SIZE(VAR_28))\n\t    VAR_9 = PJ_ARRAY_SIZE(VAR_28);\n#endif\n\n\tif( VAR_9 > 0 ) {\n#if VAR_7 >= 0x1010100fL\n\t    EC_builtin_curve * VAR_29 = NULL;\n\n\t    VAR_29 = OPENSSL_malloc((int)sizeof(*VAR_29) * VAR_9);\n\t    if (!EC_get_builtin_curves(VAR_29, VAR_9)) {\n\t\tOPENSSL_free(VAR_29);\n\t\tVAR_29 = NULL;\n\t\tVAR_9 = 0;\n\t    }\n\n\t    VAR_17 = VAR_9;\n\t    VAR_9 = 0;\n\n\t    for (VAR_16 = 0; VAR_16 < VAR_17; VAR_16++) {\n\t\tVAR_18 = VAR_29[VAR_16].nid;\n\n\t\tif ( 0 != get_cid_from_nid(VAR_18) ) {\n\t\t    VAR_19 = OBJ_nid2sn(VAR_18);\n\n\t\t    if (!VAR_19)\n\t\t\tVAR_19 = OBJ_nid2sn(VAR_18);\n\n\t\t    if (VAR_19) {\n\t\t\tVAR_28[VAR_9].id = get_cid_from_nid(VAR_18);\n\t\t\tVAR_28[VAR_9].name = VAR_19;\n\n\t\t\tVAR_9++;\n\n\t\t\tif (VAR_9 >= VAR_30 )\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if(VAR_29)\n\t\tOPENSSL_free(VAR_29);\n#else\n\tfor (VAR_16 = 0; VAR_16 < VAR_9; VAR_16++) {\n\t    VAR_18 = SSL_get_shared_curve(VAR_12, VAR_16);\n\n\t    if (VAR_18 & VAR_31) {\n\t\tVAR_19 = \"curve unknown\";\n\t\tVAR_18 &= 0xFFFF;\n\t    } else {\n\t\tVAR_19 = EC_curve_nid2nist(VAR_18);\n\t\tif (!VAR_19)\n\t\t    VAR_19 = OBJ_nid2sn(VAR_18);\n\t    }\n\n\t    VAR_28[VAR_16].id   = get_cid_from_nid(VAR_18);\n\t    VAR_28[VAR_16].name = VAR_19;\n\t}\n#endif\n\n\t}\n#else\n\tPJ_UNUSED_ARG(VAR_18);\n\tPJ_UNUSED_ARG(VAR_19);\n\tVAR_9 = 0;\n#endif\n\n\tSSL_free(VAR_12);\n\n\t/* COMMENT_6 */\n                                                                  \n                                                                      \n                                                                     \n                                                                       \n                                                                     \n                         \n                                         \n                            \n      \n    \n\n\tSSL_CTX_free(VAR_11);\n    }\n\n    /* COMMENT_17 */\n    VAR_32 = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);\n    if (VAR_32 == -1) {\n\tVAR_0 = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);\n\tPJ_LOG(1,(VAR_33,\n\t       \"Fatal error: failed to get application data index for \"\n\t       \"SSL socket\"));\n\treturn VAR_0;\n    }\n\n#if defined(VAR_34) && \\\n    VAR_34 != 0 && VAR_7 < 0x10100000L\n\n    VAR_0 = init_ossl_lock();\n    if (VAR_0 != VAR_2)\n        return VAR_0;\n#endif\n\n    return VAR_0;\n}",
    "func_graph_path": "pjsip/pjproject/d5f95aa066f878b0aef6a64e60b61e8626e664cd/ssl_sock_ossl.c/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -179,6 +179,13 @@\n \n     /* Create OpenSSL application data index for SSL socket */\n     sslsock_idx = SSL_get_ex_new_index(0, \"SSL socket\", NULL, NULL, NULL);\n+    if (sslsock_idx == -1) {\n+\tstatus = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);\n+\tPJ_LOG(1,(THIS_FILE,\n+\t       \"Fatal error: failed to get application data index for \"\n+\t       \"SSL socket\"));\n+\treturn status;\n+    }\n \n #if defined(PJ_SSL_SOCK_OSSL_USE_THREAD_CB) && \\\n     PJ_SSL_SOCK_OSSL_USE_THREAD_CB != 0 && OPENSSL_VERSION_NUMBER < 0x10100000L",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "    if (sslsock_idx == -1) {",
            "\tstatus = STATUS_FROM_SSL_ERR2(\"Init\", NULL, -1, ERR_get_error(), 0);",
            "\tPJ_LOG(1,(THIS_FILE,",
            "\t       \"Fatal error: failed to get application data index for \"",
            "\t       \"SSL socket\"));",
            "\treturn status;",
            "    }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}