{
    "cve_id": "CVE-2020-22874",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "pcmacdon/jsish",
    "commit_msg": "Release \"3.0.8\": Address Array alloc sizing issues from issue \"integer overflow and buffer overflow #5\".\n\nFossilOrigin-Name: 8c46a1d465b358110dcfb271721d35fe843a1b52f2fa24ccc10094eb8aaf6fe4",
    "commit_hash": "858da537bde4de9d8c92466d5a866505310bc328",
    "git_url": "https://github.com/pcmacdon/jsish/commit/858da537bde4de9d8c92466d5a866505310bc328",
    "file_path": "src/jsiCData.c",
    "func_name": "CDataStructDefineCmd",
    "func_before": "static Jsi_RC CDataStructDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_RC rc = JSI_OK;\n    Jsi_OptionTypedef *st = NULL;\n    jsi_csInitType(interp);\n    Jsi_Value *eval = NULL, *val = Jsi_ValueArrayIndex(interp, args, 0),\n        *flds = Jsi_ValueArrayIndex(interp, args, 1);\n    int vlen, flen, i, argc, clen = 0, arrCnt=0;\n    Jsi_DString fStr = {};\n    char **argv = NULL, *cmt, *eq, *cp, *ce, *cpval, ocp;\n    const char *vstr = Jsi_ValueString(interp, val, &vlen),\n        *fstr = Jsi_ValueString(interp, flds, &flen);\n    if (vstr) {\n        cmt = Jsi_Strstr(fstr, \"//\");\n        eq = Jsi_Strchr(fstr, '=');\n        Jsi_DString tStr = {fstr};\n        fstr=jsi_TrimStr(Jsi_DSValue(&tStr));\n        Jsi_SplitStr(fstr, &argc, &argv, (cmt?\"\\n\":\";\"), &fStr);\n        Jsi_DSFree(&tStr);\n        if (!cmt && argc>0 && !argv[argc-1][0])\n            argc--;\n        if (eq) {\n            eval = Jsi_ValueNewArray(interp, NULL, 0);\n            Jsi_IncrRefCount(interp, eval);\n        }\n    } else if (!Jsi_ValueIsArray(interp,flds) || (argc=Jsi_ValueGetLength(interp, flds))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n    if (argc>200)\n        return Jsi_LogError(\"too many fields: %d>200\", argc);\n    Jsi_StructSpec *sl, *sf, recs[argc+2];\n    memset(recs, 0, sizeof(recs));\n    sl = recs+argc+1;\n    sf = recs;\n    SIGINIT(sl, OPTS_STRUCT);\n    if (vstr) {\n        sl->name = Jsi_KeyAdd(interp, vstr);\n    } else if (Jsi_OptionsProcess(interp, StructOptions, sl, val, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(sl->name)) {\n        rc = Jsi_LogError(\"invalid struct name: %s\", sl->name);\n        goto bail;\n    }\n    if (jsi_csStructGet(interp, sl->name)) {\n        rc = Jsi_LogError(\"struct already exists: %s\", sl->name);\n        goto bail;\n    }\n    for (i = 0; i<argc; i++) {\n        Jsi_Number numVal = 0;\n        bool bVal, isbitset = 0;\n        Jsi_Value *inival = NULL;\n        sf = recs+i;\n        SIGINIT(sf, OPTS_FIELD);\n        if (!argv) {\n            val = Jsi_ValueArrayIndex(interp, flds, i);\n            if (!val || Jsi_OptionsProcess(interp, StructFieldOptions, sf, val, 0) < 0) {\n                rc = JSI_ERROR;\n                goto bail;\n            }\n            if (!Jsi_StrIsAlnum(sf->name) || !sf->type) {\n                rc = Jsi_LogError(\"invalid struct field name: %s\", sf->name);\n                goto bail;\n            }\n            if (!Jsi_ValueObjLookup(interp, val, \"init\", 0) && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n        } else {\n            if (cmt) {\n                cp = Jsi_Strstr(argv[i], \"//\"); \n                if (cp) {\n                    *cp = 0;\n                    cp += 2;\n                    cp = jsi_TrimStr(cp);\n                    sf->help = Jsi_KeyAdd(interp, cp);\n                }\n                cp = Jsi_Strchr(argv[i], ';'); \n                if (cp) *cp = 0;\n            }\n            cp = Jsi_Strchr(argv[i], '='); \n            if (cp) {\n                if (!eval)\n                    goto bail;\n                *cp++ = 0;\n                cp = jsi_TrimStr(cp);\n                int cplen = Jsi_Strlen(cp);\n                if (cplen>1 && (cp[0] == '\\'' || cp[0] == '\"') && cp[0] == cp[cplen-1]) {\n                    cpval = cp+1;\n                    cp[cplen-1] = 0;\n                    inival = Jsi_ValueNewStringDup(interp, cpval);\n                }\n                else if (Jsi_GetDouble(interp, cp, &numVal) == JSI_OK)\n                    inival = Jsi_ValueNewNumber(interp, numVal);\n                else if (Jsi_GetBool(interp, cp, &bVal) == JSI_OK)\n                    inival = Jsi_ValueNewBoolean(interp, bVal);\n                else\n                    inival = Jsi_ValueNewStringDup(interp, cp);\n            }\n            cp = argv[i];\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && !isspace(*ce)) ce++;\n            ocp = *ce;\n            if (!ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            *ce = 0;\n            sf->type = Jsi_TypeLookup(interp, cp);\n            *ce = ocp;\n            if (!sf->type) {\n                rc = Jsi_LogError(\"unknown type: %s\", argv[i]);\n                goto bail;\n            }\n            if (!inival && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n\n            cp = ce+1;\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && (isalnum(*ce) || *ce == '_')) ce++;\n            ocp = *ce;\n            *ce = 0;\n            if (!*cp) {\n                rc = Jsi_LogError(\"missing or bad struct field name\");\n                goto bail;\n            }\n            sf->name = Jsi_KeyAdd(interp, cp);\n            if (ocp) {\n                ce++;\n                clen = Jsi_Strlen(ce);\n            }\n            if (ocp == '@') {\n                isbitset = 1;\n            } else\n            if (ocp == ':') {\n                int bsiz = -1;\n                if (Jsi_GetInt(interp, ce, &bsiz,10) != JSI_OK || bsiz<=0 || bsiz>64) {\n                    rc = Jsi_LogError(\"bad bit size: %s\", ce);\n                    goto bail;\n                }\n                sf->bits = bsiz;\n            } else if (ocp == '[' && clen>1 && ce[clen-1]==']') {\n                int asiz = -1;\n                ce[clen-1] = 0;\n                if (Jsi_GetInt(interp, ce, &asiz, 10) != JSI_OK || asiz<=0) {\n                    rc = Jsi_LogError(\"bad size: %s\", cp);\n                    goto bail;\n                }\n                sf->arrSize = asiz;\n            } else if (ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            val = NULL;            \n        }\n        if (inival) {\n            Jsi_Value *sval = Jsi_ValueNewObj(interp, NULL);\n            Jsi_ValueInsert(interp, sval, \"init\", inival, 0);\n            Jsi_ValueArraySet(interp, eval, sval, i);\n        }\n        bool isEnum = (sf->type && (sf->type->flags&jsi_CTYP_ENUM));\n        if (isbitset) {\n            if (!isEnum) {\n                rc = Jsi_LogError(\"bitset type is not an enum\");\n                goto bail;\n            }\n            sf->flags |= JSI_OPT_BITSET_ENUM;\n        }\n        if (sf->arrSize) {\n            if (sf->arrSize>MAX_ARRAY_LIST) {\n                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, MAX_ARRAY_LIST);\n                goto bail;\n            }\n            if (sf->bits || isEnum) {\n                rc = Jsi_LogError(\"array of %s unsupported\", (sf->bits?\"bits\":\"enums\"));\n                goto bail;\n            }\n            arrCnt++;\n        }\n    }\n    recs[argc].id = JSI_OPTION_END;\n    rc = jsi_csSetupStruct(interp, sl, recs, recs, argc, &st, arrCnt);\n    if (rc != JSI_OK || !st) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sl = jsi_csGetStructSpec(st->extData);\n    sf = jsi_csGetFieldSpec(sl->extData);\n    if (vstr)\n        flds = eval;\n    for (i = 0; i<argc && flds; i++) {\n        val = Jsi_ValueArrayIndex(interp, flds, i);\n        if (val && Jsi_OptionsProcess(interp, StructFieldOptions, sf+i, val, JSI_OPT_PASS2) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n    }\nbail:\n    if (eval)\n        Jsi_DecrRefCount(interp, eval);\n    Jsi_DSFree(&fStr);\n    if (rc != JSI_OK && st)\n        Jsi_HashEntryDelete(st->hPtr);\n    return rc;\n}",
    "abstract_func_before": "static Jsi_RC CDataStructDefineCmd(Jsi_Interp *VAR_0, Jsi_Value *VAR_1, Jsi_Value *VAR_2,\n                                Jsi_Value **VAR_3, Jsi_Func *VAR_4)\n{\n    \n    Jsi_RC VAR_5 = VAR_6;\n    Jsi_OptionTypedef *VAR_7 = NULL;\n    jsi_csInitType(VAR_0);\n    Jsi_Value *VAR_8 = NULL, *VAR_9 = Jsi_ValueArrayIndex(VAR_0, VAR_1, 0),\n        *VAR_10 = Jsi_ValueArrayIndex(VAR_0, VAR_1, 1);\n    int VAR_11, VAR_12, VAR_13, VAR_14, VAR_15 = 0, VAR_16=0;\n    Jsi_DString VAR_17 = {};\n    char **VAR_18 = NULL, *VAR_19, *VAR_20, *VAR_21, *VAR_22, *VAR_23, VAR_24;\n    const char *VAR_25 = Jsi_ValueString(VAR_0, VAR_9, &VAR_11),\n        *VAR_26 = Jsi_ValueString(VAR_0, VAR_10, &VAR_12);\n    if (VAR_25) {\n        VAR_19 = Jsi_Strstr(VAR_26, \"//\");\n        VAR_20 = Jsi_Strchr(VAR_26, '=');\n        Jsi_DString VAR_27 = {VAR_26};\n        VAR_26=jsi_TrimStr(Jsi_DSValue(&VAR_27));\n        Jsi_SplitStr(VAR_26, &VAR_14, &VAR_18, (VAR_19?\"\\n\":\";\"), &VAR_17);\n        Jsi_DSFree(&VAR_27);\n        if (!VAR_19 && VAR_14>0 && !VAR_18[VAR_14-1][0])\n            VAR_14--;\n        if (VAR_20) {\n            VAR_8 = Jsi_ValueNewArray(VAR_0, NULL, 0);\n            Jsi_IncrRefCount(VAR_0, VAR_8);\n        }\n    } else if (!Jsi_ValueIsArray(VAR_0,VAR_10) || (VAR_14=Jsi_ValueGetLength(VAR_0, VAR_10))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n    if (VAR_14>200)\n        return Jsi_LogError(\"too many fields: %d>200\", VAR_14);\n    Jsi_StructSpec *VAR_28, *VAR_29, VAR_30[VAR_14+2];\n    memset(VAR_30, 0, sizeof(VAR_30));\n    VAR_28 = VAR_30+VAR_14+1;\n    VAR_29 = VAR_30;\n    SIGINIT(VAR_28, VAR_31);\n    if (VAR_25) {\n        VAR_28->name = Jsi_KeyAdd(VAR_0, VAR_25);\n    } else if (Jsi_OptionsProcess(VAR_0, VAR_32, VAR_28, VAR_9, 0) < 0) {\n        VAR_5 = VAR_33;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(VAR_28->name)) {\n        VAR_5 = Jsi_LogError(\"invalid struct name: %s\", VAR_28->name);\n        goto bail;\n    }\n    if (jsi_csStructGet(VAR_0, VAR_28->name)) {\n        VAR_5 = Jsi_LogError(\"struct already exists: %s\", VAR_28->name);\n        goto bail;\n    }\n    for (VAR_13 = 0; VAR_13<VAR_14; VAR_13++) {\n        Jsi_Number VAR_34 = 0;\n        bool VAR_35, VAR_36 = 0;\n        Jsi_Value *VAR_37 = NULL;\n        VAR_29 = VAR_30+VAR_13;\n        SIGINIT(VAR_29, VAR_38);\n        if (!VAR_18) {\n            VAR_9 = Jsi_ValueArrayIndex(VAR_0, VAR_10, VAR_13);\n            if (!VAR_9 || Jsi_OptionsProcess(VAR_0, VAR_39, VAR_29, VAR_9, 0) < 0) {\n                VAR_5 = VAR_33;\n                goto bail;\n            }\n            if (!Jsi_StrIsAlnum(VAR_29->name) || !VAR_29->type) {\n                VAR_5 = Jsi_LogError(\"invalid struct field name: %s\", VAR_29->name);\n                goto bail;\n            }\n            if (!Jsi_ValueObjLookup(VAR_0, VAR_9, \"init\", 0) && (VAR_29->type->flags&VAR_40))\n                VAR_37 = Jsi_ValueNewBoolean(VAR_0, true);\n        } else {\n            if (VAR_19) {\n                VAR_21 = Jsi_Strstr(VAR_18[VAR_13], \"//\"); \n                if (VAR_21) {\n                    *VAR_21 = 0;\n                    VAR_21 += 2;\n                    VAR_21 = jsi_TrimStr(VAR_21);\n                    VAR_29->help = Jsi_KeyAdd(VAR_0, VAR_21);\n                }\n                VAR_21 = Jsi_Strchr(VAR_18[VAR_13], ';'); \n                if (VAR_21) *VAR_21 = 0;\n            }\n            VAR_21 = Jsi_Strchr(VAR_18[VAR_13], '='); \n            if (VAR_21) {\n                if (!VAR_8)\n                    goto bail;\n                *VAR_21++ = 0;\n                VAR_21 = jsi_TrimStr(VAR_21);\n                int VAR_41 = Jsi_Strlen(VAR_21);\n                if (VAR_41>1 && (VAR_21[0] == '\\'' || VAR_21[0] == '\"') && VAR_21[0] == VAR_21[VAR_41-1]) {\n                    VAR_23 = VAR_21+1;\n                    VAR_21[VAR_41-1] = 0;\n                    VAR_37 = Jsi_ValueNewStringDup(VAR_0, VAR_23);\n                }\n                else if (Jsi_GetDouble(VAR_0, VAR_21, &VAR_34) == VAR_6)\n                    VAR_37 = Jsi_ValueNewNumber(VAR_0, VAR_34);\n                else if (Jsi_GetBool(VAR_0, VAR_21, &VAR_35) == VAR_6)\n                    VAR_37 = Jsi_ValueNewBoolean(VAR_0, VAR_35);\n                else\n                    VAR_37 = Jsi_ValueNewStringDup(VAR_0, VAR_21);\n            }\n            VAR_21 = VAR_18[VAR_13];\n            while (*VAR_21 && isspace(*VAR_21)) VAR_21++;\n            VAR_22 = VAR_21;\n            while (*VAR_22 && !isspace(*VAR_22)) VAR_22++;\n            VAR_24 = *VAR_22;\n            if (!VAR_24) {\n                VAR_5 = Jsi_LogError(\"bad field: %s\", VAR_21);\n                goto bail;\n            }\n            *VAR_22 = 0;\n            VAR_29->type = Jsi_TypeLookup(VAR_0, VAR_21);\n            *VAR_22 = VAR_24;\n            if (!VAR_29->type) {\n                VAR_5 = Jsi_LogError(\"unknown type: %s\", VAR_18[VAR_13]);\n                goto bail;\n            }\n            if (!VAR_37 && (VAR_29->type->flags&VAR_40))\n                VAR_37 = Jsi_ValueNewBoolean(VAR_0, true);\n\n            VAR_21 = VAR_22+1;\n            while (*VAR_21 && isspace(*VAR_21)) VAR_21++;\n            VAR_22 = VAR_21;\n            while (*VAR_22 && (isalnum(*VAR_22) || *VAR_22 == '_')) VAR_22++;\n            VAR_24 = *VAR_22;\n            *VAR_22 = 0;\n            if (!*VAR_21) {\n                VAR_5 = Jsi_LogError(\"missing or bad struct field name\");\n                goto bail;\n            }\n            VAR_29->name = Jsi_KeyAdd(VAR_0, VAR_21);\n            if (VAR_24) {\n                VAR_22++;\n                VAR_15 = Jsi_Strlen(VAR_22);\n            }\n            if (VAR_24 == '@') {\n                VAR_36 = 1;\n            } else\n            if (VAR_24 == ':') {\n                int VAR_42 = -1;\n                if (Jsi_GetInt(VAR_0, VAR_22, &VAR_42,10) != VAR_6 || VAR_42<=0 || VAR_42>64) {\n                    VAR_5 = Jsi_LogError(\"bad bit size: %s\", VAR_22);\n                    goto bail;\n                }\n                VAR_29->bits = VAR_42;\n            } else if (VAR_24 == '[' && VAR_15>1 && VAR_22[VAR_15-1]==']') {\n                int VAR_43 = -1;\n                VAR_22[VAR_15-1] = 0;\n                if (Jsi_GetInt(VAR_0, VAR_22, &VAR_43, 10) != VAR_6 || VAR_43<=0) {\n                    VAR_5 = Jsi_LogError(\"bad size: %s\", VAR_21);\n                    goto bail;\n                }\n                VAR_29->arrSize = VAR_43;\n            } else if (VAR_24) {\n                VAR_5 = Jsi_LogError(\"bad field: %s\", VAR_21);\n                goto bail;\n            }\n            VAR_9 = NULL;            \n        }\n        if (VAR_37) {\n            Jsi_Value *VAR_44 = Jsi_ValueNewObj(VAR_0, NULL);\n            Jsi_ValueInsert(VAR_0, VAR_44, \"init\", VAR_37, 0);\n            Jsi_ValueArraySet(VAR_0, VAR_8, VAR_44, VAR_13);\n        }\n        bool VAR_45 = (VAR_29->type && (VAR_29->type->flags&VAR_46));\n        if (VAR_36) {\n            if (!VAR_45) {\n                VAR_5 = Jsi_LogError(\"bitset type is not an enum\");\n                goto bail;\n            }\n            VAR_29->flags |= VAR_47;\n        }\n        if (VAR_29->arrSize) {\n            if (VAR_29->arrSize>VAR_48) {\n                VAR_5 = Jsi_LogError(\"array size too big: %d >= %d\", VAR_29->arrSize, VAR_48);\n                goto bail;\n            }\n            if (VAR_29->bits || VAR_45) {\n                VAR_5 = Jsi_LogError(\"array of %s unsupported\", (VAR_29->bits?\"bits\":\"enums\"));\n                goto bail;\n            }\n            VAR_16++;\n        }\n    }\n    VAR_30[VAR_14].id = VAR_49;\n    VAR_5 = jsi_csSetupStruct(VAR_0, VAR_28, VAR_30, VAR_30, VAR_14, &VAR_7, VAR_16);\n    if (VAR_5 != VAR_6 || !VAR_7) {\n        VAR_5 = VAR_33;\n        goto bail;\n    }\n    VAR_28 = jsi_csGetStructSpec(VAR_7->extData);\n    VAR_29 = jsi_csGetFieldSpec(VAR_28->extData);\n    if (VAR_25)\n        VAR_10 = VAR_8;\n    for (VAR_13 = 0; VAR_13<VAR_14 && VAR_10; VAR_13++) {\n        VAR_9 = Jsi_ValueArrayIndex(VAR_0, VAR_10, VAR_13);\n        if (VAR_9 && Jsi_OptionsProcess(VAR_0, VAR_39, VAR_29+VAR_13, VAR_9, VAR_50) < 0) {\n            VAR_5 = VAR_33;\n            goto bail;\n        }\n    }\nbail:\n    if (VAR_8)\n        Jsi_DecrRefCount(VAR_0, VAR_8);\n    Jsi_DSFree(&VAR_17);\n    if (VAR_5 != VAR_6 && VAR_7)\n        Jsi_HashEntryDelete(VAR_7->hPtr);\n    return VAR_5;\n}",
    "func_graph_path_before": "pcmacdon/jsish/858da537bde4de9d8c92466d5a866505310bc328/jsiCData.c/vul/before/0.json",
    "func": "static Jsi_RC CDataStructDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_RC rc = JSI_OK;\n    Jsi_OptionTypedef *st = NULL;\n    jsi_csInitType(interp);\n    Jsi_Value *eval = NULL, *val = Jsi_ValueArrayIndex(interp, args, 0),\n        *flds = Jsi_ValueArrayIndex(interp, args, 1);\n    int vlen, flen, i, argc, clen = 0, arrCnt=0;\n    Jsi_DString fStr = {};\n    char **argv = NULL, *cmt, *eq, *cp, *ce, *cpval, ocp;\n    const char *vstr = Jsi_ValueString(interp, val, &vlen),\n        *fstr = Jsi_ValueString(interp, flds, &flen);\n    if (vstr) {\n        cmt = Jsi_Strstr(fstr, \"//\");\n        eq = Jsi_Strchr(fstr, '=');\n        Jsi_DString tStr = {fstr};\n        fstr=jsi_TrimStr(Jsi_DSValue(&tStr));\n        Jsi_SplitStr(fstr, &argc, &argv, (cmt?\"\\n\":\";\"), &fStr);\n        Jsi_DSFree(&tStr);\n        if (!cmt && argc>0 && !argv[argc-1][0])\n            argc--;\n        if (eq) {\n            eval = Jsi_ValueNewArray(interp, NULL, 0);\n            Jsi_IncrRefCount(interp, eval);\n        }\n    } else if (!Jsi_ValueIsArray(interp,flds) || (argc=Jsi_ValueGetLength(interp, flds))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n    if (argc>200)\n        return Jsi_LogError(\"too many fields: %d>200\", argc);\n    Jsi_StructSpec *sl, *sf, recs[argc+2];\n    memset(recs, 0, sizeof(recs));\n    sl = recs+argc+1;\n    sf = recs;\n    SIGINIT(sl, OPTS_STRUCT);\n    if (vstr) {\n        sl->name = Jsi_KeyAdd(interp, vstr);\n    } else if (Jsi_OptionsProcess(interp, StructOptions, sl, val, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(sl->name)) {\n        rc = Jsi_LogError(\"invalid struct name: %s\", sl->name);\n        goto bail;\n    }\n    if (jsi_csStructGet(interp, sl->name)) {\n        rc = Jsi_LogError(\"struct already exists: %s\", sl->name);\n        goto bail;\n    }\n    for (i = 0; i<argc; i++) {\n        Jsi_Number numVal = 0;\n        bool bVal, isbitset = 0;\n        Jsi_Value *inival = NULL;\n        sf = recs+i;\n        SIGINIT(sf, OPTS_FIELD);\n        if (!argv) {\n            val = Jsi_ValueArrayIndex(interp, flds, i);\n            if (!val || Jsi_OptionsProcess(interp, StructFieldOptions, sf, val, 0) < 0) {\n                rc = JSI_ERROR;\n                goto bail;\n            }\n            if (!Jsi_StrIsAlnum(sf->name) || !sf->type) {\n                rc = Jsi_LogError(\"invalid struct field name: %s\", sf->name);\n                goto bail;\n            }\n            if (!Jsi_ValueObjLookup(interp, val, \"init\", 0) && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n        } else {\n            if (cmt) {\n                cp = Jsi_Strstr(argv[i], \"//\"); \n                if (cp) {\n                    *cp = 0;\n                    cp += 2;\n                    cp = jsi_TrimStr(cp);\n                    sf->help = Jsi_KeyAdd(interp, cp);\n                }\n                cp = Jsi_Strchr(argv[i], ';'); \n                if (cp) *cp = 0;\n            }\n            cp = Jsi_Strchr(argv[i], '='); \n            if (cp) {\n                if (!eval)\n                    goto bail;\n                *cp++ = 0;\n                cp = jsi_TrimStr(cp);\n                int cplen = Jsi_Strlen(cp);\n                if (cplen>1 && (cp[0] == '\\'' || cp[0] == '\"') && cp[0] == cp[cplen-1]) {\n                    cpval = cp+1;\n                    cp[cplen-1] = 0;\n                    inival = Jsi_ValueNewStringDup(interp, cpval);\n                }\n                else if (Jsi_GetDouble(interp, cp, &numVal) == JSI_OK)\n                    inival = Jsi_ValueNewNumber(interp, numVal);\n                else if (Jsi_GetBool(interp, cp, &bVal) == JSI_OK)\n                    inival = Jsi_ValueNewBoolean(interp, bVal);\n                else\n                    inival = Jsi_ValueNewStringDup(interp, cp);\n            }\n            cp = argv[i];\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && !isspace(*ce)) ce++;\n            ocp = *ce;\n            if (!ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            *ce = 0;\n            sf->type = Jsi_TypeLookup(interp, cp);\n            *ce = ocp;\n            if (!sf->type) {\n                rc = Jsi_LogError(\"unknown type: %s\", argv[i]);\n                goto bail;\n            }\n            if (!inival && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n\n            cp = ce+1;\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && (isalnum(*ce) || *ce == '_')) ce++;\n            ocp = *ce;\n            *ce = 0;\n            if (!*cp) {\n                rc = Jsi_LogError(\"missing or bad struct field name\");\n                goto bail;\n            }\n            sf->name = Jsi_KeyAdd(interp, cp);\n            if (ocp) {\n                ce++;\n                clen = Jsi_Strlen(ce);\n            }\n            if (ocp == '@') {\n                isbitset = 1;\n            } else\n            if (ocp == ':') {\n                int bsiz = -1;\n                if (Jsi_GetInt(interp, ce, &bsiz,10) != JSI_OK || bsiz<=0 || bsiz>64) {\n                    rc = Jsi_LogError(\"bad bit size: %s\", ce);\n                    goto bail;\n                }\n                sf->bits = bsiz;\n            } else if (ocp == '[' && clen>1 && ce[clen-1]==']') {\n                int asiz = -1;\n                ce[clen-1] = 0;\n                if (Jsi_GetInt(interp, ce, &asiz, 10) != JSI_OK || asiz<=0) {\n                    rc = Jsi_LogError(\"bad size: %s\", cp);\n                    goto bail;\n                }\n                sf->arrSize = asiz;\n            } else if (ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            val = NULL;            \n        }\n        if (inival) {\n            Jsi_Value *sval = Jsi_ValueNewObj(interp, NULL);\n            Jsi_ValueInsert(interp, sval, \"init\", inival, 0);\n            Jsi_ValueArraySet(interp, eval, sval, i);\n        }\n        bool isEnum = (sf->type && (sf->type->flags&jsi_CTYP_ENUM));\n        if (isbitset) {\n            if (!isEnum) {\n                rc = Jsi_LogError(\"bitset type is not an enum\");\n                goto bail;\n            }\n            sf->flags |= JSI_OPT_BITSET_ENUM;\n        }\n        if (sf->arrSize) {\n            if (sf->arrSize>interp->maxArrayList) {\n                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, interp->maxArrayList);\n                goto bail;\n            }\n            if (sf->bits || isEnum) {\n                rc = Jsi_LogError(\"array of %s unsupported\", (sf->bits?\"bits\":\"enums\"));\n                goto bail;\n            }\n            arrCnt++;\n        }\n    }\n    recs[argc].id = JSI_OPTION_END;\n    rc = jsi_csSetupStruct(interp, sl, recs, recs, argc, &st, arrCnt);\n    if (rc != JSI_OK || !st) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sl = jsi_csGetStructSpec(st->extData);\n    sf = jsi_csGetFieldSpec(sl->extData);\n    if (vstr)\n        flds = eval;\n    for (i = 0; i<argc && flds; i++) {\n        val = Jsi_ValueArrayIndex(interp, flds, i);\n        if (val && Jsi_OptionsProcess(interp, StructFieldOptions, sf+i, val, JSI_OPT_PASS2) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n    }\nbail:\n    if (eval)\n        Jsi_DecrRefCount(interp, eval);\n    Jsi_DSFree(&fStr);\n    if (rc != JSI_OK && st)\n        Jsi_HashEntryDelete(st->hPtr);\n    return rc;\n}",
    "abstract_func": "static Jsi_RC CDataStructDefineCmd(Jsi_Interp *VAR_0, Jsi_Value *VAR_1, Jsi_Value *VAR_2,\n                                Jsi_Value **VAR_3, Jsi_Func *VAR_4)\n{\n    \n    Jsi_RC VAR_5 = VAR_6;\n    Jsi_OptionTypedef *VAR_7 = NULL;\n    jsi_csInitType(VAR_0);\n    Jsi_Value *VAR_8 = NULL, *VAR_9 = Jsi_ValueArrayIndex(VAR_0, VAR_1, 0),\n        *VAR_10 = Jsi_ValueArrayIndex(VAR_0, VAR_1, 1);\n    int VAR_11, VAR_12, VAR_13, VAR_14, VAR_15 = 0, VAR_16=0;\n    Jsi_DString VAR_17 = {};\n    char **VAR_18 = NULL, *VAR_19, *VAR_20, *VAR_21, *VAR_22, *VAR_23, VAR_24;\n    const char *VAR_25 = Jsi_ValueString(VAR_0, VAR_9, &VAR_11),\n        *VAR_26 = Jsi_ValueString(VAR_0, VAR_10, &VAR_12);\n    if (VAR_25) {\n        VAR_19 = Jsi_Strstr(VAR_26, \"//\");\n        VAR_20 = Jsi_Strchr(VAR_26, '=');\n        Jsi_DString VAR_27 = {VAR_26};\n        VAR_26=jsi_TrimStr(Jsi_DSValue(&VAR_27));\n        Jsi_SplitStr(VAR_26, &VAR_14, &VAR_18, (VAR_19?\"\\n\":\";\"), &VAR_17);\n        Jsi_DSFree(&VAR_27);\n        if (!VAR_19 && VAR_14>0 && !VAR_18[VAR_14-1][0])\n            VAR_14--;\n        if (VAR_20) {\n            VAR_8 = Jsi_ValueNewArray(VAR_0, NULL, 0);\n            Jsi_IncrRefCount(VAR_0, VAR_8);\n        }\n    } else if (!Jsi_ValueIsArray(VAR_0,VAR_10) || (VAR_14=Jsi_ValueGetLength(VAR_0, VAR_10))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n    if (VAR_14>200)\n        return Jsi_LogError(\"too many fields: %d>200\", VAR_14);\n    Jsi_StructSpec *VAR_28, *VAR_29, VAR_30[VAR_14+2];\n    memset(VAR_30, 0, sizeof(VAR_30));\n    VAR_28 = VAR_30+VAR_14+1;\n    VAR_29 = VAR_30;\n    SIGINIT(VAR_28, VAR_31);\n    if (VAR_25) {\n        VAR_28->name = Jsi_KeyAdd(VAR_0, VAR_25);\n    } else if (Jsi_OptionsProcess(VAR_0, VAR_32, VAR_28, VAR_9, 0) < 0) {\n        VAR_5 = VAR_33;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(VAR_28->name)) {\n        VAR_5 = Jsi_LogError(\"invalid struct name: %s\", VAR_28->name);\n        goto bail;\n    }\n    if (jsi_csStructGet(VAR_0, VAR_28->name)) {\n        VAR_5 = Jsi_LogError(\"struct already exists: %s\", VAR_28->name);\n        goto bail;\n    }\n    for (VAR_13 = 0; VAR_13<VAR_14; VAR_13++) {\n        Jsi_Number VAR_34 = 0;\n        bool VAR_35, VAR_36 = 0;\n        Jsi_Value *VAR_37 = NULL;\n        VAR_29 = VAR_30+VAR_13;\n        SIGINIT(VAR_29, VAR_38);\n        if (!VAR_18) {\n            VAR_9 = Jsi_ValueArrayIndex(VAR_0, VAR_10, VAR_13);\n            if (!VAR_9 || Jsi_OptionsProcess(VAR_0, VAR_39, VAR_29, VAR_9, 0) < 0) {\n                VAR_5 = VAR_33;\n                goto bail;\n            }\n            if (!Jsi_StrIsAlnum(VAR_29->name) || !VAR_29->type) {\n                VAR_5 = Jsi_LogError(\"invalid struct field name: %s\", VAR_29->name);\n                goto bail;\n            }\n            if (!Jsi_ValueObjLookup(VAR_0, VAR_9, \"init\", 0) && (VAR_29->type->flags&VAR_40))\n                VAR_37 = Jsi_ValueNewBoolean(VAR_0, true);\n        } else {\n            if (VAR_19) {\n                VAR_21 = Jsi_Strstr(VAR_18[VAR_13], \"//\"); \n                if (VAR_21) {\n                    *VAR_21 = 0;\n                    VAR_21 += 2;\n                    VAR_21 = jsi_TrimStr(VAR_21);\n                    VAR_29->help = Jsi_KeyAdd(VAR_0, VAR_21);\n                }\n                VAR_21 = Jsi_Strchr(VAR_18[VAR_13], ';'); \n                if (VAR_21) *VAR_21 = 0;\n            }\n            VAR_21 = Jsi_Strchr(VAR_18[VAR_13], '='); \n            if (VAR_21) {\n                if (!VAR_8)\n                    goto bail;\n                *VAR_21++ = 0;\n                VAR_21 = jsi_TrimStr(VAR_21);\n                int VAR_41 = Jsi_Strlen(VAR_21);\n                if (VAR_41>1 && (VAR_21[0] == '\\'' || VAR_21[0] == '\"') && VAR_21[0] == VAR_21[VAR_41-1]) {\n                    VAR_23 = VAR_21+1;\n                    VAR_21[VAR_41-1] = 0;\n                    VAR_37 = Jsi_ValueNewStringDup(VAR_0, VAR_23);\n                }\n                else if (Jsi_GetDouble(VAR_0, VAR_21, &VAR_34) == VAR_6)\n                    VAR_37 = Jsi_ValueNewNumber(VAR_0, VAR_34);\n                else if (Jsi_GetBool(VAR_0, VAR_21, &VAR_35) == VAR_6)\n                    VAR_37 = Jsi_ValueNewBoolean(VAR_0, VAR_35);\n                else\n                    VAR_37 = Jsi_ValueNewStringDup(VAR_0, VAR_21);\n            }\n            VAR_21 = VAR_18[VAR_13];\n            while (*VAR_21 && isspace(*VAR_21)) VAR_21++;\n            VAR_22 = VAR_21;\n            while (*VAR_22 && !isspace(*VAR_22)) VAR_22++;\n            VAR_24 = *VAR_22;\n            if (!VAR_24) {\n                VAR_5 = Jsi_LogError(\"bad field: %s\", VAR_21);\n                goto bail;\n            }\n            *VAR_22 = 0;\n            VAR_29->type = Jsi_TypeLookup(VAR_0, VAR_21);\n            *VAR_22 = VAR_24;\n            if (!VAR_29->type) {\n                VAR_5 = Jsi_LogError(\"unknown type: %s\", VAR_18[VAR_13]);\n                goto bail;\n            }\n            if (!VAR_37 && (VAR_29->type->flags&VAR_40))\n                VAR_37 = Jsi_ValueNewBoolean(VAR_0, true);\n\n            VAR_21 = VAR_22+1;\n            while (*VAR_21 && isspace(*VAR_21)) VAR_21++;\n            VAR_22 = VAR_21;\n            while (*VAR_22 && (isalnum(*VAR_22) || *VAR_22 == '_')) VAR_22++;\n            VAR_24 = *VAR_22;\n            *VAR_22 = 0;\n            if (!*VAR_21) {\n                VAR_5 = Jsi_LogError(\"missing or bad struct field name\");\n                goto bail;\n            }\n            VAR_29->name = Jsi_KeyAdd(VAR_0, VAR_21);\n            if (VAR_24) {\n                VAR_22++;\n                VAR_15 = Jsi_Strlen(VAR_22);\n            }\n            if (VAR_24 == '@') {\n                VAR_36 = 1;\n            } else\n            if (VAR_24 == ':') {\n                int VAR_42 = -1;\n                if (Jsi_GetInt(VAR_0, VAR_22, &VAR_42,10) != VAR_6 || VAR_42<=0 || VAR_42>64) {\n                    VAR_5 = Jsi_LogError(\"bad bit size: %s\", VAR_22);\n                    goto bail;\n                }\n                VAR_29->bits = VAR_42;\n            } else if (VAR_24 == '[' && VAR_15>1 && VAR_22[VAR_15-1]==']') {\n                int VAR_43 = -1;\n                VAR_22[VAR_15-1] = 0;\n                if (Jsi_GetInt(VAR_0, VAR_22, &VAR_43, 10) != VAR_6 || VAR_43<=0) {\n                    VAR_5 = Jsi_LogError(\"bad size: %s\", VAR_21);\n                    goto bail;\n                }\n                VAR_29->arrSize = VAR_43;\n            } else if (VAR_24) {\n                VAR_5 = Jsi_LogError(\"bad field: %s\", VAR_21);\n                goto bail;\n            }\n            VAR_9 = NULL;            \n        }\n        if (VAR_37) {\n            Jsi_Value *VAR_44 = Jsi_ValueNewObj(VAR_0, NULL);\n            Jsi_ValueInsert(VAR_0, VAR_44, \"init\", VAR_37, 0);\n            Jsi_ValueArraySet(VAR_0, VAR_8, VAR_44, VAR_13);\n        }\n        bool VAR_45 = (VAR_29->type && (VAR_29->type->flags&VAR_46));\n        if (VAR_36) {\n            if (!VAR_45) {\n                VAR_5 = Jsi_LogError(\"bitset type is not an enum\");\n                goto bail;\n            }\n            VAR_29->flags |= VAR_47;\n        }\n        if (VAR_29->arrSize) {\n            if (VAR_29->arrSize>VAR_0->maxArrayList) {\n                VAR_5 = Jsi_LogError(\"array size too big: %d >= %d\", VAR_29->arrSize, VAR_0->maxArrayList);\n                goto bail;\n            }\n            if (VAR_29->bits || VAR_45) {\n                VAR_5 = Jsi_LogError(\"array of %s unsupported\", (VAR_29->bits?\"bits\":\"enums\"));\n                goto bail;\n            }\n            VAR_16++;\n        }\n    }\n    VAR_30[VAR_14].id = VAR_48;\n    VAR_5 = jsi_csSetupStruct(VAR_0, VAR_28, VAR_30, VAR_30, VAR_14, &VAR_7, VAR_16);\n    if (VAR_5 != VAR_6 || !VAR_7) {\n        VAR_5 = VAR_33;\n        goto bail;\n    }\n    VAR_28 = jsi_csGetStructSpec(VAR_7->extData);\n    VAR_29 = jsi_csGetFieldSpec(VAR_28->extData);\n    if (VAR_25)\n        VAR_10 = VAR_8;\n    for (VAR_13 = 0; VAR_13<VAR_14 && VAR_10; VAR_13++) {\n        VAR_9 = Jsi_ValueArrayIndex(VAR_0, VAR_10, VAR_13);\n        if (VAR_9 && Jsi_OptionsProcess(VAR_0, VAR_39, VAR_29+VAR_13, VAR_9, VAR_49) < 0) {\n            VAR_5 = VAR_33;\n            goto bail;\n        }\n    }\nbail:\n    if (VAR_8)\n        Jsi_DecrRefCount(VAR_0, VAR_8);\n    Jsi_DSFree(&VAR_17);\n    if (VAR_5 != VAR_6 && VAR_7)\n        Jsi_HashEntryDelete(VAR_7->hPtr);\n    return VAR_5;\n}",
    "func_graph_path": "pcmacdon/jsish/858da537bde4de9d8c92466d5a866505310bc328/jsiCData.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -169,8 +169,8 @@\n             sf->flags |= JSI_OPT_BITSET_ENUM;\n         }\n         if (sf->arrSize) {\n-            if (sf->arrSize>MAX_ARRAY_LIST) {\n-                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, MAX_ARRAY_LIST);\n+            if (sf->arrSize>interp->maxArrayList) {\n+                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, interp->maxArrayList);\n                 goto bail;\n             }\n             if (sf->bits || isEnum) {",
    "diff_line_info": {
        "deleted_lines": [
            "            if (sf->arrSize>MAX_ARRAY_LIST) {",
            "                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, MAX_ARRAY_LIST);"
        ],
        "added_lines": [
            "            if (sf->arrSize>interp->maxArrayList) {",
            "                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, interp->maxArrayList);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}