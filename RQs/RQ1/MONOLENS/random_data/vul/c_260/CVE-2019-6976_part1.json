{
    "cve_id": "CVE-2019-6976",
    "cwe_ids": [
        "CWE-908"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "libvips",
    "commit_msg": "zero memory on malloc\n\nto prevent write of uninit memory under some error conditions\n\nthanks Balint",
    "commit_hash": "00622428bda8d7521db8d74260b519fa41d69d0a",
    "git_url": "https://github.com/libvips/libvips/commit/00622428bda8d7521db8d74260b519fa41d69d0a",
    "file_path": "libvips/iofuncs/memory.c",
    "func_name": "vips_tracked_malloc",
    "func_before": "void *\nvips_tracked_malloc( size_t size )\n{\n        void *buf;\n\n\tvips_tracked_init(); \n\n\t/* Need an extra sizeof(size_t) bytes to track \n\t * size of this block. Ask for an extra 16 to make sure we don't break\n\t * alignment rules.\n\t */\n\tsize += 16;\n\n        if( !(buf = g_try_malloc( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif /*DEBUG*/\n\n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\n                return( NULL );\n\t}\n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif /*DEBUG_VERBOSE*/\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\tVIPS_GATE_MALLOC( size ); \n\n        return( buf );\n}",
    "abstract_func_before": "void *\nvips_tracked_malloc( size_t VAR_0 )\n{\n        void *VAR_1;\n\n\tvips_tracked_init(); \n\n\t/* COMMENT_0 */\n                                                                       \n                    \n    \n\tVAR_0 += 16;\n\n        if( !(VAR_1 = g_try_malloc( VAR_0 )) ) {\n#ifdef VAR_2\n\t\tg_assert_not_reached();\n#endif /* COMMENT_4 */\n\n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (VAR_0 / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (VAR_0 / (1024.0 * 1024.0))  );\n\n                return( NULL );\n\t}\n\n\tg_mutex_lock( VAR_3 );\n\n\t*((size_t *)VAR_1) = VAR_0;\n\tVAR_1 = (void *) ((char *)VAR_1 + 16);\n\n\tVAR_4 += VAR_0;\n\tif( VAR_4 > VAR_5 ) \n\t\tVAR_5 = VAR_4;\n\tVAR_6 += 1;\n\n#ifdef VAR_7\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", VAR_1, VAR_0 ); \n#endif /* COMMENT_5 */\n\n\tg_mutex_unlock( VAR_3 );\n\n\tVIPS_GATE_MALLOC( VAR_0 ); \n\n        return( VAR_1 );\n}",
    "func_graph_path_before": "libvips/00622428bda8d7521db8d74260b519fa41d69d0a/memory.c/vul/before/0.json",
    "func": "void *\nvips_tracked_malloc( size_t size )\n{\n        void *buf;\n\n\tvips_tracked_init(); \n\n\t/* Need an extra sizeof(size_t) bytes to track \n\t * size of this block. Ask for an extra 16 to make sure we don't break\n\t * alignment rules.\n\t */\n\tsize += 16;\n\n        if( !(buf = g_try_malloc0( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif /*DEBUG*/\n\n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\n                return( NULL );\n\t}\n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif /*DEBUG_VERBOSE*/\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\tVIPS_GATE_MALLOC( size ); \n\n        return( buf );\n}",
    "abstract_func": "void *\nvips_tracked_malloc( size_t VAR_0 )\n{\n        void *VAR_1;\n\n\tvips_tracked_init(); \n\n\t/* COMMENT_0 */\n                                                                       \n                    \n    \n\tVAR_0 += 16;\n\n        if( !(VAR_1 = g_try_malloc0( VAR_0 )) ) {\n#ifdef VAR_2\n\t\tg_assert_not_reached();\n#endif /* COMMENT_4 */\n\n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (VAR_0 / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (VAR_0 / (1024.0 * 1024.0))  );\n\n                return( NULL );\n\t}\n\n\tg_mutex_lock( VAR_3 );\n\n\t*((size_t *)VAR_1) = VAR_0;\n\tVAR_1 = (void *) ((char *)VAR_1 + 16);\n\n\tVAR_4 += VAR_0;\n\tif( VAR_4 > VAR_5 ) \n\t\tVAR_5 = VAR_4;\n\tVAR_6 += 1;\n\n#ifdef VAR_7\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", VAR_1, VAR_0 ); \n#endif /* COMMENT_5 */\n\n\tg_mutex_unlock( VAR_3 );\n\n\tVIPS_GATE_MALLOC( VAR_0 ); \n\n        return( VAR_1 );\n}",
    "func_graph_path": "libvips/00622428bda8d7521db8d74260b519fa41d69d0a/memory.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \t */\n \tsize += 16;\n \n-        if( !(buf = g_try_malloc( size )) ) {\n+        if( !(buf = g_try_malloc0( size )) ) {\n #ifdef DEBUG\n \t\tg_assert_not_reached();\n #endif /*DEBUG*/",
    "diff_line_info": {
        "deleted_lines": [
            "        if( !(buf = g_try_malloc( size )) ) {"
        ],
        "added_lines": [
            "        if( !(buf = g_try_malloc0( size )) ) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}