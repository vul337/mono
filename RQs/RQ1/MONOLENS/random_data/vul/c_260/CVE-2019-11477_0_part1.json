{
    "cve_id": "CVE-2019-11477",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "kernel/git/netdev/net",
    "commit_msg": "Jonathan Looney reported that TCP can trigger the following crash\nin tcp_shifted_skb() :\n\n\tBUG_ON(tcp_skb_pcount(skb) < pcount);\n\nThis can happen if the remote peer has advertized the smallest\nMSS that linux TCP accepts : 48\n\nAn skb can hold 17 fragments, and each fragment can hold 32KB\non x86, or 64KB on PowerPC.\n\nThis means that the 16bit witdh of TCP_SKB_CB(skb)->tcp_gso_segs\ncan overflow.\n\nNote that tcp_sendmsg() builds skbs with less than 64KB\nof payload, so this problem needs SACK to be enabled.\nSACK blocks allow TCP to coalesce multiple skbs in the retransmit\nqueue, thus filling the 17 fragments to maximal capacity.\n\nCVE-2019-11477 -- u16 overflow of TCP_SKB_CB(skb)->tcp_gso_segs\n\nFixes: 832d11c5cd07 (\"tcp: Try to restore large SKBs while SACK processing\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Jonathan Looney <jtl@netflix.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nReviewed-by: Tyler Hicks <tyhicks@canonical.com>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Bruce Curtis <brucec@netflix.com>\nCc: Jonathan Lemon <jonathan.lemon@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n",
    "commit_hash": "3b4929f65b0d8249f19a50245cd88ed1a2f78cff",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=3b4929f65b0d8249f19a50245cd88ed1a2f78cff",
    "file_path": "net/ipv4/tcp_input.c",
    "func_name": "tcp_shift_skb_data",
    "func_before": "static struct sk_buff *tcp_shift_skb_data(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct tcp_sacktag_state *state,\n\t\t\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t\t\t  bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev;\n\tint mss;\n\tint pcount = 0;\n\tint len;\n\tint in_sack;\n\n\t/* Normally R but no L won't result in plain S */\n\tif (!dup_sack &&\n\t    (TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_RETRANS)) == TCPCB_SACKED_RETRANS)\n\t\tgoto fallback;\n\tif (!skb_can_shift(skb))\n\t\tgoto fallback;\n\t/* This frame is about to be dropped (was ACKed). */\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una))\n\t\tgoto fallback;\n\n\t/* Can only happen with delayed DSACK + discard craziness */\n\tprev = skb_rb_prev(skb);\n\tif (!prev)\n\t\tgoto fallback;\n\n\tif ((TCP_SKB_CB(prev)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED)\n\t\tgoto fallback;\n\n\tif (!tcp_skb_can_collapse_to(prev))\n\t\tgoto fallback;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (in_sack) {\n\t\tlen = skb->len;\n\t\tpcount = tcp_skb_pcount(skb);\n\t\tmss = tcp_skb_seglen(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\t} else {\n\t\tif (!after(TCP_SKB_CB(skb)->end_seq, start_seq))\n\t\t\tgoto noop;\n\t\t/* CHECKME: This is non-MSS split case only?, this will\n\t\t * cause skipped skbs due to advancing loop btw, original\n\t\t * has that feature too\n\t\t */\n\t\tif (tcp_skb_pcount(skb) <= 1)\n\t\t\tgoto noop;\n\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\t/* TODO: head merge to next could be attempted here\n\t\t\t * if (!after(TCP_SKB_CB(skb)->end_seq, end_seq)),\n\t\t\t * though it might not be worth of the additional hassle\n\t\t\t *\n\t\t\t * ...we can probably just fallback to what was done\n\t\t\t * previously. We could try merging non-SACKed ones\n\t\t\t * as well but it probably isn't going to buy off\n\t\t\t * because later SACKs might again split them, and\n\t\t\t * it would make skb timestamp tracking considerably\n\t\t\t * harder problem.\n\t\t\t */\n\t\t\tgoto fallback;\n\t\t}\n\n\t\tlen = end_seq - TCP_SKB_CB(skb)->seq;\n\t\tBUG_ON(len < 0);\n\t\tBUG_ON(len > skb->len);\n\n\t\t/* MSS boundaries should be honoured or else pcount will\n\t\t * severely break even though it makes things bit trickier.\n\t\t * Optimize common case to avoid most of the divides\n\t\t */\n\t\tmss = tcp_skb_mss(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\n\t\tif (len == mss) {\n\t\t\tpcount = 1;\n\t\t} else if (len < mss) {\n\t\t\tgoto noop;\n\t\t} else {\n\t\t\tpcount = len / mss;\n\t\t\tlen = pcount * mss;\n\t\t}\n\t}\n\n\t/* tcp_sacktag_one() won't SACK-tag ranges below snd_una */\n\tif (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una))\n\t\tgoto fallback;\n\n\tif (!skb_shift(prev, skb, len))\n\t\tgoto fallback;\n\tif (!tcp_shifted_skb(sk, prev, skb, state, pcount, len, mss, dup_sack))\n\t\tgoto out;\n\n\t/* Hole filled allows collapsing with the next as well, this is very\n\t * useful when hole on every nth skb pattern happens\n\t */\n\tskb = skb_rb_next(prev);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (!skb_can_shift(skb) ||\n\t    ((TCP_SKB_CB(skb)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED) ||\n\t    (mss != tcp_skb_seglen(skb)))\n\t\tgoto out;\n\n\tlen = skb->len;\n\tif (skb_shift(prev, skb, len)) {\n\t\tpcount += tcp_skb_pcount(skb);\n\t\ttcp_shifted_skb(sk, prev, skb, state, tcp_skb_pcount(skb),\n\t\t\t\tlen, mss, 0);\n\t}\n\nout:\n\treturn prev;\n\nnoop:\n\treturn skb;\n\nfallback:\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKSHIFTFALLBACK);\n\treturn NULL;\n}",
    "abstract_func_before": "static struct sk_buff *tcp_shift_skb_data(struct sock *VAR_0, struct sk_buff *VAR_1,\n\t\t\t\t\t  struct tcp_sacktag_state *VAR_2,\n\t\t\t\t\t  u32 VAR_3, u32 VAR_4,\n\t\t\t\t\t  bool VAR_5)\n{\n\tstruct tcp_sock *VAR_6 = tcp_sk(VAR_0);\n\tstruct sk_buff *VAR_7;\n\tint VAR_8;\n\tint VAR_9 = 0;\n\tint VAR_10;\n\tint VAR_11;\n\n\t/* COMMENT_0 */\n\tif (!VAR_5 &&\n\t    (TCP_SKB_CB(VAR_1)->sacked & (VAR_12|VAR_13)) == VAR_13)\n\t\tgoto fallback;\n\tif (!skb_can_shift(VAR_1))\n\t\tgoto fallback;\n\t/* COMMENT_1 */\n\tif (!after(TCP_SKB_CB(VAR_1)->end_seq, VAR_6->snd_una))\n\t\tgoto fallback;\n\n\t/* COMMENT_2 */\n\tVAR_7 = skb_rb_prev(VAR_1);\n\tif (!VAR_7)\n\t\tgoto fallback;\n\n\tif ((TCP_SKB_CB(VAR_7)->sacked & VAR_14) != VAR_15)\n\t\tgoto fallback;\n\n\tif (!tcp_skb_can_collapse_to(VAR_7))\n\t\tgoto fallback;\n\n\tVAR_11 = !after(VAR_3, TCP_SKB_CB(VAR_1)->seq) &&\n\t\t  !before(VAR_4, TCP_SKB_CB(VAR_1)->end_seq);\n\n\tif (VAR_11) {\n\t\tVAR_10 = VAR_1->len;\n\t\tVAR_9 = tcp_skb_pcount(VAR_1);\n\t\tVAR_8 = tcp_skb_seglen(VAR_1);\n\n\t\t/* COMMENT_3 */\n                                         \n     \n\t\tif (VAR_8 != tcp_skb_seglen(VAR_7))\n\t\t\tgoto fallback;\n\t} else {\n\t\tif (!after(TCP_SKB_CB(VAR_1)->end_seq, VAR_3))\n\t\t\tgoto noop;\n\t\t/* COMMENT_6 */\n                                                           \n                         \n     \n\t\tif (tcp_skb_pcount(VAR_1) <= 1)\n\t\t\tgoto noop;\n\n\t\tVAR_11 = !after(VAR_3, TCP_SKB_CB(VAR_1)->seq);\n\t\tif (!VAR_11) {\n\t\t\t/* COMMENT_10 */\n                                                     \n                                                           \n     \n                                                       \n                                                      \n                                                    \n                                                     \n                                                       \n                     \n      \n\t\t\tgoto fallback;\n\t\t}\n\n\t\tVAR_10 = VAR_4 - TCP_SKB_CB(VAR_1)->seq;\n\t\tBUG_ON(VAR_10 < 0);\n\t\tBUG_ON(VAR_10 > VAR_1->len);\n\n\t\t/* COMMENT_21 */\n                                                             \n                                                      \n     \n\t\tVAR_8 = tcp_skb_mss(VAR_1);\n\n\t\t/* COMMENT_25 */\n                                         \n     \n\t\tif (VAR_8 != tcp_skb_seglen(VAR_7))\n\t\t\tgoto fallback;\n\n\t\tif (VAR_10 == VAR_8) {\n\t\t\tVAR_9 = 1;\n\t\t} else if (VAR_10 < VAR_8) {\n\t\t\tgoto noop;\n\t\t} else {\n\t\t\tVAR_9 = VAR_10 / VAR_8;\n\t\t\tVAR_10 = VAR_9 * VAR_8;\n\t\t}\n\t}\n\n\t/* COMMENT_28 */\n\tif (!after(TCP_SKB_CB(VAR_1)->seq + VAR_10, VAR_6->snd_una))\n\t\tgoto fallback;\n\n\tif (!skb_shift(VAR_7, VAR_1, VAR_10))\n\t\tgoto fallback;\n\tif (!tcp_shifted_skb(VAR_0, VAR_7, VAR_1, VAR_2, VAR_9, VAR_10, VAR_8, VAR_5))\n\t\tgoto out;\n\n\t/* COMMENT_29 */\n                                                     \n    \n\tVAR_1 = skb_rb_next(VAR_7);\n\tif (!VAR_1)\n\t\tgoto out;\n\n\tif (!skb_can_shift(VAR_1) ||\n\t    ((TCP_SKB_CB(VAR_1)->sacked & VAR_14) != VAR_15) ||\n\t    (VAR_8 != tcp_skb_seglen(VAR_1)))\n\t\tgoto out;\n\n\tVAR_10 = VAR_1->len;\n\tif (skb_shift(VAR_7, VAR_1, VAR_10)) {\n\t\tVAR_9 += tcp_skb_pcount(VAR_1);\n\t\ttcp_shifted_skb(VAR_0, VAR_7, VAR_1, VAR_2, tcp_skb_pcount(VAR_1),\n\t\t\t\tVAR_10, VAR_8, 0);\n\t}\n\nout:\n\treturn VAR_7;\n\nnoop:\n\treturn VAR_1;\n\nfallback:\n\tNET_INC_STATS(sock_net(VAR_0), VAR_16);\n\treturn NULL;\n}",
    "func_graph_path_before": "kernel/git/netdev/net/3b4929f65b0d8249f19a50245cd88ed1a2f78cff/tcp_input.c/vul/before/1.json",
    "func": "static struct sk_buff *tcp_shift_skb_data(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct tcp_sacktag_state *state,\n\t\t\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t\t\t  bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev;\n\tint mss;\n\tint pcount = 0;\n\tint len;\n\tint in_sack;\n\n\t/* Normally R but no L won't result in plain S */\n\tif (!dup_sack &&\n\t    (TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_RETRANS)) == TCPCB_SACKED_RETRANS)\n\t\tgoto fallback;\n\tif (!skb_can_shift(skb))\n\t\tgoto fallback;\n\t/* This frame is about to be dropped (was ACKed). */\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una))\n\t\tgoto fallback;\n\n\t/* Can only happen with delayed DSACK + discard craziness */\n\tprev = skb_rb_prev(skb);\n\tif (!prev)\n\t\tgoto fallback;\n\n\tif ((TCP_SKB_CB(prev)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED)\n\t\tgoto fallback;\n\n\tif (!tcp_skb_can_collapse_to(prev))\n\t\tgoto fallback;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (in_sack) {\n\t\tlen = skb->len;\n\t\tpcount = tcp_skb_pcount(skb);\n\t\tmss = tcp_skb_seglen(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\t} else {\n\t\tif (!after(TCP_SKB_CB(skb)->end_seq, start_seq))\n\t\t\tgoto noop;\n\t\t/* CHECKME: This is non-MSS split case only?, this will\n\t\t * cause skipped skbs due to advancing loop btw, original\n\t\t * has that feature too\n\t\t */\n\t\tif (tcp_skb_pcount(skb) <= 1)\n\t\t\tgoto noop;\n\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\t/* TODO: head merge to next could be attempted here\n\t\t\t * if (!after(TCP_SKB_CB(skb)->end_seq, end_seq)),\n\t\t\t * though it might not be worth of the additional hassle\n\t\t\t *\n\t\t\t * ...we can probably just fallback to what was done\n\t\t\t * previously. We could try merging non-SACKed ones\n\t\t\t * as well but it probably isn't going to buy off\n\t\t\t * because later SACKs might again split them, and\n\t\t\t * it would make skb timestamp tracking considerably\n\t\t\t * harder problem.\n\t\t\t */\n\t\t\tgoto fallback;\n\t\t}\n\n\t\tlen = end_seq - TCP_SKB_CB(skb)->seq;\n\t\tBUG_ON(len < 0);\n\t\tBUG_ON(len > skb->len);\n\n\t\t/* MSS boundaries should be honoured or else pcount will\n\t\t * severely break even though it makes things bit trickier.\n\t\t * Optimize common case to avoid most of the divides\n\t\t */\n\t\tmss = tcp_skb_mss(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\n\t\tif (len == mss) {\n\t\t\tpcount = 1;\n\t\t} else if (len < mss) {\n\t\t\tgoto noop;\n\t\t} else {\n\t\t\tpcount = len / mss;\n\t\t\tlen = pcount * mss;\n\t\t}\n\t}\n\n\t/* tcp_sacktag_one() won't SACK-tag ranges below snd_una */\n\tif (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una))\n\t\tgoto fallback;\n\n\tif (!tcp_skb_shift(prev, skb, pcount, len))\n\t\tgoto fallback;\n\tif (!tcp_shifted_skb(sk, prev, skb, state, pcount, len, mss, dup_sack))\n\t\tgoto out;\n\n\t/* Hole filled allows collapsing with the next as well, this is very\n\t * useful when hole on every nth skb pattern happens\n\t */\n\tskb = skb_rb_next(prev);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (!skb_can_shift(skb) ||\n\t    ((TCP_SKB_CB(skb)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED) ||\n\t    (mss != tcp_skb_seglen(skb)))\n\t\tgoto out;\n\n\tlen = skb->len;\n\tpcount = tcp_skb_pcount(skb);\n\tif (tcp_skb_shift(prev, skb, pcount, len))\n\t\ttcp_shifted_skb(sk, prev, skb, state, pcount,\n\t\t\t\tlen, mss, 0);\n\nout:\n\treturn prev;\n\nnoop:\n\treturn skb;\n\nfallback:\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKSHIFTFALLBACK);\n\treturn NULL;\n}",
    "abstract_func": "static struct sk_buff *tcp_shift_skb_data(struct sock *VAR_0, struct sk_buff *VAR_1,\n\t\t\t\t\t  struct tcp_sacktag_state *VAR_2,\n\t\t\t\t\t  u32 VAR_3, u32 VAR_4,\n\t\t\t\t\t  bool VAR_5)\n{\n\tstruct tcp_sock *VAR_6 = tcp_sk(VAR_0);\n\tstruct sk_buff *VAR_7;\n\tint VAR_8;\n\tint VAR_9 = 0;\n\tint VAR_10;\n\tint VAR_11;\n\n\t/* COMMENT_0 */\n\tif (!VAR_5 &&\n\t    (TCP_SKB_CB(VAR_1)->sacked & (VAR_12|VAR_13)) == VAR_13)\n\t\tgoto fallback;\n\tif (!skb_can_shift(VAR_1))\n\t\tgoto fallback;\n\t/* COMMENT_1 */\n\tif (!after(TCP_SKB_CB(VAR_1)->end_seq, VAR_6->snd_una))\n\t\tgoto fallback;\n\n\t/* COMMENT_2 */\n\tVAR_7 = skb_rb_prev(VAR_1);\n\tif (!VAR_7)\n\t\tgoto fallback;\n\n\tif ((TCP_SKB_CB(VAR_7)->sacked & VAR_14) != VAR_15)\n\t\tgoto fallback;\n\n\tif (!tcp_skb_can_collapse_to(VAR_7))\n\t\tgoto fallback;\n\n\tVAR_11 = !after(VAR_3, TCP_SKB_CB(VAR_1)->seq) &&\n\t\t  !before(VAR_4, TCP_SKB_CB(VAR_1)->end_seq);\n\n\tif (VAR_11) {\n\t\tVAR_10 = VAR_1->len;\n\t\tVAR_9 = tcp_skb_pcount(VAR_1);\n\t\tVAR_8 = tcp_skb_seglen(VAR_1);\n\n\t\t/* COMMENT_3 */\n                                         \n     \n\t\tif (VAR_8 != tcp_skb_seglen(VAR_7))\n\t\t\tgoto fallback;\n\t} else {\n\t\tif (!after(TCP_SKB_CB(VAR_1)->end_seq, VAR_3))\n\t\t\tgoto noop;\n\t\t/* COMMENT_6 */\n                                                           \n                         \n     \n\t\tif (tcp_skb_pcount(VAR_1) <= 1)\n\t\t\tgoto noop;\n\n\t\tVAR_11 = !after(VAR_3, TCP_SKB_CB(VAR_1)->seq);\n\t\tif (!VAR_11) {\n\t\t\t/* COMMENT_10 */\n                                                     \n                                                           \n     \n                                                       \n                                                      \n                                                    \n                                                     \n                                                       \n                     \n      \n\t\t\tgoto fallback;\n\t\t}\n\n\t\tVAR_10 = VAR_4 - TCP_SKB_CB(VAR_1)->seq;\n\t\tBUG_ON(VAR_10 < 0);\n\t\tBUG_ON(VAR_10 > VAR_1->len);\n\n\t\t/* COMMENT_21 */\n                                                             \n                                                      \n     \n\t\tVAR_8 = tcp_skb_mss(VAR_1);\n\n\t\t/* COMMENT_25 */\n                                         \n     \n\t\tif (VAR_8 != tcp_skb_seglen(VAR_7))\n\t\t\tgoto fallback;\n\n\t\tif (VAR_10 == VAR_8) {\n\t\t\tVAR_9 = 1;\n\t\t} else if (VAR_10 < VAR_8) {\n\t\t\tgoto noop;\n\t\t} else {\n\t\t\tVAR_9 = VAR_10 / VAR_8;\n\t\t\tVAR_10 = VAR_9 * VAR_8;\n\t\t}\n\t}\n\n\t/* COMMENT_28 */\n\tif (!after(TCP_SKB_CB(VAR_1)->seq + VAR_10, VAR_6->snd_una))\n\t\tgoto fallback;\n\n\tif (!tcp_skb_shift(VAR_7, VAR_1, VAR_9, VAR_10))\n\t\tgoto fallback;\n\tif (!tcp_shifted_skb(VAR_0, VAR_7, VAR_1, VAR_2, VAR_9, VAR_10, VAR_8, VAR_5))\n\t\tgoto out;\n\n\t/* COMMENT_29 */\n                                                     \n    \n\tVAR_1 = skb_rb_next(VAR_7);\n\tif (!VAR_1)\n\t\tgoto out;\n\n\tif (!skb_can_shift(VAR_1) ||\n\t    ((TCP_SKB_CB(VAR_1)->sacked & VAR_14) != VAR_15) ||\n\t    (VAR_8 != tcp_skb_seglen(VAR_1)))\n\t\tgoto out;\n\n\tVAR_10 = VAR_1->len;\n\tVAR_9 = tcp_skb_pcount(VAR_1);\n\tif (tcp_skb_shift(VAR_7, VAR_1, VAR_9, VAR_10))\n\t\ttcp_shifted_skb(VAR_0, VAR_7, VAR_1, VAR_2, VAR_9,\n\t\t\t\tVAR_10, VAR_8, 0);\n\nout:\n\treturn VAR_7;\n\nnoop:\n\treturn VAR_1;\n\nfallback:\n\tNET_INC_STATS(sock_net(VAR_0), VAR_16);\n\treturn NULL;\n}",
    "func_graph_path": "kernel/git/netdev/net/3b4929f65b0d8249f19a50245cd88ed1a2f78cff/tcp_input.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -100,7 +100,7 @@\n \tif (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una))\n \t\tgoto fallback;\n \n-\tif (!skb_shift(prev, skb, len))\n+\tif (!tcp_skb_shift(prev, skb, pcount, len))\n \t\tgoto fallback;\n \tif (!tcp_shifted_skb(sk, prev, skb, state, pcount, len, mss, dup_sack))\n \t\tgoto out;\n@@ -118,11 +118,10 @@\n \t\tgoto out;\n \n \tlen = skb->len;\n-\tif (skb_shift(prev, skb, len)) {\n-\t\tpcount += tcp_skb_pcount(skb);\n-\t\ttcp_shifted_skb(sk, prev, skb, state, tcp_skb_pcount(skb),\n+\tpcount = tcp_skb_pcount(skb);\n+\tif (tcp_skb_shift(prev, skb, pcount, len))\n+\t\ttcp_shifted_skb(sk, prev, skb, state, pcount,\n \t\t\t\tlen, mss, 0);\n-\t}\n \n out:\n \treturn prev;",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (!skb_shift(prev, skb, len))",
            "\tif (skb_shift(prev, skb, len)) {",
            "\t\tpcount += tcp_skb_pcount(skb);",
            "\t\ttcp_shifted_skb(sk, prev, skb, state, tcp_skb_pcount(skb),",
            "\t}"
        ],
        "added_lines": [
            "\tif (!tcp_skb_shift(prev, skb, pcount, len))",
            "\tpcount = tcp_skb_pcount(skb);",
            "\tif (tcp_skb_shift(prev, skb, pcount, len))",
            "\t\ttcp_shifted_skb(sk, prev, skb, state, pcount,"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}