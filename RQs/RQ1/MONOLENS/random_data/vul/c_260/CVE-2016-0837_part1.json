{
    "cve_id": "CVE-2016-0837",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "android",
    "commit_msg": "Also fix out of bounds access for normal read\n\nPrevious fix accidentally only fixed the fragmented read case.\n\nBug: 27208621\nChange-Id: Ie16f1920b84c8aba613842659238fcd5925694ad\n",
    "commit_hash": "7a282fb64fef25349e9d341f102d9cea3bf75baf",
    "git_url": "https://android.googlesource.com/platform/frameworks/av/+/7a282fb64fef25349e9d341f102d9cea3bf75baf",
    "file_path": "media/libstagefright/MPEG4Extractor.cpp",
    "func_name": "MPEG4Source::read",
    "func_before": "status_t MPEG4Source::read(\n        MediaBuffer **out, const ReadOptions *options) {\n    Mutex::Autolock autoLock(mLock);\n\n    CHECK(mStarted);\n\n    if (mFirstMoofOffset > 0) {\n        return fragmentedRead(out, options);\n    }\n\n    *out = NULL;\n\n    int64_t targetSampleTimeUs = -1;\n\n    int64_t seekTimeUs;\n    ReadOptions::SeekMode mode;\n    if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n        uint32_t findFlags = 0;\n        switch (mode) {\n            case ReadOptions::SEEK_PREVIOUS_SYNC:\n                findFlags = SampleTable::kFlagBefore;\n                break;\n            case ReadOptions::SEEK_NEXT_SYNC:\n                findFlags = SampleTable::kFlagAfter;\n                break;\n            case ReadOptions::SEEK_CLOSEST_SYNC:\n            case ReadOptions::SEEK_CLOSEST:\n                findFlags = SampleTable::kFlagClosest;\n                break;\n            default:\n                CHECK(!\"Should not be here.\");\n                break;\n        }\n\n        uint32_t sampleIndex;\n        status_t err = mSampleTable->findSampleAtTime(\n                seekTimeUs, 1000000, mTimescale,\n                &sampleIndex, findFlags);\n\n        if (mode == ReadOptions::SEEK_CLOSEST) {\n            // We found the closest sample already, now we want the sync\n            // sample preceding it (or the sample itself of course), even\n            // if the subsequent sync sample is closer.\n            findFlags = SampleTable::kFlagBefore;\n        }\n\n        uint32_t syncSampleIndex;\n        if (err == OK) {\n            err = mSampleTable->findSyncSampleNear(\n                    sampleIndex, &syncSampleIndex, findFlags);\n        }\n\n        uint32_t sampleTime;\n        if (err == OK) {\n            err = mSampleTable->getMetaDataForSample(\n                    sampleIndex, NULL, NULL, &sampleTime);\n        }\n\n        if (err != OK) {\n            if (err == ERROR_OUT_OF_RANGE) {\n                // An attempt to seek past the end of the stream would\n                // normally cause this ERROR_OUT_OF_RANGE error. Propagating\n                // this all the way to the MediaPlayer would cause abnormal\n                // termination. Legacy behaviour appears to be to behave as if\n                // we had seeked to the end of stream, ending normally.\n                err = ERROR_END_OF_STREAM;\n            }\n            ALOGV(\"end of stream\");\n            return err;\n        }\n\n        if (mode == ReadOptions::SEEK_CLOSEST) {\n            targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;\n        }\n\n#if 0\n        uint32_t syncSampleTime;\n        CHECK_EQ(OK, mSampleTable->getMetaDataForSample(\n                    syncSampleIndex, NULL, NULL, &syncSampleTime));\n\n        ALOGI(\"seek to time %lld us => sample at time %lld us, \"\n             \"sync sample at time %lld us\",\n             seekTimeUs,\n             sampleTime * 1000000ll / mTimescale,\n             syncSampleTime * 1000000ll / mTimescale);\n#endif\n\n        mCurrentSampleIndex = syncSampleIndex;\n        if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n        }\n\n        // fall through\n    }\n\n    off64_t offset;\n    size_t size;\n    uint32_t cts, stts;\n    bool isSyncSample;\n    bool newBuffer = false;\n    if (mBuffer == NULL) {\n        newBuffer = true;\n\n        status_t err =\n            mSampleTable->getMetaDataForSample(\n                    mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);\n\n        if (err != OK) {\n            return err;\n        }\n\n        err = mGroup->acquire_buffer(&mBuffer);\n\n        if (err != OK) {\n            CHECK(mBuffer == NULL);\n            return err;\n        }\n        if (size > mBuffer->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());\n            return ERROR_BUFFER_TOO_SMALL;\n        }\n    }\n\n    if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {\n        if (newBuffer) {\n            ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n            if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                return ERROR_IO;\n            }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->clear();\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n            mBuffer->meta_data()->setInt64(\n                    kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);\n\n            if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n            }\n\n            if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n            }\n\n            ++mCurrentSampleIndex;\n        }\n\n        if (!mIsAVC && !mIsHEVC) {\n            *out = mBuffer;\n            mBuffer = NULL;\n\n            return OK;\n        }\n\n        // Each NAL unit is split up into its constituent fragments and\n        // each one of them returned in its own buffer.\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n        const uint8_t *src =\n            (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n        size_t nal_size = parseNALSize(src);\n        if (mNALLengthSize > SIZE_MAX - nal_size) {\n            ALOGE(\"b/24441553, b/24445122\");\n        }\n        if (mBuffer->range_length() - mNALLengthSize < nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n            return ERROR_MALFORMED;\n        }\n\n        MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n        if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n        }\n\n        *out = clone;\n\n        return OK;\n    } else {\n        // Whole NAL units are returned but each fragment is prefixed by\n        // the start code (0x00 00 00 01).\n        ssize_t num_bytes_read = 0;\n        int32_t drm = 0;\n        bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n        if (usesDRM) {\n            num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);\n        } else {\n            num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);\n        }\n\n        if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            return ERROR_IO;\n        }\n\n        if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n        } else {\n            uint8_t *dstData = (uint8_t *)mBuffer->data();\n            size_t srcOffset = 0;\n            size_t dstOffset = 0;\n\n            while (srcOffset < size) {\n                bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);\n                size_t nalLength = 0;\n                if (!isMalFormed) {\n                    nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                    srcOffset += mNALLengthSize;\n                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);\n                }\n\n                if (isMalFormed) {\n                    ALOGE(\"Video is malformed\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n                    return ERROR_MALFORMED;\n                }\n\n                if (nalLength == 0) {\n                    continue;\n                }\n\n                CHECK(dstOffset + 4 <= mBuffer->size());\n\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n            }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n        }\n\n        mBuffer->meta_data()->clear();\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n        mBuffer->meta_data()->setInt64(\n                kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);\n\n        if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n        }\n\n        if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n        }\n\n        ++mCurrentSampleIndex;\n\n        *out = mBuffer;\n        mBuffer = NULL;\n\n        return OK;\n    }\n}",
    "abstract_func_before": "status_t MPEG4Source::read(\n        MediaBuffer **VAR_0, const ReadOptions *VAR_1) {\n    Mutex::Autolock autoLock(mLock);\n\n    CHECK(VAR_2);\n\n    if (VAR_3 > 0) {\n        return fragmentedRead(VAR_0, VAR_1);\n    }\n\n    *VAR_0 = NULL;\n\n    int64_t VAR_4 = -1;\n\n    int64_t VAR_5;\n    ReadOptions::SeekMode VAR_6;\n    if (VAR_1 && VAR_1->getSeekTo(&VAR_5, &VAR_6)) {\n        uint32_t VAR_7 = 0;\n        switch (VAR_6) {\n            case ReadOptions::SEEK_PREVIOUS_SYNC:\n                VAR_7 = SampleTable::kFlagBefore;\n                break;\n            case ReadOptions::SEEK_NEXT_SYNC:\n                VAR_7 = SampleTable::kFlagAfter;\n                break;\n            case ReadOptions::SEEK_CLOSEST_SYNC:\n            case ReadOptions::SEEK_CLOSEST:\n                VAR_7 = SampleTable::kFlagClosest;\n                break;\n            default:\n                CHECK(!\"Should not be here.\");\n                break;\n        }\n\n        uint32_t VAR_8;\n        status_t VAR_9 = VAR_10->findSampleAtTime(\n                VAR_5, 1000000, VAR_11,\n                &VAR_8, VAR_7);\n\n        if (VAR_6 == ReadOptions::SEEK_CLOSEST) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            VAR_7 = SampleTable::kFlagBefore;\n        }\n\n        uint32_t VAR_12;\n        if (VAR_9 == VAR_13) {\n            VAR_9 = VAR_10->findSyncSampleNear(\n                    VAR_8, &VAR_12, VAR_7);\n        }\n\n        uint32_t VAR_14;\n        if (VAR_9 == VAR_13) {\n            VAR_9 = VAR_10->getMetaDataForSample(\n                    VAR_8, NULL, NULL, &VAR_14);\n        }\n\n        if (VAR_9 != VAR_13) {\n            if (VAR_9 == VAR_15) {\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                /* COMMENT_7 */\n                VAR_9 = VAR_16;\n            }\n            ALOGV(\"end of stream\");\n            return VAR_9;\n        }\n\n        if (VAR_6 == ReadOptions::SEEK_CLOSEST) {\n            VAR_4 = (VAR_14 * 1000000ll) / VAR_11;\n        }\n\n#if 0\n        uint32_t VAR_17;\n        CHECK_EQ(VAR_13, VAR_10->getMetaDataForSample(\n                    VAR_12, NULL, NULL, &VAR_17));\n\n        ALOGI(\"seek to time %lld us => sample at time %lld us, \"\n             \"sync sample at time %lld us\",\n             VAR_5,\n             VAR_14 * 1000000ll / VAR_11,\n             VAR_17 * 1000000ll / VAR_11);\n#endif\n\n        VAR_18 = VAR_12;\n        if (VAR_19 != NULL) {\n            VAR_19->release();\n            VAR_19 = NULL;\n        }\n\n        /* COMMENT_8 */\n    }\n\n    off64_t VAR_20;\n    size_t VAR_21;\n    uint32_t VAR_22, VAR_23;\n    bool VAR_24;\n    bool VAR_25 = false;\n    if (VAR_19 == NULL) {\n        VAR_25 = true;\n\n        status_t VAR_9 =\n            VAR_10->getMetaDataForSample(\n                    VAR_18, &VAR_20, &VAR_21, &VAR_22, &VAR_24, &VAR_23);\n\n        if (VAR_9 != VAR_13) {\n            return VAR_9;\n        }\n\n        VAR_9 = VAR_26->acquire_buffer(&VAR_19);\n\n        if (VAR_9 != VAR_13) {\n            CHECK(VAR_19 == NULL);\n            return VAR_9;\n        }\n        if (VAR_21 > VAR_19->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", VAR_21, VAR_19->size());\n            return VAR_27;\n        }\n    }\n\n    if ((!VAR_28 && !VAR_29) || VAR_30) {\n        if (VAR_25) {\n            ssize_t VAR_31 =\n                VAR_32->readAt(VAR_20, (uint8_t *)VAR_19->data(), VAR_21);\n\n            if (VAR_31 < (ssize_t)VAR_21) {\n                VAR_19->release();\n                VAR_19 = NULL;\n\n                return VAR_33;\n            }\n\n            CHECK(VAR_19 != NULL);\n            VAR_19->set_range(0, VAR_21);\n            VAR_19->meta_data()->clear();\n            VAR_19->meta_data()->setInt64(\n                    VAR_34, ((int64_t)VAR_22 * 1000000) / VAR_11);\n            VAR_19->meta_data()->setInt64(\n                    VAR_35, ((int64_t)VAR_23 * 1000000) / VAR_11);\n\n            if (VAR_4 >= 0) {\n                VAR_19->meta_data()->setInt64(\n                        VAR_36, VAR_4);\n            }\n\n            if (VAR_24) {\n                VAR_19->meta_data()->setInt32(VAR_37, 1);\n            }\n\n            ++VAR_18;\n        }\n\n        if (!VAR_28 && !VAR_29) {\n            *VAR_0 = VAR_19;\n            VAR_19 = NULL;\n\n            return VAR_13;\n        }\n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n\n        CHECK(VAR_19->range_length() >= VAR_38);\n\n        const uint8_t *VAR_39 =\n            (const uint8_t *)VAR_19->data() + VAR_19->range_offset();\n\n        size_t VAR_40 = parseNALSize(VAR_39);\n        if (VAR_38 > VAR_41 - VAR_40) {\n            ALOGE(\"b/24441553, b/24445122\");\n        }\n        if (VAR_19->range_length() - VAR_38 < VAR_40) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            VAR_19->release();\n            VAR_19 = NULL;\n\n            return VAR_42;\n        }\n\n        MediaBuffer *VAR_43 = VAR_19->clone();\n        CHECK(VAR_43 != NULL);\n        VAR_43->set_range(VAR_19->range_offset() + VAR_38, VAR_40);\n\n        CHECK(VAR_19 != NULL);\n        VAR_19->set_range(\n                VAR_19->range_offset() + VAR_38 + VAR_40,\n                VAR_19->range_length() - VAR_38 - VAR_40);\n\n        if (VAR_19->range_length() == 0) {\n            VAR_19->release();\n            VAR_19 = NULL;\n        }\n\n        *VAR_0 = VAR_43;\n\n        return VAR_13;\n    } else {\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        ssize_t VAR_31 = 0;\n        int32_t VAR_44 = 0;\n        bool VAR_45 = (VAR_46->findInt32(VAR_47, &VAR_44) && VAR_44 != 0);\n        if (VAR_45) {\n            VAR_31 =\n                VAR_32->readAt(VAR_20, (uint8_t*)VAR_19->data(), VAR_21);\n        } else {\n            VAR_31 = VAR_32->readAt(VAR_20, VAR_48, VAR_21);\n        }\n\n        if (VAR_31 < (ssize_t)VAR_21) {\n            VAR_19->release();\n            VAR_19 = NULL;\n\n            return VAR_33;\n        }\n\n        if (VAR_45) {\n            CHECK(VAR_19 != NULL);\n            VAR_19->set_range(0, VAR_21);\n\n        } else {\n            uint8_t *VAR_49 = (uint8_t *)VAR_19->data();\n            size_t VAR_50 = 0;\n            size_t VAR_51 = 0;\n\n            while (VAR_50 < VAR_21) {\n                bool VAR_52 = !isInRange((size_t)0u, VAR_21, VAR_50, VAR_38);\n                size_t VAR_53 = 0;\n                if (!VAR_52) {\n                    VAR_53 = parseNALSize(&VAR_48[VAR_50]);\n                    VAR_50 += VAR_38;\n                    VAR_52 = !isInRange((size_t)0u, VAR_21, VAR_50, VAR_53);\n                }\n\n                if (VAR_52) {\n                    ALOGE(\"Video is malformed\");\n                    VAR_19->release();\n                    VAR_19 = NULL;\n                    return VAR_42;\n                }\n\n                if (VAR_53 == 0) {\n                    continue;\n                }\n\n                CHECK(VAR_51 + 4 <= VAR_19->size());\n\n                VAR_49[VAR_51++] = 0;\n                VAR_49[VAR_51++] = 0;\n                VAR_49[VAR_51++] = 0;\n                VAR_49[VAR_51++] = 1;\n                memcpy(&VAR_49[VAR_51], &VAR_48[VAR_50], VAR_53);\n                VAR_50 += VAR_53;\n                VAR_51 += VAR_53;\n            }\n            CHECK_EQ(VAR_50, VAR_21);\n            CHECK(VAR_19 != NULL);\n            VAR_19->set_range(0, VAR_51);\n        }\n\n        VAR_19->meta_data()->clear();\n        VAR_19->meta_data()->setInt64(\n                VAR_34, ((int64_t)VAR_22 * 1000000) / VAR_11);\n        VAR_19->meta_data()->setInt64(\n                VAR_35, ((int64_t)VAR_23 * 1000000) / VAR_11);\n\n        if (VAR_4 >= 0) {\n            VAR_19->meta_data()->setInt64(\n                    VAR_36, VAR_4);\n        }\n\n        if (VAR_24) {\n            VAR_19->meta_data()->setInt32(VAR_37, 1);\n        }\n\n        ++VAR_18;\n\n        *VAR_0 = VAR_19;\n        VAR_19 = NULL;\n\n        return VAR_13;\n    }\n}",
    "func_graph_path_before": "android/7a282fb64fef25349e9d341f102d9cea3bf75baf/MPEG4Extractor.cpp/vul/before/0.json",
    "func": "status_t MPEG4Source::read(\n        MediaBuffer **out, const ReadOptions *options) {\n    Mutex::Autolock autoLock(mLock);\n\n    CHECK(mStarted);\n\n    if (mFirstMoofOffset > 0) {\n        return fragmentedRead(out, options);\n    }\n\n    *out = NULL;\n\n    int64_t targetSampleTimeUs = -1;\n\n    int64_t seekTimeUs;\n    ReadOptions::SeekMode mode;\n    if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n        uint32_t findFlags = 0;\n        switch (mode) {\n            case ReadOptions::SEEK_PREVIOUS_SYNC:\n                findFlags = SampleTable::kFlagBefore;\n                break;\n            case ReadOptions::SEEK_NEXT_SYNC:\n                findFlags = SampleTable::kFlagAfter;\n                break;\n            case ReadOptions::SEEK_CLOSEST_SYNC:\n            case ReadOptions::SEEK_CLOSEST:\n                findFlags = SampleTable::kFlagClosest;\n                break;\n            default:\n                CHECK(!\"Should not be here.\");\n                break;\n        }\n\n        uint32_t sampleIndex;\n        status_t err = mSampleTable->findSampleAtTime(\n                seekTimeUs, 1000000, mTimescale,\n                &sampleIndex, findFlags);\n\n        if (mode == ReadOptions::SEEK_CLOSEST) {\n            // We found the closest sample already, now we want the sync\n            // sample preceding it (or the sample itself of course), even\n            // if the subsequent sync sample is closer.\n            findFlags = SampleTable::kFlagBefore;\n        }\n\n        uint32_t syncSampleIndex;\n        if (err == OK) {\n            err = mSampleTable->findSyncSampleNear(\n                    sampleIndex, &syncSampleIndex, findFlags);\n        }\n\n        uint32_t sampleTime;\n        if (err == OK) {\n            err = mSampleTable->getMetaDataForSample(\n                    sampleIndex, NULL, NULL, &sampleTime);\n        }\n\n        if (err != OK) {\n            if (err == ERROR_OUT_OF_RANGE) {\n                // An attempt to seek past the end of the stream would\n                // normally cause this ERROR_OUT_OF_RANGE error. Propagating\n                // this all the way to the MediaPlayer would cause abnormal\n                // termination. Legacy behaviour appears to be to behave as if\n                // we had seeked to the end of stream, ending normally.\n                err = ERROR_END_OF_STREAM;\n            }\n            ALOGV(\"end of stream\");\n            return err;\n        }\n\n        if (mode == ReadOptions::SEEK_CLOSEST) {\n            targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;\n        }\n\n#if 0\n        uint32_t syncSampleTime;\n        CHECK_EQ(OK, mSampleTable->getMetaDataForSample(\n                    syncSampleIndex, NULL, NULL, &syncSampleTime));\n\n        ALOGI(\"seek to time %lld us => sample at time %lld us, \"\n             \"sync sample at time %lld us\",\n             seekTimeUs,\n             sampleTime * 1000000ll / mTimescale,\n             syncSampleTime * 1000000ll / mTimescale);\n#endif\n\n        mCurrentSampleIndex = syncSampleIndex;\n        if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n        }\n\n        // fall through\n    }\n\n    off64_t offset;\n    size_t size;\n    uint32_t cts, stts;\n    bool isSyncSample;\n    bool newBuffer = false;\n    if (mBuffer == NULL) {\n        newBuffer = true;\n\n        status_t err =\n            mSampleTable->getMetaDataForSample(\n                    mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);\n\n        if (err != OK) {\n            return err;\n        }\n\n        err = mGroup->acquire_buffer(&mBuffer);\n\n        if (err != OK) {\n            CHECK(mBuffer == NULL);\n            return err;\n        }\n        if (size > mBuffer->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());\n            return ERROR_BUFFER_TOO_SMALL;\n        }\n    }\n\n    if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {\n        if (newBuffer) {\n            ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n            if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                return ERROR_IO;\n            }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->clear();\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n            mBuffer->meta_data()->setInt64(\n                    kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);\n\n            if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n            }\n\n            if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n            }\n\n            ++mCurrentSampleIndex;\n        }\n\n        if (!mIsAVC && !mIsHEVC) {\n            *out = mBuffer;\n            mBuffer = NULL;\n\n            return OK;\n        }\n\n        // Each NAL unit is split up into its constituent fragments and\n        // each one of them returned in its own buffer.\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n        const uint8_t *src =\n            (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n        size_t nal_size = parseNALSize(src);\n        if (mNALLengthSize > SIZE_MAX - nal_size) {\n            ALOGE(\"b/24441553, b/24445122\");\n        }\n        if (mBuffer->range_length() - mNALLengthSize < nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n            return ERROR_MALFORMED;\n        }\n\n        MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n        if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n        }\n\n        *out = clone;\n\n        return OK;\n    } else {\n        // Whole NAL units are returned but each fragment is prefixed by\n        // the start code (0x00 00 00 01).\n        ssize_t num_bytes_read = 0;\n        int32_t drm = 0;\n        bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n        if (usesDRM) {\n            num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);\n        } else {\n            num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);\n        }\n\n        if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            return ERROR_IO;\n        }\n\n        if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n        } else {\n            uint8_t *dstData = (uint8_t *)mBuffer->data();\n            size_t srcOffset = 0;\n            size_t dstOffset = 0;\n\n            while (srcOffset < size) {\n                bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);\n                size_t nalLength = 0;\n                if (!isMalFormed) {\n                    nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                    srcOffset += mNALLengthSize;\n                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);\n                }\n\n                if (isMalFormed) {\n                    ALOGE(\"Video is malformed\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n                    return ERROR_MALFORMED;\n                }\n\n                if (nalLength == 0) {\n                    continue;\n                }\n\n                if (dstOffset > SIZE_MAX - 4 ||\n                        dstOffset + 4 > SIZE_MAX - nalLength ||\n                        dstOffset + 4 + nalLength > mBuffer->size()) {\n                    ALOGE(\"b/27208621 : %zu %zu\", dstOffset, mBuffer->size());\n                    android_errorWriteLog(0x534e4554, \"27208621\");\n                    mBuffer->release();\n                    mBuffer = NULL;\n                    return ERROR_MALFORMED;\n                }\n\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n            }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n        }\n\n        mBuffer->meta_data()->clear();\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n        mBuffer->meta_data()->setInt64(\n                kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);\n\n        if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n        }\n\n        if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n        }\n\n        ++mCurrentSampleIndex;\n\n        *out = mBuffer;\n        mBuffer = NULL;\n\n        return OK;\n    }\n}",
    "abstract_func": "status_t MPEG4Source::read(\n        MediaBuffer **VAR_0, const ReadOptions *VAR_1) {\n    Mutex::Autolock autoLock(mLock);\n\n    CHECK(VAR_2);\n\n    if (VAR_3 > 0) {\n        return fragmentedRead(VAR_0, VAR_1);\n    }\n\n    *VAR_0 = NULL;\n\n    int64_t VAR_4 = -1;\n\n    int64_t VAR_5;\n    ReadOptions::SeekMode VAR_6;\n    if (VAR_1 && VAR_1->getSeekTo(&VAR_5, &VAR_6)) {\n        uint32_t VAR_7 = 0;\n        switch (VAR_6) {\n            case ReadOptions::SEEK_PREVIOUS_SYNC:\n                VAR_7 = SampleTable::kFlagBefore;\n                break;\n            case ReadOptions::SEEK_NEXT_SYNC:\n                VAR_7 = SampleTable::kFlagAfter;\n                break;\n            case ReadOptions::SEEK_CLOSEST_SYNC:\n            case ReadOptions::SEEK_CLOSEST:\n                VAR_7 = SampleTable::kFlagClosest;\n                break;\n            default:\n                CHECK(!\"Should not be here.\");\n                break;\n        }\n\n        uint32_t VAR_8;\n        status_t VAR_9 = VAR_10->findSampleAtTime(\n                VAR_5, 1000000, VAR_11,\n                &VAR_8, VAR_7);\n\n        if (VAR_6 == ReadOptions::SEEK_CLOSEST) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            VAR_7 = SampleTable::kFlagBefore;\n        }\n\n        uint32_t VAR_12;\n        if (VAR_9 == VAR_13) {\n            VAR_9 = VAR_10->findSyncSampleNear(\n                    VAR_8, &VAR_12, VAR_7);\n        }\n\n        uint32_t VAR_14;\n        if (VAR_9 == VAR_13) {\n            VAR_9 = VAR_10->getMetaDataForSample(\n                    VAR_8, NULL, NULL, &VAR_14);\n        }\n\n        if (VAR_9 != VAR_13) {\n            if (VAR_9 == VAR_15) {\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                /* COMMENT_7 */\n                VAR_9 = VAR_16;\n            }\n            ALOGV(\"end of stream\");\n            return VAR_9;\n        }\n\n        if (VAR_6 == ReadOptions::SEEK_CLOSEST) {\n            VAR_4 = (VAR_14 * 1000000ll) / VAR_11;\n        }\n\n#if 0\n        uint32_t VAR_17;\n        CHECK_EQ(VAR_13, VAR_10->getMetaDataForSample(\n                    VAR_12, NULL, NULL, &VAR_17));\n\n        ALOGI(\"seek to time %lld us => sample at time %lld us, \"\n             \"sync sample at time %lld us\",\n             VAR_5,\n             VAR_14 * 1000000ll / VAR_11,\n             VAR_17 * 1000000ll / VAR_11);\n#endif\n\n        VAR_18 = VAR_12;\n        if (VAR_19 != NULL) {\n            VAR_19->release();\n            VAR_19 = NULL;\n        }\n\n        /* COMMENT_8 */\n    }\n\n    off64_t VAR_20;\n    size_t VAR_21;\n    uint32_t VAR_22, VAR_23;\n    bool VAR_24;\n    bool VAR_25 = false;\n    if (VAR_19 == NULL) {\n        VAR_25 = true;\n\n        status_t VAR_9 =\n            VAR_10->getMetaDataForSample(\n                    VAR_18, &VAR_20, &VAR_21, &VAR_22, &VAR_24, &VAR_23);\n\n        if (VAR_9 != VAR_13) {\n            return VAR_9;\n        }\n\n        VAR_9 = VAR_26->acquire_buffer(&VAR_19);\n\n        if (VAR_9 != VAR_13) {\n            CHECK(VAR_19 == NULL);\n            return VAR_9;\n        }\n        if (VAR_21 > VAR_19->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", VAR_21, VAR_19->size());\n            return VAR_27;\n        }\n    }\n\n    if ((!VAR_28 && !VAR_29) || VAR_30) {\n        if (VAR_25) {\n            ssize_t VAR_31 =\n                VAR_32->readAt(VAR_20, (uint8_t *)VAR_19->data(), VAR_21);\n\n            if (VAR_31 < (ssize_t)VAR_21) {\n                VAR_19->release();\n                VAR_19 = NULL;\n\n                return VAR_33;\n            }\n\n            CHECK(VAR_19 != NULL);\n            VAR_19->set_range(0, VAR_21);\n            VAR_19->meta_data()->clear();\n            VAR_19->meta_data()->setInt64(\n                    VAR_34, ((int64_t)VAR_22 * 1000000) / VAR_11);\n            VAR_19->meta_data()->setInt64(\n                    VAR_35, ((int64_t)VAR_23 * 1000000) / VAR_11);\n\n            if (VAR_4 >= 0) {\n                VAR_19->meta_data()->setInt64(\n                        VAR_36, VAR_4);\n            }\n\n            if (VAR_24) {\n                VAR_19->meta_data()->setInt32(VAR_37, 1);\n            }\n\n            ++VAR_18;\n        }\n\n        if (!VAR_28 && !VAR_29) {\n            *VAR_0 = VAR_19;\n            VAR_19 = NULL;\n\n            return VAR_13;\n        }\n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n\n        CHECK(VAR_19->range_length() >= VAR_38);\n\n        const uint8_t *VAR_39 =\n            (const uint8_t *)VAR_19->data() + VAR_19->range_offset();\n\n        size_t VAR_40 = parseNALSize(VAR_39);\n        if (VAR_38 > VAR_41 - VAR_40) {\n            ALOGE(\"b/24441553, b/24445122\");\n        }\n        if (VAR_19->range_length() - VAR_38 < VAR_40) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            VAR_19->release();\n            VAR_19 = NULL;\n\n            return VAR_42;\n        }\n\n        MediaBuffer *VAR_43 = VAR_19->clone();\n        CHECK(VAR_43 != NULL);\n        VAR_43->set_range(VAR_19->range_offset() + VAR_38, VAR_40);\n\n        CHECK(VAR_19 != NULL);\n        VAR_19->set_range(\n                VAR_19->range_offset() + VAR_38 + VAR_40,\n                VAR_19->range_length() - VAR_38 - VAR_40);\n\n        if (VAR_19->range_length() == 0) {\n            VAR_19->release();\n            VAR_19 = NULL;\n        }\n\n        *VAR_0 = VAR_43;\n\n        return VAR_13;\n    } else {\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        ssize_t VAR_31 = 0;\n        int32_t VAR_44 = 0;\n        bool VAR_45 = (VAR_46->findInt32(VAR_47, &VAR_44) && VAR_44 != 0);\n        if (VAR_45) {\n            VAR_31 =\n                VAR_32->readAt(VAR_20, (uint8_t*)VAR_19->data(), VAR_21);\n        } else {\n            VAR_31 = VAR_32->readAt(VAR_20, VAR_48, VAR_21);\n        }\n\n        if (VAR_31 < (ssize_t)VAR_21) {\n            VAR_19->release();\n            VAR_19 = NULL;\n\n            return VAR_33;\n        }\n\n        if (VAR_45) {\n            CHECK(VAR_19 != NULL);\n            VAR_19->set_range(0, VAR_21);\n\n        } else {\n            uint8_t *VAR_49 = (uint8_t *)VAR_19->data();\n            size_t VAR_50 = 0;\n            size_t VAR_51 = 0;\n\n            while (VAR_50 < VAR_21) {\n                bool VAR_52 = !isInRange((size_t)0u, VAR_21, VAR_50, VAR_38);\n                size_t VAR_53 = 0;\n                if (!VAR_52) {\n                    VAR_53 = parseNALSize(&VAR_48[VAR_50]);\n                    VAR_50 += VAR_38;\n                    VAR_52 = !isInRange((size_t)0u, VAR_21, VAR_50, VAR_53);\n                }\n\n                if (VAR_52) {\n                    ALOGE(\"Video is malformed\");\n                    VAR_19->release();\n                    VAR_19 = NULL;\n                    return VAR_42;\n                }\n\n                if (VAR_53 == 0) {\n                    continue;\n                }\n\n                if (VAR_51 > VAR_41 - 4 ||\n                        VAR_51 + 4 > VAR_41 - VAR_53 ||\n                        VAR_51 + 4 + VAR_53 > VAR_19->size()) {\n                    ALOGE(\"b/27208621 : %zu %zu\", VAR_51, VAR_19->size());\n                    android_errorWriteLog(0x534e4554, \"27208621\");\n                    VAR_19->release();\n                    VAR_19 = NULL;\n                    return VAR_42;\n                }\n\n                VAR_49[VAR_51++] = 0;\n                VAR_49[VAR_51++] = 0;\n                VAR_49[VAR_51++] = 0;\n                VAR_49[VAR_51++] = 1;\n                memcpy(&VAR_49[VAR_51], &VAR_48[VAR_50], VAR_53);\n                VAR_50 += VAR_53;\n                VAR_51 += VAR_53;\n            }\n            CHECK_EQ(VAR_50, VAR_21);\n            CHECK(VAR_19 != NULL);\n            VAR_19->set_range(0, VAR_51);\n        }\n\n        VAR_19->meta_data()->clear();\n        VAR_19->meta_data()->setInt64(\n                VAR_34, ((int64_t)VAR_22 * 1000000) / VAR_11);\n        VAR_19->meta_data()->setInt64(\n                VAR_35, ((int64_t)VAR_23 * 1000000) / VAR_11);\n\n        if (VAR_4 >= 0) {\n            VAR_19->meta_data()->setInt64(\n                    VAR_36, VAR_4);\n        }\n\n        if (VAR_24) {\n            VAR_19->meta_data()->setInt32(VAR_37, 1);\n        }\n\n        ++VAR_18;\n\n        *VAR_0 = VAR_19;\n        VAR_19 = NULL;\n\n        return VAR_13;\n    }\n}",
    "func_graph_path": "android/7a282fb64fef25349e9d341f102d9cea3bf75baf/MPEG4Extractor.cpp/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -248,7 +248,15 @@\n                     continue;\n                 }\n \n-                CHECK(dstOffset + 4 <= mBuffer->size());\n+                if (dstOffset > SIZE_MAX - 4 ||\n+                        dstOffset + 4 > SIZE_MAX - nalLength ||\n+                        dstOffset + 4 + nalLength > mBuffer->size()) {\n+                    ALOGE(\"b/27208621 : %zu %zu\", dstOffset, mBuffer->size());\n+                    android_errorWriteLog(0x534e4554, \"27208621\");\n+                    mBuffer->release();\n+                    mBuffer = NULL;\n+                    return ERROR_MALFORMED;\n+                }\n \n                 dstData[dstOffset++] = 0;\n                 dstData[dstOffset++] = 0;",
    "diff_line_info": {
        "deleted_lines": [
            "                CHECK(dstOffset + 4 <= mBuffer->size());"
        ],
        "added_lines": [
            "                if (dstOffset > SIZE_MAX - 4 ||",
            "                        dstOffset + 4 > SIZE_MAX - nalLength ||",
            "                        dstOffset + 4 + nalLength > mBuffer->size()) {",
            "                    ALOGE(\"b/27208621 : %zu %zu\", dstOffset, mBuffer->size());",
            "                    android_errorWriteLog(0x534e4554, \"27208621\");",
            "                    mBuffer->release();",
            "                    mBuffer = NULL;",
            "                    return ERROR_MALFORMED;",
            "                }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}