{
    "cve_id": "CVE-2023-2163",
    "cwe_ids": [
        "CWE-682"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "Juan Jose et al reported an issue found via fuzzing where the verifier's\npruning logic prematurely marks a program path as safe.\n\nConsider the following program:\n\n   0: (b7) r6 = 1024\n   1: (b7) r7 = 0\n   2: (b7) r8 = 0\n   3: (b7) r9 = -2147483648\n   4: (97) r6 %= 1025\n   5: (05) goto pc+0\n   6: (bd) if r6 <= r9 goto pc+2\n   7: (97) r6 %= 1\n   8: (b7) r9 = 0\n   9: (bd) if r6 <= r9 goto pc+1\n  10: (b7) r6 = 0\n  11: (b7) r0 = 0\n  12: (63) *(u32 *)(r10 -4) = r0\n  13: (18) r4 = 0xffff888103693400 // map_ptr(ks=4,vs=48)\n  15: (bf) r1 = r4\n  16: (bf) r2 = r10\n  17: (07) r2 += -4\n  18: (85) call bpf_map_lookup_elem#1\n  19: (55) if r0 != 0x0 goto pc+1\n  20: (95) exit\n  21: (77) r6 >>= 10\n  22: (27) r6 *= 8192\n  23: (bf) r1 = r0\n  24: (0f) r0 += r6\n  25: (79) r3 = *(u64 *)(r0 +0)\n  26: (7b) *(u64 *)(r1 +0) = r3\n  27: (95) exit\n\nThe verifier treats this as safe, leading to oob read/write access due\nto an incorrect verifier conclusion:\n\n  func#0 @0\n  0: R1=ctx(off=0,imm=0) R10=fp0\n  0: (b7) r6 = 1024                     ; R6_w=1024\n  1: (b7) r7 = 0                        ; R7_w=0\n  2: (b7) r8 = 0                        ; R8_w=0\n  3: (b7) r9 = -2147483648              ; R9_w=-2147483648\n  4: (97) r6 %= 1025                    ; R6_w=scalar()\n  5: (05) goto pc+0\n  6: (bd) if r6 <= r9 goto pc+2         ; R6_w=scalar(umin=18446744071562067969,var_off=(0xffffffff00000000; 0xffffffff)) R9_w=-2147483648\n  7: (97) r6 %= 1                       ; R6_w=scalar()\n  8: (b7) r9 = 0                        ; R9=0\n  9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0\n  10: (b7) r6 = 0                       ; R6_w=0\n  11: (b7) r0 = 0                       ; R0_w=0\n  12: (63) *(u32 *)(r10 -4) = r0\n  last_idx 12 first_idx 9\n  regs=1 stack=0 before 11: (b7) r0 = 0\n  13: R0_w=0 R10=fp0 fp-8=0000????\n  13: (18) r4 = 0xffff8ad3886c2a00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0\n  17: (07) r2 += -4                     ; R2_w=fp-4\n  18: (85) call bpf_map_lookup_elem#1   ; R0=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0)\n  19: (55) if r0 != 0x0 goto pc+1       ; R0=0\n  20: (95) exit\n\n  from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????\n  21: (77) r6 >>= 10                    ; R6_w=0\n  22: (27) r6 *= 8192                   ; R6_w=0\n  23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)\n  24: (0f) r0 += r6\n  last_idx 24 first_idx 19\n  regs=40 stack=0 before 23: (bf) r1 = r0\n  regs=40 stack=0 before 22: (27) r6 *= 8192\n  regs=40 stack=0 before 21: (77) r6 >>= 10\n  regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1\n  parent didn't have regs=40 stack=0 marks: R0_rw=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0) R6_rw=P0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????\n  last_idx 18 first_idx 9\n  regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1\n  regs=40 stack=0 before 17: (07) r2 += -4\n  regs=40 stack=0 before 16: (bf) r2 = r10\n  regs=40 stack=0 before 15: (bf) r1 = r4\n  regs=40 stack=0 before 13: (18) r4 = 0xffff8ad3886c2a00\n  regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0\n  regs=40 stack=0 before 11: (b7) r0 = 0\n  regs=40 stack=0 before 10: (b7) r6 = 0\n  25: (79) r3 = *(u64 *)(r0 +0)         ; R0_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()\n  26: (7b) *(u64 *)(r1 +0) = r3         ; R1_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()\n  27: (95) exit\n\n  from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0\n  11: (b7) r0 = 0                       ; R0_w=0\n  12: (63) *(u32 *)(r10 -4) = r0\n  last_idx 12 first_idx 11\n  regs=1 stack=0 before 11: (b7) r0 = 0\n  13: R0_w=0 R10=fp0 fp-8=0000????\n  13: (18) r4 = 0xffff8ad3886c2a00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0\n  17: (07) r2 += -4                     ; R2_w=fp-4\n  18: (85) call bpf_map_lookup_elem#1\n  frame 0: propagating r6\n  last_idx 19 first_idx 11\n  regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1\n  regs=40 stack=0 before 17: (07) r2 += -4\n  regs=40 stack=0 before 16: (bf) r2 = r10\n  regs=40 stack=0 before 15: (bf) r1 = r4\n  regs=40 stack=0 before 13: (18) r4 = 0xffff8ad3886c2a00\n  regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0\n  regs=40 stack=0 before 11: (b7) r0 = 0\n  parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_r=P0 R7=0 R8=0 R9=0 R10=fp0\n  last_idx 9 first_idx 9\n  regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1\n  parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar() R7_w=0 R8_w=0 R9_rw=0 R10=fp0\n  last_idx 8 first_idx 0\n  regs=40 stack=0 before 8: (b7) r9 = 0\n  regs=40 stack=0 before 7: (97) r6 %= 1\n  regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2\n  regs=40 stack=0 before 5: (05) goto pc+0\n  regs=40 stack=0 before 4: (97) r6 %= 1025\n  regs=40 stack=0 before 3: (b7) r9 = -2147483648\n  regs=40 stack=0 before 2: (b7) r8 = 0\n  regs=40 stack=0 before 1: (b7) r7 = 0\n  regs=40 stack=0 before 0: (b7) r6 = 1024\n  19: safe\n  frame 0: propagating r6\n  last_idx 9 first_idx 0\n  regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2\n  regs=40 stack=0 before 5: (05) goto pc+0\n  regs=40 stack=0 before 4: (97) r6 %= 1025\n  regs=40 stack=0 before 3: (b7) r9 = -2147483648\n  regs=40 stack=0 before 2: (b7) r8 = 0\n  regs=40 stack=0 before 1: (b7) r7 = 0\n  regs=40 stack=0 before 0: (b7) r6 = 1024\n\n  from 6 to 9: safe\n  verification time 110 usec\n  stack depth 4\n  processed 36 insns (limit 1000000) max_states_per_insn 0 total_states 3 peak_states 3 mark_read 2\n\nThe verifier considers this program as safe by mistakenly pruning unsafe\ncode paths. In the above func#0, code lines 0-10 are of interest. In line\n0-3 registers r6 to r9 are initialized with known scalar values. In line 4\nthe register r6 is reset to an unknown scalar given the verifier does not\ntrack modulo operations. Due to this, the verifier can also not determine\nprecisely which branches in line 6 and 9 are taken, therefore it needs to\nexplore them both.\n\nAs can be seen, the verifier starts with exploring the false/fall-through\npaths first. The 'from 19 to 21' path has both r6=0 and r9=0 and the pointer\narithmetic on r0 += r6 is therefore considered safe. Given the arithmetic,\nr6 is correctly marked for precision tracking where backtracking kicks in\nwhere it walks back the current path all the way where r6 was set to 0 in\nthe fall-through branch.\n\nNext, the pruning logics pops the path 'from 9 to 11' from the stack. Also\nhere, the state of the registers is the same, that is, r6=0 and r9=0, so\nthat at line 19 the path can be pruned as it is considered safe. It is\ninteresting to note that the conditional in line 9 turned r6 into a more\nprecise state, that is, in the fall-through path at the beginning of line\n10, it is R6=scalar(umin=1), and in the branch-taken path (which is analyzed\nhere) at the beginning of line 11, r6 turned into a known const r6=0 as\nr9=0 prior to that and therefore (unsigned) r6 <= 0 concludes that r6 must\nbe 0 (**):\n\n  [...]                                 ; R6_w=scalar()\n  9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0\n  [...]\n\n  from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0\n  [...]\n\nThe next path is 'from 6 to 9'. The verifier considers the old and current\nstate equivalent, and therefore prunes the search incorrectly. Looking into\nthe two states which are being compared by the pruning logic at line 9, the\nold state consists of R6_rwD=Pscalar() R9_rwD=0 R10=fp0 and the new state\nconsists of R1=ctx(off=0,imm=0) R6_w=scalar(umax=18446744071562067968)\nR7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0. While r6 had the reg->precise flag\ncorrectly set in the old state, r9 did not. Both r6'es are considered as\nequivalent given the old one is a superset of the current, more precise one,\nhowever, r9's actual values (0 vs 0x80000000) mismatch. Given the old r9\ndid not have reg->precise flag set, the verifier does not consider the\nregister as contributing to the precision state of r6, and therefore it\nconsidered both r9 states as equivalent. However, for this specific pruned\npath (which is also the actual path taken at runtime), register r6 will be\n0x400 and r9 0x80000000 when reaching line 21, thus oob-accessing the map.\n\nThe purpose of precision tracking is to initially mark registers (including\nspilled ones) as imprecise to help verifier's pruning logic finding equivalent\nstates it can then prune if they don't contribute to the program's safety\naspects. For example, if registers are used for pointer arithmetic or to pass\nconstant length to a helper, then the verifier sets reg->precise flag and\nbacktracks the BPF program instruction sequence and chain of verifier states\nto ensure that the given register or stack slot including their dependencies\nare marked as precisely tracked scalar. This also includes any other registers\nand slots that contribute to a tracked state of given registers/stack slot.\nThis backtracking relies on recorded jmp_history and is able to traverse\nentire chain of parent states. This process ends only when all the necessary\nregisters/slots and their transitive dependencies are marked as precise.\n\nThe backtrack_insn() is called from the current instruction up to the first\ninstruction, and its purpose is to compute a bitmask of registers and stack\nslots that need precision tracking in the parent's verifier state. For example,\nif a current instruction is r6 = r7, then r6 needs precision after this\ninstruction and r7 needs precision before this instruction, that is, in the\nparent state. Hence for the latter r7 is marked and r6 unmarked.\n\nFor the class of jmp/jmp32 instructions, backtrack_insn() today only looks\nat call and exit instructions and for all other conditionals the masks\nremain as-is. However, in the given situation register r6 has a dependency\non r9 (as described above in **), so also that one needs to be marked for\nprecision tracking. In other words, if an imprecise register influences a\nprecise one, then the imprecise register should also be marked precise.\nMeaning, in the parent state both dest and src register need to be tracked\nfor precision and therefore the marking must be more conservative by setting\nreg->precise flag for both. The precision propagation needs to cover both\nfor the conditional: if the src reg was marked but not the dst reg and vice\nversa.\n\nAfter the fix the program is correctly rejected:\n\n  func#0 @0\n  0: R1=ctx(off=0,imm=0) R10=fp0\n  0: (b7) r6 = 1024                     ; R6_w=1024\n  1: (b7) r7 = 0                        ; R7_w=0\n  2: (b7) r8 = 0                        ; R8_w=0\n  3: (b7) r9 = -2147483648              ; R9_w=-2147483648\n  4: (97) r6 %= 1025                    ; R6_w=scalar()\n  5: (05) goto pc+0\n  6: (bd) if r6 <= r9 goto pc+2         ; R6_w=scalar(umin=18446744071562067969,var_off=(0xffffffff80000000; 0x7fffffff),u32_min=-2147483648) R9_w=-2147483648\n  7: (97) r6 %= 1                       ; R6_w=scalar()\n  8: (b7) r9 = 0                        ; R9=0\n  9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0\n  10: (b7) r6 = 0                       ; R6_w=0\n  11: (b7) r0 = 0                       ; R0_w=0\n  12: (63) *(u32 *)(r10 -4) = r0\n  last_idx 12 first_idx 9\n  regs=1 stack=0 before 11: (b7) r0 = 0\n  13: R0_w=0 R10=fp0 fp-8=0000????\n  13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0\n  17: (07) r2 += -4                     ; R2_w=fp-4\n  18: (85) call bpf_map_lookup_elem#1   ; R0=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0)\n  19: (55) if r0 != 0x0 goto pc+1       ; R0=0\n  20: (95) exit\n\n  from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????\n  21: (77) r6 >>= 10                    ; R6_w=0\n  22: (27) r6 *= 8192                   ; R6_w=0\n  23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)\n  24: (0f) r0 += r6\n  last_idx 24 first_idx 19\n  regs=40 stack=0 before 23: (bf) r1 = r0\n  regs=40 stack=0 before 22: (27) r6 *= 8192\n  regs=40 stack=0 before 21: (77) r6 >>= 10\n  regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1\n  parent didn't have regs=40 stack=0 marks: R0_rw=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0) R6_rw=P0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????\n  last_idx 18 first_idx 9\n  regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1\n  regs=40 stack=0 before 17: (07) r2 += -4\n  regs=40 stack=0 before 16: (bf) r2 = r10\n  regs=40 stack=0 before 15: (bf) r1 = r4\n  regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00\n  regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0\n  regs=40 stack=0 before 11: (b7) r0 = 0\n  regs=40 stack=0 before 10: (b7) r6 = 0\n  25: (79) r3 = *(u64 *)(r0 +0)         ; R0_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()\n  26: (7b) *(u64 *)(r1 +0) = r3         ; R1_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()\n  27: (95) exit\n\n  from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0\n  11: (b7) r0 = 0                       ; R0_w=0\n  12: (63) *(u32 *)(r10 -4) = r0\n  last_idx 12 first_idx 11\n  regs=1 stack=0 before 11: (b7) r0 = 0\n  13: R0_w=0 R10=fp0 fp-8=0000????\n  13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0\n  17: (07) r2 += -4                     ; R2_w=fp-4\n  18: (85) call bpf_map_lookup_elem#1\n  frame 0: propagating r6\n  last_idx 19 first_idx 11\n  regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1\n  regs=40 stack=0 before 17: (07) r2 += -4\n  regs=40 stack=0 before 16: (bf) r2 = r10\n  regs=40 stack=0 before 15: (bf) r1 = r4\n  regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00\n  regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0\n  regs=40 stack=0 before 11: (b7) r0 = 0\n  parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_r=P0 R7=0 R8=0 R9=0 R10=fp0\n  last_idx 9 first_idx 9\n  regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1\n  parent didn't have regs=240 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar() R7_w=0 R8_w=0 R9_rw=P0 R10=fp0\n  last_idx 8 first_idx 0\n  regs=240 stack=0 before 8: (b7) r9 = 0\n  regs=40 stack=0 before 7: (97) r6 %= 1\n  regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2\n  regs=240 stack=0 before 5: (05) goto pc+0\n  regs=240 stack=0 before 4: (97) r6 %= 1025\n  regs=240 stack=0 before 3: (b7) r9 = -2147483648\n  regs=40 stack=0 before 2: (b7) r8 = 0\n  regs=40 stack=0 before 1: (b7) r7 = 0\n  regs=40 stack=0 before 0: (b7) r6 = 1024\n  19: safe\n\n  from 6 to 9: R1=ctx(off=0,imm=0) R6_w=scalar(umax=18446744071562067968) R7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0\n  9: (bd) if r6 <= r9 goto pc+1\n  last_idx 9 first_idx 0\n  regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2\n  regs=240 stack=0 before 5: (05) goto pc+0\n  regs=240 stack=0 before 4: (97) r6 %= 1025\n  regs=240 stack=0 before 3: (b7) r9 = -2147483648\n  regs=40 stack=0 before 2: (b7) r8 = 0\n  regs=40 stack=0 before 1: (b7) r7 = 0\n  regs=40 stack=0 before 0: (b7) r6 = 1024\n  last_idx 9 first_idx 0\n  regs=200 stack=0 before 6: (bd) if r6 <= r9 goto pc+2\n  regs=240 stack=0 before 5: (05) goto pc+0\n  regs=240 stack=0 before 4: (97) r6 %= 1025\n  regs=240 stack=0 before 3: (b7) r9 = -2147483648\n  regs=40 stack=0 before 2: (b7) r8 = 0\n  regs=40 stack=0 before 1: (b7) r7 = 0\n  regs=40 stack=0 before 0: (b7) r6 = 1024\n  11: R6=scalar(umax=18446744071562067968) R9=-2147483648\n  11: (b7) r0 = 0                       ; R0_w=0\n  12: (63) *(u32 *)(r10 -4) = r0\n  last_idx 12 first_idx 11\n  regs=1 stack=0 before 11: (b7) r0 = 0\n  13: R0_w=0 R10=fp0 fp-8=0000????\n  13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)\n  16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0\n  17: (07) r2 += -4                     ; R2_w=fp-4\n  18: (85) call bpf_map_lookup_elem#1   ; R0_w=map_value_or_null(id=3,off=0,ks=4,vs=48,imm=0)\n  19: (55) if r0 != 0x0 goto pc+1       ; R0_w=0\n  20: (95) exit\n\n  from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=scalar(umax=18446744071562067968) R7=0 R8=0 R9=-2147483648 R10=fp0 fp-8=mmmm????\n  21: (77) r6 >>= 10                    ; R6_w=scalar(umax=18014398507384832,var_off=(0x0; 0x3fffffffffffff))\n  22: (27) r6 *= 8192                   ; R6_w=scalar(smax=9223372036854767616,umax=18446744073709543424,var_off=(0x0; 0xffffffffffffe000),s32_max=2147475456,u32_max=-8192)\n  23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)\n  24: (0f) r0 += r6\n  last_idx 24 first_idx 21\n  regs=40 stack=0 before 23: (bf) r1 = r0\n  regs=40 stack=0 before 22: (27) r6 *= 8192\n  regs=40 stack=0 before 21: (77) r6 >>= 10\n  parent didn't have regs=40 stack=0 marks: R0_rw=map_value(off=0,ks=4,vs=48,imm=0) R6_r=Pscalar(umax=18446744071562067968) R7=0 R8=0 R9=-2147483648 R10=fp0 fp-8=mmmm????\n  last_idx 19 first_idx 11\n  regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1\n  regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1\n  regs=40 stack=0 before 17: (07) r2 += -4\n  regs=40 stack=0 before 16: (bf) r2 = r10\n  regs=40 stack=0 before 15: (bf) r1 = r4\n  regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00\n  regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0\n  regs=40 stack=0 before 11: (b7) r0 = 0\n  parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar(umax=18446744071562067968) R7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0\n  last_idx 9 first_idx 0\n  regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1\n  regs=240 stack=0 before 6: (bd) if r6 <= r9 goto pc+2\n  regs=240 stack=0 before 5: (05) goto pc+0\n  regs=240 stack=0 before 4: (97) r6 %= 1025\n  regs=240 stack=0 before 3: (b7) r9 = -2147483648\n  regs=40 stack=0 before 2: (b7) r8 = 0\n  regs=40 stack=0 before 1: (b7) r7 = 0\n  regs=40 stack=0 before 0: (b7) r6 = 1024\n  math between map_value pointer and register with unbounded min value is not allowed\n  verification time 886 usec\n  stack depth 4\n  processed 49 insns (limit 1000000) max_states_per_insn 1 total_states 5 peak_states 5 mark_read 2\n\nFixes: b5dc0163d8fd (\"bpf: precise scalar_value tracking\")\nReported-by: Juan Jose Lopez Jaimez <jjlopezjaimez@google.com>\nReported-by: Meador Inge <meadori@google.com>\nReported-by: Simon Scannell <simonscannell@google.com>\nReported-by: Nenad Stojanovski <thenenadx@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nCo-developed-by: Andrii Nakryiko <andrii@kernel.org>\nSigned-off-by: Andrii Nakryiko <andrii@kernel.org>\nReviewed-by: John Fastabend <john.fastabend@gmail.com>\nReviewed-by: Juan Jose Lopez Jaimez <jjlopezjaimez@google.com>\nReviewed-by: Meador Inge <meadori@google.com>\nReviewed-by: Simon Scannell <simonscannell@google.com>\n",
    "commit_hash": "71b547f561247897a0a14f3082730156c0533fed",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=71b547f561247897a0a14f3082730156c0533fed",
    "file_path": "kernel/bpf/verifier.c",
    "func_name": "backtrack_insn",
    "func_before": "static int backtrack_insn(struct bpf_verifier_env *env, int idx,\n\t\t\t  u32 *reg_mask, u64 *stack_mask)\n{\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_call\t= disasm_kfunc_name,\n\t\t.cb_print\t= verbose,\n\t\t.private_data\t= env,\n\t};\n\tstruct bpf_insn *insn = env->prog->insnsi + idx;\n\tu8 class = BPF_CLASS(insn->code);\n\tu8 opcode = BPF_OP(insn->code);\n\tu8 mode = BPF_MODE(insn->code);\n\tu32 dreg = 1u << insn->dst_reg;\n\tu32 sreg = 1u << insn->src_reg;\n\tu32 spi;\n\n\tif (insn->code == 0)\n\t\treturn 0;\n\tif (env->log.level & BPF_LOG_LEVEL2) {\n\t\tverbose(env, \"regs=%x stack=%llx before \", *reg_mask, *stack_mask);\n\t\tverbose(env, \"%d: \", idx);\n\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t}\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\tif (opcode == BPF_MOV) {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg = sreg\n\t\t\t\t * dreg needs precision after this insn\n\t\t\t\t * sreg needs precision before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} else {\n\t\t\t\t/* dreg = K\n\t\t\t\t * dreg needs precision after this insn.\n\t\t\t\t * Corresponding register is already marked\n\t\t\t\t * as precise=true in this verifier state.\n\t\t\t\t * No further markings in parent are necessary\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg += sreg\n\t\t\t\t * both dreg and sreg need precision\n\t\t\t\t * before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} /* else dreg += K\n\t\t\t   * dreg still needs precision before this insn\n\t\t\t   */\n\t\t}\n\t} else if (class == BPF_LDX) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\n\t\t/* scalars can only be spilled into stack w/o losing precision.\n\t\t * Load from any other memory can be zero extended.\n\t\t * The desire to keep that precision is already indicated\n\t\t * by 'precise' mark in corresponding register of this state.\n\t\t * No further tracking necessary.\n\t\t */\n\t\tif (insn->src_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\n\t\t/* dreg = *(u64 *)[fp - off] was a fill from the stack.\n\t\t * that [fp - off] slot contains scalar that needs to be\n\t\t * tracked with precision\n\t\t */\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t*stack_mask |= 1ull << spi;\n\t} else if (class == BPF_STX || class == BPF_ST) {\n\t\tif (*reg_mask & dreg)\n\t\t\t/* stx & st shouldn't be using _scalar_ dst_reg\n\t\t\t * to access memory. It means backtracking\n\t\t\t * encountered a case of pointer subtraction.\n\t\t\t */\n\t\t\treturn -ENOTSUPP;\n\t\t/* scalars can only be spilled into stack */\n\t\tif (insn->dst_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (!(*stack_mask & (1ull << spi)))\n\t\t\treturn 0;\n\t\t*stack_mask &= ~(1ull << spi);\n\t\tif (class == BPF_STX)\n\t\t\t*reg_mask |= sreg;\n\t} else if (class == BPF_JMP || class == BPF_JMP32) {\n\t\tif (opcode == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* BPF helpers that invoke callback subprogs are\n\t\t\t * equivalent to BPF_PSEUDO_CALL above\n\t\t\t */\n\t\t\tif (insn->src_reg == 0 && is_callback_calling_function(insn->imm))\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* kfunc with imm==0 is invalid and fixup_kfunc_call will\n\t\t\t * catch this error later. Make backtracking conservative\n\t\t\t * with ENOTSUPP.\n\t\t\t */\n\t\t\tif (insn->src_reg == BPF_PSEUDO_KFUNC_CALL && insn->imm == 0)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* regular helper call sets R0 */\n\t\t\t*reg_mask &= ~1;\n\t\t\tif (*reg_mask & 0x3f) {\n\t\t\t\t/* if backtracing was looking for registers R1-R5\n\t\t\t\t * they should have been found already.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"BUG regs %x\\n\", *reg_mask);\n\t\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else if (opcode == BPF_EXIT) {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t} else if (class == BPF_LD) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\t\t/* It's ld_imm64 or ld_abs or ld_ind.\n\t\t * For ld_imm64 no further tracking of precision\n\t\t * into parent is necessary\n\t\t */\n\t\tif (mode == BPF_IND || mode == BPF_ABS)\n\t\t\t/* to be analyzed */\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}",
    "abstract_func_before": "static int backtrack_insn(struct bpf_verifier_env *VAR_0, int VAR_1,\n\t\t\t  u32 *VAR_2, u64 *VAR_3)\n{\n\tconst struct bpf_insn_cbs VAR_4 = {\n\t\t.cb_call\t= VAR_5,\n\t\t.cb_print\t= VAR_6,\n\t\t.private_data\t= VAR_0,\n\t};\n\tstruct bpf_insn *VAR_7 = VAR_0->prog->insnsi + VAR_1;\n\tu8 VAR_8 = BPF_CLASS(VAR_7->code);\n\tu8 VAR_9 = BPF_OP(VAR_7->code);\n\tu8 VAR_10 = BPF_MODE(VAR_7->code);\n\tu32 VAR_11 = 1u << VAR_7->dst_reg;\n\tu32 VAR_12 = 1u << VAR_7->src_reg;\n\tu32 VAR_13;\n\n\tif (VAR_7->code == 0)\n\t\treturn 0;\n\tif (VAR_0->log.level & VAR_14) {\n\t\tVAR_6(VAR_0, \"regs=%x stack=%llx before \", *VAR_2, *VAR_3);\n\t\tVAR_6(VAR_0, \"%d: \", VAR_1);\n\t\tprint_bpf_insn(&VAR_4, VAR_7, VAR_0->allow_ptr_leaks);\n\t}\n\n\tif (VAR_8 == VAR_15 || VAR_8 == VAR_16) {\n\t\tif (!(*VAR_2 & VAR_11))\n\t\t\treturn 0;\n\t\tif (VAR_9 == VAR_17) {\n\t\t\tif (BPF_SRC(VAR_7->code) == VAR_18) {\n\t\t\t\t/* COMMENT_0 */\n                                           \n                                            \n       \n\t\t\t\t*VAR_2 &= ~VAR_11;\n\t\t\t\t*VAR_2 |= VAR_12;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_4 */\n                                            \n                                               \n                                              \n                                                  \n       \n\t\t\t\t*VAR_2 &= ~VAR_11;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BPF_SRC(VAR_7->code) == VAR_18) {\n\t\t\t\t/* COMMENT_10 */\n                                        \n                       \n       \n\t\t\t\t*VAR_2 |= VAR_12;\n\t\t\t} /* COMMENT_14 */\n                                                   \n        \n\t\t}\n\t} else if (VAR_8 == VAR_19) {\n\t\tif (!(*VAR_2 & VAR_11))\n\t\t\treturn 0;\n\t\t*VAR_2 &= ~VAR_11;\n\n\t\t/* COMMENT_17 */\n                                                     \n                                                           \n                                                               \n                                   \n     \n\t\tif (VAR_7->src_reg != VAR_20)\n\t\t\treturn 0;\n\n\t\t/* COMMENT_23 */\n                                                          \n                           \n     \n\t\tVAR_13 = (-VAR_7->off - 1) / VAR_21;\n\t\tif (VAR_13 >= 64) {\n\t\t\tVAR_6(VAR_0, \"BUG spi %d\\n\", VAR_13);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -VAR_22;\n\t\t}\n\t\t*VAR_3 |= 1ull << VAR_13;\n\t} else if (VAR_8 == VAR_23 || VAR_8 == VAR_24) {\n\t\tif (*VAR_2 & VAR_11)\n\t\t\t/* COMMENT_27 */\n                                             \n                                                \n      \n\t\t\treturn -VAR_25;\n\t\t/* COMMENT_31 */\n\t\tif (VAR_7->dst_reg != VAR_20)\n\t\t\treturn 0;\n\t\tVAR_13 = (-VAR_7->off - 1) / VAR_21;\n\t\tif (VAR_13 >= 64) {\n\t\t\tVAR_6(VAR_0, \"BUG spi %d\\n\", VAR_13);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -VAR_22;\n\t\t}\n\t\tif (!(*VAR_3 & (1ull << VAR_13)))\n\t\t\treturn 0;\n\t\t*VAR_3 &= ~(1ull << VAR_13);\n\t\tif (VAR_8 == VAR_23)\n\t\t\t*VAR_2 |= VAR_12;\n\t} else if (VAR_8 == VAR_26 || VAR_8 == VAR_27) {\n\t\tif (VAR_9 == VAR_28) {\n\t\t\tif (VAR_7->src_reg == VAR_29)\n\t\t\t\treturn -VAR_25;\n\t\t\t/* COMMENT_32 */\n                                         \n      \n\t\t\tif (VAR_7->src_reg == 0 && is_callback_calling_function(VAR_7->imm))\n\t\t\t\treturn -VAR_25;\n\t\t\t/* COMMENT_35 */\n                                                            \n                    \n      \n\t\t\tif (VAR_7->src_reg == VAR_30 && VAR_7->imm == 0)\n\t\t\t\treturn -VAR_25;\n\t\t\t/* COMMENT_39 */\n\t\t\t*VAR_2 &= ~1;\n\t\t\tif (*VAR_2 & 0x3f) {\n\t\t\t\t/* COMMENT_40 */\n                                           \n       \n\t\t\t\tVAR_6(VAR_0, \"BUG regs %x\\n\", *VAR_2);\n\t\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\t\treturn -VAR_22;\n\t\t\t}\n\t\t} else if (VAR_9 == VAR_31) {\n\t\t\treturn -VAR_25;\n\t\t}\n\t} else if (VAR_8 == VAR_32) {\n\t\tif (!(*VAR_2 & VAR_11))\n\t\t\treturn 0;\n\t\t*VAR_2 &= ~VAR_11;\n\t\t/* COMMENT_43 */\n                                                  \n                             \n     \n\t\tif (VAR_10 == VAR_33 || VAR_10 == VAR_34)\n\t\t\t/* COMMENT_47 */\n\t\t\treturn -VAR_25;\n\t}\n\treturn 0;\n}",
    "func_graph_path_before": "torvalds/linux/71b547f561247897a0a14f3082730156c0533fed/verifier.c/vul/before/0.json",
    "func": "static int backtrack_insn(struct bpf_verifier_env *env, int idx,\n\t\t\t  u32 *reg_mask, u64 *stack_mask)\n{\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_call\t= disasm_kfunc_name,\n\t\t.cb_print\t= verbose,\n\t\t.private_data\t= env,\n\t};\n\tstruct bpf_insn *insn = env->prog->insnsi + idx;\n\tu8 class = BPF_CLASS(insn->code);\n\tu8 opcode = BPF_OP(insn->code);\n\tu8 mode = BPF_MODE(insn->code);\n\tu32 dreg = 1u << insn->dst_reg;\n\tu32 sreg = 1u << insn->src_reg;\n\tu32 spi;\n\n\tif (insn->code == 0)\n\t\treturn 0;\n\tif (env->log.level & BPF_LOG_LEVEL2) {\n\t\tverbose(env, \"regs=%x stack=%llx before \", *reg_mask, *stack_mask);\n\t\tverbose(env, \"%d: \", idx);\n\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t}\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\tif (opcode == BPF_MOV) {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg = sreg\n\t\t\t\t * dreg needs precision after this insn\n\t\t\t\t * sreg needs precision before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} else {\n\t\t\t\t/* dreg = K\n\t\t\t\t * dreg needs precision after this insn.\n\t\t\t\t * Corresponding register is already marked\n\t\t\t\t * as precise=true in this verifier state.\n\t\t\t\t * No further markings in parent are necessary\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg += sreg\n\t\t\t\t * both dreg and sreg need precision\n\t\t\t\t * before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} /* else dreg += K\n\t\t\t   * dreg still needs precision before this insn\n\t\t\t   */\n\t\t}\n\t} else if (class == BPF_LDX) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\n\t\t/* scalars can only be spilled into stack w/o losing precision.\n\t\t * Load from any other memory can be zero extended.\n\t\t * The desire to keep that precision is already indicated\n\t\t * by 'precise' mark in corresponding register of this state.\n\t\t * No further tracking necessary.\n\t\t */\n\t\tif (insn->src_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\n\t\t/* dreg = *(u64 *)[fp - off] was a fill from the stack.\n\t\t * that [fp - off] slot contains scalar that needs to be\n\t\t * tracked with precision\n\t\t */\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t*stack_mask |= 1ull << spi;\n\t} else if (class == BPF_STX || class == BPF_ST) {\n\t\tif (*reg_mask & dreg)\n\t\t\t/* stx & st shouldn't be using _scalar_ dst_reg\n\t\t\t * to access memory. It means backtracking\n\t\t\t * encountered a case of pointer subtraction.\n\t\t\t */\n\t\t\treturn -ENOTSUPP;\n\t\t/* scalars can only be spilled into stack */\n\t\tif (insn->dst_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (!(*stack_mask & (1ull << spi)))\n\t\t\treturn 0;\n\t\t*stack_mask &= ~(1ull << spi);\n\t\tif (class == BPF_STX)\n\t\t\t*reg_mask |= sreg;\n\t} else if (class == BPF_JMP || class == BPF_JMP32) {\n\t\tif (opcode == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* BPF helpers that invoke callback subprogs are\n\t\t\t * equivalent to BPF_PSEUDO_CALL above\n\t\t\t */\n\t\t\tif (insn->src_reg == 0 && is_callback_calling_function(insn->imm))\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* kfunc with imm==0 is invalid and fixup_kfunc_call will\n\t\t\t * catch this error later. Make backtracking conservative\n\t\t\t * with ENOTSUPP.\n\t\t\t */\n\t\t\tif (insn->src_reg == BPF_PSEUDO_KFUNC_CALL && insn->imm == 0)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* regular helper call sets R0 */\n\t\t\t*reg_mask &= ~1;\n\t\t\tif (*reg_mask & 0x3f) {\n\t\t\t\t/* if backtracing was looking for registers R1-R5\n\t\t\t\t * they should have been found already.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"BUG regs %x\\n\", *reg_mask);\n\t\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else if (opcode == BPF_EXIT) {\n\t\t\treturn -ENOTSUPP;\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (!(*reg_mask & (dreg | sreg)))\n\t\t\t\treturn 0;\n\t\t\t/* dreg <cond> sreg\n\t\t\t * Both dreg and sreg need precision before\n\t\t\t * this insn. If only sreg was marked precise\n\t\t\t * before it would be equally necessary to\n\t\t\t * propagate it to dreg.\n\t\t\t */\n\t\t\t*reg_mask |= (sreg | dreg);\n\t\t\t /* else dreg <cond> K\n\t\t\t  * Only dreg still needs precision before\n\t\t\t  * this insn, so for the K-based conditional\n\t\t\t  * there is nothing new to be marked.\n\t\t\t  */\n\t\t}\n\t} else if (class == BPF_LD) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\t\t/* It's ld_imm64 or ld_abs or ld_ind.\n\t\t * For ld_imm64 no further tracking of precision\n\t\t * into parent is necessary\n\t\t */\n\t\tif (mode == BPF_IND || mode == BPF_ABS)\n\t\t\t/* to be analyzed */\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}",
    "abstract_func": "static int backtrack_insn(struct bpf_verifier_env *VAR_0, int VAR_1,\n\t\t\t  u32 *VAR_2, u64 *VAR_3)\n{\n\tconst struct bpf_insn_cbs VAR_4 = {\n\t\t.cb_call\t= VAR_5,\n\t\t.cb_print\t= VAR_6,\n\t\t.private_data\t= VAR_0,\n\t};\n\tstruct bpf_insn *VAR_7 = VAR_0->prog->insnsi + VAR_1;\n\tu8 VAR_8 = BPF_CLASS(VAR_7->code);\n\tu8 VAR_9 = BPF_OP(VAR_7->code);\n\tu8 VAR_10 = BPF_MODE(VAR_7->code);\n\tu32 VAR_11 = 1u << VAR_7->dst_reg;\n\tu32 VAR_12 = 1u << VAR_7->src_reg;\n\tu32 VAR_13;\n\n\tif (VAR_7->code == 0)\n\t\treturn 0;\n\tif (VAR_0->log.level & VAR_14) {\n\t\tVAR_6(VAR_0, \"regs=%x stack=%llx before \", *VAR_2, *VAR_3);\n\t\tVAR_6(VAR_0, \"%d: \", VAR_1);\n\t\tprint_bpf_insn(&VAR_4, VAR_7, VAR_0->allow_ptr_leaks);\n\t}\n\n\tif (VAR_8 == VAR_15 || VAR_8 == VAR_16) {\n\t\tif (!(*VAR_2 & VAR_11))\n\t\t\treturn 0;\n\t\tif (VAR_9 == VAR_17) {\n\t\t\tif (BPF_SRC(VAR_7->code) == VAR_18) {\n\t\t\t\t/* COMMENT_0 */\n                                           \n                                            \n       \n\t\t\t\t*VAR_2 &= ~VAR_11;\n\t\t\t\t*VAR_2 |= VAR_12;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_4 */\n                                            \n                                               \n                                              \n                                                  \n       \n\t\t\t\t*VAR_2 &= ~VAR_11;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BPF_SRC(VAR_7->code) == VAR_18) {\n\t\t\t\t/* COMMENT_10 */\n                                        \n                       \n       \n\t\t\t\t*VAR_2 |= VAR_12;\n\t\t\t} /* COMMENT_14 */\n                                                   \n        \n\t\t}\n\t} else if (VAR_8 == VAR_19) {\n\t\tif (!(*VAR_2 & VAR_11))\n\t\t\treturn 0;\n\t\t*VAR_2 &= ~VAR_11;\n\n\t\t/* COMMENT_17 */\n                                                     \n                                                           \n                                                               \n                                   \n     \n\t\tif (VAR_7->src_reg != VAR_20)\n\t\t\treturn 0;\n\n\t\t/* COMMENT_23 */\n                                                          \n                           \n     \n\t\tVAR_13 = (-VAR_7->off - 1) / VAR_21;\n\t\tif (VAR_13 >= 64) {\n\t\t\tVAR_6(VAR_0, \"BUG spi %d\\n\", VAR_13);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -VAR_22;\n\t\t}\n\t\t*VAR_3 |= 1ull << VAR_13;\n\t} else if (VAR_8 == VAR_23 || VAR_8 == VAR_24) {\n\t\tif (*VAR_2 & VAR_11)\n\t\t\t/* COMMENT_27 */\n                                             \n                                                \n      \n\t\t\treturn -VAR_25;\n\t\t/* COMMENT_31 */\n\t\tif (VAR_7->dst_reg != VAR_20)\n\t\t\treturn 0;\n\t\tVAR_13 = (-VAR_7->off - 1) / VAR_21;\n\t\tif (VAR_13 >= 64) {\n\t\t\tVAR_6(VAR_0, \"BUG spi %d\\n\", VAR_13);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -VAR_22;\n\t\t}\n\t\tif (!(*VAR_3 & (1ull << VAR_13)))\n\t\t\treturn 0;\n\t\t*VAR_3 &= ~(1ull << VAR_13);\n\t\tif (VAR_8 == VAR_23)\n\t\t\t*VAR_2 |= VAR_12;\n\t} else if (VAR_8 == VAR_26 || VAR_8 == VAR_27) {\n\t\tif (VAR_9 == VAR_28) {\n\t\t\tif (VAR_7->src_reg == VAR_29)\n\t\t\t\treturn -VAR_25;\n\t\t\t/* COMMENT_32 */\n                                         \n      \n\t\t\tif (VAR_7->src_reg == 0 && is_callback_calling_function(VAR_7->imm))\n\t\t\t\treturn -VAR_25;\n\t\t\t/* COMMENT_35 */\n                                                            \n                    \n      \n\t\t\tif (VAR_7->src_reg == VAR_30 && VAR_7->imm == 0)\n\t\t\t\treturn -VAR_25;\n\t\t\t/* COMMENT_39 */\n\t\t\t*VAR_2 &= ~1;\n\t\t\tif (*VAR_2 & 0x3f) {\n\t\t\t\t/* COMMENT_40 */\n                                           \n       \n\t\t\t\tVAR_6(VAR_0, \"BUG regs %x\\n\", *VAR_2);\n\t\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\t\treturn -VAR_22;\n\t\t\t}\n\t\t} else if (VAR_9 == VAR_31) {\n\t\t\treturn -VAR_25;\n\t\t} else if (BPF_SRC(VAR_7->code) == VAR_18) {\n\t\t\tif (!(*VAR_2 & (VAR_11 | VAR_12)))\n\t\t\t\treturn 0;\n\t\t\t/* COMMENT_43 */\n                                              \n                                                \n                                             \n                           \n      \n\t\t\t*VAR_2 |= (VAR_12 | VAR_11);\n\t\t\t /* COMMENT_49 */\n                                             \n                                                \n                                         \n       \n\t\t}\n\t} else if (VAR_8 == VAR_32) {\n\t\tif (!(*VAR_2 & VAR_11))\n\t\t\treturn 0;\n\t\t*VAR_2 &= ~VAR_11;\n\t\t/* COMMENT_54 */\n                                                  \n                             \n     \n\t\tif (VAR_10 == VAR_33 || VAR_10 == VAR_34)\n\t\t\t/* COMMENT_58 */\n\t\t\treturn -VAR_25;\n\t}\n\treturn 0;\n}",
    "func_graph_path": "torvalds/linux/71b547f561247897a0a14f3082730156c0533fed/verifier.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -126,6 +126,21 @@\n \t\t\t}\n \t\t} else if (opcode == BPF_EXIT) {\n \t\t\treturn -ENOTSUPP;\n+\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n+\t\t\tif (!(*reg_mask & (dreg | sreg)))\n+\t\t\t\treturn 0;\n+\t\t\t/* dreg <cond> sreg\n+\t\t\t * Both dreg and sreg need precision before\n+\t\t\t * this insn. If only sreg was marked precise\n+\t\t\t * before it would be equally necessary to\n+\t\t\t * propagate it to dreg.\n+\t\t\t */\n+\t\t\t*reg_mask |= (sreg | dreg);\n+\t\t\t /* else dreg <cond> K\n+\t\t\t  * Only dreg still needs precision before\n+\t\t\t  * this insn, so for the K-based conditional\n+\t\t\t  * there is nothing new to be marked.\n+\t\t\t  */\n \t\t}\n \t} else if (class == BPF_LD) {\n \t\tif (!(*reg_mask & dreg))",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\t} else if (BPF_SRC(insn->code) == BPF_X) {",
            "\t\t\tif (!(*reg_mask & (dreg | sreg)))",
            "\t\t\t\treturn 0;",
            "\t\t\t/* dreg <cond> sreg",
            "\t\t\t * Both dreg and sreg need precision before",
            "\t\t\t * this insn. If only sreg was marked precise",
            "\t\t\t * before it would be equally necessary to",
            "\t\t\t * propagate it to dreg.",
            "\t\t\t */",
            "\t\t\t*reg_mask |= (sreg | dreg);",
            "\t\t\t /* else dreg <cond> K",
            "\t\t\t  * Only dreg still needs precision before",
            "\t\t\t  * this insn, so for the K-based conditional",
            "\t\t\t  * there is nothing new to be marked.",
            "\t\t\t  */"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}