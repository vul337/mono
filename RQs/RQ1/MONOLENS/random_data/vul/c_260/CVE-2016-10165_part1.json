{
    "cve_id": "CVE-2016-10165",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "mm2/Little-CMS",
    "commit_msg": "Added an extra check to MLU bounds\n\nThanks to Ibrahim el-sayed for spotting the bug",
    "commit_hash": "5ca71a7bc18b6897ab21d815d15e218e204581e2",
    "git_url": "https://github.com/mm2/Little-CMS/commit/5ca71a7bc18b6897ab21d815d15e218e204581e2",
    "file_path": "src/cmstypes.c",
    "func_name": "Type_MLU_Read",
    "func_before": "static\nvoid *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu;\n    cmsUInt32Number Count, RecLen, NumOfWchar;\n    cmsUInt32Number SizeOfHeader;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number  i;\n    wchar_t*         Block;\n    cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;\n\n    if (RecLen != 12) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"multiLocalizedUnicodeType of len != 12 is not supported.\");\n        return NULL;\n    }\n\n    mlu = cmsMLUalloc(self ->ContextID, Count);\n    if (mlu == NULL) return NULL;\n\n    mlu ->UsedEntries = Count;\n\n    SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);\n    LargestPosition = 0;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;\n\n        // Now deal with Len and offset.\n        if (!_cmsReadUInt32Number(io, &Len)) goto Error;\n        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;\n\n        // Check for overflow\n        if (Offset < (SizeOfHeader + 8)) goto Error;\n\n        // True begin of the string\n        BeginOfThisString = Offset - SizeOfHeader - 8;\n\n        // Ajust to wchar_t elements\n        mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n        mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n\n        // To guess maximum size, add offset + len\n        EndOfThisString = BeginOfThisString + Len;\n        if (EndOfThisString > LargestPosition)\n            LargestPosition = EndOfThisString;\n    }\n\n    // Now read the remaining of tag and fill all strings. Subtract the directory\n    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n    if (SizeOfTag == 0)\n    {\n        Block = NULL;\n        NumOfWchar = 0;\n\n    }\n    else\n    {\n        Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);\n        if (Block == NULL) goto Error;\n        NumOfWchar = SizeOfTag / sizeof(wchar_t);\n        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;\n    }\n\n    mlu ->MemPool  = Block;\n    mlu ->PoolSize = SizeOfTag;\n    mlu ->PoolUsed = SizeOfTag;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}",
    "abstract_func_before": "static\nvoid *Type_MLU_Read(struct _cms_typehandler_struct* VAR_0, cmsIOHANDLER* VAR_1, cmsUInt32Number* VAR_2, cmsUInt32Number VAR_3)\n{\n    cmsMLU* VAR_4;\n    cmsUInt32Number VAR_5, VAR_6, VAR_7;\n    cmsUInt32Number VAR_8;\n    cmsUInt32Number  VAR_9, VAR_10;\n    cmsUInt32Number  VAR_11;\n    wchar_t*         VAR_12;\n    cmsUInt32Number  VAR_13, VAR_14, VAR_15;\n\n    *VAR_2 = 0;\n    if (!_cmsReadUInt32Number(VAR_1, &VAR_5)) return NULL;\n    if (!_cmsReadUInt32Number(VAR_1, &VAR_6)) return NULL;\n\n    if (VAR_6 != 12) {\n\n        cmsSignalError(VAR_0->ContextID, VAR_16, \"multiLocalizedUnicodeType of len != 12 is not supported.\");\n        return NULL;\n    }\n\n    VAR_4 = cmsMLUalloc(VAR_0 ->ContextID, VAR_5);\n    if (VAR_4 == NULL) return NULL;\n\n    VAR_4 ->UsedEntries = VAR_5;\n\n    VAR_8 = 12 * VAR_5 + sizeof(VAR_17);\n    VAR_15 = 0;\n\n    for (VAR_11=0; VAR_11 < VAR_5; VAR_11++) {\n\n        if (!_cmsReadUInt16Number(VAR_1, &VAR_4 ->Entries[VAR_11].Language)) goto Error;\n        if (!_cmsReadUInt16Number(VAR_1, &VAR_4 ->Entries[VAR_11].Country))  goto Error;\n\n        /* COMMENT_0 */\n        if (!_cmsReadUInt32Number(VAR_1, &VAR_9)) goto Error;\n        if (!_cmsReadUInt32Number(VAR_1, &VAR_10)) goto Error;\n\n        /* COMMENT_1 */\n        if (VAR_10 < (VAR_8 + 8)) goto Error;\n\n        /* COMMENT_2 */\n        VAR_13 = VAR_10 - VAR_8 - 8;\n\n        /* COMMENT_3 */\n        VAR_4 ->Entries[VAR_11].Len = (VAR_9 * sizeof(wchar_t)) / sizeof(VAR_18);\n        VAR_4 ->Entries[VAR_11].StrW = (VAR_13 * sizeof(wchar_t)) / sizeof(VAR_18);\n\n        /* COMMENT_4 */\n        VAR_14 = VAR_13 + VAR_9;\n        if (VAR_14 > VAR_15)\n            VAR_15 = VAR_14;\n    }\n\n    /* COMMENT_5 */\n    VAR_3   = (VAR_15 * sizeof(wchar_t)) / sizeof(VAR_18);\n    if (VAR_3 == 0)\n    {\n        VAR_12 = NULL;\n        VAR_7 = 0;\n\n    }\n    else\n    {\n        VAR_12 = (wchar_t*) _cmsMalloc(VAR_0 ->ContextID, VAR_3);\n        if (VAR_12 == NULL) goto Error;\n        VAR_7 = VAR_3 / sizeof(wchar_t);\n        if (!_cmsReadWCharArray(VAR_1, VAR_7, VAR_12)) goto Error;\n    }\n\n    VAR_4 ->MemPool  = VAR_12;\n    VAR_4 ->PoolSize = VAR_3;\n    VAR_4 ->PoolUsed = VAR_3;\n\n    *VAR_2 = 1;\n    return (void*) VAR_4;\n\nError:\n    if (VAR_4) cmsMLUfree(VAR_4);\n    return NULL;\n}",
    "func_graph_path_before": "mm2/Little-CMS/5ca71a7bc18b6897ab21d815d15e218e204581e2/cmstypes.c/vul/before/0.json",
    "func": "static\nvoid *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu;\n    cmsUInt32Number Count, RecLen, NumOfWchar;\n    cmsUInt32Number SizeOfHeader;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number  i;\n    wchar_t*         Block;\n    cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;\n\n    if (RecLen != 12) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"multiLocalizedUnicodeType of len != 12 is not supported.\");\n        return NULL;\n    }\n\n    mlu = cmsMLUalloc(self ->ContextID, Count);\n    if (mlu == NULL) return NULL;\n\n    mlu ->UsedEntries = Count;\n\n    SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);\n    LargestPosition = 0;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;\n\n        // Now deal with Len and offset.\n        if (!_cmsReadUInt32Number(io, &Len)) goto Error;\n        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;\n\n        // Check for overflow\n        if (Offset < (SizeOfHeader + 8)) goto Error;\n        if ((Offset + Len) > SizeOfTag + 8) goto Error;\n\n        // True begin of the string\n        BeginOfThisString = Offset - SizeOfHeader - 8;\n\n        // Ajust to wchar_t elements\n        mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n        mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n\n        // To guess maximum size, add offset + len\n        EndOfThisString = BeginOfThisString + Len;\n        if (EndOfThisString > LargestPosition)\n            LargestPosition = EndOfThisString;\n    }\n\n    // Now read the remaining of tag and fill all strings. Subtract the directory\n    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n    if (SizeOfTag == 0)\n    {\n        Block = NULL;\n        NumOfWchar = 0;\n\n    }\n    else\n    {\n        Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);\n        if (Block == NULL) goto Error;\n        NumOfWchar = SizeOfTag / sizeof(wchar_t);\n        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;\n    }\n\n    mlu ->MemPool  = Block;\n    mlu ->PoolSize = SizeOfTag;\n    mlu ->PoolUsed = SizeOfTag;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}",
    "abstract_func": "static\nvoid *Type_MLU_Read(struct _cms_typehandler_struct* VAR_0, cmsIOHANDLER* VAR_1, cmsUInt32Number* VAR_2, cmsUInt32Number VAR_3)\n{\n    cmsMLU* VAR_4;\n    cmsUInt32Number VAR_5, VAR_6, VAR_7;\n    cmsUInt32Number VAR_8;\n    cmsUInt32Number  VAR_9, VAR_10;\n    cmsUInt32Number  VAR_11;\n    wchar_t*         VAR_12;\n    cmsUInt32Number  VAR_13, VAR_14, VAR_15;\n\n    *VAR_2 = 0;\n    if (!_cmsReadUInt32Number(VAR_1, &VAR_5)) return NULL;\n    if (!_cmsReadUInt32Number(VAR_1, &VAR_6)) return NULL;\n\n    if (VAR_6 != 12) {\n\n        cmsSignalError(VAR_0->ContextID, VAR_16, \"multiLocalizedUnicodeType of len != 12 is not supported.\");\n        return NULL;\n    }\n\n    VAR_4 = cmsMLUalloc(VAR_0 ->ContextID, VAR_5);\n    if (VAR_4 == NULL) return NULL;\n\n    VAR_4 ->UsedEntries = VAR_5;\n\n    VAR_8 = 12 * VAR_5 + sizeof(VAR_17);\n    VAR_15 = 0;\n\n    for (VAR_11=0; VAR_11 < VAR_5; VAR_11++) {\n\n        if (!_cmsReadUInt16Number(VAR_1, &VAR_4 ->Entries[VAR_11].Language)) goto Error;\n        if (!_cmsReadUInt16Number(VAR_1, &VAR_4 ->Entries[VAR_11].Country))  goto Error;\n\n        /* COMMENT_0 */\n        if (!_cmsReadUInt32Number(VAR_1, &VAR_9)) goto Error;\n        if (!_cmsReadUInt32Number(VAR_1, &VAR_10)) goto Error;\n\n        /* COMMENT_1 */\n        if (VAR_10 < (VAR_8 + 8)) goto Error;\n        if ((VAR_10 + VAR_9) > VAR_3 + 8) goto Error;\n\n        /* COMMENT_2 */\n        VAR_13 = VAR_10 - VAR_8 - 8;\n\n        /* COMMENT_3 */\n        VAR_4 ->Entries[VAR_11].Len = (VAR_9 * sizeof(wchar_t)) / sizeof(VAR_18);\n        VAR_4 ->Entries[VAR_11].StrW = (VAR_13 * sizeof(wchar_t)) / sizeof(VAR_18);\n\n        /* COMMENT_4 */\n        VAR_14 = VAR_13 + VAR_9;\n        if (VAR_14 > VAR_15)\n            VAR_15 = VAR_14;\n    }\n\n    /* COMMENT_5 */\n    VAR_3   = (VAR_15 * sizeof(wchar_t)) / sizeof(VAR_18);\n    if (VAR_3 == 0)\n    {\n        VAR_12 = NULL;\n        VAR_7 = 0;\n\n    }\n    else\n    {\n        VAR_12 = (wchar_t*) _cmsMalloc(VAR_0 ->ContextID, VAR_3);\n        if (VAR_12 == NULL) goto Error;\n        VAR_7 = VAR_3 / sizeof(wchar_t);\n        if (!_cmsReadWCharArray(VAR_1, VAR_7, VAR_12)) goto Error;\n    }\n\n    VAR_4 ->MemPool  = VAR_12;\n    VAR_4 ->PoolSize = VAR_3;\n    VAR_4 ->PoolUsed = VAR_3;\n\n    *VAR_2 = 1;\n    return (void*) VAR_4;\n\nError:\n    if (VAR_4) cmsMLUfree(VAR_4);\n    return NULL;\n}",
    "func_graph_path": "mm2/Little-CMS/5ca71a7bc18b6897ab21d815d15e218e204581e2/cmstypes.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,7 @@\n \n         // Check for overflow\n         if (Offset < (SizeOfHeader + 8)) goto Error;\n+        if ((Offset + Len) > SizeOfTag + 8) goto Error;\n \n         // True begin of the string\n         BeginOfThisString = Offset - SizeOfHeader - 8;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "        if ((Offset + Len) > SizeOfTag + 8) goto Error;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}