{
    "cve_id": "CVE-2017-12670",
    "cwe_ids": [
        "CWE-20",
        "CWE-617"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "ImageMagick",
    "commit_msg": "https://github.com/ImageMagick/ImageMagick/issues/610",
    "commit_hash": "ab440f9ea11e0dbefb7a808cbb9441198758b0cb",
    "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ab440f9ea11e0dbefb7a808cbb9441198758b0cb",
    "file_path": "coders/mat.c",
    "func_name": "ReadMATImage",
    "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
    "abstract_func_before": "static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)\n{\n  Image *VAR_2, *VAR_3=NULL,\n   *VAR_4;\n  PixelPacket *VAR_5;\n\n  unsigned int VAR_6;\n  MATHeader VAR_7;\n  size_t VAR_8;\n  size_t VAR_9;\n  QuantumInfo *VAR_10;\n  ImageInfo *VAR_11;\n  int VAR_12;\n  ssize_t VAR_13;\n  unsigned char *VAR_14 = NULL;\n  double VAR_15, VAR_16;\n  size_t VAR_17;\n  unsigned VAR_18, VAR_19;\n  unsigned VAR_20;\n  int VAR_21;\n  int VAR_22;\n  MagickOffsetType VAR_23=0x80;\n  BlobInfo *VAR_24;\n  size_t VAR_25;\n\n  unsigned int (*VAR_26)(Image *VAR_2);\n  unsigned short (*VAR_27)(Image *VAR_2);\n  void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);\n  void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);\n\n\n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_32);\n  assert(VAR_1 != (ExceptionInfo *) NULL);\n  assert(VAR_1->signature == VAR_32);\n  VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),\"enter\");\n\n  /* COMMENT_0 */\n                     \n     \n  VAR_10=(QuantumInfo *) NULL;\n  VAR_2 = AcquireImage(VAR_0);\n\n  VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);\n  if (VAR_6 == VAR_35)\n    {\n      VAR_2=DestroyImageList(VAR_2);\n      return((Image *) NULL);\n    }\n  /* COMMENT_3 */\n                       \n     \n  VAR_11=(ImageInfo *) NULL;\n  if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)\n    ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n  if (strncmp(VAR_7.identific,\"MATLAB\",6) != 0)\n    {\n      VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);\n      if (VAR_3  == NULL)\n        goto MATLAB_KO;\n      VAR_2=VAR_3;\n      goto END_OF_READING;\n    }\n  VAR_7.Version = ReadBlobLSBShort(VAR_2);\n  if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)\n    ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n\n  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\"  Endian %c%c\",\n        VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);\n  if (!strncmp(VAR_7.EndianIndicator, \"IM\", 2))\n  {\n    VAR_26 = VAR_37;\n    VAR_27 = VAR_38;\n    VAR_28 = VAR_39;\n    VAR_31 = VAR_40;\n    VAR_2->endian = VAR_41;\n  }\n  else if (!strncmp(VAR_7.EndianIndicator, \"MI\", 2))\n  {\n    VAR_26 = VAR_42;\n    VAR_27 = VAR_43;\n    VAR_28 = VAR_44;\n    VAR_31 = VAR_45;\n    VAR_2->endian = VAR_46;\n  }\n  else\n    goto MATLAB_KO;    /* COMMENT_6 */\n\n  if (strncmp(VAR_7.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if (VAR_11 != (ImageInfo *) NULL)\n        VAR_11=DestroyImageInfo(VAR_11);\n      ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n    }\n\n  VAR_23 = TellBlob(VAR_2);\n  while(!EOFBlob(VAR_2)) /* COMMENT_7 */\n  {\n    VAR_20 = 1;\n    (void) SeekBlob(VAR_2,VAR_23,VAR_47);\n    /* COMMENT_8 */\n\n    VAR_7.DataType = VAR_26(VAR_2);\n    if(EOFBlob(VAR_2)) break;\n    VAR_7.ObjectSize = VAR_26(VAR_2);\n    if(EOFBlob(VAR_2)) break;\n    if((VAR_48) (VAR_7.ObjectSize+VAR_23) > GetBlobSize(VAR_2))\n      goto MATLAB_KO;\n    VAR_23 += VAR_7.ObjectSize + 4 + 4;\n\n    VAR_11=CloneImageInfo(VAR_0);\n    VAR_3 = VAR_2;\n#if defined(VAR_49)\n    if(VAR_7.DataType == VAR_50)\n    {\n      VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);\n      if(VAR_3==NULL) continue;\n      VAR_7.DataType = VAR_26(VAR_3); /* COMMENT_9 */\n    }\n#endif\n\n    if(VAR_7.DataType!=VAR_51) continue;  /* COMMENT_10 */\n\n    VAR_7.unknown1 = VAR_26(VAR_3);\n    VAR_7.unknown2 = VAR_26(VAR_3);\n\n    VAR_7.unknown5 = VAR_26(VAR_3);\n    VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;\n    VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;\n\n    VAR_7.unknown3 = VAR_26(VAR_3);\n    if(VAR_2!=VAR_3)\n      VAR_7.unknown4 = VAR_26(VAR_3);  /* COMMENT_11 */\n    VAR_7.unknown4 = VAR_26(VAR_3);\n    VAR_7.DimFlag = VAR_26(VAR_3);\n    VAR_7.SizeX = VAR_26(VAR_3);\n    VAR_7.SizeY = VAR_26(VAR_3);\n\n\n    switch(VAR_7.DimFlag)\n    {\n      case  8: VAR_19=VAR_18=1; break;      /* COMMENT_12 */\n      case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_13 */\n           VAR_17 = VAR_26(VAR_3);\n           (void) VAR_17;\n         if(VAR_18!=3) ThrowReaderException(VAR_52, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_14 */\n         if(VAR_18!=3 && VAR_18!=1)\n           ThrowReaderException(VAR_52, \"MultidimensionalMatricesAreNotSupported\");\n         VAR_20 = VAR_26(VAR_3);\n         if (VAR_20 == 0)\n           ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(VAR_52, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    VAR_7.Flag1 = VAR_27(VAR_3);\n    VAR_7.NameFlag = VAR_27(VAR_3);\n\n    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",VAR_7.StructureClass);\n    if (VAR_7.StructureClass != VAR_53 &&\n        VAR_7.StructureClass != VAR_54 &&    /* COMMENT_15 */\n        VAR_7.StructureClass != VAR_55 &&    /* COMMENT_16 */\n        VAR_7.StructureClass != VAR_56 &&\n        VAR_7.StructureClass != VAR_57 &&    /* COMMENT_17 */\n        VAR_7.StructureClass != VAR_58 &&\n        VAR_7.StructureClass != VAR_59 &&    /* COMMENT_18 */\n        VAR_7.StructureClass != VAR_60 &&\n        VAR_7.StructureClass != VAR_61 &&    /* COMMENT_19 */\n        VAR_7.StructureClass != VAR_62 &&\n        VAR_7.StructureClass != VAR_63)    /* COMMENT_20 */\n      ThrowReaderException(VAR_52,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (VAR_7.NameFlag)\n    {\n      case 0:\n        VAR_8 = VAR_26(VAR_3);  /* COMMENT_21 */\n        VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);\n        (void) SeekBlob(VAR_3, VAR_8, VAR_64);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); /* COMMENT_22 */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */\n    if (VAR_21)\n      (void) LogMagickEvent(VAR_33,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) VAR_9);\n\n    (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     /* COMMENT_24 */\n\nNEXT_FRAME:\n    switch (VAR_9)\n    {\n      case VAR_65:\n      case VAR_66:\n        VAR_22 = 8;\n        if(VAR_7.StructureFlag & VAR_67)\n          VAR_2->depth = 1;\n        else\n          VAR_2->depth = 8;         /* COMMENT_25 */\n        VAR_13 = (ssize_t) VAR_7.SizeX;\n        break;\n      case VAR_68:\n      case VAR_69:\n        VAR_22 = 16;\n        VAR_2->depth = 16;        /* COMMENT_26 */\n        VAR_13 = (ssize_t) (2 * VAR_7.SizeX);\n        break;\n      case VAR_70:\n      case VAR_71:\n        VAR_22 = 32;\n        VAR_2->depth = 32;        /* COMMENT_27 */\n        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);\n        break;\n      case VAR_72:\n      case VAR_73:\n        VAR_22 = 64;\n        VAR_2->depth = 64;        /* COMMENT_28 */\n        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);\n        break;\n      case VAR_74:\n        VAR_22 = 32;\n        VAR_2->depth = 32;        /* COMMENT_29 */\n        (void) SetImageOption(VAR_11,\"quantum:format\",\"floating-point\");\n        if (VAR_7.StructureFlag & VAR_75)\n  {              /* COMMENT_30 */\n  }\n        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);\n        break;\n      case VAR_76:\n        VAR_22 = 64;\n        VAR_2->depth = 64;        /* COMMENT_29 */\n        (void) SetImageOption(VAR_11,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nVAR_77\n          ThrowReaderException(VAR_52, \"IncompatibleSizeOfDouble\");\n        if (VAR_7.StructureFlag & VAR_75)\n  {                         /* COMMENT_31 */\n  }\n        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);\n        break;\n      default:\n        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))\n          VAR_3=DestroyImage(VAR_3);\n        if (VAR_11)\n          VAR_11=DestroyImageInfo(VAR_11);\n        ThrowReaderException(VAR_52, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) VAR_22;\n    VAR_2->columns = VAR_7.SizeX;\n    VAR_2->rows = VAR_7.SizeY;\n    VAR_25=1;\n    VAR_2->colors = VAR_25 << VAR_2->depth;\n    if (VAR_2->columns == 0 || VAR_2->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)\n      goto MATLAB_KO;\n      /* COMMENT_32 */\n    if ((VAR_7.DimFlag == 8) &&\n        ((VAR_7.StructureFlag & VAR_75) == 0))\n      {\n        SetImageColorspace(VAR_2,VAR_78);\n        VAR_2->type=VAR_79;\n      }\n\n\n    /* COMMENT_33 */\n                                                                  \n                             \n      \n    if (VAR_0->ping)\n    {\n      size_t VAR_80 = VAR_2->columns;\n      VAR_2->columns = VAR_2->rows;\n      VAR_2->rows = VAR_80;\n      goto done_reading; /* COMMENT_37 */\n    }\n    VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);\n    if (VAR_6 == VAR_35)\n      {\n        InheritException(VAR_1,&VAR_2->exception);\n        return(DestroyImageList(VAR_2));\n      }\n    VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);\n    if (VAR_10 == (QuantumInfo *) NULL)\n      ThrowReaderException(VAR_81,\"MemoryAllocationFailed\");\n\n  /* COMMENT_38 */\n    VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    /* COMMENT_39 */\n    if (VAR_14 == NULL)\n      ThrowReaderException(VAR_81,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));\n\n    VAR_15 = 0;\n    VAR_16 = 0;\n    if (VAR_9==VAR_76 || VAR_9==VAR_74)        /* COMMENT_40 */\n    {\n      CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);\n    }\n\n    /* COMMENT_41 */\n    if(VAR_18==1) VAR_18=0; /* COMMENT_42 */\n    /* COMMENT_43 */\n    do\n    {\n      for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)\n      {\n        VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);\n        if (VAR_5 == (PixelPacket *) NULL)\n  {\n    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(VAR_7.SizeY-VAR_12-1));\n    goto done_reading;    /* COMMENT_44 */\n  }\n        if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)\n  {\n    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(VAR_7.SizeY-VAR_12-1));\n    goto ExitLoop;\n  }\n        if((VAR_9==VAR_65 || VAR_9==VAR_66) && (VAR_7.StructureFlag & VAR_67))\n        {\n          FixLogical((unsigned char *)VAR_14,VAR_13);\n          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(VAR_7.SizeY-VAR_12-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (VAR_18<=1 &&       /* COMMENT_45 */\n          (VAR_9==VAR_65 || VAR_9==VAR_68 || VAR_9==VAR_70 || VAR_9==VAR_72))\n      FixSignedValues(VAR_5,VAR_7.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(VAR_2,VAR_1))\n  {\n    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(VAR_7.SizeY-VAR_12-1));\n    goto ExitLoop;\n  }\n      }\n    } while(VAR_18-- >= 2);\nExitLoop:\n\n\n    /* COMMENT_46 */\n    if (VAR_7.StructureFlag & VAR_75)\n    {        /* COMMENT_47 */\n      VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */\n      VAR_12 = VAR_26(VAR_3);           /* COMMENT_48 */\n\n      if (VAR_9==VAR_76 || VAR_9==VAR_74)\n      {\n        CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);\n      }\n\n      if (VAR_9==VAR_76)\n        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)\n  {\n          VAR_28(VAR_3, VAR_13, (double *)VAR_14);\n          InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);\n  }\n\n      if (VAR_9==VAR_74)\n        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)\n  {\n          VAR_31(VAR_3, VAR_13, (float *)VAR_14);\n          InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);\n  }\n    }\n\n      /* COMMENT_49 */\n    if ((VAR_7.DimFlag == 8) &&\n        ((VAR_7.StructureFlag & VAR_75) == 0))\n      VAR_2->type=VAR_79;\n    if (VAR_2->depth == 1)\n      VAR_2->type=VAR_83;\n\n    if(VAR_3==VAR_2)\n        VAR_3 = NULL;    /* COMMENT_50 */\n\n      /* COMMENT_51 */\n    VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);\n    if (VAR_4 != (Image *) NULL)\n    {\n        /* COMMENT_52 */\n      VAR_4->page.x=0;\n      VAR_4->page.y=0;\n\n      VAR_24 = VAR_4->blob;\n      VAR_4->blob = VAR_2->blob;\n      VAR_4->colors = VAR_2->colors;\n      VAR_2->blob = VAR_24;\n      AppendImageToList(&VAR_2,VAR_4);\n      DeleteImageFromList(&VAR_2);\n    }\n\ndone_reading:\n\n    if(VAR_3!=NULL)\n      if(VAR_3!=VAR_2)\n      {\n        DeleteImageFromList(&VAR_3);\n  if(VAR_11)\n  {\n          if(VAR_11->file)\n    {\n            fclose(VAR_11->file);\n            VAR_11->file = NULL;\n            (void) remove_utf8(VAR_11->filename);\n    }\n        }\n      }\n\n      /* COMMENT_53 */\n    AcquireNextImage(VAR_0,VAR_2);\n    if (VAR_2->next == (Image *) NULL) break;\n    VAR_2=SyncNextImageInList(VAR_2);\n    VAR_2->columns=VAR_2->rows=0;\n    VAR_2->colors=0;\n\n      /* COMMENT_54 */\n    RelinquishMagickMemory(VAR_14);\n    VAR_14 = NULL;\n\n    if(--VAR_20>0)\n    {\n      VAR_18 = VAR_19;\n      if(VAR_3==NULL) VAR_3 = VAR_2;\n      goto NEXT_FRAME;\n    }\n\n    if(VAR_3!=NULL)\n      if(VAR_3!=VAR_2)   /* COMMENT_55 */\n      {\n/* COMMENT_56 */\n        DeleteImageFromList(&VAR_3);\n        if(VAR_11)\n        {\n          if(VAR_11->file)\n          {\n            fclose(VAR_11->file);\n            VAR_11->file = NULL;\n            (void) unlink(VAR_11->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(VAR_14);\n  if (VAR_10 != (QuantumInfo *) NULL)\n    VAR_10=DestroyQuantumInfo(VAR_10);\nEND_OF_READING:\n  if (VAR_11)\n    VAR_11=DestroyImageInfo(VAR_11);\n  CloseBlob(VAR_2);\n\n\n  {\n    Image *VAR_84;\n    ssize_t VAR_85=0;\n\n    /* COMMENT_57 */\n                                                             \n      \n    VAR_84=VAR_2;\n    VAR_2=NULL;\n    while (VAR_84 != (Image *) NULL)\n      {\n        Image *VAR_86=VAR_84;\n        if ((VAR_84->rows == 0) || (VAR_84->columns == 0)) {\n          VAR_84=VAR_84->previous;\n          DeleteImageFromList(&VAR_86);\n        } else {\n          VAR_2=VAR_84;\n          VAR_84=VAR_84->previous;\n        }\n      }\n\n    /* COMMENT_60 */\n                       \n      \n    for (VAR_84=VAR_2; VAR_84 != (Image *) NULL; VAR_84=VAR_84->next)\n      VAR_84->scene=VAR_85++;\n  }\n\n  if(VAR_11 != NULL)  /* COMMENT_63 */\n  {\n    if(VAR_11->file)\n    {\n      fclose(VAR_11->file);\n      VAR_11->file = NULL;\n      (void) remove_utf8(VAR_11->filename);\n    }\n    DestroyImageInfo(VAR_11);\n    VAR_11 = NULL;\n  }\n  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\"return\");\n  if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))\n    VAR_3=DestroyImage(VAR_3);\n  if(VAR_2==NULL)\n    ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n  return (VAR_2);\n}",
    "func_graph_path_before": "ImageMagick/ab440f9ea11e0dbefb7a808cbb9441198758b0cb/mat.c/vul/before/0.json",
    "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
    "abstract_func": "static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)\n{\n  Image *VAR_2, *VAR_3=NULL,\n   *VAR_4;\n  PixelPacket *VAR_5;\n\n  unsigned int VAR_6;\n  MATHeader VAR_7;\n  size_t VAR_8;\n  size_t VAR_9;\n  QuantumInfo *VAR_10;\n  ImageInfo *VAR_11;\n  int VAR_12;\n  ssize_t VAR_13;\n  unsigned char *VAR_14 = NULL;\n  double VAR_15, VAR_16;\n  size_t VAR_17;\n  unsigned VAR_18, VAR_19;\n  unsigned VAR_20;\n  int VAR_21;\n  int VAR_22;\n  MagickOffsetType VAR_23=0x80;\n  BlobInfo *VAR_24;\n  size_t VAR_25;\n\n  unsigned int (*VAR_26)(Image *VAR_2);\n  unsigned short (*VAR_27)(Image *VAR_2);\n  void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);\n  void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);\n\n\n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_32);\n  assert(VAR_1 != (ExceptionInfo *) NULL);\n  assert(VAR_1->signature == VAR_32);\n  VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),\"enter\");\n\n  /* COMMENT_0 */\n                     \n     \n  VAR_10=(QuantumInfo *) NULL;\n  VAR_2 = AcquireImage(VAR_0);\n\n  VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);\n  if (VAR_6 == VAR_35)\n    {\n      VAR_2=DestroyImageList(VAR_2);\n      return((Image *) NULL);\n    }\n  /* COMMENT_3 */\n                       \n     \n  VAR_11=(ImageInfo *) NULL;\n  if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)\n    ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n  if (strncmp(VAR_7.identific,\"MATLAB\",6) != 0)\n    {\n      VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);\n      if (VAR_3  == NULL)\n        goto MATLAB_KO;\n      VAR_2=VAR_3;\n      goto END_OF_READING;\n    }\n  VAR_7.Version = ReadBlobLSBShort(VAR_2);\n  if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)\n    ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n\n  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\"  Endian %c%c\",\n        VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);\n  if (!strncmp(VAR_7.EndianIndicator, \"IM\", 2))\n  {\n    VAR_26 = VAR_37;\n    VAR_27 = VAR_38;\n    VAR_28 = VAR_39;\n    VAR_31 = VAR_40;\n    VAR_2->endian = VAR_41;\n  }\n  else if (!strncmp(VAR_7.EndianIndicator, \"MI\", 2))\n  {\n    VAR_26 = VAR_42;\n    VAR_27 = VAR_43;\n    VAR_28 = VAR_44;\n    VAR_31 = VAR_45;\n    VAR_2->endian = VAR_46;\n  }\n  else\n    goto MATLAB_KO;    /* COMMENT_6 */\n\n  if (strncmp(VAR_7.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if (VAR_11 != (ImageInfo *) NULL)\n        VAR_11=DestroyImageInfo(VAR_11);\n      ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n    }\n\n  VAR_23 = TellBlob(VAR_2);\n  while(!EOFBlob(VAR_2)) /* COMMENT_7 */\n  {\n    VAR_20 = 1;\n    (void) SeekBlob(VAR_2,VAR_23,VAR_47);\n    /* COMMENT_8 */\n\n    VAR_7.DataType = VAR_26(VAR_2);\n    if(EOFBlob(VAR_2)) break;\n    VAR_7.ObjectSize = VAR_26(VAR_2);\n    if(EOFBlob(VAR_2)) break;\n    if((VAR_48) (VAR_7.ObjectSize+VAR_23) > GetBlobSize(VAR_2))\n      goto MATLAB_KO;\n    VAR_23 += VAR_7.ObjectSize + 4 + 4;\n\n    VAR_11=CloneImageInfo(VAR_0);\n    VAR_3 = VAR_2;\n#if defined(VAR_49)\n    if(VAR_7.DataType == VAR_50)\n    {\n      VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);\n      if(VAR_3==NULL) continue;\n      VAR_7.DataType = VAR_26(VAR_3); /* COMMENT_9 */\n    }\n#endif\n\n    if(VAR_7.DataType!=VAR_51) continue;  /* COMMENT_10 */\n\n    VAR_7.unknown1 = VAR_26(VAR_3);\n    VAR_7.unknown2 = VAR_26(VAR_3);\n\n    VAR_7.unknown5 = VAR_26(VAR_3);\n    VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;\n    VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;\n\n    VAR_7.unknown3 = VAR_26(VAR_3);\n    if(VAR_2!=VAR_3)\n      VAR_7.unknown4 = VAR_26(VAR_3);  /* COMMENT_11 */\n    VAR_7.unknown4 = VAR_26(VAR_3);\n    VAR_7.DimFlag = VAR_26(VAR_3);\n    VAR_7.SizeX = VAR_26(VAR_3);\n    VAR_7.SizeY = VAR_26(VAR_3);\n\n\n    switch(VAR_7.DimFlag)\n    {\n      case  8: VAR_19=VAR_18=1; break;      /* COMMENT_12 */\n      case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_13 */\n           VAR_17 = VAR_26(VAR_3);\n           (void) VAR_17;\n         if(VAR_18!=3) ThrowReaderException(VAR_52, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_14 */\n         if(VAR_18!=3 && VAR_18!=1)\n           ThrowReaderException(VAR_52, \"MultidimensionalMatricesAreNotSupported\");\n         VAR_20 = VAR_26(VAR_3);\n         if (VAR_20 == 0)\n           ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(VAR_52, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    VAR_7.Flag1 = VAR_27(VAR_3);\n    VAR_7.NameFlag = VAR_27(VAR_3);\n\n    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",VAR_7.StructureClass);\n    if (VAR_7.StructureClass != VAR_53 &&\n        VAR_7.StructureClass != VAR_54 &&    /* COMMENT_15 */\n        VAR_7.StructureClass != VAR_55 &&    /* COMMENT_16 */\n        VAR_7.StructureClass != VAR_56 &&\n        VAR_7.StructureClass != VAR_57 &&    /* COMMENT_17 */\n        VAR_7.StructureClass != VAR_58 &&\n        VAR_7.StructureClass != VAR_59 &&    /* COMMENT_18 */\n        VAR_7.StructureClass != VAR_60 &&\n        VAR_7.StructureClass != VAR_61 &&    /* COMMENT_19 */\n        VAR_7.StructureClass != VAR_62 &&\n        VAR_7.StructureClass != VAR_63)    /* COMMENT_20 */\n      ThrowReaderException(VAR_52,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (VAR_7.NameFlag)\n    {\n      case 0:\n        VAR_8 = VAR_26(VAR_3);  /* COMMENT_21 */\n        VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);\n        (void) SeekBlob(VAR_3, VAR_8, VAR_64);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); /* COMMENT_22 */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */\n    if (VAR_21)\n      (void) LogMagickEvent(VAR_33,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) VAR_9);\n\n    (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     /* COMMENT_24 */\n\nNEXT_FRAME:\n    switch (VAR_9)\n    {\n      case VAR_65:\n      case VAR_66:\n        VAR_22 = 8;\n        if(VAR_7.StructureFlag & VAR_67)\n          VAR_2->depth = 1;\n        else\n          VAR_2->depth = 8;         /* COMMENT_25 */\n        VAR_13 = (ssize_t) VAR_7.SizeX;\n        break;\n      case VAR_68:\n      case VAR_69:\n        VAR_22 = 16;\n        VAR_2->depth = 16;        /* COMMENT_26 */\n        VAR_13 = (ssize_t) (2 * VAR_7.SizeX);\n        break;\n      case VAR_70:\n      case VAR_71:\n        VAR_22 = 32;\n        VAR_2->depth = 32;        /* COMMENT_27 */\n        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);\n        break;\n      case VAR_72:\n      case VAR_73:\n        VAR_22 = 64;\n        VAR_2->depth = 64;        /* COMMENT_28 */\n        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);\n        break;\n      case VAR_74:\n        VAR_22 = 32;\n        VAR_2->depth = 32;        /* COMMENT_29 */\n        (void) SetImageOption(VAR_11,\"quantum:format\",\"floating-point\");\n        if (VAR_7.StructureFlag & VAR_75)\n  {              /* COMMENT_30 */\n  }\n        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);\n        break;\n      case VAR_76:\n        VAR_22 = 64;\n        VAR_2->depth = 64;        /* COMMENT_29 */\n        (void) SetImageOption(VAR_11,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nVAR_77\n          ThrowReaderException(VAR_52, \"IncompatibleSizeOfDouble\");\n        if (VAR_7.StructureFlag & VAR_75)\n  {                         /* COMMENT_31 */\n  }\n        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);\n        break;\n      default:\n        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))\n          VAR_3=DestroyImage(VAR_3);\n        if (VAR_11)\n          VAR_11=DestroyImageInfo(VAR_11);\n        ThrowReaderException(VAR_52, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) VAR_22;\n    VAR_2->columns = VAR_7.SizeX;\n    VAR_2->rows = VAR_7.SizeY;\n    VAR_25=1;\n    VAR_2->colors = VAR_25 << VAR_2->depth;\n    if (VAR_2->columns == 0 || VAR_2->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)\n      goto MATLAB_KO;\n      /* COMMENT_32 */\n    if ((VAR_7.DimFlag == 8) &&\n        ((VAR_7.StructureFlag & VAR_75) == 0))\n      {\n        SetImageColorspace(VAR_2,VAR_78);\n        VAR_2->type=VAR_79;\n      }\n\n\n    /* COMMENT_33 */\n                                                                  \n                             \n      \n    if (VAR_0->ping)\n    {\n      size_t VAR_80 = VAR_2->columns;\n      VAR_2->columns = VAR_2->rows;\n      VAR_2->rows = VAR_80;\n      goto done_reading; /* COMMENT_37 */\n    }\n    VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);\n    if (VAR_6 == VAR_35)\n      {\n        InheritException(VAR_1,&VAR_2->exception);\n        return(DestroyImageList(VAR_2));\n      }\n    VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);\n    if (VAR_10 == (QuantumInfo *) NULL)\n      ThrowReaderException(VAR_81,\"MemoryAllocationFailed\");\n\n  /* COMMENT_38 */\n    VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    /* COMMENT_39 */\n    if (VAR_14 == NULL)\n      ThrowReaderException(VAR_81,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));\n\n    VAR_15 = 0;\n    VAR_16 = 0;\n    if (VAR_9==VAR_76 || VAR_9==VAR_74)        /* COMMENT_40 */\n    {\n      CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);\n    }\n\n    /* COMMENT_41 */\n    if(VAR_18==1) VAR_18=0; /* COMMENT_42 */\n    /* COMMENT_43 */\n    do\n    {\n      for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)\n      {\n        VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);\n        if (VAR_5 == (PixelPacket *) NULL)\n  {\n    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(VAR_7.SizeY-VAR_12-1));\n    goto done_reading;    /* COMMENT_44 */\n  }\n        if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)\n  {\n    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(VAR_7.SizeY-VAR_12-1));\n    goto ExitLoop;\n  }\n        if((VAR_9==VAR_65 || VAR_9==VAR_66) && (VAR_7.StructureFlag & VAR_67))\n        {\n          FixLogical((unsigned char *)VAR_14,VAR_13);\n          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(VAR_7.SizeY-VAR_12-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (VAR_18<=1 &&       /* COMMENT_45 */\n          (VAR_9==VAR_65 || VAR_9==VAR_68 || VAR_9==VAR_70 || VAR_9==VAR_72))\n      FixSignedValues(VAR_5,VAR_7.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(VAR_2,VAR_1))\n  {\n    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(VAR_7.SizeY-VAR_12-1));\n    goto ExitLoop;\n  }\n      }\n    } while(VAR_18-- >= 2);\nExitLoop:\n\n\n    /* COMMENT_46 */\n    if (VAR_7.StructureFlag & VAR_75)\n    {        /* COMMENT_47 */\n      VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */\n      VAR_12 = VAR_26(VAR_3);           /* COMMENT_48 */\n\n      if (VAR_9==VAR_76 || VAR_9==VAR_74)\n      {\n        CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);\n      }\n\n      if (VAR_9==VAR_76)\n        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)\n  {\n          VAR_28(VAR_3, VAR_13, (double *)VAR_14);\n          InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);\n  }\n\n      if (VAR_9==VAR_74)\n        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)\n  {\n          VAR_31(VAR_3, VAR_13, (float *)VAR_14);\n          InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);\n  }\n    }\n\n      /* COMMENT_49 */\n    if ((VAR_7.DimFlag == 8) &&\n        ((VAR_7.StructureFlag & VAR_75) == 0))\n      VAR_2->type=VAR_79;\n    if (VAR_2->depth == 1)\n      VAR_2->type=VAR_83;\n\n    if(VAR_3==VAR_2)\n        VAR_3 = NULL;    /* COMMENT_50 */\n\n      /* COMMENT_51 */\n    VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);\n    if (VAR_4 != (Image *) NULL)\n    {\n        /* COMMENT_52 */\n      VAR_4->page.x=0;\n      VAR_4->page.y=0;\n\n      VAR_24 = VAR_4->blob;\n      VAR_4->blob = VAR_2->blob;\n      VAR_4->colors = VAR_2->colors;\n      VAR_2->blob = VAR_24;\n      AppendImageToList(&VAR_2,VAR_4);\n      DeleteImageFromList(&VAR_2);\n    }\n\ndone_reading:\n\n    if(VAR_3!=NULL)\n      if(VAR_3!=VAR_2)\n      {\n        DeleteImageFromList(&VAR_3);\n  if(VAR_11)\n  {\n          if(VAR_11->file)\n    {\n            fclose(VAR_11->file);\n            VAR_11->file = NULL;\n            (void) remove_utf8(VAR_11->filename);\n    }\n        }\n      }\n\n      /* COMMENT_53 */\n    AcquireNextImage(VAR_0,VAR_2);\n    if (VAR_2->next == (Image *) NULL) break;\n    VAR_2=SyncNextImageInList(VAR_2);\n    VAR_2->columns=VAR_2->rows=0;\n    VAR_2->colors=0;\n\n      /* COMMENT_54 */\n    RelinquishMagickMemory(VAR_14);\n    VAR_14 = NULL;\n\n    if(--VAR_20>0)\n    {\n      VAR_18 = VAR_19;\n      if(VAR_3==NULL) VAR_3 = VAR_2;\n      goto NEXT_FRAME;\n    }\n\n    if(VAR_3!=NULL)\n      if(VAR_3!=VAR_2)   /* COMMENT_55 */\n      {\n/* COMMENT_56 */\n        DeleteImageFromList(&VAR_3);\n        if(VAR_11)\n        {\n          if(VAR_11->file)\n          {\n            fclose(VAR_11->file);\n            VAR_11->file = NULL;\n            (void) unlink(VAR_11->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(VAR_14);\n  if (VAR_10 != (QuantumInfo *) NULL)\n    VAR_10=DestroyQuantumInfo(VAR_10);\nEND_OF_READING:\n  if (VAR_11)\n    VAR_11=DestroyImageInfo(VAR_11);\n  CloseBlob(VAR_2);\n\n\n  {\n    Image *VAR_84;\n    ssize_t VAR_85=0;\n\n    /* COMMENT_57 */\n                                                             \n      \n    VAR_84=VAR_2;\n    VAR_2=NULL;\n    while (VAR_84 != (Image *) NULL)\n      {\n        Image *VAR_86=VAR_84;\n        if ((VAR_84->rows == 0) || (VAR_84->columns == 0)) {\n          VAR_84=VAR_84->previous;\n          DeleteImageFromList(&VAR_86);\n        } else {\n          VAR_2=VAR_84;\n          VAR_84=VAR_84->previous;\n        }\n      }\n\n    /* COMMENT_60 */\n                       \n      \n    for (VAR_84=VAR_2; VAR_84 != (Image *) NULL; VAR_84=VAR_84->next)\n      VAR_84->scene=VAR_85++;\n  }\n\n  if(VAR_11 != NULL)  /* COMMENT_63 */\n  {\n    if(VAR_11->file)\n    {\n      fclose(VAR_11->file);\n      VAR_11->file = NULL;\n      (void) remove_utf8(VAR_11->filename);\n    }\n    DestroyImageInfo(VAR_11);\n    VAR_11 = NULL;\n  }\n  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),\"return\");\n  if(VAR_2==NULL)\n    ThrowReaderException(VAR_36,\"ImproperImageHeader\");\n  else\n    if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))\n      VAR_3=DestroyImage(VAR_3);\n  return (VAR_2);\n}",
    "func_graph_path": "ImageMagick/ab440f9ea11e0dbefb7a808cbb9441198758b0cb/mat.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -515,9 +515,10 @@\n     clone_info = NULL;\n   }\n   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n-  if ((image != image2) && (image2 != (Image *) NULL))\n-    image2=DestroyImage(image2);\n   if(image==NULL)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+  else\n+    if ((image != image2) && (image2 != (Image *) NULL))\n+      image2=DestroyImage(image2);\n   return (image);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "  if ((image != image2) && (image2 != (Image *) NULL))",
            "    image2=DestroyImage(image2);"
        ],
        "added_lines": [
            "  else",
            "    if ((image != image2) && (image2 != (Image *) NULL))",
            "      image2=DestroyImage(image2);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}