{
    "cve_id": "CVE-2022-1735",
    "cwe_ids": [
        "CWE-120"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "vim",
    "commit_msg": "patch 8.2.4969: changing text in Visual mode may cause invalid memory access\n\nProblem:    Changing text in Visual mode may cause invalid memory access.\nSolution:   Check the Visual position after making a change.",
    "commit_hash": "7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97",
    "git_url": "https://github.com/vim/vim/commit/7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97",
    "file_path": "src/change.c",
    "func_name": "changed_common",
    "func_before": "static void\nchanged_common(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n    int\t\ti;\n    int\t\tcols;\n    pos_T\t*p;\n    int\t\tadd;\n\n    // mark the buffer as modified\n    changed();\n\n#ifdef FEAT_EVAL\n    may_record_change(lnum, col, lnume, xtra);\n#endif\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff && diff_internal())\n\tcurtab->tp_diff_update = TRUE;\n#endif\n\n    // set the '. mark\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n    {\n\tcurbuf->b_last_change.lnum = lnum;\n\tcurbuf->b_last_change.col = col;\n\n\t// Create a new entry if a new undo-able change was started or we\n\t// don't have an entry yet.\n\tif (curbuf->b_new_change || curbuf->b_changelistlen == 0)\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\tadd = TRUE;\n\t    else\n\t    {\n\t\t// Don't create a new entry when the line number is the same\n\t\t// as the last one and the column is not too far away.  Avoids\n\t\t// creating many entries for typing \"xxxxx\".\n\t\tp = &curbuf->b_changelist[curbuf->b_changelistlen - 1];\n\t\tif (p->lnum != lnum)\n\t\t    add = TRUE;\n\t\telse\n\t\t{\n\t\t    cols = comp_textwidth(FALSE);\n\t\t    if (cols == 0)\n\t\t\tcols = 79;\n\t\t    add = (p->col + cols < col || col + cols < p->col);\n\t\t}\n\t    }\n\t    if (add)\n\t    {\n\t\t// This is the first of a new sequence of undo-able changes\n\t\t// and it's at some distance of the last change.  Use a new\n\t\t// position in the changelist.\n\t\tcurbuf->b_new_change = FALSE;\n\n\t\tif (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // changelist is full: remove oldest entry\n\t\t    curbuf->b_changelistlen = JUMPLISTSIZE - 1;\n\t\t    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t    {\n\t\t\t// Correct position in changelist for other windows on\n\t\t\t// this buffer.\n\t\t\tif (wp->w_buffer == curbuf && wp->w_changelistidx > 0)\n\t\t\t    --wp->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t{\n\t\t    // For other windows, if the position in the changelist is\n\t\t    // at the end it stays at the end.\n\t\t    if (wp->w_buffer == curbuf\n\t\t\t    && wp->w_changelistidx == curbuf->b_changelistlen)\n\t\t\t++wp->w_changelistidx;\n\t\t}\n\t\t++curbuf->b_changelistlen;\n\t    }\n\t}\n\tcurbuf->b_changelist[curbuf->b_changelistlen - 1] =\n\t\t\t\t\t\t\tcurbuf->b_last_change;\n\t// The current window is always after the last change, so that \"g,\"\n\t// takes you back to it.\n\tcurwin->w_changelistidx = curbuf->b_changelistlen;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == curbuf)\n\t{\n#ifdef FEAT_FOLDING\n\t    linenr_T last = lnume + xtra - 1;  // last line after the change\n#endif\n\t    // Mark this window to be redrawn later.\n\t    if (wp->w_redr_type < VALID)\n\t\twp->w_redr_type = VALID;\n\n\t    // Check if a change in the buffer has invalidated the cached\n\t    // values for the cursor.\n#ifdef FEAT_FOLDING\n\t    // Update the folds for this window.  Can't postpone this, because\n\t    // a following operator might work on the whole fold: \">>dd\".\n\t    foldUpdate(wp, lnum, last);\n\n\t    // The change may cause lines above or below the change to become\n\t    // included in a fold.  Set lnum/lnume to the first/last line that\n\t    // might be displayed differently.\n\t    // Set w_cline_folded here as an efficient way to update it when\n\t    // inserting lines just above a closed fold.\n\t    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == lnum)\n\t\twp->w_cline_folded = i;\n\t    i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == last)\n\t\twp->w_cline_folded = i;\n\n\t    // If the changed line is in a range of previously folded lines,\n\t    // compare with the first line in that range.\n\t    if (wp->w_cursor.lnum <= lnum)\n\t    {\n\t\ti = find_wl_entry(wp, lnum);\n\t\tif (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)\n\t\t    changed_line_abv_curs_win(wp);\n\t    }\n#endif\n\t    if (wp->w_cursor.lnum > lnum)\n\t\tchanged_line_abv_curs_win(wp);\n\t    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)\n\t\tchanged_cline_bef_curs_win(wp);\n\t    if (wp->w_botline >= lnum)\n\t    {\n\t\tif (xtra < 0)\n\t\t    invalidate_botline_win(wp);\n\t\telse\n\t\t    // Assume that botline doesn't change (inserted lines make\n\t\t    // other lines scroll down below botline).\n\t\t    approximate_botline_win(wp);\n\t    }\n\n\t    // Check if any w_lines[] entries have become invalid.\n\t    // For entries below the change: Correct the lnums for\n\t    // inserted/deleted lines.  Makes it possible to stop displaying\n\t    // after the change.\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lnum >= lnum)\n\t\t    {\n\t\t\tif (wp->w_lines[i].wl_lnum < lnume)\n\t\t\t{\n\t\t\t    // line included in change\n\t\t\t    wp->w_lines[i].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (xtra != 0)\n\t\t\t{\n\t\t\t    // line below change\n\t\t\t    wp->w_lines[i].wl_lnum += xtra;\n#ifdef FEAT_FOLDING\n\t\t\t    wp->w_lines[i].wl_lastlnum += xtra;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FOLDING\n\t\t    else if (wp->w_lines[i].wl_lastlnum >= lnum)\n\t\t    {\n\t\t\t// change somewhere inside this range of folded lines,\n\t\t\t// may need to be redrawn\n\t\t\twp->w_lines[i].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef FEAT_FOLDING\n\t    // Take care of side effects for setting w_topline when folds have\n\t    // changed.  Esp. when the buffer was changed in another window.\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    // If lines have been added or removed, relative numbering always\n\t    // requires a redraw.\n\t    if (wp->w_p_rnu && xtra != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VALID);\n\t    }\n#ifdef FEAT_SYN_HL\n\t    // Cursor line highlighting probably need to be updated with\n\t    // \"VALID\" if it's below the change.\n\t    // If the cursor line is inside the change we need to redraw more.\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (xtra == 0)\n\t\t    redraw_win_later(wp, VALID);\n\t\telse if (lnum <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, SOME_VALID);\n\t    }\n#endif\n\t}\n    }\n\n    // Call update_screen() later, which checks out what needs to be redrawn,\n    // since it notices b_mod_set and then uses b_mod_*.\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n\n    // when the cursor line is changed always trigger CursorMoved\n    if (lnum <= curwin->w_cursor.lnum\n\t\t && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)\n\tlast_cursormoved.lnum = 0;\n}",
    "abstract_func_before": "static void\nchanged_common(\n    linenr_T\tVAR_0,\n    colnr_T\tVAR_1,\n    linenr_T\tVAR_2,\n    long\tVAR_3)\n{\n    win_T\t*VAR_4;\n    tabpage_T\t*VAR_5;\n    int\t\tVAR_6;\n    int\t\tVAR_7;\n    pos_T\t*VAR_8;\n    int\t\tVAR_9;\n\n    /* COMMENT_0 */\n    changed();\n\n#ifdef VAR_10\n    may_record_change(VAR_0, VAR_1, VAR_2, VAR_3);\n#endif\n#ifdef VAR_11\n    if (VAR_12->w_p_diff && diff_internal())\n\tVAR_13->tp_diff_update = TRUE;\n#endif\n\n    /* COMMENT_1 */\n    if ((VAR_14.cmod_flags & VAR_15) == 0)\n    {\n\tVAR_16->b_last_change.lnum = VAR_0;\n\tVAR_16->b_last_change.col = VAR_1;\n\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\tif (VAR_16->b_new_change || VAR_16->b_changelistlen == 0)\n\t{\n\t    if (VAR_16->b_changelistlen == 0)\n\t\tVAR_9 = TRUE;\n\t    else\n\t    {\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\t\t/* COMMENT_6 */\n\t\tVAR_8 = &VAR_16->b_changelist[VAR_16->b_changelistlen - 1];\n\t\tif (VAR_8->lnum != VAR_0)\n\t\t    VAR_9 = TRUE;\n\t\telse\n\t\t{\n\t\t    VAR_7 = comp_textwidth(FALSE);\n\t\t    if (VAR_7 == 0)\n\t\t\tVAR_7 = 79;\n\t\t    VAR_9 = (VAR_8->col + VAR_7 < VAR_1 || VAR_1 + VAR_7 < VAR_8->col);\n\t\t}\n\t    }\n\t    if (VAR_9)\n\t    {\n\t\t/* COMMENT_7 */\n\t\t/* COMMENT_8 */\n\t\t/* COMMENT_9 */\n\t\tVAR_16->b_new_change = FALSE;\n\n\t\tif (VAR_16->b_changelistlen == VAR_17)\n\t\t{\n\t\t    /* COMMENT_10 */\n\t\t    VAR_16->b_changelistlen = VAR_17 - 1;\n\t\t    mch_memmove(VAR_16->b_changelist, VAR_16->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (VAR_17 - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(VAR_5, VAR_4)\n\t\t    {\n\t\t\t/* COMMENT_11 */\n\t\t\t/* COMMENT_12 */\n\t\t\tif (VAR_4->w_buffer == VAR_16 && VAR_4->w_changelistidx > 0)\n\t\t\t    --VAR_4->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(VAR_5, VAR_4)\n\t\t{\n\t\t    /* COMMENT_13 */\n\t\t    /* COMMENT_14 */\n\t\t    if (VAR_4->w_buffer == VAR_16\n\t\t\t    && VAR_4->w_changelistidx == VAR_16->b_changelistlen)\n\t\t\t++VAR_4->w_changelistidx;\n\t\t}\n\t\t++VAR_16->b_changelistlen;\n\t    }\n\t}\n\tVAR_16->b_changelist[VAR_16->b_changelistlen - 1] =\n\t\t\t\t\t\t\tVAR_16->b_last_change;\n\t/* COMMENT_15 */\n\t/* COMMENT_16 */\n\tVAR_12->w_changelistidx = VAR_16->b_changelistlen;\n    }\n\n    FOR_ALL_TAB_WINDOWS(VAR_5, VAR_4)\n    {\n\tif (VAR_4->w_buffer == VAR_16)\n\t{\n#ifdef VAR_18\n\t    linenr_T VAR_19 = VAR_2 + VAR_3 - 1;  /* COMMENT_17 */\n#endif\n\t    /* COMMENT_18 */\n\t    if (VAR_4->w_redr_type < VAR_20)\n\t\tVAR_4->w_redr_type = VAR_20;\n\n\t    /* COMMENT_19 */\n\t    /* COMMENT_20 */\n#ifdef VAR_18\n\t    /* COMMENT_21 */\n\t    /* COMMENT_22 */\n\t    foldUpdate(VAR_4, VAR_0, VAR_19);\n\n\t    /* COMMENT_23 */\n\t    /* COMMENT_24 */\n\t    /* COMMENT_25 */\n\t    /* COMMENT_26 */\n\t    /* COMMENT_27 */\n\t    VAR_6 = hasFoldingWin(VAR_4, VAR_0, &VAR_0, NULL, FALSE, NULL);\n\t    if (VAR_4->w_cursor.lnum == VAR_0)\n\t\tVAR_4->w_cline_folded = VAR_6;\n\t    VAR_6 = hasFoldingWin(VAR_4, VAR_19, NULL, &VAR_19, FALSE, NULL);\n\t    if (VAR_4->w_cursor.lnum == VAR_19)\n\t\tVAR_4->w_cline_folded = VAR_6;\n\n\t    /* COMMENT_28 */\n\t    /* COMMENT_29 */\n\t    if (VAR_4->w_cursor.lnum <= VAR_0)\n\t    {\n\t\tVAR_6 = find_wl_entry(VAR_4, VAR_0);\n\t\tif (VAR_6 >= 0 && VAR_4->w_cursor.lnum > VAR_4->w_lines[VAR_6].wl_lnum)\n\t\t    changed_line_abv_curs_win(VAR_4);\n\t    }\n#endif\n\t    if (VAR_4->w_cursor.lnum > VAR_0)\n\t\tchanged_line_abv_curs_win(VAR_4);\n\t    else if (VAR_4->w_cursor.lnum == VAR_0 && VAR_4->w_cursor.col >= VAR_1)\n\t\tchanged_cline_bef_curs_win(VAR_4);\n\t    if (VAR_4->w_botline >= VAR_0)\n\t    {\n\t\tif (VAR_3 < 0)\n\t\t    invalidate_botline_win(VAR_4);\n\t\telse\n\t\t    /* COMMENT_30 */\n\t\t    /* COMMENT_31 */\n\t\t    approximate_botline_win(VAR_4);\n\t    }\n\n\t    /* COMMENT_32 */\n\t    /* COMMENT_33 */\n\t    /* COMMENT_34 */\n\t    /* COMMENT_35 */\n\t    for (VAR_6 = 0; VAR_6 < VAR_4->w_lines_valid; ++VAR_6)\n\t\tif (VAR_4->w_lines[VAR_6].wl_valid)\n\t\t{\n\t\t    if (VAR_4->w_lines[VAR_6].wl_lnum >= VAR_0)\n\t\t    {\n\t\t\tif (VAR_4->w_lines[VAR_6].wl_lnum < VAR_2)\n\t\t\t{\n\t\t\t    /* COMMENT_36 */\n\t\t\t    VAR_4->w_lines[VAR_6].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (VAR_3 != 0)\n\t\t\t{\n\t\t\t    /* COMMENT_37 */\n\t\t\t    VAR_4->w_lines[VAR_6].wl_lnum += VAR_3;\n#ifdef VAR_18\n\t\t\t    VAR_4->w_lines[VAR_6].wl_lastlnum += VAR_3;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef VAR_18\n\t\t    else if (wp->VAR_21[VAR_6].VAR_22 >= VAR_0)\n\t\t    {\n\t\t\t/* COMMENT_38 */\n\t\t\t/* COMMENT_39 */\n\t\t\twp->w_lines[VAR_6].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef VAR_18\n\t    /* COMMENT_40 */\n\t    /* COMMENT_41 */\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    /* COMMENT_42 */\n\t    /* COMMENT_43 */\n\t    if (wp->w_p_rnu && VAR_3 != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VAR_20);\n\t    }\n#ifdef VAR_23\n\t    /* COMMENT_44 */\n\t    /* COMMENT_45 */\n\t    /* COMMENT_46 */\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (VAR_3 == 0)\n\t\t    redraw_win_later(wp, VAR_20);\n\t\telse if (VAR_0 <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, VAR_24);\n\t    }\n#endif\n\t}\n    }\n\n    /* COMMENT_47 */\n    /* COMMENT_48 */\n    if (VAR_25 < VAR_20)\n\tVAR_25 = VAR_20;\n\n    /* COMMENT_49 */\n    if (VAR_0 <= VAR_12->w_cursor.lnum\n\t\t && VAR_2 + (VAR_3 < 0 ? -VAR_3 : VAR_3) > VAR_12->w_cursor.lnum)\n\tVAR_26.lnum = 0;\n}",
    "func_graph_path_before": "vim/7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97/change.c/vul/before/0.json",
    "func": "static void\nchanged_common(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n    int\t\ti;\n    int\t\tcols;\n    pos_T\t*p;\n    int\t\tadd;\n\n    // mark the buffer as modified\n    changed();\n\n#ifdef FEAT_EVAL\n    may_record_change(lnum, col, lnume, xtra);\n#endif\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff && diff_internal())\n\tcurtab->tp_diff_update = TRUE;\n#endif\n\n    // set the '. mark\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n    {\n\tcurbuf->b_last_change.lnum = lnum;\n\tcurbuf->b_last_change.col = col;\n\n\t// Create a new entry if a new undo-able change was started or we\n\t// don't have an entry yet.\n\tif (curbuf->b_new_change || curbuf->b_changelistlen == 0)\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\tadd = TRUE;\n\t    else\n\t    {\n\t\t// Don't create a new entry when the line number is the same\n\t\t// as the last one and the column is not too far away.  Avoids\n\t\t// creating many entries for typing \"xxxxx\".\n\t\tp = &curbuf->b_changelist[curbuf->b_changelistlen - 1];\n\t\tif (p->lnum != lnum)\n\t\t    add = TRUE;\n\t\telse\n\t\t{\n\t\t    cols = comp_textwidth(FALSE);\n\t\t    if (cols == 0)\n\t\t\tcols = 79;\n\t\t    add = (p->col + cols < col || col + cols < p->col);\n\t\t}\n\t    }\n\t    if (add)\n\t    {\n\t\t// This is the first of a new sequence of undo-able changes\n\t\t// and it's at some distance of the last change.  Use a new\n\t\t// position in the changelist.\n\t\tcurbuf->b_new_change = FALSE;\n\n\t\tif (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // changelist is full: remove oldest entry\n\t\t    curbuf->b_changelistlen = JUMPLISTSIZE - 1;\n\t\t    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t    {\n\t\t\t// Correct position in changelist for other windows on\n\t\t\t// this buffer.\n\t\t\tif (wp->w_buffer == curbuf && wp->w_changelistidx > 0)\n\t\t\t    --wp->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t{\n\t\t    // For other windows, if the position in the changelist is\n\t\t    // at the end it stays at the end.\n\t\t    if (wp->w_buffer == curbuf\n\t\t\t    && wp->w_changelistidx == curbuf->b_changelistlen)\n\t\t\t++wp->w_changelistidx;\n\t\t}\n\t\t++curbuf->b_changelistlen;\n\t    }\n\t}\n\tcurbuf->b_changelist[curbuf->b_changelistlen - 1] =\n\t\t\t\t\t\t\tcurbuf->b_last_change;\n\t// The current window is always after the last change, so that \"g,\"\n\t// takes you back to it.\n\tcurwin->w_changelistidx = curbuf->b_changelistlen;\n    }\n\n    if (VIsual_active)\n\tcheck_visual_pos();\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == curbuf)\n\t{\n#ifdef FEAT_FOLDING\n\t    linenr_T last = lnume + xtra - 1;  // last line after the change\n#endif\n\t    // Mark this window to be redrawn later.\n\t    if (wp->w_redr_type < VALID)\n\t\twp->w_redr_type = VALID;\n\n\t    // Check if a change in the buffer has invalidated the cached\n\t    // values for the cursor.\n#ifdef FEAT_FOLDING\n\t    // Update the folds for this window.  Can't postpone this, because\n\t    // a following operator might work on the whole fold: \">>dd\".\n\t    foldUpdate(wp, lnum, last);\n\n\t    // The change may cause lines above or below the change to become\n\t    // included in a fold.  Set lnum/lnume to the first/last line that\n\t    // might be displayed differently.\n\t    // Set w_cline_folded here as an efficient way to update it when\n\t    // inserting lines just above a closed fold.\n\t    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == lnum)\n\t\twp->w_cline_folded = i;\n\t    i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == last)\n\t\twp->w_cline_folded = i;\n\n\t    // If the changed line is in a range of previously folded lines,\n\t    // compare with the first line in that range.\n\t    if (wp->w_cursor.lnum <= lnum)\n\t    {\n\t\ti = find_wl_entry(wp, lnum);\n\t\tif (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)\n\t\t    changed_line_abv_curs_win(wp);\n\t    }\n#endif\n\t    if (wp->w_cursor.lnum > lnum)\n\t\tchanged_line_abv_curs_win(wp);\n\t    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)\n\t\tchanged_cline_bef_curs_win(wp);\n\t    if (wp->w_botline >= lnum)\n\t    {\n\t\tif (xtra < 0)\n\t\t    invalidate_botline_win(wp);\n\t\telse\n\t\t    // Assume that botline doesn't change (inserted lines make\n\t\t    // other lines scroll down below botline).\n\t\t    approximate_botline_win(wp);\n\t    }\n\n\t    // Check if any w_lines[] entries have become invalid.\n\t    // For entries below the change: Correct the lnums for\n\t    // inserted/deleted lines.  Makes it possible to stop displaying\n\t    // after the change.\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lnum >= lnum)\n\t\t    {\n\t\t\tif (wp->w_lines[i].wl_lnum < lnume)\n\t\t\t{\n\t\t\t    // line included in change\n\t\t\t    wp->w_lines[i].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (xtra != 0)\n\t\t\t{\n\t\t\t    // line below change\n\t\t\t    wp->w_lines[i].wl_lnum += xtra;\n#ifdef FEAT_FOLDING\n\t\t\t    wp->w_lines[i].wl_lastlnum += xtra;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FOLDING\n\t\t    else if (wp->w_lines[i].wl_lastlnum >= lnum)\n\t\t    {\n\t\t\t// change somewhere inside this range of folded lines,\n\t\t\t// may need to be redrawn\n\t\t\twp->w_lines[i].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef FEAT_FOLDING\n\t    // Take care of side effects for setting w_topline when folds have\n\t    // changed.  Esp. when the buffer was changed in another window.\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    // If lines have been added or removed, relative numbering always\n\t    // requires a redraw.\n\t    if (wp->w_p_rnu && xtra != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VALID);\n\t    }\n#ifdef FEAT_SYN_HL\n\t    // Cursor line highlighting probably need to be updated with\n\t    // \"VALID\" if it's below the change.\n\t    // If the cursor line is inside the change we need to redraw more.\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (xtra == 0)\n\t\t    redraw_win_later(wp, VALID);\n\t\telse if (lnum <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, SOME_VALID);\n\t    }\n#endif\n\t}\n    }\n\n    // Call update_screen() later, which checks out what needs to be redrawn,\n    // since it notices b_mod_set and then uses b_mod_*.\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n\n    // when the cursor line is changed always trigger CursorMoved\n    if (lnum <= curwin->w_cursor.lnum\n\t\t && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)\n\tlast_cursormoved.lnum = 0;\n}",
    "abstract_func": "static void\nchanged_common(\n    linenr_T\tVAR_0,\n    colnr_T\tVAR_1,\n    linenr_T\tVAR_2,\n    long\tVAR_3)\n{\n    win_T\t*VAR_4;\n    tabpage_T\t*VAR_5;\n    int\t\tVAR_6;\n    int\t\tVAR_7;\n    pos_T\t*VAR_8;\n    int\t\tVAR_9;\n\n    /* COMMENT_0 */\n    changed();\n\n#ifdef VAR_10\n    may_record_change(VAR_0, VAR_1, VAR_2, VAR_3);\n#endif\n#ifdef VAR_11\n    if (VAR_12->w_p_diff && diff_internal())\n\tVAR_13->tp_diff_update = TRUE;\n#endif\n\n    /* COMMENT_1 */\n    if ((VAR_14.cmod_flags & VAR_15) == 0)\n    {\n\tVAR_16->b_last_change.lnum = VAR_0;\n\tVAR_16->b_last_change.col = VAR_1;\n\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\tif (VAR_16->b_new_change || VAR_16->b_changelistlen == 0)\n\t{\n\t    if (VAR_16->b_changelistlen == 0)\n\t\tVAR_9 = TRUE;\n\t    else\n\t    {\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\t\t/* COMMENT_6 */\n\t\tVAR_8 = &VAR_16->b_changelist[VAR_16->b_changelistlen - 1];\n\t\tif (VAR_8->lnum != VAR_0)\n\t\t    VAR_9 = TRUE;\n\t\telse\n\t\t{\n\t\t    VAR_7 = comp_textwidth(FALSE);\n\t\t    if (VAR_7 == 0)\n\t\t\tVAR_7 = 79;\n\t\t    VAR_9 = (VAR_8->col + VAR_7 < VAR_1 || VAR_1 + VAR_7 < VAR_8->col);\n\t\t}\n\t    }\n\t    if (VAR_9)\n\t    {\n\t\t/* COMMENT_7 */\n\t\t/* COMMENT_8 */\n\t\t/* COMMENT_9 */\n\t\tVAR_16->b_new_change = FALSE;\n\n\t\tif (VAR_16->b_changelistlen == VAR_17)\n\t\t{\n\t\t    /* COMMENT_10 */\n\t\t    VAR_16->b_changelistlen = VAR_17 - 1;\n\t\t    mch_memmove(VAR_16->b_changelist, VAR_16->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (VAR_17 - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(VAR_5, VAR_4)\n\t\t    {\n\t\t\t/* COMMENT_11 */\n\t\t\t/* COMMENT_12 */\n\t\t\tif (VAR_4->w_buffer == VAR_16 && VAR_4->w_changelistidx > 0)\n\t\t\t    --VAR_4->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(VAR_5, VAR_4)\n\t\t{\n\t\t    /* COMMENT_13 */\n\t\t    /* COMMENT_14 */\n\t\t    if (VAR_4->w_buffer == VAR_16\n\t\t\t    && VAR_4->w_changelistidx == VAR_16->b_changelistlen)\n\t\t\t++VAR_4->w_changelistidx;\n\t\t}\n\t\t++VAR_16->b_changelistlen;\n\t    }\n\t}\n\tVAR_16->b_changelist[VAR_16->b_changelistlen - 1] =\n\t\t\t\t\t\t\tVAR_16->b_last_change;\n\t/* COMMENT_15 */\n\t/* COMMENT_16 */\n\tVAR_12->w_changelistidx = VAR_16->b_changelistlen;\n    }\n\n    if (VAR_18)\n\tcheck_visual_pos();\n\n    FOR_ALL_TAB_WINDOWS(VAR_5, VAR_4)\n    {\n\tif (VAR_4->w_buffer == VAR_16)\n\t{\n#ifdef VAR_19\n\t    linenr_T VAR_20 = VAR_2 + VAR_3 - 1;  /* COMMENT_17 */\n#endif\n\t    /* COMMENT_18 */\n\t    if (VAR_4->w_redr_type < VAR_21)\n\t\tVAR_4->w_redr_type = VAR_21;\n\n\t    /* COMMENT_19 */\n\t    /* COMMENT_20 */\n#ifdef VAR_19\n\t    /* COMMENT_21 */\n\t    /* COMMENT_22 */\n\t    foldUpdate(VAR_4, VAR_0, VAR_20);\n\n\t    /* COMMENT_23 */\n\t    /* COMMENT_24 */\n\t    /* COMMENT_25 */\n\t    /* COMMENT_26 */\n\t    /* COMMENT_27 */\n\t    VAR_6 = hasFoldingWin(VAR_4, VAR_0, &VAR_0, NULL, FALSE, NULL);\n\t    if (VAR_4->w_cursor.lnum == VAR_0)\n\t\tVAR_4->w_cline_folded = VAR_6;\n\t    VAR_6 = hasFoldingWin(VAR_4, VAR_20, NULL, &VAR_20, FALSE, NULL);\n\t    if (VAR_4->w_cursor.lnum == VAR_20)\n\t\tVAR_4->w_cline_folded = VAR_6;\n\n\t    /* COMMENT_28 */\n\t    /* COMMENT_29 */\n\t    if (VAR_4->w_cursor.lnum <= VAR_0)\n\t    {\n\t\tVAR_6 = find_wl_entry(VAR_4, VAR_0);\n\t\tif (VAR_6 >= 0 && VAR_4->w_cursor.lnum > VAR_4->w_lines[VAR_6].wl_lnum)\n\t\t    changed_line_abv_curs_win(VAR_4);\n\t    }\n#endif\n\t    if (VAR_4->w_cursor.lnum > VAR_0)\n\t\tchanged_line_abv_curs_win(VAR_4);\n\t    else if (VAR_4->w_cursor.lnum == VAR_0 && VAR_4->w_cursor.col >= VAR_1)\n\t\tchanged_cline_bef_curs_win(VAR_4);\n\t    if (VAR_4->w_botline >= VAR_0)\n\t    {\n\t\tif (VAR_3 < 0)\n\t\t    invalidate_botline_win(VAR_4);\n\t\telse\n\t\t    /* COMMENT_30 */\n\t\t    /* COMMENT_31 */\n\t\t    approximate_botline_win(VAR_4);\n\t    }\n\n\t    /* COMMENT_32 */\n\t    /* COMMENT_33 */\n\t    /* COMMENT_34 */\n\t    /* COMMENT_35 */\n\t    for (VAR_6 = 0; VAR_6 < VAR_4->w_lines_valid; ++VAR_6)\n\t\tif (VAR_4->w_lines[VAR_6].wl_valid)\n\t\t{\n\t\t    if (VAR_4->w_lines[VAR_6].wl_lnum >= VAR_0)\n\t\t    {\n\t\t\tif (VAR_4->w_lines[VAR_6].wl_lnum < VAR_2)\n\t\t\t{\n\t\t\t    /* COMMENT_36 */\n\t\t\t    VAR_4->w_lines[VAR_6].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (VAR_3 != 0)\n\t\t\t{\n\t\t\t    /* COMMENT_37 */\n\t\t\t    VAR_4->w_lines[VAR_6].wl_lnum += VAR_3;\n#ifdef VAR_19\n\t\t\t    VAR_4->w_lines[VAR_6].wl_lastlnum += VAR_3;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef VAR_19\n\t\t    else if (wp->VAR_22[VAR_6].VAR_23 >= VAR_0)\n\t\t    {\n\t\t\t/* COMMENT_38 */\n\t\t\t/* COMMENT_39 */\n\t\t\twp->w_lines[VAR_6].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef VAR_19\n\t    /* COMMENT_40 */\n\t    /* COMMENT_41 */\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    /* COMMENT_42 */\n\t    /* COMMENT_43 */\n\t    if (wp->w_p_rnu && VAR_3 != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VAR_21);\n\t    }\n#ifdef VAR_24\n\t    /* COMMENT_44 */\n\t    /* COMMENT_45 */\n\t    /* COMMENT_46 */\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (VAR_3 == 0)\n\t\t    redraw_win_later(wp, VAR_21);\n\t\telse if (VAR_0 <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, VAR_25);\n\t    }\n#endif\n\t}\n    }\n\n    /* COMMENT_47 */\n    /* COMMENT_48 */\n    if (VAR_26 < VAR_21)\n\tVAR_26 = VAR_21;\n\n    /* COMMENT_49 */\n    if (VAR_0 <= VAR_12->w_cursor.lnum\n\t\t && VAR_2 + (VAR_3 < 0 ? -VAR_3 : VAR_3) > VAR_12->w_cursor.lnum)\n\tVAR_27.lnum = 0;\n}",
    "func_graph_path": "vim/7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97/change.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -90,6 +90,9 @@\n \tcurwin->w_changelistidx = curbuf->b_changelistlen;\n     }\n \n+    if (VIsual_active)\n+\tcheck_visual_pos();\n+\n     FOR_ALL_TAB_WINDOWS(tp, wp)\n     {\n \tif (wp->w_buffer == curbuf)",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "    if (VIsual_active)",
            "\tcheck_visual_pos();",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}