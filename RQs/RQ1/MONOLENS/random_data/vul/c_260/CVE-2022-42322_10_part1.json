{
    "cve_id": "CVE-2022-42322",
    "cwe_ids": [
        "CWE-401"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "xen-project/xen",
    "commit_msg": "tools/xenstore: remove nodes owned by destroyed domain\n\nIn case a domain is removed from Xenstore, remove all nodes owned by\nit per default.\n\nThis tackles the problem that nodes might be created by a domain\noutside its home path in Xenstore, leading to Xenstore hogging more\nand more memory. Domain quota don't work in this case if the guest is\nrebooting in between.\n\nSince XSA-322 ownership of such stale nodes is transferred to dom0,\nwhich is helping against unintended access, but not against OOM of\nXenstore.\n\nAs a fallback for weird cases add a Xenstore start parameter for\nkeeping today's way to handle stale nodes, adding the risk of Xenstore\nhitting an OOM situation.\n\nThis is part of XSA-419 / CVE-2022-42322.\n\nFixes: 496306324d8d (\"tools/xenstore: revoke access rights for removed domains\")\nSigned-off-by: Juergen Gross <jgross@suse.com>\nReviewed-by: Julien Grall <jgrall@amazon.com>",
    "commit_hash": "755d3f9debf8879448211fffb018f556136f6a79",
    "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
    "file_path": "tools/xenstore/xenstored_core.c",
    "func_name": "read_node",
    "func_before": "struct node *read_node(struct connection *conn, const void *ctx,\n\t\t       const char *name)\n{\n\tTDB_DATA key, data;\n\tstruct xs_tdb_record_hdr *hdr;\n\tstruct node *node;\n\tint err;\n\n\tnode = talloc(ctx, struct node);\n\tif (!node) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tnode->name = talloc_strdup(node, name);\n\tif (!node->name) {\n\t\ttalloc_free(node);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tif (transaction_prepend(conn, name, &key))\n\t\treturn NULL;\n\n\tdata = tdb_fetch(tdb_ctx, key);\n\n\tif (data.dptr == NULL) {\n\t\tif (tdb_error(tdb_ctx) == TDB_ERR_NOEXIST) {\n\t\t\tnode->generation = NO_GENERATION;\n\t\t\terr = access_node(conn, node, NODE_ACCESS_READ, NULL);\n\t\t\terrno = err ? : ENOENT;\n\t\t} else {\n\t\t\tlog(\"TDB error on read: %s\", tdb_errorstr(tdb_ctx));\n\t\t\terrno = EIO;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tnode->parent = NULL;\n\ttalloc_steal(node, data.dptr);\n\n\t/* Datalen, childlen, number of permissions */\n\thdr = (void *)data.dptr;\n\tnode->generation = hdr->generation;\n\tnode->perms.num = hdr->num_perms;\n\tnode->datalen = hdr->datalen;\n\tnode->childlen = hdr->childlen;\n\n\t/* Permissions are struct xs_permissions. */\n\tnode->perms.p = hdr->perms;\n\tnode->acc.domid = node->perms.p[0].id;\n\tnode->acc.memory = data.dsize;\n\tif (domain_adjust_node_perms(conn, node))\n\t\tgoto error;\n\n\t/* If owner is gone reset currently accounted memory size. */\n\tif (node->acc.domid != node->perms.p[0].id)\n\t\tnode->acc.memory = 0;\n\n\t/* Data is binary blob (usually ascii, no nul). */\n\tnode->data = node->perms.p + hdr->num_perms;\n\t/* Children is strings, nul separated. */\n\tnode->children = node->data + node->datalen;\n\n\tif (access_node(conn, node, NODE_ACCESS_READ, NULL))\n\t\tgoto error;\n\n\treturn node;\n\n error:\n\terr = errno;\n\ttalloc_free(node);\n\terrno = err;\n\treturn NULL;\n}",
    "abstract_func_before": "struct node *read_node(struct connection *VAR_0, const void *VAR_1,\n\t\t       const char *VAR_2)\n{\n\tTDB_DATA VAR_3, VAR_4;\n\tstruct xs_tdb_record_hdr *VAR_5;\n\tstruct node *node;\n\tint VAR_6;\n\n\tnode = talloc(VAR_1, struct node);\n\tif (!node) {\n\t\tVAR_7 = VAR_8;\n\t\treturn NULL;\n\t}\n\tnode->name = talloc_strdup(node, VAR_2);\n\tif (!node->name) {\n\t\ttalloc_free(node);\n\t\tVAR_7 = VAR_8;\n\t\treturn NULL;\n\t}\n\n\tif (transaction_prepend(VAR_0, VAR_2, &VAR_3))\n\t\treturn NULL;\n\n\tVAR_4 = tdb_fetch(VAR_9, VAR_3);\n\n\tif (VAR_4.dptr == NULL) {\n\t\tif (tdb_error(VAR_9) == VAR_10) {\n\t\t\tnode->generation = VAR_11;\n\t\t\tVAR_6 = access_node(VAR_0, node, VAR_12, NULL);\n\t\t\tVAR_7 = VAR_6 ?VAR_13 : VAR_14;\n\t\t} else {\n\t\t\tlog(\"TDB error on read: %s\", tdb_errorstr(VAR_9));\n\t\t\tVAR_7 = VAR_15;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tnode->parent = NULL;\n\ttalloc_steal(node, VAR_4.dptr);\n\n\t/* COMMENT_0 */\n\tVAR_5 = (void *)VAR_4.dptr;\n\tnode->generation = VAR_5->generation;\n\tnode->perms.num = VAR_5->num_perms;\n\tnode->datalen = VAR_5->datalen;\n\tnode->childlen = VAR_5->childlen;\n\n\t/* COMMENT_1 */\n\tnode->perms.p = VAR_5->perms;\n\tnode->acc.domid = node->perms.p[0].id;\n\tnode->acc.memory = VAR_4.dsize;\n\tif (domain_adjust_node_perms(VAR_0, node))\n\t\tgoto error;\n\n\t/* COMMENT_2 */\n\tif (node->acc.domid != node->perms.p[0].id)\n\t\tnode->acc.memory = 0;\n\n\t/* COMMENT_3 */\n\tnode->data = node->perms.p + VAR_5->num_perms;\n\t/* COMMENT_4 */\n\tnode->children = node->data + node->datalen;\n\n\tif (access_node(VAR_0, node, VAR_12, NULL))\n\t\tgoto error;\n\n\treturn node;\n\n error:\n\tVAR_6 = VAR_7;\n\ttalloc_free(node);\n\tVAR_7 = VAR_6;\n\treturn NULL;\n}",
    "func_graph_path_before": "xen-project/xen/755d3f9debf8879448211fffb018f556136f6a79/xenstored_core.c/vul/before/3.json",
    "func": "struct node *read_node(struct connection *conn, const void *ctx,\n\t\t       const char *name)\n{\n\tTDB_DATA key, data;\n\tstruct xs_tdb_record_hdr *hdr;\n\tstruct node *node;\n\tint err;\n\n\tnode = talloc(ctx, struct node);\n\tif (!node) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tnode->name = talloc_strdup(node, name);\n\tif (!node->name) {\n\t\ttalloc_free(node);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tif (transaction_prepend(conn, name, &key))\n\t\treturn NULL;\n\n\tdata = tdb_fetch(tdb_ctx, key);\n\n\tif (data.dptr == NULL) {\n\t\tif (tdb_error(tdb_ctx) == TDB_ERR_NOEXIST) {\n\t\t\tnode->generation = NO_GENERATION;\n\t\t\terr = access_node(conn, node, NODE_ACCESS_READ, NULL);\n\t\t\terrno = err ? : ENOENT;\n\t\t} else {\n\t\t\tlog(\"TDB error on read: %s\", tdb_errorstr(tdb_ctx));\n\t\t\terrno = EIO;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tnode->parent = NULL;\n\ttalloc_steal(node, data.dptr);\n\n\t/* Datalen, childlen, number of permissions */\n\thdr = (void *)data.dptr;\n\tnode->generation = hdr->generation;\n\tnode->perms.num = hdr->num_perms;\n\tnode->datalen = hdr->datalen;\n\tnode->childlen = hdr->childlen;\n\n\t/* Permissions are struct xs_permissions. */\n\tnode->perms.p = hdr->perms;\n\tnode->acc.domid = node->perms.p[0].id;\n\tnode->acc.memory = data.dsize;\n\tif (domain_adjust_node_perms(node))\n\t\tgoto error;\n\n\t/* If owner is gone reset currently accounted memory size. */\n\tif (node->acc.domid != node->perms.p[0].id)\n\t\tnode->acc.memory = 0;\n\n\t/* Data is binary blob (usually ascii, no nul). */\n\tnode->data = node->perms.p + hdr->num_perms;\n\t/* Children is strings, nul separated. */\n\tnode->children = node->data + node->datalen;\n\n\tif (access_node(conn, node, NODE_ACCESS_READ, NULL))\n\t\tgoto error;\n\n\treturn node;\n\n error:\n\terr = errno;\n\ttalloc_free(node);\n\terrno = err;\n\treturn NULL;\n}",
    "abstract_func": "struct node *read_node(struct connection *VAR_0, const void *VAR_1,\n\t\t       const char *VAR_2)\n{\n\tTDB_DATA VAR_3, VAR_4;\n\tstruct xs_tdb_record_hdr *VAR_5;\n\tstruct node *node;\n\tint VAR_6;\n\n\tnode = talloc(VAR_1, struct node);\n\tif (!node) {\n\t\tVAR_7 = VAR_8;\n\t\treturn NULL;\n\t}\n\tnode->name = talloc_strdup(node, VAR_2);\n\tif (!node->name) {\n\t\ttalloc_free(node);\n\t\tVAR_7 = VAR_8;\n\t\treturn NULL;\n\t}\n\n\tif (transaction_prepend(VAR_0, VAR_2, &VAR_3))\n\t\treturn NULL;\n\n\tVAR_4 = tdb_fetch(VAR_9, VAR_3);\n\n\tif (VAR_4.dptr == NULL) {\n\t\tif (tdb_error(VAR_9) == VAR_10) {\n\t\t\tnode->generation = VAR_11;\n\t\t\tVAR_6 = access_node(VAR_0, node, VAR_12, NULL);\n\t\t\tVAR_7 = VAR_6 ?VAR_13 : VAR_14;\n\t\t} else {\n\t\t\tlog(\"TDB error on read: %s\", tdb_errorstr(VAR_9));\n\t\t\tVAR_7 = VAR_15;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tnode->parent = NULL;\n\ttalloc_steal(node, VAR_4.dptr);\n\n\t/* COMMENT_0 */\n\tVAR_5 = (void *)VAR_4.dptr;\n\tnode->generation = VAR_5->generation;\n\tnode->perms.num = VAR_5->num_perms;\n\tnode->datalen = VAR_5->datalen;\n\tnode->childlen = VAR_5->childlen;\n\n\t/* COMMENT_1 */\n\tnode->perms.p = VAR_5->perms;\n\tnode->acc.domid = node->perms.p[0].id;\n\tnode->acc.memory = VAR_4.dsize;\n\tif (domain_adjust_node_perms(node))\n\t\tgoto error;\n\n\t/* COMMENT_2 */\n\tif (node->acc.domid != node->perms.p[0].id)\n\t\tnode->acc.memory = 0;\n\n\t/* COMMENT_3 */\n\tnode->data = node->perms.p + VAR_5->num_perms;\n\t/* COMMENT_4 */\n\tnode->children = node->data + node->datalen;\n\n\tif (access_node(VAR_0, node, VAR_12, NULL))\n\t\tgoto error;\n\n\treturn node;\n\n error:\n\tVAR_6 = VAR_7;\n\ttalloc_free(node);\n\tVAR_7 = VAR_6;\n\treturn NULL;\n}",
    "func_graph_path": "xen-project/xen/755d3f9debf8879448211fffb018f556136f6a79/xenstored_core.c/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n \tnode->perms.p = hdr->perms;\n \tnode->acc.domid = node->perms.p[0].id;\n \tnode->acc.memory = data.dsize;\n-\tif (domain_adjust_node_perms(conn, node))\n+\tif (domain_adjust_node_perms(node))\n \t\tgoto error;\n \n \t/* If owner is gone reset currently accounted memory size. */",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (domain_adjust_node_perms(conn, node))"
        ],
        "added_lines": [
            "\tif (domain_adjust_node_perms(node))"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}