{
    "cve_id": "CVE-2018-1000085",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "Cisco-Talos/clamav",
    "commit_msg": "bb11588 - fix out of bounds read.",
    "commit_hash": "d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6",
    "git_url": "https://github.com/Cisco-Talos/clamav/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6",
    "file_path": "libclamav/xar.c",
    "func_name": "cli_scanxar",
    "func_before": "int cli_scanxar(cli_ctx *ctx)\n{\n    int rc = CL_SUCCESS;\n    unsigned int cksum_fails = 0;\n    unsigned int extract_errors = 0;\n#if HAVE_LIBXML2\n    int fd = -1;\n    struct xar_header hdr;\n    fmap_t *map = *ctx->fmap;\n    long length, offset, size, at;\n    int encoding;\n    z_stream strm;\n    char *toc, *tmpname;\n    xmlTextReaderPtr reader = NULL;\n    int a_hash, e_hash;\n    unsigned char *a_cksum = NULL, *e_cksum = NULL;\n    void *a_hash_ctx = NULL, *e_hash_ctx = NULL;\n    char result[SHA1_HASH_SIZE];\n\n    memset(&strm, 0x00, sizeof(z_stream));\n\n    /* retrieve xar header */\n    if (fmap_readn(*ctx->fmap, &hdr, 0, sizeof(hdr)) != sizeof(hdr)) {\n        cli_dbgmsg(\"cli_scanxar: Invalid header, too short.\\n\");\n        return CL_EFORMAT;\n    }\n    hdr.magic = be32_to_host(hdr.magic);\n\n    if (hdr.magic == XAR_HEADER_MAGIC) {\n        cli_dbgmsg(\"cli_scanxar: Matched magic\\n\");\n    }\n    else {\n        cli_dbgmsg(\"cli_scanxar: Invalid magic\\n\");\n        return CL_EFORMAT;\n    }\n    hdr.size = be16_to_host(hdr.size);\n    hdr.version = be16_to_host(hdr.version);\n    hdr.toc_length_compressed = be64_to_host(hdr.toc_length_compressed);\n    hdr.toc_length_decompressed = be64_to_host(hdr.toc_length_decompressed);\n    hdr.chksum_alg = be32_to_host(hdr.chksum_alg);\n\n    /* cli_dbgmsg(\"hdr.magic %x\\n\", hdr.magic); */\n    /* cli_dbgmsg(\"hdr.size %i\\n\", hdr.size); */\n    /* cli_dbgmsg(\"hdr.version %i\\n\", hdr.version); */\n    /* cli_dbgmsg(\"hdr.toc_length_compressed %lu\\n\", hdr.toc_length_compressed); */\n    /* cli_dbgmsg(\"hdr.toc_length_decompressed %lu\\n\", hdr.toc_length_decompressed); */\n    /* cli_dbgmsg(\"hdr.chksum_alg %i\\n\", hdr.chksum_alg); */\n \n    /* Uncompress TOC */\n    strm.next_in = (unsigned char *)fmap_need_off_once(*ctx->fmap, hdr.size, hdr.toc_length_compressed);\n    if (strm.next_in == NULL) {\n        cli_dbgmsg(\"cli_scanxar: fmap_need_off_once fails on TOC.\\n\");\n        return CL_EREAD;\n    }\n    strm.avail_in = hdr.toc_length_compressed; \n    toc = cli_malloc(hdr.toc_length_decompressed+1);\n    if (toc == NULL) {\n        cli_dbgmsg(\"cli_scanxar: cli_malloc fails on TOC decompress buffer.\\n\");\n        return CL_EMEM;\n    }\n    toc[hdr.toc_length_decompressed] = '\\0';\n    strm.avail_out = hdr.toc_length_decompressed;\n    strm.next_out = (unsigned char *)toc;\n    rc = inflateInit(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateInit error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }    \n    rc = inflate(&strm, Z_SYNC_FLUSH);\n    if (rc != Z_OK && rc != Z_STREAM_END) {\n        cli_dbgmsg(\"cli_scanxar:inflate error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n    rc = inflateEnd(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n\n    /* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); */\n    /* printf(\"cli_scanxar: TOC end:\\n\"); */\n\n    /* scan the xml */\n    cli_dbgmsg(\"cli_scanxar: scanning xar TOC xml in memory.\\n\"); \n    rc = cli_mem_scandesc(toc, hdr.toc_length_decompressed, ctx);\n    if (rc != CL_SUCCESS) {\n        if (rc != CL_VIRUS || !SCAN_ALL)\n            goto exit_toc;        \n    }\n\n    /* make a file to leave if --leave-temps in effect */\n    if(ctx->engine->keeptmp) {\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't create temporary file for TOC.\\n\");\n            goto exit_toc;\n        }\n        if (cli_writen(fd, toc, hdr.toc_length_decompressed) < 0) {\n            cli_dbgmsg(\"cli_scanxar: cli_writen error writing TOC.\\n\");\n            rc = CL_EWRITE;\n            xar_cleanup_temp_file(ctx, fd, tmpname);\n            goto exit_toc;\n        }\n        rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n        if (rc != CL_SUCCESS)\n            goto exit_toc;\n    }\n\n    reader = xmlReaderForMemory(toc, hdr.toc_length_decompressed, \"noname.xml\", NULL, CLAMAV_MIN_XMLREADER_FLAGS);\n    if (reader == NULL) {\n        cli_dbgmsg(\"cli_scanxar: xmlReaderForMemory error for TOC\\n\");\n        goto exit_toc;\n    }\n\n    rc = xar_scan_subdocuments(reader, ctx);\n    if (rc != CL_SUCCESS) {\n        cli_dbgmsg(\"xar_scan_subdocuments returns %i.\\n\", rc);\n        goto exit_reader;\n    }\n\n    /* Walk the TOC XML and extract files */\n    fd = -1;\n    tmpname = NULL;\n    while (CL_SUCCESS == (rc = xar_get_toc_data_values(reader, &length, &offset, &size, &encoding,\n                                                       &a_cksum, &a_hash, &e_cksum, &e_hash))) {\n        int do_extract_cksum = 1;\n        unsigned char * blockp;\n        void *a_sc, *e_sc;\n        void *a_mc, *e_mc;\n        char * expected;\n\n        /* clean up temp file from previous loop iteration */\n        if (fd > -1 && tmpname) {\n            rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n            if (rc != CL_SUCCESS)\n                goto exit_reader;\n        }\n\n        at = offset + hdr.toc_length_compressed + hdr.size;\n\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %li,\\n\"\n                   \"from xar heap offset %li length %li\\n\",\n                   tmpname, size, offset, length);\n\n\n        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);\n        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);\n\n        switch (encoding) {\n        case CL_TYPE_GZ:\n            /* inflate gzip directly because file segments do not contain magic */\n            memset(&strm, 0, sizeof(strm));\n            if ((rc = inflateInit(&strm)) != Z_OK) {\n                cli_dbgmsg(\"cli_scanxar: InflateInit failed: %d\\n\", rc);\n                rc = CL_EFORMAT;\n                extract_errors++;\n                break;\n            }\n            \n            while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {\n                unsigned long avail_in;\n                void * next_in;\n                unsigned int bytes = MIN(map->len - at, map->pgsz);\n                bytes = MIN(length, bytes);\n                if(!(strm.next_in = next_in = (void*)fmap_need_off_once(map, at, bytes))) {\n                    cli_dbgmsg(\"cli_scanxar: Can't read %u bytes @ %lu.\\n\", bytes, (long unsigned)at);\n                    inflateEnd(&strm);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                at += bytes;\n                strm.avail_in = avail_in = bytes;\n                do {\n                    int inf, outsize = 0;\n                    unsigned char buff[FILEBUFF];\n                    strm.avail_out = sizeof(buff);\n                    strm.next_out = buff;\n                    inf = inflate(&strm, Z_SYNC_FLUSH);\n                    if (inf != Z_OK && inf != Z_STREAM_END && inf != Z_BUF_ERROR) {\n                        cli_dbgmsg(\"cli_scanxar: inflate error %i %s.\\n\", inf, strm.msg?strm.msg:\"\");\n                        rc = CL_EFORMAT;\n                        extract_errors++;\n                        break;\n                    }\n\n                    bytes = sizeof(buff) - strm.avail_out;\n\n                    if (e_hash_ctx != NULL)\n                        xar_hash_update(e_hash_ctx, buff, bytes, e_hash);\n                   \n                    if (cli_writen(fd, buff, bytes) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error file %s.\\n\", tmpname);\n                        inflateEnd(&strm);\n                        rc = CL_EWRITE;\n                        goto exit_tmpfile;\n                    }\n                    outsize += sizeof(buff) - strm.avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", ctx, outsize, 0, 0) != CL_CLEAN) {\n                        break;\n                    }\n                    if (inf == Z_STREAM_END) {\n                        break;\n                    }\n                } while (strm.avail_out == 0);\n\n                if (rc != CL_SUCCESS)\n                    break;\n\n                avail_in -= strm.avail_in;\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, next_in, avail_in, a_hash);\n            }\n\n            inflateEnd(&strm);\n            break;\n        case CL_TYPE_7Z:\n#define CLI_LZMA_OBUF_SIZE 1024*1024\n#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8\n#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n            {\n                struct CLI_LZMA lz;\n                unsigned long in_remaining = length;\n                unsigned long out_size = 0;\n                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                int lret;\n                \n                memset(&lz, 0, sizeof(lz));\n                if (buff == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    rc = CL_EMEM;\n                    goto exit_tmpfile;\n                    \n                }\n\n                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);\n                if (blockp == NULL) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               length, at, errbuff);\n                    rc = CL_EREAD;\n                    __lzma_wrap_free(NULL, buff);\n                    goto exit_tmpfile;\n                }\n\n                lz.next_in = blockp;\n                lz.avail_in = CLI_LZMA_HDR_SIZE;\n\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, CLI_LZMA_HDR_SIZE, a_hash);\n\n                lret = cli_LzmaInit(&lz, 0);\n                if (lret != LZMA_RESULT_OK) {\n                    cli_dbgmsg(\"cli_scanxar: cli_LzmaInit() fails: %i.\\n\", lret);\n                    rc = CL_EFORMAT;\n                    __lzma_wrap_free(NULL, buff);\n                    extract_errors++;\n                    break;\n                }\n\n                at += CLI_LZMA_HDR_SIZE;\n                in_remaining -= CLI_LZMA_HDR_SIZE;\n                while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {\n                    SizeT avail_in;\n                    SizeT avail_out;\n                    void * next_in;\n                    unsigned long in_consumed;\n\n                    lz.next_out = buff;\n                    lz.avail_out = CLI_LZMA_OBUF_SIZE;\n                    lz.avail_in = avail_in = MIN(CLI_LZMA_IBUF_SIZE, in_remaining);\n                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);\n                    if (lz.next_in == NULL) {\n                        char errbuff[128];\n                        cli_strerror(errno, errbuff, sizeof(errbuff));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   length, at, errbuff);\n                        rc = CL_EREAD;\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        goto exit_tmpfile;\n                    }\n\n                    lret = cli_LzmaDecode(&lz);\n                    if (lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END) {\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() fails: %i.\\n\", lret);\n                        rc = CL_EFORMAT;\n                        extract_errors++;\n                        break;\n                    }\n\n                    in_consumed = avail_in - lz.avail_in;\n                    in_remaining -= in_consumed;\n                    at += in_consumed;\n                    avail_out = CLI_LZMA_OBUF_SIZE - lz.avail_out;\n                    \n                    if (avail_out == 0)\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() produces no output for \"\n                                   \"avail_in %llu, avail_out %llu.\\n\",\n                                   (long long unsigned)avail_in, (long long unsigned)avail_out);\n\n                    if (a_hash_ctx != NULL)\n                        xar_hash_update(a_hash_ctx, next_in, in_consumed, a_hash);                    \n                    if (e_hash_ctx != NULL)\n                        xar_hash_update(e_hash_ctx, buff, avail_out, e_hash);\n\n                    /* Write a decompressed block. */\n                    /* cli_dbgmsg(\"Writing %li bytes to LZMA decompress temp file, \" */\n                    /*            \"consumed %li of %li available compressed bytes.\\n\", */\n                    /*            avail_out, in_consumed, avail_in); */\n\n                    if (cli_writen(fd, buff, avail_out) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\\n\",\n                                   (long long unsigned)avail_out);\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        rc = CL_EWRITE;\n                        goto exit_tmpfile;\n                    }\n\n                    /* Check file size limitation. */\n                    out_size += avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", ctx, out_size, 0, 0) != CL_CLEAN) {\n                        break;\n                    }\n\n                    if (lret == LZMA_STREAM_END)\n                        break;\n                }\n\n                cli_LzmaShutdown(&lz);\n                __lzma_wrap_free(NULL, buff);\n            }\n            break; \n        case CL_TYPE_ANY:\n        default:\n        case CL_TYPE_BZ:\n        case CL_TYPE_XZ:\n            /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */\n            do_extract_cksum = 0;\n            {\n                unsigned long write_len;\n                \n                if (ctx->engine->maxfilesize)\n                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);\n                else\n                    write_len = length;\n                    \n                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               length, at, errbuff);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                \n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);\n                \n                if (cli_writen(fd, blockp, write_len) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %li bytes @ %li.\\n\", length, at);\n                    rc = CL_EWRITE;\n                    goto exit_tmpfile;\n                }\n                /*break;*/\n            }          \n        }\n\n        if (rc == CL_SUCCESS) {\n            if (a_hash_ctx != NULL) {\n                xar_hash_final(a_hash_ctx, result, a_hash);\n                a_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: archived-checksum missing.\\n\");\n                cksum_fails++;\n            }\n            if (a_cksum != NULL) {\n                expected = cli_hex2str((char *)a_cksum);\n                if (xar_hash_check(a_hash, result, expected) != 0) {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum mismatch.\\n\");\n                    cksum_fails++;\n                } else {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum matched.\\n\");                \n                }\n                free(expected);\n            }\n\n            if (e_hash_ctx != NULL) {\n                xar_hash_final(e_hash_ctx, result, e_hash);\n                e_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: extracted-checksum(unarchived-checksum) missing.\\n\");\n                cksum_fails++;\n            }\n            if (e_cksum != NULL) {\n                if (do_extract_cksum) {\n                    expected = cli_hex2str((char *)e_cksum);\n                    if (xar_hash_check(e_hash, result, expected) != 0) {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum mismatch.\\n\");\n                        cksum_fails++;\n                    } else {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum matched.\\n\");                \n                    }\n                    free(expected);\n                }\n            }\n        \n            rc = cli_magic_scandesc(fd, ctx);\n            if (rc != CL_SUCCESS) {\n                if (rc == CL_VIRUS) {\n                    cli_dbgmsg(\"cli_scanxar: Infected with %s\\n\", cli_get_last_virus(ctx));\n                    if (!SCAN_ALL)\n                        goto exit_tmpfile;\n                } else if (rc != CL_BREAK) {\n                    cli_dbgmsg(\"cli_scanxar: cli_magic_scandesc error %i\\n\", rc);\n                    goto exit_tmpfile;\n                }\n            }\n        }\n        \n        if (a_cksum != NULL) {\n            xmlFree(a_cksum);\n            a_cksum = NULL;\n        }\n        if (e_cksum != NULL) {\n            xmlFree(e_cksum);\n            e_cksum = NULL;\n        }\n    }\n\n exit_tmpfile:\n    xar_cleanup_temp_file(ctx, fd, tmpname);\n    if (a_hash_ctx != NULL)\n        xar_hash_final(a_hash_ctx, result, a_hash);\n    if (e_hash_ctx != NULL)\n        xar_hash_final(e_hash_ctx, result, e_hash);\n \n exit_reader:\n    if (a_cksum != NULL)\n        xmlFree(a_cksum);   \n    if (e_cksum != NULL)\n        xmlFree(e_cksum);\n    xmlTextReaderClose(reader);\n    xmlFreeTextReader(reader);\n\n exit_toc:\n    free(toc);\n    if (rc == CL_BREAK)\n        rc = CL_SUCCESS;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (cksum_fails + extract_errors != 0) {\n        cli_warnmsg(\"cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n\",\n                    cksum_fails, extract_errors);\n    }\n\n    return rc;\n}",
    "abstract_func_before": "int cli_scanxar(cli_ctx *VAR_0)\n{\n    int VAR_1 = VAR_2;\n    unsigned int VAR_3 = 0;\n    unsigned int VAR_4 = 0;\n#if VAR_5\n    int VAR_6 = -1;\n    struct xar_header VAR_7;\n    fmap_t *VAR_8 = *VAR_0->fmap;\n    long VAR_9, VAR_10, VAR_11, VAR_12;\n    int VAR_13;\n    z_stream VAR_14;\n    char *VAR_15, *VAR_16;\n    xmlTextReaderPtr VAR_17 = NULL;\n    int VAR_18, VAR_19;\n    unsigned char *VAR_20 = NULL, *VAR_21 = NULL;\n    void *VAR_22 = NULL, *VAR_23 = NULL;\n    char VAR_24[VAR_25];\n\n    memset(&VAR_14, 0x00, sizeof(z_stream));\n\n    /* COMMENT_0 */\n    if (fmap_readn(*VAR_0->fmap, &VAR_7, 0, sizeof(VAR_7)) != sizeof(VAR_7)) {\n        cli_dbgmsg(\"cli_scanxar: Invalid header, too short.\\n\");\n        return VAR_26;\n    }\n    VAR_7.magic = be32_to_host(VAR_7.magic);\n\n    if (VAR_7.magic == VAR_27) {\n        cli_dbgmsg(\"cli_scanxar: Matched magic\\n\");\n    }\n    else {\n        cli_dbgmsg(\"cli_scanxar: Invalid magic\\n\");\n        return VAR_26;\n    }\n    VAR_7.size = be16_to_host(VAR_7.size);\n    VAR_7.version = be16_to_host(VAR_7.version);\n    VAR_7.toc_length_compressed = be64_to_host(VAR_7.toc_length_compressed);\n    VAR_7.toc_length_decompressed = be64_to_host(VAR_7.toc_length_decompressed);\n    VAR_7.chksum_alg = be32_to_host(VAR_7.chksum_alg);\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n \n    /* COMMENT_7 */\n    VAR_14.next_in = (unsigned char *)fmap_need_off_once(*VAR_0->fmap, VAR_7.size, VAR_7.toc_length_compressed);\n    if (VAR_14.next_in == NULL) {\n        cli_dbgmsg(\"cli_scanxar: fmap_need_off_once fails on TOC.\\n\");\n        return VAR_28;\n    }\n    VAR_14.avail_in = VAR_7.toc_length_compressed; \n    VAR_15 = cli_malloc(VAR_7.toc_length_decompressed+1);\n    if (VAR_15 == NULL) {\n        cli_dbgmsg(\"cli_scanxar: cli_malloc fails on TOC decompress buffer.\\n\");\n        return VAR_29;\n    }\n    VAR_15[VAR_7.toc_length_decompressed] = '\\0';\n    VAR_14.avail_out = VAR_7.toc_length_decompressed;\n    VAR_14.next_out = (unsigned char *)VAR_15;\n    VAR_1 = inflateInit(&VAR_14);\n    if (VAR_1 != VAR_30) {\n        cli_dbgmsg(\"cli_scanxar:inflateInit error %i \\n\", VAR_1);\n        VAR_1 = VAR_26;\n        goto exit_toc;\n    }    \n    VAR_1 = inflate(&VAR_14, VAR_31);\n    if (VAR_1 != VAR_30 && VAR_1 != VAR_32) {\n        cli_dbgmsg(\"cli_scanxar:inflate error %i \\n\", VAR_1);\n        VAR_1 = VAR_26;\n        goto exit_toc;\n    }\n    VAR_1 = inflateEnd(&VAR_14);\n    if (VAR_1 != VAR_30) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", VAR_1);\n        VAR_1 = VAR_26;\n        goto exit_toc;\n    }\n\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n\n    /* COMMENT_12 */\n    cli_dbgmsg(\"cli_scanxar: scanning xar TOC xml in memory.\\n\"); \n    VAR_1 = cli_mem_scandesc(VAR_15, VAR_7.toc_length_decompressed, VAR_0);\n    if (VAR_1 != VAR_2) {\n        if (VAR_1 != VAR_33 || !VAR_34)\n            goto exit_toc;        \n    }\n\n    /* COMMENT_13 */\n    if(VAR_0->engine->keeptmp) {\n        if ((VAR_1 = cli_gentempfd(VAR_0->engine->tmpdir, &VAR_16, &VAR_6)) != VAR_2) {\n            cli_dbgmsg(\"cli_scanxar: Can't create temporary file for TOC.\\n\");\n            goto exit_toc;\n        }\n        if (cli_writen(VAR_6, VAR_15, VAR_7.toc_length_decompressed) < 0) {\n            cli_dbgmsg(\"cli_scanxar: cli_writen error writing TOC.\\n\");\n            VAR_1 = VAR_35;\n            xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);\n            goto exit_toc;\n        }\n        VAR_1 = xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);\n        if (VAR_1 != VAR_2)\n            goto exit_toc;\n    }\n\n    VAR_17 = xmlReaderForMemory(VAR_15, VAR_7.toc_length_decompressed, \"noname.xml\", NULL, VAR_36);\n    if (VAR_17 == NULL) {\n        cli_dbgmsg(\"cli_scanxar: xmlReaderForMemory error for TOC\\n\");\n        goto exit_toc;\n    }\n\n    VAR_1 = xar_scan_subdocuments(VAR_17, VAR_0);\n    if (VAR_1 != VAR_2) {\n        cli_dbgmsg(\"xar_scan_subdocuments returns %i.\\n\", VAR_1);\n        goto exit_reader;\n    }\n\n    /* COMMENT_14 */\n    VAR_6 = -1;\n    VAR_16 = NULL;\n    while (VAR_2 == (VAR_1 = xar_get_toc_data_values(VAR_17, &VAR_9, &VAR_10, &VAR_11, &VAR_13,\n                                                       &VAR_20, &VAR_18, &VAR_21, &VAR_19))) {\n        int VAR_37 = 1;\n        unsigned char * VAR_38;\n        void *VAR_39, *VAR_40;\n        void *VAR_41, *VAR_42;\n        char * VAR_43;\n\n        /* COMMENT_15 */\n        if (VAR_6 > -1 && VAR_16) {\n            VAR_1 = xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);\n            if (VAR_1 != VAR_2)\n                goto exit_reader;\n        }\n\n        VAR_12 = VAR_10 + VAR_7.toc_length_compressed + VAR_7.size;\n\n        if ((VAR_1 = cli_gentempfd(VAR_0->engine->tmpdir, &VAR_16, &VAR_6)) != VAR_2) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %li,\\n\"\n                   \"from xar heap offset %li length %li\\n\",\n                   VAR_16, VAR_11, VAR_10, VAR_9);\n\n\n        VAR_22 = xar_hash_init(VAR_18, &VAR_39, &VAR_41);\n        VAR_23 = xar_hash_init(VAR_19, &VAR_40, &VAR_42);\n\n        switch (VAR_13) {\n        case VAR_44:\n            /* COMMENT_16 */\n            memset(&VAR_14, 0, sizeof(VAR_14));\n            if ((VAR_1 = inflateInit(&VAR_14)) != VAR_30) {\n                cli_dbgmsg(\"cli_scanxar: InflateInit failed: %d\\n\", VAR_1);\n                VAR_1 = VAR_26;\n                VAR_4++;\n                break;\n            }\n            \n            while ((size_t)VAR_12 < VAR_8->len && (unsigned long)VAR_12 < VAR_10+VAR_7.toc_length_compressed+VAR_7.size+VAR_9) {\n                unsigned long VAR_45;\n                void * VAR_46;\n                unsigned int VAR_47 = MIN(VAR_8->len - VAR_12, VAR_8->pgsz);\n                VAR_47 = MIN(VAR_9, VAR_47);\n                if(!(VAR_14.next_in = VAR_46 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_47))) {\n                    cli_dbgmsg(\"cli_scanxar: Can't read %u bytes @ %lu.\\n\", VAR_47, (long unsigned)VAR_12);\n                    inflateEnd(&VAR_14);\n                    VAR_1 = VAR_28;\n                    goto exit_tmpfile;\n                }\n                VAR_12 += VAR_47;\n                VAR_14.avail_in = VAR_45 = VAR_47;\n                do {\n                    int VAR_48, VAR_49 = 0;\n                    unsigned char VAR_50[VAR_51];\n                    VAR_14.avail_out = sizeof(VAR_50);\n                    VAR_14.next_out = VAR_50;\n                    VAR_48 = inflate(&VAR_14, VAR_31);\n                    if (VAR_48 != VAR_30 && VAR_48 != VAR_32 && VAR_48 != VAR_52) {\n                        cli_dbgmsg(\"cli_scanxar: inflate error %i %s.\\n\", VAR_48, VAR_14.msg?VAR_14.msg:\"\");\n                        VAR_1 = VAR_26;\n                        VAR_4++;\n                        break;\n                    }\n\n                    VAR_47 = sizeof(VAR_50) - VAR_14.avail_out;\n\n                    if (VAR_23 != NULL)\n                        xar_hash_update(VAR_23, VAR_50, VAR_47, VAR_19);\n                   \n                    if (cli_writen(VAR_6, VAR_50, VAR_47) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error file %s.\\n\", VAR_16);\n                        inflateEnd(&VAR_14);\n                        VAR_1 = VAR_35;\n                        goto exit_tmpfile;\n                    }\n                    VAR_49 += sizeof(VAR_50) - VAR_14.avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", VAR_0, VAR_49, 0, 0) != VAR_53) {\n                        break;\n                    }\n                    if (VAR_48 == VAR_32) {\n                        break;\n                    }\n                } while (VAR_14.avail_out == 0);\n\n                if (VAR_1 != VAR_2)\n                    break;\n\n                VAR_45 -= VAR_14.avail_in;\n                if (VAR_22 != NULL)\n                    xar_hash_update(VAR_22, VAR_46, VAR_45, VAR_18);\n            }\n\n            inflateEnd(&VAR_14);\n            break;\n        case VAR_54:\n#define VAR_55 1024*1024\n#define VAR_56 LZMA_PROPS_SIZE+8\n#define VAR_57 CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n            {\n                struct CLI_LZMA VAR_58;\n                unsigned long VAR_59 = VAR_9;\n                unsigned long VAR_60 = 0;\n                unsigned char * VAR_50 = __lzma_wrap_alloc(NULL, VAR_55);\n                int VAR_61;\n                \n                memset(&VAR_58, 0, sizeof(VAR_58));\n                if (VAR_50 == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    VAR_1 = VAR_29;\n                    goto exit_tmpfile;\n                    \n                }\n\n                VAR_38 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_56);\n                if (VAR_38 == NULL) {\n                    char VAR_62[128];\n                    cli_strerror(VAR_63, VAR_62, sizeof(VAR_62));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               VAR_9, VAR_12, VAR_62);\n                    VAR_1 = VAR_28;\n                    __lzma_wrap_free(NULL, VAR_50);\n                    goto exit_tmpfile;\n                }\n\n                VAR_58.next_in = VAR_38;\n                VAR_58.avail_in = VAR_56;\n\n                if (VAR_22 != NULL)\n                    xar_hash_update(VAR_22, VAR_38, VAR_56, VAR_18);\n\n                VAR_61 = cli_LzmaInit(&VAR_58, 0);\n                if (VAR_61 != VAR_64) {\n                    cli_dbgmsg(\"cli_scanxar: cli_LzmaInit() fails: %i.\\n\", VAR_61);\n                    VAR_1 = VAR_26;\n                    __lzma_wrap_free(NULL, VAR_50);\n                    VAR_4++;\n                    break;\n                }\n\n                VAR_12 += VAR_56;\n                VAR_59 -= VAR_56;\n                while ((size_t)VAR_12 < VAR_8->len && (unsigned long)VAR_12 < VAR_10+VAR_7.toc_length_compressed+VAR_7.size+VAR_9) {\n                    SizeT VAR_45;\n                    SizeT VAR_65;\n                    void * VAR_46;\n                    unsigned long VAR_66;\n\n                    VAR_58.next_out = VAR_50;\n                    VAR_58.avail_out = VAR_55;\n                    VAR_58.avail_in = VAR_45 = MIN(VAR_57, VAR_59);\n                    VAR_58.next_in = VAR_46 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_58.avail_in);\n                    if (VAR_58.next_in == NULL) {\n                        char VAR_62[128];\n                        cli_strerror(VAR_63, VAR_62, sizeof(VAR_62));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   VAR_9, VAR_12, VAR_62);\n                        VAR_1 = VAR_28;\n                        __lzma_wrap_free(NULL, VAR_50);\n                        cli_LzmaShutdown(&VAR_58);\n                        goto exit_tmpfile;\n                    }\n\n                    VAR_61 = cli_LzmaDecode(&VAR_58);\n                    if (VAR_61 != VAR_64 && VAR_61 != VAR_67) {\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() fails: %i.\\n\", VAR_61);\n                        VAR_1 = VAR_26;\n                        VAR_4++;\n                        break;\n                    }\n\n                    VAR_66 = VAR_45 - VAR_58.avail_in;\n                    VAR_59 -= VAR_66;\n                    VAR_12 += VAR_66;\n                    VAR_65 = VAR_55 - VAR_58.avail_out;\n                    \n                    if (VAR_65 == 0)\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() produces no output for \"\n                                   \"avail_in %llu, avail_out %llu.\\n\",\n                                   (long long unsigned)VAR_45, (long long unsigned)VAR_65);\n\n                    if (VAR_22 != NULL)\n                        xar_hash_update(VAR_22, VAR_46, VAR_66, VAR_18);                    \n                    if (VAR_23 != NULL)\n                        xar_hash_update(VAR_23, VAR_50, VAR_65, VAR_19);\n\n                    /* COMMENT_17 */\n                    /* COMMENT_18 */\n                    /* COMMENT_19 */\n                    /* COMMENT_20 */\n\n                    if (cli_writen(VAR_6, VAR_50, VAR_65) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\\n\",\n                                   (long long unsigned)VAR_65);\n                        __lzma_wrap_free(NULL, VAR_50);\n                        cli_LzmaShutdown(&VAR_58);\n                        VAR_1 = VAR_35;\n                        goto exit_tmpfile;\n                    }\n\n                    /* COMMENT_21 */\n                    VAR_60 += VAR_65;\n                    if (cli_checklimits(\"cli_scanxar\", VAR_0, VAR_60, 0, 0) != VAR_53) {\n                        break;\n                    }\n\n                    if (VAR_61 == VAR_67)\n                        break;\n                }\n\n                cli_LzmaShutdown(&VAR_58);\n                __lzma_wrap_free(NULL, VAR_50);\n            }\n            break; \n        case VAR_68:\n        default:\n        case VAR_69:\n        case VAR_70:\n            /* COMMENT_22 */\n            VAR_37 = 0;\n            {\n                unsigned long VAR_71;\n                \n                if (VAR_0->engine->maxfilesize)\n                    VAR_71 = MIN((size_t)(VAR_0->engine->maxfilesize), (size_t)VAR_9);\n                else\n                    VAR_71 = VAR_9;\n                    \n                if (!(VAR_38 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_9))) {\n                    char VAR_62[128];\n                    cli_strerror(VAR_63, VAR_62, sizeof(VAR_62));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               VAR_9, VAR_12, VAR_62);\n                    VAR_1 = VAR_28;\n                    goto exit_tmpfile;\n                }\n                \n                if (VAR_22 != NULL)\n                    xar_hash_update(VAR_22, VAR_38, VAR_9, VAR_18);\n                \n                if (cli_writen(VAR_6, VAR_38, VAR_71) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %li bytes @ %li.\\n\", VAR_9, VAR_12);\n                    VAR_1 = VAR_35;\n                    goto exit_tmpfile;\n                }\n                /* COMMENT_23 */\n            }          \n        }\n\n        if (VAR_1 == VAR_2) {\n            if (VAR_22 != NULL) {\n                xar_hash_final(VAR_22, VAR_24, VAR_18);\n                VAR_22 = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: archived-checksum missing.\\n\");\n                VAR_3++;\n            }\n            if (VAR_20 != NULL) {\n                VAR_43 = cli_hex2str((char *)VAR_20);\n                if (xar_hash_check(VAR_18, VAR_24, VAR_43) != 0) {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum mismatch.\\n\");\n                    VAR_3++;\n                } else {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum matched.\\n\");                \n                }\n                free(VAR_43);\n            }\n\n            if (VAR_23 != NULL) {\n                xar_hash_final(VAR_23, VAR_24, VAR_19);\n                VAR_23 = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: extracted-checksum(unarchived-checksum) missing.\\n\");\n                VAR_3++;\n            }\n            if (VAR_21 != NULL) {\n                if (VAR_37) {\n                    VAR_43 = cli_hex2str((char *)VAR_21);\n                    if (xar_hash_check(VAR_19, VAR_24, VAR_43) != 0) {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum mismatch.\\n\");\n                        VAR_3++;\n                    } else {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum matched.\\n\");                \n                    }\n                    free(VAR_43);\n                }\n            }\n        \n            VAR_1 = cli_magic_scandesc(VAR_6, VAR_0);\n            if (VAR_1 != VAR_2) {\n                if (VAR_1 == VAR_33) {\n                    cli_dbgmsg(\"cli_scanxar: Infected with %s\\n\", cli_get_last_virus(VAR_0));\n                    if (!VAR_34)\n                        goto exit_tmpfile;\n                } else if (VAR_1 != VAR_72) {\n                    cli_dbgmsg(\"cli_scanxar: cli_magic_scandesc error %i\\n\", VAR_1);\n                    goto exit_tmpfile;\n                }\n            }\n        }\n        \n        if (VAR_20 != NULL) {\n            xmlFree(VAR_20);\n            VAR_20 = NULL;\n        }\n        if (VAR_21 != NULL) {\n            xmlFree(VAR_21);\n            VAR_21 = NULL;\n        }\n    }\n\n exit_tmpfile:\n    xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);\n    if (VAR_22 != NULL)\n        xar_hash_final(VAR_22, VAR_24, VAR_18);\n    if (VAR_23 != NULL)\n        xar_hash_final(VAR_23, VAR_24, VAR_19);\n \n exit_reader:\n    if (VAR_20 != NULL)\n        xmlFree(VAR_20);   \n    if (VAR_21 != NULL)\n        xmlFree(VAR_21);\n    xmlTextReaderClose(VAR_17);\n    xmlFreeTextReader(VAR_17);\n\n exit_toc:\n    free(VAR_15);\n    if (VAR_1 == VAR_72)\n        VAR_1 = VAR_2;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (VAR_3 + VAR_4 != 0) {\n        cli_warnmsg(\"cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n\",\n                    VAR_3, VAR_4);\n    }\n\n    return VAR_1;\n}",
    "func_graph_path_before": "Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/before/0.json",
    "func": "int cli_scanxar(cli_ctx *ctx)\n{\n    int rc = CL_SUCCESS;\n    unsigned int cksum_fails = 0;\n    unsigned int extract_errors = 0;\n#if HAVE_LIBXML2\n    int fd = -1;\n    struct xar_header hdr;\n    fmap_t *map = *ctx->fmap;\n    size_t length, offset, size, at;\n    int encoding;\n    z_stream strm;\n    char *toc, *tmpname;\n    xmlTextReaderPtr reader = NULL;\n    int a_hash, e_hash;\n    unsigned char *a_cksum = NULL, *e_cksum = NULL;\n    void *a_hash_ctx = NULL, *e_hash_ctx = NULL;\n    char result[SHA1_HASH_SIZE];\n\n    memset(&strm, 0x00, sizeof(z_stream));\n\n    /* retrieve xar header */\n    if (fmap_readn(*ctx->fmap, &hdr, 0, sizeof(hdr)) != sizeof(hdr)) {\n        cli_dbgmsg(\"cli_scanxar: Invalid header, too short.\\n\");\n        return CL_EFORMAT;\n    }\n    hdr.magic = be32_to_host(hdr.magic);\n\n    if (hdr.magic == XAR_HEADER_MAGIC) {\n        cli_dbgmsg(\"cli_scanxar: Matched magic\\n\");\n    }\n    else {\n        cli_dbgmsg(\"cli_scanxar: Invalid magic\\n\");\n        return CL_EFORMAT;\n    }\n    hdr.size = be16_to_host(hdr.size);\n    hdr.version = be16_to_host(hdr.version);\n    hdr.toc_length_compressed = be64_to_host(hdr.toc_length_compressed);\n    hdr.toc_length_decompressed = be64_to_host(hdr.toc_length_decompressed);\n    hdr.chksum_alg = be32_to_host(hdr.chksum_alg);\n\n    /* cli_dbgmsg(\"hdr.magic %x\\n\", hdr.magic); */\n    /* cli_dbgmsg(\"hdr.size %i\\n\", hdr.size); */\n    /* cli_dbgmsg(\"hdr.version %i\\n\", hdr.version); */\n    /* cli_dbgmsg(\"hdr.toc_length_compressed %lu\\n\", hdr.toc_length_compressed); */\n    /* cli_dbgmsg(\"hdr.toc_length_decompressed %lu\\n\", hdr.toc_length_decompressed); */\n    /* cli_dbgmsg(\"hdr.chksum_alg %i\\n\", hdr.chksum_alg); */\n \n    /* Uncompress TOC */\n    strm.next_in = (unsigned char *)fmap_need_off_once(*ctx->fmap, hdr.size, hdr.toc_length_compressed);\n    if (strm.next_in == NULL) {\n        cli_dbgmsg(\"cli_scanxar: fmap_need_off_once fails on TOC.\\n\");\n        return CL_EREAD;\n    }\n    strm.avail_in = hdr.toc_length_compressed; \n    toc = cli_malloc(hdr.toc_length_decompressed+1);\n    if (toc == NULL) {\n        cli_dbgmsg(\"cli_scanxar: cli_malloc fails on TOC decompress buffer.\\n\");\n        return CL_EMEM;\n    }\n    toc[hdr.toc_length_decompressed] = '\\0';\n    strm.avail_out = hdr.toc_length_decompressed;\n    strm.next_out = (unsigned char *)toc;\n    rc = inflateInit(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateInit error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }    \n    rc = inflate(&strm, Z_SYNC_FLUSH);\n    if (rc != Z_OK && rc != Z_STREAM_END) {\n        cli_dbgmsg(\"cli_scanxar:inflate error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n    rc = inflateEnd(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n\n    if (hdr.toc_length_decompressed != strm.total_out) {\n        cli_dbgmsg(\"TOC decompress length %\" PRIu64 \" does not match amount decompressed %lu\\n\",\n                   hdr.toc_length_decompressed, strm.total_out);\n        toc[strm.total_out] = '\\0';\n        hdr.toc_length_decompressed = strm.total_out;\n    }\n\n    /* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); */\n    /* printf(\"cli_scanxar: TOC end:\\n\"); */\n\n    /* scan the xml */\n    cli_dbgmsg(\"cli_scanxar: scanning xar TOC xml in memory.\\n\"); \n    rc = cli_mem_scandesc(toc, hdr.toc_length_decompressed, ctx);\n    if (rc != CL_SUCCESS) {\n        if (rc != CL_VIRUS || !SCAN_ALL)\n            goto exit_toc;        \n    }\n\n    /* make a file to leave if --leave-temps in effect */\n    if(ctx->engine->keeptmp) {\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't create temporary file for TOC.\\n\");\n            goto exit_toc;\n        }\n        if (cli_writen(fd, toc, hdr.toc_length_decompressed) < 0) {\n            cli_dbgmsg(\"cli_scanxar: cli_writen error writing TOC.\\n\");\n            rc = CL_EWRITE;\n            xar_cleanup_temp_file(ctx, fd, tmpname);\n            goto exit_toc;\n        }\n        rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n        if (rc != CL_SUCCESS)\n            goto exit_toc;\n    }\n\n    reader = xmlReaderForMemory(toc, hdr.toc_length_decompressed, \"noname.xml\", NULL, CLAMAV_MIN_XMLREADER_FLAGS);\n    if (reader == NULL) {\n        cli_dbgmsg(\"cli_scanxar: xmlReaderForMemory error for TOC\\n\");\n        goto exit_toc;\n    }\n\n    rc = xar_scan_subdocuments(reader, ctx);\n    if (rc != CL_SUCCESS) {\n        cli_dbgmsg(\"xar_scan_subdocuments returns %i.\\n\", rc);\n        goto exit_reader;\n    }\n\n    /* Walk the TOC XML and extract files */\n    fd = -1;\n    tmpname = NULL;\n    while (CL_SUCCESS == (rc = xar_get_toc_data_values(reader, &length, &offset, &size, &encoding,\n                                                       &a_cksum, &a_hash, &e_cksum, &e_hash))) {\n        int do_extract_cksum = 1;\n        unsigned char * blockp;\n        void *a_sc, *e_sc;\n        void *a_mc, *e_mc;\n        char * expected;\n\n        /* clean up temp file from previous loop iteration */\n        if (fd > -1 && tmpname) {\n            rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n            if (rc != CL_SUCCESS)\n                goto exit_reader;\n        }\n\n        at = offset + hdr.toc_length_compressed + hdr.size;\n\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n\"\n                   \"from xar heap offset %zu length %zu\\n\",\n                   tmpname, size, offset, length);\n\n\n        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);\n        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);\n\n        switch (encoding) {\n        case CL_TYPE_GZ:\n            /* inflate gzip directly because file segments do not contain magic */\n            memset(&strm, 0, sizeof(strm));\n            if ((rc = inflateInit(&strm)) != Z_OK) {\n                cli_dbgmsg(\"cli_scanxar: InflateInit failed: %d\\n\", rc);\n                rc = CL_EFORMAT;\n                extract_errors++;\n                break;\n            }\n            \n            while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {\n                unsigned long avail_in;\n                void * next_in;\n                unsigned int bytes = MIN(map->len - at, map->pgsz);\n                bytes = MIN(length, bytes);\n                if(!(strm.next_in = next_in = (void*)fmap_need_off_once(map, at, bytes))) {\n                    cli_dbgmsg(\"cli_scanxar: Can't read %u bytes @ %lu.\\n\", bytes, (long unsigned)at);\n                    inflateEnd(&strm);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                at += bytes;\n                strm.avail_in = avail_in = bytes;\n                do {\n                    int inf, outsize = 0;\n                    unsigned char buff[FILEBUFF];\n                    strm.avail_out = sizeof(buff);\n                    strm.next_out = buff;\n                    inf = inflate(&strm, Z_SYNC_FLUSH);\n                    if (inf != Z_OK && inf != Z_STREAM_END && inf != Z_BUF_ERROR) {\n                        cli_dbgmsg(\"cli_scanxar: inflate error %i %s.\\n\", inf, strm.msg?strm.msg:\"\");\n                        rc = CL_EFORMAT;\n                        extract_errors++;\n                        break;\n                    }\n\n                    bytes = sizeof(buff) - strm.avail_out;\n\n                    if (e_hash_ctx != NULL)\n                        xar_hash_update(e_hash_ctx, buff, bytes, e_hash);\n                   \n                    if (cli_writen(fd, buff, bytes) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error file %s.\\n\", tmpname);\n                        inflateEnd(&strm);\n                        rc = CL_EWRITE;\n                        goto exit_tmpfile;\n                    }\n                    outsize += sizeof(buff) - strm.avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", ctx, outsize, 0, 0) != CL_CLEAN) {\n                        break;\n                    }\n                    if (inf == Z_STREAM_END) {\n                        break;\n                    }\n                } while (strm.avail_out == 0);\n\n                if (rc != CL_SUCCESS)\n                    break;\n\n                avail_in -= strm.avail_in;\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, next_in, avail_in, a_hash);\n            }\n\n            inflateEnd(&strm);\n            break;\n        case CL_TYPE_7Z:\n#define CLI_LZMA_OBUF_SIZE 1024*1024\n#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8\n#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n            {\n                struct CLI_LZMA lz;\n                unsigned long in_remaining = MIN(length, map->len - at);\n                unsigned long out_size = 0;\n                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                int lret;\n\n                if (length > in_remaining)\n                    length = in_remaining;\n\n                memset(&lz, 0, sizeof(lz));\n                if (buff == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    rc = CL_EMEM;\n                    goto exit_tmpfile;\n                    \n                }\n\n                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);\n                if (blockp == NULL) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %i bytes @ %li, errno:%s.\\n\",\n                               CLI_LZMA_HDR_SIZE, at, errbuff);\n                    rc = CL_EREAD;\n                    __lzma_wrap_free(NULL, buff);\n                    goto exit_tmpfile;\n                }\n\n                lz.next_in = blockp;\n                lz.avail_in = CLI_LZMA_HDR_SIZE;\n\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, CLI_LZMA_HDR_SIZE, a_hash);\n\n                lret = cli_LzmaInit(&lz, 0);\n                if (lret != LZMA_RESULT_OK) {\n                    cli_dbgmsg(\"cli_scanxar: cli_LzmaInit() fails: %i.\\n\", lret);\n                    rc = CL_EFORMAT;\n                    __lzma_wrap_free(NULL, buff);\n                    extract_errors++;\n                    break;\n                }\n\n                at += CLI_LZMA_HDR_SIZE;\n                in_remaining -= CLI_LZMA_HDR_SIZE;\n                while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {\n                    SizeT avail_in;\n                    SizeT avail_out;\n                    void * next_in;\n                    unsigned long in_consumed;\n\n                    lz.next_out = buff;\n                    lz.avail_out = CLI_LZMA_OBUF_SIZE;\n                    lz.avail_in = avail_in = MIN(CLI_LZMA_IBUF_SIZE, in_remaining);\n                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);\n                    if (lz.next_in == NULL) {\n                        char errbuff[128];\n                        cli_strerror(errno, errbuff, sizeof(errbuff));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   lz.avail_in, at, errbuff);\n                        rc = CL_EREAD;\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        goto exit_tmpfile;\n                    }\n\n                    lret = cli_LzmaDecode(&lz);\n                    if (lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END) {\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() fails: %i.\\n\", lret);\n                        rc = CL_EFORMAT;\n                        extract_errors++;\n                        break;\n                    }\n\n                    in_consumed = avail_in - lz.avail_in;\n                    in_remaining -= in_consumed;\n                    at += in_consumed;\n                    avail_out = CLI_LZMA_OBUF_SIZE - lz.avail_out;\n                    \n                    if (avail_out == 0)\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() produces no output for \"\n                                   \"avail_in %llu, avail_out %llu.\\n\",\n                                   (long long unsigned)avail_in, (long long unsigned)avail_out);\n\n                    if (a_hash_ctx != NULL)\n                        xar_hash_update(a_hash_ctx, next_in, in_consumed, a_hash);                    \n                    if (e_hash_ctx != NULL)\n                        xar_hash_update(e_hash_ctx, buff, avail_out, e_hash);\n\n                    /* Write a decompressed block. */\n                    /* cli_dbgmsg(\"Writing %li bytes to LZMA decompress temp file, \" */\n                    /*            \"consumed %li of %li available compressed bytes.\\n\", */\n                    /*            avail_out, in_consumed, avail_in); */\n\n                    if (cli_writen(fd, buff, avail_out) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\\n\",\n                                   (long long unsigned)avail_out);\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        rc = CL_EWRITE;\n                        goto exit_tmpfile;\n                    }\n\n                    /* Check file size limitation. */\n                    out_size += avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", ctx, out_size, 0, 0) != CL_CLEAN) {\n                        break;\n                    }\n\n                    if (lret == LZMA_STREAM_END)\n                        break;\n                }\n\n                cli_LzmaShutdown(&lz);\n                __lzma_wrap_free(NULL, buff);\n            }\n            break; \n        case CL_TYPE_ANY:\n        default:\n        case CL_TYPE_BZ:\n        case CL_TYPE_XZ:\n            /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */\n            do_extract_cksum = 0;\n            {\n                size_t writelen = MIN(map->len - at, length);\n\n                if (ctx->engine->maxfilesize)\n                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);\n                    \n                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\\n\",\n                               writelen, at, errbuff);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                \n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);\n                \n                if (cli_writen(fd, blockp, writelen) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %zu bytes @ %li.\\n\", writelen, at);\n                    rc = CL_EWRITE;\n                    goto exit_tmpfile;\n                }\n                /*break;*/\n            }          \n        } /* end of switch */\n\n        if (rc == CL_SUCCESS) {\n            if (a_hash_ctx != NULL) {\n                xar_hash_final(a_hash_ctx, result, a_hash);\n                a_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: archived-checksum missing.\\n\");\n                cksum_fails++;\n            }\n            if (a_cksum != NULL) {\n                expected = cli_hex2str((char *)a_cksum);\n                if (xar_hash_check(a_hash, result, expected) != 0) {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum mismatch.\\n\");\n                    cksum_fails++;\n                } else {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum matched.\\n\");                \n                }\n                free(expected);\n            }\n\n            if (e_hash_ctx != NULL) {\n                xar_hash_final(e_hash_ctx, result, e_hash);\n                e_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: extracted-checksum(unarchived-checksum) missing.\\n\");\n                cksum_fails++;\n            }\n            if (e_cksum != NULL) {\n                if (do_extract_cksum) {\n                    expected = cli_hex2str((char *)e_cksum);\n                    if (xar_hash_check(e_hash, result, expected) != 0) {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum mismatch.\\n\");\n                        cksum_fails++;\n                    } else {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum matched.\\n\");                \n                    }\n                    free(expected);\n                }\n            }\n        \n            rc = cli_magic_scandesc(fd, ctx);\n            if (rc != CL_SUCCESS) {\n                if (rc == CL_VIRUS) {\n                    cli_dbgmsg(\"cli_scanxar: Infected with %s\\n\", cli_get_last_virus(ctx));\n                    if (!SCAN_ALL)\n                        goto exit_tmpfile;\n                } else if (rc != CL_BREAK) {\n                    cli_dbgmsg(\"cli_scanxar: cli_magic_scandesc error %i\\n\", rc);\n                    goto exit_tmpfile;\n                }\n            }\n        }\n        \n        if (a_cksum != NULL) {\n            xmlFree(a_cksum);\n            a_cksum = NULL;\n        }\n        if (e_cksum != NULL) {\n            xmlFree(e_cksum);\n            e_cksum = NULL;\n        }\n    }\n\n exit_tmpfile:\n    xar_cleanup_temp_file(ctx, fd, tmpname);\n    if (a_hash_ctx != NULL)\n        xar_hash_final(a_hash_ctx, result, a_hash);\n    if (e_hash_ctx != NULL)\n        xar_hash_final(e_hash_ctx, result, e_hash);\n \n exit_reader:\n    if (a_cksum != NULL)\n        xmlFree(a_cksum);   \n    if (e_cksum != NULL)\n        xmlFree(e_cksum);\n    xmlTextReaderClose(reader);\n    xmlFreeTextReader(reader);\n\n exit_toc:\n    free(toc);\n    if (rc == CL_BREAK)\n        rc = CL_SUCCESS;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (cksum_fails + extract_errors != 0) {\n        cli_dbgmsg(\"cli_scanxar: %u checksum errors and %u extraction errors.\\n\",\n                    cksum_fails, extract_errors);\n    }\n\n    return rc;\n}",
    "abstract_func": "int cli_scanxar(cli_ctx *VAR_0)\n{\n    int VAR_1 = VAR_2;\n    unsigned int VAR_3 = 0;\n    unsigned int VAR_4 = 0;\n#if VAR_5\n    int VAR_6 = -1;\n    struct xar_header VAR_7;\n    fmap_t *VAR_8 = *VAR_0->fmap;\n    size_t VAR_9, VAR_10, VAR_11, VAR_12;\n    int VAR_13;\n    z_stream VAR_14;\n    char *VAR_15, *VAR_16;\n    xmlTextReaderPtr VAR_17 = NULL;\n    int VAR_18, VAR_19;\n    unsigned char *VAR_20 = NULL, *VAR_21 = NULL;\n    void *VAR_22 = NULL, *VAR_23 = NULL;\n    char VAR_24[VAR_25];\n\n    memset(&VAR_14, 0x00, sizeof(z_stream));\n\n    /* COMMENT_0 */\n    if (fmap_readn(*VAR_0->fmap, &VAR_7, 0, sizeof(VAR_7)) != sizeof(VAR_7)) {\n        cli_dbgmsg(\"cli_scanxar: Invalid header, too short.\\n\");\n        return VAR_26;\n    }\n    VAR_7.magic = be32_to_host(VAR_7.magic);\n\n    if (VAR_7.magic == VAR_27) {\n        cli_dbgmsg(\"cli_scanxar: Matched magic\\n\");\n    }\n    else {\n        cli_dbgmsg(\"cli_scanxar: Invalid magic\\n\");\n        return VAR_26;\n    }\n    VAR_7.size = be16_to_host(VAR_7.size);\n    VAR_7.version = be16_to_host(VAR_7.version);\n    VAR_7.toc_length_compressed = be64_to_host(VAR_7.toc_length_compressed);\n    VAR_7.toc_length_decompressed = be64_to_host(VAR_7.toc_length_decompressed);\n    VAR_7.chksum_alg = be32_to_host(VAR_7.chksum_alg);\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n \n    /* COMMENT_7 */\n    VAR_14.next_in = (unsigned char *)fmap_need_off_once(*VAR_0->fmap, VAR_7.size, VAR_7.toc_length_compressed);\n    if (VAR_14.next_in == NULL) {\n        cli_dbgmsg(\"cli_scanxar: fmap_need_off_once fails on TOC.\\n\");\n        return VAR_28;\n    }\n    VAR_14.avail_in = VAR_7.toc_length_compressed; \n    VAR_15 = cli_malloc(VAR_7.toc_length_decompressed+1);\n    if (VAR_15 == NULL) {\n        cli_dbgmsg(\"cli_scanxar: cli_malloc fails on TOC decompress buffer.\\n\");\n        return VAR_29;\n    }\n    VAR_15[VAR_7.toc_length_decompressed] = '\\0';\n    VAR_14.avail_out = VAR_7.toc_length_decompressed;\n    VAR_14.next_out = (unsigned char *)VAR_15;\n    VAR_1 = inflateInit(&VAR_14);\n    if (VAR_1 != VAR_30) {\n        cli_dbgmsg(\"cli_scanxar:inflateInit error %i \\n\", VAR_1);\n        VAR_1 = VAR_26;\n        goto exit_toc;\n    }    \n    VAR_1 = inflate(&VAR_14, VAR_31);\n    if (VAR_1 != VAR_30 && VAR_1 != VAR_32) {\n        cli_dbgmsg(\"cli_scanxar:inflate error %i \\n\", VAR_1);\n        VAR_1 = VAR_26;\n        goto exit_toc;\n    }\n    VAR_1 = inflateEnd(&VAR_14);\n    if (VAR_1 != VAR_30) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", VAR_1);\n        VAR_1 = VAR_26;\n        goto exit_toc;\n    }\n\n    if (VAR_7.toc_length_decompressed != VAR_14.total_out) {\n        cli_dbgmsg(\"TOC decompress length %\" VAR_33 \" does not match amount decompressed %lu\\n\",\n                   VAR_7.toc_length_decompressed, VAR_14.total_out);\n        VAR_15[VAR_14.total_out] = '\\0';\n        VAR_7.toc_length_decompressed = VAR_14.total_out;\n    }\n\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n\n    /* COMMENT_12 */\n    cli_dbgmsg(\"cli_scanxar: scanning xar TOC xml in memory.\\n\"); \n    VAR_1 = cli_mem_scandesc(VAR_15, VAR_7.toc_length_decompressed, VAR_0);\n    if (VAR_1 != VAR_2) {\n        if (VAR_1 != VAR_34 || !VAR_35)\n            goto exit_toc;        \n    }\n\n    /* COMMENT_13 */\n    if(VAR_0->engine->keeptmp) {\n        if ((VAR_1 = cli_gentempfd(VAR_0->engine->tmpdir, &VAR_16, &VAR_6)) != VAR_2) {\n            cli_dbgmsg(\"cli_scanxar: Can't create temporary file for TOC.\\n\");\n            goto exit_toc;\n        }\n        if (cli_writen(VAR_6, VAR_15, VAR_7.toc_length_decompressed) < 0) {\n            cli_dbgmsg(\"cli_scanxar: cli_writen error writing TOC.\\n\");\n            VAR_1 = VAR_36;\n            xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);\n            goto exit_toc;\n        }\n        VAR_1 = xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);\n        if (VAR_1 != VAR_2)\n            goto exit_toc;\n    }\n\n    VAR_17 = xmlReaderForMemory(VAR_15, VAR_7.toc_length_decompressed, \"noname.xml\", NULL, VAR_37);\n    if (VAR_17 == NULL) {\n        cli_dbgmsg(\"cli_scanxar: xmlReaderForMemory error for TOC\\n\");\n        goto exit_toc;\n    }\n\n    VAR_1 = xar_scan_subdocuments(VAR_17, VAR_0);\n    if (VAR_1 != VAR_2) {\n        cli_dbgmsg(\"xar_scan_subdocuments returns %i.\\n\", VAR_1);\n        goto exit_reader;\n    }\n\n    /* COMMENT_14 */\n    VAR_6 = -1;\n    VAR_16 = NULL;\n    while (VAR_2 == (VAR_1 = xar_get_toc_data_values(VAR_17, &VAR_9, &VAR_10, &VAR_11, &VAR_13,\n                                                       &VAR_20, &VAR_18, &VAR_21, &VAR_19))) {\n        int VAR_38 = 1;\n        unsigned char * VAR_39;\n        void *VAR_40, *VAR_41;\n        void *VAR_42, *VAR_43;\n        char * VAR_44;\n\n        /* COMMENT_15 */\n        if (VAR_6 > -1 && VAR_16) {\n            VAR_1 = xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);\n            if (VAR_1 != VAR_2)\n                goto exit_reader;\n        }\n\n        VAR_12 = VAR_10 + VAR_7.toc_length_compressed + VAR_7.size;\n\n        if ((VAR_1 = cli_gentempfd(VAR_0->engine->tmpdir, &VAR_16, &VAR_6)) != VAR_2) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n\"\n                   \"from xar heap offset %zu length %zu\\n\",\n                   VAR_16, VAR_11, VAR_10, VAR_9);\n\n\n        VAR_22 = xar_hash_init(VAR_18, &VAR_40, &VAR_42);\n        VAR_23 = xar_hash_init(VAR_19, &VAR_41, &VAR_43);\n\n        switch (VAR_13) {\n        case VAR_45:\n            /* COMMENT_16 */\n            memset(&VAR_14, 0, sizeof(VAR_14));\n            if ((VAR_1 = inflateInit(&VAR_14)) != VAR_30) {\n                cli_dbgmsg(\"cli_scanxar: InflateInit failed: %d\\n\", VAR_1);\n                VAR_1 = VAR_26;\n                VAR_4++;\n                break;\n            }\n            \n            while ((size_t)VAR_12 < VAR_8->len && (unsigned long)VAR_12 < VAR_10+VAR_7.toc_length_compressed+VAR_7.size+VAR_9) {\n                unsigned long VAR_46;\n                void * VAR_47;\n                unsigned int VAR_48 = MIN(VAR_8->len - VAR_12, VAR_8->pgsz);\n                VAR_48 = MIN(VAR_9, VAR_48);\n                if(!(VAR_14.next_in = VAR_47 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_48))) {\n                    cli_dbgmsg(\"cli_scanxar: Can't read %u bytes @ %lu.\\n\", VAR_48, (long unsigned)VAR_12);\n                    inflateEnd(&VAR_14);\n                    VAR_1 = VAR_28;\n                    goto exit_tmpfile;\n                }\n                VAR_12 += VAR_48;\n                VAR_14.avail_in = VAR_46 = VAR_48;\n                do {\n                    int VAR_49, VAR_50 = 0;\n                    unsigned char VAR_51[VAR_52];\n                    VAR_14.avail_out = sizeof(VAR_51);\n                    VAR_14.next_out = VAR_51;\n                    VAR_49 = inflate(&VAR_14, VAR_31);\n                    if (VAR_49 != VAR_30 && VAR_49 != VAR_32 && VAR_49 != VAR_53) {\n                        cli_dbgmsg(\"cli_scanxar: inflate error %i %s.\\n\", VAR_49, VAR_14.msg?VAR_14.msg:\"\");\n                        VAR_1 = VAR_26;\n                        VAR_4++;\n                        break;\n                    }\n\n                    VAR_48 = sizeof(VAR_51) - VAR_14.avail_out;\n\n                    if (VAR_23 != NULL)\n                        xar_hash_update(VAR_23, VAR_51, VAR_48, VAR_19);\n                   \n                    if (cli_writen(VAR_6, VAR_51, VAR_48) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error file %s.\\n\", VAR_16);\n                        inflateEnd(&VAR_14);\n                        VAR_1 = VAR_36;\n                        goto exit_tmpfile;\n                    }\n                    VAR_50 += sizeof(VAR_51) - VAR_14.avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", VAR_0, VAR_50, 0, 0) != VAR_54) {\n                        break;\n                    }\n                    if (VAR_49 == VAR_32) {\n                        break;\n                    }\n                } while (VAR_14.avail_out == 0);\n\n                if (VAR_1 != VAR_2)\n                    break;\n\n                VAR_46 -= VAR_14.avail_in;\n                if (VAR_22 != NULL)\n                    xar_hash_update(VAR_22, VAR_47, VAR_46, VAR_18);\n            }\n\n            inflateEnd(&VAR_14);\n            break;\n        case VAR_55:\n#define VAR_56 1024*1024\n#define VAR_57 LZMA_PROPS_SIZE+8\n#define VAR_58 CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n            {\n                struct CLI_LZMA VAR_59;\n                unsigned long VAR_60 = MIN(VAR_9, VAR_8->len - VAR_12);\n                unsigned long VAR_61 = 0;\n                unsigned char * VAR_51 = __lzma_wrap_alloc(NULL, VAR_56);\n                int VAR_62;\n\n                if (VAR_9 > VAR_60)\n                    VAR_9 = VAR_60;\n\n                memset(&VAR_59, 0, sizeof(VAR_59));\n                if (VAR_51 == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    VAR_1 = VAR_29;\n                    goto exit_tmpfile;\n                    \n                }\n\n                VAR_39 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_57);\n                if (VAR_39 == NULL) {\n                    char VAR_63[128];\n                    cli_strerror(VAR_64, VAR_63, sizeof(VAR_63));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %i bytes @ %li, errno:%s.\\n\",\n                               VAR_57, VAR_12, VAR_63);\n                    VAR_1 = VAR_28;\n                    __lzma_wrap_free(NULL, VAR_51);\n                    goto exit_tmpfile;\n                }\n\n                VAR_59.next_in = VAR_39;\n                VAR_59.avail_in = VAR_57;\n\n                if (VAR_22 != NULL)\n                    xar_hash_update(VAR_22, VAR_39, VAR_57, VAR_18);\n\n                VAR_62 = cli_LzmaInit(&VAR_59, 0);\n                if (VAR_62 != VAR_65) {\n                    cli_dbgmsg(\"cli_scanxar: cli_LzmaInit() fails: %i.\\n\", VAR_62);\n                    VAR_1 = VAR_26;\n                    __lzma_wrap_free(NULL, VAR_51);\n                    VAR_4++;\n                    break;\n                }\n\n                VAR_12 += VAR_57;\n                VAR_60 -= VAR_57;\n                while ((size_t)VAR_12 < VAR_8->len && (unsigned long)VAR_12 < VAR_10+VAR_7.toc_length_compressed+VAR_7.size+VAR_9) {\n                    SizeT VAR_46;\n                    SizeT VAR_66;\n                    void * VAR_47;\n                    unsigned long VAR_67;\n\n                    VAR_59.next_out = VAR_51;\n                    VAR_59.avail_out = VAR_56;\n                    VAR_59.avail_in = VAR_46 = MIN(VAR_58, VAR_60);\n                    VAR_59.next_in = VAR_47 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_59.avail_in);\n                    if (VAR_59.next_in == NULL) {\n                        char VAR_63[128];\n                        cli_strerror(VAR_64, VAR_63, sizeof(VAR_63));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   VAR_59.avail_in, VAR_12, VAR_63);\n                        VAR_1 = VAR_28;\n                        __lzma_wrap_free(NULL, VAR_51);\n                        cli_LzmaShutdown(&VAR_59);\n                        goto exit_tmpfile;\n                    }\n\n                    VAR_62 = cli_LzmaDecode(&VAR_59);\n                    if (VAR_62 != VAR_65 && VAR_62 != VAR_68) {\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() fails: %i.\\n\", VAR_62);\n                        VAR_1 = VAR_26;\n                        VAR_4++;\n                        break;\n                    }\n\n                    VAR_67 = VAR_46 - VAR_59.avail_in;\n                    VAR_60 -= VAR_67;\n                    VAR_12 += VAR_67;\n                    VAR_66 = VAR_56 - VAR_59.avail_out;\n                    \n                    if (VAR_66 == 0)\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() produces no output for \"\n                                   \"avail_in %llu, avail_out %llu.\\n\",\n                                   (long long unsigned)VAR_46, (long long unsigned)VAR_66);\n\n                    if (VAR_22 != NULL)\n                        xar_hash_update(VAR_22, VAR_47, VAR_67, VAR_18);                    \n                    if (VAR_23 != NULL)\n                        xar_hash_update(VAR_23, VAR_51, VAR_66, VAR_19);\n\n                    /* COMMENT_17 */\n                    /* COMMENT_18 */\n                    /* COMMENT_19 */\n                    /* COMMENT_20 */\n\n                    if (cli_writen(VAR_6, VAR_51, VAR_66) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\\n\",\n                                   (long long unsigned)VAR_66);\n                        __lzma_wrap_free(NULL, VAR_51);\n                        cli_LzmaShutdown(&VAR_59);\n                        VAR_1 = VAR_36;\n                        goto exit_tmpfile;\n                    }\n\n                    /* COMMENT_21 */\n                    VAR_61 += VAR_66;\n                    if (cli_checklimits(\"cli_scanxar\", VAR_0, VAR_61, 0, 0) != VAR_54) {\n                        break;\n                    }\n\n                    if (VAR_62 == VAR_68)\n                        break;\n                }\n\n                cli_LzmaShutdown(&VAR_59);\n                __lzma_wrap_free(NULL, VAR_51);\n            }\n            break; \n        case VAR_69:\n        default:\n        case VAR_70:\n        case VAR_71:\n            /* COMMENT_22 */\n            VAR_38 = 0;\n            {\n                size_t VAR_72 = MIN(VAR_8->len - VAR_12, VAR_9);\n\n                if (VAR_0->engine->maxfilesize)\n                    VAR_72 = MIN((size_t)(VAR_0->engine->maxfilesize), VAR_72);\n                    \n                if (!(VAR_39 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_72))) {\n                    char VAR_63[128];\n                    cli_strerror(VAR_64, VAR_63, sizeof(VAR_63));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\\n\",\n                               VAR_72, VAR_12, VAR_63);\n                    VAR_1 = VAR_28;\n                    goto exit_tmpfile;\n                }\n                \n                if (VAR_22 != NULL)\n                    xar_hash_update(VAR_22, VAR_39, VAR_72, VAR_18);\n                \n                if (cli_writen(VAR_6, VAR_39, VAR_72) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %zu bytes @ %li.\\n\", VAR_72, VAR_12);\n                    VAR_1 = VAR_36;\n                    goto exit_tmpfile;\n                }\n                /* COMMENT_23 */\n            }          \n        } /* COMMENT_24 */\n\n        if (VAR_1 == VAR_2) {\n            if (VAR_22 != NULL) {\n                xar_hash_final(VAR_22, VAR_24, VAR_18);\n                VAR_22 = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: archived-checksum missing.\\n\");\n                VAR_3++;\n            }\n            if (VAR_20 != NULL) {\n                VAR_44 = cli_hex2str((char *)VAR_20);\n                if (xar_hash_check(VAR_18, VAR_24, VAR_44) != 0) {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum mismatch.\\n\");\n                    VAR_3++;\n                } else {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum matched.\\n\");                \n                }\n                free(VAR_44);\n            }\n\n            if (VAR_23 != NULL) {\n                xar_hash_final(VAR_23, VAR_24, VAR_19);\n                VAR_23 = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: extracted-checksum(unarchived-checksum) missing.\\n\");\n                VAR_3++;\n            }\n            if (VAR_21 != NULL) {\n                if (VAR_38) {\n                    VAR_44 = cli_hex2str((char *)VAR_21);\n                    if (xar_hash_check(VAR_19, VAR_24, VAR_44) != 0) {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum mismatch.\\n\");\n                        VAR_3++;\n                    } else {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum matched.\\n\");                \n                    }\n                    free(VAR_44);\n                }\n            }\n        \n            VAR_1 = cli_magic_scandesc(VAR_6, VAR_0);\n            if (VAR_1 != VAR_2) {\n                if (VAR_1 == VAR_34) {\n                    cli_dbgmsg(\"cli_scanxar: Infected with %s\\n\", cli_get_last_virus(VAR_0));\n                    if (!VAR_35)\n                        goto exit_tmpfile;\n                } else if (VAR_1 != VAR_73) {\n                    cli_dbgmsg(\"cli_scanxar: cli_magic_scandesc error %i\\n\", VAR_1);\n                    goto exit_tmpfile;\n                }\n            }\n        }\n        \n        if (VAR_20 != NULL) {\n            xmlFree(VAR_20);\n            VAR_20 = NULL;\n        }\n        if (VAR_21 != NULL) {\n            xmlFree(VAR_21);\n            VAR_21 = NULL;\n        }\n    }\n\n exit_tmpfile:\n    xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);\n    if (VAR_22 != NULL)\n        xar_hash_final(VAR_22, VAR_24, VAR_18);\n    if (VAR_23 != NULL)\n        xar_hash_final(VAR_23, VAR_24, VAR_19);\n \n exit_reader:\n    if (VAR_20 != NULL)\n        xmlFree(VAR_20);   \n    if (VAR_21 != NULL)\n        xmlFree(VAR_21);\n    xmlTextReaderClose(VAR_17);\n    xmlFreeTextReader(VAR_17);\n\n exit_toc:\n    free(VAR_15);\n    if (VAR_1 == VAR_73)\n        VAR_1 = VAR_2;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (VAR_3 + VAR_4 != 0) {\n        cli_dbgmsg(\"cli_scanxar: %u checksum errors and %u extraction errors.\\n\",\n                    VAR_3, VAR_4);\n    }\n\n    return VAR_1;\n}",
    "func_graph_path": "Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n     int fd = -1;\n     struct xar_header hdr;\n     fmap_t *map = *ctx->fmap;\n-    long length, offset, size, at;\n+    size_t length, offset, size, at;\n     int encoding;\n     z_stream strm;\n     char *toc, *tmpname;\n@@ -80,6 +80,13 @@\n         goto exit_toc;\n     }\n \n+    if (hdr.toc_length_decompressed != strm.total_out) {\n+        cli_dbgmsg(\"TOC decompress length %\" PRIu64 \" does not match amount decompressed %lu\\n\",\n+                   hdr.toc_length_decompressed, strm.total_out);\n+        toc[strm.total_out] = '\\0';\n+        hdr.toc_length_decompressed = strm.total_out;\n+    }\n+\n     /* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n     /* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n     /* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); */\n@@ -147,8 +154,8 @@\n             goto exit_reader;\n         }\n \n-        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %li,\\n\"\n-                   \"from xar heap offset %li length %li\\n\",\n+        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n\"\n+                   \"from xar heap offset %zu length %zu\\n\",\n                    tmpname, size, offset, length);\n \n \n@@ -228,11 +235,14 @@\n #define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n             {\n                 struct CLI_LZMA lz;\n-                unsigned long in_remaining = length;\n+                unsigned long in_remaining = MIN(length, map->len - at);\n                 unsigned long out_size = 0;\n                 unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                 int lret;\n-                \n+\n+                if (length > in_remaining)\n+                    length = in_remaining;\n+\n                 memset(&lz, 0, sizeof(lz));\n                 if (buff == NULL) {\n                     cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n@@ -245,8 +255,8 @@\n                 if (blockp == NULL) {\n                     char errbuff[128];\n                     cli_strerror(errno, errbuff, sizeof(errbuff));\n-                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n-                               length, at, errbuff);\n+                    cli_dbgmsg(\"cli_scanxar: Can't read %i bytes @ %li, errno:%s.\\n\",\n+                               CLI_LZMA_HDR_SIZE, at, errbuff);\n                     rc = CL_EREAD;\n                     __lzma_wrap_free(NULL, buff);\n                     goto exit_tmpfile;\n@@ -283,7 +293,7 @@\n                         char errbuff[128];\n                         cli_strerror(errno, errbuff, sizeof(errbuff));\n                         cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n-                                   length, at, errbuff);\n+                                   lz.avail_in, at, errbuff);\n                         rc = CL_EREAD;\n                         __lzma_wrap_free(NULL, buff);\n                         cli_LzmaShutdown(&lz);\n@@ -348,33 +358,31 @@\n             /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */\n             do_extract_cksum = 0;\n             {\n-                unsigned long write_len;\n-                \n+                size_t writelen = MIN(map->len - at, length);\n+\n                 if (ctx->engine->maxfilesize)\n-                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);\n-                else\n-                    write_len = length;\n+                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);\n                     \n-                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {\n+                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {\n                     char errbuff[128];\n                     cli_strerror(errno, errbuff, sizeof(errbuff));\n-                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n-                               length, at, errbuff);\n+                    cli_dbgmsg(\"cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\\n\",\n+                               writelen, at, errbuff);\n                     rc = CL_EREAD;\n                     goto exit_tmpfile;\n                 }\n                 \n                 if (a_hash_ctx != NULL)\n-                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);\n+                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);\n                 \n-                if (cli_writen(fd, blockp, write_len) < 0) {\n-                    cli_dbgmsg(\"cli_scanxar: cli_writen error %li bytes @ %li.\\n\", length, at);\n+                if (cli_writen(fd, blockp, writelen) < 0) {\n+                    cli_dbgmsg(\"cli_scanxar: cli_writen error %zu bytes @ %li.\\n\", writelen, at);\n                     rc = CL_EWRITE;\n                     goto exit_tmpfile;\n                 }\n                 /*break;*/\n             }          \n-        }\n+        } /* end of switch */\n \n         if (rc == CL_SUCCESS) {\n             if (a_hash_ctx != NULL) {\n@@ -461,7 +469,7 @@\n     cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n #endif\n     if (cksum_fails + extract_errors != 0) {\n-        cli_warnmsg(\"cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n\",\n+        cli_dbgmsg(\"cli_scanxar: %u checksum errors and %u extraction errors.\\n\",\n                     cksum_fails, extract_errors);\n     }\n ",
    "diff_line_info": {
        "deleted_lines": [
            "    long length, offset, size, at;",
            "        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %li,\\n\"",
            "                   \"from xar heap offset %li length %li\\n\",",
            "                unsigned long in_remaining = length;",
            "                ",
            "                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",",
            "                               length, at, errbuff);",
            "                                   length, at, errbuff);",
            "                unsigned long write_len;",
            "                ",
            "                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);",
            "                else",
            "                    write_len = length;",
            "                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {",
            "                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",",
            "                               length, at, errbuff);",
            "                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);",
            "                if (cli_writen(fd, blockp, write_len) < 0) {",
            "                    cli_dbgmsg(\"cli_scanxar: cli_writen error %li bytes @ %li.\\n\", length, at);",
            "        }",
            "        cli_warnmsg(\"cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n\","
        ],
        "added_lines": [
            "    size_t length, offset, size, at;",
            "    if (hdr.toc_length_decompressed != strm.total_out) {",
            "        cli_dbgmsg(\"TOC decompress length %\" PRIu64 \" does not match amount decompressed %lu\\n\",",
            "                   hdr.toc_length_decompressed, strm.total_out);",
            "        toc[strm.total_out] = '\\0';",
            "        hdr.toc_length_decompressed = strm.total_out;",
            "    }",
            "",
            "        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n\"",
            "                   \"from xar heap offset %zu length %zu\\n\",",
            "                unsigned long in_remaining = MIN(length, map->len - at);",
            "",
            "                if (length > in_remaining)",
            "                    length = in_remaining;",
            "",
            "                    cli_dbgmsg(\"cli_scanxar: Can't read %i bytes @ %li, errno:%s.\\n\",",
            "                               CLI_LZMA_HDR_SIZE, at, errbuff);",
            "                                   lz.avail_in, at, errbuff);",
            "                size_t writelen = MIN(map->len - at, length);",
            "",
            "                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);",
            "                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {",
            "                    cli_dbgmsg(\"cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\\n\",",
            "                               writelen, at, errbuff);",
            "                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);",
            "                if (cli_writen(fd, blockp, writelen) < 0) {",
            "                    cli_dbgmsg(\"cli_scanxar: cli_writen error %zu bytes @ %li.\\n\", writelen, at);",
            "        } /* end of switch */",
            "        cli_dbgmsg(\"cli_scanxar: %u checksum errors and %u extraction errors.\\n\","
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}