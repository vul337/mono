{
    "cve_id": "CVE-2015-9382",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "freetype/freetype2",
    "commit_msg": "* src/psaux/psobjs.c (ps_parser_skip_PS_token): If a token is\nenclosed in balanced expressions, ensure that the cursor position\ndoesn't get larger than the current limit.\n",
    "commit_hash": "db5a4a9ae7b0048f033361744421da8569642f73",
    "git_url": "http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/src/psaux/psobjs.c?id=db5a4a9ae7b0048f033361744421da8569642f73",
    "file_path": "src/psaux/psobjs.c",
    "func_name": "ps_parser_skip_PS_token",
    "func_before": "FT_LOCAL_DEF( void )\n  ps_parser_skip_PS_token( PS_Parser  parser )\n  {\n    /* Note: PostScript allows any non-delimiting, non-whitespace        */\n    /*       character in a name (PS Ref Manual, 3rd ed, p31).           */\n    /*       PostScript delimiters are (, ), <, >, [, ], {, }, /, and %. */\n\n    FT_Byte*  cur   = parser->cursor;\n    FT_Byte*  limit = parser->limit;\n    FT_Error  error = FT_Err_Ok;\n\n\n    skip_spaces( &cur, limit );             /* this also skips comments */\n    if ( cur >= limit )\n      goto Exit;\n\n    /* self-delimiting, single-character tokens */\n    if ( *cur == '[' || *cur == ']' )\n    {\n      cur++;\n      goto Exit;\n    }\n\n    /* skip balanced expressions (procedures and strings) */\n\n    if ( *cur == '{' )                              /* {...} */\n    {\n      error = skip_procedure( &cur, limit );\n      goto Exit;\n    }\n\n    if ( *cur == '(' )                              /* (...) */\n    {\n      error = skip_literal_string( &cur, limit );\n      goto Exit;\n    }\n\n    if ( *cur == '<' )                              /* <...> */\n    {\n      if ( cur + 1 < limit && *(cur + 1) == '<' )   /* << */\n      {\n        cur++;\n        cur++;\n      }\n      else\n        error = skip_string( &cur, limit );\n\n      goto Exit;\n    }\n\n    if ( *cur == '>' )\n    {\n      cur++;\n      if ( cur >= limit || *cur != '>' )             /* >> */\n      {\n        FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                   \" unexpected closing delimiter `>'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n      cur++;\n      goto Exit;\n    }\n\n    if ( *cur == '/' )\n      cur++;\n\n    /* anything else */\n    while ( cur < limit )\n    {\n      /* *cur might be invalid (e.g., ')' or '}'), but this   */\n      /* is handled by the test `cur == parser->cursor' below */\n      if ( IS_PS_DELIM( *cur ) )\n        break;\n\n      cur++;\n    }\n\n  Exit:\n    if ( cur < limit && cur == parser->cursor )\n    {\n      FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                 \" current token is `%c' which is self-delimiting\\n\"\n                 \"                        \"\n                 \" but invalid at this point\\n\",\n                 *cur ));\n\n      error = FT_THROW( Invalid_File_Format );\n    }\n\n    parser->error  = error;\n    parser->cursor = cur;\n  }",
    "abstract_func_before": "VAR_0( void )\n  ps_parser_skip_PS_token( PS_Parser  VAR_1 )\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n\n    FT_Byte*  VAR_2   = VAR_1->cursor;\n    FT_Byte*  VAR_3 = VAR_1->limit;\n    FT_Error  VAR_4 = VAR_5;\n\n\n    skip_spaces( &VAR_2, VAR_3 );             /* COMMENT_3 */\n    if ( VAR_2 >= VAR_3 )\n      goto Exit;\n\n    /* COMMENT_4 */\n    if ( *VAR_2 == '[' || *VAR_2 == ']' )\n    {\n      VAR_2++;\n      goto Exit;\n    }\n\n    /* COMMENT_5 */\n\n    if ( *VAR_2 == '{' )                              /* COMMENT_6 */\n    {\n      VAR_4 = skip_procedure( &VAR_2, VAR_3 );\n      goto Exit;\n    }\n\n    if ( *VAR_2 == '(' )                              /* COMMENT_7 */\n    {\n      VAR_4 = skip_literal_string( &VAR_2, VAR_3 );\n      goto Exit;\n    }\n\n    if ( *VAR_2 == '<' )                              /* COMMENT_8 */\n    {\n      if ( VAR_2 + 1 < VAR_3 && *(VAR_2 + 1) == '<' )   /* COMMENT_9 */\n      {\n        VAR_2++;\n        VAR_2++;\n      }\n      else\n        VAR_4 = skip_string( &VAR_2, VAR_3 );\n\n      goto Exit;\n    }\n\n    if ( *VAR_2 == '>' )\n    {\n      VAR_2++;\n      if ( VAR_2 >= VAR_3 || *VAR_2 != '>' )             /* COMMENT_10 */\n      {\n        FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                   \" unexpected closing delimiter `>'\\n\" ));\n        VAR_4 = FT_THROW( VAR_6 );\n        goto Exit;\n      }\n      VAR_2++;\n      goto Exit;\n    }\n\n    if ( *VAR_2 == '/' )\n      VAR_2++;\n\n    /* COMMENT_11 */\n    while ( VAR_2 < VAR_3 )\n    {\n      /* COMMENT_12 */\n      /* COMMENT_13 */\n      if ( IS_PS_DELIM( *VAR_2 ) )\n        break;\n\n      VAR_2++;\n    }\n\n  Exit:\n    if ( VAR_2 < VAR_3 && VAR_2 == VAR_1->cursor )\n    {\n      FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                 \" current token is `%c' which is self-delimiting\\n\"\n                 \"                        \"\n                 \" but invalid at this point\\n\",\n                 *VAR_2 ));\n\n      VAR_4 = FT_THROW( VAR_6 );\n    }\n\n    VAR_1->error  = VAR_4;\n    VAR_1->cursor = VAR_2;\n  }",
    "func_graph_path_before": null,
    "func": "FT_LOCAL_DEF( void )\n  ps_parser_skip_PS_token( PS_Parser  parser )\n  {\n    /* Note: PostScript allows any non-delimiting, non-whitespace        */\n    /*       character in a name (PS Ref Manual, 3rd ed, p31).           */\n    /*       PostScript delimiters are (, ), <, >, [, ], {, }, /, and %. */\n\n    FT_Byte*  cur   = parser->cursor;\n    FT_Byte*  limit = parser->limit;\n    FT_Error  error = FT_Err_Ok;\n\n\n    skip_spaces( &cur, limit );             /* this also skips comments */\n    if ( cur >= limit )\n      goto Exit;\n\n    /* self-delimiting, single-character tokens */\n    if ( *cur == '[' || *cur == ']' )\n    {\n      cur++;\n      goto Exit;\n    }\n\n    /* skip balanced expressions (procedures and strings) */\n\n    if ( *cur == '{' )                              /* {...} */\n    {\n      error = skip_procedure( &cur, limit );\n      goto Exit;\n    }\n\n    if ( *cur == '(' )                              /* (...) */\n    {\n      error = skip_literal_string( &cur, limit );\n      goto Exit;\n    }\n\n    if ( *cur == '<' )                              /* <...> */\n    {\n      if ( cur + 1 < limit && *(cur + 1) == '<' )   /* << */\n      {\n        cur++;\n        cur++;\n      }\n      else\n        error = skip_string( &cur, limit );\n\n      goto Exit;\n    }\n\n    if ( *cur == '>' )\n    {\n      cur++;\n      if ( cur >= limit || *cur != '>' )             /* >> */\n      {\n        FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                   \" unexpected closing delimiter `>'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n      cur++;\n      goto Exit;\n    }\n\n    if ( *cur == '/' )\n      cur++;\n\n    /* anything else */\n    while ( cur < limit )\n    {\n      /* *cur might be invalid (e.g., ')' or '}'), but this   */\n      /* is handled by the test `cur == parser->cursor' below */\n      if ( IS_PS_DELIM( *cur ) )\n        break;\n\n      cur++;\n    }\n\n  Exit:\n    if ( cur < limit && cur == parser->cursor )\n    {\n      FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                 \" current token is `%c' which is self-delimiting\\n\"\n                 \"                        \"\n                 \" but invalid at this point\\n\",\n                 *cur ));\n\n      error = FT_THROW( Invalid_File_Format );\n    }\n\n    if ( cur > limit )\n      cur = limit;\n\n    parser->error  = error;\n    parser->cursor = cur;\n  }",
    "abstract_func": "VAR_0( void )\n  ps_parser_skip_PS_token( PS_Parser  VAR_1 )\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n\n    FT_Byte*  VAR_2   = VAR_1->cursor;\n    FT_Byte*  VAR_3 = VAR_1->limit;\n    FT_Error  VAR_4 = VAR_5;\n\n\n    skip_spaces( &VAR_2, VAR_3 );             /* COMMENT_3 */\n    if ( VAR_2 >= VAR_3 )\n      goto Exit;\n\n    /* COMMENT_4 */\n    if ( *VAR_2 == '[' || *VAR_2 == ']' )\n    {\n      VAR_2++;\n      goto Exit;\n    }\n\n    /* COMMENT_5 */\n\n    if ( *VAR_2 == '{' )                              /* COMMENT_6 */\n    {\n      VAR_4 = skip_procedure( &VAR_2, VAR_3 );\n      goto Exit;\n    }\n\n    if ( *VAR_2 == '(' )                              /* COMMENT_7 */\n    {\n      VAR_4 = skip_literal_string( &VAR_2, VAR_3 );\n      goto Exit;\n    }\n\n    if ( *VAR_2 == '<' )                              /* COMMENT_8 */\n    {\n      if ( VAR_2 + 1 < VAR_3 && *(VAR_2 + 1) == '<' )   /* COMMENT_9 */\n      {\n        VAR_2++;\n        VAR_2++;\n      }\n      else\n        VAR_4 = skip_string( &VAR_2, VAR_3 );\n\n      goto Exit;\n    }\n\n    if ( *VAR_2 == '>' )\n    {\n      VAR_2++;\n      if ( VAR_2 >= VAR_3 || *VAR_2 != '>' )             /* COMMENT_10 */\n      {\n        FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                   \" unexpected closing delimiter `>'\\n\" ));\n        VAR_4 = FT_THROW( VAR_6 );\n        goto Exit;\n      }\n      VAR_2++;\n      goto Exit;\n    }\n\n    if ( *VAR_2 == '/' )\n      VAR_2++;\n\n    /* COMMENT_11 */\n    while ( VAR_2 < VAR_3 )\n    {\n      /* COMMENT_12 */\n      /* COMMENT_13 */\n      if ( IS_PS_DELIM( *VAR_2 ) )\n        break;\n\n      VAR_2++;\n    }\n\n  Exit:\n    if ( VAR_2 < VAR_3 && VAR_2 == VAR_1->cursor )\n    {\n      FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                 \" current token is `%c' which is self-delimiting\\n\"\n                 \"                        \"\n                 \" but invalid at this point\\n\",\n                 *VAR_2 ));\n\n      VAR_4 = FT_THROW( VAR_6 );\n    }\n\n    if ( VAR_2 > VAR_3 )\n      VAR_2 = VAR_3;\n\n    VAR_1->error  = VAR_4;\n    VAR_1->cursor = VAR_2;\n  }",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -88,6 +88,9 @@\n       error = FT_THROW( Invalid_File_Format );\n     }\n \n+    if ( cur > limit )\n+      cur = limit;\n+\n     parser->error  = error;\n     parser->cursor = cur;\n   }",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "    if ( cur > limit )",
            "      cur = limit;",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}