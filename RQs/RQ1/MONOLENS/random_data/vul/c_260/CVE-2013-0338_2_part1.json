{
    "cve_id": "CVE-2013-0338",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "GNOME/libxml2",
    "commit_msg": "Detect excessive entities expansion upon replacement\n\nIf entities expansion in the XML parser is asked for,\nit is possble to craft relatively small input document leading\nto excessive on-the-fly content generation.\nThis patch accounts for those replacement and stop parsing\nafter a given threshold. it can be bypassed as usual with the\nHUGE parser option.",
    "commit_hash": "23f05e0c33987d6605387b300c4be5da2120a7ab",
    "git_url": "https://github.com/GNOME/libxml2/commit/23f05e0c33987d6605387b300c4be5da2120a7ab",
    "file_path": "parser.c",
    "func_name": "xmlParserEntityCheck",
    "func_before": "static int\nxmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,\n                     xmlEntityPtr ent)\n{\n    size_t consumed = 0;\n\n    if ((ctxt == NULL) || (ctxt->options & XML_PARSE_HUGE))\n        return (0);\n    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n        return (1);\n    if (size != 0) {\n        /*\n         * Do the check based on the replacement size of the entity\n         */\n        if (size < XML_PARSER_BIG_ENTITY)\n\t    return(0);\n\n        /*\n         * A limit on the amount of text data reasonably used\n         */\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n\n        if ((size < XML_PARSER_NON_LINEAR * consumed) &&\n\t    (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))\n            return (0);\n    } else if (ent != NULL) {\n        /*\n         * use the number of parsed entities in the replacement\n         */\n        size = ent->checked;\n\n        /*\n         * The amount of data parsed counting entities size only once\n         */\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n\n        /*\n         * Check the density of entities for the amount of data\n\t * knowing an entity reference will take at least 3 bytes\n         */\n        if (size * 3 < consumed * XML_PARSER_NON_LINEAR)\n            return (0);\n    } else {\n        /*\n         * strange we got no data for checking just return\n         */\n        return (0);\n    }\n\n    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n    return (1);\n}",
    "abstract_func_before": "static int\nxmlParserEntityCheck(xmlParserCtxtPtr VAR_0, size_t VAR_1,\n                     xmlEntityPtr VAR_2)\n{\n    size_t VAR_3 = 0;\n\n    if ((VAR_0 == NULL) || (VAR_0->options & VAR_4))\n        return (0);\n    if (VAR_0->lastError.code == VAR_5)\n        return (1);\n    if (VAR_1 != 0) {\n        /* COMMENT_0 */\n                                                                   \n           \n        if (VAR_1 < VAR_6)\n\t    return(0);\n\n        /* COMMENT_3 */\n                                                             \n           \n        if (VAR_0->input != NULL) {\n            VAR_3 = VAR_0->input->consumed +\n                (VAR_0->input->cur - VAR_0->input->base);\n        }\n        VAR_3 += VAR_0->sizeentities;\n\n        if ((VAR_1 < VAR_7 * VAR_3) &&\n\t    (VAR_0->nbentities * 3 < VAR_7 * VAR_3))\n            return (0);\n    } else if (VAR_2 != NULL) {\n        /* COMMENT_6 */\n                                                               \n           \n        VAR_1 = VAR_2->checked;\n\n        /* COMMENT_9 */\n                                                                     \n           \n        if (VAR_0->input != NULL) {\n            VAR_3 = VAR_0->input->consumed +\n                (VAR_0->input->cur - VAR_0->input->base);\n        }\n        VAR_3 += VAR_0->sizeentities;\n\n        /* COMMENT_12 */\n                                                               \n                                                          \n           \n        if (VAR_1 * 3 < VAR_3 * VAR_7)\n            return (0);\n    } else {\n        /* COMMENT_16 */\n                                                          \n           \n        return (0);\n    }\n\n    xmlFatalErr(VAR_0, VAR_5, NULL);\n    return (1);\n}",
    "func_graph_path_before": "GNOME/libxml2/23f05e0c33987d6605387b300c4be5da2120a7ab/parser.c/vul/before/3.json",
    "func": "static int\nxmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,\n                     xmlEntityPtr ent, size_t replacement)\n{\n    size_t consumed = 0;\n\n    if ((ctxt == NULL) || (ctxt->options & XML_PARSE_HUGE))\n        return (0);\n    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n        return (1);\n    if (replacement != 0) {\n\tif (replacement < XML_MAX_TEXT_LENGTH)\n\t    return(0);\n\n        /*\n\t * If the volume of entity copy reaches 10 times the\n\t * amount of parsed data and over the large text threshold\n\t * then that's very likely to be an abuse.\n\t */\n        if (ctxt->input != NULL) {\n\t    consumed = ctxt->input->consumed +\n\t               (ctxt->input->cur - ctxt->input->base);\n\t}\n        consumed += ctxt->sizeentities;\n\n        if (replacement < XML_PARSER_NON_LINEAR * consumed)\n\t    return(0);\n    } else if (size != 0) {\n        /*\n         * Do the check based on the replacement size of the entity\n         */\n        if (size < XML_PARSER_BIG_ENTITY)\n\t    return(0);\n\n        /*\n         * A limit on the amount of text data reasonably used\n         */\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n\n        if ((size < XML_PARSER_NON_LINEAR * consumed) &&\n\t    (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))\n            return (0);\n    } else if (ent != NULL) {\n        /*\n         * use the number of parsed entities in the replacement\n         */\n        size = ent->checked;\n\n        /*\n         * The amount of data parsed counting entities size only once\n         */\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n\n        /*\n         * Check the density of entities for the amount of data\n\t * knowing an entity reference will take at least 3 bytes\n         */\n        if (size * 3 < consumed * XML_PARSER_NON_LINEAR)\n            return (0);\n    } else {\n        /*\n         * strange we got no data for checking just return\n         */\n        return (0);\n    }\n    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n    return (1);\n}",
    "abstract_func": "static int\nxmlParserEntityCheck(xmlParserCtxtPtr VAR_0, size_t VAR_1,\n                     xmlEntityPtr VAR_2, size_t VAR_3)\n{\n    size_t VAR_4 = 0;\n\n    if ((VAR_0 == NULL) || (VAR_0->options & VAR_5))\n        return (0);\n    if (VAR_0->lastError.code == VAR_6)\n        return (1);\n    if (VAR_3 != 0) {\n\tif (VAR_3 < VAR_7)\n\t    return(0);\n\n        /* COMMENT_0 */\n                                                     \n                                                           \n                                           \n    \n        if (VAR_0->input != NULL) {\n\t    VAR_4 = VAR_0->input->consumed +\n\t               (VAR_0->input->cur - VAR_0->input->base);\n\t}\n        VAR_4 += VAR_0->sizeentities;\n\n        if (VAR_3 < VAR_8 * VAR_4)\n\t    return(0);\n    } else if (VAR_1 != 0) {\n        /* COMMENT_5 */\n                                                                   \n           \n        if (VAR_1 < VAR_9)\n\t    return(0);\n\n        /* COMMENT_8 */\n                                                             \n           \n        if (VAR_0->input != NULL) {\n            VAR_4 = VAR_0->input->consumed +\n                (VAR_0->input->cur - VAR_0->input->base);\n        }\n        VAR_4 += VAR_0->sizeentities;\n\n        if ((VAR_1 < VAR_8 * VAR_4) &&\n\t    (VAR_0->nbentities * 3 < VAR_8 * VAR_4))\n            return (0);\n    } else if (VAR_2 != NULL) {\n        /* COMMENT_11 */\n                                                               \n           \n        VAR_1 = VAR_2->checked;\n\n        /* COMMENT_14 */\n                                                                     \n           \n        if (VAR_0->input != NULL) {\n            VAR_4 = VAR_0->input->consumed +\n                (VAR_0->input->cur - VAR_0->input->base);\n        }\n        VAR_4 += VAR_0->sizeentities;\n\n        /* COMMENT_17 */\n                                                               \n                                                          \n           \n        if (VAR_1 * 3 < VAR_4 * VAR_8)\n            return (0);\n    } else {\n        /* COMMENT_21 */\n                                                          \n           \n        return (0);\n    }\n    xmlFatalErr(VAR_0, VAR_6, NULL);\n    return (1);\n}",
    "func_graph_path": "GNOME/libxml2/23f05e0c33987d6605387b300c4be5da2120a7ab/parser.c/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,\n-                     xmlEntityPtr ent)\n+                     xmlEntityPtr ent, size_t replacement)\n {\n     size_t consumed = 0;\n \n@@ -8,7 +8,24 @@\n         return (0);\n     if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n         return (1);\n-    if (size != 0) {\n+    if (replacement != 0) {\n+\tif (replacement < XML_MAX_TEXT_LENGTH)\n+\t    return(0);\n+\n+        /*\n+\t * If the volume of entity copy reaches 10 times the\n+\t * amount of parsed data and over the large text threshold\n+\t * then that's very likely to be an abuse.\n+\t */\n+        if (ctxt->input != NULL) {\n+\t    consumed = ctxt->input->consumed +\n+\t               (ctxt->input->cur - ctxt->input->base);\n+\t}\n+        consumed += ctxt->sizeentities;\n+\n+        if (replacement < XML_PARSER_NON_LINEAR * consumed)\n+\t    return(0);\n+    } else if (size != 0) {\n         /*\n          * Do the check based on the replacement size of the entity\n          */\n@@ -54,7 +71,6 @@\n          */\n         return (0);\n     }\n-\n     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n     return (1);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "                     xmlEntityPtr ent)",
            "    if (size != 0) {",
            ""
        ],
        "added_lines": [
            "                     xmlEntityPtr ent, size_t replacement)",
            "    if (replacement != 0) {",
            "\tif (replacement < XML_MAX_TEXT_LENGTH)",
            "\t    return(0);",
            "",
            "        /*",
            "\t * If the volume of entity copy reaches 10 times the",
            "\t * amount of parsed data and over the large text threshold",
            "\t * then that's very likely to be an abuse.",
            "\t */",
            "        if (ctxt->input != NULL) {",
            "\t    consumed = ctxt->input->consumed +",
            "\t               (ctxt->input->cur - ctxt->input->base);",
            "\t}",
            "        consumed += ctxt->sizeentities;",
            "",
            "        if (replacement < XML_PARSER_NON_LINEAR * consumed)",
            "\t    return(0);",
            "    } else if (size != 0) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}