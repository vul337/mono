{
    "cve_id": "CVE-2022-2959",
    "cwe_ids": [
        "CWE-362",
        "CWE-667"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "pipe: Fix missing lock in pipe_resize_ring()\n\npipe_resize_ring() needs to take the pipe->rd_wait.lock spinlock to\nprevent post_one_notification() from trying to insert into the ring\nwhilst the ring is being replaced.\n\nThe occupancy check must be done after the lock is taken, and the lock\nmust be taken after the new ring is allocated.\n\nThe bug can lead to an oops looking something like:\n\n BUG: KASAN: use-after-free in post_one_notification.isra.0+0x62e/0x840\n Read of size 4 at addr ffff88801cc72a70 by task poc/27196\n ...\n Call Trace:\n  post_one_notification.isra.0+0x62e/0x840\n  __post_watch_notification+0x3b7/0x650\n  key_create_or_update+0xb8b/0xd20\n  __do_sys_add_key+0x175/0x340\n  __x64_sys_add_key+0xbe/0x140\n  do_syscall_64+0x5c/0xc0\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nReported by Selim Enes Karaduman @Enesdex working with Trend Micro Zero\nDay Initiative.\n\nFixes: c73be61cede5 (\"pipe: Add general notification queue support\")\nReported-by: zdi-disclosures@trendmicro.com # ZDI-CAN-17291\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "commit_hash": "189b0ddc245139af81198d1a3637cac74f96e13a",
    "git_url": "https://github.com/torvalds/linux/commit/189b0ddc245139af81198d1a3637cac74f96e13a",
    "file_path": "fs/pipe.c",
    "func_name": "pipe_resize_ring",
    "func_before": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\n\t/*\n\t * We can shrink the pipe, if arg is greater than the ring occupancy.\n\t * Since we don't expect a lot of shrink+grow operations, just free and\n\t * allocate again like we would do for growing.  If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indices.\n\t */\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\n\thead = n;\n\ttail = 0;\n\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\n\t/* This might have made more room for writers */\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}",
    "abstract_func_before": "int pipe_resize_ring(struct pipe_inode_info *VAR_0, unsigned int VAR_1)\n{\n\tstruct pipe_buffer *VAR_2;\n\tunsigned int VAR_3, VAR_4, VAR_5, VAR_6;\n\n\t/* COMMENT_0 */\n                                                                      \n                                                                        \n                                                                       \n                                                     \n    \n\tVAR_5 = VAR_0->ring_size - 1;\n\tVAR_3 = VAR_0->head;\n\tVAR_4 = VAR_0->tail;\n\tVAR_6 = pipe_occupancy(VAR_0->head, VAR_0->tail);\n\tif (VAR_1 < VAR_6)\n\t\treturn -VAR_7;\n\n\tVAR_2 = kcalloc(VAR_1, sizeof(*VAR_2),\n\t\t       VAR_8 | VAR_9);\n\tif (unlikely(!VAR_2))\n\t\treturn -VAR_10;\n\n\t/* COMMENT_6 */\n                                                                  \n                           \n    \n\tif (VAR_6 > 0) {\n\t\tunsigned int VAR_11 = VAR_3 & VAR_5;\n\t\tunsigned int VAR_12 = VAR_4 & VAR_5;\n\t\tif (VAR_11 > VAR_12) {\n\t\t\tmemcpy(VAR_2, VAR_0->bufs + VAR_12,\n\t\t\t       VAR_6 * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int VAR_13 = VAR_0->ring_size - VAR_12;\n\t\t\tif (VAR_11 > 0)\n\t\t\t\tmemcpy(VAR_2 + VAR_13, VAR_0->bufs,\n\t\t\t\t       VAR_11 * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(VAR_2, VAR_0->bufs + VAR_12,\n\t\t\t       VAR_13 * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\n\tVAR_3 = VAR_6;\n\tVAR_4 = 0;\n\n\tkfree(VAR_0->bufs);\n\tVAR_0->bufs = VAR_2;\n\tVAR_0->ring_size = VAR_1;\n\tif (VAR_0->max_usage > VAR_1)\n\t\tVAR_0->max_usage = VAR_1;\n\tVAR_0->tail = VAR_4;\n\tVAR_0->head = VAR_3;\n\n\t/* COMMENT_10 */\n\twake_up_interruptible(&VAR_0->wr_wait);\n\treturn 0;\n}",
    "func_graph_path_before": "torvalds/linux/189b0ddc245139af81198d1a3637cac74f96e13a/pipe.c/vul/before/0.json",
    "func": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\n\tn = pipe_occupancy(head, tail);\n\tif (nr_slots < n) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tkfree(bufs);\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indices.\n\t */\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\n\thead = n;\n\ttail = 0;\n\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\n\t/* This might have made more room for writers */\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}",
    "abstract_func": "int pipe_resize_ring(struct pipe_inode_info *VAR_0, unsigned int VAR_1)\n{\n\tstruct pipe_buffer *VAR_2;\n\tunsigned int VAR_3, VAR_4, VAR_5, VAR_6;\n\n\tVAR_2 = kcalloc(VAR_1, sizeof(*VAR_2),\n\t\t       VAR_7 | VAR_8);\n\tif (unlikely(!VAR_2))\n\t\treturn -VAR_9;\n\n\tspin_lock_irq(&VAR_0->rd_wait.lock);\n\tVAR_5 = VAR_0->ring_size - 1;\n\tVAR_3 = VAR_0->head;\n\tVAR_4 = VAR_0->tail;\n\n\tVAR_6 = pipe_occupancy(VAR_3, VAR_4);\n\tif (VAR_1 < VAR_6) {\n\t\tspin_unlock_irq(&VAR_0->rd_wait.lock);\n\t\tkfree(VAR_2);\n\t\treturn -VAR_10;\n\t}\n\n\t/* COMMENT_0 */\n                                                                  \n                           \n    \n\tif (VAR_6 > 0) {\n\t\tunsigned int VAR_11 = VAR_3 & VAR_5;\n\t\tunsigned int VAR_12 = VAR_4 & VAR_5;\n\t\tif (VAR_11 > VAR_12) {\n\t\t\tmemcpy(VAR_2, VAR_0->bufs + VAR_12,\n\t\t\t       VAR_6 * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int VAR_13 = VAR_0->ring_size - VAR_12;\n\t\t\tif (VAR_11 > 0)\n\t\t\t\tmemcpy(VAR_2 + VAR_13, VAR_0->bufs,\n\t\t\t\t       VAR_11 * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(VAR_2, VAR_0->bufs + VAR_12,\n\t\t\t       VAR_13 * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\n\tVAR_3 = VAR_6;\n\tVAR_4 = 0;\n\n\tkfree(VAR_0->bufs);\n\tVAR_0->bufs = VAR_2;\n\tVAR_0->ring_size = VAR_1;\n\tif (VAR_0->max_usage > VAR_1)\n\t\tVAR_0->max_usage = VAR_1;\n\tVAR_0->tail = VAR_4;\n\tVAR_0->head = VAR_3;\n\n\tspin_unlock_irq(&VAR_0->rd_wait.lock);\n\n\t/* COMMENT_4 */\n\twake_up_interruptible(&VAR_0->wr_wait);\n\treturn 0;\n}",
    "func_graph_path": "torvalds/linux/189b0ddc245139af81198d1a3637cac74f96e13a/pipe.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -3,23 +3,22 @@\n \tstruct pipe_buffer *bufs;\n \tunsigned int head, tail, mask, n;\n \n-\t/*\n-\t * We can shrink the pipe, if arg is greater than the ring occupancy.\n-\t * Since we don't expect a lot of shrink+grow operations, just free and\n-\t * allocate again like we would do for growing.  If the pipe currently\n-\t * contains more buffers than arg, then return busy.\n-\t */\n-\tmask = pipe->ring_size - 1;\n-\thead = pipe->head;\n-\ttail = pipe->tail;\n-\tn = pipe_occupancy(pipe->head, pipe->tail);\n-\tif (nr_slots < n)\n-\t\treturn -EBUSY;\n-\n \tbufs = kcalloc(nr_slots, sizeof(*bufs),\n \t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n \tif (unlikely(!bufs))\n \t\treturn -ENOMEM;\n+\n+\tspin_lock_irq(&pipe->rd_wait.lock);\n+\tmask = pipe->ring_size - 1;\n+\thead = pipe->head;\n+\ttail = pipe->tail;\n+\n+\tn = pipe_occupancy(head, tail);\n+\tif (nr_slots < n) {\n+\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n+\t\tkfree(bufs);\n+\t\treturn -EBUSY;\n+\t}\n \n \t/*\n \t * The pipe array wraps around, so just start the new one at zero\n@@ -52,6 +51,8 @@\n \tpipe->tail = tail;\n \tpipe->head = head;\n \n+\tspin_unlock_irq(&pipe->rd_wait.lock);\n+\n \t/* This might have made more room for writers */\n \twake_up_interruptible(&pipe->wr_wait);\n \treturn 0;",
    "diff_line_info": {
        "deleted_lines": [
            "\t/*",
            "\t * We can shrink the pipe, if arg is greater than the ring occupancy.",
            "\t * Since we don't expect a lot of shrink+grow operations, just free and",
            "\t * allocate again like we would do for growing.  If the pipe currently",
            "\t * contains more buffers than arg, then return busy.",
            "\t */",
            "\tmask = pipe->ring_size - 1;",
            "\thead = pipe->head;",
            "\ttail = pipe->tail;",
            "\tn = pipe_occupancy(pipe->head, pipe->tail);",
            "\tif (nr_slots < n)",
            "\t\treturn -EBUSY;",
            ""
        ],
        "added_lines": [
            "",
            "\tspin_lock_irq(&pipe->rd_wait.lock);",
            "\tmask = pipe->ring_size - 1;",
            "\thead = pipe->head;",
            "\ttail = pipe->tail;",
            "",
            "\tn = pipe_occupancy(head, tail);",
            "\tif (nr_slots < n) {",
            "\t\tspin_unlock_irq(&pipe->rd_wait.lock);",
            "\t\tkfree(bufs);",
            "\t\treturn -EBUSY;",
            "\t}",
            "\tspin_unlock_irq(&pipe->rd_wait.lock);",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}