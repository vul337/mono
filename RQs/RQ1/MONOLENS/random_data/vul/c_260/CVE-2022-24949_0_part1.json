{
    "cve_id": "CVE-2022-24949",
    "cwe_ids": [
        "CWE-362",
        "CWE-120"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "MisterTea/EternalTerminal",
    "commit_msg": "red fixes (#468)\n\n* red fixes\r\n\r\n* remove magic number",
    "commit_hash": "900348bb8bc96e1c7ba4888ac8480f643c43d3c3",
    "git_url": "https://github.com/MisterTea/EternalTerminal/commit/900348bb8bc96e1c7ba4888ac8480f643c43d3c3",
    "file_path": "src/base/PipeSocketHandler.cpp",
    "func_name": "PipeSocketHandler::connect",
    "func_before": "int PipeSocketHandler::connect(const SocketEndpoint& endpoint) {\n  lock_guard<std::recursive_mutex> mutexGuard(globalMutex);\n\n  string pipePath = endpoint.name();\n  sockaddr_un remote;\n\n  int sockFd = ::socket(AF_UNIX, SOCK_STREAM, 0);\n  FATAL_FAIL(sockFd);\n  initSocket(sockFd);\n  remote.sun_family = AF_UNIX;\n  strcpy(remote.sun_path, pipePath.c_str());\n\n  VLOG(3) << \"Connecting to \" << endpoint << \" with fd \" << sockFd;\n  int result =\n      ::connect(sockFd, (struct sockaddr*)&remote, sizeof(sockaddr_un));\n  auto localErrno = GetErrno();\n  if (result < 0 && localErrno != EINPROGRESS) {\n    VLOG(3) << \"Connection result: \" << result << \" (\" << strerror(localErrno)\n            << \")\";\n#ifdef WIN32\n    ::shutdown(sockFd, SD_BOTH);\n#else\n    ::shutdown(sockFd, SHUT_RDWR);\n#endif\n#ifdef _MSC_VER\n    FATAL_FAIL(::closesocket(sockFd));\n#else\n    FATAL_FAIL(::close(sockFd));\n#endif\n    sockFd = -1;\n    SetErrno(localErrno);\n    return sockFd;\n  }\n\n  fd_set fdset;\n  FD_ZERO(&fdset);\n  FD_SET(sockFd, &fdset);\n  timeval tv;\n  tv.tv_sec = 3; /* 3 second timeout */\n  tv.tv_usec = 0;\n  VLOG(4) << \"Before selecting sockFd\";\n  select(sockFd + 1, NULL, &fdset, NULL, &tv);\n\n  if (FD_ISSET(sockFd, &fdset)) {\n    VLOG(4) << \"sockFd \" << sockFd << \" is selected\";\n    int so_error;\n    socklen_t len = sizeof so_error;\n\n    FATAL_FAIL(\n        ::getsockopt(sockFd, SOL_SOCKET, SO_ERROR, (char*)&so_error, &len));\n\n    if (so_error == 0) {\n      LOG(INFO) << \"Connected to endpoint \" << endpoint;\n      // Initialize the socket again once it's blocking to make sure timeouts\n      // are set\n      initSocket(sockFd);\n\n      // if we get here, we must have connected successfully\n    } else {\n      LOG(INFO) << \"Error connecting to \" << endpoint << \": \" << so_error << \" \"\n                << strerror(so_error);\n#ifdef _MSC_VER\n      FATAL_FAIL(::closesocket(sockFd));\n#else\n      FATAL_FAIL(::close(sockFd));\n#endif\n      sockFd = -1;\n    }\n  } else {\n    auto localErrno = GetErrno();\n    LOG(INFO) << \"Error connecting to \" << endpoint << \": \" << localErrno << \" \"\n              << strerror(localErrno);\n#ifdef _MSC_VER\n    FATAL_FAIL(::closesocket(sockFd));\n#else\n    FATAL_FAIL(::close(sockFd));\n#endif\n    sockFd = -1;\n  }\n\n  LOG(INFO) << sockFd << \" is a good socket\";\n  if (sockFd >= 0) {\n    addToActiveSockets(sockFd);\n  }\n  return sockFd;\n}",
    "abstract_func_before": "int PipeSocketHandler::connect(const SocketEndpoint& VAR_0) {\n  lock_guard<std::recursive_mutex> mutexGuard(globalMutex);\n\n  string VAR_1 = VAR_0.name();\n  sockaddr_un VAR_2;\n\n  int VAR_3 = ::socket(VAR_4, VAR_5, 0);\n  FATAL_FAIL(VAR_3);\n  initSocket(VAR_3);\n  VAR_2.sun_family = VAR_4;\n  strcpy(VAR_2.sun_path, VAR_1.c_str());\n\n  VLOG(3) << \"Connecting to \" << VAR_0 << \" with fd \" << VAR_3;\n  int VAR_6 =\n      ::connect(VAR_3, (struct sockaddr*)&VAR_2, sizeof(sockaddr_un));\n  auto VAR_7 = GetErrno();\n  if (VAR_6 < 0 && VAR_7 != VAR_8) {\n    VLOG(3) << \"Connection result: \" << VAR_6 << \" (\" << strerror(VAR_7)\n            << \")\";\n#ifdef VAR_9\n    ::shutdown(VAR_3, VAR_10);\n#else\n    ::shutdown(VAR_3, VAR_11);\n#endif\n#ifdef VAR_12\n    FATAL_FAIL(::closesocket(VAR_3));\n#else\n    FATAL_FAIL(::close(VAR_3));\n#endif\n    VAR_3 = -1;\n    SetErrno(VAR_7);\n    return VAR_3;\n  }\n\n  fd_set VAR_13;\n  FD_ZERO(&VAR_13);\n  FD_SET(VAR_3, &VAR_13);\n  timeval VAR_14;\n  VAR_14.tv_sec = 3; /* COMMENT_0 */\n  VAR_14.tv_usec = 0;\n  VLOG(4) << \"Before selecting sockFd\";\n  select(VAR_3 + 1, NULL, &VAR_13, NULL, &VAR_14);\n\n  if (FD_ISSET(VAR_3, &VAR_13)) {\n    VLOG(4) << \"sockFd \" << VAR_3 << \" is selected\";\n    int VAR_15;\n    socklen_t VAR_16 = sizeof VAR_15;\n\n    FATAL_FAIL(\n        ::getsockopt(VAR_3, VAR_17, VAR_18, (char*)&VAR_15, &VAR_16));\n\n    if (VAR_15 == 0) {\n      LOG(VAR_19) << \"Connected to endpoint \" << VAR_0;\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      initSocket(VAR_3);\n\n      /* COMMENT_3 */\n    } else {\n      LOG(VAR_19) << \"Error connecting to \" << VAR_0 << \": \" << VAR_15 << \" \"\n                << strerror(VAR_15);\n#ifdef VAR_12\n      FATAL_FAIL(::closesocket(VAR_3));\n#else\n      FATAL_FAIL(::close(VAR_3));\n#endif\n      VAR_3 = -1;\n    }\n  } else {\n    auto VAR_7 = GetErrno();\n    LOG(VAR_19) << \"Error connecting to \" << VAR_0 << \": \" << VAR_7 << \" \"\n              << strerror(VAR_7);\n#ifdef VAR_12\n    FATAL_FAIL(::closesocket(VAR_3));\n#else\n    FATAL_FAIL(::close(VAR_3));\n#endif\n    VAR_3 = -1;\n  }\n\n  LOG(VAR_19) << VAR_3 << \" is a good socket\";\n  if (VAR_3 >= 0) {\n    addToActiveSockets(VAR_3);\n  }\n  return VAR_3;\n}",
    "func_graph_path_before": "MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/PipeSocketHandler.cpp/vul/before/0.json",
    "func": "int PipeSocketHandler::connect(const SocketEndpoint& endpoint) {\n  lock_guard<std::recursive_mutex> mutexGuard(globalMutex);\n\n  string pipePath = endpoint.name();\n  sockaddr_un remote;\n\n  int sockFd = ::socket(AF_UNIX, SOCK_STREAM, 0);\n  FATAL_FAIL(sockFd);\n  initSocket(sockFd);\n  remote.sun_family = AF_UNIX;\n  strncpy(remote.sun_path, pipePath.c_str(), sizeof(remote.sun_path));\n\n  VLOG(3) << \"Connecting to \" << endpoint << \" with fd \" << sockFd;\n  int result =\n      ::connect(sockFd, (struct sockaddr*)&remote, sizeof(sockaddr_un));\n  auto localErrno = GetErrno();\n  if (result < 0 && localErrno != EINPROGRESS) {\n    VLOG(3) << \"Connection result: \" << result << \" (\" << strerror(localErrno)\n            << \")\";\n#ifdef WIN32\n    ::shutdown(sockFd, SD_BOTH);\n#else\n    ::shutdown(sockFd, SHUT_RDWR);\n#endif\n#ifdef _MSC_VER\n    FATAL_FAIL(::closesocket(sockFd));\n#else\n    FATAL_FAIL(::close(sockFd));\n#endif\n    sockFd = -1;\n    SetErrno(localErrno);\n    return sockFd;\n  }\n\n  fd_set fdset;\n  FD_ZERO(&fdset);\n  FD_SET(sockFd, &fdset);\n  timeval tv;\n  tv.tv_sec = 3; /* 3 second timeout */\n  tv.tv_usec = 0;\n  VLOG(4) << \"Before selecting sockFd\";\n  select(sockFd + 1, NULL, &fdset, NULL, &tv);\n\n  if (FD_ISSET(sockFd, &fdset)) {\n    VLOG(4) << \"sockFd \" << sockFd << \" is selected\";\n    int so_error;\n    socklen_t len = sizeof so_error;\n\n    FATAL_FAIL(\n        ::getsockopt(sockFd, SOL_SOCKET, SO_ERROR, (char*)&so_error, &len));\n\n    if (so_error == 0) {\n      LOG(INFO) << \"Connected to endpoint \" << endpoint;\n      // Initialize the socket again once it's blocking to make sure timeouts\n      // are set\n      initSocket(sockFd);\n\n      // if we get here, we must have connected successfully\n    } else {\n      LOG(INFO) << \"Error connecting to \" << endpoint << \": \" << so_error << \" \"\n                << strerror(so_error);\n#ifdef _MSC_VER\n      FATAL_FAIL(::closesocket(sockFd));\n#else\n      FATAL_FAIL(::close(sockFd));\n#endif\n      sockFd = -1;\n    }\n  } else {\n    auto localErrno = GetErrno();\n    LOG(INFO) << \"Error connecting to \" << endpoint << \": \" << localErrno << \" \"\n              << strerror(localErrno);\n#ifdef _MSC_VER\n    FATAL_FAIL(::closesocket(sockFd));\n#else\n    FATAL_FAIL(::close(sockFd));\n#endif\n    sockFd = -1;\n  }\n\n  LOG(INFO) << sockFd << \" is a good socket\";\n  if (sockFd >= 0) {\n    addToActiveSockets(sockFd);\n  }\n  return sockFd;\n}",
    "abstract_func": "int PipeSocketHandler::connect(const SocketEndpoint& VAR_0) {\n  lock_guard<std::recursive_mutex> mutexGuard(globalMutex);\n\n  string VAR_1 = VAR_0.name();\n  sockaddr_un VAR_2;\n\n  int VAR_3 = ::socket(VAR_4, VAR_5, 0);\n  FATAL_FAIL(VAR_3);\n  initSocket(VAR_3);\n  VAR_2.sun_family = VAR_4;\n  strncpy(VAR_2.sun_path, VAR_1.c_str(), sizeof(VAR_2.sun_path));\n\n  VLOG(3) << \"Connecting to \" << VAR_0 << \" with fd \" << VAR_3;\n  int VAR_6 =\n      ::connect(VAR_3, (struct sockaddr*)&VAR_2, sizeof(sockaddr_un));\n  auto VAR_7 = GetErrno();\n  if (VAR_6 < 0 && VAR_7 != VAR_8) {\n    VLOG(3) << \"Connection result: \" << VAR_6 << \" (\" << strerror(VAR_7)\n            << \")\";\n#ifdef VAR_9\n    ::shutdown(VAR_3, VAR_10);\n#else\n    ::shutdown(VAR_3, VAR_11);\n#endif\n#ifdef VAR_12\n    FATAL_FAIL(::closesocket(VAR_3));\n#else\n    FATAL_FAIL(::close(VAR_3));\n#endif\n    VAR_3 = -1;\n    SetErrno(VAR_7);\n    return VAR_3;\n  }\n\n  fd_set VAR_13;\n  FD_ZERO(&VAR_13);\n  FD_SET(VAR_3, &VAR_13);\n  timeval VAR_14;\n  VAR_14.tv_sec = 3; /* COMMENT_0 */\n  VAR_14.tv_usec = 0;\n  VLOG(4) << \"Before selecting sockFd\";\n  select(VAR_3 + 1, NULL, &VAR_13, NULL, &VAR_14);\n\n  if (FD_ISSET(VAR_3, &VAR_13)) {\n    VLOG(4) << \"sockFd \" << VAR_3 << \" is selected\";\n    int VAR_15;\n    socklen_t VAR_16 = sizeof VAR_15;\n\n    FATAL_FAIL(\n        ::getsockopt(VAR_3, VAR_17, VAR_18, (char*)&VAR_15, &VAR_16));\n\n    if (VAR_15 == 0) {\n      LOG(VAR_19) << \"Connected to endpoint \" << VAR_0;\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      initSocket(VAR_3);\n\n      /* COMMENT_3 */\n    } else {\n      LOG(VAR_19) << \"Error connecting to \" << VAR_0 << \": \" << VAR_15 << \" \"\n                << strerror(VAR_15);\n#ifdef VAR_12\n      FATAL_FAIL(::closesocket(VAR_3));\n#else\n      FATAL_FAIL(::close(VAR_3));\n#endif\n      VAR_3 = -1;\n    }\n  } else {\n    auto VAR_7 = GetErrno();\n    LOG(VAR_19) << \"Error connecting to \" << VAR_0 << \": \" << VAR_7 << \" \"\n              << strerror(VAR_7);\n#ifdef VAR_12\n    FATAL_FAIL(::closesocket(VAR_3));\n#else\n    FATAL_FAIL(::close(VAR_3));\n#endif\n    VAR_3 = -1;\n  }\n\n  LOG(VAR_19) << VAR_3 << \" is a good socket\";\n  if (VAR_3 >= 0) {\n    addToActiveSockets(VAR_3);\n  }\n  return VAR_3;\n}",
    "func_graph_path": "MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/PipeSocketHandler.cpp/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n   FATAL_FAIL(sockFd);\n   initSocket(sockFd);\n   remote.sun_family = AF_UNIX;\n-  strcpy(remote.sun_path, pipePath.c_str());\n+  strncpy(remote.sun_path, pipePath.c_str(), sizeof(remote.sun_path));\n \n   VLOG(3) << \"Connecting to \" << endpoint << \" with fd \" << sockFd;\n   int result =",
    "diff_line_info": {
        "deleted_lines": [
            "  strcpy(remote.sun_path, pipePath.c_str());"
        ],
        "added_lines": [
            "  strncpy(remote.sun_path, pipePath.c_str(), sizeof(remote.sun_path));"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/MisterTea/EternalTerminal/pull/468",
    "description": "no more info"
}