{
    "cve_id": "CVE-2014-8109",
    "cwe_ids": [
        "CWE-863"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "apache/httpd",
    "commit_msg": "Merge r1642499 from trunk:\n\n  *) SECURITY: CVE-2014-8109 (cve.mitre.org)\n     mod_lua: Fix handling of the Require line when a LuaAuthzProvider is\n     used in multiple Require directives with different arguments.\n     PR57204 [Edward Lu <Chaosed0 gmail.com>]\n\nSubmitted By: Edward Lu\nCommitted By: covener\n\n\nSubmitted by: covener\nReviewed/backported by: jim\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x@1642861 13f79535-47bb-0310-9956-ffa450edef68",
    "commit_hash": "3f1693d558d0758f829c8b53993f1749ddf6ffcb",
    "git_url": "https://github.com/apache/httpd/commit/3f1693d558d0758f829c8b53993f1749ddf6ffcb",
    "file_path": "modules/lua/mod_lua.c",
    "func_name": "lua_authz_check",
    "func_before": "static authz_status lua_authz_check(request_rec *r, const char *require_line,\n                                    const void *parsed_require_line)\n{\n    apr_pool_t *pool;\n    ap_lua_vm_spec *spec;\n    lua_State *L;\n    ap_lua_server_cfg *server_cfg = ap_get_module_config(r->server->module_config,\n                                                         &lua_module);\n    const ap_lua_dir_cfg *cfg = ap_get_module_config(r->per_dir_config,\n                                                     &lua_module);\n    const lua_authz_provider_spec *prov_spec = parsed_require_line;\n    int result;\n    int nargs = 0;\n\n    spec = create_vm_spec(&pool, r, cfg, server_cfg, prov_spec->file_name,\n                          NULL, 0, prov_spec->function_name, \"authz provider\");\n\n    L = ap_lua_get_lua_state(pool, spec, r);\n    if (L == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02314)\n                      \"Unable to compile VM for authz provider %s\", prov_spec->name);\n        return AUTHZ_GENERAL_ERROR;\n    }\n    lua_getglobal(L, prov_spec->function_name);\n    if (!lua_isfunction(L, -1)) {\n        ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(02319)\n                      \"Unable to find entry function '%s' in %s (not a valid function)\",\n                      prov_spec->function_name, prov_spec->file_name);\n        ap_lua_release_state(L, spec, r);\n        return AUTHZ_GENERAL_ERROR;\n    }\n    ap_lua_run_lua_request(L, r);\n    if (prov_spec->args) {\n        int i;\n        if (!lua_checkstack(L, prov_spec->args->nelts)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02315)\n                          \"Error: authz provider %s: too many arguments\", prov_spec->name);\n            ap_lua_release_state(L, spec, r);\n            return AUTHZ_GENERAL_ERROR;\n        }\n        for (i = 0; i < prov_spec->args->nelts; i++) {\n            const char *arg = APR_ARRAY_IDX(prov_spec->args, i, const char *);\n            lua_pushstring(L, arg);\n        }\n        nargs = prov_spec->args->nelts;\n    }\n    if (lua_pcall(L, 1 + nargs, 1, 0)) {\n        const char *err = lua_tostring(L, -1);\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02316)\n                      \"Error executing authz provider %s: %s\", prov_spec->name, err);\n        ap_lua_release_state(L, spec, r);\n        return AUTHZ_GENERAL_ERROR;\n    }\n    if (!lua_isnumber(L, -1)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02317)\n                      \"Error: authz provider %s did not return integer\", prov_spec->name);\n        ap_lua_release_state(L, spec, r);\n        return AUTHZ_GENERAL_ERROR;\n    }\n    result = lua_tointeger(L, -1);\n    ap_lua_release_state(L, spec, r);\n    switch (result) {\n        case AUTHZ_DENIED:\n        case AUTHZ_GRANTED:\n        case AUTHZ_NEUTRAL:\n        case AUTHZ_GENERAL_ERROR:\n        case AUTHZ_DENIED_NO_USER:\n            return result;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02318)\n                          \"Error: authz provider %s: invalid return value %d\",\n                          prov_spec->name, result);\n    }\n    return AUTHZ_GENERAL_ERROR;\n}",
    "abstract_func_before": "static authz_status lua_authz_check(request_rec *VAR_0, const char *VAR_1,\n                                    const void *VAR_2)\n{\n    apr_pool_t *VAR_3;\n    ap_lua_vm_spec *VAR_4;\n    lua_State *VAR_5;\n    ap_lua_server_cfg *VAR_6 = ap_get_module_config(VAR_0->server->module_config,\n                                                         &VAR_7);\n    const ap_lua_dir_cfg *VAR_8 = ap_get_module_config(VAR_0->per_dir_config,\n                                                     &VAR_7);\n    const lua_authz_provider_spec *VAR_9 = VAR_2;\n    int VAR_10;\n    int VAR_11 = 0;\n\n    VAR_4 = create_vm_spec(&VAR_3, VAR_0, VAR_8, VAR_6, VAR_9->file_name,\n                          NULL, 0, VAR_9->function_name, \"authz provider\");\n\n    VAR_5 = ap_lua_get_lua_state(VAR_3, VAR_4, VAR_0);\n    if (VAR_5 == NULL) {\n        ap_log_rerror(VAR_12, VAR_13, 0, VAR_0, APLOGNO(02314)\n                      \"Unable to compile VM for authz provider %s\", VAR_9->name);\n        return VAR_14;\n    }\n    lua_getglobal(VAR_5, VAR_9->function_name);\n    if (!lua_isfunction(VAR_5, -1)) {\n        ap_log_rerror(VAR_12, VAR_15, 0, VAR_0, APLOGNO(02319)\n                      \"Unable to find entry function '%s' in %s (not a valid function)\",\n                      VAR_9->function_name, VAR_9->file_name);\n        ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n        return VAR_14;\n    }\n    ap_lua_run_lua_request(VAR_5, VAR_0);\n    if (VAR_9->args) {\n        int VAR_16;\n        if (!lua_checkstack(VAR_5, VAR_9->args->nelts)) {\n            ap_log_rerror(VAR_12, VAR_13, 0, VAR_0, APLOGNO(02315)\n                          \"Error: authz provider %s: too many arguments\", VAR_9->name);\n            ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n            return VAR_14;\n        }\n        for (VAR_16 = 0; VAR_16 < VAR_9->args->nelts; VAR_16++) {\n            const char *VAR_17 = APR_ARRAY_IDX(VAR_9->args, VAR_16, VAR_18 char *);\n            lua_pushstring(VAR_5, VAR_17);\n        }\n        VAR_11 = VAR_9->args->nelts;\n    }\n    if (lua_pcall(VAR_5, 1 + VAR_11, 1, 0)) {\n        const char *VAR_19 = lua_tostring(VAR_5, -1);\n        ap_log_rerror(VAR_12, VAR_13, 0, VAR_0, APLOGNO(02316)\n                      \"Error executing authz provider %s: %s\", VAR_9->name, VAR_19);\n        ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n        return VAR_14;\n    }\n    if (!lua_isnumber(VAR_5, -1)) {\n        ap_log_rerror(VAR_12, VAR_13, 0, VAR_0, APLOGNO(02317)\n                      \"Error: authz provider %s did not return integer\", VAR_9->name);\n        ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n        return VAR_14;\n    }\n    VAR_10 = lua_tointeger(VAR_5, -1);\n    ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n    switch (VAR_10) {\n        case VAR_20:\n        case VAR_21:\n        case VAR_22:\n        case VAR_14:\n        case VAR_23:\n            return VAR_10;\n        default:\n            ap_log_rerror(VAR_12, VAR_13, 0, VAR_0, APLOGNO(02318)\n                          \"Error: authz provider %s: invalid return value %d\",\n                          VAR_9->name, VAR_10);\n    }\n    return VAR_14;\n}",
    "func_graph_path_before": "apache/httpd/3f1693d558d0758f829c8b53993f1749ddf6ffcb/mod_lua.c/vul/before/1.json",
    "func": "static authz_status lua_authz_check(request_rec *r, const char *require_line,\n                                    const void *parsed_require_line)\n{\n    apr_pool_t *pool;\n    ap_lua_vm_spec *spec;\n    lua_State *L;\n    ap_lua_server_cfg *server_cfg = ap_get_module_config(r->server->module_config,\n                                                         &lua_module);\n    const ap_lua_dir_cfg *cfg = ap_get_module_config(r->per_dir_config,\n                                                     &lua_module);\n    const lua_authz_provider_func *prov_func = parsed_require_line;\n    const lua_authz_provider_spec *prov_spec = prov_func->spec;\n    int result;\n    int nargs = 0;\n\n    spec = create_vm_spec(&pool, r, cfg, server_cfg, prov_spec->file_name,\n                          NULL, 0, prov_spec->function_name, \"authz provider\");\n\n    L = ap_lua_get_lua_state(pool, spec, r);\n    if (L == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02314)\n                      \"Unable to compile VM for authz provider %s\", prov_spec->name);\n        return AUTHZ_GENERAL_ERROR;\n    }\n    lua_getglobal(L, prov_spec->function_name);\n    if (!lua_isfunction(L, -1)) {\n        ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(02319)\n                      \"Unable to find entry function '%s' in %s (not a valid function)\",\n                      prov_spec->function_name, prov_spec->file_name);\n        ap_lua_release_state(L, spec, r);\n        return AUTHZ_GENERAL_ERROR;\n    }\n    ap_lua_run_lua_request(L, r);\n    if (prov_func->args) {\n        int i;\n        if (!lua_checkstack(L, prov_func->args->nelts)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02315)\n                          \"Error: authz provider %s: too many arguments\", prov_spec->name);\n            ap_lua_release_state(L, spec, r);\n            return AUTHZ_GENERAL_ERROR;\n        }\n        for (i = 0; i < prov_func->args->nelts; i++) {\n            const char *arg = APR_ARRAY_IDX(prov_func->args, i, const char *);\n            lua_pushstring(L, arg);\n        }\n        nargs = prov_func->args->nelts;\n    }\n    if (lua_pcall(L, 1 + nargs, 1, 0)) {\n        const char *err = lua_tostring(L, -1);\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02316)\n                      \"Error executing authz provider %s: %s\", prov_spec->name, err);\n        ap_lua_release_state(L, spec, r);\n        return AUTHZ_GENERAL_ERROR;\n    }\n    if (!lua_isnumber(L, -1)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02317)\n                      \"Error: authz provider %s did not return integer\", prov_spec->name);\n        ap_lua_release_state(L, spec, r);\n        return AUTHZ_GENERAL_ERROR;\n    }\n    result = lua_tointeger(L, -1);\n    ap_lua_release_state(L, spec, r);\n    switch (result) {\n        case AUTHZ_DENIED:\n        case AUTHZ_GRANTED:\n        case AUTHZ_NEUTRAL:\n        case AUTHZ_GENERAL_ERROR:\n        case AUTHZ_DENIED_NO_USER:\n            return result;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02318)\n                          \"Error: authz provider %s: invalid return value %d\",\n                          prov_spec->name, result);\n    }\n    return AUTHZ_GENERAL_ERROR;\n}",
    "abstract_func": "static authz_status lua_authz_check(request_rec *VAR_0, const char *VAR_1,\n                                    const void *VAR_2)\n{\n    apr_pool_t *VAR_3;\n    ap_lua_vm_spec *VAR_4;\n    lua_State *VAR_5;\n    ap_lua_server_cfg *VAR_6 = ap_get_module_config(VAR_0->server->module_config,\n                                                         &VAR_7);\n    const ap_lua_dir_cfg *VAR_8 = ap_get_module_config(VAR_0->per_dir_config,\n                                                     &VAR_7);\n    const lua_authz_provider_func *VAR_9 = VAR_2;\n    const lua_authz_provider_spec *VAR_10 = VAR_9->spec;\n    int VAR_11;\n    int VAR_12 = 0;\n\n    VAR_4 = create_vm_spec(&VAR_3, VAR_0, VAR_8, VAR_6, VAR_10->file_name,\n                          NULL, 0, VAR_10->function_name, \"authz provider\");\n\n    VAR_5 = ap_lua_get_lua_state(VAR_3, VAR_4, VAR_0);\n    if (VAR_5 == NULL) {\n        ap_log_rerror(VAR_13, VAR_14, 0, VAR_0, APLOGNO(02314)\n                      \"Unable to compile VM for authz provider %s\", VAR_10->name);\n        return VAR_15;\n    }\n    lua_getglobal(VAR_5, VAR_10->function_name);\n    if (!lua_isfunction(VAR_5, -1)) {\n        ap_log_rerror(VAR_13, VAR_16, 0, VAR_0, APLOGNO(02319)\n                      \"Unable to find entry function '%s' in %s (not a valid function)\",\n                      VAR_10->function_name, VAR_10->file_name);\n        ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n        return VAR_15;\n    }\n    ap_lua_run_lua_request(VAR_5, VAR_0);\n    if (VAR_9->args) {\n        int VAR_17;\n        if (!lua_checkstack(VAR_5, VAR_9->args->nelts)) {\n            ap_log_rerror(VAR_13, VAR_14, 0, VAR_0, APLOGNO(02315)\n                          \"Error: authz provider %s: too many arguments\", VAR_10->name);\n            ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n            return VAR_15;\n        }\n        for (VAR_17 = 0; VAR_17 < VAR_9->args->nelts; VAR_17++) {\n            const char *VAR_18 = APR_ARRAY_IDX(VAR_9->args, VAR_17, VAR_19 char *);\n            lua_pushstring(VAR_5, VAR_18);\n        }\n        VAR_12 = VAR_9->args->nelts;\n    }\n    if (lua_pcall(VAR_5, 1 + VAR_12, 1, 0)) {\n        const char *VAR_20 = lua_tostring(VAR_5, -1);\n        ap_log_rerror(VAR_13, VAR_14, 0, VAR_0, APLOGNO(02316)\n                      \"Error executing authz provider %s: %s\", VAR_10->name, VAR_20);\n        ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n        return VAR_15;\n    }\n    if (!lua_isnumber(VAR_5, -1)) {\n        ap_log_rerror(VAR_13, VAR_14, 0, VAR_0, APLOGNO(02317)\n                      \"Error: authz provider %s did not return integer\", VAR_10->name);\n        ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n        return VAR_15;\n    }\n    VAR_11 = lua_tointeger(VAR_5, -1);\n    ap_lua_release_state(VAR_5, VAR_4, VAR_0);\n    switch (VAR_11) {\n        case VAR_21:\n        case VAR_22:\n        case VAR_23:\n        case VAR_15:\n        case VAR_24:\n            return VAR_11;\n        default:\n            ap_log_rerror(VAR_13, VAR_14, 0, VAR_0, APLOGNO(02318)\n                          \"Error: authz provider %s: invalid return value %d\",\n                          VAR_10->name, VAR_11);\n    }\n    return VAR_15;\n}",
    "func_graph_path": "apache/httpd/3f1693d558d0758f829c8b53993f1749ddf6ffcb/mod_lua.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,8 @@\n                                                          &lua_module);\n     const ap_lua_dir_cfg *cfg = ap_get_module_config(r->per_dir_config,\n                                                      &lua_module);\n-    const lua_authz_provider_spec *prov_spec = parsed_require_line;\n+    const lua_authz_provider_func *prov_func = parsed_require_line;\n+    const lua_authz_provider_spec *prov_spec = prov_func->spec;\n     int result;\n     int nargs = 0;\n \n@@ -30,19 +31,19 @@\n         return AUTHZ_GENERAL_ERROR;\n     }\n     ap_lua_run_lua_request(L, r);\n-    if (prov_spec->args) {\n+    if (prov_func->args) {\n         int i;\n-        if (!lua_checkstack(L, prov_spec->args->nelts)) {\n+        if (!lua_checkstack(L, prov_func->args->nelts)) {\n             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02315)\n                           \"Error: authz provider %s: too many arguments\", prov_spec->name);\n             ap_lua_release_state(L, spec, r);\n             return AUTHZ_GENERAL_ERROR;\n         }\n-        for (i = 0; i < prov_spec->args->nelts; i++) {\n-            const char *arg = APR_ARRAY_IDX(prov_spec->args, i, const char *);\n+        for (i = 0; i < prov_func->args->nelts; i++) {\n+            const char *arg = APR_ARRAY_IDX(prov_func->args, i, const char *);\n             lua_pushstring(L, arg);\n         }\n-        nargs = prov_spec->args->nelts;\n+        nargs = prov_func->args->nelts;\n     }\n     if (lua_pcall(L, 1 + nargs, 1, 0)) {\n         const char *err = lua_tostring(L, -1);",
    "diff_line_info": {
        "deleted_lines": [
            "    const lua_authz_provider_spec *prov_spec = parsed_require_line;",
            "    if (prov_spec->args) {",
            "        if (!lua_checkstack(L, prov_spec->args->nelts)) {",
            "        for (i = 0; i < prov_spec->args->nelts; i++) {",
            "            const char *arg = APR_ARRAY_IDX(prov_spec->args, i, const char *);",
            "        nargs = prov_spec->args->nelts;"
        ],
        "added_lines": [
            "    const lua_authz_provider_func *prov_func = parsed_require_line;",
            "    const lua_authz_provider_spec *prov_spec = prov_func->spec;",
            "    if (prov_func->args) {",
            "        if (!lua_checkstack(L, prov_func->args->nelts)) {",
            "        for (i = 0; i < prov_func->args->nelts; i++) {",
            "            const char *arg = APR_ARRAY_IDX(prov_func->args, i, const char *);",
            "        nargs = prov_func->args->nelts;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}