{
    "cve_id": "CVE-2020-36386",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "Check upon `num_rsp` is insufficient. A malformed event packet with a\nlarge `num_rsp` number makes hci_extended_inquiry_result_evt() go out\nof bounds. Fix it.\n\nThis patch fixes the following syzbot bug:\n\n    https://syzkaller.appspot.com/bug?id=4bf11aa05c4ca51ce0df86e500fce486552dc8d2\n\nReported-by: syzbot+d8489a79b781849b9c46@syzkaller.appspotmail.com\nCc: stable@vger.kernel.org\nSigned-off-by: Peilin Ye <yepeilin.cs@gmail.com>\nAcked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\n",
    "commit_hash": "51c19bf3d5cfaa66571e4b88ba2a6f6295311101",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=51c19bf3d5cfaa66571e4b88ba2a6f6295311101",
    "file_path": "net/bluetooth/hci_event.c",
    "func_name": "hci_extended_inquiry_result_evt",
    "func_before": "static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}",
    "abstract_func_before": "static void hci_extended_inquiry_result_evt(struct hci_dev *VAR_0,\n\t\t\t\t\t    struct sk_buff *VAR_1)\n{\n\tstruct inquiry_data VAR_2;\n\tstruct extended_inquiry_info *VAR_3 = (void *) (VAR_1->data + 1);\n\tint VAR_4 = *((__u8 *) VAR_1->data);\n\tsize_t VAR_5;\n\n\tBT_DBG(\"%s num_rsp %d\", VAR_0->name, VAR_4);\n\n\tif (!VAR_4)\n\t\treturn;\n\n\tif (hci_dev_test_flag(VAR_0, VAR_6))\n\t\treturn;\n\n\thci_dev_lock(VAR_0);\n\n\tfor (; VAR_4; VAR_4--, VAR_3++) {\n\t\tu32 VAR_7;\n\t\tbool VAR_8;\n\n\t\tbacpy(&VAR_2.bdaddr, &VAR_3->bdaddr);\n\t\tVAR_2.pscan_rep_mode\t= VAR_3->pscan_rep_mode;\n\t\tVAR_2.pscan_period_mode\t= VAR_3->pscan_period_mode;\n\t\tVAR_2.pscan_mode\t\t= 0x00;\n\t\tmemcpy(VAR_2.dev_class, VAR_3->dev_class, 3);\n\t\tVAR_2.clock_offset\t= VAR_3->clock_offset;\n\t\tVAR_2.rssi\t\t= VAR_3->rssi;\n\t\tVAR_2.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(VAR_0, VAR_9))\n\t\t\tVAR_8 = eir_get_data(VAR_3->data,\n\t\t\t\t\t\t  sizeof(VAR_3->data),\n\t\t\t\t\t\t  VAR_10, NULL);\n\t\telse\n\t\t\tVAR_8 = true;\n\n\t\tVAR_7 = hci_inquiry_cache_update(VAR_0, &VAR_2, VAR_8);\n\n\t\tVAR_5 = eir_get_length(VAR_3->data, sizeof(VAR_3->data));\n\n\t\tmgmt_device_found(VAR_0, &VAR_3->bdaddr, VAR_11, 0x00,\n\t\t\t\t  VAR_3->dev_class, VAR_3->rssi,\n\t\t\t\t  VAR_7, VAR_3->data, VAR_5, NULL, 0);\n\t}\n\n\thci_dev_unlock(VAR_0);\n}",
    "func_graph_path_before": "torvalds/linux/51c19bf3d5cfaa66571e4b88ba2a6f6295311101/hci_event.c/vul/before/0.json",
    "func": "static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}",
    "abstract_func": "static void hci_extended_inquiry_result_evt(struct hci_dev *VAR_0,\n\t\t\t\t\t    struct sk_buff *VAR_1)\n{\n\tstruct inquiry_data VAR_2;\n\tstruct extended_inquiry_info *VAR_3 = (void *) (VAR_1->data + 1);\n\tint VAR_4 = *((__u8 *) VAR_1->data);\n\tsize_t VAR_5;\n\n\tBT_DBG(\"%s num_rsp %d\", VAR_0->name, VAR_4);\n\n\tif (!VAR_4 || VAR_1->len < VAR_4 * sizeof(*VAR_3) + 1)\n\t\treturn;\n\n\tif (hci_dev_test_flag(VAR_0, VAR_6))\n\t\treturn;\n\n\thci_dev_lock(VAR_0);\n\n\tfor (; VAR_4; VAR_4--, VAR_3++) {\n\t\tu32 VAR_7;\n\t\tbool VAR_8;\n\n\t\tbacpy(&VAR_2.bdaddr, &VAR_3->bdaddr);\n\t\tVAR_2.pscan_rep_mode\t= VAR_3->pscan_rep_mode;\n\t\tVAR_2.pscan_period_mode\t= VAR_3->pscan_period_mode;\n\t\tVAR_2.pscan_mode\t\t= 0x00;\n\t\tmemcpy(VAR_2.dev_class, VAR_3->dev_class, 3);\n\t\tVAR_2.clock_offset\t= VAR_3->clock_offset;\n\t\tVAR_2.rssi\t\t= VAR_3->rssi;\n\t\tVAR_2.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(VAR_0, VAR_9))\n\t\t\tVAR_8 = eir_get_data(VAR_3->data,\n\t\t\t\t\t\t  sizeof(VAR_3->data),\n\t\t\t\t\t\t  VAR_10, NULL);\n\t\telse\n\t\t\tVAR_8 = true;\n\n\t\tVAR_7 = hci_inquiry_cache_update(VAR_0, &VAR_2, VAR_8);\n\n\t\tVAR_5 = eir_get_length(VAR_3->data, sizeof(VAR_3->data));\n\n\t\tmgmt_device_found(VAR_0, &VAR_3->bdaddr, VAR_11, 0x00,\n\t\t\t\t  VAR_3->dev_class, VAR_3->rssi,\n\t\t\t\t  VAR_7, VAR_3->data, VAR_5, NULL, 0);\n\t}\n\n\thci_dev_unlock(VAR_0);\n}",
    "func_graph_path": "torvalds/linux/51c19bf3d5cfaa66571e4b88ba2a6f6295311101/hci_event.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \n \tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n \n-\tif (!num_rsp)\n+\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)\n \t\treturn;\n \n \tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (!num_rsp)"
        ],
        "added_lines": [
            "\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}