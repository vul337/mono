{
    "cve_id": "CVE-2012-6616",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "ffmpeg",
    "commit_msg": "\nlavc/movtextdec: keep the min size instead of max to fix overread.\n\nFixes Ticket #2087.\n(cherry picked from commit 7d66bc7920240cc0e8df6c44b2d2cdbe4b228fbe)\n",
    "commit_hash": "68e48ed72e0597ae61bc3e9e6e6d9edcb1a00073",
    "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=68e48ed72e0597ae61bc3e9e6e6d9edcb1a00073",
    "file_path": "libavcodec/movtextdec.c",
    "func_name": "mov_text_decode_frame",
    "func_before": "static int mov_text_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n{\n    AVSubtitle *sub = data;\n    int ts_start, ts_end;\n    AVBPrint buf;\n    const char *ptr = avpkt->data;\n    const char *end;\n\n    if (!ptr || avpkt->size < 2)\n        return AVERROR_INVALIDDATA;\n\n    /*\n     * A packet of size two with value zero is an empty subtitle\n     * used to mark the end of the previous non-empty subtitle.\n     * We can just drop them here as we have duration information\n     * already. If the value is non-zero, then it's technically a\n     * bad packet.\n     */\n    if (avpkt->size == 2)\n        return AV_RB16(ptr) == 0 ? 0 : AVERROR_INVALIDDATA;\n\n    /*\n     * The first two bytes of the packet are the length of the text string\n     * In complex cases, there are style descriptors appended to the string\n     * so we can't just assume the packet size is the string size.\n     */\n    end = ptr + FFMAX(2 + AV_RB16(ptr), avpkt->size);\n    ptr += 2;\n\n    ts_start = av_rescale_q(avpkt->pts,\n                            avctx->time_base,\n                            (AVRational){1,100});\n    ts_end   = av_rescale_q(avpkt->pts + avpkt->duration,\n                            avctx->time_base,\n                            (AVRational){1,100});\n\n    // Note that the spec recommends lines be no longer than 2048 characters.\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n    text_to_ass(&buf, ptr, end);\n\n    if (!av_bprint_is_complete(&buf))\n        return AVERROR(ENOMEM);\n\n    ff_ass_add_rect(sub, buf.str, ts_start, ts_end-ts_start, 0);\n    *got_sub_ptr = sub->num_rects > 0;\n    av_bprint_finalize(&buf, NULL);\n    return avpkt->size;\n}",
    "abstract_func_before": "static int mov_text_decode_frame(AVCodecContext *VAR_0,\n                            void *VAR_1, int *VAR_2, AVPacket *VAR_3)\n{\n    AVSubtitle *VAR_4 = VAR_1;\n    int VAR_5, VAR_6;\n    AVBPrint VAR_7;\n    const char *VAR_8 = VAR_3->data;\n    const char *VAR_9;\n\n    if (!VAR_8 || VAR_3->size < 2)\n        return VAR_10;\n\n    /* COMMENT_0 */\n                                                                \n                                                               \n                                                                 \n                                                                 \n                  \n       \n    if (VAR_3->size == 2)\n        return AV_RB16(VAR_8) == 0 ? 0 : VAR_10;\n\n    /* COMMENT_7 */\n                                                                          \n                                                                           \n                                                                  \n       \n    VAR_9 = VAR_8 + FFMAX(2 + AV_RB16(VAR_8), VAR_3->size);\n    VAR_8 += 2;\n\n    VAR_5 = av_rescale_q(VAR_3->pts,\n                            VAR_0->time_base,\n                            (AVRational){1,100});\n    VAR_6   = av_rescale_q(VAR_3->pts + VAR_3->duration,\n                            VAR_0->time_base,\n                            (AVRational){1,100});\n\n    /* COMMENT_12 */\n    av_bprint_init(&VAR_7, 0, VAR_11);\n    text_to_ass(&VAR_7, VAR_8, VAR_9);\n\n    if (!av_bprint_is_complete(&VAR_7))\n        return AVERROR(VAR_12);\n\n    ff_ass_add_rect(VAR_4, VAR_7.str, VAR_5, VAR_6-VAR_5, 0);\n    *VAR_2 = VAR_4->num_rects > 0;\n    av_bprint_finalize(&VAR_7, NULL);\n    return VAR_3->size;\n}",
    "func_graph_path_before": "ffmpeg/68e48ed72e0597ae61bc3e9e6e6d9edcb1a00073/movtextdec.c/vul/before/0.json",
    "func": "static int mov_text_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n{\n    AVSubtitle *sub = data;\n    int ts_start, ts_end;\n    AVBPrint buf;\n    const char *ptr = avpkt->data;\n    const char *end;\n\n    if (!ptr || avpkt->size < 2)\n        return AVERROR_INVALIDDATA;\n\n    /*\n     * A packet of size two with value zero is an empty subtitle\n     * used to mark the end of the previous non-empty subtitle.\n     * We can just drop them here as we have duration information\n     * already. If the value is non-zero, then it's technically a\n     * bad packet.\n     */\n    if (avpkt->size == 2)\n        return AV_RB16(ptr) == 0 ? 0 : AVERROR_INVALIDDATA;\n\n    /*\n     * The first two bytes of the packet are the length of the text string\n     * In complex cases, there are style descriptors appended to the string\n     * so we can't just assume the packet size is the string size.\n     */\n    end = ptr + FFMIN(2 + AV_RB16(ptr), avpkt->size);\n    ptr += 2;\n\n    ts_start = av_rescale_q(avpkt->pts,\n                            avctx->time_base,\n                            (AVRational){1,100});\n    ts_end   = av_rescale_q(avpkt->pts + avpkt->duration,\n                            avctx->time_base,\n                            (AVRational){1,100});\n\n    // Note that the spec recommends lines be no longer than 2048 characters.\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n    text_to_ass(&buf, ptr, end);\n\n    if (!av_bprint_is_complete(&buf))\n        return AVERROR(ENOMEM);\n\n    ff_ass_add_rect(sub, buf.str, ts_start, ts_end-ts_start, 0);\n    *got_sub_ptr = sub->num_rects > 0;\n    av_bprint_finalize(&buf, NULL);\n    return avpkt->size;\n}",
    "abstract_func": "static int mov_text_decode_frame(AVCodecContext *VAR_0,\n                            void *VAR_1, int *VAR_2, AVPacket *VAR_3)\n{\n    AVSubtitle *VAR_4 = VAR_1;\n    int VAR_5, VAR_6;\n    AVBPrint VAR_7;\n    const char *VAR_8 = VAR_3->data;\n    const char *VAR_9;\n\n    if (!VAR_8 || VAR_3->size < 2)\n        return VAR_10;\n\n    /* COMMENT_0 */\n                                                                \n                                                               \n                                                                 \n                                                                 \n                  \n       \n    if (VAR_3->size == 2)\n        return AV_RB16(VAR_8) == 0 ? 0 : VAR_10;\n\n    /* COMMENT_7 */\n                                                                          \n                                                                           \n                                                                  \n       \n    VAR_9 = VAR_8 + FFMIN(2 + AV_RB16(VAR_8), VAR_3->size);\n    VAR_8 += 2;\n\n    VAR_5 = av_rescale_q(VAR_3->pts,\n                            VAR_0->time_base,\n                            (AVRational){1,100});\n    VAR_6   = av_rescale_q(VAR_3->pts + VAR_3->duration,\n                            VAR_0->time_base,\n                            (AVRational){1,100});\n\n    /* COMMENT_12 */\n    av_bprint_init(&VAR_7, 0, VAR_11);\n    text_to_ass(&VAR_7, VAR_8, VAR_9);\n\n    if (!av_bprint_is_complete(&VAR_7))\n        return AVERROR(VAR_12);\n\n    ff_ass_add_rect(VAR_4, VAR_7.str, VAR_5, VAR_6-VAR_5, 0);\n    *VAR_2 = VAR_4->num_rects > 0;\n    av_bprint_finalize(&VAR_7, NULL);\n    return VAR_3->size;\n}",
    "func_graph_path": "ffmpeg/68e48ed72e0597ae61bc3e9e6e6d9edcb1a00073/movtextdec.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n      * In complex cases, there are style descriptors appended to the string\n      * so we can't just assume the packet size is the string size.\n      */\n-    end = ptr + FFMAX(2 + AV_RB16(ptr), avpkt->size);\n+    end = ptr + FFMIN(2 + AV_RB16(ptr), avpkt->size);\n     ptr += 2;\n \n     ts_start = av_rescale_q(avpkt->pts,",
    "diff_line_info": {
        "deleted_lines": [
            "    end = ptr + FFMAX(2 + AV_RB16(ptr), avpkt->size);"
        ],
        "added_lines": [
            "    end = ptr + FFMIN(2 + AV_RB16(ptr), avpkt->size);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}