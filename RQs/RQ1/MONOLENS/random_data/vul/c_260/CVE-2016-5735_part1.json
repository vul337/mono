{
    "cve_id": "CVE-2016-5735",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "kornelski/pngquant",
    "commit_msg": "Fix integer overflow in rwpng.h (CVE-2016-5735)\n\nReported by Choi Jaeseung \nFound with Sparrow (http://ropas.snu.ac.kr/sparrow)",
    "commit_hash": "b7c217680cda02dddced245d237ebe8c383be285",
    "git_url": "https://github.com/kornelski/pngquant/commit/b7c217680cda02dddced245d237ebe8c383be285",
    "file_path": "rwpng.c",
    "func_name": "rwpng_read_image24_libpng",
    "func_before": "static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)\n{\n    png_structp  png_ptr = NULL;\n    png_infop    info_ptr = NULL;\n    png_size_t   rowbytes;\n    int          color_type, bit_depth;\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);\n    if (!png_ptr) {\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a non-trivial\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return LIBPNG_FATAL_ERROR;   /* fatal libpng error (via longjmp()) */\n    }\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n    png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n\n#if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    /* copy standard chunks too */\n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);\n\n    struct rwpng_read_data read_data = {infile, 0};\n    png_set_read_fn(png_ptr, &read_data, user_read_data);\n\n    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */\n\n    /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);\n\n    // For overflow safety reject images that won't fit in 32-bit\n    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;  /* not quite true, but whatever */\n    }\n\n    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n     * transparency chunks to full alpha channel; strip 16-bit-per-sample\n     * images to 8 bits per sample; and convert grayscale to RGB[A] */\n\n    /* GRR TO DO:  preserve all safe-to-copy ancillary PNG chunks */\n\n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) {\n#ifdef PNG_READ_FILLER_SUPPORTED\n        png_set_expand(png_ptr);\n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);\n#else\n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;\n        return mainprog_ptr->retval;\n#endif\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(png_ptr);\n    }\n\n    if (!(color_type & PNG_COLOR_MASK_COLOR)) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    /* get source gamma for gamma correction, or use sRGB default */\n    double gamma = 0.45455;\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {\n        mainprog_ptr->input_color = RWPNG_SRGB;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    } else {\n        png_get_gAMA(png_ptr, info_ptr, &gamma);\n        if (gamma > 0 && gamma <= 1.0) {\n            mainprog_ptr->input_color = RWPNG_GAMA_ONLY;\n            mainprog_ptr->output_color = RWPNG_GAMA_ONLY;\n        } else {\n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);\n            mainprog_ptr->input_color = RWPNG_NONE;\n            mainprog_ptr->output_color = RWPNG_NONE;\n            gamma = 0.45455;\n        }\n    }\n    mainprog_ptr->gamma = gamma;\n\n    png_set_interlace_handling(png_ptr);\n\n    /* all transformations have been registered; now update info_ptr data,\n     * get rowbytes and channels, and allocate image memory */\n\n    png_read_update_info(png_ptr, info_ptr);\n\n    rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n\n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    /* now we can go ahead and just read the whole image */\n\n    png_read_image(png_ptr, row_pointers);\n\n    /* and we're done!  (png_read_end() can be omitted if no processing of\n     * post-IDAT text/time/etc. is desired) */\n\n    png_read_end(png_ptr, NULL);\n\n#if USE_LCMS\n#if PNG_LIBPNG_VER < 10500\n    png_charp ProfileData;\n#else\n    png_bytep ProfileData;\n#endif\n    png_uint_32 ProfileLen;\n\n    cmsHPROFILE hInProfile = NULL;\n\n    /* color_type is read from the image before conversion to RGBA */\n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;\n\n    /* embedded ICC profile */\n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {\n\n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);\n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);\n\n        /* only RGB (and GRAY) valid for PNGs */\n        if (colorspace == cmsSigRgbData && COLOR_PNG) {\n            mainprog_ptr->input_color = RWPNG_ICCP;\n            mainprog_ptr->output_color = RWPNG_SRGB;\n        } else {\n            if (colorspace == cmsSigGrayData && !COLOR_PNG) {\n                mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;\n                mainprog_ptr->output_color = RWPNG_SRGB;\n            }\n            cmsCloseProfile(hInProfile);\n            hInProfile = NULL;\n        }\n    }\n\n    /* build RGB profile from cHRM and gAMA */\n    if (hInProfile == NULL && COLOR_PNG &&\n        !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {\n\n        cmsCIExyY WhitePoint;\n        cmsCIExyYTRIPLE Primaries;\n\n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,\n                     &Primaries.Red.x, &Primaries.Red.y,\n                     &Primaries.Green.x, &Primaries.Green.y,\n                     &Primaries.Blue.x, &Primaries.Blue.y);\n\n        WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        cmsToneCurve *GammaTable[3];\n        GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);\n\n        hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);\n\n        cmsFreeToneCurve(GammaTable[0]);\n\n        mainprog_ptr->input_color = RWPNG_GAMA_CHRM;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    }\n\n    /* transform image to sRGB colorspace */\n    if (hInProfile != NULL) {\n\n        cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,\n                                                      hOutProfile, TYPE_RGBA_8,\n                                                      INTENT_PERCEPTUAL,\n                                                      omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int i = 0; i < mainprog_ptr->height; i++) {\n            /* It is safe to use the same block for input and output,\n               when both are of the same TYPE. */\n            cmsDoTransform(hTransform, row_pointers[i],\n                                       row_pointers[i],\n                                       mainprog_ptr->width);\n        }\n\n        cmsDeleteTransform(hTransform);\n        cmsCloseProfile(hOutProfile);\n        cmsCloseProfile(hInProfile);\n\n        mainprog_ptr->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\n    mainprog_ptr->file_size = read_data.bytes_read;\n    mainprog_ptr->row_pointers = (unsigned char **)row_pointers;\n\n    return SUCCESS;\n}",
    "abstract_func_before": "static pngquant_error rwpng_read_image24_libpng(FILE *VAR_0, png24_image *VAR_1, int VAR_2)\n{\n    png_structp  VAR_3 = NULL;\n    png_infop    VAR_4 = NULL;\n    png_size_t   VAR_5;\n    int          VAR_6, VAR_7;\n\n    VAR_3 = png_create_read_struct(VAR_8, VAR_1,\n      VAR_9, VAR_2 ? VAR_10 : VAR_11);\n    if (!VAR_3) {\n        return VAR_12;   /* COMMENT_0 */\n    }\n\n    VAR_4 = png_create_info_struct(VAR_3);\n    if (!VAR_4) {\n        png_destroy_read_struct(&VAR_3, NULL, NULL);\n        return VAR_12;   /* COMMENT_0 */\n    }\n\n    /* COMMENT_1 */\n                         \n\n    if (setjmp(VAR_1->jmpbuf)) {\n        png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n        return VAR_13;   /* COMMENT_3 */\n    }\n\n#if defined(VAR_14) && defined(VAR_15)\n    png_set_option(VAR_3, VAR_14, VAR_16);\n#endif\n\n#if VAR_17 >= 10500 && defined(VAR_18)\n    /* COMMENT_4 */\n    png_set_keep_unknown_chunks(VAR_3, VAR_19, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(VAR_3, &VAR_1->chunks, VAR_20);\n\n    struct rwpng_read_data VAR_21 = {VAR_0, 0};\n    png_set_read_fn(VAR_3, &VAR_21, VAR_22);\n\n    png_read_info(VAR_3, VAR_4);  /* COMMENT_5 */\n\n    /* COMMENT_6 */\n                                                                          \n                                                    \n\n    png_get_IHDR(VAR_3, VAR_4, &VAR_1->width, &VAR_1->height,\n                 &VAR_7, &VAR_6, NULL, NULL, NULL);\n\n    /* COMMENT_9 */\n    if (VAR_1->width > VAR_23/VAR_1->height) {\n        png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n        return VAR_12;  /* COMMENT_10 */\n    }\n\n    /* COMMENT_11 */\n                                                                         \n                                                                      \n\n    /* COMMENT_14 */\n\n    if (!(VAR_6 & VAR_24)) {\n#ifdef VAR_25\n        png_set_expand(VAR_3);\n        png_set_filler(VAR_3, 65535L, VAR_26);\n#else\n        fprintf(VAR_27, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n        VAR_1->retval = VAR_28;\n        return VAR_1->retval;\n#endif\n    }\n\n    if (VAR_7 == 16) {\n        png_set_strip_16(VAR_3);\n    }\n\n    if (!(VAR_6 & VAR_29)) {\n        png_set_gray_to_rgb(VAR_3);\n    }\n\n    /* COMMENT_15 */\n    double VAR_30 = 0.45455;\n    if (png_get_valid(VAR_3, VAR_4, VAR_31)) {\n        VAR_1->input_color = VAR_32;\n        VAR_1->output_color = VAR_32;\n    } else {\n        png_get_gAMA(VAR_3, VAR_4, &VAR_30);\n        if (VAR_30 > 0 && VAR_30 <= 1.0) {\n            VAR_1->input_color = VAR_33;\n            VAR_1->output_color = VAR_33;\n        } else {\n            fprintf(VAR_27, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", VAR_30);\n            VAR_1->input_color = VAR_34;\n            VAR_1->output_color = VAR_34;\n            VAR_30 = 0.45455;\n        }\n    }\n    VAR_1->gamma = VAR_30;\n\n    png_set_interlace_handling(VAR_3);\n\n    /* COMMENT_16 */\n                                                              \n\n    png_read_update_info(VAR_3, VAR_4);\n\n    VAR_5 = png_get_rowbytes(VAR_3, VAR_4);\n\n    if ((VAR_1->rgba_data = malloc(VAR_5 * VAR_1->height)) == NULL) {\n        fprintf(VAR_27, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n        return VAR_12;\n    }\n\n    png_bytepp VAR_35 = rwpng_create_row_pointers(VAR_4, VAR_3, VAR_1->rgba_data, VAR_1->height, 0);\n\n    /* COMMENT_18 */\n\n    png_read_image(VAR_3, VAR_35);\n\n    /* COMMENT_19 */\n                                              \n\n    png_read_end(VAR_3, NULL);\n\n#if VAR_36\n#if VAR_17 < 10500\n    png_charp VAR_37;\n#else\n    png_bytep VAR_37;\n#endif\n    png_uint_32 VAR_38;\n\n    cmsHPROFILE VAR_39 = NULL;\n\n    /* COMMENT_21 */\n    int VAR_40 = VAR_6 & VAR_29;\n\n    /* COMMENT_22 */\n    if (png_get_iCCP(VAR_3, VAR_4, &(png_charp){0}, &(int){0}, &VAR_37, &VAR_38)) {\n\n        VAR_39 = cmsOpenProfileFromMem(VAR_37, VAR_38);\n        cmsColorSpaceSignature VAR_41 = cmsGetColorSpace(VAR_39);\n\n        /* COMMENT_23 */\n        if (VAR_41 == VAR_42 && VAR_40) {\n            VAR_1->input_color = VAR_43;\n            VAR_1->output_color = VAR_32;\n        } else {\n            if (VAR_41 == VAR_44 && !VAR_40) {\n                VAR_1->input_color = VAR_45;\n                VAR_1->output_color = VAR_32;\n            }\n            cmsCloseProfile(VAR_39);\n            VAR_39 = NULL;\n        }\n    }\n\n    /* COMMENT_24 */\n    if (VAR_39 == NULL && VAR_40 &&\n        !png_get_valid(VAR_3, VAR_4, VAR_31) &&\n        png_get_valid(VAR_3, VAR_4, VAR_46) &&\n        png_get_valid(VAR_3, VAR_4, VAR_47)) {\n\n        cmsCIExyY VAR_48;\n        cmsCIExyYTRIPLE VAR_49;\n\n        png_get_cHRM(VAR_3, VAR_4, &VAR_48.x, &VAR_48.y,\n                     &VAR_49.Red.x, &VAR_49.Red.y,\n                     &VAR_49.Green.x, &VAR_49.Green.y,\n                     &VAR_49.Blue.x, &VAR_49.Blue.y);\n\n        VAR_48.Y = VAR_49.Red.Y = VAR_49.Green.Y = VAR_49.Blue.Y = 1.0;\n\n        cmsToneCurve *VAR_50[3];\n        VAR_50[0] = VAR_50[1] = VAR_50[2] = cmsBuildGamma(NULL, 1/VAR_30);\n\n        VAR_39 = cmsCreateRGBProfile(&VAR_48, &VAR_49, VAR_50);\n\n        cmsFreeToneCurve(VAR_50[0]);\n\n        VAR_1->input_color = VAR_51;\n        VAR_1->output_color = VAR_32;\n    }\n\n    /* COMMENT_25 */\n    if (VAR_39 != NULL) {\n\n        cmsHPROFILE VAR_52 = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM VAR_53 = cmsCreateTransform(VAR_39, VAR_54,\n                                                      VAR_52, VAR_54,\n                                                      VAR_55,\n                                                      omp_get_max_threads() > 1 ? VAR_56 : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int VAR_57 = 0; VAR_57 < VAR_1->height; VAR_57++) {\n            /* COMMENT_26 */\n                                                 \n            cmsDoTransform(VAR_53, VAR_35[VAR_57],\n                                       VAR_35[VAR_57],\n                                       VAR_1->width);\n        }\n\n        cmsDeleteTransform(VAR_53);\n        cmsCloseProfile(VAR_52);\n        cmsCloseProfile(VAR_39);\n\n        VAR_1->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n\n    VAR_1->file_size = VAR_21.bytes_read;\n    VAR_1->row_pointers = (unsigned char **)VAR_35;\n\n    return VAR_58;\n}",
    "func_graph_path_before": "kornelski/pngquant/b7c217680cda02dddced245d237ebe8c383be285/rwpng.c/vul/before/0.json",
    "func": "static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose)\n{\n    png_structp  png_ptr = NULL;\n    png_infop    info_ptr = NULL;\n    png_size_t   rowbytes;\n    int          color_type, bit_depth;\n\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,\n      rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler);\n    if (!png_ptr) {\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;   /* out of memory */\n    }\n\n    /* setjmp() must be called in every function that calls a non-trivial\n     * libpng function */\n\n    if (setjmp(mainprog_ptr->jmpbuf)) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return LIBPNG_FATAL_ERROR;   /* fatal libpng error (via longjmp()) */\n    }\n\n#if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n    png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#endif\n\n#if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n    /* copy standard chunks too */\n    png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback);\n\n    struct rwpng_read_data read_data = {infile, 0};\n    png_set_read_fn(png_ptr, &read_data, user_read_data);\n\n    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */\n\n    /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);\n\n    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n     * transparency chunks to full alpha channel; strip 16-bit-per-sample\n     * images to 8 bits per sample; and convert grayscale to RGB[A] */\n\n    /* GRR TO DO:  preserve all safe-to-copy ancillary PNG chunks */\n\n    if (!(color_type & PNG_COLOR_MASK_ALPHA)) {\n#ifdef PNG_READ_FILLER_SUPPORTED\n        png_set_expand(png_ptr);\n        png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER);\n#else\n        fprintf(stderr, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE;\n        return mainprog_ptr->retval;\n#endif\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(png_ptr);\n    }\n\n    if (!(color_type & PNG_COLOR_MASK_COLOR)) {\n        png_set_gray_to_rgb(png_ptr);\n    }\n\n    /* get source gamma for gamma correction, or use sRGB default */\n    double gamma = 0.45455;\n    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) {\n        mainprog_ptr->input_color = RWPNG_SRGB;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    } else {\n        png_get_gAMA(png_ptr, info_ptr, &gamma);\n        if (gamma > 0 && gamma <= 1.0) {\n            mainprog_ptr->input_color = RWPNG_GAMA_ONLY;\n            mainprog_ptr->output_color = RWPNG_GAMA_ONLY;\n        } else {\n            fprintf(stderr, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", gamma);\n            mainprog_ptr->input_color = RWPNG_NONE;\n            mainprog_ptr->output_color = RWPNG_NONE;\n            gamma = 0.45455;\n        }\n    }\n    mainprog_ptr->gamma = gamma;\n\n    png_set_interlace_handling(png_ptr);\n\n    /* all transformations have been registered; now update info_ptr data,\n     * get rowbytes and channels, and allocate image memory */\n\n    png_read_update_info(png_ptr, info_ptr);\n\n    rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n\n    // For overflow safety reject images that won't fit in 32-bit\n    if (rowbytes > INT_MAX/mainprog_ptr->height) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n        fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n        return PNG_OUT_OF_MEMORY_ERROR;\n    }\n\n    png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0);\n\n    /* now we can go ahead and just read the whole image */\n\n    png_read_image(png_ptr, row_pointers);\n\n    /* and we're done!  (png_read_end() can be omitted if no processing of\n     * post-IDAT text/time/etc. is desired) */\n\n    png_read_end(png_ptr, NULL);\n\n#if USE_LCMS\n#if PNG_LIBPNG_VER < 10500\n    png_charp ProfileData;\n#else\n    png_bytep ProfileData;\n#endif\n    png_uint_32 ProfileLen;\n\n    cmsHPROFILE hInProfile = NULL;\n\n    /* color_type is read from the image before conversion to RGBA */\n    int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR;\n\n    /* embedded ICC profile */\n    if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) {\n\n        hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen);\n        cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile);\n\n        /* only RGB (and GRAY) valid for PNGs */\n        if (colorspace == cmsSigRgbData && COLOR_PNG) {\n            mainprog_ptr->input_color = RWPNG_ICCP;\n            mainprog_ptr->output_color = RWPNG_SRGB;\n        } else {\n            if (colorspace == cmsSigGrayData && !COLOR_PNG) {\n                mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY;\n                mainprog_ptr->output_color = RWPNG_SRGB;\n            }\n            cmsCloseProfile(hInProfile);\n            hInProfile = NULL;\n        }\n    }\n\n    /* build RGB profile from cHRM and gAMA */\n    if (hInProfile == NULL && COLOR_PNG &&\n        !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) &&\n        png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) {\n\n        cmsCIExyY WhitePoint;\n        cmsCIExyYTRIPLE Primaries;\n\n        png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y,\n                     &Primaries.Red.x, &Primaries.Red.y,\n                     &Primaries.Green.x, &Primaries.Green.y,\n                     &Primaries.Blue.x, &Primaries.Blue.y);\n\n        WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0;\n\n        cmsToneCurve *GammaTable[3];\n        GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma);\n\n        hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable);\n\n        cmsFreeToneCurve(GammaTable[0]);\n\n        mainprog_ptr->input_color = RWPNG_GAMA_CHRM;\n        mainprog_ptr->output_color = RWPNG_SRGB;\n    }\n\n    /* transform image to sRGB colorspace */\n    if (hInProfile != NULL) {\n\n        cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8,\n                                                      hOutProfile, TYPE_RGBA_8,\n                                                      INTENT_PERCEPTUAL,\n                                                      omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int i = 0; i < mainprog_ptr->height; i++) {\n            /* It is safe to use the same block for input and output,\n               when both are of the same TYPE. */\n            cmsDoTransform(hTransform, row_pointers[i],\n                                       row_pointers[i],\n                                       mainprog_ptr->width);\n        }\n\n        cmsDeleteTransform(hTransform);\n        cmsCloseProfile(hOutProfile);\n        cmsCloseProfile(hInProfile);\n\n        mainprog_ptr->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\n    mainprog_ptr->file_size = read_data.bytes_read;\n    mainprog_ptr->row_pointers = (unsigned char **)row_pointers;\n\n    return SUCCESS;\n}",
    "abstract_func": "static pngquant_error rwpng_read_image24_libpng(FILE *VAR_0, png24_image *VAR_1, int VAR_2)\n{\n    png_structp  VAR_3 = NULL;\n    png_infop    VAR_4 = NULL;\n    png_size_t   VAR_5;\n    int          VAR_6, VAR_7;\n\n    VAR_3 = png_create_read_struct(VAR_8, VAR_1,\n      VAR_9, VAR_2 ? VAR_10 : VAR_11);\n    if (!VAR_3) {\n        return VAR_12;   /* COMMENT_0 */\n    }\n\n    VAR_4 = png_create_info_struct(VAR_3);\n    if (!VAR_4) {\n        png_destroy_read_struct(&VAR_3, NULL, NULL);\n        return VAR_12;   /* COMMENT_0 */\n    }\n\n    /* COMMENT_1 */\n                         \n\n    if (setjmp(VAR_1->jmpbuf)) {\n        png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n        return VAR_13;   /* COMMENT_3 */\n    }\n\n#if defined(VAR_14) && defined(VAR_15)\n    png_set_option(VAR_3, VAR_14, VAR_16);\n#endif\n\n#if VAR_17 >= 10500 && defined(VAR_18)\n    /* COMMENT_4 */\n    png_set_keep_unknown_chunks(VAR_3, VAR_19, (png_const_bytep)\"pHYs\\0iTXt\\0tEXt\\0zTXt\", 4);\n#endif\n    png_set_read_user_chunk_fn(VAR_3, &VAR_1->chunks, VAR_20);\n\n    struct rwpng_read_data VAR_21 = {VAR_0, 0};\n    png_set_read_fn(VAR_3, &VAR_21, VAR_22);\n\n    png_read_info(VAR_3, VAR_4);  /* COMMENT_5 */\n\n    /* COMMENT_6 */\n                                                                          \n                                                    \n\n    png_get_IHDR(VAR_3, VAR_4, &VAR_1->width, &VAR_1->height,\n                 &VAR_7, &VAR_6, NULL, NULL, NULL);\n\n    /* COMMENT_9 */\n                                                                         \n                                                                      \n\n    /* COMMENT_12 */\n\n    if (!(VAR_6 & VAR_23)) {\n#ifdef VAR_24\n        png_set_expand(VAR_3);\n        png_set_filler(VAR_3, 65535L, VAR_25);\n#else\n        fprintf(VAR_26, \"pngquant readpng:  image is neither RGBA nor GA\\n\");\n        png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n        VAR_1->retval = VAR_27;\n        return VAR_1->retval;\n#endif\n    }\n\n    if (VAR_7 == 16) {\n        png_set_strip_16(VAR_3);\n    }\n\n    if (!(VAR_6 & VAR_28)) {\n        png_set_gray_to_rgb(VAR_3);\n    }\n\n    /* COMMENT_13 */\n    double VAR_29 = 0.45455;\n    if (png_get_valid(VAR_3, VAR_4, VAR_30)) {\n        VAR_1->input_color = VAR_31;\n        VAR_1->output_color = VAR_31;\n    } else {\n        png_get_gAMA(VAR_3, VAR_4, &VAR_29);\n        if (VAR_29 > 0 && VAR_29 <= 1.0) {\n            VAR_1->input_color = VAR_32;\n            VAR_1->output_color = VAR_32;\n        } else {\n            fprintf(VAR_26, \"pngquant readpng:  ignored out-of-range gamma %f\\n\", VAR_29);\n            VAR_1->input_color = VAR_33;\n            VAR_1->output_color = VAR_33;\n            VAR_29 = 0.45455;\n        }\n    }\n    VAR_1->gamma = VAR_29;\n\n    png_set_interlace_handling(VAR_3);\n\n    /* COMMENT_14 */\n                                                              \n\n    png_read_update_info(VAR_3, VAR_4);\n\n    VAR_5 = png_get_rowbytes(VAR_3, VAR_4);\n\n    /* COMMENT_16 */\n    if (VAR_5 > VAR_34/VAR_1->height) {\n        png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n        return VAR_12;\n    }\n\n    if ((VAR_1->rgba_data = malloc(VAR_5 * VAR_1->height)) == NULL) {\n        fprintf(VAR_26, \"pngquant readpng:  unable to allocate image data\\n\");\n        png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n        return VAR_12;\n    }\n\n    png_bytepp VAR_35 = rwpng_create_row_pointers(VAR_4, VAR_3, VAR_1->rgba_data, VAR_1->height, 0);\n\n    /* COMMENT_17 */\n\n    png_read_image(VAR_3, VAR_35);\n\n    /* COMMENT_18 */\n                                              \n\n    png_read_end(VAR_3, NULL);\n\n#if VAR_36\n#if VAR_17 < 10500\n    png_charp VAR_37;\n#else\n    png_bytep VAR_37;\n#endif\n    png_uint_32 VAR_38;\n\n    cmsHPROFILE VAR_39 = NULL;\n\n    /* COMMENT_20 */\n    int VAR_40 = VAR_6 & VAR_28;\n\n    /* COMMENT_21 */\n    if (png_get_iCCP(VAR_3, VAR_4, &(png_charp){0}, &(int){0}, &VAR_37, &VAR_38)) {\n\n        VAR_39 = cmsOpenProfileFromMem(VAR_37, VAR_38);\n        cmsColorSpaceSignature VAR_41 = cmsGetColorSpace(VAR_39);\n\n        /* COMMENT_22 */\n        if (VAR_41 == VAR_42 && VAR_40) {\n            VAR_1->input_color = VAR_43;\n            VAR_1->output_color = VAR_31;\n        } else {\n            if (VAR_41 == VAR_44 && !VAR_40) {\n                VAR_1->input_color = VAR_45;\n                VAR_1->output_color = VAR_31;\n            }\n            cmsCloseProfile(VAR_39);\n            VAR_39 = NULL;\n        }\n    }\n\n    /* COMMENT_23 */\n    if (VAR_39 == NULL && VAR_40 &&\n        !png_get_valid(VAR_3, VAR_4, VAR_30) &&\n        png_get_valid(VAR_3, VAR_4, VAR_46) &&\n        png_get_valid(VAR_3, VAR_4, VAR_47)) {\n\n        cmsCIExyY VAR_48;\n        cmsCIExyYTRIPLE VAR_49;\n\n        png_get_cHRM(VAR_3, VAR_4, &VAR_48.x, &VAR_48.y,\n                     &VAR_49.Red.x, &VAR_49.Red.y,\n                     &VAR_49.Green.x, &VAR_49.Green.y,\n                     &VAR_49.Blue.x, &VAR_49.Blue.y);\n\n        VAR_48.Y = VAR_49.Red.Y = VAR_49.Green.Y = VAR_49.Blue.Y = 1.0;\n\n        cmsToneCurve *VAR_50[3];\n        VAR_50[0] = VAR_50[1] = VAR_50[2] = cmsBuildGamma(NULL, 1/VAR_29);\n\n        VAR_39 = cmsCreateRGBProfile(&VAR_48, &VAR_49, VAR_50);\n\n        cmsFreeToneCurve(VAR_50[0]);\n\n        VAR_1->input_color = VAR_51;\n        VAR_1->output_color = VAR_31;\n    }\n\n    /* COMMENT_24 */\n    if (VAR_39 != NULL) {\n\n        cmsHPROFILE VAR_52 = cmsCreate_sRGBProfile();\n        cmsHTRANSFORM VAR_53 = cmsCreateTransform(VAR_39, VAR_54,\n                                                      VAR_52, VAR_54,\n                                                      VAR_55,\n                                                      omp_get_max_threads() > 1 ? VAR_56 : 0);\n\n        #pragma omp parallel for \\\n            if (mainprog_ptr->height*mainprog_ptr->width > 8000) \\\n            schedule(static)\n        for (unsigned int VAR_57 = 0; VAR_57 < VAR_1->height; VAR_57++) {\n            /* COMMENT_25 */\n                                                 \n            cmsDoTransform(VAR_53, VAR_35[VAR_57],\n                                       VAR_35[VAR_57],\n                                       VAR_1->width);\n        }\n\n        cmsDeleteTransform(VAR_53);\n        cmsCloseProfile(VAR_52);\n        cmsCloseProfile(VAR_39);\n\n        VAR_1->gamma = 0.45455;\n    }\n#endif\n\n    png_destroy_read_struct(&VAR_3, &VAR_4, NULL);\n\n    VAR_1->file_size = VAR_21.bytes_read;\n    VAR_1->row_pointers = (unsigned char **)VAR_35;\n\n    return VAR_58;\n}",
    "func_graph_path": "kornelski/pngquant/b7c217680cda02dddced245d237ebe8c383be285/rwpng.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -46,12 +46,6 @@\n \n     png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                  &bit_depth, &color_type, NULL, NULL, NULL);\n-\n-    // For overflow safety reject images that won't fit in 32-bit\n-    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {\n-        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n-        return PNG_OUT_OF_MEMORY_ERROR;  /* not quite true, but whatever */\n-    }\n \n     /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,\n      * transparency chunks to full alpha channel; strip 16-bit-per-sample\n@@ -107,6 +101,12 @@\n \n     rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n \n+    // For overflow safety reject images that won't fit in 32-bit\n+    if (rowbytes > INT_MAX/mainprog_ptr->height) {\n+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n+        return PNG_OUT_OF_MEMORY_ERROR;\n+    }\n+\n     if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {\n         fprintf(stderr, \"pngquant readpng:  unable to allocate image data\\n\");\n         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);",
    "diff_line_info": {
        "deleted_lines": [
            "",
            "    // For overflow safety reject images that won't fit in 32-bit",
            "    if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {",
            "        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);",
            "        return PNG_OUT_OF_MEMORY_ERROR;  /* not quite true, but whatever */",
            "    }"
        ],
        "added_lines": [
            "    // For overflow safety reject images that won't fit in 32-bit",
            "    if (rowbytes > INT_MAX/mainprog_ptr->height) {",
            "        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);",
            "        return PNG_OUT_OF_MEMORY_ERROR;",
            "    }",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}