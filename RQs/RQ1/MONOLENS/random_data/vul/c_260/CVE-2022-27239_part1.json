{
    "cve_id": "CVE-2022-27239",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "piastry/cifs-utils",
    "commit_msg": "CVE-2022-27239: mount.cifs: fix length check for ip option parsing\n\nPrevious check was true whatever the length of the input string was,\nleading to a buffer overflow in the subsequent strcpy call.\n\nBug: https://bugzilla.samba.org/show_bug.cgi?id=15025\n\nSigned-off-by: Jeffrey Bencteux <jbe@improsec.com>\nReviewed-by: David Disseldorp <ddiss@suse.de>",
    "commit_hash": "955fb147e97a6a74e1aaa65766de91e2c1479765",
    "git_url": "https://github.com/piastry/cifs-utils/commit/955fb147e97a6a74e1aaa65766de91e2c1479765",
    "file_path": "mount.cifs.c",
    "func_name": "parse_options",
    "func_before": "static int\nparse_options(const char *data, struct parsed_mount_info *parsed_info)\n{\n\tchar *value = NULL;\n\tchar *equals = NULL;\n\tchar *next_keyword = NULL;\n\tchar *out = parsed_info->options;\n\tunsigned long *filesys_flags = &parsed_info->flags;\n\tint out_len = 0;\n\tint word_len;\n\tint rc = 0;\n\tint got_bkupuid = 0;\n\tint got_bkupgid = 0;\n\tint got_uid = 0;\n\tint got_cruid = 0;\n\tint got_gid = 0;\n\tint got_snapshot = 0;\n\tuid_t uid, cruid = 0, bkupuid = 0;\n\tgid_t gid, bkupgid = 0;\n\tchar *ep;\n\tstruct passwd *pw;\n\tstruct group *gr;\n\t/*\n\t * max 64-bit uint in decimal is 18446744073709551615 which is 20 chars\n\t * wide +1 for NULL, and +1 for good measure\n\t */\n\tchar txtbuf[22];\n\tunsigned long long snapshot;\n\tstruct tm tm;\n\n\t/* make sure we're starting from beginning */\n\tout[0] = '\\0';\n\n\t/* BB fixme check for separator override BB */\n\tuid = getuid();\n\tif (uid != 0)\n\t\tgot_uid = 1;\n\n\tgid = getgid();\n\tif (gid != 0)\n\t\tgot_gid = 1;\n\n\tif (!data)\n\t\treturn EX_USAGE;\n\n\t/*\n\t * format is keyword,keyword2=value2,keyword3=value3... \n\t * data  = next keyword\n\t * value = next value ie stuff after equal sign\n\t */\n\twhile (data && *data) {\n\t\tnext_keyword = strchr(data, ',');\t/* BB handle sep= */\n\n\t\t/* temporarily null terminate end of keyword=value pair */\n\t\tif (next_keyword)\n\t\t\t*next_keyword++ = 0;\n\n\t\t/* temporarily null terminate keyword if there's a value */\n\t\tvalue = NULL;\n\t\tif ((equals = strchr(data, '=')) != NULL) {\n\t\t\t*equals = '\\0';\n\t\t\tvalue = equals + 1;\n\t\t}\n\n\t\tswitch(parse_opt_token(data)) {\n\t\tcase OPT_USERS:\n\t\t\tif (!value || !*value) {\n\t\t\t\t*filesys_flags |= MS_USERS;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_USER:\n\t\t\tif (!value || !*value) {\n\t\t\t\tif (data[4] == '\\0') {\n\t\t\t\t\t*filesys_flags |= MS_USER;\n\t\t\t\t\tgoto nocopy;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"username specified with no parameter\\n\");\n\t\t\t\t\treturn EX_USAGE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(parsed_info->username, value,\n\t\t\t\t\tsizeof(parsed_info->username));\n\t\t\t\tparsed_info->got_user = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\tcase OPT_PASS:\n\t\t\tif (parsed_info->got_password) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"password specified twice, ignoring second\\n\");\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (!value || !*value) {\n\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\trc = set_password(parsed_info, value);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_SEC:\n\t\t\tif (value) {\n\t\t\t\tif (!strncmp(value, \"none\", 4))\n\t\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\tif (!strncmp(value, \"krb5\", 4)) {\n\t\t\t\t\tparsed_info->is_krb5 = 1;\n\t\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_IP:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"target ip address argument missing\\n\");\n\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <=\n\t\t\t\tMAX_ADDRESS_LEN) {\n\t\t\t\tstrcpy(parsed_info->addrlist, value);\n\t\t\t\tif (parsed_info->verboseflag)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"ip address %s override specified\\n\",\n\t\t\t\t\t\tvalue);\n\t\t\t\tgoto nocopy;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"ip address too long\\n\");\n\t\t\t\treturn EX_USAGE;\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* unc || target || path */\n\t\tcase OPT_UNC:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"invalid path to network resource\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\trc = parse_unc(value, parsed_info, thisprogram);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\n\t\t/* dom || workgroup */\n\t\tcase OPT_DOM:\n\t\t\tif (!value) {\n\t\t\t\t/*\n\t\t\t\t * An empty domain has been passed\n\t\t\t\t */\n\t\t\t\t/* not necessary but better safe than.. */\n\t\t\t\tparsed_info->domain[0] = '\\0';\n\t\t\t\tparsed_info->got_domain = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (strnlen(value, sizeof(parsed_info->domain)) >=\n\t\t\t    sizeof(parsed_info->domain)) {\n\t\t\t\tfprintf(stderr, \"domain name too long\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\tstrlcpy(parsed_info->domain, value,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_CRED:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"invalid credential file name specified\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\trc = open_cred_file(value, parsed_info);\n\t\t\tif (rc) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"error %d (%s) opening credential file %s\\n\",\n\t\t\t\t\trc, strerror(rc), value);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_UID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_uid = 1;\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw) {\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tuid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option uid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\tcase OPT_CRUID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_cruid = 1;\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw) {\n\t\t\t\tcruid = pw->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tcruid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option: cruid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\tcase OPT_GID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_gid = 1;\n\t\t\tgr = getgrnam(value);\n\t\t\tif (gr) {\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tgid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option: gid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\t/* fmask falls through to file_mode */\n\t\tcase OPT_FMASK:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"WARNING: CIFS mount option 'fmask' is\\\n\t\t\t\t deprecated. Use 'file_mode' instead.\\n\");\n\t\t\tdata = \"file_mode\";\t/* BB fix this */\n\t\t\t/* Fallthrough */\n\t\tcase OPT_FILE_MODE:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tdata);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tif (value[0] != '0')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tdata);\n\t\t\tbreak;\n\n\t\t/* dmask falls through to dir_mode */\n\t\tcase OPT_DMASK:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"WARNING: CIFS mount option 'dmask' is\\\n\t\t\t\t deprecated. Use 'dir_mode' instead.\\n\");\n\t\t\tdata = \"dir_mode\";\n\t\t\t/* Fallthrough */\n\t\tcase OPT_DIR_MODE:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tdata);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tif (value[0] != '0')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tdata);\n\t\t\tbreak;\n\t\tcase OPT_NO_SUID:\n\t\t\t*filesys_flags |= MS_NOSUID;\n\t\t\tgoto nocopy;\n\t\tcase OPT_SUID:\n\t\t\t*filesys_flags &= ~MS_NOSUID;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_DEV:\n\t\t\t*filesys_flags |= MS_NODEV;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_LOCK:\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t\tbreak;\n\t\tcase OPT_MAND:\n\t\t\t*filesys_flags |= MS_MANDLOCK;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NOMAND:\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t\tgoto nocopy;\n\t\tcase OPT_DEV:\n\t\t\t*filesys_flags &= ~MS_NODEV;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_EXEC:\n\t\t\t*filesys_flags |= MS_NOEXEC;\n\t\t\tgoto nocopy;\n\t\tcase OPT_EXEC:\n\t\t\t*filesys_flags &= ~MS_NOEXEC;\n\t\t\tgoto nocopy;\n\t\tcase OPT_GUEST:\n\t\t\tparsed_info->got_user = 1;\n\t\t\tparsed_info->got_password = 1;\n\t\t\tgoto nocopy;\n\t\tcase OPT_RO:\n\t\t\t*filesys_flags |= MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\tcase OPT_RW:\n\t\t\t*filesys_flags &= ~MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\tcase OPT_REMOUNT:\n\t\t\t*filesys_flags |= MS_REMOUNT;\n\t\t\tgoto nocopy;\n\t\tcase OPT_IGNORE:\n\t\t\tgoto nocopy;\n\t\tcase OPT_BKUPUID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_bkupuid = 1;\n\t\t\terrno = 0;\n\t\t\tbkupuid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bad user name \\\"%s\\\"\\n\", value);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tbkupuid = pw->pw_uid;\n\t\t\tgoto nocopy;\n\t\tcase OPT_BKUPGID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_bkupgid = 1;\n\t\t\terrno = 0;\n\t\t\tbkupgid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tgr = getgrnam(value);\n\t\t\tif (gr == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bad group name \\\"%s\\\"\\n\", value);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tbkupgid = gr->gr_gid;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NOFAIL:\n\t\t\tparsed_info->nofail = 1;\n\t\t\tgoto nocopy;\n\t\tcase OPT_SNAPSHOT:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\t\t\tif (strncmp(value, \"@GMT-\", 5))\n\t\t\t\tbreak;\n\t\t\tif ((strlen(value) != GMT_NAME_LEN) ||\n\t\t\t    (strptime(value, GMT_FORMAT, &tm) == NULL)) {\n\t\t\t\tfprintf(stderr, \"bad snapshot token\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\tsnapshot = timegm(&tm) * 10000000 + NTFS_TIME_OFFSET;\n\t\t\tgot_snapshot = 1;\n\t\t\tgoto nocopy;\n\t\t}\n\n\t\t/* check size before copying option to buffer */\n\t\tword_len = strlen(data);\n\t\tif (value)\n\t\t\tword_len += 1 + strlen(value);\n\n\t\t/* need 2 extra bytes for comma and null byte */\n\t\tif (out_len + word_len + 2 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\t/* put back equals sign, if any */\n\t\tif (equals)\n\t\t\t*equals = '=';\n\n\t\t/* go ahead and copy */\n\t\tif (out_len)\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\n\t\tstrlcat(out, data, MAX_OPTIONS_LEN);\n\t\tout_len = strlen(out);\nnocopy:\n\t\tdata = next_keyword;\n\t}\n\n\n\t/* special-case the uid and gid */\n\tif (got_uid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", uid);\n\n\t\t/* comma + \"uid=\" + terminating NULL == 6 */\n\t\tif (out_len + word_len + 6 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"uid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (parsed_info->is_krb5 && parsed_info->sudo_uid) {\n\t\tcruid = parsed_info->sudo_uid;\n\t\tgot_cruid = 1;\n\t}\n\tif (got_cruid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", cruid);\n\n\t\t/* comma + \"cruid=\" + terminating NULL == 8 */\n\t\tif (out_len + word_len + 8 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 7, \"cruid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_gid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", gid);\n\n\t\t/* comma + \"gid=\" + terminating NULL == 6 */\n\t\tif (out_len + word_len + 6 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"gid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_bkupuid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", bkupuid);\n\n\t\t/* comma + \"backupuid=\" + terminating NULL == 12 */\n\t\tif (out_len + word_len + 12 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 11, \"backupuid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_bkupgid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", bkupgid);\n\n\t\t/* comma + \"backupgid=\" + terminating NULL == 12 */\n\t\tif (out_len + word_len + 12 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 11, \"backupgid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_snapshot) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%llu\", snapshot);\n\n\t\t/* comma + \"snapshot=\" + terminating NULL == 11 */\n\t\tif (out_len + word_len + 11 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 10, \"snapshot=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\n\treturn 0;\n}",
    "abstract_func_before": "static int\nparse_options(const char *VAR_0, struct parsed_mount_info *VAR_1)\n{\n\tchar *VAR_2 = NULL;\n\tchar *VAR_3 = NULL;\n\tchar *VAR_4 = NULL;\n\tchar *VAR_5 = VAR_1->options;\n\tunsigned long *VAR_6 = &VAR_1->flags;\n\tint VAR_7 = 0;\n\tint VAR_8;\n\tint VAR_9 = 0;\n\tint VAR_10 = 0;\n\tint VAR_11 = 0;\n\tint VAR_12 = 0;\n\tint VAR_13 = 0;\n\tint VAR_14 = 0;\n\tint VAR_15 = 0;\n\tuid_t VAR_16, VAR_17 = 0, VAR_18 = 0;\n\tgid_t VAR_19, VAR_20 = 0;\n\tchar *VAR_21;\n\tstruct passwd *VAR_22;\n\tstruct group *VAR_23;\n\t/* COMMENT_0 */\n                                                                        \n                                             \n    \n\tchar VAR_24[22];\n\tunsigned long long VAR_25;\n\tstruct tm tm;\n\n\t/* COMMENT_4 */\n\tVAR_5[0] = '\\0';\n\n\t/* COMMENT_5 */\n\tVAR_16 = getuid();\n\tif (VAR_16 != 0)\n\t\tVAR_12 = 1;\n\n\tVAR_19 = getgid();\n\tif (VAR_19 != 0)\n\t\tVAR_14 = 1;\n\n\tif (!VAR_0)\n\t\treturn VAR_26;\n\n\t/* COMMENT_6 */\n                                                         \n                        \n                                                \n    \n\twhile (VAR_0 && *VAR_0) {\n\t\tVAR_4 = strchr(VAR_0, ',');\t/* COMMENT_11 */\n\n\t\t/* COMMENT_12 */\n\t\tif (VAR_4)\n\t\t\t*VAR_4++ = 0;\n\n\t\t/* COMMENT_13 */\n\t\tVAR_2 = NULL;\n\t\tif ((VAR_3 = strchr(VAR_0, '=')) != NULL) {\n\t\t\t*VAR_3 = '\\0';\n\t\t\tVAR_2 = VAR_3 + 1;\n\t\t}\n\n\t\tswitch(parse_opt_token(VAR_0)) {\n\t\tcase VAR_27:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\t*VAR_6 |= VAR_28;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_29:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tif (VAR_0[4] == '\\0') {\n\t\t\t\t\t*VAR_6 |= VAR_30;\n\t\t\t\t\tgoto nocopy;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\t\"username specified with no parameter\\n\");\n\t\t\t\t\treturn VAR_26;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(VAR_1->username, VAR_2,\n\t\t\t\t\tsizeof(VAR_1->username));\n\t\t\t\tVAR_1->got_user = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\tcase VAR_32:\n\t\t\tif (VAR_1->got_password) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"password specified twice, ignoring second\\n\");\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tVAR_1->got_password = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tVAR_9 = set_password(VAR_1, VAR_2);\n\t\t\tif (VAR_9)\n\t\t\t\treturn VAR_9;\n\t\t\tgoto nocopy;\n\n\t\tcase VAR_33:\n\t\t\tif (VAR_2) {\n\t\t\t\tif (!strncmp(VAR_2, \"none\", 4))\n\t\t\t\t\tVAR_1->got_password = 1;\n\t\t\t\tif (!strncmp(VAR_2, \"krb5\", 4)) {\n\t\t\t\t\tVAR_1->is_krb5 = 1;\n\t\t\t\t\tVAR_1->got_password = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_34:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"target ip address argument missing\\n\");\n\t\t\t} else if (strnlen(VAR_2, VAR_35) <=\n\t\t\t\tVAR_35) {\n\t\t\t\tstrcpy(VAR_1->addrlist, VAR_2);\n\t\t\t\tif (VAR_1->verboseflag)\n\t\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\t\"ip address %s override specified\\n\",\n\t\t\t\t\t\tVAR_2);\n\t\t\t\tgoto nocopy;\n\t\t\t} else {\n\t\t\t\tfprintf(VAR_31, \"ip address too long\\n\");\n\t\t\t\treturn VAR_26;\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* COMMENT_14 */\n\t\tcase VAR_36:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"invalid path to network resource\\n\");\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t\t\tVAR_9 = parse_unc(VAR_2, VAR_1, VAR_37);\n\t\t\tif (VAR_9)\n\t\t\t\treturn VAR_9;\n\t\t\tbreak;\n\n\t\t/* COMMENT_15 */\n\t\tcase VAR_38:\n\t\t\tif (!VAR_2) {\n\t\t\t\t/* COMMENT_16 */\n                                      \n       \n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tVAR_1->domain[0] = '\\0';\n\t\t\t\tVAR_1->got_domain = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (strnlen(VAR_2, sizeof(VAR_1->domain)) >=\n\t\t\t    sizeof(VAR_1->domain)) {\n\t\t\t\tfprintf(VAR_31, \"domain name too long\\n\");\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t\t\tstrlcpy(VAR_1->domain, VAR_2,\n\t\t\t\tsizeof(VAR_1->domain));\n\t\t\tgoto nocopy;\n\n\t\tcase VAR_39:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"invalid credential file name specified\\n\");\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t\t\tVAR_9 = open_cred_file(VAR_2, VAR_1);\n\t\t\tif (VAR_9) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"error %d (%s) opening credential file %s\\n\",\n\t\t\t\t\tVAR_9, strerror(VAR_9), VAR_2);\n\t\t\t\treturn VAR_9;\n\t\t\t}\n\t\t\tgoto nocopy;\n\n\t\tcase VAR_40:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_12 = 1;\n\t\t\tVAR_22 = getpwnam(VAR_2);\n\t\t\tif (VAR_22) {\n\t\t\t\tVAR_16 = VAR_22->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_16 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(VAR_31, \"bad option uid=\\\"%s\\\"\\n\", VAR_2);\n\t\t\treturn VAR_26;\n\t\tcase VAR_42:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_13 = 1;\n\t\t\tVAR_22 = getpwnam(VAR_2);\n\t\t\tif (VAR_22) {\n\t\t\t\tVAR_17 = VAR_22->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_17 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(VAR_31, \"bad option: cruid=\\\"%s\\\"\\n\", VAR_2);\n\t\t\treturn VAR_26;\n\t\tcase VAR_43:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_14 = 1;\n\t\t\tVAR_23 = getgrnam(VAR_2);\n\t\t\tif (VAR_23) {\n\t\t\t\tVAR_19 = VAR_23->gr_gid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_19 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(VAR_31, \"bad option: gid=\\\"%s\\\"\\n\", VAR_2);\n\t\t\treturn VAR_26;\n\t\t/* COMMENT_20 */\n\t\tcase VAR_44:\n\t\t\tfprintf(VAR_31,\n\t\t\t\t\"WARNING: CIFS mount option 'fmask' is\\\n\t\t\t\t deprecated. Use 'file_mode' instead.\\n\");\n\t\t\tVAR_0 = \"file_mode\";\t/* COMMENT_21 */\n\t\t\t/* COMMENT_22 */\n\t\tcase VAR_45:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tVAR_0);\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\n\t\t\tif (VAR_2[0] != '0')\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tVAR_0);\n\t\t\tbreak;\n\n\t\t/* COMMENT_23 */\n\t\tcase VAR_46:\n\t\t\tfprintf(VAR_31,\n\t\t\t\t\"WARNING: CIFS mount option 'dmask' is\\\n\t\t\t\t deprecated. Use 'dir_mode' instead.\\n\");\n\t\t\tVAR_0 = \"dir_mode\";\n\t\t\t/* COMMENT_22 */\n\t\tcase VAR_47:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tVAR_0);\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\n\t\t\tif (VAR_2[0] != '0')\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tVAR_0);\n\t\t\tbreak;\n\t\tcase VAR_48:\n\t\t\t*VAR_6 |= VAR_49;\n\t\t\tgoto nocopy;\n\t\tcase VAR_50:\n\t\t\t*VAR_6 &= ~VAR_49;\n\t\t\tgoto nocopy;\n\t\tcase VAR_51:\n\t\t\t*VAR_6 |= VAR_52;\n\t\t\tgoto nocopy;\n\t\tcase VAR_53:\n\t\t\t*VAR_6 &= ~VAR_54;\n\t\t\tbreak;\n\t\tcase VAR_55:\n\t\t\t*VAR_6 |= VAR_54;\n\t\t\tgoto nocopy;\n\t\tcase VAR_56:\n\t\t\t*VAR_6 &= ~VAR_54;\n\t\t\tgoto nocopy;\n\t\tcase VAR_57:\n\t\t\t*VAR_6 &= ~VAR_52;\n\t\t\tgoto nocopy;\n\t\tcase VAR_58:\n\t\t\t*VAR_6 |= VAR_59;\n\t\t\tgoto nocopy;\n\t\tcase VAR_60:\n\t\t\t*VAR_6 &= ~VAR_59;\n\t\t\tgoto nocopy;\n\t\tcase VAR_61:\n\t\t\tVAR_1->got_user = 1;\n\t\t\tVAR_1->got_password = 1;\n\t\t\tgoto nocopy;\n\t\tcase VAR_62:\n\t\t\t*VAR_6 |= VAR_63;\n\t\t\tgoto nocopy;\n\t\tcase VAR_64:\n\t\t\t*VAR_6 &= ~VAR_63;\n\t\t\tgoto nocopy;\n\t\tcase VAR_65:\n\t\t\t*VAR_6 |= VAR_66;\n\t\t\tgoto nocopy;\n\t\tcase VAR_67:\n\t\t\tgoto nocopy;\n\t\tcase VAR_68:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_10 = 1;\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_18 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_22 = getpwnam(VAR_2);\n\t\t\tif (VAR_22 == NULL) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"bad user name \\\"%s\\\"\\n\", VAR_2);\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\n\t\t\tVAR_18 = VAR_22->pw_uid;\n\t\t\tgoto nocopy;\n\t\tcase VAR_69:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_11 = 1;\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_20 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_23 = getgrnam(VAR_2);\n\t\t\tif (VAR_23 == NULL) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"bad group name \\\"%s\\\"\\n\", VAR_2);\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\n\t\t\tVAR_20 = VAR_23->gr_gid;\n\t\t\tgoto nocopy;\n\t\tcase VAR_70:\n\t\t\tVAR_1->nofail = 1;\n\t\t\tgoto nocopy;\n\t\tcase VAR_71:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\t\t\tif (strncmp(VAR_2, \"@GMT-\", 5))\n\t\t\t\tbreak;\n\t\t\tif ((strlen(VAR_2) != VAR_72) ||\n\t\t\t    (strptime(VAR_2, VAR_73, &tm) == NULL)) {\n\t\t\t\tfprintf(VAR_31, \"bad snapshot token\\n\");\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t\t\tVAR_25 = timegm(&tm) * 10000000 + VAR_74;\n\t\t\tVAR_15 = 1;\n\t\t\tgoto nocopy;\n\t\t}\n\n\t\t/* COMMENT_24 */\n\t\tVAR_8 = strlen(VAR_0);\n\t\tif (VAR_2)\n\t\t\tVAR_8 += 1 + strlen(VAR_2);\n\n\t\t/* COMMENT_25 */\n\t\tif (VAR_7 + VAR_8 + 2 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\t/* COMMENT_26 */\n\t\tif (VAR_3)\n\t\t\t*VAR_3 = '=';\n\n\t\t/* COMMENT_27 */\n\t\tif (VAR_7)\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\n\t\tstrlcat(VAR_5, VAR_0, VAR_75);\n\t\tVAR_7 = strlen(VAR_5);\nnocopy:\n\t\tVAR_0 = VAR_4;\n\t}\n\n\n\t/* COMMENT_28 */\n\tif (VAR_12) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_16);\n\n\t\t/* COMMENT_29 */\n\t\tif (VAR_7 + VAR_8 + 6 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 5, \"uid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_1->is_krb5 && VAR_1->sudo_uid) {\n\t\tVAR_17 = VAR_1->sudo_uid;\n\t\tVAR_13 = 1;\n\t}\n\tif (VAR_13) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_17);\n\n\t\t/* COMMENT_30 */\n\t\tif (VAR_7 + VAR_8 + 8 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 7, \"cruid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_14) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_19);\n\n\t\t/* COMMENT_31 */\n\t\tif (VAR_7 + VAR_8 + 6 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 5, \"gid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_10) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_18);\n\n\t\t/* COMMENT_32 */\n\t\tif (VAR_7 + VAR_8 + 12 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 11, \"backupuid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_11) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_20);\n\n\t\t/* COMMENT_33 */\n\t\tif (VAR_7 + VAR_8 + 12 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 11, \"backupgid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_15) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%llu\", VAR_25);\n\n\t\t/* COMMENT_34 */\n\t\tif (VAR_7 + VAR_8 + 11 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 10, \"snapshot=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\n\treturn 0;\n}",
    "func_graph_path_before": "piastry/cifs-utils/955fb147e97a6a74e1aaa65766de91e2c1479765/mount.cifs.c/vul/before/0.json",
    "func": "static int\nparse_options(const char *data, struct parsed_mount_info *parsed_info)\n{\n\tchar *value = NULL;\n\tchar *equals = NULL;\n\tchar *next_keyword = NULL;\n\tchar *out = parsed_info->options;\n\tunsigned long *filesys_flags = &parsed_info->flags;\n\tint out_len = 0;\n\tint word_len;\n\tint rc = 0;\n\tint got_bkupuid = 0;\n\tint got_bkupgid = 0;\n\tint got_uid = 0;\n\tint got_cruid = 0;\n\tint got_gid = 0;\n\tint got_snapshot = 0;\n\tuid_t uid, cruid = 0, bkupuid = 0;\n\tgid_t gid, bkupgid = 0;\n\tchar *ep;\n\tstruct passwd *pw;\n\tstruct group *gr;\n\t/*\n\t * max 64-bit uint in decimal is 18446744073709551615 which is 20 chars\n\t * wide +1 for NULL, and +1 for good measure\n\t */\n\tchar txtbuf[22];\n\tunsigned long long snapshot;\n\tstruct tm tm;\n\n\t/* make sure we're starting from beginning */\n\tout[0] = '\\0';\n\n\t/* BB fixme check for separator override BB */\n\tuid = getuid();\n\tif (uid != 0)\n\t\tgot_uid = 1;\n\n\tgid = getgid();\n\tif (gid != 0)\n\t\tgot_gid = 1;\n\n\tif (!data)\n\t\treturn EX_USAGE;\n\n\t/*\n\t * format is keyword,keyword2=value2,keyword3=value3... \n\t * data  = next keyword\n\t * value = next value ie stuff after equal sign\n\t */\n\twhile (data && *data) {\n\t\tnext_keyword = strchr(data, ',');\t/* BB handle sep= */\n\n\t\t/* temporarily null terminate end of keyword=value pair */\n\t\tif (next_keyword)\n\t\t\t*next_keyword++ = 0;\n\n\t\t/* temporarily null terminate keyword if there's a value */\n\t\tvalue = NULL;\n\t\tif ((equals = strchr(data, '=')) != NULL) {\n\t\t\t*equals = '\\0';\n\t\t\tvalue = equals + 1;\n\t\t}\n\n\t\tswitch(parse_opt_token(data)) {\n\t\tcase OPT_USERS:\n\t\t\tif (!value || !*value) {\n\t\t\t\t*filesys_flags |= MS_USERS;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_USER:\n\t\t\tif (!value || !*value) {\n\t\t\t\tif (data[4] == '\\0') {\n\t\t\t\t\t*filesys_flags |= MS_USER;\n\t\t\t\t\tgoto nocopy;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"username specified with no parameter\\n\");\n\t\t\t\t\treturn EX_USAGE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(parsed_info->username, value,\n\t\t\t\t\tsizeof(parsed_info->username));\n\t\t\t\tparsed_info->got_user = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\tcase OPT_PASS:\n\t\t\tif (parsed_info->got_password) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"password specified twice, ignoring second\\n\");\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (!value || !*value) {\n\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\trc = set_password(parsed_info, value);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_SEC:\n\t\t\tif (value) {\n\t\t\t\tif (!strncmp(value, \"none\", 4))\n\t\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\tif (!strncmp(value, \"krb5\", 4)) {\n\t\t\t\t\tparsed_info->is_krb5 = 1;\n\t\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_IP:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"target ip address argument missing\\n\");\n\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <\n\t\t\t\tMAX_ADDRESS_LEN) {\n\t\t\t\tstrlcpy(parsed_info->addrlist, value,\n\t\t\t\t\tMAX_ADDRESS_LEN);\n\t\t\t\tif (parsed_info->verboseflag)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"ip address %s override specified\\n\",\n\t\t\t\t\t\tvalue);\n\t\t\t\tgoto nocopy;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"ip address too long\\n\");\n\t\t\t\treturn EX_USAGE;\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* unc || target || path */\n\t\tcase OPT_UNC:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"invalid path to network resource\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\trc = parse_unc(value, parsed_info, thisprogram);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\n\t\t/* dom || workgroup */\n\t\tcase OPT_DOM:\n\t\t\tif (!value) {\n\t\t\t\t/*\n\t\t\t\t * An empty domain has been passed\n\t\t\t\t */\n\t\t\t\t/* not necessary but better safe than.. */\n\t\t\t\tparsed_info->domain[0] = '\\0';\n\t\t\t\tparsed_info->got_domain = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (strnlen(value, sizeof(parsed_info->domain)) >=\n\t\t\t    sizeof(parsed_info->domain)) {\n\t\t\t\tfprintf(stderr, \"domain name too long\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\tstrlcpy(parsed_info->domain, value,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_CRED:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"invalid credential file name specified\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\trc = open_cred_file(value, parsed_info);\n\t\t\tif (rc) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"error %d (%s) opening credential file %s\\n\",\n\t\t\t\t\trc, strerror(rc), value);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_UID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_uid = 1;\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw) {\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tuid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option uid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\tcase OPT_CRUID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_cruid = 1;\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw) {\n\t\t\t\tcruid = pw->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tcruid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option: cruid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\tcase OPT_GID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_gid = 1;\n\t\t\tgr = getgrnam(value);\n\t\t\tif (gr) {\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tgid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option: gid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\t/* fmask falls through to file_mode */\n\t\tcase OPT_FMASK:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"WARNING: CIFS mount option 'fmask' is\\\n\t\t\t\t deprecated. Use 'file_mode' instead.\\n\");\n\t\t\tdata = \"file_mode\";\t/* BB fix this */\n\t\t\t/* Fallthrough */\n\t\tcase OPT_FILE_MODE:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tdata);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tif (value[0] != '0')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tdata);\n\t\t\tbreak;\n\n\t\t/* dmask falls through to dir_mode */\n\t\tcase OPT_DMASK:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"WARNING: CIFS mount option 'dmask' is\\\n\t\t\t\t deprecated. Use 'dir_mode' instead.\\n\");\n\t\t\tdata = \"dir_mode\";\n\t\t\t/* Fallthrough */\n\t\tcase OPT_DIR_MODE:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tdata);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tif (value[0] != '0')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tdata);\n\t\t\tbreak;\n\t\tcase OPT_NO_SUID:\n\t\t\t*filesys_flags |= MS_NOSUID;\n\t\t\tgoto nocopy;\n\t\tcase OPT_SUID:\n\t\t\t*filesys_flags &= ~MS_NOSUID;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_DEV:\n\t\t\t*filesys_flags |= MS_NODEV;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_LOCK:\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t\tbreak;\n\t\tcase OPT_MAND:\n\t\t\t*filesys_flags |= MS_MANDLOCK;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NOMAND:\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t\tgoto nocopy;\n\t\tcase OPT_DEV:\n\t\t\t*filesys_flags &= ~MS_NODEV;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_EXEC:\n\t\t\t*filesys_flags |= MS_NOEXEC;\n\t\t\tgoto nocopy;\n\t\tcase OPT_EXEC:\n\t\t\t*filesys_flags &= ~MS_NOEXEC;\n\t\t\tgoto nocopy;\n\t\tcase OPT_GUEST:\n\t\t\tparsed_info->got_user = 1;\n\t\t\tparsed_info->got_password = 1;\n\t\t\tgoto nocopy;\n\t\tcase OPT_RO:\n\t\t\t*filesys_flags |= MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\tcase OPT_RW:\n\t\t\t*filesys_flags &= ~MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\tcase OPT_REMOUNT:\n\t\t\t*filesys_flags |= MS_REMOUNT;\n\t\t\tgoto nocopy;\n\t\tcase OPT_IGNORE:\n\t\t\tgoto nocopy;\n\t\tcase OPT_BKUPUID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_bkupuid = 1;\n\t\t\terrno = 0;\n\t\t\tbkupuid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bad user name \\\"%s\\\"\\n\", value);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tbkupuid = pw->pw_uid;\n\t\t\tgoto nocopy;\n\t\tcase OPT_BKUPGID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_bkupgid = 1;\n\t\t\terrno = 0;\n\t\t\tbkupgid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tgr = getgrnam(value);\n\t\t\tif (gr == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bad group name \\\"%s\\\"\\n\", value);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tbkupgid = gr->gr_gid;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NOFAIL:\n\t\t\tparsed_info->nofail = 1;\n\t\t\tgoto nocopy;\n\t\tcase OPT_SNAPSHOT:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\t\t\tif (strncmp(value, \"@GMT-\", 5))\n\t\t\t\tbreak;\n\t\t\tif ((strlen(value) != GMT_NAME_LEN) ||\n\t\t\t    (strptime(value, GMT_FORMAT, &tm) == NULL)) {\n\t\t\t\tfprintf(stderr, \"bad snapshot token\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\tsnapshot = timegm(&tm) * 10000000 + NTFS_TIME_OFFSET;\n\t\t\tgot_snapshot = 1;\n\t\t\tgoto nocopy;\n\t\t}\n\n\t\t/* check size before copying option to buffer */\n\t\tword_len = strlen(data);\n\t\tif (value)\n\t\t\tword_len += 1 + strlen(value);\n\n\t\t/* need 2 extra bytes for comma and null byte */\n\t\tif (out_len + word_len + 2 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\t/* put back equals sign, if any */\n\t\tif (equals)\n\t\t\t*equals = '=';\n\n\t\t/* go ahead and copy */\n\t\tif (out_len)\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\n\t\tstrlcat(out, data, MAX_OPTIONS_LEN);\n\t\tout_len = strlen(out);\nnocopy:\n\t\tdata = next_keyword;\n\t}\n\n\n\t/* special-case the uid and gid */\n\tif (got_uid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", uid);\n\n\t\t/* comma + \"uid=\" + terminating NULL == 6 */\n\t\tif (out_len + word_len + 6 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"uid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (parsed_info->is_krb5 && parsed_info->sudo_uid) {\n\t\tcruid = parsed_info->sudo_uid;\n\t\tgot_cruid = 1;\n\t}\n\tif (got_cruid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", cruid);\n\n\t\t/* comma + \"cruid=\" + terminating NULL == 8 */\n\t\tif (out_len + word_len + 8 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 7, \"cruid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_gid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", gid);\n\n\t\t/* comma + \"gid=\" + terminating NULL == 6 */\n\t\tif (out_len + word_len + 6 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"gid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_bkupuid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", bkupuid);\n\n\t\t/* comma + \"backupuid=\" + terminating NULL == 12 */\n\t\tif (out_len + word_len + 12 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 11, \"backupuid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_bkupgid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", bkupgid);\n\n\t\t/* comma + \"backupgid=\" + terminating NULL == 12 */\n\t\tif (out_len + word_len + 12 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 11, \"backupgid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_snapshot) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%llu\", snapshot);\n\n\t\t/* comma + \"snapshot=\" + terminating NULL == 11 */\n\t\tif (out_len + word_len + 11 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 10, \"snapshot=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\n\treturn 0;\n}",
    "abstract_func": "static int\nparse_options(const char *VAR_0, struct parsed_mount_info *VAR_1)\n{\n\tchar *VAR_2 = NULL;\n\tchar *VAR_3 = NULL;\n\tchar *VAR_4 = NULL;\n\tchar *VAR_5 = VAR_1->options;\n\tunsigned long *VAR_6 = &VAR_1->flags;\n\tint VAR_7 = 0;\n\tint VAR_8;\n\tint VAR_9 = 0;\n\tint VAR_10 = 0;\n\tint VAR_11 = 0;\n\tint VAR_12 = 0;\n\tint VAR_13 = 0;\n\tint VAR_14 = 0;\n\tint VAR_15 = 0;\n\tuid_t VAR_16, VAR_17 = 0, VAR_18 = 0;\n\tgid_t VAR_19, VAR_20 = 0;\n\tchar *VAR_21;\n\tstruct passwd *VAR_22;\n\tstruct group *VAR_23;\n\t/* COMMENT_0 */\n                                                                        \n                                             \n    \n\tchar VAR_24[22];\n\tunsigned long long VAR_25;\n\tstruct tm tm;\n\n\t/* COMMENT_4 */\n\tVAR_5[0] = '\\0';\n\n\t/* COMMENT_5 */\n\tVAR_16 = getuid();\n\tif (VAR_16 != 0)\n\t\tVAR_12 = 1;\n\n\tVAR_19 = getgid();\n\tif (VAR_19 != 0)\n\t\tVAR_14 = 1;\n\n\tif (!VAR_0)\n\t\treturn VAR_26;\n\n\t/* COMMENT_6 */\n                                                         \n                        \n                                                \n    \n\twhile (VAR_0 && *VAR_0) {\n\t\tVAR_4 = strchr(VAR_0, ',');\t/* COMMENT_11 */\n\n\t\t/* COMMENT_12 */\n\t\tif (VAR_4)\n\t\t\t*VAR_4++ = 0;\n\n\t\t/* COMMENT_13 */\n\t\tVAR_2 = NULL;\n\t\tif ((VAR_3 = strchr(VAR_0, '=')) != NULL) {\n\t\t\t*VAR_3 = '\\0';\n\t\t\tVAR_2 = VAR_3 + 1;\n\t\t}\n\n\t\tswitch(parse_opt_token(VAR_0)) {\n\t\tcase VAR_27:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\t*VAR_6 |= VAR_28;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_29:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tif (VAR_0[4] == '\\0') {\n\t\t\t\t\t*VAR_6 |= VAR_30;\n\t\t\t\t\tgoto nocopy;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\t\"username specified with no parameter\\n\");\n\t\t\t\t\treturn VAR_26;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(VAR_1->username, VAR_2,\n\t\t\t\t\tsizeof(VAR_1->username));\n\t\t\t\tVAR_1->got_user = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\tcase VAR_32:\n\t\t\tif (VAR_1->got_password) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"password specified twice, ignoring second\\n\");\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tVAR_1->got_password = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tVAR_9 = set_password(VAR_1, VAR_2);\n\t\t\tif (VAR_9)\n\t\t\t\treturn VAR_9;\n\t\t\tgoto nocopy;\n\n\t\tcase VAR_33:\n\t\t\tif (VAR_2) {\n\t\t\t\tif (!strncmp(VAR_2, \"none\", 4))\n\t\t\t\t\tVAR_1->got_password = 1;\n\t\t\t\tif (!strncmp(VAR_2, \"krb5\", 4)) {\n\t\t\t\t\tVAR_1->is_krb5 = 1;\n\t\t\t\t\tVAR_1->got_password = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_34:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"target ip address argument missing\\n\");\n\t\t\t} else if (strnlen(VAR_2, VAR_35) <\n\t\t\t\tVAR_35) {\n\t\t\t\tstrlcpy(VAR_1->addrlist, VAR_2,\n\t\t\t\t\tVAR_35);\n\t\t\t\tif (VAR_1->verboseflag)\n\t\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\t\"ip address %s override specified\\n\",\n\t\t\t\t\t\tVAR_2);\n\t\t\t\tgoto nocopy;\n\t\t\t} else {\n\t\t\t\tfprintf(VAR_31, \"ip address too long\\n\");\n\t\t\t\treturn VAR_26;\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* COMMENT_14 */\n\t\tcase VAR_36:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"invalid path to network resource\\n\");\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t\t\tVAR_9 = parse_unc(VAR_2, VAR_1, VAR_37);\n\t\t\tif (VAR_9)\n\t\t\t\treturn VAR_9;\n\t\t\tbreak;\n\n\t\t/* COMMENT_15 */\n\t\tcase VAR_38:\n\t\t\tif (!VAR_2) {\n\t\t\t\t/* COMMENT_16 */\n                                      \n       \n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tVAR_1->domain[0] = '\\0';\n\t\t\t\tVAR_1->got_domain = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (strnlen(VAR_2, sizeof(VAR_1->domain)) >=\n\t\t\t    sizeof(VAR_1->domain)) {\n\t\t\t\tfprintf(VAR_31, \"domain name too long\\n\");\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t\t\tstrlcpy(VAR_1->domain, VAR_2,\n\t\t\t\tsizeof(VAR_1->domain));\n\t\t\tgoto nocopy;\n\n\t\tcase VAR_39:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"invalid credential file name specified\\n\");\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t\t\tVAR_9 = open_cred_file(VAR_2, VAR_1);\n\t\t\tif (VAR_9) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"error %d (%s) opening credential file %s\\n\",\n\t\t\t\t\tVAR_9, strerror(VAR_9), VAR_2);\n\t\t\t\treturn VAR_9;\n\t\t\t}\n\t\t\tgoto nocopy;\n\n\t\tcase VAR_40:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_12 = 1;\n\t\t\tVAR_22 = getpwnam(VAR_2);\n\t\t\tif (VAR_22) {\n\t\t\t\tVAR_16 = VAR_22->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_16 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(VAR_31, \"bad option uid=\\\"%s\\\"\\n\", VAR_2);\n\t\t\treturn VAR_26;\n\t\tcase VAR_42:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_13 = 1;\n\t\t\tVAR_22 = getpwnam(VAR_2);\n\t\t\tif (VAR_22) {\n\t\t\t\tVAR_17 = VAR_22->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_17 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(VAR_31, \"bad option: cruid=\\\"%s\\\"\\n\", VAR_2);\n\t\t\treturn VAR_26;\n\t\tcase VAR_43:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_14 = 1;\n\t\t\tVAR_23 = getgrnam(VAR_2);\n\t\t\tif (VAR_23) {\n\t\t\t\tVAR_19 = VAR_23->gr_gid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_19 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(VAR_31, \"bad option: gid=\\\"%s\\\"\\n\", VAR_2);\n\t\t\treturn VAR_26;\n\t\t/* COMMENT_20 */\n\t\tcase VAR_44:\n\t\t\tfprintf(VAR_31,\n\t\t\t\t\"WARNING: CIFS mount option 'fmask' is\\\n\t\t\t\t deprecated. Use 'file_mode' instead.\\n\");\n\t\t\tVAR_0 = \"file_mode\";\t/* COMMENT_21 */\n\t\t\t/* COMMENT_22 */\n\t\tcase VAR_45:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tVAR_0);\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\n\t\t\tif (VAR_2[0] != '0')\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tVAR_0);\n\t\t\tbreak;\n\n\t\t/* COMMENT_23 */\n\t\tcase VAR_46:\n\t\t\tfprintf(VAR_31,\n\t\t\t\t\"WARNING: CIFS mount option 'dmask' is\\\n\t\t\t\t deprecated. Use 'dir_mode' instead.\\n\");\n\t\t\tVAR_0 = \"dir_mode\";\n\t\t\t/* COMMENT_22 */\n\t\tcase VAR_47:\n\t\t\tif (!VAR_2 || !*VAR_2) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tVAR_0);\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\n\t\t\tif (VAR_2[0] != '0')\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tVAR_0);\n\t\t\tbreak;\n\t\tcase VAR_48:\n\t\t\t*VAR_6 |= VAR_49;\n\t\t\tgoto nocopy;\n\t\tcase VAR_50:\n\t\t\t*VAR_6 &= ~VAR_49;\n\t\t\tgoto nocopy;\n\t\tcase VAR_51:\n\t\t\t*VAR_6 |= VAR_52;\n\t\t\tgoto nocopy;\n\t\tcase VAR_53:\n\t\t\t*VAR_6 &= ~VAR_54;\n\t\t\tbreak;\n\t\tcase VAR_55:\n\t\t\t*VAR_6 |= VAR_54;\n\t\t\tgoto nocopy;\n\t\tcase VAR_56:\n\t\t\t*VAR_6 &= ~VAR_54;\n\t\t\tgoto nocopy;\n\t\tcase VAR_57:\n\t\t\t*VAR_6 &= ~VAR_52;\n\t\t\tgoto nocopy;\n\t\tcase VAR_58:\n\t\t\t*VAR_6 |= VAR_59;\n\t\t\tgoto nocopy;\n\t\tcase VAR_60:\n\t\t\t*VAR_6 &= ~VAR_59;\n\t\t\tgoto nocopy;\n\t\tcase VAR_61:\n\t\t\tVAR_1->got_user = 1;\n\t\t\tVAR_1->got_password = 1;\n\t\t\tgoto nocopy;\n\t\tcase VAR_62:\n\t\t\t*VAR_6 |= VAR_63;\n\t\t\tgoto nocopy;\n\t\tcase VAR_64:\n\t\t\t*VAR_6 &= ~VAR_63;\n\t\t\tgoto nocopy;\n\t\tcase VAR_65:\n\t\t\t*VAR_6 |= VAR_66;\n\t\t\tgoto nocopy;\n\t\tcase VAR_67:\n\t\t\tgoto nocopy;\n\t\tcase VAR_68:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_10 = 1;\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_18 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_22 = getpwnam(VAR_2);\n\t\t\tif (VAR_22 == NULL) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"bad user name \\\"%s\\\"\\n\", VAR_2);\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\n\t\t\tVAR_18 = VAR_22->pw_uid;\n\t\t\tgoto nocopy;\n\t\tcase VAR_69:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_11 = 1;\n\t\t\tVAR_41 = 0;\n\t\t\tVAR_20 = strtoul(VAR_2, &VAR_21, 10);\n\t\t\tif (VAR_41 == 0 && *VAR_21 == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tVAR_23 = getgrnam(VAR_2);\n\t\t\tif (VAR_23 == NULL) {\n\t\t\t\tfprintf(VAR_31,\n\t\t\t\t\t\"bad group name \\\"%s\\\"\\n\", VAR_2);\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\n\t\t\tVAR_20 = VAR_23->gr_gid;\n\t\t\tgoto nocopy;\n\t\tcase VAR_70:\n\t\t\tVAR_1->nofail = 1;\n\t\t\tgoto nocopy;\n\t\tcase VAR_71:\n\t\t\tif (!VAR_2 || !*VAR_2)\n\t\t\t\tgoto nocopy;\n\t\t\tif (strncmp(VAR_2, \"@GMT-\", 5))\n\t\t\t\tbreak;\n\t\t\tif ((strlen(VAR_2) != VAR_72) ||\n\t\t\t    (strptime(VAR_2, VAR_73, &tm) == NULL)) {\n\t\t\t\tfprintf(VAR_31, \"bad snapshot token\\n\");\n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t\t\tVAR_25 = timegm(&tm) * 10000000 + VAR_74;\n\t\t\tVAR_15 = 1;\n\t\t\tgoto nocopy;\n\t\t}\n\n\t\t/* COMMENT_24 */\n\t\tVAR_8 = strlen(VAR_0);\n\t\tif (VAR_2)\n\t\t\tVAR_8 += 1 + strlen(VAR_2);\n\n\t\t/* COMMENT_25 */\n\t\tif (VAR_7 + VAR_8 + 2 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\t/* COMMENT_26 */\n\t\tif (VAR_3)\n\t\t\t*VAR_3 = '=';\n\n\t\t/* COMMENT_27 */\n\t\tif (VAR_7)\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\n\t\tstrlcat(VAR_5, VAR_0, VAR_75);\n\t\tVAR_7 = strlen(VAR_5);\nnocopy:\n\t\tVAR_0 = VAR_4;\n\t}\n\n\n\t/* COMMENT_28 */\n\tif (VAR_12) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_16);\n\n\t\t/* COMMENT_29 */\n\t\tif (VAR_7 + VAR_8 + 6 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 5, \"uid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_1->is_krb5 && VAR_1->sudo_uid) {\n\t\tVAR_17 = VAR_1->sudo_uid;\n\t\tVAR_13 = 1;\n\t}\n\tif (VAR_13) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_17);\n\n\t\t/* COMMENT_30 */\n\t\tif (VAR_7 + VAR_8 + 8 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 7, \"cruid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_14) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_19);\n\n\t\t/* COMMENT_31 */\n\t\tif (VAR_7 + VAR_8 + 6 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 5, \"gid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_10) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_18);\n\n\t\t/* COMMENT_32 */\n\t\tif (VAR_7 + VAR_8 + 12 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 11, \"backupuid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_11) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%u\", VAR_20);\n\n\t\t/* COMMENT_33 */\n\t\tif (VAR_7 + VAR_8 + 12 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 11, \"backupgid=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\tif (VAR_15) {\n\t\tVAR_8 = snprintf(VAR_24, sizeof(VAR_24), \"%llu\", VAR_25);\n\n\t\t/* COMMENT_34 */\n\t\tif (VAR_7 + VAR_8 + 11 > VAR_75) {\n\t\t\tfprintf(VAR_31, \"Options string too long\\n\");\n\t\t\treturn VAR_26;\n\t\t}\n\n\t\tif (VAR_7) {\n\t\t\tstrlcat(VAR_5, \",\", VAR_75);\n\t\t\tVAR_7++;\n\t\t}\n\t\tsnprintf(VAR_5 + VAR_7, VAR_8 + 10, \"snapshot=%s\", VAR_24);\n\t\tVAR_7 = strlen(VAR_5);\n\t}\n\n\treturn 0;\n}",
    "func_graph_path": "piastry/cifs-utils/955fb147e97a6a74e1aaa65766de91e2c1479765/mount.cifs.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -117,9 +117,10 @@\n \t\t\tif (!value || !*value) {\n \t\t\t\tfprintf(stderr,\n \t\t\t\t\t\"target ip address argument missing\\n\");\n-\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <=\n+\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <\n \t\t\t\tMAX_ADDRESS_LEN) {\n-\t\t\t\tstrcpy(parsed_info->addrlist, value);\n+\t\t\t\tstrlcpy(parsed_info->addrlist, value,\n+\t\t\t\t\tMAX_ADDRESS_LEN);\n \t\t\t\tif (parsed_info->verboseflag)\n \t\t\t\t\tfprintf(stderr,\n \t\t\t\t\t\t\"ip address %s override specified\\n\",",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <=",
            "\t\t\t\tstrcpy(parsed_info->addrlist, value);"
        ],
        "added_lines": [
            "\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <",
            "\t\t\t\tstrlcpy(parsed_info->addrlist, value,",
            "\t\t\t\t\tMAX_ADDRESS_LEN);"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/piastry/cifs-utils/pull/7",
    "description": "Both reported and fixed by Jeffrey Bencteux"
}