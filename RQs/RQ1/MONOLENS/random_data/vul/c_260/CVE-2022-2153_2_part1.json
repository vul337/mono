{
    "cve_id": "CVE-2022-2153",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "KVM: x86: Avoid theoretical NULL pointer dereference in kvm_irq_delivery_to_apic_fast()\n\nWhen kvm_irq_delivery_to_apic_fast() is called with APIC_DEST_SELF\nshorthand, 'src' must not be NULL. Crash the VM with KVM_BUG_ON()\ninstead of crashing the host.\n\nSigned-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>\nMessage-Id: <20220325132140.25650-3-vkuznets@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "commit_hash": "00b5f37189d24ac3ed46cb7f11742094778c46ce",
    "git_url": "https://github.com/torvalds/linux/commit/00b5f37189d24ac3ed46cb7f11742094778c46ce",
    "file_path": "arch/x86/kvm/lapic.c",
    "func_name": "kvm_irq_delivery_to_apic_fast",
    "func_before": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
    "abstract_func_before": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *VAR_0,\n\t\tstruct kvm_lapic_irq *VAR_1, int *VAR_2, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *VAR_3;\n\tunsigned long VAR_4;\n\tstruct kvm_lapic **VAR_5 = NULL;\n\tint VAR_6;\n\tbool VAR_7;\n\n\t*VAR_2 = -1;\n\n\tif (VAR_1->shorthand == VAR_8) {\n\t\t*VAR_2 = kvm_apic_set_irq(VAR_0->vcpu, VAR_1, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tVAR_3 = rcu_dereference(kvm->arch.apic_map);\n\n\tVAR_7 = kvm_apic_map_get_dest_lapic(kvm, &VAR_0, VAR_1, VAR_3, &VAR_5, &VAR_4);\n\tif (VAR_7) {\n\t\t*VAR_2 = 0;\n\t\tfor_each_set_bit(VAR_6, &VAR_4, 16) {\n\t\t\tif (!VAR_5[VAR_6])\n\t\t\t\tcontinue;\n\t\t\t*VAR_2 += kvm_apic_set_irq(VAR_5[VAR_6]->vcpu, VAR_1, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn VAR_7;\n}",
    "func_graph_path_before": "torvalds/linux/00b5f37189d24ac3ed46cb7f11742094778c46ce/lapic.c/vul/before/0.json",
    "func": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\tif (KVM_BUG_ON(!src, kvm)) {\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
    "abstract_func": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *VAR_0,\n\t\tstruct kvm_lapic_irq *VAR_1, int *VAR_2, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *VAR_3;\n\tunsigned long VAR_4;\n\tstruct kvm_lapic **VAR_5 = NULL;\n\tint VAR_6;\n\tbool VAR_7;\n\n\t*VAR_2 = -1;\n\n\tif (VAR_1->shorthand == VAR_8) {\n\t\tif (KVM_BUG_ON(!VAR_0, kvm)) {\n\t\t\t*VAR_2 = 0;\n\t\t\treturn true;\n\t\t}\n\t\t*VAR_2 = kvm_apic_set_irq(VAR_0->vcpu, VAR_1, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tVAR_3 = rcu_dereference(kvm->arch.apic_map);\n\n\tVAR_7 = kvm_apic_map_get_dest_lapic(kvm, &VAR_0, VAR_1, VAR_3, &VAR_5, &VAR_4);\n\tif (VAR_7) {\n\t\t*VAR_2 = 0;\n\t\tfor_each_set_bit(VAR_6, &VAR_4, 16) {\n\t\t\tif (!VAR_5[VAR_6])\n\t\t\t\tcontinue;\n\t\t\t*VAR_2 += kvm_apic_set_irq(VAR_5[VAR_6]->vcpu, VAR_1, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn VAR_7;\n}",
    "func_graph_path": "torvalds/linux/00b5f37189d24ac3ed46cb7f11742094778c46ce/lapic.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,10 @@\n \t*r = -1;\n \n \tif (irq->shorthand == APIC_DEST_SELF) {\n+\t\tif (KVM_BUG_ON(!src, kvm)) {\n+\t\t\t*r = 0;\n+\t\t\treturn true;\n+\t\t}\n \t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n \t\treturn true;\n \t}",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\tif (KVM_BUG_ON(!src, kvm)) {",
            "\t\t\t*r = 0;",
            "\t\t\treturn true;",
            "\t\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}