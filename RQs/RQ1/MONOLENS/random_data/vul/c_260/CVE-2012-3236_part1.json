{
    "cve_id": "CVE-2012-3236",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "GNOME/gimp",
    "commit_msg": "Bug 676804 - file handling DoS for fit file format\n\nApply patch from joe@reactionis.co.uk which fixes a buffer overflow on\nbroken/malicious fits files.\n(cherry picked from commit ace45631595e8781a1420842582d67160097163c)",
    "commit_hash": "0474376d234bc3d0901fd5e86f89d778a6473dd8",
    "git_url": "https://github.com/GNOME/gimp/commit/0474376d234bc3d0901fd5e86f89d778a6473dd8",
    "file_path": "plug-ins/file-fits/fits-io.c",
    "func_name": "fits_decode_header",
    "func_before": "static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\"fits_decode_header: Not enough memory\", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \"SIMPLE  \", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \"XTENSION\", 8) == 0);\n if (hdulist->used.xtension)\n {\n   fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);\n   strcpy (hdulist->xtension, fdat->fstring);\n }\n\n FITS_DECODE_CARD (hdr, \"NAXIS\", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \"BITPIX\", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \"fits_decode_header: Invalid BITPIX-value\");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \"GCOUNT\", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \"PCOUNT\", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"GROUPS\", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \"EXTEND\", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \"fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \"NAXIS%-3d\", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \"fits_decode_header: Negative value in NAXISn\");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \"fits_decode_header: Random groups with NAXIS1 != 0\");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \"fits_decode_card: Not enough NAXISn-cards\");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \"BLANK\", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"DATAMIN\", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"DATAMAX\", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \"BZERO\", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"BSCALE\", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \"IMAGE\", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \"fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \"fits_decode_header: missing/invalid %s card\", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}",
    "abstract_func_before": "static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *VAR_0,\n                        long VAR_1, long VAR_2)\n\n{FITS_HDU_LIST *VAR_3;\n FITS_DATA *VAR_4;\n char VAR_5[80], VAR_6[9];\n int VAR_7, VAR_8, VAR_9;\n long VAR_10, VAR_11, VAR_12;\n\n#define FITS_DECODE_CARD(VAR_13,VAR_14,VAR_15,VAR_16) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(VAR_13,VAR_17,VAR_14,VAR_18,VAR_16,VAR_19) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n VAR_3 = fits_new_hdulist ();\n if (VAR_3 == NULL)\n   FITS_RETURN (\"fits_decode_header: Not enough memory\", NULL);\n\n /* COMMENT_0 */\n VAR_3->header_offset = VAR_1;\n VAR_3->data_offset = VAR_2;\n\n VAR_3->used.simple = (strncmp (VAR_0->data, \"SIMPLE  \", 8) == 0);\n VAR_3->used.xtension = (strncmp (VAR_0->data, \"XTENSION\", 8) == 0);\n if (VAR_3->used.xtension)\n {\n   VAR_4 = fits_decode_card (fits_search_card (VAR_0, \"XTENSION\"), VAR_20);\n   strcpy (VAR_3->xtension, VAR_4->fstring);\n }\n\n FITS_DECODE_CARD (VAR_0, \"NAXIS\", VAR_4, VAR_21);\n VAR_3->naxis = VAR_4->flong;\n\n FITS_DECODE_CARD (VAR_0, \"BITPIX\", VAR_4, VAR_21);\n VAR_8 = VAR_3->bitpix = (int)VAR_4->flong;\n if (   (VAR_8 != 8) && (VAR_8 != 16) && (VAR_8 != 32)\n     && (VAR_8 != -32) && (VAR_8 != -64))\n {\n   strcpy (VAR_5, \"fits_decode_header: Invalid BITPIX-value\");\n   goto err_return;\n }\n if (VAR_8 < 0) VAR_8 = -VAR_8;\n VAR_8 /= 8;\n VAR_3->bpp = VAR_8;\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"GCOUNT\", VAR_22, VAR_21, VAR_23);\n FITS_TRY_CARD (VAR_0, VAR_3, \"PCOUNT\", VAR_24, VAR_21, VAR_23);\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"GROUPS\", VAR_25, VAR_26, VAR_27);\n VAR_9 = VAR_3->used.groups && VAR_3->groups;\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"EXTEND\", VAR_28, VAR_26, VAR_27);\n\n if (VAR_3->used.xtension)  /* COMMENT_1 */\n {\n   if ((!VAR_3->used.gcount) || (!VAR_3->used.pcount))\n   {\n     strcpy (VAR_5, \"fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\");\n     goto err_return;\n   }\n }\n\n VAR_10 = 1;\n\n /* COMMENT_2 */\n for (VAR_7 = 1; VAR_7 <= VAR_29; VAR_7++)\n {char VAR_30[9];\n\n   sprintf (VAR_30, \"NAXIS%-3d\", VAR_7);\n   VAR_4 = fits_decode_card (fits_search_card (VAR_0, VAR_30), VAR_21);\n   if (VAR_4 == NULL)\n   {\n     VAR_7--;   /* COMMENT_3 */\n     break;\n   }\n   VAR_3->naxisn[VAR_7-1] = (int)VAR_4->flong;\n   if (VAR_3->naxisn[VAR_7-1] < 0)\n   {\n     strcpy (VAR_5, \"fits_decode_header: Negative value in NAXISn\");\n     goto err_return;\n   }\n   if ((VAR_7 == 1) && (VAR_9))\n   {\n     if (VAR_3->naxisn[0] != 0)\n     {\n       strcpy (VAR_5, \"fits_decode_header: Random groups with NAXIS1 != 0\");\n       goto err_return;\n     }\n   }\n   else\n     VAR_10 *= VAR_3->naxisn[VAR_7-1];\n }\n\n if ((VAR_3->naxis > 0) && (VAR_7 < VAR_3->naxis))\n {\n   strcpy (VAR_5, \"fits_decode_card: Not enough NAXISn-cards\");\n   goto err_return;\n }\n\n /* COMMENT_4 */\n /* COMMENT_5 */\n if (VAR_3->naxis < 2)\n   VAR_3->naxisn[1] = 1;\n if (VAR_3->naxis < 1)\n {\n   VAR_10 = 0;\n   VAR_3->naxisn[0] = 1;\n }\n\n if (VAR_3->used.xtension)\n   VAR_11 = VAR_8*VAR_3->gcount*(VAR_3->pcount + VAR_10);\n else\n   VAR_11 = VAR_8*VAR_10;\n VAR_3->udata_size = VAR_11;  /* COMMENT_6 */\n\n /* COMMENT_7 */\n VAR_11 = (VAR_11 + VAR_31 - 1) / VAR_31;\n VAR_11 *= VAR_31;\n VAR_3->data_size = VAR_11;\n\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"BLANK\", VAR_32, VAR_21, VAR_23);\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"DATAMIN\", VAR_33, VAR_34, VAR_35);\n FITS_TRY_CARD (VAR_0, VAR_3, \"DATAMAX\", VAR_36, VAR_34, VAR_35);\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"BZERO\", VAR_37, VAR_34, VAR_35);\n FITS_TRY_CARD (VAR_0, VAR_3, \"BSCALE\", VAR_38, VAR_34, VAR_35);\n\n /* COMMENT_8 */\n VAR_3->numpic = 0;\n\n /* COMMENT_9 */\n VAR_12 =    (VAR_3->bitpix > 0)\n                    || (   (VAR_3->bitpix == -64)\n                        && (VAR_39 || VAR_40))\n                    || (   (VAR_3->bitpix == -32)\n                        && (   VAR_41 || VAR_42\n                            || VAR_39 || VAR_40));\n\n if (VAR_12)\n {\n   if (VAR_3->used.simple)\n   {\n     if (VAR_3->naxis > 0)\n     {\n       VAR_3->numpic = 1;\n       for (VAR_7 = 3; VAR_7 <= VAR_3->naxis; VAR_7++)\n         VAR_3->numpic *= VAR_3->naxisn[VAR_7-1];\n     }\n   }\n   else if (   VAR_3->used.xtension\n            && (strncmp (VAR_3->xtension, \"IMAGE\", 5) == 0))\n   {\n     if (VAR_3->naxis > 0)\n     {\n       VAR_3->numpic = 1;\n       for (VAR_7 = 3; VAR_7 <= VAR_3->naxis; VAR_7++)\n         VAR_3->numpic *= VAR_3->naxisn[VAR_7-1];\n     }\n   }\n }\n else\n {char VAR_43[160];\n   sprintf (VAR_43, \"fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\", VAR_3->bitpix);\n   fits_set_error (VAR_43);\n }\n\n VAR_3->header_record_list = VAR_0;  /* COMMENT_10 */\n return (VAR_3);\n\nerr_missing:\n sprintf (VAR_5, \"fits_decode_header: missing/invalid %s card\", VAR_6);\n\nerr_return:\n fits_delete_hdulist (VAR_3);\n fits_set_error (VAR_5);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}",
    "func_graph_path_before": "GNOME/gimp/0474376d234bc3d0901fd5e86f89d778a6473dd8/fits-io.c/vul/before/0.json",
    "func": "static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\"fits_decode_header: Not enough memory\", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \"SIMPLE  \", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \"XTENSION\", 8) == 0);\n if (hdulist->used.xtension)\n   {\n     fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);\n     if (fdat != NULL)\n       {\n         strcpy (hdulist->xtension, fdat->fstring);\n       }\n     else\n       {\n         strcpy (errmsg, \"No valid XTENSION header found.\");\n         goto err_return;\n       }\n   }\n\n FITS_DECODE_CARD (hdr, \"NAXIS\", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \"BITPIX\", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \"fits_decode_header: Invalid BITPIX-value\");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \"GCOUNT\", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \"PCOUNT\", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"GROUPS\", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \"EXTEND\", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \"fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \"NAXIS%-3d\", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \"fits_decode_header: Negative value in NAXISn\");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \"fits_decode_header: Random groups with NAXIS1 != 0\");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \"fits_decode_card: Not enough NAXISn-cards\");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \"BLANK\", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"DATAMIN\", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"DATAMAX\", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \"BZERO\", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"BSCALE\", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \"IMAGE\", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \"fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \"fits_decode_header: missing/invalid %s card\", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}",
    "abstract_func": "static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *VAR_0,\n                        long VAR_1, long VAR_2)\n\n{FITS_HDU_LIST *VAR_3;\n FITS_DATA *VAR_4;\n char VAR_5[80], VAR_6[9];\n int VAR_7, VAR_8, VAR_9;\n long VAR_10, VAR_11, VAR_12;\n\n#define FITS_DECODE_CARD(VAR_13,VAR_14,VAR_15,VAR_16) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(VAR_13,VAR_17,VAR_14,VAR_18,VAR_16,VAR_19) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n VAR_3 = fits_new_hdulist ();\n if (VAR_3 == NULL)\n   FITS_RETURN (\"fits_decode_header: Not enough memory\", NULL);\n\n /* COMMENT_0 */\n VAR_3->header_offset = VAR_1;\n VAR_3->data_offset = VAR_2;\n\n VAR_3->used.simple = (strncmp (VAR_0->data, \"SIMPLE  \", 8) == 0);\n VAR_3->used.xtension = (strncmp (VAR_0->data, \"XTENSION\", 8) == 0);\n if (VAR_3->used.xtension)\n   {\n     VAR_4 = fits_decode_card (fits_search_card (VAR_0, \"XTENSION\"), VAR_20);\n     if (VAR_4 != NULL)\n       {\n         strcpy (VAR_3->xtension, VAR_4->fstring);\n       }\n     else\n       {\n         strcpy (VAR_5, \"No valid XTENSION header found.\");\n         goto err_return;\n       }\n   }\n\n FITS_DECODE_CARD (VAR_0, \"NAXIS\", VAR_4, VAR_21);\n VAR_3->naxis = VAR_4->flong;\n\n FITS_DECODE_CARD (VAR_0, \"BITPIX\", VAR_4, VAR_21);\n VAR_8 = VAR_3->bitpix = (int)VAR_4->flong;\n if (   (VAR_8 != 8) && (VAR_8 != 16) && (VAR_8 != 32)\n     && (VAR_8 != -32) && (VAR_8 != -64))\n {\n   strcpy (VAR_5, \"fits_decode_header: Invalid BITPIX-value\");\n   goto err_return;\n }\n if (VAR_8 < 0) VAR_8 = -VAR_8;\n VAR_8 /= 8;\n VAR_3->bpp = VAR_8;\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"GCOUNT\", VAR_22, VAR_21, VAR_23);\n FITS_TRY_CARD (VAR_0, VAR_3, \"PCOUNT\", VAR_24, VAR_21, VAR_23);\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"GROUPS\", VAR_25, VAR_26, VAR_27);\n VAR_9 = VAR_3->used.groups && VAR_3->groups;\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"EXTEND\", VAR_28, VAR_26, VAR_27);\n\n if (VAR_3->used.xtension)  /* COMMENT_1 */\n {\n   if ((!VAR_3->used.gcount) || (!VAR_3->used.pcount))\n   {\n     strcpy (VAR_5, \"fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\");\n     goto err_return;\n   }\n }\n\n VAR_10 = 1;\n\n /* COMMENT_2 */\n for (VAR_7 = 1; VAR_7 <= VAR_29; VAR_7++)\n {char VAR_30[9];\n\n   sprintf (VAR_30, \"NAXIS%-3d\", VAR_7);\n   VAR_4 = fits_decode_card (fits_search_card (VAR_0, VAR_30), VAR_21);\n   if (VAR_4 == NULL)\n   {\n     VAR_7--;   /* COMMENT_3 */\n     break;\n   }\n   VAR_3->naxisn[VAR_7-1] = (int)VAR_4->flong;\n   if (VAR_3->naxisn[VAR_7-1] < 0)\n   {\n     strcpy (VAR_5, \"fits_decode_header: Negative value in NAXISn\");\n     goto err_return;\n   }\n   if ((VAR_7 == 1) && (VAR_9))\n   {\n     if (VAR_3->naxisn[0] != 0)\n     {\n       strcpy (VAR_5, \"fits_decode_header: Random groups with NAXIS1 != 0\");\n       goto err_return;\n     }\n   }\n   else\n     VAR_10 *= VAR_3->naxisn[VAR_7-1];\n }\n\n if ((VAR_3->naxis > 0) && (VAR_7 < VAR_3->naxis))\n {\n   strcpy (VAR_5, \"fits_decode_card: Not enough NAXISn-cards\");\n   goto err_return;\n }\n\n /* COMMENT_4 */\n /* COMMENT_5 */\n if (VAR_3->naxis < 2)\n   VAR_3->naxisn[1] = 1;\n if (VAR_3->naxis < 1)\n {\n   VAR_10 = 0;\n   VAR_3->naxisn[0] = 1;\n }\n\n if (VAR_3->used.xtension)\n   VAR_11 = VAR_8*VAR_3->gcount*(VAR_3->pcount + VAR_10);\n else\n   VAR_11 = VAR_8*VAR_10;\n VAR_3->udata_size = VAR_11;  /* COMMENT_6 */\n\n /* COMMENT_7 */\n VAR_11 = (VAR_11 + VAR_31 - 1) / VAR_31;\n VAR_11 *= VAR_31;\n VAR_3->data_size = VAR_11;\n\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"BLANK\", VAR_32, VAR_21, VAR_23);\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"DATAMIN\", VAR_33, VAR_34, VAR_35);\n FITS_TRY_CARD (VAR_0, VAR_3, \"DATAMAX\", VAR_36, VAR_34, VAR_35);\n\n FITS_TRY_CARD (VAR_0, VAR_3, \"BZERO\", VAR_37, VAR_34, VAR_35);\n FITS_TRY_CARD (VAR_0, VAR_3, \"BSCALE\", VAR_38, VAR_34, VAR_35);\n\n /* COMMENT_8 */\n VAR_3->numpic = 0;\n\n /* COMMENT_9 */\n VAR_12 =    (VAR_3->bitpix > 0)\n                    || (   (VAR_3->bitpix == -64)\n                        && (VAR_39 || VAR_40))\n                    || (   (VAR_3->bitpix == -32)\n                        && (   VAR_41 || VAR_42\n                            || VAR_39 || VAR_40));\n\n if (VAR_12)\n {\n   if (VAR_3->used.simple)\n   {\n     if (VAR_3->naxis > 0)\n     {\n       VAR_3->numpic = 1;\n       for (VAR_7 = 3; VAR_7 <= VAR_3->naxis; VAR_7++)\n         VAR_3->numpic *= VAR_3->naxisn[VAR_7-1];\n     }\n   }\n   else if (   VAR_3->used.xtension\n            && (strncmp (VAR_3->xtension, \"IMAGE\", 5) == 0))\n   {\n     if (VAR_3->naxis > 0)\n     {\n       VAR_3->numpic = 1;\n       for (VAR_7 = 3; VAR_7 <= VAR_3->naxis; VAR_7++)\n         VAR_3->numpic *= VAR_3->naxisn[VAR_7-1];\n     }\n   }\n }\n else\n {char VAR_43[160];\n   sprintf (VAR_43, \"fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\", VAR_3->bitpix);\n   fits_set_error (VAR_43);\n }\n\n VAR_3->header_record_list = VAR_0;  /* COMMENT_10 */\n return (VAR_3);\n\nerr_missing:\n sprintf (VAR_5, \"fits_decode_header: missing/invalid %s card\", VAR_6);\n\nerr_return:\n fits_delete_hdulist (VAR_3);\n fits_set_error (VAR_5);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}",
    "func_graph_path": "GNOME/gimp/0474376d234bc3d0901fd5e86f89d778a6473dd8/fits-io.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -28,10 +28,18 @@\n  hdulist->used.simple = (strncmp (hdr->data, \"SIMPLE  \", 8) == 0);\n  hdulist->used.xtension = (strncmp (hdr->data, \"XTENSION\", 8) == 0);\n  if (hdulist->used.xtension)\n- {\n-   fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);\n-   strcpy (hdulist->xtension, fdat->fstring);\n- }\n+   {\n+     fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);\n+     if (fdat != NULL)\n+       {\n+         strcpy (hdulist->xtension, fdat->fstring);\n+       }\n+     else\n+       {\n+         strcpy (errmsg, \"No valid XTENSION header found.\");\n+         goto err_return;\n+       }\n+   }\n \n  FITS_DECODE_CARD (hdr, \"NAXIS\", fdat, typ_flong);\n  hdulist->naxis = fdat->flong;",
    "diff_line_info": {
        "deleted_lines": [
            " {",
            "   fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);",
            "   strcpy (hdulist->xtension, fdat->fstring);",
            " }"
        ],
        "added_lines": [
            "   {",
            "     fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);",
            "     if (fdat != NULL)",
            "       {",
            "         strcpy (hdulist->xtension, fdat->fstring);",
            "       }",
            "     else",
            "       {",
            "         strcpy (errmsg, \"No valid XTENSION header found.\");",
            "         goto err_return;",
            "       }",
            "   }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}