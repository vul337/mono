{
    "cve_id": "CVE-2018-17073",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "wernsey/bitmap",
    "commit_msg": "Added a bunch of `assert(b)`'s to address CVE-2018-17073\nSee https://github.com/wernsey/bitmap/issues/1",
    "commit_hash": "1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b",
    "git_url": "https://github.com/wernsey/bitmap/commit/1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b",
    "file_path": "bmp.c",
    "func_name": "bm_fill",
    "func_before": "void bm_fill(Bitmap *b, int x, int y) {\n    BmPoint *queue, n;\n    int qs = 0, /* queue size */\n        mqs = 128; /* Max queue size */\n    unsigned int sc, dc; /* Source and Destination colors */\n\n    dc = b->color;\n    b->color = BM_GET(b, x, y);\n    sc = b->color;\n\n    /* Don't fill if source == dest\n     * It leads to major performance problems otherwise\n     */\n    if(sc == dc)\n        return;\n\n    queue = calloc(mqs, sizeof *queue);\n    if(!queue)\n        return;\n\n    n.x = x; n.y = y;\n    queue[qs++] = n;\n\n    while(qs > 0) {\n        BmPoint w,e, nn;\n        int i;\n\n        n = queue[--qs];\n        w = n;\n        e = n;\n\n        if(BM_GET(b, n.x, n.y) != sc)\n            continue;\n\n        while(w.x > b->clip.x0) {\n            if(BM_GET(b, w.x-1, w.y) != sc) {\n                break;\n            }\n            w.x--;\n        }\n        while(e.x < b->clip.x1 - 1) {\n            if(BM_GET(b, e.x+1, e.y) != sc) {\n                break;\n            }\n            e.x++;\n        }\n        for(i = w.x; i <= e.x; i++) {\n            assert(i >= 0 && i < b->w);\n            BM_SET(b, i, w.y, dc);\n            if(w.y > b->clip.y0) {\n                if(BM_GET(b, i, w.y - 1) == sc) {\n                    nn.x = i; nn.y = w.y - 1;\n                    queue[qs++] = nn;\n                    if(qs == mqs) {\n                        mqs <<= 1;\n                        void *tmp = realloc(queue, mqs * sizeof *queue);\n                        if (!queue) {\n                            free(queue);\n                            return;\n                        }\n                        queue = tmp;\n                    }\n                }\n            }\n            if(w.y < b->clip.y1 - 1) {\n                if(BM_GET(b, i, w.y + 1) == sc) {\n                    nn.x = i; nn.y = w.y + 1;\n                    queue[qs++] = nn;\n                    if(qs == mqs) {\n                        mqs <<= 1;\n                        void *tmp = realloc(queue, mqs * sizeof *queue);\n                        if (!tmp) {\n                            free(queue);\n                            return;\n                        }\n                        queue = tmp;\n                    }\n                }\n            }\n        }\n    }\n    free(queue);\n    b->color = dc;\n}",
    "abstract_func_before": "void bm_fill(Bitmap *VAR_0, int VAR_1, int VAR_2) {\n    BmPoint *VAR_3, VAR_4;\n    int VAR_5 = 0, /* COMMENT_0 */\n        VAR_6 = 128; /* COMMENT_1 */\n    unsigned int VAR_7, VAR_8; /* COMMENT_2 */\n\n    VAR_8 = VAR_0->color;\n    VAR_0->color = BM_GET(VAR_0, VAR_1, VAR_2);\n    VAR_7 = VAR_0->color;\n\n    /* COMMENT_3 */\n                                                       \n       \n    if(VAR_7 == VAR_8)\n        return;\n\n    VAR_3 = calloc(VAR_6, sizeof *VAR_3);\n    if(!VAR_3)\n        return;\n\n    VAR_4.x = VAR_1; VAR_4.y = VAR_2;\n    VAR_3[VAR_5++] = VAR_4;\n\n    while(VAR_5 > 0) {\n        BmPoint VAR_9,VAR_10, VAR_11;\n        int VAR_12;\n\n        VAR_4 = VAR_3[--VAR_5];\n        VAR_9 = VAR_4;\n        VAR_10 = VAR_4;\n\n        if(BM_GET(VAR_0, VAR_4.x, VAR_4.y) != VAR_7)\n            continue;\n\n        while(VAR_9.x > VAR_0->clip.x0) {\n            if(BM_GET(VAR_0, VAR_9.x-1, VAR_9.y) != VAR_7) {\n                break;\n            }\n            VAR_9.x--;\n        }\n        while(VAR_10.x < VAR_0->clip.x1 - 1) {\n            if(BM_GET(VAR_0, VAR_10.x+1, VAR_10.y) != VAR_7) {\n                break;\n            }\n            VAR_10.x++;\n        }\n        for(VAR_12 = VAR_9.x; VAR_12 <= VAR_10.x; VAR_12++) {\n            assert(VAR_12 >= 0 && VAR_12 < VAR_0->w);\n            BM_SET(VAR_0, VAR_12, VAR_9.y, VAR_8);\n            if(VAR_9.y > VAR_0->clip.y0) {\n                if(BM_GET(VAR_0, VAR_12, VAR_9.y - 1) == VAR_7) {\n                    VAR_11.x = VAR_12; VAR_11.y = VAR_9.y - 1;\n                    VAR_3[VAR_5++] = VAR_11;\n                    if(VAR_5 == VAR_6) {\n                        VAR_6 <<= 1;\n                        void *VAR_13 = realloc(VAR_3, VAR_6 * sizeof *VAR_3);\n                        if (!VAR_3) {\n                            free(VAR_3);\n                            return;\n                        }\n                        VAR_3 = VAR_13;\n                    }\n                }\n            }\n            if(VAR_9.y < VAR_0->clip.y1 - 1) {\n                if(BM_GET(VAR_0, VAR_12, VAR_9.y + 1) == VAR_7) {\n                    VAR_11.x = VAR_12; VAR_11.y = VAR_9.y + 1;\n                    VAR_3[VAR_5++] = VAR_11;\n                    if(VAR_5 == VAR_6) {\n                        VAR_6 <<= 1;\n                        void *VAR_13 = realloc(VAR_3, VAR_6 * sizeof *VAR_3);\n                        if (!VAR_13) {\n                            free(VAR_3);\n                            return;\n                        }\n                        VAR_3 = VAR_13;\n                    }\n                }\n            }\n        }\n    }\n    free(VAR_3);\n    VAR_0->color = VAR_8;\n}",
    "func_graph_path_before": "wernsey/bitmap/1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b/bmp.c/vul/before/19.json",
    "func": "void bm_fill(Bitmap *b, int x, int y) {\n    BmPoint *queue, n;\n    int qs = 0, /* queue size */\n        mqs = 128; /* Max queue size */\n    unsigned int sc, dc; /* Source and Destination colors */\n\t\n\tassert(b);\n\t\n    dc = b->color;\n    b->color = BM_GET(b, x, y);\n    sc = b->color;\n\n    /* Don't fill if source == dest\n     * It leads to major performance problems otherwise\n     */\n    if(sc == dc)\n        return;\n\n    queue = calloc(mqs, sizeof *queue);\n    if(!queue)\n        return;\n\n    n.x = x; n.y = y;\n    queue[qs++] = n;\n\n    while(qs > 0) {\n        BmPoint w,e, nn;\n        int i;\n\n        n = queue[--qs];\n        w = n;\n        e = n;\n\n        if(BM_GET(b, n.x, n.y) != sc)\n            continue;\n\n        while(w.x > b->clip.x0) {\n            if(BM_GET(b, w.x-1, w.y) != sc) {\n                break;\n            }\n            w.x--;\n        }\n        while(e.x < b->clip.x1 - 1) {\n            if(BM_GET(b, e.x+1, e.y) != sc) {\n                break;\n            }\n            e.x++;\n        }\n        for(i = w.x; i <= e.x; i++) {\n            assert(i >= 0 && i < b->w);\n            BM_SET(b, i, w.y, dc);\n            if(w.y > b->clip.y0) {\n                if(BM_GET(b, i, w.y - 1) == sc) {\n                    nn.x = i; nn.y = w.y - 1;\n                    queue[qs++] = nn;\n                    if(qs == mqs) {\n                        mqs <<= 1;\n                        void *tmp = realloc(queue, mqs * sizeof *queue);\n                        if (!queue) {\n                            free(queue);\n                            return;\n                        }\n                        queue = tmp;\n                    }\n                }\n            }\n            if(w.y < b->clip.y1 - 1) {\n                if(BM_GET(b, i, w.y + 1) == sc) {\n                    nn.x = i; nn.y = w.y + 1;\n                    queue[qs++] = nn;\n                    if(qs == mqs) {\n                        mqs <<= 1;\n                        void *tmp = realloc(queue, mqs * sizeof *queue);\n                        if (!tmp) {\n                            free(queue);\n                            return;\n                        }\n                        queue = tmp;\n                    }\n                }\n            }\n        }\n    }\n    free(queue);\n    b->color = dc;\n}",
    "abstract_func": "void bm_fill(Bitmap *VAR_0, int VAR_1, int VAR_2) {\n    BmPoint *VAR_3, VAR_4;\n    int VAR_5 = 0, /* COMMENT_0 */\n        VAR_6 = 128; /* COMMENT_1 */\n    unsigned int VAR_7, VAR_8; /* COMMENT_2 */\n\t\n\tassert(VAR_0);\n\t\n    VAR_8 = VAR_0->color;\n    VAR_0->color = BM_GET(VAR_0, VAR_1, VAR_2);\n    VAR_7 = VAR_0->color;\n\n    /* COMMENT_3 */\n                                                       \n       \n    if(VAR_7 == VAR_8)\n        return;\n\n    VAR_3 = calloc(VAR_6, sizeof *VAR_3);\n    if(!VAR_3)\n        return;\n\n    VAR_4.x = VAR_1; VAR_4.y = VAR_2;\n    VAR_3[VAR_5++] = VAR_4;\n\n    while(VAR_5 > 0) {\n        BmPoint VAR_9,VAR_10, VAR_11;\n        int VAR_12;\n\n        VAR_4 = VAR_3[--VAR_5];\n        VAR_9 = VAR_4;\n        VAR_10 = VAR_4;\n\n        if(BM_GET(VAR_0, VAR_4.x, VAR_4.y) != VAR_7)\n            continue;\n\n        while(VAR_9.x > VAR_0->clip.x0) {\n            if(BM_GET(VAR_0, VAR_9.x-1, VAR_9.y) != VAR_7) {\n                break;\n            }\n            VAR_9.x--;\n        }\n        while(VAR_10.x < VAR_0->clip.x1 - 1) {\n            if(BM_GET(VAR_0, VAR_10.x+1, VAR_10.y) != VAR_7) {\n                break;\n            }\n            VAR_10.x++;\n        }\n        for(VAR_12 = VAR_9.x; VAR_12 <= VAR_10.x; VAR_12++) {\n            assert(VAR_12 >= 0 && VAR_12 < VAR_0->w);\n            BM_SET(VAR_0, VAR_12, VAR_9.y, VAR_8);\n            if(VAR_9.y > VAR_0->clip.y0) {\n                if(BM_GET(VAR_0, VAR_12, VAR_9.y - 1) == VAR_7) {\n                    VAR_11.x = VAR_12; VAR_11.y = VAR_9.y - 1;\n                    VAR_3[VAR_5++] = VAR_11;\n                    if(VAR_5 == VAR_6) {\n                        VAR_6 <<= 1;\n                        void *VAR_13 = realloc(VAR_3, VAR_6 * sizeof *VAR_3);\n                        if (!VAR_3) {\n                            free(VAR_3);\n                            return;\n                        }\n                        VAR_3 = VAR_13;\n                    }\n                }\n            }\n            if(VAR_9.y < VAR_0->clip.y1 - 1) {\n                if(BM_GET(VAR_0, VAR_12, VAR_9.y + 1) == VAR_7) {\n                    VAR_11.x = VAR_12; VAR_11.y = VAR_9.y + 1;\n                    VAR_3[VAR_5++] = VAR_11;\n                    if(VAR_5 == VAR_6) {\n                        VAR_6 <<= 1;\n                        void *VAR_13 = realloc(VAR_3, VAR_6 * sizeof *VAR_3);\n                        if (!VAR_13) {\n                            free(VAR_3);\n                            return;\n                        }\n                        VAR_3 = VAR_13;\n                    }\n                }\n            }\n        }\n    }\n    free(VAR_3);\n    VAR_0->color = VAR_8;\n}",
    "func_graph_path": "wernsey/bitmap/1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b/bmp.c/vul/after/19.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,9 @@\n     int qs = 0, /* queue size */\n         mqs = 128; /* Max queue size */\n     unsigned int sc, dc; /* Source and Destination colors */\n-\n+\t\n+\tassert(b);\n+\t\n     dc = b->color;\n     b->color = BM_GET(b, x, y);\n     sc = b->color;",
    "diff_line_info": {
        "deleted_lines": [
            ""
        ],
        "added_lines": [
            "\t",
            "\tassert(b);",
            "\t"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}