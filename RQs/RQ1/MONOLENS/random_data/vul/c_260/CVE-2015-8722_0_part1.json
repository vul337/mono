{
    "cve_id": "CVE-2015-8722",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "wireshark",
    "commit_msg": "SCTP: verify frame pointer before dereferencing it\n\nBug: 11767\nChange-Id: Icd01550e0aaa4cd0cc33ae3acc0ef702c38f4db4\nReviewed-on: https://code.wireshark.org/review/12146\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "commit_hash": "2259bf8a827088081bef101f98e4983de8aa8099",
    "git_url": "https://github.com/wireshark/wireshark/commit/2259bf8a827088081bef101f98e4983de8aa8099",
    "file_path": "epan/dissectors/packet-sctp.c",
    "func_name": "dissect_data_chunk",
    "func_before": "static gboolean\ndissect_data_chunk(tvbuff_t *chunk_tvb,\n                   guint16 chunk_length,\n                   packet_info *pinfo,\n                   proto_tree *tree,\n                   proto_tree *chunk_tree,\n                   proto_item *chunk_item,\n                   proto_item *flags_item,\n                   sctp_half_assoc_t *ha,\n                   gboolean is_idata)\n{\n  guint number_of_ppid;\n  volatile guint32 payload_proto_id;\n  tvbuff_t *payload_tvb;\n  proto_tree *flags_tree;\n  guint8 e_bit, b_bit, u_bit;\n  guint16 stream_id;\n  guint32 tsn, ppid, stream_seq_num = 0;\n  proto_item *tsn_item = NULL;\n  gboolean call_subdissector = FALSE;\n  gboolean is_retransmission;\n  guint16 header_length;\n  guint16 payload_offset;\n\n  if (is_idata) {\n    if (chunk_length < I_DATA_CHUNK_HEADER_LENGTH) {\n      proto_item_append_text(chunk_item, \", bogus chunk length %u < %u)\", chunk_length, I_DATA_CHUNK_HEADER_LENGTH);\n      return TRUE;\n    }\n    payload_proto_id  = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET);\n  } else {\n    if (chunk_length < DATA_CHUNK_HEADER_LENGTH) {\n      proto_item_append_text(chunk_item, \", bogus chunk length %u < %u)\", chunk_length, DATA_CHUNK_HEADER_LENGTH);\n      return TRUE;\n    }\n    payload_proto_id  = tvb_get_ntohl(chunk_tvb, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET);\n  }\n\n  /* insert the PPID in the pinfo structure if it is not already there and there is still room */\n  for(number_of_ppid = 0; number_of_ppid < MAX_NUMBER_OF_PPIDS; number_of_ppid++) {\n    void *tmp = p_get_proto_data(pinfo->pool, pinfo, proto_sctp, number_of_ppid);\n    ppid = GPOINTER_TO_UINT(tmp);\n    if ((ppid == LAST_PPID) || (ppid == payload_proto_id))\n      break;\n  }\n  if ((number_of_ppid < MAX_NUMBER_OF_PPIDS) && (ppid == LAST_PPID))\n    p_add_proto_data(pinfo->pool, pinfo, proto_sctp, number_of_ppid, GUINT_TO_POINTER(payload_proto_id));\n\n  e_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_E_BIT;\n  b_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_B_BIT;\n  u_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_U_BIT;\n  tsn = tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET);\n\n  if (chunk_tree) {\n    if (is_idata)\n      proto_item_set_len(chunk_item, I_DATA_CHUNK_HEADER_LENGTH);\n    else\n      proto_item_set_len(chunk_item, DATA_CHUNK_HEADER_LENGTH);\n    flags_tree  = proto_item_add_subtree(flags_item, ett_sctp_data_chunk_flags);\n    proto_tree_add_item(flags_tree, hf_data_chunk_e_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);\n    proto_tree_add_item(flags_tree, hf_data_chunk_b_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);\n    proto_tree_add_item(flags_tree, hf_data_chunk_u_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);\n    proto_tree_add_item(flags_tree, hf_data_chunk_i_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);\n    tsn_item = proto_tree_add_item(chunk_tree, hf_data_chunk_tsn,    chunk_tvb, DATA_CHUNK_TSN_OFFSET,                 DATA_CHUNK_TSN_LENGTH,                 ENC_BIG_ENDIAN);\n    proto_tree_add_item(chunk_tree, hf_data_chunk_stream_id,         chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET,           DATA_CHUNK_STREAM_ID_LENGTH,           ENC_BIG_ENDIAN);\n    if (is_idata) {\n      proto_tree_add_item(chunk_tree, hf_idata_chunk_reserved, chunk_tvb, I_DATA_CHUNK_RESERVED_OFFSET, I_DATA_CHUNK_RESERVED_LENGTH, ENC_BIG_ENDIAN);\n      proto_tree_add_item(chunk_tree, hf_idata_chunk_mid, chunk_tvb, I_DATA_CHUNK_MID_OFFSET, I_DATA_CHUNK_MID_LENGTH, ENC_BIG_ENDIAN);\n      if (b_bit)\n        proto_tree_add_item(chunk_tree, hf_data_chunk_payload_proto_id,  chunk_tvb, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_LENGTH, ENC_BIG_ENDIAN);\n      else\n        proto_tree_add_item(chunk_tree, hf_idata_chunk_fsn, chunk_tvb, I_DATA_CHUNK_FSN_OFFSET, I_DATA_CHUNK_FSN_LENGTH, ENC_BIG_ENDIAN);\n    } else {\n      proto_tree_add_item(chunk_tree, hf_data_chunk_stream_seq_number, chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET,   DATA_CHUNK_STREAM_SEQ_NUMBER_LENGTH,   ENC_BIG_ENDIAN);\n      proto_tree_add_item(chunk_tree, hf_data_chunk_payload_proto_id,  chunk_tvb, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_LENGTH, ENC_BIG_ENDIAN);\n    }\n    proto_item_append_text(chunk_item, \"(%s, \", (u_bit) ? \"unordered\" : \"ordered\");\n    if (b_bit) {\n      if (e_bit)\n        proto_item_append_text(chunk_item, \"complete\");\n      else\n        proto_item_append_text(chunk_item, \"first\");\n    } else {\n      if (e_bit)\n        proto_item_append_text(chunk_item, \"last\");\n      else\n        proto_item_append_text(chunk_item, \"middle\");\n    }\n\n    if (is_idata) {\n      if (b_bit)\n        proto_item_append_text(chunk_item, \" segment, TSN: %u, SID: %u, MID: %u, payload length: %u byte%s)\",\n                               tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),\n                               tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),\n                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET),\n                               chunk_length - I_DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - I_DATA_CHUNK_HEADER_LENGTH, \"\", \"s\"));\n      else\n        proto_item_append_text(chunk_item, \" segment, TSN: %u, SID: %u, MID: %u, FSN: %u, payload length: %u byte%s)\",\n                               tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),\n                               tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),\n                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET),\n                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_FSN_OFFSET),\n                               chunk_length - I_DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - I_DATA_CHUNK_HEADER_LENGTH, \"\", \"s\"));\n    } else\n      proto_item_append_text(chunk_item, \" segment, TSN: %u, SID: %u, SSN: %u, PPID: %u, payload length: %u byte%s)\",\n                             tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),\n                             tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),\n                             tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET),\n                             payload_proto_id,\n                             chunk_length - DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - DATA_CHUNK_HEADER_LENGTH, \"\", \"s\"));\n  }\n\n  is_retransmission = sctp_tsn(pinfo, chunk_tvb, tsn_item, ha, tsn);\n\n  if (is_idata) {\n    header_length = I_DATA_CHUNK_HEADER_LENGTH;\n    payload_offset = I_DATA_CHUNK_PAYLOAD_OFFSET;\n  } else {\n    header_length = DATA_CHUNK_HEADER_LENGTH;\n    payload_offset = DATA_CHUNK_PAYLOAD_OFFSET;\n  }\n  payload_tvb = tvb_new_subset(chunk_tvb, payload_offset,\n                                 MIN(chunk_length - header_length, tvb_captured_length_remaining(chunk_tvb, payload_offset)),\n                                 MIN(chunk_length - header_length, tvb_reported_length_remaining(chunk_tvb, payload_offset)));\n\n  /* Is this a fragment? */\n  if (b_bit && e_bit) {\n    /* No - just call the subdissector. */\n    if (!is_retransmission)\n      call_subdissector = TRUE;\n  } else {\n    /* Yes. */\n    pinfo->fragmented = TRUE;\n\n    /* if reassembly is off just mark as fragment for next dissector and proceed */\n    if (!use_reassembly)\n    {\n      /*  Don't pass on non-first fragments since the next dissector will\n       *  almost certainly not understand the data.\n       */\n      if (b_bit) {\n        if (!is_retransmission)\n          call_subdissector = TRUE;\n      } else\n        return FALSE;\n    }\n\n  }\n\n  if (call_subdissector) {\n    /* This isn't a fragment or reassembly is off and it's the first fragment */\n\n    volatile gboolean retval = FALSE;\n\n    TRY {\n      wmem_list_frame_t *cur;\n      guint proto_id;\n      const gchar *proto_name;\n      void *tmp;\n\n      cur = wmem_list_tail(pinfo->layers);\n      retval = dissect_payload(payload_tvb, pinfo, tree, payload_proto_id);\n      cur = wmem_list_frame_next(cur);\n      tmp = wmem_list_frame_data(cur);\n      proto_id = GPOINTER_TO_UINT(tmp);\n      proto_name = proto_get_protocol_filter_name(proto_id);\n      if (strcmp(proto_name, \"data\") != 0){\n        if (have_tap_listener(exported_pdu_tap)){\n          export_sctp_data_chunk(pinfo,payload_tvb, proto_name);\n        }\n      }\n    }\n    CATCH_NONFATAL_ERRORS {\n      /*\n       * Somebody threw an exception that means that there was a problem\n       * dissecting the payload; that means that a dissector was found,\n       * so we don't need to dissect the payload as data or update the\n       * protocol or info columns.\n       *\n       * Just show the exception and then continue dissecting chunks.\n       */\n      show_exception(payload_tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\n    }\n    ENDTRY;\n\n    return retval;\n\n  } else if (is_retransmission) {\n    col_append_str(pinfo->cinfo, COL_INFO, \"(retransmission) \");\n    return FALSE;\n  } else {\n\n    /* The logic above should ensure this... */\n    DISSECTOR_ASSERT(use_reassembly);\n\n    stream_id = tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET);\n    if (is_idata) {\n      /* The stream_seq_num variable is used to hold the MID, the tsn variable holds the FSN*/\n      stream_seq_num = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET);\n      if (b_bit) {\n        tsn = 0;\n      } else {\n        tsn = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_FSN_OFFSET);\n        payload_proto_id = 0;\n      }\n    } else {\n      /* if unordered set stream_seq_num to 0 for easier handling */\n      if (u_bit)\n        stream_seq_num = 0;\n      else\n        stream_seq_num = tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET);\n    }\n    /* start reassembly */\n    return dissect_fragmented_payload(payload_tvb, pinfo, tree, chunk_tree, tsn, payload_proto_id, stream_id, stream_seq_num, b_bit, e_bit, u_bit, is_idata);\n  }\n\n}",
    "abstract_func_before": "static gboolean\ndissect_data_chunk(tvbuff_t *VAR_0,\n                   guint16 VAR_1,\n                   packet_info *VAR_2,\n                   proto_tree *VAR_3,\n                   proto_tree *VAR_4,\n                   proto_item *VAR_5,\n                   proto_item *VAR_6,\n                   sctp_half_assoc_t *VAR_7,\n                   gboolean VAR_8)\n{\n  guint VAR_9;\n  volatile guint32 VAR_10;\n  tvbuff_t *VAR_11;\n  proto_tree *VAR_12;\n  guint8 VAR_13, VAR_14, VAR_15;\n  guint16 VAR_16;\n  guint32 VAR_17, VAR_18, VAR_19 = 0;\n  proto_item *VAR_20 = NULL;\n  gboolean VAR_21 = FALSE;\n  gboolean VAR_22;\n  guint16 VAR_23;\n  guint16 VAR_24;\n\n  if (VAR_8) {\n    if (VAR_1 < VAR_25) {\n      proto_item_append_text(VAR_5, \", bogus chunk length %u < %u)\", VAR_1, VAR_25);\n      return TRUE;\n    }\n    VAR_10  = tvb_get_ntohl(VAR_0, VAR_26);\n  } else {\n    if (VAR_1 < VAR_27) {\n      proto_item_append_text(VAR_5, \", bogus chunk length %u < %u)\", VAR_1, VAR_27);\n      return TRUE;\n    }\n    VAR_10  = tvb_get_ntohl(VAR_0, VAR_28);\n  }\n\n  /* COMMENT_0 */\n  for(VAR_9 = 0; VAR_9 < VAR_29; VAR_9++) {\n    void *VAR_30 = p_get_proto_data(VAR_2->pool, VAR_2, VAR_31, VAR_9);\n    VAR_18 = GPOINTER_TO_UINT(VAR_30);\n    if ((VAR_18 == VAR_32) || (VAR_18 == VAR_10))\n      break;\n  }\n  if ((VAR_9 < VAR_29) && (VAR_18 == VAR_32))\n    p_add_proto_data(VAR_2->pool, VAR_2, VAR_31, VAR_9, GUINT_TO_POINTER(VAR_10));\n\n  VAR_13 = tvb_get_guint8(VAR_0, VAR_33) & VAR_34;\n  VAR_14 = tvb_get_guint8(VAR_0, VAR_33) & VAR_35;\n  VAR_15 = tvb_get_guint8(VAR_0, VAR_33) & VAR_36;\n  VAR_17 = tvb_get_ntohl(VAR_0, VAR_37);\n\n  if (VAR_4) {\n    if (VAR_8)\n      proto_item_set_len(VAR_5, VAR_25);\n    else\n      proto_item_set_len(VAR_5, VAR_27);\n    VAR_12  = proto_item_add_subtree(VAR_6, VAR_38);\n    proto_tree_add_item(VAR_12, VAR_39,             VAR_0, VAR_33,                    VAR_40,                    VAR_41);\n    proto_tree_add_item(VAR_12, VAR_42,             VAR_0, VAR_33,                    VAR_40,                    VAR_41);\n    proto_tree_add_item(VAR_12, VAR_43,             VAR_0, VAR_33,                    VAR_40,                    VAR_41);\n    proto_tree_add_item(VAR_12, VAR_44,             VAR_0, VAR_33,                    VAR_40,                    VAR_41);\n    VAR_20 = proto_tree_add_item(VAR_4, VAR_45,    VAR_0, VAR_37,                 VAR_46,                 VAR_41);\n    proto_tree_add_item(VAR_4, VAR_47,         VAR_0, VAR_48,           VAR_49,           VAR_41);\n    if (VAR_8) {\n      proto_tree_add_item(VAR_4, VAR_50, VAR_0, VAR_51, VAR_52, VAR_41);\n      proto_tree_add_item(VAR_4, VAR_53, VAR_0, VAR_54, VAR_55, VAR_41);\n      if (VAR_14)\n        proto_tree_add_item(VAR_4, VAR_56,  VAR_0, VAR_26, VAR_57, VAR_41);\n      else\n        proto_tree_add_item(VAR_4, VAR_58, VAR_0, VAR_59, VAR_60, VAR_41);\n    } else {\n      proto_tree_add_item(VAR_4, VAR_61, VAR_0, VAR_62,   VAR_63,   VAR_41);\n      proto_tree_add_item(VAR_4, VAR_56,  VAR_0, VAR_28, VAR_64, VAR_41);\n    }\n    proto_item_append_text(VAR_5, \"(%s, \", (VAR_15) ? \"unordered\" : \"ordered\");\n    if (VAR_14) {\n      if (VAR_13)\n        proto_item_append_text(VAR_5, \"complete\");\n      else\n        proto_item_append_text(VAR_5, \"first\");\n    } else {\n      if (VAR_13)\n        proto_item_append_text(VAR_5, \"last\");\n      else\n        proto_item_append_text(VAR_5, \"middle\");\n    }\n\n    if (VAR_8) {\n      if (VAR_14)\n        proto_item_append_text(VAR_5, \" segment, TSN: %u, SID: %u, MID: %u, payload length: %u byte%s)\",\n                               tvb_get_ntohl(VAR_0, VAR_37),\n                               tvb_get_ntohs(VAR_0, VAR_48),\n                               tvb_get_ntohl(VAR_0, VAR_54),\n                               VAR_1 - VAR_25, plurality(VAR_1 - VAR_25, \"\", \"s\"));\n      else\n        proto_item_append_text(VAR_5, \" segment, TSN: %u, SID: %u, MID: %u, FSN: %u, payload length: %u byte%s)\",\n                               tvb_get_ntohl(VAR_0, VAR_37),\n                               tvb_get_ntohs(VAR_0, VAR_48),\n                               tvb_get_ntohl(VAR_0, VAR_54),\n                               tvb_get_ntohl(VAR_0, VAR_59),\n                               VAR_1 - VAR_25, plurality(VAR_1 - VAR_25, \"\", \"s\"));\n    } else\n      proto_item_append_text(VAR_5, \" segment, TSN: %u, SID: %u, SSN: %u, PPID: %u, payload length: %u byte%s)\",\n                             tvb_get_ntohl(VAR_0, VAR_37),\n                             tvb_get_ntohs(VAR_0, VAR_48),\n                             tvb_get_ntohs(VAR_0, VAR_62),\n                             VAR_10,\n                             VAR_1 - VAR_27, plurality(VAR_1 - VAR_27, \"\", \"s\"));\n  }\n\n  VAR_22 = sctp_tsn(VAR_2, VAR_0, VAR_20, VAR_7, VAR_17);\n\n  if (VAR_8) {\n    VAR_23 = VAR_25;\n    VAR_24 = VAR_65;\n  } else {\n    VAR_23 = VAR_27;\n    VAR_24 = VAR_66;\n  }\n  VAR_11 = tvb_new_subset(VAR_0, VAR_24,\n                                 MIN(VAR_1 - VAR_23, tvb_captured_length_remaining(VAR_0, VAR_24)),\n                                 MIN(VAR_1 - VAR_23, tvb_reported_length_remaining(VAR_0, VAR_24)));\n\n  /* COMMENT_1 */\n  if (VAR_14 && VAR_13) {\n    /* COMMENT_2 */\n    if (!VAR_22)\n      VAR_21 = TRUE;\n  } else {\n    /* COMMENT_3 */\n    VAR_2->fragmented = TRUE;\n\n    /* COMMENT_4 */\n    if (!VAR_67)\n    {\n      /* COMMENT_5 */\n                                                   \n         \n      if (VAR_14) {\n        if (!VAR_22)\n          VAR_21 = TRUE;\n      } else\n        return FALSE;\n    }\n\n  }\n\n  if (VAR_21) {\n    /* COMMENT_8 */\n\n    volatile gboolean VAR_68 = FALSE;\n\n    TRY {\n      wmem_list_frame_t *VAR_69;\n      guint VAR_70;\n      const gchar *VAR_71;\n      void *VAR_30;\n\n      VAR_69 = wmem_list_tail(VAR_2->layers);\n      VAR_68 = dissect_payload(VAR_11, VAR_2, VAR_3, VAR_10);\n      VAR_69 = wmem_list_frame_next(VAR_69);\n      VAR_30 = wmem_list_frame_data(VAR_69);\n      VAR_70 = GPOINTER_TO_UINT(VAR_30);\n      VAR_71 = proto_get_protocol_filter_name(VAR_70);\n      if (strcmp(VAR_71, \"data\") != 0){\n        if (have_tap_listener(VAR_72)){\n          export_sctp_data_chunk(VAR_2,VAR_11, VAR_71);\n        }\n      }\n    }\n    CATCH_NONFATAL_ERRORS {\n      /* COMMENT_9 */\n                                                                        \n                                                                       \n                                                                      \n                                  \n        \n                                                                     \n         \n      show_exception(VAR_11, VAR_2, VAR_3, VAR_73, VAR_74);\n    }\n    VAR_75;\n\n    return VAR_68;\n\n  } else if (VAR_22) {\n    col_append_str(VAR_2->cinfo, VAR_76, \"(retransmission) \");\n    return FALSE;\n  } else {\n\n    /* COMMENT_17 */\n    DISSECTOR_ASSERT(VAR_67);\n\n    VAR_16 = tvb_get_ntohs(VAR_0, VAR_48);\n    if (VAR_8) {\n      /* COMMENT_18 */\n      VAR_19 = tvb_get_ntohl(VAR_0, VAR_54);\n      if (VAR_14) {\n        VAR_17 = 0;\n      } else {\n        VAR_17 = tvb_get_ntohl(VAR_0, VAR_59);\n        VAR_10 = 0;\n      }\n    } else {\n      /* COMMENT_19 */\n      if (VAR_15)\n        VAR_19 = 0;\n      else\n        VAR_19 = tvb_get_ntohs(VAR_0, VAR_62);\n    }\n    /* COMMENT_20 */\n    return dissect_fragmented_payload(VAR_11, VAR_2, VAR_3, VAR_4, VAR_17, VAR_10, VAR_16, VAR_19, VAR_14, VAR_13, VAR_15, VAR_8);\n  }\n\n}",
    "func_graph_path_before": "wireshark/2259bf8a827088081bef101f98e4983de8aa8099/packet-sctp.c/vul/before/0.json",
    "func": "static gboolean\ndissect_data_chunk(tvbuff_t *chunk_tvb,\n                   guint16 chunk_length,\n                   packet_info *pinfo,\n                   proto_tree *tree,\n                   proto_tree *chunk_tree,\n                   proto_item *chunk_item,\n                   proto_item *flags_item,\n                   sctp_half_assoc_t *ha,\n                   gboolean is_idata)\n{\n  guint number_of_ppid;\n  volatile guint32 payload_proto_id;\n  tvbuff_t *payload_tvb;\n  proto_tree *flags_tree;\n  guint8 e_bit, b_bit, u_bit;\n  guint16 stream_id;\n  guint32 tsn, ppid, stream_seq_num = 0;\n  proto_item *tsn_item = NULL;\n  gboolean call_subdissector = FALSE;\n  gboolean is_retransmission;\n  guint16 header_length;\n  guint16 payload_offset;\n\n  if (is_idata) {\n    if (chunk_length < I_DATA_CHUNK_HEADER_LENGTH) {\n      proto_item_append_text(chunk_item, \", bogus chunk length %u < %u)\", chunk_length, I_DATA_CHUNK_HEADER_LENGTH);\n      return TRUE;\n    }\n    payload_proto_id  = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET);\n  } else {\n    if (chunk_length < DATA_CHUNK_HEADER_LENGTH) {\n      proto_item_append_text(chunk_item, \", bogus chunk length %u < %u)\", chunk_length, DATA_CHUNK_HEADER_LENGTH);\n      return TRUE;\n    }\n    payload_proto_id  = tvb_get_ntohl(chunk_tvb, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET);\n  }\n\n  /* insert the PPID in the pinfo structure if it is not already there and there is still room */\n  for(number_of_ppid = 0; number_of_ppid < MAX_NUMBER_OF_PPIDS; number_of_ppid++) {\n    void *tmp = p_get_proto_data(pinfo->pool, pinfo, proto_sctp, number_of_ppid);\n    ppid = GPOINTER_TO_UINT(tmp);\n    if ((ppid == LAST_PPID) || (ppid == payload_proto_id))\n      break;\n  }\n  if ((number_of_ppid < MAX_NUMBER_OF_PPIDS) && (ppid == LAST_PPID))\n    p_add_proto_data(pinfo->pool, pinfo, proto_sctp, number_of_ppid, GUINT_TO_POINTER(payload_proto_id));\n\n  e_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_E_BIT;\n  b_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_B_BIT;\n  u_bit = tvb_get_guint8(chunk_tvb, CHUNK_FLAGS_OFFSET) & SCTP_DATA_CHUNK_U_BIT;\n  tsn = tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET);\n\n  if (chunk_tree) {\n    if (is_idata)\n      proto_item_set_len(chunk_item, I_DATA_CHUNK_HEADER_LENGTH);\n    else\n      proto_item_set_len(chunk_item, DATA_CHUNK_HEADER_LENGTH);\n    flags_tree  = proto_item_add_subtree(flags_item, ett_sctp_data_chunk_flags);\n    proto_tree_add_item(flags_tree, hf_data_chunk_e_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);\n    proto_tree_add_item(flags_tree, hf_data_chunk_b_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);\n    proto_tree_add_item(flags_tree, hf_data_chunk_u_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);\n    proto_tree_add_item(flags_tree, hf_data_chunk_i_bit,             chunk_tvb, CHUNK_FLAGS_OFFSET,                    CHUNK_FLAGS_LENGTH,                    ENC_BIG_ENDIAN);\n    tsn_item = proto_tree_add_item(chunk_tree, hf_data_chunk_tsn,    chunk_tvb, DATA_CHUNK_TSN_OFFSET,                 DATA_CHUNK_TSN_LENGTH,                 ENC_BIG_ENDIAN);\n    proto_tree_add_item(chunk_tree, hf_data_chunk_stream_id,         chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET,           DATA_CHUNK_STREAM_ID_LENGTH,           ENC_BIG_ENDIAN);\n    if (is_idata) {\n      proto_tree_add_item(chunk_tree, hf_idata_chunk_reserved, chunk_tvb, I_DATA_CHUNK_RESERVED_OFFSET, I_DATA_CHUNK_RESERVED_LENGTH, ENC_BIG_ENDIAN);\n      proto_tree_add_item(chunk_tree, hf_idata_chunk_mid, chunk_tvb, I_DATA_CHUNK_MID_OFFSET, I_DATA_CHUNK_MID_LENGTH, ENC_BIG_ENDIAN);\n      if (b_bit)\n        proto_tree_add_item(chunk_tree, hf_data_chunk_payload_proto_id,  chunk_tvb, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET, I_DATA_CHUNK_PAYLOAD_PROTOCOL_ID_LENGTH, ENC_BIG_ENDIAN);\n      else\n        proto_tree_add_item(chunk_tree, hf_idata_chunk_fsn, chunk_tvb, I_DATA_CHUNK_FSN_OFFSET, I_DATA_CHUNK_FSN_LENGTH, ENC_BIG_ENDIAN);\n    } else {\n      proto_tree_add_item(chunk_tree, hf_data_chunk_stream_seq_number, chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET,   DATA_CHUNK_STREAM_SEQ_NUMBER_LENGTH,   ENC_BIG_ENDIAN);\n      proto_tree_add_item(chunk_tree, hf_data_chunk_payload_proto_id,  chunk_tvb, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_OFFSET, DATA_CHUNK_PAYLOAD_PROTOCOL_ID_LENGTH, ENC_BIG_ENDIAN);\n    }\n    proto_item_append_text(chunk_item, \"(%s, \", (u_bit) ? \"unordered\" : \"ordered\");\n    if (b_bit) {\n      if (e_bit)\n        proto_item_append_text(chunk_item, \"complete\");\n      else\n        proto_item_append_text(chunk_item, \"first\");\n    } else {\n      if (e_bit)\n        proto_item_append_text(chunk_item, \"last\");\n      else\n        proto_item_append_text(chunk_item, \"middle\");\n    }\n\n    if (is_idata) {\n      if (b_bit)\n        proto_item_append_text(chunk_item, \" segment, TSN: %u, SID: %u, MID: %u, payload length: %u byte%s)\",\n                               tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),\n                               tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),\n                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET),\n                               chunk_length - I_DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - I_DATA_CHUNK_HEADER_LENGTH, \"\", \"s\"));\n      else\n        proto_item_append_text(chunk_item, \" segment, TSN: %u, SID: %u, MID: %u, FSN: %u, payload length: %u byte%s)\",\n                               tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),\n                               tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),\n                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET),\n                               tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_FSN_OFFSET),\n                               chunk_length - I_DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - I_DATA_CHUNK_HEADER_LENGTH, \"\", \"s\"));\n    } else\n      proto_item_append_text(chunk_item, \" segment, TSN: %u, SID: %u, SSN: %u, PPID: %u, payload length: %u byte%s)\",\n                             tvb_get_ntohl(chunk_tvb, DATA_CHUNK_TSN_OFFSET),\n                             tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET),\n                             tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET),\n                             payload_proto_id,\n                             chunk_length - DATA_CHUNK_HEADER_LENGTH, plurality(chunk_length - DATA_CHUNK_HEADER_LENGTH, \"\", \"s\"));\n  }\n\n  is_retransmission = sctp_tsn(pinfo, chunk_tvb, tsn_item, ha, tsn);\n\n  if (is_idata) {\n    header_length = I_DATA_CHUNK_HEADER_LENGTH;\n    payload_offset = I_DATA_CHUNK_PAYLOAD_OFFSET;\n  } else {\n    header_length = DATA_CHUNK_HEADER_LENGTH;\n    payload_offset = DATA_CHUNK_PAYLOAD_OFFSET;\n  }\n  payload_tvb = tvb_new_subset(chunk_tvb, payload_offset,\n                                 MIN(chunk_length - header_length, tvb_captured_length_remaining(chunk_tvb, payload_offset)),\n                                 MIN(chunk_length - header_length, tvb_reported_length_remaining(chunk_tvb, payload_offset)));\n\n  /* Is this a fragment? */\n  if (b_bit && e_bit) {\n    /* No - just call the subdissector. */\n    if (!is_retransmission)\n      call_subdissector = TRUE;\n  } else {\n    /* Yes. */\n    pinfo->fragmented = TRUE;\n\n    /* if reassembly is off just mark as fragment for next dissector and proceed */\n    if (!use_reassembly)\n    {\n      /*  Don't pass on non-first fragments since the next dissector will\n       *  almost certainly not understand the data.\n       */\n      if (b_bit) {\n        if (!is_retransmission)\n          call_subdissector = TRUE;\n      } else\n        return FALSE;\n    }\n\n  }\n\n  if (call_subdissector) {\n    /* This isn't a fragment or reassembly is off and it's the first fragment */\n\n    volatile gboolean retval = FALSE;\n\n    TRY {\n      wmem_list_frame_t *cur;\n      guint proto_id;\n      const gchar *proto_name;\n      void *tmp;\n\n      cur = wmem_list_tail(pinfo->layers);\n      retval = dissect_payload(payload_tvb, pinfo, tree, payload_proto_id);\n      cur = wmem_list_frame_next(cur);\n      if (cur) {\n        tmp = wmem_list_frame_data(cur);\n        proto_id = GPOINTER_TO_UINT(tmp);\n        proto_name = proto_get_protocol_filter_name(proto_id);\n        if (strcmp(proto_name, \"data\") != 0){\n          if (have_tap_listener(exported_pdu_tap)){\n            export_sctp_data_chunk(pinfo,payload_tvb, proto_name);\n          }\n        }\n      }\n    }\n    CATCH_NONFATAL_ERRORS {\n      /*\n       * Somebody threw an exception that means that there was a problem\n       * dissecting the payload; that means that a dissector was found,\n       * so we don't need to dissect the payload as data or update the\n       * protocol or info columns.\n       *\n       * Just show the exception and then continue dissecting chunks.\n       */\n      show_exception(payload_tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\n    }\n    ENDTRY;\n\n    return retval;\n\n  } else if (is_retransmission) {\n    col_append_str(pinfo->cinfo, COL_INFO, \"(retransmission) \");\n    return FALSE;\n  } else {\n\n    /* The logic above should ensure this... */\n    DISSECTOR_ASSERT(use_reassembly);\n\n    stream_id = tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_ID_OFFSET);\n    if (is_idata) {\n      /* The stream_seq_num variable is used to hold the MID, the tsn variable holds the FSN*/\n      stream_seq_num = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_MID_OFFSET);\n      if (b_bit) {\n        tsn = 0;\n      } else {\n        tsn = tvb_get_ntohl(chunk_tvb, I_DATA_CHUNK_FSN_OFFSET);\n        payload_proto_id = 0;\n      }\n    } else {\n      /* if unordered set stream_seq_num to 0 for easier handling */\n      if (u_bit)\n        stream_seq_num = 0;\n      else\n        stream_seq_num = tvb_get_ntohs(chunk_tvb, DATA_CHUNK_STREAM_SEQ_NUMBER_OFFSET);\n    }\n    /* start reassembly */\n    return dissect_fragmented_payload(payload_tvb, pinfo, tree, chunk_tree, tsn, payload_proto_id, stream_id, stream_seq_num, b_bit, e_bit, u_bit, is_idata);\n  }\n\n}",
    "abstract_func": "static gboolean\ndissect_data_chunk(tvbuff_t *VAR_0,\n                   guint16 VAR_1,\n                   packet_info *VAR_2,\n                   proto_tree *VAR_3,\n                   proto_tree *VAR_4,\n                   proto_item *VAR_5,\n                   proto_item *VAR_6,\n                   sctp_half_assoc_t *VAR_7,\n                   gboolean VAR_8)\n{\n  guint VAR_9;\n  volatile guint32 VAR_10;\n  tvbuff_t *VAR_11;\n  proto_tree *VAR_12;\n  guint8 VAR_13, VAR_14, VAR_15;\n  guint16 VAR_16;\n  guint32 VAR_17, VAR_18, VAR_19 = 0;\n  proto_item *VAR_20 = NULL;\n  gboolean VAR_21 = FALSE;\n  gboolean VAR_22;\n  guint16 VAR_23;\n  guint16 VAR_24;\n\n  if (VAR_8) {\n    if (VAR_1 < VAR_25) {\n      proto_item_append_text(VAR_5, \", bogus chunk length %u < %u)\", VAR_1, VAR_25);\n      return TRUE;\n    }\n    VAR_10  = tvb_get_ntohl(VAR_0, VAR_26);\n  } else {\n    if (VAR_1 < VAR_27) {\n      proto_item_append_text(VAR_5, \", bogus chunk length %u < %u)\", VAR_1, VAR_27);\n      return TRUE;\n    }\n    VAR_10  = tvb_get_ntohl(VAR_0, VAR_28);\n  }\n\n  /* COMMENT_0 */\n  for(VAR_9 = 0; VAR_9 < VAR_29; VAR_9++) {\n    void *VAR_30 = p_get_proto_data(VAR_2->pool, VAR_2, VAR_31, VAR_9);\n    VAR_18 = GPOINTER_TO_UINT(VAR_30);\n    if ((VAR_18 == VAR_32) || (VAR_18 == VAR_10))\n      break;\n  }\n  if ((VAR_9 < VAR_29) && (VAR_18 == VAR_32))\n    p_add_proto_data(VAR_2->pool, VAR_2, VAR_31, VAR_9, GUINT_TO_POINTER(VAR_10));\n\n  VAR_13 = tvb_get_guint8(VAR_0, VAR_33) & VAR_34;\n  VAR_14 = tvb_get_guint8(VAR_0, VAR_33) & VAR_35;\n  VAR_15 = tvb_get_guint8(VAR_0, VAR_33) & VAR_36;\n  VAR_17 = tvb_get_ntohl(VAR_0, VAR_37);\n\n  if (VAR_4) {\n    if (VAR_8)\n      proto_item_set_len(VAR_5, VAR_25);\n    else\n      proto_item_set_len(VAR_5, VAR_27);\n    VAR_12  = proto_item_add_subtree(VAR_6, VAR_38);\n    proto_tree_add_item(VAR_12, VAR_39,             VAR_0, VAR_33,                    VAR_40,                    VAR_41);\n    proto_tree_add_item(VAR_12, VAR_42,             VAR_0, VAR_33,                    VAR_40,                    VAR_41);\n    proto_tree_add_item(VAR_12, VAR_43,             VAR_0, VAR_33,                    VAR_40,                    VAR_41);\n    proto_tree_add_item(VAR_12, VAR_44,             VAR_0, VAR_33,                    VAR_40,                    VAR_41);\n    VAR_20 = proto_tree_add_item(VAR_4, VAR_45,    VAR_0, VAR_37,                 VAR_46,                 VAR_41);\n    proto_tree_add_item(VAR_4, VAR_47,         VAR_0, VAR_48,           VAR_49,           VAR_41);\n    if (VAR_8) {\n      proto_tree_add_item(VAR_4, VAR_50, VAR_0, VAR_51, VAR_52, VAR_41);\n      proto_tree_add_item(VAR_4, VAR_53, VAR_0, VAR_54, VAR_55, VAR_41);\n      if (VAR_14)\n        proto_tree_add_item(VAR_4, VAR_56,  VAR_0, VAR_26, VAR_57, VAR_41);\n      else\n        proto_tree_add_item(VAR_4, VAR_58, VAR_0, VAR_59, VAR_60, VAR_41);\n    } else {\n      proto_tree_add_item(VAR_4, VAR_61, VAR_0, VAR_62,   VAR_63,   VAR_41);\n      proto_tree_add_item(VAR_4, VAR_56,  VAR_0, VAR_28, VAR_64, VAR_41);\n    }\n    proto_item_append_text(VAR_5, \"(%s, \", (VAR_15) ? \"unordered\" : \"ordered\");\n    if (VAR_14) {\n      if (VAR_13)\n        proto_item_append_text(VAR_5, \"complete\");\n      else\n        proto_item_append_text(VAR_5, \"first\");\n    } else {\n      if (VAR_13)\n        proto_item_append_text(VAR_5, \"last\");\n      else\n        proto_item_append_text(VAR_5, \"middle\");\n    }\n\n    if (VAR_8) {\n      if (VAR_14)\n        proto_item_append_text(VAR_5, \" segment, TSN: %u, SID: %u, MID: %u, payload length: %u byte%s)\",\n                               tvb_get_ntohl(VAR_0, VAR_37),\n                               tvb_get_ntohs(VAR_0, VAR_48),\n                               tvb_get_ntohl(VAR_0, VAR_54),\n                               VAR_1 - VAR_25, plurality(VAR_1 - VAR_25, \"\", \"s\"));\n      else\n        proto_item_append_text(VAR_5, \" segment, TSN: %u, SID: %u, MID: %u, FSN: %u, payload length: %u byte%s)\",\n                               tvb_get_ntohl(VAR_0, VAR_37),\n                               tvb_get_ntohs(VAR_0, VAR_48),\n                               tvb_get_ntohl(VAR_0, VAR_54),\n                               tvb_get_ntohl(VAR_0, VAR_59),\n                               VAR_1 - VAR_25, plurality(VAR_1 - VAR_25, \"\", \"s\"));\n    } else\n      proto_item_append_text(VAR_5, \" segment, TSN: %u, SID: %u, SSN: %u, PPID: %u, payload length: %u byte%s)\",\n                             tvb_get_ntohl(VAR_0, VAR_37),\n                             tvb_get_ntohs(VAR_0, VAR_48),\n                             tvb_get_ntohs(VAR_0, VAR_62),\n                             VAR_10,\n                             VAR_1 - VAR_27, plurality(VAR_1 - VAR_27, \"\", \"s\"));\n  }\n\n  VAR_22 = sctp_tsn(VAR_2, VAR_0, VAR_20, VAR_7, VAR_17);\n\n  if (VAR_8) {\n    VAR_23 = VAR_25;\n    VAR_24 = VAR_65;\n  } else {\n    VAR_23 = VAR_27;\n    VAR_24 = VAR_66;\n  }\n  VAR_11 = tvb_new_subset(VAR_0, VAR_24,\n                                 MIN(VAR_1 - VAR_23, tvb_captured_length_remaining(VAR_0, VAR_24)),\n                                 MIN(VAR_1 - VAR_23, tvb_reported_length_remaining(VAR_0, VAR_24)));\n\n  /* COMMENT_1 */\n  if (VAR_14 && VAR_13) {\n    /* COMMENT_2 */\n    if (!VAR_22)\n      VAR_21 = TRUE;\n  } else {\n    /* COMMENT_3 */\n    VAR_2->fragmented = TRUE;\n\n    /* COMMENT_4 */\n    if (!VAR_67)\n    {\n      /* COMMENT_5 */\n                                                   \n         \n      if (VAR_14) {\n        if (!VAR_22)\n          VAR_21 = TRUE;\n      } else\n        return FALSE;\n    }\n\n  }\n\n  if (VAR_21) {\n    /* COMMENT_8 */\n\n    volatile gboolean VAR_68 = FALSE;\n\n    TRY {\n      wmem_list_frame_t *VAR_69;\n      guint VAR_70;\n      const gchar *VAR_71;\n      void *VAR_30;\n\n      VAR_69 = wmem_list_tail(VAR_2->layers);\n      VAR_68 = dissect_payload(VAR_11, VAR_2, VAR_3, VAR_10);\n      VAR_69 = wmem_list_frame_next(VAR_69);\n      if (VAR_69) {\n        VAR_30 = wmem_list_frame_data(VAR_69);\n        VAR_70 = GPOINTER_TO_UINT(VAR_30);\n        VAR_71 = proto_get_protocol_filter_name(VAR_70);\n        if (strcmp(VAR_71, \"data\") != 0){\n          if (have_tap_listener(VAR_72)){\n            export_sctp_data_chunk(VAR_2,VAR_11, VAR_71);\n          }\n        }\n      }\n    }\n    CATCH_NONFATAL_ERRORS {\n      /* COMMENT_9 */\n                                                                        \n                                                                       \n                                                                      \n                                  \n        \n                                                                     \n         \n      show_exception(VAR_11, VAR_2, VAR_3, VAR_73, VAR_74);\n    }\n    VAR_75;\n\n    return VAR_68;\n\n  } else if (VAR_22) {\n    col_append_str(VAR_2->cinfo, VAR_76, \"(retransmission) \");\n    return FALSE;\n  } else {\n\n    /* COMMENT_17 */\n    DISSECTOR_ASSERT(VAR_67);\n\n    VAR_16 = tvb_get_ntohs(VAR_0, VAR_48);\n    if (VAR_8) {\n      /* COMMENT_18 */\n      VAR_19 = tvb_get_ntohl(VAR_0, VAR_54);\n      if (VAR_14) {\n        VAR_17 = 0;\n      } else {\n        VAR_17 = tvb_get_ntohl(VAR_0, VAR_59);\n        VAR_10 = 0;\n      }\n    } else {\n      /* COMMENT_19 */\n      if (VAR_15)\n        VAR_19 = 0;\n      else\n        VAR_19 = tvb_get_ntohs(VAR_0, VAR_62);\n    }\n    /* COMMENT_20 */\n    return dissect_fragmented_payload(VAR_11, VAR_2, VAR_3, VAR_4, VAR_17, VAR_10, VAR_16, VAR_19, VAR_14, VAR_13, VAR_15, VAR_8);\n  }\n\n}",
    "func_graph_path": "wireshark/2259bf8a827088081bef101f98e4983de8aa8099/packet-sctp.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -161,12 +161,14 @@\n       cur = wmem_list_tail(pinfo->layers);\n       retval = dissect_payload(payload_tvb, pinfo, tree, payload_proto_id);\n       cur = wmem_list_frame_next(cur);\n-      tmp = wmem_list_frame_data(cur);\n-      proto_id = GPOINTER_TO_UINT(tmp);\n-      proto_name = proto_get_protocol_filter_name(proto_id);\n-      if (strcmp(proto_name, \"data\") != 0){\n-        if (have_tap_listener(exported_pdu_tap)){\n-          export_sctp_data_chunk(pinfo,payload_tvb, proto_name);\n+      if (cur) {\n+        tmp = wmem_list_frame_data(cur);\n+        proto_id = GPOINTER_TO_UINT(tmp);\n+        proto_name = proto_get_protocol_filter_name(proto_id);\n+        if (strcmp(proto_name, \"data\") != 0){\n+          if (have_tap_listener(exported_pdu_tap)){\n+            export_sctp_data_chunk(pinfo,payload_tvb, proto_name);\n+          }\n         }\n       }\n     }",
    "diff_line_info": {
        "deleted_lines": [
            "      tmp = wmem_list_frame_data(cur);",
            "      proto_id = GPOINTER_TO_UINT(tmp);",
            "      proto_name = proto_get_protocol_filter_name(proto_id);",
            "      if (strcmp(proto_name, \"data\") != 0){",
            "        if (have_tap_listener(exported_pdu_tap)){",
            "          export_sctp_data_chunk(pinfo,payload_tvb, proto_name);"
        ],
        "added_lines": [
            "      if (cur) {",
            "        tmp = wmem_list_frame_data(cur);",
            "        proto_id = GPOINTER_TO_UINT(tmp);",
            "        proto_name = proto_get_protocol_filter_name(proto_id);",
            "        if (strcmp(proto_name, \"data\") != 0){",
            "          if (have_tap_listener(exported_pdu_tap)){",
            "            export_sctp_data_chunk(pinfo,payload_tvb, proto_name);",
            "          }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}