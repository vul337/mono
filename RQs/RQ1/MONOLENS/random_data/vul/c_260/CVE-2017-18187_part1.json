{
    "cve_id": "CVE-2017-18187",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "Mbed-TLS/mbedtls",
    "commit_msg": "Prevent bounds check bypass through overflow in PSK identity parsing\n\nThe check `if( *p + n > end )` in `ssl_parse_client_psk_identity` is\nunsafe because `*p + n` might overflow, thus bypassing the check. As\n`n` is a user-specified value up to 65K, this is relevant if the\nlibrary happens to be located in the last 65K of virtual memory.\n\nThis commit replaces the check by a safe version.",
    "commit_hash": "83c9f495ffe70c7dd280b41fdfd4881485a3bc28",
    "git_url": "https://github.com/Mbed-TLS/mbedtls/commit/83c9f495ffe70c7dd280b41fdfd4881485a3bc28",
    "file_path": "library/ssl_srv.c",
    "func_name": "ssl_parse_client_psk_identity",
    "func_before": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}",
    "abstract_func_before": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *VAR_0, unsigned char **VAR_1,\n                                          const unsigned char *VAR_2 )\n{\n    int VAR_3 = 0;\n    size_t VAR_4;\n\n    if( VAR_0->conf->f_psk == NULL &&\n        ( VAR_0->conf->psk == NULL || VAR_0->conf->psk_identity == NULL ||\n          VAR_0->conf->psk_identity_len == 0 || VAR_0->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( VAR_5 );\n    }\n\n    /* COMMENT_0 */\n                                                  \n       \n    if( *VAR_1 + 2 > VAR_2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( VAR_6 );\n    }\n\n    VAR_4 = ( (*VAR_1)[0] << 8 ) | (*VAR_1)[1];\n    *VAR_1 += 2;\n\n    if( VAR_4 < 1 || VAR_4 > 65535 || *VAR_1 + VAR_4 > VAR_2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( VAR_6 );\n    }\n\n    if( VAR_0->conf->f_psk != NULL )\n    {\n        if( VAR_0->conf->f_psk( VAR_0->conf->p_psk, VAR_0, *VAR_1, VAR_4 ) != 0 )\n            VAR_3 = VAR_7;\n    }\n    else\n    {\n        /* COMMENT_3 */\n                                                         \n        if( VAR_4 != VAR_0->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( VAR_0->conf->psk_identity, *VAR_1, VAR_4 ) != 0 )\n        {\n            VAR_3 = VAR_7;\n        }\n    }\n\n    if( VAR_3 == VAR_7 )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *VAR_1, VAR_4 );\n        mbedtls_ssl_send_alert_message( VAR_0, VAR_8,\n                                        VAR_9 );\n        return( VAR_7 );\n    }\n\n    *VAR_1 += VAR_4;\n\n    return( 0 );\n}",
    "func_graph_path_before": "Mbed-TLS/mbedtls/83c9f495ffe70c7dd280b41fdfd4881485a3bc28/ssl_srv.c/vul/before/0.json",
    "func": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( end - *p < 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}",
    "abstract_func": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *VAR_0, unsigned char **VAR_1,\n                                          const unsigned char *VAR_2 )\n{\n    int VAR_3 = 0;\n    size_t VAR_4;\n\n    if( VAR_0->conf->f_psk == NULL &&\n        ( VAR_0->conf->psk == NULL || VAR_0->conf->psk_identity == NULL ||\n          VAR_0->conf->psk_identity_len == 0 || VAR_0->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( VAR_5 );\n    }\n\n    /* COMMENT_0 */\n                                                  \n       \n    if( VAR_2 - *VAR_1 < 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( VAR_6 );\n    }\n\n    VAR_4 = ( (*VAR_1)[0] << 8 ) | (*VAR_1)[1];\n    *VAR_1 += 2;\n\n    if( VAR_4 < 1 || VAR_4 > 65535 || VAR_4 > (size_t) ( VAR_2 - *VAR_1 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( VAR_6 );\n    }\n\n    if( VAR_0->conf->f_psk != NULL )\n    {\n        if( VAR_0->conf->f_psk( VAR_0->conf->p_psk, VAR_0, *VAR_1, VAR_4 ) != 0 )\n            VAR_3 = VAR_7;\n    }\n    else\n    {\n        /* COMMENT_3 */\n                                                         \n        if( VAR_4 != VAR_0->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( VAR_0->conf->psk_identity, *VAR_1, VAR_4 ) != 0 )\n        {\n            VAR_3 = VAR_7;\n        }\n    }\n\n    if( VAR_3 == VAR_7 )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *VAR_1, VAR_4 );\n        mbedtls_ssl_send_alert_message( VAR_0, VAR_8,\n                                        VAR_9 );\n        return( VAR_7 );\n    }\n\n    *VAR_1 += VAR_4;\n\n    return( 0 );\n}",
    "func_graph_path": "Mbed-TLS/mbedtls/83c9f495ffe70c7dd280b41fdfd4881485a3bc28/ssl_srv.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     /*\n      * Receive client pre-shared key identity name\n      */\n-    if( *p + 2 > end )\n+    if( end - *p < 2 )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n@@ -24,7 +24,7 @@\n     n = ( (*p)[0] << 8 ) | (*p)[1];\n     *p += 2;\n \n-    if( n < 1 || n > 65535 || *p + n > end )\n+    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );",
    "diff_line_info": {
        "deleted_lines": [
            "    if( *p + 2 > end )",
            "    if( n < 1 || n > 65535 || *p + n > end )"
        ],
        "added_lines": [
            "    if( end - *p < 2 )",
            "    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}