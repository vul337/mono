{
    "cve_id": "CVE-2021-3782",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
    "cvss_is_v3": true,
    "repo_name": "wayland",
    "commit_msg": "Since server IDs are basically indistinguishable from really big client\nIDs at many points in the source, it's theoretically possible to overflow\na map and either overflow server IDs into the client ID space, or grow\nclient IDs into the server ID space. This would currently take a massive\namount of RAM, but the definition of massive changes yearly.\n\nPrevent this by placing a ridiculous but arbitrary upper bound on the\nnumber of items we can put in a map: 0xF00000, somewhere over 15 million.\nThis should satisfy pathological clients without restriction, but stays\nwell clear of the 0xFF000000 transition point between server and client\nIDs. It will still take an improbable amount of RAM to hit this, and a\nclient could still exhaust all RAM in this way, but our goal is to prevent\noverflow and undefined behaviour.\n\nFixes #224\n\nSigned-off-by: Derek Foreman <derek.foreman@collabora.com>\n",
    "commit_hash": "b19488c7154b902354cb26a27f11415d7799b0b2",
    "git_url": "https://cgit.freedesktop.org/wayland/wayland/commit/?id=b19488c7154b902354cb26a27f11415d7799b0b2",
    "file_path": "src/wayland-util.c",
    "func_name": "wl_map_insert_new",
    "func_before": "uint32_t\nwl_map_insert_new(struct wl_map *map, uint32_t flags, void *data)\n{\n\tunion map_entry *start, *entry;\n\tstruct wl_array *entries;\n\tuint32_t base;\n\n\tif (map->side == WL_MAP_CLIENT_SIDE) {\n\t\tentries = &map->client_entries;\n\t\tbase = 0;\n\t} else {\n\t\tentries = &map->server_entries;\n\t\tbase = WL_SERVER_ID_START;\n\t}\n\n\tif (map->free_list) {\n\t\tstart = entries->data;\n\t\tentry = &start[map->free_list >> 1];\n\t\tmap->free_list = entry->next;\n\t} else {\n\t\tentry = wl_array_add(entries, sizeof *entry);\n\t\tif (!entry)\n\t\t\treturn 0;\n\t\tstart = entries->data;\n\t}\n\n\tentry->data = data;\n\tentry->next |= (flags & 0x1) << 1;\n\n\treturn (entry - start) + base;\n}",
    "abstract_func_before": "uint32_t\nwl_map_insert_new(struct wl_map *VAR_0, uint32_t VAR_1, void *VAR_2)\n{\n\tunion map_entry *VAR_3, *VAR_4;\n\tstruct wl_array *VAR_5;\n\tuint32_t VAR_6;\n\n\tif (VAR_0->side == VAR_7) {\n\t\tVAR_5 = &VAR_0->client_entries;\n\t\tVAR_6 = 0;\n\t} else {\n\t\tVAR_5 = &VAR_0->server_entries;\n\t\tVAR_6 = VAR_8;\n\t}\n\n\tif (VAR_0->free_list) {\n\t\tVAR_3 = VAR_5->data;\n\t\tVAR_4 = &VAR_3[VAR_0->free_list >> 1];\n\t\tVAR_0->free_list = VAR_4->next;\n\t} else {\n\t\tVAR_4 = wl_array_add(VAR_5, sizeof *VAR_4);\n\t\tif (!VAR_4)\n\t\t\treturn 0;\n\t\tVAR_3 = VAR_5->data;\n\t}\n\n\tVAR_4->data = VAR_2;\n\tVAR_4->next |= (VAR_1 & 0x1) << 1;\n\n\treturn (VAR_4 - VAR_3) + VAR_6;\n}",
    "func_graph_path_before": "wayland/b19488c7154b902354cb26a27f11415d7799b0b2/wayland-util.c/vul/before/2.json",
    "func": "uint32_t\nwl_map_insert_new(struct wl_map *map, uint32_t flags, void *data)\n{\n\tunion map_entry *start, *entry;\n\tstruct wl_array *entries;\n\tuint32_t base;\n\tuint32_t count;\n\n\tif (map->side == WL_MAP_CLIENT_SIDE) {\n\t\tentries = &map->client_entries;\n\t\tbase = 0;\n\t} else {\n\t\tentries = &map->server_entries;\n\t\tbase = WL_SERVER_ID_START;\n\t}\n\n\tif (map->free_list) {\n\t\tstart = entries->data;\n\t\tentry = &start[map->free_list >> 1];\n\t\tmap->free_list = entry->next;\n\t} else {\n\t\tentry = wl_array_add(entries, sizeof *entry);\n\t\tif (!entry)\n\t\t\treturn 0;\n\t\tstart = entries->data;\n\t}\n\n\t/* wl_array only grows, so if we have too many objects at\n\t * this point there's no way to clean up. We could be more\n\t * pro-active about trying to avoid this allocation, but\n\t * it doesn't really matter because at this point there is\n\t * nothing to be done but disconnect the client and delete\n\t * the whole array either way.\n\t */\n\tcount = entry - start;\n\tif (count > WL_MAP_MAX_OBJECTS) {\n\t\t/* entry->data is freshly malloced garbage, so we'd\n\t\t * better make it a NULL so wl_map_for_each doesn't\n\t\t * dereference it later. */\n\t\tentry->data = NULL;\n\t\treturn 0;\n\t}\n\tentry->data = data;\n\tentry->next |= (flags & 0x1) << 1;\n\n\treturn count + base;\n}",
    "abstract_func": "uint32_t\nwl_map_insert_new(struct wl_map *VAR_0, uint32_t VAR_1, void *VAR_2)\n{\n\tunion map_entry *VAR_3, *VAR_4;\n\tstruct wl_array *VAR_5;\n\tuint32_t VAR_6;\n\tuint32_t VAR_7;\n\n\tif (VAR_0->side == VAR_8) {\n\t\tVAR_5 = &VAR_0->client_entries;\n\t\tVAR_6 = 0;\n\t} else {\n\t\tVAR_5 = &VAR_0->server_entries;\n\t\tVAR_6 = VAR_9;\n\t}\n\n\tif (VAR_0->free_list) {\n\t\tVAR_3 = VAR_5->data;\n\t\tVAR_4 = &VAR_3[VAR_0->free_list >> 1];\n\t\tVAR_0->free_list = VAR_4->next;\n\t} else {\n\t\tVAR_4 = wl_array_add(VAR_5, sizeof *VAR_4);\n\t\tif (!VAR_4)\n\t\t\treturn 0;\n\t\tVAR_3 = VAR_5->data;\n\t}\n\n\t/* COMMENT_0 */\n                                                           \n                                                         \n                                                           \n                                                           \n                               \n    \n\tVAR_7 = VAR_4 - VAR_3;\n\tif (VAR_7 > VAR_10) {\n\t\t/* COMMENT_7 */\n                                                     \n                             \n\t\tVAR_4->data = NULL;\n\t\treturn 0;\n\t}\n\tVAR_4->data = VAR_2;\n\tVAR_4->next |= (VAR_1 & 0x1) << 1;\n\n\treturn VAR_7 + VAR_6;\n}",
    "func_graph_path": "wayland/b19488c7154b902354cb26a27f11415d7799b0b2/wayland-util.c/vul/after/2.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tunion map_entry *start, *entry;\n \tstruct wl_array *entries;\n \tuint32_t base;\n+\tuint32_t count;\n \n \tif (map->side == WL_MAP_CLIENT_SIDE) {\n \t\tentries = &map->client_entries;\n@@ -24,8 +25,23 @@\n \t\tstart = entries->data;\n \t}\n \n+\t/* wl_array only grows, so if we have too many objects at\n+\t * this point there's no way to clean up. We could be more\n+\t * pro-active about trying to avoid this allocation, but\n+\t * it doesn't really matter because at this point there is\n+\t * nothing to be done but disconnect the client and delete\n+\t * the whole array either way.\n+\t */\n+\tcount = entry - start;\n+\tif (count > WL_MAP_MAX_OBJECTS) {\n+\t\t/* entry->data is freshly malloced garbage, so we'd\n+\t\t * better make it a NULL so wl_map_for_each doesn't\n+\t\t * dereference it later. */\n+\t\tentry->data = NULL;\n+\t\treturn 0;\n+\t}\n \tentry->data = data;\n \tentry->next |= (flags & 0x1) << 1;\n \n-\treturn (entry - start) + base;\n+\treturn count + base;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\treturn (entry - start) + base;"
        ],
        "added_lines": [
            "\tuint32_t count;",
            "\t/* wl_array only grows, so if we have too many objects at",
            "\t * this point there's no way to clean up. We could be more",
            "\t * pro-active about trying to avoid this allocation, but",
            "\t * it doesn't really matter because at this point there is",
            "\t * nothing to be done but disconnect the client and delete",
            "\t * the whole array either way.",
            "\t */",
            "\tcount = entry - start;",
            "\tif (count > WL_MAP_MAX_OBJECTS) {",
            "\t\t/* entry->data is freshly malloced garbage, so we'd",
            "\t\t * better make it a NULL so wl_map_for_each doesn't",
            "\t\t * dereference it later. */",
            "\t\tentry->data = NULL;",
            "\t\treturn 0;",
            "\t}",
            "\treturn count + base;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}