{
    "cve_id": "CVE-2023-46813",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "Check the IO permission bitmap (if present) before emulating IOIO #VC\nexceptions for user-space. These permissions are checked by hardware\nalready before the #VC is raised, but due to the VC-handler decoding\nrace it needs to be checked again in software.\n\nFixes: 25189d08e516 (\"x86/sev-es: Add support for handling IOIO exceptions\")\nReported-by: Tom Dohrmann <erbse.13@gmx.de>\nSigned-off-by: Joerg Roedel <jroedel@suse.de>\nSigned-off-by: Borislav Petkov (AMD) <bp@alien8.de>\nTested-by: Tom Dohrmann <erbse.13@gmx.de>\nCc: <stable@kernel.org>\n",
    "commit_hash": "b9cb9c45583b911e0db71d09caa6b56469eb2bdf",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=b9cb9c45583b911e0db71d09caa6b56469eb2bdf",
    "file_path": "arch/x86/kernel/sev-shared.c",
    "func_name": "vc_ioio_exitinfo",
    "func_before": "static enum es_result vc_ioio_exitinfo(struct es_em_ctxt *ctxt, u64 *exitinfo)\n{\n\tstruct insn *insn = &ctxt->insn;\n\t*exitinfo = 0;\n\n\tswitch (insn->opcode.bytes[0]) {\n\t/* INS opcodes */\n\tcase 0x6c:\n\tcase 0x6d:\n\t\t*exitinfo |= IOIO_TYPE_INS;\n\t\t*exitinfo |= IOIO_SEG_ES;\n\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;\n\t\tbreak;\n\n\t/* OUTS opcodes */\n\tcase 0x6e:\n\tcase 0x6f:\n\t\t*exitinfo |= IOIO_TYPE_OUTS;\n\t\t*exitinfo |= IOIO_SEG_DS;\n\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;\n\t\tbreak;\n\n\t/* IN immediate opcodes */\n\tcase 0xe4:\n\tcase 0xe5:\n\t\t*exitinfo |= IOIO_TYPE_IN;\n\t\t*exitinfo |= (u8)insn->immediate.value << 16;\n\t\tbreak;\n\n\t/* OUT immediate opcodes */\n\tcase 0xe6:\n\tcase 0xe7:\n\t\t*exitinfo |= IOIO_TYPE_OUT;\n\t\t*exitinfo |= (u8)insn->immediate.value << 16;\n\t\tbreak;\n\n\t/* IN register opcodes */\n\tcase 0xec:\n\tcase 0xed:\n\t\t*exitinfo |= IOIO_TYPE_IN;\n\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;\n\t\tbreak;\n\n\t/* OUT register opcodes */\n\tcase 0xee:\n\tcase 0xef:\n\t\t*exitinfo |= IOIO_TYPE_OUT;\n\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;\n\t\tbreak;\n\n\tdefault:\n\t\treturn ES_DECODE_FAILED;\n\t}\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0x6c:\n\tcase 0x6e:\n\tcase 0xe4:\n\tcase 0xe6:\n\tcase 0xec:\n\tcase 0xee:\n\t\t/* Single byte opcodes */\n\t\t*exitinfo |= IOIO_DATA_8;\n\t\tbreak;\n\tdefault:\n\t\t/* Length determined by instruction parsing */\n\t\t*exitinfo |= (insn->opnd_bytes == 2) ? IOIO_DATA_16\n\t\t\t\t\t\t     : IOIO_DATA_32;\n\t}\n\tswitch (insn->addr_bytes) {\n\tcase 2:\n\t\t*exitinfo |= IOIO_ADDR_16;\n\t\tbreak;\n\tcase 4:\n\t\t*exitinfo |= IOIO_ADDR_32;\n\t\tbreak;\n\tcase 8:\n\t\t*exitinfo |= IOIO_ADDR_64;\n\t\tbreak;\n\t}\n\n\tif (insn_has_rep_prefix(insn))\n\t\t*exitinfo |= IOIO_REP;\n\n\treturn ES_OK;\n}",
    "abstract_func_before": "static enum es_result vc_ioio_exitinfo(struct es_em_ctxt *VAR_0, u64 *VAR_1)\n{\n\tstruct insn *insn = &VAR_0->insn;\n\t*VAR_1 = 0;\n\n\tswitch (insn->opcode.bytes[0]) {\n\t/* COMMENT_0 */\n\tcase 0x6c:\n\tcase 0x6d:\n\t\t*VAR_1 |= VAR_2;\n\t\t*VAR_1 |= VAR_3;\n\t\t*VAR_1 |= (VAR_0->regs->dx & 0xffff) << 16;\n\t\tbreak;\n\n\t/* COMMENT_1 */\n\tcase 0x6e:\n\tcase 0x6f:\n\t\t*VAR_1 |= VAR_4;\n\t\t*VAR_1 |= VAR_5;\n\t\t*VAR_1 |= (VAR_0->regs->dx & 0xffff) << 16;\n\t\tbreak;\n\n\t/* COMMENT_2 */\n\tcase 0xe4:\n\tcase 0xe5:\n\t\t*VAR_1 |= VAR_6;\n\t\t*VAR_1 |= (u8)insn->immediate.value << 16;\n\t\tbreak;\n\n\t/* COMMENT_3 */\n\tcase 0xe6:\n\tcase 0xe7:\n\t\t*VAR_1 |= VAR_7;\n\t\t*VAR_1 |= (u8)insn->immediate.value << 16;\n\t\tbreak;\n\n\t/* COMMENT_4 */\n\tcase 0xec:\n\tcase 0xed:\n\t\t*VAR_1 |= VAR_6;\n\t\t*VAR_1 |= (VAR_0->regs->dx & 0xffff) << 16;\n\t\tbreak;\n\n\t/* COMMENT_5 */\n\tcase 0xee:\n\tcase 0xef:\n\t\t*VAR_1 |= VAR_7;\n\t\t*VAR_1 |= (VAR_0->regs->dx & 0xffff) << 16;\n\t\tbreak;\n\n\tdefault:\n\t\treturn VAR_8;\n\t}\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0x6c:\n\tcase 0x6e:\n\tcase 0xe4:\n\tcase 0xe6:\n\tcase 0xec:\n\tcase 0xee:\n\t\t/* COMMENT_6 */\n\t\t*VAR_1 |= VAR_9;\n\t\tbreak;\n\tdefault:\n\t\t/* COMMENT_7 */\n\t\t*VAR_1 |= (insn->opnd_bytes == 2) ? VAR_10\n\t\t\t\t\t\t     : VAR_11;\n\t}\n\tswitch (insn->addr_bytes) {\n\tcase 2:\n\t\t*VAR_1 |= VAR_12;\n\t\tbreak;\n\tcase 4:\n\t\t*VAR_1 |= VAR_13;\n\t\tbreak;\n\tcase 8:\n\t\t*VAR_1 |= VAR_14;\n\t\tbreak;\n\t}\n\n\tif (insn_has_rep_prefix(insn))\n\t\t*VAR_1 |= VAR_15;\n\n\treturn VAR_16;\n}",
    "func_graph_path_before": "torvalds/linux/b9cb9c45583b911e0db71d09caa6b56469eb2bdf/sev-shared.c/vul/before/0.json",
    "func": "static enum es_result vc_ioio_exitinfo(struct es_em_ctxt *ctxt, u64 *exitinfo)\n{\n\tstruct insn *insn = &ctxt->insn;\n\tsize_t size;\n\tu64 port;\n\n\t*exitinfo = 0;\n\n\tswitch (insn->opcode.bytes[0]) {\n\t/* INS opcodes */\n\tcase 0x6c:\n\tcase 0x6d:\n\t\t*exitinfo |= IOIO_TYPE_INS;\n\t\t*exitinfo |= IOIO_SEG_ES;\n\t\tport\t   = ctxt->regs->dx & 0xffff;\n\t\tbreak;\n\n\t/* OUTS opcodes */\n\tcase 0x6e:\n\tcase 0x6f:\n\t\t*exitinfo |= IOIO_TYPE_OUTS;\n\t\t*exitinfo |= IOIO_SEG_DS;\n\t\tport\t   = ctxt->regs->dx & 0xffff;\n\t\tbreak;\n\n\t/* IN immediate opcodes */\n\tcase 0xe4:\n\tcase 0xe5:\n\t\t*exitinfo |= IOIO_TYPE_IN;\n\t\tport\t   = (u8)insn->immediate.value & 0xffff;\n\t\tbreak;\n\n\t/* OUT immediate opcodes */\n\tcase 0xe6:\n\tcase 0xe7:\n\t\t*exitinfo |= IOIO_TYPE_OUT;\n\t\tport\t   = (u8)insn->immediate.value & 0xffff;\n\t\tbreak;\n\n\t/* IN register opcodes */\n\tcase 0xec:\n\tcase 0xed:\n\t\t*exitinfo |= IOIO_TYPE_IN;\n\t\tport\t   = ctxt->regs->dx & 0xffff;\n\t\tbreak;\n\n\t/* OUT register opcodes */\n\tcase 0xee:\n\tcase 0xef:\n\t\t*exitinfo |= IOIO_TYPE_OUT;\n\t\tport\t   = ctxt->regs->dx & 0xffff;\n\t\tbreak;\n\n\tdefault:\n\t\treturn ES_DECODE_FAILED;\n\t}\n\n\t*exitinfo |= port << 16;\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0x6c:\n\tcase 0x6e:\n\tcase 0xe4:\n\tcase 0xe6:\n\tcase 0xec:\n\tcase 0xee:\n\t\t/* Single byte opcodes */\n\t\t*exitinfo |= IOIO_DATA_8;\n\t\tsize       = 1;\n\t\tbreak;\n\tdefault:\n\t\t/* Length determined by instruction parsing */\n\t\t*exitinfo |= (insn->opnd_bytes == 2) ? IOIO_DATA_16\n\t\t\t\t\t\t     : IOIO_DATA_32;\n\t\tsize       = (insn->opnd_bytes == 2) ? 2 : 4;\n\t}\n\n\tswitch (insn->addr_bytes) {\n\tcase 2:\n\t\t*exitinfo |= IOIO_ADDR_16;\n\t\tbreak;\n\tcase 4:\n\t\t*exitinfo |= IOIO_ADDR_32;\n\t\tbreak;\n\tcase 8:\n\t\t*exitinfo |= IOIO_ADDR_64;\n\t\tbreak;\n\t}\n\n\tif (insn_has_rep_prefix(insn))\n\t\t*exitinfo |= IOIO_REP;\n\n\treturn vc_ioio_check(ctxt, (u16)port, size);\n}",
    "abstract_func": "static enum es_result vc_ioio_exitinfo(struct es_em_ctxt *VAR_0, u64 *VAR_1)\n{\n\tstruct insn *insn = &VAR_0->insn;\n\tsize_t VAR_2;\n\tu64 VAR_3;\n\n\t*VAR_1 = 0;\n\n\tswitch (insn->opcode.bytes[0]) {\n\t/* COMMENT_0 */\n\tcase 0x6c:\n\tcase 0x6d:\n\t\t*VAR_1 |= VAR_4;\n\t\t*VAR_1 |= VAR_5;\n\t\tVAR_3\t   = VAR_0->regs->dx & 0xffff;\n\t\tbreak;\n\n\t/* COMMENT_1 */\n\tcase 0x6e:\n\tcase 0x6f:\n\t\t*VAR_1 |= VAR_6;\n\t\t*VAR_1 |= VAR_7;\n\t\tVAR_3\t   = VAR_0->regs->dx & 0xffff;\n\t\tbreak;\n\n\t/* COMMENT_2 */\n\tcase 0xe4:\n\tcase 0xe5:\n\t\t*VAR_1 |= VAR_8;\n\t\tVAR_3\t   = (u8)insn->immediate.value & 0xffff;\n\t\tbreak;\n\n\t/* COMMENT_3 */\n\tcase 0xe6:\n\tcase 0xe7:\n\t\t*VAR_1 |= VAR_9;\n\t\tVAR_3\t   = (u8)insn->immediate.value & 0xffff;\n\t\tbreak;\n\n\t/* COMMENT_4 */\n\tcase 0xec:\n\tcase 0xed:\n\t\t*VAR_1 |= VAR_8;\n\t\tVAR_3\t   = VAR_0->regs->dx & 0xffff;\n\t\tbreak;\n\n\t/* COMMENT_5 */\n\tcase 0xee:\n\tcase 0xef:\n\t\t*VAR_1 |= VAR_9;\n\t\tVAR_3\t   = VAR_0->regs->dx & 0xffff;\n\t\tbreak;\n\n\tdefault:\n\t\treturn VAR_10;\n\t}\n\n\t*VAR_1 |= VAR_3 << 16;\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0x6c:\n\tcase 0x6e:\n\tcase 0xe4:\n\tcase 0xe6:\n\tcase 0xec:\n\tcase 0xee:\n\t\t/* COMMENT_6 */\n\t\t*VAR_1 |= VAR_11;\n\t\tVAR_2       = 1;\n\t\tbreak;\n\tdefault:\n\t\t/* COMMENT_7 */\n\t\t*VAR_1 |= (insn->opnd_bytes == 2) ? VAR_12\n\t\t\t\t\t\t     : VAR_13;\n\t\tVAR_2       = (insn->opnd_bytes == 2) ? 2 : 4;\n\t}\n\n\tswitch (insn->addr_bytes) {\n\tcase 2:\n\t\t*VAR_1 |= VAR_14;\n\t\tbreak;\n\tcase 4:\n\t\t*VAR_1 |= VAR_15;\n\t\tbreak;\n\tcase 8:\n\t\t*VAR_1 |= VAR_16;\n\t\tbreak;\n\t}\n\n\tif (insn_has_rep_prefix(insn))\n\t\t*VAR_1 |= VAR_17;\n\n\treturn vc_ioio_check(VAR_0, (u16)VAR_3, VAR_2);\n}",
    "func_graph_path": "torvalds/linux/b9cb9c45583b911e0db71d09caa6b56469eb2bdf/sev-shared.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n static enum es_result vc_ioio_exitinfo(struct es_em_ctxt *ctxt, u64 *exitinfo)\n {\n \tstruct insn *insn = &ctxt->insn;\n+\tsize_t size;\n+\tu64 port;\n+\n \t*exitinfo = 0;\n \n \tswitch (insn->opcode.bytes[0]) {\n@@ -9,7 +12,7 @@\n \tcase 0x6d:\n \t\t*exitinfo |= IOIO_TYPE_INS;\n \t\t*exitinfo |= IOIO_SEG_ES;\n-\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;\n+\t\tport\t   = ctxt->regs->dx & 0xffff;\n \t\tbreak;\n \n \t/* OUTS opcodes */\n@@ -17,40 +20,42 @@\n \tcase 0x6f:\n \t\t*exitinfo |= IOIO_TYPE_OUTS;\n \t\t*exitinfo |= IOIO_SEG_DS;\n-\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;\n+\t\tport\t   = ctxt->regs->dx & 0xffff;\n \t\tbreak;\n \n \t/* IN immediate opcodes */\n \tcase 0xe4:\n \tcase 0xe5:\n \t\t*exitinfo |= IOIO_TYPE_IN;\n-\t\t*exitinfo |= (u8)insn->immediate.value << 16;\n+\t\tport\t   = (u8)insn->immediate.value & 0xffff;\n \t\tbreak;\n \n \t/* OUT immediate opcodes */\n \tcase 0xe6:\n \tcase 0xe7:\n \t\t*exitinfo |= IOIO_TYPE_OUT;\n-\t\t*exitinfo |= (u8)insn->immediate.value << 16;\n+\t\tport\t   = (u8)insn->immediate.value & 0xffff;\n \t\tbreak;\n \n \t/* IN register opcodes */\n \tcase 0xec:\n \tcase 0xed:\n \t\t*exitinfo |= IOIO_TYPE_IN;\n-\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;\n+\t\tport\t   = ctxt->regs->dx & 0xffff;\n \t\tbreak;\n \n \t/* OUT register opcodes */\n \tcase 0xee:\n \tcase 0xef:\n \t\t*exitinfo |= IOIO_TYPE_OUT;\n-\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;\n+\t\tport\t   = ctxt->regs->dx & 0xffff;\n \t\tbreak;\n \n \tdefault:\n \t\treturn ES_DECODE_FAILED;\n \t}\n+\n+\t*exitinfo |= port << 16;\n \n \tswitch (insn->opcode.bytes[0]) {\n \tcase 0x6c:\n@@ -61,12 +66,15 @@\n \tcase 0xee:\n \t\t/* Single byte opcodes */\n \t\t*exitinfo |= IOIO_DATA_8;\n+\t\tsize       = 1;\n \t\tbreak;\n \tdefault:\n \t\t/* Length determined by instruction parsing */\n \t\t*exitinfo |= (insn->opnd_bytes == 2) ? IOIO_DATA_16\n \t\t\t\t\t\t     : IOIO_DATA_32;\n+\t\tsize       = (insn->opnd_bytes == 2) ? 2 : 4;\n \t}\n+\n \tswitch (insn->addr_bytes) {\n \tcase 2:\n \t\t*exitinfo |= IOIO_ADDR_16;\n@@ -82,5 +90,5 @@\n \tif (insn_has_rep_prefix(insn))\n \t\t*exitinfo |= IOIO_REP;\n \n-\treturn ES_OK;\n+\treturn vc_ioio_check(ctxt, (u16)port, size);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;",
            "\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;",
            "\t\t*exitinfo |= (u8)insn->immediate.value << 16;",
            "\t\t*exitinfo |= (u8)insn->immediate.value << 16;",
            "\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;",
            "\t\t*exitinfo |= (ctxt->regs->dx & 0xffff) << 16;",
            "\treturn ES_OK;"
        ],
        "added_lines": [
            "\tsize_t size;",
            "\tu64 port;",
            "",
            "\t\tport\t   = ctxt->regs->dx & 0xffff;",
            "\t\tport\t   = ctxt->regs->dx & 0xffff;",
            "\t\tport\t   = (u8)insn->immediate.value & 0xffff;",
            "\t\tport\t   = (u8)insn->immediate.value & 0xffff;",
            "\t\tport\t   = ctxt->regs->dx & 0xffff;",
            "\t\tport\t   = ctxt->regs->dx & 0xffff;",
            "",
            "\t*exitinfo |= port << 16;",
            "\t\tsize       = 1;",
            "\t\tsize       = (insn->opnd_bytes == 2) ? 2 : 4;",
            "",
            "\treturn vc_ioio_check(ctxt, (u16)port, size);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}