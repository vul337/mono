{
    "cve_id": "CVE-2018-1065",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "netfilter: add back stackpointer size checks\n\nThe rationale for removing the check is only correct for rulesets\ngenerated by ip(6)tables.\n\nIn iptables, a jump can only occur to a user-defined chain, i.e.\nbecause we size the stack based on number of user-defined chains we\ncannot exceed stack size.\n\nHowever, the underlying binary format has no such restriction,\nand the validation step only ensures that the jump target is a\nvalid rule start point.\n\nIOW, its possible to build a rule blob that has no user-defined\nchains but does contain a jump.\n\nIf this happens, no jump stack gets allocated and crash occurs\nbecause no jumpstack was allocated.\n\nFixes: 7814b6ec6d0d6 (\"netfilter: xtables: don't save/restore jumpstack offset\")\nReported-by: syzbot+e783f671527912cd9403@syzkaller.appspotmail.com\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "commit_hash": "57ebd808a97d7c5b1e1afb937c2db22beba3c1f8",
    "git_url": "https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8",
    "file_path": "net/ipv6/netfilter/ip6_tables.c",
    "func_name": "ip6t_do_table",
    "func_before": "unsigned int\nip6t_do_table(struct sk_buff *skb,\n\t      const struct nf_hook_state *state,\n\t      struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ip6t_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tacpar.thoff = 0;\n\t\tif (!ip6_packet_match(skb, indev, outdev, &e->ipv6,\n\t\t    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {\n no_match:\n\t\t\te = ip6t_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ip6t_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0)\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\telse\n\t\t\t\t\te = ip6t_next_entry(jumpstack[--stackidx]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ip6t_next_entry(e) &&\n\t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE)\n\t\t\te = ip6t_next_entry(e);\n\t\telse\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
    "abstract_func_before": "unsigned int\nip6t_do_table(struct sk_buff *VAR_0,\n\t      const struct nf_hook_state *VAR_1,\n\t      struct xt_table *VAR_2)\n{\n\tunsigned int VAR_3 = VAR_1->hook;\n\tstatic const char VAR_4[VAR_5] __attribute__((aligned(sizeof(long))));\n\t/* COMMENT_0 */\n\tunsigned int VAR_6 = VAR_7;\n\tconst char *VAR_8, *VAR_9;\n\tconst void *VAR_10;\n\tstruct ip6t_entry *VAR_11, **VAR_12;\n\tunsigned int VAR_13, VAR_14;\n\tconst struct xt_table_info *VAR_15;\n\tstruct xt_action_param VAR_16;\n\tunsigned int VAR_17;\n\n\t/* COMMENT_1 */\n\tVAR_13 = 0;\n\tVAR_8 = VAR_1->in ? VAR_1->in->name : VAR_4;\n\tVAR_9 = VAR_1->out ? VAR_1->out->name : VAR_4;\n\t/* COMMENT_2 */\n                                                               \n                                                              \n                                                             \n                                                              \n                \n\tVAR_16.hotdrop = false;\n\tVAR_16.state   = VAR_1;\n\n\tWARN_ON(!(VAR_2->valid_hooks & (1 << VAR_3)));\n\n\tlocal_bh_disable();\n\tVAR_17 = xt_write_recseq_begin();\n\tVAR_15 = READ_ONCE(VAR_2->private); /* COMMENT_8 */\n\tVAR_14        = smp_processor_id();\n\tVAR_10 = VAR_15->entries;\n\tVAR_12  = (struct ip6t_entry **)VAR_15->jumpstack[VAR_14];\n\n\t/* COMMENT_9 */\n                                                                 \n                          \n   \n                                                                    \n                                                                   \n    \n\tif (static_key_false(&VAR_18))\n\t\tVAR_12 += VAR_15->stacksize * __this_cpu_read(VAR_19);\n\n\tVAR_11 = get_entry(VAR_10, VAR_15->hook_entry[VAR_3]);\n\n\tdo {\n\t\tconst struct xt_entry_target *VAR_20;\n\t\tconst struct xt_entry_match *VAR_21;\n\t\tstruct xt_counters *VAR_22;\n\n\t\tWARN_ON(!VAR_11);\n\t\tVAR_16.thoff = 0;\n\t\tif (!ip6_packet_match(VAR_0, VAR_8, VAR_9, &VAR_11->ipv6,\n\t\t    &VAR_16.thoff, &VAR_16.fragoff, &VAR_16.hotdrop)) {\n no_match:\n\t\t\tVAR_11 = ip6t_next_entry(VAR_11);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(VAR_21, VAR_11) {\n\t\t\tVAR_16.match     = VAR_21->u.kernel.match;\n\t\t\tVAR_16.matchinfo = VAR_21->data;\n\t\t\tif (!VAR_16.match->match(VAR_0, &VAR_16))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tVAR_22 = xt_get_this_cpu_counter(&VAR_11->counters);\n\t\tADD_COUNTER(*VAR_22, VAR_0->len, 1);\n\n\t\tVAR_20 = ip6t_get_target_c(VAR_11);\n\t\tWARN_ON(!VAR_20->u.kernel.target);\n\n#if IS_ENABLED(VAR_23)\n\t\t/* COMMENT_16 */\n\t\tif (unlikely(VAR_0->nf_trace))\n\t\t\ttrace_packet(VAR_1->net, VAR_0, VAR_3, VAR_1->in,\n\t\t\t\t     VAR_1->out, VAR_2->name, VAR_15, VAR_11);\n#endif\n\t\t/* COMMENT_17 */\n\t\tif (!VAR_20->u.kernel.target->target) {\n\t\t\tint VAR_24;\n\n\t\t\tVAR_24 = ((struct xt_standard_target *)VAR_20)->verdict;\n\t\t\tif (VAR_24 < 0) {\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tif (VAR_24 != VAR_25) {\n\t\t\t\t\tVAR_6 = (unsigned int)(-VAR_24) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (VAR_13 == 0)\n\t\t\t\t\tVAR_11 = get_entry(VAR_10,\n\t\t\t\t\t    VAR_15->underflow[VAR_3]);\n\t\t\t\telse\n\t\t\t\t\tVAR_11 = ip6t_next_entry(VAR_12[--VAR_13]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (VAR_10 + VAR_24 != ip6t_next_entry(VAR_11) &&\n\t\t\t    !(VAR_11->ipv6.flags & VAR_26)) {\n\t\t\t\tVAR_12[VAR_13++] = VAR_11;\n\t\t\t}\n\n\t\t\tVAR_11 = get_entry(VAR_10, VAR_24);\n\t\t\tcontinue;\n\t\t}\n\n\t\tVAR_16.target   = VAR_20->u.kernel.target;\n\t\tVAR_16.targinfo = VAR_20->data;\n\n\t\tVAR_6 = VAR_20->u.kernel.target->target(VAR_0, &VAR_16);\n\t\tif (VAR_6 == VAR_27)\n\t\t\tVAR_11 = ip6t_next_entry(VAR_11);\n\t\telse\n\t\t\t/* COMMENT_19 */\n\t\t\tbreak;\n\t} while (!VAR_16.hotdrop);\n\n\txt_write_recseq_end(VAR_17);\n\tlocal_bh_enable();\n\n\tif (VAR_16.hotdrop)\n\t\treturn VAR_7;\n\telse return VAR_6;\n}",
    "func_graph_path_before": "torvalds/linux/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/ip6_tables.c/vul/before/0.json",
    "func": "unsigned int\nip6t_do_table(struct sk_buff *skb,\n\t      const struct nf_hook_state *state,\n\t      struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ip6t_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tacpar.thoff = 0;\n\t\tif (!ip6_packet_match(skb, indev, outdev, &e->ipv6,\n\t\t    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {\n no_match:\n\t\t\te = ip6t_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ip6t_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0)\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\telse\n\t\t\t\t\te = ip6t_next_entry(jumpstack[--stackidx]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ip6t_next_entry(e) &&\n\t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE)\n\t\t\te = ip6t_next_entry(e);\n\t\telse\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
    "abstract_func": "unsigned int\nip6t_do_table(struct sk_buff *VAR_0,\n\t      const struct nf_hook_state *VAR_1,\n\t      struct xt_table *VAR_2)\n{\n\tunsigned int VAR_3 = VAR_1->hook;\n\tstatic const char VAR_4[VAR_5] __attribute__((aligned(sizeof(long))));\n\t/* COMMENT_0 */\n\tunsigned int VAR_6 = VAR_7;\n\tconst char *VAR_8, *VAR_9;\n\tconst void *VAR_10;\n\tstruct ip6t_entry *VAR_11, **VAR_12;\n\tunsigned int VAR_13, VAR_14;\n\tconst struct xt_table_info *VAR_15;\n\tstruct xt_action_param VAR_16;\n\tunsigned int VAR_17;\n\n\t/* COMMENT_1 */\n\tVAR_13 = 0;\n\tVAR_8 = VAR_1->in ? VAR_1->in->name : VAR_4;\n\tVAR_9 = VAR_1->out ? VAR_1->out->name : VAR_4;\n\t/* COMMENT_2 */\n                                                               \n                                                              \n                                                             \n                                                              \n                \n\tVAR_16.hotdrop = false;\n\tVAR_16.state   = VAR_1;\n\n\tWARN_ON(!(VAR_2->valid_hooks & (1 << VAR_3)));\n\n\tlocal_bh_disable();\n\tVAR_17 = xt_write_recseq_begin();\n\tVAR_15 = READ_ONCE(VAR_2->private); /* COMMENT_8 */\n\tVAR_14        = smp_processor_id();\n\tVAR_10 = VAR_15->entries;\n\tVAR_12  = (struct ip6t_entry **)VAR_15->jumpstack[VAR_14];\n\n\t/* COMMENT_9 */\n                                                                 \n                          \n   \n                                                                    \n                                                                   \n    \n\tif (static_key_false(&VAR_18))\n\t\tVAR_12 += VAR_15->stacksize * __this_cpu_read(VAR_19);\n\n\tVAR_11 = get_entry(VAR_10, VAR_15->hook_entry[VAR_3]);\n\n\tdo {\n\t\tconst struct xt_entry_target *VAR_20;\n\t\tconst struct xt_entry_match *VAR_21;\n\t\tstruct xt_counters *VAR_22;\n\n\t\tWARN_ON(!VAR_11);\n\t\tVAR_16.thoff = 0;\n\t\tif (!ip6_packet_match(VAR_0, VAR_8, VAR_9, &VAR_11->ipv6,\n\t\t    &VAR_16.thoff, &VAR_16.fragoff, &VAR_16.hotdrop)) {\n no_match:\n\t\t\tVAR_11 = ip6t_next_entry(VAR_11);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(VAR_21, VAR_11) {\n\t\t\tVAR_16.match     = VAR_21->u.kernel.match;\n\t\t\tVAR_16.matchinfo = VAR_21->data;\n\t\t\tif (!VAR_16.match->match(VAR_0, &VAR_16))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tVAR_22 = xt_get_this_cpu_counter(&VAR_11->counters);\n\t\tADD_COUNTER(*VAR_22, VAR_0->len, 1);\n\n\t\tVAR_20 = ip6t_get_target_c(VAR_11);\n\t\tWARN_ON(!VAR_20->u.kernel.target);\n\n#if IS_ENABLED(VAR_23)\n\t\t/* COMMENT_16 */\n\t\tif (unlikely(VAR_0->nf_trace))\n\t\t\ttrace_packet(VAR_1->net, VAR_0, VAR_3, VAR_1->in,\n\t\t\t\t     VAR_1->out, VAR_2->name, VAR_15, VAR_11);\n#endif\n\t\t/* COMMENT_17 */\n\t\tif (!VAR_20->u.kernel.target->target) {\n\t\t\tint VAR_24;\n\n\t\t\tVAR_24 = ((struct xt_standard_target *)VAR_20)->verdict;\n\t\t\tif (VAR_24 < 0) {\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tif (VAR_24 != VAR_25) {\n\t\t\t\t\tVAR_6 = (unsigned int)(-VAR_24) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (VAR_13 == 0)\n\t\t\t\t\tVAR_11 = get_entry(VAR_10,\n\t\t\t\t\t    VAR_15->underflow[VAR_3]);\n\t\t\t\telse\n\t\t\t\t\tVAR_11 = ip6t_next_entry(VAR_12[--VAR_13]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (VAR_10 + VAR_24 != ip6t_next_entry(VAR_11) &&\n\t\t\t    !(VAR_11->ipv6.flags & VAR_26)) {\n\t\t\t\tif (unlikely(VAR_13 >= VAR_15->stacksize)) {\n\t\t\t\t\tVAR_6 = VAR_7;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_12[VAR_13++] = VAR_11;\n\t\t\t}\n\n\t\t\tVAR_11 = get_entry(VAR_10, VAR_24);\n\t\t\tcontinue;\n\t\t}\n\n\t\tVAR_16.target   = VAR_20->u.kernel.target;\n\t\tVAR_16.targinfo = VAR_20->data;\n\n\t\tVAR_6 = VAR_20->u.kernel.target->target(VAR_0, &VAR_16);\n\t\tif (VAR_6 == VAR_27)\n\t\t\tVAR_11 = ip6t_next_entry(VAR_11);\n\t\telse\n\t\t\t/* COMMENT_19 */\n\t\t\tbreak;\n\t} while (!VAR_16.hotdrop);\n\n\txt_write_recseq_end(VAR_17);\n\tlocal_bh_enable();\n\n\tif (VAR_16.hotdrop)\n\t\treturn VAR_7;\n\telse return VAR_6;\n}",
    "func_graph_path": "torvalds/linux/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8/ip6_tables.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -102,6 +102,10 @@\n \t\t\t}\n \t\t\tif (table_base + v != ip6t_next_entry(e) &&\n \t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n ",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {",
            "\t\t\t\t\tverdict = NF_DROP;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}