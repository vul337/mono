{
    "cve_id": "CVE-2012-2133",
    "cwe_ids": [
        "CWE-399"
    ],
    "cvss_vector": "AV:L/AC:H/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "commit_hash": "90481622d75715bfcb68501280a917dbfe516029",
    "git_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
    "file_path": "mm/hugetlb.c",
    "func_name": "hugetlb_unreserve_pages",
    "func_before": "void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n\tspin_unlock(&inode->i_lock);\n\n\thugetlb_put_quota(inode->i_mapping, (chg - freed));\n\thugetlb_acct_memory(h, -(chg - freed));\n}",
    "abstract_func_before": "void hugetlb_unreserve_pages(struct inode *inode, long VAR_0, long VAR_1)\n{\n\tstruct hstate *VAR_2 = hstate_inode(inode);\n\tlong VAR_3 = region_truncate(&inode->i_mapping->private_list, VAR_0);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(VAR_2) * VAR_1);\n\tspin_unlock(&inode->i_lock);\n\n\thugetlb_put_quota(inode->i_mapping, (VAR_3 - VAR_1));\n\thugetlb_acct_memory(VAR_2, -(VAR_3 - VAR_1));\n}",
    "func_graph_path_before": "torvalds/linux/90481622d75715bfcb68501280a917dbfe516029/hugetlb.c/vul/before/5.json",
    "func": "void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n\tspin_unlock(&inode->i_lock);\n\n\thugepage_subpool_put_pages(spool, (chg - freed));\n\thugetlb_acct_memory(h, -(chg - freed));\n}",
    "abstract_func": "void hugetlb_unreserve_pages(struct inode *inode, long VAR_0, long VAR_1)\n{\n\tstruct hstate *VAR_2 = hstate_inode(inode);\n\tlong VAR_3 = region_truncate(&inode->i_mapping->private_list, VAR_0);\n\tstruct hugepage_subpool *VAR_4 = subpool_inode(inode);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(VAR_2) * VAR_1);\n\tspin_unlock(&inode->i_lock);\n\n\thugepage_subpool_put_pages(VAR_4, (VAR_3 - VAR_1));\n\thugetlb_acct_memory(VAR_2, -(VAR_3 - VAR_1));\n}",
    "func_graph_path": "torvalds/linux/90481622d75715bfcb68501280a917dbfe516029/hugetlb.c/vul/after/5.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,12 @@\n {\n \tstruct hstate *h = hstate_inode(inode);\n \tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n+\tstruct hugepage_subpool *spool = subpool_inode(inode);\n \n \tspin_lock(&inode->i_lock);\n \tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n \tspin_unlock(&inode->i_lock);\n \n-\thugetlb_put_quota(inode->i_mapping, (chg - freed));\n+\thugepage_subpool_put_pages(spool, (chg - freed));\n \thugetlb_acct_memory(h, -(chg - freed));\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\thugetlb_put_quota(inode->i_mapping, (chg - freed));"
        ],
        "added_lines": [
            "\tstruct hugepage_subpool *spool = subpool_inode(inode);",
            "\thugepage_subpool_put_pages(spool, (chg - freed));"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}