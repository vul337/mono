{
    "cve_id": "CVE-2015-1342",
    "cwe_ids": [
        "CWE-264"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "lxc/lxcfs",
    "commit_msg": "Fix checking of parent directories\n\nTaken from the justification in the launchpad bug:\n\nTo a task in freezer cgroup /a/b/c/d, it should appear that there are no\ncgroups other than its descendents. Since this is a filesystem, we must have\nthe parent directories, but each parent cgroup should only contain the child\nwhich the task can see.\n\nSo, when this task looks at /a/b, it should see only directory 'c' and no\nfiles. Attempt to create /a/b/x should result in -EPERM, whether /a/b/x already\nexists or not. Attempts to query /a/b/x should result in -ENOENT whether /a/b/x\nexists or not. Opening /a/b/tasks should result in -ENOENT.\n\nThe caller_may_see_dir checks specifically whether a task may see a cgroup\ndirectory - i.e. /a/b/x if opening /a/b/x/tasks, and /a/b/c/d if doing\nopendir('/a/b/c/d').\n\ncaller_is_in_ancestor() will return true if the caller in /a/b/c/d looks at\n/a/b/c/d/e. If the caller is in a child cgroup of the queried one - i.e. if the\ntask in /a/b/c/d queries /a/b, then *nextcg will container the next (the only)\ndirectory which he can see in the path - 'c'.\n\nBeyond this, regular DAC permissions should apply, with the\nroot-in-user-namespace privilege over its mapped uids being respected. The\nfc_may_access check does this check for both directories and files.\n\nThis is CVE-2015-1342 (LP: #1508481)\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
    "commit_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "git_url": "https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "file_path": "lxcfs.c",
    "func_name": "cg_open",
    "func_before": "static int cg_open(const char *path, struct fuse_file_info *fi)\n{\n\tconst char *cgroup;\n\tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *fc = fuse_get_context();\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\n\tk = cgfs_get_key(controller, path1, path2);\n\tif (!k) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfree_key(k);\n\n\tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n\t\t// should never get here\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\t/* we'll free this at cg_release */\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(controller);\n\tfile_info->cgroup = must_copy_string(path1);\n\tfile_info->file = must_copy_string(path2);\n\tfile_info->type = LXC_TYPE_CGFILE;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\n\tfi->fh = (unsigned long)file_info;\n\tret = 0;\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}",
    "abstract_func_before": "static int cg_open(const char *VAR_0, struct fuse_file_info *VAR_1)\n{\n\tconst char *VAR_2;\n\tchar *VAR_3 = NULL, *VAR_4, *VAR_5, * VAR_6 = NULL, *VAR_7;\n\tstruct cgfs_files *VAR_8 = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *VAR_9 = fuse_get_context();\n\tint VAR_10;\n\n\tif (!VAR_9)\n\t\treturn -VAR_11;\n\n\tVAR_7 = pick_controller_from_path(VAR_9, VAR_0);\n\tif (!VAR_7)\n\t\treturn -VAR_11;\n\tVAR_2 = find_cgroup_in_path(VAR_0);\n\tif (!VAR_2)\n\t\treturn -VAR_12;\n\n\tget_cgdir_and_path(VAR_2, &VAR_6, &VAR_3);\n\tif (!VAR_3) {\n\t\tVAR_4 = \"/\";\n\t\tVAR_5 = VAR_6;\n\t} else {\n\t\tVAR_4 = VAR_6;\n\t\tVAR_5 = VAR_3;\n\t}\n\n\tVAR_8 = cgfs_get_key(VAR_7, VAR_4, VAR_5);\n\tif (!VAR_8) {\n\t\tVAR_10 = -VAR_12;\n\t\tgoto out;\n\t}\n\tfree_key(VAR_8);\n\n\tif (!fc_may_access(VAR_9, VAR_7, VAR_4, VAR_5, VAR_1->flags)) {\n\t\t/* COMMENT_0 */\n\t\tVAR_10 = -VAR_13;\n\t\tgoto out;\n\t}\n\n\t/* COMMENT_1 */\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tVAR_10 = -VAR_14;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(VAR_7);\n\tfile_info->cgroup = must_copy_string(VAR_4);\n\tfile_info->file = must_copy_string(VAR_5);\n\tfile_info->type = VAR_15;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\n\tVAR_1->fh = (unsigned long)file_info;\n\tVAR_10 = 0;\n\nout:\n\tfree(VAR_6);\n\treturn VAR_10;\n}",
    "func_graph_path_before": "lxc/lxcfs/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7/lxcfs.c/vul/before/1.json",
    "func": "static int cg_open(const char *path, struct fuse_file_info *fi)\n{\n\tconst char *cgroup;\n\tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *fc = fuse_get_context();\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\n\tk = cgfs_get_key(controller, path1, path2);\n\tif (!k) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfree_key(k);\n\n\tif (!caller_may_see_dir(fc->pid, controller, path1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n\t\t// should never get here\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\t/* we'll free this at cg_release */\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(controller);\n\tfile_info->cgroup = must_copy_string(path1);\n\tfile_info->file = must_copy_string(path2);\n\tfile_info->type = LXC_TYPE_CGFILE;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\n\tfi->fh = (unsigned long)file_info;\n\tret = 0;\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}",
    "abstract_func": "static int cg_open(const char *VAR_0, struct fuse_file_info *VAR_1)\n{\n\tconst char *VAR_2;\n\tchar *VAR_3 = NULL, *VAR_4, *VAR_5, * VAR_6 = NULL, *VAR_7;\n\tstruct cgfs_files *VAR_8 = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *VAR_9 = fuse_get_context();\n\tint VAR_10;\n\n\tif (!VAR_9)\n\t\treturn -VAR_11;\n\n\tVAR_7 = pick_controller_from_path(VAR_9, VAR_0);\n\tif (!VAR_7)\n\t\treturn -VAR_11;\n\tVAR_2 = find_cgroup_in_path(VAR_0);\n\tif (!VAR_2)\n\t\treturn -VAR_12;\n\n\tget_cgdir_and_path(VAR_2, &VAR_6, &VAR_3);\n\tif (!VAR_3) {\n\t\tVAR_4 = \"/\";\n\t\tVAR_5 = VAR_6;\n\t} else {\n\t\tVAR_4 = VAR_6;\n\t\tVAR_5 = VAR_3;\n\t}\n\n\tVAR_8 = cgfs_get_key(VAR_7, VAR_4, VAR_5);\n\tif (!VAR_8) {\n\t\tVAR_10 = -VAR_12;\n\t\tgoto out;\n\t}\n\tfree_key(VAR_8);\n\n\tif (!caller_may_see_dir(VAR_9->pid, VAR_7, VAR_4)) {\n\t\tVAR_10 = -VAR_13;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(VAR_9, VAR_7, VAR_4, VAR_5, VAR_1->flags)) {\n\t\t/* COMMENT_0 */\n\t\tVAR_10 = -VAR_14;\n\t\tgoto out;\n\t}\n\n\t/* COMMENT_1 */\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tVAR_10 = -VAR_15;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(VAR_7);\n\tfile_info->cgroup = must_copy_string(VAR_4);\n\tfile_info->file = must_copy_string(VAR_5);\n\tfile_info->type = VAR_16;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\n\tVAR_1->fh = (unsigned long)file_info;\n\tVAR_10 = 0;\n\nout:\n\tfree(VAR_6);\n\treturn VAR_10;\n}",
    "func_graph_path": "lxc/lxcfs/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7/lxcfs.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -33,6 +33,10 @@\n \t}\n \tfree_key(k);\n \n+\tif (!caller_may_see_dir(fc->pid, controller, path1)) {\n+\t\tret = -ENOENT;\n+\t\tgoto out;\n+\t}\n \tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n \t\t// should never get here\n \t\tret = -EACCES;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\tif (!caller_may_see_dir(fc->pid, controller, path1)) {",
            "\t\tret = -ENOENT;",
            "\t\tgoto out;",
            "\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}