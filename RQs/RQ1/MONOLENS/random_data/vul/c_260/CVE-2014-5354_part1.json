{
    "cve_id": "CVE-2014-5354",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:N/AC:M/Au:S/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "krb5",
    "commit_msg": "Support keyless principals in LDAP [CVE-2014-5354]\n\nOperations like \"kadmin -q 'addprinc -nokey foo'\" or\n\"kadmin -q 'purgekeys -all foo'\" result in principal entries with\nno keys present, so krb5_encode_krbsecretkey() would just return\nNULL, which then got unconditionally dereferenced in\nkrb5_add_ber_mem_ldap_mod().\n\nApply some fixes to krb5_encode_krbsecretkey() to handle zero-key\nprincipals better, correct the test for an allocation failure, and\nslightly restructure the cleanup handler to be shorter and more\nappropriate for the usage.  Once it no longer short-circuits when\nn_key_data is zero, it will produce an array of length two with both\nentries NULL, which is treated as an empty list by the LDAP library,\nthe correct behavior for a keyless principal.\n\nHowever, attributes with empty values are only handled by the LDAP\nlibrary for Modify operations, not Add operations (which only get\na sequence of Attribute, with no operation field).  Therefore, only\nadd an empty krbprincipalkey to the modlist when we will be performing a\nModify, and not when we will be performing an Add, which is conditional\non the (misspelled) create_standalone_prinicipal boolean.\n\nCVE-2014-5354:\n\nIn MIT krb5, when kadmind is configured to use LDAP for the KDC\ndatabase, an authenticated remote attacker can cause a NULL\ndereference by inserting into the database a principal entry which\ncontains no long-term keys.\n\nIn order for the LDAP KDC backend to translate a principal entry\nfrom the database abstraction layer into the form expected by the\nLDAP schema, the principal's keys are encoded into a\nNULL-terminated array of length-value entries to be stored in the\nLDAP database.  However, the subroutine which produced this array\ndid not correctly handle the case where no keys were present,\nreturning NULL instead of an empty array, and the array was\nunconditionally dereferenced while adding to the list of LDAP\noperations to perform.\n\nVersions of MIT krb5 prior to 1.12 did not expose a way for\nprincipal entries to have no long-term key material, and\ntherefore are not vulnerable.\n\n    CVSSv2 Vector: AV:N/AC:M/Au:S/C:N/I:N/A:P/E:H/RL:OF/RC:C\n\nticket: 8041 (new)\ntags: pullup\ntarget_version: 1.13.1\nsubject: kadmind with ldap backend crashes when putting keyless entries",
    "commit_hash": "04038bf3633c4b909b5ded3072dc88c8c419bf16",
    "git_url": "https://github.com/krb5/krb5/commit/04038bf3633c4b909b5ded3072dc88c8c419bf16",
    "file_path": "src/plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c",
    "func_name": "krb5_encode_krbsecretkey",
    "func_before": "static struct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,\n                         krb5_kvno mkvno) {\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 1;\n    int i, j, last;\n    krb5_error_code err = 0;\n    krb5_key_data *key_data;\n\n    if (n_key_data <= 0)\n        return NULL;\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data_in == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* Find the number of key versions */\n    for (i = 0; i < n_key_data - 1; i++)\n        if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n            num_versions++;\n\n    ret = (struct berval **) calloc (num_versions + 1, sizeof (struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    for (i = 0, last = 0, j = 0, currkvno = key_data[0].key_data_kvno; i < n_key_data; i++) {\n        krb5_data *code;\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            ret[j] = k5alloc(sizeof(struct berval), &err);\n            if (ret[j] == NULL)\n                goto cleanup;\n            err = asn1_encode_sequence_of_keys(key_data + last,\n                                               (krb5_int16)i - last + 1,\n                                               mkvno, &code);\n            if (err)\n                goto cleanup;\n            /*CHECK_NULL(ret[j]); */\n            ret[j]->bv_len = code->length;\n            ret[j]->bv_val = code->data;\n            free(code);\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n    ret[num_versions] = NULL;\n\ncleanup:\n\n    free(key_data);\n    if (err != 0) {\n        if (ret != NULL) {\n            for (i = 0; i <= num_versions; i++)\n                if (ret[i] != NULL)\n                    free (ret[i]);\n            free (ret);\n            ret = NULL;\n        }\n    }\n\n    return ret;\n}",
    "abstract_func_before": "static struct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *VAR_0, int VAR_1,\n                         krb5_kvno VAR_2) {\n    struct berval **VAR_3 = NULL;\n    int VAR_4;\n    int VAR_5 = 1;\n    int VAR_6, VAR_7, VAR_8;\n    krb5_error_code VAR_9 = 0;\n    krb5_key_data *VAR_10;\n\n    if (VAR_1 <= 0)\n        return NULL;\n\n    /* COMMENT_0 */\n    VAR_10 = k5calloc(VAR_1, sizeof(*VAR_10), &VAR_9);\n    if (VAR_0 == NULL)\n        goto cleanup;\n    memcpy(VAR_10, VAR_0, VAR_1 * sizeof(*VAR_10));\n\n    /* COMMENT_1 */\n                                                                \n    for (VAR_6 = 0; VAR_6 < VAR_1; VAR_6++) {\n        if (VAR_10[VAR_6].key_data_ver == 1) {\n            VAR_10[VAR_6].key_data_ver = 2;\n            VAR_10[VAR_6].key_data_type[1] = VAR_11;\n            VAR_10[VAR_6].key_data_length[1] = 0;\n            VAR_10[VAR_6].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* COMMENT_3 */\n    for (VAR_6 = 0; VAR_6 < VAR_1 - 1; VAR_6++)\n        if (VAR_10[VAR_6].key_data_kvno != VAR_10[VAR_6 + 1].key_data_kvno)\n            VAR_5++;\n\n    VAR_3 = (struct berval **) calloc (VAR_5 + 1, sizeof (struct berval *));\n    if (VAR_3 == NULL) {\n        VAR_9 = VAR_12;\n        goto cleanup;\n    }\n    for (VAR_6 = 0, VAR_8 = 0, VAR_7 = 0, VAR_4 = VAR_10[0].key_data_kvno; VAR_6 < VAR_1; VAR_6++) {\n        krb5_data *VAR_13;\n        if (VAR_6 == VAR_1 - 1 || VAR_10[VAR_6 + 1].key_data_kvno != VAR_4) {\n            VAR_3[VAR_7] = k5alloc(sizeof(struct berval), &VAR_9);\n            if (VAR_3[VAR_7] == NULL)\n                goto cleanup;\n            VAR_9 = asn1_encode_sequence_of_keys(VAR_10 + VAR_8,\n                                               (krb5_int16)VAR_6 - VAR_8 + 1,\n                                               VAR_2, &VAR_13);\n            if (VAR_9)\n                goto cleanup;\n            /* COMMENT_4 */\n            VAR_3[VAR_7]->bv_len = VAR_13->length;\n            VAR_3[VAR_7]->bv_val = VAR_13->data;\n            free(VAR_13);\n            VAR_7++;\n            VAR_8 = VAR_6 + 1;\n\n            if (VAR_6 < VAR_1 - 1)\n                VAR_4 = VAR_10[VAR_6 + 1].key_data_kvno;\n        }\n    }\n    VAR_3[VAR_5] = NULL;\n\ncleanup:\n\n    free(VAR_10);\n    if (VAR_9 != 0) {\n        if (VAR_3 != NULL) {\n            for (VAR_6 = 0; VAR_6 <= VAR_5; VAR_6++)\n                if (VAR_3[VAR_6] != NULL)\n                    free (VAR_3[VAR_6]);\n            free (VAR_3);\n            VAR_3 = NULL;\n        }\n    }\n\n    return VAR_3;\n}",
    "func_graph_path_before": "krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16/ldap_principal2.c/vul/before/0.json",
    "func": "static struct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,\n                         krb5_kvno mkvno) {\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 1;\n    int i, j, last;\n    krb5_error_code err = 0;\n    krb5_key_data *key_data = NULL;\n\n    if (n_key_data < 0)\n        return NULL;\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* Find the number of key versions */\n    for (i = 0; i < n_key_data - 1; i++)\n        if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n            num_versions++;\n\n    ret = (struct berval **) calloc (num_versions + 1, sizeof (struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    for (i = 0, last = 0, j = 0, currkvno = key_data[0].key_data_kvno; i < n_key_data; i++) {\n        krb5_data *code;\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            ret[j] = k5alloc(sizeof(struct berval), &err);\n            if (ret[j] == NULL)\n                goto cleanup;\n            err = asn1_encode_sequence_of_keys(key_data + last,\n                                               (krb5_int16)i - last + 1,\n                                               mkvno, &code);\n            if (err)\n                goto cleanup;\n            /*CHECK_NULL(ret[j]); */\n            ret[j]->bv_len = code->length;\n            ret[j]->bv_val = code->data;\n            free(code);\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n    ret[num_versions] = NULL;\n\ncleanup:\n\n    free(key_data);\n    if (err != 0) {\n        if (ret != NULL) {\n            for (i = 0; ret[i] != NULL; i++)\n                free (ret[i]);\n            free (ret);\n            ret = NULL;\n        }\n    }\n\n    return ret;\n}",
    "abstract_func": "static struct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *VAR_0, int VAR_1,\n                         krb5_kvno VAR_2) {\n    struct berval **VAR_3 = NULL;\n    int VAR_4;\n    int VAR_5 = 1;\n    int VAR_6, VAR_7, VAR_8;\n    krb5_error_code VAR_9 = 0;\n    krb5_key_data *VAR_10 = NULL;\n\n    if (VAR_1 < 0)\n        return NULL;\n\n    /* COMMENT_0 */\n    VAR_10 = k5calloc(VAR_1, sizeof(*VAR_10), &VAR_9);\n    if (VAR_10 == NULL)\n        goto cleanup;\n    memcpy(VAR_10, VAR_0, VAR_1 * sizeof(*VAR_10));\n\n    /* COMMENT_1 */\n                                                                \n    for (VAR_6 = 0; VAR_6 < VAR_1; VAR_6++) {\n        if (VAR_10[VAR_6].key_data_ver == 1) {\n            VAR_10[VAR_6].key_data_ver = 2;\n            VAR_10[VAR_6].key_data_type[1] = VAR_11;\n            VAR_10[VAR_6].key_data_length[1] = 0;\n            VAR_10[VAR_6].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* COMMENT_3 */\n    for (VAR_6 = 0; VAR_6 < VAR_1 - 1; VAR_6++)\n        if (VAR_10[VAR_6].key_data_kvno != VAR_10[VAR_6 + 1].key_data_kvno)\n            VAR_5++;\n\n    VAR_3 = (struct berval **) calloc (VAR_5 + 1, sizeof (struct berval *));\n    if (VAR_3 == NULL) {\n        VAR_9 = VAR_12;\n        goto cleanup;\n    }\n    for (VAR_6 = 0, VAR_8 = 0, VAR_7 = 0, VAR_4 = VAR_10[0].key_data_kvno; VAR_6 < VAR_1; VAR_6++) {\n        krb5_data *VAR_13;\n        if (VAR_6 == VAR_1 - 1 || VAR_10[VAR_6 + 1].key_data_kvno != VAR_4) {\n            VAR_3[VAR_7] = k5alloc(sizeof(struct berval), &VAR_9);\n            if (VAR_3[VAR_7] == NULL)\n                goto cleanup;\n            VAR_9 = asn1_encode_sequence_of_keys(VAR_10 + VAR_8,\n                                               (krb5_int16)VAR_6 - VAR_8 + 1,\n                                               VAR_2, &VAR_13);\n            if (VAR_9)\n                goto cleanup;\n            /* COMMENT_4 */\n            VAR_3[VAR_7]->bv_len = VAR_13->length;\n            VAR_3[VAR_7]->bv_val = VAR_13->data;\n            free(VAR_13);\n            VAR_7++;\n            VAR_8 = VAR_6 + 1;\n\n            if (VAR_6 < VAR_1 - 1)\n                VAR_4 = VAR_10[VAR_6 + 1].key_data_kvno;\n        }\n    }\n    VAR_3[VAR_5] = NULL;\n\ncleanup:\n\n    free(VAR_10);\n    if (VAR_9 != 0) {\n        if (VAR_3 != NULL) {\n            for (VAR_6 = 0; VAR_3[VAR_6] != NULL; VAR_6++)\n                free (VAR_3[VAR_6]);\n            free (VAR_3);\n            VAR_3 = NULL;\n        }\n    }\n\n    return VAR_3;\n}",
    "func_graph_path": "krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16/ldap_principal2.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,14 @@\n     int num_versions = 1;\n     int i, j, last;\n     krb5_error_code err = 0;\n-    krb5_key_data *key_data;\n+    krb5_key_data *key_data = NULL;\n \n-    if (n_key_data <= 0)\n+    if (n_key_data < 0)\n         return NULL;\n \n     /* Make a shallow copy of the key data so we can alter it. */\n     key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n-    if (key_data_in == NULL)\n+    if (key_data == NULL)\n         goto cleanup;\n     memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n \n@@ -67,9 +67,8 @@\n     free(key_data);\n     if (err != 0) {\n         if (ret != NULL) {\n-            for (i = 0; i <= num_versions; i++)\n-                if (ret[i] != NULL)\n-                    free (ret[i]);\n+            for (i = 0; ret[i] != NULL; i++)\n+                free (ret[i]);\n             free (ret);\n             ret = NULL;\n         }",
    "diff_line_info": {
        "deleted_lines": [
            "    krb5_key_data *key_data;",
            "    if (n_key_data <= 0)",
            "    if (key_data_in == NULL)",
            "            for (i = 0; i <= num_versions; i++)",
            "                if (ret[i] != NULL)",
            "                    free (ret[i]);"
        ],
        "added_lines": [
            "    krb5_key_data *key_data = NULL;",
            "    if (n_key_data < 0)",
            "    if (key_data == NULL)",
            "            for (i = 0; ret[i] != NULL; i++)",
            "                free (ret[i]);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}