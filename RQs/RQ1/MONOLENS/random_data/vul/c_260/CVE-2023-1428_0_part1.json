{
    "cve_id": "CVE-2023-1428",
    "cwe_ids": [
        "CWE-617"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "grpc",
    "commit_msg": "[chttp2] Fix fuzzer found bug (#32507)\n\n<!--\r\n\r\nIf you know who should review your pull request, please assign it to\r\nthat\r\nperson, otherwise the pull request would get assigned randomly.\r\n\r\nIf your pull request is for a specific language, please add the\r\nappropriate\r\nlang label.\r\n\r\n-->",
    "commit_hash": "2485fa94bd8a723e5c977d55a3ce10b301b437f8",
    "git_url": "https://github.com/grpc/grpc/commit/2485fa94bd8a723e5c977d55a3ce10b301b437f8",
    "file_path": "src/core/lib/transport/metadata_batch.cc",
    "func_name": "ContentTypeMetadata::Encode",
    "func_before": "StaticSlice ContentTypeMetadata::Encode(ValueType x) {\n  switch (x) {\n    case kEmpty:\n      return StaticSlice::FromStaticString(\"\");\n    case kApplicationGrpc:\n      return StaticSlice::FromStaticString(\"application/grpc\");\n    case kInvalid:\n      return StaticSlice::FromStaticString(\"application/grpc+unknown\");\n  }\n  GPR_UNREACHABLE_CODE(\n      return StaticSlice::FromStaticString(\"unrepresentable value\"));\n}\n\nconst char* ContentTypeMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case ValueType::kApplicationGrpc:\n      return \"application/grpc\";\n    case ValueType::kEmpty:\n      return \"\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nGrpcTimeoutMetadata::MementoType GrpcTimeoutMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  auto timeout = ParseTimeout(value);\n  if (!timeout.has_value()) {\n    on_error(\"invalid value\", value);\n    return Duration::Infinity();\n  }\n  return *timeout;\n}\n\nGrpcTimeoutMetadata::ValueType GrpcTimeoutMetadata::MementoToValue(\n    MementoType timeout) {\n  if (timeout == Duration::Infinity()) {\n    return Timestamp::InfFuture();\n  }\n  return Timestamp::Now() + timeout;\n}\n\nSlice GrpcTimeoutMetadata::Encode(ValueType x) {\n  return Timeout::FromDuration(x - Timestamp::Now()).Encode();\n}\n\nTeMetadata::MementoType TeMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  auto out = kInvalid;\n  if (value == \"trailers\") {\n    out = kTrailers;\n  } else {\n    on_error(\"invalid value\", value);\n  }\n  return out;\n}\n\nconst char* TeMetadata::DisplayValue(ValueType te) {\n  switch (te) {\n    case ValueType::kTrailers:\n      return \"trailers\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nHttpSchemeMetadata::ValueType HttpSchemeMetadata::Parse(\n    absl::string_view value, MetadataParseErrorFn on_error) {\n  if (value == \"http\") {\n    return kHttp;\n  } else if (value == \"https\") {\n    return kHttps;\n  }\n  on_error(\"invalid value\", Slice::FromCopiedBuffer(value));\n  return kInvalid;\n}\n\nStaticSlice HttpSchemeMetadata::Encode(ValueType x) {\n  switch (x) {\n    case kHttp:\n      return StaticSlice::FromStaticString(\"http\");\n    case kHttps:\n      return StaticSlice::FromStaticString(\"https\");\n    default:\n      abort();\n  }\n}\n\nconst char* HttpSchemeMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case kHttp:\n      return \"http\";\n    case kHttps:\n      return \"https\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nHttpMethodMetadata::MementoType HttpMethodMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  auto out = kInvalid;\n  auto value_string = value.as_string_view();\n  if (value_string == \"POST\") {\n    out = kPost;\n  } else if (value_string == \"PUT\") {\n    out = kPut;\n  } else if (value_string == \"GET\") {\n    out = kGet;\n  } else {\n    on_error(\"invalid value\", value);\n  }\n  return out;\n}\n\nStaticSlice HttpMethodMetadata::Encode(ValueType x) {\n  switch (x) {\n    case kPost:\n      return StaticSlice::FromStaticString(\"POST\");\n    case kPut:\n      return StaticSlice::FromStaticString(\"PUT\");\n    case kGet:\n      return StaticSlice::FromStaticString(\"GET\");\n    default:\n      // TODO(ctiller): this should be an abort, we should split up the debug\n      // string generation from the encode string generation so that debug\n      // strings can always succeed and encode strings can crash.\n      return StaticSlice::FromStaticString(\"<<INVALID METHOD>>\");\n  }\n}\n\nconst char* HttpMethodMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case kPost:\n      return \"POST\";\n    case kGet:\n      return \"GET\";\n    case kPut:\n      return \"PUT\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nCompressionAlgorithmBasedMetadata::MementoType\nCompressionAlgorithmBasedMetadata::ParseMemento(Slice value,\n                                                MetadataParseErrorFn on_error) {\n  auto algorithm = ParseCompressionAlgorithm(value.as_string_view());\n  if (!algorithm.has_value()) {\n    on_error(\"invalid value\", value);\n    return GRPC_COMPRESS_NONE;\n  }\n  return *algorithm;\n}\n\nDuration GrpcRetryPushbackMsMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  int64_t out;\n  if (!absl::SimpleAtoi(value.as_string_view(), &out)) {\n    on_error(\"not an integer\", value);\n    return Duration::NegativeInfinity();\n  }\n  return Duration::Milliseconds(out);\n}\n\nSlice LbCostBinMetadata::Encode(const ValueType& x) {\n  auto slice =\n      MutableSlice::CreateUninitialized(sizeof(double) + x.name.length());\n  memcpy(slice.data(), &x.cost, sizeof(double));\n  memcpy(slice.data() + sizeof(double), x.name.data(), x.name.length());\n  return Slice(std::move(slice));\n}\n\nstd::string LbCostBinMetadata::DisplayValue(ValueType x) {\n  return absl::StrCat(x.name, \":\", x.cost);\n}\n\nLbCostBinMetadata::MementoType LbCostBinMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  if (value.length() < sizeof(double)) {\n    on_error(\"too short\", value);\n    return {0, \"\"};\n  }\n  MementoType out;\n  memcpy(&out.cost, value.data(), sizeof(double));\n  out.name =\n      std::string(reinterpret_cast<const char*>(value.data()) + sizeof(double),\n                  value.length() - sizeof(double));\n  return out;\n}\n\nstd::string GrpcStreamNetworkState::DisplayValue(ValueType x) {\n  switch (x) {\n    case kNotSentOnWire:\n      return \"not sent on wire\";\n    case kNotSeenByServer:\n      return \"not seen by server\";\n  }\n  GPR_UNREACHABLE_CODE(return \"unknown value\");\n}\n\nstd::string PeerString::DisplayValue(const ValueType& x) {\n  return std::string(x.as_string_view());\n}\n\nconst std::string& GrpcStatusContext::DisplayValue(const std::string& x) {\n  return x;\n}\n\nstd::string WaitForReady::DisplayValue(ValueType x) {\n  return absl::StrCat(x.value ? \"true\" : \"false\",\n                      x.explicitly_set ? \" (explicit)\" : \"\");\n}\n\n}",
    "abstract_func_before": "StaticSlice ContentTypeMetadata::Encode(ValueType VAR_0) {\n  switch (VAR_0) {\n    case VAR_1:\n      return StaticSlice::FromStaticString(\"\");\n    case VAR_2:\n      return StaticSlice::FromStaticString(\"application/grpc\");\n    case VAR_3:\n      return StaticSlice::FromStaticString(\"application/grpc+unknown\");\n  }\n  GPR_UNREACHABLE_CODE(\n      return StaticSlice::FromStaticString(\"unrepresentable VAR_4\"));\n}\n\nconst char* ContentTypeMetadata::DisplayValue(ValueType VAR_5) {\n  switch (content_type) {\n    case ValueType::VAR_2:\n      return \"VAR_6/VAR_7\";\n    case ValueType::kEmpty:\n      return \"\";\n    default:\n      return \"<VAR_8-VAR_9-VAR_4>\";\n  }\n}\n\nVAR_10::MementoType GrpcTimeoutMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  auto VAR_12 = ParseTimeout(VAR_4);\n  if (!VAR_12.has_value()) {\n    VAR_11(\"invalid value\", VAR_4);\n    return Duration::Infinity();\n  }\n  return *VAR_12;\n}\n\nGrpcTimeoutMetadata::ValueType GrpcTimeoutMetadata::MementoToValue(\n    VAR_13 VAR_12) {\n  if (VAR_12 == Duration::Infinity()) {\n    return Timestamp::InfFuture();\n  }\n  return Timestamp::Now() + VAR_12;\n}\n\nSlice GrpcTimeoutMetadata::Encode(ValueType VAR_0) {\n  return Timeout::FromDuration(VAR_0 - Timestamp::Now()).Encode();\n}\n\nTeMetadata::MementoType TeMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  auto VAR_14 = VAR_3;\n  if (VAR_4 == \"trailers\") {\n    VAR_14 = VAR_15;\n  } else {\n    VAR_11(\"invalid value\", VAR_4);\n  }\n  return VAR_14;\n}\n\nconst char* TeMetadata::DisplayValue(ValueType VAR_16) {\n  switch (VAR_16) {\n    case ValueType::kTrailers:\n      return \"trailers\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nHttpSchemeMetadata::ValueType HttpSchemeMetadata::Parse(\n    absl::string_view VAR_4, MetadataParseErrorFn VAR_11) {\n  if (VAR_4 == \"http\") {\n    return kHttp;\n  } else if (VAR_4 == \"https\") {\n    return VAR_17;\n  }\n  VAR_11(\"invalid value\", Slice::FromCopiedBuffer(VAR_4));\n  return VAR_3;\n}\n\nStaticSlice HttpSchemeMetadata::Encode(ValueType VAR_0) {\n  switch (VAR_0) {\n    case VAR_18:\n      return StaticSlice::FromStaticString(\"http\");\n    case VAR_17:\n      return StaticSlice::FromStaticString(\"https\");\n    default:\n      abort();\n  }\n}\n\nconst char* HttpSchemeMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case VAR_18:\n      return \"http\";\n    case VAR_17:\n      return \"https\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nHttpMethodMetadata::MementoType HttpMethodMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  auto VAR_14 = VAR_3;\n  auto VAR_19 = VAR_4.as_string_view();\n  if (VAR_19 == \"POST\") {\n    VAR_14 = VAR_20;\n  } else if (VAR_19 == \"PUT\") {\n    VAR_14 = VAR_21;\n  } else if (VAR_19 == \"GET\") {\n    VAR_14 = VAR_22;\n  } else {\n    VAR_11(\"invalid value\", VAR_4);\n  }\n  return VAR_14;\n}\n\nStaticSlice HttpMethodMetadata::Encode(ValueType VAR_0) {\n  switch (VAR_0) {\n    case VAR_20:\n      return StaticSlice::FromStaticString(\"POST\");\n    case VAR_21:\n      return StaticSlice::FromStaticString(\"PUT\");\n    case VAR_22:\n      return StaticSlice::FromStaticString(\"GET\");\n    default:\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      return StaticSlice::FromStaticString(\"<<INVALID METHOD>>\");\n  }\n}\n\nconst char* HttpMethodMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case VAR_20:\n      return \"POST\";\n    case VAR_22:\n      return \"GET\";\n    case VAR_21:\n      return \"PUT\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nCompressionAlgorithmBasedMetadata::MementoType\nCompressionAlgorithmBasedMetadata::ParseMemento(Slice VAR_4,\n                                                MetadataParseErrorFn VAR_11) {\n  auto VAR_23 = ParseCompressionAlgorithm(VAR_4.as_string_view());\n  if (!VAR_23.has_value()) {\n    VAR_11(\"invalid value\", VAR_4);\n    return VAR_24;\n  }\n  return *VAR_23;\n}\n\nVAR_25 GrpcRetryPushbackMsMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  int64_t VAR_14;\n  if (!absl::SimpleAtoi(VAR_4.as_string_view(), &VAR_14)) {\n    VAR_11(\"not an integer\", VAR_4);\n    return Duration::NegativeInfinity();\n  }\n  return Duration::Milliseconds(VAR_14);\n}\n\nSlice LbCostBinMetadata::Encode(VAR_26 ValueType& VAR_0) {\n  auto VAR_27 =\n      MutableSlice::CreateUninitialized(sizeof(double) + VAR_0.name.length());\n  memcpy(VAR_27.data(), &VAR_0.cost, sizeof(double));\n  memcpy(VAR_27.data() + sizeof(double), VAR_0.name.data(), VAR_0.name.length());\n  return Slice(std::move(VAR_27));\n}\n\nstd::string LbCostBinMetadata::DisplayValue(ValueType VAR_0) {\n  return absl::StrCat(VAR_0.name, \":\", VAR_0.cost);\n}\n\nLbCostBinMetadata::MementoType LbCostBinMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  if (VAR_4.length() < sizeof(double)) {\n    VAR_11(\"too short\", VAR_4);\n    return {0, \"\"};\n  }\n  MementoType VAR_14;\n  memcpy(&out.VAR_28, value.data(), sizeof(double));\n  out.VAR_29 =\n      std::string(VAR_30<const char*>(value.data()) + sizeof(double),\n                  value.length() - sizeof(double));\n  return out;\n}\n\nstd::string GrpcStreamNetworkState::DisplayValue(ValueType VAR_0) {\n  switch (VAR_0) {\n    case VAR_31:\n      return \"not sent on wire\";\n    case VAR_32:\n      return \"not seen by server\";\n  }\n  GPR_UNREACHABLE_CODE(return \"unknown value\");\n}\n\nstd::string PeerString::DisplayValue(const ValueType& VAR_0) {\n  return std::string(VAR_0.as_string_view());\n}\n\nconst std::string& GrpcStatusContext::DisplayValue(const std::string& VAR_0) {\n  return VAR_0;\n}\n\nstd::string WaitForReady::DisplayValue(ValueType VAR_0) {\n  return absl::StrCat(VAR_0.value ? \"true\" : \"false\",\n                      VAR_0.explicitly_set ? \" (explicit)\" : \"\");\n}\n\n}",
    "func_graph_path_before": null,
    "func": "StaticSlice ContentTypeMetadata::Encode(ValueType x) {\n  switch (x) {\n    case kEmpty:\n      return StaticSlice::FromStaticString(\"\");\n    case kApplicationGrpc:\n      return StaticSlice::FromStaticString(\"application/grpc\");\n    case kInvalid:\n      return StaticSlice::FromStaticString(\"application/grpc+unknown\");\n  }\n  GPR_UNREACHABLE_CODE(\n      return StaticSlice::FromStaticString(\"unrepresentable value\"));\n}\n\nconst char* ContentTypeMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case ValueType::kApplicationGrpc:\n      return \"application/grpc\";\n    case ValueType::kEmpty:\n      return \"\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nGrpcTimeoutMetadata::MementoType GrpcTimeoutMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  auto timeout = ParseTimeout(value);\n  if (!timeout.has_value()) {\n    on_error(\"invalid value\", value);\n    return Duration::Infinity();\n  }\n  return *timeout;\n}\n\nGrpcTimeoutMetadata::ValueType GrpcTimeoutMetadata::MementoToValue(\n    MementoType timeout) {\n  if (timeout == Duration::Infinity()) {\n    return Timestamp::InfFuture();\n  }\n  return Timestamp::Now() + timeout;\n}\n\nSlice GrpcTimeoutMetadata::Encode(ValueType x) {\n  return Timeout::FromDuration(x - Timestamp::Now()).Encode();\n}\n\nTeMetadata::MementoType TeMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  auto out = kInvalid;\n  if (value == \"trailers\") {\n    out = kTrailers;\n  } else {\n    on_error(\"invalid value\", value);\n  }\n  return out;\n}\n\nconst char* TeMetadata::DisplayValue(ValueType te) {\n  switch (te) {\n    case ValueType::kTrailers:\n      return \"trailers\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nHttpSchemeMetadata::ValueType HttpSchemeMetadata::Parse(\n    absl::string_view value, MetadataParseErrorFn on_error) {\n  if (value == \"http\") {\n    return kHttp;\n  } else if (value == \"https\") {\n    return kHttps;\n  }\n  on_error(\"invalid value\", Slice::FromCopiedBuffer(value));\n  return kInvalid;\n}\n\nStaticSlice HttpSchemeMetadata::Encode(ValueType x) {\n  switch (x) {\n    case kHttp:\n      return StaticSlice::FromStaticString(\"http\");\n    case kHttps:\n      return StaticSlice::FromStaticString(\"https\");\n    default:\n      abort();\n  }\n}\n\nsize_t EncodedSizeOfKey(HttpSchemeMetadata, HttpSchemeMetadata::ValueType x) {\n  switch (x) {\n    case HttpSchemeMetadata::kHttp:\n      return 4;\n    case HttpSchemeMetadata::kHttps:\n      return 5;\n    default:\n      return 0;\n  }\n}\n\nconst char* HttpSchemeMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case kHttp:\n      return \"http\";\n    case kHttps:\n      return \"https\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nHttpMethodMetadata::MementoType HttpMethodMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  auto out = kInvalid;\n  auto value_string = value.as_string_view();\n  if (value_string == \"POST\") {\n    out = kPost;\n  } else if (value_string == \"PUT\") {\n    out = kPut;\n  } else if (value_string == \"GET\") {\n    out = kGet;\n  } else {\n    on_error(\"invalid value\", value);\n  }\n  return out;\n}\n\nStaticSlice HttpMethodMetadata::Encode(ValueType x) {\n  switch (x) {\n    case kPost:\n      return StaticSlice::FromStaticString(\"POST\");\n    case kPut:\n      return StaticSlice::FromStaticString(\"PUT\");\n    case kGet:\n      return StaticSlice::FromStaticString(\"GET\");\n    default:\n      // TODO(ctiller): this should be an abort, we should split up the debug\n      // string generation from the encode string generation so that debug\n      // strings can always succeed and encode strings can crash.\n      return StaticSlice::FromStaticString(\"<<INVALID METHOD>>\");\n  }\n}\n\nconst char* HttpMethodMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case kPost:\n      return \"POST\";\n    case kGet:\n      return \"GET\";\n    case kPut:\n      return \"PUT\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nCompressionAlgorithmBasedMetadata::MementoType\nCompressionAlgorithmBasedMetadata::ParseMemento(Slice value,\n                                                MetadataParseErrorFn on_error) {\n  auto algorithm = ParseCompressionAlgorithm(value.as_string_view());\n  if (!algorithm.has_value()) {\n    on_error(\"invalid value\", value);\n    return GRPC_COMPRESS_NONE;\n  }\n  return *algorithm;\n}\n\nDuration GrpcRetryPushbackMsMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  int64_t out;\n  if (!absl::SimpleAtoi(value.as_string_view(), &out)) {\n    on_error(\"not an integer\", value);\n    return Duration::NegativeInfinity();\n  }\n  return Duration::Milliseconds(out);\n}\n\nSlice LbCostBinMetadata::Encode(const ValueType& x) {\n  auto slice =\n      MutableSlice::CreateUninitialized(sizeof(double) + x.name.length());\n  memcpy(slice.data(), &x.cost, sizeof(double));\n  memcpy(slice.data() + sizeof(double), x.name.data(), x.name.length());\n  return Slice(std::move(slice));\n}\n\nstd::string LbCostBinMetadata::DisplayValue(ValueType x) {\n  return absl::StrCat(x.name, \":\", x.cost);\n}\n\nLbCostBinMetadata::MementoType LbCostBinMetadata::ParseMemento(\n    Slice value, MetadataParseErrorFn on_error) {\n  if (value.length() < sizeof(double)) {\n    on_error(\"too short\", value);\n    return {0, \"\"};\n  }\n  MementoType out;\n  memcpy(&out.cost, value.data(), sizeof(double));\n  out.name =\n      std::string(reinterpret_cast<const char*>(value.data()) + sizeof(double),\n                  value.length() - sizeof(double));\n  return out;\n}\n\nstd::string GrpcStreamNetworkState::DisplayValue(ValueType x) {\n  switch (x) {\n    case kNotSentOnWire:\n      return \"not sent on wire\";\n    case kNotSeenByServer:\n      return \"not seen by server\";\n  }\n  GPR_UNREACHABLE_CODE(return \"unknown value\");\n}\n\nstd::string PeerString::DisplayValue(const ValueType& x) {\n  return std::string(x.as_string_view());\n}\n\nconst std::string& GrpcStatusContext::DisplayValue(const std::string& x) {\n  return x;\n}\n\nstd::string WaitForReady::DisplayValue(ValueType x) {\n  return absl::StrCat(x.value ? \"true\" : \"false\",\n                      x.explicitly_set ? \" (explicit)\" : \"\");\n}\n\n}",
    "abstract_func": "StaticSlice ContentTypeMetadata::Encode(ValueType VAR_0) {\n  switch (VAR_0) {\n    case VAR_1:\n      return StaticSlice::FromStaticString(\"\");\n    case VAR_2:\n      return StaticSlice::FromStaticString(\"application/grpc\");\n    case VAR_3:\n      return StaticSlice::FromStaticString(\"application/grpc+unknown\");\n  }\n  GPR_UNREACHABLE_CODE(\n      return StaticSlice::FromStaticString(\"unrepresentable VAR_4\"));\n}\n\nconst char* ContentTypeMetadata::DisplayValue(ValueType VAR_5) {\n  switch (content_type) {\n    case ValueType::VAR_2:\n      return \"VAR_6/VAR_7\";\n    case ValueType::kEmpty:\n      return \"\";\n    default:\n      return \"<VAR_8-VAR_9-VAR_4>\";\n  }\n}\n\nVAR_10::MementoType GrpcTimeoutMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  auto VAR_12 = ParseTimeout(VAR_4);\n  if (!VAR_12.has_value()) {\n    VAR_11(\"invalid value\", VAR_4);\n    return Duration::Infinity();\n  }\n  return *VAR_12;\n}\n\nGrpcTimeoutMetadata::ValueType GrpcTimeoutMetadata::MementoToValue(\n    VAR_13 VAR_12) {\n  if (VAR_12 == Duration::Infinity()) {\n    return Timestamp::InfFuture();\n  }\n  return Timestamp::Now() + VAR_12;\n}\n\nSlice GrpcTimeoutMetadata::Encode(ValueType VAR_0) {\n  return Timeout::FromDuration(VAR_0 - Timestamp::Now()).Encode();\n}\n\nTeMetadata::MementoType TeMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  auto VAR_14 = VAR_3;\n  if (VAR_4 == \"trailers\") {\n    VAR_14 = VAR_15;\n  } else {\n    VAR_11(\"invalid value\", VAR_4);\n  }\n  return VAR_14;\n}\n\nconst char* TeMetadata::DisplayValue(ValueType VAR_16) {\n  switch (VAR_16) {\n    case ValueType::kTrailers:\n      return \"trailers\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nHttpSchemeMetadata::ValueType HttpSchemeMetadata::Parse(\n    absl::string_view VAR_4, MetadataParseErrorFn VAR_11) {\n  if (VAR_4 == \"http\") {\n    return kHttp;\n  } else if (VAR_4 == \"https\") {\n    return VAR_17;\n  }\n  VAR_11(\"invalid value\", Slice::FromCopiedBuffer(VAR_4));\n  return VAR_3;\n}\n\nStaticSlice HttpSchemeMetadata::Encode(ValueType VAR_0) {\n  switch (VAR_0) {\n    case VAR_18:\n      return StaticSlice::FromStaticString(\"http\");\n    case VAR_17:\n      return StaticSlice::FromStaticString(\"https\");\n    default:\n      abort();\n  }\n}\n\nsize_t EncodedSizeOfKey(VAR_19, HttpSchemeMetadata::ValueType VAR_0) {\n  switch (VAR_0) {\n    case HttpSchemeMetadata::kHttp:\n      return 4;\n    case HttpSchemeMetadata::kHttps:\n      return 5;\n    default:\n      return 0;\n  }\n}\n\nconst char* HttpSchemeMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case VAR_18:\n      return \"http\";\n    case VAR_17:\n      return \"https\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nHttpMethodMetadata::MementoType HttpMethodMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  auto VAR_14 = VAR_3;\n  auto VAR_20 = VAR_4.as_string_view();\n  if (VAR_20 == \"POST\") {\n    VAR_14 = VAR_21;\n  } else if (VAR_20 == \"PUT\") {\n    VAR_14 = VAR_22;\n  } else if (VAR_20 == \"GET\") {\n    VAR_14 = VAR_23;\n  } else {\n    VAR_11(\"invalid value\", VAR_4);\n  }\n  return VAR_14;\n}\n\nStaticSlice HttpMethodMetadata::Encode(ValueType VAR_0) {\n  switch (VAR_0) {\n    case VAR_21:\n      return StaticSlice::FromStaticString(\"POST\");\n    case VAR_22:\n      return StaticSlice::FromStaticString(\"PUT\");\n    case VAR_23:\n      return StaticSlice::FromStaticString(\"GET\");\n    default:\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      return StaticSlice::FromStaticString(\"<<INVALID METHOD>>\");\n  }\n}\n\nconst char* HttpMethodMetadata::DisplayValue(ValueType content_type) {\n  switch (content_type) {\n    case VAR_21:\n      return \"POST\";\n    case VAR_23:\n      return \"GET\";\n    case VAR_22:\n      return \"PUT\";\n    default:\n      return \"<discarded-invalid-value>\";\n  }\n}\n\nCompressionAlgorithmBasedMetadata::MementoType\nCompressionAlgorithmBasedMetadata::ParseMemento(Slice VAR_4,\n                                                MetadataParseErrorFn VAR_11) {\n  auto VAR_24 = ParseCompressionAlgorithm(VAR_4.as_string_view());\n  if (!VAR_24.has_value()) {\n    VAR_11(\"invalid value\", VAR_4);\n    return VAR_25;\n  }\n  return *VAR_24;\n}\n\nVAR_26 GrpcRetryPushbackMsMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  int64_t VAR_14;\n  if (!absl::SimpleAtoi(VAR_4.as_string_view(), &VAR_14)) {\n    VAR_11(\"not an integer\", VAR_4);\n    return Duration::NegativeInfinity();\n  }\n  return Duration::Milliseconds(VAR_14);\n}\n\nSlice LbCostBinMetadata::Encode(VAR_27 ValueType& VAR_0) {\n  auto VAR_28 =\n      MutableSlice::CreateUninitialized(sizeof(double) + VAR_0.name.length());\n  memcpy(VAR_28.data(), &VAR_0.cost, sizeof(double));\n  memcpy(VAR_28.data() + sizeof(double), VAR_0.name.data(), VAR_0.name.length());\n  return Slice(std::move(VAR_28));\n}\n\nstd::string LbCostBinMetadata::DisplayValue(ValueType VAR_0) {\n  return absl::StrCat(VAR_0.name, \":\", VAR_0.cost);\n}\n\nLbCostBinMetadata::MementoType LbCostBinMetadata::ParseMemento(\n    Slice VAR_4, MetadataParseErrorFn VAR_11) {\n  if (VAR_4.length() < sizeof(double)) {\n    VAR_11(\"too short\", VAR_4);\n    return {0, \"\"};\n  }\n  MementoType VAR_14;\n  memcpy(&out.VAR_29, value.data(), sizeof(double));\n  out.VAR_30 =\n      std::string(VAR_31<const char*>(value.data()) + sizeof(double),\n                  value.length() - sizeof(double));\n  return out;\n}\n\nstd::string GrpcStreamNetworkState::DisplayValue(ValueType VAR_0) {\n  switch (VAR_0) {\n    case VAR_32:\n      return \"not sent on wire\";\n    case VAR_33:\n      return \"not seen by server\";\n  }\n  GPR_UNREACHABLE_CODE(return \"unknown value\");\n}\n\nstd::string PeerString::DisplayValue(const ValueType& VAR_0) {\n  return std::string(VAR_0.as_string_view());\n}\n\nconst std::string& GrpcStatusContext::DisplayValue(const std::string& VAR_0) {\n  return VAR_0;\n}\n\nstd::string WaitForReady::DisplayValue(ValueType VAR_0) {\n  return absl::StrCat(VAR_0.value ? \"true\" : \"false\",\n                      VAR_0.explicitly_set ? \" (explicit)\" : \"\");\n}\n\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -83,6 +83,17 @@\n       return StaticSlice::FromStaticString(\"https\");\n     default:\n       abort();\n+  }\n+}\n+\n+size_t EncodedSizeOfKey(HttpSchemeMetadata, HttpSchemeMetadata::ValueType x) {\n+  switch (x) {\n+    case HttpSchemeMetadata::kHttp:\n+      return 4;\n+    case HttpSchemeMetadata::kHttps:\n+      return 5;\n+    default:\n+      return 0;\n   }\n }\n ",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "  }",
            "}",
            "",
            "size_t EncodedSizeOfKey(HttpSchemeMetadata, HttpSchemeMetadata::ValueType x) {",
            "  switch (x) {",
            "    case HttpSchemeMetadata::kHttp:",
            "      return 4;",
            "    case HttpSchemeMetadata::kHttps:",
            "      return 5;",
            "    default:",
            "      return 0;"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/grpc/grpc/pull/32507",
    "description": "\r\n\r\n<!--\r\n\r\nIf you know who should review your pull request, please assign it to that\r\nperson, otherwise the pull request would get assigned randomly.\r\n\r\nIf your pull request is for a specific language, please add the appropriate\r\nlang label.\r\n\r\n-->\r\n\r\n"
}