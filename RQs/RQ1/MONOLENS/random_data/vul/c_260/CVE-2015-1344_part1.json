{
    "cve_id": "CVE-2015-1344",
    "cwe_ids": [
        "CWE-264"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "lxc/lxcfs",
    "commit_msg": "Implement privilege check when moving tasks\n\nWhen writing pids to a tasks file in lxcfs, lxcfs was checking\nfor privilege over the tasks file but not over the pid being\nmoved.  Since the cgm_movepid request is done as root on the host,\nnot with the requestor's credentials, we must copy the check which\ncgmanager was doing to ensure that the requesting task is allowed\nto change the victim task's cgroup membership.\n\nThis is CVE-2015-1344\nhttps://bugs.launchpad.net/ubuntu/+source/lxcfs/+bug/1512854\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
    "commit_hash": "8ee2a503e102b1a43ec4d83113dc275ab20a869a",
    "git_url": "https://github.com/lxc/lxcfs/commit/8ee2a503e102b1a43ec4d83113dc275ab20a869a",
    "file_path": "lxcfs.c",
    "func_name": "do_write_pids",
    "func_before": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n{\n\tint sock[2] = {-1, -1};\n\tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\n\t/*\n\t * write the pids to a socket, have helper in writer's pidns\n\t * call movepid for us\n\t */\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\n\tif (!cpid) { // child\n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (recv_creds(sock[0], &cred, &v)) {\n\t\t\tif (v == '0') {\n\t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n\t\t\t\t\tfail = true;\n\t\t\t}\n\t\t}\n\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\n\t/* All good, write the value */\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\n\tif (!fail)\n\t\tanswer = true;\n\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}",
    "abstract_func_before": "static bool do_write_pids(pid_t VAR_0, const char *VAR_1, const char *VAR_2, const char *VAR_3, const char *VAR_4)\n{\n\tint VAR_5[2] = {-1, -1};\n\tpid_t VAR_6, VAR_7 = -1;\n\tFILE *VAR_8 = NULL;\n\tbool VAR_9 = false, VAR_10 = false;\n\n\tVAR_8 = open_pids_file(VAR_1, VAR_2);\n\tif (!VAR_8)\n\t\treturn false;\n\n\t/* COMMENT_0 */\n                                                             \n                       \n    \n\tif (socketpair(VAR_11, VAR_12, 0, VAR_5) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\n\tVAR_7 = fork();\n\tif (VAR_7 == -1)\n\t\tgoto out;\n\n\tif (!VAR_7) { /* COMMENT_4 */\n\t\tfclose(VAR_8);\n\t\tpid_from_ns_wrapper(VAR_5[1], VAR_0);\n\t}\n\n\tconst char *VAR_13 = VAR_4;\n\twhile (sscanf(VAR_13, \"%d\", &VAR_6) == 1) {\n\t\tstruct ucred VAR_14;\n\t\tchar VAR_15;\n\n\t\tif (write(VAR_5[0], &VAR_6, sizeof(VAR_6)) != sizeof(VAR_6)) {\n\t\t\tfprintf(VAR_16, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\tVAR_17, strerror(VAR_18));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (recv_creds(VAR_5[0], &VAR_14, &VAR_15)) {\n\t\t\tif (VAR_15 == '0') {\n\t\t\t\tif (fprintf(VAR_8, \"%d\", (int) VAR_14.pid) < 0)\n\t\t\t\t\tVAR_10 = true;\n\t\t\t}\n\t\t}\n\n\t\tVAR_13 = strchr(VAR_13, '\\n');\n\t\tif (!VAR_13)\n\t\t\tbreak;\n\t\tVAR_13++;\n\t}\n\n\t/* COMMENT_5 */\n\tVAR_6 = -1;\n\tif (write(VAR_5[0], &VAR_6 ,sizeof(VAR_6)) != sizeof(VAR_6))\n\t\tfprintf(VAR_16, \"Warning: failed to ask child to exit\\n\");\n\n\tif (!VAR_10)\n\t\tVAR_9 = true;\n\nout:\n\tif (VAR_7 != -1)\n\t\twait_for_pid(VAR_7);\n\tif (VAR_5[0] != -1) {\n\t\tclose(VAR_5[0]);\n\t\tclose(VAR_5[1]);\n\t}\n\tif (VAR_8) {\n\t\tif (fclose(VAR_8) != 0)\n\t\t\tVAR_9 = false;\n\t}\n\treturn VAR_9;\n}",
    "func_graph_path_before": "lxc/lxcfs/8ee2a503e102b1a43ec4d83113dc275ab20a869a/lxcfs.c/vul/before/0.json",
    "func": "static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,\n\t\tconst char *file, const char *buf)\n{\n\tint sock[2] = {-1, -1};\n\tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\n\t/*\n\t * write the pids to a socket, have helper in writer's pidns\n\t * call movepid for us\n\t */\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\n\tif (!cpid) { // child\n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (recv_creds(sock[0], &cred, &v)) {\n\t\t\tif (v == '0') {\n\t\t\t\tif (!may_move_pid(tpid, tuid, cred.pid)) {\n\t\t\t\t\tfail = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n\t\t\t\t\tfail = true;\n\t\t\t}\n\t\t}\n\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\n\t/* All good, write the value */\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\n\tif (!fail)\n\t\tanswer = true;\n\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}",
    "abstract_func": "static bool do_write_pids(pid_t VAR_0, uid_t VAR_1, const char *VAR_2, const char *VAR_3,\n\t\tconst char *VAR_4, const char *VAR_5)\n{\n\tint VAR_6[2] = {-1, -1};\n\tpid_t VAR_7, VAR_8 = -1;\n\tFILE *VAR_9 = NULL;\n\tbool VAR_10 = false, VAR_11 = false;\n\n\tVAR_9 = open_pids_file(VAR_2, VAR_3);\n\tif (!VAR_9)\n\t\treturn false;\n\n\t/* COMMENT_0 */\n                                                             \n                       \n    \n\tif (socketpair(VAR_12, VAR_13, 0, VAR_6) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\n\tVAR_8 = fork();\n\tif (VAR_8 == -1)\n\t\tgoto out;\n\n\tif (!VAR_8) { /* COMMENT_4 */\n\t\tfclose(VAR_9);\n\t\tpid_from_ns_wrapper(VAR_6[1], VAR_0);\n\t}\n\n\tconst char *VAR_14 = VAR_5;\n\twhile (sscanf(VAR_14, \"%d\", &VAR_7) == 1) {\n\t\tstruct ucred VAR_15;\n\t\tchar VAR_16;\n\n\t\tif (write(VAR_6[0], &VAR_7, sizeof(VAR_7)) != sizeof(VAR_7)) {\n\t\t\tfprintf(VAR_17, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\tVAR_18, strerror(VAR_19));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (recv_creds(VAR_6[0], &VAR_15, &VAR_16)) {\n\t\t\tif (VAR_16 == '0') {\n\t\t\t\tif (!may_move_pid(VAR_0, VAR_1, VAR_15.pid)) {\n\t\t\t\t\tVAR_11 = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fprintf(VAR_9, \"%d\", (int) VAR_15.pid) < 0)\n\t\t\t\t\tVAR_11 = true;\n\t\t\t}\n\t\t}\n\n\t\tVAR_14 = strchr(VAR_14, '\\n');\n\t\tif (!VAR_14)\n\t\t\tbreak;\n\t\tVAR_14++;\n\t}\n\n\t/* COMMENT_5 */\n\tVAR_7 = -1;\n\tif (write(VAR_6[0], &VAR_7 ,sizeof(VAR_7)) != sizeof(VAR_7))\n\t\tfprintf(VAR_17, \"Warning: failed to ask child to exit\\n\");\n\n\tif (!VAR_11)\n\t\tVAR_10 = true;\n\nout:\n\tif (VAR_8 != -1)\n\t\twait_for_pid(VAR_8);\n\tif (VAR_6[0] != -1) {\n\t\tclose(VAR_6[0]);\n\t\tclose(VAR_6[1]);\n\t}\n\tif (VAR_9) {\n\t\tif (fclose(VAR_9) != 0)\n\t\t\tVAR_10 = false;\n\t}\n\treturn VAR_10;\n}",
    "func_graph_path": "lxc/lxcfs/8ee2a503e102b1a43ec4d83113dc275ab20a869a/lxcfs.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n-static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n+static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,\n+\t\tconst char *file, const char *buf)\n {\n \tint sock[2] = {-1, -1};\n \tpid_t qpid, cpid = -1;\n@@ -40,6 +41,10 @@\n \n \t\tif (recv_creds(sock[0], &cred, &v)) {\n \t\t\tif (v == '0') {\n+\t\t\t\tif (!may_move_pid(tpid, tuid, cred.pid)) {\n+\t\t\t\t\tfail = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n \t\t\t\t\tfail = true;\n \t\t\t}",
    "diff_line_info": {
        "deleted_lines": [
            "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)"
        ],
        "added_lines": [
            "static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,",
            "\t\tconst char *file, const char *buf)",
            "\t\t\t\tif (!may_move_pid(tpid, tuid, cred.pid)) {",
            "\t\t\t\t\tfail = true;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}