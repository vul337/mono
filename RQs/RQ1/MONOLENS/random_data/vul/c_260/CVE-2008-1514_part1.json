{
    "cve_id": "CVE-2008-1514",
    "cwe_ids": [
        "CWE-399"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "When running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>\n",
    "commit_hash": "3d6e48f43340343d97839eadb1ab7b6a3ea98797",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=3d6e48f43340343d97839eadb1ab7b6a3ea98797",
    "file_path": "arch/s390/kernel/ptrace.c",
    "func_name": "__poke_user",
    "func_before": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask &&\n#ifdef CONFIG_COMPAT\n\t\t    data != PSW_MASK_MERGE(psw_user32_bits, data) &&\n#endif\n\t\t    data != PSW_MASK_MERGE(psw_user_bits, data))\n\t\t\t/* Invalid psw mask. */\n\t\t\treturn -EINVAL;\n#ifndef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.psw.addr)\n\t\t\t/* I'd like to reject addresses without the\n\t\t\t   high order bit but older gdb's rely on it */\n\t\t\tdata |= PSW_ADDR_AMODE;\n#endif\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc &&\n\t\t    (data & ~((unsigned long) FPC_VALID_MASK\n\t\t\t      << (BITS_PER_LONG - 32))) != 0)\n\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure \n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.per_info;\n\t\t*(addr_t *)((addr_t) &child->thread.per_info + offset) = data;\n\n\t}\n\n\tFixPerRegisters(child);\n\treturn 0;\n}",
    "abstract_func_before": "static int __poke_user(struct task_struct *VAR_0, addr_t VAR_1, addr_t VAR_2)\n{\n\tstruct user *VAR_3 = NULL;\n\taddr_t VAR_4;\n\n\tif (VAR_1 < (addr_t) &VAR_3->regs.acrs) {\n\t\t/* COMMENT_0 */\n                                         \n     \n\t\tif (VAR_1 == (addr_t) &VAR_3->regs.psw.mask &&\n#ifdef VAR_5\n\t\t    VAR_2 != PSW_MASK_MERGE(VAR_6, VAR_2) &&\n#endif\n\t\t    VAR_2 != PSW_MASK_MERGE(VAR_7, VAR_2))\n\t\t\t/* COMMENT_3 */\n\t\t\treturn -VAR_8;\n#ifndef VAR_9\n\t\tif (VAR_1 == (addr_t) &VAR_3->regs.psw.addr)\n\t\t\t/* COMMENT_4 */\n                                                  \n\t\t\tVAR_2 |= VAR_10;\n#endif\n\t\t*(addr_t *)((addr_t) &task_pt_regs(VAR_0)->psw + VAR_1) = VAR_2;\n\n\t} else if (VAR_1 < (addr_t) (&VAR_3->regs.orig_gpr2)) {\n\t\t/* COMMENT_6 */\n                                                        \n     \n\t\tVAR_4 = VAR_1 - (addr_t) &VAR_3->regs.acrs;\n#ifdef VAR_9\n\t\t/* COMMENT_9 */\n                                                       \n                                                      \n                                                    \n                      \n     \n\t\tif (VAR_1 == (addr_t) &VAR_3->regs.acrs[15])\n\t\t\tVAR_0->thread.acrs[15] = (unsigned int) (VAR_2 >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &VAR_0->thread.acrs + VAR_4) = VAR_2;\n\n\t} else if (VAR_1 == (addr_t) &VAR_3->regs.orig_gpr2) {\n\t\t/* COMMENT_15 */\n                                            \n     \n\t\ttask_pt_regs(VAR_0)->orig_gpr2 = VAR_2;\n\n\t} else if (VAR_1 < (addr_t) (&VAR_3->regs.fp_regs + 1)) {\n\t\t/* COMMENT_18 */\n                                                            \n     \n\t\tif (VAR_1 == (addr_t) &VAR_3->regs.fp_regs.fpc &&\n\t\t    (VAR_2 & ~((unsigned long) VAR_11\n\t\t\t      << (VAR_12 - 32))) != 0)\n\t\t\treturn -VAR_8;\n\t\tVAR_4 = VAR_1 - (addr_t) &VAR_3->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &VAR_0->thread.fp_regs + VAR_4) = VAR_2;\n\n\t} else if (VAR_1 < (addr_t) (&VAR_3->regs.per_info + 1)) {\n\t\t/* COMMENT_21 */\n                                               \n     \n\t\tVAR_4 = VAR_1 - (addr_t) &VAR_3->regs.per_info;\n\t\t*(addr_t *)((addr_t) &VAR_0->thread.per_info + VAR_4) = VAR_2;\n\n\t}\n\n\tFixPerRegisters(VAR_0);\n\treturn 0;\n}",
    "func_graph_path_before": "torvalds/linux/3d6e48f43340343d97839eadb1ab7b6a3ea98797/ptrace.c/vul/before/0.json",
    "func": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask &&\n#ifdef CONFIG_COMPAT\n\t\t    data != PSW_MASK_MERGE(psw_user32_bits, data) &&\n#endif\n\t\t    data != PSW_MASK_MERGE(psw_user_bits, data))\n\t\t\t/* Invalid psw mask. */\n\t\t\treturn -EINVAL;\n#ifndef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.psw.addr)\n\t\t\t/* I'd like to reject addresses without the\n\t\t\t   high order bit but older gdb's rely on it */\n\t\t\tdata |= PSW_ADDR_AMODE;\n#endif\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writes of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc &&\n\t\t    (data & ~((unsigned long) FPC_VALID_MASK\n\t\t\t      << (BITS_PER_LONG - 32))) != 0)\n\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure \n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.per_info;\n\t\t*(addr_t *)((addr_t) &child->thread.per_info + offset) = data;\n\n\t}\n\n\tFixPerRegisters(child);\n\treturn 0;\n}",
    "abstract_func": "static int __poke_user(struct task_struct *VAR_0, addr_t VAR_1, addr_t VAR_2)\n{\n\tstruct user *VAR_3 = NULL;\n\taddr_t VAR_4;\n\n\tif (VAR_1 < (addr_t) &VAR_3->regs.acrs) {\n\t\t/* COMMENT_0 */\n                                         \n     \n\t\tif (VAR_1 == (addr_t) &VAR_3->regs.psw.mask &&\n#ifdef VAR_5\n\t\t    VAR_2 != PSW_MASK_MERGE(VAR_6, VAR_2) &&\n#endif\n\t\t    VAR_2 != PSW_MASK_MERGE(VAR_7, VAR_2))\n\t\t\t/* COMMENT_3 */\n\t\t\treturn -VAR_8;\n#ifndef VAR_9\n\t\tif (VAR_1 == (addr_t) &VAR_3->regs.psw.addr)\n\t\t\t/* COMMENT_4 */\n                                                  \n\t\t\tVAR_2 |= VAR_10;\n#endif\n\t\t*(addr_t *)((addr_t) &task_pt_regs(VAR_0)->psw + VAR_1) = VAR_2;\n\n\t} else if (VAR_1 < (addr_t) (&VAR_3->regs.orig_gpr2)) {\n\t\t/* COMMENT_6 */\n                                                        \n     \n\t\tVAR_4 = VAR_1 - (addr_t) &VAR_3->regs.acrs;\n#ifdef VAR_9\n\t\t/* COMMENT_9 */\n                                                       \n                                                      \n                                                    \n                      \n     \n\t\tif (VAR_1 == (addr_t) &VAR_3->regs.acrs[15])\n\t\t\tVAR_0->thread.acrs[15] = (unsigned int) (VAR_2 >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &VAR_0->thread.acrs + VAR_4) = VAR_2;\n\n\t} else if (VAR_1 == (addr_t) &VAR_3->regs.orig_gpr2) {\n\t\t/* COMMENT_15 */\n                                            \n     \n\t\ttask_pt_regs(VAR_0)->orig_gpr2 = VAR_2;\n\n\t} else if (VAR_1 < (addr_t) &VAR_3->regs.fp_regs) {\n\t\t/* COMMENT_18 */\n                                           \n                                   \n     \n\t\treturn 0;\n\n\t} else if (VAR_1 < (addr_t) (&VAR_3->regs.fp_regs + 1)) {\n\t\t/* COMMENT_22 */\n                                                            \n     \n\t\tif (VAR_1 == (addr_t) &VAR_3->regs.fp_regs.fpc &&\n\t\t    (VAR_2 & ~((unsigned long) VAR_11\n\t\t\t      << (VAR_12 - 32))) != 0)\n\t\t\treturn -VAR_8;\n\t\tVAR_4 = VAR_1 - (addr_t) &VAR_3->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &VAR_0->thread.fp_regs + VAR_4) = VAR_2;\n\n\t} else if (VAR_1 < (addr_t) (&VAR_3->regs.per_info + 1)) {\n\t\t/* COMMENT_25 */\n                                               \n     \n\t\tVAR_4 = VAR_1 - (addr_t) &VAR_3->regs.per_info;\n\t\t*(addr_t *)((addr_t) &VAR_0->thread.per_info + VAR_4) = VAR_2;\n\n\t}\n\n\tFixPerRegisters(VAR_0);\n\treturn 0;\n}",
    "func_graph_path": "torvalds/linux/3d6e48f43340343d97839eadb1ab7b6a3ea98797/ptrace.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -46,6 +46,13 @@\n \t\t */\n \t\ttask_pt_regs(child)->orig_gpr2 = data;\n \n+\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n+\t\t/*\n+\t\t * prevent writes of padding hole between\n+\t\t * orig_gpr2 and fp_regs on s390.\n+\t\t */\n+\t\treturn 0;\n+\n \t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n \t\t/*\n \t\t * floating point regs. are stored in the thread structure",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {",
            "\t\t/*",
            "\t\t * prevent writes of padding hole between",
            "\t\t * orig_gpr2 and fp_regs on s390.",
            "\t\t */",
            "\t\treturn 0;",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}