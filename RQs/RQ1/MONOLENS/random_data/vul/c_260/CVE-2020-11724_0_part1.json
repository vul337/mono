{
    "cve_id": "CVE-2020-11724",
    "cwe_ids": [
        "CWE-444"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "openresty/lua-nginx-module",
    "commit_msg": "bugfix: prevented request smuggling in the ngx.location.capture API.\n\nSigned-off-by: Yichun Zhang (agentzh) <yichun@openresty.com>",
    "commit_hash": "9ab38e8ee35fc08a57636b1b6190dca70b0076fa",
    "git_url": "https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa",
    "file_path": "src/ngx_http_lua_subrequest.c",
    "func_name": "ngx_http_lua_adjust_subrequest",
    "func_before": "static ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_int_t                    rc;\n    ngx_http_core_main_conf_t   *cmcf;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n        rc = ngx_http_lua_set_content_length_header(sr,\n                                                    body->buf\n                                                    ? ngx_buf_size(body->buf)\n                                                    : 0);\n\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        rc = ngx_http_lua_set_content_length_header(sr, 0);\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n#if 1\n        sr->request_body = NULL;\n#endif\n\n    } else {\n        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (sr->request_body) {\n\n            /* deep-copy the request body */\n\n            if (sr->request_body->temp_file) {\n                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n            }\n        }\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}",
    "abstract_func_before": "static ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *VAR_0, ngx_uint_t VAR_1,\n    int VAR_2, ngx_http_request_body_t *VAR_3,\n    unsigned VAR_4, ngx_array_t *VAR_5)\n{\n    ngx_http_request_t          *VAR_6;\n    ngx_int_t                    VAR_7;\n    ngx_http_core_main_conf_t   *VAR_8;\n    size_t                       VAR_9;\n\n    VAR_6 = VAR_0->parent;\n\n    VAR_0->header_in = VAR_6->header_in;\n\n    if (VAR_3) {\n        VAR_0->request_body = VAR_3;\n\n        VAR_7 = ngx_http_lua_set_content_length_header(VAR_0,\n                                                    VAR_3->buf\n                                                    ? ngx_buf_size(VAR_3->buf)\n                                                    : 0);\n\n        if (VAR_7 != VAR_10) {\n            return VAR_11;\n        }\n\n    } else if (!VAR_2\n               && VAR_1 != VAR_12\n               && VAR_1 != VAR_13\n               && VAR_6->headers_in.content_length_n > 0)\n    {\n        VAR_7 = ngx_http_lua_set_content_length_header(VAR_0, 0);\n        if (VAR_7 != VAR_10) {\n            return VAR_11;\n        }\n\n#if 1\n        VAR_0->request_body = NULL;\n#endif\n\n    } else {\n        if (ngx_http_lua_copy_request_headers(VAR_0, VAR_6) != VAR_10) {\n            return VAR_11;\n        }\n\n        if (VAR_0->request_body) {\n\n            /* COMMENT_0 */\n\n            if (VAR_0->request_body->temp_file) {\n                if (ngx_http_lua_copy_in_file_request_body(VAR_0) != VAR_10) {\n                    return VAR_11;\n                }\n            }\n        }\n    }\n\n    VAR_0->method = VAR_1;\n\n    switch (VAR_1) {\n        case VAR_14:\n            VAR_0->method_name = VAR_15;\n            break;\n\n        case VAR_13:\n            VAR_0->method_name = VAR_16;\n            break;\n\n        case VAR_12:\n            VAR_0->method_name = VAR_17;\n            break;\n\n        case VAR_18:\n            VAR_0->method_name = VAR_19;\n            break;\n\n        case VAR_20:\n            VAR_0->method_name = VAR_21;\n            break;\n\n        case VAR_22:\n            VAR_0->method_name = VAR_23;\n            break;\n\n        case VAR_24:\n            VAR_0->method_name = VAR_25;\n            break;\n\n        case VAR_26:\n            VAR_0->method_name = VAR_27;\n            break;\n\n        case VAR_28:\n            VAR_0->method_name = VAR_29;\n            break;\n\n        case VAR_30:\n            VAR_0->method_name = VAR_31;\n            break;\n\n        case VAR_32:\n            VAR_0->method_name = VAR_33;\n            break;\n\n        case VAR_34:\n            VAR_0->method_name = VAR_35;\n            break;\n\n        case VAR_36:\n            VAR_0->method_name = VAR_37;\n            break;\n\n        case VAR_38:\n            VAR_0->method_name = VAR_39;\n            break;\n\n        case VAR_40:\n            VAR_0->method_name = VAR_41;\n            break;\n\n        default:\n            ngx_log_error(VAR_42, VAR_6->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) VAR_1);\n\n            return VAR_11;\n    }\n\n    if (!(VAR_4 & VAR_43)) {\n        /* COMMENT_1 */\n        VAR_8 = ngx_http_get_module_main_conf(VAR_0, VAR_44);\n\n        VAR_9 = VAR_8->variables.nelts * sizeof(VAR_45);\n\n        if (VAR_4 & VAR_46) {\n\n            VAR_0->variables = ngx_palloc(VAR_0->pool, VAR_9);\n            if (VAR_0->variables == NULL) {\n                return VAR_11;\n            }\n\n            ngx_memcpy(VAR_0->variables, VAR_6->variables, VAR_9);\n\n        } else {\n\n            /* COMMENT_1 */\n\n            VAR_0->variables = ngx_pcalloc(VAR_0->pool, VAR_9);\n            if (VAR_0->variables == NULL) {\n                return VAR_11;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(VAR_0, VAR_5);\n}",
    "func_graph_path_before": "openresty/lua-nginx-module/9ab38e8ee35fc08a57636b1b6190dca70b0076fa/ngx_http_lua_subrequest.c/vul/before/1.json",
    "func": "static ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_http_core_main_conf_t   *cmcf;\n    int                          pr_not_chunked = 0;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        sr->request_body = NULL;\n\n    } else {\n        if (!r->headers_in.chunked) {\n            pr_not_chunked = 1;\n        }\n\n        if (sr->request_body && sr->request_body->temp_file) {\n\n            /* deep-copy the request body */\n\n            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}",
    "abstract_func": "static ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *VAR_0, ngx_uint_t VAR_1,\n    int VAR_2, ngx_http_request_body_t *VAR_3,\n    unsigned VAR_4, ngx_array_t *VAR_5)\n{\n    ngx_http_request_t          *VAR_6;\n    ngx_http_core_main_conf_t   *VAR_7;\n    int                          VAR_8 = 0;\n    size_t                       VAR_9;\n\n    VAR_6 = VAR_0->parent;\n\n    VAR_0->header_in = VAR_6->header_in;\n\n    if (VAR_3) {\n        VAR_0->request_body = VAR_3;\n\n    } else if (!VAR_2\n               && VAR_1 != VAR_10\n               && VAR_1 != VAR_11\n               && VAR_6->headers_in.content_length_n > 0)\n    {\n        VAR_0->request_body = NULL;\n\n    } else {\n        if (!VAR_6->headers_in.chunked) {\n            VAR_8 = 1;\n        }\n\n        if (VAR_0->request_body && VAR_0->request_body->temp_file) {\n\n            /* COMMENT_0 */\n\n            if (ngx_http_lua_copy_in_file_request_body(VAR_0) != VAR_12) {\n                return VAR_13;\n            }\n        }\n    }\n\n    if (ngx_http_lua_copy_request_headers(VAR_0, VAR_6, VAR_8) != VAR_12) {\n        return VAR_13;\n    }\n\n    VAR_0->method = VAR_1;\n\n    switch (VAR_1) {\n        case VAR_14:\n            VAR_0->method_name = VAR_15;\n            break;\n\n        case VAR_11:\n            VAR_0->method_name = VAR_16;\n            break;\n\n        case VAR_10:\n            VAR_0->method_name = VAR_17;\n            break;\n\n        case VAR_18:\n            VAR_0->method_name = VAR_19;\n            break;\n\n        case VAR_20:\n            VAR_0->method_name = VAR_21;\n            break;\n\n        case VAR_22:\n            VAR_0->method_name = VAR_23;\n            break;\n\n        case VAR_24:\n            VAR_0->method_name = VAR_25;\n            break;\n\n        case VAR_26:\n            VAR_0->method_name = VAR_27;\n            break;\n\n        case VAR_28:\n            VAR_0->method_name = VAR_29;\n            break;\n\n        case VAR_30:\n            VAR_0->method_name = VAR_31;\n            break;\n\n        case VAR_32:\n            VAR_0->method_name = VAR_33;\n            break;\n\n        case VAR_34:\n            VAR_0->method_name = VAR_35;\n            break;\n\n        case VAR_36:\n            VAR_0->method_name = VAR_37;\n            break;\n\n        case VAR_38:\n            VAR_0->method_name = VAR_39;\n            break;\n\n        case VAR_40:\n            VAR_0->method_name = VAR_41;\n            break;\n\n        default:\n            ngx_log_error(VAR_42, VAR_6->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) VAR_1);\n\n            return VAR_13;\n    }\n\n    if (!(VAR_4 & VAR_43)) {\n        /* COMMENT_1 */\n        VAR_7 = ngx_http_get_module_main_conf(VAR_0, VAR_44);\n\n        VAR_9 = VAR_7->variables.nelts * sizeof(VAR_45);\n\n        if (VAR_4 & VAR_46) {\n\n            VAR_0->variables = ngx_palloc(VAR_0->pool, VAR_9);\n            if (VAR_0->variables == NULL) {\n                return VAR_13;\n            }\n\n            ngx_memcpy(VAR_0->variables, VAR_6->variables, VAR_9);\n\n        } else {\n\n            /* COMMENT_1 */\n\n            VAR_0->variables = ngx_pcalloc(VAR_0->pool, VAR_9);\n            if (VAR_0->variables == NULL) {\n                return VAR_13;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(VAR_0, VAR_5);\n}",
    "func_graph_path": "openresty/lua-nginx-module/9ab38e8ee35fc08a57636b1b6190dca70b0076fa/ngx_http_lua_subrequest.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,8 @@\n     unsigned vars_action, ngx_array_t *extra_vars)\n {\n     ngx_http_request_t          *r;\n-    ngx_int_t                    rc;\n     ngx_http_core_main_conf_t   *cmcf;\n+    int                          pr_not_chunked = 0;\n     size_t                       size;\n \n     r = sr->parent;\n@@ -15,44 +15,30 @@\n     if (body) {\n         sr->request_body = body;\n \n-        rc = ngx_http_lua_set_content_length_header(sr,\n-                                                    body->buf\n-                                                    ? ngx_buf_size(body->buf)\n-                                                    : 0);\n-\n-        if (rc != NGX_OK) {\n-            return NGX_ERROR;\n-        }\n-\n     } else if (!always_forward_body\n                && method != NGX_HTTP_PUT\n                && method != NGX_HTTP_POST\n                && r->headers_in.content_length_n > 0)\n     {\n-        rc = ngx_http_lua_set_content_length_header(sr, 0);\n-        if (rc != NGX_OK) {\n-            return NGX_ERROR;\n+        sr->request_body = NULL;\n+\n+    } else {\n+        if (!r->headers_in.chunked) {\n+            pr_not_chunked = 1;\n         }\n \n-#if 1\n-        sr->request_body = NULL;\n-#endif\n-\n-    } else {\n-        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {\n-            return NGX_ERROR;\n-        }\n-\n-        if (sr->request_body) {\n+        if (sr->request_body && sr->request_body->temp_file) {\n \n             /* deep-copy the request body */\n \n-            if (sr->request_body->temp_file) {\n-                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n-                    return NGX_ERROR;\n-                }\n+            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n+                return NGX_ERROR;\n             }\n         }\n+    }\n+\n+    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {\n+        return NGX_ERROR;\n     }\n \n     sr->method = method;",
    "diff_line_info": {
        "deleted_lines": [
            "    ngx_int_t                    rc;",
            "        rc = ngx_http_lua_set_content_length_header(sr,",
            "                                                    body->buf",
            "                                                    ? ngx_buf_size(body->buf)",
            "                                                    : 0);",
            "",
            "        if (rc != NGX_OK) {",
            "            return NGX_ERROR;",
            "        }",
            "",
            "        rc = ngx_http_lua_set_content_length_header(sr, 0);",
            "        if (rc != NGX_OK) {",
            "            return NGX_ERROR;",
            "#if 1",
            "        sr->request_body = NULL;",
            "#endif",
            "",
            "    } else {",
            "        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {",
            "            return NGX_ERROR;",
            "        }",
            "",
            "        if (sr->request_body) {",
            "            if (sr->request_body->temp_file) {",
            "                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {",
            "                    return NGX_ERROR;",
            "                }"
        ],
        "added_lines": [
            "    int                          pr_not_chunked = 0;",
            "        sr->request_body = NULL;",
            "",
            "    } else {",
            "        if (!r->headers_in.chunked) {",
            "            pr_not_chunked = 1;",
            "        if (sr->request_body && sr->request_body->temp_file) {",
            "            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {",
            "                return NGX_ERROR;",
            "    }",
            "",
            "    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {",
            "        return NGX_ERROR;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}