{
    "cve_id": "CVE-2011-1080",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "bridge: netfilter: fix information leak\n\nStruct tmp is copied from userspace.  It is not checked whether the \"name\"\nfield is NULL terminated.  This may lead to buffer overflow and passing\ncontents of kernel stack as a module name to try_then_request_module() and,\nconsequently, to modprobe commandline.  It would be seen by all userspace\nprocesses.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>",
    "commit_hash": "d846f71195d57b0bbb143382647c2c6638b04c5a",
    "git_url": "https://github.com/torvalds/linux/commit/d846f71195d57b0bbb143382647c2c6638b04c5a",
    "file_path": "net/bridge/netfilter/ebtables.c",
    "func_name": "do_replace",
    "func_before": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* overflow check */\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}",
    "abstract_func_before": "static int do_replace(struct net *net, const void __user *VAR_0,\n\t\t      unsigned int VAR_1)\n{\n\tint VAR_2, VAR_3;\n\tstruct ebt_table_info *VAR_4;\n\tstruct ebt_replace VAR_5;\n\n\tif (copy_from_user(&VAR_5, VAR_0, sizeof(VAR_5)) != 0)\n\t\treturn -VAR_6;\n\n\tif (VAR_1 != sizeof(VAR_5) + VAR_5.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -VAR_7;\n\t}\n\n\tif (VAR_5.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -VAR_7;\n\t}\n\t/* COMMENT_0 */\n\tif (VAR_5.nentries >= ((VAR_8 - sizeof(struct ebt_table_info)) /\n\t\t\tVAR_9 - VAR_10) / sizeof(struct ebt_counter))\n\t\treturn -VAR_11;\n\tif (VAR_5.num_counters >= VAR_8 / sizeof(struct ebt_counter))\n\t\treturn -VAR_11;\n\n\tVAR_3 = COUNTER_OFFSET(VAR_5.nentries) * VAR_12;\n\tVAR_4 = vmalloc(sizeof(*VAR_4) + VAR_3);\n\tif (!VAR_4)\n\t\treturn -VAR_11;\n\n\tif (VAR_3)\n\t\tmemset(VAR_4->counters, 0, VAR_3);\n\n\tVAR_4->entries = vmalloc(VAR_5.entries_size);\n\tif (!VAR_4->entries) {\n\t\tVAR_2 = -VAR_11;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   VAR_4->entries, VAR_5.entries, VAR_5.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tVAR_2 = -VAR_6;\n\t\tgoto free_entries;\n\t}\n\n\tVAR_2 = do_replace_finish(net, &VAR_5, VAR_4);\n\tif (VAR_2 == 0)\n\t\treturn VAR_2;\nfree_entries:\n\tvfree(VAR_4->entries);\nfree_newinfo:\n\tvfree(VAR_4);\n\treturn VAR_2;\n}",
    "func_graph_path_before": null,
    "func": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* overflow check */\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}",
    "abstract_func": "static int do_replace(struct net *net, const void __user *VAR_0,\n\t\t      unsigned int VAR_1)\n{\n\tint VAR_2, VAR_3;\n\tstruct ebt_table_info *VAR_4;\n\tstruct ebt_replace VAR_5;\n\n\tif (copy_from_user(&VAR_5, VAR_0, sizeof(VAR_5)) != 0)\n\t\treturn -VAR_6;\n\n\tif (VAR_1 != sizeof(VAR_5) + VAR_5.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -VAR_7;\n\t}\n\n\tif (VAR_5.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -VAR_7;\n\t}\n\t/* COMMENT_0 */\n\tif (VAR_5.nentries >= ((VAR_8 - sizeof(struct ebt_table_info)) /\n\t\t\tVAR_9 - VAR_10) / sizeof(struct ebt_counter))\n\t\treturn -VAR_11;\n\tif (VAR_5.num_counters >= VAR_8 / sizeof(struct ebt_counter))\n\t\treturn -VAR_11;\n\n\tVAR_5.name[sizeof(VAR_5.name) - 1] = 0;\n\n\tVAR_3 = COUNTER_OFFSET(VAR_5.nentries) * VAR_12;\n\tVAR_4 = vmalloc(sizeof(*VAR_4) + VAR_3);\n\tif (!VAR_4)\n\t\treturn -VAR_11;\n\n\tif (VAR_3)\n\t\tmemset(VAR_4->counters, 0, VAR_3);\n\n\tVAR_4->entries = vmalloc(VAR_5.entries_size);\n\tif (!VAR_4->entries) {\n\t\tVAR_2 = -VAR_11;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   VAR_4->entries, VAR_5.entries, VAR_5.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tVAR_2 = -VAR_6;\n\t\tgoto free_entries;\n\t}\n\n\tVAR_2 = do_replace_finish(net, &VAR_5, VAR_4);\n\tif (VAR_2 == 0)\n\t\treturn VAR_2;\nfree_entries:\n\tvfree(VAR_4->entries);\nfree_newinfo:\n\tvfree(VAR_4);\n\treturn VAR_2;\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,8 @@\n \t\treturn -ENOMEM;\n \tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n \t\treturn -ENOMEM;\n+\n+\ttmp.name[sizeof(tmp.name) - 1] = 0;\n \n \tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n \tnewinfo = vmalloc(sizeof(*newinfo) + countersize);",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "",
            "\ttmp.name[sizeof(tmp.name) - 1] = 0;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}