{
    "cve_id": "CVE-2014-0146",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "qemu",
    "commit_msg": "qcow2: Fix NULL dereference in qcow2_open() error path (CVE-2014-0146)\n\nThe qcow2 code assumes that s->snapshots is non-NULL if s->nb_snapshots\n!= 0. By having the initialisation of both fields separated in\nqcow2_open(), any error occuring in between would cause the error path\nto dereference NULL in qcow2_free_snapshots() if the image had any\nsnapshots.\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>",
    "commit_hash": "11b128f4062dd7f89b14abc8877ff20d41b28be9",
    "git_url": "https://github.com/qemu/qemu/commit/11b128f4062dd7f89b14abc8877ff20d41b28be9",
    "file_path": "block/qcow2.c",
    "func_name": "qcow2_open",
    "func_before": "static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVQcowState *s = bs->opaque;\n    unsigned int len, i;\n    int ret = 0;\n    QCowHeader header;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    uint64_t ext_end;\n    uint64_t l1_vm_state_index;\n    const char *opt_overlap_check;\n    int overlap_check_template = 0;\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read qcow2 header\");\n        goto fail;\n    }\n    be32_to_cpus(&header.magic);\n    be32_to_cpus(&header.version);\n    be64_to_cpus(&header.backing_file_offset);\n    be32_to_cpus(&header.backing_file_size);\n    be64_to_cpus(&header.size);\n    be32_to_cpus(&header.cluster_bits);\n    be32_to_cpus(&header.crypt_method);\n    be64_to_cpus(&header.l1_table_offset);\n    be32_to_cpus(&header.l1_size);\n    be64_to_cpus(&header.refcount_table_offset);\n    be32_to_cpus(&header.refcount_table_clusters);\n    be64_to_cpus(&header.snapshots_offset);\n    be32_to_cpus(&header.nb_snapshots);\n\n    if (header.magic != QCOW_MAGIC) {\n        error_setg(errp, \"Image is not in qcow2 format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    if (header.version < 2 || header.version > 3) {\n        report_unsupported(bs, errp, \"QCOW version %d\", header.version);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n\n    s->qcow_version = header.version;\n\n    /* Initialise cluster size */\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n        error_setg(errp, \"Unsupported cluster size: 2^%i\", header.cluster_bits);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->cluster_bits = header.cluster_bits;\n    s->cluster_size = 1 << s->cluster_bits;\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    /* Initialise version 3 header fields */\n    if (header.version == 2) {\n        header.incompatible_features    = 0;\n        header.compatible_features      = 0;\n        header.autoclear_features       = 0;\n        header.refcount_order           = 4;\n        header.header_length            = 72;\n    } else {\n        be64_to_cpus(&header.incompatible_features);\n        be64_to_cpus(&header.compatible_features);\n        be64_to_cpus(&header.autoclear_features);\n        be32_to_cpus(&header.refcount_order);\n        be32_to_cpus(&header.header_length);\n\n        if (header.header_length < 104) {\n            error_setg(errp, \"qcow2 header too short\");\n            ret = -EINVAL;\n            goto fail;\n        }\n    }\n\n    if (header.header_length > s->cluster_size) {\n        error_setg(errp, \"qcow2 header exceeds cluster size\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.header_length > sizeof(header)) {\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n                         s->unknown_header_fields_size);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read unknown qcow2 header \"\n                             \"fields\");\n            goto fail;\n        }\n    }\n\n    if (header.backing_file_offset > s->cluster_size) {\n        error_setg(errp, \"Invalid backing file offset\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.backing_file_offset) {\n        ext_end = header.backing_file_offset;\n    } else {\n        ext_end = 1 << header.cluster_bits;\n    }\n\n    /* Handle feature bits */\n    s->incompatible_features    = header.incompatible_features;\n    s->compatible_features      = header.compatible_features;\n    s->autoclear_features       = header.autoclear_features;\n\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n        void *feature_table = NULL;\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n                              &feature_table, NULL);\n        report_unsupported_feature(bs, errp, feature_table,\n                                   s->incompatible_features &\n                                   ~QCOW2_INCOMPAT_MASK);\n        ret = -ENOTSUP;\n        g_free(feature_table);\n        goto fail;\n    }\n\n    if (s->incompatible_features & QCOW2_INCOMPAT_CORRUPT) {\n        /* Corrupt images may not be written to unless they are being repaired\n         */\n        if ((flags & BDRV_O_RDWR) && !(flags & BDRV_O_CHECK)) {\n            error_setg(errp, \"qcow2: Image is corrupt; cannot be opened \"\n                       \"read/write\");\n            ret = -EACCES;\n            goto fail;\n        }\n    }\n\n    /* Check support for various header values */\n    if (header.refcount_order != 4) {\n        report_unsupported(bs, errp, \"%d bit reference counts\",\n                           1 << header.refcount_order);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n    s->refcount_order = header.refcount_order;\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n        error_setg(errp, \"Unsupported encryption method: %i\",\n                   header.crypt_method);\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->crypt_method_header = header.crypt_method;\n    if (s->crypt_method_header) {\n        bs->encrypted = 1;\n    }\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n    s->l2_size = 1 << s->l2_bits;\n    bs->total_sectors = header.size / 512;\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n    s->refcount_table_size =\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n    if (header.refcount_table_clusters > qcow2_max_refcount_clusters(s)) {\n        error_setg(errp, \"Reference count table too large\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, s->refcount_table_offset,\n                                s->refcount_table_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid reference count table offset\");\n        goto fail;\n    }\n\n    /* Snapshot table offset/length */\n    if (header.nb_snapshots > QCOW_MAX_SNAPSHOTS) {\n        error_setg(errp, \"Too many snapshots\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.snapshots_offset,\n                                header.nb_snapshots,\n                                sizeof(QCowSnapshotHeader));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid snapshot table offset\");\n        goto fail;\n    }\n\n    s->snapshots_offset = header.snapshots_offset;\n    s->nb_snapshots = header.nb_snapshots;\n\n    /* read the level 1 table */\n    if (header.l1_size > 0x2000000) {\n        /* 32 MB L1 table is enough for 2 PB images at 64k cluster size\n         * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */\n        error_setg(errp, \"Active L1 table too large\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_size = header.l1_size;\n\n    l1_vm_state_index = size_to_l1(s, header.size);\n    if (l1_vm_state_index > INT_MAX) {\n        error_setg(errp, \"Image is too big\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_vm_state_index = l1_vm_state_index;\n\n    /* the L1 table must contain at least enough entries to put\n       header.size bytes */\n    if (s->l1_size < s->l1_vm_state_index) {\n        error_setg(errp, \"L1 table is too small\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.l1_table_offset,\n                                header.l1_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid L1 table offset\");\n        goto fail;\n    }\n    s->l1_table_offset = header.l1_table_offset;\n\n\n    if (s->l1_size > 0) {\n        s->l1_table = g_malloc0(\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n                         s->l1_size * sizeof(uint64_t));\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read L1 table\");\n            goto fail;\n        }\n        for(i = 0;i < s->l1_size; i++) {\n            be64_to_cpus(&s->l1_table[i]);\n        }\n    }\n\n    /* alloc L2 table/refcount block cache */\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n    /* one more sector for decompressed data alignment */\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n                                  + 512);\n    s->cluster_cache_offset = -1;\n    s->flags = flags;\n\n    ret = qcow2_refcount_init(bs);\n    if (ret != 0) {\n        error_setg_errno(errp, -ret, \"Could not initialize refcount handling\");\n        goto fail;\n    }\n\n    QLIST_INIT(&s->cluster_allocs);\n    QTAILQ_INIT(&s->discards);\n\n    /* read qcow2 extensions */\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,\n        &local_err)) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    /* read the backing file name */\n    if (header.backing_file_offset != 0) {\n        len = header.backing_file_size;\n        if (len > MIN(1023, s->cluster_size - header.backing_file_offset)) {\n            error_setg(errp, \"Backing file name too long\");\n            ret = -EINVAL;\n            goto fail;\n        }\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n                         bs->backing_file, len);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read backing file name\");\n            goto fail;\n        }\n        bs->backing_file[len] = '\\0';\n    }\n\n    ret = qcow2_read_snapshots(bs);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read snapshots\");\n        goto fail;\n    }\n\n    /* Clear unknown autoclear feature bits */\n    if (!bs->read_only && !(flags & BDRV_O_INCOMING) && s->autoclear_features) {\n        s->autoclear_features = 0;\n        ret = qcow2_update_header(bs);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not update qcow2 header\");\n            goto fail;\n        }\n    }\n\n    /* Initialise locks */\n    qemu_co_mutex_init(&s->lock);\n\n    /* Repair image if dirty */\n    if (!(flags & (BDRV_O_CHECK | BDRV_O_INCOMING)) && !bs->read_only &&\n        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {\n        BdrvCheckResult result = {0};\n\n        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not repair dirty image\");\n            goto fail;\n        }\n    }\n\n    /* Enable lazy_refcounts according to image and command line options */\n    opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,\n        (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));\n\n    s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;\n    s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;\n    s->discard_passthrough[QCOW2_DISCARD_REQUEST] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,\n                          flags & BDRV_O_UNMAP);\n    s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);\n    s->discard_passthrough[QCOW2_DISCARD_OTHER] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);\n\n    opt_overlap_check = qemu_opt_get(opts, \"overlap-check\") ?: \"cached\";\n    if (!strcmp(opt_overlap_check, \"none\")) {\n        overlap_check_template = 0;\n    } else if (!strcmp(opt_overlap_check, \"constant\")) {\n        overlap_check_template = QCOW2_OL_CONSTANT;\n    } else if (!strcmp(opt_overlap_check, \"cached\")) {\n        overlap_check_template = QCOW2_OL_CACHED;\n    } else if (!strcmp(opt_overlap_check, \"all\")) {\n        overlap_check_template = QCOW2_OL_ALL;\n    } else {\n        error_setg(errp, \"Unsupported value '%s' for qcow2 option \"\n                   \"'overlap-check'. Allowed are either of the following: \"\n                   \"none, constant, cached, all\", opt_overlap_check);\n        qemu_opts_del(opts);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->overlap_check = 0;\n    for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n        /* overlap-check defines a template bitmask, but every flag may be\n         * overwritten through the associated boolean option */\n        s->overlap_check |=\n            qemu_opt_get_bool(opts, overlap_bool_option_names[i],\n                              overlap_check_template & (1 << i)) << i;\n    }\n\n    qemu_opts_del(opts);\n\n    if (s->use_lazy_refcounts && s->qcow_version < 3) {\n        error_setg(errp, \"Lazy refcounts require a qcow2 image with at least \"\n                   \"qemu 1.1 compatibility level\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n#ifdef DEBUG_ALLOC\n    {\n        BdrvCheckResult result = {0};\n        qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return ret;\n\n fail:\n    g_free(s->unknown_header_fields);\n    cleanup_unknown_header_ext(bs);\n    qcow2_free_snapshots(bs);\n    qcow2_refcount_close(bs);\n    g_free(s->l1_table);\n    /* else pre-write overlap checks in cache_destroy may crash */\n    s->l1_table = NULL;\n    if (s->l2_table_cache) {\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n    }\n    if (s->refcount_block_cache) {\n        qcow2_cache_destroy(bs, s->refcount_block_cache);\n    }\n    g_free(s->cluster_cache);\n    qemu_vfree(s->cluster_data);\n    return ret;\n}",
    "abstract_func_before": "static int qcow2_open(BlockDriverState *VAR_0, QDict *VAR_1, int VAR_2,\n                      Error **VAR_3)\n{\n    BDRVQcowState *VAR_4 = VAR_0->opaque;\n    unsigned int VAR_5, VAR_6;\n    int VAR_7 = 0;\n    QCowHeader VAR_8;\n    QemuOpts *VAR_9;\n    Error *VAR_10 = NULL;\n    uint64_t VAR_11;\n    uint64_t VAR_12;\n    const char *VAR_13;\n    int VAR_14 = 0;\n\n    VAR_7 = bdrv_pread(VAR_0->file, 0, &VAR_8, sizeof(VAR_8));\n    if (VAR_7 < 0) {\n        error_setg_errno(VAR_3, -VAR_7, \"Could not read qcow2 header\");\n        goto fail;\n    }\n    be32_to_cpus(&VAR_8.magic);\n    be32_to_cpus(&VAR_8.version);\n    be64_to_cpus(&VAR_8.backing_file_offset);\n    be32_to_cpus(&VAR_8.backing_file_size);\n    be64_to_cpus(&VAR_8.size);\n    be32_to_cpus(&VAR_8.cluster_bits);\n    be32_to_cpus(&VAR_8.crypt_method);\n    be64_to_cpus(&VAR_8.l1_table_offset);\n    be32_to_cpus(&VAR_8.l1_size);\n    be64_to_cpus(&VAR_8.refcount_table_offset);\n    be32_to_cpus(&VAR_8.refcount_table_clusters);\n    be64_to_cpus(&VAR_8.snapshots_offset);\n    be32_to_cpus(&VAR_8.nb_snapshots);\n\n    if (VAR_8.magic != VAR_15) {\n        error_setg(VAR_3, \"Image is not in qcow2 format\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n    if (VAR_8.version < 2 || VAR_8.version > 3) {\n        report_unsupported(VAR_0, VAR_3, \"QCOW version %d\", VAR_8.version);\n        VAR_7 = -VAR_17;\n        goto fail;\n    }\n\n    VAR_4->qcow_version = VAR_8.version;\n\n    /* COMMENT_0 */\n    if (VAR_8.cluster_bits < VAR_18 ||\n        VAR_8.cluster_bits > VAR_19) {\n        error_setg(VAR_3, \"Unsupported cluster size: 2^%i\", VAR_8.cluster_bits);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_4->cluster_bits = VAR_8.cluster_bits;\n    VAR_4->cluster_size = 1 << VAR_4->cluster_bits;\n    VAR_4->cluster_sectors = 1 << (VAR_4->cluster_bits - 9);\n\n    /* COMMENT_1 */\n    if (VAR_8.version == 2) {\n        VAR_8.incompatible_features    = 0;\n        VAR_8.compatible_features      = 0;\n        VAR_8.autoclear_features       = 0;\n        VAR_8.refcount_order           = 4;\n        VAR_8.header_length            = 72;\n    } else {\n        be64_to_cpus(&VAR_8.incompatible_features);\n        be64_to_cpus(&VAR_8.compatible_features);\n        be64_to_cpus(&VAR_8.autoclear_features);\n        be32_to_cpus(&VAR_8.refcount_order);\n        be32_to_cpus(&VAR_8.header_length);\n\n        if (VAR_8.header_length < 104) {\n            error_setg(VAR_3, \"qcow2 header too short\");\n            VAR_7 = -VAR_16;\n            goto fail;\n        }\n    }\n\n    if (VAR_8.header_length > VAR_4->cluster_size) {\n        error_setg(VAR_3, \"qcow2 header exceeds cluster size\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    if (VAR_8.header_length > sizeof(VAR_8)) {\n        VAR_4->unknown_header_fields_size = VAR_8.header_length - sizeof(VAR_8);\n        VAR_4->unknown_header_fields = g_malloc(VAR_4->unknown_header_fields_size);\n        VAR_7 = bdrv_pread(VAR_0->file, sizeof(VAR_8), VAR_4->unknown_header_fields,\n                         VAR_4->unknown_header_fields_size);\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not read unknown qcow2 header \"\n                             \"fields\");\n            goto fail;\n        }\n    }\n\n    if (VAR_8.backing_file_offset > VAR_4->cluster_size) {\n        error_setg(VAR_3, \"Invalid backing file offset\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    if (VAR_8.backing_file_offset) {\n        VAR_11 = VAR_8.backing_file_offset;\n    } else {\n        VAR_11 = 1 << VAR_8.cluster_bits;\n    }\n\n    /* COMMENT_2 */\n    VAR_4->incompatible_features    = VAR_8.incompatible_features;\n    VAR_4->compatible_features      = VAR_8.compatible_features;\n    VAR_4->autoclear_features       = VAR_8.autoclear_features;\n\n    if (VAR_4->incompatible_features & ~VAR_20) {\n        void *VAR_21 = NULL;\n        qcow2_read_extensions(VAR_0, VAR_8.header_length, VAR_11,\n                              &VAR_21, NULL);\n        report_unsupported_feature(VAR_0, VAR_3, VAR_21,\n                                   VAR_4->incompatible_features &\n                                   ~VAR_20);\n        VAR_7 = -VAR_17;\n        g_free(VAR_21);\n        goto fail;\n    }\n\n    if (VAR_4->incompatible_features & VAR_22) {\n        /* COMMENT_3 */\n           \n        if ((VAR_2 & VAR_23) && !(VAR_2 & VAR_24)) {\n            error_setg(VAR_3, \"qcow2: Image is corrupt; cannot be opened \"\n                       \"read/write\");\n            VAR_7 = -VAR_25;\n            goto fail;\n        }\n    }\n\n    /* COMMENT_5 */\n    if (VAR_8.refcount_order != 4) {\n        report_unsupported(VAR_0, VAR_3, \"%d bit reference counts\",\n                           1 << VAR_8.refcount_order);\n        VAR_7 = -VAR_17;\n        goto fail;\n    }\n    VAR_4->refcount_order = VAR_8.refcount_order;\n\n    if (VAR_8.crypt_method > VAR_26) {\n        error_setg(VAR_3, \"Unsupported encryption method: %i\",\n                   VAR_8.crypt_method);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n    VAR_4->crypt_method_header = VAR_8.crypt_method;\n    if (VAR_4->crypt_method_header) {\n        VAR_0->encrypted = 1;\n    }\n\n    VAR_4->l2_bits = VAR_4->cluster_bits - 3; /* COMMENT_6 */\n    VAR_4->l2_size = 1 << VAR_4->l2_bits;\n    VAR_0->total_sectors = VAR_8.size / 512;\n    VAR_4->csize_shift = (62 - (VAR_4->cluster_bits - 8));\n    VAR_4->csize_mask = (1 << (VAR_4->cluster_bits - 8)) - 1;\n    VAR_4->cluster_offset_mask = (1LL << VAR_4->csize_shift) - 1;\n\n    VAR_4->refcount_table_offset = VAR_8.refcount_table_offset;\n    VAR_4->refcount_table_size =\n        VAR_8.refcount_table_clusters << (VAR_4->cluster_bits - 3);\n\n    if (VAR_8.refcount_table_clusters > qcow2_max_refcount_clusters(VAR_4)) {\n        error_setg(VAR_3, \"Reference count table too large\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_7 = validate_table_offset(VAR_0, VAR_4->refcount_table_offset,\n                                VAR_4->refcount_table_size, sizeof(uint64_t));\n    if (VAR_7 < 0) {\n        error_setg(VAR_3, \"Invalid reference count table offset\");\n        goto fail;\n    }\n\n    /* COMMENT_7 */\n    if (VAR_8.nb_snapshots > VAR_27) {\n        error_setg(VAR_3, \"Too many snapshots\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_7 = validate_table_offset(VAR_0, VAR_8.snapshots_offset,\n                                VAR_8.nb_snapshots,\n                                sizeof(VAR_28));\n    if (VAR_7 < 0) {\n        error_setg(VAR_3, \"Invalid snapshot table offset\");\n        goto fail;\n    }\n\n    VAR_4->snapshots_offset = VAR_8.snapshots_offset;\n    VAR_4->nb_snapshots = VAR_8.nb_snapshots;\n\n    /* COMMENT_8 */\n    if (VAR_8.l1_size > 0x2000000) {\n        /* COMMENT_9 */\n                                                                    \n        error_setg(VAR_3, \"Active L1 table too large\");\n        VAR_7 = -VAR_29;\n        goto fail;\n    }\n    VAR_4->l1_size = VAR_8.l1_size;\n\n    VAR_12 = size_to_l1(VAR_4, VAR_8.size);\n    if (VAR_12 > VAR_30) {\n        error_setg(VAR_3, \"Image is too big\");\n        VAR_7 = -VAR_29;\n        goto fail;\n    }\n    VAR_4->l1_vm_state_index = VAR_12;\n\n    /* COMMENT_11 */\n                           \n    if (VAR_4->l1_size < VAR_4->l1_vm_state_index) {\n        error_setg(VAR_3, \"L1 table is too small\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_7 = validate_table_offset(VAR_0, VAR_8.l1_table_offset,\n                                VAR_8.l1_size, sizeof(uint64_t));\n    if (VAR_7 < 0) {\n        error_setg(VAR_3, \"Invalid L1 table offset\");\n        goto fail;\n    }\n    VAR_4->l1_table_offset = VAR_8.l1_table_offset;\n\n\n    if (VAR_4->l1_size > 0) {\n        VAR_4->l1_table = g_malloc0(\n            align_offset(VAR_4->l1_size * sizeof(uint64_t), 512));\n        VAR_7 = bdrv_pread(VAR_0->file, VAR_4->l1_table_offset, VAR_4->l1_table,\n                         VAR_4->l1_size * sizeof(uint64_t));\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not read L1 table\");\n            goto fail;\n        }\n        for(VAR_6 = 0;VAR_6 < VAR_4->l1_size; VAR_6++) {\n            be64_to_cpus(&VAR_4->l1_table[VAR_6]);\n        }\n    }\n\n    /* COMMENT_13 */\n    VAR_4->l2_table_cache = qcow2_cache_create(VAR_0, VAR_31);\n    VAR_4->refcount_block_cache = qcow2_cache_create(VAR_0, VAR_32);\n\n    VAR_4->cluster_cache = g_malloc(VAR_4->cluster_size);\n    /* COMMENT_14 */\n    VAR_4->cluster_data = qemu_blockalign(VAR_0, VAR_33 * VAR_4->cluster_size\n                                  + 512);\n    VAR_4->cluster_cache_offset = -1;\n    VAR_4->flags = VAR_2;\n\n    VAR_7 = qcow2_refcount_init(VAR_0);\n    if (VAR_7 != 0) {\n        error_setg_errno(VAR_3, -VAR_7, \"Could not initialize refcount handling\");\n        goto fail;\n    }\n\n    QLIST_INIT(&VAR_4->cluster_allocs);\n    QTAILQ_INIT(&VAR_4->discards);\n\n    /* COMMENT_15 */\n    if (qcow2_read_extensions(VAR_0, VAR_8.header_length, VAR_11, NULL,\n        &VAR_10)) {\n        error_propagate(VAR_3, VAR_10);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    /* COMMENT_16 */\n    if (VAR_8.backing_file_offset != 0) {\n        VAR_5 = VAR_8.backing_file_size;\n        if (VAR_5 > MIN(1023, VAR_4->cluster_size - VAR_8.backing_file_offset)) {\n            error_setg(VAR_3, \"Backing file name too long\");\n            VAR_7 = -VAR_16;\n            goto fail;\n        }\n        VAR_7 = bdrv_pread(VAR_0->file, VAR_8.backing_file_offset,\n                         VAR_0->backing_file, VAR_5);\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not read backing file name\");\n            goto fail;\n        }\n        VAR_0->backing_file[VAR_5] = '\\0';\n    }\n\n    VAR_7 = qcow2_read_snapshots(VAR_0);\n    if (VAR_7 < 0) {\n        error_setg_errno(VAR_3, -VAR_7, \"Could not read snapshots\");\n        goto fail;\n    }\n\n    /* COMMENT_17 */\n    if (!VAR_0->read_only && !(VAR_2 & VAR_34) && VAR_4->autoclear_features) {\n        VAR_4->autoclear_features = 0;\n        VAR_7 = qcow2_update_header(VAR_0);\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not update qcow2 header\");\n            goto fail;\n        }\n    }\n\n    /* COMMENT_18 */\n    qemu_co_mutex_init(&VAR_4->lock);\n\n    /* COMMENT_19 */\n    if (!(VAR_2 & (VAR_24 | VAR_34)) && !VAR_0->read_only &&\n        (VAR_4->incompatible_features & VAR_35)) {\n        BdrvCheckResult VAR_36 = {0};\n\n        VAR_7 = qcow2_check(VAR_0, &VAR_36, VAR_37);\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not repair dirty image\");\n            goto fail;\n        }\n    }\n\n    /* COMMENT_20 */\n    VAR_9 = qemu_opts_create(&VAR_38, NULL, 0, &VAR_39);\n    qemu_opts_absorb_qdict(VAR_9, VAR_1, &VAR_10);\n    if (VAR_10) {\n        error_propagate(VAR_3, VAR_10);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_4->use_lazy_refcounts = qemu_opt_get_bool(VAR_9, VAR_40,\n        (VAR_4->compatible_features & VAR_41));\n\n    VAR_4->discard_passthrough[VAR_42] = false;\n    VAR_4->discard_passthrough[VAR_43] = true;\n    VAR_4->discard_passthrough[VAR_44] =\n        qemu_opt_get_bool(VAR_9, VAR_45,\n                          VAR_2 & VAR_46);\n    VAR_4->discard_passthrough[VAR_47] =\n        qemu_opt_get_bool(VAR_9, VAR_48, true);\n    VAR_4->discard_passthrough[VAR_49] =\n        qemu_opt_get_bool(VAR_9, VAR_50, false);\n\n    VAR_13 = qemu_opt_get(VAR_9, \"overlap-check\") ?VAR_51: \"cached\";\n    if (!strcmp(VAR_13, \"none\")) {\n        VAR_14 = 0;\n    } else if (!strcmp(VAR_13, \"constant\")) {\n        VAR_14 = VAR_52;\n    } else if (!strcmp(VAR_13, \"cached\")) {\n        VAR_14 = VAR_53;\n    } else if (!strcmp(VAR_13, \"all\")) {\n        VAR_14 = VAR_54;\n    } else {\n        error_setg(VAR_3, \"Unsupported value '%s' for qcow2 option \"\n                   \"'overlap-check'. Allowed are either of the following: \"\n                   \"none, constant, cached, all\", VAR_13);\n        qemu_opts_del(VAR_9);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_4->overlap_check = 0;\n    for (VAR_6 = 0; VAR_6 < VAR_55; VAR_6++) {\n        /* COMMENT_21 */\n                                                               \n        VAR_4->overlap_check |=\n            qemu_opt_get_bool(VAR_9, VAR_56[VAR_6],\n                              VAR_14 & (1 << VAR_6)) << VAR_6;\n    }\n\n    qemu_opts_del(VAR_9);\n\n    if (VAR_4->use_lazy_refcounts && VAR_4->qcow_version < 3) {\n        error_setg(VAR_3, \"Lazy refcounts require a qcow2 image with at least \"\n                   \"qemu 1.1 compatibility level\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n#ifdef VAR_57\n    {\n        BdrvCheckResult VAR_36 = {0};\n        qcow2_check_refcounts(VAR_0, &VAR_36, 0);\n    }\n#endif\n    return VAR_7;\n\n fail:\n    g_free(VAR_4->unknown_header_fields);\n    cleanup_unknown_header_ext(VAR_0);\n    qcow2_free_snapshots(VAR_0);\n    qcow2_refcount_close(VAR_0);\n    g_free(VAR_4->l1_table);\n    /* COMMENT_23 */\n    VAR_4->l1_table = NULL;\n    if (VAR_4->l2_table_cache) {\n        qcow2_cache_destroy(VAR_0, VAR_4->l2_table_cache);\n    }\n    if (VAR_4->refcount_block_cache) {\n        qcow2_cache_destroy(VAR_0, VAR_4->refcount_block_cache);\n    }\n    g_free(VAR_4->cluster_cache);\n    qemu_vfree(VAR_4->cluster_data);\n    return VAR_7;\n}",
    "func_graph_path_before": "qemu/11b128f4062dd7f89b14abc8877ff20d41b28be9/qcow2.c/vul/before/0.json",
    "func": "static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVQcowState *s = bs->opaque;\n    unsigned int len, i;\n    int ret = 0;\n    QCowHeader header;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    uint64_t ext_end;\n    uint64_t l1_vm_state_index;\n    const char *opt_overlap_check;\n    int overlap_check_template = 0;\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read qcow2 header\");\n        goto fail;\n    }\n    be32_to_cpus(&header.magic);\n    be32_to_cpus(&header.version);\n    be64_to_cpus(&header.backing_file_offset);\n    be32_to_cpus(&header.backing_file_size);\n    be64_to_cpus(&header.size);\n    be32_to_cpus(&header.cluster_bits);\n    be32_to_cpus(&header.crypt_method);\n    be64_to_cpus(&header.l1_table_offset);\n    be32_to_cpus(&header.l1_size);\n    be64_to_cpus(&header.refcount_table_offset);\n    be32_to_cpus(&header.refcount_table_clusters);\n    be64_to_cpus(&header.snapshots_offset);\n    be32_to_cpus(&header.nb_snapshots);\n\n    if (header.magic != QCOW_MAGIC) {\n        error_setg(errp, \"Image is not in qcow2 format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    if (header.version < 2 || header.version > 3) {\n        report_unsupported(bs, errp, \"QCOW version %d\", header.version);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n\n    s->qcow_version = header.version;\n\n    /* Initialise cluster size */\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n        error_setg(errp, \"Unsupported cluster size: 2^%i\", header.cluster_bits);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->cluster_bits = header.cluster_bits;\n    s->cluster_size = 1 << s->cluster_bits;\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    /* Initialise version 3 header fields */\n    if (header.version == 2) {\n        header.incompatible_features    = 0;\n        header.compatible_features      = 0;\n        header.autoclear_features       = 0;\n        header.refcount_order           = 4;\n        header.header_length            = 72;\n    } else {\n        be64_to_cpus(&header.incompatible_features);\n        be64_to_cpus(&header.compatible_features);\n        be64_to_cpus(&header.autoclear_features);\n        be32_to_cpus(&header.refcount_order);\n        be32_to_cpus(&header.header_length);\n\n        if (header.header_length < 104) {\n            error_setg(errp, \"qcow2 header too short\");\n            ret = -EINVAL;\n            goto fail;\n        }\n    }\n\n    if (header.header_length > s->cluster_size) {\n        error_setg(errp, \"qcow2 header exceeds cluster size\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.header_length > sizeof(header)) {\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n                         s->unknown_header_fields_size);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read unknown qcow2 header \"\n                             \"fields\");\n            goto fail;\n        }\n    }\n\n    if (header.backing_file_offset > s->cluster_size) {\n        error_setg(errp, \"Invalid backing file offset\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.backing_file_offset) {\n        ext_end = header.backing_file_offset;\n    } else {\n        ext_end = 1 << header.cluster_bits;\n    }\n\n    /* Handle feature bits */\n    s->incompatible_features    = header.incompatible_features;\n    s->compatible_features      = header.compatible_features;\n    s->autoclear_features       = header.autoclear_features;\n\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n        void *feature_table = NULL;\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n                              &feature_table, NULL);\n        report_unsupported_feature(bs, errp, feature_table,\n                                   s->incompatible_features &\n                                   ~QCOW2_INCOMPAT_MASK);\n        ret = -ENOTSUP;\n        g_free(feature_table);\n        goto fail;\n    }\n\n    if (s->incompatible_features & QCOW2_INCOMPAT_CORRUPT) {\n        /* Corrupt images may not be written to unless they are being repaired\n         */\n        if ((flags & BDRV_O_RDWR) && !(flags & BDRV_O_CHECK)) {\n            error_setg(errp, \"qcow2: Image is corrupt; cannot be opened \"\n                       \"read/write\");\n            ret = -EACCES;\n            goto fail;\n        }\n    }\n\n    /* Check support for various header values */\n    if (header.refcount_order != 4) {\n        report_unsupported(bs, errp, \"%d bit reference counts\",\n                           1 << header.refcount_order);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n    s->refcount_order = header.refcount_order;\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n        error_setg(errp, \"Unsupported encryption method: %i\",\n                   header.crypt_method);\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->crypt_method_header = header.crypt_method;\n    if (s->crypt_method_header) {\n        bs->encrypted = 1;\n    }\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n    s->l2_size = 1 << s->l2_bits;\n    bs->total_sectors = header.size / 512;\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n    s->refcount_table_size =\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n    if (header.refcount_table_clusters > qcow2_max_refcount_clusters(s)) {\n        error_setg(errp, \"Reference count table too large\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, s->refcount_table_offset,\n                                s->refcount_table_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid reference count table offset\");\n        goto fail;\n    }\n\n    /* Snapshot table offset/length */\n    if (header.nb_snapshots > QCOW_MAX_SNAPSHOTS) {\n        error_setg(errp, \"Too many snapshots\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.snapshots_offset,\n                                header.nb_snapshots,\n                                sizeof(QCowSnapshotHeader));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid snapshot table offset\");\n        goto fail;\n    }\n\n    /* read the level 1 table */\n    if (header.l1_size > 0x2000000) {\n        /* 32 MB L1 table is enough for 2 PB images at 64k cluster size\n         * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */\n        error_setg(errp, \"Active L1 table too large\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_size = header.l1_size;\n\n    l1_vm_state_index = size_to_l1(s, header.size);\n    if (l1_vm_state_index > INT_MAX) {\n        error_setg(errp, \"Image is too big\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_vm_state_index = l1_vm_state_index;\n\n    /* the L1 table must contain at least enough entries to put\n       header.size bytes */\n    if (s->l1_size < s->l1_vm_state_index) {\n        error_setg(errp, \"L1 table is too small\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.l1_table_offset,\n                                header.l1_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid L1 table offset\");\n        goto fail;\n    }\n    s->l1_table_offset = header.l1_table_offset;\n\n\n    if (s->l1_size > 0) {\n        s->l1_table = g_malloc0(\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n                         s->l1_size * sizeof(uint64_t));\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read L1 table\");\n            goto fail;\n        }\n        for(i = 0;i < s->l1_size; i++) {\n            be64_to_cpus(&s->l1_table[i]);\n        }\n    }\n\n    /* alloc L2 table/refcount block cache */\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n    /* one more sector for decompressed data alignment */\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n                                  + 512);\n    s->cluster_cache_offset = -1;\n    s->flags = flags;\n\n    ret = qcow2_refcount_init(bs);\n    if (ret != 0) {\n        error_setg_errno(errp, -ret, \"Could not initialize refcount handling\");\n        goto fail;\n    }\n\n    QLIST_INIT(&s->cluster_allocs);\n    QTAILQ_INIT(&s->discards);\n\n    /* read qcow2 extensions */\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,\n        &local_err)) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    /* read the backing file name */\n    if (header.backing_file_offset != 0) {\n        len = header.backing_file_size;\n        if (len > MIN(1023, s->cluster_size - header.backing_file_offset)) {\n            error_setg(errp, \"Backing file name too long\");\n            ret = -EINVAL;\n            goto fail;\n        }\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n                         bs->backing_file, len);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read backing file name\");\n            goto fail;\n        }\n        bs->backing_file[len] = '\\0';\n    }\n\n    /* Internal snapshots */\n    s->snapshots_offset = header.snapshots_offset;\n    s->nb_snapshots = header.nb_snapshots;\n\n    ret = qcow2_read_snapshots(bs);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read snapshots\");\n        goto fail;\n    }\n\n    /* Clear unknown autoclear feature bits */\n    if (!bs->read_only && !(flags & BDRV_O_INCOMING) && s->autoclear_features) {\n        s->autoclear_features = 0;\n        ret = qcow2_update_header(bs);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not update qcow2 header\");\n            goto fail;\n        }\n    }\n\n    /* Initialise locks */\n    qemu_co_mutex_init(&s->lock);\n\n    /* Repair image if dirty */\n    if (!(flags & (BDRV_O_CHECK | BDRV_O_INCOMING)) && !bs->read_only &&\n        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {\n        BdrvCheckResult result = {0};\n\n        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not repair dirty image\");\n            goto fail;\n        }\n    }\n\n    /* Enable lazy_refcounts according to image and command line options */\n    opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,\n        (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));\n\n    s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;\n    s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;\n    s->discard_passthrough[QCOW2_DISCARD_REQUEST] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,\n                          flags & BDRV_O_UNMAP);\n    s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);\n    s->discard_passthrough[QCOW2_DISCARD_OTHER] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);\n\n    opt_overlap_check = qemu_opt_get(opts, \"overlap-check\") ?: \"cached\";\n    if (!strcmp(opt_overlap_check, \"none\")) {\n        overlap_check_template = 0;\n    } else if (!strcmp(opt_overlap_check, \"constant\")) {\n        overlap_check_template = QCOW2_OL_CONSTANT;\n    } else if (!strcmp(opt_overlap_check, \"cached\")) {\n        overlap_check_template = QCOW2_OL_CACHED;\n    } else if (!strcmp(opt_overlap_check, \"all\")) {\n        overlap_check_template = QCOW2_OL_ALL;\n    } else {\n        error_setg(errp, \"Unsupported value '%s' for qcow2 option \"\n                   \"'overlap-check'. Allowed are either of the following: \"\n                   \"none, constant, cached, all\", opt_overlap_check);\n        qemu_opts_del(opts);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->overlap_check = 0;\n    for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n        /* overlap-check defines a template bitmask, but every flag may be\n         * overwritten through the associated boolean option */\n        s->overlap_check |=\n            qemu_opt_get_bool(opts, overlap_bool_option_names[i],\n                              overlap_check_template & (1 << i)) << i;\n    }\n\n    qemu_opts_del(opts);\n\n    if (s->use_lazy_refcounts && s->qcow_version < 3) {\n        error_setg(errp, \"Lazy refcounts require a qcow2 image with at least \"\n                   \"qemu 1.1 compatibility level\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n#ifdef DEBUG_ALLOC\n    {\n        BdrvCheckResult result = {0};\n        qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return ret;\n\n fail:\n    g_free(s->unknown_header_fields);\n    cleanup_unknown_header_ext(bs);\n    qcow2_free_snapshots(bs);\n    qcow2_refcount_close(bs);\n    g_free(s->l1_table);\n    /* else pre-write overlap checks in cache_destroy may crash */\n    s->l1_table = NULL;\n    if (s->l2_table_cache) {\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n    }\n    if (s->refcount_block_cache) {\n        qcow2_cache_destroy(bs, s->refcount_block_cache);\n    }\n    g_free(s->cluster_cache);\n    qemu_vfree(s->cluster_data);\n    return ret;\n}",
    "abstract_func": "static int qcow2_open(BlockDriverState *VAR_0, QDict *VAR_1, int VAR_2,\n                      Error **VAR_3)\n{\n    BDRVQcowState *VAR_4 = VAR_0->opaque;\n    unsigned int VAR_5, VAR_6;\n    int VAR_7 = 0;\n    QCowHeader VAR_8;\n    QemuOpts *VAR_9;\n    Error *VAR_10 = NULL;\n    uint64_t VAR_11;\n    uint64_t VAR_12;\n    const char *VAR_13;\n    int VAR_14 = 0;\n\n    VAR_7 = bdrv_pread(VAR_0->file, 0, &VAR_8, sizeof(VAR_8));\n    if (VAR_7 < 0) {\n        error_setg_errno(VAR_3, -VAR_7, \"Could not read qcow2 header\");\n        goto fail;\n    }\n    be32_to_cpus(&VAR_8.magic);\n    be32_to_cpus(&VAR_8.version);\n    be64_to_cpus(&VAR_8.backing_file_offset);\n    be32_to_cpus(&VAR_8.backing_file_size);\n    be64_to_cpus(&VAR_8.size);\n    be32_to_cpus(&VAR_8.cluster_bits);\n    be32_to_cpus(&VAR_8.crypt_method);\n    be64_to_cpus(&VAR_8.l1_table_offset);\n    be32_to_cpus(&VAR_8.l1_size);\n    be64_to_cpus(&VAR_8.refcount_table_offset);\n    be32_to_cpus(&VAR_8.refcount_table_clusters);\n    be64_to_cpus(&VAR_8.snapshots_offset);\n    be32_to_cpus(&VAR_8.nb_snapshots);\n\n    if (VAR_8.magic != VAR_15) {\n        error_setg(VAR_3, \"Image is not in qcow2 format\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n    if (VAR_8.version < 2 || VAR_8.version > 3) {\n        report_unsupported(VAR_0, VAR_3, \"QCOW version %d\", VAR_8.version);\n        VAR_7 = -VAR_17;\n        goto fail;\n    }\n\n    VAR_4->qcow_version = VAR_8.version;\n\n    /* COMMENT_0 */\n    if (VAR_8.cluster_bits < VAR_18 ||\n        VAR_8.cluster_bits > VAR_19) {\n        error_setg(VAR_3, \"Unsupported cluster size: 2^%i\", VAR_8.cluster_bits);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_4->cluster_bits = VAR_8.cluster_bits;\n    VAR_4->cluster_size = 1 << VAR_4->cluster_bits;\n    VAR_4->cluster_sectors = 1 << (VAR_4->cluster_bits - 9);\n\n    /* COMMENT_1 */\n    if (VAR_8.version == 2) {\n        VAR_8.incompatible_features    = 0;\n        VAR_8.compatible_features      = 0;\n        VAR_8.autoclear_features       = 0;\n        VAR_8.refcount_order           = 4;\n        VAR_8.header_length            = 72;\n    } else {\n        be64_to_cpus(&VAR_8.incompatible_features);\n        be64_to_cpus(&VAR_8.compatible_features);\n        be64_to_cpus(&VAR_8.autoclear_features);\n        be32_to_cpus(&VAR_8.refcount_order);\n        be32_to_cpus(&VAR_8.header_length);\n\n        if (VAR_8.header_length < 104) {\n            error_setg(VAR_3, \"qcow2 header too short\");\n            VAR_7 = -VAR_16;\n            goto fail;\n        }\n    }\n\n    if (VAR_8.header_length > VAR_4->cluster_size) {\n        error_setg(VAR_3, \"qcow2 header exceeds cluster size\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    if (VAR_8.header_length > sizeof(VAR_8)) {\n        VAR_4->unknown_header_fields_size = VAR_8.header_length - sizeof(VAR_8);\n        VAR_4->unknown_header_fields = g_malloc(VAR_4->unknown_header_fields_size);\n        VAR_7 = bdrv_pread(VAR_0->file, sizeof(VAR_8), VAR_4->unknown_header_fields,\n                         VAR_4->unknown_header_fields_size);\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not read unknown qcow2 header \"\n                             \"fields\");\n            goto fail;\n        }\n    }\n\n    if (VAR_8.backing_file_offset > VAR_4->cluster_size) {\n        error_setg(VAR_3, \"Invalid backing file offset\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    if (VAR_8.backing_file_offset) {\n        VAR_11 = VAR_8.backing_file_offset;\n    } else {\n        VAR_11 = 1 << VAR_8.cluster_bits;\n    }\n\n    /* COMMENT_2 */\n    VAR_4->incompatible_features    = VAR_8.incompatible_features;\n    VAR_4->compatible_features      = VAR_8.compatible_features;\n    VAR_4->autoclear_features       = VAR_8.autoclear_features;\n\n    if (VAR_4->incompatible_features & ~VAR_20) {\n        void *VAR_21 = NULL;\n        qcow2_read_extensions(VAR_0, VAR_8.header_length, VAR_11,\n                              &VAR_21, NULL);\n        report_unsupported_feature(VAR_0, VAR_3, VAR_21,\n                                   VAR_4->incompatible_features &\n                                   ~VAR_20);\n        VAR_7 = -VAR_17;\n        g_free(VAR_21);\n        goto fail;\n    }\n\n    if (VAR_4->incompatible_features & VAR_22) {\n        /* COMMENT_3 */\n           \n        if ((VAR_2 & VAR_23) && !(VAR_2 & VAR_24)) {\n            error_setg(VAR_3, \"qcow2: Image is corrupt; cannot be opened \"\n                       \"read/write\");\n            VAR_7 = -VAR_25;\n            goto fail;\n        }\n    }\n\n    /* COMMENT_5 */\n    if (VAR_8.refcount_order != 4) {\n        report_unsupported(VAR_0, VAR_3, \"%d bit reference counts\",\n                           1 << VAR_8.refcount_order);\n        VAR_7 = -VAR_17;\n        goto fail;\n    }\n    VAR_4->refcount_order = VAR_8.refcount_order;\n\n    if (VAR_8.crypt_method > VAR_26) {\n        error_setg(VAR_3, \"Unsupported encryption method: %i\",\n                   VAR_8.crypt_method);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n    VAR_4->crypt_method_header = VAR_8.crypt_method;\n    if (VAR_4->crypt_method_header) {\n        VAR_0->encrypted = 1;\n    }\n\n    VAR_4->l2_bits = VAR_4->cluster_bits - 3; /* COMMENT_6 */\n    VAR_4->l2_size = 1 << VAR_4->l2_bits;\n    VAR_0->total_sectors = VAR_8.size / 512;\n    VAR_4->csize_shift = (62 - (VAR_4->cluster_bits - 8));\n    VAR_4->csize_mask = (1 << (VAR_4->cluster_bits - 8)) - 1;\n    VAR_4->cluster_offset_mask = (1LL << VAR_4->csize_shift) - 1;\n\n    VAR_4->refcount_table_offset = VAR_8.refcount_table_offset;\n    VAR_4->refcount_table_size =\n        VAR_8.refcount_table_clusters << (VAR_4->cluster_bits - 3);\n\n    if (VAR_8.refcount_table_clusters > qcow2_max_refcount_clusters(VAR_4)) {\n        error_setg(VAR_3, \"Reference count table too large\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_7 = validate_table_offset(VAR_0, VAR_4->refcount_table_offset,\n                                VAR_4->refcount_table_size, sizeof(uint64_t));\n    if (VAR_7 < 0) {\n        error_setg(VAR_3, \"Invalid reference count table offset\");\n        goto fail;\n    }\n\n    /* COMMENT_7 */\n    if (VAR_8.nb_snapshots > VAR_27) {\n        error_setg(VAR_3, \"Too many snapshots\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_7 = validate_table_offset(VAR_0, VAR_8.snapshots_offset,\n                                VAR_8.nb_snapshots,\n                                sizeof(VAR_28));\n    if (VAR_7 < 0) {\n        error_setg(VAR_3, \"Invalid snapshot table offset\");\n        goto fail;\n    }\n\n    /* COMMENT_8 */\n    if (VAR_8.l1_size > 0x2000000) {\n        /* COMMENT_9 */\n                                                                    \n        error_setg(VAR_3, \"Active L1 table too large\");\n        VAR_7 = -VAR_29;\n        goto fail;\n    }\n    VAR_4->l1_size = VAR_8.l1_size;\n\n    VAR_12 = size_to_l1(VAR_4, VAR_8.size);\n    if (VAR_12 > VAR_30) {\n        error_setg(VAR_3, \"Image is too big\");\n        VAR_7 = -VAR_29;\n        goto fail;\n    }\n    VAR_4->l1_vm_state_index = VAR_12;\n\n    /* COMMENT_11 */\n                           \n    if (VAR_4->l1_size < VAR_4->l1_vm_state_index) {\n        error_setg(VAR_3, \"L1 table is too small\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_7 = validate_table_offset(VAR_0, VAR_8.l1_table_offset,\n                                VAR_8.l1_size, sizeof(uint64_t));\n    if (VAR_7 < 0) {\n        error_setg(VAR_3, \"Invalid L1 table offset\");\n        goto fail;\n    }\n    VAR_4->l1_table_offset = VAR_8.l1_table_offset;\n\n\n    if (VAR_4->l1_size > 0) {\n        VAR_4->l1_table = g_malloc0(\n            align_offset(VAR_4->l1_size * sizeof(uint64_t), 512));\n        VAR_7 = bdrv_pread(VAR_0->file, VAR_4->l1_table_offset, VAR_4->l1_table,\n                         VAR_4->l1_size * sizeof(uint64_t));\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not read L1 table\");\n            goto fail;\n        }\n        for(VAR_6 = 0;VAR_6 < VAR_4->l1_size; VAR_6++) {\n            be64_to_cpus(&VAR_4->l1_table[VAR_6]);\n        }\n    }\n\n    /* COMMENT_13 */\n    VAR_4->l2_table_cache = qcow2_cache_create(VAR_0, VAR_31);\n    VAR_4->refcount_block_cache = qcow2_cache_create(VAR_0, VAR_32);\n\n    VAR_4->cluster_cache = g_malloc(VAR_4->cluster_size);\n    /* COMMENT_14 */\n    VAR_4->cluster_data = qemu_blockalign(VAR_0, VAR_33 * VAR_4->cluster_size\n                                  + 512);\n    VAR_4->cluster_cache_offset = -1;\n    VAR_4->flags = VAR_2;\n\n    VAR_7 = qcow2_refcount_init(VAR_0);\n    if (VAR_7 != 0) {\n        error_setg_errno(VAR_3, -VAR_7, \"Could not initialize refcount handling\");\n        goto fail;\n    }\n\n    QLIST_INIT(&VAR_4->cluster_allocs);\n    QTAILQ_INIT(&VAR_4->discards);\n\n    /* COMMENT_15 */\n    if (qcow2_read_extensions(VAR_0, VAR_8.header_length, VAR_11, NULL,\n        &VAR_10)) {\n        error_propagate(VAR_3, VAR_10);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    /* COMMENT_16 */\n    if (VAR_8.backing_file_offset != 0) {\n        VAR_5 = VAR_8.backing_file_size;\n        if (VAR_5 > MIN(1023, VAR_4->cluster_size - VAR_8.backing_file_offset)) {\n            error_setg(VAR_3, \"Backing file name too long\");\n            VAR_7 = -VAR_16;\n            goto fail;\n        }\n        VAR_7 = bdrv_pread(VAR_0->file, VAR_8.backing_file_offset,\n                         VAR_0->backing_file, VAR_5);\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not read backing file name\");\n            goto fail;\n        }\n        VAR_0->backing_file[VAR_5] = '\\0';\n    }\n\n    /* COMMENT_17 */\n    VAR_4->snapshots_offset = VAR_8.snapshots_offset;\n    VAR_4->nb_snapshots = VAR_8.nb_snapshots;\n\n    VAR_7 = qcow2_read_snapshots(VAR_0);\n    if (VAR_7 < 0) {\n        error_setg_errno(VAR_3, -VAR_7, \"Could not read snapshots\");\n        goto fail;\n    }\n\n    /* COMMENT_18 */\n    if (!VAR_0->read_only && !(VAR_2 & VAR_34) && VAR_4->autoclear_features) {\n        VAR_4->autoclear_features = 0;\n        VAR_7 = qcow2_update_header(VAR_0);\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not update qcow2 header\");\n            goto fail;\n        }\n    }\n\n    /* COMMENT_19 */\n    qemu_co_mutex_init(&VAR_4->lock);\n\n    /* COMMENT_20 */\n    if (!(VAR_2 & (VAR_24 | VAR_34)) && !VAR_0->read_only &&\n        (VAR_4->incompatible_features & VAR_35)) {\n        BdrvCheckResult VAR_36 = {0};\n\n        VAR_7 = qcow2_check(VAR_0, &VAR_36, VAR_37);\n        if (VAR_7 < 0) {\n            error_setg_errno(VAR_3, -VAR_7, \"Could not repair dirty image\");\n            goto fail;\n        }\n    }\n\n    /* COMMENT_21 */\n    VAR_9 = qemu_opts_create(&VAR_38, NULL, 0, &VAR_39);\n    qemu_opts_absorb_qdict(VAR_9, VAR_1, &VAR_10);\n    if (VAR_10) {\n        error_propagate(VAR_3, VAR_10);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_4->use_lazy_refcounts = qemu_opt_get_bool(VAR_9, VAR_40,\n        (VAR_4->compatible_features & VAR_41));\n\n    VAR_4->discard_passthrough[VAR_42] = false;\n    VAR_4->discard_passthrough[VAR_43] = true;\n    VAR_4->discard_passthrough[VAR_44] =\n        qemu_opt_get_bool(VAR_9, VAR_45,\n                          VAR_2 & VAR_46);\n    VAR_4->discard_passthrough[VAR_47] =\n        qemu_opt_get_bool(VAR_9, VAR_48, true);\n    VAR_4->discard_passthrough[VAR_49] =\n        qemu_opt_get_bool(VAR_9, VAR_50, false);\n\n    VAR_13 = qemu_opt_get(VAR_9, \"overlap-check\") ?VAR_51: \"cached\";\n    if (!strcmp(VAR_13, \"none\")) {\n        VAR_14 = 0;\n    } else if (!strcmp(VAR_13, \"constant\")) {\n        VAR_14 = VAR_52;\n    } else if (!strcmp(VAR_13, \"cached\")) {\n        VAR_14 = VAR_53;\n    } else if (!strcmp(VAR_13, \"all\")) {\n        VAR_14 = VAR_54;\n    } else {\n        error_setg(VAR_3, \"Unsupported value '%s' for qcow2 option \"\n                   \"'overlap-check'. Allowed are either of the following: \"\n                   \"none, constant, cached, all\", VAR_13);\n        qemu_opts_del(VAR_9);\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n    VAR_4->overlap_check = 0;\n    for (VAR_6 = 0; VAR_6 < VAR_55; VAR_6++) {\n        /* COMMENT_22 */\n                                                               \n        VAR_4->overlap_check |=\n            qemu_opt_get_bool(VAR_9, VAR_56[VAR_6],\n                              VAR_14 & (1 << VAR_6)) << VAR_6;\n    }\n\n    qemu_opts_del(VAR_9);\n\n    if (VAR_4->use_lazy_refcounts && VAR_4->qcow_version < 3) {\n        error_setg(VAR_3, \"Lazy refcounts require a qcow2 image with at least \"\n                   \"qemu 1.1 compatibility level\");\n        VAR_7 = -VAR_16;\n        goto fail;\n    }\n\n#ifdef VAR_57\n    {\n        BdrvCheckResult VAR_36 = {0};\n        qcow2_check_refcounts(VAR_0, &VAR_36, 0);\n    }\n#endif\n    return VAR_7;\n\n fail:\n    g_free(VAR_4->unknown_header_fields);\n    cleanup_unknown_header_ext(VAR_0);\n    qcow2_free_snapshots(VAR_0);\n    qcow2_refcount_close(VAR_0);\n    g_free(VAR_4->l1_table);\n    /* COMMENT_24 */\n    VAR_4->l1_table = NULL;\n    if (VAR_4->l2_table_cache) {\n        qcow2_cache_destroy(VAR_0, VAR_4->l2_table_cache);\n    }\n    if (VAR_4->refcount_block_cache) {\n        qcow2_cache_destroy(VAR_0, VAR_4->refcount_block_cache);\n    }\n    g_free(VAR_4->cluster_cache);\n    qemu_vfree(VAR_4->cluster_data);\n    return VAR_7;\n}",
    "func_graph_path": "qemu/11b128f4062dd7f89b14abc8877ff20d41b28be9/qcow2.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -194,9 +194,6 @@\n         goto fail;\n     }\n \n-    s->snapshots_offset = header.snapshots_offset;\n-    s->nb_snapshots = header.nb_snapshots;\n-\n     /* read the level 1 table */\n     if (header.l1_size > 0x2000000) {\n         /* 32 MB L1 table is enough for 2 PB images at 64k cluster size\n@@ -290,6 +287,10 @@\n         }\n         bs->backing_file[len] = '\\0';\n     }\n+\n+    /* Internal snapshots */\n+    s->snapshots_offset = header.snapshots_offset;\n+    s->nb_snapshots = header.nb_snapshots;\n \n     ret = qcow2_read_snapshots(bs);\n     if (ret < 0) {",
    "diff_line_info": {
        "deleted_lines": [
            "    s->snapshots_offset = header.snapshots_offset;",
            "    s->nb_snapshots = header.nb_snapshots;",
            ""
        ],
        "added_lines": [
            "",
            "    /* Internal snapshots */",
            "    s->snapshots_offset = header.snapshots_offset;",
            "    s->nb_snapshots = header.nb_snapshots;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}