{
    "cve_id": "CVE-2018-17961",
    "cwe_ids": [
        "CWE-209"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "ArtifexSoftware/ghostpdl",
    "commit_msg": "For hidden operators, pass a name object to error handler.\n\nIn normal operation, Postscript error handlers are passed the object which\ntriggered the error: this is invariably an operator object.\n\nThe issue arises when an error is triggered by an operator which is for internal\nuse only, and that operator is then passed to the error handler, meaning it\nbecomes visible to the error handler code.\n\nBy converting to a name object, the error message is still valid, but we no\nlonger expose internal use only operators.\n\nThe change in gs_dps1.ps is related to the above: previously an error in\nscheck would throw an error against .gcheck, but as .gcheck is now a hidden\noperator, it resulted in a name object being passed to the error handler. As\nscheck is a 'real' operator, it's better to use the real operator, rather than\nthe name of an internal, hidden one.",
    "commit_hash": "a6807394bd94",
    "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/a6807394bd94b708be24758287b606154daaaed9",
    "file_path": "psi/interp.c",
    "func_name": "gs_call_interp",
    "func_before": "static int\ngs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors,\n               int *pexit_code, ref * perror_object)\n{\n    ref *epref = pref;\n    ref doref;\n    ref *perrordict;\n    ref error_name;\n    int code, ccode;\n    ref saref;\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal;\n\n    *pexit_code = 0;\n    *gc_signal = 0;\n    ialloc_reset_requested(idmemory);\nagain:\n    /* Avoid a dangling error object that might get traced by a future GC. */\n    make_null(perror_object);\n    o_stack.requested = e_stack.requested = d_stack.requested = 0;\n    while (*gc_signal) { /* Some routine below triggered a GC. */\n        gs_gc_root_t epref_root;\n\n        *gc_signal = 0;\n        /* Make sure that doref will get relocated properly if */\n        /* a garbage collection happens with epref == &doref. */\n        gs_register_ref_root(imemory_system, &epref_root,\n                             (void **)&epref, \"gs_call_interp(epref)\");\n        code = interp_reclaim(pi_ctx_p, -1);\n        i_ctx_p = *pi_ctx_p;\n        gs_unregister_root(imemory_system, &epref_root,\n                           \"gs_call_interp(epref)\");\n        if (code < 0)\n            return code;\n    }\n    code = interp(pi_ctx_p, epref, perror_object);\n    i_ctx_p = *pi_ctx_p;\n    if (!r_has_type(&i_ctx_p->error_object, t__invalid)) {\n        *perror_object = i_ctx_p->error_object;\n        make_t(&i_ctx_p->error_object, t__invalid);\n    }\n    /* Prevent a dangling reference to the GC signal in ticks_left */\n    /* in the frame of interp, but be prepared to do a GC if */\n    /* an allocation in this routine asks for it. */\n    *gc_signal = 0;\n    set_gc_signal(i_ctx_p, 1);\n    if (esp < esbot)            /* popped guard entry */\n        esp = esbot;\n    switch (code) {\n        case gs_error_Fatal:\n            *pexit_code = 255;\n            return code;\n        case gs_error_Quit:\n            *perror_object = osp[-1];\n            *pexit_code = code = osp->value.intval;\n            osp -= 2;\n            return\n                (code == 0 ? gs_error_Quit :\n                 code < 0 && code > -100 ? code : gs_error_Fatal);\n        case gs_error_InterpreterExit:\n            return 0;\n        case gs_error_ExecStackUnderflow:\n/****** WRONG -- must keep mark blocks intact ******/\n            ref_stack_pop_block(&e_stack);\n            doref = *perror_object;\n            epref = &doref;\n            goto again;\n        case gs_error_VMreclaim:\n            /* Do the GC and continue. */\n            /* We ignore the return value here, if it fails here\n             * we'll call it again having jumped to the \"again\" label.\n             * Where, assuming it fails again, we'll handle the error.\n             */\n            (void)interp_reclaim(pi_ctx_p,\n                                  (osp->value.intval == 2 ?\n                                   avm_global : avm_local));\n            i_ctx_p = *pi_ctx_p;\n            make_oper(&doref, 0, zpop);\n            epref = &doref;\n            goto again;\n        case gs_error_NeedInput:\n        case gs_error_interrupt:\n            return code;\n    }\n    /* Adjust osp in case of operand stack underflow */\n    if (osp < osbot - 1)\n        osp = osbot - 1;\n    /* We have to handle stack over/underflow specially, because */\n    /* we might be able to recover by adding or removing a block. */\n    switch (code) {\n        case gs_error_dictstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_dstack, which does a ref_stack_extend, */\n            /* so if` we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            /* Skip system dictionaries for CET 20-02-02 */\n            ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_pop_to(&d_stack, min_dstack_size);\n            dict_set_top();\n            *++osp = saref;\n            break;\n        case gs_error_dictstackunderflow:\n            if (ref_stack_pop_block(&d_stack) >= 0) {\n                dict_set_top();\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n        case gs_error_execstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_estack, which does a ref_stack_extend, */\n            /* so if we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            {\n                uint count = ref_stack_count(&e_stack);\n                uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM;\n\n                if (count > limit) {\n                    /*\n                     * If there is an e-stack mark within MIN_BLOCK_ESTACK of\n                     * the new top, cut the stack back to remove the mark.\n                     */\n                    int skip = count - limit;\n                    int i;\n\n                    for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) {\n                        const ref *ep = ref_stack_index(&e_stack, i);\n\n                        if (r_has_type_attrs(ep, t_null, a_executable)) {\n                            skip = i + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(i_ctx_p, skip);\n                }\n            }\n            *++osp = saref;\n            break;\n        case gs_error_stackoverflow:\n            if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {   /* We can't just re-execute the object, because */\n                /* it might be a procedure being pushed as a */\n                /* literal.  We check for this case specially. */\n                doref = *perror_object;\n                if (r_is_proc(&doref)) {\n                    *++osp = doref;\n                    make_null_proc(&doref);\n                }\n                epref = &doref;\n                goto again;\n            }\n            ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_clear(&o_stack);\n            *++osp = saref;\n            break;\n        case gs_error_stackunderflow:\n            if (ref_stack_pop_block(&o_stack) >= 0) {\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n    }\n    if (user_errors < 0)\n        return code;\n    if (gs_errorname(i_ctx_p, code, &error_name) < 0)\n        return code;            /* out-of-range error code! */\n\n    /*  We refer to gserrordict first, which is not accessible to Postcript jobs\n     *  If we're running with SAFERERRORS all the handlers are copied to gserrordict\n     *  so we'll always find the default one. If not SAFERERRORS, only gs specific\n     *  errors are in gserrordict.\n     */\n    if (dict_find_string(systemdict, \"gserrordict\", &perrordict) <= 0 ||\n        (dict_find(perrordict, &error_name, &epref) <= 0 &&\n         (dict_find_string(systemdict, \"errordict\", &perrordict) <= 0 ||\n          dict_find(perrordict, &error_name, &epref) <= 0))\n        )\n        return code;            /* error name not in errordict??? */\n\n    doref = *epref;\n    epref = &doref;\n    /* Push the error object on the operand stack if appropriate. */\n    if (!GS_ERROR_IS_INTERRUPT(code)) {\n        /* Replace the error object if within an oparray or .errorexec. */\n        osp++;\n        if (osp >= ostop) {\n            *pexit_code = gs_error_Fatal;\n            return_error(gs_error_Fatal);\n        }\n        *osp = *perror_object;\n        errorexec_find(i_ctx_p, osp);\n        /* If using SAFER, hand a name object to the error handler, rather than the executable\n         * object/operator itself.\n         */\n        if (i_ctx_p->LockFilePermissions) {\n            code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n            if (code < 0) {\n                const char *unknownstr = \"--unknown--\";\n                rlen = strlen(unknownstr);\n                memcpy(buf, unknownstr, rlen);\n            }\n            else {\n                buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n                rlen += 4;\n            }\n            code = name_ref(imemory, buf, rlen, osp, 1);\n            if (code < 0)\n                make_null(osp);\n        }\n    }\n    goto again;\n}",
    "abstract_func_before": "static int\ngs_call_interp(i_ctx_t **VAR_0, ref * VAR_1, int VAR_2,\n               int *VAR_3, ref * VAR_4)\n{\n    ref *VAR_5 = VAR_1;\n    ref VAR_6;\n    ref *VAR_7;\n    ref VAR_8;\n    int VAR_9, VAR_10;\n    ref VAR_11;\n    i_ctx_t *VAR_12 = *VAR_0;\n    int *VAR_13 = &VAR_14->gs_lib_ctx->gcsignal;\n\n    *VAR_3 = 0;\n    *VAR_13 = 0;\n    ialloc_reset_requested(VAR_15);\nagain:\n    /* COMMENT_0 */\n    make_null(VAR_4);\n    VAR_16.requested = VAR_17.requested = VAR_18.requested = 0;\n    while (*VAR_13) { /* COMMENT_1 */\n        gs_gc_root_t VAR_19;\n\n        *VAR_13 = 0;\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        gs_register_ref_root(VAR_14, &VAR_19,\n                             (void **)&VAR_5, \"gs_call_interp(epref)\");\n        VAR_9 = interp_reclaim(VAR_0, -1);\n        VAR_12 = *VAR_0;\n        gs_unregister_root(VAR_14, &VAR_19,\n                           \"gs_call_interp(epref)\");\n        if (VAR_9 < 0)\n            return VAR_9;\n    }\n    VAR_9 = interp(VAR_0, VAR_5, VAR_4);\n    VAR_12 = *VAR_0;\n    if (!r_has_type(&VAR_12->error_object, VAR_20)) {\n        *VAR_4 = VAR_12->error_object;\n        make_t(&VAR_12->error_object, VAR_20);\n    }\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    *VAR_13 = 0;\n    set_gc_signal(VAR_12, 1);\n    if (VAR_21 < VAR_22)            /* COMMENT_7 */\n        VAR_21 = VAR_22;\n    switch (VAR_9) {\n        case VAR_23:\n            *VAR_3 = 255;\n            return VAR_9;\n        case VAR_24:\n            *VAR_4 = VAR_25[-1];\n            *VAR_3 = VAR_9 = VAR_25->value.intval;\n            VAR_25 -= 2;\n            return\n                (VAR_9 == 0 ? VAR_24 :\n                 VAR_9 < 0 && VAR_9 > -100 ? VAR_9 : VAR_23);\n        case VAR_26:\n            return 0;\n        case VAR_27:\n/* COMMENT_8 */\n            ref_stack_pop_block(&VAR_17);\n            VAR_6 = *VAR_4;\n            VAR_5 = &VAR_6;\n            goto again;\n        case VAR_28:\n            /* COMMENT_9 */\n            /* COMMENT_10 */\n                                                                      \n                                                                      \n               \n            (void)interp_reclaim(VAR_0,\n                                  (VAR_25->value.intval == 2 ?\n                                   VAR_29 : VAR_30));\n            VAR_12 = *VAR_0;\n            make_oper(&VAR_6, 0, VAR_31);\n            VAR_5 = &VAR_6;\n            goto again;\n        case VAR_32:\n        case VAR_33:\n            return VAR_9;\n    }\n    /* COMMENT_14 */\n    if (VAR_25 < VAR_34 - 1)\n        VAR_25 = VAR_34 - 1;\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    switch (VAR_9) {\n        case VAR_35:\n            /* COMMENT_17 */\n            /* COMMENT_18 */\n            /* COMMENT_19 */\n            /* COMMENT_20 */\n            if (VAR_25 >= VAR_36) {\n                if ((VAR_10 = ref_stack_extend(&VAR_16, 1)) < 0)\n                    return VAR_10;\n            }\n            /* COMMENT_21 */\n            VAR_10 = copy_stack(VAR_12, &VAR_18, VAR_37, &VAR_11);\n            if (VAR_10 < 0)\n                return VAR_10;\n            ref_stack_pop_to(&VAR_18, VAR_37);\n            dict_set_top();\n            *++VAR_25 = VAR_11;\n            break;\n        case VAR_38:\n            if (ref_stack_pop_block(&VAR_18) >= 0) {\n                dict_set_top();\n                VAR_6 = *VAR_4;\n                VAR_5 = &VAR_6;\n                goto again;\n            }\n            break;\n        case VAR_39:\n            /* COMMENT_17 */\n            /* COMMENT_18 */\n            /* COMMENT_22 */\n            /* COMMENT_23 */\n            if (VAR_25 >= VAR_36) {\n                if ((VAR_10 = ref_stack_extend(&VAR_16, 1)) < 0)\n                    return VAR_10;\n            }\n            VAR_10 = copy_stack(VAR_12, &VAR_17, 0, &VAR_11);\n            if (VAR_10 < 0)\n                return VAR_10;\n            {\n                uint VAR_40 = ref_stack_count(&VAR_17);\n                uint VAR_41 = ref_stack_max_count(&VAR_17) - VAR_42;\n\n                if (VAR_40 > VAR_41) {\n                    /* COMMENT_24 */\n                                                                             \n                                                                          \n                       \n                    int VAR_43 = VAR_40 - VAR_41;\n                    int VAR_44;\n\n                    for (VAR_44 = VAR_43; VAR_44 < VAR_43 + VAR_45; ++VAR_44) {\n                        const ref *VAR_46 = ref_stack_index(&VAR_17, VAR_44);\n\n                        if (r_has_type_attrs(VAR_46, VAR_47, VAR_48)) {\n                            VAR_43 = VAR_44 + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(VAR_12, VAR_43);\n                }\n            }\n            *++VAR_25 = VAR_11;\n            break;\n        case VAR_49:\n            if (ref_stack_extend(&VAR_16, VAR_16.requested) >= 0) {   /* COMMENT_28 */\n                /* COMMENT_29 */\n                /* COMMENT_30 */\n                VAR_6 = *VAR_4;\n                if (r_is_proc(&VAR_6)) {\n                    *++VAR_25 = VAR_6;\n                    make_null_proc(&VAR_6);\n                }\n                VAR_5 = &VAR_6;\n                goto again;\n            }\n            VAR_10 = copy_stack(VAR_12, &VAR_16, 0, &VAR_11);\n            if (VAR_10 < 0)\n                return VAR_10;\n            ref_stack_clear(&VAR_16);\n            *++VAR_25 = VAR_11;\n            break;\n        case VAR_50:\n            if (ref_stack_pop_block(&VAR_16) >= 0) {\n                VAR_6 = *VAR_4;\n                VAR_5 = &VAR_6;\n                goto again;\n            }\n            break;\n    }\n    if (VAR_2 < 0)\n        return VAR_9;\n    if (gs_errorname(VAR_12, VAR_9, &VAR_8) < 0)\n        return VAR_9;            /* COMMENT_31 */\n\n    /* COMMENT_32 */\n                                                                                    \n                                                                                  \n                                  \n       \n    if (dict_find_string(VAR_51, \"gserrordict\", &VAR_7) <= 0 ||\n        (dict_find(VAR_7, &VAR_8, &VAR_5) <= 0 &&\n         (dict_find_string(VAR_51, \"errordict\", &VAR_7) <= 0 ||\n          dict_find(VAR_7, &VAR_8, &VAR_5) <= 0))\n        )\n        return VAR_9;            /* COMMENT_37 */\n\n    VAR_6 = *VAR_5;\n    VAR_5 = &VAR_6;\n    /* COMMENT_38 */\n    if (!GS_ERROR_IS_INTERRUPT(VAR_9)) {\n        /* COMMENT_39 */\n        VAR_25++;\n        if (VAR_25 >= VAR_36) {\n            *VAR_3 = VAR_23;\n            return_error(VAR_23);\n        }\n        *VAR_25 = *VAR_4;\n        errorexec_find(VAR_12, VAR_25);\n        /* COMMENT_40 */\n                                  \n           \n        if (VAR_12->LockFilePermissions) {\n            VAR_9 = obj_cvs(VAR_52, VAR_25, VAR_53 + 2, 256, &VAR_54, (const byte **)&VAR_55);\n            if (VAR_9 < 0) {\n                const char *VAR_56 = \"--unknown--\";\n                VAR_54 = strlen(VAR_56);\n                memcpy(VAR_53, VAR_56, VAR_54);\n            }\n            else {\n                VAR_53[0] = VAR_53[1] = VAR_53[VAR_54 + 2] = VAR_53[VAR_54 + 3] = '-';\n                VAR_54 += 4;\n            }\n            VAR_9 = name_ref(VAR_52, VAR_53, VAR_54, VAR_25, 1);\n            if (VAR_9 < 0)\n                make_null(VAR_25);\n        }\n    }\n    goto again;\n}",
    "func_graph_path_before": "ArtifexSoftware/ghostpdl/a6807394bd94/interp.c/vul/before/0.json",
    "func": "static int\ngs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors,\n               int *pexit_code, ref * perror_object)\n{\n    ref *epref = pref;\n    ref doref;\n    ref *perrordict;\n    ref error_name;\n    int code, ccode;\n    ref saref;\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal;\n\n    *pexit_code = 0;\n    *gc_signal = 0;\n    ialloc_reset_requested(idmemory);\nagain:\n    /* Avoid a dangling error object that might get traced by a future GC. */\n    make_null(perror_object);\n    o_stack.requested = e_stack.requested = d_stack.requested = 0;\n    while (*gc_signal) { /* Some routine below triggered a GC. */\n        gs_gc_root_t epref_root;\n\n        *gc_signal = 0;\n        /* Make sure that doref will get relocated properly if */\n        /* a garbage collection happens with epref == &doref. */\n        gs_register_ref_root(imemory_system, &epref_root,\n                             (void **)&epref, \"gs_call_interp(epref)\");\n        code = interp_reclaim(pi_ctx_p, -1);\n        i_ctx_p = *pi_ctx_p;\n        gs_unregister_root(imemory_system, &epref_root,\n                           \"gs_call_interp(epref)\");\n        if (code < 0)\n            return code;\n    }\n    code = interp(pi_ctx_p, epref, perror_object);\n    i_ctx_p = *pi_ctx_p;\n    if (!r_has_type(&i_ctx_p->error_object, t__invalid)) {\n        *perror_object = i_ctx_p->error_object;\n        make_t(&i_ctx_p->error_object, t__invalid);\n    }\n    /* Prevent a dangling reference to the GC signal in ticks_left */\n    /* in the frame of interp, but be prepared to do a GC if */\n    /* an allocation in this routine asks for it. */\n    *gc_signal = 0;\n    set_gc_signal(i_ctx_p, 1);\n    if (esp < esbot)            /* popped guard entry */\n        esp = esbot;\n    switch (code) {\n        case gs_error_Fatal:\n            *pexit_code = 255;\n            return code;\n        case gs_error_Quit:\n            *perror_object = osp[-1];\n            *pexit_code = code = osp->value.intval;\n            osp -= 2;\n            return\n                (code == 0 ? gs_error_Quit :\n                 code < 0 && code > -100 ? code : gs_error_Fatal);\n        case gs_error_InterpreterExit:\n            return 0;\n        case gs_error_ExecStackUnderflow:\n/****** WRONG -- must keep mark blocks intact ******/\n            ref_stack_pop_block(&e_stack);\n            doref = *perror_object;\n            epref = &doref;\n            goto again;\n        case gs_error_VMreclaim:\n            /* Do the GC and continue. */\n            /* We ignore the return value here, if it fails here\n             * we'll call it again having jumped to the \"again\" label.\n             * Where, assuming it fails again, we'll handle the error.\n             */\n            (void)interp_reclaim(pi_ctx_p,\n                                  (osp->value.intval == 2 ?\n                                   avm_global : avm_local));\n            i_ctx_p = *pi_ctx_p;\n            make_oper(&doref, 0, zpop);\n            epref = &doref;\n            goto again;\n        case gs_error_NeedInput:\n        case gs_error_interrupt:\n            return code;\n    }\n    /* Adjust osp in case of operand stack underflow */\n    if (osp < osbot - 1)\n        osp = osbot - 1;\n    /* We have to handle stack over/underflow specially, because */\n    /* we might be able to recover by adding or removing a block. */\n    switch (code) {\n        case gs_error_dictstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_dstack, which does a ref_stack_extend, */\n            /* so if` we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            /* Skip system dictionaries for CET 20-02-02 */\n            ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_pop_to(&d_stack, min_dstack_size);\n            dict_set_top();\n            *++osp = saref;\n            break;\n        case gs_error_dictstackunderflow:\n            if (ref_stack_pop_block(&d_stack) >= 0) {\n                dict_set_top();\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n        case gs_error_execstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_estack, which does a ref_stack_extend, */\n            /* so if we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            {\n                uint count = ref_stack_count(&e_stack);\n                uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM;\n\n                if (count > limit) {\n                    /*\n                     * If there is an e-stack mark within MIN_BLOCK_ESTACK of\n                     * the new top, cut the stack back to remove the mark.\n                     */\n                    int skip = count - limit;\n                    int i;\n\n                    for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) {\n                        const ref *ep = ref_stack_index(&e_stack, i);\n\n                        if (r_has_type_attrs(ep, t_null, a_executable)) {\n                            skip = i + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(i_ctx_p, skip);\n                }\n            }\n            *++osp = saref;\n            break;\n        case gs_error_stackoverflow:\n            if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {   /* We can't just re-execute the object, because */\n                /* it might be a procedure being pushed as a */\n                /* literal.  We check for this case specially. */\n                doref = *perror_object;\n                if (r_is_proc(&doref)) {\n                    *++osp = doref;\n                    make_null_proc(&doref);\n                }\n                epref = &doref;\n                goto again;\n            }\n            ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_clear(&o_stack);\n            *++osp = saref;\n            break;\n        case gs_error_stackunderflow:\n            if (ref_stack_pop_block(&o_stack) >= 0) {\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n    }\n    if (user_errors < 0)\n        return code;\n    if (gs_errorname(i_ctx_p, code, &error_name) < 0)\n        return code;            /* out-of-range error code! */\n\n    /*  We refer to gserrordict first, which is not accessible to Postcript jobs\n     *  If we're running with SAFERERRORS all the handlers are copied to gserrordict\n     *  so we'll always find the default one. If not SAFERERRORS, only gs specific\n     *  errors are in gserrordict.\n     */\n    if (dict_find_string(systemdict, \"gserrordict\", &perrordict) <= 0 ||\n        (dict_find(perrordict, &error_name, &epref) <= 0 &&\n         (dict_find_string(systemdict, \"errordict\", &perrordict) <= 0 ||\n          dict_find(perrordict, &error_name, &epref) <= 0))\n        )\n        return code;            /* error name not in errordict??? */\n\n    doref = *epref;\n    epref = &doref;\n    /* Push the error object on the operand stack if appropriate. */\n    if (!GS_ERROR_IS_INTERRUPT(code)) {\n        byte buf[260], *bufptr;\n        uint rlen;\n        /* Replace the error object if within an oparray or .errorexec. */\n        osp++;\n        if (osp >= ostop) {\n            *pexit_code = gs_error_Fatal;\n            return_error(gs_error_Fatal);\n        }\n        *osp = *perror_object;\n        errorexec_find(i_ctx_p, osp);\n\n        if (!r_has_type(osp, t_string) && !r_has_type(osp, t_name)) {\n            code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n            if (code < 0) {\n                const char *unknownstr = \"--unknown--\";\n                rlen = strlen(unknownstr);\n                memcpy(buf, unknownstr, rlen);\n                bufptr = buf;\n            }\n            else {\n                ref *tobj;\n                bufptr[rlen] = '\\0';\n                /* Only pass a name object if the operator doesn't exist in systemdict\n                 * i.e. it's an internal operator we have hidden\n                 */\n                code = dict_find_string(systemdict, (const char *)bufptr, &tobj);\n                if (code < 0) {\n                    buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n                    rlen += 4;\n                    bufptr = buf;\n                }\n                else {\n                    bufptr = NULL;\n                }\n            }\n            if (bufptr) {\n                code = name_ref(imemory, buf, rlen, osp, 1);\n                if (code < 0)\n                    make_null(osp);\n            }\n        }\n    }\n    goto again;\n}",
    "abstract_func": "static int\ngs_call_interp(i_ctx_t **VAR_0, ref * VAR_1, int VAR_2,\n               int *VAR_3, ref * VAR_4)\n{\n    ref *VAR_5 = VAR_1;\n    ref VAR_6;\n    ref *VAR_7;\n    ref VAR_8;\n    int VAR_9, VAR_10;\n    ref VAR_11;\n    i_ctx_t *VAR_12 = *VAR_0;\n    int *VAR_13 = &VAR_14->gs_lib_ctx->gcsignal;\n\n    *VAR_3 = 0;\n    *VAR_13 = 0;\n    ialloc_reset_requested(VAR_15);\nagain:\n    /* COMMENT_0 */\n    make_null(VAR_4);\n    VAR_16.requested = VAR_17.requested = VAR_18.requested = 0;\n    while (*VAR_13) { /* COMMENT_1 */\n        gs_gc_root_t VAR_19;\n\n        *VAR_13 = 0;\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        gs_register_ref_root(VAR_14, &VAR_19,\n                             (void **)&VAR_5, \"gs_call_interp(epref)\");\n        VAR_9 = interp_reclaim(VAR_0, -1);\n        VAR_12 = *VAR_0;\n        gs_unregister_root(VAR_14, &VAR_19,\n                           \"gs_call_interp(epref)\");\n        if (VAR_9 < 0)\n            return VAR_9;\n    }\n    VAR_9 = interp(VAR_0, VAR_5, VAR_4);\n    VAR_12 = *VAR_0;\n    if (!r_has_type(&VAR_12->error_object, VAR_20)) {\n        *VAR_4 = VAR_12->error_object;\n        make_t(&VAR_12->error_object, VAR_20);\n    }\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    *VAR_13 = 0;\n    set_gc_signal(VAR_12, 1);\n    if (VAR_21 < VAR_22)            /* COMMENT_7 */\n        VAR_21 = VAR_22;\n    switch (VAR_9) {\n        case VAR_23:\n            *VAR_3 = 255;\n            return VAR_9;\n        case VAR_24:\n            *VAR_4 = VAR_25[-1];\n            *VAR_3 = VAR_9 = VAR_25->value.intval;\n            VAR_25 -= 2;\n            return\n                (VAR_9 == 0 ? VAR_24 :\n                 VAR_9 < 0 && VAR_9 > -100 ? VAR_9 : VAR_23);\n        case VAR_26:\n            return 0;\n        case VAR_27:\n/* COMMENT_8 */\n            ref_stack_pop_block(&VAR_17);\n            VAR_6 = *VAR_4;\n            VAR_5 = &VAR_6;\n            goto again;\n        case VAR_28:\n            /* COMMENT_9 */\n            /* COMMENT_10 */\n                                                                      \n                                                                      \n               \n            (void)interp_reclaim(VAR_0,\n                                  (VAR_25->value.intval == 2 ?\n                                   VAR_29 : VAR_30));\n            VAR_12 = *VAR_0;\n            make_oper(&VAR_6, 0, VAR_31);\n            VAR_5 = &VAR_6;\n            goto again;\n        case VAR_32:\n        case VAR_33:\n            return VAR_9;\n    }\n    /* COMMENT_14 */\n    if (VAR_25 < VAR_34 - 1)\n        VAR_25 = VAR_34 - 1;\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    switch (VAR_9) {\n        case VAR_35:\n            /* COMMENT_17 */\n            /* COMMENT_18 */\n            /* COMMENT_19 */\n            /* COMMENT_20 */\n            if (VAR_25 >= VAR_36) {\n                if ((VAR_10 = ref_stack_extend(&VAR_16, 1)) < 0)\n                    return VAR_10;\n            }\n            /* COMMENT_21 */\n            VAR_10 = copy_stack(VAR_12, &VAR_18, VAR_37, &VAR_11);\n            if (VAR_10 < 0)\n                return VAR_10;\n            ref_stack_pop_to(&VAR_18, VAR_37);\n            dict_set_top();\n            *++VAR_25 = VAR_11;\n            break;\n        case VAR_38:\n            if (ref_stack_pop_block(&VAR_18) >= 0) {\n                dict_set_top();\n                VAR_6 = *VAR_4;\n                VAR_5 = &VAR_6;\n                goto again;\n            }\n            break;\n        case VAR_39:\n            /* COMMENT_17 */\n            /* COMMENT_18 */\n            /* COMMENT_22 */\n            /* COMMENT_23 */\n            if (VAR_25 >= VAR_36) {\n                if ((VAR_10 = ref_stack_extend(&VAR_16, 1)) < 0)\n                    return VAR_10;\n            }\n            VAR_10 = copy_stack(VAR_12, &VAR_17, 0, &VAR_11);\n            if (VAR_10 < 0)\n                return VAR_10;\n            {\n                uint VAR_40 = ref_stack_count(&VAR_17);\n                uint VAR_41 = ref_stack_max_count(&VAR_17) - VAR_42;\n\n                if (VAR_40 > VAR_41) {\n                    /* COMMENT_24 */\n                                                                             \n                                                                          \n                       \n                    int VAR_43 = VAR_40 - VAR_41;\n                    int VAR_44;\n\n                    for (VAR_44 = VAR_43; VAR_44 < VAR_43 + VAR_45; ++VAR_44) {\n                        const ref *VAR_46 = ref_stack_index(&VAR_17, VAR_44);\n\n                        if (r_has_type_attrs(VAR_46, VAR_47, VAR_48)) {\n                            VAR_43 = VAR_44 + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(VAR_12, VAR_43);\n                }\n            }\n            *++VAR_25 = VAR_11;\n            break;\n        case VAR_49:\n            if (ref_stack_extend(&VAR_16, VAR_16.requested) >= 0) {   /* COMMENT_28 */\n                /* COMMENT_29 */\n                /* COMMENT_30 */\n                VAR_6 = *VAR_4;\n                if (r_is_proc(&VAR_6)) {\n                    *++VAR_25 = VAR_6;\n                    make_null_proc(&VAR_6);\n                }\n                VAR_5 = &VAR_6;\n                goto again;\n            }\n            VAR_10 = copy_stack(VAR_12, &VAR_16, 0, &VAR_11);\n            if (VAR_10 < 0)\n                return VAR_10;\n            ref_stack_clear(&VAR_16);\n            *++VAR_25 = VAR_11;\n            break;\n        case VAR_50:\n            if (ref_stack_pop_block(&VAR_16) >= 0) {\n                VAR_6 = *VAR_4;\n                VAR_5 = &VAR_6;\n                goto again;\n            }\n            break;\n    }\n    if (VAR_2 < 0)\n        return VAR_9;\n    if (gs_errorname(VAR_12, VAR_9, &VAR_8) < 0)\n        return VAR_9;            /* COMMENT_31 */\n\n    /* COMMENT_32 */\n                                                                                    \n                                                                                  \n                                  \n       \n    if (dict_find_string(VAR_51, \"gserrordict\", &VAR_7) <= 0 ||\n        (dict_find(VAR_7, &VAR_8, &VAR_5) <= 0 &&\n         (dict_find_string(VAR_51, \"errordict\", &VAR_7) <= 0 ||\n          dict_find(VAR_7, &VAR_8, &VAR_5) <= 0))\n        )\n        return VAR_9;            /* COMMENT_37 */\n\n    VAR_6 = *VAR_5;\n    VAR_5 = &VAR_6;\n    /* COMMENT_38 */\n    if (!GS_ERROR_IS_INTERRUPT(VAR_9)) {\n        byte VAR_52[260], *VAR_53;\n        uint VAR_54;\n        /* COMMENT_39 */\n        VAR_25++;\n        if (VAR_25 >= VAR_36) {\n            *VAR_3 = VAR_23;\n            return_error(VAR_23);\n        }\n        *VAR_25 = *VAR_4;\n        errorexec_find(VAR_12, VAR_25);\n\n        if (!r_has_type(VAR_25, VAR_55) && !r_has_type(VAR_25, VAR_56)) {\n            VAR_9 = obj_cvs(VAR_57, VAR_25, VAR_52 + 2, 256, &VAR_54, (const byte **)&VAR_53);\n            if (VAR_9 < 0) {\n                const char *VAR_58 = \"--unknown--\";\n                VAR_54 = strlen(VAR_58);\n                memcpy(VAR_52, VAR_58, VAR_54);\n                VAR_53 = VAR_52;\n            }\n            else {\n                ref *VAR_59;\n                VAR_53[VAR_54] = '\\0';\n                /* COMMENT_40 */\n                                                                \n                   \n                VAR_9 = dict_find_string(VAR_51, (const char *)VAR_53, &VAR_59);\n                if (VAR_9 < 0) {\n                    VAR_52[0] = VAR_52[1] = VAR_52[VAR_54 + 2] = VAR_52[VAR_54 + 3] = '-';\n                    VAR_54 += 4;\n                    VAR_53 = VAR_52;\n                }\n                else {\n                    VAR_53 = NULL;\n                }\n            }\n            if (VAR_53) {\n                VAR_9 = name_ref(VAR_57, VAR_52, VAR_54, VAR_25, 1);\n                if (VAR_9 < 0)\n                    make_null(VAR_25);\n            }\n        }\n    }\n    goto again;\n}",
    "func_graph_path": "ArtifexSoftware/ghostpdl/a6807394bd94/interp.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -197,6 +197,8 @@\n     epref = &doref;\n     /* Push the error object on the operand stack if appropriate. */\n     if (!GS_ERROR_IS_INTERRUPT(code)) {\n+        byte buf[260], *bufptr;\n+        uint rlen;\n         /* Replace the error object if within an oparray or .errorexec. */\n         osp++;\n         if (osp >= ostop) {\n@@ -205,23 +207,36 @@\n         }\n         *osp = *perror_object;\n         errorexec_find(i_ctx_p, osp);\n-        /* If using SAFER, hand a name object to the error handler, rather than the executable\n-         * object/operator itself.\n-         */\n-        if (i_ctx_p->LockFilePermissions) {\n+\n+        if (!r_has_type(osp, t_string) && !r_has_type(osp, t_name)) {\n             code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n             if (code < 0) {\n                 const char *unknownstr = \"--unknown--\";\n                 rlen = strlen(unknownstr);\n                 memcpy(buf, unknownstr, rlen);\n+                bufptr = buf;\n             }\n             else {\n-                buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n-                rlen += 4;\n-            }\n-            code = name_ref(imemory, buf, rlen, osp, 1);\n-            if (code < 0)\n-                make_null(osp);\n+                ref *tobj;\n+                bufptr[rlen] = '\\0';\n+                /* Only pass a name object if the operator doesn't exist in systemdict\n+                 * i.e. it's an internal operator we have hidden\n+                 */\n+                code = dict_find_string(systemdict, (const char *)bufptr, &tobj);\n+                if (code < 0) {\n+                    buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n+                    rlen += 4;\n+                    bufptr = buf;\n+                }\n+                else {\n+                    bufptr = NULL;\n+                }\n+            }\n+            if (bufptr) {\n+                code = name_ref(imemory, buf, rlen, osp, 1);\n+                if (code < 0)\n+                    make_null(osp);\n+            }\n         }\n     }\n     goto again;",
    "diff_line_info": {
        "deleted_lines": [
            "        /* If using SAFER, hand a name object to the error handler, rather than the executable",
            "         * object/operator itself.",
            "         */",
            "        if (i_ctx_p->LockFilePermissions) {",
            "                buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';",
            "                rlen += 4;",
            "            }",
            "            code = name_ref(imemory, buf, rlen, osp, 1);",
            "            if (code < 0)",
            "                make_null(osp);"
        ],
        "added_lines": [
            "        byte buf[260], *bufptr;",
            "        uint rlen;",
            "",
            "        if (!r_has_type(osp, t_string) && !r_has_type(osp, t_name)) {",
            "                bufptr = buf;",
            "                ref *tobj;",
            "                bufptr[rlen] = '\\0';",
            "                /* Only pass a name object if the operator doesn't exist in systemdict",
            "                 * i.e. it's an internal operator we have hidden",
            "                 */",
            "                code = dict_find_string(systemdict, (const char *)bufptr, &tobj);",
            "                if (code < 0) {",
            "                    buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';",
            "                    rlen += 4;",
            "                    bufptr = buf;",
            "                }",
            "                else {",
            "                    bufptr = NULL;",
            "                }",
            "            }",
            "            if (bufptr) {",
            "                code = name_ref(imemory, buf, rlen, osp, 1);",
            "                if (code < 0)",
            "                    make_null(osp);",
            "            }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}