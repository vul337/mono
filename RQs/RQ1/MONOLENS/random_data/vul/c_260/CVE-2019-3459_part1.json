{
    "cve_id": "CVE-2019-3459",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:A/AC:L/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "The function l2cap_get_conf_opt will return L2CAP_CONF_OPT_SIZE + opt->len\nas length value. The opt->len however is in control over the remote user\nand can be used by an attacker to gain access beyond the bounds of the\nactual packet.\n\nTo prevent any potential leak of heap memory, it is enough to check that\nthe resulting len calculation after calling l2cap_get_conf_opt is not\nbelow zero. A well formed packet will always return >= 0 here and will\nend with the length value being zero after the last option has been\nparsed. In case of malformed packets messing with the opt->len field the\nlength value will become negative. If that is the case, then just abort\nand ignore the option.\n\nIn case an attacker uses a too short opt->len value, then garbage will\nbe parsed, but that is protected by the unknown option handling and also\nthe option parameter size checks.\n\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\nReviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Johan Hedberg <johan.hedberg@intel.com>\n",
    "commit_hash": "7c9cbd0b5e38a1672fcd137894ace3b042dfbf69",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=7c9cbd0b5e38a1672fcd137894ace3b042dfbf69",
    "file_path": "net/bluetooth/l2cap_core.c",
    "func_name": "l2cap_conf_rfc_get",
    "func_before": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
    "abstract_func_before": "static void l2cap_conf_rfc_get(struct l2cap_chan *VAR_0, void *VAR_1, int VAR_2)\n{\n\tint VAR_3, VAR_4;\n\tunsigned long VAR_5;\n\t/* COMMENT_0 */\n                                                       \n    \n\tu16 VAR_6 = VAR_0->ack_win;\n\tstruct l2cap_conf_rfc VAR_7 = {\n\t\t.mode = VAR_0->mode,\n\t\t.retrans_timeout = cpu_to_le16(VAR_8),\n\t\t.monitor_timeout = cpu_to_le16(VAR_9),\n\t\t.max_pdu_size = cpu_to_le16(VAR_0->imtu),\n\t\t.txwin_size = min_t(u16, VAR_0->ack_win, VAR_10),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", VAR_0, VAR_1, VAR_2);\n\n\tif ((VAR_0->mode != VAR_11) && (VAR_0->mode != VAR_12))\n\t\treturn;\n\n\twhile (VAR_2 >= VAR_13) {\n\t\tVAR_2 -= l2cap_get_conf_opt(&VAR_1, &VAR_3, &VAR_4, &VAR_5);\n\n\t\tswitch (VAR_3) {\n\t\tcase VAR_14:\n\t\t\tif (VAR_4 != sizeof(VAR_7))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&VAR_7, (void *)VAR_5, VAR_4);\n\t\t\tbreak;\n\t\tcase VAR_15:\n\t\t\tif (VAR_4 != 2)\n\t\t\t\tbreak;\n\t\t\tVAR_6 = VAR_5;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (VAR_7.mode) {\n\tcase VAR_11:\n\t\tVAR_0->retrans_timeout = le16_to_cpu(VAR_7.retrans_timeout);\n\t\tVAR_0->monitor_timeout = le16_to_cpu(VAR_7.monitor_timeout);\n\t\tVAR_0->mps = le16_to_cpu(VAR_7.max_pdu_size);\n\t\tif (test_bit(VAR_16, &VAR_0->flags))\n\t\t\tVAR_0->ack_win = min_t(u16, VAR_0->ack_win, VAR_6);\n\t\telse\n\t\t\tVAR_0->ack_win = min_t(u16, VAR_0->ack_win,\n\t\t\t\t\t      VAR_7.txwin_size);\n\t\tbreak;\n\tcase VAR_12:\n\t\tVAR_0->mps    = le16_to_cpu(VAR_7.max_pdu_size);\n\t}\n}",
    "func_graph_path_before": "torvalds/linux/7c9cbd0b5e38a1672fcd137894ace3b042dfbf69/l2cap_core.c/vul/before/0.json",
    "func": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
    "abstract_func": "static void l2cap_conf_rfc_get(struct l2cap_chan *VAR_0, void *VAR_1, int VAR_2)\n{\n\tint VAR_3, VAR_4;\n\tunsigned long VAR_5;\n\t/* COMMENT_0 */\n                                                       \n    \n\tu16 VAR_6 = VAR_0->ack_win;\n\tstruct l2cap_conf_rfc VAR_7 = {\n\t\t.mode = VAR_0->mode,\n\t\t.retrans_timeout = cpu_to_le16(VAR_8),\n\t\t.monitor_timeout = cpu_to_le16(VAR_9),\n\t\t.max_pdu_size = cpu_to_le16(VAR_0->imtu),\n\t\t.txwin_size = min_t(u16, VAR_0->ack_win, VAR_10),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", VAR_0, VAR_1, VAR_2);\n\n\tif ((VAR_0->mode != VAR_11) && (VAR_0->mode != VAR_12))\n\t\treturn;\n\n\twhile (VAR_2 >= VAR_13) {\n\t\tVAR_2 -= l2cap_get_conf_opt(&VAR_1, &VAR_3, &VAR_4, &VAR_5);\n\t\tif (VAR_2 < 0)\n\t\t\tbreak;\n\n\t\tswitch (VAR_3) {\n\t\tcase VAR_14:\n\t\t\tif (VAR_4 != sizeof(VAR_7))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&VAR_7, (void *)VAR_5, VAR_4);\n\t\t\tbreak;\n\t\tcase VAR_15:\n\t\t\tif (VAR_4 != 2)\n\t\t\t\tbreak;\n\t\t\tVAR_6 = VAR_5;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (VAR_7.mode) {\n\tcase VAR_11:\n\t\tVAR_0->retrans_timeout = le16_to_cpu(VAR_7.retrans_timeout);\n\t\tVAR_0->monitor_timeout = le16_to_cpu(VAR_7.monitor_timeout);\n\t\tVAR_0->mps = le16_to_cpu(VAR_7.max_pdu_size);\n\t\tif (test_bit(VAR_16, &VAR_0->flags))\n\t\t\tVAR_0->ack_win = min_t(u16, VAR_0->ack_win, VAR_6);\n\t\telse\n\t\t\tVAR_0->ack_win = min_t(u16, VAR_0->ack_win,\n\t\t\t\t\t      VAR_7.txwin_size);\n\t\tbreak;\n\tcase VAR_12:\n\t\tVAR_0->mps    = le16_to_cpu(VAR_7.max_pdu_size);\n\t}\n}",
    "func_graph_path": "torvalds/linux/7c9cbd0b5e38a1672fcd137894ace3b042dfbf69/l2cap_core.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,8 @@\n \n \twhile (len >= L2CAP_CONF_OPT_SIZE) {\n \t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n+\t\tif (len < 0)\n+\t\t\tbreak;\n \n \t\tswitch (type) {\n \t\tcase L2CAP_CONF_RFC:",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\tif (len < 0)",
            "\t\t\tbreak;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}