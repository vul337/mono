{
    "cve_id": "CVE-2018-16509",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "ArtifexSoftware/ghostpdl",
    "commit_msg": "Improve restore robustness\n\nPrompted by looking at Bug 699654:\n\nThere are two variants of the restore operator in Ghostscript: one is Level 1\n(restoring VM), the other is Level 2+ (adding page device restoring to the\nLevel operator).\n\nThis was implemented by the Level 2+ version restoring the device in the\ngraphics state, then calling the Level 1 implementation to handle actually\nrestoring the VM state.\n\nThe problem was that the operand checking, and sanity of the save object was\nonly done by the Level 1 variant, thus meaning an invalid save object could\nleave a (Level 2+) restore partially complete - with the page device part\nrestored, but not VM, and the page device not configured.\n\nTo solve that, this commit splits the operand and sanity checking, and the\ncore of the restore operation into separate functions, so the relevant\noperators can validate the operand *before* taking any further action. That\nreduces the chances of an invalid restore leaving the interpreter in an\nunknown state.\n\nIf an error occurs during the actual VM restore it is essentially fatal, and the\ninterpreter cannot continue, but as an extra surety for security, in the event\nof such an error, we'll explicitly preserve the LockSafetyParams of the device,\nrather than rely on the post-restore device configuration (which won't happen\nin the event of an error).",
    "commit_hash": "5516c614dc33662a2afdc377159f70218e67bde5",
    "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/5516c614dc33662a2afdc377159f70218e67bde5",
    "file_path": "psi/zvmem.c",
    "func_name": "zrestore",
    "func_before": "int\nzrestore(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    alloc_save_t *asave;\n    bool last;\n    vm_save_t *vmsave;\n    int code = restore_check_operand(op, &asave, idmemory);\n\n    if (code < 0)\n        return code;\n    if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n               (ulong) alloc_save_client_data(asave),\n               (ulong) op->value.saveid);\n    if (I_VALIDATE_BEFORE_RESTORE)\n        ivalidate_clean_spaces(i_ctx_p);\n    /* Check the contents of the stacks. */\n    osp--;\n    {\n        int code;\n\n        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n            ) {\n            osp++;\n            return code;\n        }\n    }\n    /* Reset l_new in all stack entries if the new save level is zero. */\n    /* Also do some special fixing on the e-stack. */\n    restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n    restore_fix_stack(i_ctx_p, &e_stack, asave, true);\n    restore_fix_stack(i_ctx_p, &d_stack, asave, false);\n    /* Iteratively restore the state of memory, */\n    /* also doing a grestoreall at each step. */\n    do {\n        vmsave = alloc_save_client_data(alloc_save_current(idmemory));\n        /* Restore the graphics state. */\n        gs_grestoreall_for_restore(igs, vmsave->gsave);\n        /*\n         * If alloc_save_space decided to do a second save, the vmsave\n         * object was allocated one save level less deep than the\n         * current level, so ifree_object won't actually free it;\n         * however, it points to a gsave object that definitely\n         * *has* been freed.  In order not to trip up the garbage\n         * collector, we clear the gsave pointer now.\n         */\n        vmsave->gsave = 0;\n        /* Now it's safe to restore the state of memory. */\n        code = alloc_restore_step_in(idmemory, asave);\n        if (code < 0)\n            return code;\n        last = code;\n    }\n    while (!last);\n    {\n        uint space = icurrent_space;\n\n        ialloc_set_space(idmemory, avm_local);\n        ifree_object(vmsave, \"zrestore\");\n        ialloc_set_space(idmemory, space);\n    }\n    dict_set_top();\t\t/* reload dict stack cache */\n    if (I_VALIDATE_AFTER_RESTORE)\n        ivalidate_clean_spaces(i_ctx_p);\n    /* If the i_ctx_p LockFilePermissions is true, but the userparams */\n    /* we just restored is false, we need to make sure that we do not */\n    /* cause an 'invalidaccess' in setuserparams. Temporarily set     */\n    /* LockFilePermissions false until the gs_lev2.ps can do a        */\n    /* setuserparams from the restored userparam dictionary.          */\n    i_ctx_p->LockFilePermissions = false;\n    return 0;\n}",
    "abstract_func_before": "int\nzrestore(i_ctx_t *VAR_0)\n{\n    os_ptr VAR_1 = VAR_2;\n    alloc_save_t *VAR_3;\n    bool VAR_4;\n    vm_save_t *VAR_5;\n    int VAR_6 = restore_check_operand(VAR_1, &VAR_3, VAR_7);\n\n    if (VAR_6 < 0)\n        return VAR_6;\n    if_debug2m('u', VAR_8, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n               (ulong) alloc_save_client_data(VAR_3),\n               (ulong) VAR_1->value.saveid);\n    if (VAR_9)\n        ivalidate_clean_spaces(VAR_0);\n    /* COMMENT_0 */\n    VAR_2--;\n    {\n        int VAR_6;\n\n        if ((VAR_6 = restore_check_stack(VAR_0, &VAR_10, VAR_3, false)) < 0 ||\n            (VAR_6 = restore_check_stack(VAR_0, &VAR_11, VAR_3, true)) < 0 ||\n            (VAR_6 = restore_check_stack(VAR_0, &VAR_12, VAR_3, false)) < 0\n            ) {\n            VAR_2++;\n            return VAR_6;\n        }\n    }\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    restore_fix_stack(VAR_0, &VAR_10, VAR_3, false);\n    restore_fix_stack(VAR_0, &VAR_11, VAR_3, true);\n    restore_fix_stack(VAR_0, &VAR_12, VAR_3, false);\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    do {\n        VAR_5 = alloc_save_client_data(alloc_save_current(VAR_7));\n        /* COMMENT_5 */\n        gs_grestoreall_for_restore(VAR_13, VAR_5->gsave);\n        /* COMMENT_6 */\n                                                                      \n                                                                 \n                                                                 \n                                                               \n                                                                 \n                                                     \n           \n        VAR_5->gsave = 0;\n        /* COMMENT_14 */\n        VAR_6 = alloc_restore_step_in(VAR_7, VAR_3);\n        if (VAR_6 < 0)\n            return VAR_6;\n        VAR_4 = VAR_6;\n    }\n    while (!VAR_4);\n    {\n        uint VAR_14 = VAR_15;\n\n        ialloc_set_space(VAR_7, VAR_16);\n        ifree_object(VAR_5, \"zrestore\");\n        ialloc_set_space(VAR_7, VAR_14);\n    }\n    dict_set_top();\t\t/* COMMENT_15 */\n    if (VAR_17)\n        ivalidate_clean_spaces(VAR_0);\n    /* COMMENT_16 */\n    /* COMMENT_17 */\n    /* COMMENT_18 */\n    /* COMMENT_19 */\n    /* COMMENT_20 */\n    VAR_0->LockFilePermissions = false;\n    return 0;\n}",
    "func_graph_path_before": "ArtifexSoftware/ghostpdl/5516c614dc33662a2afdc377159f70218e67bde5/zvmem.c/vul/before/0.json",
    "func": "int\nzrestore(i_ctx_t *i_ctx_p)\n{\n    alloc_save_t *asave;\n    int code = restore_check_save(i_ctx_p, &asave);\n    if (code < 0)\n        return code;\n\n    return dorestore(i_ctx_p, asave);\n}",
    "abstract_func": "int\nzrestore(i_ctx_t *VAR_0)\n{\n    alloc_save_t *VAR_1;\n    int VAR_2 = restore_check_save(VAR_0, &VAR_1);\n    if (VAR_2 < 0)\n        return VAR_2;\n\n    return dorestore(VAR_0, VAR_1);\n}",
    "func_graph_path": "ArtifexSoftware/ghostpdl/5516c614dc33662a2afdc377159f70218e67bde5/zvmem.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,74 +1,10 @@\n int\n zrestore(i_ctx_t *i_ctx_p)\n {\n-    os_ptr op = osp;\n     alloc_save_t *asave;\n-    bool last;\n-    vm_save_t *vmsave;\n-    int code = restore_check_operand(op, &asave, idmemory);\n-\n+    int code = restore_check_save(i_ctx_p, &asave);\n     if (code < 0)\n         return code;\n-    if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n-               (ulong) alloc_save_client_data(asave),\n-               (ulong) op->value.saveid);\n-    if (I_VALIDATE_BEFORE_RESTORE)\n-        ivalidate_clean_spaces(i_ctx_p);\n-    /* Check the contents of the stacks. */\n-    osp--;\n-    {\n-        int code;\n \n-        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n-            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n-            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n-            ) {\n-            osp++;\n-            return code;\n-        }\n-    }\n-    /* Reset l_new in all stack entries if the new save level is zero. */\n-    /* Also do some special fixing on the e-stack. */\n-    restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n-    restore_fix_stack(i_ctx_p, &e_stack, asave, true);\n-    restore_fix_stack(i_ctx_p, &d_stack, asave, false);\n-    /* Iteratively restore the state of memory, */\n-    /* also doing a grestoreall at each step. */\n-    do {\n-        vmsave = alloc_save_client_data(alloc_save_current(idmemory));\n-        /* Restore the graphics state. */\n-        gs_grestoreall_for_restore(igs, vmsave->gsave);\n-        /*\n-         * If alloc_save_space decided to do a second save, the vmsave\n-         * object was allocated one save level less deep than the\n-         * current level, so ifree_object won't actually free it;\n-         * however, it points to a gsave object that definitely\n-         * *has* been freed.  In order not to trip up the garbage\n-         * collector, we clear the gsave pointer now.\n-         */\n-        vmsave->gsave = 0;\n-        /* Now it's safe to restore the state of memory. */\n-        code = alloc_restore_step_in(idmemory, asave);\n-        if (code < 0)\n-            return code;\n-        last = code;\n-    }\n-    while (!last);\n-    {\n-        uint space = icurrent_space;\n-\n-        ialloc_set_space(idmemory, avm_local);\n-        ifree_object(vmsave, \"zrestore\");\n-        ialloc_set_space(idmemory, space);\n-    }\n-    dict_set_top();\t\t/* reload dict stack cache */\n-    if (I_VALIDATE_AFTER_RESTORE)\n-        ivalidate_clean_spaces(i_ctx_p);\n-    /* If the i_ctx_p LockFilePermissions is true, but the userparams */\n-    /* we just restored is false, we need to make sure that we do not */\n-    /* cause an 'invalidaccess' in setuserparams. Temporarily set     */\n-    /* LockFilePermissions false until the gs_lev2.ps can do a        */\n-    /* setuserparams from the restored userparam dictionary.          */\n-    i_ctx_p->LockFilePermissions = false;\n-    return 0;\n+    return dorestore(i_ctx_p, asave);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "    os_ptr op = osp;",
            "    bool last;",
            "    vm_save_t *vmsave;",
            "    int code = restore_check_operand(op, &asave, idmemory);",
            "",
            "    if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",",
            "               (ulong) alloc_save_client_data(asave),",
            "               (ulong) op->value.saveid);",
            "    if (I_VALIDATE_BEFORE_RESTORE)",
            "        ivalidate_clean_spaces(i_ctx_p);",
            "    /* Check the contents of the stacks. */",
            "    osp--;",
            "    {",
            "        int code;",
            "        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||",
            "            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||",
            "            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0",
            "            ) {",
            "            osp++;",
            "            return code;",
            "        }",
            "    }",
            "    /* Reset l_new in all stack entries if the new save level is zero. */",
            "    /* Also do some special fixing on the e-stack. */",
            "    restore_fix_stack(i_ctx_p, &o_stack, asave, false);",
            "    restore_fix_stack(i_ctx_p, &e_stack, asave, true);",
            "    restore_fix_stack(i_ctx_p, &d_stack, asave, false);",
            "    /* Iteratively restore the state of memory, */",
            "    /* also doing a grestoreall at each step. */",
            "    do {",
            "        vmsave = alloc_save_client_data(alloc_save_current(idmemory));",
            "        /* Restore the graphics state. */",
            "        gs_grestoreall_for_restore(igs, vmsave->gsave);",
            "        /*",
            "         * If alloc_save_space decided to do a second save, the vmsave",
            "         * object was allocated one save level less deep than the",
            "         * current level, so ifree_object won't actually free it;",
            "         * however, it points to a gsave object that definitely",
            "         * *has* been freed.  In order not to trip up the garbage",
            "         * collector, we clear the gsave pointer now.",
            "         */",
            "        vmsave->gsave = 0;",
            "        /* Now it's safe to restore the state of memory. */",
            "        code = alloc_restore_step_in(idmemory, asave);",
            "        if (code < 0)",
            "            return code;",
            "        last = code;",
            "    }",
            "    while (!last);",
            "    {",
            "        uint space = icurrent_space;",
            "",
            "        ialloc_set_space(idmemory, avm_local);",
            "        ifree_object(vmsave, \"zrestore\");",
            "        ialloc_set_space(idmemory, space);",
            "    }",
            "    dict_set_top();\t\t/* reload dict stack cache */",
            "    if (I_VALIDATE_AFTER_RESTORE)",
            "        ivalidate_clean_spaces(i_ctx_p);",
            "    /* If the i_ctx_p LockFilePermissions is true, but the userparams */",
            "    /* we just restored is false, we need to make sure that we do not */",
            "    /* cause an 'invalidaccess' in setuserparams. Temporarily set     */",
            "    /* LockFilePermissions false until the gs_lev2.ps can do a        */",
            "    /* setuserparams from the restored userparam dictionary.          */",
            "    i_ctx_p->LockFilePermissions = false;",
            "    return 0;"
        ],
        "added_lines": [
            "    int code = restore_check_save(i_ctx_p, &asave);",
            "    return dorestore(i_ctx_p, asave);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}