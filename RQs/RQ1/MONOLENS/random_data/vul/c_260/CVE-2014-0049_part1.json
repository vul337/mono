{
    "cve_id": "CVE-2014-0049",
    "cwe_ids": [
        "CWE-120"
    ],
    "cvss_vector": "AV:A/AC:M/Au:S/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "kvm: x86: fix emulator buffer overflow (CVE-2014-0049)\n\nThe problem occurs when the guest performs a pusha with the stack\naddress pointing to an mmio address (or an invalid guest physical\naddress) to start with, but then extending into an ordinary guest\nphysical address.  When doing repeated emulated pushes\nemulator_read_write sets mmio_needed to 1 on the first one.  On a\nlater push when the stack points to regular memory,\nmmio_nr_fragments is set to 0, but mmio_is_needed is not set to 0.\n\nAs a result, KVM exits to userspace, and then returns to\ncomplete_emulated_mmio.  In complete_emulated_mmio\nvcpu->mmio_cur_fragment is incremented.  The termination condition of\nvcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments is never achieved.\nThe code bounces back and fourth to userspace incrementing\nmmio_cur_fragment past it's buffer.  If the guest does nothing else it\neventually leads to a a crash on a memcpy from invalid memory address.\n\nHowever if a guest code can cause the vm to be destroyed in another\nvcpu with excellent timing, then kvm_clear_async_pf_completion_queue\ncan be used by the guest to control the data that's pointed to by the\ncall to cancel_work_item, which can be used to gain execution.\n\nFixes: f78146b0f9230765c6315b2e14f56112513389ad\nSigned-off-by: Andrew Honig <ahonig@google.com>\nCc: stable@vger.kernel.org (3.5+)\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "commit_hash": "a08d3b3b99efd509133946056531cdf8f3a0c09b",
    "git_url": "https://github.com/torvalds/linux/commit/a08d3b3b99efd509133946056531cdf8f3a0c09b",
    "file_path": "arch/x86/kvm/x86.c",
    "func_name": "complete_emulated_mmio",
    "func_before": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}",
    "abstract_func_before": "static int complete_emulated_mmio(struct kvm_vcpu *VAR_0)\n{\n\tstruct kvm_run *VAR_1 = VAR_0->run;\n\tstruct kvm_mmio_fragment *VAR_2;\n\tunsigned VAR_3;\n\n\tBUG_ON(!VAR_0->mmio_needed);\n\n\t/* COMMENT_0 */\n\tVAR_2 = &VAR_0->mmio_fragments[VAR_0->mmio_cur_fragment];\n\tVAR_3 = min(8u, VAR_2->len);\n\tif (!VAR_0->mmio_is_write)\n\t\tmemcpy(VAR_2->data, VAR_1->mmio.data, VAR_3);\n\n\tif (VAR_2->len <= 8) {\n\t\t/* COMMENT_1 */\n\t\tVAR_2++;\n\t\tVAR_0->mmio_cur_fragment++;\n\t} else {\n\t\t/* COMMENT_2 */\n\t\tVAR_2->data += VAR_3;\n\t\tVAR_2->gpa += VAR_3;\n\t\tVAR_2->len -= VAR_3;\n\t}\n\n\tif (VAR_0->mmio_cur_fragment == VAR_0->mmio_nr_fragments) {\n\t\tVAR_0->mmio_needed = 0;\n\n\t\t/* COMMENT_3 */\n\t\tif (VAR_0->mmio_is_write)\n\t\t\treturn 1;\n\t\tVAR_0->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(VAR_0);\n\t}\n\n\tVAR_1->exit_reason = VAR_4;\n\tVAR_1->mmio.phys_addr = VAR_2->gpa;\n\tif (VAR_0->mmio_is_write)\n\t\tmemcpy(VAR_1->mmio.data, VAR_2->data, min(8u, VAR_2->len));\n\tVAR_1->mmio.len = min(8u, VAR_2->len);\n\tVAR_1->mmio.is_write = VAR_0->mmio_is_write;\n\tVAR_0->arch.complete_userspace_io = VAR_5;\n\treturn 0;\n}",
    "func_graph_path_before": "torvalds/linux/a08d3b3b99efd509133946056531cdf8f3a0c09b/x86.c/vul/before/0.json",
    "func": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}",
    "abstract_func": "static int complete_emulated_mmio(struct kvm_vcpu *VAR_0)\n{\n\tstruct kvm_run *VAR_1 = VAR_0->run;\n\tstruct kvm_mmio_fragment *VAR_2;\n\tunsigned VAR_3;\n\n\tBUG_ON(!VAR_0->mmio_needed);\n\n\t/* COMMENT_0 */\n\tVAR_2 = &VAR_0->mmio_fragments[VAR_0->mmio_cur_fragment];\n\tVAR_3 = min(8u, VAR_2->len);\n\tif (!VAR_0->mmio_is_write)\n\t\tmemcpy(VAR_2->data, VAR_1->mmio.data, VAR_3);\n\n\tif (VAR_2->len <= 8) {\n\t\t/* COMMENT_1 */\n\t\tVAR_2++;\n\t\tVAR_0->mmio_cur_fragment++;\n\t} else {\n\t\t/* COMMENT_2 */\n\t\tVAR_2->data += VAR_3;\n\t\tVAR_2->gpa += VAR_3;\n\t\tVAR_2->len -= VAR_3;\n\t}\n\n\tif (VAR_0->mmio_cur_fragment >= VAR_0->mmio_nr_fragments) {\n\t\tVAR_0->mmio_needed = 0;\n\n\t\t/* COMMENT_3 */\n\t\tif (VAR_0->mmio_is_write)\n\t\t\treturn 1;\n\t\tVAR_0->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(VAR_0);\n\t}\n\n\tVAR_1->exit_reason = VAR_4;\n\tVAR_1->mmio.phys_addr = VAR_2->gpa;\n\tif (VAR_0->mmio_is_write)\n\t\tmemcpy(VAR_1->mmio.data, VAR_2->data, min(8u, VAR_2->len));\n\tVAR_1->mmio.len = min(8u, VAR_2->len);\n\tVAR_1->mmio.is_write = VAR_0->mmio_is_write;\n\tVAR_0->arch.complete_userspace_io = VAR_5;\n\treturn 0;\n}",
    "func_graph_path": "torvalds/linux/a08d3b3b99efd509133946056531cdf8f3a0c09b/x86.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n \t\tfrag->len -= len;\n \t}\n \n-\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n+\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n \t\tvcpu->mmio_needed = 0;\n \n \t\t/* FIXME: return into emulator if single-stepping.  */",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {"
        ],
        "added_lines": [
            "\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}