{
    "cve_id": "CVE-2016-5407",
    "cwe_ids": [
        "CWE-119",
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "xorg/lib/libXv",
    "commit_msg": "The Xv query functions for adaptors and encodings suffer from out of\nboundary accesses if a hostile X server sends a maliciously crafted\nresponse.\n\nA previous fix already checks the received length against fixed values\nbut ignores additional length specifications which are stored inside\nthe received data.\n\nThese lengths are accessed in a for-loop. The easiest way to guarantee\na correct processing is by validating all lengths against the\nremaining size left before accessing referenced memory.\n\nThis makes the previously applied check obsolete, therefore I removed\nit.\n\nSigned-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>\nReviewed-by: Matthieu Herrb <matthieu@herrb.eu>\n",
    "commit_hash": "d9da580b46a28ab497de2e94fdc7b9ff953dab17",
    "git_url": "https://cgit.freedesktop.org/xorg/lib/libXv/commit/?id=d9da580b46a28ab497de2e94fdc7b9ff953dab17",
    "file_path": "src/Xv.c",
    "func_name": "XvQueryAdaptors",
    "func_before": "int\nXvQueryAdaptors(\n    Display *dpy,\n    Window window,\n    unsigned int *p_nAdaptors,\n    XvAdaptorInfo **p_pAdaptors)\n{\n    XExtDisplayInfo *info = xv_find_display(dpy);\n    xvQueryAdaptorsReq *req;\n    xvQueryAdaptorsReply rep;\n    size_t size;\n    unsigned int ii, jj;\n    char *name;\n    XvAdaptorInfo *pas = NULL, *pa;\n    XvFormat *pfs, *pf;\n    char *buffer = NULL;\n    union {\n        char *buffer;\n        char *string;\n        xvAdaptorInfo *pa;\n        xvFormat *pf;\n    } u;\n    int status;\n\n    XvCheckExtension(dpy, info, XvBadExtension);\n\n    LockDisplay(dpy);\n\n    XvGetReq(QueryAdaptors, req);\n    req->window = window;\n\n    /* READ THE REPLY */\n\n    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {\n        rep.num_adaptors = 0;\n        status = XvBadReply;\n        goto out;\n    }\n\n    size = rep.length << 2;\n    if (size > 0) {\n        if ((buffer = Xmalloc(size)) == NULL) {\n            _XEatDataWords(dpy, rep.length);\n            status = XvBadAlloc;\n            goto out;\n        }\n        _XRead(dpy, buffer, (long) size);\n    }\n\n    /* GET INPUT ADAPTORS */\n\n    if (rep.num_adaptors == 0) {\n        /* If there's no adaptors, there's nothing more to do. */\n        status = Success;\n        goto out;\n    }\n\n    if (size < (rep.num_adaptors * sz_xvAdaptorInfo)) {\n        /* If there's not enough data for the number of adaptors,\n           then we have a problem. */\n        status = XvBadReply;\n        goto out;\n    }\n\n    size = rep.num_adaptors * sizeof(XvAdaptorInfo);\n    if ((pas = Xmalloc(size)) == NULL) {\n        status = XvBadAlloc;\n        goto out;\n    }\n\n    /* INIT ADAPTOR FIELDS */\n\n    pa = pas;\n    for (ii = 0; ii < rep.num_adaptors; ii++) {\n        pa->num_adaptors = 0;\n        pa->name = (char *) NULL;\n        pa->formats = (XvFormat *) NULL;\n        pa++;\n    }\n\n    u.buffer = buffer;\n    pa = pas;\n    for (ii = 0; ii < rep.num_adaptors; ii++) {\n        pa->type = u.pa->type;\n        pa->base_id = u.pa->base_id;\n        pa->num_ports = u.pa->num_ports;\n        pa->num_formats = u.pa->num_formats;\n        pa->num_adaptors = rep.num_adaptors - ii;\n\n        /* GET ADAPTOR NAME */\n\n        size = u.pa->name_size;\n        u.buffer += pad_to_int32(sz_xvAdaptorInfo);\n\n        if ((name = Xmalloc(size + 1)) == NULL) {\n            status = XvBadAlloc;\n            goto out;\n        }\n        (void) strncpy(name, u.string, size);\n        name[size] = '\\0';\n        pa->name = name;\n\n        u.buffer += pad_to_int32(size);\n\n        /* GET FORMATS */\n\n        size = pa->num_formats * sizeof(XvFormat);\n        if ((pfs = Xmalloc(size)) == NULL) {\n            status = XvBadAlloc;\n            goto out;\n        }\n\n        pf = pfs;\n        for (jj = 0; jj < pa->num_formats; jj++) {\n            pf->depth = u.pf->depth;\n            pf->visual_id = u.pf->visual;\n            pf++;\n\n            u.buffer += pad_to_int32(sz_xvFormat);\n        }\n\n        pa->formats = pfs;\n\n        pa++;\n\n    }\n\n    status = Success;\n\n  out:\n    if (status != Success) {\n        XvFreeAdaptorInfo(pas);\n        pas = NULL;\n    }\n\n    *p_nAdaptors = rep.num_adaptors;\n    *p_pAdaptors = pas;\n\n    Xfree(buffer);\n    UnlockDisplay(dpy);\n    SyncHandle();\n\n    return status;\n}",
    "abstract_func_before": "int\nXvQueryAdaptors(\n    Display *VAR_0,\n    Window VAR_1,\n    unsigned int *VAR_2,\n    XvAdaptorInfo **VAR_3)\n{\n    XExtDisplayInfo *VAR_4 = xv_find_display(VAR_0);\n    xvQueryAdaptorsReq *VAR_5;\n    xvQueryAdaptorsReply VAR_6;\n    size_t VAR_7;\n    unsigned int VAR_8, VAR_9;\n    char *VAR_10;\n    XvAdaptorInfo *VAR_11 = NULL, *VAR_12;\n    XvFormat *VAR_13, *VAR_14;\n    char *VAR_15 = NULL;\n    union {\n        char *buffer;\n        char *string;\n        xvAdaptorInfo *pa;\n        xvFormat *pf;\n    } VAR_16;\n    int VAR_17;\n\n    XvCheckExtension(VAR_0, VAR_4, VAR_18);\n\n    LockDisplay(VAR_0);\n\n    XvGetReq(VAR_19, VAR_5);\n    VAR_5->window = VAR_1;\n\n    /* COMMENT_0 */\n\n    if (_XReply(VAR_0, (xReply *) &VAR_6, 0, VAR_20) == 0) {\n        VAR_6.num_adaptors = 0;\n        VAR_17 = VAR_21;\n        goto out;\n    }\n\n    VAR_7 = VAR_6.length << 2;\n    if (VAR_7 > 0) {\n        if ((VAR_15 = Xmalloc(VAR_7)) == NULL) {\n            _XEatDataWords(VAR_0, VAR_6.length);\n            VAR_17 = VAR_22;\n            goto out;\n        }\n        _XRead(VAR_0, VAR_15, (long) VAR_7);\n    }\n\n    /* COMMENT_1 */\n\n    if (VAR_6.num_adaptors == 0) {\n        /* COMMENT_2 */\n        VAR_17 = VAR_23;\n        goto out;\n    }\n\n    if (VAR_7 < (VAR_6.num_adaptors * VAR_24)) {\n        /* COMMENT_3 */\n                                     \n        VAR_17 = VAR_21;\n        goto out;\n    }\n\n    VAR_7 = VAR_6.num_adaptors * sizeof(XvAdaptorInfo);\n    if ((VAR_11 = Xmalloc(VAR_7)) == NULL) {\n        VAR_17 = VAR_22;\n        goto out;\n    }\n\n    /* COMMENT_5 */\n\n    VAR_12 = VAR_11;\n    for (VAR_8 = 0; VAR_8 < VAR_6.num_adaptors; VAR_8++) {\n        VAR_12->num_adaptors = 0;\n        VAR_12->name = (char *) NULL;\n        VAR_12->formats = (XvFormat *) NULL;\n        VAR_12++;\n    }\n\n    VAR_16.buffer = VAR_15;\n    VAR_12 = VAR_11;\n    for (VAR_8 = 0; VAR_8 < VAR_6.num_adaptors; VAR_8++) {\n        VAR_12->type = VAR_16.pa->type;\n        VAR_12->base_id = VAR_16.pa->base_id;\n        VAR_12->num_ports = VAR_16.pa->num_ports;\n        VAR_12->num_formats = VAR_16.pa->num_formats;\n        VAR_12->num_adaptors = VAR_6.num_adaptors - VAR_8;\n\n        /* COMMENT_6 */\n\n        VAR_7 = VAR_16.pa->name_size;\n        VAR_16.buffer += pad_to_int32(VAR_24);\n\n        if ((VAR_10 = Xmalloc(VAR_7 + 1)) == NULL) {\n            VAR_17 = VAR_22;\n            goto out;\n        }\n        (void) strncpy(VAR_10, VAR_16.string, VAR_7);\n        VAR_10[VAR_7] = '\\0';\n        VAR_12->name = VAR_10;\n\n        VAR_16.buffer += pad_to_int32(VAR_7);\n\n        /* COMMENT_7 */\n\n        VAR_7 = VAR_12->num_formats * sizeof(XvFormat);\n        if ((VAR_13 = Xmalloc(VAR_7)) == NULL) {\n            VAR_17 = VAR_22;\n            goto out;\n        }\n\n        VAR_14 = VAR_13;\n        for (VAR_9 = 0; VAR_9 < VAR_12->num_formats; VAR_9++) {\n            VAR_14->depth = VAR_16.pf->depth;\n            VAR_14->visual_id = VAR_16.pf->visual;\n            VAR_14++;\n\n            VAR_16.buffer += pad_to_int32(VAR_25);\n        }\n\n        VAR_12->formats = VAR_13;\n\n        VAR_12++;\n\n    }\n\n    VAR_17 = VAR_23;\n\n  out:\n    if (VAR_17 != VAR_23) {\n        XvFreeAdaptorInfo(VAR_11);\n        VAR_11 = NULL;\n    }\n\n    *VAR_2 = VAR_6.num_adaptors;\n    *VAR_3 = VAR_11;\n\n    Xfree(VAR_15);\n    UnlockDisplay(VAR_0);\n    SyncHandle();\n\n    return VAR_17;\n}",
    "func_graph_path_before": "xorg/lib/libXv/d9da580b46a28ab497de2e94fdc7b9ff953dab17/Xv.c/vul/before/0.json",
    "func": "int\nXvQueryAdaptors(\n    Display *dpy,\n    Window window,\n    unsigned int *p_nAdaptors,\n    XvAdaptorInfo **p_pAdaptors)\n{\n    XExtDisplayInfo *info = xv_find_display(dpy);\n    xvQueryAdaptorsReq *req;\n    xvQueryAdaptorsReply rep;\n    size_t size;\n    unsigned int ii, jj;\n    char *name;\n    char *end;\n    XvAdaptorInfo *pas = NULL, *pa;\n    XvFormat *pfs, *pf;\n    char *buffer = NULL;\n    union {\n        char *buffer;\n        char *string;\n        xvAdaptorInfo *pa;\n        xvFormat *pf;\n    } u;\n    int status;\n\n    XvCheckExtension(dpy, info, XvBadExtension);\n\n    LockDisplay(dpy);\n\n    XvGetReq(QueryAdaptors, req);\n    req->window = window;\n\n    /* READ THE REPLY */\n\n    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {\n        rep.num_adaptors = 0;\n        status = XvBadReply;\n        goto out;\n    }\n\n    size = rep.length << 2;\n    if (size > 0) {\n        if ((buffer = Xmalloc(size)) == NULL) {\n            _XEatDataWords(dpy, rep.length);\n            status = XvBadAlloc;\n            goto out;\n        }\n        _XRead(dpy, buffer, (long) size);\n    }\n\n    /* GET INPUT ADAPTORS */\n\n    if (rep.num_adaptors == 0) {\n        /* If there are no adaptors, there's nothing more to do. */\n        status = Success;\n        goto out;\n    }\n\n    u.buffer = buffer;\n    end = buffer + size;\n\n    size = rep.num_adaptors * sizeof(XvAdaptorInfo);\n    if ((pas = Xmalloc(size)) == NULL) {\n        status = XvBadAlloc;\n        goto out;\n    }\n\n    /* INIT ADAPTOR FIELDS */\n\n    pa = pas;\n    for (ii = 0; ii < rep.num_adaptors; ii++) {\n        pa->num_adaptors = 0;\n        pa->name = (char *) NULL;\n        pa->formats = (XvFormat *) NULL;\n        pa++;\n    }\n\n    pa = pas;\n    for (ii = 0; ii < rep.num_adaptors; ii++) {\n        if (u.buffer + sz_xvAdaptorInfo > end) {\n            status = XvBadReply;\n            goto out;\n        }\n        pa->type = u.pa->type;\n        pa->base_id = u.pa->base_id;\n        pa->num_ports = u.pa->num_ports;\n        pa->num_formats = u.pa->num_formats;\n        pa->num_adaptors = rep.num_adaptors - ii;\n\n        /* GET ADAPTOR NAME */\n\n        size = u.pa->name_size;\n        u.buffer += pad_to_int32(sz_xvAdaptorInfo);\n\n        if (u.buffer + size > end) {\n            status = XvBadReply;\n            goto out;\n        }\n        if ((name = Xmalloc(size + 1)) == NULL) {\n            status = XvBadAlloc;\n            goto out;\n        }\n        (void) strncpy(name, u.string, size);\n        name[size] = '\\0';\n        pa->name = name;\n\n        u.buffer += pad_to_int32(size);\n\n        /* GET FORMATS */\n\n        size = pa->num_formats * sizeof(XvFormat);\n        if ((pfs = Xmalloc(size)) == NULL) {\n            status = XvBadAlloc;\n            goto out;\n        }\n\n        pf = pfs;\n        for (jj = 0; jj < pa->num_formats; jj++) {\n            if (u.buffer + sz_xvFormat > end) {\n                Xfree(pfs);\n                status = XvBadReply;\n                goto out;\n            }\n            pf->depth = u.pf->depth;\n            pf->visual_id = u.pf->visual;\n            pf++;\n\n            u.buffer += pad_to_int32(sz_xvFormat);\n        }\n\n        pa->formats = pfs;\n\n        pa++;\n\n    }\n\n    status = Success;\n\n  out:\n    if (status != Success) {\n        XvFreeAdaptorInfo(pas);\n        pas = NULL;\n    }\n\n    *p_nAdaptors = rep.num_adaptors;\n    *p_pAdaptors = pas;\n\n    Xfree(buffer);\n    UnlockDisplay(dpy);\n    SyncHandle();\n\n    return status;\n}",
    "abstract_func": "int\nXvQueryAdaptors(\n    Display *VAR_0,\n    Window VAR_1,\n    unsigned int *VAR_2,\n    XvAdaptorInfo **VAR_3)\n{\n    XExtDisplayInfo *VAR_4 = xv_find_display(VAR_0);\n    xvQueryAdaptorsReq *VAR_5;\n    xvQueryAdaptorsReply VAR_6;\n    size_t VAR_7;\n    unsigned int VAR_8, VAR_9;\n    char *VAR_10;\n    char *VAR_11;\n    XvAdaptorInfo *VAR_12 = NULL, *VAR_13;\n    XvFormat *VAR_14, *VAR_15;\n    char *VAR_16 = NULL;\n    union {\n        char *buffer;\n        char *string;\n        xvAdaptorInfo *pa;\n        xvFormat *pf;\n    } VAR_17;\n    int VAR_18;\n\n    XvCheckExtension(VAR_0, VAR_4, VAR_19);\n\n    LockDisplay(VAR_0);\n\n    XvGetReq(VAR_20, VAR_5);\n    VAR_5->window = VAR_1;\n\n    /* COMMENT_0 */\n\n    if (_XReply(VAR_0, (xReply *) &VAR_6, 0, VAR_21) == 0) {\n        VAR_6.num_adaptors = 0;\n        VAR_18 = VAR_22;\n        goto out;\n    }\n\n    VAR_7 = VAR_6.length << 2;\n    if (VAR_7 > 0) {\n        if ((VAR_16 = Xmalloc(VAR_7)) == NULL) {\n            _XEatDataWords(VAR_0, VAR_6.length);\n            VAR_18 = VAR_23;\n            goto out;\n        }\n        _XRead(VAR_0, VAR_16, (long) VAR_7);\n    }\n\n    /* COMMENT_1 */\n\n    if (VAR_6.num_adaptors == 0) {\n        /* COMMENT_2 */\n        VAR_18 = VAR_24;\n        goto out;\n    }\n\n    VAR_17.buffer = VAR_16;\n    VAR_11 = VAR_16 + VAR_7;\n\n    VAR_7 = VAR_6.num_adaptors * sizeof(XvAdaptorInfo);\n    if ((VAR_12 = Xmalloc(VAR_7)) == NULL) {\n        VAR_18 = VAR_23;\n        goto out;\n    }\n\n    /* COMMENT_3 */\n\n    VAR_13 = VAR_12;\n    for (VAR_8 = 0; VAR_8 < VAR_6.num_adaptors; VAR_8++) {\n        VAR_13->num_adaptors = 0;\n        VAR_13->name = (char *) NULL;\n        VAR_13->formats = (XvFormat *) NULL;\n        VAR_13++;\n    }\n\n    VAR_13 = VAR_12;\n    for (VAR_8 = 0; VAR_8 < VAR_6.num_adaptors; VAR_8++) {\n        if (VAR_17.buffer + VAR_25 > VAR_11) {\n            VAR_18 = VAR_22;\n            goto out;\n        }\n        VAR_13->type = VAR_17.pa->type;\n        VAR_13->base_id = VAR_17.pa->base_id;\n        VAR_13->num_ports = VAR_17.pa->num_ports;\n        VAR_13->num_formats = VAR_17.pa->num_formats;\n        VAR_13->num_adaptors = VAR_6.num_adaptors - VAR_8;\n\n        /* COMMENT_4 */\n\n        VAR_7 = VAR_17.pa->name_size;\n        VAR_17.buffer += pad_to_int32(VAR_25);\n\n        if (VAR_17.buffer + VAR_7 > VAR_11) {\n            VAR_18 = VAR_22;\n            goto out;\n        }\n        if ((VAR_10 = Xmalloc(VAR_7 + 1)) == NULL) {\n            VAR_18 = VAR_23;\n            goto out;\n        }\n        (void) strncpy(VAR_10, VAR_17.string, VAR_7);\n        VAR_10[VAR_7] = '\\0';\n        VAR_13->name = VAR_10;\n\n        VAR_17.buffer += pad_to_int32(VAR_7);\n\n        /* COMMENT_5 */\n\n        VAR_7 = VAR_13->num_formats * sizeof(XvFormat);\n        if ((VAR_14 = Xmalloc(VAR_7)) == NULL) {\n            VAR_18 = VAR_23;\n            goto out;\n        }\n\n        VAR_15 = VAR_14;\n        for (VAR_9 = 0; VAR_9 < VAR_13->num_formats; VAR_9++) {\n            if (VAR_17.buffer + VAR_26 > VAR_11) {\n                Xfree(VAR_14);\n                VAR_18 = VAR_22;\n                goto out;\n            }\n            VAR_15->depth = VAR_17.pf->depth;\n            VAR_15->visual_id = VAR_17.pf->visual;\n            VAR_15++;\n\n            VAR_17.buffer += pad_to_int32(VAR_26);\n        }\n\n        VAR_13->formats = VAR_14;\n\n        VAR_13++;\n\n    }\n\n    VAR_18 = VAR_24;\n\n  out:\n    if (VAR_18 != VAR_24) {\n        XvFreeAdaptorInfo(VAR_12);\n        VAR_12 = NULL;\n    }\n\n    *VAR_2 = VAR_6.num_adaptors;\n    *VAR_3 = VAR_12;\n\n    Xfree(VAR_16);\n    UnlockDisplay(VAR_0);\n    SyncHandle();\n\n    return VAR_18;\n}",
    "func_graph_path": "xorg/lib/libXv/d9da580b46a28ab497de2e94fdc7b9ff953dab17/Xv.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,7 @@\n     size_t size;\n     unsigned int ii, jj;\n     char *name;\n+    char *end;\n     XvAdaptorInfo *pas = NULL, *pa;\n     XvFormat *pfs, *pf;\n     char *buffer = NULL;\n@@ -50,17 +51,13 @@\n     /* GET INPUT ADAPTORS */\n \n     if (rep.num_adaptors == 0) {\n-        /* If there's no adaptors, there's nothing more to do. */\n+        /* If there are no adaptors, there's nothing more to do. */\n         status = Success;\n         goto out;\n     }\n \n-    if (size < (rep.num_adaptors * sz_xvAdaptorInfo)) {\n-        /* If there's not enough data for the number of adaptors,\n-           then we have a problem. */\n-        status = XvBadReply;\n-        goto out;\n-    }\n+    u.buffer = buffer;\n+    end = buffer + size;\n \n     size = rep.num_adaptors * sizeof(XvAdaptorInfo);\n     if ((pas = Xmalloc(size)) == NULL) {\n@@ -78,9 +75,12 @@\n         pa++;\n     }\n \n-    u.buffer = buffer;\n     pa = pas;\n     for (ii = 0; ii < rep.num_adaptors; ii++) {\n+        if (u.buffer + sz_xvAdaptorInfo > end) {\n+            status = XvBadReply;\n+            goto out;\n+        }\n         pa->type = u.pa->type;\n         pa->base_id = u.pa->base_id;\n         pa->num_ports = u.pa->num_ports;\n@@ -92,6 +92,10 @@\n         size = u.pa->name_size;\n         u.buffer += pad_to_int32(sz_xvAdaptorInfo);\n \n+        if (u.buffer + size > end) {\n+            status = XvBadReply;\n+            goto out;\n+        }\n         if ((name = Xmalloc(size + 1)) == NULL) {\n             status = XvBadAlloc;\n             goto out;\n@@ -112,6 +116,11 @@\n \n         pf = pfs;\n         for (jj = 0; jj < pa->num_formats; jj++) {\n+            if (u.buffer + sz_xvFormat > end) {\n+                Xfree(pfs);\n+                status = XvBadReply;\n+                goto out;\n+            }\n             pf->depth = u.pf->depth;\n             pf->visual_id = u.pf->visual;\n             pf++;",
    "diff_line_info": {
        "deleted_lines": [
            "        /* If there's no adaptors, there's nothing more to do. */",
            "    if (size < (rep.num_adaptors * sz_xvAdaptorInfo)) {",
            "        /* If there's not enough data for the number of adaptors,",
            "           then we have a problem. */",
            "        status = XvBadReply;",
            "        goto out;",
            "    }",
            "    u.buffer = buffer;"
        ],
        "added_lines": [
            "    char *end;",
            "        /* If there are no adaptors, there's nothing more to do. */",
            "    u.buffer = buffer;",
            "    end = buffer + size;",
            "        if (u.buffer + sz_xvAdaptorInfo > end) {",
            "            status = XvBadReply;",
            "            goto out;",
            "        }",
            "        if (u.buffer + size > end) {",
            "            status = XvBadReply;",
            "            goto out;",
            "        }",
            "            if (u.buffer + sz_xvFormat > end) {",
            "                Xfree(pfs);",
            "                status = XvBadReply;",
            "                goto out;",
            "            }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}