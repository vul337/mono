{
    "cve_id": "CVE-2022-0171",
    "cwe_ids": [
        "CWE-212"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "Flush the CPU caches when memory is reclaimed from an SEV guest (where\nreclaim also includes it being unmapped from KVM's memslots).  Due to lack\nof coherency for SEV encrypted memory, failure to flush results in silent\ndata corruption if userspace is malicious/broken and doesn't ensure SEV\nguest memory is properly pinned and unpinned.\n\nCache coherency is not enforced across the VM boundary in SEV (AMD APM\nvol.2 Section 15.34.7). Confidential cachelines, generated by confidential\nVM guests have to be explicitly flushed on the host side. If a memory page\ncontaining dirty confidential cachelines was released by VM and reallocated\nto another user, the cachelines may corrupt the new user at a later time.\n\nKVM takes a shortcut by assuming all confidential memory remain pinned\nuntil the end of VM lifetime. Therefore, KVM does not flush cache at\nmmu_notifier invalidation events. Because of this incorrect assumption and\nthe lack of cache flushing, malicous userspace can crash the host kernel:\ncreating a malicious VM and continuously allocates/releases unpinned\nconfidential memory pages when the VM is running.\n\nAdd cache flush operations to mmu_notifier operations to ensure that any\nphysical memory leaving the guest VM get flushed. In particular, hook\nmmu_notifier_invalidate_range_start and mmu_notifier_release events and\nflush cache accordingly. The hook after releasing the mmu lock to avoid\ncontention with other vCPUs.\n\nCc: stable@vger.kernel.org\nSuggested-by: Sean Christpherson <seanjc@google.com>\nReported-by: Mingwei Zhang <mizhang@google.com>\nSigned-off-by: Mingwei Zhang <mizhang@google.com>\nMessage-Id: <20220421031407.2516575-4-mizhang@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n",
    "commit_hash": "683412ccf61294d727ead4a73d97397396e69a6b",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=683412ccf61294d727ead4a73d97397396e69a6b",
    "file_path": "virt/kvm/kvm_main.c",
    "func_name": "kvm_handle_hva_range_no_flush",
    "func_before": "static __always_inline int kvm_handle_hva_range_no_flush(struct mmu_notifier *mn,\n\t\t\t\t\t\t\t unsigned long start,\n\t\t\t\t\t\t\t unsigned long end,\n\t\t\t\t\t\t\t hva_handler_t handler)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range range = {\n\t\t.start\t\t= start,\n\t\t.end\t\t= end,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= handler,\n\t\t.on_lock\t= (void *)kvm_null_fn,\n\t\t.flush_on_ret\t= false,\n\t\t.may_block\t= false,\n\t};\n\n\treturn __kvm_handle_hva_range(kvm, &range);\n}",
    "abstract_func_before": "static __always_inline VAR_0 kvm_handle_hva_range_no_flush(struct mmu_notifier *VAR_1,\n\t\t\t\t\t\t\t unsigned long VAR_2,\n\t\t\t\t\t\t\t unsigned long VAR_3,\n\t\t\t\t\t\t\t hva_handler_t VAR_4)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(VAR_1);\n\tconst struct kvm_hva_range VAR_5 = {\n\t\t.start\t\t= VAR_2,\n\t\t.end\t\t= VAR_3,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= VAR_4,\n\t\t.on_lock\t= (void *)VAR_6,\n\t\t.flush_on_ret\t= false,\n\t\t.may_block\t= false,\n\t};\n\n\treturn __kvm_handle_hva_range(kvm, &VAR_5);\n}",
    "func_graph_path_before": null,
    "func": "static __always_inline int kvm_handle_hva_range_no_flush(struct mmu_notifier *mn,\n\t\t\t\t\t\t\t unsigned long start,\n\t\t\t\t\t\t\t unsigned long end,\n\t\t\t\t\t\t\t hva_handler_t handler)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range range = {\n\t\t.start\t\t= start,\n\t\t.end\t\t= end,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= handler,\n\t\t.on_lock\t= (void *)kvm_null_fn,\n\t\t.on_unlock\t= (void *)kvm_null_fn,\n\t\t.flush_on_ret\t= false,\n\t\t.may_block\t= false,\n\t};\n\n\treturn __kvm_handle_hva_range(kvm, &range);\n}",
    "abstract_func": "static __always_inline VAR_0 kvm_handle_hva_range_no_flush(struct mmu_notifier *VAR_1,\n\t\t\t\t\t\t\t unsigned long VAR_2,\n\t\t\t\t\t\t\t unsigned long VAR_3,\n\t\t\t\t\t\t\t hva_handler_t VAR_4)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(VAR_1);\n\tconst struct kvm_hva_range VAR_5 = {\n\t\t.start\t\t= VAR_2,\n\t\t.end\t\t= VAR_3,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= VAR_4,\n\t\t.on_lock\t= (void *)VAR_6,\n\t\t.on_unlock\t= (void *)VAR_6,\n\t\t.flush_on_ret\t= false,\n\t\t.may_block\t= false,\n\t};\n\n\treturn __kvm_handle_hva_range(kvm, &VAR_5);\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n \t\t.pte\t\t= __pte(0),\n \t\t.handler\t= handler,\n \t\t.on_lock\t= (void *)kvm_null_fn,\n+\t\t.on_unlock\t= (void *)kvm_null_fn,\n \t\t.flush_on_ret\t= false,\n \t\t.may_block\t= false,\n \t};",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\t.on_unlock\t= (void *)kvm_null_fn,"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}