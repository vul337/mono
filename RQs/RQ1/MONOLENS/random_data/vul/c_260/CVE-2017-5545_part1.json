{
    "cve_id": "CVE-2017-5545",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "libimobiledevice/libplist",
    "commit_msg": "plistutil: Prevent OOB heap buffer read by checking input size\n\nAs pointed out in #87 plistutil would do a memcmp with a heap buffer\nwithout checking the size. If the size is less than 8 it would read\nbeyond the bounds of this heap buffer. This commit prevents that.",
    "commit_hash": "7391a506352c009fe044dead7baad9e22dd279ee",
    "git_url": "https://github.com/libimobiledevice/libplist/commit/7391a506352c009fe044dead7baad9e22dd279ee",
    "file_path": "tools/plistutil.c",
    "func_name": "main",
    "func_before": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n\n    // read input file\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n\n    stat(options->in_file, &filestats);\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        // if no output file specified, write to stdout\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n\n    free(options);\n    return 0;\n}",
    "abstract_func_before": "int main(int VAR_0, char *VAR_1[])\n{\n    FILE *VAR_2 = NULL;\n    plist_t VAR_3 = NULL;\n    char *VAR_4 = NULL;\n    uint32_t VAR_5 = 0;\n    int VAR_6 = 0;\n    char *VAR_7 = NULL;\n    struct stat VAR_8;\n    options_t *VAR_9 = parse_arguments(VAR_0, VAR_1);\n\n    if (!VAR_9)\n    {\n        print_usage(VAR_0, VAR_1);\n        return 0;\n    }\n\n    /* COMMENT_0 */\n    VAR_2 = fopen(VAR_9->in_file, \"rb\");\n    if (!VAR_2) {\n        free(VAR_9);\n        return 1;\n    }\n\n    stat(VAR_9->in_file, &VAR_8);\n    VAR_7 = (char *) malloc(sizeof(char) * (VAR_8.st_size + 1));\n    VAR_6 = fread(VAR_7, sizeof(char), VAR_8.st_size, VAR_2);\n    fclose(VAR_2);\n\n    /* COMMENT_1 */\n    if (memcmp(VAR_7, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(VAR_7, VAR_6, &VAR_3);\n        plist_to_xml(VAR_3, &VAR_4, &VAR_5);\n    }\n    else\n    {\n        plist_from_xml(VAR_7, VAR_6, &VAR_3);\n        plist_to_bin(VAR_3, &VAR_4, &VAR_5);\n    }\n    plist_free(VAR_3);\n    free(VAR_7);\n\n    if (VAR_4)\n    {\n        if (VAR_9->out_file != NULL)\n        {\n            FILE *VAR_10 = fopen(VAR_9->out_file, \"wb\");\n            if (!VAR_10) {\n                free(VAR_9);\n                return 1;\n            }\n            fwrite(VAR_4, VAR_5, sizeof(char), VAR_10);\n            fclose(VAR_10);\n        }\n        /* COMMENT_2 */\n        else\n            fwrite(VAR_4, VAR_5, sizeof(char), VAR_11);\n\n        free(VAR_4);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n\n    free(VAR_9);\n    return 0;\n}",
    "func_graph_path_before": "libimobiledevice/libplist/7391a506352c009fe044dead7baad9e22dd279ee/plistutil.c/vul/before/0.json",
    "func": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n\n    // read input file\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n\n    stat(options->in_file, &filestats);\n\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        // if no output file specified, write to stdout\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n\n    free(options);\n    return 0;\n}",
    "abstract_func": "int main(int VAR_0, char *VAR_1[])\n{\n    FILE *VAR_2 = NULL;\n    plist_t VAR_3 = NULL;\n    char *VAR_4 = NULL;\n    uint32_t VAR_5 = 0;\n    int VAR_6 = 0;\n    char *VAR_7 = NULL;\n    struct stat VAR_8;\n    options_t *VAR_9 = parse_arguments(VAR_0, VAR_1);\n\n    if (!VAR_9)\n    {\n        print_usage(VAR_0, VAR_1);\n        return 0;\n    }\n\n    /* COMMENT_0 */\n    VAR_2 = fopen(VAR_9->in_file, \"rb\");\n    if (!VAR_2) {\n        free(VAR_9);\n        return 1;\n    }\n\n    stat(VAR_9->in_file, &VAR_8);\n\n    if (VAR_8.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n\n    VAR_7 = (char *) malloc(sizeof(char) * (VAR_8.st_size + 1));\n    VAR_6 = fread(VAR_7, sizeof(char), VAR_8.st_size, VAR_2);\n    fclose(VAR_2);\n\n    /* COMMENT_1 */\n    if (memcmp(VAR_7, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(VAR_7, VAR_6, &VAR_3);\n        plist_to_xml(VAR_3, &VAR_4, &VAR_5);\n    }\n    else\n    {\n        plist_from_xml(VAR_7, VAR_6, &VAR_3);\n        plist_to_bin(VAR_3, &VAR_4, &VAR_5);\n    }\n    plist_free(VAR_3);\n    free(VAR_7);\n\n    if (VAR_4)\n    {\n        if (VAR_9->out_file != NULL)\n        {\n            FILE *VAR_10 = fopen(VAR_9->out_file, \"wb\");\n            if (!VAR_10) {\n                free(VAR_9);\n                return 1;\n            }\n            fwrite(VAR_4, VAR_5, sizeof(char), VAR_10);\n            fclose(VAR_10);\n        }\n        /* COMMENT_2 */\n        else\n            fwrite(VAR_4, VAR_5, sizeof(char), VAR_11);\n\n        free(VAR_4);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n\n    free(VAR_9);\n    return 0;\n}",
    "func_graph_path": "libimobiledevice/libplist/7391a506352c009fe044dead7baad9e22dd279ee/plistutil.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,12 @@\n     }\n \n     stat(options->in_file, &filestats);\n+\n+    if (filestats.st_size < 8) {\n+        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n+        return -1;\n+    }\n+\n     plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n     read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n     fclose(iplist);",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "",
            "    if (filestats.st_size < 8) {",
            "        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");",
            "        return -1;",
            "    }",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}