{
    "cve_id": "CVE-2018-9259",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "wireshark",
    "commit_msg": "mp4: limit the recursion depth for boxes\n\nAlthough the dissection of each box header consumes a couple of bytes,\nit turned out that it's still possible to crash wireshark with a sample\nfile that contains a large number of nested boxes. The stack will fill\nup before we reach the end of the data bytes.\n\nKeep track of the recursion depth as we walk through the hierarchy of\nboxes. Abort if we reach the (locally defined) upper limit.\n\nBug: 13777\nChange-Id: I0f67245a5c74131f10d0f9d99b39ad31711b9775\nReviewed-on: https://code.wireshark.org/review/26167\nReviewed-by: Martin Kaiser <wireshark@kaiser.cx>\nPetri-Dish: Martin Kaiser <wireshark@kaiser.cx>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 620f69a74b18908e3424920c7bb01cb5e4cbd8b1)\nReviewed-on: https://code.wireshark.org/review/26204",
    "commit_hash": "2113179835b37549f245ac7c05ff2b96276893e4",
    "git_url": "https://github.com/wireshark/wireshark/commit/2113179835b37549f245ac7c05ff2b96276893e4",
    "file_path": "epan/dissectors/file-mp4.c",
    "func_name": "dissect_mp4",
    "func_before": "static int\ndissect_mp4(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    gint        offset = 0;\n    guint32     box_type;\n    proto_item *pi;\n    proto_tree *mp4_tree;\n    gint        ret;\n\n    /* to make sure that we have an mp4 file, we check that it starts with\n        a box of a known type\n       please note that we do not allow the first box to be an extended box\n       this detection should be safe as long as the dissector is only called for\n        the video/mp4 mime type\n       when we read mp4 files directly, we might need stricter checks here */\n    if (tvb_reported_length(tvb) < MIN_BOX_SIZE)\n        return 0;\n    box_type = tvb_get_ntohl(tvb, 4);\n    if (try_val_to_str(box_type, box_types) == NULL)\n        return 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"MP4\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n    pi = proto_tree_add_protocol_format(tree, proto_mp4,\n            tvb, 0, (gint)tvb_reported_length(tvb), \"MP4\");\n    mp4_tree = proto_item_add_subtree(pi, ett_mp4);\n\n    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n        ret = dissect_mp4_box(BOX_TYPE_NONE, tvb, offset, pinfo, mp4_tree);\n        if (ret <= 0)\n            break;\n        offset += ret;\n    }\n\n    return offset;\n}",
    "abstract_func_before": "static int\ndissect_mp4(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3 _U_)\n{\n    gint        VAR_4 = 0;\n    guint32     VAR_5;\n    proto_item *VAR_6;\n    proto_tree *VAR_7;\n    gint        VAR_8;\n\n    /* COMMENT_0 */\n                             \n                                                                           \n                                                                                \n                               \n                                                                             \n    if (tvb_reported_length(VAR_0) < VAR_9)\n        return 0;\n    VAR_5 = tvb_get_ntohl(VAR_0, 4);\n    if (try_val_to_str(VAR_5, VAR_10) == NULL)\n        return 0;\n\n    col_set_str(VAR_1->cinfo, VAR_11, \"MP4\");\n    col_clear(VAR_1->cinfo, VAR_12);\n\n    VAR_6 = proto_tree_add_protocol_format(VAR_2, VAR_13,\n            VAR_0, 0, (gint)tvb_reported_length(VAR_0), \"MP4\");\n    VAR_7 = proto_item_add_subtree(VAR_6, VAR_14);\n\n    while (tvb_reported_length_remaining(VAR_0, VAR_4) > 0) {\n        VAR_8 = dissect_mp4_box(VAR_15, VAR_0, VAR_4, VAR_1, VAR_7);\n        if (VAR_8 <= 0)\n            break;\n        VAR_4 += VAR_8;\n    }\n\n    return VAR_4;\n}",
    "func_graph_path_before": null,
    "func": "static int\ndissect_mp4(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    gint        offset = 0;\n    guint32     box_type;\n    proto_item *pi;\n    proto_tree *mp4_tree;\n    gint        ret;\n\n    /* to make sure that we have an mp4 file, we check that it starts with\n        a box of a known type\n       please note that we do not allow the first box to be an extended box\n       this detection should be safe as long as the dissector is only called for\n        the video/mp4 mime type\n       when we read mp4 files directly, we might need stricter checks here */\n    if (tvb_reported_length(tvb) < MIN_BOX_SIZE)\n        return 0;\n    box_type = tvb_get_ntohl(tvb, 4);\n    if (try_val_to_str(box_type, box_types) == NULL)\n        return 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"MP4\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n    pi = proto_tree_add_protocol_format(tree, proto_mp4,\n            tvb, 0, (gint)tvb_reported_length(tvb), \"MP4\");\n    mp4_tree = proto_item_add_subtree(pi, ett_mp4);\n\n    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n        ret = dissect_mp4_box(BOX_TYPE_NONE, 0, tvb, offset, pinfo, mp4_tree);\n        if (ret <= 0)\n            break;\n        offset += ret;\n    }\n\n    return offset;\n}",
    "abstract_func": "static int\ndissect_mp4(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void *VAR_3 _U_)\n{\n    gint        VAR_4 = 0;\n    guint32     VAR_5;\n    proto_item *VAR_6;\n    proto_tree *VAR_7;\n    gint        VAR_8;\n\n    /* COMMENT_0 */\n                             \n                                                                           \n                                                                                \n                               \n                                                                             \n    if (tvb_reported_length(VAR_0) < VAR_9)\n        return 0;\n    VAR_5 = tvb_get_ntohl(VAR_0, 4);\n    if (try_val_to_str(VAR_5, VAR_10) == NULL)\n        return 0;\n\n    col_set_str(VAR_1->cinfo, VAR_11, \"MP4\");\n    col_clear(VAR_1->cinfo, VAR_12);\n\n    VAR_6 = proto_tree_add_protocol_format(VAR_2, VAR_13,\n            VAR_0, 0, (gint)tvb_reported_length(VAR_0), \"MP4\");\n    VAR_7 = proto_item_add_subtree(VAR_6, VAR_14);\n\n    while (tvb_reported_length_remaining(VAR_0, VAR_4) > 0) {\n        VAR_8 = dissect_mp4_box(VAR_15, 0, VAR_0, VAR_4, VAR_1, VAR_7);\n        if (VAR_8 <= 0)\n            break;\n        VAR_4 += VAR_8;\n    }\n\n    return VAR_4;\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n     mp4_tree = proto_item_add_subtree(pi, ett_mp4);\n \n     while (tvb_reported_length_remaining(tvb, offset) > 0) {\n-        ret = dissect_mp4_box(BOX_TYPE_NONE, tvb, offset, pinfo, mp4_tree);\n+        ret = dissect_mp4_box(BOX_TYPE_NONE, 0, tvb, offset, pinfo, mp4_tree);\n         if (ret <= 0)\n             break;\n         offset += ret;",
    "diff_line_info": {
        "deleted_lines": [
            "        ret = dissect_mp4_box(BOX_TYPE_NONE, tvb, offset, pinfo, mp4_tree);"
        ],
        "added_lines": [
            "        ret = dissect_mp4_box(BOX_TYPE_NONE, 0, tvb, offset, pinfo, mp4_tree);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}