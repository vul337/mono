{
    "cve_id": "CVE-2010-4251",
    "cwe_ids": [
        "CWE-400"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "We got system OOM while running some UDP netperf testing on the loopback\ndevice. The case is multiple senders sent stream UDP packets to a single\nreceiver via loopback on local host. Of course, the receiver is not able\nto handle all the packets in time. But we surprisingly found that these\npackets were not discarded due to the receiver's sk->sk_rcvbuf limit.\nInstead, they are kept queuing to sk->sk_backlog and finally ate up all\nthe memory. We believe this is a secure hole that a none privileged user\ncan crash the system.\n\nThe root cause for this problem is, when the receiver is doing\n__release_sock() (i.e. after userspace recv, kernel udp_recvmsg ->\nskb_free_datagram_locked -> release_sock), it moves skbs from backlog to\nsk_receive_queue with the softirq enabled. In the above case, multiple\nbusy senders will almost make it an endless loop. The skbs in the\nbacklog end up eat all the system memory.\n\nThe issue is not only for UDP. Any protocols using socket backlog is\npotentially affected. The patch adds limit for socket backlog so that\nthe backlog size cannot be expanded endlessly.\n\nReported-by: Alex Shi <alex.shi@intel.com>\nCc: David Miller <davem@davemloft.net>\nCc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>\nCc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru\nCc: \"Pekka Savola (ipv6)\" <pekkas@netcore.fi>\nCc: Patrick McHardy <kaber@trash.net>\nCc: Vlad Yasevich <vladislav.yasevich@hp.com>\nCc: Sridhar Samudrala <sri@us.ibm.com>\nCc: Jon Maloy <jon.maloy@ericsson.com>\nCc: Allan Stephens <allan.stephens@windriver.com>\nCc: Andrew Hendry <andrew.hendry@gmail.com>\nSigned-off-by: Zhu Yi <yi.zhu@intel.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Arnaldo Carvalho de Melo <acme@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n",
    "commit_hash": "8eae939f1400326b06d0c9afe53d2a484a326871",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=8eae939f1400326b06d0c9afe53d2a484a326871",
    "file_path": "net/core/sock.c",
    "func_name": "__release_sock",
    "func_before": "static void __release_sock(struct sock *sk)\n{\n\tstruct sk_buff *skb = sk->sk_backlog.head;\n\n\tdo {\n\t\tsk->sk_backlog.head = sk->sk_backlog.tail = NULL;\n\t\tbh_unlock_sock(sk);\n\n\t\tdo {\n\t\t\tstruct sk_buff *next = skb->next;\n\n\t\t\tskb->next = NULL;\n\t\t\tsk_backlog_rcv(sk, skb);\n\n\t\t\t/*\n\t\t\t * We are in process context here with softirqs\n\t\t\t * disabled, use cond_resched_softirq() to preempt.\n\t\t\t * This is safe to do because we've taken the backlog\n\t\t\t * queue private:\n\t\t\t */\n\t\t\tcond_resched_softirq();\n\n\t\t\tskb = next;\n\t\t} while (skb != NULL);\n\n\t\tbh_lock_sock(sk);\n\t} while ((skb = sk->sk_backlog.head) != NULL);\n}",
    "abstract_func_before": "static void __release_sock(struct sock *VAR_0)\n{\n\tstruct sk_buff *VAR_1 = VAR_0->sk_backlog.head;\n\n\tdo {\n\t\tVAR_0->sk_backlog.head = VAR_0->sk_backlog.tail = NULL;\n\t\tbh_unlock_sock(VAR_0);\n\n\t\tdo {\n\t\t\tstruct sk_buff *VAR_2 = VAR_1->next;\n\n\t\t\tVAR_1->next = NULL;\n\t\t\tsk_backlog_rcv(VAR_0, VAR_1);\n\n\t\t\t/* COMMENT_0 */\n                                                  \n                                                      \n                                                        \n                    \n      \n\t\t\tcond_resched_softirq();\n\n\t\t\tVAR_1 = VAR_2;\n\t\t} while (VAR_1 != NULL);\n\n\t\tbh_lock_sock(VAR_0);\n\t} while ((VAR_1 = VAR_0->sk_backlog.head) != NULL);\n}",
    "func_graph_path_before": "torvalds/linux/8eae939f1400326b06d0c9afe53d2a484a326871/sock.c/vul/before/1.json",
    "func": "static void __release_sock(struct sock *sk)\n{\n\tstruct sk_buff *skb = sk->sk_backlog.head;\n\n\tdo {\n\t\tsk->sk_backlog.head = sk->sk_backlog.tail = NULL;\n\t\tbh_unlock_sock(sk);\n\n\t\tdo {\n\t\t\tstruct sk_buff *next = skb->next;\n\n\t\t\tskb->next = NULL;\n\t\t\tsk_backlog_rcv(sk, skb);\n\n\t\t\t/*\n\t\t\t * We are in process context here with softirqs\n\t\t\t * disabled, use cond_resched_softirq() to preempt.\n\t\t\t * This is safe to do because we've taken the backlog\n\t\t\t * queue private:\n\t\t\t */\n\t\t\tcond_resched_softirq();\n\n\t\t\tskb = next;\n\t\t} while (skb != NULL);\n\n\t\tbh_lock_sock(sk);\n\t} while ((skb = sk->sk_backlog.head) != NULL);\n\n\t/*\n\t * Doing the zeroing here guarantee we can not loop forever\n\t * while a wild producer attempts to flood us.\n\t */\n\tsk->sk_backlog.len = 0;\n}",
    "abstract_func": "static void __release_sock(struct sock *VAR_0)\n{\n\tstruct sk_buff *VAR_1 = VAR_0->sk_backlog.head;\n\n\tdo {\n\t\tVAR_0->sk_backlog.head = VAR_0->sk_backlog.tail = NULL;\n\t\tbh_unlock_sock(VAR_0);\n\n\t\tdo {\n\t\t\tstruct sk_buff *VAR_2 = VAR_1->next;\n\n\t\t\tVAR_1->next = NULL;\n\t\t\tsk_backlog_rcv(VAR_0, VAR_1);\n\n\t\t\t/* COMMENT_0 */\n                                                  \n                                                      \n                                                        \n                    \n      \n\t\t\tcond_resched_softirq();\n\n\t\t\tVAR_1 = VAR_2;\n\t\t} while (VAR_1 != NULL);\n\n\t\tbh_lock_sock(VAR_0);\n\t} while ((VAR_1 = VAR_0->sk_backlog.head) != NULL);\n\n\t/* COMMENT_6 */\n                                                            \n                                               \n    \n\tVAR_0->sk_backlog.len = 0;\n}",
    "func_graph_path": "torvalds/linux/8eae939f1400326b06d0c9afe53d2a484a326871/sock.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -25,4 +25,10 @@\n \n \t\tbh_lock_sock(sk);\n \t} while ((skb = sk->sk_backlog.head) != NULL);\n+\n+\t/*\n+\t * Doing the zeroing here guarantee we can not loop forever\n+\t * while a wild producer attempts to flood us.\n+\t */\n+\tsk->sk_backlog.len = 0;\n }",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "",
            "\t/*",
            "\t * Doing the zeroing here guarantee we can not loop forever",
            "\t * while a wild producer attempts to flood us.",
            "\t */",
            "\tsk->sk_backlog.len = 0;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}