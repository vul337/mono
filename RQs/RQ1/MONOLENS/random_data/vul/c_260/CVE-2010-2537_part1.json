{
    "cve_id": "CVE-2010-2537",
    "cwe_ids": [
        "CWE-Other",
        "CWE-200"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "1.  The BTRFS_IOC_CLONE and BTRFS_IOC_CLONE_RANGE ioctls should check\nwhether the donor file is append-only before writing to it.\n\n2.  The BTRFS_IOC_CLONE_RANGE ioctl appears to have an integer\noverflow that allows a user to specify an out-of-bounds range to copy\nfrom the source file (if off + len wraps around).  I haven't been able\nto successfully exploit this, but I'd imagine that a clever attacker\ncould use this to read things he shouldn't.  Even if it's not\nexploitable, it couldn't hurt to be safe.\n\nSigned-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>\ncc: stable@kernel.org\nSigned-off-by: Chris Mason <chris.mason@oracle.com>\n",
    "commit_hash": "2ebc3464781ad24474abcbd2274e6254689853b5",
    "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=2ebc3464781ad24474abcbd2274e6254689853b5",
    "file_path": "fs/btrfs/ioctl.c",
    "func_name": "btrfs_ioctl_clone",
    "func_before": "static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n\t\t\t\t       u64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = fdentry(file)->d_inode;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file *src_file;\n\tstruct inode *src;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tchar *buf;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = root->fs_info->sb->s_blocksize;\n\tu64 hint_byte;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t * - allow ranges within the same file to be cloned (provided\n\t *   they don't overlap)?\n\t */\n\n\t/* the destination must be opened for writing */\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EINVAL;\n\n\tret = mnt_want_write(file->f_path.mnt);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_file = fget(srcfd);\n\tif (!src_file) {\n\t\tret = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tsrc = src_file->f_dentry->d_inode;\n\n\tret = -EINVAL;\n\tif (src == inode)\n\t\tgoto out_fput;\n\n\t/* the src must be open for reading */\n\tif (!(src_file->f_mode & FMODE_READ))\n\t\tgoto out_fput;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tret = -EXDEV;\n\tif (src->i_sb != inode->i_sb || BTRFS_I(src)->root != root)\n\t\tgoto out_fput;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(btrfs_level_size(root, 0));\n\tif (!buf)\n\t\tgoto out_fput;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\tgoto out_fput;\n\t}\n\tpath->reada = 2;\n\n\tif (inode < src) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tmutex_lock(&src->i_mutex);\n\t} else {\n\t\tmutex_lock(&src->i_mutex);\n\t\tmutex_lock(&inode->i_mutex);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off >= src->i_size || off + len > src->i_size)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ((src->i_size + bs-1) & ~(bs-1))\n\t\t\t- off;\n\n\t/* verify the end result is block aligned */\n\tif ((off & (bs-1)) ||\n\t    ((off + len) & (bs-1)))\n\t\tgoto out_unlock;\n\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(src)->io_tree, off, off+len, GFP_NOFS);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, off+len);\n\t\tif (BTRFS_I(src)->delalloc_bytes == 0 && !ordered)\n\t\t\tbreak;\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, off, off+len, GFP_NOFS);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(src, off, off+len);\n\t}\n\n\t/* clone data */\n\tkey.objectid = src->i_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\n\twhile (1) {\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (btrfs_key_type(&key) > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != src->i_ino)\n\t\t\tbreak;\n\n\t\tif (btrfs_key_type(&key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 endoff;\n\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\t\t\tbtrfs_release_path(root, path);\n\n\t\t\tif (key.offset + datal < off ||\n\t\t\t    key.offset >= off+len)\n\t\t\t\tgoto next;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = inode->i_ino;\n\t\t\tnew_key.offset = key.offset + destoff - off;\n\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\tret = btrfs_drop_extents(trans, inode,\n\t\t\t\t\t\t\t new_key.offset,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t &hint_byte, 1);\n\t\t\t\tBUG_ON(ret);\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tBUG_ON(ret);\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tnew_key.offset - datao);\n\t\t\t\t\tBUG_ON(ret);\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off+len)\n\t\t\t\t\ttrim = key.offset + datal - (off+len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\tret = btrfs_drop_extents(trans, inode,\n\t\t\t\t\t\t\t new_key.offset,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t &hint_byte, 1);\n\t\t\t\tBUG_ON(ret);\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tBUG_ON(ret);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(root, path);\n\n\t\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\t\t\t/*\n\t\t\t * we round up to the block size at eof when\n\t\t\t * determining which extents to clone above,\n\t\t\t * but shouldn't round up the file size\n\t\t\t */\n\t\t\tendoff = new_key.offset + datal;\n\t\t\tif (endoff > off+olen)\n\t\t\t\tendoff = off+olen;\n\t\t\tif (endoff > inode->i_size)\n\t\t\t\tbtrfs_i_size_write(inode, endoff);\n\n\t\t\tBTRFS_I(inode)->flags = BTRFS_I(src)->flags;\n\t\t\tret = btrfs_update_inode(trans, root, inode);\n\t\t\tBUG_ON(ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t}\nnext:\n\t\tbtrfs_release_path(root, path);\n\t\tkey.offset++;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(root, path);\n\tunlock_extent(&BTRFS_I(src)->io_tree, off, off+len, GFP_NOFS);\nout_unlock:\n\tmutex_unlock(&src->i_mutex);\n\tmutex_unlock(&inode->i_mutex);\n\tvfree(buf);\n\tbtrfs_free_path(path);\nout_fput:\n\tfput(src_file);\nout_drop_write:\n\tmnt_drop_write(file->f_path.mnt);\n\treturn ret;\n}",
    "abstract_func_before": "static noinline VAR_0 btrfs_ioctl_clone(struct file *file, unsigned long VAR_1,\n\t\t\t\t       u64 VAR_2, u64 VAR_3, u64 VAR_4)\n{\n\tstruct inode *inode = fdentry(file)->d_inode;\n\tstruct btrfs_root *VAR_5 = BTRFS_I(inode)->root;\n\tstruct file *VAR_6;\n\tstruct inode *VAR_7;\n\tstruct btrfs_trans_handle *VAR_8;\n\tstruct btrfs_path *VAR_9;\n\tstruct extent_buffer *VAR_10;\n\tchar *VAR_11;\n\tstruct btrfs_key VAR_12;\n\tu32 VAR_13;\n\tint VAR_14;\n\tint VAR_15;\n\tu64 VAR_16 = VAR_3;\n\tu64 VAR_17 = VAR_5->fs_info->sb->s_blocksize;\n\tu64 VAR_18;\n\n\t/* COMMENT_0 */\n         \n                                                            \n                                                                  \n                                                                  \n                                     \n                                                              \n                          \n    \n\n\t/* COMMENT_9 */\n\tif (!(file->f_mode & VAR_19))\n\t\treturn -VAR_20;\n\n\tVAR_15 = mnt_want_write(file->f_path.mnt);\n\tif (VAR_15)\n\t\treturn VAR_15;\n\n\tVAR_6 = fget(VAR_1);\n\tif (!VAR_6) {\n\t\tVAR_15 = -VAR_21;\n\t\tgoto out_drop_write;\n\t}\n\n\tVAR_7 = VAR_6->f_dentry->d_inode;\n\n\tVAR_15 = -VAR_20;\n\tif (VAR_7 == inode)\n\t\tgoto out_fput;\n\n\t/* COMMENT_10 */\n\tif (!(VAR_6->f_mode & VAR_22))\n\t\tgoto out_fput;\n\n\tVAR_15 = -VAR_23;\n\tif (S_ISDIR(VAR_7->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tVAR_15 = -VAR_24;\n\tif (VAR_7->i_sb != inode->i_sb || BTRFS_I(VAR_7)->root != VAR_5)\n\t\tgoto out_fput;\n\n\tVAR_15 = -VAR_25;\n\tVAR_11 = vmalloc(btrfs_level_size(VAR_5, 0));\n\tif (!VAR_11)\n\t\tgoto out_fput;\n\n\tVAR_9 = btrfs_alloc_path();\n\tif (!VAR_9) {\n\t\tvfree(VAR_11);\n\t\tgoto out_fput;\n\t}\n\tVAR_9->reada = 2;\n\n\tif (inode < VAR_7) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tmutex_lock(&VAR_7->i_mutex);\n\t} else {\n\t\tmutex_lock(&VAR_7->i_mutex);\n\t\tmutex_lock(&inode->i_mutex);\n\t}\n\n\t/* COMMENT_11 */\n\tVAR_15 = -VAR_20;\n\tif (VAR_2 >= VAR_7->i_size || VAR_2 + VAR_16 > VAR_7->i_size)\n\t\tgoto out_unlock;\n\tif (VAR_16 == 0)\n\t\tVAR_3 = VAR_16 = VAR_7->i_size - VAR_2;\n\t/* COMMENT_12 */\n\tif (VAR_2 + VAR_16 == VAR_7->i_size)\n\t\tVAR_16 = ((VAR_7->i_size + VAR_17-1) & ~(VAR_17-1))\n\t\t\t- VAR_2;\n\n\t/* COMMENT_13 */\n\tif ((VAR_2 & (VAR_17-1)) ||\n\t    ((VAR_2 + VAR_16) & (VAR_17-1)))\n\t\tgoto out_unlock;\n\n\t/* COMMENT_14 */\n                                     \n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *VAR_26;\n\t\tlock_extent(&BTRFS_I(VAR_7)->io_tree, VAR_2, VAR_2+VAR_16, VAR_27);\n\t\tVAR_26 = btrfs_lookup_first_ordered_extent(inode, VAR_2+VAR_16);\n\t\tif (BTRFS_I(VAR_7)->delalloc_bytes == 0 && !VAR_26)\n\t\t\tbreak;\n\t\tunlock_extent(&BTRFS_I(VAR_7)->io_tree, VAR_2, VAR_2+VAR_16, VAR_27);\n\t\tif (VAR_26)\n\t\t\tbtrfs_put_ordered_extent(VAR_26);\n\t\tbtrfs_wait_ordered_range(VAR_7, VAR_2, VAR_2+VAR_16);\n\t}\n\n\t/* COMMENT_16 */\n\tVAR_12.objectid = VAR_7->i_ino;\n\tVAR_12.type = VAR_28;\n\tVAR_12.offset = 0;\n\n\twhile (1) {\n\t\t/* COMMENT_17 */\n                                                         \n          \n     \n\t\tVAR_15 = btrfs_search_slot(NULL, VAR_5, &VAR_12, VAR_9, 0, 0);\n\t\tif (VAR_15 < 0)\n\t\t\tgoto out;\n\n\t\tVAR_13 = btrfs_header_nritems(VAR_9->nodes[0]);\n\t\tif (VAR_9->slots[0] >= VAR_13) {\n\t\t\tVAR_15 = btrfs_next_leaf(VAR_5, VAR_9);\n\t\t\tif (VAR_15 < 0)\n\t\t\t\tgoto out;\n\t\t\tif (VAR_15 > 0)\n\t\t\t\tbreak;\n\t\t\tVAR_13 = btrfs_header_nritems(VAR_9->nodes[0]);\n\t\t}\n\t\tVAR_10 = VAR_9->nodes[0];\n\t\tVAR_14 = VAR_9->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(VAR_10, &VAR_12, VAR_14);\n\t\tif (btrfs_key_type(&VAR_12) > VAR_28 ||\n\t\t    VAR_12.objectid != VAR_7->i_ino)\n\t\t\tbreak;\n\n\t\tif (btrfs_key_type(&VAR_12) == VAR_28) {\n\t\t\tstruct btrfs_file_extent_item *VAR_29;\n\t\t\tint VAR_30;\n\t\t\tu32 VAR_31;\n\t\t\tstruct btrfs_key VAR_32;\n\t\t\tu64 VAR_33 = 0, VAR_34 = 0;\n\t\t\tu64 VAR_35 = 0, VAR_36 = 0;\n\t\t\tu8 VAR_37;\n\t\t\tu64 VAR_38;\n\n\t\t\tVAR_31 = btrfs_item_size_nr(VAR_10, VAR_14);\n\t\t\tread_extent_buffer(VAR_10, VAR_11,\n\t\t\t\t\t   btrfs_item_ptr_offset(VAR_10, VAR_14),\n\t\t\t\t\t   VAR_31);\n\n\t\t\tVAR_29 = btrfs_item_ptr(VAR_10, VAR_14,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tVAR_37 = btrfs_file_extent_compression(VAR_10, VAR_29);\n\t\t\tVAR_30 = btrfs_file_extent_type(VAR_10, VAR_29);\n\t\t\tif (VAR_30 == VAR_39 ||\n\t\t\t    VAR_30 == VAR_40) {\n\t\t\t\tVAR_33 = btrfs_file_extent_disk_bytenr(VAR_10,\n\t\t\t\t\t\t\t\t      VAR_29);\n\t\t\t\tVAR_34 = btrfs_file_extent_disk_num_bytes(VAR_10,\n\t\t\t\t\t\t\t\t VAR_29);\n\t\t\t\tVAR_35 = btrfs_file_extent_offset(VAR_10, VAR_29);\n\t\t\t\tVAR_36 = btrfs_file_extent_num_bytes(VAR_10,\n\t\t\t\t\t\t\t\t    VAR_29);\n\t\t\t} else if (VAR_30 == VAR_41) {\n\t\t\t\t/* COMMENT_21 */\n\t\t\t\tVAR_36 = btrfs_file_extent_ram_bytes(VAR_10,\n\t\t\t\t\t\t\t\t    VAR_29);\n\t\t\t}\n\t\t\tbtrfs_release_path(VAR_5, VAR_9);\n\n\t\t\tif (VAR_12.offset + VAR_36 < VAR_2 ||\n\t\t\t    VAR_12.offset >= VAR_2+VAR_16)\n\t\t\t\tgoto next;\n\n\t\t\tmemcpy(&VAR_32, &VAR_12, sizeof(VAR_32));\n\t\t\tVAR_32.objectid = inode->i_ino;\n\t\t\tVAR_32.offset = VAR_12.offset + VAR_4 - VAR_2;\n\n\t\t\tVAR_8 = btrfs_start_transaction(VAR_5, 1);\n\t\t\tif (IS_ERR(VAR_8)) {\n\t\t\t\tVAR_15 = PTR_ERR(VAR_8);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (VAR_30 == VAR_39 ||\n\t\t\t    VAR_30 == VAR_40) {\n\t\t\t\tif (VAR_2 > VAR_12.offset) {\n\t\t\t\t\tVAR_35 += VAR_2 - VAR_12.offset;\n\t\t\t\t\tVAR_36 -= VAR_2 - VAR_12.offset;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_12.offset + VAR_36 > VAR_2 + VAR_16)\n\t\t\t\t\tVAR_36 = VAR_2 + VAR_16 - VAR_12.offset;\n\n\t\t\t\tVAR_15 = btrfs_drop_extents(VAR_8, inode,\n\t\t\t\t\t\t\t VAR_32.offset,\n\t\t\t\t\t\t\t VAR_32.offset + VAR_36,\n\t\t\t\t\t\t\t &VAR_18, 1);\n\t\t\t\tBUG_ON(VAR_15);\n\n\t\t\t\tVAR_15 = btrfs_insert_empty_item(VAR_8, VAR_5, VAR_9,\n\t\t\t\t\t\t\t      &VAR_32, VAR_31);\n\t\t\t\tBUG_ON(VAR_15);\n\n\t\t\t\tVAR_10 = VAR_9->nodes[0];\n\t\t\t\tVAR_14 = VAR_9->slots[0];\n\t\t\t\twrite_extent_buffer(VAR_10, VAR_11,\n\t\t\t\t\t    btrfs_item_ptr_offset(VAR_10, VAR_14),\n\t\t\t\t\t    VAR_31);\n\n\t\t\t\tVAR_29 = btrfs_item_ptr(VAR_10, VAR_14,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* COMMENT_22 */\n\t\t\t\tif (!VAR_33)\n\t\t\t\t\tVAR_35 = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(VAR_10, VAR_29,\n\t\t\t\t\t\t\t     VAR_35);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(VAR_10, VAR_29,\n\t\t\t\t\t\t\t\tVAR_36);\n\t\t\t\tif (VAR_33) {\n\t\t\t\t\tinode_add_bytes(inode, VAR_36);\n\t\t\t\t\tVAR_15 = btrfs_inc_extent_ref(VAR_8, VAR_5,\n\t\t\t\t\t\t\tVAR_33, VAR_34, 0,\n\t\t\t\t\t\t\tVAR_5->root_key.objectid,\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tVAR_32.offset - VAR_35);\n\t\t\t\t\tBUG_ON(VAR_15);\n\t\t\t\t}\n\t\t\t} else if (VAR_30 == VAR_41) {\n\t\t\t\tu64 VAR_42 = 0;\n\t\t\t\tu64 VAR_43 = 0;\n\t\t\t\tif (VAR_2 > VAR_12.offset) {\n\t\t\t\t\tVAR_42 = VAR_2 - VAR_12.offset;\n\t\t\t\t\tVAR_32.offset += VAR_42;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_12.offset + VAR_36 > VAR_2+VAR_16)\n\t\t\t\t\tVAR_43 = VAR_12.offset + VAR_36 - (VAR_2+VAR_16);\n\n\t\t\t\tif (VAR_37 && (VAR_42 || VAR_43)) {\n\t\t\t\t\tVAR_15 = -VAR_20;\n\t\t\t\t\tbtrfs_end_transaction(VAR_8, VAR_5);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tVAR_31 -= VAR_42 + VAR_43;\n\t\t\t\tVAR_36 -= VAR_42 + VAR_43;\n\n\t\t\t\tVAR_15 = btrfs_drop_extents(VAR_8, inode,\n\t\t\t\t\t\t\t VAR_32.offset,\n\t\t\t\t\t\t\t VAR_32.offset + VAR_36,\n\t\t\t\t\t\t\t &VAR_18, 1);\n\t\t\t\tBUG_ON(VAR_15);\n\n\t\t\t\tVAR_15 = btrfs_insert_empty_item(VAR_8, VAR_5, VAR_9,\n\t\t\t\t\t\t\t      &VAR_32, VAR_31);\n\t\t\t\tBUG_ON(VAR_15);\n\n\t\t\t\tif (VAR_42) {\n\t\t\t\t\tu32 VAR_44 =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(VAR_11+VAR_44, VAR_11+VAR_44+VAR_42,\n\t\t\t\t\t\tVAR_36);\n\t\t\t\t}\n\n\t\t\t\tVAR_10 = VAR_9->nodes[0];\n\t\t\t\tVAR_14 = VAR_9->slots[0];\n\t\t\t\twrite_extent_buffer(VAR_10, VAR_11,\n\t\t\t\t\t    btrfs_item_ptr_offset(VAR_10, VAR_14),\n\t\t\t\t\t    VAR_31);\n\t\t\t\tinode_add_bytes(inode, VAR_36);\n\t\t\t}\n\n\t\t\tbtrfs_mark_buffer_dirty(VAR_10);\n\t\t\tbtrfs_release_path(VAR_5, VAR_9);\n\n\t\t\tinode->i_mtime = inode->i_ctime = VAR_45;\n\n\t\t\t/* COMMENT_23 */\n                                               \n                                               \n                                          \n      \n\t\t\tVAR_38 = VAR_32.offset + VAR_36;\n\t\t\tif (VAR_38 > VAR_2+VAR_3)\n\t\t\t\tVAR_38 = VAR_2+VAR_3;\n\t\t\tif (VAR_38 > inode->i_size)\n\t\t\t\tbtrfs_i_size_write(inode, VAR_38);\n\n\t\t\tBTRFS_I(inode)->flags = BTRFS_I(VAR_7)->flags;\n\t\t\tVAR_15 = btrfs_update_inode(VAR_8, VAR_5, inode);\n\t\t\tBUG_ON(VAR_15);\n\t\t\tbtrfs_end_transaction(VAR_8, VAR_5);\n\t\t}\nnext:\n\t\tbtrfs_release_path(VAR_5, VAR_9);\n\t\tVAR_12.offset++;\n\t}\n\tVAR_15 = 0;\nout:\n\tbtrfs_release_path(VAR_5, VAR_9);\n\tunlock_extent(&BTRFS_I(VAR_7)->io_tree, VAR_2, VAR_2+VAR_16, VAR_27);\nout_unlock:\n\tmutex_unlock(&VAR_7->i_mutex);\n\tmutex_unlock(&inode->i_mutex);\n\tvfree(VAR_11);\n\tbtrfs_free_path(VAR_9);\nout_fput:\n\tfput(VAR_6);\nout_drop_write:\n\tmnt_drop_write(file->f_path.mnt);\n\treturn VAR_15;\n}",
    "func_graph_path_before": null,
    "func": "static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n\t\t\t\t       u64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = fdentry(file)->d_inode;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file *src_file;\n\tstruct inode *src;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tchar *buf;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = root->fs_info->sb->s_blocksize;\n\tu64 hint_byte;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t * - allow ranges within the same file to be cloned (provided\n\t *   they don't overlap)?\n\t */\n\n\t/* the destination must be opened for writing */\n\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = mnt_want_write(file->f_path.mnt);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_file = fget(srcfd);\n\tif (!src_file) {\n\t\tret = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tsrc = src_file->f_dentry->d_inode;\n\n\tret = -EINVAL;\n\tif (src == inode)\n\t\tgoto out_fput;\n\n\t/* the src must be open for reading */\n\tif (!(src_file->f_mode & FMODE_READ))\n\t\tgoto out_fput;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tret = -EXDEV;\n\tif (src->i_sb != inode->i_sb || BTRFS_I(src)->root != root)\n\t\tgoto out_fput;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(btrfs_level_size(root, 0));\n\tif (!buf)\n\t\tgoto out_fput;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\tgoto out_fput;\n\t}\n\tpath->reada = 2;\n\n\tif (inode < src) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tmutex_lock(&src->i_mutex);\n\t} else {\n\t\tmutex_lock(&src->i_mutex);\n\t\tmutex_lock(&inode->i_mutex);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off + len > src->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ((src->i_size + bs-1) & ~(bs-1))\n\t\t\t- off;\n\n\t/* verify the end result is block aligned */\n\tif ((off & (bs-1)) ||\n\t    ((off + len) & (bs-1)))\n\t\tgoto out_unlock;\n\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(src)->io_tree, off, off+len, GFP_NOFS);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, off+len);\n\t\tif (BTRFS_I(src)->delalloc_bytes == 0 && !ordered)\n\t\t\tbreak;\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, off, off+len, GFP_NOFS);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(src, off, off+len);\n\t}\n\n\t/* clone data */\n\tkey.objectid = src->i_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\n\twhile (1) {\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (btrfs_key_type(&key) > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != src->i_ino)\n\t\t\tbreak;\n\n\t\tif (btrfs_key_type(&key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 endoff;\n\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\t\t\tbtrfs_release_path(root, path);\n\n\t\t\tif (key.offset + datal < off ||\n\t\t\t    key.offset >= off+len)\n\t\t\t\tgoto next;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = inode->i_ino;\n\t\t\tnew_key.offset = key.offset + destoff - off;\n\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\tret = btrfs_drop_extents(trans, inode,\n\t\t\t\t\t\t\t new_key.offset,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t &hint_byte, 1);\n\t\t\t\tBUG_ON(ret);\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tBUG_ON(ret);\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tnew_key.offset - datao);\n\t\t\t\t\tBUG_ON(ret);\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off+len)\n\t\t\t\t\ttrim = key.offset + datal - (off+len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\tret = btrfs_drop_extents(trans, inode,\n\t\t\t\t\t\t\t new_key.offset,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t &hint_byte, 1);\n\t\t\t\tBUG_ON(ret);\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tBUG_ON(ret);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(root, path);\n\n\t\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\t\t\t/*\n\t\t\t * we round up to the block size at eof when\n\t\t\t * determining which extents to clone above,\n\t\t\t * but shouldn't round up the file size\n\t\t\t */\n\t\t\tendoff = new_key.offset + datal;\n\t\t\tif (endoff > off+olen)\n\t\t\t\tendoff = off+olen;\n\t\t\tif (endoff > inode->i_size)\n\t\t\t\tbtrfs_i_size_write(inode, endoff);\n\n\t\t\tBTRFS_I(inode)->flags = BTRFS_I(src)->flags;\n\t\t\tret = btrfs_update_inode(trans, root, inode);\n\t\t\tBUG_ON(ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t}\nnext:\n\t\tbtrfs_release_path(root, path);\n\t\tkey.offset++;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(root, path);\n\tunlock_extent(&BTRFS_I(src)->io_tree, off, off+len, GFP_NOFS);\nout_unlock:\n\tmutex_unlock(&src->i_mutex);\n\tmutex_unlock(&inode->i_mutex);\n\tvfree(buf);\n\tbtrfs_free_path(path);\nout_fput:\n\tfput(src_file);\nout_drop_write:\n\tmnt_drop_write(file->f_path.mnt);\n\treturn ret;\n}",
    "abstract_func": "static noinline VAR_0 btrfs_ioctl_clone(struct file *file, unsigned long VAR_1,\n\t\t\t\t       u64 VAR_2, u64 VAR_3, u64 VAR_4)\n{\n\tstruct inode *inode = fdentry(file)->d_inode;\n\tstruct btrfs_root *VAR_5 = BTRFS_I(inode)->root;\n\tstruct file *VAR_6;\n\tstruct inode *VAR_7;\n\tstruct btrfs_trans_handle *VAR_8;\n\tstruct btrfs_path *VAR_9;\n\tstruct extent_buffer *VAR_10;\n\tchar *VAR_11;\n\tstruct btrfs_key VAR_12;\n\tu32 VAR_13;\n\tint VAR_14;\n\tint VAR_15;\n\tu64 VAR_16 = VAR_3;\n\tu64 VAR_17 = VAR_5->fs_info->sb->s_blocksize;\n\tu64 VAR_18;\n\n\t/* COMMENT_0 */\n         \n                                                            \n                                                                  \n                                                                  \n                                     \n                                                              \n                          \n    \n\n\t/* COMMENT_9 */\n\tif (!(file->f_mode & VAR_19) || (file->f_flags & VAR_20))\n\t\treturn -VAR_21;\n\n\tVAR_15 = mnt_want_write(file->f_path.mnt);\n\tif (VAR_15)\n\t\treturn VAR_15;\n\n\tVAR_6 = fget(VAR_1);\n\tif (!VAR_6) {\n\t\tVAR_15 = -VAR_22;\n\t\tgoto out_drop_write;\n\t}\n\n\tVAR_7 = VAR_6->f_dentry->d_inode;\n\n\tVAR_15 = -VAR_21;\n\tif (VAR_7 == inode)\n\t\tgoto out_fput;\n\n\t/* COMMENT_10 */\n\tif (!(VAR_6->f_mode & VAR_23))\n\t\tgoto out_fput;\n\n\tVAR_15 = -VAR_24;\n\tif (S_ISDIR(VAR_7->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tVAR_15 = -VAR_25;\n\tif (VAR_7->i_sb != inode->i_sb || BTRFS_I(VAR_7)->root != VAR_5)\n\t\tgoto out_fput;\n\n\tVAR_15 = -VAR_26;\n\tVAR_11 = vmalloc(btrfs_level_size(VAR_5, 0));\n\tif (!VAR_11)\n\t\tgoto out_fput;\n\n\tVAR_9 = btrfs_alloc_path();\n\tif (!VAR_9) {\n\t\tvfree(VAR_11);\n\t\tgoto out_fput;\n\t}\n\tVAR_9->reada = 2;\n\n\tif (inode < VAR_7) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tmutex_lock(&VAR_7->i_mutex);\n\t} else {\n\t\tmutex_lock(&VAR_7->i_mutex);\n\t\tmutex_lock(&inode->i_mutex);\n\t}\n\n\t/* COMMENT_11 */\n\tVAR_15 = -VAR_21;\n\tif (VAR_2 + VAR_16 > VAR_7->i_size || VAR_2 + VAR_16 < VAR_2)\n\t\tgoto out_unlock;\n\tif (VAR_16 == 0)\n\t\tVAR_3 = VAR_16 = VAR_7->i_size - VAR_2;\n\t/* COMMENT_12 */\n\tif (VAR_2 + VAR_16 == VAR_7->i_size)\n\t\tVAR_16 = ((VAR_7->i_size + VAR_17-1) & ~(VAR_17-1))\n\t\t\t- VAR_2;\n\n\t/* COMMENT_13 */\n\tif ((VAR_2 & (VAR_17-1)) ||\n\t    ((VAR_2 + VAR_16) & (VAR_17-1)))\n\t\tgoto out_unlock;\n\n\t/* COMMENT_14 */\n                                     \n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *VAR_27;\n\t\tlock_extent(&BTRFS_I(VAR_7)->io_tree, VAR_2, VAR_2+VAR_16, VAR_28);\n\t\tVAR_27 = btrfs_lookup_first_ordered_extent(inode, VAR_2+VAR_16);\n\t\tif (BTRFS_I(VAR_7)->delalloc_bytes == 0 && !VAR_27)\n\t\t\tbreak;\n\t\tunlock_extent(&BTRFS_I(VAR_7)->io_tree, VAR_2, VAR_2+VAR_16, VAR_28);\n\t\tif (VAR_27)\n\t\t\tbtrfs_put_ordered_extent(VAR_27);\n\t\tbtrfs_wait_ordered_range(VAR_7, VAR_2, VAR_2+VAR_16);\n\t}\n\n\t/* COMMENT_16 */\n\tVAR_12.objectid = VAR_7->i_ino;\n\tVAR_12.type = VAR_29;\n\tVAR_12.offset = 0;\n\n\twhile (1) {\n\t\t/* COMMENT_17 */\n                                                         \n          \n     \n\t\tVAR_15 = btrfs_search_slot(NULL, VAR_5, &VAR_12, VAR_9, 0, 0);\n\t\tif (VAR_15 < 0)\n\t\t\tgoto out;\n\n\t\tVAR_13 = btrfs_header_nritems(VAR_9->nodes[0]);\n\t\tif (VAR_9->slots[0] >= VAR_13) {\n\t\t\tVAR_15 = btrfs_next_leaf(VAR_5, VAR_9);\n\t\t\tif (VAR_15 < 0)\n\t\t\t\tgoto out;\n\t\t\tif (VAR_15 > 0)\n\t\t\t\tbreak;\n\t\t\tVAR_13 = btrfs_header_nritems(VAR_9->nodes[0]);\n\t\t}\n\t\tVAR_10 = VAR_9->nodes[0];\n\t\tVAR_14 = VAR_9->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(VAR_10, &VAR_12, VAR_14);\n\t\tif (btrfs_key_type(&VAR_12) > VAR_29 ||\n\t\t    VAR_12.objectid != VAR_7->i_ino)\n\t\t\tbreak;\n\n\t\tif (btrfs_key_type(&VAR_12) == VAR_29) {\n\t\t\tstruct btrfs_file_extent_item *VAR_30;\n\t\t\tint VAR_31;\n\t\t\tu32 VAR_32;\n\t\t\tstruct btrfs_key VAR_33;\n\t\t\tu64 VAR_34 = 0, VAR_35 = 0;\n\t\t\tu64 VAR_36 = 0, VAR_37 = 0;\n\t\t\tu8 VAR_38;\n\t\t\tu64 VAR_39;\n\n\t\t\tVAR_32 = btrfs_item_size_nr(VAR_10, VAR_14);\n\t\t\tread_extent_buffer(VAR_10, VAR_11,\n\t\t\t\t\t   btrfs_item_ptr_offset(VAR_10, VAR_14),\n\t\t\t\t\t   VAR_32);\n\n\t\t\tVAR_30 = btrfs_item_ptr(VAR_10, VAR_14,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tVAR_38 = btrfs_file_extent_compression(VAR_10, VAR_30);\n\t\t\tVAR_31 = btrfs_file_extent_type(VAR_10, VAR_30);\n\t\t\tif (VAR_31 == VAR_40 ||\n\t\t\t    VAR_31 == VAR_41) {\n\t\t\t\tVAR_34 = btrfs_file_extent_disk_bytenr(VAR_10,\n\t\t\t\t\t\t\t\t      VAR_30);\n\t\t\t\tVAR_35 = btrfs_file_extent_disk_num_bytes(VAR_10,\n\t\t\t\t\t\t\t\t VAR_30);\n\t\t\t\tVAR_36 = btrfs_file_extent_offset(VAR_10, VAR_30);\n\t\t\t\tVAR_37 = btrfs_file_extent_num_bytes(VAR_10,\n\t\t\t\t\t\t\t\t    VAR_30);\n\t\t\t} else if (VAR_31 == VAR_42) {\n\t\t\t\t/* COMMENT_21 */\n\t\t\t\tVAR_37 = btrfs_file_extent_ram_bytes(VAR_10,\n\t\t\t\t\t\t\t\t    VAR_30);\n\t\t\t}\n\t\t\tbtrfs_release_path(VAR_5, VAR_9);\n\n\t\t\tif (VAR_12.offset + VAR_37 < VAR_2 ||\n\t\t\t    VAR_12.offset >= VAR_2+VAR_16)\n\t\t\t\tgoto next;\n\n\t\t\tmemcpy(&VAR_33, &VAR_12, sizeof(VAR_33));\n\t\t\tVAR_33.objectid = inode->i_ino;\n\t\t\tVAR_33.offset = VAR_12.offset + VAR_4 - VAR_2;\n\n\t\t\tVAR_8 = btrfs_start_transaction(VAR_5, 1);\n\t\t\tif (IS_ERR(VAR_8)) {\n\t\t\t\tVAR_15 = PTR_ERR(VAR_8);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (VAR_31 == VAR_40 ||\n\t\t\t    VAR_31 == VAR_41) {\n\t\t\t\tif (VAR_2 > VAR_12.offset) {\n\t\t\t\t\tVAR_36 += VAR_2 - VAR_12.offset;\n\t\t\t\t\tVAR_37 -= VAR_2 - VAR_12.offset;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_12.offset + VAR_37 > VAR_2 + VAR_16)\n\t\t\t\t\tVAR_37 = VAR_2 + VAR_16 - VAR_12.offset;\n\n\t\t\t\tVAR_15 = btrfs_drop_extents(VAR_8, inode,\n\t\t\t\t\t\t\t VAR_33.offset,\n\t\t\t\t\t\t\t VAR_33.offset + VAR_37,\n\t\t\t\t\t\t\t &VAR_18, 1);\n\t\t\t\tBUG_ON(VAR_15);\n\n\t\t\t\tVAR_15 = btrfs_insert_empty_item(VAR_8, VAR_5, VAR_9,\n\t\t\t\t\t\t\t      &VAR_33, VAR_32);\n\t\t\t\tBUG_ON(VAR_15);\n\n\t\t\t\tVAR_10 = VAR_9->nodes[0];\n\t\t\t\tVAR_14 = VAR_9->slots[0];\n\t\t\t\twrite_extent_buffer(VAR_10, VAR_11,\n\t\t\t\t\t    btrfs_item_ptr_offset(VAR_10, VAR_14),\n\t\t\t\t\t    VAR_32);\n\n\t\t\t\tVAR_30 = btrfs_item_ptr(VAR_10, VAR_14,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* COMMENT_22 */\n\t\t\t\tif (!VAR_34)\n\t\t\t\t\tVAR_36 = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(VAR_10, VAR_30,\n\t\t\t\t\t\t\t     VAR_36);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(VAR_10, VAR_30,\n\t\t\t\t\t\t\t\tVAR_37);\n\t\t\t\tif (VAR_34) {\n\t\t\t\t\tinode_add_bytes(inode, VAR_37);\n\t\t\t\t\tVAR_15 = btrfs_inc_extent_ref(VAR_8, VAR_5,\n\t\t\t\t\t\t\tVAR_34, VAR_35, 0,\n\t\t\t\t\t\t\tVAR_5->root_key.objectid,\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tVAR_33.offset - VAR_36);\n\t\t\t\t\tBUG_ON(VAR_15);\n\t\t\t\t}\n\t\t\t} else if (VAR_31 == VAR_42) {\n\t\t\t\tu64 VAR_43 = 0;\n\t\t\t\tu64 VAR_44 = 0;\n\t\t\t\tif (VAR_2 > VAR_12.offset) {\n\t\t\t\t\tVAR_43 = VAR_2 - VAR_12.offset;\n\t\t\t\t\tVAR_33.offset += VAR_43;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_12.offset + VAR_37 > VAR_2+VAR_16)\n\t\t\t\t\tVAR_44 = VAR_12.offset + VAR_37 - (VAR_2+VAR_16);\n\n\t\t\t\tif (VAR_38 && (VAR_43 || VAR_44)) {\n\t\t\t\t\tVAR_15 = -VAR_21;\n\t\t\t\t\tbtrfs_end_transaction(VAR_8, VAR_5);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tVAR_32 -= VAR_43 + VAR_44;\n\t\t\t\tVAR_37 -= VAR_43 + VAR_44;\n\n\t\t\t\tVAR_15 = btrfs_drop_extents(VAR_8, inode,\n\t\t\t\t\t\t\t VAR_33.offset,\n\t\t\t\t\t\t\t VAR_33.offset + VAR_37,\n\t\t\t\t\t\t\t &VAR_18, 1);\n\t\t\t\tBUG_ON(VAR_15);\n\n\t\t\t\tVAR_15 = btrfs_insert_empty_item(VAR_8, VAR_5, VAR_9,\n\t\t\t\t\t\t\t      &VAR_33, VAR_32);\n\t\t\t\tBUG_ON(VAR_15);\n\n\t\t\t\tif (VAR_43) {\n\t\t\t\t\tu32 VAR_45 =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(VAR_11+VAR_45, VAR_11+VAR_45+VAR_43,\n\t\t\t\t\t\tVAR_37);\n\t\t\t\t}\n\n\t\t\t\tVAR_10 = VAR_9->nodes[0];\n\t\t\t\tVAR_14 = VAR_9->slots[0];\n\t\t\t\twrite_extent_buffer(VAR_10, VAR_11,\n\t\t\t\t\t    btrfs_item_ptr_offset(VAR_10, VAR_14),\n\t\t\t\t\t    VAR_32);\n\t\t\t\tinode_add_bytes(inode, VAR_37);\n\t\t\t}\n\n\t\t\tbtrfs_mark_buffer_dirty(VAR_10);\n\t\t\tbtrfs_release_path(VAR_5, VAR_9);\n\n\t\t\tinode->i_mtime = inode->i_ctime = VAR_46;\n\n\t\t\t/* COMMENT_23 */\n                                               \n                                               \n                                          \n      \n\t\t\tVAR_39 = VAR_33.offset + VAR_37;\n\t\t\tif (VAR_39 > VAR_2+VAR_3)\n\t\t\t\tVAR_39 = VAR_2+VAR_3;\n\t\t\tif (VAR_39 > inode->i_size)\n\t\t\t\tbtrfs_i_size_write(inode, VAR_39);\n\n\t\t\tBTRFS_I(inode)->flags = BTRFS_I(VAR_7)->flags;\n\t\t\tVAR_15 = btrfs_update_inode(VAR_8, VAR_5, inode);\n\t\t\tBUG_ON(VAR_15);\n\t\t\tbtrfs_end_transaction(VAR_8, VAR_5);\n\t\t}\nnext:\n\t\tbtrfs_release_path(VAR_5, VAR_9);\n\t\tVAR_12.offset++;\n\t}\n\tVAR_15 = 0;\nout:\n\tbtrfs_release_path(VAR_5, VAR_9);\n\tunlock_extent(&BTRFS_I(VAR_7)->io_tree, VAR_2, VAR_2+VAR_16, VAR_28);\nout_unlock:\n\tmutex_unlock(&VAR_7->i_mutex);\n\tmutex_unlock(&inode->i_mutex);\n\tvfree(VAR_11);\n\tbtrfs_free_path(VAR_9);\nout_fput:\n\tfput(VAR_6);\nout_drop_write:\n\tmnt_drop_write(file->f_path.mnt);\n\treturn VAR_15;\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \t */\n \n \t/* the destination must be opened for writing */\n-\tif (!(file->f_mode & FMODE_WRITE))\n+\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n \t\treturn -EINVAL;\n \n \tret = mnt_want_write(file->f_path.mnt);\n@@ -81,7 +81,7 @@\n \n \t/* determine range to clone */\n \tret = -EINVAL;\n-\tif (off >= src->i_size || off + len > src->i_size)\n+\tif (off + len > src->i_size || off + len < off)\n \t\tgoto out_unlock;\n \tif (len == 0)\n \t\tolen = len = src->i_size - off;",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (!(file->f_mode & FMODE_WRITE))",
            "\tif (off >= src->i_size || off + len > src->i_size)"
        ],
        "added_lines": [
            "\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))",
            "\tif (off + len > src->i_size || off + len < off)"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}