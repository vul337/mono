{
    "cve_id": "CVE-2023-34969",
    "cwe_ids": [
        "CWE-Other"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "dbus",
    "commit_msg": "Normally, it's enough to rely on a message being given a serial number\nby the DBusConnection just before it is actually sent. However, in the\nrare case where the policy blocks the driver from sending a message\n(due to a deny rule or the outgoing message quota being full), we need\nto get a valid serial number sooner, so that we can copy it into the\nDBUS_HEADER_FIELD_REPLY_SERIAL field (which is mandatory) in the error\nmessage sent to monitors. Otherwise, the dbus-daemon will crash with\nan assertion failure if at least one Monitoring client is attached,\nbecause zero is not a valid serial number to copy.\n\nThis fixes a denial-of-service vulnerability: if a privileged user is\nmonitoring the well-known system bus using a Monitoring client like\ndbus-monitor or `busctl monitor`, then an unprivileged user can cause\ndenial-of-service by triggering this crash. A mitigation for this\nvulnerability is to avoid attaching Monitoring clients to the system\nbus when they are not needed. If there are no Monitoring clients, then\nthe vulnerable code is not reached.\n\nCo-authored-by: Simon McVittie <smcv@collabora.com>\nResolves: dbus/dbus#457\n",
    "commit_hash": "b159849e031000d1dbc1ab876b5fc78a3ce9b534",
    "git_url": "https://cgit.freedesktop.org/dbus/dbus/commit/?id=b159849e031000d1dbc1ab876b5fc78a3ce9b534",
    "file_path": "bus/connection.c",
    "func_name": "bus_transaction_send_from_driver",
    "func_before": "dbus_bool_t\nbus_transaction_send_from_driver (BusTransaction *transaction,\n                                  DBusConnection *connection,\n                                  DBusMessage    *message)\n{\n  DBusError error = DBUS_ERROR_INIT;\n\n  /* We have to set the sender to the driver, and have\n   * to check security policy since it was not done in\n   * dispatch.c\n   */\n  _dbus_verbose (\"Sending %s %s %s from driver\\n\",\n                 dbus_message_get_interface (message) ?\n                 dbus_message_get_interface (message) : \"(no interface)\",\n                 dbus_message_get_member (message) ?\n                 dbus_message_get_member (message) : \"(no member)\",\n                 dbus_message_get_error_name (message) ?\n                 dbus_message_get_error_name (message) : \"(no error name)\");\n                 \n  if (!dbus_message_set_sender (message, DBUS_SERVICE_DBUS))\n    return FALSE;\n\n  if (bus_connection_is_active (connection))\n    {\n      if (!dbus_message_set_destination (message,\n                                         bus_connection_get_name (connection)))\n        return FALSE;\n    }\n  \n  /* bus driver never wants a reply */\n  dbus_message_set_no_reply (message, TRUE);\n\n  /* Capture it for monitors, even if the real recipient's receive policy\n   * does not allow it to receive this message from us (which would be odd).\n   */\n  if (!bus_transaction_capture (transaction, NULL, connection, message))\n    return FALSE;\n\n  /* If security policy doesn't allow the message, we would silently\n   * eat it; the driver doesn't care about getting a reply. However,\n   * if we're actively capturing messages, it's nice to log that we\n   * tried to send it and did not allow ourselves to do so.\n   */\n  if (!bus_context_check_security_policy (bus_transaction_get_context (transaction),\n                                          transaction,\n                                          NULL, connection, connection,\n                                          message, NULL, &error))\n    {\n      if (!bus_transaction_capture_error_reply (transaction, connection,\n                                                &error, message))\n        {\n          bus_context_log (transaction->context, DBUS_SYSTEM_LOG_WARNING,\n                           \"message from dbus-daemon rejected but not enough \"\n                           \"memory to capture it\");\n        }\n\n      /* This is not fatal to the transaction so silently eat the disallowed\n       * message (see reasoning above) */\n      dbus_error_free (&error);\n      return TRUE;\n    }\n\n  return bus_transaction_send (transaction, NULL, connection, message);\n}",
    "abstract_func_before": "dbus_bool_t\nbus_transaction_send_from_driver (BusTransaction *VAR_0,\n                                  DBusConnection *VAR_1,\n                                  DBusMessage    *VAR_2)\n{\n  DBusError VAR_3 = VAR_4;\n\n  /* COMMENT_0 */\n                                                      \n               \n     \n  _dbus_verbose (\"Sending %s %s %s from driver\\n\",\n                 dbus_message_get_interface (VAR_2) ?\n                 dbus_message_get_interface (VAR_2) : \"(no interface)\",\n                 dbus_message_get_member (VAR_2) ?\n                 dbus_message_get_member (VAR_2) : \"(no member)\",\n                 dbus_message_get_error_name (VAR_2) ?\n                 dbus_message_get_error_name (VAR_2) : \"(no error name)\");\n                 \n  if (!dbus_message_set_sender (VAR_2, VAR_5))\n    return FALSE;\n\n  if (bus_connection_is_active (VAR_1))\n    {\n      if (!dbus_message_set_destination (VAR_2,\n                                         bus_connection_get_name (VAR_1)))\n        return FALSE;\n    }\n  \n  /* COMMENT_4 */\n  dbus_message_set_no_reply (VAR_2, TRUE);\n\n  /* COMMENT_5 */\n                                                                            \n     \n  if (!bus_transaction_capture (VAR_0, NULL, VAR_1, VAR_2))\n    return FALSE;\n\n  /* COMMENT_8 */\n                                                                    \n                                                                   \n                                                           \n     \n  if (!bus_context_check_security_policy (bus_transaction_get_context (VAR_0),\n                                          VAR_0,\n                                          NULL, VAR_1, VAR_1,\n                                          VAR_2, NULL, &VAR_3))\n    {\n      if (!bus_transaction_capture_error_reply (VAR_0, VAR_1,\n                                                &VAR_3, VAR_2))\n        {\n          bus_context_log (VAR_0->context, VAR_6,\n                           \"message from dbus-daemon rejected but not enough \"\n                           \"memory to capture it\");\n        }\n\n      /* COMMENT_13 */\n                                         \n      dbus_error_free (&VAR_3);\n      return TRUE;\n    }\n\n  return bus_transaction_send (VAR_0, NULL, VAR_1, VAR_2);\n}",
    "func_graph_path_before": "dbus/b159849e031000d1dbc1ab876b5fc78a3ce9b534/connection.c/vul/before/0.json",
    "func": "dbus_bool_t\nbus_transaction_send_from_driver (BusTransaction *transaction,\n                                  DBusConnection *connection,\n                                  DBusMessage    *message)\n{\n  DBusError error = DBUS_ERROR_INIT;\n\n  /* We have to set the sender to the driver, and have\n   * to check security policy since it was not done in\n   * dispatch.c\n   */\n  _dbus_verbose (\"Sending %s %s %s from driver\\n\",\n                 dbus_message_get_interface (message) ?\n                 dbus_message_get_interface (message) : \"(no interface)\",\n                 dbus_message_get_member (message) ?\n                 dbus_message_get_member (message) : \"(no member)\",\n                 dbus_message_get_error_name (message) ?\n                 dbus_message_get_error_name (message) : \"(no error name)\");\n                 \n  if (!dbus_message_set_sender (message, DBUS_SERVICE_DBUS))\n    return FALSE;\n\n  /* Make sure the message has a non-zero serial number, otherwise\n   * bus_transaction_capture_error_reply() will not be able to mock up\n   * a corresponding reply for it. Normally this would be delayed until\n   * the first time we actually send the message out from a\n   * connection, when the transaction is committed, but that's too late\n   * in this case.\n   */\n  if (dbus_message_get_serial (message) == 0)\n    {\n      dbus_uint32_t next_serial;\n\n      next_serial = _dbus_connection_get_next_client_serial (connection);\n      dbus_message_set_serial (message, next_serial);\n    }\n\n  if (bus_connection_is_active (connection))\n    {\n      if (!dbus_message_set_destination (message,\n                                         bus_connection_get_name (connection)))\n        return FALSE;\n    }\n  \n  /* bus driver never wants a reply */\n  dbus_message_set_no_reply (message, TRUE);\n\n  /* Capture it for monitors, even if the real recipient's receive policy\n   * does not allow it to receive this message from us (which would be odd).\n   */\n  if (!bus_transaction_capture (transaction, NULL, connection, message))\n    return FALSE;\n\n  /* If security policy doesn't allow the message, we would silently\n   * eat it; the driver doesn't care about getting a reply. However,\n   * if we're actively capturing messages, it's nice to log that we\n   * tried to send it and did not allow ourselves to do so.\n   */\n  if (!bus_context_check_security_policy (bus_transaction_get_context (transaction),\n                                          transaction,\n                                          NULL, connection, connection,\n                                          message, NULL, &error))\n    {\n      if (!bus_transaction_capture_error_reply (transaction, connection,\n                                                &error, message))\n        {\n          bus_context_log (transaction->context, DBUS_SYSTEM_LOG_WARNING,\n                           \"message from dbus-daemon rejected but not enough \"\n                           \"memory to capture it\");\n        }\n\n      /* This is not fatal to the transaction so silently eat the disallowed\n       * message (see reasoning above) */\n      dbus_error_free (&error);\n      return TRUE;\n    }\n\n  return bus_transaction_send (transaction, NULL, connection, message);\n}",
    "abstract_func": "dbus_bool_t\nbus_transaction_send_from_driver (BusTransaction *VAR_0,\n                                  DBusConnection *VAR_1,\n                                  DBusMessage    *VAR_2)\n{\n  DBusError VAR_3 = VAR_4;\n\n  /* COMMENT_0 */\n                                                      \n               \n     \n  _dbus_verbose (\"Sending %s %s %s from driver\\n\",\n                 dbus_message_get_interface (VAR_2) ?\n                 dbus_message_get_interface (VAR_2) : \"(no interface)\",\n                 dbus_message_get_member (VAR_2) ?\n                 dbus_message_get_member (VAR_2) : \"(no member)\",\n                 dbus_message_get_error_name (VAR_2) ?\n                 dbus_message_get_error_name (VAR_2) : \"(no error name)\");\n                 \n  if (!dbus_message_set_sender (VAR_2, VAR_5))\n    return FALSE;\n\n  /* COMMENT_4 */\n                                                                      \n                                                                       \n                                                           \n                                                                       \n                  \n     \n  if (dbus_message_get_serial (VAR_2) == 0)\n    {\n      dbus_uint32_t VAR_6;\n\n      VAR_6 = _dbus_connection_get_next_client_serial (VAR_1);\n      dbus_message_set_serial (VAR_2, VAR_6);\n    }\n\n  if (bus_connection_is_active (VAR_1))\n    {\n      if (!dbus_message_set_destination (VAR_2,\n                                         bus_connection_get_name (VAR_1)))\n        return FALSE;\n    }\n  \n  /* COMMENT_11 */\n  dbus_message_set_no_reply (VAR_2, TRUE);\n\n  /* COMMENT_12 */\n                                                                            \n     \n  if (!bus_transaction_capture (VAR_0, NULL, VAR_1, VAR_2))\n    return FALSE;\n\n  /* COMMENT_15 */\n                                                                    \n                                                                   \n                                                           \n     \n  if (!bus_context_check_security_policy (bus_transaction_get_context (VAR_0),\n                                          VAR_0,\n                                          NULL, VAR_1, VAR_1,\n                                          VAR_2, NULL, &VAR_3))\n    {\n      if (!bus_transaction_capture_error_reply (VAR_0, VAR_1,\n                                                &VAR_3, VAR_2))\n        {\n          bus_context_log (VAR_0->context, VAR_7,\n                           \"message from dbus-daemon rejected but not enough \"\n                           \"memory to capture it\");\n        }\n\n      /* COMMENT_20 */\n                                         \n      dbus_error_free (&VAR_3);\n      return TRUE;\n    }\n\n  return bus_transaction_send (VAR_0, NULL, VAR_1, VAR_2);\n}",
    "func_graph_path": "dbus/b159849e031000d1dbc1ab876b5fc78a3ce9b534/connection.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,21 @@\n                  \n   if (!dbus_message_set_sender (message, DBUS_SERVICE_DBUS))\n     return FALSE;\n+\n+  /* Make sure the message has a non-zero serial number, otherwise\n+   * bus_transaction_capture_error_reply() will not be able to mock up\n+   * a corresponding reply for it. Normally this would be delayed until\n+   * the first time we actually send the message out from a\n+   * connection, when the transaction is committed, but that's too late\n+   * in this case.\n+   */\n+  if (dbus_message_get_serial (message) == 0)\n+    {\n+      dbus_uint32_t next_serial;\n+\n+      next_serial = _dbus_connection_get_next_client_serial (connection);\n+      dbus_message_set_serial (message, next_serial);\n+    }\n \n   if (bus_connection_is_active (connection))\n     {",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "",
            "  /* Make sure the message has a non-zero serial number, otherwise",
            "   * bus_transaction_capture_error_reply() will not be able to mock up",
            "   * a corresponding reply for it. Normally this would be delayed until",
            "   * the first time we actually send the message out from a",
            "   * connection, when the transaction is committed, but that's too late",
            "   * in this case.",
            "   */",
            "  if (dbus_message_get_serial (message) == 0)",
            "    {",
            "      dbus_uint32_t next_serial;",
            "",
            "      next_serial = _dbus_connection_get_next_client_serial (connection);",
            "      dbus_message_set_serial (message, next_serial);",
            "    }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}