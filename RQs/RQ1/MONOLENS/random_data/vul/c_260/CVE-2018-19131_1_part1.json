{
    "cve_id": "CVE-2018-19131",
    "cwe_ids": [
        "CWE-79"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "squid-cache/squid",
    "commit_msg": "SSL Interception: Injection into default ssl error page via untrusted certificate\n\nThe error page allows injecting snippets using the distinguished name of\nuntrusted certificates via the %D template parameter.\nThis patch quote information retrieved from  remote certificates using the\n%ssl_subject, %ssl_ca_name and %ssl_cn error details formating codes.\n\nThanks to Nikolas Lohmann [eBlocker] for identifying the problem.\n\nThis is a Measurement Factory project",
    "commit_hash": "d241f11e4aaa2ab719358cb808935c98612e71b5",
    "git_url": "https://github.com/squid-cache/squid/commit/d241f11e4aaa2ab719358cb808935c98612e71b5",
    "file_path": "src/ssl/ErrorDetail.cc",
    "func_name": "Ssl::ErrorDetail::subject",
    "func_before": "const char  *Ssl::ErrorDetail::subject() const\n{\n    if (broken_cert.get()) {\n        static char tmpBuffer[256]; // A temporary buffer\n        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))\n            return tmpBuffer;\n    }\n    return \"[Not available]\";\n}",
    "abstract_func_before": "const char  *Ssl::ErrorDetail::subject() const\n{\n    if (VAR_0.get()) {\n        static char VAR_1[256]; /* COMMENT_0 */\n        if (X509_NAME_oneline(X509_get_subject_name(VAR_0.get()), VAR_1, sizeof(VAR_1)))\n            return VAR_1;\n    }\n    return \"[Not available]\";\n}",
    "func_graph_path_before": "squid-cache/squid/d241f11e4aaa2ab719358cb808935c98612e71b5/ErrorDetail.cc/vul/before/2.json",
    "func": "const char  *Ssl::ErrorDetail::subject() const\n{\n    if (broken_cert.get()) {\n        static char tmpBuffer[256]; // A temporary buffer\n        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {\n            // quote to avoid possible html code injection through\n            // certificate subject\n            return html_quote(tmpBuffer);\n        }\n    }\n    return \"[Not available]\";\n}",
    "abstract_func": "const char  *Ssl::ErrorDetail::subject() const\n{\n    if (VAR_0.get()) {\n        static char VAR_1[256]; /* COMMENT_0 */\n        if (X509_NAME_oneline(X509_get_subject_name(VAR_0.get()), VAR_1, sizeof(VAR_1))) {\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            return html_quote(VAR_1);\n        }\n    }\n    return \"[Not available]\";\n}",
    "func_graph_path": "squid-cache/squid/d241f11e4aaa2ab719358cb808935c98612e71b5/ErrorDetail.cc/vul/after/2.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,11 @@\n {\n     if (broken_cert.get()) {\n         static char tmpBuffer[256]; // A temporary buffer\n-        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))\n-            return tmpBuffer;\n+        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {\n+            // quote to avoid possible html code injection through\n+            // certificate subject\n+            return html_quote(tmpBuffer);\n+        }\n     }\n     return \"[Not available]\";\n }",
    "diff_line_info": {
        "deleted_lines": [
            "        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))",
            "            return tmpBuffer;"
        ],
        "added_lines": [
            "        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {",
            "            // quote to avoid possible html code injection through",
            "            // certificate subject",
            "            return html_quote(tmpBuffer);",
            "        }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}