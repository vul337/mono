{
    "cve_id": "CVE-2016-7179",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "wireshark",
    "commit_msg": "DCT2000: prevent a stack buffer overflow\n\nBug: 12752\nChange-Id: I2007082909cea07314ac40d6db32ee9c2804ecdf\nReviewed-on: https://code.wireshark.org/review/17095\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",
    "commit_hash": "3b97fbddc23c065727b0147aab52a27c4aadffe7",
    "git_url": "https://github.com/wireshark/wireshark/commit/3b97fbddc23c065727b0147aab52a27c4aadffe7",
    "file_path": "epan/dissectors/packet-catapult-dct2000.c",
    "func_name": "parse_outhdr_string",
    "func_before": "static void parse_outhdr_string(const guchar *outhdr_string, gint outhdr_string_len)\n{\n    int   n                 = 0;\n\n    /* Populate values array */\n    for (outhdr_values_found=0; outhdr_values_found < MAX_OUTHDR_VALUES; ) {\n\n        guint  digit_array[MAX_OUTHDR_VALUES];\n        guint  number_digits = 0;\n\n        guint   number = 0;\n        guint   multiplier = 1;\n        guint   d;\n\n        /* Find digits */\n        for ( ; n < outhdr_string_len; n++) {\n            if (!g_ascii_isdigit(outhdr_string[n])) {\n                break;\n            }\n            else {\n                digit_array[number_digits++] = outhdr_string[n] - '0';\n            }\n        }\n\n        if (number_digits == 0) {\n            /* No more numbers left */\n            break;\n        }\n\n        /* Convert digits into value (much faster than format_text() + atoi()) */\n        for (d=number_digits; d > 0; d--) {\n            number += ((digit_array[d-1]) * multiplier);\n            multiplier *= 10;\n        }\n        outhdr_values[outhdr_values_found++] = number;\n\n        /* Skip comma */\n        n++;\n    }\n}",
    "abstract_func_before": "static void parse_outhdr_string(const guchar *VAR_0, gint VAR_1)\n{\n    int   VAR_2                 = 0;\n\n    /* COMMENT_0 */\n    for (VAR_3=0; VAR_3 < VAR_4; ) {\n\n        guint  VAR_5[VAR_4];\n        guint  VAR_6 = 0;\n\n        guint   VAR_7 = 0;\n        guint   VAR_8 = 1;\n        guint   VAR_9;\n\n        /* COMMENT_1 */\n        for ( ; VAR_2 < VAR_1; VAR_2++) {\n            if (!g_ascii_isdigit(VAR_0[VAR_2])) {\n                break;\n            }\n            else {\n                VAR_5[VAR_6++] = VAR_0[VAR_2] - '0';\n            }\n        }\n\n        if (VAR_6 == 0) {\n            /* COMMENT_2 */\n            break;\n        }\n\n        /* COMMENT_3 */\n        for (VAR_9=VAR_6; VAR_9 > 0; VAR_9--) {\n            VAR_7 += ((VAR_5[VAR_9-1]) * VAR_8);\n            VAR_8 *= 10;\n        }\n        VAR_10[VAR_3++] = VAR_7;\n\n        /* COMMENT_4 */\n        VAR_2++;\n    }\n}",
    "func_graph_path_before": "wireshark/3b97fbddc23c065727b0147aab52a27c4aadffe7/packet-catapult-dct2000.c/vul/before/0.json",
    "func": "static void parse_outhdr_string(const guchar *outhdr_string, gint outhdr_string_len)\n{\n    int   n                 = 0;\n\n    /* Populate values array */\n    for (outhdr_values_found=0; outhdr_values_found < MAX_OUTHDR_VALUES; ) {\n\n        guint  digit_array[MAX_OUTHDR_VALUES];\n        guint  number_digits = 0;\n\n        guint   number = 0;\n        guint   multiplier = 1;\n        guint   d;\n\n        /* Find digits */\n        for ( ; (n < outhdr_string_len) && (number_digits < MAX_OUTHDR_VALUES); n++) {\n            if (!g_ascii_isdigit(outhdr_string[n])) {\n                break;\n            }\n            else {\n                digit_array[number_digits++] = outhdr_string[n] - '0';\n            }\n        }\n\n        if (number_digits == 0) {\n            /* No more numbers left */\n            break;\n        }\n\n        /* Convert digits into value (much faster than format_text() + atoi()) */\n        for (d=number_digits; d > 0; d--) {\n            number += ((digit_array[d-1]) * multiplier);\n            multiplier *= 10;\n        }\n        outhdr_values[outhdr_values_found++] = number;\n\n        /* Skip comma */\n        n++;\n    }\n}",
    "abstract_func": "static void parse_outhdr_string(const guchar *VAR_0, gint VAR_1)\n{\n    int   VAR_2                 = 0;\n\n    /* COMMENT_0 */\n    for (VAR_3=0; VAR_3 < VAR_4; ) {\n\n        guint  VAR_5[VAR_4];\n        guint  VAR_6 = 0;\n\n        guint   VAR_7 = 0;\n        guint   VAR_8 = 1;\n        guint   VAR_9;\n\n        /* COMMENT_1 */\n        for ( ; (VAR_2 < VAR_1) && (VAR_6 < VAR_4); VAR_2++) {\n            if (!g_ascii_isdigit(VAR_0[VAR_2])) {\n                break;\n            }\n            else {\n                VAR_5[VAR_6++] = VAR_0[VAR_2] - '0';\n            }\n        }\n\n        if (VAR_6 == 0) {\n            /* COMMENT_2 */\n            break;\n        }\n\n        /* COMMENT_3 */\n        for (VAR_9=VAR_6; VAR_9 > 0; VAR_9--) {\n            VAR_7 += ((VAR_5[VAR_9-1]) * VAR_8);\n            VAR_8 *= 10;\n        }\n        VAR_10[VAR_3++] = VAR_7;\n\n        /* COMMENT_4 */\n        VAR_2++;\n    }\n}",
    "func_graph_path": "wireshark/3b97fbddc23c065727b0147aab52a27c4aadffe7/packet-catapult-dct2000.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n         guint   d;\n \n         /* Find digits */\n-        for ( ; n < outhdr_string_len; n++) {\n+        for ( ; (n < outhdr_string_len) && (number_digits < MAX_OUTHDR_VALUES); n++) {\n             if (!g_ascii_isdigit(outhdr_string[n])) {\n                 break;\n             }",
    "diff_line_info": {
        "deleted_lines": [
            "        for ( ; n < outhdr_string_len; n++) {"
        ],
        "added_lines": [
            "        for ( ; (n < outhdr_string_len) && (number_digits < MAX_OUTHDR_VALUES); n++) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}