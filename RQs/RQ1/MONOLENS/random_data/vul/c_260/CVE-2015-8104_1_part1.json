{
    "cve_id": "CVE-2015-8104",
    "cwe_ids": [
        "CWE-399"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "KVM: svm: unconditionally intercept #DB\n\nThis is needed to avoid the possibility that the guest triggers\nan infinite stream of #DB exceptions (CVE-2015-8104).\n\nVMX is not affected: because it does not save DR6 in the VMCS,\nit already intercepts #DB unconditionally.\n\nReported-by: Jan Beulich <jbeulich@suse.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "commit_hash": "cbdb967af3d54993f5814f1cee0ed311a055377d",
    "git_url": "https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d",
    "file_path": "arch/x86/kvm/svm.c",
    "func_name": "init_vmcb",
    "func_before": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n}",
    "abstract_func_before": "static void init_vmcb(struct vcpu_svm *VAR_0)\n{\n\tstruct vmcb_control_area *VAR_1 = &VAR_0->vmcb->control;\n\tstruct vmcb_save_area *VAR_2 = &VAR_0->vmcb->save;\n\n\tVAR_0->vcpu.fpu_active = 1;\n\tVAR_0->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(VAR_0, VAR_3);\n\tset_cr_intercept(VAR_0, VAR_4);\n\tset_cr_intercept(VAR_0, VAR_5);\n\tset_cr_intercept(VAR_0, VAR_6);\n\tset_cr_intercept(VAR_0, VAR_7);\n\tset_cr_intercept(VAR_0, VAR_8);\n\tset_cr_intercept(VAR_0, VAR_9);\n\n\tset_dr_intercepts(VAR_0);\n\n\tset_exception_intercept(VAR_0, VAR_10);\n\tset_exception_intercept(VAR_0, VAR_11);\n\tset_exception_intercept(VAR_0, VAR_12);\n\tset_exception_intercept(VAR_0, VAR_13);\n\n\tset_intercept(VAR_0, VAR_14);\n\tset_intercept(VAR_0, VAR_15);\n\tset_intercept(VAR_0, VAR_16);\n\tset_intercept(VAR_0, VAR_17);\n\tset_intercept(VAR_0, VAR_18);\n\tset_intercept(VAR_0, VAR_19);\n\tset_intercept(VAR_0, VAR_20);\n\tset_intercept(VAR_0, VAR_21);\n\tset_intercept(VAR_0, VAR_22);\n\tset_intercept(VAR_0, VAR_23);\n\tset_intercept(VAR_0, VAR_24);\n\tset_intercept(VAR_0, VAR_25);\n\tset_intercept(VAR_0, VAR_26);\n\tset_intercept(VAR_0, VAR_27);\n\tset_intercept(VAR_0, VAR_28);\n\tset_intercept(VAR_0, VAR_29);\n\tset_intercept(VAR_0, VAR_30);\n\tset_intercept(VAR_0, VAR_31);\n\tset_intercept(VAR_0, VAR_32);\n\tset_intercept(VAR_0, VAR_33);\n\tset_intercept(VAR_0, VAR_34);\n\tset_intercept(VAR_0, VAR_35);\n\tset_intercept(VAR_0, VAR_36);\n\tset_intercept(VAR_0, VAR_37);\n\tset_intercept(VAR_0, VAR_38);\n\n\tVAR_1->iopm_base_pa = VAR_39;\n\tVAR_1->msrpm_base_pa = __pa(VAR_0->msrpm);\n\tVAR_1->int_ctl = VAR_40;\n\n\tinit_seg(&VAR_2->es);\n\tinit_seg(&VAR_2->ss);\n\tinit_seg(&VAR_2->ds);\n\tinit_seg(&VAR_2->fs);\n\tinit_seg(&VAR_2->gs);\n\n\tVAR_2->cs.selector = 0xf000;\n\tVAR_2->cs.base = 0xffff0000;\n\t/* COMMENT_0 */\n\tVAR_2->cs.attrib = VAR_41 | VAR_42 |\n\t\tVAR_43 | VAR_44;\n\tVAR_2->cs.limit = 0xffff;\n\n\tVAR_2->gdtr.limit = 0xffff;\n\tVAR_2->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&VAR_2->ldtr, VAR_45);\n\tinit_sys_seg(&VAR_2->tr, VAR_46);\n\n\tsvm_set_efer(&VAR_0->vcpu, 0);\n\tVAR_2->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&VAR_0->vcpu, 2);\n\tVAR_2->rip = 0x0000fff0;\n\tVAR_0->vcpu.arch.regs[VAR_47] = VAR_2->rip;\n\n\t/* COMMENT_1 */\n                                                                   \n                                                \n    \n\tsvm_set_cr0(&VAR_0->vcpu, VAR_48 | VAR_49 | VAR_50);\n\tkvm_mmu_reset_context(&VAR_0->vcpu);\n\n\tVAR_2->cr4 = VAR_51;\n\t/* COMMENT_5 */\n\n\tif (VAR_52) {\n\t\t/* COMMENT_6 */\n\t\tVAR_1->nested_ctl = 1;\n\t\tclr_intercept(VAR_0, VAR_22);\n\t\tclr_exception_intercept(VAR_0, VAR_10);\n\t\tclr_cr_intercept(VAR_0, VAR_4);\n\t\tclr_cr_intercept(VAR_0, VAR_7);\n\t\tVAR_2->g_pat = VAR_0->vcpu.arch.pat;\n\t\tVAR_2->cr3 = 0;\n\t\tVAR_2->cr4 = 0;\n\t}\n\tVAR_0->asid_generation = 0;\n\n\tVAR_0->nested.vmcb = 0;\n\tVAR_0->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(VAR_53)) {\n\t\tVAR_1->pause_filter_count = 3000;\n\t\tset_intercept(VAR_0, VAR_54);\n\t}\n\n\tmark_all_dirty(VAR_0->vmcb);\n\n\tenable_gif(VAR_0);\n}",
    "func_graph_path_before": "torvalds/linux/cbdb967af3d54993f5814f1cee0ed311a055377d/svm.c/vul/before/2.json",
    "func": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.fpu_active = 1;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_HLT);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_MONITOR);\n\tset_intercept(svm, INTERCEPT_MWAIT);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\n\tcontrol->iopm_base_pa = iopm_base;\n\tcontrol->msrpm_base_pa = __pa(svm->msrpm);\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl = 1;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tcontrol->pause_filter_count = 3000;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n}",
    "abstract_func": "static void init_vmcb(struct vcpu_svm *VAR_0)\n{\n\tstruct vmcb_control_area *VAR_1 = &VAR_0->vmcb->control;\n\tstruct vmcb_save_area *VAR_2 = &VAR_0->vmcb->save;\n\n\tVAR_0->vcpu.fpu_active = 1;\n\tVAR_0->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(VAR_0, VAR_3);\n\tset_cr_intercept(VAR_0, VAR_4);\n\tset_cr_intercept(VAR_0, VAR_5);\n\tset_cr_intercept(VAR_0, VAR_6);\n\tset_cr_intercept(VAR_0, VAR_7);\n\tset_cr_intercept(VAR_0, VAR_8);\n\tset_cr_intercept(VAR_0, VAR_9);\n\n\tset_dr_intercepts(VAR_0);\n\n\tset_exception_intercept(VAR_0, VAR_10);\n\tset_exception_intercept(VAR_0, VAR_11);\n\tset_exception_intercept(VAR_0, VAR_12);\n\tset_exception_intercept(VAR_0, VAR_13);\n\tset_exception_intercept(VAR_0, VAR_14);\n\n\tset_intercept(VAR_0, VAR_15);\n\tset_intercept(VAR_0, VAR_16);\n\tset_intercept(VAR_0, VAR_17);\n\tset_intercept(VAR_0, VAR_18);\n\tset_intercept(VAR_0, VAR_19);\n\tset_intercept(VAR_0, VAR_20);\n\tset_intercept(VAR_0, VAR_21);\n\tset_intercept(VAR_0, VAR_22);\n\tset_intercept(VAR_0, VAR_23);\n\tset_intercept(VAR_0, VAR_24);\n\tset_intercept(VAR_0, VAR_25);\n\tset_intercept(VAR_0, VAR_26);\n\tset_intercept(VAR_0, VAR_27);\n\tset_intercept(VAR_0, VAR_28);\n\tset_intercept(VAR_0, VAR_29);\n\tset_intercept(VAR_0, VAR_30);\n\tset_intercept(VAR_0, VAR_31);\n\tset_intercept(VAR_0, VAR_32);\n\tset_intercept(VAR_0, VAR_33);\n\tset_intercept(VAR_0, VAR_34);\n\tset_intercept(VAR_0, VAR_35);\n\tset_intercept(VAR_0, VAR_36);\n\tset_intercept(VAR_0, VAR_37);\n\tset_intercept(VAR_0, VAR_38);\n\tset_intercept(VAR_0, VAR_39);\n\n\tVAR_1->iopm_base_pa = VAR_40;\n\tVAR_1->msrpm_base_pa = __pa(VAR_0->msrpm);\n\tVAR_1->int_ctl = VAR_41;\n\n\tinit_seg(&VAR_2->es);\n\tinit_seg(&VAR_2->ss);\n\tinit_seg(&VAR_2->ds);\n\tinit_seg(&VAR_2->fs);\n\tinit_seg(&VAR_2->gs);\n\n\tVAR_2->cs.selector = 0xf000;\n\tVAR_2->cs.base = 0xffff0000;\n\t/* COMMENT_0 */\n\tVAR_2->cs.attrib = VAR_42 | VAR_43 |\n\t\tVAR_44 | VAR_45;\n\tVAR_2->cs.limit = 0xffff;\n\n\tVAR_2->gdtr.limit = 0xffff;\n\tVAR_2->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&VAR_2->ldtr, VAR_46);\n\tinit_sys_seg(&VAR_2->tr, VAR_47);\n\n\tsvm_set_efer(&VAR_0->vcpu, 0);\n\tVAR_2->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&VAR_0->vcpu, 2);\n\tVAR_2->rip = 0x0000fff0;\n\tVAR_0->vcpu.arch.regs[VAR_48] = VAR_2->rip;\n\n\t/* COMMENT_1 */\n                                                                   \n                                                \n    \n\tsvm_set_cr0(&VAR_0->vcpu, VAR_49 | VAR_50 | VAR_51);\n\tkvm_mmu_reset_context(&VAR_0->vcpu);\n\n\tVAR_2->cr4 = VAR_52;\n\t/* COMMENT_5 */\n\n\tif (VAR_53) {\n\t\t/* COMMENT_6 */\n\t\tVAR_1->nested_ctl = 1;\n\t\tclr_intercept(VAR_0, VAR_23);\n\t\tclr_exception_intercept(VAR_0, VAR_10);\n\t\tclr_cr_intercept(VAR_0, VAR_4);\n\t\tclr_cr_intercept(VAR_0, VAR_7);\n\t\tVAR_2->g_pat = VAR_0->vcpu.arch.pat;\n\t\tVAR_2->cr3 = 0;\n\t\tVAR_2->cr4 = 0;\n\t}\n\tVAR_0->asid_generation = 0;\n\n\tVAR_0->nested.vmcb = 0;\n\tVAR_0->vcpu.arch.hflags = 0;\n\n\tif (boot_cpu_has(VAR_54)) {\n\t\tVAR_1->pause_filter_count = 3000;\n\t\tset_intercept(VAR_0, VAR_55);\n\t}\n\n\tmark_all_dirty(VAR_0->vmcb);\n\n\tenable_gif(VAR_0);\n}",
    "func_graph_path": "torvalds/linux/cbdb967af3d54993f5814f1cee0ed311a055377d/svm.c/vul/after/2.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,7 @@\n \tset_exception_intercept(svm, UD_VECTOR);\n \tset_exception_intercept(svm, MC_VECTOR);\n \tset_exception_intercept(svm, AC_VECTOR);\n+\tset_exception_intercept(svm, DB_VECTOR);\n \n \tset_intercept(svm, INTERCEPT_INTR);\n \tset_intercept(svm, INTERCEPT_NMI);",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\tset_exception_intercept(svm, DB_VECTOR);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}