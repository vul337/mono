{
    "cve_id": "CVE-2012-6547",
    "cwe_ids": [
        "CWE-200"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "net/tun: fix ioctl() based info leaks\n\nThe tun module leaks up to 36 bytes of memory by not fully initializing\na structure located on the stack that gets copied to user memory by the\nTUNGETIFF and SIOCGIFHWADDR ioctl()s.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "commit_hash": "a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc",
    "git_url": "https://github.com/torvalds/linux/commit/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc",
    "file_path": "drivers/net/tun.c",
    "func_name": "__tun_chr_ioctl",
    "func_before": "static long __tun_chr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg, int ifreq_len)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n\n\trtnl_lock();\n\n\ttun = __tun_get(tfile);\n\tif (cmd == TUNSETIFF && !tun) {\n\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\n\t\tret = tun_set_iff(tfile->net, file, &ifr);\n\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tret = -EBADFD;\n\tif (!tun)\n\t\tgoto unlock;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_ioctl cmd %d\\n\", cmd);\n\n\tret = 0;\n\tswitch (cmd) {\n\tcase TUNGETIFF:\n\t\tret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETNOCSUM:\n\t\t/* Disable/Enable checksum */\n\n\t\t/* [unimplemented] */\n\t\ttun_debug(KERN_INFO, tun, \"ignored: set checksum %s\\n\",\n\t\t\t  arg ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase TUNSETPERSIST:\n\t\t/* Disable/Enable persist mode */\n\t\tif (arg)\n\t\t\ttun->flags |= TUN_PERSIST;\n\t\telse\n\t\t\ttun->flags &= ~TUN_PERSIST;\n\n\t\ttun_debug(KERN_INFO, tun, \"persist %s\\n\",\n\t\t\t  arg ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase TUNSETOWNER:\n\t\t/* Set owner of the device */\n\t\ttun->owner = (uid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"owner set to %d\\n\", tun->owner);\n\t\tbreak;\n\n\tcase TUNSETGROUP:\n\t\t/* Set group of the device */\n\t\ttun->group= (gid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"group set to %d\\n\", tun->group);\n\t\tbreak;\n\n\tcase TUNSETLINK:\n\t\t/* Only allow setting the type when the interface is down */\n\t\tif (tun->dev->flags & IFF_UP) {\n\t\t\ttun_debug(KERN_INFO, tun,\n\t\t\t\t  \"Linktype set failed because interface is up\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\ttun->dev->type = (int) arg;\n\t\t\ttun_debug(KERN_INFO, tun, \"linktype set to %d\\n\",\n\t\t\t\t  tun->dev->type);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n#ifdef TUN_DEBUG\n\tcase TUNSETDEBUG:\n\t\ttun->debug = arg;\n\t\tbreak;\n#endif\n\tcase TUNSETOFFLOAD:\n\t\tret = set_offload(tun, arg);\n\t\tbreak;\n\n\tcase TUNSETTXFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = update_filter(&tun->txflt, (void __user *)arg);\n\t\tbreak;\n\n\tcase SIOCGIFHWADDR:\n\t\t/* Get hw address */\n\t\tmemcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);\n\t\tifr.ifr_hwaddr.sa_family = tun->dev->type;\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR:\n\t\t/* Set hw address */\n\t\ttun_debug(KERN_DEBUG, tun, \"set hw address: %pM\\n\",\n\t\t\t  ifr.ifr_hwaddr.sa_data);\n\n\t\tret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);\n\t\tbreak;\n\n\tcase TUNGETSNDBUF:\n\t\tsndbuf = tun->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETSNDBUF:\n\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->socket.sk->sk_sndbuf = sndbuf;\n\t\tbreak;\n\n\tcase TUNGETVNETHDRSZ:\n\t\tvnet_hdr_sz = tun->vnet_hdr_sz;\n\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETVNETHDRSZ:\n\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->vnet_hdr_sz = vnet_hdr_sz;\n\t\tbreak;\n\n\tcase TUNATTACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&fprog, argp, sizeof(fprog)))\n\t\t\tbreak;\n\n\t\tret = sk_attach_filter(&fprog, tun->socket.sk);\n\t\tbreak;\n\n\tcase TUNDETACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = sk_detach_filter(tun->socket.sk);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\trtnl_unlock();\n\tif (tun)\n\t\ttun_put(tun);\n\treturn ret;\n}",
    "abstract_func_before": "static long __tun_chr_ioctl(struct file *file, unsigned int VAR_0,\n\t\t\t    unsigned long VAR_1, int VAR_2)\n{\n\tstruct tun_file *VAR_3 = file->private_data;\n\tstruct tun_struct *VAR_4;\n\tvoid __user* VAR_5 = (void __user*)VAR_1;\n\tstruct sock_fprog VAR_6;\n\tstruct ifreq VAR_7;\n\tint VAR_8;\n\tint VAR_9;\n\tint VAR_10;\n\n\tif (VAR_0 == VAR_11 || _IOC_TYPE(VAR_0) == 0x89)\n\t\tif (copy_from_user(&VAR_7, VAR_5, VAR_2))\n\t\t\treturn -VAR_12;\n\n\tif (VAR_0 == VAR_13) {\n\t\t/* COMMENT_0 */\n                                                                 \n                  \n\t\treturn put_user(VAR_14 | VAR_15 | VAR_16 | VAR_17 |\n\t\t\t\tVAR_18,\n\t\t\t\t(unsigned int __user*)VAR_5);\n\t}\n\n\trtnl_lock();\n\n\tVAR_4 = __tun_get(VAR_3);\n\tif (VAR_0 == VAR_11 && !VAR_4) {\n\t\tVAR_7.ifr_name[VAR_19-1] = '\\0';\n\n\t\tVAR_10 = tun_set_iff(VAR_3->net, file, &VAR_7);\n\n\t\tif (VAR_10)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(VAR_5, &VAR_7, VAR_2))\n\t\t\tVAR_10 = -VAR_12;\n\t\tgoto unlock;\n\t}\n\n\tVAR_10 = -VAR_20;\n\tif (!VAR_4)\n\t\tgoto unlock;\n\n\ttun_debug(VAR_21, VAR_4, \"tun_chr_ioctl cmd %d\\n\", VAR_0);\n\n\tVAR_10 = 0;\n\tswitch (VAR_0) {\n\tcase VAR_22:\n\t\tVAR_10 = tun_get_iff(VAR_23->nsproxy->net_ns, VAR_4, &VAR_7);\n\t\tif (VAR_10)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(VAR_5, &VAR_7, VAR_2))\n\t\t\tVAR_10 = -VAR_12;\n\t\tbreak;\n\n\tcase VAR_24:\n\t\t/* COMMENT_3 */\n\n\t\t/* COMMENT_4 */\n\t\ttun_debug(VAR_21, VAR_4, \"ignored: set checksum %s\\n\",\n\t\t\t  VAR_1 ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase VAR_25:\n\t\t/* COMMENT_5 */\n\t\tif (VAR_1)\n\t\t\tVAR_4->flags |= VAR_26;\n\t\telse\n\t\t\tVAR_4->flags &= ~VAR_26;\n\n\t\ttun_debug(VAR_21, VAR_4, \"persist %s\\n\",\n\t\t\t  VAR_1 ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase VAR_27:\n\t\t/* COMMENT_6 */\n\t\tVAR_4->owner = (uid_t) VAR_1;\n\n\t\ttun_debug(VAR_21, VAR_4, \"owner set to %d\\n\", VAR_4->owner);\n\t\tbreak;\n\n\tcase VAR_28:\n\t\t/* COMMENT_7 */\n\t\tVAR_4->group= (gid_t) VAR_1;\n\n\t\ttun_debug(VAR_21, VAR_4, \"group set to %d\\n\", VAR_4->group);\n\t\tbreak;\n\n\tcase VAR_29:\n\t\t/* COMMENT_8 */\n\t\tif (VAR_4->dev->flags & VAR_30) {\n\t\t\ttun_debug(VAR_21, VAR_4,\n\t\t\t\t  \"Linktype set failed because interface is up\\n\");\n\t\t\tVAR_10 = -VAR_31;\n\t\t} else {\n\t\t\tVAR_4->dev->type = (int) VAR_1;\n\t\t\ttun_debug(VAR_21, VAR_4, \"linktype set to %d\\n\",\n\t\t\t\t  VAR_4->dev->type);\n\t\t\tVAR_10 = 0;\n\t\t}\n\t\tbreak;\n\n#ifdef VAR_32\n\tcase VAR_33:\n\t\tVAR_4->debug = VAR_1;\n\t\tbreak;\n#endif\n\tcase VAR_34:\n\t\tVAR_10 = set_offload(VAR_4, VAR_1);\n\t\tbreak;\n\n\tcase VAR_35:\n\t\t/* COMMENT_9 */\n\t\tVAR_10 = -VAR_36;\n\t\tif ((VAR_4->flags & VAR_37) != VAR_38)\n\t\t\tbreak;\n\t\tVAR_10 = update_filter(&VAR_4->txflt, (void __user *)VAR_1);\n\t\tbreak;\n\n\tcase VAR_39:\n\t\t/* COMMENT_10 */\n\t\tmemcpy(VAR_7.ifr_hwaddr.sa_data, VAR_4->dev->dev_addr, VAR_40);\n\t\tVAR_7.ifr_hwaddr.sa_family = VAR_4->dev->type;\n\t\tif (copy_to_user(VAR_5, &VAR_7, VAR_2))\n\t\t\tVAR_10 = -VAR_12;\n\t\tbreak;\n\n\tcase VAR_41:\n\t\t/* COMMENT_11 */\n\t\ttun_debug(VAR_42, VAR_4, \"set hw address: %pM\\n\",\n\t\t\t  VAR_7.ifr_hwaddr.sa_data);\n\n\t\tVAR_10 = dev_set_mac_address(VAR_4->dev, &VAR_7.ifr_hwaddr);\n\t\tbreak;\n\n\tcase VAR_43:\n\t\tVAR_8 = VAR_4->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(VAR_5, &VAR_8, sizeof(VAR_8)))\n\t\t\tVAR_10 = -VAR_12;\n\t\tbreak;\n\n\tcase VAR_44:\n\t\tif (copy_from_user(&VAR_8, VAR_5, sizeof(VAR_8))) {\n\t\t\tVAR_10 = -VAR_12;\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_4->socket.sk->sk_sndbuf = VAR_8;\n\t\tbreak;\n\n\tcase VAR_45:\n\t\tVAR_9 = VAR_4->vnet_hdr_sz;\n\t\tif (copy_to_user(VAR_5, &VAR_9, sizeof(VAR_9)))\n\t\t\tVAR_10 = -VAR_12;\n\t\tbreak;\n\n\tcase VAR_46:\n\t\tif (copy_from_user(&VAR_9, VAR_5, sizeof(VAR_9))) {\n\t\t\tVAR_10 = -VAR_12;\n\t\t\tbreak;\n\t\t}\n\t\tif (VAR_9 < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tVAR_10 = -VAR_36;\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_4->vnet_hdr_sz = VAR_9;\n\t\tbreak;\n\n\tcase VAR_47:\n\t\t/* COMMENT_9 */\n\t\tVAR_10 = -VAR_36;\n\t\tif ((VAR_4->flags & VAR_37) != VAR_38)\n\t\t\tbreak;\n\t\tVAR_10 = -VAR_12;\n\t\tif (copy_from_user(&VAR_6, VAR_5, sizeof(VAR_6)))\n\t\t\tbreak;\n\n\t\tVAR_10 = sk_attach_filter(&VAR_6, VAR_4->socket.sk);\n\t\tbreak;\n\n\tcase VAR_48:\n\t\t/* COMMENT_9 */\n\t\tVAR_10 = -VAR_36;\n\t\tif ((VAR_4->flags & VAR_37) != VAR_38)\n\t\t\tbreak;\n\t\tVAR_10 = sk_detach_filter(VAR_4->socket.sk);\n\t\tbreak;\n\n\tdefault:\n\t\tVAR_10 = -VAR_36;\n\t\tbreak;\n\t}\n\nunlock:\n\trtnl_unlock();\n\tif (VAR_4)\n\t\ttun_put(VAR_4);\n\treturn VAR_10;\n}",
    "func_graph_path_before": "torvalds/linux/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc/tun.c/vul/before/0.json",
    "func": "static long __tun_chr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg, int ifreq_len)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n\n\trtnl_lock();\n\n\ttun = __tun_get(tfile);\n\tif (cmd == TUNSETIFF && !tun) {\n\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\n\t\tret = tun_set_iff(tfile->net, file, &ifr);\n\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tret = -EBADFD;\n\tif (!tun)\n\t\tgoto unlock;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_ioctl cmd %d\\n\", cmd);\n\n\tret = 0;\n\tswitch (cmd) {\n\tcase TUNGETIFF:\n\t\tret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETNOCSUM:\n\t\t/* Disable/Enable checksum */\n\n\t\t/* [unimplemented] */\n\t\ttun_debug(KERN_INFO, tun, \"ignored: set checksum %s\\n\",\n\t\t\t  arg ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase TUNSETPERSIST:\n\t\t/* Disable/Enable persist mode */\n\t\tif (arg)\n\t\t\ttun->flags |= TUN_PERSIST;\n\t\telse\n\t\t\ttun->flags &= ~TUN_PERSIST;\n\n\t\ttun_debug(KERN_INFO, tun, \"persist %s\\n\",\n\t\t\t  arg ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase TUNSETOWNER:\n\t\t/* Set owner of the device */\n\t\ttun->owner = (uid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"owner set to %d\\n\", tun->owner);\n\t\tbreak;\n\n\tcase TUNSETGROUP:\n\t\t/* Set group of the device */\n\t\ttun->group= (gid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"group set to %d\\n\", tun->group);\n\t\tbreak;\n\n\tcase TUNSETLINK:\n\t\t/* Only allow setting the type when the interface is down */\n\t\tif (tun->dev->flags & IFF_UP) {\n\t\t\ttun_debug(KERN_INFO, tun,\n\t\t\t\t  \"Linktype set failed because interface is up\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\ttun->dev->type = (int) arg;\n\t\t\ttun_debug(KERN_INFO, tun, \"linktype set to %d\\n\",\n\t\t\t\t  tun->dev->type);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n#ifdef TUN_DEBUG\n\tcase TUNSETDEBUG:\n\t\ttun->debug = arg;\n\t\tbreak;\n#endif\n\tcase TUNSETOFFLOAD:\n\t\tret = set_offload(tun, arg);\n\t\tbreak;\n\n\tcase TUNSETTXFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = update_filter(&tun->txflt, (void __user *)arg);\n\t\tbreak;\n\n\tcase SIOCGIFHWADDR:\n\t\t/* Get hw address */\n\t\tmemcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);\n\t\tifr.ifr_hwaddr.sa_family = tun->dev->type;\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR:\n\t\t/* Set hw address */\n\t\ttun_debug(KERN_DEBUG, tun, \"set hw address: %pM\\n\",\n\t\t\t  ifr.ifr_hwaddr.sa_data);\n\n\t\tret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);\n\t\tbreak;\n\n\tcase TUNGETSNDBUF:\n\t\tsndbuf = tun->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETSNDBUF:\n\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->socket.sk->sk_sndbuf = sndbuf;\n\t\tbreak;\n\n\tcase TUNGETVNETHDRSZ:\n\t\tvnet_hdr_sz = tun->vnet_hdr_sz;\n\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETVNETHDRSZ:\n\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->vnet_hdr_sz = vnet_hdr_sz;\n\t\tbreak;\n\n\tcase TUNATTACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&fprog, argp, sizeof(fprog)))\n\t\t\tbreak;\n\n\t\tret = sk_attach_filter(&fprog, tun->socket.sk);\n\t\tbreak;\n\n\tcase TUNDETACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = sk_detach_filter(tun->socket.sk);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\trtnl_unlock();\n\tif (tun)\n\t\ttun_put(tun);\n\treturn ret;\n}",
    "abstract_func": "static long __tun_chr_ioctl(struct file *file, unsigned int VAR_0,\n\t\t\t    unsigned long VAR_1, int VAR_2)\n{\n\tstruct tun_file *VAR_3 = file->private_data;\n\tstruct tun_struct *VAR_4;\n\tvoid __user* VAR_5 = (void __user*)VAR_1;\n\tstruct sock_fprog VAR_6;\n\tstruct ifreq VAR_7;\n\tint VAR_8;\n\tint VAR_9;\n\tint VAR_10;\n\n\tif (VAR_0 == VAR_11 || _IOC_TYPE(VAR_0) == 0x89) {\n\t\tif (copy_from_user(&VAR_7, VAR_5, VAR_2))\n\t\t\treturn -VAR_12;\n\t} else\n\t\tmemset(&VAR_7, 0, sizeof(VAR_7));\n\n\tif (VAR_0 == VAR_13) {\n\t\t/* COMMENT_0 */\n                                                                 \n                  \n\t\treturn put_user(VAR_14 | VAR_15 | VAR_16 | VAR_17 |\n\t\t\t\tVAR_18,\n\t\t\t\t(unsigned int __user*)VAR_5);\n\t}\n\n\trtnl_lock();\n\n\tVAR_4 = __tun_get(VAR_3);\n\tif (VAR_0 == VAR_11 && !VAR_4) {\n\t\tVAR_7.ifr_name[VAR_19-1] = '\\0';\n\n\t\tVAR_10 = tun_set_iff(VAR_3->net, file, &VAR_7);\n\n\t\tif (VAR_10)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(VAR_5, &VAR_7, VAR_2))\n\t\t\tVAR_10 = -VAR_12;\n\t\tgoto unlock;\n\t}\n\n\tVAR_10 = -VAR_20;\n\tif (!VAR_4)\n\t\tgoto unlock;\n\n\ttun_debug(VAR_21, VAR_4, \"tun_chr_ioctl cmd %d\\n\", VAR_0);\n\n\tVAR_10 = 0;\n\tswitch (VAR_0) {\n\tcase VAR_22:\n\t\tVAR_10 = tun_get_iff(VAR_23->nsproxy->net_ns, VAR_4, &VAR_7);\n\t\tif (VAR_10)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(VAR_5, &VAR_7, VAR_2))\n\t\t\tVAR_10 = -VAR_12;\n\t\tbreak;\n\n\tcase VAR_24:\n\t\t/* COMMENT_3 */\n\n\t\t/* COMMENT_4 */\n\t\ttun_debug(VAR_21, VAR_4, \"ignored: set checksum %s\\n\",\n\t\t\t  VAR_1 ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase VAR_25:\n\t\t/* COMMENT_5 */\n\t\tif (VAR_1)\n\t\t\tVAR_4->flags |= VAR_26;\n\t\telse\n\t\t\tVAR_4->flags &= ~VAR_26;\n\n\t\ttun_debug(VAR_21, VAR_4, \"persist %s\\n\",\n\t\t\t  VAR_1 ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase VAR_27:\n\t\t/* COMMENT_6 */\n\t\tVAR_4->owner = (uid_t) VAR_1;\n\n\t\ttun_debug(VAR_21, VAR_4, \"owner set to %d\\n\", VAR_4->owner);\n\t\tbreak;\n\n\tcase VAR_28:\n\t\t/* COMMENT_7 */\n\t\tVAR_4->group= (gid_t) VAR_1;\n\n\t\ttun_debug(VAR_21, VAR_4, \"group set to %d\\n\", VAR_4->group);\n\t\tbreak;\n\n\tcase VAR_29:\n\t\t/* COMMENT_8 */\n\t\tif (VAR_4->dev->flags & VAR_30) {\n\t\t\ttun_debug(VAR_21, VAR_4,\n\t\t\t\t  \"Linktype set failed because interface is up\\n\");\n\t\t\tVAR_10 = -VAR_31;\n\t\t} else {\n\t\t\tVAR_4->dev->type = (int) VAR_1;\n\t\t\ttun_debug(VAR_21, VAR_4, \"linktype set to %d\\n\",\n\t\t\t\t  VAR_4->dev->type);\n\t\t\tVAR_10 = 0;\n\t\t}\n\t\tbreak;\n\n#ifdef VAR_32\n\tcase VAR_33:\n\t\tVAR_4->debug = VAR_1;\n\t\tbreak;\n#endif\n\tcase VAR_34:\n\t\tVAR_10 = set_offload(VAR_4, VAR_1);\n\t\tbreak;\n\n\tcase VAR_35:\n\t\t/* COMMENT_9 */\n\t\tVAR_10 = -VAR_36;\n\t\tif ((VAR_4->flags & VAR_37) != VAR_38)\n\t\t\tbreak;\n\t\tVAR_10 = update_filter(&VAR_4->txflt, (void __user *)VAR_1);\n\t\tbreak;\n\n\tcase VAR_39:\n\t\t/* COMMENT_10 */\n\t\tmemcpy(VAR_7.ifr_hwaddr.sa_data, VAR_4->dev->dev_addr, VAR_40);\n\t\tVAR_7.ifr_hwaddr.sa_family = VAR_4->dev->type;\n\t\tif (copy_to_user(VAR_5, &VAR_7, VAR_2))\n\t\t\tVAR_10 = -VAR_12;\n\t\tbreak;\n\n\tcase VAR_41:\n\t\t/* COMMENT_11 */\n\t\ttun_debug(VAR_42, VAR_4, \"set hw address: %pM\\n\",\n\t\t\t  VAR_7.ifr_hwaddr.sa_data);\n\n\t\tVAR_10 = dev_set_mac_address(VAR_4->dev, &VAR_7.ifr_hwaddr);\n\t\tbreak;\n\n\tcase VAR_43:\n\t\tVAR_8 = VAR_4->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(VAR_5, &VAR_8, sizeof(VAR_8)))\n\t\t\tVAR_10 = -VAR_12;\n\t\tbreak;\n\n\tcase VAR_44:\n\t\tif (copy_from_user(&VAR_8, VAR_5, sizeof(VAR_8))) {\n\t\t\tVAR_10 = -VAR_12;\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_4->socket.sk->sk_sndbuf = VAR_8;\n\t\tbreak;\n\n\tcase VAR_45:\n\t\tVAR_9 = VAR_4->vnet_hdr_sz;\n\t\tif (copy_to_user(VAR_5, &VAR_9, sizeof(VAR_9)))\n\t\t\tVAR_10 = -VAR_12;\n\t\tbreak;\n\n\tcase VAR_46:\n\t\tif (copy_from_user(&VAR_9, VAR_5, sizeof(VAR_9))) {\n\t\t\tVAR_10 = -VAR_12;\n\t\t\tbreak;\n\t\t}\n\t\tif (VAR_9 < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tVAR_10 = -VAR_36;\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_4->vnet_hdr_sz = VAR_9;\n\t\tbreak;\n\n\tcase VAR_47:\n\t\t/* COMMENT_9 */\n\t\tVAR_10 = -VAR_36;\n\t\tif ((VAR_4->flags & VAR_37) != VAR_38)\n\t\t\tbreak;\n\t\tVAR_10 = -VAR_12;\n\t\tif (copy_from_user(&VAR_6, VAR_5, sizeof(VAR_6)))\n\t\t\tbreak;\n\n\t\tVAR_10 = sk_attach_filter(&VAR_6, VAR_4->socket.sk);\n\t\tbreak;\n\n\tcase VAR_48:\n\t\t/* COMMENT_9 */\n\t\tVAR_10 = -VAR_36;\n\t\tif ((VAR_4->flags & VAR_37) != VAR_38)\n\t\t\tbreak;\n\t\tVAR_10 = sk_detach_filter(VAR_4->socket.sk);\n\t\tbreak;\n\n\tdefault:\n\t\tVAR_10 = -VAR_36;\n\t\tbreak;\n\t}\n\nunlock:\n\trtnl_unlock();\n\tif (VAR_4)\n\t\ttun_put(VAR_4);\n\treturn VAR_10;\n}",
    "func_graph_path": "torvalds/linux/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc/tun.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -10,9 +10,11 @@\n \tint vnet_hdr_sz;\n \tint ret;\n \n-\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n+\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {\n \t\tif (copy_from_user(&ifr, argp, ifreq_len))\n \t\t\treturn -EFAULT;\n+\t} else\n+\t\tmemset(&ifr, 0, sizeof(ifr));\n \n \tif (cmd == TUNGETFEATURES) {\n \t\t/* Currently this just means: \"what IFF flags are valid?\".",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)"
        ],
        "added_lines": [
            "\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {",
            "\t} else",
            "\t\tmemset(&ifr, 0, sizeof(ifr));"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}