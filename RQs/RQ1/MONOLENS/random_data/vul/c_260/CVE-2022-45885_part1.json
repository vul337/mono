{
    "cve_id": "CVE-2022-45885",
    "cwe_ids": [
        "CWE-362",
        "CWE-416"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "If the device node of dvb_frontend is open() and the device is\ndisconnected, many kinds of UAFs may occur when calling close()\non the device node.\n\nThe root cause of this is that wake_up() for dvbdev->wait_queue\nis implemented in the dvb_frontend_release() function, but\nwait_event() is not implemented in the dvb_frontend_stop() function.\n\nSo, implement wait_event() function in dvb_frontend_stop() and\nadd 'remove_mutex' which prevents race condition for 'fe->exit'.\n\n[mchehab: fix a couple of checkpatch warnings and some mistakes at the error handling logic]\n\nLink: https://lore.kernel.org/linux-media/20221117045925.14297-2-imv4bel@gmail.com\nSigned-off-by: Hyunwoo Kim <imv4bel@gmail.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>\n",
    "commit_hash": "6769a0b7ee0c3b31e1b22c3fadff2bfb642de23f",
    "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=6769a0b7ee0c3b31e1b22c3fadff2bfb642de23f",
    "file_path": "drivers/media/dvb-core/dvb_frontend.c",
    "func_name": "dvb_frontend_stop",
    "func_before": "static void dvb_frontend_stop(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tif (fe->exit != DVB_FE_DEVICE_REMOVED)\n\t\tfe->exit = DVB_FE_NORMAL_EXIT;\n\tmb();\n\n\tif (!fepriv->thread)\n\t\treturn;\n\n\tkthread_stop(fepriv->thread);\n\n\tsema_init(&fepriv->sem, 1);\n\tfepriv->state = FESTATE_IDLE;\n\n\t/* paranoia check in case a signal arrived */\n\tif (fepriv->thread)\n\t\tdev_warn(fe->dvb->device,\n\t\t\t \"dvb_frontend_stop: warning: thread %p won't exit\\n\",\n\t\t\t fepriv->thread);\n}",
    "abstract_func_before": "static void dvb_frontend_stop(struct dvb_frontend *VAR_0)\n{\n\tstruct dvb_frontend_private *VAR_1 = VAR_0->frontend_priv;\n\n\tdev_dbg(VAR_0->dvb->device, \"%s:\\n\", VAR_2);\n\n\tif (VAR_0->exit != VAR_3)\n\t\tVAR_0->exit = VAR_4;\n\tmb();\n\n\tif (!VAR_1->thread)\n\t\treturn;\n\n\tkthread_stop(VAR_1->thread);\n\n\tsema_init(&VAR_1->sem, 1);\n\tVAR_1->state = VAR_5;\n\n\t/* COMMENT_0 */\n\tif (VAR_1->thread)\n\t\tdev_warn(VAR_0->dvb->device,\n\t\t\t \"dvb_frontend_stop: warning: thread %p won't exit\\n\",\n\t\t\t VAR_1->thread);\n}",
    "func_graph_path_before": "torvalds/linux/6769a0b7ee0c3b31e1b22c3fadff2bfb642de23f/dvb_frontend.c/vul/before/0.json",
    "func": "static void dvb_frontend_stop(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tmutex_lock(&fe->remove_mutex);\n\n\tif (fe->exit != DVB_FE_DEVICE_REMOVED)\n\t\tfe->exit = DVB_FE_NORMAL_EXIT;\n\tmb();\n\n\tif (!fepriv->thread) {\n\t\tmutex_unlock(&fe->remove_mutex);\n\t\treturn;\n\t}\n\n\tkthread_stop(fepriv->thread);\n\n\tmutex_unlock(&fe->remove_mutex);\n\n\tif (fepriv->dvbdev->users < -1) {\n\t\twait_event(fepriv->dvbdev->wait_queue,\n\t\t\t   fepriv->dvbdev->users == -1);\n\t}\n\n\tsema_init(&fepriv->sem, 1);\n\tfepriv->state = FESTATE_IDLE;\n\n\t/* paranoia check in case a signal arrived */\n\tif (fepriv->thread)\n\t\tdev_warn(fe->dvb->device,\n\t\t\t \"dvb_frontend_stop: warning: thread %p won't exit\\n\",\n\t\t\t fepriv->thread);\n}",
    "abstract_func": "static void dvb_frontend_stop(struct dvb_frontend *VAR_0)\n{\n\tstruct dvb_frontend_private *VAR_1 = VAR_0->frontend_priv;\n\n\tdev_dbg(VAR_0->dvb->device, \"%s:\\n\", VAR_2);\n\n\tmutex_lock(&VAR_0->remove_mutex);\n\n\tif (VAR_0->exit != VAR_3)\n\t\tVAR_0->exit = VAR_4;\n\tmb();\n\n\tif (!VAR_1->thread) {\n\t\tmutex_unlock(&VAR_0->remove_mutex);\n\t\treturn;\n\t}\n\n\tkthread_stop(VAR_1->thread);\n\n\tmutex_unlock(&VAR_0->remove_mutex);\n\n\tif (VAR_1->dvbdev->users < -1) {\n\t\twait_event(VAR_1->dvbdev->wait_queue,\n\t\t\t   VAR_1->dvbdev->users == -1);\n\t}\n\n\tsema_init(&VAR_1->sem, 1);\n\tVAR_1->state = VAR_5;\n\n\t/* COMMENT_0 */\n\tif (VAR_1->thread)\n\t\tdev_warn(VAR_0->dvb->device,\n\t\t\t \"dvb_frontend_stop: warning: thread %p won't exit\\n\",\n\t\t\t VAR_1->thread);\n}",
    "func_graph_path": "torvalds/linux/6769a0b7ee0c3b31e1b22c3fadff2bfb642de23f/dvb_frontend.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -4,14 +4,25 @@\n \n \tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n \n+\tmutex_lock(&fe->remove_mutex);\n+\n \tif (fe->exit != DVB_FE_DEVICE_REMOVED)\n \t\tfe->exit = DVB_FE_NORMAL_EXIT;\n \tmb();\n \n-\tif (!fepriv->thread)\n+\tif (!fepriv->thread) {\n+\t\tmutex_unlock(&fe->remove_mutex);\n \t\treturn;\n+\t}\n \n \tkthread_stop(fepriv->thread);\n+\n+\tmutex_unlock(&fe->remove_mutex);\n+\n+\tif (fepriv->dvbdev->users < -1) {\n+\t\twait_event(fepriv->dvbdev->wait_queue,\n+\t\t\t   fepriv->dvbdev->users == -1);\n+\t}\n \n \tsema_init(&fepriv->sem, 1);\n \tfepriv->state = FESTATE_IDLE;",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (!fepriv->thread)"
        ],
        "added_lines": [
            "\tmutex_lock(&fe->remove_mutex);",
            "",
            "\tif (!fepriv->thread) {",
            "\t\tmutex_unlock(&fe->remove_mutex);",
            "\t}",
            "",
            "\tmutex_unlock(&fe->remove_mutex);",
            "",
            "\tif (fepriv->dvbdev->users < -1) {",
            "\t\twait_event(fepriv->dvbdev->wait_queue,",
            "\t\t\t   fepriv->dvbdev->users == -1);",
            "\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}