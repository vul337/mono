{
    "cve_id": "CVE-2017-5953",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "vim",
    "commit_msg": "patch 8.0.0322: possible overflow with corrupted spell file\n\nProblem:    Possible overflow with spell file where the tree length is\n            corrupted.\nSolution:   Check for an invalid length (suggested by shqking)",
    "commit_hash": "399c297aa93afe2c0a39e2a1b3f972aebba44c9d",
    "git_url": "https://github.com/vim/vim/commit/399c297aa93afe2c0a39e2a1b3f972aebba44c9d",
    "file_path": "src/spellfile.c",
    "func_name": "spell_read_tree",
    "func_before": "static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \"prefixtree\" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}",
    "abstract_func_before": "static int\nspell_read_tree(\n    FILE\t*VAR_0,\n    char_u\t**VAR_1,\n    idx_T\t**VAR_2,\n    int\t\tVAR_3,\t/* COMMENT_0 */\n    int\t\tVAR_4)\t/* COMMENT_1 */\n{\n    int\t\tVAR_5;\n    int\t\tVAR_6;\n    char_u\t*VAR_7;\n    idx_T\t*VAR_8;\n\n    /* COMMENT_2 */\n                                                    \n    VAR_5 = get4c(VAR_0);\n    if (VAR_5 < 0)\n\treturn VAR_9;\n    if (VAR_5 > 0)\n    {\n\t/* COMMENT_4 */\n\tVAR_7 = lalloc((long_u)VAR_5, TRUE);\n\tif (VAR_7 == NULL)\n\t    return VAR_10;\n\t*VAR_1 = VAR_7;\n\n\t/* COMMENT_5 */\n\tVAR_8 = (idx_T *)lalloc_clear((long_u)(VAR_5 * sizeof(int)), TRUE);\n\tif (VAR_8 == NULL)\n\t    return VAR_10;\n\t*VAR_2 = VAR_8;\n\n\t/* COMMENT_6 */\n\tVAR_6 = read_tree_node(VAR_0, VAR_7, VAR_8, VAR_5, 0, VAR_3, VAR_4);\n\tif (VAR_6 < 0)\n\t    return VAR_6;\n    }\n    return 0;\n}",
    "func_graph_path_before": "vim/399c297aa93afe2c0a39e2a1b3f972aebba44c9d/spellfile.c/vul/before/0.json",
    "func": "static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \"prefixtree\" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len >= 0x3ffffff)\n\t/* Invalid length, multiply with sizeof(int) would overflow. */\n\treturn SP_FORMERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}",
    "abstract_func": "static int\nspell_read_tree(\n    FILE\t*VAR_0,\n    char_u\t**VAR_1,\n    idx_T\t**VAR_2,\n    int\t\tVAR_3,\t/* COMMENT_0 */\n    int\t\tVAR_4)\t/* COMMENT_1 */\n{\n    int\t\tVAR_5;\n    int\t\tVAR_6;\n    char_u\t*VAR_7;\n    idx_T\t*VAR_8;\n\n    /* COMMENT_2 */\n                                                    \n    VAR_5 = get4c(VAR_0);\n    if (VAR_5 < 0)\n\treturn VAR_9;\n    if (VAR_5 >= 0x3ffffff)\n\t/* COMMENT_4 */\n\treturn VAR_10;\n    if (VAR_5 > 0)\n    {\n\t/* COMMENT_5 */\n\tVAR_7 = lalloc((long_u)VAR_5, TRUE);\n\tif (VAR_7 == NULL)\n\t    return VAR_11;\n\t*VAR_1 = VAR_7;\n\n\t/* COMMENT_6 */\n\tVAR_8 = (idx_T *)lalloc_clear((long_u)(VAR_5 * sizeof(int)), TRUE);\n\tif (VAR_8 == NULL)\n\t    return VAR_11;\n\t*VAR_2 = VAR_8;\n\n\t/* COMMENT_7 */\n\tVAR_6 = read_tree_node(VAR_0, VAR_7, VAR_8, VAR_5, 0, VAR_3, VAR_4);\n\tif (VAR_6 < 0)\n\t    return VAR_6;\n    }\n    return 0;\n}",
    "func_graph_path": "vim/399c297aa93afe2c0a39e2a1b3f972aebba44c9d/spellfile.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,9 @@\n     len = get4c(fd);\n     if (len < 0)\n \treturn SP_TRUNCERROR;\n+    if (len >= 0x3ffffff)\n+\t/* Invalid length, multiply with sizeof(int) would overflow. */\n+\treturn SP_FORMERROR;\n     if (len > 0)\n     {\n \t/* Allocate the byte array. */",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "    if (len >= 0x3ffffff)",
            "\t/* Invalid length, multiply with sizeof(int) would overflow. */",
            "\treturn SP_FORMERROR;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}