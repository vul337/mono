{
    "cve_id": "CVE-2022-21144",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "libxmljs",
    "commit_msg": "Ensure parseXml/parseHtml input is string or buffer (#594)",
    "commit_hash": "2501807bde9b38cfaed06d1e140487516d91379d",
    "git_url": "https://github.com/libxmljs/libxmljs/commit/2501807bde9b38cfaed06d1e140487516d91379d",
    "file_path": "src/xml_document.cc",
    "func_name": "NAN_METHOD",
    "func_before": "NAN_METHOD(XmlDocument::FromHtml)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Object> options = Nan::To<v8::Object>(info[1]).ToLocalChecked();\n    v8::Local<v8::Value>  baseUrlOpt  = Nan::Get(options,\n        Nan::New<v8::String>(\"baseUrl\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value>  encodingOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"encoding\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value> excludeImpliedElementsOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"excludeImpliedElements\").ToLocalChecked()).ToLocalChecked();\n\n    // the base URL that will be used for this HTML parsed document\n    Nan::Utf8String baseUrl_(Nan::To<v8::String>(baseUrlOpt).ToLocalChecked());\n    const char * baseUrl = *baseUrl_;\n    if (!baseUrlOpt->IsString()) {\n        baseUrl = NULL;\n    }\n\n    // the encoding to be used for this document\n    // (leave NULL for libxml to autodetect)\n    Nan::Utf8String encoding_(Nan::To<v8::String>(encodingOpt).ToLocalChecked());\n    const char * encoding = *encoding_;\n\n    if (!encodingOpt->IsString()) {\n        encoding = NULL;\n    }\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void*>(&errors), XmlSyntaxError::PushToArray);\n\n    int opts = (int)getParserOptions(options);\n    if (Nan::To<v8::Boolean>(excludeImpliedElementsOpt).ToLocalChecked()->Value())\n        opts |= HTML_PARSE_NOIMPLIED | HTML_PARSE_NODEFDTD;\n\n    htmlDocPtr doc;\n    if (!node::Buffer::HasInstance(info[0])) {\n        // Parse a string\n        Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());\n        doc = htmlReadMemory(*str, str.length(), baseUrl, encoding, opts);\n    }\n    else {\n        // Parse a buffer\n        v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n        doc = htmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),\n                            baseUrl, encoding, opts);\n    }\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n\n    if (!doc) {\n        xmlError* error = xmlGetLastError();\n        if (error) {\n            return Nan::ThrowError(XmlSyntaxError::BuildSyntaxError(error));\n        }\n        return Nan::ThrowError(\"Could not parse XML string\");\n    }\n\n    v8::Local<v8::Object> doc_handle = XmlDocument::New(doc);\n    Nan::Set(doc_handle, Nan::New<v8::String>(\"errors\").ToLocalChecked(), errors);\n\n    // create the xml document handle to return\n    return info.GetReturnValue().Set(doc_handle);\n}",
    "abstract_func_before": "NAN_METHOD(XmlDocument::FromHtml)\n{\n    Nan::HandleScope VAR_0;\n\n    v8::Local<v8::Object> VAR_1 = Nan::VAR_2<v8::Object>(VAR_3[1]).ToLocalChecked();\n    v8::Local<v8::Value>  VAR_4  = Nan::Get(VAR_1,\n        Nan::VAR_5<v8::String>(\"baseUrl\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value>  VAR_6 = Nan::Get(VAR_1,\n        Nan::VAR_5<v8::String>(\"encoding\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value> VAR_7 = Nan::Get(VAR_1,\n        Nan::VAR_5<v8::String>(\"excludeImpliedElements\").ToLocalChecked()).ToLocalChecked();\n\n    /* COMMENT_0 */\n    Nan::Utf8String VAR_8(Nan::VAR_2<v8::String>(VAR_4).ToLocalChecked());\n    const char * VAR_9 = *VAR_8;\n    if (!VAR_4->IsString()) {\n        VAR_9 = NULL;\n    }\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    Nan::Utf8String VAR_10(Nan::VAR_2<v8::String>(VAR_6).ToLocalChecked());\n    const char * VAR_11 = *VAR_10;\n\n    if (!VAR_6->IsString()) {\n        VAR_11 = NULL;\n    }\n\n    v8::Local<v8::Array> VAR_12 = Nan::VAR_5<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(VAR_13<void*>(&VAR_12), XmlSyntaxError::PushToArray);\n\n    int VAR_14 = (int)getParserOptions(VAR_1);\n    if (Nan::VAR_2<v8::Boolean>(VAR_7).ToLocalChecked()->Value())\n        VAR_14 |= VAR_15 | VAR_16;\n\n    htmlDocPtr VAR_17;\n    if (!node::Buffer::HasInstance(VAR_3[0])) {\n        /* COMMENT_3 */\n        Nan::Utf8String VAR_18(Nan::VAR_2<v8::String>(VAR_3[0]).ToLocalChecked());\n        VAR_17 = htmlReadMemory(*VAR_18, VAR_18.length(), VAR_9, VAR_11, VAR_14);\n    }\n    else {\n        /* COMMENT_4 */\n        v8::Local<v8::Object> VAR_19 = Nan::VAR_2<v8::Object>(VAR_3[0]).ToLocalChecked();\n        VAR_17 = htmlReadMemory(node::Buffer::Data(VAR_19), node::Buffer::Length(VAR_19),\n                            VAR_9, VAR_11, VAR_14);\n    }\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n\n    if (!VAR_17) {\n        xmlError* VAR_20 = xmlGetLastError();\n        if (VAR_20) {\n            return Nan::ThrowError(XmlSyntaxError::BuildSyntaxError(VAR_20));\n        }\n        return Nan::ThrowError(\"Could not parse XML string\");\n    }\n\n    v8::Local<v8::Object> VAR_21 = XmlDocument::New(VAR_17);\n    Nan::Set(VAR_21, Nan::VAR_5<v8::String>(\"errors\").ToLocalChecked(), VAR_12);\n\n    /* COMMENT_5 */\n    return VAR_3.GetReturnValue().Set(VAR_21);\n}",
    "func_graph_path_before": null,
    "func": "NAN_METHOD(XmlDocument::FromHtml)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Object> options = Nan::To<v8::Object>(info[1]).ToLocalChecked();\n    v8::Local<v8::Value>  baseUrlOpt  = Nan::Get(options,\n        Nan::New<v8::String>(\"baseUrl\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value>  encodingOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"encoding\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value> excludeImpliedElementsOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"excludeImpliedElements\").ToLocalChecked()).ToLocalChecked();\n\n    // the base URL that will be used for this HTML parsed document\n    Nan::Utf8String baseUrl_(Nan::To<v8::String>(baseUrlOpt).ToLocalChecked());\n    const char * baseUrl = *baseUrl_;\n    if (!baseUrlOpt->IsString()) {\n        baseUrl = NULL;\n    }\n\n    // the encoding to be used for this document\n    // (leave NULL for libxml to autodetect)\n    Nan::Utf8String encoding_(Nan::To<v8::String>(encodingOpt).ToLocalChecked());\n    const char * encoding = *encoding_;\n\n    if (!encodingOpt->IsString()) {\n        encoding = NULL;\n    }\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void*>(&errors), XmlSyntaxError::PushToArray);\n\n    int opts = (int)getParserOptions(options);\n    if (Nan::To<v8::Boolean>(excludeImpliedElementsOpt).ToLocalChecked()->Value())\n        opts |= HTML_PARSE_NOIMPLIED | HTML_PARSE_NODEFDTD;\n\n    htmlDocPtr doc;\n    if (info[0]->IsString()) {\n        // Parse a string\n        Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());\n        doc = htmlReadMemory(*str, str.length(), baseUrl, encoding, opts);\n    }\n    else if (node::Buffer::HasInstance(info[0])) {\n        // Parse a buffer\n        v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n        doc = htmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),\n                            baseUrl, encoding, opts);\n    } else {\n        return Nan::ThrowError(\"XML must be a string or buffer\");\n    }\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n\n    if (!doc) {\n        xmlError* error = xmlGetLastError();\n        if (error) {\n            return Nan::ThrowError(XmlSyntaxError::BuildSyntaxError(error));\n        }\n        return Nan::ThrowError(\"Could not parse XML string\");\n    }\n\n    v8::Local<v8::Object> doc_handle = XmlDocument::New(doc);\n    Nan::Set(doc_handle, Nan::New<v8::String>(\"errors\").ToLocalChecked(), errors);\n\n    // create the xml document handle to return\n    return info.GetReturnValue().Set(doc_handle);\n}",
    "abstract_func": "NAN_METHOD(XmlDocument::FromHtml)\n{\n    Nan::HandleScope VAR_0;\n\n    v8::Local<v8::Object> VAR_1 = Nan::VAR_2<v8::Object>(VAR_3[1]).ToLocalChecked();\n    v8::Local<v8::Value>  VAR_4  = Nan::Get(VAR_1,\n        Nan::VAR_5<v8::String>(\"baseUrl\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value>  VAR_6 = Nan::Get(VAR_1,\n        Nan::VAR_5<v8::String>(\"encoding\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value> VAR_7 = Nan::Get(VAR_1,\n        Nan::VAR_5<v8::String>(\"excludeImpliedElements\").ToLocalChecked()).ToLocalChecked();\n\n    /* COMMENT_0 */\n    Nan::Utf8String VAR_8(Nan::VAR_2<v8::String>(VAR_4).ToLocalChecked());\n    const char * VAR_9 = *VAR_8;\n    if (!VAR_4->IsString()) {\n        VAR_9 = NULL;\n    }\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    Nan::Utf8String VAR_10(Nan::VAR_2<v8::String>(VAR_6).ToLocalChecked());\n    const char * VAR_11 = *VAR_10;\n\n    if (!VAR_6->IsString()) {\n        VAR_11 = NULL;\n    }\n\n    v8::Local<v8::Array> VAR_12 = Nan::VAR_5<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(VAR_13<void*>(&VAR_12), XmlSyntaxError::PushToArray);\n\n    int VAR_14 = (int)getParserOptions(VAR_1);\n    if (Nan::VAR_2<v8::Boolean>(VAR_7).ToLocalChecked()->Value())\n        VAR_14 |= VAR_15 | VAR_16;\n\n    htmlDocPtr VAR_17;\n    if (VAR_3[0]->IsString()) {\n        /* COMMENT_3 */\n        Nan::Utf8String VAR_18(Nan::VAR_2<v8::String>(VAR_3[0]).ToLocalChecked());\n        VAR_17 = htmlReadMemory(*VAR_18, VAR_18.length(), VAR_9, VAR_11, VAR_14);\n    }\n    else if (node::Buffer::HasInstance(VAR_3[0])) {\n        /* COMMENT_4 */\n        v8::Local<v8::Object> VAR_19 = Nan::VAR_2<v8::Object>(VAR_3[0]).ToLocalChecked();\n        VAR_17 = htmlReadMemory(node::Buffer::Data(VAR_19), node::Buffer::Length(VAR_19),\n                            VAR_9, VAR_11, VAR_14);\n    } else {\n        return Nan::ThrowError(\"XML must be a string or buffer\");\n    }\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n\n    if (!VAR_17) {\n        xmlError* VAR_20 = xmlGetLastError();\n        if (VAR_20) {\n            return Nan::ThrowError(XmlSyntaxError::BuildSyntaxError(VAR_20));\n        }\n        return Nan::ThrowError(\"Could not parse XML string\");\n    }\n\n    v8::Local<v8::Object> VAR_21 = XmlDocument::New(VAR_17);\n    Nan::Set(VAR_21, Nan::VAR_5<v8::String>(\"errors\").ToLocalChecked(), VAR_12);\n\n    /* COMMENT_5 */\n    return VAR_3.GetReturnValue().Set(VAR_21);\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -35,16 +35,18 @@\n         opts |= HTML_PARSE_NOIMPLIED | HTML_PARSE_NODEFDTD;\n \n     htmlDocPtr doc;\n-    if (!node::Buffer::HasInstance(info[0])) {\n+    if (info[0]->IsString()) {\n         // Parse a string\n         Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());\n         doc = htmlReadMemory(*str, str.length(), baseUrl, encoding, opts);\n     }\n-    else {\n+    else if (node::Buffer::HasInstance(info[0])) {\n         // Parse a buffer\n         v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n         doc = htmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),\n                             baseUrl, encoding, opts);\n+    } else {\n+        return Nan::ThrowError(\"XML must be a string or buffer\");\n     }\n \n     xmlSetStructuredErrorFunc(NULL, NULL);",
    "diff_line_info": {
        "deleted_lines": [
            "    if (!node::Buffer::HasInstance(info[0])) {",
            "    else {"
        ],
        "added_lines": [
            "    if (info[0]->IsString()) {",
            "    else if (node::Buffer::HasInstance(info[0])) {",
            "    } else {",
            "        return Nan::ThrowError(\"XML must be a string or buffer\");"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/libxmljs/libxmljs/pull/594",
    "description": "no more info"
}