{
    "cve_id": "CVE-2013-4348",
    "cwe_ids": [
        "CWE-399"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "kernel/git/netdev/net",
    "commit_msg": "We don't validate iph->ihl which may lead a dead loop if we meet a IPIP\nskb whose iph->ihl is zero. Fix this by failing immediately when iph->ihl\nis evil (less than 5).\n\nThis issue were introduced by commit ec5efe7946280d1e84603389a1030ccec0a767ae\n(rps: support IPIP encapsulation).\n\nCc: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Michael S. Tsirkin <mst@redhat.com>\nCc: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n",
    "commit_hash": "6f092343855a71e03b8d209815d8c45bf3a27fcd",
    "git_url": "https://git.kernel.org/cgit/linux/kernel/git/davem/net.git/commit/?h=6f092343855a71e03b8d209815d8c45bf3a27fcd",
    "file_path": "net/core/flow_dissector.c",
    "func_name": "skb_flow_dissect",
    "func_before": "bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)\n{\n\tint poff, nhoff = skb_network_offset(skb);\n\tu8 ip_proto;\n\t__be16 proto = skb->protocol;\n\n\tmemset(flow, 0, sizeof(*flow));\n\nagain:\n\tswitch (proto) {\n\tcase __constant_htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\n\t\tif (!iph)\n\t\t\treturn false;\n\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\t\telse\n\t\t\tip_proto = iph->protocol;\n\t\tiph_to_flow_copy_addrs(flow, iph);\n\t\tnhoff += iph->ihl * 4;\n\t\tbreak;\n\t}\n\tcase __constant_htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\nipv6:\n\t\tiph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\n\t\tif (!iph)\n\t\t\treturn false;\n\n\t\tip_proto = iph->nexthdr;\n\t\tflow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);\n\t\tflow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);\n\t\tnhoff += sizeof(struct ipv6hdr);\n\t\tbreak;\n\t}\n\tcase __constant_htons(ETH_P_8021AD):\n\tcase __constant_htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = skb_header_pointer(skb, nhoff, sizeof(_vlan), &_vlan);\n\t\tif (!vlan)\n\t\t\treturn false;\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase __constant_htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = skb_header_pointer(skb, nhoff, sizeof(_hdr), &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase __constant_htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase __constant_htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = skb_header_pointer(skb, nhoff, sizeof(_hdr), &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (!(hdr->flags & (GRE_VERSION|GRE_ROUTING))) {\n\t\t\tproto = hdr->proto;\n\t\t\tnhoff += 4;\n\t\t\tif (hdr->flags & GRE_CSUM)\n\t\t\t\tnhoff += 4;\n\t\t\tif (hdr->flags & GRE_KEY)\n\t\t\t\tnhoff += 4;\n\t\t\tif (hdr->flags & GRE_SEQ)\n\t\t\t\tnhoff += 4;\n\t\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\t\tconst struct ethhdr *eth;\n\t\t\t\tstruct ethhdr _eth;\n\n\t\t\t\teth = skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t\t sizeof(_eth), &_eth);\n\t\t\t\tif (!eth)\n\t\t\t\t\treturn false;\n\t\t\t\tproto = eth->h_proto;\n\t\t\t\tnhoff += sizeof(*eth);\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tflow->ip_proto = ip_proto;\n\tpoff = proto_ports_offset(ip_proto);\n\tif (poff >= 0) {\n\t\t__be32 *ports, _ports;\n\n\t\tports = skb_header_pointer(skb, nhoff + poff,\n\t\t\t\t\t   sizeof(_ports), &_ports);\n\t\tif (ports)\n\t\t\tflow->ports = *ports;\n\t}\n\n\tflow->thoff = (u16) nhoff;\n\n\treturn true;\n}",
    "abstract_func_before": "bool skb_flow_dissect(const struct sk_buff *VAR_0, struct flow_keys *VAR_1)\n{\n\tint VAR_2, VAR_3 = skb_network_offset(VAR_0);\n\tu8 VAR_4;\n\t__be16 protoVAR_5 = VAR_0->protocol;\n\n\tmemset(VAR_1, 0, sizeof(*VAR_1));\n\nagain:\n\tswitch (proto) {\n\tcase __constant_htons(VAR_6): {\n\t\tconst struct iphdr *VAR_7;\n\t\tstruct iphdr VAR_8;\nip:\n\t\tVAR_7 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_8), &VAR_8);\n\t\tif (!VAR_7)\n\t\t\treturn false;\n\n\t\tif (ip_is_fragment(VAR_7))\n\t\t\tVAR_4 = 0;\n\t\telse\n\t\t\tVAR_4 = VAR_7->protocol;\n\t\tiph_to_flow_copy_addrs(VAR_1, VAR_7);\n\t\tVAR_3 += VAR_7->ihl * 4;\n\t\tbreak;\n\t}\n\tcase __constant_htons(VAR_9): {\n\t\tconst struct ipv6hdr *VAR_7;\n\t\tstruct ipv6hdr VAR_8;\nipv6:\n\t\tVAR_7 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_8), &VAR_8);\n\t\tif (!VAR_7)\n\t\t\treturn false;\n\n\t\tVAR_4 = VAR_7->nexthdr;\n\t\tVAR_1->src = (__force VAR_10)ipv6_addr_hash(&VAR_7->saddr);\n\t\tVAR_1->dst = (__force VAR_10)ipv6_addr_hash(&VAR_7->daddr);\n\t\tVAR_3 += sizeof(struct ipv6hdr);\n\t\tbreak;\n\t}\n\tcase __constant_htons(VAR_11):\n\tcase __constant_htons(VAR_12): {\n\t\tconst struct vlan_hdr *VAR_13;\n\t\tstruct vlan_hdr VAR_14;\n\n\t\tVAR_13 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_14), &VAR_14);\n\t\tif (!VAR_13)\n\t\t\treturn false;\n\n\t\tproto = VAR_13->h_vlan_encapsulated_proto;\n\t\tVAR_3 += sizeof(*VAR_13);\n\t\tgoto again;\n\t}\n\tcase __constant_htons(VAR_15): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *VAR_16, VAR_17;\n\t\tVAR_16 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_17), &VAR_17);\n\t\tif (!VAR_16)\n\t\t\treturn false;\n\t\tproto = VAR_16->proto;\n\t\tVAR_3 += VAR_18;\n\t\tswitch (proto) {\n\t\tcase __constant_htons(VAR_19):\n\t\t\tgoto ip;\n\t\tcase __constant_htons(VAR_20):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (VAR_4) {\n\tcase VAR_21: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *VAR_16, VAR_17;\n\n\t\tVAR_16 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_17), &VAR_17);\n\t\tif (!VAR_16)\n\t\t\treturn false;\n\t\t/* COMMENT_0 */\n                                                \n            \n     \n\t\tif (!(VAR_16->flags & (VAR_22|VAR_23))) {\n\t\t\tproto = VAR_16->proto;\n\t\t\tVAR_3 += 4;\n\t\t\tif (VAR_16->flags & VAR_24)\n\t\t\t\tVAR_3 += 4;\n\t\t\tif (VAR_16->flags & VAR_25)\n\t\t\t\tVAR_3 += 4;\n\t\t\tif (VAR_16->flags & VAR_26)\n\t\t\t\tVAR_3 += 4;\n\t\t\tif (proto == htons(VAR_27)) {\n\t\t\t\tconst struct ethhdr *VAR_28;\n\t\t\t\tstruct ethhdr VAR_29;\n\n\t\t\t\tVAR_28 = skb_header_pointer(VAR_0, VAR_3,\n\t\t\t\t\t\t\t sizeof(VAR_29), &VAR_29);\n\t\t\t\tif (!VAR_28)\n\t\t\t\t\treturn false;\n\t\t\t\tproto = VAR_28->h_proto;\n\t\t\t\tVAR_3 += sizeof(*VAR_28);\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VAR_30:\n\t\tproto = htons(VAR_6);\n\t\tgoto ip;\n\tcase VAR_31:\n\t\tproto = htons(VAR_9);\n\t\tgoto ipv6;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tVAR_1->ip_proto = VAR_4;\n\tVAR_2 = proto_ports_offset(VAR_4);\n\tif (VAR_2 >= 0) {\n\t\t__be32 *VAR_32, VAR_33;\n\n\t\tVAR_32 = skb_header_pointer(VAR_0, VAR_3 + VAR_2,\n\t\t\t\t\t   sizeof(VAR_33), &VAR_33);\n\t\tif (VAR_32)\n\t\t\tVAR_1->ports = *VAR_32;\n\t}\n\n\tVAR_1->thoff = (u16) VAR_3;\n\n\treturn true;\n}",
    "func_graph_path_before": "kernel/git/netdev/net/6f092343855a71e03b8d209815d8c45bf3a27fcd/flow_dissector.c/vul/before/0.json",
    "func": "bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)\n{\n\tint poff, nhoff = skb_network_offset(skb);\n\tu8 ip_proto;\n\t__be16 proto = skb->protocol;\n\n\tmemset(flow, 0, sizeof(*flow));\n\nagain:\n\tswitch (proto) {\n\tcase __constant_htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\treturn false;\n\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\t\telse\n\t\t\tip_proto = iph->protocol;\n\t\tiph_to_flow_copy_addrs(flow, iph);\n\t\tnhoff += iph->ihl * 4;\n\t\tbreak;\n\t}\n\tcase __constant_htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\nipv6:\n\t\tiph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\n\t\tif (!iph)\n\t\t\treturn false;\n\n\t\tip_proto = iph->nexthdr;\n\t\tflow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);\n\t\tflow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);\n\t\tnhoff += sizeof(struct ipv6hdr);\n\t\tbreak;\n\t}\n\tcase __constant_htons(ETH_P_8021AD):\n\tcase __constant_htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = skb_header_pointer(skb, nhoff, sizeof(_vlan), &_vlan);\n\t\tif (!vlan)\n\t\t\treturn false;\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase __constant_htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = skb_header_pointer(skb, nhoff, sizeof(_hdr), &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase __constant_htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase __constant_htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = skb_header_pointer(skb, nhoff, sizeof(_hdr), &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (!(hdr->flags & (GRE_VERSION|GRE_ROUTING))) {\n\t\t\tproto = hdr->proto;\n\t\t\tnhoff += 4;\n\t\t\tif (hdr->flags & GRE_CSUM)\n\t\t\t\tnhoff += 4;\n\t\t\tif (hdr->flags & GRE_KEY)\n\t\t\t\tnhoff += 4;\n\t\t\tif (hdr->flags & GRE_SEQ)\n\t\t\t\tnhoff += 4;\n\t\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\t\tconst struct ethhdr *eth;\n\t\t\t\tstruct ethhdr _eth;\n\n\t\t\t\teth = skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t\t sizeof(_eth), &_eth);\n\t\t\t\tif (!eth)\n\t\t\t\t\treturn false;\n\t\t\t\tproto = eth->h_proto;\n\t\t\t\tnhoff += sizeof(*eth);\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tflow->ip_proto = ip_proto;\n\tpoff = proto_ports_offset(ip_proto);\n\tif (poff >= 0) {\n\t\t__be32 *ports, _ports;\n\n\t\tports = skb_header_pointer(skb, nhoff + poff,\n\t\t\t\t\t   sizeof(_ports), &_ports);\n\t\tif (ports)\n\t\t\tflow->ports = *ports;\n\t}\n\n\tflow->thoff = (u16) nhoff;\n\n\treturn true;\n}",
    "abstract_func": "bool skb_flow_dissect(const struct sk_buff *VAR_0, struct flow_keys *VAR_1)\n{\n\tint VAR_2, VAR_3 = skb_network_offset(VAR_0);\n\tu8 VAR_4;\n\t__be16 protoVAR_5 = VAR_0->protocol;\n\n\tmemset(VAR_1, 0, sizeof(*VAR_1));\n\nagain:\n\tswitch (proto) {\n\tcase __constant_htons(VAR_6): {\n\t\tconst struct iphdr *VAR_7;\n\t\tstruct iphdr VAR_8;\nip:\n\t\tVAR_7 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_8), &VAR_8);\n\t\tif (!VAR_7 || VAR_7->ihl < 5)\n\t\t\treturn false;\n\n\t\tif (ip_is_fragment(VAR_7))\n\t\t\tVAR_4 = 0;\n\t\telse\n\t\t\tVAR_4 = VAR_7->protocol;\n\t\tiph_to_flow_copy_addrs(VAR_1, VAR_7);\n\t\tVAR_3 += VAR_7->ihl * 4;\n\t\tbreak;\n\t}\n\tcase __constant_htons(VAR_9): {\n\t\tconst struct ipv6hdr *VAR_7;\n\t\tstruct ipv6hdr VAR_8;\nipv6:\n\t\tVAR_7 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_8), &VAR_8);\n\t\tif (!VAR_7)\n\t\t\treturn false;\n\n\t\tVAR_4 = VAR_7->nexthdr;\n\t\tVAR_1->src = (__force VAR_10)ipv6_addr_hash(&VAR_7->saddr);\n\t\tVAR_1->dst = (__force VAR_10)ipv6_addr_hash(&VAR_7->daddr);\n\t\tVAR_3 += sizeof(struct ipv6hdr);\n\t\tbreak;\n\t}\n\tcase __constant_htons(VAR_11):\n\tcase __constant_htons(VAR_12): {\n\t\tconst struct vlan_hdr *VAR_13;\n\t\tstruct vlan_hdr VAR_14;\n\n\t\tVAR_13 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_14), &VAR_14);\n\t\tif (!VAR_13)\n\t\t\treturn false;\n\n\t\tproto = VAR_13->h_vlan_encapsulated_proto;\n\t\tVAR_3 += sizeof(*VAR_13);\n\t\tgoto again;\n\t}\n\tcase __constant_htons(VAR_15): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *VAR_16, VAR_17;\n\t\tVAR_16 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_17), &VAR_17);\n\t\tif (!VAR_16)\n\t\t\treturn false;\n\t\tproto = VAR_16->proto;\n\t\tVAR_3 += VAR_18;\n\t\tswitch (proto) {\n\t\tcase __constant_htons(VAR_19):\n\t\t\tgoto ip;\n\t\tcase __constant_htons(VAR_20):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (VAR_4) {\n\tcase VAR_21: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *VAR_16, VAR_17;\n\n\t\tVAR_16 = skb_header_pointer(VAR_0, VAR_3, sizeof(VAR_17), &VAR_17);\n\t\tif (!VAR_16)\n\t\t\treturn false;\n\t\t/* COMMENT_0 */\n                                                \n            \n     \n\t\tif (!(VAR_16->flags & (VAR_22|VAR_23))) {\n\t\t\tproto = VAR_16->proto;\n\t\t\tVAR_3 += 4;\n\t\t\tif (VAR_16->flags & VAR_24)\n\t\t\t\tVAR_3 += 4;\n\t\t\tif (VAR_16->flags & VAR_25)\n\t\t\t\tVAR_3 += 4;\n\t\t\tif (VAR_16->flags & VAR_26)\n\t\t\t\tVAR_3 += 4;\n\t\t\tif (proto == htons(VAR_27)) {\n\t\t\t\tconst struct ethhdr *VAR_28;\n\t\t\t\tstruct ethhdr VAR_29;\n\n\t\t\t\tVAR_28 = skb_header_pointer(VAR_0, VAR_3,\n\t\t\t\t\t\t\t sizeof(VAR_29), &VAR_29);\n\t\t\t\tif (!VAR_28)\n\t\t\t\t\treturn false;\n\t\t\t\tproto = VAR_28->h_proto;\n\t\t\t\tVAR_3 += sizeof(*VAR_28);\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VAR_30:\n\t\tproto = htons(VAR_6);\n\t\tgoto ip;\n\tcase VAR_31:\n\t\tproto = htons(VAR_9);\n\t\tgoto ipv6;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tVAR_1->ip_proto = VAR_4;\n\tVAR_2 = proto_ports_offset(VAR_4);\n\tif (VAR_2 >= 0) {\n\t\t__be32 *VAR_32, VAR_33;\n\n\t\tVAR_32 = skb_header_pointer(VAR_0, VAR_3 + VAR_2,\n\t\t\t\t\t   sizeof(VAR_33), &VAR_33);\n\t\tif (VAR_32)\n\t\t\tVAR_1->ports = *VAR_32;\n\t}\n\n\tVAR_1->thoff = (u16) VAR_3;\n\n\treturn true;\n}",
    "func_graph_path": "kernel/git/netdev/net/6f092343855a71e03b8d209815d8c45bf3a27fcd/flow_dissector.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \t\tstruct iphdr _iph;\n ip:\n \t\tiph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\n-\t\tif (!iph)\n+\t\tif (!iph || iph->ihl < 5)\n \t\t\treturn false;\n \n \t\tif (ip_is_fragment(iph))",
    "diff_line_info": {
        "deleted_lines": [
            "\t\tif (!iph)"
        ],
        "added_lines": [
            "\t\tif (!iph || iph->ihl < 5)"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}