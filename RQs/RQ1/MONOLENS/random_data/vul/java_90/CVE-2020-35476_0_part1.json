{
    "cve_id": "CVE-2020-35476",
    "cwe_ids": [
        "CWE-78"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "OpenTSDB/opentsdb",
    "commit_msg": "Fix remote code execution #2051 by adding regex validators for the\nGnuplot params and introducting the tsd.gnuplot.options.allowlist\nsetting that is a strict matching allow list of o= values from the\nquery string that will be allowed through. By default tihs is empty\nso if folks are using this query param, they'll different graphs\nuntil they add the options they need.",
    "commit_hash": "b762338664c3ee6e3f773bc04da2a8af24a5c486",
    "git_url": "https://github.com/OpenTSDB/opentsdb/commit/b762338664c3ee6e3f773bc04da2a8af24a5c486",
    "file_path": "src/tsd/GraphHandler.java",
    "func_name": "doGraph",
    "func_before": "private void doGraph(final TSDB tsdb, final HttpQuery query)\n    throws IOException {\n    final String basepath = getGnuplotBasePath(tsdb, query);\n    long start_time = DateTime.parseDateTimeString(\n      query.getRequiredQueryStringParam(\"start\"),\n      query.getQueryStringParam(\"tz\"));\n    final boolean nocache = query.hasQueryStringParam(\"nocache\");\n    if (start_time == -1) {\n      throw BadRequestException.missingParameter(\"start\");\n    } else {\n      // temp fixup to seconds from ms until the rest of TSDB supports ms\n      // Note you can't append this to the DateTime.parseDateTimeString() call as\n      // it clobbers -1 results\n      start_time /= 1000;\n    }\n    long end_time = DateTime.parseDateTimeString(\n        query.getQueryStringParam(\"end\"),\n        query.getQueryStringParam(\"tz\"));\n    final long now = System.currentTimeMillis() / 1000;\n    if (end_time == -1) {\n      end_time = now;\n    } else {\n      // temp fixup to seconds from ms until the rest of TSDB supports ms\n      // Note you can't append this to the DateTime.parseDateTimeString() call as\n      // it clobbers -1 results\n      end_time /= 1000;\n    }\n    final int max_age = computeMaxAge(query, start_time, end_time, now);\n    if (!nocache && isDiskCacheHit(query, end_time, max_age, basepath)) {\n      return;\n    }\n\n    // Parse TSQuery from HTTP query\n    final TSQuery tsquery = QueryRpc.parseQuery(tsdb, query);\n    tsquery.validateAndSetQuery();\n\n    // Build the queries for the parsed TSQuery\n    Query[] tsdbqueries = tsquery.buildQueries(tsdb);\n\n    List<String> options = query.getQueryStringParams(\"o\");\n    if (options == null) {\n      options = new ArrayList<String>(tsdbqueries.length);\n      for (int i = 0; i < tsdbqueries.length; i++) {\n        options.add(\"\");\n      }\n    } else if (options.size() != tsdbqueries.length) {\n      throw new BadRequestException(options.size() + \" `o' parameters, but \"\n        + tsdbqueries.length + \" `m' parameters.\");\n    } else {\n      for (final String option : options) {\n        // TODO - far from perfect, should help a little.\n        if (option.contains(\"`\") || option.contains(\"%60\") || \n            option.contains(\"&#96;\")) {\n          throw new BadRequestException(\"Option contained a back-tick. \"\n              + \"That's a no-no.\");\n        }\n      }\n    }\n    for (final Query tsdbquery : tsdbqueries) {\n      try {\n        tsdbquery.setStartTime(start_time);\n      } catch (IllegalArgumentException e) {\n        throw new BadRequestException(\"start time: \" + e.getMessage());\n      }\n      try {\n        tsdbquery.setEndTime(end_time);\n      } catch (IllegalArgumentException e) {\n        throw new BadRequestException(\"end time: \" + e.getMessage());\n      }\n    }\n    final Plot plot = new Plot(start_time, end_time,\n          DateTime.timezones.get(query.getQueryStringParam(\"tz\")));\n    setPlotDimensions(query, plot);\n    setPlotParams(query, plot);\n    final int nqueries = tsdbqueries.length;\n    @SuppressWarnings(\"unchecked\")\n    final HashSet<String>[] aggregated_tags = new HashSet[nqueries];\n    int npoints = 0;\n    for (int i = 0; i < nqueries; i++) {\n      try {  // execute the TSDB query!\n        // XXX This is slow and will block Netty.  TODO(tsuna): Don't block.\n        // TODO(tsuna): Optimization: run each query in parallel.\n        final DataPoints[] series = tsdbqueries[i].run();\n        for (final DataPoints datapoints : series) {\n          plot.add(datapoints, options.get(i));\n          aggregated_tags[i] = new HashSet<String>();\n          aggregated_tags[i].addAll(datapoints.getAggregatedTags());\n          npoints += datapoints.aggregatedSize();\n        }\n      } catch (RuntimeException e) {\n        logInfo(query, \"Query failed (stack trace coming): \"\n                + tsdbqueries[i]);\n        throw e;\n      }\n      tsdbqueries[i] = null;  // free()\n    }\n    tsdbqueries = null;  // free()\n\n    if (query.hasQueryStringParam(\"ascii\")) {\n      respondAsciiQuery(query, max_age, basepath, plot);\n      return;\n    }\n\n    final RunGnuplot rungnuplot = new RunGnuplot(query, max_age, plot, basepath,\n            aggregated_tags, npoints);\n\n    class ErrorCB implements Callback<Object, Exception> {\n      public Object call(final Exception e) throws Exception {\n        LOG.warn(\"Failed to retrieve global annotations: \", e);\n        throw e;\n      }\n    }\n\n    class GlobalCB implements Callback<Object, List<Annotation>> {\n      public Object call(final List<Annotation> global_annotations) throws Exception {\n        rungnuplot.plot.setGlobals(global_annotations);\n        execGnuplot(rungnuplot, query);\n\n        return null;\n      }\n    }\n\n    // Fetch global annotations, if needed\n    if (!tsquery.getNoAnnotations() && tsquery.getGlobalAnnotations()) {\n      Annotation.getGlobalAnnotations(tsdb, start_time, end_time)\n              .addCallback(new GlobalCB()).addErrback(new ErrorCB());\n    } else {\n      execGnuplot(rungnuplot, query);\n    }\n  }",
    "abstract_func_before": "private void doGraph(final TSDB VAR_0, final HttpQuery VAR_1)\n    throws IOException {\n    final String VAR_2 = getGnuplotBasePath(VAR_0, VAR_1);\n    long VAR_3 = VAR_4.parseDateTimeString(\n      VAR_1.getRequiredQueryStringParam(\"start\"),\n      VAR_1.getQueryStringParam(\"tz\"));\n    final boolean VAR_5 = VAR_1.hasQueryStringParam(\"nocache\");\n    if (VAR_3 == -1) {\n      throw VAR_6.missingParameter(\"start\");\n    } else {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      VAR_3 /= 1000;\n    }\n    long VAR_7 = VAR_4.parseDateTimeString(\n        VAR_1.getQueryStringParam(\"end\"),\n        VAR_1.getQueryStringParam(\"tz\"));\n    final long VAR_8 = VAR_9.currentTimeMillis() / 1000;\n    if (VAR_7 == -1) {\n      VAR_7 = VAR_8;\n    } else {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      VAR_7 /= 1000;\n    }\n    final int VAR_10 = computeMaxAge(VAR_1, VAR_3, VAR_7, VAR_8);\n    if (!VAR_5 && isDiskCacheHit(VAR_1, VAR_7, VAR_10, VAR_2)) {\n      return;\n    }\n\n    /* COMMENT_3 */\n    final TSQuery VAR_11 = VAR_12.parseQuery(VAR_0, VAR_1);\n    VAR_11.validateAndSetQuery();\n\n    /* COMMENT_4 */\n    Query[] VAR_13 = VAR_11.buildQueries(VAR_0);\n\n    List<String> VAR_14 = VAR_1.getQueryStringParams(\"o\");\n    if (VAR_14 == null) {\n      VAR_14 = new ArrayList<String>(VAR_13.length);\n      for (int VAR_15 = 0; VAR_15 < VAR_13.length; VAR_15++) {\n        VAR_14.add(\"\");\n      }\n    } else if (VAR_14.size() != VAR_13.length) {\n      throw new BadRequestException(VAR_14.size() + \" `o' parameters, but \"\n        + VAR_13.length + \" `m' parameters.\");\n    } else {\n      for (final String VAR_16 : VAR_14) {\n        /* COMMENT_5 */\n        if (VAR_16.contains(\"`\") || VAR_16.contains(\"%60\") || \n            VAR_16.contains(\"&#96;\")) {\n          throw new BadRequestException(\"Option contained a back-tick. \"\n              + \"That's a no-no.\");\n        }\n      }\n    }\n    for (final Query VAR_17 : VAR_13) {\n      try {\n        VAR_17.setStartTime(VAR_3);\n      } catch (IllegalArgumentException VAR_18) {\n        throw new BadRequestException(\"start time: \" + VAR_18.getMessage());\n      }\n      try {\n        VAR_17.setEndTime(VAR_7);\n      } catch (IllegalArgumentException VAR_18) {\n        throw new BadRequestException(\"end time: \" + VAR_18.getMessage());\n      }\n    }\n    final Plot VAR_19 = new Plot(VAR_3, VAR_7,\n          VAR_4.timezones.get(VAR_1.getQueryStringParam(\"tz\")));\n    setPlotDimensions(VAR_1, VAR_19);\n    setPlotParams(VAR_1, VAR_19);\n    final int VAR_20 = VAR_13.length;\n    @SuppressWarnings(\"unchecked\")\n    final HashSet<String>[] VAR_21 = new HashSet[VAR_20];\n    int VAR_22 = 0;\n    for (int VAR_15 = 0; VAR_15 < VAR_20; VAR_15++) {\n      try {  /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        final DataPoints[] VAR_23 = VAR_13[VAR_15].run();\n        for (final DataPoints VAR_24 : VAR_23) {\n          VAR_19.add(VAR_24, VAR_14.get(VAR_15));\n          VAR_21[VAR_15] = new HashSet<String>();\n          VAR_21[VAR_15].addAll(VAR_24.getAggregatedTags());\n          VAR_22 += VAR_24.aggregatedSize();\n        }\n      } catch (RuntimeException VAR_18) {\n        logInfo(VAR_1, \"Query failed (stack trace coming): \"\n                + VAR_13[VAR_15]);\n        throw VAR_18;\n      }\n      VAR_13[VAR_15] = null;  /* COMMENT_9 */\n    }\n    VAR_13 = null;  /* COMMENT_9 */\n\n    if (VAR_1.hasQueryStringParam(\"ascii\")) {\n      respondAsciiQuery(VAR_1, VAR_10, VAR_2, VAR_19);\n      return;\n    }\n\n    final RunGnuplot VAR_25 = new RunGnuplot(VAR_1, VAR_10, VAR_19, VAR_2,\n            VAR_21, VAR_22);\n\n    class ErrorCB implements Callback<Object, Exception> {\n      public Object call(final Exception VAR_18) throws Exception {\n        VAR_26.warn(\"Failed to retrieve global annotations: \", VAR_18);\n        throw VAR_18;\n      }\n    }\n\n    class GlobalCB implements Callback<Object, List<Annotation>> {\n      public Object call(final List<Annotation> VAR_27) throws Exception {\n        VAR_25.plot.setGlobals(VAR_27);\n        execGnuplot(VAR_25, VAR_1);\n\n        return null;\n      }\n    }\n\n    /* COMMENT_10 */\n    if (!VAR_11.getNoAnnotations() && VAR_11.getGlobalAnnotations()) {\n      VAR_28.getGlobalAnnotations(VAR_0, VAR_3, VAR_7)\n              .addCallback(new GlobalCB()).addErrback(new ErrorCB());\n    } else {\n      execGnuplot(VAR_25, VAR_1);\n    }\n  }",
    "func_graph_path_before": "OpenTSDB/opentsdb/b762338664c3ee6e3f773bc04da2a8af24a5c486/GraphHandler.java/vul/before/0.json",
    "func": "private void doGraph(final TSDB tsdb, final HttpQuery query)\n    throws IOException {\n    final String basepath = getGnuplotBasePath(tsdb, query);\n    long start_time = DateTime.parseDateTimeString(\n      query.getRequiredQueryStringParam(\"start\"),\n      query.getQueryStringParam(\"tz\"));\n    final boolean nocache = query.hasQueryStringParam(\"nocache\");\n    if (start_time == -1) {\n      throw BadRequestException.missingParameter(\"start\");\n    } else {\n      // temp fixup to seconds from ms until the rest of TSDB supports ms\n      // Note you can't append this to the DateTime.parseDateTimeString() call as\n      // it clobbers -1 results\n      start_time /= 1000;\n    }\n    long end_time = DateTime.parseDateTimeString(\n        query.getQueryStringParam(\"end\"),\n        query.getQueryStringParam(\"tz\"));\n    final long now = System.currentTimeMillis() / 1000;\n    if (end_time == -1) {\n      end_time = now;\n    } else {\n      // temp fixup to seconds from ms until the rest of TSDB supports ms\n      // Note you can't append this to the DateTime.parseDateTimeString() call as\n      // it clobbers -1 results\n      end_time /= 1000;\n    }\n    final int max_age = computeMaxAge(query, start_time, end_time, now);\n    if (!nocache && isDiskCacheHit(query, end_time, max_age, basepath)) {\n      return;\n    }\n\n    // Parse TSQuery from HTTP query\n    final TSQuery tsquery = QueryRpc.parseQuery(tsdb, query);\n    tsquery.validateAndSetQuery();\n\n    // Build the queries for the parsed TSQuery\n    Query[] tsdbqueries = tsquery.buildQueries(tsdb);\n\n    List<String> options = null;\n    final String options_allow_list = tsdb.getConfig().getString(\n        \"tsd.gnuplot.options.allowlist\");\n    if (!Strings.isNullOrEmpty(options_allow_list)) {\n      String[] allow_list_strings = options_allow_list.split(\";\");\n      Set<String> allow_list = Sets.newHashSet();\n      for (int i = 0; i < allow_list_strings.length; i++) {\n        String allow = allow_list_strings[i];\n        if (allow != null) {\n          allow = URLDecoder.decode(allow.trim());\n          allow_list.add(allow);\n        }\n      }\n      \n      options = query.getQueryStringParams(\"o\");\n      for (int i = 0; i < options.size(); i++) {\n        if (!allow_list.contains(options.get(i))) {\n          throw new BadRequestException(\"Query option at index \" + i \n              + \" was not in the allow list.\");\n        }\n      }\n    }\n    \n    if (options == null) {\n      options = new ArrayList<String>(tsdbqueries.length);\n      for (int i = 0; i < tsdbqueries.length; i++) {\n        options.add(\"\");\n      }\n    } else if (options.size() != tsdbqueries.length) {\n      throw new BadRequestException(options.size() + \" `o' parameters, but \"\n        + tsdbqueries.length + \" `m' parameters.\");\n    }\n    for (final Query tsdbquery : tsdbqueries) {\n      try {\n        tsdbquery.setStartTime(start_time);\n      } catch (IllegalArgumentException e) {\n        throw new BadRequestException(\"start time: \" + e.getMessage());\n      }\n      try {\n        tsdbquery.setEndTime(end_time);\n      } catch (IllegalArgumentException e) {\n        throw new BadRequestException(\"end time: \" + e.getMessage());\n      }\n    }\n    final Plot plot = new Plot(start_time, end_time,\n          DateTime.timezones.get(query.getQueryStringParam(\"tz\")));\n    setPlotDimensions(query, plot);\n    setPlotParams(query, plot);\n    final int nqueries = tsdbqueries.length;\n    @SuppressWarnings(\"unchecked\")\n    final HashSet<String>[] aggregated_tags = new HashSet[nqueries];\n    int npoints = 0;\n    for (int i = 0; i < nqueries; i++) {\n      try {  // execute the TSDB query!\n        // XXX This is slow and will block Netty.  TODO(tsuna): Don't block.\n        // TODO(tsuna): Optimization: run each query in parallel.\n        final DataPoints[] series = tsdbqueries[i].run();\n        for (final DataPoints datapoints : series) {\n          plot.add(datapoints, options.get(i));\n          aggregated_tags[i] = new HashSet<String>();\n          aggregated_tags[i].addAll(datapoints.getAggregatedTags());\n          npoints += datapoints.aggregatedSize();\n        }\n      } catch (RuntimeException e) {\n        logInfo(query, \"Query failed (stack trace coming): \"\n                + tsdbqueries[i]);\n        throw e;\n      }\n      tsdbqueries[i] = null;  // free()\n    }\n    tsdbqueries = null;  // free()\n\n    if (query.hasQueryStringParam(\"ascii\")) {\n      respondAsciiQuery(query, max_age, basepath, plot);\n      return;\n    }\n\n    final RunGnuplot rungnuplot = new RunGnuplot(query, max_age, plot, basepath,\n            aggregated_tags, npoints);\n\n    class ErrorCB implements Callback<Object, Exception> {\n      public Object call(final Exception e) throws Exception {\n        LOG.warn(\"Failed to retrieve global annotations: \", e);\n        throw e;\n      }\n    }\n\n    class GlobalCB implements Callback<Object, List<Annotation>> {\n      public Object call(final List<Annotation> global_annotations) throws Exception {\n        rungnuplot.plot.setGlobals(global_annotations);\n        execGnuplot(rungnuplot, query);\n\n        return null;\n      }\n    }\n\n    // Fetch global annotations, if needed\n    if (!tsquery.getNoAnnotations() && tsquery.getGlobalAnnotations()) {\n      Annotation.getGlobalAnnotations(tsdb, start_time, end_time)\n              .addCallback(new GlobalCB()).addErrback(new ErrorCB());\n    } else {\n      execGnuplot(rungnuplot, query);\n    }\n  }",
    "abstract_func": "private void doGraph(final TSDB VAR_0, final HttpQuery VAR_1)\n    throws IOException {\n    final String VAR_2 = getGnuplotBasePath(VAR_0, VAR_1);\n    long VAR_3 = VAR_4.parseDateTimeString(\n      VAR_1.getRequiredQueryStringParam(\"start\"),\n      VAR_1.getQueryStringParam(\"tz\"));\n    final boolean VAR_5 = VAR_1.hasQueryStringParam(\"nocache\");\n    if (VAR_3 == -1) {\n      throw VAR_6.missingParameter(\"start\");\n    } else {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      VAR_3 /= 1000;\n    }\n    long VAR_7 = VAR_4.parseDateTimeString(\n        VAR_1.getQueryStringParam(\"end\"),\n        VAR_1.getQueryStringParam(\"tz\"));\n    final long VAR_8 = VAR_9.currentTimeMillis() / 1000;\n    if (VAR_7 == -1) {\n      VAR_7 = VAR_8;\n    } else {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      VAR_7 /= 1000;\n    }\n    final int VAR_10 = computeMaxAge(VAR_1, VAR_3, VAR_7, VAR_8);\n    if (!VAR_5 && isDiskCacheHit(VAR_1, VAR_7, VAR_10, VAR_2)) {\n      return;\n    }\n\n    /* COMMENT_3 */\n    final TSQuery VAR_11 = VAR_12.parseQuery(VAR_0, VAR_1);\n    VAR_11.validateAndSetQuery();\n\n    /* COMMENT_4 */\n    Query[] VAR_13 = VAR_11.buildQueries(VAR_0);\n\n    List<String> VAR_14 = null;\n    final String VAR_15 = VAR_0.getConfig().getString(\n        \"tsd.gnuplot.options.allowlist\");\n    if (!VAR_16.isNullOrEmpty(VAR_15)) {\n      String[] VAR_17 = VAR_15.split(\";\");\n      Set<String> VAR_18 = VAR_19.newHashSet();\n      for (int VAR_20 = 0; VAR_20 < VAR_17.length; VAR_20++) {\n        String VAR_21 = VAR_17[VAR_20];\n        if (VAR_21 != null) {\n          VAR_21 = VAR_22.decode(VAR_21.trim());\n          VAR_18.add(VAR_21);\n        }\n      }\n      \n      VAR_14 = VAR_1.getQueryStringParams(\"o\");\n      for (int VAR_20 = 0; VAR_20 < VAR_14.size(); VAR_20++) {\n        if (!VAR_18.contains(VAR_14.get(VAR_20))) {\n          throw new BadRequestException(\"Query option at index \" + VAR_20 \n              + \" was not in the allow list.\");\n        }\n      }\n    }\n    \n    if (VAR_14 == null) {\n      VAR_14 = new ArrayList<String>(VAR_13.length);\n      for (int VAR_20 = 0; VAR_20 < VAR_13.length; VAR_20++) {\n        VAR_14.add(\"\");\n      }\n    } else if (VAR_14.size() != VAR_13.length) {\n      throw new BadRequestException(VAR_14.size() + \" `o' parameters, but \"\n        + VAR_13.length + \" `m' parameters.\");\n    }\n    for (final Query VAR_23 : VAR_13) {\n      try {\n        VAR_23.setStartTime(VAR_3);\n      } catch (IllegalArgumentException VAR_24) {\n        throw new BadRequestException(\"start time: \" + VAR_24.getMessage());\n      }\n      try {\n        VAR_23.setEndTime(VAR_7);\n      } catch (IllegalArgumentException VAR_24) {\n        throw new BadRequestException(\"end time: \" + VAR_24.getMessage());\n      }\n    }\n    final Plot VAR_25 = new Plot(VAR_3, VAR_7,\n          VAR_4.timezones.get(VAR_1.getQueryStringParam(\"tz\")));\n    setPlotDimensions(VAR_1, VAR_25);\n    setPlotParams(VAR_1, VAR_25);\n    final int VAR_26 = VAR_13.length;\n    @SuppressWarnings(\"unchecked\")\n    final HashSet<String>[] VAR_27 = new HashSet[VAR_26];\n    int VAR_28 = 0;\n    for (int VAR_20 = 0; VAR_20 < VAR_26; VAR_20++) {\n      try {  /* COMMENT_5 */\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        final DataPoints[] VAR_29 = VAR_13[VAR_20].run();\n        for (final DataPoints VAR_30 : VAR_29) {\n          VAR_25.add(VAR_30, VAR_14.get(VAR_20));\n          VAR_27[VAR_20] = new HashSet<String>();\n          VAR_27[VAR_20].addAll(VAR_30.getAggregatedTags());\n          VAR_28 += VAR_30.aggregatedSize();\n        }\n      } catch (RuntimeException VAR_24) {\n        logInfo(VAR_1, \"Query failed (stack trace coming): \"\n                + VAR_13[VAR_20]);\n        throw VAR_24;\n      }\n      VAR_13[VAR_20] = null;  /* COMMENT_8 */\n    }\n    VAR_13 = null;  /* COMMENT_8 */\n\n    if (VAR_1.hasQueryStringParam(\"ascii\")) {\n      respondAsciiQuery(VAR_1, VAR_10, VAR_2, VAR_25);\n      return;\n    }\n\n    final RunGnuplot VAR_31 = new RunGnuplot(VAR_1, VAR_10, VAR_25, VAR_2,\n            VAR_27, VAR_28);\n\n    class ErrorCB implements Callback<Object, Exception> {\n      public Object call(final Exception VAR_24) throws Exception {\n        VAR_32.warn(\"Failed to retrieve global annotations: \", VAR_24);\n        throw VAR_24;\n      }\n    }\n\n    class GlobalCB implements Callback<Object, List<Annotation>> {\n      public Object call(final List<Annotation> VAR_33) throws Exception {\n        VAR_31.plot.setGlobals(VAR_33);\n        execGnuplot(VAR_31, VAR_1);\n\n        return null;\n      }\n    }\n\n    /* COMMENT_9 */\n    if (!VAR_11.getNoAnnotations() && VAR_11.getGlobalAnnotations()) {\n      VAR_34.getGlobalAnnotations(VAR_0, VAR_3, VAR_7)\n              .addCallback(new GlobalCB()).addErrback(new ErrorCB());\n    } else {\n      execGnuplot(VAR_31, VAR_1);\n    }\n  }",
    "func_graph_path": "OpenTSDB/opentsdb/b762338664c3ee6e3f773bc04da2a8af24a5c486/GraphHandler.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,29 @@\n     // Build the queries for the parsed TSQuery\n     Query[] tsdbqueries = tsquery.buildQueries(tsdb);\n \n-    List<String> options = query.getQueryStringParams(\"o\");\n+    List<String> options = null;\n+    final String options_allow_list = tsdb.getConfig().getString(\n+        \"tsd.gnuplot.options.allowlist\");\n+    if (!Strings.isNullOrEmpty(options_allow_list)) {\n+      String[] allow_list_strings = options_allow_list.split(\";\");\n+      Set<String> allow_list = Sets.newHashSet();\n+      for (int i = 0; i < allow_list_strings.length; i++) {\n+        String allow = allow_list_strings[i];\n+        if (allow != null) {\n+          allow = URLDecoder.decode(allow.trim());\n+          allow_list.add(allow);\n+        }\n+      }\n+      \n+      options = query.getQueryStringParams(\"o\");\n+      for (int i = 0; i < options.size(); i++) {\n+        if (!allow_list.contains(options.get(i))) {\n+          throw new BadRequestException(\"Query option at index \" + i \n+              + \" was not in the allow list.\");\n+        }\n+      }\n+    }\n+    \n     if (options == null) {\n       options = new ArrayList<String>(tsdbqueries.length);\n       for (int i = 0; i < tsdbqueries.length; i++) {\n@@ -46,15 +68,6 @@\n     } else if (options.size() != tsdbqueries.length) {\n       throw new BadRequestException(options.size() + \" `o' parameters, but \"\n         + tsdbqueries.length + \" `m' parameters.\");\n-    } else {\n-      for (final String option : options) {\n-        // TODO - far from perfect, should help a little.\n-        if (option.contains(\"`\") || option.contains(\"%60\") || \n-            option.contains(\"&#96;\")) {\n-          throw new BadRequestException(\"Option contained a back-tick. \"\n-              + \"That's a no-no.\");\n-        }\n-      }\n     }\n     for (final Query tsdbquery : tsdbqueries) {\n       try {",
    "diff_line_info": {
        "deleted_lines": [
            "    List<String> options = query.getQueryStringParams(\"o\");",
            "    } else {",
            "      for (final String option : options) {",
            "        // TODO - far from perfect, should help a little.",
            "        if (option.contains(\"`\") || option.contains(\"%60\") || ",
            "            option.contains(\"&#96;\")) {",
            "          throw new BadRequestException(\"Option contained a back-tick. \"",
            "              + \"That's a no-no.\");",
            "        }",
            "      }"
        ],
        "added_lines": [
            "    List<String> options = null;",
            "    final String options_allow_list = tsdb.getConfig().getString(",
            "        \"tsd.gnuplot.options.allowlist\");",
            "    if (!Strings.isNullOrEmpty(options_allow_list)) {",
            "      String[] allow_list_strings = options_allow_list.split(\";\");",
            "      Set<String> allow_list = Sets.newHashSet();",
            "      for (int i = 0; i < allow_list_strings.length; i++) {",
            "        String allow = allow_list_strings[i];",
            "        if (allow != null) {",
            "          allow = URLDecoder.decode(allow.trim());",
            "          allow_list.add(allow);",
            "        }",
            "      }",
            "      ",
            "      options = query.getQueryStringParams(\"o\");",
            "      for (int i = 0; i < options.size(); i++) {",
            "        if (!allow_list.contains(options.get(i))) {",
            "          throw new BadRequestException(\"Query option at index \" + i ",
            "              + \" was not in the allow list.\");",
            "        }",
            "      }",
            "    }",
            "    "
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}