{
    "cve_id": "CVE-2018-8039",
    "cwe_ids": [
        "CWE-755"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "apache/cxf",
    "commit_msg": "Fix hostname verification using the deprecated SSL stack",
    "commit_hash": "fae6fabf9bd7647f5e9cb68897a7d72b545b741b",
    "git_url": "https://github.com/apache/cxf/commit/fae6fabf9bd7647f5e9cb68897a7d72b545b741b",
    "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/https/HttpsURLConnectionFactory.java",
    "func_name": "decorateWithTLS",
    "func_before": "protected synchronized void decorateWithTLS(TLSClientParameters tlsClientParameters,\n            HttpURLConnection connection) throws GeneralSecurityException {\n\n\n        int hash = tlsClientParameters.hashCode();\n        if (hash != lastTlsHash) {\n            lastTlsHash = hash;\n            socketFactory = null;\n        }\n\n        // always reload socketFactory from HttpsURLConnection.defaultSSLSocketFactory and\n        // tlsClientParameters.sslSocketFactory to allow runtime configuration change\n        if (tlsClientParameters.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            socketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n\n        } else if (tlsClientParameters.getSSLSocketFactory() != null) {\n            // see if an SSLSocketFactory was set. This allows easy interop\n            // with not-yet-commons-ssl.jar, or even just people who like doing their\n            // own JSSE.\n            socketFactory = tlsClientParameters.getSSLSocketFactory();\n\n        } else if (socketFactory == null) {\n            // ssl socket factory not yet instantiated, create a new one with tlsClientParameters's Trust\n            // Managers, Key Managers, etc\n\n            SSLContext ctx =\n                org.apache.cxf.transport.https.SSLUtils.getSSLContext(tlsClientParameters);\n\n            String[] cipherSuites =\n                SSLUtils.getCiphersuitesToInclude(tlsClientParameters.getCipherSuites(),\n                                                  tlsClientParameters.getCipherSuitesFilter(),\n                                                  ctx.getSocketFactory().getDefaultCipherSuites(),\n                                                  SSLUtils.getSupportedCipherSuites(ctx),\n                                                  LOG);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null ? tlsClientParameters\n                .getSecureSocketProtocol() : \"TLS\";\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(), cipherSuites,\n                                                        protocol);\n            //recalc the hashcode since some of the above MAY have changed the tlsClientParameters\n            lastTlsHash = tlsClientParameters.hashCode();\n        } else {\n           // ssl socket factory already initialized, reuse it to benefit of keep alive\n        }\n\n\n        HostnameVerifier verifier = org.apache.cxf.transport.https.SSLUtils\n            .getHostnameVerifier(tlsClientParameters);\n\n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            conn.setHostnameVerifier(verifier);\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case and other possible hidden API's\n            // that are similar to the Sun cases\n            try {\n                Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n\n                InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy,\n                                         Method method,\n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return true;\n                        }\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {method.getReturnType()},\n                                                                        handler);\n\n                method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                method.invoke(connection, proxy);\n            } catch (Exception ex) {\n                //Ignore this one\n            }\n            try {\n                Method getSSLSocketFactory = connection.getClass().getMethod(\"getSSLSocketFactory\");\n                Method setSSLSocketFactory = connection.getClass()\n                    .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                    setSSLSocketFactory.invoke(connection, socketFactory);\n                } else {\n                    //need to see if we can create one - mostly the weblogic case.   The\n                    //weblogic SSLSocketFactory has a protected constructor that can take\n                    //a JSSE SSLSocketFactory so we'll try and use that\n                    Constructor<?> c = getSSLSocketFactory.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    ReflectionUtil.setAccessible(c);\n                    setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                }\n            } catch (Exception ex) {\n                if (connection.getClass().getName().contains(\"weblogic\")) {\n                    if (!weblogicWarned) {\n                        weblogicWarned = true;\n                        LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                }\n                //if we cannot set the SSLSocketFactory, we're in serious trouble.\n                throw new IllegalArgumentException(\"Error decorating connection class \"\n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }",
    "abstract_func_before": "protected synchronized void decorateWithTLS(TLSClientParameters VAR_0,\n            HttpURLConnection VAR_1) throws GeneralSecurityException {\n\n\n        int VAR_2 = VAR_0.hashCode();\n        if (VAR_2 != VAR_3) {\n            VAR_3 = VAR_2;\n            VAR_4 = null;\n        }\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        if (VAR_0.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            VAR_4 = VAR_5.getDefaultSSLSocketFactory();\n\n        } else if (VAR_0.getSSLSocketFactory() != null) {\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            VAR_4 = VAR_0.getSSLSocketFactory();\n\n        } else if (VAR_4 == null) {\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n\n            SSLContext VAR_6 =\n                VAR_7.apache.cxf.transport.https.SSLUtils.getSSLContext(VAR_0);\n\n            String[] VAR_8 =\n                VAR_9.getCiphersuitesToInclude(VAR_0.getCipherSuites(),\n                                                  VAR_0.getCipherSuitesFilter(),\n                                                  VAR_6.getSocketFactory().getDefaultCipherSuites(),\n                                                  VAR_9.getSupportedCipherSuites(VAR_6),\n                                                  VAR_10);\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            String VAR_11 = VAR_0.getSecureSocketProtocol() != null ? VAR_0\n                .getSecureSocketProtocol() : \"TLS\";\n            VAR_4 = new SSLSocketFactoryWrapper(VAR_6.getSocketFactory(), VAR_8,\n                                                        VAR_11);\n            /* COMMENT_9 */\n            VAR_3 = VAR_0.hashCode();\n        } else {\n           /* COMMENT_10 */\n        }\n\n\n        HostnameVerifier VAR_12 = VAR_7.apache.cxf.transport.https.SSLUtils\n            .getHostnameVerifier(VAR_0);\n\n        if (VAR_1 instanceof HttpsURLConnection) {\n            /* COMMENT_11 */\n            HttpsURLConnection VAR_13 = (HttpsURLConnection) VAR_1;\n            VAR_13.setHostnameVerifier(VAR_12);\n            VAR_13.setSSLSocketFactory(VAR_4);\n        } else {\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            try {\n                Method VAR_14 = VAR_1.getClass().getMethod(\"getHostnameVerifier\");\n\n                InvocationHandler VAR_15 = new ReflectionInvokationHandler(VAR_12) {\n                    public Object invoke(Object VAR_16,\n                                         Method VAR_14,\n                                         Object[] VAR_17) throws Throwable {\n                        try {\n                            return super.invoke(VAR_16, VAR_14, VAR_17);\n                        } catch (Exception VAR_18) {\n                            return true;\n                        }\n                    }\n                };\n                Object VAR_16 = VAR_19.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {VAR_14.getReturnType()},\n                                                                        VAR_15);\n\n                VAR_14 = VAR_1.getClass().getMethod(\"setHostnameVerifier\", VAR_14.getReturnType());\n                VAR_14.invoke(VAR_1, VAR_16);\n            } catch (Exception VAR_18) {\n                /* COMMENT_14 */\n            }\n            try {\n                Method VAR_20 = VAR_1.getClass().getMethod(\"getSSLSocketFactory\");\n                Method VAR_21 = VAR_1.getClass()\n                    .getMethod(\"setSSLSocketFactory\", VAR_20.getReturnType());\n                if (VAR_20.getReturnType().isInstance(VAR_4)) {\n                    VAR_21.invoke(VAR_1, VAR_4);\n                } else {\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    /* COMMENT_17 */\n                    Constructor<?> VAR_22 = VAR_20.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    VAR_23.setAccessible(VAR_22);\n                    VAR_21.invoke(VAR_1, VAR_22.newInstance(VAR_4));\n                }\n            } catch (Exception VAR_18) {\n                if (VAR_1.getClass().getName().contains(\"weblogic\")) {\n                    if (!VAR_24) {\n                        VAR_24 = true;\n                        VAR_10.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                }\n                /* COMMENT_18 */\n                throw new IllegalArgumentException(\"Error decorating connection class \"\n                        + VAR_1.getClass().getName(), VAR_18);\n            }\n        }\n    }",
    "func_graph_path_before": "apache/cxf/fae6fabf9bd7647f5e9cb68897a7d72b545b741b/HttpsURLConnectionFactory.java/vul/before/0.json",
    "func": "protected synchronized void decorateWithTLS(TLSClientParameters tlsClientParameters,\n            HttpURLConnection connection) throws GeneralSecurityException {\n\n\n        int hash = tlsClientParameters.hashCode();\n        if (hash != lastTlsHash) {\n            lastTlsHash = hash;\n            socketFactory = null;\n        }\n\n        // always reload socketFactory from HttpsURLConnection.defaultSSLSocketFactory and\n        // tlsClientParameters.sslSocketFactory to allow runtime configuration change\n        if (tlsClientParameters.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            socketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n\n        } else if (tlsClientParameters.getSSLSocketFactory() != null) {\n            // see if an SSLSocketFactory was set. This allows easy interop\n            // with not-yet-commons-ssl.jar, or even just people who like doing their\n            // own JSSE.\n            socketFactory = tlsClientParameters.getSSLSocketFactory();\n\n        } else if (socketFactory == null) {\n            // ssl socket factory not yet instantiated, create a new one with tlsClientParameters's Trust\n            // Managers, Key Managers, etc\n\n            SSLContext ctx =\n                org.apache.cxf.transport.https.SSLUtils.getSSLContext(tlsClientParameters);\n\n            String[] cipherSuites =\n                SSLUtils.getCiphersuitesToInclude(tlsClientParameters.getCipherSuites(),\n                                                  tlsClientParameters.getCipherSuitesFilter(),\n                                                  ctx.getSocketFactory().getDefaultCipherSuites(),\n                                                  SSLUtils.getSupportedCipherSuites(ctx),\n                                                  LOG);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null ? tlsClientParameters\n                .getSecureSocketProtocol() : \"TLS\";\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(), cipherSuites,\n                                                        protocol);\n            //recalc the hashcode since some of the above MAY have changed the tlsClientParameters\n            lastTlsHash = tlsClientParameters.hashCode();\n        } else {\n           // ssl socket factory already initialized, reuse it to benefit of keep alive\n        }\n\n\n        HostnameVerifier verifier = org.apache.cxf.transport.https.SSLUtils\n            .getHostnameVerifier(tlsClientParameters);\n\n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            conn.setHostnameVerifier(verifier);\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case and other possible hidden API's\n            // that are similar to the Sun cases\n            try {\n                Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n\n                InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy,\n                                         Method method,\n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return false;\n                        }\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {method.getReturnType()},\n                                                                        handler);\n\n                method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                method.invoke(connection, proxy);\n            } catch (Exception ex) {\n                //Ignore this one\n            }\n            try {\n                Method getSSLSocketFactory = connection.getClass().getMethod(\"getSSLSocketFactory\");\n                Method setSSLSocketFactory = connection.getClass()\n                    .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                    setSSLSocketFactory.invoke(connection, socketFactory);\n                } else {\n                    //need to see if we can create one - mostly the weblogic case.   The\n                    //weblogic SSLSocketFactory has a protected constructor that can take\n                    //a JSSE SSLSocketFactory so we'll try and use that\n                    Constructor<?> c = getSSLSocketFactory.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    ReflectionUtil.setAccessible(c);\n                    setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                }\n            } catch (Exception ex) {\n                if (connection.getClass().getName().contains(\"weblogic\")) {\n                    if (!weblogicWarned) {\n                        weblogicWarned = true;\n                        LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                }\n                //if we cannot set the SSLSocketFactory, we're in serious trouble.\n                throw new IllegalArgumentException(\"Error decorating connection class \"\n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }",
    "abstract_func": "protected synchronized void decorateWithTLS(TLSClientParameters VAR_0,\n            HttpURLConnection VAR_1) throws GeneralSecurityException {\n\n\n        int VAR_2 = VAR_0.hashCode();\n        if (VAR_2 != VAR_3) {\n            VAR_3 = VAR_2;\n            VAR_4 = null;\n        }\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        if (VAR_0.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            VAR_4 = VAR_5.getDefaultSSLSocketFactory();\n\n        } else if (VAR_0.getSSLSocketFactory() != null) {\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            VAR_4 = VAR_0.getSSLSocketFactory();\n\n        } else if (VAR_4 == null) {\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n\n            SSLContext VAR_6 =\n                VAR_7.apache.cxf.transport.https.SSLUtils.getSSLContext(VAR_0);\n\n            String[] VAR_8 =\n                VAR_9.getCiphersuitesToInclude(VAR_0.getCipherSuites(),\n                                                  VAR_0.getCipherSuitesFilter(),\n                                                  VAR_6.getSocketFactory().getDefaultCipherSuites(),\n                                                  VAR_9.getSupportedCipherSuites(VAR_6),\n                                                  VAR_10);\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            String VAR_11 = VAR_0.getSecureSocketProtocol() != null ? VAR_0\n                .getSecureSocketProtocol() : \"TLS\";\n            VAR_4 = new SSLSocketFactoryWrapper(VAR_6.getSocketFactory(), VAR_8,\n                                                        VAR_11);\n            /* COMMENT_9 */\n            VAR_3 = VAR_0.hashCode();\n        } else {\n           /* COMMENT_10 */\n        }\n\n\n        HostnameVerifier VAR_12 = VAR_7.apache.cxf.transport.https.SSLUtils\n            .getHostnameVerifier(VAR_0);\n\n        if (VAR_1 instanceof HttpsURLConnection) {\n            /* COMMENT_11 */\n            HttpsURLConnection VAR_13 = (HttpsURLConnection) VAR_1;\n            VAR_13.setHostnameVerifier(VAR_12);\n            VAR_13.setSSLSocketFactory(VAR_4);\n        } else {\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            try {\n                Method VAR_14 = VAR_1.getClass().getMethod(\"getHostnameVerifier\");\n\n                InvocationHandler VAR_15 = new ReflectionInvokationHandler(VAR_12) {\n                    public Object invoke(Object VAR_16,\n                                         Method VAR_14,\n                                         Object[] VAR_17) throws Throwable {\n                        try {\n                            return super.invoke(VAR_16, VAR_14, VAR_17);\n                        } catch (Exception VAR_18) {\n                            return false;\n                        }\n                    }\n                };\n                Object VAR_16 = VAR_19.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {VAR_14.getReturnType()},\n                                                                        VAR_15);\n\n                VAR_14 = VAR_1.getClass().getMethod(\"setHostnameVerifier\", VAR_14.getReturnType());\n                VAR_14.invoke(VAR_1, VAR_16);\n            } catch (Exception VAR_18) {\n                /* COMMENT_14 */\n            }\n            try {\n                Method VAR_20 = VAR_1.getClass().getMethod(\"getSSLSocketFactory\");\n                Method VAR_21 = VAR_1.getClass()\n                    .getMethod(\"setSSLSocketFactory\", VAR_20.getReturnType());\n                if (VAR_20.getReturnType().isInstance(VAR_4)) {\n                    VAR_21.invoke(VAR_1, VAR_4);\n                } else {\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    /* COMMENT_17 */\n                    Constructor<?> VAR_22 = VAR_20.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    VAR_23.setAccessible(VAR_22);\n                    VAR_21.invoke(VAR_1, VAR_22.newInstance(VAR_4));\n                }\n            } catch (Exception VAR_18) {\n                if (VAR_1.getClass().getName().contains(\"weblogic\")) {\n                    if (!VAR_24) {\n                        VAR_24 = true;\n                        VAR_10.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                }\n                /* COMMENT_18 */\n                throw new IllegalArgumentException(\"Error decorating connection class \"\n                        + VAR_1.getClass().getName(), VAR_18);\n            }\n        }\n    }",
    "func_graph_path": "apache/cxf/fae6fabf9bd7647f5e9cb68897a7d72b545b741b/HttpsURLConnectionFactory.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n                         try {\n                             return super.invoke(proxy, method, args);\n                         } catch (Exception ex) {\n-                            return true;\n+                            return false;\n                         }\n                     }\n                 };",
    "diff_line_info": {
        "deleted_lines": [
            "                            return true;"
        ],
        "added_lines": [
            "                            return false;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}