{
    "cve_id": "CVE-2021-21295",
    "cwe_ids": [
        "CWE-444"
    ],
    "cvss_vector": "AV:N/AC:H/Au:N/C:N/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "netty",
    "commit_msg": "Merge pull request from GHSA-wm47-8v5p-wjpj\n\nMotivation:\n\nAs stated by https://tools.ietf.org/html/rfc7540#section-8.1.2.6 we should report a stream error if the content-length does not match the sum of all data frames.\n\nModifications:\n\n- Verify that the sum of data frames match if a content-length header was send.\n- Handle multiple content-length headers and also handle negative values\n- Add io.netty.http2.validateContentLength system property which allows to disable the more strict validation\n- Add unit tests\n\nResult:\n\nCorrectly handle the case when the content-length header was included but not match what is send and also when content-length header is invalid",
    "commit_hash": "89c241e3b1795ff257af4ad6eadc616cb2fb3dc4",
    "git_url": "https://github.com/netty/netty/commit/89c241e3b1795ff257af4ad6eadc616cb2fb3dc4",
    "file_path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
    "func_name": "readHeaders",
    "func_before": "private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n\n        if (!contentLengthFields.isEmpty()) {\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            //\n            // If a message is received that has multiple Content-Length header\n            //   fields with field-values consisting of the same decimal value, or a\n            //   single Content-Length header field with a field value containing a\n            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n            //   indicating that duplicate Content-Length header fields have been\n            //   generated or combined by an upstream message processor, then the\n            //   recipient MUST either reject the message as invalid or replace the\n            //   duplicated field-values with a single valid Content-Length field\n            //   containing that decimal value prior to determining the message body\n            //   length or forwarding the message.\n            boolean multipleContentLengths =\n                    contentLengthFields.size() > 1 || contentLengthFields.get(0).indexOf(COMMA) >= 0;\n            if (multipleContentLengths && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                if (allowDuplicateContentLengths) {\n                    // Find and enforce that all Content-Length values are the same\n                    String firstValue = null;\n                    for (String field : contentLengthFields) {\n                        String[] tokens = COMMA_PATTERN.split(field, -1);\n                        for (String token : tokens) {\n                            String trimmed = token.trim();\n                            if (firstValue == null) {\n                                firstValue = trimmed;\n                            } else if (!trimmed.equals(firstValue)) {\n                                throw new IllegalArgumentException(\n                                        \"Multiple Content-Length values found: \" + contentLengthFields);\n                            }\n                        }\n                    }\n                    // Replace the duplicated field-values with a single valid Content-Length field\n                    headers.set(HttpHeaderNames.CONTENT_LENGTH, firstValue);\n                    contentLength = Long.parseLong(firstValue);\n                } else {\n                    // Reject the message as invalid\n                    throw new IllegalArgumentException(\n                            \"Multiple Content-Length values found: \" + contentLengthFields);\n                }\n            } else {\n                contentLength = Long.parseLong(contentLengthFields.get(0));\n            }\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }",
    "abstract_func_before": "private State readHeaders(ByteBuf VAR_0) {\n        final HttpMessage VAR_1 = this.message;\n        final HttpHeaders VAR_2 = VAR_1.headers();\n\n        AppendableCharSequence VAR_3 = VAR_4.parse(VAR_0);\n        if (VAR_3 == null) {\n            return null;\n        }\n        if (VAR_3.length() > 0) {\n            do {\n                char VAR_5 = VAR_3.charAtUnsafe(0);\n                if (VAR_6 != null && (VAR_5 == ' ' || VAR_5 == '\\t')) {\n                    /* COMMENT_0 */\n                    /* COMMENT_1 */\n                    String VAR_7 = VAR_3.toString().trim();\n                    String VAR_8 = VAR_9.valueOf(VAR_10);\n                    VAR_10 = VAR_8 + ' ' + VAR_7;\n                } else {\n                    if (VAR_6 != null) {\n                        VAR_2.add(VAR_6, VAR_10);\n                    }\n                    splitHeader(VAR_3);\n                }\n\n                VAR_3 = VAR_4.parse(VAR_0);\n                if (VAR_3 == null) {\n                    return null;\n                }\n            } while (VAR_3.length() > 0);\n        }\n\n        /* COMMENT_2 */\n        if (VAR_6 != null) {\n            VAR_2.add(VAR_6, VAR_10);\n        }\n\n        /* COMMENT_3 */\n        VAR_6 = null;\n        VAR_10 = null;\n\n        List<String> VAR_11 = VAR_2.getAll(VAR_12.CONTENT_LENGTH);\n\n        if (!VAR_11.isEmpty()) {\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            /* COMMENT_10 */\n            /* COMMENT_11 */\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            /* COMMENT_14 */\n            /* COMMENT_15 */\n            /* COMMENT_16 */\n            boolean VAR_13 =\n                    VAR_11.size() > 1 || VAR_11.get(0).indexOf(VAR_14) >= 0;\n            if (VAR_13 && VAR_1.protocolVersion() == VAR_15.HTTP_1_1) {\n                if (VAR_16) {\n                    /* COMMENT_17 */\n                    String VAR_17 = null;\n                    for (String VAR_18 : VAR_11) {\n                        String[] VAR_19 = VAR_20.split(VAR_18, -1);\n                        for (String VAR_21 : VAR_19) {\n                            String VAR_22 = VAR_21.trim();\n                            if (VAR_17 == null) {\n                                VAR_17 = VAR_22;\n                            } else if (!VAR_22.equals(VAR_17)) {\n                                throw new IllegalArgumentException(\n                                        \"Multiple Content-Length values found: \" + VAR_11);\n                            }\n                        }\n                    }\n                    /* COMMENT_18 */\n                    VAR_2.set(VAR_12.CONTENT_LENGTH, VAR_17);\n                    VAR_23 = VAR_24.parseLong(VAR_17);\n                } else {\n                    /* COMMENT_19 */\n                    throw new IllegalArgumentException(\n                            \"Multiple Content-Length values found: \" + VAR_11);\n                }\n            } else {\n                VAR_23 = VAR_24.parseLong(VAR_11.get(0));\n            }\n        }\n\n        if (isContentAlwaysEmpty(VAR_1)) {\n            VAR_25.setTransferEncodingChunked(VAR_1, false);\n            return VAR_26.SKIP_CONTROL_CHARS;\n        } else if (VAR_25.isTransferEncodingChunked(VAR_1)) {\n            if (!VAR_11.isEmpty() && VAR_1.protocolVersion() == VAR_15.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(VAR_1);\n            }\n            return VAR_26.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return VAR_26.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return VAR_26.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }",
    "func_graph_path_before": "netty/89c241e3b1795ff257af4ad6eadc616cb2fb3dc4/HttpObjectDecoder.java/vul/before/0.json",
    "func": "private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        if (!contentLengthFields.isEmpty()) {\n            HttpVersion version = message.protocolVersion();\n            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n                    && version.minorVersion() == 0);\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n                    isHttp10OrEarlier, allowDuplicateContentLengths);\n            if (contentLength != -1) {\n                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n            }\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }",
    "abstract_func": "private State readHeaders(ByteBuf VAR_0) {\n        final HttpMessage VAR_1 = this.message;\n        final HttpHeaders VAR_2 = VAR_1.headers();\n\n        AppendableCharSequence VAR_3 = VAR_4.parse(VAR_0);\n        if (VAR_3 == null) {\n            return null;\n        }\n        if (VAR_3.length() > 0) {\n            do {\n                char VAR_5 = VAR_3.charAtUnsafe(0);\n                if (VAR_6 != null && (VAR_5 == ' ' || VAR_5 == '\\t')) {\n                    /* COMMENT_0 */\n                    /* COMMENT_1 */\n                    String VAR_7 = VAR_3.toString().trim();\n                    String VAR_8 = VAR_9.valueOf(VAR_10);\n                    VAR_10 = VAR_8 + ' ' + VAR_7;\n                } else {\n                    if (VAR_6 != null) {\n                        VAR_2.add(VAR_6, VAR_10);\n                    }\n                    splitHeader(VAR_3);\n                }\n\n                VAR_3 = VAR_4.parse(VAR_0);\n                if (VAR_3 == null) {\n                    return null;\n                }\n            } while (VAR_3.length() > 0);\n        }\n\n        /* COMMENT_2 */\n        if (VAR_6 != null) {\n            VAR_2.add(VAR_6, VAR_10);\n        }\n\n        /* COMMENT_3 */\n        VAR_6 = null;\n        VAR_10 = null;\n\n        List<String> VAR_11 = VAR_2.getAll(VAR_12.CONTENT_LENGTH);\n        if (!VAR_11.isEmpty()) {\n            HttpVersion VAR_13 = VAR_1.protocolVersion();\n            boolean VAR_14 = VAR_13.majorVersion() < 1 || (VAR_13.majorVersion() == 1\n                    && VAR_13.minorVersion() == 0);\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            VAR_15 = VAR_16.normalizeAndGetContentLength(VAR_11,\n                    VAR_14, VAR_17);\n            if (VAR_15 != -1) {\n                VAR_2.set(VAR_12.CONTENT_LENGTH, VAR_15);\n            }\n        }\n\n        if (isContentAlwaysEmpty(VAR_1)) {\n            VAR_16.setTransferEncodingChunked(VAR_1, false);\n            return VAR_18.SKIP_CONTROL_CHARS;\n        } else if (VAR_16.isTransferEncodingChunked(VAR_1)) {\n            if (!VAR_11.isEmpty() && VAR_1.protocolVersion() == VAR_19.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(VAR_1);\n            }\n            return VAR_18.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return VAR_18.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return VAR_18.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }",
    "func_graph_path": "netty/89c241e3b1795ff257af4ad6eadc616cb2fb3dc4/HttpObjectDecoder.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -39,49 +39,16 @@\n         value = null;\n \n         List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n-\n         if (!contentLengthFields.isEmpty()) {\n+            HttpVersion version = message.protocolVersion();\n+            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n+                    && version.minorVersion() == 0);\n             // Guard against multiple Content-Length headers as stated in\n             // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n-            //\n-            // If a message is received that has multiple Content-Length header\n-            //   fields with field-values consisting of the same decimal value, or a\n-            //   single Content-Length header field with a field value containing a\n-            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n-            //   indicating that duplicate Content-Length header fields have been\n-            //   generated or combined by an upstream message processor, then the\n-            //   recipient MUST either reject the message as invalid or replace the\n-            //   duplicated field-values with a single valid Content-Length field\n-            //   containing that decimal value prior to determining the message body\n-            //   length or forwarding the message.\n-            boolean multipleContentLengths =\n-                    contentLengthFields.size() > 1 || contentLengthFields.get(0).indexOf(COMMA) >= 0;\n-            if (multipleContentLengths && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n-                if (allowDuplicateContentLengths) {\n-                    // Find and enforce that all Content-Length values are the same\n-                    String firstValue = null;\n-                    for (String field : contentLengthFields) {\n-                        String[] tokens = COMMA_PATTERN.split(field, -1);\n-                        for (String token : tokens) {\n-                            String trimmed = token.trim();\n-                            if (firstValue == null) {\n-                                firstValue = trimmed;\n-                            } else if (!trimmed.equals(firstValue)) {\n-                                throw new IllegalArgumentException(\n-                                        \"Multiple Content-Length values found: \" + contentLengthFields);\n-                            }\n-                        }\n-                    }\n-                    // Replace the duplicated field-values with a single valid Content-Length field\n-                    headers.set(HttpHeaderNames.CONTENT_LENGTH, firstValue);\n-                    contentLength = Long.parseLong(firstValue);\n-                } else {\n-                    // Reject the message as invalid\n-                    throw new IllegalArgumentException(\n-                            \"Multiple Content-Length values found: \" + contentLengthFields);\n-                }\n-            } else {\n-                contentLength = Long.parseLong(contentLengthFields.get(0));\n+            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n+                    isHttp10OrEarlier, allowDuplicateContentLengths);\n+            if (contentLength != -1) {\n+                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n             }\n         }\n ",
    "diff_line_info": {
        "deleted_lines": [
            "",
            "            //",
            "            // If a message is received that has multiple Content-Length header",
            "            //   fields with field-values consisting of the same decimal value, or a",
            "            //   single Content-Length header field with a field value containing a",
            "            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),",
            "            //   indicating that duplicate Content-Length header fields have been",
            "            //   generated or combined by an upstream message processor, then the",
            "            //   recipient MUST either reject the message as invalid or replace the",
            "            //   duplicated field-values with a single valid Content-Length field",
            "            //   containing that decimal value prior to determining the message body",
            "            //   length or forwarding the message.",
            "            boolean multipleContentLengths =",
            "                    contentLengthFields.size() > 1 || contentLengthFields.get(0).indexOf(COMMA) >= 0;",
            "            if (multipleContentLengths && message.protocolVersion() == HttpVersion.HTTP_1_1) {",
            "                if (allowDuplicateContentLengths) {",
            "                    // Find and enforce that all Content-Length values are the same",
            "                    String firstValue = null;",
            "                    for (String field : contentLengthFields) {",
            "                        String[] tokens = COMMA_PATTERN.split(field, -1);",
            "                        for (String token : tokens) {",
            "                            String trimmed = token.trim();",
            "                            if (firstValue == null) {",
            "                                firstValue = trimmed;",
            "                            } else if (!trimmed.equals(firstValue)) {",
            "                                throw new IllegalArgumentException(",
            "                                        \"Multiple Content-Length values found: \" + contentLengthFields);",
            "                            }",
            "                        }",
            "                    }",
            "                    // Replace the duplicated field-values with a single valid Content-Length field",
            "                    headers.set(HttpHeaderNames.CONTENT_LENGTH, firstValue);",
            "                    contentLength = Long.parseLong(firstValue);",
            "                } else {",
            "                    // Reject the message as invalid",
            "                    throw new IllegalArgumentException(",
            "                            \"Multiple Content-Length values found: \" + contentLengthFields);",
            "                }",
            "            } else {",
            "                contentLength = Long.parseLong(contentLengthFields.get(0));"
        ],
        "added_lines": [
            "            HttpVersion version = message.protocolVersion();",
            "            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1",
            "                    && version.minorVersion() == 0);",
            "            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,",
            "                    isHttp10OrEarlier, allowDuplicateContentLengths);",
            "            if (contentLength != -1) {",
            "                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}