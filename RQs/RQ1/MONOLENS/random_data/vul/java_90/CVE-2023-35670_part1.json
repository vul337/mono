{
    "cve_id": "CVE-2023-35670",
    "cwe_ids": [
        "CWE-22"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "android",
    "commit_msg": "Canonicalize file path for insertion by legacy apps\n\nApps with legacy external storage can try to create entries in MP for\nfile paths in other apps external private directories by using a\nnon-canonical path in insertion calls.\n\nTest: atest LegacyStorageHostTest#testInsertToOtherAppPrivateDirFails\nBug: 276898626\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3c0f583f5dc3f4d395fa2423ab72dbd902c0c6c8)\nMerged-In: If4c941c8156f19459b3ec6cbaf705824ecc2ba77\nChange-Id: If4c941c8156f19459b3ec6cbaf705824ecc2ba77\n",
    "commit_hash": "db3c69afcb0a45c8aa2f333fcde36217889899fe",
    "git_url": "https://android.googlesource.com/platform/packages/providers/MediaProvider/+/db3c69afcb0a45c8aa2f333fcde36217889899fe",
    "file_path": "src/com/android/providers/media/util/FileUtils.java",
    "func_name": "computeValuesFromData",
    "func_before": "public static void computeValuesFromData(@NonNull ContentValues values, boolean isForFuse) {\n        // Worst case we have to assume no bucket details\n        values.remove(MediaColumns.VOLUME_NAME);\n        values.remove(MediaColumns.RELATIVE_PATH);\n        values.remove(MediaColumns.IS_TRASHED);\n        values.remove(MediaColumns.DATE_EXPIRES);\n        values.remove(MediaColumns.DISPLAY_NAME);\n        values.remove(MediaColumns.BUCKET_ID);\n        values.remove(MediaColumns.BUCKET_DISPLAY_NAME);\n\n        final String data = values.getAsString(MediaColumns.DATA);\n        if (TextUtils.isEmpty(data)) return;\n\n        final File file = new File(data);\n        final File fileLower = new File(data.toLowerCase(Locale.ROOT));\n\n        values.put(MediaColumns.VOLUME_NAME, extractVolumeName(data));\n        values.put(MediaColumns.RELATIVE_PATH, extractRelativePath(data));\n        final String displayName = extractDisplayName(data);\n        final Matcher matcher = FileUtils.PATTERN_EXPIRES_FILE.matcher(displayName);\n        if (matcher.matches()) {\n            values.put(MediaColumns.IS_PENDING,\n                    matcher.group(1).equals(FileUtils.PREFIX_PENDING) ? 1 : 0);\n            values.put(MediaColumns.IS_TRASHED,\n                    matcher.group(1).equals(FileUtils.PREFIX_TRASHED) ? 1 : 0);\n            values.put(MediaColumns.DATE_EXPIRES, Long.parseLong(matcher.group(2)));\n            values.put(MediaColumns.DISPLAY_NAME, matcher.group(3));\n        } else {\n            if (isForFuse) {\n                // Allow Fuse thread to set IS_PENDING when using DATA column.\n                // TODO(b/156867379) Unset IS_PENDING when Fuse thread doesn't explicitly specify\n                // IS_PENDING. It can't be done now because we scan after create. Scan doesn't\n                // explicitly specify the value of IS_PENDING.\n            } else {\n                values.put(MediaColumns.IS_PENDING, 0);\n            }\n            values.put(MediaColumns.IS_TRASHED, 0);\n            values.putNull(MediaColumns.DATE_EXPIRES);\n            values.put(MediaColumns.DISPLAY_NAME, displayName);\n        }\n\n        // Buckets are the parent directory\n        final String parent = fileLower.getParent();\n        if (parent != null) {\n            values.put(MediaColumns.BUCKET_ID, parent.hashCode());\n            // The relative path for files in the top directory is \"/\"\n            if (!\"/\".equals(values.getAsString(MediaColumns.RELATIVE_PATH))) {\n                values.put(MediaColumns.BUCKET_DISPLAY_NAME, file.getParentFile().getName());\n            } else {\n                values.putNull(MediaColumns.BUCKET_DISPLAY_NAME);\n            }\n        }\n    }",
    "abstract_func_before": "public static void computeValuesFromData(@NonNull ContentValues VAR_0, boolean VAR_1) {\n        /* COMMENT_0 */\n        VAR_0.remove(VAR_2.VOLUME_NAME);\n        VAR_0.remove(VAR_2.RELATIVE_PATH);\n        VAR_0.remove(VAR_2.IS_TRASHED);\n        VAR_0.remove(VAR_2.DATE_EXPIRES);\n        VAR_0.remove(VAR_2.DISPLAY_NAME);\n        VAR_0.remove(VAR_2.BUCKET_ID);\n        VAR_0.remove(VAR_2.BUCKET_DISPLAY_NAME);\n\n        final String VAR_3 = VAR_0.getAsString(VAR_2.DATA);\n        if (VAR_4.isEmpty(VAR_3)) return;\n\n        final File VAR_5 = new File(VAR_3);\n        final File VAR_6 = new File(VAR_3.toLowerCase(VAR_7.ROOT));\n\n        VAR_0.put(VAR_2.VOLUME_NAME, extractVolumeName(VAR_3));\n        VAR_0.put(VAR_2.RELATIVE_PATH, extractRelativePath(VAR_3));\n        final String VAR_8 = extractDisplayName(VAR_3);\n        final Matcher VAR_9 = VAR_10.PATTERN_EXPIRES_FILE.matcher(VAR_8);\n        if (VAR_9.matches()) {\n            VAR_0.put(VAR_2.IS_PENDING,\n                    VAR_9.group(1).equals(VAR_10.PREFIX_PENDING) ? 1 : 0);\n            VAR_0.put(VAR_2.IS_TRASHED,\n                    VAR_9.group(1).equals(VAR_10.PREFIX_TRASHED) ? 1 : 0);\n            VAR_0.put(VAR_2.DATE_EXPIRES, VAR_11.parseLong(VAR_9.group(2)));\n            VAR_0.put(VAR_2.DISPLAY_NAME, VAR_9.group(3));\n        } else {\n            if (VAR_1) {\n                /* COMMENT_1 */\n                /* COMMENT_2 */\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n            } else {\n                VAR_0.put(VAR_2.IS_PENDING, 0);\n            }\n            VAR_0.put(VAR_2.IS_TRASHED, 0);\n            VAR_0.putNull(VAR_2.DATE_EXPIRES);\n            VAR_0.put(VAR_2.DISPLAY_NAME, VAR_8);\n        }\n\n        /* COMMENT_5 */\n        final String VAR_12 = VAR_6.getParent();\n        if (VAR_12 != null) {\n            VAR_0.put(VAR_2.BUCKET_ID, VAR_12.hashCode());\n            /* COMMENT_6 */\n            if (!\"/\".equals(VAR_0.getAsString(VAR_2.RELATIVE_PATH))) {\n                VAR_0.put(VAR_2.BUCKET_DISPLAY_NAME, VAR_5.getParentFile().getName());\n            } else {\n                VAR_0.putNull(VAR_2.BUCKET_DISPLAY_NAME);\n            }\n        }\n    }",
    "func_graph_path_before": "android/db3c69afcb0a45c8aa2f333fcde36217889899fe/FileUtils.java/vul/before/0.json",
    "func": "public static void computeValuesFromData(@NonNull ContentValues values, boolean isForFuse) {\n        // Worst case we have to assume no bucket details\n        values.remove(MediaColumns.VOLUME_NAME);\n        values.remove(MediaColumns.RELATIVE_PATH);\n        values.remove(MediaColumns.IS_TRASHED);\n        values.remove(MediaColumns.DATE_EXPIRES);\n        values.remove(MediaColumns.DISPLAY_NAME);\n        values.remove(MediaColumns.BUCKET_ID);\n        values.remove(MediaColumns.BUCKET_DISPLAY_NAME);\n\n        String data = values.getAsString(MediaColumns.DATA);\n        if (TextUtils.isEmpty(data)) return;\n\n        try {\n            data = new File(data).getCanonicalPath();\n            values.put(MediaColumns.DATA, data);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(\n                    String.format(Locale.ROOT, \"Invalid file path:%s in request.\", data));\n        }\n\n        final File file = new File(data);\n        final File fileLower = new File(data.toLowerCase(Locale.ROOT));\n\n        values.put(MediaColumns.VOLUME_NAME, extractVolumeName(data));\n        values.put(MediaColumns.RELATIVE_PATH, extractRelativePath(data));\n        final String displayName = extractDisplayName(data);\n        final Matcher matcher = FileUtils.PATTERN_EXPIRES_FILE.matcher(displayName);\n        if (matcher.matches()) {\n            values.put(MediaColumns.IS_PENDING,\n                    matcher.group(1).equals(FileUtils.PREFIX_PENDING) ? 1 : 0);\n            values.put(MediaColumns.IS_TRASHED,\n                    matcher.group(1).equals(FileUtils.PREFIX_TRASHED) ? 1 : 0);\n            values.put(MediaColumns.DATE_EXPIRES, Long.parseLong(matcher.group(2)));\n            values.put(MediaColumns.DISPLAY_NAME, matcher.group(3));\n        } else {\n            if (isForFuse) {\n                // Allow Fuse thread to set IS_PENDING when using DATA column.\n                // TODO(b/156867379) Unset IS_PENDING when Fuse thread doesn't explicitly specify\n                // IS_PENDING. It can't be done now because we scan after create. Scan doesn't\n                // explicitly specify the value of IS_PENDING.\n            } else {\n                values.put(MediaColumns.IS_PENDING, 0);\n            }\n            values.put(MediaColumns.IS_TRASHED, 0);\n            values.putNull(MediaColumns.DATE_EXPIRES);\n            values.put(MediaColumns.DISPLAY_NAME, displayName);\n        }\n\n        // Buckets are the parent directory\n        final String parent = fileLower.getParent();\n        if (parent != null) {\n            values.put(MediaColumns.BUCKET_ID, parent.hashCode());\n            // The relative path for files in the top directory is \"/\"\n            if (!\"/\".equals(values.getAsString(MediaColumns.RELATIVE_PATH))) {\n                values.put(MediaColumns.BUCKET_DISPLAY_NAME, file.getParentFile().getName());\n            } else {\n                values.putNull(MediaColumns.BUCKET_DISPLAY_NAME);\n            }\n        }\n    }",
    "abstract_func": "public static void computeValuesFromData(@NonNull ContentValues VAR_0, boolean VAR_1) {\n        /* COMMENT_0 */\n        VAR_0.remove(VAR_2.VOLUME_NAME);\n        VAR_0.remove(VAR_2.RELATIVE_PATH);\n        VAR_0.remove(VAR_2.IS_TRASHED);\n        VAR_0.remove(VAR_2.DATE_EXPIRES);\n        VAR_0.remove(VAR_2.DISPLAY_NAME);\n        VAR_0.remove(VAR_2.BUCKET_ID);\n        VAR_0.remove(VAR_2.BUCKET_DISPLAY_NAME);\n\n        String VAR_3 = VAR_0.getAsString(VAR_2.DATA);\n        if (VAR_4.isEmpty(VAR_3)) return;\n\n        try {\n            VAR_3 = new File(VAR_3).getCanonicalPath();\n            VAR_0.put(VAR_2.DATA, VAR_3);\n        } catch (IOException VAR_5) {\n            throw new IllegalArgumentException(\n                    VAR_6.format(VAR_7.ROOT, \"Invalid file path:%s in request.\", VAR_3));\n        }\n\n        final File VAR_8 = new File(VAR_3);\n        final File VAR_9 = new File(VAR_3.toLowerCase(VAR_7.ROOT));\n\n        VAR_0.put(VAR_2.VOLUME_NAME, extractVolumeName(VAR_3));\n        VAR_0.put(VAR_2.RELATIVE_PATH, extractRelativePath(VAR_3));\n        final String VAR_10 = extractDisplayName(VAR_3);\n        final Matcher VAR_11 = VAR_12.PATTERN_EXPIRES_FILE.matcher(VAR_10);\n        if (VAR_11.matches()) {\n            VAR_0.put(VAR_2.IS_PENDING,\n                    VAR_11.group(1).equals(VAR_12.PREFIX_PENDING) ? 1 : 0);\n            VAR_0.put(VAR_2.IS_TRASHED,\n                    VAR_11.group(1).equals(VAR_12.PREFIX_TRASHED) ? 1 : 0);\n            VAR_0.put(VAR_2.DATE_EXPIRES, VAR_13.parseLong(VAR_11.group(2)));\n            VAR_0.put(VAR_2.DISPLAY_NAME, VAR_11.group(3));\n        } else {\n            if (VAR_1) {\n                /* COMMENT_1 */\n                /* COMMENT_2 */\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n            } else {\n                VAR_0.put(VAR_2.IS_PENDING, 0);\n            }\n            VAR_0.put(VAR_2.IS_TRASHED, 0);\n            VAR_0.putNull(VAR_2.DATE_EXPIRES);\n            VAR_0.put(VAR_2.DISPLAY_NAME, VAR_10);\n        }\n\n        /* COMMENT_5 */\n        final String VAR_14 = VAR_9.getParent();\n        if (VAR_14 != null) {\n            VAR_0.put(VAR_2.BUCKET_ID, VAR_14.hashCode());\n            /* COMMENT_6 */\n            if (!\"/\".equals(VAR_0.getAsString(VAR_2.RELATIVE_PATH))) {\n                VAR_0.put(VAR_2.BUCKET_DISPLAY_NAME, VAR_8.getParentFile().getName());\n            } else {\n                VAR_0.putNull(VAR_2.BUCKET_DISPLAY_NAME);\n            }\n        }\n    }",
    "func_graph_path": "android/db3c69afcb0a45c8aa2f333fcde36217889899fe/FileUtils.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,16 @@\n         values.remove(MediaColumns.BUCKET_ID);\n         values.remove(MediaColumns.BUCKET_DISPLAY_NAME);\n \n-        final String data = values.getAsString(MediaColumns.DATA);\n+        String data = values.getAsString(MediaColumns.DATA);\n         if (TextUtils.isEmpty(data)) return;\n+\n+        try {\n+            data = new File(data).getCanonicalPath();\n+            values.put(MediaColumns.DATA, data);\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(\n+                    String.format(Locale.ROOT, \"Invalid file path:%s in request.\", data));\n+        }\n \n         final File file = new File(data);\n         final File fileLower = new File(data.toLowerCase(Locale.ROOT));",
    "diff_line_info": {
        "deleted_lines": [
            "        final String data = values.getAsString(MediaColumns.DATA);"
        ],
        "added_lines": [
            "        String data = values.getAsString(MediaColumns.DATA);",
            "",
            "        try {",
            "            data = new File(data).getCanonicalPath();",
            "            values.put(MediaColumns.DATA, data);",
            "        } catch (IOException e) {",
            "            throw new IllegalArgumentException(",
            "                    String.format(Locale.ROOT, \"Invalid file path:%s in request.\", data));",
            "        }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}