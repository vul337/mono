{
    "cve_id": "CVE-2018-9493",
    "cwe_ids": [
        "CWE-89"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "android",
    "commit_msg": "DO NOT MERGE. Extend SQLiteQueryBuilder for update and delete.\n\nDevelopers often accept selection clauses from untrusted code, and\nSQLiteQueryBuilder already supports a \"strict\" mode to help catch\nSQL injection attacks.  This change extends the builder to support\nupdate() and delete() calls, so that we can help secure those\nselection clauses too.\n\nBug: 111085900\nTest: atest packages/providers/DownloadProvider/tests/\nTest: atest cts/tests/app/src/android/app/cts/DownloadManagerTest.java\nTest: atest cts/tests/tests/database/src/android/database/sqlite/cts/SQLiteQueryBuilderTest.java\nChange-Id: Ib4fc8400f184755ee7e971ab5f2095186341730c\nMerged-In: Ib4fc8400f184755ee7e971ab5f2095186341730c\n(cherry picked from commit 506994268bc4fa07d8798b7737a2952f74b8fd04)\n",
    "commit_hash": "ebc250d16c747f4161167b5ff58b3aea88b37acf",
    "git_url": "https://android.googlesource.com/platform/frameworks/base/+/ebc250d16c747f4161167b5ff58b3aea88b37acf",
    "file_path": "core/java/android/database/sqlite/SQLiteQueryBuilder.java",
    "func_name": "query",
    "func_before": "public Cursor query(SQLiteDatabase db, String[] projectionIn,\n            String selection, String[] selectionArgs, String groupBy,\n            String having, String sortOrder, String limit, CancellationSignal cancellationSignal) {\n        if (mTables == null) {\n            return null;\n        }\n\n        final String sql;\n        final String unwrappedSql = buildQuery(\n                projectionIn, selection, groupBy, having,\n                sortOrder, limit);\n\n        if (mStrict && selection != null && selection.length() > 0) {\n            // Validate the user-supplied selection to detect syntactic anomalies\n            // in the selection string that could indicate a SQL injection attempt.\n            // The idea is to ensure that the selection clause is a valid SQL expression\n            // by compiling it twice: once wrapped in parentheses and once as\n            // originally specified. An attacker cannot create an expression that\n            // would escape the SQL expression while maintaining balanced parentheses\n            // in both the wrapped and original forms.\n\n            // NOTE: The ordering of the below operations is important; we must\n            // execute the wrapped query to ensure the untrusted clause has been\n            // fully isolated.\n\n            // Validate the unwrapped query\n            db.validateSql(unwrappedSql, cancellationSignal); // will throw if query is invalid\n\n            // Execute wrapped query for extra protection\n            final String wrappedSql = buildQuery(projectionIn, \"(\" + selection + \")\", groupBy,\n                    having, sortOrder, limit);\n            sql = wrappedSql;\n        } else {\n            // Execute unwrapped query\n            sql = unwrappedSql;\n        }\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Performing query: \" + sql);\n        }\n        return db.rawQueryWithFactory(\n                mFactory, sql, selectionArgs,\n                SQLiteDatabase.findEditTable(mTables),\n                cancellationSignal); // will throw if query is invalid\n    }",
    "abstract_func_before": "public Cursor query(SQLiteDatabase VAR_0, String[] VAR_1,\n            String VAR_2, String[] VAR_3, String VAR_4,\n            String VAR_5, String VAR_6, String VAR_7, CancellationSignal VAR_8) {\n        if (VAR_9 == null) {\n            return null;\n        }\n\n        final String VAR_10;\n        final String VAR_11 = buildQuery(\n                VAR_1, VAR_2, VAR_4, VAR_5,\n                VAR_6, VAR_7);\n\n        if (VAR_12 && VAR_2 != null && VAR_2.length() > 0) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n\n            /* COMMENT_10 */\n            VAR_0.validateSql(VAR_11, VAR_8); /* COMMENT_11 */\n\n            /* COMMENT_12 */\n            final String VAR_13 = buildQuery(VAR_1, \"(\" + VAR_2 + \")\", VAR_4,\n                    VAR_5, VAR_6, VAR_7);\n            VAR_10 = VAR_13;\n        } else {\n            /* COMMENT_13 */\n            VAR_10 = VAR_11;\n        }\n\n        if (VAR_14.isLoggable(VAR_15, VAR_14.DEBUG)) {\n            VAR_14.d(VAR_15, \"Performing query: \" + VAR_10);\n        }\n        return VAR_0.rawQueryWithFactory(\n                VAR_16, VAR_10, VAR_3,\n                VAR_17.findEditTable(VAR_9),\n                VAR_8); /* COMMENT_11 */\n    }",
    "func_graph_path_before": "android/ebc250d16c747f4161167b5ff58b3aea88b37acf/SQLiteQueryBuilder.java/vul/before/0.json",
    "func": "public Cursor query(SQLiteDatabase db, String[] projectionIn,\n            String selection, String[] selectionArgs, String groupBy,\n            String having, String sortOrder, String limit, CancellationSignal cancellationSignal) {\n        if (mTables == null) {\n            return null;\n        }\n\n        final String sql;\n        final String unwrappedSql = buildQuery(\n                projectionIn, selection, groupBy, having,\n                sortOrder, limit);\n\n        if (mStrict && selection != null && selection.length() > 0) {\n            // Validate the user-supplied selection to detect syntactic anomalies\n            // in the selection string that could indicate a SQL injection attempt.\n            // The idea is to ensure that the selection clause is a valid SQL expression\n            // by compiling it twice: once wrapped in parentheses and once as\n            // originally specified. An attacker cannot create an expression that\n            // would escape the SQL expression while maintaining balanced parentheses\n            // in both the wrapped and original forms.\n\n            // NOTE: The ordering of the below operations is important; we must\n            // execute the wrapped query to ensure the untrusted clause has been\n            // fully isolated.\n\n            // Validate the unwrapped query\n            db.validateSql(unwrappedSql, cancellationSignal); // will throw if query is invalid\n\n            // Execute wrapped query for extra protection\n            final String wrappedSql = buildQuery(projectionIn, wrap(selection), groupBy,\n                    having, sortOrder, limit);\n            sql = wrappedSql;\n        } else {\n            // Execute unwrapped query\n            sql = unwrappedSql;\n        }\n\n        final String[] sqlArgs = selectionArgs;\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            if (Build.IS_DEBUGGABLE) {\n                Log.d(TAG, sql + \" with args \" + Arrays.toString(sqlArgs));\n            } else {\n                Log.d(TAG, sql);\n            }\n        }\n        return db.rawQueryWithFactory(\n                mFactory, sql, sqlArgs,\n                SQLiteDatabase.findEditTable(mTables),\n                cancellationSignal); // will throw if query is invalid\n    }",
    "abstract_func": "public Cursor query(SQLiteDatabase VAR_0, String[] VAR_1,\n            String VAR_2, String[] VAR_3, String VAR_4,\n            String VAR_5, String VAR_6, String VAR_7, CancellationSignal VAR_8) {\n        if (VAR_9 == null) {\n            return null;\n        }\n\n        final String VAR_10;\n        final String VAR_11 = buildQuery(\n                VAR_1, VAR_2, VAR_4, VAR_5,\n                VAR_6, VAR_7);\n\n        if (VAR_12 && VAR_2 != null && VAR_2.length() > 0) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n\n            /* COMMENT_10 */\n            VAR_0.validateSql(VAR_11, VAR_8); /* COMMENT_11 */\n\n            /* COMMENT_12 */\n            final String VAR_13 = buildQuery(VAR_1, wrap(VAR_2), VAR_4,\n                    VAR_5, VAR_6, VAR_7);\n            VAR_10 = VAR_13;\n        } else {\n            /* COMMENT_13 */\n            VAR_10 = VAR_11;\n        }\n\n        final String[] VAR_14 = VAR_3;\n        if (VAR_15.isLoggable(VAR_16, VAR_15.DEBUG)) {\n            if (VAR_17.IS_DEBUGGABLE) {\n                VAR_15.d(VAR_16, VAR_10 + \" with args \" + VAR_18.toString(VAR_14));\n            } else {\n                VAR_15.d(VAR_16, VAR_10);\n            }\n        }\n        return VAR_0.rawQueryWithFactory(\n                VAR_19, VAR_10, VAR_14,\n                VAR_20.findEditTable(VAR_9),\n                VAR_8); /* COMMENT_11 */\n    }",
    "func_graph_path": "android/ebc250d16c747f4161167b5ff58b3aea88b37acf/SQLiteQueryBuilder.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n             db.validateSql(unwrappedSql, cancellationSignal); // will throw if query is invalid\n \n             // Execute wrapped query for extra protection\n-            final String wrappedSql = buildQuery(projectionIn, \"(\" + selection + \")\", groupBy,\n+            final String wrappedSql = buildQuery(projectionIn, wrap(selection), groupBy,\n                     having, sortOrder, limit);\n             sql = wrappedSql;\n         } else {\n@@ -35,11 +35,16 @@\n             sql = unwrappedSql;\n         }\n \n+        final String[] sqlArgs = selectionArgs;\n         if (Log.isLoggable(TAG, Log.DEBUG)) {\n-            Log.d(TAG, \"Performing query: \" + sql);\n+            if (Build.IS_DEBUGGABLE) {\n+                Log.d(TAG, sql + \" with args \" + Arrays.toString(sqlArgs));\n+            } else {\n+                Log.d(TAG, sql);\n+            }\n         }\n         return db.rawQueryWithFactory(\n-                mFactory, sql, selectionArgs,\n+                mFactory, sql, sqlArgs,\n                 SQLiteDatabase.findEditTable(mTables),\n                 cancellationSignal); // will throw if query is invalid\n     }",
    "diff_line_info": {
        "deleted_lines": [
            "            final String wrappedSql = buildQuery(projectionIn, \"(\" + selection + \")\", groupBy,",
            "            Log.d(TAG, \"Performing query: \" + sql);",
            "                mFactory, sql, selectionArgs,"
        ],
        "added_lines": [
            "            final String wrappedSql = buildQuery(projectionIn, wrap(selection), groupBy,",
            "        final String[] sqlArgs = selectionArgs;",
            "            if (Build.IS_DEBUGGABLE) {",
            "                Log.d(TAG, sql + \" with args \" + Arrays.toString(sqlArgs));",
            "            } else {",
            "                Log.d(TAG, sql);",
            "            }",
            "                mFactory, sql, sqlArgs,"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}