{
    "cve_id": "CVE-2023-48795",
    "cwe_ids": [
        "CWE-354"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cvss_is_v3": true,
    "repo_name": "hierynomus/sshj",
    "commit_msg": "Implement OpenSSH strict key exchange extension",
    "commit_hash": "94fcc960e0fb198ddec0f7efc53f95ac627fe083",
    "git_url": "https://github.com/hierynomus/sshj/commit/94fcc960e0fb198ddec0f7efc53f95ac627fe083",
    "file_path": "src/main/java/net/schmizz/sshj/transport/TransportImpl.java",
    "func_name": "write",
    "func_before": "@Override\n    public long write(SSHPacket payload)\n            throws TransportException {\n        writeLock.lock();\n        try {\n\n            if (kexer.isKexOngoing()) {\n                // Only transport layer packets (1 to 49) allowed except SERVICE_REQUEST\n                final Message m = Message.fromByte(payload.array()[payload.rpos()]);\n                if (!m.in(1, 49) || m == Message.SERVICE_REQUEST) {\n                    assert m != Message.KEXINIT;\n                    kexer.waitForDone();\n                }\n            } else if (encoder.getSequenceNumber() == 0) // We get here every 2**32th packet\n                kexer.startKex(true);\n\n            final long seq = encoder.encode(payload);\n            try {\n                connInfo.out.write(payload.array(), payload.rpos(), payload.available());\n                connInfo.out.flush();\n            } catch (IOException ioe) {\n                throw new TransportException(ioe);\n            }\n\n            return seq;\n\n        } finally {\n            writeLock.unlock();\n        }\n    }",
    "abstract_func_before": "@Override\n    public long write(SSHPacket VAR_0)\n            throws TransportException {\n        VAR_1.lock();\n        try {\n\n            if (VAR_2.isKexOngoing()) {\n                /* COMMENT_0 */\n                final Message VAR_3 = VAR_4.fromByte(VAR_0.array()[VAR_0.rpos()]);\n                if (!VAR_3.in(1, 49) || VAR_3 == VAR_4.SERVICE_REQUEST) {\n                    assert VAR_3 != VAR_4.KEXINIT;\n                    VAR_2.waitForDone();\n                }\n            } else if (VAR_5.getSequenceNumber() == 0) /* COMMENT_1 */\n                VAR_2.startKex(true);\n\n            final long VAR_6 = VAR_5.encode(VAR_0);\n            try {\n                VAR_7.out.write(VAR_0.array(), VAR_0.rpos(), VAR_0.available());\n                VAR_7.out.flush();\n            } catch (IOException VAR_8) {\n                throw new TransportException(VAR_8);\n            }\n\n            return VAR_6;\n\n        } finally {\n            VAR_1.unlock();\n        }\n    }",
    "func_graph_path_before": "hierynomus/sshj/94fcc960e0fb198ddec0f7efc53f95ac627fe083/TransportImpl.java/vul/before/0.json",
    "func": "@Override\n    public long write(SSHPacket payload)\n            throws TransportException {\n        writeLock.lock();\n        try {\n\n            if (kexer.isKexOngoing()) {\n                // Only transport layer packets (1 to 49) allowed except SERVICE_REQUEST\n                final Message m = Message.fromByte(payload.array()[payload.rpos()]);\n                if (!m.in(1, 49) || m == Message.SERVICE_REQUEST) {\n                    assert m != Message.KEXINIT;\n                    kexer.waitForDone();\n                }\n            } else if (encoder.isSequenceNumberAtMax()) // We get here every 2**32th packet\n                kexer.startKex(true);\n\n            final long seq = encoder.encode(payload);\n            try {\n                connInfo.out.write(payload.array(), payload.rpos(), payload.available());\n                connInfo.out.flush();\n            } catch (IOException ioe) {\n                throw new TransportException(ioe);\n            }\n\n            return seq;\n\n        } finally {\n            writeLock.unlock();\n        }\n    }",
    "abstract_func": "@Override\n    public long write(SSHPacket VAR_0)\n            throws TransportException {\n        VAR_1.lock();\n        try {\n\n            if (VAR_2.isKexOngoing()) {\n                /* COMMENT_0 */\n                final Message VAR_3 = VAR_4.fromByte(VAR_0.array()[VAR_0.rpos()]);\n                if (!VAR_3.in(1, 49) || VAR_3 == VAR_4.SERVICE_REQUEST) {\n                    assert VAR_3 != VAR_4.KEXINIT;\n                    VAR_2.waitForDone();\n                }\n            } else if (VAR_5.isSequenceNumberAtMax()) /* COMMENT_1 */\n                VAR_2.startKex(true);\n\n            final long VAR_6 = VAR_5.encode(VAR_0);\n            try {\n                VAR_7.out.write(VAR_0.array(), VAR_0.rpos(), VAR_0.available());\n                VAR_7.out.flush();\n            } catch (IOException VAR_8) {\n                throw new TransportException(VAR_8);\n            }\n\n            return VAR_6;\n\n        } finally {\n            VAR_1.unlock();\n        }\n    }",
    "func_graph_path": "hierynomus/sshj/94fcc960e0fb198ddec0f7efc53f95ac627fe083/TransportImpl.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n                     assert m != Message.KEXINIT;\n                     kexer.waitForDone();\n                 }\n-            } else if (encoder.getSequenceNumber() == 0) // We get here every 2**32th packet\n+            } else if (encoder.isSequenceNumberAtMax()) // We get here every 2**32th packet\n                 kexer.startKex(true);\n \n             final long seq = encoder.encode(payload);",
    "diff_line_info": {
        "deleted_lines": [
            "            } else if (encoder.getSequenceNumber() == 0) // We get here every 2**32th packet"
        ],
        "added_lines": [
            "            } else if (encoder.isSequenceNumberAtMax()) // We get here every 2**32th packet"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/hierynomus/sshj/pull/917",
    "description": "Resolves #916 \r\n\r\nThe PR implements the algorithm described in section 1.9 of https://github.com/openssh/openssh-portable/blob/master/PROTOCOL and also follows the changes implemented in the commit https://github.com/openssh/openssh-portable/commit/1edb00c58f8a6875fad6a497aa2bacf37f9e6cd5.\r\n\r\nAll tests are successful. The integration tests work both against the current container and a custom built container with OpenSSH 9.6p1. When run against the latter, the log also show that the resets of sequence numbers are happening, and working correctly as otherwise ChaCha20-Poly1305 should break.\r\n\r\nThe jsch fork of mwiede also implemented config switches to disable or enforce the strict key exchange extension. But I'm not sure whether it makes sense to maintain such flags long term when OpenSSH itself doesn't have them: https://github.com/mwiede/jsch/pull/461\r\n\r\nThe Terrapin Scanner referenced in #916 is happy, but I think it only checks whether the additional pseudo-key exchange `kex-strict-c-v00@openssh.com` is being advertised by the client:\r\n\r\n```\r\n================================================================================\r\n==================================== Report ====================================\r\n================================================================================\r\n\r\nRemote Banner: SSH-2.0-SSHJ_0.18.0\r\n\r\nChaCha20-Poly1305 support:   true\r\nCBC-EtM support:             true\r\n\r\nStrict key exchange support: true\r\n\r\n==> The scanned peer supports Terrapin mitigations and can establish\r\n    connections that are NOT VULNERABLE to Terrapin. Glad to see this.\r\n    For strict key exchange to take effect, both peers must support it.\r\n\r\nNote: This tool is provided as is, with no warranty whatsoever. It determines\r\n      the vulnerability of a peer by checking the supported algorithms and\r\n      support for strict key exchange. It may falsely claim a peer to be\r\n      vulnerable if the vendor supports countermeasures other than strict key\r\n      exchange.\r\n\r\nFor more details visit our website available at https://terrapin-attack.com\r\n```\r\n\r\n"
}