{
    "cve_id": "CVE-2014-125071",
    "cwe_ids": [
        "CWE-346"
    ],
    "cvss_vector": "AV:A/AC:L/Au:S/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "lukehutch/gribbit",
    "commit_msg": "Protect against CSWSH: (Cross-Site WebSocket Hijacking)",
    "commit_hash": "620418df247aebda3dd4be1dda10fe229ea505dd",
    "git_url": "https://github.com/lukehutch/gribbit/commit/620418df247aebda3dd4be1dda10fe229ea505dd",
    "file_path": "src/gribbit/request/HttpRequestHandler.java",
    "func_name": "messageReceived",
    "func_before": "@Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\"REQUEST: \" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\"100-continue\")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\"UTF-8\") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                                }\n                            } else {\n                                Log.warning(\"Got unknown data chunk type: \" + httpDataType);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException e) {\n                    // Apparently decoder.hasNext() doesn't actually work\n                }\n\n                if (chunk instanceof LastHttpContent) {\n                    requestComplete = true;\n                }\n            }\n\n            if (!requestComplete) {\n                // Wait for more chunks.\n                // (Since requestComplete is false, calling return here will not call destroyDecoder()\n                // in the finally block, so it will still exist when the next chunk is received.)\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Figure out how to handle HTTP request\n            // ------------------------------------------------------------------------------\n\n            // All POST chunks have been received (or there are no chunks); ready to start handling the request\n\n            String origReqURI = request.getURI();\n\n            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.\n            // We only need to serve the resource at a hash URI once per resource per client, since resources served\n            // from hash URIs are indefinitely cached in the browser.\n            String hashKey = CacheExtension.getHashKey(origReqURI);\n            boolean isHashURI = hashKey != null;\n            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;\n\n            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();\n            if (requestor != null) {\n                InetAddress address = requestor.getAddress();\n                if (address != null) {\n                    request.setRequestor(address.getHostAddress());\n                }\n            }\n\n            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;\n\n            // Run the GET method if HEAD is requested, just don't return a body.\n            HttpMethod origReqMethod = request.getMethod();\n            if (isHEAD) {\n                request.setMethod(HttpMethod.GET);\n            }\n\n            // ------------------------------------------------------------------------------\n            // Authenticate user\n            // ------------------------------------------------------------------------------\n\n            // The response object generated by a RestHandler\n            Response response = null;\n\n            // Call route handlers until one is able to handle the route,\n            // or until we run out of handlers\n            User user = null;\n            RouteInfo authorizedRoute = null;\n            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();\n            for (int i = 0, n = allRoutes.size(); i < n; i++) {\n                RouteInfo route = allRoutes.get(i);\n                // If the request URI matches this route path\n                if (route.matches(reqURI)) {\n                    Class<? extends RouteHandler> handler = route.getHandler();\n\n                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {\n\n                        // We only support GET and POST at this point\n                        Log.error(\"Unsupported HTTP method \" + request.getMethod().name() + \" for path \" + reqURI);\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())\n                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {\n\n                        // Tried to call an HTTP method that is not defined for this route\n                        Log.error(\"HTTP method \" + request.getMethod().name() + \" not implemented in handler \"\n                                + handler.getName());\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {\n\n                        // This handler requires authentication -- check if user is logged in\n                        user = User.getLoggedInUser(request);\n                        if (user == null) {\n\n                            // User is not logged in: handle request with OnUnauthorized handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),\n                                            request, user)\n                                    // Redirect the user back to the page they were trying to get to once they\n                                    // do manage to log in successfully\n                                            .setCookie(\n                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \"/\", reqURI,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)\n                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations\n                    && reqURI.endsWith(\"/websocket\")) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Record which user was authenticated (if any) when websocket upgrade request was made.\n                // TODO: Reject WS upgrade request for websockets that require authentication.\n                // TODO: Also provide a means for revoking WS login.\n                wsAuthenticatedUser = User.getLoggedInUser(request);\n\n                WebSocketServerHandshakerFactory wsFactory =\n                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);\n                handshaker = wsFactory.newHandshaker(httpReq);\n                if (handshaker == null) {\n                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());\n                } else {\n                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket\n                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest\n                    DefaultFullHttpRequest fullReq =\n                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());\n                    fullReq.headers().add(httpReq.headers());\n                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);\n                }\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle static file requests\n            // ------------------------------------------------------------------------------\n\n            // If no error has occurred so far, and no route handler matched the request URI, and this is a\n            // GET request, then see if the URI points to a static file resource, and if so, serve the file.\n            if (response == null && authorizedRoute == null) {\n                // Static file requests can only use GET method\n                if (request.getMethod() != HttpMethod.GET) {\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n\n                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);\n                if (staticResourceFile == null) {\n\n                    // Neither a route handler nor a static resource matched the request URI.\n                    // Return 404 Not Found.\n                    response =\n                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,\n                                    user);\n\n                } else {\n\n                    // A static resource matched the request URI, check last-modified timestamp\n                    // against the If-Modified-Since header timestamp in the request.\n                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;\n                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                        // File has not been modified since it was last cached -- return Not Modified\n                        response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                    } else {\n                        // If file is newer than what is in the browser cache, or is not in cache, serve the file\n                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);\n\n                        Log.fine(request.getRequestor() + \"\\t\" + origReqMethod + \"\\t\" + reqURI + \"\\tfile://\"\n                                + staticResourceFile.getPath() + \"\\t\" + HttpResponseStatus.OK + \"\\t\"\n                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \" msec\");\n\n                        // Finished request\n                        return;\n                    }\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle GET or POST requests\n            // ------------------------------------------------------------------------------\n\n            ZonedDateTime timeNow = null;\n\n            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,\n            // then call the get() or post() method for the route handler bound to the request URI to obtain the\n            // response object.\n            boolean hashTheResponse = false;\n            long hashKeyRemainingAgeSeconds = 0;\n            if (response == null && authorizedRoute != null) {\n\n                // ----------------------------------\n                // See if response should be hashed\n                // ----------------------------------\n\n                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served\n                // content can't be read directly, so read the last modified timestamp stored for the\n                // previously hashed version in the CacheExtension class, as long as the max age of the\n                // cached version hasn't been exceeded, and see if the last modified timestamp is more\n                // recent than the version cached in the browser.\n                //\n                // The important ramification of this is that when the resource identified by the non-file\n                // URI changes, the CacheExtension class must be notified of that change (including in cases\n                // where the database is modified by another database client) if the modified version should\n                // start being served at a new hash URI immediately, otherwise the web client connected to\n                // this web server will continue to serve old resources until the max age of the cached\n                // content is exceeded.\n                if (isHashURI) {\n                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);\n                    if (hashInfo != null) {\n                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();\n                        timeNow = ZonedDateTime.now();\n                        long timeNowEpochSeconds = timeNow.toEpochSecond();\n\n                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();\n                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;\n\n                        if (maxAgeSeconds == 0) {\n                            // Content is not hash-cached\n                            hashKeyRemainingAgeSeconds = 0;\n                        }\n\n                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {\n                            // Resource has expired -- call the route handler to generate a new response rather\n                            // than serving a Not Modified response, and schedule the response to be hashed or\n                            // re-hashed once the response has been generated.\n                            hashTheResponse = true;\n\n                            // Reset the expiry time at the requested number of seconds in the future\n                            hashKeyRemainingAgeSeconds = maxAgeSeconds;\n\n                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // However, resource has not been modified since it was last hashed --\n                            // return Not Modified.\n                            response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                        } else {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // Resource *has* been modified since it was last hashed -- serve it the\n                            // normal way using the route handler, but don't hash the response, since\n                            // it has not expired yet.\n                        }\n                    } else {\n                        // There is no original URI matching this hash URI, so the hash key was stale\n                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from\n                        // the previous time the server was run), but we still got a valid request URI\n                        // by stripping away the hash code, so that is served below in the normal way.\n                    }\n                }\n\n                // If the response wasn't just set to \"Not Modified\" above, serve the request\n                if (response == null) {\n\n                    // -----------------------------------------------------------------\n                    // Call the route handler for this request, generating the response\n                    // -----------------------------------------------------------------\n\n                    response = getResponseForRoute(authorizedRoute, request, user);\n\n                    if (response == null) {\n                        // Should not happen\n                        throw new RuntimeException(\"Didn't generate a response\");\n                    }\n\n                }\n\n            }\n            if (response == null) {\n                // Should not happen\n                throw new RuntimeException(\"Didn't generate a response\");\n            }\n\n            // ------------------------------------------------------------------------------------\n            // Serve an HTTP result (except in the case of static files, they were served already)\n            // ------------------------------------------------------------------------------------\n\n            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.\n            if (timeNow == null) {\n                timeNow = ZonedDateTime.now();\n            }\n\n            // Serve the response to the client \n            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//\n                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);\n\n            // Log the request and response\n            HttpResponseStatus status = response.getStatus();\n            String logMsg =\n                    request.getRequestor() + \"\\t\" + origReqMethod + \"\\t\" + reqURI\n                            + (request.getMethod() == origReqMethod ? \"\" : \"\\t\" + request.getMethod()) + \"\\t\" + status\n                            + \"\\t\" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \" msec\";\n            if (status == HttpResponseStatus.OK //\n                    || status == HttpResponseStatus.NOT_MODIFIED //\n                    || status == HttpResponseStatus.FOUND //\n                    || (status == HttpResponseStatus.NOT_FOUND //\n                    && (reqURI.equals(\"favicon.ico\") || reqURI.endsWith(\"/favicon.ico\")))) {\n                // Log at level \"fine\" for non-errors, or 404 for favicon\n                Log.fine(logMsg);\n            } else {\n                // Log at level \"warning\" for errors, or 404 for non-favicon\n                Log.warningWithoutCallerRef(logMsg);\n            }\n\n        } finally {\n            if (requestComplete) {\n                // Finished request -- destroy the multipart decoder and remove temporary files\n                destroyDecoder();\n            }\n        }\n    }",
    "abstract_func_before": "@Override\n    public void messageReceived(ChannelHandlerContext VAR_0, Object VAR_1) throws Exception {\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_0 */\n\n        if (VAR_1 instanceof WebSocketFrame) {\n            handleWebsocketFrame(VAR_0, (WebSocketFrame) VAR_1);\n            return;\n        }\n\n        /* COMMENT_0 */\n        /* COMMENT_2 */\n        /* COMMENT_0 */\n\n        boolean VAR_2 = false;\n        try {\n            if (VAR_1 instanceof HttpRequest) {\n                HttpRequest VAR_3 = (HttpRequest) VAR_1;\n\n                /* COMMENT_3 */\n\n                /* COMMENT_4 */\n                VAR_4 = new Request(VAR_3);\n\n                /* COMMENT_5 */\n                boolean VAR_5 = false;\n                List<CharSequence> VAR_6 = VAR_3.headers().getAll(VAR_7);\n                for (int VAR_8 = 0; VAR_8 < VAR_6.size(); VAR_8++) {\n                    String VAR_9 = VAR_6.get(VAR_8).toString();\n                    if (VAR_9.equalsIgnoreCase(\"100-continue\")) {\n                        VAR_5 = true;\n                        break;\n                    }\n                }\n                if (VAR_5) {\n                    VAR_0.writeAndFlush(new DefaultFullHttpResponse(VAR_10.HTTP_1_1, VAR_11.CONTINUE,\n                            VAR_12.EMPTY_BUFFER));\n                    VAR_2 = true;\n                    return;\n                }\n\n                VAR_13 = !VAR_14.isKeepAlive(VAR_3);\n                VAR_15 = !VAR_13 && VAR_3.protocolVersion().equals(VAR_10.HTTP_1_0);\n\n                if (VAR_3.method() == VAR_16.POST) {\n                    /* COMMENT_6 */\n                    destroyDecoder();\n                    VAR_17 = new HttpPostRequestDecoder(VAR_18, VAR_3);\n\n                } else {\n                    /* COMMENT_7 */\n                    VAR_2 = true;\n                }\n\n                /* COMMENT_8 */\n                if (!VAR_3.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(VAR_0, VAR_3, new DefaultFullHttpResponse(VAR_10.HTTP_1_1,\n                            VAR_11.BAD_REQUEST));\n                    VAR_2 = true;\n                    return;\n                }\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_9 */\n            /* COMMENT_0 */\n\n            if (VAR_1 instanceof HttpContent && VAR_17 != null) {\n                HttpContent VAR_19 = (HttpContent) VAR_1;\n                /* COMMENT_10 */\n                /* COMMENT_11 */\n                VAR_17.offer(VAR_19);\n\n                try {\n                    while (VAR_17.hasNext()) {\n                        InterfaceHttpData VAR_20 = VAR_17.next();\n                        if (VAR_20 != null) {\n                            HttpDataType VAR_21 = VAR_20.getHttpDataType();\n                            if (VAR_21 == VAR_22.Attribute) {\n                                try {\n                                    Attribute VAR_23 = (Attribute) VAR_20;\n                                    VAR_4.setPostParam(VAR_23.getName(), VAR_23.getString(VAR_23\n                                            .getCharset() == null ? VAR_24.forName(\"UTF-8\") : VAR_23.getCharset()));\n                                } finally {\n                                    /* COMMENT_12 */\n                                    VAR_20.release();\n                                }\n\n                            } else if (VAR_21 == VAR_22.FileUpload) {\n                                FileUpload VAR_25 = (FileUpload) VAR_20;\n                                /* COMMENT_13 */\n                                /* COMMENT_14 */\n                                if (VAR_25.isCompleted()) {\n                                    /* COMMENT_15 */\n                                    /* COMMENT_16 */\n                                    VAR_4.setPostFileUploadParam(VAR_25.getName(), VAR_25);\n                                }\n                            } else {\n                                VAR_26.warning(\"Got unknown data chunk type: \" + VAR_21);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException VAR_27) {\n                    /* COMMENT_17 */\n                }\n\n                if (VAR_19 instanceof LastHttpContent) {\n                    VAR_2 = true;\n                }\n            }\n\n            if (!VAR_2) {\n                /* COMMENT_18 */\n                /* COMMENT_19 */\n                /* COMMENT_20 */\n                return;\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_21 */\n            /* COMMENT_0 */\n\n            /* COMMENT_22 */\n\n            String VAR_28 = VAR_4.getURI();\n\n            /* COMMENT_23 */\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            String VAR_29 = VAR_30.getHashKey(VAR_28);\n            boolean VAR_31 = VAR_29 != null;\n            String VAR_32 = VAR_31 ? VAR_30.getOrigURI(VAR_28) : VAR_28;\n\n            InetSocketAddress VAR_33 = (InetSocketAddress) VAR_0.channel().remoteAddress();\n            if (VAR_33 != null) {\n                InetAddress VAR_34 = VAR_33.getAddress();\n                if (VAR_34 != null) {\n                    VAR_4.setRequestor(VAR_34.getHostAddress());\n                }\n            }\n\n            boolean VAR_35 = VAR_4.getMethod() == VAR_16.HEAD;\n\n            /* COMMENT_26 */\n            HttpMethod VAR_36 = VAR_4.getMethod();\n            if (VAR_35) {\n                VAR_4.setMethod(VAR_16.GET);\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_27 */\n            /* COMMENT_0 */\n\n            /* COMMENT_28 */\n            Response VAR_37 = null;\n\n            /* COMMENT_29 */\n            /* COMMENT_30 */\n            User VAR_38 = null;\n            RouteInfo VAR_39 = null;\n            ArrayList<RouteInfo> VAR_40 = VAR_41.siteResources.getAllRoutes();\n            for (int VAR_8 = 0, VAR_42 = VAR_40.size(); VAR_8 < VAR_42; VAR_8++) {\n                RouteInfo VAR_43 = VAR_40.get(VAR_8);\n                /* COMMENT_31 */\n                if (VAR_43.matches(VAR_32)) {\n                    Class<? extends RouteHandler> VAR_44 = VAR_43.getHandler();\n\n                    if (!(VAR_4.getMethod() == VAR_16.GET || VAR_4.getMethod() == VAR_16.POST)) {\n\n                        /* COMMENT_32 */\n                        VAR_26.error(\"Unsupported HTTP method \" + VAR_4.getMethod().name() + \" for path \" + VAR_32);\n                        VAR_37 = new ErrorResponse(VAR_11.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if ((VAR_4.getMethod() == VAR_16.GET && !VAR_43.hasGetMethod())\n                            || (VAR_4.getMethod() == VAR_16.POST && !VAR_43.hasPostMethod())) {\n\n                        /* COMMENT_33 */\n                        VAR_26.error(\"HTTP method \" + VAR_4.getMethod().name() + \" not implemented in handler \"\n                                + VAR_44.getName());\n                        VAR_37 = new ErrorResponse(VAR_11.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(VAR_44)) {\n\n                        /* COMMENT_34 */\n                        VAR_38 = VAR_45.getLoggedInUser(VAR_4);\n                        if (VAR_38 == null) {\n\n                            /* COMMENT_35 */\n                            VAR_37 =\n                                    getResponseForErrorHandlerRoute(VAR_41.siteResources.getUnauthorizedRoute(),\n                                            VAR_4, VAR_38)\n                                    /* COMMENT_36 */\n                                    /* COMMENT_37 */\n                                            .setCookie(\n                                                    new Cookie(VAR_46.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \"/\", VAR_32,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(VAR_44)\n                                && !VAR_38.emailIsValidated()) {\n\n                            /* COMMENT_38 */\n                            /* COMMENT_39 */\n                            VAR_37 =\n                                    getResponseForErrorHandlerRoute(\n                                            VAR_41.siteResources.getEmailNotValidatedRoute(), VAR_4, VAR_38);\n\n                        } else {\n\n                            /* COMMENT_40 */\n                            /* COMMENT_41 */\n                            VAR_39 = VAR_43;\n                        }\n                    } else {\n\n                        /* COMMENT_42 */\n                        VAR_39 = VAR_43;\n                    }\n\n                    /* COMMENT_43 */\n                    break;\n                }\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_44 */\n            /* COMMENT_0 */\n\n            if (VAR_37 == null && VAR_39 == null && VAR_1 instanceof HttpRequest\n            /* COMMENT_45 */\n                    && VAR_32.endsWith(\"/websocket\")) {\n                HttpRequest VAR_3 = (HttpRequest) VAR_1;\n\n                /* COMMENT_46 */\n                /* COMMENT_47 */\n                /* COMMENT_48 */\n                VAR_47 = VAR_45.getLoggedInUser(VAR_4);\n\n                WebSocketServerHandshakerFactory VAR_48 =\n                        new WebSocketServerHandshakerFactory(VAR_41.wsUri.toString(), null, true);\n                VAR_49 = VAR_48.newHandshaker(VAR_3);\n                if (VAR_49 == null) {\n                    VAR_50.sendUnsupportedVersionResponse(VAR_0.channel());\n                } else {\n                    /* COMMENT_49 */\n                    /* COMMENT_50 */\n                    DefaultFullHttpRequest VAR_51 =\n                            new DefaultFullHttpRequest(VAR_3.protocolVersion(), VAR_3.method(), VAR_3.uri());\n                    VAR_51.headers().add(VAR_3.headers());\n                    VAR_49.handshake(VAR_0.channel(), (FullHttpRequest) VAR_51);\n                }\n                return;\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_51 */\n            /* COMMENT_0 */\n\n            /* COMMENT_52 */\n            /* COMMENT_53 */\n            if (VAR_37 == null && VAR_39 == null) {\n                /* COMMENT_54 */\n                if (VAR_4.getMethod() != VAR_16.GET) {\n                    sendHttpErrorResponse(VAR_0, null, new DefaultFullHttpResponse(VAR_10.HTTP_1_1,\n                            VAR_11.FORBIDDEN));\n                    return;\n                }\n\n                File VAR_52 = VAR_41.siteResources.getStaticResource(VAR_32);\n                if (VAR_52 == null) {\n\n                    /* COMMENT_55 */\n                    /* COMMENT_56 */\n                    VAR_37 =\n                            getResponseForErrorHandlerRoute(VAR_41.siteResources.getNotFoundRoute(), VAR_4,\n                                    VAR_38);\n\n                } else {\n\n                    /* COMMENT_57 */\n                    /* COMMENT_58 */\n                    long VAR_53 = VAR_52.lastModified() / 1000;\n                    if (!VAR_4.cachedVersionIsOlderThan(VAR_53)) {\n                        /* COMMENT_59 */\n                        VAR_37 = new NotModifiedResponse(VAR_53);\n\n                    } else {\n                        /* COMMENT_60 */\n                        serveStaticFile(VAR_32, VAR_29, VAR_52, VAR_53, VAR_0);\n\n                        VAR_26.fine(VAR_4.getRequestor() + \"\\t\" + VAR_36 + \"\\t\" + VAR_32 + \"\\tfile://\"\n                                + VAR_52.getPath() + \"\\t\" + VAR_11.OK + \"\\t\"\n                                + (VAR_54.currentTimeMillis() - VAR_4.getReqReceivedTimeEpochMillis()) + \" msec\");\n\n                        /* COMMENT_61 */\n                        return;\n                    }\n                }\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_62 */\n            /* COMMENT_0 */\n\n            ZonedDateTime VAR_55 = null;\n\n            /* COMMENT_63 */\n            /* COMMENT_64 */\n            /* COMMENT_65 */\n            boolean VAR_56 = false;\n            long VAR_57 = 0;\n            if (VAR_37 == null && VAR_39 != null) {\n\n                /* COMMENT_66 */\n                /* COMMENT_67 */\n                /* COMMENT_66 */\n\n                /* COMMENT_68 */\n                /* COMMENT_69 */\n                /* COMMENT_70 */\n                /* COMMENT_71 */\n                /* COMMENT_72 */\n                /* COMMENT_73 */\n                /* COMMENT_74 */\n                /* COMMENT_75 */\n                /* COMMENT_76 */\n                /* COMMENT_77 */\n                /* COMMENT_78 */\n                /* COMMENT_79 */\n                if (VAR_31) {\n                    HashInfo VAR_58 = VAR_30.getHashInfo(VAR_32);\n                    if (VAR_58 != null) {\n                        long VAR_53 = VAR_58.getLastModifiedEpochSeconds();\n                        VAR_55 = VAR_59.now();\n                        long VAR_60 = VAR_55.toEpochSecond();\n\n                        long VAR_61 = VAR_39.getMaxAgeSeconds();\n                        VAR_57 = VAR_53 + VAR_61 - VAR_60;\n\n                        if (VAR_61 == 0) {\n                            /* COMMENT_80 */\n                            VAR_57 = 0;\n                        }\n\n                        if (VAR_61 > 0 && VAR_57 <= 0) {\n                            /* COMMENT_81 */\n                            /* COMMENT_82 */\n                            /* COMMENT_83 */\n                            VAR_56 = true;\n\n                            /* COMMENT_84 */\n                            VAR_57 = VAR_61;\n\n                        } else if (!VAR_4.cachedVersionIsOlderThan(VAR_53)) {\n                            /* COMMENT_85 */\n                            /* COMMENT_86 */\n                            /* COMMENT_87 */\n                            VAR_37 = new NotModifiedResponse(VAR_53);\n\n                        } else {\n                            /* COMMENT_85 */\n                            /* COMMENT_88 */\n                            /* COMMENT_89 */\n                            /* COMMENT_90 */\n                        }\n                    } else {\n                        /* COMMENT_91 */\n                        /* COMMENT_92 */\n                        /* COMMENT_93 */\n                        /* COMMENT_94 */\n                    }\n                }\n\n                /* COMMENT_95 */\n                if (VAR_37 == null) {\n\n                    /* COMMENT_96 */\n                    /* COMMENT_97 */\n                    /* COMMENT_96 */\n\n                    VAR_37 = getResponseForRoute(VAR_39, VAR_4, VAR_38);\n\n                    if (VAR_37 == null) {\n                        /* COMMENT_98 */\n                        throw new RuntimeException(\"Didn't generate a response\");\n                    }\n\n                }\n\n            }\n            if (VAR_37 == null) {\n                /* COMMENT_98 */\n                throw new RuntimeException(\"Didn't generate a response\");\n            }\n\n            /* COMMENT_99 */\n            /* COMMENT_100 */\n            /* COMMENT_99 */\n\n            /* COMMENT_101 */\n            if (VAR_55 == null) {\n                VAR_55 = VAR_59.now();\n            }\n\n            /* COMMENT_102 */\n            serveHttpResponse(VAR_32, VAR_37, VAR_35, VAR_4.acceptEncodingGzip(),/* COMMENT_73 */\n                    VAR_55, VAR_56, VAR_57, VAR_29, VAR_0);\n\n            /* COMMENT_103 */\n            HttpResponseStatus VAR_62 = VAR_37.getStatus();\n            String VAR_63 =\n                    VAR_4.getRequestor() + \"\\t\" + VAR_36 + \"\\t\" + VAR_32\n                            + (VAR_4.getMethod() == VAR_36 ? \"\" : \"\\t\" + VAR_4.getMethod()) + \"\\t\" + VAR_62\n                            + \"\\t\" + (VAR_54.currentTimeMillis() - VAR_4.getReqReceivedTimeEpochMillis()) + \" msec\";\n            if (VAR_62 == VAR_11.OK /* COMMENT_73 */\n                    || VAR_62 == VAR_11.NOT_MODIFIED /* COMMENT_73 */\n                    || VAR_62 == VAR_11.FOUND /* COMMENT_73 */\n                    || (VAR_62 == VAR_11.NOT_FOUND /* COMMENT_73 */\n                    && (VAR_32.equals(\"favicon.ico\") || VAR_32.endsWith(\"/favicon.ico\")))) {\n                /* COMMENT_104 */\n                VAR_26.fine(VAR_63);\n            } else {\n                /* COMMENT_105 */\n                VAR_26.warningWithoutCallerRef(VAR_63);\n            }\n\n        } finally {\n            if (VAR_2) {\n                /* COMMENT_106 */\n                destroyDecoder();\n            }\n        }\n    }",
    "func_graph_path_before": "lukehutch/gribbit/620418df247aebda3dd4be1dda10fe229ea505dd/HttpRequestHandler.java/vul/before/0.json",
    "func": "@Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\"REQUEST: \" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\"100-continue\")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\"UTF-8\") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                                }\n                            } else {\n                                Log.warning(\"Got unknown data chunk type: \" + httpDataType);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException e) {\n                    // Apparently decoder.hasNext() doesn't actually work\n                }\n\n                if (chunk instanceof LastHttpContent) {\n                    requestComplete = true;\n                }\n            }\n\n            if (!requestComplete) {\n                // Wait for more chunks.\n                // (Since requestComplete is false, calling return here will not call destroyDecoder()\n                // in the finally block, so it will still exist when the next chunk is received.)\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Figure out how to handle HTTP request\n            // ------------------------------------------------------------------------------\n\n            // All POST chunks have been received (or there are no chunks); ready to start handling the request\n\n            String origReqURI = request.getURI();\n\n            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.\n            // We only need to serve the resource at a hash URI once per resource per client, since resources served\n            // from hash URIs are indefinitely cached in the browser.\n            String hashKey = CacheExtension.getHashKey(origReqURI);\n            boolean isHashURI = hashKey != null;\n            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;\n\n            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();\n            if (requestor != null) {\n                InetAddress address = requestor.getAddress();\n                if (address != null) {\n                    request.setRequestor(address.getHostAddress());\n                }\n            }\n\n            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;\n\n            // Run the GET method if HEAD is requested, just don't return a body.\n            HttpMethod origReqMethod = request.getMethod();\n            if (isHEAD) {\n                request.setMethod(HttpMethod.GET);\n            }\n\n            // ------------------------------------------------------------------------------\n            // Authenticate user\n            // ------------------------------------------------------------------------------\n\n            // The response object generated by a RestHandler\n            Response response = null;\n\n            // Call route handlers until one is able to handle the route,\n            // or until we run out of handlers\n            User user = null;\n            RouteInfo authorizedRoute = null;\n            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();\n            for (int i = 0, n = allRoutes.size(); i < n; i++) {\n                RouteInfo route = allRoutes.get(i);\n                // If the request URI matches this route path\n                if (route.matches(reqURI)) {\n                    Class<? extends RouteHandler> handler = route.getHandler();\n\n                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {\n\n                        // We only support GET and POST at this point\n                        Log.error(\"Unsupported HTTP method \" + request.getMethod().name() + \" for path \" + reqURI);\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())\n                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {\n\n                        // Tried to call an HTTP method that is not defined for this route\n                        Log.error(\"HTTP method \" + request.getMethod().name() + \" not implemented in handler \"\n                                + handler.getName());\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {\n\n                        // This handler requires authentication -- check if user is logged in\n                        user = User.getLoggedInUser(request);\n                        if (user == null) {\n\n                            // User is not logged in: handle request with OnUnauthorized handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),\n                                            request, user)\n                                    // Redirect the user back to the page they were trying to get to once they\n                                    // do manage to log in successfully\n                                            .setCookie(\n                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \"/\", reqURI,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)\n                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n\n            // FIXME: Make these into class annotations\n            String websocketPath = \"/websocket\";\n            boolean isAuthenticatedWebsocket = true;\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations, rather than using hardcoded \"/websocket\"\n                    && reqURI.endsWith(websocketPath)) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Protect against CSWSH: (Cross-Site WebSocket Hijacking)\n                // http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html\n                // http://tools.ietf.org/html/rfc6455#page-7\n                CharSequence origin = request.getOrigin();\n                URI originUri = null;\n                if (origin != null && origin.length() > 0) {\n                    try {\n                        // Try parsing origin URI\n                        originUri = new URI(origin.toString());\n                    } catch (Exception e) {\n                    }\n                }\n                // If port number is set but it is the default for the URI scheme, revert the port number\n                // back to -1 (which means unspecified), so that it matches the server port number, \n                // which is unspecified when serving http on port 80 and https on port 443\n                int originPort = originUri == null ? -1 //\n                        : originUri.getPort() == 80 && \"http\".equals(originUri.getScheme()) ? -1 //\n                                : originUri.getPort() == 443 && \"https\".equals(originUri.getScheme()) ? -1 //\n                                        : originUri.getPort();\n                // Scheme, host and port all must match to forbid cross-origin requests\n                if (originUri == null //\n                        || !GribbitServer.uri.getScheme().equals(originUri.getScheme()) //\n                        || !GribbitServer.uri.getHost().equals(originUri.getHost()) //\n                        || GribbitServer.uri.getPort() != originPort) { //\n                    // Reject scripted requests to open this websocket from a different domain\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n                // Log.info(\"Origin: \" + origin.toString());\n\n                if (isAuthenticatedWebsocket) {\n                    // For authenticated websockets, check if the user is logged in\n                    User loggedInUser = User.getLoggedInUser(request);\n                    if (loggedInUser == null) {\n                        // Not logged in, so can't connect to this websocket\n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;\n                    }\n\n                    // To further mitigate CSWSH attacks: check for the CSRF token in the URL parameter \"_csrf\";\n                    // the passed token must match the user's CSRF token. This means the websocket URL has to\n                    // be dynamically generated and inserted into the webpage that opened the websocket.\n                    // TODO: generate this URL an insert into the page somehow\n                    String csrfTok = loggedInUser.csrfTok;\n                    if (csrfTok == null || csrfTok.isEmpty() || csrfTok.equals(CSRF.CSRF_TOKEN_UNKNOWN)\n                            || csrfTok.equals(CSRF.CSRF_TOKEN_PLACEHOLDER)) {\n                        // No valid CSRF token in User object\n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;\n                    }\n                    String csrfParam = request.getQueryParam(\"_csrf\");\n                    if (csrfParam == null || csrfParam.isEmpty() || !csrfParam.equals(csrfTok)) {\n                        // The CSRF URL query parameter is missing, or doesn't match the user's token \n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;                        \n                    }\n\n                    // Record which user was authenticated when the websocket upgrade request was made.\n                    // TODO: Also provide a means for revoking user's session while WS is still open,\n                    // e.g. poll the user table every few seconds to see if user's session token has\n                    // changed in the database? (Although this would mean that logging in on a new\n                    // device would log you out of all other sessions...)\n                    wsAuthenticatedUser = loggedInUser;\n                }\n\n                WebSocketServerHandshakerFactory wsFactory =\n                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);\n                handshaker = wsFactory.newHandshaker(httpReq);\n                if (handshaker == null) {\n                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());\n                } else {\n                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket\n                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest\n                    DefaultFullHttpRequest fullReq =\n                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());\n                    fullReq.headers().add(httpReq.headers());\n                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);\n                }\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle static file requests\n            // ------------------------------------------------------------------------------\n\n            // If no error has occurred so far, and no route handler matched the request URI, and this is a\n            // GET request, then see if the URI points to a static file resource, and if so, serve the file.\n            if (response == null && authorizedRoute == null) {\n                // Static file requests can only use GET method\n                if (request.getMethod() != HttpMethod.GET) {\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n\n                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);\n                if (staticResourceFile == null) {\n\n                    // Neither a route handler nor a static resource matched the request URI.\n                    // Return 404 Not Found.\n                    response =\n                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,\n                                    user);\n\n                } else {\n\n                    // A static resource matched the request URI, check last-modified timestamp\n                    // against the If-Modified-Since header timestamp in the request.\n                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;\n                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                        // File has not been modified since it was last cached -- return Not Modified\n                        response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                    } else {\n                        // If file is newer than what is in the browser cache, or is not in cache, serve the file\n                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);\n\n                        Log.fine(request.getRequestor() + \"\\t\" + origReqMethod + \"\\t\" + reqURI + \"\\tfile://\"\n                                + staticResourceFile.getPath() + \"\\t\" + HttpResponseStatus.OK + \"\\t\"\n                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \" msec\");\n\n                        // Finished request\n                        return;\n                    }\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle GET or POST requests\n            // ------------------------------------------------------------------------------\n\n            ZonedDateTime timeNow = null;\n\n            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,\n            // then call the get() or post() method for the route handler bound to the request URI to obtain the\n            // response object.\n            boolean hashTheResponse = false;\n            long hashKeyRemainingAgeSeconds = 0;\n            if (response == null && authorizedRoute != null) {\n\n                // ----------------------------------\n                // See if response should be hashed\n                // ----------------------------------\n\n                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served\n                // content can't be read directly, so read the last modified timestamp stored for the\n                // previously hashed version in the CacheExtension class, as long as the max age of the\n                // cached version hasn't been exceeded, and see if the last modified timestamp is more\n                // recent than the version cached in the browser.\n                //\n                // The important ramification of this is that when the resource identified by the non-file\n                // URI changes, the CacheExtension class must be notified of that change (including in cases\n                // where the database is modified by another database client) if the modified version should\n                // start being served at a new hash URI immediately, otherwise the web client connected to\n                // this web server will continue to serve old resources until the max age of the cached\n                // content is exceeded.\n                if (isHashURI) {\n                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);\n                    if (hashInfo != null) {\n                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();\n                        timeNow = ZonedDateTime.now();\n                        long timeNowEpochSeconds = timeNow.toEpochSecond();\n\n                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();\n                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;\n\n                        if (maxAgeSeconds == 0) {\n                            // Content is not hash-cached\n                            hashKeyRemainingAgeSeconds = 0;\n                        }\n\n                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {\n                            // Resource has expired -- call the route handler to generate a new response rather\n                            // than serving a Not Modified response, and schedule the response to be hashed or\n                            // re-hashed once the response has been generated.\n                            hashTheResponse = true;\n\n                            // Reset the expiry time at the requested number of seconds in the future\n                            hashKeyRemainingAgeSeconds = maxAgeSeconds;\n\n                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // However, resource has not been modified since it was last hashed --\n                            // return Not Modified.\n                            response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                        } else {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // Resource *has* been modified since it was last hashed -- serve it the\n                            // normal way using the route handler, but don't hash the response, since\n                            // it has not expired yet.\n                        }\n                    } else {\n                        // There is no original URI matching this hash URI, so the hash key was stale\n                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from\n                        // the previous time the server was run), but we still got a valid request URI\n                        // by stripping away the hash code, so that is served below in the normal way.\n                    }\n                }\n\n                // If the response wasn't just set to \"Not Modified\" above, serve the request\n                if (response == null) {\n\n                    // -----------------------------------------------------------------\n                    // Call the route handler for this request, generating the response\n                    // -----------------------------------------------------------------\n\n                    response = getResponseForRoute(authorizedRoute, request, user);\n\n                    if (response == null) {\n                        // Should not happen\n                        throw new RuntimeException(\"Didn't generate a response\");\n                    }\n\n                }\n\n            }\n            if (response == null) {\n                // Should not happen\n                throw new RuntimeException(\"Didn't generate a response\");\n            }\n\n            // ------------------------------------------------------------------------------------\n            // Serve an HTTP result (except in the case of static files, they were served already)\n            // ------------------------------------------------------------------------------------\n\n            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.\n            if (timeNow == null) {\n                timeNow = ZonedDateTime.now();\n            }\n\n            // Serve the response to the client \n            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//\n                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);\n\n            // Log the request and response\n            HttpResponseStatus status = response.getStatus();\n            String logMsg =\n                    request.getRequestor() + \"\\t\" + origReqMethod + \"\\t\" + reqURI\n                            + (request.getMethod() == origReqMethod ? \"\" : \"\\t\" + request.getMethod()) + \"\\t\" + status\n                            + \"\\t\" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \" msec\";\n            if (status == HttpResponseStatus.OK //\n                    || status == HttpResponseStatus.NOT_MODIFIED //\n                    || status == HttpResponseStatus.FOUND //\n                    || (status == HttpResponseStatus.NOT_FOUND //\n                    && (reqURI.equals(\"favicon.ico\") || reqURI.endsWith(\"/favicon.ico\")))) {\n                // Log at level \"fine\" for non-errors, or 404 for favicon\n                Log.fine(logMsg);\n            } else {\n                // Log at level \"warning\" for errors, or 404 for non-favicon\n                Log.warningWithoutCallerRef(logMsg);\n            }\n\n        } finally {\n            if (requestComplete) {\n                // Finished request -- destroy the multipart decoder and remove temporary files\n                destroyDecoder();\n            }\n        }\n    }",
    "abstract_func": "@Override\n    public void messageReceived(ChannelHandlerContext VAR_0, Object VAR_1) throws Exception {\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_0 */\n\n        if (VAR_1 instanceof WebSocketFrame) {\n            handleWebsocketFrame(VAR_0, (WebSocketFrame) VAR_1);\n            return;\n        }\n\n        /* COMMENT_0 */\n        /* COMMENT_2 */\n        /* COMMENT_0 */\n\n        boolean VAR_2 = false;\n        try {\n            if (VAR_1 instanceof HttpRequest) {\n                HttpRequest VAR_3 = (HttpRequest) VAR_1;\n\n                /* COMMENT_3 */\n\n                /* COMMENT_4 */\n                VAR_4 = new Request(VAR_3);\n\n                /* COMMENT_5 */\n                boolean VAR_5 = false;\n                List<CharSequence> VAR_6 = VAR_3.headers().getAll(VAR_7);\n                for (int VAR_8 = 0; VAR_8 < VAR_6.size(); VAR_8++) {\n                    String VAR_9 = VAR_6.get(VAR_8).toString();\n                    if (VAR_9.equalsIgnoreCase(\"100-continue\")) {\n                        VAR_5 = true;\n                        break;\n                    }\n                }\n                if (VAR_5) {\n                    VAR_0.writeAndFlush(new DefaultFullHttpResponse(VAR_10.HTTP_1_1, VAR_11.CONTINUE,\n                            VAR_12.EMPTY_BUFFER));\n                    VAR_2 = true;\n                    return;\n                }\n\n                VAR_13 = !VAR_14.isKeepAlive(VAR_3);\n                VAR_15 = !VAR_13 && VAR_3.protocolVersion().equals(VAR_10.HTTP_1_0);\n\n                if (VAR_3.method() == VAR_16.POST) {\n                    /* COMMENT_6 */\n                    destroyDecoder();\n                    VAR_17 = new HttpPostRequestDecoder(VAR_18, VAR_3);\n\n                } else {\n                    /* COMMENT_7 */\n                    VAR_2 = true;\n                }\n\n                /* COMMENT_8 */\n                if (!VAR_3.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(VAR_0, VAR_3, new DefaultFullHttpResponse(VAR_10.HTTP_1_1,\n                            VAR_11.BAD_REQUEST));\n                    VAR_2 = true;\n                    return;\n                }\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_9 */\n            /* COMMENT_0 */\n\n            if (VAR_1 instanceof HttpContent && VAR_17 != null) {\n                HttpContent VAR_19 = (HttpContent) VAR_1;\n                /* COMMENT_10 */\n                /* COMMENT_11 */\n                VAR_17.offer(VAR_19);\n\n                try {\n                    while (VAR_17.hasNext()) {\n                        InterfaceHttpData VAR_20 = VAR_17.next();\n                        if (VAR_20 != null) {\n                            HttpDataType VAR_21 = VAR_20.getHttpDataType();\n                            if (VAR_21 == VAR_22.Attribute) {\n                                try {\n                                    Attribute VAR_23 = (Attribute) VAR_20;\n                                    VAR_4.setPostParam(VAR_23.getName(), VAR_23.getString(VAR_23\n                                            .getCharset() == null ? VAR_24.forName(\"UTF-8\") : VAR_23.getCharset()));\n                                } finally {\n                                    /* COMMENT_12 */\n                                    VAR_20.release();\n                                }\n\n                            } else if (VAR_21 == VAR_22.FileUpload) {\n                                FileUpload VAR_25 = (FileUpload) VAR_20;\n                                /* COMMENT_13 */\n                                /* COMMENT_14 */\n                                if (VAR_25.isCompleted()) {\n                                    /* COMMENT_15 */\n                                    /* COMMENT_16 */\n                                    VAR_4.setPostFileUploadParam(VAR_25.getName(), VAR_25);\n                                }\n                            } else {\n                                VAR_26.warning(\"Got unknown data chunk type: \" + VAR_21);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException VAR_27) {\n                    /* COMMENT_17 */\n                }\n\n                if (VAR_19 instanceof LastHttpContent) {\n                    VAR_2 = true;\n                }\n            }\n\n            if (!VAR_2) {\n                /* COMMENT_18 */\n                /* COMMENT_19 */\n                /* COMMENT_20 */\n                return;\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_21 */\n            /* COMMENT_0 */\n\n            /* COMMENT_22 */\n\n            String VAR_28 = VAR_4.getURI();\n\n            /* COMMENT_23 */\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            String VAR_29 = VAR_30.getHashKey(VAR_28);\n            boolean VAR_31 = VAR_29 != null;\n            String VAR_32 = VAR_31 ? VAR_30.getOrigURI(VAR_28) : VAR_28;\n\n            InetSocketAddress VAR_33 = (InetSocketAddress) VAR_0.channel().remoteAddress();\n            if (VAR_33 != null) {\n                InetAddress VAR_34 = VAR_33.getAddress();\n                if (VAR_34 != null) {\n                    VAR_4.setRequestor(VAR_34.getHostAddress());\n                }\n            }\n\n            boolean VAR_35 = VAR_4.getMethod() == VAR_16.HEAD;\n\n            /* COMMENT_26 */\n            HttpMethod VAR_36 = VAR_4.getMethod();\n            if (VAR_35) {\n                VAR_4.setMethod(VAR_16.GET);\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_27 */\n            /* COMMENT_0 */\n\n            /* COMMENT_28 */\n            Response VAR_37 = null;\n\n            /* COMMENT_29 */\n            /* COMMENT_30 */\n            User VAR_38 = null;\n            RouteInfo VAR_39 = null;\n            ArrayList<RouteInfo> VAR_40 = VAR_41.siteResources.getAllRoutes();\n            for (int VAR_8 = 0, VAR_42 = VAR_40.size(); VAR_8 < VAR_42; VAR_8++) {\n                RouteInfo VAR_43 = VAR_40.get(VAR_8);\n                /* COMMENT_31 */\n                if (VAR_43.matches(VAR_32)) {\n                    Class<? extends RouteHandler> VAR_44 = VAR_43.getHandler();\n\n                    if (!(VAR_4.getMethod() == VAR_16.GET || VAR_4.getMethod() == VAR_16.POST)) {\n\n                        /* COMMENT_32 */\n                        VAR_26.error(\"Unsupported HTTP method \" + VAR_4.getMethod().name() + \" for path \" + VAR_32);\n                        VAR_37 = new ErrorResponse(VAR_11.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if ((VAR_4.getMethod() == VAR_16.GET && !VAR_43.hasGetMethod())\n                            || (VAR_4.getMethod() == VAR_16.POST && !VAR_43.hasPostMethod())) {\n\n                        /* COMMENT_33 */\n                        VAR_26.error(\"HTTP method \" + VAR_4.getMethod().name() + \" not implemented in handler \"\n                                + VAR_44.getName());\n                        VAR_37 = new ErrorResponse(VAR_11.METHOD_NOT_ALLOWED, \"HTTP method not allowed\");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(VAR_44)) {\n\n                        /* COMMENT_34 */\n                        VAR_38 = VAR_45.getLoggedInUser(VAR_4);\n                        if (VAR_38 == null) {\n\n                            /* COMMENT_35 */\n                            VAR_37 =\n                                    getResponseForErrorHandlerRoute(VAR_41.siteResources.getUnauthorizedRoute(),\n                                            VAR_4, VAR_38)\n                                    /* COMMENT_36 */\n                                    /* COMMENT_37 */\n                                            .setCookie(\n                                                    new Cookie(VAR_46.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \"/\", VAR_32,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(VAR_44)\n                                && !VAR_38.emailIsValidated()) {\n\n                            /* COMMENT_38 */\n                            /* COMMENT_39 */\n                            VAR_37 =\n                                    getResponseForErrorHandlerRoute(\n                                            VAR_41.siteResources.getEmailNotValidatedRoute(), VAR_4, VAR_38);\n\n                        } else {\n\n                            /* COMMENT_40 */\n                            /* COMMENT_41 */\n                            VAR_39 = VAR_43;\n                        }\n                    } else {\n\n                        /* COMMENT_42 */\n                        VAR_39 = VAR_43;\n                    }\n\n                    /* COMMENT_43 */\n                    break;\n                }\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_44 */\n            /* COMMENT_0 */\n\n            /* COMMENT_45 */\n            String VAR_47 = \"/websocket\";\n            boolean VAR_48 = true;\n\n            if (VAR_37 == null && VAR_39 == null && VAR_1 instanceof HttpRequest\n            /* COMMENT_46 */\n                    && VAR_32.endsWith(VAR_47)) {\n                HttpRequest VAR_3 = (HttpRequest) VAR_1;\n\n                /* COMMENT_47 */\n                /* COMMENT_48 */\n                /* COMMENT_49 */\n                CharSequence VAR_49 = VAR_4.getOrigin();\n                URI VAR_50 = null;\n                if (VAR_49 != null && VAR_49.length() > 0) {\n                    try {\n                        /* COMMENT_50 */\n                        VAR_50 = new URI(VAR_49.toString());\n                    } catch (Exception VAR_27) {\n                    }\n                }\n                /* COMMENT_51 */\n                /* COMMENT_52 */\n                /* COMMENT_53 */\n                int VAR_51 = VAR_50 == null ? -1 /* COMMENT_54 */\n                        : VAR_50.getPort() == 80 && \"http\".equals(VAR_50.getScheme()) ? -1 /* COMMENT_54 */\n                                : VAR_50.getPort() == 443 && \"https\".equals(VAR_50.getScheme()) ? -1 /* COMMENT_54 */\n                                        : VAR_50.getPort();\n                /* COMMENT_55 */\n                if (VAR_50 == null /* COMMENT_54 */\n                        || !VAR_41.uri.getScheme().equals(VAR_50.getScheme()) /* COMMENT_54 */\n                        || !VAR_41.uri.getHost().equals(VAR_50.getHost()) /* COMMENT_54 */\n                        || VAR_41.uri.getPort() != VAR_51) { /* COMMENT_54 */\n                    /* COMMENT_56 */\n                    sendHttpErrorResponse(VAR_0, null, new DefaultFullHttpResponse(VAR_10.HTTP_1_1,\n                            VAR_11.FORBIDDEN));\n                    return;\n                }\n                /* COMMENT_57 */\n\n                if (VAR_48) {\n                    /* COMMENT_58 */\n                    User VAR_52 = VAR_45.getLoggedInUser(VAR_4);\n                    if (VAR_52 == null) {\n                        /* COMMENT_59 */\n                        sendHttpErrorResponse(VAR_0, null, new DefaultFullHttpResponse(VAR_10.HTTP_1_1,\n                                VAR_11.FORBIDDEN));\n                        return;\n                    }\n\n                    /* COMMENT_60 */\n                    /* COMMENT_61 */\n                    /* COMMENT_62 */\n                    /* COMMENT_63 */\n                    String VAR_53 = VAR_52.csrfTok;\n                    if (VAR_53 == null || VAR_53.isEmpty() || VAR_53.equals(VAR_54.CSRF_TOKEN_UNKNOWN)\n                            || VAR_53.equals(VAR_54.CSRF_TOKEN_PLACEHOLDER)) {\n                        /* COMMENT_64 */\n                        sendHttpErrorResponse(VAR_0, null, new DefaultFullHttpResponse(VAR_10.HTTP_1_1,\n                                VAR_11.FORBIDDEN));\n                        return;\n                    }\n                    String VAR_55 = VAR_4.getQueryParam(\"_csrf\");\n                    if (VAR_55 == null || VAR_55.isEmpty() || !VAR_55.equals(VAR_53)) {\n                        /* COMMENT_65 */\n                        sendHttpErrorResponse(VAR_0, null, new DefaultFullHttpResponse(VAR_10.HTTP_1_1,\n                                VAR_11.FORBIDDEN));\n                        return;                        \n                    }\n\n                    /* COMMENT_66 */\n                    /* COMMENT_67 */\n                    /* COMMENT_68 */\n                    /* COMMENT_69 */\n                    /* COMMENT_70 */\n                    VAR_56 = VAR_52;\n                }\n\n                WebSocketServerHandshakerFactory VAR_57 =\n                        new WebSocketServerHandshakerFactory(VAR_41.wsUri.toString(), null, true);\n                VAR_58 = VAR_57.newHandshaker(VAR_3);\n                if (VAR_58 == null) {\n                    VAR_59.sendUnsupportedVersionResponse(VAR_0.channel());\n                } else {\n                    /* COMMENT_71 */\n                    /* COMMENT_72 */\n                    DefaultFullHttpRequest VAR_60 =\n                            new DefaultFullHttpRequest(VAR_3.protocolVersion(), VAR_3.method(), VAR_3.uri());\n                    VAR_60.headers().add(VAR_3.headers());\n                    VAR_58.handshake(VAR_0.channel(), (FullHttpRequest) VAR_60);\n                }\n                return;\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_73 */\n            /* COMMENT_0 */\n\n            /* COMMENT_74 */\n            /* COMMENT_75 */\n            if (VAR_37 == null && VAR_39 == null) {\n                /* COMMENT_76 */\n                if (VAR_4.getMethod() != VAR_16.GET) {\n                    sendHttpErrorResponse(VAR_0, null, new DefaultFullHttpResponse(VAR_10.HTTP_1_1,\n                            VAR_11.FORBIDDEN));\n                    return;\n                }\n\n                File VAR_61 = VAR_41.siteResources.getStaticResource(VAR_32);\n                if (VAR_61 == null) {\n\n                    /* COMMENT_77 */\n                    /* COMMENT_78 */\n                    VAR_37 =\n                            getResponseForErrorHandlerRoute(VAR_41.siteResources.getNotFoundRoute(), VAR_4,\n                                    VAR_38);\n\n                } else {\n\n                    /* COMMENT_79 */\n                    /* COMMENT_80 */\n                    long VAR_62 = VAR_61.lastModified() / 1000;\n                    if (!VAR_4.cachedVersionIsOlderThan(VAR_62)) {\n                        /* COMMENT_81 */\n                        VAR_37 = new NotModifiedResponse(VAR_62);\n\n                    } else {\n                        /* COMMENT_82 */\n                        serveStaticFile(VAR_32, VAR_29, VAR_61, VAR_62, VAR_0);\n\n                        VAR_26.fine(VAR_4.getRequestor() + \"\\t\" + VAR_36 + \"\\t\" + VAR_32 + \"\\tfile://\"\n                                + VAR_61.getPath() + \"\\t\" + VAR_11.OK + \"\\t\"\n                                + (VAR_63.currentTimeMillis() - VAR_4.getReqReceivedTimeEpochMillis()) + \" msec\");\n\n                        /* COMMENT_83 */\n                        return;\n                    }\n                }\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_84 */\n            /* COMMENT_0 */\n\n            ZonedDateTime VAR_64 = null;\n\n            /* COMMENT_85 */\n            /* COMMENT_86 */\n            /* COMMENT_87 */\n            boolean VAR_65 = false;\n            long VAR_66 = 0;\n            if (VAR_37 == null && VAR_39 != null) {\n\n                /* COMMENT_88 */\n                /* COMMENT_89 */\n                /* COMMENT_88 */\n\n                /* COMMENT_90 */\n                /* COMMENT_91 */\n                /* COMMENT_92 */\n                /* COMMENT_93 */\n                /* COMMENT_94 */\n                /* COMMENT_54 */\n                /* COMMENT_95 */\n                /* COMMENT_96 */\n                /* COMMENT_97 */\n                /* COMMENT_98 */\n                /* COMMENT_99 */\n                /* COMMENT_100 */\n                if (VAR_31) {\n                    HashInfo VAR_67 = VAR_30.getHashInfo(VAR_32);\n                    if (VAR_67 != null) {\n                        long VAR_62 = VAR_67.getLastModifiedEpochSeconds();\n                        VAR_64 = VAR_68.now();\n                        long VAR_69 = VAR_64.toEpochSecond();\n\n                        long VAR_70 = VAR_39.getMaxAgeSeconds();\n                        VAR_66 = VAR_62 + VAR_70 - VAR_69;\n\n                        if (VAR_70 == 0) {\n                            /* COMMENT_101 */\n                            VAR_66 = 0;\n                        }\n\n                        if (VAR_70 > 0 && VAR_66 <= 0) {\n                            /* COMMENT_102 */\n                            /* COMMENT_103 */\n                            /* COMMENT_104 */\n                            VAR_65 = true;\n\n                            /* COMMENT_105 */\n                            VAR_66 = VAR_70;\n\n                        } else if (!VAR_4.cachedVersionIsOlderThan(VAR_62)) {\n                            /* COMMENT_106 */\n                            /* COMMENT_107 */\n                            /* COMMENT_108 */\n                            VAR_37 = new NotModifiedResponse(VAR_62);\n\n                        } else {\n                            /* COMMENT_106 */\n                            /* COMMENT_109 */\n                            /* COMMENT_110 */\n                            /* COMMENT_111 */\n                        }\n                    } else {\n                        /* COMMENT_112 */\n                        /* COMMENT_113 */\n                        /* COMMENT_114 */\n                        /* COMMENT_115 */\n                    }\n                }\n\n                /* COMMENT_116 */\n                if (VAR_37 == null) {\n\n                    /* COMMENT_117 */\n                    /* COMMENT_118 */\n                    /* COMMENT_117 */\n\n                    VAR_37 = getResponseForRoute(VAR_39, VAR_4, VAR_38);\n\n                    if (VAR_37 == null) {\n                        /* COMMENT_119 */\n                        throw new RuntimeException(\"Didn't generate a response\");\n                    }\n\n                }\n\n            }\n            if (VAR_37 == null) {\n                /* COMMENT_119 */\n                throw new RuntimeException(\"Didn't generate a response\");\n            }\n\n            /* COMMENT_120 */\n            /* COMMENT_121 */\n            /* COMMENT_120 */\n\n            /* COMMENT_122 */\n            if (VAR_64 == null) {\n                VAR_64 = VAR_68.now();\n            }\n\n            /* COMMENT_123 */\n            serveHttpResponse(VAR_32, VAR_37, VAR_35, VAR_4.acceptEncodingGzip(),/* COMMENT_54 */\n                    VAR_64, VAR_65, VAR_66, VAR_29, VAR_0);\n\n            /* COMMENT_124 */\n            HttpResponseStatus VAR_71 = VAR_37.getStatus();\n            String VAR_72 =\n                    VAR_4.getRequestor() + \"\\t\" + VAR_36 + \"\\t\" + VAR_32\n                            + (VAR_4.getMethod() == VAR_36 ? \"\" : \"\\t\" + VAR_4.getMethod()) + \"\\t\" + VAR_71\n                            + \"\\t\" + (VAR_63.currentTimeMillis() - VAR_4.getReqReceivedTimeEpochMillis()) + \" msec\";\n            if (VAR_71 == VAR_11.OK /* COMMENT_54 */\n                    || VAR_71 == VAR_11.NOT_MODIFIED /* COMMENT_54 */\n                    || VAR_71 == VAR_11.FOUND /* COMMENT_54 */\n                    || (VAR_71 == VAR_11.NOT_FOUND /* COMMENT_54 */\n                    && (VAR_32.equals(\"favicon.ico\") || VAR_32.endsWith(\"/favicon.ico\")))) {\n                /* COMMENT_125 */\n                VAR_26.fine(VAR_72);\n            } else {\n                /* COMMENT_126 */\n                VAR_26.warningWithoutCallerRef(VAR_72);\n            }\n\n        } finally {\n            if (VAR_2) {\n                /* COMMENT_127 */\n                destroyDecoder();\n            }\n        }\n    }",
    "func_graph_path": "lukehutch/gribbit/620418df247aebda3dd4be1dda10fe229ea505dd/HttpRequestHandler.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -227,15 +227,83 @@\n             // Complete websocket handshake if requested\n             // ------------------------------------------------------------------------------\n \n+            // FIXME: Make these into class annotations\n+            String websocketPath = \"/websocket\";\n+            boolean isAuthenticatedWebsocket = true;\n+\n             if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n-            // TODO: Read WS routes from class annotations\n-                    && reqURI.endsWith(\"/websocket\")) {\n+            // TODO: Read WS routes from class annotations, rather than using hardcoded \"/websocket\"\n+                    && reqURI.endsWith(websocketPath)) {\n                 HttpRequest httpReq = (HttpRequest) msg;\n \n-                // Record which user was authenticated (if any) when websocket upgrade request was made.\n-                // TODO: Reject WS upgrade request for websockets that require authentication.\n-                // TODO: Also provide a means for revoking WS login.\n-                wsAuthenticatedUser = User.getLoggedInUser(request);\n+                // Protect against CSWSH: (Cross-Site WebSocket Hijacking)\n+                // http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html\n+                // http://tools.ietf.org/html/rfc6455#page-7\n+                CharSequence origin = request.getOrigin();\n+                URI originUri = null;\n+                if (origin != null && origin.length() > 0) {\n+                    try {\n+                        // Try parsing origin URI\n+                        originUri = new URI(origin.toString());\n+                    } catch (Exception e) {\n+                    }\n+                }\n+                // If port number is set but it is the default for the URI scheme, revert the port number\n+                // back to -1 (which means unspecified), so that it matches the server port number, \n+                // which is unspecified when serving http on port 80 and https on port 443\n+                int originPort = originUri == null ? -1 //\n+                        : originUri.getPort() == 80 && \"http\".equals(originUri.getScheme()) ? -1 //\n+                                : originUri.getPort() == 443 && \"https\".equals(originUri.getScheme()) ? -1 //\n+                                        : originUri.getPort();\n+                // Scheme, host and port all must match to forbid cross-origin requests\n+                if (originUri == null //\n+                        || !GribbitServer.uri.getScheme().equals(originUri.getScheme()) //\n+                        || !GribbitServer.uri.getHost().equals(originUri.getHost()) //\n+                        || GribbitServer.uri.getPort() != originPort) { //\n+                    // Reject scripted requests to open this websocket from a different domain\n+                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                            HttpResponseStatus.FORBIDDEN));\n+                    return;\n+                }\n+                // Log.info(\"Origin: \" + origin.toString());\n+\n+                if (isAuthenticatedWebsocket) {\n+                    // For authenticated websockets, check if the user is logged in\n+                    User loggedInUser = User.getLoggedInUser(request);\n+                    if (loggedInUser == null) {\n+                        // Not logged in, so can't connect to this websocket\n+                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                HttpResponseStatus.FORBIDDEN));\n+                        return;\n+                    }\n+\n+                    // To further mitigate CSWSH attacks: check for the CSRF token in the URL parameter \"_csrf\";\n+                    // the passed token must match the user's CSRF token. This means the websocket URL has to\n+                    // be dynamically generated and inserted into the webpage that opened the websocket.\n+                    // TODO: generate this URL an insert into the page somehow\n+                    String csrfTok = loggedInUser.csrfTok;\n+                    if (csrfTok == null || csrfTok.isEmpty() || csrfTok.equals(CSRF.CSRF_TOKEN_UNKNOWN)\n+                            || csrfTok.equals(CSRF.CSRF_TOKEN_PLACEHOLDER)) {\n+                        // No valid CSRF token in User object\n+                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                HttpResponseStatus.FORBIDDEN));\n+                        return;\n+                    }\n+                    String csrfParam = request.getQueryParam(\"_csrf\");\n+                    if (csrfParam == null || csrfParam.isEmpty() || !csrfParam.equals(csrfTok)) {\n+                        // The CSRF URL query parameter is missing, or doesn't match the user's token \n+                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                HttpResponseStatus.FORBIDDEN));\n+                        return;                        \n+                    }\n+\n+                    // Record which user was authenticated when the websocket upgrade request was made.\n+                    // TODO: Also provide a means for revoking user's session while WS is still open,\n+                    // e.g. poll the user table every few seconds to see if user's session token has\n+                    // changed in the database? (Although this would mean that logging in on a new\n+                    // device would log you out of all other sessions...)\n+                    wsAuthenticatedUser = loggedInUser;\n+                }\n \n                 WebSocketServerHandshakerFactory wsFactory =\n                         new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);",
    "diff_line_info": {
        "deleted_lines": [
            "            // TODO: Read WS routes from class annotations",
            "                    && reqURI.endsWith(\"/websocket\")) {",
            "                // Record which user was authenticated (if any) when websocket upgrade request was made.",
            "                // TODO: Reject WS upgrade request for websockets that require authentication.",
            "                // TODO: Also provide a means for revoking WS login.",
            "                wsAuthenticatedUser = User.getLoggedInUser(request);"
        ],
        "added_lines": [
            "            // FIXME: Make these into class annotations",
            "            String websocketPath = \"/websocket\";",
            "            boolean isAuthenticatedWebsocket = true;",
            "",
            "            // TODO: Read WS routes from class annotations, rather than using hardcoded \"/websocket\"",
            "                    && reqURI.endsWith(websocketPath)) {",
            "                // Protect against CSWSH: (Cross-Site WebSocket Hijacking)",
            "                // http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html",
            "                // http://tools.ietf.org/html/rfc6455#page-7",
            "                CharSequence origin = request.getOrigin();",
            "                URI originUri = null;",
            "                if (origin != null && origin.length() > 0) {",
            "                    try {",
            "                        // Try parsing origin URI",
            "                        originUri = new URI(origin.toString());",
            "                    } catch (Exception e) {",
            "                    }",
            "                }",
            "                // If port number is set but it is the default for the URI scheme, revert the port number",
            "                // back to -1 (which means unspecified), so that it matches the server port number, ",
            "                // which is unspecified when serving http on port 80 and https on port 443",
            "                int originPort = originUri == null ? -1 //",
            "                        : originUri.getPort() == 80 && \"http\".equals(originUri.getScheme()) ? -1 //",
            "                                : originUri.getPort() == 443 && \"https\".equals(originUri.getScheme()) ? -1 //",
            "                                        : originUri.getPort();",
            "                // Scheme, host and port all must match to forbid cross-origin requests",
            "                if (originUri == null //",
            "                        || !GribbitServer.uri.getScheme().equals(originUri.getScheme()) //",
            "                        || !GribbitServer.uri.getHost().equals(originUri.getHost()) //",
            "                        || GribbitServer.uri.getPort() != originPort) { //",
            "                    // Reject scripted requests to open this websocket from a different domain",
            "                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,",
            "                            HttpResponseStatus.FORBIDDEN));",
            "                    return;",
            "                }",
            "                // Log.info(\"Origin: \" + origin.toString());",
            "",
            "                if (isAuthenticatedWebsocket) {",
            "                    // For authenticated websockets, check if the user is logged in",
            "                    User loggedInUser = User.getLoggedInUser(request);",
            "                    if (loggedInUser == null) {",
            "                        // Not logged in, so can't connect to this websocket",
            "                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,",
            "                                HttpResponseStatus.FORBIDDEN));",
            "                        return;",
            "                    }",
            "",
            "                    // To further mitigate CSWSH attacks: check for the CSRF token in the URL parameter \"_csrf\";",
            "                    // the passed token must match the user's CSRF token. This means the websocket URL has to",
            "                    // be dynamically generated and inserted into the webpage that opened the websocket.",
            "                    // TODO: generate this URL an insert into the page somehow",
            "                    String csrfTok = loggedInUser.csrfTok;",
            "                    if (csrfTok == null || csrfTok.isEmpty() || csrfTok.equals(CSRF.CSRF_TOKEN_UNKNOWN)",
            "                            || csrfTok.equals(CSRF.CSRF_TOKEN_PLACEHOLDER)) {",
            "                        // No valid CSRF token in User object",
            "                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,",
            "                                HttpResponseStatus.FORBIDDEN));",
            "                        return;",
            "                    }",
            "                    String csrfParam = request.getQueryParam(\"_csrf\");",
            "                    if (csrfParam == null || csrfParam.isEmpty() || !csrfParam.equals(csrfTok)) {",
            "                        // The CSRF URL query parameter is missing, or doesn't match the user's token ",
            "                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,",
            "                                HttpResponseStatus.FORBIDDEN));",
            "                        return;                        ",
            "                    }",
            "",
            "                    // Record which user was authenticated when the websocket upgrade request was made.",
            "                    // TODO: Also provide a means for revoking user's session while WS is still open,",
            "                    // e.g. poll the user table every few seconds to see if user's session token has",
            "                    // changed in the database? (Although this would mean that logging in on a new",
            "                    // device would log you out of all other sessions...)",
            "                    wsAuthenticatedUser = loggedInUser;",
            "                }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}