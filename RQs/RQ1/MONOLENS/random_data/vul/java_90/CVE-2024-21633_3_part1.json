{
    "cve_id": "CVE-2024-21633",
    "cwe_ids": [
        "CWE-22"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "iBotPeaches/Apktool",
    "commit_msg": "Prevent arbitrary file writes with malicious resource names. (#3484)\n\n* refactor: rename sanitize function\r\n\r\n* fix: expose getDir\r\n\r\n* fix: safe handling of untrusted resource names\r\n\r\n - fixes: GHSA-2hqv-2xv4-5h5w\r\n\r\n* test: sample file for GHSA-2hqv-2xv4-5h5w\r\n\r\n* refactor: avoid detection of absolute files for resource check\r\n\r\n* chore: enable info mode on gradle\r\n\r\n* test: skip test on windows\r\n\r\n* chore: debug windows handling\r\n\r\n* fix: normalize entry with file separators\r\n\r\n* fix: normalize filepath after cleansing\r\n\r\n* chore: Android paths are not OS specific\r\n\r\n* refactor: use java.nio for path traversal checking\r\n\r\n* chore: align path separator on Windows for Zip files\r\n\r\n* chore: rework towards basic directory traversal\r\n\r\n* chore: remove '--info' on build.yml",
    "commit_hash": "d348c43b24a9de350ff6e5bd610545a10c1fc712",
    "git_url": "https://github.com/iBotPeaches/Apktool/commit/d348c43b24a9de350ff6e5bd610545a10c1fc712",
    "file_path": "brut.j.dir/src/main/java/brut/directory/ZipUtils.java",
    "func_name": "processFolder",
    "func_before": "private static void processFolder(final File folder, final ZipOutputStream zipOutputStream, final int prefixLength)\n            throws BrutException, IOException {\n        for (final File file : folder.listFiles()) {\n            if (file.isFile()) {\n                final String cleanedPath = BrutIO.sanitizeUnknownFile(folder, file.getPath().substring(prefixLength));\n                final ZipEntry zipEntry = new ZipEntry(BrutIO.normalizePath(cleanedPath));\n\n                // aapt binary by default takes in parameters via -0 arsc to list extensions that shouldn't be\n                // compressed. We will replicate that behavior\n                final String extension = FilenameUtils.getExtension(file.getAbsolutePath());\n                if (mDoNotCompress != null && (mDoNotCompress.contains(extension) || mDoNotCompress.contains(zipEntry.getName()))) {\n                    zipEntry.setMethod(ZipEntry.STORED);\n                    zipEntry.setSize(file.length());\n                    BufferedInputStream unknownFile = new BufferedInputStream(Files.newInputStream(file.toPath()));\n                    CRC32 crc = BrutIO.calculateCrc(unknownFile);\n                    zipEntry.setCrc(crc.getValue());\n                    unknownFile.close();\n                } else {\n                    zipEntry.setMethod(ZipEntry.DEFLATED);\n                }\n\n                zipOutputStream.putNextEntry(zipEntry);\n                try (FileInputStream inputStream = new FileInputStream(file)) {\n                    IOUtils.copy(inputStream, zipOutputStream);\n                }\n                zipOutputStream.closeEntry();\n            } else if (file.isDirectory()) {\n                processFolder(file, zipOutputStream, prefixLength);\n            }\n        }\n    }",
    "abstract_func_before": "private static void processFolder(final File VAR_0, final ZipOutputStream VAR_1, final int VAR_2)\n            throws BrutException, IOException {\n        for (final File VAR_3 : VAR_0.listFiles()) {\n            if (VAR_3.isFile()) {\n                final String VAR_4 = VAR_5.sanitizeUnknownFile(VAR_0, VAR_3.getPath().substring(VAR_2));\n                final ZipEntry VAR_6 = new ZipEntry(VAR_5.normalizePath(VAR_4));\n\n                /* COMMENT_0 */\n                /* COMMENT_1 */\n                final String VAR_7 = VAR_8.getExtension(VAR_3.getAbsolutePath());\n                if (VAR_9 != null && (VAR_9.contains(VAR_7) || VAR_9.contains(VAR_6.getName()))) {\n                    VAR_6.setMethod(VAR_10.STORED);\n                    VAR_6.setSize(VAR_3.length());\n                    BufferedInputStream VAR_11 = new BufferedInputStream(VAR_12.newInputStream(VAR_3.toPath()));\n                    CRC32 VAR_13 = VAR_5.calculateCrc(VAR_11);\n                    VAR_6.setCrc(VAR_13.getValue());\n                    VAR_11.close();\n                } else {\n                    VAR_6.setMethod(VAR_10.DEFLATED);\n                }\n\n                VAR_1.putNextEntry(VAR_6);\n                try (FileInputStream VAR_14 = new FileInputStream(VAR_3)) {\n                    VAR_15.copy(VAR_14, VAR_1);\n                }\n                VAR_1.closeEntry();\n            } else if (VAR_3.isDirectory()) {\n                processFolder(VAR_3, VAR_1, VAR_2);\n            }\n        }\n    }",
    "func_graph_path_before": "iBotPeaches/Apktool/d348c43b24a9de350ff6e5bd610545a10c1fc712/ZipUtils.java/vul/before/0.json",
    "func": "private static void processFolder(final File folder, final ZipOutputStream zipOutputStream, final int prefixLength)\n            throws BrutException, IOException {\n        for (final File file : folder.listFiles()) {\n            if (file.isFile()) {\n                final String cleanedPath = BrutIO.sanitizeFilepath(folder, file.getPath().substring(prefixLength));\n                final ZipEntry zipEntry = new ZipEntry(BrutIO.adaptSeparatorToUnix(cleanedPath));\n\n                // aapt binary by default takes in parameters via -0 arsc to list extensions that shouldn't be\n                // compressed. We will replicate that behavior\n                final String extension = FilenameUtils.getExtension(file.getAbsolutePath());\n                if (mDoNotCompress != null && (mDoNotCompress.contains(extension) || mDoNotCompress.contains(zipEntry.getName()))) {\n                    zipEntry.setMethod(ZipEntry.STORED);\n                    zipEntry.setSize(file.length());\n                    BufferedInputStream unknownFile = new BufferedInputStream(Files.newInputStream(file.toPath()));\n                    CRC32 crc = BrutIO.calculateCrc(unknownFile);\n                    zipEntry.setCrc(crc.getValue());\n                    unknownFile.close();\n                } else {\n                    zipEntry.setMethod(ZipEntry.DEFLATED);\n                }\n\n                zipOutputStream.putNextEntry(zipEntry);\n                try (FileInputStream inputStream = new FileInputStream(file)) {\n                    IOUtils.copy(inputStream, zipOutputStream);\n                }\n                zipOutputStream.closeEntry();\n            } else if (file.isDirectory()) {\n                processFolder(file, zipOutputStream, prefixLength);\n            }\n        }\n    }",
    "abstract_func": "private static void processFolder(final File VAR_0, final ZipOutputStream VAR_1, final int VAR_2)\n            throws BrutException, IOException {\n        for (final File VAR_3 : VAR_0.listFiles()) {\n            if (VAR_3.isFile()) {\n                final String VAR_4 = VAR_5.sanitizeFilepath(VAR_0, VAR_3.getPath().substring(VAR_2));\n                final ZipEntry VAR_6 = new ZipEntry(VAR_5.adaptSeparatorToUnix(VAR_4));\n\n                /* COMMENT_0 */\n                /* COMMENT_1 */\n                final String VAR_7 = VAR_8.getExtension(VAR_3.getAbsolutePath());\n                if (VAR_9 != null && (VAR_9.contains(VAR_7) || VAR_9.contains(VAR_6.getName()))) {\n                    VAR_6.setMethod(VAR_10.STORED);\n                    VAR_6.setSize(VAR_3.length());\n                    BufferedInputStream VAR_11 = new BufferedInputStream(VAR_12.newInputStream(VAR_3.toPath()));\n                    CRC32 VAR_13 = VAR_5.calculateCrc(VAR_11);\n                    VAR_6.setCrc(VAR_13.getValue());\n                    VAR_11.close();\n                } else {\n                    VAR_6.setMethod(VAR_10.DEFLATED);\n                }\n\n                VAR_1.putNextEntry(VAR_6);\n                try (FileInputStream VAR_14 = new FileInputStream(VAR_3)) {\n                    VAR_15.copy(VAR_14, VAR_1);\n                }\n                VAR_1.closeEntry();\n            } else if (VAR_3.isDirectory()) {\n                processFolder(VAR_3, VAR_1, VAR_2);\n            }\n        }\n    }",
    "func_graph_path": "iBotPeaches/Apktool/d348c43b24a9de350ff6e5bd610545a10c1fc712/ZipUtils.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,8 @@\n             throws BrutException, IOException {\n         for (final File file : folder.listFiles()) {\n             if (file.isFile()) {\n-                final String cleanedPath = BrutIO.sanitizeUnknownFile(folder, file.getPath().substring(prefixLength));\n-                final ZipEntry zipEntry = new ZipEntry(BrutIO.normalizePath(cleanedPath));\n+                final String cleanedPath = BrutIO.sanitizeFilepath(folder, file.getPath().substring(prefixLength));\n+                final ZipEntry zipEntry = new ZipEntry(BrutIO.adaptSeparatorToUnix(cleanedPath));\n \n                 // aapt binary by default takes in parameters via -0 arsc to list extensions that shouldn't be\n                 // compressed. We will replicate that behavior",
    "diff_line_info": {
        "deleted_lines": [
            "                final String cleanedPath = BrutIO.sanitizeUnknownFile(folder, file.getPath().substring(prefixLength));",
            "                final ZipEntry zipEntry = new ZipEntry(BrutIO.normalizePath(cleanedPath));"
        ],
        "added_lines": [
            "                final String cleanedPath = BrutIO.sanitizeFilepath(folder, file.getPath().substring(prefixLength));",
            "                final ZipEntry zipEntry = new ZipEntry(BrutIO.adaptSeparatorToUnix(cleanedPath));"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/iBotPeaches/Apktool/pull/3484",
    "description": "Fixes: [#GHSA-2hqv-2xv4-5h5w](https://github.com/iBotPeaches/Apktool/security/advisories/GHSA-2hqv-2xv4-5h5w)"
}