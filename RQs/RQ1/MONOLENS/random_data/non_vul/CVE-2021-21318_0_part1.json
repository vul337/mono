{
    "cve_id": "CVE-2021-21318",
    "cwe_ids": [
        "CWE-863"
    ],
    "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "opencast",
    "commit_msg": "Fix Engage Series Publication and Access\n\nAccess to series and series metadata on the search service (shown in\nmedia module and player) depends on the events published which are part\nof the series. Publishing an event will automatically publish a series\nand update access to it. Removing an event or republishing the event\nshould do the same.\n\nIncorrectly Hiding Public Series\n--------------------------------\n\nThis patch fixes the access control update to the series when a new\nepisode is being published. Until now, a new episode publication would\nalways update the series access with the episode access.\n\nWhile this is no security issue since it can only cause the access to be\nstricter, it may cause public series to become private. This would\nhappen, for example, if a users sets one episode of a series to private\nand republishes the episode.\n\nNow, the search service will merge the access control lists of all\nepisodes to grant access based on their combined access rules.\n\nUpdate Series on Removal\n------------------------\n\nThis patch fixes Opencast not updating the series access or remove a\npublished series if an event is being removed.\n\nThis means that access to a series is re-calculated when an episode is\nbeing deleted based on the remaining published episodes in the series.\nFor example, removing the last episode with public access will now make\nthe series private which it would have stayed public before.\n\nIt also means that if the last episode of a series is being removed, the\nseries itself will be unpublished as well, so no empty series will\ncontinue to show up any longer.",
    "commit_hash": "b18c6a7f81f08ed14884592a6c14c9ab611ad450",
    "git_url": "https://github.com/opencast/opencast/commit/b18c6a7f81f08ed14884592a6c14c9ab611ad450",
    "file_path": "modules/search-service-impl/src/main/java/org/opencastproject/search/impl/SearchServiceImpl.java",
    "func_name": "deleteSynchronously",
    "func_before": "public boolean deleteSynchronously(String mediaPackageId) throws SearchException, UnauthorizedException,\n          NotFoundException {\n    SearchResult result;\n    try {\n      result = solrRequester.getForWrite(new SearchQuery().withId(mediaPackageId));\n      if (result.getItems().length == 0) {\n        logger.warn(\n                \"Can not delete mediapackage {}, which is not available for the current user to delete from the search index.\",\n                mediaPackageId);\n        return false;\n      }\n      logger.info(\"Removing mediapackage {} from search index\", mediaPackageId);\n\n      Date now = new Date();\n      try {\n        persistence.deleteMediaPackage(mediaPackageId, now);\n        logger.info(\"Removed mediapackage {} from search persistence\", mediaPackageId);\n      } catch (NotFoundException e) {\n        // even if mp not found in persistence, it might still exist in search index.\n        logger.info(\"Could not find mediapackage with id {} in persistence, but will try remove it from index, anyway.\",\n                mediaPackageId);\n      } catch (SearchServiceDatabaseException e) {\n        logger.error(\"Could not delete media package with id {} from persistence storage\", mediaPackageId);\n        throw new SearchException(e);\n      }\n\n      return indexManager.delete(mediaPackageId, now);\n    } catch (SolrServerException e) {\n      logger.info(\"Could not delete media package with id {} from search index\", mediaPackageId);\n      throw new SearchException(e);\n    }\n  }",
    "abstract_func_before": "public boolean deleteSynchronously(String VAR_0) throws SearchException, UnauthorizedException,\n          NotFoundException {\n    SearchResult VAR_1;\n    try {\n      VAR_1 = VAR_2.getForWrite(new SearchQuery().withId(VAR_0));\n      if (VAR_1.getItems().length == 0) {\n        VAR_3.warn(\n                \"Can not delete mediapackage {}, which is not available for the current user to delete from the search index.\",\n                VAR_0);\n        return false;\n      }\n      VAR_3.info(\"Removing mediapackage {} from search index\", VAR_0);\n\n      Date VAR_4 = new Date();\n      try {\n        VAR_5.deleteMediaPackage(VAR_0, VAR_4);\n        VAR_3.info(\"Removed mediapackage {} from search persistence\", VAR_0);\n      } catch (NotFoundException VAR_6) {\n        /* COMMENT_0 */\n        VAR_3.info(\"Could not find mediapackage with id {} in persistence, but will try remove it from index, anyway.\",\n                VAR_0);\n      } catch (SearchServiceDatabaseException VAR_6) {\n        VAR_3.error(\"Could not delete media package with id {} from persistence storage\", VAR_0);\n        throw new SearchException(VAR_6);\n      }\n\n      return VAR_7.delete(VAR_0, VAR_4);\n    } catch (SolrServerException VAR_6) {\n      VAR_3.info(\"Could not delete media package with id {} from search index\", VAR_0);\n      throw new SearchException(VAR_6);\n    }\n  }",
    "func_graph_path_before": "opencast/b18c6a7f81f08ed14884592a6c14c9ab611ad450/SearchServiceImpl.java/vul/before/1.json",
    "func": "public boolean deleteSynchronously(final String mediaPackageId) throws SearchException {\n    SearchResult result;\n    try {\n      result = solrRequester.getForWrite(new SearchQuery().withId(mediaPackageId));\n      if (result.getItems().length == 0) {\n        logger.warn(\n                \"Can not delete mediapackage {}, which is not available for the current user to delete from the search index.\",\n                mediaPackageId);\n        return false;\n      }\n      final String seriesId = result.getItems()[0].getDcIsPartOf();\n      logger.info(\"Removing media package {} from search index\", mediaPackageId);\n\n      Date now = new Date();\n      try {\n        persistence.deleteMediaPackage(mediaPackageId, now);\n        logger.info(\"Removed mediapackage {} from search persistence\", mediaPackageId);\n      } catch (NotFoundException e) {\n        // even if mp not found in persistence, it might still exist in search index.\n        logger.info(\"Could not find mediapackage with id {} in persistence, but will try remove it from index, anyway.\",\n                mediaPackageId);\n      } catch (SearchServiceDatabaseException e) {\n        logger.error(\"Could not delete media package with id {} from persistence storage\", mediaPackageId);\n        throw new SearchException(e);\n      }\n\n      final boolean success = indexManager.delete(mediaPackageId, now);\n\n      // Update series\n      if (seriesId != null) {\n        if (persistence.getMediaPackages(seriesId).size() > 0) {\n          // Update series acl if there are still episodes in the series\n          final AccessControlList seriesAcl = persistence.getAccessControlLists(seriesId).stream()\n              .reduce(new AccessControlList(), AccessControlList::mergeActions);\n          indexManager.addSeries(seriesId, seriesAcl);\n\n        } else {\n          // Remove series if there are no episodes in the series any longer\n          indexManager.delete(seriesId, now);\n        }\n      }\n\n      return success;\n    } catch (SolrServerException | SearchServiceDatabaseException e) {\n      logger.info(\"Could not delete media package with id {} from search index\", mediaPackageId);\n      throw new SearchException(e);\n    }\n  }",
    "abstract_func": "public boolean deleteSynchronously(final String VAR_0) throws SearchException {\n    SearchResult VAR_1;\n    try {\n      VAR_1 = VAR_2.getForWrite(new SearchQuery().withId(VAR_0));\n      if (VAR_1.getItems().length == 0) {\n        VAR_3.warn(\n                \"Can not delete mediapackage {}, which is not available for the current user to delete from the search index.\",\n                VAR_0);\n        return false;\n      }\n      final String VAR_4 = VAR_1.getItems()[0].getDcIsPartOf();\n      VAR_3.info(\"Removing media package {} from search index\", VAR_0);\n\n      Date VAR_5 = new Date();\n      try {\n        VAR_6.deleteMediaPackage(VAR_0, VAR_5);\n        VAR_3.info(\"Removed mediapackage {} from search persistence\", VAR_0);\n      } catch (NotFoundException VAR_7) {\n        /* COMMENT_0 */\n        VAR_3.info(\"Could not find mediapackage with id {} in persistence, but will try remove it from index, anyway.\",\n                VAR_0);\n      } catch (SearchServiceDatabaseException VAR_7) {\n        VAR_3.error(\"Could not delete media package with id {} from persistence storage\", VAR_0);\n        throw new SearchException(VAR_7);\n      }\n\n      final boolean VAR_8 = VAR_9.delete(VAR_0, VAR_5);\n\n      /* COMMENT_1 */\n      if (VAR_4 != null) {\n        if (VAR_6.getMediaPackages(VAR_4).size() > 0) {\n          /* COMMENT_2 */\n          final AccessControlList VAR_10 = VAR_6.getAccessControlLists(VAR_4).stream()\n              .reduce(new AccessControlList(), VAR_11::VAR_12);\n          VAR_9.addSeries(VAR_4, VAR_10);\n\n        } else {\n          /* COMMENT_3 */\n          VAR_9.delete(VAR_4, VAR_5);\n        }\n      }\n\n      return VAR_8;\n    } catch (SolrServerException | SearchServiceDatabaseException VAR_7) {\n      VAR_3.info(\"Could not delete media package with id {} from search index\", VAR_0);\n      throw new SearchException(VAR_7);\n    }\n  }",
    "func_graph_path": "opencast/b18c6a7f81f08ed14884592a6c14c9ab611ad450/SearchServiceImpl.java/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,4 @@\n-public boolean deleteSynchronously(String mediaPackageId) throws SearchException, UnauthorizedException,\n-          NotFoundException {\n+public boolean deleteSynchronously(final String mediaPackageId) throws SearchException {\n     SearchResult result;\n     try {\n       result = solrRequester.getForWrite(new SearchQuery().withId(mediaPackageId));\n@@ -9,7 +8,8 @@\n                 mediaPackageId);\n         return false;\n       }\n-      logger.info(\"Removing mediapackage {} from search index\", mediaPackageId);\n+      final String seriesId = result.getItems()[0].getDcIsPartOf();\n+      logger.info(\"Removing media package {} from search index\", mediaPackageId);\n \n       Date now = new Date();\n       try {\n@@ -24,8 +24,24 @@\n         throw new SearchException(e);\n       }\n \n-      return indexManager.delete(mediaPackageId, now);\n-    } catch (SolrServerException e) {\n+      final boolean success = indexManager.delete(mediaPackageId, now);\n+\n+      // Update series\n+      if (seriesId != null) {\n+        if (persistence.getMediaPackages(seriesId).size() > 0) {\n+          // Update series acl if there are still episodes in the series\n+          final AccessControlList seriesAcl = persistence.getAccessControlLists(seriesId).stream()\n+              .reduce(new AccessControlList(), AccessControlList::mergeActions);\n+          indexManager.addSeries(seriesId, seriesAcl);\n+\n+        } else {\n+          // Remove series if there are no episodes in the series any longer\n+          indexManager.delete(seriesId, now);\n+        }\n+      }\n+\n+      return success;\n+    } catch (SolrServerException | SearchServiceDatabaseException e) {\n       logger.info(\"Could not delete media package with id {} from search index\", mediaPackageId);\n       throw new SearchException(e);\n     }",
    "diff_line_info": {
        "deleted_lines": [
            "public boolean deleteSynchronously(String mediaPackageId) throws SearchException, UnauthorizedException,",
            "          NotFoundException {",
            "      logger.info(\"Removing mediapackage {} from search index\", mediaPackageId);",
            "      return indexManager.delete(mediaPackageId, now);",
            "    } catch (SolrServerException e) {"
        ],
        "added_lines": [
            "public boolean deleteSynchronously(final String mediaPackageId) throws SearchException {",
            "      final String seriesId = result.getItems()[0].getDcIsPartOf();",
            "      logger.info(\"Removing media package {} from search index\", mediaPackageId);",
            "      final boolean success = indexManager.delete(mediaPackageId, now);",
            "",
            "      // Update series",
            "      if (seriesId != null) {",
            "        if (persistence.getMediaPackages(seriesId).size() > 0) {",
            "          // Update series acl if there are still episodes in the series",
            "          final AccessControlList seriesAcl = persistence.getAccessControlLists(seriesId).stream()",
            "              .reduce(new AccessControlList(), AccessControlList::mergeActions);",
            "          indexManager.addSeries(seriesId, seriesAcl);",
            "",
            "        } else {",
            "          // Remove series if there are no episodes in the series any longer",
            "          indexManager.delete(seriesId, now);",
            "        }",
            "      }",
            "",
            "      return success;",
            "    } catch (SolrServerException | SearchServiceDatabaseException e) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}