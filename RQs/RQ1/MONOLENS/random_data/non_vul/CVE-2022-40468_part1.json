{
    "cve_id": "CVE-2022-40468",
    "cwe_ids": [
        "CWE-1188"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cvss_is_v3": true,
    "repo_name": "tinyproxy",
    "commit_msg": "prevent junk from showing up in error page in invalid requests\n\nfixes #457",
    "commit_hash": "3764b8551463b900b5b4e3ec0cd9bb9182191cb7",
    "git_url": "https://github.com/tinyproxy/tinyproxy/commit/3764b8551463b900b5b4e3ec0cd9bb9182191cb7",
    "file_path": "src/reqs.c",
    "func_name": "process_request",
    "func_before": "static struct request_s *process_request (struct conn_s *connptr,\n                                          orderedmap hashofheaders)\n{\n        char *url;\n        struct request_s *request;\n        int ret, skip_trans;\n        size_t request_len;\n\n        skip_trans = 0;\n\n        /* NULL out all the fields so frees don't cause segfaults. */\n        request =\n            (struct request_s *) safecalloc (1, sizeof (struct request_s));\n        if (!request)\n                return NULL;\n\n        request_len = strlen (connptr->request_line) + 1;\n\n        request->method = (char *) safemalloc (request_len);\n        url = (char *) safemalloc (request_len);\n        request->protocol = (char *) safemalloc (request_len);\n\n        if (!request->method || !url || !request->protocol) {\n                goto fail;\n        }\n\n        ret = sscanf (connptr->request_line, \"%[^ ] %[^ ] %[^ ]\",\n                      request->method, url, request->protocol);\n        if (ret == 2 && !strcasecmp (request->method, \"GET\")) {\n                request->protocol[0] = 0;\n\n                /* Indicate that this is a HTTP/0.9 GET request */\n                connptr->protocol.major = 0;\n                connptr->protocol.minor = 9;\n        } else if (ret == 3 && !strncasecmp (request->protocol, \"HTTP/\", 5)) {\n                /*\n                 * Break apart the protocol and update the connection\n                 * structure.\n                 */\n                ret = sscanf (request->protocol + 5, \"%u.%u\",\n                              &connptr->protocol.major,\n                              &connptr->protocol.minor);\n\n                /*\n                 * If the conversion doesn't succeed, drop down below and\n                 * send the error to the user.\n                 */\n                if (ret != 2)\n                        goto BAD_REQUEST_ERROR;\n        } else {\nBAD_REQUEST_ERROR:\n                log_message (LOG_ERR,\n                             \"process_request: Bad Request on file descriptor %d\",\n                             connptr->client_fd);\n                indicate_http_error (connptr, 400, \"Bad Request\",\n                                     \"detail\", \"Request has an invalid format\",\n                                     \"url\", url, NULL);\n                goto fail;\n        }\n\n#ifdef REVERSE_SUPPORT\n        if (config->reversepath_list != NULL) {\n                /*\n                 * Rewrite the URL based on the reverse path.  After calling\n                 * reverse_rewrite_url \"url\" can be freed since we either\n                 * have the newly rewritten URL, or something failed and\n                 * we'll be closing anyway.\n                 */\n                char *reverse_url;\n                int reverse_status;\n\n                reverse_url = reverse_rewrite_url (connptr, hashofheaders, url, &reverse_status);\n\n                if (reverse_url != NULL) {\n                        if (reverse_status == 301) {\n                                char buf[PATH_MAX];\n                                snprintf (buf, sizeof buf, \"Location: %s\\r\\n\", reverse_url);\n                                send_http_headers (connptr, 301, \"Moved Permanently\", buf);\n                                goto fail;\n                        }\n                        safefree (url);\n                        url = reverse_url;\n                        skip_trans = 1;\n                } else if (config->reverseonly) {\n                        log_message (LOG_ERR,\n                                     \"Bad request, no mapping for '%s' found\",\n                                     url);\n                        indicate_http_error (connptr, 400, \"Bad Request\",\n                                             \"detail\", \"No mapping found for \"\n                                             \"requested url\", \"url\", url, NULL);\n                        goto fail;\n                }\n        }\n#endif\n\n        if (strncasecmp (url, \"http://\", 7) == 0\n            || (UPSTREAM_CONFIGURED () && strncasecmp (url, \"ftp://\", 6) == 0))\n        {\n                char *skipped_type = strstr (url, \"//\") + 2;\n\n                if (extract_url (skipped_type, HTTP_PORT, request) < 0) {\n                        indicate_http_error (connptr, 400, \"Bad Request\",\n                                             \"detail\", \"Could not parse URL\",\n                                             \"url\", url, NULL);\n                        goto fail;\n                }\n        } else if (strcmp (request->method, \"CONNECT\") == 0) {\n                if (extract_url (url, HTTP_PORT_SSL, request) < 0) {\n                        indicate_http_error (connptr, 400, \"Bad Request\",\n                                             \"detail\", \"Could not parse URL\",\n                                             \"url\", url, NULL);\n                        goto fail;\n                }\n\n                /* Verify that the port in the CONNECT method is allowed */\n                if (!check_allowed_connect_ports (request->port,\n                                                  config->connect_ports))\n                {\n                        indicate_http_error (connptr, 403, \"Access violation\",\n                                             \"detail\",\n                                             \"The CONNECT method not allowed \"\n                                             \"with the port you tried to use.\",\n                                             \"url\", url, NULL);\n                        log_message (LOG_INFO,\n                                     \"Refused CONNECT method on port %d\",\n                                     request->port);\n                        goto fail;\n                }\n\n                connptr->connect_method = TRUE;\n        } else {\n#ifdef TRANSPARENT_PROXY\n                if (!skip_trans) {\n                        if (!do_transparent_proxy\n                            (connptr, hashofheaders, request, config, &url))\n                                goto fail;\n                } else\n#endif\n                {\n                indicate_http_error (connptr, 501, \"Not Implemented\",\n                                     \"detail\",\n                                     \"Unknown method or unsupported protocol.\",\n                                     \"url\", url, NULL);\n                log_message (LOG_INFO, \"Unknown method (%s) or protocol (%s)\",\n                             request->method, url);\n                goto fail;\n                }\n        }\n\n#ifdef FILTER_ENABLE\n        /*\n         * Filter restricted domains/urls\n         */\n        if (config->filter) {\n                int fu = config->filter_opts & FILTER_OPT_URL;\n                ret = filter_run (fu ? url : request->host);\n\n                if (ret) {\n                        update_stats (STAT_DENIED);\n\n                        log_message (LOG_NOTICE,\n                                     \"Proxying refused on filtered %s \\\"%s\\\"\",\n                                     fu ? \"url\" : \"domain\",\n                                     fu ? url : request->host);\n\n                        indicate_http_error (connptr, 403, \"Filtered\",\n                                             \"detail\",\n                                             \"The request you made has been filtered\",\n                                             \"url\", url, NULL);\n                        goto fail;\n                }\n        }\n#endif\n\n\n        /*\n         * Check to see if they're requesting the stat host\n         */\n        if (config->stathost && strcmp (config->stathost, request->host) == 0) {\n                log_message (LOG_NOTICE, \"Request for the stathost.\");\n                connptr->show_stats = TRUE;\n                goto fail;\n        }\n\n        safefree (url);\n\n        return request;\n\nfail:\n        safefree (url);\n        free_request_struct (request);\n        return NULL;\n}",
    "abstract_func_before": "static struct request_s *process_request (struct conn_s *VAR_0,\n                                          orderedmap VAR_1)\n{\n        char *VAR_2;\n        struct request_s *VAR_3;\n        int VAR_4, VAR_5;\n        size_t VAR_6;\n\n        VAR_5 = 0;\n\n        /* COMMENT_0 */\n        VAR_3 =\n            (struct request_s *) safecalloc (1, sizeof (struct request_s));\n        if (!VAR_3)\n                return NULL;\n\n        VAR_6 = strlen (VAR_0->request_line) + 1;\n\n        VAR_3->method = (char *) safemalloc (VAR_6);\n        VAR_2 = (char *) safemalloc (VAR_6);\n        VAR_3->protocol = (char *) safemalloc (VAR_6);\n\n        if (!VAR_3->method || !VAR_2 || !VAR_3->protocol) {\n                goto fail;\n        }\n\n        VAR_4 = sscanf (VAR_0->request_line, \"%[^ ] %[^ ] %[^ ]\",\n                      VAR_3->method, VAR_2, VAR_3->protocol);\n        if (VAR_4 == 2 && !strcasecmp (VAR_3->method, \"GET\")) {\n                VAR_3->protocol[0] = 0;\n\n                /* COMMENT_1 */\n                VAR_0->protocol.major = 0;\n                VAR_0->protocol.minor = 9;\n        } else if (VAR_4 == 3 && !strncasecmp (VAR_3->protocol, \"HTTP/\", 5)) {\n                /* COMMENT_2 */\n                                                                     \n                             \n                   \n                VAR_4 = sscanf (VAR_3->protocol + 5, \"%u.%u\",\n                              &VAR_0->protocol.major,\n                              &VAR_0->protocol.minor);\n\n                /* COMMENT_6 */\n                                                                         \n                                              \n                   \n                if (VAR_4 != 2)\n                        goto BAD_REQUEST_ERROR;\n        } else {\nBAD_REQUEST_ERROR:\n                log_message (VAR_7,\n                             \"process_request: Bad Request on file descriptor %d\",\n                             VAR_0->client_fd);\n                indicate_http_error (VAR_0, 400, \"Bad Request\",\n                                     \"detail\", \"Request has an invalid format\",\n                                     \"url\", VAR_2, NULL);\n                goto fail;\n        }\n\n#ifdef VAR_8\n        if (VAR_9->reversepath_list != NULL) {\n                /* COMMENT_10 */\n                                                                            \n                                                                         \n                                                                        \n                                           \n                   \n                char *VAR_10;\n                int VAR_11;\n\n                VAR_10 = reverse_rewrite_url (VAR_0, VAR_1, VAR_2, &VAR_11);\n\n                if (VAR_10 != NULL) {\n                        if (VAR_11 == 301) {\n                                char VAR_12[VAR_13];\n                                snprintf (VAR_12, sizeof VAR_12, \"Location: %s\\r\\n\", VAR_10);\n                                send_http_headers (VAR_0, 301, \"Moved Permanently\", VAR_12);\n                                goto fail;\n                        }\n                        safefree (VAR_2);\n                        VAR_2 = VAR_10;\n                        VAR_5 = 1;\n                } else if (VAR_9->reverseonly) {\n                        log_message (VAR_7,\n                                     \"Bad request, no mapping for '%s' found\",\n                                     VAR_2);\n                        indicate_http_error (VAR_0, 400, \"Bad Request\",\n                                             \"detail\", \"No mapping found for \"\n                                             \"requested url\", \"url\", VAR_2, NULL);\n                        goto fail;\n                }\n        }\n#endif\n\n        if (strncasecmp (VAR_2, \"http://\", 7) == 0\n            || (UPSTREAM_CONFIGURED () && strncasecmp (VAR_2, \"ftp://\", 6) == 0))\n        {\n                char *VAR_14 = strstr (VAR_2, \"//\") + 2;\n\n                if (extract_url (VAR_14, VAR_15, VAR_3) < 0) {\n                        indicate_http_error (VAR_0, 400, \"Bad Request\",\n                                             \"detail\", \"Could not parse URL\",\n                                             \"url\", VAR_2, NULL);\n                        goto fail;\n                }\n        } else if (strcmp (VAR_3->method, \"CONNECT\") == 0) {\n                if (extract_url (VAR_2, VAR_16, VAR_3) < 0) {\n                        indicate_http_error (VAR_0, 400, \"Bad Request\",\n                                             \"detail\", \"Could not parse URL\",\n                                             \"url\", VAR_2, NULL);\n                        goto fail;\n                }\n\n                /* COMMENT_16 */\n                if (!check_allowed_connect_ports (VAR_3->port,\n                                                  VAR_9->connect_ports))\n                {\n                        indicate_http_error (VAR_0, 403, \"Access violation\",\n                                             \"detail\",\n                                             \"The CONNECT method not allowed \"\n                                             \"with the port you tried to use.\",\n                                             \"url\", VAR_2, NULL);\n                        log_message (VAR_17,\n                                     \"Refused CONNECT method on port %d\",\n                                     VAR_3->port);\n                        goto fail;\n                }\n\n                VAR_0->connect_method = TRUE;\n        } else {\n#ifdef VAR_18\n                if (!VAR_5) {\n                        if (!do_transparent_proxy\n                            (VAR_0, VAR_1, VAR_3, VAR_9, &VAR_2))\n                                goto fail;\n                } else\n#endif\n                {\n                indicate_http_error (VAR_0, 501, \"Not Implemented\",\n                                     \"detail\",\n                                     \"Unknown method or unsupported protocol.\",\n                                     \"url\", VAR_2, NULL);\n                log_message (VAR_17, \"Unknown method (%s) or protocol (%s)\",\n                             VAR_3->method, VAR_2);\n                goto fail;\n                }\n        }\n\n#ifdef VAR_19\n        /* COMMENT_17 */\n                                         \n           \n        if (VAR_9->filter) {\n                int VAR_20 = VAR_9->filter_opts & VAR_21;\n                VAR_4 = filter_run (VAR_20 ? VAR_2 : VAR_3->host);\n\n                if (VAR_4) {\n                        update_stats (VAR_22);\n\n                        log_message (VAR_23,\n                                     \"Proxying refused on filtered %s \\\"%s\\\"\",\n                                     VAR_20 ? \"url\" : \"domain\",\n                                     VAR_20 ? VAR_2 : VAR_3->host);\n\n                        indicate_http_error (VAR_0, 403, \"Filtered\",\n                                             \"detail\",\n                                             \"The request you made has been filtered\",\n                                             \"url\", VAR_2, NULL);\n                        goto fail;\n                }\n        }\n#endif\n\n\n        /* COMMENT_20 */\n                                                           \n           \n        if (VAR_9->stathost && strcmp (VAR_9->stathost, VAR_3->host) == 0) {\n                log_message (VAR_23, \"Request for the stathost.\");\n                VAR_0->show_stats = TRUE;\n                goto fail;\n        }\n\n        safefree (VAR_2);\n\n        return VAR_3;\n\nfail:\n        safefree (VAR_2);\n        free_request_struct (VAR_3);\n        return NULL;\n}",
    "func_graph_path_before": "tinyproxy/3764b8551463b900b5b4e3ec0cd9bb9182191cb7/reqs.c/vul/before/0.json",
    "func": "static struct request_s *process_request (struct conn_s *connptr,\n                                          orderedmap hashofheaders)\n{\n        char *url;\n        struct request_s *request;\n        int ret, skip_trans;\n        size_t request_len;\n\n        skip_trans = 0;\n\n        /* NULL out all the fields so frees don't cause segfaults. */\n        request =\n            (struct request_s *) safecalloc (1, sizeof (struct request_s));\n        if (!request)\n                return NULL;\n\n        request_len = strlen (connptr->request_line) + 1;\n\n        request->method = (char *) safemalloc (request_len);\n        url = (char *) safemalloc (request_len);\n        request->protocol = (char *) safemalloc (request_len);\n\n        if (!request->method || !url || !request->protocol) {\n                goto fail;\n        }\n\n        /* zero-terminate the strings so they don't contain junk in error page */\n        request->method[0] = url[0] = request->protocol[0] = 0;\n\n        ret = sscanf (connptr->request_line, \"%[^ ] %[^ ] %[^ ]\",\n                      request->method, url, request->protocol);\n\n        if (ret == 2 && !strcasecmp (request->method, \"GET\")) {\n                request->protocol[0] = 0;\n\n                /* Indicate that this is a HTTP/0.9 GET request */\n                connptr->protocol.major = 0;\n                connptr->protocol.minor = 9;\n        } else if (ret == 3 && !strncasecmp (request->protocol, \"HTTP/\", 5)) {\n                /*\n                 * Break apart the protocol and update the connection\n                 * structure.\n                 */\n                ret = sscanf (request->protocol + 5, \"%u.%u\",\n                              &connptr->protocol.major,\n                              &connptr->protocol.minor);\n\n                /*\n                 * If the conversion doesn't succeed, drop down below and\n                 * send the error to the user.\n                 */\n                if (ret != 2)\n                        goto BAD_REQUEST_ERROR;\n        } else {\nBAD_REQUEST_ERROR:\n                log_message (LOG_ERR,\n                             \"process_request: Bad Request on file descriptor %d\",\n                             connptr->client_fd);\n                indicate_http_error (connptr, 400, \"Bad Request\",\n                                     \"detail\", \"Request has an invalid format\",\n                                     \"url\", url, NULL);\n                goto fail;\n        }\n\n#ifdef REVERSE_SUPPORT\n        if (config->reversepath_list != NULL) {\n                /*\n                 * Rewrite the URL based on the reverse path.  After calling\n                 * reverse_rewrite_url \"url\" can be freed since we either\n                 * have the newly rewritten URL, or something failed and\n                 * we'll be closing anyway.\n                 */\n                char *reverse_url;\n                int reverse_status;\n\n                reverse_url = reverse_rewrite_url (connptr, hashofheaders, url, &reverse_status);\n\n                if (reverse_url != NULL) {\n                        if (reverse_status == 301) {\n                                char buf[PATH_MAX];\n                                snprintf (buf, sizeof buf, \"Location: %s\\r\\n\", reverse_url);\n                                send_http_headers (connptr, 301, \"Moved Permanently\", buf);\n                                goto fail;\n                        }\n                        safefree (url);\n                        url = reverse_url;\n                        skip_trans = 1;\n                } else if (config->reverseonly) {\n                        log_message (LOG_ERR,\n                                     \"Bad request, no mapping for '%s' found\",\n                                     url);\n                        indicate_http_error (connptr, 400, \"Bad Request\",\n                                             \"detail\", \"No mapping found for \"\n                                             \"requested url\", \"url\", url, NULL);\n                        goto fail;\n                }\n        }\n#endif\n\n        if (strncasecmp (url, \"http://\", 7) == 0\n            || (UPSTREAM_CONFIGURED () && strncasecmp (url, \"ftp://\", 6) == 0))\n        {\n                char *skipped_type = strstr (url, \"//\") + 2;\n\n                if (extract_url (skipped_type, HTTP_PORT, request) < 0) {\n                        indicate_http_error (connptr, 400, \"Bad Request\",\n                                             \"detail\", \"Could not parse URL\",\n                                             \"url\", url, NULL);\n                        goto fail;\n                }\n        } else if (strcmp (request->method, \"CONNECT\") == 0) {\n                if (extract_url (url, HTTP_PORT_SSL, request) < 0) {\n                        indicate_http_error (connptr, 400, \"Bad Request\",\n                                             \"detail\", \"Could not parse URL\",\n                                             \"url\", url, NULL);\n                        goto fail;\n                }\n\n                /* Verify that the port in the CONNECT method is allowed */\n                if (!check_allowed_connect_ports (request->port,\n                                                  config->connect_ports))\n                {\n                        indicate_http_error (connptr, 403, \"Access violation\",\n                                             \"detail\",\n                                             \"The CONNECT method not allowed \"\n                                             \"with the port you tried to use.\",\n                                             \"url\", url, NULL);\n                        log_message (LOG_INFO,\n                                     \"Refused CONNECT method on port %d\",\n                                     request->port);\n                        goto fail;\n                }\n\n                connptr->connect_method = TRUE;\n        } else {\n#ifdef TRANSPARENT_PROXY\n                if (!skip_trans) {\n                        if (!do_transparent_proxy\n                            (connptr, hashofheaders, request, config, &url))\n                                goto fail;\n                } else\n#endif\n                {\n                indicate_http_error (connptr, 501, \"Not Implemented\",\n                                     \"detail\",\n                                     \"Unknown method or unsupported protocol.\",\n                                     \"url\", url, NULL);\n                log_message (LOG_INFO, \"Unknown method (%s) or protocol (%s)\",\n                             request->method, url);\n                goto fail;\n                }\n        }\n\n#ifdef FILTER_ENABLE\n        /*\n         * Filter restricted domains/urls\n         */\n        if (config->filter) {\n                int fu = config->filter_opts & FILTER_OPT_URL;\n                ret = filter_run (fu ? url : request->host);\n\n                if (ret) {\n                        update_stats (STAT_DENIED);\n\n                        log_message (LOG_NOTICE,\n                                     \"Proxying refused on filtered %s \\\"%s\\\"\",\n                                     fu ? \"url\" : \"domain\",\n                                     fu ? url : request->host);\n\n                        indicate_http_error (connptr, 403, \"Filtered\",\n                                             \"detail\",\n                                             \"The request you made has been filtered\",\n                                             \"url\", url, NULL);\n                        goto fail;\n                }\n        }\n#endif\n\n\n        /*\n         * Check to see if they're requesting the stat host\n         */\n        if (config->stathost && strcmp (config->stathost, request->host) == 0) {\n                log_message (LOG_NOTICE, \"Request for the stathost.\");\n                connptr->show_stats = TRUE;\n                goto fail;\n        }\n\n        safefree (url);\n\n        return request;\n\nfail:\n        safefree (url);\n        free_request_struct (request);\n        return NULL;\n}",
    "abstract_func": "static struct request_s *process_request (struct conn_s *VAR_0,\n                                          orderedmap VAR_1)\n{\n        char *VAR_2;\n        struct request_s *VAR_3;\n        int VAR_4, VAR_5;\n        size_t VAR_6;\n\n        VAR_5 = 0;\n\n        /* COMMENT_0 */\n        VAR_3 =\n            (struct request_s *) safecalloc (1, sizeof (struct request_s));\n        if (!VAR_3)\n                return NULL;\n\n        VAR_6 = strlen (VAR_0->request_line) + 1;\n\n        VAR_3->method = (char *) safemalloc (VAR_6);\n        VAR_2 = (char *) safemalloc (VAR_6);\n        VAR_3->protocol = (char *) safemalloc (VAR_6);\n\n        if (!VAR_3->method || !VAR_2 || !VAR_3->protocol) {\n                goto fail;\n        }\n\n        /* COMMENT_1 */\n        VAR_3->method[0] = VAR_2[0] = VAR_3->protocol[0] = 0;\n\n        VAR_4 = sscanf (VAR_0->request_line, \"%[^ ] %[^ ] %[^ ]\",\n                      VAR_3->method, VAR_2, VAR_3->protocol);\n\n        if (VAR_4 == 2 && !strcasecmp (VAR_3->method, \"GET\")) {\n                VAR_3->protocol[0] = 0;\n\n                /* COMMENT_2 */\n                VAR_0->protocol.major = 0;\n                VAR_0->protocol.minor = 9;\n        } else if (VAR_4 == 3 && !strncasecmp (VAR_3->protocol, \"HTTP/\", 5)) {\n                /* COMMENT_3 */\n                                                                     \n                             \n                   \n                VAR_4 = sscanf (VAR_3->protocol + 5, \"%u.%u\",\n                              &VAR_0->protocol.major,\n                              &VAR_0->protocol.minor);\n\n                /* COMMENT_7 */\n                                                                         \n                                              \n                   \n                if (VAR_4 != 2)\n                        goto BAD_REQUEST_ERROR;\n        } else {\nBAD_REQUEST_ERROR:\n                log_message (VAR_7,\n                             \"process_request: Bad Request on file descriptor %d\",\n                             VAR_0->client_fd);\n                indicate_http_error (VAR_0, 400, \"Bad Request\",\n                                     \"detail\", \"Request has an invalid format\",\n                                     \"url\", VAR_2, NULL);\n                goto fail;\n        }\n\n#ifdef VAR_8\n        if (VAR_9->reversepath_list != NULL) {\n                /* COMMENT_11 */\n                                                                            \n                                                                         \n                                                                        \n                                           \n                   \n                char *VAR_10;\n                int VAR_11;\n\n                VAR_10 = reverse_rewrite_url (VAR_0, VAR_1, VAR_2, &VAR_11);\n\n                if (VAR_10 != NULL) {\n                        if (VAR_11 == 301) {\n                                char VAR_12[VAR_13];\n                                snprintf (VAR_12, sizeof VAR_12, \"Location: %s\\r\\n\", VAR_10);\n                                send_http_headers (VAR_0, 301, \"Moved Permanently\", VAR_12);\n                                goto fail;\n                        }\n                        safefree (VAR_2);\n                        VAR_2 = VAR_10;\n                        VAR_5 = 1;\n                } else if (VAR_9->reverseonly) {\n                        log_message (VAR_7,\n                                     \"Bad request, no mapping for '%s' found\",\n                                     VAR_2);\n                        indicate_http_error (VAR_0, 400, \"Bad Request\",\n                                             \"detail\", \"No mapping found for \"\n                                             \"requested url\", \"url\", VAR_2, NULL);\n                        goto fail;\n                }\n        }\n#endif\n\n        if (strncasecmp (VAR_2, \"http://\", 7) == 0\n            || (UPSTREAM_CONFIGURED () && strncasecmp (VAR_2, \"ftp://\", 6) == 0))\n        {\n                char *VAR_14 = strstr (VAR_2, \"//\") + 2;\n\n                if (extract_url (VAR_14, VAR_15, VAR_3) < 0) {\n                        indicate_http_error (VAR_0, 400, \"Bad Request\",\n                                             \"detail\", \"Could not parse URL\",\n                                             \"url\", VAR_2, NULL);\n                        goto fail;\n                }\n        } else if (strcmp (VAR_3->method, \"CONNECT\") == 0) {\n                if (extract_url (VAR_2, VAR_16, VAR_3) < 0) {\n                        indicate_http_error (VAR_0, 400, \"Bad Request\",\n                                             \"detail\", \"Could not parse URL\",\n                                             \"url\", VAR_2, NULL);\n                        goto fail;\n                }\n\n                /* COMMENT_17 */\n                if (!check_allowed_connect_ports (VAR_3->port,\n                                                  VAR_9->connect_ports))\n                {\n                        indicate_http_error (VAR_0, 403, \"Access violation\",\n                                             \"detail\",\n                                             \"The CONNECT method not allowed \"\n                                             \"with the port you tried to use.\",\n                                             \"url\", VAR_2, NULL);\n                        log_message (VAR_17,\n                                     \"Refused CONNECT method on port %d\",\n                                     VAR_3->port);\n                        goto fail;\n                }\n\n                VAR_0->connect_method = TRUE;\n        } else {\n#ifdef VAR_18\n                if (!VAR_5) {\n                        if (!do_transparent_proxy\n                            (VAR_0, VAR_1, VAR_3, VAR_9, &VAR_2))\n                                goto fail;\n                } else\n#endif\n                {\n                indicate_http_error (VAR_0, 501, \"Not Implemented\",\n                                     \"detail\",\n                                     \"Unknown method or unsupported protocol.\",\n                                     \"url\", VAR_2, NULL);\n                log_message (VAR_17, \"Unknown method (%s) or protocol (%s)\",\n                             VAR_3->method, VAR_2);\n                goto fail;\n                }\n        }\n\n#ifdef VAR_19\n        /* COMMENT_18 */\n                                         \n           \n        if (VAR_9->filter) {\n                int VAR_20 = VAR_9->filter_opts & VAR_21;\n                VAR_4 = filter_run (VAR_20 ? VAR_2 : VAR_3->host);\n\n                if (VAR_4) {\n                        update_stats (VAR_22);\n\n                        log_message (VAR_23,\n                                     \"Proxying refused on filtered %s \\\"%s\\\"\",\n                                     VAR_20 ? \"url\" : \"domain\",\n                                     VAR_20 ? VAR_2 : VAR_3->host);\n\n                        indicate_http_error (VAR_0, 403, \"Filtered\",\n                                             \"detail\",\n                                             \"The request you made has been filtered\",\n                                             \"url\", VAR_2, NULL);\n                        goto fail;\n                }\n        }\n#endif\n\n\n        /* COMMENT_21 */\n                                                           \n           \n        if (VAR_9->stathost && strcmp (VAR_9->stathost, VAR_3->host) == 0) {\n                log_message (VAR_23, \"Request for the stathost.\");\n                VAR_0->show_stats = TRUE;\n                goto fail;\n        }\n\n        safefree (VAR_2);\n\n        return VAR_3;\n\nfail:\n        safefree (VAR_2);\n        free_request_struct (VAR_3);\n        return NULL;\n}",
    "func_graph_path": "tinyproxy/3764b8551463b900b5b4e3ec0cd9bb9182191cb7/reqs.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -24,8 +24,12 @@\n                 goto fail;\n         }\n \n+        /* zero-terminate the strings so they don't contain junk in error page */\n+        request->method[0] = url[0] = request->protocol[0] = 0;\n+\n         ret = sscanf (connptr->request_line, \"%[^ ] %[^ ] %[^ ]\",\n                       request->method, url, request->protocol);\n+\n         if (ret == 2 && !strcasecmp (request->method, \"GET\")) {\n                 request->protocol[0] = 0;\n ",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "        /* zero-terminate the strings so they don't contain junk in error page */",
            "        request->method[0] = url[0] = request->protocol[0] = 0;",
            "",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}