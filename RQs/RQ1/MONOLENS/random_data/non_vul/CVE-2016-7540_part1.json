{
    "cve_id": "CVE-2016-7540",
    "cwe_ids": [
        "CWE-19"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "ImageMagick",
    "commit_msg": "Fix abort when writing to rgf format\n\nThe rgf format (LEGO MINDSTORMS EV3 images) caused a software abort because\nexception == NULL. When WriteRGFImage is called from WriteImage, it is only\npassed two parameters, not three. So, removed the extra parameter and use\nimage->exception instead as in other coders.",
    "commit_hash": "a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7",
    "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7",
    "file_path": "coders/rgf.c",
    "func_name": "WriteRGFImage",
    "func_before": "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  int\n    bit;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  unsigned char\n    byte;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if((image->columns > 255L) || (image->rows > 255L))\n    ThrowWriterException(ImageError,\"Dimensions must be less than 255x255\");\n  /*\n    Write header (just the image dimensions)\n  */\n  (void) WriteBlobByte(image,image->columns & 0xff);\n  (void) WriteBlobByte(image,image->rows & 0xff);\n  /*\n    Convert MIFF to bit pixels.\n  */\n  (void) SetImageType(image,BilevelType);\n  x=0;\n  y=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n          /*\n            Write a bitmap byte to the image file.\n          */\n       \t  (void) WriteBlobByte(image,byte);\n          bit=0;\n          byte=0;\n        }\n      p++;\n    }\n    if (bit != 0)\n      (void) WriteBlobByte(image,byte);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "abstract_func_before": "static MagickBooleanType WriteRGFImage(const ImageInfo *VAR_0,Image *VAR_1,\n  ExceptionInfo *VAR_2)\n{\n  MagickBooleanType\n    VAR_3;\n\n  int\n    VAR_4;\n\n  register const PixelPacket\n    *VAR_5;\n\n  register ssize_t\n    VAR_6;\n\n  ssize_t\n    VAR_7;\n\n  unsigned char\n    VAR_8;\n\n  /* COMMENT_0 */\n                           \n    \n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_9);\n  assert(VAR_1 != (Image *) NULL);\n  assert(VAR_1->signature == VAR_9);\n  if (VAR_1->debug != VAR_10)\n    (void) LogMagickEvent(VAR_11,GetMagickModule(),\"%s\",VAR_1->filename);\n  assert(VAR_2 != (ExceptionInfo *) NULL);\n  assert(VAR_2->signature == VAR_9);\n  VAR_3=OpenBlob(VAR_0,VAR_1,VAR_12,VAR_2);\n  if (VAR_3 == VAR_10)\n    return(VAR_3);\n  (void) TransformImageColorspace(VAR_1,VAR_13);\n  if((VAR_1->columns > 255L) || (VAR_1->rows > 255L))\n    ThrowWriterException(VAR_14,\"Dimensions must be less than 255x255\");\n  /* COMMENT_3 */\n                                            \n    \n  (void) WriteBlobByte(VAR_1,VAR_1->columns & 0xff);\n  (void) WriteBlobByte(VAR_1,VAR_1->rows & 0xff);\n  /* COMMENT_6 */\n                               \n    \n  (void) SetImageType(VAR_1,VAR_15);\n  VAR_6=0;\n  VAR_7=0;\n  for (VAR_7=0; VAR_7 < (ssize_t) VAR_1->rows; VAR_7++)\n  {\n    VAR_5=GetVirtualPixels(VAR_1,0,VAR_7,VAR_1->columns,1,VAR_2);\n    if (VAR_5 == (const PixelPacket *) NULL)\n      break;\n    VAR_4=0;\n    VAR_8=0;\n    for (VAR_6=0; VAR_6 < (ssize_t) VAR_1->columns; VAR_6++)\n    {\n      VAR_8>>=1;\n      if (GetPixelLuma(VAR_1,VAR_5) < (VAR_16/2.0))\n        VAR_8|=0x80;\n      VAR_4++;\n      if (VAR_4 == 8)\n        {\n          /* COMMENT_9 */\n                                                  \n            \n       \t  (void) WriteBlobByte(VAR_1,VAR_8);\n          VAR_4=0;\n          VAR_8=0;\n        }\n      VAR_5++;\n    }\n    if (VAR_4 != 0)\n      (void) WriteBlobByte(VAR_1,VAR_8);\n    VAR_3=SetImageProgress(VAR_1,VAR_17,(MagickOffsetType) VAR_7,\n      VAR_1->rows);\n    if (VAR_3 == VAR_10)\n      break;\n  }\n  (void) CloseBlob(VAR_1);\n  return(VAR_18);\n}",
    "func_graph_path_before": "ImageMagick/a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7/rgf.c/vul/before/0.json",
    "func": "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  int\n    bit;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  unsigned char\n    byte;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if((image->columns > 255L) || (image->rows > 255L))\n    ThrowWriterException(ImageError,\"Dimensions must be less than 255x255\");\n  /*\n    Write header (just the image dimensions)\n  */\n  (void) WriteBlobByte(image,image->columns & 0xff);\n  (void) WriteBlobByte(image,image->rows & 0xff);\n  /*\n    Convert MIFF to bit pixels.\n  */\n  (void) SetImageType(image,BilevelType);\n  x=0;\n  y=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n          /*\n            Write a bitmap byte to the image file.\n          */\n       \t  (void) WriteBlobByte(image,byte);\n          bit=0;\n          byte=0;\n        }\n      p++;\n    }\n    if (bit != 0)\n      (void) WriteBlobByte(image,byte);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
    "abstract_func": "static MagickBooleanType WriteRGFImage(const ImageInfo *VAR_0,Image *VAR_1)\n{\n  MagickBooleanType\n    VAR_2;\n\n  int\n    VAR_3;\n\n  register const PixelPacket\n    *VAR_4;\n\n  register ssize_t\n    VAR_5;\n\n  ssize_t\n    VAR_6;\n\n  unsigned char\n    VAR_7;\n\n  /* COMMENT_0 */\n                           \n    \n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_8);\n  assert(VAR_1 != (Image *) NULL);\n  assert(VAR_1->signature == VAR_8);\n  if (VAR_1->debug != VAR_9)\n    (void) LogMagickEvent(VAR_10,GetMagickModule(),\"%s\",VAR_1->filename);\n  VAR_2=OpenBlob(VAR_0,VAR_1,VAR_11,&VAR_1->exception);\n  if (VAR_2 == VAR_9)\n    return(VAR_2);\n  (void) TransformImageColorspace(VAR_1,VAR_12);\n  if((VAR_1->columns > 255L) || (VAR_1->rows > 255L))\n    ThrowWriterException(VAR_13,\"Dimensions must be less than 255x255\");\n  /* COMMENT_3 */\n                                            \n    \n  (void) WriteBlobByte(VAR_1,VAR_1->columns & 0xff);\n  (void) WriteBlobByte(VAR_1,VAR_1->rows & 0xff);\n  /* COMMENT_6 */\n                               \n    \n  (void) SetImageType(VAR_1,VAR_14);\n  VAR_5=0;\n  VAR_6=0;\n  for (VAR_6=0; VAR_6 < (ssize_t) VAR_1->rows; VAR_6++)\n  {\n    VAR_4=GetVirtualPixels(VAR_1,0,VAR_6,VAR_1->columns,1,&VAR_1->exception);\n    if (VAR_4 == (const PixelPacket *) NULL)\n      break;\n    VAR_3=0;\n    VAR_7=0;\n    for (VAR_5=0; VAR_5 < (ssize_t) VAR_1->columns; VAR_5++)\n    {\n      VAR_7>>=1;\n      if (GetPixelLuma(VAR_1,VAR_4) < (VAR_15/2.0))\n        VAR_7|=0x80;\n      VAR_3++;\n      if (VAR_3 == 8)\n        {\n          /* COMMENT_9 */\n                                                  \n            \n       \t  (void) WriteBlobByte(VAR_1,VAR_7);\n          VAR_3=0;\n          VAR_7=0;\n        }\n      VAR_4++;\n    }\n    if (VAR_3 != 0)\n      (void) WriteBlobByte(VAR_1,VAR_7);\n    VAR_2=SetImageProgress(VAR_1,VAR_16,(MagickOffsetType) VAR_6,\n      VAR_1->rows);\n    if (VAR_2 == VAR_9)\n      break;\n  }\n  (void) CloseBlob(VAR_1);\n  return(VAR_17);\n}",
    "func_graph_path": "ImageMagick/a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7/rgf.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,4 @@\n-static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n-  ExceptionInfo *exception)\n+static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)\n {\n   MagickBooleanType\n     status;\n@@ -28,9 +27,7 @@\n   assert(image->signature == MagickSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n-  assert(exception != (ExceptionInfo *) NULL);\n-  assert(exception->signature == MagickSignature);\n-  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n+  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n   if (status == MagickFalse)\n     return(status);\n   (void) TransformImageColorspace(image,sRGBColorspace);\n@@ -49,7 +46,7 @@\n   y=0;\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n-    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n+    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n     if (p == (const PixelPacket *) NULL)\n       break;\n     bit=0;",
    "diff_line_info": {
        "deleted_lines": [
            "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,",
            "  ExceptionInfo *exception)",
            "  assert(exception != (ExceptionInfo *) NULL);",
            "  assert(exception->signature == MagickSignature);",
            "  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);",
            "    p=GetVirtualPixels(image,0,y,image->columns,1,exception);"
        ],
        "added_lines": [
            "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)",
            "  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);",
            "    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}