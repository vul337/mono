{
    "cve_id": "CVE-2022-1276",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "mruby",
    "commit_msg": "codegen.c: need to pack argument when `n==13` too.\n\nBecause we have extra 2 arguments coming (kw and rhs).",
    "commit_hash": "c8c083cb750606b2da81582cd8e43b442bb143e6",
    "git_url": "https://github.com/mruby/mruby/commit/c8c083cb750606b2da81582cd8e43b442bb143e6",
    "file_path": "mrbgems/mruby-compiler/core/codegen.c",
    "func_name": "gen_assignment",
    "func_before": "static void\ngen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
    "abstract_func_before": "static void\ngen_assignment(codegen_scope *VAR_0, node *VAR_1, node *VAR_2, int VAR_3, int VAR_4)\n{\n  int VAR_5;\n  int VAR_6 = nint(VAR_1->car);\n\n  switch (VAR_6) {\n  case VAR_7:\n  case VAR_8:\n  case VAR_9:\n  case VAR_10:\n  case VAR_11:\n  case VAR_12:\n  case VAR_13:\n  case VAR_14:\n    if (VAR_2) {\n      codegen(VAR_0, VAR_2, VAR_15);\n      pop();\n      VAR_3 = cursp();\n    }\n    break;\n\n  case VAR_16:\n  case VAR_17:\n  case VAR_18:\n    /* COMMENT_0 */\n    break;\n\n  case VAR_19:\n    codegen_error(VAR_0, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(VAR_0, \"unknown lhs\");\n    break;\n  }\n\n  VAR_1 = VAR_1->cdr;\n  switch (VAR_6) {\n  case VAR_7:\n    gen_setxv(VAR_0, VAR_20, VAR_3, nsym(VAR_1), VAR_4);\n    break;\n  case VAR_8:\n  case VAR_9:\n    VAR_5 = lv_idx(VAR_0, nsym(VAR_1));\n    if (VAR_5 > 0) {\n      if (VAR_5 != VAR_3) {\n        gen_move(VAR_0, VAR_5, VAR_3, VAR_4);\n      }\n      break;\n    }\n    else {                      /* COMMENT_1 */\n      gen_setupvar(VAR_0, VAR_3, nsym(VAR_1));\n    }\n    break;\n  case VAR_10:\n    gen_setxv(VAR_0, VAR_21, VAR_3, nsym(VAR_1), VAR_4);\n    break;\n  case VAR_11:\n    gen_setxv(VAR_0, VAR_22, VAR_3, nsym(VAR_1), VAR_4);\n    break;\n  case VAR_12:\n    gen_setxv(VAR_0, VAR_23, VAR_3, nsym(VAR_1), VAR_4);\n    break;\n  case VAR_16:\n    if (VAR_3) {\n      gen_move(VAR_0, cursp(), VAR_3, 0);\n    }\n    VAR_3 = cursp();\n    push();\n    codegen(VAR_0, VAR_1->car, VAR_15);\n    if (VAR_2) {\n      codegen(VAR_0, VAR_2, VAR_15); pop();\n      gen_move(VAR_0, VAR_3, cursp(), 0);\n    }\n    pop_n(2);\n    VAR_5 = new_sym(VAR_0, nsym(VAR_1->cdr));\n    genop_2(VAR_0, VAR_24, VAR_3, VAR_5);\n    break;\n\n  case VAR_17:\n  case VAR_18:\n    {\n      int VAR_25 = 0, VAR_26 = (VAR_6 == VAR_18), VAR_27 = 0, VAR_28, VAR_29, VAR_30 = 0;\n      mrb_sym VAR_31 = nsym(VAR_1->cdr->car);\n\n      VAR_28 = cursp();\n      if (VAR_4 || VAR_3 == cursp()) {\n        push();                   /* COMMENT_2 */\n      }\n      VAR_29 = cursp();\n      if (!VAR_1->car) {\n        VAR_25 = 1;\n        push();\n      }\n      else {\n        codegen(VAR_0, VAR_1->car, VAR_15); /* COMMENT_3 */\n      }\n      if (VAR_26) {\n        int VAR_32 = cursp()-1;\n        gen_move(VAR_0, cursp(), VAR_32, 1);\n        VAR_27 = genjmp2_0(VAR_0, VAR_33, cursp(), VAR_4);\n      }\n      VAR_1 = VAR_1->cdr->cdr->car;\n      if (VAR_1) {\n        if (VAR_1->car) {            /* COMMENT_4 */\n          VAR_30 = gen_values(VAR_0, VAR_1->car, VAR_15, (VAR_1->cdr->car)?13:14);\n          if (VAR_30 < 0) {              /* COMMENT_5 */\n            VAR_30 = 15;\n            push();\n          }\n        }\n        if (VAR_1->cdr->car) {       /* COMMENT_6 */\n          if (VAR_30 == 14) {\n            pop_n(VAR_30);\n            genop_2(VAR_0, VAR_34, cursp(), VAR_30);\n            push();\n            VAR_30 = 15;\n          }\n          gen_hash(VAR_0, VAR_1->cdr->car->cdr, VAR_15, 0);\n          if (VAR_30 < 14) {\n            VAR_30++;\n          }\n          else {\n            pop_n(2);\n            genop_2(VAR_0, VAR_35, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (VAR_2) {\n        codegen(VAR_0, VAR_2, VAR_15);\n        pop();\n      }\n      else {\n        gen_move(VAR_0, cursp(), VAR_3, 0);\n      }\n      if (VAR_4) {\n        gen_move(VAR_0, VAR_28, cursp(), 1);\n      }\n      if (VAR_30 < 15) {\n        VAR_30++;\n        if (VAR_30 == 15) {\n          pop_n(14);\n          genop_2(VAR_0, VAR_34, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(VAR_0, VAR_35, cursp(), 1);\n      }\n      VAR_0->sp = VAR_29;\n      if (VAR_31 == MRB_OPSYM_2(VAR_0->mrb, VAR_36) && VAR_30 == 2) {\n        genop_1(VAR_0, VAR_37, cursp());\n      }\n      else {\n        genop_3(VAR_0, VAR_25 ? VAR_38 : VAR_39, cursp(), new_sym(VAR_0, attrsym(VAR_0, VAR_31)), VAR_30);\n      }\n      if (VAR_26) {\n        dispatch(VAR_0, VAR_27);\n      }\n      VAR_0->sp = VAR_28;\n    }\n    break;\n\n  case VAR_14:\n    gen_massignment(VAR_0, VAR_1->car, VAR_3, VAR_4);\n    break;\n\n  /* COMMENT_7 */\n  case VAR_13:\n    break;\n\n  default:\n    codegen_error(VAR_0, \"unknown lhs\");\n    break;\n  }\n  if (VAR_4) push();\n}",
    "func_graph_path_before": "mruby/c8c083cb750606b2da81582cd8e43b442bb143e6/codegen.c/vul/before/0.json",
    "func": "static void\ngen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 13 || n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
    "abstract_func": "static void\ngen_assignment(codegen_scope *VAR_0, node *VAR_1, node *VAR_2, int VAR_3, int VAR_4)\n{\n  int VAR_5;\n  int VAR_6 = nint(VAR_1->car);\n\n  switch (VAR_6) {\n  case VAR_7:\n  case VAR_8:\n  case VAR_9:\n  case VAR_10:\n  case VAR_11:\n  case VAR_12:\n  case VAR_13:\n  case VAR_14:\n    if (VAR_2) {\n      codegen(VAR_0, VAR_2, VAR_15);\n      pop();\n      VAR_3 = cursp();\n    }\n    break;\n\n  case VAR_16:\n  case VAR_17:\n  case VAR_18:\n    /* COMMENT_0 */\n    break;\n\n  case VAR_19:\n    codegen_error(VAR_0, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(VAR_0, \"unknown lhs\");\n    break;\n  }\n\n  VAR_1 = VAR_1->cdr;\n  switch (VAR_6) {\n  case VAR_7:\n    gen_setxv(VAR_0, VAR_20, VAR_3, nsym(VAR_1), VAR_4);\n    break;\n  case VAR_8:\n  case VAR_9:\n    VAR_5 = lv_idx(VAR_0, nsym(VAR_1));\n    if (VAR_5 > 0) {\n      if (VAR_5 != VAR_3) {\n        gen_move(VAR_0, VAR_5, VAR_3, VAR_4);\n      }\n      break;\n    }\n    else {                      /* COMMENT_1 */\n      gen_setupvar(VAR_0, VAR_3, nsym(VAR_1));\n    }\n    break;\n  case VAR_10:\n    gen_setxv(VAR_0, VAR_21, VAR_3, nsym(VAR_1), VAR_4);\n    break;\n  case VAR_11:\n    gen_setxv(VAR_0, VAR_22, VAR_3, nsym(VAR_1), VAR_4);\n    break;\n  case VAR_12:\n    gen_setxv(VAR_0, VAR_23, VAR_3, nsym(VAR_1), VAR_4);\n    break;\n  case VAR_16:\n    if (VAR_3) {\n      gen_move(VAR_0, cursp(), VAR_3, 0);\n    }\n    VAR_3 = cursp();\n    push();\n    codegen(VAR_0, VAR_1->car, VAR_15);\n    if (VAR_2) {\n      codegen(VAR_0, VAR_2, VAR_15); pop();\n      gen_move(VAR_0, VAR_3, cursp(), 0);\n    }\n    pop_n(2);\n    VAR_5 = new_sym(VAR_0, nsym(VAR_1->cdr));\n    genop_2(VAR_0, VAR_24, VAR_3, VAR_5);\n    break;\n\n  case VAR_17:\n  case VAR_18:\n    {\n      int VAR_25 = 0, VAR_26 = (VAR_6 == VAR_18), VAR_27 = 0, VAR_28, VAR_29, VAR_30 = 0;\n      mrb_sym VAR_31 = nsym(VAR_1->cdr->car);\n\n      VAR_28 = cursp();\n      if (VAR_4 || VAR_3 == cursp()) {\n        push();                   /* COMMENT_2 */\n      }\n      VAR_29 = cursp();\n      if (!VAR_1->car) {\n        VAR_25 = 1;\n        push();\n      }\n      else {\n        codegen(VAR_0, VAR_1->car, VAR_15); /* COMMENT_3 */\n      }\n      if (VAR_26) {\n        int VAR_32 = cursp()-1;\n        gen_move(VAR_0, cursp(), VAR_32, 1);\n        VAR_27 = genjmp2_0(VAR_0, VAR_33, cursp(), VAR_4);\n      }\n      VAR_1 = VAR_1->cdr->cdr->car;\n      if (VAR_1) {\n        if (VAR_1->car) {            /* COMMENT_4 */\n          VAR_30 = gen_values(VAR_0, VAR_1->car, VAR_15, (VAR_1->cdr->car)?13:14);\n          if (VAR_30 < 0) {              /* COMMENT_5 */\n            VAR_30 = 15;\n            push();\n          }\n        }\n        if (VAR_1->cdr->car) {       /* COMMENT_6 */\n          if (VAR_30 == 13 || VAR_30 == 14) {\n            pop_n(VAR_30);\n            genop_2(VAR_0, VAR_34, cursp(), VAR_30);\n            push();\n            VAR_30 = 15;\n          }\n          gen_hash(VAR_0, VAR_1->cdr->car->cdr, VAR_15, 0);\n          if (VAR_30 < 14) {\n            VAR_30++;\n          }\n          else {\n            pop_n(2);\n            genop_2(VAR_0, VAR_35, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (VAR_2) {\n        codegen(VAR_0, VAR_2, VAR_15);\n        pop();\n      }\n      else {\n        gen_move(VAR_0, cursp(), VAR_3, 0);\n      }\n      if (VAR_4) {\n        gen_move(VAR_0, VAR_28, cursp(), 1);\n      }\n      if (VAR_30 < 15) {\n        VAR_30++;\n        if (VAR_30 == 15) {\n          pop_n(14);\n          genop_2(VAR_0, VAR_34, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(VAR_0, VAR_35, cursp(), 1);\n      }\n      VAR_0->sp = VAR_29;\n      if (VAR_31 == MRB_OPSYM_2(VAR_0->mrb, VAR_36) && VAR_30 == 2) {\n        genop_1(VAR_0, VAR_37, cursp());\n      }\n      else {\n        genop_3(VAR_0, VAR_25 ? VAR_38 : VAR_39, cursp(), new_sym(VAR_0, attrsym(VAR_0, VAR_31)), VAR_30);\n      }\n      if (VAR_26) {\n        dispatch(VAR_0, VAR_27);\n      }\n      VAR_0->sp = VAR_28;\n    }\n    break;\n\n  case VAR_14:\n    gen_massignment(VAR_0, VAR_1->car, VAR_3, VAR_4);\n    break;\n\n  /* COMMENT_7 */\n  case VAR_13:\n    break;\n\n  default:\n    codegen_error(VAR_0, \"unknown lhs\");\n    break;\n  }\n  if (VAR_4) push();\n}",
    "func_graph_path": "mruby/c8c083cb750606b2da81582cd8e43b442bb143e6/codegen.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -111,7 +111,7 @@\n           }\n         }\n         if (tree->cdr->car) {       /* keyword arguments */\n-          if (n == 14) {\n+          if (n == 13 || n == 14) {\n             pop_n(n);\n             genop_2(s, OP_ARRAY, cursp(), n);\n             push();",
    "diff_line_info": {
        "deleted_lines": [
            "          if (n == 14) {"
        ],
        "added_lines": [
            "          if (n == 13 || n == 14) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}