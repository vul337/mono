{
    "cve_id": "CVE-2022-30067",
    "cwe_ids": [
        "CWE-120"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "GNOME/gimp",
    "commit_msg": "app: fix #8120 GIMP 2.10.30 crashed when allocate large memory\n\nGIMP could crash if the information regarding old path properties read\nfrom XCF was incorrect. It did not check if xcf_old_path succeeded and\nkept trying to load more paths even if the last one failed to load.\n\nInstead we now stop loading paths as soon as that function fails.\nIn case we have a failure here we also try to skip to the next property\nbased on the size of the path property, in hopes that the only problem\nwas this property.",
    "commit_hash": "4f99f1fcfd892ead19831b5adcd38a99d71214b6",
    "git_url": "https://github.com/GNOME/gimp/commit/4f99f1fcfd892ead19831b5adcd38a99d71214b6",
    "file_path": "app/xcf/xcf-load.c",
    "func_name": "xcf_load_old_path",
    "func_before": "static gboolean\nxcf_load_old_path (XcfInfo   *info,\n                   GimpImage *image)\n{\n  gchar                  *name;\n  guint32                 locked;\n  guint8                  state;\n  guint32                 closed;\n  guint32                 num_points;\n  guint32                 version; /* changed from num_paths */\n  GimpTattoo              tattoo = 0;\n  GimpVectors            *vectors;\n  GimpVectorsCompatPoint *points;\n  gint                    i;\n\n  xcf_read_string (info, &name,       1);\n  xcf_read_int32  (info, &locked,     1);\n  xcf_read_int8   (info, &state,      1);\n  xcf_read_int32  (info, &closed,     1);\n  xcf_read_int32  (info, &num_points, 1);\n  xcf_read_int32  (info, &version,    1);\n\n  if (version == 2)\n    {\n      guint32 dummy;\n\n      /* Had extra type field and points are stored as doubles */\n      xcf_read_int32 (info, (guint32 *) &dummy, 1);\n    }\n  else if (version == 3)\n    {\n      guint32 dummy;\n\n      /* Has extra tattoo field */\n      xcf_read_int32 (info, (guint32 *) &dummy,  1);\n      xcf_read_int32 (info, (guint32 *) &tattoo, 1);\n    }\n  else if (version != 1)\n    {\n      g_printerr (\"Unknown path type. Possibly corrupt XCF file\");\n\n      g_free (name);\n      return FALSE;\n    }\n\n  /* skip empty compatibility paths */\n  if (num_points == 0)\n    {\n      g_free (name);\n      return FALSE;\n    }\n\n  points = g_new0 (GimpVectorsCompatPoint, num_points);\n\n  for (i = 0; i < num_points; i++)\n    {\n      if (version == 1)\n        {\n          gint32 x;\n          gint32 y;\n\n          xcf_read_int32 (info, &points[i].type, 1);\n          xcf_read_int32 (info, (guint32 *) &x,  1);\n          xcf_read_int32 (info, (guint32 *) &y,  1);\n\n          points[i].x = x;\n          points[i].y = y;\n        }\n      else\n        {\n          gfloat x;\n          gfloat y;\n\n          xcf_read_int32 (info, &points[i].type, 1);\n          xcf_read_float (info, &x,              1);\n          xcf_read_float (info, &y,              1);\n\n          points[i].x = x;\n          points[i].y = y;\n        }\n    }\n\n  vectors = gimp_vectors_compat_new (image, name, points, num_points, closed);\n\n  g_free (name);\n  g_free (points);\n\n  if (locked)\n    info->linked_paths = g_list_prepend (info->linked_paths, vectors);\n\n  if (tattoo)\n    gimp_item_set_tattoo (GIMP_ITEM (vectors), tattoo);\n\n  gimp_image_add_vectors (image, vectors,\n                          NULL, /* can't be a tree */\n                          gimp_container_get_n_children (gimp_image_get_vectors (image)),\n                          FALSE);\n\n  return TRUE;\n}",
    "abstract_func_before": "static gboolean\nxcf_load_old_path (XcfInfo   *VAR_0,\n                   GimpImage *VAR_1)\n{\n  gchar                  *VAR_2;\n  guint32                 VAR_3;\n  guint8                  VAR_4;\n  guint32                 VAR_5;\n  guint32                 VAR_6;\n  guint32                 VAR_7; /* COMMENT_0 */\n  GimpTattoo              VAR_8 = 0;\n  GimpVectors            *VAR_9;\n  GimpVectorsCompatPoint *VAR_10;\n  gint                    VAR_11;\n\n  xcf_read_string (VAR_0, &VAR_2,       1);\n  xcf_read_int32  (VAR_0, &VAR_3,     1);\n  xcf_read_int8   (VAR_0, &VAR_4,      1);\n  xcf_read_int32  (VAR_0, &VAR_5,     1);\n  xcf_read_int32  (VAR_0, &VAR_6, 1);\n  xcf_read_int32  (VAR_0, &VAR_7,    1);\n\n  if (VAR_7 == 2)\n    {\n      guint32 VAR_12;\n\n      /* COMMENT_1 */\n      xcf_read_int32 (VAR_0, (guint32 *) &VAR_12, 1);\n    }\n  else if (VAR_7 == 3)\n    {\n      guint32 VAR_12;\n\n      /* COMMENT_2 */\n      xcf_read_int32 (VAR_0, (guint32 *) &VAR_12,  1);\n      xcf_read_int32 (VAR_0, (guint32 *) &VAR_8, 1);\n    }\n  else if (VAR_7 != 1)\n    {\n      g_printerr (\"Unknown path type. Possibly corrupt XCF file\");\n\n      g_free (VAR_2);\n      return FALSE;\n    }\n\n  /* COMMENT_3 */\n  if (VAR_6 == 0)\n    {\n      g_free (VAR_2);\n      return FALSE;\n    }\n\n  VAR_10 = g_new0 (GimpVectorsCompatPoint, VAR_6);\n\n  for (VAR_11 = 0; VAR_11 < VAR_6; VAR_11++)\n    {\n      if (VAR_7 == 1)\n        {\n          gint32 VAR_13;\n          gint32 VAR_14;\n\n          xcf_read_int32 (VAR_0, &VAR_10[VAR_11].type, 1);\n          xcf_read_int32 (VAR_0, (guint32 *) &VAR_13,  1);\n          xcf_read_int32 (VAR_0, (guint32 *) &VAR_14,  1);\n\n          VAR_10[VAR_11].x = VAR_13;\n          VAR_10[VAR_11].y = VAR_14;\n        }\n      else\n        {\n          gfloat VAR_13;\n          gfloat VAR_14;\n\n          xcf_read_int32 (VAR_0, &VAR_10[VAR_11].type, 1);\n          xcf_read_float (VAR_0, &VAR_13,              1);\n          xcf_read_float (VAR_0, &VAR_14,              1);\n\n          VAR_10[VAR_11].x = VAR_13;\n          VAR_10[VAR_11].y = VAR_14;\n        }\n    }\n\n  VAR_9 = gimp_vectors_compat_new (VAR_1, VAR_2, VAR_10, VAR_6, VAR_5);\n\n  g_free (VAR_2);\n  g_free (VAR_10);\n\n  if (VAR_3)\n    VAR_0->linked_paths = g_list_prepend (VAR_0->linked_paths, VAR_9);\n\n  if (VAR_8)\n    gimp_item_set_tattoo (GIMP_ITEM (VAR_9), VAR_8);\n\n  gimp_image_add_vectors (VAR_1, VAR_9,\n                          NULL, /* COMMENT_4 */\n                          gimp_container_get_n_children (gimp_image_get_vectors (VAR_1)),\n                          FALSE);\n\n  return TRUE;\n}",
    "func_graph_path_before": "GNOME/gimp/4f99f1fcfd892ead19831b5adcd38a99d71214b6/xcf-load.c/vul/before/2.json",
    "func": "static gboolean\nxcf_load_old_path (XcfInfo   *info,\n                   GimpImage *image)\n{\n  gchar                  *name;\n  guint32                 locked;\n  guint8                  state;\n  guint32                 closed;\n  guint32                 num_points;\n  guint32                 version; /* changed from num_paths */\n  GimpTattoo              tattoo = 0;\n  GimpVectors            *vectors;\n  GimpVectorsCompatPoint *points;\n  gint                    i;\n\n  xcf_read_string (info, &name,       1);\n  xcf_read_int32  (info, &locked,     1);\n  xcf_read_int8   (info, &state,      1);\n  xcf_read_int32  (info, &closed,     1);\n  xcf_read_int32  (info, &num_points, 1);\n  xcf_read_int32  (info, &version,    1);\n\n  if (version == 2)\n    {\n      guint32 dummy;\n\n      /* Had extra type field and points are stored as doubles */\n      xcf_read_int32 (info, (guint32 *) &dummy, 1);\n    }\n  else if (version == 3)\n    {\n      guint32 dummy;\n\n      /* Has extra tattoo field */\n      xcf_read_int32 (info, (guint32 *) &dummy,  1);\n      xcf_read_int32 (info, (guint32 *) &tattoo, 1);\n    }\n  else if (version != 1)\n    {\n      g_printerr (\"Unknown path type (version: %u). Possibly corrupt XCF file.\\n\", version);\n\n      g_free (name);\n      return FALSE;\n    }\n\n  /* skip empty compatibility paths */\n  if (num_points == 0)\n    {\n      g_free (name);\n      return FALSE;\n    }\n\n  points = g_new0 (GimpVectorsCompatPoint, num_points);\n\n  for (i = 0; i < num_points; i++)\n    {\n      if (version == 1)\n        {\n          gint32 x;\n          gint32 y;\n\n          xcf_read_int32 (info, &points[i].type, 1);\n          xcf_read_int32 (info, (guint32 *) &x,  1);\n          xcf_read_int32 (info, (guint32 *) &y,  1);\n\n          points[i].x = x;\n          points[i].y = y;\n        }\n      else\n        {\n          gfloat x;\n          gfloat y;\n\n          xcf_read_int32 (info, &points[i].type, 1);\n          xcf_read_float (info, &x,              1);\n          xcf_read_float (info, &y,              1);\n\n          points[i].x = x;\n          points[i].y = y;\n        }\n    }\n\n  vectors = gimp_vectors_compat_new (image, name, points, num_points, closed);\n\n  g_free (name);\n  g_free (points);\n\n  if (locked)\n    info->linked_paths = g_list_prepend (info->linked_paths, vectors);\n\n  if (tattoo)\n    gimp_item_set_tattoo (GIMP_ITEM (vectors), tattoo);\n\n  gimp_image_add_vectors (image, vectors,\n                          NULL, /* can't be a tree */\n                          gimp_container_get_n_children (gimp_image_get_vectors (image)),\n                          FALSE);\n\n  return TRUE;\n}",
    "abstract_func": "static gboolean\nxcf_load_old_path (XcfInfo   *VAR_0,\n                   GimpImage *VAR_1)\n{\n  gchar                  *VAR_2;\n  guint32                 VAR_3;\n  guint8                  VAR_4;\n  guint32                 VAR_5;\n  guint32                 VAR_6;\n  guint32                 VAR_7; /* COMMENT_0 */\n  GimpTattoo              VAR_8 = 0;\n  GimpVectors            *VAR_9;\n  GimpVectorsCompatPoint *VAR_10;\n  gint                    VAR_11;\n\n  xcf_read_string (VAR_0, &VAR_2,       1);\n  xcf_read_int32  (VAR_0, &VAR_3,     1);\n  xcf_read_int8   (VAR_0, &VAR_4,      1);\n  xcf_read_int32  (VAR_0, &VAR_5,     1);\n  xcf_read_int32  (VAR_0, &VAR_6, 1);\n  xcf_read_int32  (VAR_0, &VAR_7,    1);\n\n  if (VAR_7 == 2)\n    {\n      guint32 VAR_12;\n\n      /* COMMENT_1 */\n      xcf_read_int32 (VAR_0, (guint32 *) &VAR_12, 1);\n    }\n  else if (VAR_7 == 3)\n    {\n      guint32 VAR_12;\n\n      /* COMMENT_2 */\n      xcf_read_int32 (VAR_0, (guint32 *) &VAR_12,  1);\n      xcf_read_int32 (VAR_0, (guint32 *) &VAR_8, 1);\n    }\n  else if (VAR_7 != 1)\n    {\n      g_printerr (\"Unknown path type (version: %u). Possibly corrupt XCF file.\\n\", VAR_7);\n\n      g_free (VAR_2);\n      return FALSE;\n    }\n\n  /* COMMENT_3 */\n  if (VAR_6 == 0)\n    {\n      g_free (VAR_2);\n      return FALSE;\n    }\n\n  VAR_10 = g_new0 (GimpVectorsCompatPoint, VAR_6);\n\n  for (VAR_11 = 0; VAR_11 < VAR_6; VAR_11++)\n    {\n      if (VAR_7 == 1)\n        {\n          gint32 VAR_13;\n          gint32 VAR_14;\n\n          xcf_read_int32 (VAR_0, &VAR_10[VAR_11].type, 1);\n          xcf_read_int32 (VAR_0, (guint32 *) &VAR_13,  1);\n          xcf_read_int32 (VAR_0, (guint32 *) &VAR_14,  1);\n\n          VAR_10[VAR_11].x = VAR_13;\n          VAR_10[VAR_11].y = VAR_14;\n        }\n      else\n        {\n          gfloat VAR_13;\n          gfloat VAR_14;\n\n          xcf_read_int32 (VAR_0, &VAR_10[VAR_11].type, 1);\n          xcf_read_float (VAR_0, &VAR_13,              1);\n          xcf_read_float (VAR_0, &VAR_14,              1);\n\n          VAR_10[VAR_11].x = VAR_13;\n          VAR_10[VAR_11].y = VAR_14;\n        }\n    }\n\n  VAR_9 = gimp_vectors_compat_new (VAR_1, VAR_2, VAR_10, VAR_6, VAR_5);\n\n  g_free (VAR_2);\n  g_free (VAR_10);\n\n  if (VAR_3)\n    VAR_0->linked_paths = g_list_prepend (VAR_0->linked_paths, VAR_9);\n\n  if (VAR_8)\n    gimp_item_set_tattoo (GIMP_ITEM (VAR_9), VAR_8);\n\n  gimp_image_add_vectors (VAR_1, VAR_9,\n                          NULL, /* COMMENT_4 */\n                          gimp_container_get_n_children (gimp_image_get_vectors (VAR_1)),\n                          FALSE);\n\n  return TRUE;\n}",
    "func_graph_path": "GNOME/gimp/4f99f1fcfd892ead19831b5adcd38a99d71214b6/xcf-load.c/vul/after/2.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,7 @@\n     }\n   else if (version != 1)\n     {\n-      g_printerr (\"Unknown path type. Possibly corrupt XCF file\");\n+      g_printerr (\"Unknown path type (version: %u). Possibly corrupt XCF file.\\n\", version);\n \n       g_free (name);\n       return FALSE;",
    "diff_line_info": {
        "deleted_lines": [
            "      g_printerr (\"Unknown path type. Possibly corrupt XCF file\");"
        ],
        "added_lines": [
            "      g_printerr (\"Unknown path type (version: %u). Possibly corrupt XCF file.\\n\", version);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}