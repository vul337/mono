{
    "cve_id": "CVE-2022-47089",
    "cwe_ids": [
        "CWE-120"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "gpac",
    "commit_msg": "fixed #2338",
    "commit_hash": "73a8c425adaad7526de81586fcb053acde807757",
    "git_url": "https://github.com/gpac/gpac/commit/73a8c425adaad7526de81586fcb053acde807757",
    "file_path": "src/filters/reframe_nalu.c",
    "func_name": "naludmx_parse_nal_vvc",
    "func_before": "static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res;\n\tu8 nal_unit_type, temporal_id, layer_id;\n\t*skip_nal = GF_FALSE;\n\n\tif (size<2) return -1;\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\tres = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);\n\tctx->nb_nalus++;\n\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Warning: Error parsing NAL unit\\n\", ctx->log_name));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\n\tif (layer_id && ctx->nosvc) {\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\t}\n\n\tswitch (nal_unit_type) {\n\tcase GF_VVC_NALU_VID_PARAM:\n\t\tif (ctx->novpsext) {\n\t\t\t//this may modify nal_size, but we don't use it for bitstream reading\n//\t\t\tps_idx = gf_hevc_read_vps_ex(data, &size, ctx->hevc_state, GF_TRUE);\n\t\t\tps_idx = ctx->vvc_state->last_parsed_vps_id;\n\t\t} else {\n\t\t\tps_idx = ctx->vvc_state->last_parsed_vps_id;\n\t\t}\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Video Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_VID_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->vvc_state->last_parsed_sps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_SEQ_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->vvc_state->last_parsed_pps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_PIC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_DEC_PARAM:\n\t\tps_idx = 0;\n\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_DEC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_OPI:\n\t\tps_idx = 0;\n\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_OPI, ps_idx, temporal_id, layer_id);\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t//for now we keep APS in the stream\n#if 0\n\t\tps_idx = ctx->vvc_state->last_parsed_aps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Decoder Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_APS_PREFIX, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n#else\n\t\t//same logic as SEI\n\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t*skip_nal = GF_TRUE;\n#endif\n\t\tbreak;\n\tcase GF_VVC_NALU_SEI_PREFIX:\n\t\tgf_vvc_parse_sei(data, size, ctx->vvc_state);\n\t\tif (!ctx->nosei) {\n\t\t\tctx->nb_sei++;\n\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t} else {\n\t\t\tctx->nb_nalus--;\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_SEI_SUFFIX:\n\t\tif (! ctx->is_playing) return 0;\n\t\tgf_vvc_parse_sei(data, size, ctx->vvc_state);\n\t\tif (ctx->nosei) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t\tctx->nb_nalus--;\n\t\t} else {\n\t\t\tctx->nb_sei++;\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_PIC_HEADER:\n\t\tif (! ctx->is_playing) return 0;\n\t\tbreak;\n\n\t/*slice_segment_layer_rbsp*/\n\tcase GF_VVC_NALU_SLICE_TRAIL:\n\tcase GF_VVC_NALU_SLICE_STSA:\n\tcase GF_VVC_NALU_SLICE_RADL:\n\tcase GF_VVC_NALU_SLICE_RASL:\n\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_VVC_NALU_SLICE_CRA:\n\tcase GF_VVC_NALU_SLICE_GDR:\n\t\tif (! ctx->is_playing) return 0;\n\t\t*is_slice = GF_TRUE;\n\t\tctx->last_layer_id = layer_id;\n\t\tctx->last_temporal_id = temporal_id;\n\t\tif (! *skip_nal) {\n\t\t\tswitch (ctx->vvc_state->s_info.slice_type) {\n\t\t\tcase GF_VVC_SLICE_TYPE_P:\n\t\t\t\tif (layer_id) ctx->nb_e_p++;\n\t\t\t\telse ctx->nb_p++;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_I:\n\t\t\t\tif (layer_id) ctx->nb_e_i++;\n\t\t\t\telse ctx->nb_i++;\n\t\t\t\t*is_islice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_B:\n\t\t\t\tif (layer_id) ctx->nb_e_b++;\n\t\t\t\telse ctx->nb_b++;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_UNKNOWN:\n\t\t\t\tctx->vvc_no_stats = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\t//no skip AUD in VVC\n\n\t\tif (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 3);\n\t\t}\n\t\tbreak;\n\t/*remove*/\n\tcase GF_VVC_NALU_FILLER_DATA:\n\tcase GF_VVC_NALU_END_OF_SEQ:\n\tcase GF_VVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\n\tdefault:\n\t\tif (! ctx->is_playing) return 0;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] NAL Unit type %d not handled - adding\\n\", ctx->log_name, nal_unit_type));\n\t\tbreak;\n\t}\n\tif (*skip_nal) return res;\n\n\tctx->linf[layer_id].layer_id_plus_one = layer_id + 1;\n\tif (! ctx->linf[layer_id].max_temporal_id ) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].max_temporal_id < temporal_id) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\n\tif (! ctx->linf[layer_id].min_temporal_id ) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].min_temporal_id > temporal_id) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\n\tif (ctx->max_temporal_id[layer_id] < temporal_id)\n\t\tctx->max_temporal_id[layer_id] = temporal_id;\n\tif (ctx->min_layer_id > layer_id) ctx->min_layer_id = layer_id;\n\treturn res;\n}",
    "abstract_func_before": "static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *VAR_0, char *VAR_1, u32 VAR_2, Bool *VAR_3, Bool *VAR_4, Bool *VAR_5)\n{\n\ts32 VAR_6 = 0;\n\ts32 VAR_7;\n\tu8 VAR_8, VAR_9, VAR_10;\n\t*VAR_3 = VAR_11;\n\n\tif (VAR_2<2) return -1;\n\tgf_bs_reassign_buffer(VAR_0->bs_r, VAR_1, VAR_2);\n\tVAR_7 = gf_vvc_parse_nalu_bs(VAR_0->bs_r, VAR_0->vvc_state, &VAR_8, &VAR_9, &VAR_10);\n\tVAR_0->nb_nalus++;\n\n\tif (VAR_7 < 0) {\n\t\tif (VAR_7 == -1) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Warning: Error parsing NAL unit\\n\", VAR_0->log_name));\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t}\n\n\tif (VAR_10 && VAR_0->nosvc) {\n\t\t*VAR_3 = VAR_14;\n\t\treturn 0;\n\t}\n\n\tswitch (VAR_8) {\n\tcase VAR_15:\n\t\tif (VAR_0->novpsext) {\n\t\t\t/* COMMENT_0 */\n/* COMMENT_1 */\n\t\t\tVAR_6 = VAR_0->vvc_state->last_parsed_vps_id;\n\t\t} else {\n\t\t\tVAR_6 = VAR_0->vvc_state->last_parsed_vps_id;\n\t\t}\n\t\tif (VAR_6<0) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing Video Param Set\\n\", VAR_0->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_15, VAR_6, VAR_9, VAR_10);\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_16:\n\t\tVAR_6 = VAR_0->vvc_state->last_parsed_sps_id;\n\t\tif (VAR_6<0) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing Sequence Param Set\\n\", VAR_0->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_16, VAR_6, VAR_9, VAR_10);\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_17:\n\t\tVAR_6 = VAR_0->vvc_state->last_parsed_pps_id;\n\t\tif (VAR_6<0) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing Picture Param Set\\n\", VAR_0->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_17, VAR_6, VAR_9, VAR_10);\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_6 = 0;\n\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_18, VAR_6, VAR_9, VAR_10);\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_6 = 0;\n\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_19, VAR_6, VAR_9, VAR_10);\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_20:\n\t\t/* COMMENT_2 */\n#if 0\n\t\tVAR_6 = VAR_0->vvc_state->last_parsed_aps_id;\n\t\tif (VAR_6<0) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing Decoder Param Set\\n\", VAR_0->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_20, VAR_6, VAR_9, VAR_10);\n\t\t}\n\t\t*VAR_3 = VAR_14;\n#else\n\t\t/* COMMENT_3 */\n\t\tnaludmx_push_prefix(VAR_0, VAR_1, VAR_2, VAR_11);\n\t\t*VAR_3 = VAR_14;\n#endif\n\t\tbreak;\n\tcase VAR_21:\n\t\tgf_vvc_parse_sei(VAR_1, VAR_2, VAR_0->vvc_state);\n\t\tif (!VAR_0->nosei) {\n\t\t\tVAR_0->nb_sei++;\n\n\t\t\tnaludmx_push_prefix(VAR_0, VAR_1, VAR_2, VAR_11);\n\t\t} else {\n\t\t\tVAR_0->nb_nalus--;\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (! VAR_0->is_playing) return 0;\n\t\tgf_vvc_parse_sei(VAR_1, VAR_2, VAR_0->vvc_state);\n\t\tif (VAR_0->nosei) {\n\t\t\t*VAR_3 = VAR_14;\n\t\t\tVAR_0->nb_nalus--;\n\t\t} else {\n\t\t\tVAR_0->nb_sei++;\n\t\t}\n\t\tbreak;\n\n\tcase VAR_23:\n\t\tif (! VAR_0->is_playing) return 0;\n\t\tbreak;\n\n\t/* COMMENT_4 */\n\tcase VAR_24:\n\tcase VAR_25:\n\tcase VAR_26:\n\tcase VAR_27:\n\tcase VAR_28:\n\tcase VAR_29:\n\tcase VAR_30:\n\tcase VAR_31:\n\t\tif (! VAR_0->is_playing) return 0;\n\t\t*VAR_4 = VAR_14;\n\t\tVAR_0->last_layer_id = VAR_10;\n\t\tVAR_0->last_temporal_id = VAR_9;\n\t\tif (! *VAR_3) {\n\t\t\tswitch (VAR_0->vvc_state->s_info.slice_type) {\n\t\t\tcase VAR_32:\n\t\t\t\tif (VAR_10) VAR_0->nb_e_p++;\n\t\t\t\telse VAR_0->nb_p++;\n\t\t\t\tbreak;\n\t\t\tcase VAR_33:\n\t\t\t\tif (VAR_10) VAR_0->nb_e_i++;\n\t\t\t\telse VAR_0->nb_i++;\n\t\t\t\t*VAR_5 = VAR_14;\n\t\t\t\tbreak;\n\t\t\tcase VAR_34:\n\t\t\t\tif (VAR_10) VAR_0->nb_e_b++;\n\t\t\t\telse VAR_0->nb_b++;\n\t\t\t\tbreak;\n\t\t\tcase VAR_35:\n\t\t\t\tVAR_0->vvc_no_stats = VAR_14;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase VAR_36:\n\t\tVAR_0->nb_aud++;\n\t\t/* COMMENT_5 */\n\n\t\tif (!VAR_0->opid) {\n\t\t\tVAR_0->has_initial_aud = VAR_14;\n\t\t\tmemcpy(VAR_0->init_aud, VAR_1, 3);\n\t\t}\n\t\tbreak;\n\t/* COMMENT_6 */\n\tcase VAR_37:\n\tcase VAR_38:\n\tcase VAR_39:\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\n\tdefault:\n\t\tif (! VAR_0->is_playing) return 0;\n\t\tGF_LOG(VAR_40, VAR_13, (\"[%s] NAL Unit type %d not handled - adding\\n\", VAR_0->log_name, VAR_8));\n\t\tbreak;\n\t}\n\tif (*VAR_3) return VAR_7;\n\n\tVAR_0->linf[VAR_10].layer_id_plus_one = VAR_10 + 1;\n\tif (! VAR_0->linf[VAR_10].max_temporal_id ) VAR_0->linf[VAR_10].max_temporal_id = VAR_9;\n\telse if (VAR_0->linf[VAR_10].max_temporal_id < VAR_9) VAR_0->linf[VAR_10].max_temporal_id = VAR_9;\n\n\tif (! VAR_0->linf[VAR_10].min_temporal_id ) VAR_0->linf[VAR_10].min_temporal_id = VAR_9;\n\telse if (VAR_0->linf[VAR_10].min_temporal_id > VAR_9) VAR_0->linf[VAR_10].min_temporal_id = VAR_9;\n\n\tif (VAR_0->max_temporal_id[VAR_10] < VAR_9)\n\t\tVAR_0->max_temporal_id[VAR_10] = VAR_9;\n\tif (VAR_0->min_layer_id > VAR_10) VAR_0->min_layer_id = VAR_10;\n\treturn VAR_7;\n}",
    "func_graph_path_before": "gpac/73a8c425adaad7526de81586fcb053acde807757/reframe_nalu.c/vul/before/2.json",
    "func": "static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res;\n\tu8 nal_unit_type, temporal_id, layer_id;\n\t*skip_nal = GF_FALSE;\n\n\tif (size<2) return -1;\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\tres = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);\n\tctx->nb_nalus++;\n\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_unit_type));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\n\tif (layer_id && ctx->nosvc) {\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\t}\n\n\tswitch (nal_unit_type) {\n\tcase GF_VVC_NALU_VID_PARAM:\n\t\tif (ctx->novpsext) {\n\t\t\t//this may modify nal_size, but we don't use it for bitstream reading\n//\t\t\tps_idx = gf_hevc_read_vps_ex(data, &size, ctx->hevc_state, GF_TRUE);\n\t\t\tps_idx = ctx->vvc_state->last_parsed_vps_id;\n\t\t} else {\n\t\t\tps_idx = ctx->vvc_state->last_parsed_vps_id;\n\t\t}\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Video Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_VID_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->vvc_state->last_parsed_sps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_SEQ_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->vvc_state->last_parsed_pps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_PIC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_DEC_PARAM:\n\t\tps_idx = 0;\n\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_DEC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_OPI:\n\t\tps_idx = 0;\n\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_OPI, ps_idx, temporal_id, layer_id);\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t//for now we keep APS in the stream\n#if 0\n\t\tps_idx = ctx->vvc_state->last_parsed_aps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Decoder Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_APS_PREFIX, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n#else\n\t\t//same logic as SEI\n\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t*skip_nal = GF_TRUE;\n#endif\n\t\tbreak;\n\tcase GF_VVC_NALU_SEI_PREFIX:\n\t\tgf_vvc_parse_sei(data, size, ctx->vvc_state);\n\t\tif (!ctx->nosei) {\n\t\t\tctx->nb_sei++;\n\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t} else {\n\t\t\tctx->nb_nalus--;\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_SEI_SUFFIX:\n\t\tif (! ctx->is_playing) return 0;\n\t\tgf_vvc_parse_sei(data, size, ctx->vvc_state);\n\t\tif (ctx->nosei) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t\tctx->nb_nalus--;\n\t\t} else {\n\t\t\tctx->nb_sei++;\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_PIC_HEADER:\n\t\tif (! ctx->is_playing) return 0;\n\t\tbreak;\n\n\t/*slice_segment_layer_rbsp*/\n\tcase GF_VVC_NALU_SLICE_TRAIL:\n\tcase GF_VVC_NALU_SLICE_STSA:\n\tcase GF_VVC_NALU_SLICE_RADL:\n\tcase GF_VVC_NALU_SLICE_RASL:\n\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_VVC_NALU_SLICE_CRA:\n\tcase GF_VVC_NALU_SLICE_GDR:\n\t\tif (! ctx->is_playing) return 0;\n\t\t*is_slice = GF_TRUE;\n\t\tctx->last_layer_id = layer_id;\n\t\tctx->last_temporal_id = temporal_id;\n\t\tif (! *skip_nal) {\n\t\t\tswitch (ctx->vvc_state->s_info.slice_type) {\n\t\t\tcase GF_VVC_SLICE_TYPE_P:\n\t\t\t\tif (layer_id) ctx->nb_e_p++;\n\t\t\t\telse ctx->nb_p++;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_I:\n\t\t\t\tif (layer_id) ctx->nb_e_i++;\n\t\t\t\telse ctx->nb_i++;\n\t\t\t\t*is_islice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_B:\n\t\t\t\tif (layer_id) ctx->nb_e_b++;\n\t\t\t\telse ctx->nb_b++;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_UNKNOWN:\n\t\t\t\tctx->vvc_no_stats = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\t//no skip AUD in VVC\n\n\t\tif (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 3);\n\t\t}\n\t\tbreak;\n\t/*remove*/\n\tcase GF_VVC_NALU_FILLER_DATA:\n\tcase GF_VVC_NALU_END_OF_SEQ:\n\tcase GF_VVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\n\tdefault:\n\t\tif (! ctx->is_playing) return 0;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] NAL Unit type %d not handled - adding\\n\", ctx->log_name, nal_unit_type));\n\t\tbreak;\n\t}\n\tif (*skip_nal) return res;\n\n\tctx->linf[layer_id].layer_id_plus_one = layer_id + 1;\n\tif (! ctx->linf[layer_id].max_temporal_id ) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].max_temporal_id < temporal_id) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\n\tif (! ctx->linf[layer_id].min_temporal_id ) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].min_temporal_id > temporal_id) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\n\tif (ctx->max_temporal_id[layer_id] < temporal_id)\n\t\tctx->max_temporal_id[layer_id] = temporal_id;\n\tif (ctx->min_layer_id > layer_id) ctx->min_layer_id = layer_id;\n\treturn res;\n}",
    "abstract_func": "static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *VAR_0, char *VAR_1, u32 VAR_2, Bool *VAR_3, Bool *VAR_4, Bool *VAR_5)\n{\n\ts32 VAR_6 = 0;\n\ts32 VAR_7;\n\tu8 VAR_8, VAR_9, VAR_10;\n\t*VAR_3 = VAR_11;\n\n\tif (VAR_2<2) return -1;\n\tgf_bs_reassign_buffer(VAR_0->bs_r, VAR_1, VAR_2);\n\tVAR_7 = gf_vvc_parse_nalu_bs(VAR_0->bs_r, VAR_0->vvc_state, &VAR_8, &VAR_9, &VAR_10);\n\tVAR_0->nb_nalus++;\n\n\tif (VAR_7 < 0) {\n\t\tif (VAR_7 == -1) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing NAL unit type %u\\n\", VAR_0->log_name, VAR_8));\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t}\n\n\tif (VAR_10 && VAR_0->nosvc) {\n\t\t*VAR_3 = VAR_14;\n\t\treturn 0;\n\t}\n\n\tswitch (VAR_8) {\n\tcase VAR_15:\n\t\tif (VAR_0->novpsext) {\n\t\t\t/* COMMENT_0 */\n/* COMMENT_1 */\n\t\t\tVAR_6 = VAR_0->vvc_state->last_parsed_vps_id;\n\t\t} else {\n\t\t\tVAR_6 = VAR_0->vvc_state->last_parsed_vps_id;\n\t\t}\n\t\tif (VAR_6<0) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing Video Param Set\\n\", VAR_0->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_15, VAR_6, VAR_9, VAR_10);\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_16:\n\t\tVAR_6 = VAR_0->vvc_state->last_parsed_sps_id;\n\t\tif (VAR_6<0) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing Sequence Param Set\\n\", VAR_0->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_16, VAR_6, VAR_9, VAR_10);\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_17:\n\t\tVAR_6 = VAR_0->vvc_state->last_parsed_pps_id;\n\t\tif (VAR_6<0) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing Picture Param Set\\n\", VAR_0->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_17, VAR_6, VAR_9, VAR_10);\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_6 = 0;\n\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_18, VAR_6, VAR_9, VAR_10);\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_6 = 0;\n\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_19, VAR_6, VAR_9, VAR_10);\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_20:\n\t\t/* COMMENT_2 */\n#if 0\n\t\tVAR_6 = VAR_0->vvc_state->last_parsed_aps_id;\n\t\tif (VAR_6<0) {\n\t\t\tGF_LOG(VAR_12, VAR_13, (\"[%s] Error parsing Decoder Param Set\\n\", VAR_0->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(VAR_0, VAR_1, VAR_2, VAR_20, VAR_6, VAR_9, VAR_10);\n\t\t}\n\t\t*VAR_3 = VAR_14;\n#else\n\t\t/* COMMENT_3 */\n\t\tnaludmx_push_prefix(VAR_0, VAR_1, VAR_2, VAR_11);\n\t\t*VAR_3 = VAR_14;\n#endif\n\t\tbreak;\n\tcase VAR_21:\n\t\tgf_vvc_parse_sei(VAR_1, VAR_2, VAR_0->vvc_state);\n\t\tif (!VAR_0->nosei) {\n\t\t\tVAR_0->nb_sei++;\n\n\t\t\tnaludmx_push_prefix(VAR_0, VAR_1, VAR_2, VAR_11);\n\t\t} else {\n\t\t\tVAR_0->nb_nalus--;\n\t\t}\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (! VAR_0->is_playing) return 0;\n\t\tgf_vvc_parse_sei(VAR_1, VAR_2, VAR_0->vvc_state);\n\t\tif (VAR_0->nosei) {\n\t\t\t*VAR_3 = VAR_14;\n\t\t\tVAR_0->nb_nalus--;\n\t\t} else {\n\t\t\tVAR_0->nb_sei++;\n\t\t}\n\t\tbreak;\n\n\tcase VAR_23:\n\t\tif (! VAR_0->is_playing) return 0;\n\t\tbreak;\n\n\t/* COMMENT_4 */\n\tcase VAR_24:\n\tcase VAR_25:\n\tcase VAR_26:\n\tcase VAR_27:\n\tcase VAR_28:\n\tcase VAR_29:\n\tcase VAR_30:\n\tcase VAR_31:\n\t\tif (! VAR_0->is_playing) return 0;\n\t\t*VAR_4 = VAR_14;\n\t\tVAR_0->last_layer_id = VAR_10;\n\t\tVAR_0->last_temporal_id = VAR_9;\n\t\tif (! *VAR_3) {\n\t\t\tswitch (VAR_0->vvc_state->s_info.slice_type) {\n\t\t\tcase VAR_32:\n\t\t\t\tif (VAR_10) VAR_0->nb_e_p++;\n\t\t\t\telse VAR_0->nb_p++;\n\t\t\t\tbreak;\n\t\t\tcase VAR_33:\n\t\t\t\tif (VAR_10) VAR_0->nb_e_i++;\n\t\t\t\telse VAR_0->nb_i++;\n\t\t\t\t*VAR_5 = VAR_14;\n\t\t\t\tbreak;\n\t\t\tcase VAR_34:\n\t\t\t\tif (VAR_10) VAR_0->nb_e_b++;\n\t\t\t\telse VAR_0->nb_b++;\n\t\t\t\tbreak;\n\t\t\tcase VAR_35:\n\t\t\t\tVAR_0->vvc_no_stats = VAR_14;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase VAR_36:\n\t\tVAR_0->nb_aud++;\n\t\t/* COMMENT_5 */\n\n\t\tif (!VAR_0->opid) {\n\t\t\tVAR_0->has_initial_aud = VAR_14;\n\t\t\tmemcpy(VAR_0->init_aud, VAR_1, 3);\n\t\t}\n\t\tbreak;\n\t/* COMMENT_6 */\n\tcase VAR_37:\n\tcase VAR_38:\n\tcase VAR_39:\n\t\t*VAR_3 = VAR_14;\n\t\tbreak;\n\n\tdefault:\n\t\tif (! VAR_0->is_playing) return 0;\n\t\tGF_LOG(VAR_40, VAR_13, (\"[%s] NAL Unit type %d not handled - adding\\n\", VAR_0->log_name, VAR_8));\n\t\tbreak;\n\t}\n\tif (*VAR_3) return VAR_7;\n\n\tVAR_0->linf[VAR_10].layer_id_plus_one = VAR_10 + 1;\n\tif (! VAR_0->linf[VAR_10].max_temporal_id ) VAR_0->linf[VAR_10].max_temporal_id = VAR_9;\n\telse if (VAR_0->linf[VAR_10].max_temporal_id < VAR_9) VAR_0->linf[VAR_10].max_temporal_id = VAR_9;\n\n\tif (! VAR_0->linf[VAR_10].min_temporal_id ) VAR_0->linf[VAR_10].min_temporal_id = VAR_9;\n\telse if (VAR_0->linf[VAR_10].min_temporal_id > VAR_9) VAR_0->linf[VAR_10].min_temporal_id = VAR_9;\n\n\tif (VAR_0->max_temporal_id[VAR_10] < VAR_9)\n\t\tVAR_0->max_temporal_id[VAR_10] = VAR_9;\n\tif (VAR_0->min_layer_id > VAR_10) VAR_0->min_layer_id = VAR_10;\n\treturn VAR_7;\n}",
    "func_graph_path": "gpac/73a8c425adaad7526de81586fcb053acde807757/reframe_nalu.c/vul/after/2.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \n \tif (res < 0) {\n \t\tif (res == -1) {\n-\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Warning: Error parsing NAL unit\\n\", ctx->log_name));\n+\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_unit_type));\n \t\t}\n \t\t*skip_nal = GF_TRUE;\n \t}",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Warning: Error parsing NAL unit\\n\", ctx->log_name));"
        ],
        "added_lines": [
            "\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_unit_type));"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}