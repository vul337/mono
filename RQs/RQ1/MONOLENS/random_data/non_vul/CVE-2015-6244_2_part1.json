{
    "cve_id": "CVE-2015-6244",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "wireshark",
    "commit_msg": "Use the reported length where appropriate.\n\nUse the captured length to know how much data to decrypt.  Use the\nreported length to determine whether we have a null payload and to se\nthe reported length of the decrypted payload and of tvbuffs for the\nun-decrypted payload.\n\nBug: 11389\nChange-Id: I4395c5a48c16110fcf31b611b99749c61000d489\nReviewed-on: https://code.wireshark.org/review/9953\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
    "commit_hash": "31571144be5f03f054a9c7e195b38c2f5792fe54",
    "git_url": "https://github.com/wireshark/wireshark/commit/31571144be5f03f054a9c7e195b38c2f5792fe54",
    "file_path": "epan/dissectors/packet-zbee-security.c",
    "func_name": "dissect_zbee_secure",
    "func_before": "tvbuff_t *\ndissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint offset)\n{\n    proto_tree     *sec_tree;\n\n    zbee_security_packet    packet;\n    guint           mic_len;\n    gint            payload_len;\n    tvbuff_t       *payload_tvb;\n\n#ifdef HAVE_LIBGCRYPT\n    proto_item         *ti;\n    proto_item         *key_item;\n    guint8             *enc_buffer;\n    guint8             *dec_buffer;\n    gboolean            decrypted;\n    GSList            **nwk_keyring;\n    GSList             *GSList_i;\n    key_record_t       *key_rec = NULL;\n#endif\n    zbee_nwk_hints_t   *nwk_hints;\n    ieee802154_hints_t *ieee_hints;\n    ieee802154_map_rec *map_rec = NULL;\n\n    static const int * sec_flags[] = {\n        &hf_zbee_sec_key_id,\n        &hf_zbee_sec_nonce,\n        NULL\n    };\n\n    /* Init */\n    memset(&packet, 0, sizeof(zbee_security_packet));\n\n    /* Get pointers to any useful frame data from lower layers */\n    nwk_hints = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(ZBEE_PROTOABBREV_NWK), 0);\n    ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN), 0);\n\n    /* Create a subtree for the security information. */\n    sec_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_zbee_sec, NULL, \"ZigBee Security Header\");\n\n    /*  Get and display the Security control field */\n    packet.control  = tvb_get_guint8(tvb, offset);\n\n    /* Patch the security level. */\n    packet.control &= ~ZBEE_SEC_CONTROL_LEVEL;\n    packet.control |= (ZBEE_SEC_CONTROL_LEVEL & gPREF_zbee_sec_level);\n\n    /*\n     * Eww, I think I just threw up a little...  ZigBee requires this field\n     * to be patched before computing the MIC, but we don't have write-access\n     * to the tvbuff. So we need to allocate a copy of the whole thing just\n     * so we can fix these 3 bits. Memory allocated by tvb_memdup(wmem_packet_scope(),...)\n     * is automatically freed before the next packet is processed.\n     */\n#ifdef HAVE_LIBGCRYPT\n    enc_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb));\n    /*\n     * Override the const qualifiers and patch the security level field, we\n     * know it is safe to overide the const qualifiers because we just\n     * allocated this memory via tvb_memdup(wmem_packet_scope(),...).\n     */\n    enc_buffer[offset] = packet.control;\n#endif /* HAVE_LIBGCRYPT */\n    packet.level    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_LEVEL);\n    packet.key_id   = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_KEY);\n    packet.nonce    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_NONCE);\n\n    proto_tree_add_bitmask(sec_tree, tvb, offset, hf_zbee_sec_field, ett_zbee_sec_control, sec_flags, ENC_NA);\n    offset += 1;\n\n    /* Get and display the frame counter field. */\n    packet.counter = tvb_get_letohl(tvb, offset);\n    if (tree) {\n        proto_tree_add_uint(sec_tree, hf_zbee_sec_counter, tvb, offset, 4, packet.counter);\n    }\n    offset += 4;\n\n    if (packet.nonce) {\n        /* Get and display the source address of the device that secured this payload. */\n        packet.src64 = tvb_get_letoh64(tvb, offset);\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_src64, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        }\n#if 1\n        if (!pinfo->fd->flags.visited) {\n            switch ( packet.key_id ) {\n                case ZBEE_SEC_KEY_LINK:\n                if (nwk_hints && ieee_hints) {\n                    /* Map this long address with the nwk layer short address. */\n                    nwk_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, nwk_hints->src,\n                            ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                case ZBEE_SEC_KEY_NWK:\n                if (ieee_hints) {\n                    /* Map this long address with the ieee short address. */\n                    ieee_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, ieee_hints->src16,\n                        ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                /* We ignore the extended source addresses used to encrypt payloads with these\n                 * types of keys, because they can emerge from APS tunnels created by nodes whose\n                 * short address is not recorded in the packet. */\n                case ZBEE_SEC_KEY_TRANSPORT:\n                case ZBEE_SEC_KEY_LOAD:\n                break;\n            }\n        }\n#endif\n        offset += 8;\n    }\n    else {\n        /* Look for a source address in hints */\n        switch ( packet.key_id ) {\n            case ZBEE_SEC_KEY_NWK:\n                /* use the ieee extended source address for NWK decryption */\n                if ( ieee_hints && (map_rec = ieee_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n\n            default:\n                /* use the nwk extended source address for APS decryption */\n                if ( nwk_hints && (map_rec = nwk_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n        }\n    }\n\n    if (packet.key_id == ZBEE_SEC_KEY_NWK) {\n        /* Get and display the key sequence number. */\n        packet.key_seqno = tvb_get_guint8(tvb, offset);\n        if (tree) {\n            proto_tree_add_uint(sec_tree, hf_zbee_sec_key_seqno, tvb, offset, 1, packet.key_seqno);\n        }\n        offset += 1;\n    }\n\n    /* Determine the length of the MIC. */\n    switch (packet.level) {\n        case ZBEE_SEC_ENC:\n        case ZBEE_SEC_NONE:\n        default:\n            mic_len=0;\n            break;\n\n        case ZBEE_SEC_ENC_MIC32:\n        case ZBEE_SEC_MIC32:\n            mic_len=4;\n            break;\n\n        case ZBEE_SEC_ENC_MIC64:\n        case ZBEE_SEC_MIC64:\n            mic_len=8;\n            break;\n\n        case ZBEE_SEC_ENC_MIC128:\n        case ZBEE_SEC_MIC128:\n            mic_len=16;\n            break;\n    } /* switch */\n\n    /* Get and display the MIC. */\n    if (mic_len) {\n        /* Display the MIC. */\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_mic, tvb, (gint)(tvb_captured_length(tvb)-mic_len),\n                   mic_len, ENC_NA);\n        }\n    }\n\n    /* Check for null payload. */\n    payload_len = tvb_captured_length_remaining(tvb, offset+mic_len);\n    if (payload_len == 0)\n        return NULL;\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_len);\n\n    decrypted = FALSE;\n    if ( packet.src64 ) {\n        if (pinfo->fd->flags.visited) {\n            if ( nwk_hints ) {\n                /* Use previously found key */\n                switch ( packet.key_id ) {\n                    case ZBEE_SEC_KEY_NWK:\n                        if ( (key_rec = nwk_hints->nwk) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (key_rec = nwk_hints->link) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* ( !pinfo->fd->flags.visited ) */\n        else {\n            /* We only search for sniffed keys in the first pass,\n             * to save time, and because decrypting with keys\n             * transported in future packets is cheating */\n\n            /* Lookup NWK and link key in hash for this pan. */\n            /* This overkill approach is a placeholder for a hash that looks up\n             * a key ring for a link key associated with a pair of devices.\n             */\n            if ( nwk_hints ) {\n                nwk_keyring = (GSList **)g_hash_table_lookup(zbee_table_nwk_keyring, &nwk_hints->src_pan);\n\n                if ( nwk_keyring ) {\n                    GSList_i = *nwk_keyring;\n                    while ( GSList_i && !decrypted ) {\n                        decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                        if (decrypted) {\n                            /* save pointer to the successful key record */\n                            switch (packet.key_id) {\n                                case ZBEE_SEC_KEY_NWK:\n                                    key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                    break;\n\n                                default:\n                                    key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                    break;\n                            }\n                        } else {\n                            GSList_i = g_slist_next(GSList_i);\n                        }\n                    }\n                }\n\n                /* Loop through user's password table for preconfigured keys, our last resort */\n                GSList_i = zbee_pc_keyring;\n                while ( GSList_i && !decrypted ) {\n                    decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                            payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                    if (decrypted) {\n                        /* save pointer to the successful key record */\n                        switch (packet.key_id) {\n                            case ZBEE_SEC_KEY_NWK:\n                                key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                break;\n\n                            default:\n                                key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                break;\n                        }\n                    } else {\n                        GSList_i = g_slist_next(GSList_i);\n                    }\n                }\n            }\n        } /* ( ! pinfo->fd->flags.visited ) */\n    } /* ( packet.src64 ) */\n\n    if ( decrypted ) {\n        if ( tree && key_rec ) {\n            key_item = proto_tree_add_bytes(sec_tree, hf_zbee_sec_key, tvb, 0, ZBEE_SEC_CONST_KEYSIZE, key_rec->key);\n            PROTO_ITEM_SET_GENERATED(key_item);\n\n            if ( key_rec->frame_num == ZBEE_SEC_PC_KEY ) {\n                ti = proto_tree_add_string(sec_tree, hf_zbee_sec_decryption_key, tvb, 0, 0, key_rec->label);\n            } else {\n                ti = proto_tree_add_uint(sec_tree, hf_zbee_sec_key_origin, tvb, 0, 0,\n                        key_rec->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(ti);\n        }\n\n        /* Found a key that worked, setup the new tvbuff_t and return */\n        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_len, payload_len);\n        tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n        add_new_data_source(pinfo, payload_tvb, \"Decrypted ZigBee Payload\");\n\n        /* Done! */\n        return payload_tvb;\n    }\n\n    g_free(dec_buffer);\n#endif /* HAVE_LIBGCRYPT */\n\n    /* Add expert info. */\n    expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n    /* Create a buffer for the undecrypted payload. */\n    payload_tvb = tvb_new_subset(tvb, offset, payload_len, -1);\n    /* Dump the payload to the data dissector. */\n    call_dissector(data_handle, payload_tvb, pinfo, tree);\n    /* Couldn't decrypt, so return NULL. */\n    return NULL;\n}",
    "abstract_func_before": "tvbuff_t *\ndissect_zbee_secure(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree* VAR_2, guint VAR_3)\n{\n    proto_tree     *VAR_4;\n\n    zbee_security_packet    VAR_5;\n    guint           VAR_6;\n    gint            VAR_7;\n    tvbuff_t       *VAR_8;\n\n#ifdef VAR_9\n    proto_item         *VAR_10;\n    proto_item         *VAR_11;\n    guint8             *VAR_12;\n    guint8             *VAR_13;\n    gboolean            VAR_14;\n    GSList            **VAR_15;\n    GSList             *VAR_16;\n    key_record_t       *VAR_17 = NULL;\n#endif\n    zbee_nwk_hints_t   *VAR_18;\n    ieee802154_hints_t *VAR_19;\n    ieee802154_map_rec *VAR_20 = NULL;\n\n    static const int * VAR_21[] = {\n        &VAR_22,\n        &VAR_23,\n        NULL\n    };\n\n    /* COMMENT_0 */\n    memset(&VAR_5, 0, sizeof(zbee_security_packet));\n\n    /* COMMENT_1 */\n    VAR_18 = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), VAR_1,\n        proto_get_id_by_filter_name(VAR_24), 0);\n    VAR_19 = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), VAR_1,\n        proto_get_id_by_filter_name(VAR_25), 0);\n\n    /* COMMENT_2 */\n    VAR_4 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_3, -1, VAR_26, NULL, \"ZigBee Security Header\");\n\n    /* COMMENT_3 */\n    VAR_5.control  = tvb_get_guint8(VAR_0, VAR_3);\n\n    /* COMMENT_4 */\n    VAR_5.control &= ~VAR_27;\n    VAR_5.control |= (VAR_27 & VAR_28);\n\n    /* COMMENT_5 */\n                                                                           \n                                                                             \n                                                                           \n                                                                                          \n                                                                  \n       \n#ifdef VAR_9\n    VAR_12 = (guint8 *)tvb_memdup(wmem_packet_scope(), VAR_0, 0, tvb_captured_length(VAR_0));\n    /* COMMENT_12 */\n                                                                           \n                                                                      \n                                                                     \n       \n    VAR_12[VAR_3] = VAR_5.control;\n#endif /* COMMENT_17 */\n    VAR_5.level    = zbee_get_bit_field(VAR_5.control, VAR_27);\n    VAR_5.key_id   = zbee_get_bit_field(VAR_5.control, VAR_29);\n    VAR_5.nonce    = zbee_get_bit_field(VAR_5.control, VAR_30);\n\n    proto_tree_add_bitmask(VAR_4, VAR_0, VAR_3, VAR_31, VAR_32, VAR_21, VAR_33);\n    VAR_3 += 1;\n\n    /* COMMENT_18 */\n    VAR_5.counter = tvb_get_letohl(VAR_0, VAR_3);\n    if (VAR_2) {\n        proto_tree_add_uint(VAR_4, VAR_34, VAR_0, VAR_3, 4, VAR_5.counter);\n    }\n    VAR_3 += 4;\n\n    if (VAR_5.nonce) {\n        /* COMMENT_19 */\n        VAR_5.src64 = tvb_get_letoh64(VAR_0, VAR_3);\n        if (VAR_2) {\n            proto_tree_add_item(VAR_4, VAR_35, VAR_0, VAR_3, 8, VAR_36);\n        }\n#if 1\n        if (!VAR_1->fd->flags.visited) {\n            switch ( VAR_5.key_id ) {\n                case VAR_37:\n                if (VAR_18 && VAR_19) {\n                    /* COMMENT_20 */\n                    VAR_18->map_rec = ieee802154_addr_update(&VAR_38, VAR_18->src,\n                            VAR_19->src_pan, VAR_5.src64, VAR_1->current_proto, VAR_1->fd->num);\n                }\n                break;\n\n                case VAR_39:\n                if (VAR_19) {\n                    /* COMMENT_21 */\n                    VAR_19->map_rec = ieee802154_addr_update(&VAR_38, VAR_19->src16,\n                        VAR_19->src_pan, VAR_5.src64, VAR_1->current_proto, VAR_1->fd->num);\n                }\n                break;\n\n                /* COMMENT_22 */\n                                                                                                 \n                                                                  \n                case VAR_40:\n                case VAR_41:\n                break;\n            }\n        }\n#endif\n        VAR_3 += 8;\n    }\n    else {\n        /* COMMENT_25 */\n        switch ( VAR_5.key_id ) {\n            case VAR_39:\n                /* COMMENT_26 */\n                if ( VAR_19 && (VAR_20 = VAR_19->map_rec) )\n                    VAR_5.src64 = VAR_20->addr64;\n                else\n                    proto_tree_add_expert(VAR_4, VAR_1, &VAR_42, VAR_0, 0, 0);\n                break;\n\n            default:\n                /* COMMENT_27 */\n                if ( VAR_18 && (VAR_20 = VAR_18->map_rec) )\n                    VAR_5.src64 = VAR_20->addr64;\n                else\n                    proto_tree_add_expert(VAR_4, VAR_1, &VAR_42, VAR_0, 0, 0);\n                break;\n        }\n    }\n\n    if (VAR_5.key_id == VAR_39) {\n        /* COMMENT_28 */\n        VAR_5.key_seqno = tvb_get_guint8(VAR_0, VAR_3);\n        if (VAR_2) {\n            proto_tree_add_uint(VAR_4, VAR_43, VAR_0, VAR_3, 1, VAR_5.key_seqno);\n        }\n        VAR_3 += 1;\n    }\n\n    /* COMMENT_29 */\n    switch (VAR_5.level) {\n        case VAR_44:\n        case VAR_45:\n        default:\n            VAR_6=0;\n            break;\n\n        case VAR_46:\n        case VAR_47:\n            VAR_6=4;\n            break;\n\n        case VAR_48:\n        case VAR_49:\n            VAR_6=8;\n            break;\n\n        case VAR_50:\n        case VAR_51:\n            VAR_6=16;\n            break;\n    } /* COMMENT_30 */\n\n    /* COMMENT_31 */\n    if (VAR_6) {\n        /* COMMENT_32 */\n        if (VAR_2) {\n            proto_tree_add_item(VAR_4, VAR_52, VAR_0, (gint)(tvb_captured_length(VAR_0)-VAR_6),\n                   VAR_6, VAR_33);\n        }\n    }\n\n    /* COMMENT_33 */\n    VAR_7 = tvb_captured_length_remaining(VAR_0, VAR_3+VAR_6);\n    if (VAR_7 == 0)\n        return NULL;\n\n    /* COMMENT_34 */\n                                                   \n                                                   \n       \n    if ((VAR_5.level == VAR_45) ||\n        (VAR_5.level == VAR_47) ||\n        (VAR_5.level == VAR_49) ||\n        (VAR_5.level == VAR_51)) {\n\n        /* COMMENT_38 */\n        return tvb_new_subset_length(VAR_0, VAR_3, VAR_7);\n    }\n\n#ifdef VAR_9\n    /* COMMENT_39 */\n    VAR_13 = (guint8 *)g_malloc(VAR_7);\n\n    VAR_14 = FALSE;\n    if ( VAR_5.src64 ) {\n        if (VAR_1->fd->flags.visited) {\n            if ( VAR_18 ) {\n                /* COMMENT_40 */\n                switch ( VAR_5.key_id ) {\n                    case VAR_39:\n                        if ( (VAR_17 = VAR_18->nwk) ) {\n                            VAR_14 = zbee_sec_decrypt_payload( &VAR_5, VAR_12, VAR_3, VAR_13,\n                                VAR_7, VAR_6, VAR_18->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (VAR_17 = VAR_18->link) ) {\n                            VAR_14 = zbee_sec_decrypt_payload( &VAR_5, VAR_12, VAR_3, VAR_13,\n                                VAR_7, VAR_6, VAR_18->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* COMMENT_41 */\n        else {\n            /* COMMENT_42 */\n                                                             \n                                                           \n\n            /* COMMENT_45 */\n            /* COMMENT_46 */\n                                                                           \n               \n            if ( VAR_18 ) {\n                VAR_15 = (GSList **)g_hash_table_lookup(VAR_53, &VAR_18->src_pan);\n\n                if ( VAR_15 ) {\n                    VAR_16 = *VAR_15;\n                    while ( VAR_16 && !VAR_14 ) {\n                        VAR_14 = zbee_sec_decrypt_payload( &VAR_5, VAR_12, VAR_3, VAR_13,\n                                VAR_7, VAR_6, ((key_record_t *)(VAR_16->data))->key);\n\n                        if (VAR_14) {\n                            /* COMMENT_49 */\n                            switch (VAR_5.key_id) {\n                                case VAR_39:\n                                    VAR_17 = VAR_18->nwk = (key_record_t *)(VAR_16->data);\n                                    break;\n\n                                default:\n                                    VAR_17 = VAR_18->link = (key_record_t *)(VAR_16->data);\n                                    break;\n                            }\n                        } else {\n                            VAR_16 = g_slist_next(VAR_16);\n                        }\n                    }\n                }\n\n                /* COMMENT_50 */\n                VAR_16 = VAR_54;\n                while ( VAR_16 && !VAR_14 ) {\n                    VAR_14 = zbee_sec_decrypt_payload( &VAR_5, VAR_12, VAR_3, VAR_13,\n                            VAR_7, VAR_6, ((key_record_t *)(VAR_16->data))->key);\n\n                    if (VAR_14) {\n                        /* COMMENT_49 */\n                        switch (VAR_5.key_id) {\n                            case VAR_39:\n                                VAR_17 = VAR_18->nwk = (key_record_t *)(VAR_16->data);\n                                break;\n\n                            default:\n                                VAR_17 = VAR_18->link = (key_record_t *)(VAR_16->data);\n                                break;\n                        }\n                    } else {\n                        VAR_16 = g_slist_next(VAR_16);\n                    }\n                }\n            }\n        } /* COMMENT_51 */\n    } /* COMMENT_52 */\n\n    if ( VAR_14 ) {\n        if ( VAR_2 && VAR_17 ) {\n            VAR_11 = proto_tree_add_bytes(VAR_4, VAR_55, VAR_0, 0, VAR_56, VAR_17->key);\n            PROTO_ITEM_SET_GENERATED(VAR_11);\n\n            if ( VAR_17->frame_num == VAR_57 ) {\n                VAR_10 = proto_tree_add_string(VAR_4, VAR_58, VAR_0, 0, 0, VAR_17->label);\n            } else {\n                VAR_10 = proto_tree_add_uint(VAR_4, VAR_59, VAR_0, 0, 0,\n                        VAR_17->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(VAR_10);\n        }\n\n        /* COMMENT_53 */\n        VAR_8 = tvb_new_child_real_data(VAR_0, VAR_13, VAR_7, VAR_7);\n        tvb_set_free_cb(VAR_8, VAR_60); /* COMMENT_54 */\n        add_new_data_source(VAR_1, VAR_8, \"Decrypted ZigBee Payload\");\n\n        /* COMMENT_55 */\n        return VAR_8;\n    }\n\n    VAR_60(VAR_13);\n#endif /* COMMENT_17 */\n\n    /* COMMENT_56 */\n    expert_add_info(VAR_1, VAR_4, &VAR_61);\n    /* COMMENT_57 */\n    VAR_8 = tvb_new_subset(VAR_0, VAR_3, VAR_7, -1);\n    /* COMMENT_58 */\n    call_dissector(VAR_62, VAR_8, VAR_1, VAR_2);\n    /* COMMENT_59 */\n    return NULL;\n}",
    "func_graph_path_before": "wireshark/31571144be5f03f054a9c7e195b38c2f5792fe54/packet-zbee-security.c/vul/before/0.json",
    "func": "tvbuff_t *\ndissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint offset)\n{\n    proto_tree     *sec_tree;\n\n    zbee_security_packet    packet;\n    guint           mic_len;\n    gint            payload_reported_len;\n    tvbuff_t       *payload_tvb;\n\n#ifdef HAVE_LIBGCRYPT\n    gint               payload_captured_len;\n    proto_item         *ti;\n    proto_item         *key_item;\n    guint8             *enc_buffer;\n    guint8             *dec_buffer;\n    gboolean            decrypted;\n    GSList            **nwk_keyring;\n    GSList             *GSList_i;\n    key_record_t       *key_rec = NULL;\n#endif\n    zbee_nwk_hints_t   *nwk_hints;\n    ieee802154_hints_t *ieee_hints;\n    ieee802154_map_rec *map_rec = NULL;\n\n    static const int * sec_flags[] = {\n        &hf_zbee_sec_key_id,\n        &hf_zbee_sec_nonce,\n        NULL\n    };\n\n    /* Init */\n    memset(&packet, 0, sizeof(zbee_security_packet));\n\n    /* Get pointers to any useful frame data from lower layers */\n    nwk_hints = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(ZBEE_PROTOABBREV_NWK), 0);\n    ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN), 0);\n\n    /* Create a subtree for the security information. */\n    sec_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_zbee_sec, NULL, \"ZigBee Security Header\");\n\n    /*  Get and display the Security control field */\n    packet.control  = tvb_get_guint8(tvb, offset);\n\n    /* Patch the security level. */\n    packet.control &= ~ZBEE_SEC_CONTROL_LEVEL;\n    packet.control |= (ZBEE_SEC_CONTROL_LEVEL & gPREF_zbee_sec_level);\n\n    /*\n     * Eww, I think I just threw up a little...  ZigBee requires this field\n     * to be patched before computing the MIC, but we don't have write-access\n     * to the tvbuff. So we need to allocate a copy of the whole thing just\n     * so we can fix these 3 bits. Memory allocated by tvb_memdup(wmem_packet_scope(),...)\n     * is automatically freed before the next packet is processed.\n     */\n#ifdef HAVE_LIBGCRYPT\n    enc_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb));\n    /*\n     * Override the const qualifiers and patch the security level field, we\n     * know it is safe to overide the const qualifiers because we just\n     * allocated this memory via tvb_memdup(wmem_packet_scope(),...).\n     */\n    enc_buffer[offset] = packet.control;\n#endif /* HAVE_LIBGCRYPT */\n    packet.level    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_LEVEL);\n    packet.key_id   = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_KEY);\n    packet.nonce    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_NONCE);\n\n    proto_tree_add_bitmask(sec_tree, tvb, offset, hf_zbee_sec_field, ett_zbee_sec_control, sec_flags, ENC_NA);\n    offset += 1;\n\n    /* Get and display the frame counter field. */\n    packet.counter = tvb_get_letohl(tvb, offset);\n    if (tree) {\n        proto_tree_add_uint(sec_tree, hf_zbee_sec_counter, tvb, offset, 4, packet.counter);\n    }\n    offset += 4;\n\n    if (packet.nonce) {\n        /* Get and display the source address of the device that secured this payload. */\n        packet.src64 = tvb_get_letoh64(tvb, offset);\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_src64, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        }\n#if 1\n        if (!pinfo->fd->flags.visited) {\n            switch ( packet.key_id ) {\n                case ZBEE_SEC_KEY_LINK:\n                if (nwk_hints && ieee_hints) {\n                    /* Map this long address with the nwk layer short address. */\n                    nwk_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, nwk_hints->src,\n                            ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                case ZBEE_SEC_KEY_NWK:\n                if (ieee_hints) {\n                    /* Map this long address with the ieee short address. */\n                    ieee_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, ieee_hints->src16,\n                        ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                /* We ignore the extended source addresses used to encrypt payloads with these\n                 * types of keys, because they can emerge from APS tunnels created by nodes whose\n                 * short address is not recorded in the packet. */\n                case ZBEE_SEC_KEY_TRANSPORT:\n                case ZBEE_SEC_KEY_LOAD:\n                break;\n            }\n        }\n#endif\n        offset += 8;\n    }\n    else {\n        /* Look for a source address in hints */\n        switch ( packet.key_id ) {\n            case ZBEE_SEC_KEY_NWK:\n                /* use the ieee extended source address for NWK decryption */\n                if ( ieee_hints && (map_rec = ieee_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n\n            default:\n                /* use the nwk extended source address for APS decryption */\n                if ( nwk_hints && (map_rec = nwk_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n        }\n    }\n\n    if (packet.key_id == ZBEE_SEC_KEY_NWK) {\n        /* Get and display the key sequence number. */\n        packet.key_seqno = tvb_get_guint8(tvb, offset);\n        if (tree) {\n            proto_tree_add_uint(sec_tree, hf_zbee_sec_key_seqno, tvb, offset, 1, packet.key_seqno);\n        }\n        offset += 1;\n    }\n\n    /* Determine the length of the MIC. */\n    switch (packet.level) {\n        case ZBEE_SEC_ENC:\n        case ZBEE_SEC_NONE:\n        default:\n            mic_len=0;\n            break;\n\n        case ZBEE_SEC_ENC_MIC32:\n        case ZBEE_SEC_MIC32:\n            mic_len=4;\n            break;\n\n        case ZBEE_SEC_ENC_MIC64:\n        case ZBEE_SEC_MIC64:\n            mic_len=8;\n            break;\n\n        case ZBEE_SEC_ENC_MIC128:\n        case ZBEE_SEC_MIC128:\n            mic_len=16;\n            break;\n    } /* switch */\n\n    /* Get and display the MIC. */\n    if (mic_len) {\n        /* Display the MIC. */\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_mic, tvb, (gint)(tvb_captured_length(tvb)-mic_len),\n                   mic_len, ENC_NA);\n        }\n    }\n\n    /* Check for null payload. */\n    payload_reported_len = tvb_reported_length_remaining(tvb, offset+mic_len);\n    if (payload_reported_len == 0)\n        return NULL;\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_reported_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* How much payload was actually captured? */\n    payload_captured_len = tvb_captured_length_remaining(tvb, offset+mic_len);\n\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_captured_len);\n\n    decrypted = FALSE;\n    if ( packet.src64 ) {\n        if (pinfo->fd->flags.visited) {\n            if ( nwk_hints ) {\n                /* Use previously found key */\n                switch ( packet.key_id ) {\n                    case ZBEE_SEC_KEY_NWK:\n                        if ( (key_rec = nwk_hints->nwk) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, nwk_hints->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (key_rec = nwk_hints->link) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, nwk_hints->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* ( !pinfo->fd->flags.visited ) */\n        else {\n            /* We only search for sniffed keys in the first pass,\n             * to save time, and because decrypting with keys\n             * transported in future packets is cheating */\n\n            /* Lookup NWK and link key in hash for this pan. */\n            /* This overkill approach is a placeholder for a hash that looks up\n             * a key ring for a link key associated with a pair of devices.\n             */\n            if ( nwk_hints ) {\n                nwk_keyring = (GSList **)g_hash_table_lookup(zbee_table_nwk_keyring, &nwk_hints->src_pan);\n\n                if ( nwk_keyring ) {\n                    GSList_i = *nwk_keyring;\n                    while ( GSList_i && !decrypted ) {\n                        decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                        if (decrypted) {\n                            /* save pointer to the successful key record */\n                            switch (packet.key_id) {\n                                case ZBEE_SEC_KEY_NWK:\n                                    key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                    break;\n\n                                default:\n                                    key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                    break;\n                            }\n                        } else {\n                            GSList_i = g_slist_next(GSList_i);\n                        }\n                    }\n                }\n\n                /* Loop through user's password table for preconfigured keys, our last resort */\n                GSList_i = zbee_pc_keyring;\n                while ( GSList_i && !decrypted ) {\n                    decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                            payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                    if (decrypted) {\n                        /* save pointer to the successful key record */\n                        switch (packet.key_id) {\n                            case ZBEE_SEC_KEY_NWK:\n                                key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                break;\n\n                            default:\n                                key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                break;\n                        }\n                    } else {\n                        GSList_i = g_slist_next(GSList_i);\n                    }\n                }\n            }\n        } /* ( ! pinfo->fd->flags.visited ) */\n    } /* ( packet.src64 ) */\n\n    if ( decrypted ) {\n        if ( tree && key_rec ) {\n            key_item = proto_tree_add_bytes(sec_tree, hf_zbee_sec_key, tvb, 0, ZBEE_SEC_CONST_KEYSIZE, key_rec->key);\n            PROTO_ITEM_SET_GENERATED(key_item);\n\n            if ( key_rec->frame_num == ZBEE_SEC_PC_KEY ) {\n                ti = proto_tree_add_string(sec_tree, hf_zbee_sec_decryption_key, tvb, 0, 0, key_rec->label);\n            } else {\n                ti = proto_tree_add_uint(sec_tree, hf_zbee_sec_key_origin, tvb, 0, 0,\n                        key_rec->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(ti);\n        }\n\n        /* Found a key that worked, setup the new tvbuff_t and return */\n        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_captured_len, payload_reported_len);\n        tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n        add_new_data_source(pinfo, payload_tvb, \"Decrypted ZigBee Payload\");\n\n        /* Done! */\n        return payload_tvb;\n    }\n\n    g_free(dec_buffer);\n#endif /* HAVE_LIBGCRYPT */\n\n    /* Add expert info. */\n    expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n    /* Create a buffer for the undecrypted payload. */\n    payload_tvb = tvb_new_subset_length(tvb, offset, payload_reported_len);\n    /* Dump the payload to the data dissector. */\n    call_dissector(data_handle, payload_tvb, pinfo, tree);\n    /* Couldn't decrypt, so return NULL. */\n    return NULL;\n}",
    "abstract_func": "tvbuff_t *\ndissect_zbee_secure(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree* VAR_2, guint VAR_3)\n{\n    proto_tree     *VAR_4;\n\n    zbee_security_packet    VAR_5;\n    guint           VAR_6;\n    gint            VAR_7;\n    tvbuff_t       *VAR_8;\n\n#ifdef VAR_9\n    gint               VAR_10;\n    proto_item         *VAR_11;\n    proto_item         *VAR_12;\n    guint8             *VAR_13;\n    guint8             *VAR_14;\n    gboolean            VAR_15;\n    GSList            **VAR_16;\n    GSList             *VAR_17;\n    key_record_t       *VAR_18 = NULL;\n#endif\n    zbee_nwk_hints_t   *VAR_19;\n    ieee802154_hints_t *VAR_20;\n    ieee802154_map_rec *VAR_21 = NULL;\n\n    static const int * VAR_22[] = {\n        &VAR_23,\n        &VAR_24,\n        NULL\n    };\n\n    /* COMMENT_0 */\n    memset(&VAR_5, 0, sizeof(zbee_security_packet));\n\n    /* COMMENT_1 */\n    VAR_19 = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), VAR_1,\n        proto_get_id_by_filter_name(VAR_25), 0);\n    VAR_20 = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), VAR_1,\n        proto_get_id_by_filter_name(VAR_26), 0);\n\n    /* COMMENT_2 */\n    VAR_4 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_3, -1, VAR_27, NULL, \"ZigBee Security Header\");\n\n    /* COMMENT_3 */\n    VAR_5.control  = tvb_get_guint8(VAR_0, VAR_3);\n\n    /* COMMENT_4 */\n    VAR_5.control &= ~VAR_28;\n    VAR_5.control |= (VAR_28 & VAR_29);\n\n    /* COMMENT_5 */\n                                                                           \n                                                                             \n                                                                           \n                                                                                          \n                                                                  \n       \n#ifdef VAR_9\n    VAR_13 = (guint8 *)tvb_memdup(wmem_packet_scope(), VAR_0, 0, tvb_captured_length(VAR_0));\n    /* COMMENT_12 */\n                                                                           \n                                                                      \n                                                                     \n       \n    VAR_13[VAR_3] = VAR_5.control;\n#endif /* COMMENT_17 */\n    VAR_5.level    = zbee_get_bit_field(VAR_5.control, VAR_28);\n    VAR_5.key_id   = zbee_get_bit_field(VAR_5.control, VAR_30);\n    VAR_5.nonce    = zbee_get_bit_field(VAR_5.control, VAR_31);\n\n    proto_tree_add_bitmask(VAR_4, VAR_0, VAR_3, VAR_32, VAR_33, VAR_22, VAR_34);\n    VAR_3 += 1;\n\n    /* COMMENT_18 */\n    VAR_5.counter = tvb_get_letohl(VAR_0, VAR_3);\n    if (VAR_2) {\n        proto_tree_add_uint(VAR_4, VAR_35, VAR_0, VAR_3, 4, VAR_5.counter);\n    }\n    VAR_3 += 4;\n\n    if (VAR_5.nonce) {\n        /* COMMENT_19 */\n        VAR_5.src64 = tvb_get_letoh64(VAR_0, VAR_3);\n        if (VAR_2) {\n            proto_tree_add_item(VAR_4, VAR_36, VAR_0, VAR_3, 8, VAR_37);\n        }\n#if 1\n        if (!VAR_1->fd->flags.visited) {\n            switch ( VAR_5.key_id ) {\n                case VAR_38:\n                if (VAR_19 && VAR_20) {\n                    /* COMMENT_20 */\n                    VAR_19->map_rec = ieee802154_addr_update(&VAR_39, VAR_19->src,\n                            VAR_20->src_pan, VAR_5.src64, VAR_1->current_proto, VAR_1->fd->num);\n                }\n                break;\n\n                case VAR_40:\n                if (VAR_20) {\n                    /* COMMENT_21 */\n                    VAR_20->map_rec = ieee802154_addr_update(&VAR_39, VAR_20->src16,\n                        VAR_20->src_pan, VAR_5.src64, VAR_1->current_proto, VAR_1->fd->num);\n                }\n                break;\n\n                /* COMMENT_22 */\n                                                                                                 \n                                                                  \n                case VAR_41:\n                case VAR_42:\n                break;\n            }\n        }\n#endif\n        VAR_3 += 8;\n    }\n    else {\n        /* COMMENT_25 */\n        switch ( VAR_5.key_id ) {\n            case VAR_40:\n                /* COMMENT_26 */\n                if ( VAR_20 && (VAR_21 = VAR_20->map_rec) )\n                    VAR_5.src64 = VAR_21->addr64;\n                else\n                    proto_tree_add_expert(VAR_4, VAR_1, &VAR_43, VAR_0, 0, 0);\n                break;\n\n            default:\n                /* COMMENT_27 */\n                if ( VAR_19 && (VAR_21 = VAR_19->map_rec) )\n                    VAR_5.src64 = VAR_21->addr64;\n                else\n                    proto_tree_add_expert(VAR_4, VAR_1, &VAR_43, VAR_0, 0, 0);\n                break;\n        }\n    }\n\n    if (VAR_5.key_id == VAR_40) {\n        /* COMMENT_28 */\n        VAR_5.key_seqno = tvb_get_guint8(VAR_0, VAR_3);\n        if (VAR_2) {\n            proto_tree_add_uint(VAR_4, VAR_44, VAR_0, VAR_3, 1, VAR_5.key_seqno);\n        }\n        VAR_3 += 1;\n    }\n\n    /* COMMENT_29 */\n    switch (VAR_5.level) {\n        case VAR_45:\n        case VAR_46:\n        default:\n            VAR_6=0;\n            break;\n\n        case VAR_47:\n        case VAR_48:\n            VAR_6=4;\n            break;\n\n        case VAR_49:\n        case VAR_50:\n            VAR_6=8;\n            break;\n\n        case VAR_51:\n        case VAR_52:\n            VAR_6=16;\n            break;\n    } /* COMMENT_30 */\n\n    /* COMMENT_31 */\n    if (VAR_6) {\n        /* COMMENT_32 */\n        if (VAR_2) {\n            proto_tree_add_item(VAR_4, VAR_53, VAR_0, (gint)(tvb_captured_length(VAR_0)-VAR_6),\n                   VAR_6, VAR_34);\n        }\n    }\n\n    /* COMMENT_33 */\n    VAR_7 = tvb_reported_length_remaining(VAR_0, VAR_3+VAR_6);\n    if (VAR_7 == 0)\n        return NULL;\n\n    /* COMMENT_34 */\n                                                   \n                                                   \n       \n    if ((VAR_5.level == VAR_46) ||\n        (VAR_5.level == VAR_48) ||\n        (VAR_5.level == VAR_50) ||\n        (VAR_5.level == VAR_52)) {\n\n        /* COMMENT_38 */\n        return tvb_new_subset_length(VAR_0, VAR_3, VAR_7);\n    }\n\n#ifdef VAR_9\n    /* COMMENT_39 */\n    VAR_10 = tvb_captured_length_remaining(VAR_0, VAR_3+VAR_6);\n\n    /* COMMENT_40 */\n    VAR_14 = (guint8 *)g_malloc(VAR_10);\n\n    VAR_15 = FALSE;\n    if ( VAR_5.src64 ) {\n        if (VAR_1->fd->flags.visited) {\n            if ( VAR_19 ) {\n                /* COMMENT_41 */\n                switch ( VAR_5.key_id ) {\n                    case VAR_40:\n                        if ( (VAR_18 = VAR_19->nwk) ) {\n                            VAR_15 = zbee_sec_decrypt_payload( &VAR_5, VAR_13, VAR_3, VAR_14,\n                                VAR_10, VAR_6, VAR_19->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (VAR_18 = VAR_19->link) ) {\n                            VAR_15 = zbee_sec_decrypt_payload( &VAR_5, VAR_13, VAR_3, VAR_14,\n                                VAR_10, VAR_6, VAR_19->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* COMMENT_42 */\n        else {\n            /* COMMENT_43 */\n                                                             \n                                                           \n\n            /* COMMENT_46 */\n            /* COMMENT_47 */\n                                                                           \n               \n            if ( VAR_19 ) {\n                VAR_16 = (GSList **)g_hash_table_lookup(VAR_54, &VAR_19->src_pan);\n\n                if ( VAR_16 ) {\n                    VAR_17 = *VAR_16;\n                    while ( VAR_17 && !VAR_15 ) {\n                        VAR_15 = zbee_sec_decrypt_payload( &VAR_5, VAR_13, VAR_3, VAR_14,\n                                VAR_10, VAR_6, ((key_record_t *)(VAR_17->data))->key);\n\n                        if (VAR_15) {\n                            /* COMMENT_50 */\n                            switch (VAR_5.key_id) {\n                                case VAR_40:\n                                    VAR_18 = VAR_19->nwk = (key_record_t *)(VAR_17->data);\n                                    break;\n\n                                default:\n                                    VAR_18 = VAR_19->link = (key_record_t *)(VAR_17->data);\n                                    break;\n                            }\n                        } else {\n                            VAR_17 = g_slist_next(VAR_17);\n                        }\n                    }\n                }\n\n                /* COMMENT_51 */\n                VAR_17 = VAR_55;\n                while ( VAR_17 && !VAR_15 ) {\n                    VAR_15 = zbee_sec_decrypt_payload( &VAR_5, VAR_13, VAR_3, VAR_14,\n                            VAR_10, VAR_6, ((key_record_t *)(VAR_17->data))->key);\n\n                    if (VAR_15) {\n                        /* COMMENT_50 */\n                        switch (VAR_5.key_id) {\n                            case VAR_40:\n                                VAR_18 = VAR_19->nwk = (key_record_t *)(VAR_17->data);\n                                break;\n\n                            default:\n                                VAR_18 = VAR_19->link = (key_record_t *)(VAR_17->data);\n                                break;\n                        }\n                    } else {\n                        VAR_17 = g_slist_next(VAR_17);\n                    }\n                }\n            }\n        } /* COMMENT_52 */\n    } /* COMMENT_53 */\n\n    if ( VAR_15 ) {\n        if ( VAR_2 && VAR_18 ) {\n            VAR_12 = proto_tree_add_bytes(VAR_4, VAR_56, VAR_0, 0, VAR_57, VAR_18->key);\n            PROTO_ITEM_SET_GENERATED(VAR_12);\n\n            if ( VAR_18->frame_num == VAR_58 ) {\n                VAR_11 = proto_tree_add_string(VAR_4, VAR_59, VAR_0, 0, 0, VAR_18->label);\n            } else {\n                VAR_11 = proto_tree_add_uint(VAR_4, VAR_60, VAR_0, 0, 0,\n                        VAR_18->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(VAR_11);\n        }\n\n        /* COMMENT_54 */\n        VAR_8 = tvb_new_child_real_data(VAR_0, VAR_14, VAR_10, VAR_7);\n        tvb_set_free_cb(VAR_8, VAR_61); /* COMMENT_55 */\n        add_new_data_source(VAR_1, VAR_8, \"Decrypted ZigBee Payload\");\n\n        /* COMMENT_56 */\n        return VAR_8;\n    }\n\n    VAR_61(VAR_14);\n#endif /* COMMENT_17 */\n\n    /* COMMENT_57 */\n    expert_add_info(VAR_1, VAR_4, &VAR_62);\n    /* COMMENT_58 */\n    VAR_8 = tvb_new_subset_length(VAR_0, VAR_3, VAR_7);\n    /* COMMENT_59 */\n    call_dissector(VAR_63, VAR_8, VAR_1, VAR_2);\n    /* COMMENT_60 */\n    return NULL;\n}",
    "func_graph_path": "wireshark/31571144be5f03f054a9c7e195b38c2f5792fe54/packet-zbee-security.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -5,10 +5,11 @@\n \n     zbee_security_packet    packet;\n     guint           mic_len;\n-    gint            payload_len;\n+    gint            payload_reported_len;\n     tvbuff_t       *payload_tvb;\n \n #ifdef HAVE_LIBGCRYPT\n+    gint               payload_captured_len;\n     proto_item         *ti;\n     proto_item         *key_item;\n     guint8             *enc_buffer;\n@@ -177,8 +178,8 @@\n     }\n \n     /* Check for null payload. */\n-    payload_len = tvb_captured_length_remaining(tvb, offset+mic_len);\n-    if (payload_len == 0)\n+    payload_reported_len = tvb_reported_length_remaining(tvb, offset+mic_len);\n+    if (payload_reported_len == 0)\n         return NULL;\n \n     /**********************************************\n@@ -191,12 +192,15 @@\n         (packet.level == ZBEE_SEC_MIC128)) {\n \n         /* Payload is only integrity protected. Just return the sub-tvbuff. */\n-        return tvb_new_subset_length(tvb, offset, payload_len);\n+        return tvb_new_subset_length(tvb, offset, payload_reported_len);\n     }\n \n #ifdef HAVE_LIBGCRYPT\n+    /* How much payload was actually captured? */\n+    payload_captured_len = tvb_captured_length_remaining(tvb, offset+mic_len);\n+\n     /* Allocate memory to decrypt the payload into. */\n-    dec_buffer = (guint8 *)g_malloc(payload_len);\n+    dec_buffer = (guint8 *)g_malloc(payload_captured_len);\n \n     decrypted = FALSE;\n     if ( packet.src64 ) {\n@@ -207,14 +211,14 @@\n                     case ZBEE_SEC_KEY_NWK:\n                         if ( (key_rec = nwk_hints->nwk) ) {\n                             decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n-                                payload_len, mic_len, nwk_hints->nwk->key);\n+                                payload_captured_len, mic_len, nwk_hints->nwk->key);\n                         }\n                         break;\n \n                     default:\n                         if ( (key_rec = nwk_hints->link) ) {\n                             decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n-                                payload_len, mic_len, nwk_hints->link->key);\n+                                payload_captured_len, mic_len, nwk_hints->link->key);\n                         }\n                         break;\n                 }\n@@ -236,7 +240,7 @@\n                     GSList_i = *nwk_keyring;\n                     while ( GSList_i && !decrypted ) {\n                         decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n-                                payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n+                                payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n \n                         if (decrypted) {\n                             /* save pointer to the successful key record */\n@@ -259,7 +263,7 @@\n                 GSList_i = zbee_pc_keyring;\n                 while ( GSList_i && !decrypted ) {\n                     decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n-                            payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n+                            payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n \n                     if (decrypted) {\n                         /* save pointer to the successful key record */\n@@ -295,7 +299,7 @@\n         }\n \n         /* Found a key that worked, setup the new tvbuff_t and return */\n-        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_len, payload_len);\n+        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_captured_len, payload_reported_len);\n         tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n         add_new_data_source(pinfo, payload_tvb, \"Decrypted ZigBee Payload\");\n \n@@ -309,7 +313,7 @@\n     /* Add expert info. */\n     expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n     /* Create a buffer for the undecrypted payload. */\n-    payload_tvb = tvb_new_subset(tvb, offset, payload_len, -1);\n+    payload_tvb = tvb_new_subset_length(tvb, offset, payload_reported_len);\n     /* Dump the payload to the data dissector. */\n     call_dissector(data_handle, payload_tvb, pinfo, tree);\n     /* Couldn't decrypt, so return NULL. */",
    "diff_line_info": {
        "deleted_lines": [
            "    gint            payload_len;",
            "    payload_len = tvb_captured_length_remaining(tvb, offset+mic_len);",
            "    if (payload_len == 0)",
            "        return tvb_new_subset_length(tvb, offset, payload_len);",
            "    dec_buffer = (guint8 *)g_malloc(payload_len);",
            "                                payload_len, mic_len, nwk_hints->nwk->key);",
            "                                payload_len, mic_len, nwk_hints->link->key);",
            "                                payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);",
            "                            payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);",
            "        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_len, payload_len);",
            "    payload_tvb = tvb_new_subset(tvb, offset, payload_len, -1);"
        ],
        "added_lines": [
            "    gint            payload_reported_len;",
            "    gint               payload_captured_len;",
            "    payload_reported_len = tvb_reported_length_remaining(tvb, offset+mic_len);",
            "    if (payload_reported_len == 0)",
            "        return tvb_new_subset_length(tvb, offset, payload_reported_len);",
            "    /* How much payload was actually captured? */",
            "    payload_captured_len = tvb_captured_length_remaining(tvb, offset+mic_len);",
            "",
            "    dec_buffer = (guint8 *)g_malloc(payload_captured_len);",
            "                                payload_captured_len, mic_len, nwk_hints->nwk->key);",
            "                                payload_captured_len, mic_len, nwk_hints->link->key);",
            "                                payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);",
            "                            payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);",
            "        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_captured_len, payload_reported_len);",
            "    payload_tvb = tvb_new_subset_length(tvb, offset, payload_reported_len);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}