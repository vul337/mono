{
    "cve_id": "CVE-2019-10184",
    "cwe_ids": [
        "CWE-862"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "undertow-io/undertow",
    "commit_msg": "[UNDERTOW-1578] 401 Unauthorized should be returned when requesting a protected directory without trailing slash",
    "commit_hash": "d2715e3afa13f50deaa19643676816ce391551e9",
    "git_url": "https://github.com/undertow-io/undertow/commit/d2715e3afa13f50deaa19643676816ce391551e9",
    "file_path": "servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java",
    "func_name": "handleRequest",
    "func_before": "@Override\n    public void handleRequest(final HttpServerExchange exchange) throws Exception {\n        final String path = exchange.getRelativePath();\n        if(isForbiddenPath(path)) {\n            exchange.setStatusCode(StatusCodes.NOT_FOUND);\n            return;\n        }\n        final ServletPathMatch info = paths.getServletHandlerByPath(path);\n        //https://issues.jboss.org/browse/WFLY-3439\n        //if the request is an upgrade request then we don't want to redirect\n        //as there is a good chance the web socket client won't understand the redirect\n        //we make an exception for HTTP2 upgrade requests, as this would have already be handled at\n        //the connector level if it was going to be handled.\n        String upgradeString = exchange.getRequestHeaders().getFirst(Headers.UPGRADE);\n        boolean isUpgradeRequest = upgradeString != null && !upgradeString.startsWith(HTTP2_UPGRADE_PREFIX);\n        if (info.getType() == ServletPathMatch.Type.REDIRECT && !isUpgradeRequest) {\n            //UNDERTOW-89\n            //we redirect on GET requests to the root context to add an / to the end\n            if(exchange.getRequestMethod().equals(Methods.GET) || exchange.getRequestMethod().equals(Methods.HEAD)) {\n                exchange.setStatusCode(StatusCodes.FOUND);\n            } else {\n                exchange.setStatusCode(StatusCodes.TEMPORARY_REDIRECT);\n            }\n            exchange.getResponseHeaders().put(Headers.LOCATION, RedirectBuilder.redirect(exchange, exchange.getRelativePath() + \"/\", true));\n            return;\n        } else if (info.getType() == ServletPathMatch.Type.REWRITE) {\n            //this can only happen if the path ends with a /\n            //otherwise there would be a redirect instead\n            exchange.setRelativePath(info.getRewriteLocation());\n            exchange.setRequestPath(exchange.getResolvedPath() + info.getRewriteLocation());\n        }\n\n        final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);\n        final HttpServletRequestImpl request = new HttpServletRequestImpl(exchange, servletContext);\n        final ServletRequestContext servletRequestContext = new ServletRequestContext(servletContext.getDeployment(), request, response, info);\n        //set the max request size if applicable\n        if (info.getServletChain().getManagedServlet().getMaxRequestSize() > 0) {\n            exchange.setMaxEntitySize(info.getServletChain().getManagedServlet().getMaxRequestSize());\n        }\n        exchange.putAttachment(ServletRequestContext.ATTACHMENT_KEY, servletRequestContext);\n\n        exchange.startBlocking(new ServletBlockingHttpExchange(exchange));\n        servletRequestContext.setServletPathMatch(info);\n\n        Executor executor = info.getServletChain().getExecutor();\n        if (executor == null) {\n            executor = servletContext.getDeployment().getExecutor();\n        }\n\n        if (exchange.isInIoThread() || executor != null) {\n            //either the exchange has not been dispatched yet, or we need to use a special executor\n            exchange.dispatch(executor, dispatchHandler);\n        } else {\n            dispatchRequest(exchange, servletRequestContext, info.getServletChain(), DispatcherType.REQUEST);\n        }\n    }",
    "abstract_func_before": "@Override\n    public void handleRequest(final HttpServerExchange VAR_0) throws Exception {\n        final String VAR_1 = VAR_0.getRelativePath();\n        if(isForbiddenPath(VAR_1)) {\n            VAR_0.setStatusCode(VAR_2.NOT_FOUND);\n            return;\n        }\n        final ServletPathMatch VAR_3 = VAR_4.getServletHandlerByPath(VAR_1);\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        String VAR_5 = VAR_0.getRequestHeaders().getFirst(VAR_6.UPGRADE);\n        boolean VAR_7 = VAR_5 != null && !VAR_5.startsWith(VAR_8);\n        if (VAR_3.getType() == VAR_9.Type.REDIRECT && !VAR_7) {\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n            if(VAR_0.getRequestMethod().equals(VAR_10.GET) || VAR_0.getRequestMethod().equals(VAR_10.HEAD)) {\n                VAR_0.setStatusCode(VAR_2.FOUND);\n            } else {\n                VAR_0.setStatusCode(VAR_2.TEMPORARY_REDIRECT);\n            }\n            VAR_0.getResponseHeaders().put(VAR_6.LOCATION, VAR_11.redirect(VAR_0, VAR_0.getRelativePath() + \"/\", true));\n            return;\n        } else if (VAR_3.getType() == VAR_9.Type.REWRITE) {\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            VAR_0.setRelativePath(VAR_3.getRewriteLocation());\n            VAR_0.setRequestPath(VAR_0.getResolvedPath() + VAR_3.getRewriteLocation());\n        }\n\n        final HttpServletResponseImpl VAR_12 = new HttpServletResponseImpl(VAR_0, VAR_13);\n        final HttpServletRequestImpl VAR_14 = new HttpServletRequestImpl(VAR_0, VAR_13);\n        final ServletRequestContext VAR_15 = new ServletRequestContext(VAR_13.getDeployment(), VAR_14, VAR_12, VAR_3);\n        /* COMMENT_9 */\n        if (VAR_3.getServletChain().getManagedServlet().getMaxRequestSize() > 0) {\n            VAR_0.setMaxEntitySize(VAR_3.getServletChain().getManagedServlet().getMaxRequestSize());\n        }\n        VAR_0.putAttachment(VAR_16.ATTACHMENT_KEY, VAR_15);\n\n        VAR_0.startBlocking(new ServletBlockingHttpExchange(VAR_0));\n        VAR_15.setServletPathMatch(VAR_3);\n\n        Executor VAR_17 = VAR_3.getServletChain().getExecutor();\n        if (VAR_17 == null) {\n            VAR_17 = VAR_13.getDeployment().getExecutor();\n        }\n\n        if (VAR_0.isInIoThread() || VAR_17 != null) {\n            /* COMMENT_10 */\n            VAR_0.dispatch(VAR_17, VAR_18);\n        } else {\n            dispatchRequest(VAR_0, VAR_15, VAR_3.getServletChain(), VAR_19.REQUEST);\n        }\n    }",
    "func_graph_path_before": "undertow-io/undertow/d2715e3afa13f50deaa19643676816ce391551e9/ServletInitialHandler.java/vul/before/0.json",
    "func": "@Override\n    public void handleRequest(final HttpServerExchange exchange) throws Exception {\n        final String path = exchange.getRelativePath();\n        if(isForbiddenPath(path)) {\n            exchange.setStatusCode(StatusCodes.NOT_FOUND);\n            return;\n        }\n        final ServletPathMatch info = paths.getServletHandlerByPath(path);\n        if (info.getType() == ServletPathMatch.Type.REWRITE) {\n            // this can only happen if the path ends with a /\n            // otherwise there would be a redirect instead\n            exchange.setRelativePath(info.getRewriteLocation());\n            exchange.setRequestPath(exchange.getResolvedPath() + info.getRewriteLocation());\n        }\n        final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);\n        final HttpServletRequestImpl request = new HttpServletRequestImpl(exchange, servletContext);\n        final ServletRequestContext servletRequestContext = new ServletRequestContext(servletContext.getDeployment(), request, response, info);\n        //set the max request size if applicable\n        if (info.getServletChain().getManagedServlet().getMaxRequestSize() > 0) {\n            exchange.setMaxEntitySize(info.getServletChain().getManagedServlet().getMaxRequestSize());\n        }\n        exchange.putAttachment(ServletRequestContext.ATTACHMENT_KEY, servletRequestContext);\n\n        exchange.startBlocking(new ServletBlockingHttpExchange(exchange));\n        servletRequestContext.setServletPathMatch(info);\n\n        Executor executor = info.getServletChain().getExecutor();\n        if (executor == null) {\n            executor = servletContext.getDeployment().getExecutor();\n        }\n\n        if (exchange.isInIoThread() || executor != null) {\n            //either the exchange has not been dispatched yet, or we need to use a special executor\n            exchange.dispatch(executor, dispatchHandler);\n        } else {\n            dispatchRequest(exchange, servletRequestContext, info.getServletChain(), DispatcherType.REQUEST);\n        }\n    }",
    "abstract_func": "@Override\n    public void handleRequest(final HttpServerExchange VAR_0) throws Exception {\n        final String VAR_1 = VAR_0.getRelativePath();\n        if(isForbiddenPath(VAR_1)) {\n            VAR_0.setStatusCode(VAR_2.NOT_FOUND);\n            return;\n        }\n        final ServletPathMatch VAR_3 = VAR_4.getServletHandlerByPath(VAR_1);\n        if (VAR_3.getType() == VAR_5.Type.REWRITE) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            VAR_0.setRelativePath(VAR_3.getRewriteLocation());\n            VAR_0.setRequestPath(VAR_0.getResolvedPath() + VAR_3.getRewriteLocation());\n        }\n        final HttpServletResponseImpl VAR_6 = new HttpServletResponseImpl(VAR_0, VAR_7);\n        final HttpServletRequestImpl VAR_8 = new HttpServletRequestImpl(VAR_0, VAR_7);\n        final ServletRequestContext VAR_9 = new ServletRequestContext(VAR_7.getDeployment(), VAR_8, VAR_6, VAR_3);\n        /* COMMENT_2 */\n        if (VAR_3.getServletChain().getManagedServlet().getMaxRequestSize() > 0) {\n            VAR_0.setMaxEntitySize(VAR_3.getServletChain().getManagedServlet().getMaxRequestSize());\n        }\n        VAR_0.putAttachment(VAR_10.ATTACHMENT_KEY, VAR_9);\n\n        VAR_0.startBlocking(new ServletBlockingHttpExchange(VAR_0));\n        VAR_9.setServletPathMatch(VAR_3);\n\n        Executor VAR_11 = VAR_3.getServletChain().getExecutor();\n        if (VAR_11 == null) {\n            VAR_11 = VAR_7.getDeployment().getExecutor();\n        }\n\n        if (VAR_0.isInIoThread() || VAR_11 != null) {\n            /* COMMENT_3 */\n            VAR_0.dispatch(VAR_11, VAR_12);\n        } else {\n            dispatchRequest(VAR_0, VAR_9, VAR_3.getServletChain(), VAR_13.REQUEST);\n        }\n    }",
    "func_graph_path": "undertow-io/undertow/d2715e3afa13f50deaa19643676816ce391551e9/ServletInitialHandler.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -6,30 +6,12 @@\n             return;\n         }\n         final ServletPathMatch info = paths.getServletHandlerByPath(path);\n-        //https://issues.jboss.org/browse/WFLY-3439\n-        //if the request is an upgrade request then we don't want to redirect\n-        //as there is a good chance the web socket client won't understand the redirect\n-        //we make an exception for HTTP2 upgrade requests, as this would have already be handled at\n-        //the connector level if it was going to be handled.\n-        String upgradeString = exchange.getRequestHeaders().getFirst(Headers.UPGRADE);\n-        boolean isUpgradeRequest = upgradeString != null && !upgradeString.startsWith(HTTP2_UPGRADE_PREFIX);\n-        if (info.getType() == ServletPathMatch.Type.REDIRECT && !isUpgradeRequest) {\n-            //UNDERTOW-89\n-            //we redirect on GET requests to the root context to add an / to the end\n-            if(exchange.getRequestMethod().equals(Methods.GET) || exchange.getRequestMethod().equals(Methods.HEAD)) {\n-                exchange.setStatusCode(StatusCodes.FOUND);\n-            } else {\n-                exchange.setStatusCode(StatusCodes.TEMPORARY_REDIRECT);\n-            }\n-            exchange.getResponseHeaders().put(Headers.LOCATION, RedirectBuilder.redirect(exchange, exchange.getRelativePath() + \"/\", true));\n-            return;\n-        } else if (info.getType() == ServletPathMatch.Type.REWRITE) {\n-            //this can only happen if the path ends with a /\n-            //otherwise there would be a redirect instead\n+        if (info.getType() == ServletPathMatch.Type.REWRITE) {\n+            // this can only happen if the path ends with a /\n+            // otherwise there would be a redirect instead\n             exchange.setRelativePath(info.getRewriteLocation());\n             exchange.setRequestPath(exchange.getResolvedPath() + info.getRewriteLocation());\n         }\n-\n         final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);\n         final HttpServletRequestImpl request = new HttpServletRequestImpl(exchange, servletContext);\n         final ServletRequestContext servletRequestContext = new ServletRequestContext(servletContext.getDeployment(), request, response, info);",
    "diff_line_info": {
        "deleted_lines": [
            "        //https://issues.jboss.org/browse/WFLY-3439",
            "        //if the request is an upgrade request then we don't want to redirect",
            "        //as there is a good chance the web socket client won't understand the redirect",
            "        //we make an exception for HTTP2 upgrade requests, as this would have already be handled at",
            "        //the connector level if it was going to be handled.",
            "        String upgradeString = exchange.getRequestHeaders().getFirst(Headers.UPGRADE);",
            "        boolean isUpgradeRequest = upgradeString != null && !upgradeString.startsWith(HTTP2_UPGRADE_PREFIX);",
            "        if (info.getType() == ServletPathMatch.Type.REDIRECT && !isUpgradeRequest) {",
            "            //UNDERTOW-89",
            "            //we redirect on GET requests to the root context to add an / to the end",
            "            if(exchange.getRequestMethod().equals(Methods.GET) || exchange.getRequestMethod().equals(Methods.HEAD)) {",
            "                exchange.setStatusCode(StatusCodes.FOUND);",
            "            } else {",
            "                exchange.setStatusCode(StatusCodes.TEMPORARY_REDIRECT);",
            "            }",
            "            exchange.getResponseHeaders().put(Headers.LOCATION, RedirectBuilder.redirect(exchange, exchange.getRelativePath() + \"/\", true));",
            "            return;",
            "        } else if (info.getType() == ServletPathMatch.Type.REWRITE) {",
            "            //this can only happen if the path ends with a /",
            "            //otherwise there would be a redirect instead",
            ""
        ],
        "added_lines": [
            "        if (info.getType() == ServletPathMatch.Type.REWRITE) {",
            "            // this can only happen if the path ends with a /",
            "            // otherwise there would be a redirect instead"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/undertow-io/undertow/pull/794",
    "description": "Issue: https://issues.jboss.org/browse/UNDERTOW-1578\r\n\r\nCreated a `RedirectDirHandler` to handle the redirect after security check."
}