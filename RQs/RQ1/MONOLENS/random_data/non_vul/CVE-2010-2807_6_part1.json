{
    "cve_id": "CVE-2010-2807",
    "cwe_ids": [
        "CWE-681"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "freetype/freetype2",
    "commit_msg": "* src/truetype/ttinterp.c (BOUNDSL): New macro.\nChange `BOUNDS' to `BOUNDSL' where appropriate.\n\n* src/truetype/ttinterp.h (TT_ExecContextRec): Fix type of\n`cvtSize'.\n",
    "commit_hash": "346f1867fd32dae8f56e5b482d1af98f626804ac",
    "git_url": "http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=346f1867fd32dae8f56e5b482d1af98f626804ac",
    "file_path": "src/truetype/ttinterp.c",
    "func_name": "Ins_MIRP",
    "func_before": "static void\n  Ins_MIRP( INS_ARG )\n  {\n    FT_UShort   point;\n    FT_ULong    cvtEntry;\n\n    FT_F26Dot6  cvt_dist,\n                distance,\n                cur_dist,\n                org_dist;\n\n\n    point    = (FT_UShort)args[0];\n    cvtEntry = (FT_ULong)( args[1] + 1 );\n\n    /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */\n\n    if ( BOUNDS( point,      CUR.zp1.n_points ) ||\n         BOUNDS( cvtEntry,   CUR.cvtSize + 1 )  ||\n         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )\n    {\n      if ( CUR.pedantic_hinting )\n        CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    if ( !cvtEntry )\n      cvt_dist = 0;\n    else\n      cvt_dist = CUR_Func_read_cvt( cvtEntry - 1 );\n\n    /* single width test */\n\n    if ( FT_ABS( cvt_dist - CUR.GS.single_width_value ) <\n         CUR.GS.single_width_cutin )\n    {\n      if ( cvt_dist >= 0 )\n        cvt_dist =  CUR.GS.single_width_value;\n      else\n        cvt_dist = -CUR.GS.single_width_value;\n    }\n\n    /* XXX: UNDOCUMENTED! -- twilight zone */\n\n    if ( CUR.GS.gep1 == 0 )\n    {\n      CUR.zp1.org[point].x = CUR.zp0.org[CUR.GS.rp0].x +\n                             TT_MulFix14( (FT_UInt32)cvt_dist,\n                                          CUR.GS.freeVector.x );\n\n      CUR.zp1.org[point].y = CUR.zp0.org[CUR.GS.rp0].y +\n                             TT_MulFix14( (FT_UInt32)cvt_dist,\n                                          CUR.GS.freeVector.y );\n\n      CUR.zp1.cur[point] = CUR.zp0.cur[point];\n    }\n\n    org_dist = CUR_Func_dualproj( &CUR.zp1.org[point],\n                                  &CUR.zp0.org[CUR.GS.rp0] );\n    cur_dist = CUR_Func_project ( &CUR.zp1.cur[point],\n                                  &CUR.zp0.cur[CUR.GS.rp0] );\n\n    /* auto-flip test */\n\n    if ( CUR.GS.auto_flip )\n    {\n      if ( ( org_dist ^ cvt_dist ) < 0 )\n        cvt_dist = -cvt_dist;\n    }\n\n    /* control value cutin and round */\n\n    if ( ( CUR.opcode & 4 ) != 0 )\n    {\n      /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */\n      /*      refer to the same zone.                                  */\n\n      if ( CUR.GS.gep0 == CUR.GS.gep1 )\n        if ( FT_ABS( cvt_dist - org_dist ) >= CUR.GS.control_value_cutin )\n          cvt_dist = org_dist;\n\n      distance = CUR_Func_round(\n                   cvt_dist,\n                   CUR.tt_metrics.compensations[CUR.opcode & 3] );\n    }\n    else\n      distance = ROUND_None(\n                   cvt_dist,\n                   CUR.tt_metrics.compensations[CUR.opcode & 3] );\n\n    /* minimum distance test */\n\n    if ( ( CUR.opcode & 8 ) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n\n    CUR_Func_move( &CUR.zp1, point, distance - cur_dist );\n\n    CUR.GS.rp1 = CUR.GS.rp0;\n\n    if ( ( CUR.opcode & 16 ) != 0 )\n      CUR.GS.rp0 = point;\n\n    /* XXX: UNDOCUMENTED! */\n    CUR.GS.rp2 = point;\n  }",
    "abstract_func_before": "static void\n  Ins_MIRP( INS_ARG )\n  {\n    FT_UShort   VAR_0;\n    FT_ULong    VAR_1;\n\n    FT_F26Dot6  VAR_2,\n                VAR_3,\n                VAR_4,\n                VAR_5;\n\n\n    VAR_0    = (FT_UShort)VAR_6[0];\n    VAR_1 = (FT_ULong)( VAR_6[1] + 1 );\n\n    /* COMMENT_0 */\n\n    if ( BOUNDS( VAR_0,      VAR_7.zp1.n_points ) ||\n         BOUNDS( VAR_1,   VAR_7.cvtSize + 1 )  ||\n         BOUNDS( VAR_7.GS.rp0, VAR_7.zp0.n_points ) )\n    {\n      if ( VAR_7.pedantic_hinting )\n        VAR_7.error = VAR_8;\n      return;\n    }\n\n    if ( !VAR_1 )\n      VAR_2 = 0;\n    else\n      VAR_2 = CUR_Func_read_cvt( VAR_1 - 1 );\n\n    /* COMMENT_1 */\n\n    if ( FT_ABS( VAR_2 - VAR_7.GS.single_width_value ) <\n         VAR_7.GS.single_width_cutin )\n    {\n      if ( VAR_2 >= 0 )\n        VAR_2 =  VAR_7.GS.single_width_value;\n      else\n        VAR_2 = -VAR_7.GS.single_width_value;\n    }\n\n    /* COMMENT_2 */\n\n    if ( VAR_7.GS.gep1 == 0 )\n    {\n      VAR_7.zp1.org[VAR_0].x = VAR_7.zp0.org[VAR_7.GS.rp0].x +\n                             TT_MulFix14( (FT_UInt32)VAR_2,\n                                          VAR_7.GS.freeVector.x );\n\n      VAR_7.zp1.org[VAR_0].y = VAR_7.zp0.org[VAR_7.GS.rp0].y +\n                             TT_MulFix14( (FT_UInt32)VAR_2,\n                                          VAR_7.GS.freeVector.y );\n\n      VAR_7.zp1.cur[VAR_0] = VAR_7.zp0.cur[VAR_0];\n    }\n\n    VAR_5 = CUR_Func_dualproj( &VAR_7.zp1.org[VAR_0],\n                                  &VAR_7.zp0.org[VAR_7.GS.rp0] );\n    VAR_4 = CUR_Func_project ( &VAR_7.zp1.cur[VAR_0],\n                                  &VAR_7.zp0.cur[VAR_7.GS.rp0] );\n\n    /* COMMENT_3 */\n\n    if ( VAR_7.GS.auto_flip )\n    {\n      if ( ( VAR_5 ^ VAR_2 ) < 0 )\n        VAR_2 = -VAR_2;\n    }\n\n    /* COMMENT_4 */\n\n    if ( ( VAR_7.opcode & 4 ) != 0 )\n    {\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n\n      if ( VAR_7.GS.gep0 == VAR_7.GS.gep1 )\n        if ( FT_ABS( VAR_2 - VAR_5 ) >= VAR_7.GS.control_value_cutin )\n          VAR_2 = VAR_5;\n\n      VAR_3 = CUR_Func_round(\n                   VAR_2,\n                   VAR_7.tt_metrics.compensations[VAR_7.opcode & 3] );\n    }\n    else\n      VAR_3 = ROUND_None(\n                   VAR_2,\n                   VAR_7.tt_metrics.compensations[VAR_7.opcode & 3] );\n\n    /* COMMENT_7 */\n\n    if ( ( VAR_7.opcode & 8 ) != 0 )\n    {\n      if ( VAR_5 >= 0 )\n      {\n        if ( VAR_3 < VAR_7.GS.minimum_distance )\n          VAR_3 = VAR_7.GS.minimum_distance;\n      }\n      else\n      {\n        if ( VAR_3 > -VAR_7.GS.minimum_distance )\n          VAR_3 = -VAR_7.GS.minimum_distance;\n      }\n    }\n\n    CUR_Func_move( &VAR_7.zp1, VAR_0, VAR_3 - VAR_4 );\n\n    VAR_7.GS.rp1 = VAR_7.GS.rp0;\n\n    if ( ( VAR_7.opcode & 16 ) != 0 )\n      VAR_7.GS.rp0 = VAR_0;\n\n    /* COMMENT_8 */\n    VAR_7.GS.rp2 = VAR_0;\n  }",
    "func_graph_path_before": "freetype/freetype2/346f1867fd32dae8f56e5b482d1af98f626804ac/ttinterp.c/vul/before/7.json",
    "func": "static void\n  Ins_MIRP( INS_ARG )\n  {\n    FT_UShort   point;\n    FT_ULong    cvtEntry;\n\n    FT_F26Dot6  cvt_dist,\n                distance,\n                cur_dist,\n                org_dist;\n\n\n    point    = (FT_UShort)args[0];\n    cvtEntry = (FT_ULong)( args[1] + 1 );\n\n    /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */\n\n    if ( BOUNDS( point,      CUR.zp1.n_points ) ||\n         BOUNDSL( cvtEntry,  CUR.cvtSize + 1 )  ||\n         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )\n    {\n      if ( CUR.pedantic_hinting )\n        CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    if ( !cvtEntry )\n      cvt_dist = 0;\n    else\n      cvt_dist = CUR_Func_read_cvt( cvtEntry - 1 );\n\n    /* single width test */\n\n    if ( FT_ABS( cvt_dist - CUR.GS.single_width_value ) <\n         CUR.GS.single_width_cutin )\n    {\n      if ( cvt_dist >= 0 )\n        cvt_dist =  CUR.GS.single_width_value;\n      else\n        cvt_dist = -CUR.GS.single_width_value;\n    }\n\n    /* XXX: UNDOCUMENTED! -- twilight zone */\n\n    if ( CUR.GS.gep1 == 0 )\n    {\n      CUR.zp1.org[point].x = CUR.zp0.org[CUR.GS.rp0].x +\n                             TT_MulFix14( (FT_UInt32)cvt_dist,\n                                          CUR.GS.freeVector.x );\n\n      CUR.zp1.org[point].y = CUR.zp0.org[CUR.GS.rp0].y +\n                             TT_MulFix14( (FT_UInt32)cvt_dist,\n                                          CUR.GS.freeVector.y );\n\n      CUR.zp1.cur[point] = CUR.zp0.cur[point];\n    }\n\n    org_dist = CUR_Func_dualproj( &CUR.zp1.org[point],\n                                  &CUR.zp0.org[CUR.GS.rp0] );\n    cur_dist = CUR_Func_project ( &CUR.zp1.cur[point],\n                                  &CUR.zp0.cur[CUR.GS.rp0] );\n\n    /* auto-flip test */\n\n    if ( CUR.GS.auto_flip )\n    {\n      if ( ( org_dist ^ cvt_dist ) < 0 )\n        cvt_dist = -cvt_dist;\n    }\n\n    /* control value cutin and round */\n\n    if ( ( CUR.opcode & 4 ) != 0 )\n    {\n      /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */\n      /*      refer to the same zone.                                  */\n\n      if ( CUR.GS.gep0 == CUR.GS.gep1 )\n        if ( FT_ABS( cvt_dist - org_dist ) >= CUR.GS.control_value_cutin )\n          cvt_dist = org_dist;\n\n      distance = CUR_Func_round(\n                   cvt_dist,\n                   CUR.tt_metrics.compensations[CUR.opcode & 3] );\n    }\n    else\n      distance = ROUND_None(\n                   cvt_dist,\n                   CUR.tt_metrics.compensations[CUR.opcode & 3] );\n\n    /* minimum distance test */\n\n    if ( ( CUR.opcode & 8 ) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n\n    CUR_Func_move( &CUR.zp1, point, distance - cur_dist );\n\n    CUR.GS.rp1 = CUR.GS.rp0;\n\n    if ( ( CUR.opcode & 16 ) != 0 )\n      CUR.GS.rp0 = point;\n\n    /* XXX: UNDOCUMENTED! */\n    CUR.GS.rp2 = point;\n  }",
    "abstract_func": "static void\n  Ins_MIRP( INS_ARG )\n  {\n    FT_UShort   VAR_0;\n    FT_ULong    VAR_1;\n\n    FT_F26Dot6  VAR_2,\n                VAR_3,\n                VAR_4,\n                VAR_5;\n\n\n    VAR_0    = (FT_UShort)VAR_6[0];\n    VAR_1 = (FT_ULong)( VAR_6[1] + 1 );\n\n    /* COMMENT_0 */\n\n    if ( BOUNDS( VAR_0,      VAR_7.zp1.n_points ) ||\n         BOUNDSL( VAR_1,  VAR_7.cvtSize + 1 )  ||\n         BOUNDS( VAR_7.GS.rp0, VAR_7.zp0.n_points ) )\n    {\n      if ( VAR_7.pedantic_hinting )\n        VAR_7.error = VAR_8;\n      return;\n    }\n\n    if ( !VAR_1 )\n      VAR_2 = 0;\n    else\n      VAR_2 = CUR_Func_read_cvt( VAR_1 - 1 );\n\n    /* COMMENT_1 */\n\n    if ( FT_ABS( VAR_2 - VAR_7.GS.single_width_value ) <\n         VAR_7.GS.single_width_cutin )\n    {\n      if ( VAR_2 >= 0 )\n        VAR_2 =  VAR_7.GS.single_width_value;\n      else\n        VAR_2 = -VAR_7.GS.single_width_value;\n    }\n\n    /* COMMENT_2 */\n\n    if ( VAR_7.GS.gep1 == 0 )\n    {\n      VAR_7.zp1.org[VAR_0].x = VAR_7.zp0.org[VAR_7.GS.rp0].x +\n                             TT_MulFix14( (FT_UInt32)VAR_2,\n                                          VAR_7.GS.freeVector.x );\n\n      VAR_7.zp1.org[VAR_0].y = VAR_7.zp0.org[VAR_7.GS.rp0].y +\n                             TT_MulFix14( (FT_UInt32)VAR_2,\n                                          VAR_7.GS.freeVector.y );\n\n      VAR_7.zp1.cur[VAR_0] = VAR_7.zp0.cur[VAR_0];\n    }\n\n    VAR_5 = CUR_Func_dualproj( &VAR_7.zp1.org[VAR_0],\n                                  &VAR_7.zp0.org[VAR_7.GS.rp0] );\n    VAR_4 = CUR_Func_project ( &VAR_7.zp1.cur[VAR_0],\n                                  &VAR_7.zp0.cur[VAR_7.GS.rp0] );\n\n    /* COMMENT_3 */\n\n    if ( VAR_7.GS.auto_flip )\n    {\n      if ( ( VAR_5 ^ VAR_2 ) < 0 )\n        VAR_2 = -VAR_2;\n    }\n\n    /* COMMENT_4 */\n\n    if ( ( VAR_7.opcode & 4 ) != 0 )\n    {\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n\n      if ( VAR_7.GS.gep0 == VAR_7.GS.gep1 )\n        if ( FT_ABS( VAR_2 - VAR_5 ) >= VAR_7.GS.control_value_cutin )\n          VAR_2 = VAR_5;\n\n      VAR_3 = CUR_Func_round(\n                   VAR_2,\n                   VAR_7.tt_metrics.compensations[VAR_7.opcode & 3] );\n    }\n    else\n      VAR_3 = ROUND_None(\n                   VAR_2,\n                   VAR_7.tt_metrics.compensations[VAR_7.opcode & 3] );\n\n    /* COMMENT_7 */\n\n    if ( ( VAR_7.opcode & 8 ) != 0 )\n    {\n      if ( VAR_5 >= 0 )\n      {\n        if ( VAR_3 < VAR_7.GS.minimum_distance )\n          VAR_3 = VAR_7.GS.minimum_distance;\n      }\n      else\n      {\n        if ( VAR_3 > -VAR_7.GS.minimum_distance )\n          VAR_3 = -VAR_7.GS.minimum_distance;\n      }\n    }\n\n    CUR_Func_move( &VAR_7.zp1, VAR_0, VAR_3 - VAR_4 );\n\n    VAR_7.GS.rp1 = VAR_7.GS.rp0;\n\n    if ( ( VAR_7.opcode & 16 ) != 0 )\n      VAR_7.GS.rp0 = VAR_0;\n\n    /* COMMENT_8 */\n    VAR_7.GS.rp2 = VAR_0;\n  }",
    "func_graph_path": "freetype/freetype2/346f1867fd32dae8f56e5b482d1af98f626804ac/ttinterp.c/vul/after/7.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n     /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */\n \n     if ( BOUNDS( point,      CUR.zp1.n_points ) ||\n-         BOUNDS( cvtEntry,   CUR.cvtSize + 1 )  ||\n+         BOUNDSL( cvtEntry,  CUR.cvtSize + 1 )  ||\n          BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )\n     {\n       if ( CUR.pedantic_hinting )",
    "diff_line_info": {
        "deleted_lines": [
            "         BOUNDS( cvtEntry,   CUR.cvtSize + 1 )  ||"
        ],
        "added_lines": [
            "         BOUNDSL( cvtEntry,  CUR.cvtSize + 1 )  ||"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}