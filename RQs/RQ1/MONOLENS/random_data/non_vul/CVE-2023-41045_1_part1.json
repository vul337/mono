{
    "cve_id": "CVE-2023-41045",
    "cwe_ids": [
        "CWE-345"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cvss_is_v3": true,
    "repo_name": "Graylog2/graylog2-server",
    "commit_msg": "Merge pull request from GHSA-g96c-x7rh-99r3\n\n* Add support for randomizing DNS Lookup source port\n\n* Clarify purpose of lease\n\n* Skip initial refresh\n\nPreviously, the pool was being refreshed immediately upon initialization. Now, the refresh waits until the `poolRefreshSeconds` duration has elapsed.\n\n* Ensure thread safety, skip unused poller refreshes\n\n* Add change log",
    "commit_hash": "466af814523cffae9fbc7e77bab7472988f03c3e",
    "git_url": "https://github.com/Graylog2/graylog2-server/commit/466af814523cffae9fbc7e77bab7472988f03c3e",
    "file_path": "graylog2-server/src/main/java/org/graylog2/lookup/adapters/dnslookup/DnsClient.java",
    "func_name": "txtLookup",
    "func_before": "public List<TxtDnsAnswer> txtLookup(String hostName) throws InterruptedException, ExecutionException {\n\n        if (isShutdown()) {\n            throw new DnsClientNotRunningException();\n        }\n\n        LOG.debug(\"Attempting to perform TXT lookup for hostname [{}]\", hostName);\n\n        validateHostName(hostName);\n\n        DnsResponse content = null;\n        try {\n            content = resolver.query(new DefaultDnsQuestion(hostName, DnsRecordType.TXT)).get(requestTimeout, TimeUnit.MILLISECONDS).content();\n            int count = content.count(DnsSection.ANSWER);\n            final ArrayList<TxtDnsAnswer> txtRecords = new ArrayList<>(count);\n            for (int i = 0; i < count; i++) {\n\n                final DnsRecord dnsRecord = content.recordAt(DnsSection.ANSWER, i);\n                LOG.trace(\"TXT record [{}] retrieved with content [{}].\", i, dnsRecord);\n\n                if (dnsRecord instanceof DefaultDnsRawRecord) {\n                    final DefaultDnsRawRecord txtRecord = (DefaultDnsRawRecord) dnsRecord;\n\n                    final TxtDnsAnswer.Builder dnsAnswerBuilder = TxtDnsAnswer.builder();\n                    final String decodeTxtRecord = decodeTxtRecord(txtRecord);\n                    LOG.trace(\"The decoded TXT record is [{}]\", decodeTxtRecord);\n\n                    dnsAnswerBuilder.value(decodeTxtRecord)\n                                    .dnsTTL(txtRecord.timeToLive())\n                                    .build();\n\n                    txtRecords.add(dnsAnswerBuilder.build());\n                }\n            }\n\n            return txtRecords;\n        } catch (TimeoutException e) {\n            throw new ExecutionException(\"Resolver future didn't return a result in \" + requestTimeout + \" ms\", e);\n        } finally {\n            if (content != null) {\n                // Must manually release references on content object since the DnsResponse class extends ReferenceCounted\n                content.release();\n            }\n        }\n    }",
    "abstract_func_before": "public List<TxtDnsAnswer> txtLookup(String VAR_0) throws InterruptedException, ExecutionException {\n\n        if (isShutdown()) {\n            throw new DnsClientNotRunningException();\n        }\n\n        VAR_1.debug(\"Attempting to perform TXT lookup for hostname [{}]\", VAR_0);\n\n        validateHostName(VAR_0);\n\n        DnsResponse VAR_2 = null;\n        try {\n            VAR_2 = VAR_3.query(new DefaultDnsQuestion(VAR_0, VAR_4.TXT)).get(VAR_5, VAR_6.MILLISECONDS).content();\n            int VAR_7 = VAR_2.count(VAR_8.ANSWER);\n            final ArrayList<TxtDnsAnswer> VAR_9 = new ArrayList<>(VAR_7);\n            for (int VAR_10 = 0; VAR_10 < VAR_7; VAR_10++) {\n\n                final DnsRecord VAR_11 = VAR_2.recordAt(VAR_8.ANSWER, VAR_10);\n                VAR_1.trace(\"TXT record [{}] retrieved with content [{}].\", VAR_10, VAR_11);\n\n                if (VAR_11 instanceof DefaultDnsRawRecord) {\n                    final DefaultDnsRawRecord VAR_12 = (DefaultDnsRawRecord) VAR_11;\n\n                    final TxtDnsAnswer.Builder VAR_13 = VAR_14.builder();\n                    final String VAR_15 = decodeTxtRecord(VAR_12);\n                    VAR_1.trace(\"The decoded TXT record is [{}]\", VAR_15);\n\n                    VAR_13.value(VAR_15)\n                                    .dnsTTL(VAR_12.timeToLive())\n                                    .build();\n\n                    VAR_9.add(VAR_13.build());\n                }\n            }\n\n            return VAR_9;\n        } catch (TimeoutException VAR_16) {\n            throw new ExecutionException(\"Resolver future didn't return a result in \" + VAR_5 + \" ms\", VAR_16);\n        } finally {\n            if (VAR_2 != null) {\n                /* COMMENT_0 */\n                VAR_2.release();\n            }\n        }\n    }",
    "func_graph_path_before": "Graylog2/graylog2-server/466af814523cffae9fbc7e77bab7472988f03c3e/DnsClient.java/vul/before/1.json",
    "func": "public List<TxtDnsAnswer> txtLookup(String hostName) throws InterruptedException, ExecutionException {\n\n        if (resolverPool.isStopped()) {\n            throw new DnsClientNotRunningException();\n        }\n\n        LOG.debug(\"Attempting to perform TXT lookup for hostname [{}]\", hostName);\n\n        validateHostName(hostName);\n\n        DnsResponse content = null;\n        final ResolverLease resolverLease = resolverPool.takeLease();\n        try {\n            content = resolverLease.getResolver().query(new DefaultDnsQuestion(hostName, DnsRecordType.TXT)).get(requestTimeout, TimeUnit.MILLISECONDS).content();\n            int count = content.count(DnsSection.ANSWER);\n            final ArrayList<TxtDnsAnswer> txtRecords = new ArrayList<>(count);\n            for (int i = 0; i < count; i++) {\n\n                final DnsRecord dnsRecord = content.recordAt(DnsSection.ANSWER, i);\n                LOG.trace(\"TXT record [{}] retrieved with content [{}].\", i, dnsRecord);\n\n                if (dnsRecord instanceof DefaultDnsRawRecord) {\n                    final DefaultDnsRawRecord txtRecord = (DefaultDnsRawRecord) dnsRecord;\n\n                    final TxtDnsAnswer.Builder dnsAnswerBuilder = TxtDnsAnswer.builder();\n                    final String decodeTxtRecord = decodeTxtRecord(txtRecord);\n                    LOG.trace(\"The decoded TXT record is [{}]\", decodeTxtRecord);\n\n                    dnsAnswerBuilder.value(decodeTxtRecord)\n                                    .dnsTTL(txtRecord.timeToLive())\n                                    .build();\n\n                    txtRecords.add(dnsAnswerBuilder.build());\n                }\n            }\n\n            return txtRecords;\n        } catch (TimeoutException e) {\n            throw new ExecutionException(\"Resolver future didn't return a result in \" + requestTimeout + \" ms\", e);\n        } finally {\n            if (content != null) {\n                // Must manually release references on content object since the DnsResponse class extends ReferenceCounted\n                content.release();\n            }\n            resolverPool.returnLease(resolverLease);\n        }\n    }",
    "abstract_func": "public List<TxtDnsAnswer> txtLookup(String VAR_0) throws InterruptedException, ExecutionException {\n\n        if (VAR_1.isStopped()) {\n            throw new DnsClientNotRunningException();\n        }\n\n        VAR_2.debug(\"Attempting to perform TXT lookup for hostname [{}]\", VAR_0);\n\n        validateHostName(VAR_0);\n\n        DnsResponse VAR_3 = null;\n        final ResolverLease VAR_4 = VAR_1.takeLease();\n        try {\n            VAR_3 = VAR_4.getResolver().query(new DefaultDnsQuestion(VAR_0, VAR_5.TXT)).get(VAR_6, VAR_7.MILLISECONDS).content();\n            int VAR_8 = VAR_3.count(VAR_9.ANSWER);\n            final ArrayList<TxtDnsAnswer> VAR_10 = new ArrayList<>(VAR_8);\n            for (int VAR_11 = 0; VAR_11 < VAR_8; VAR_11++) {\n\n                final DnsRecord VAR_12 = VAR_3.recordAt(VAR_9.ANSWER, VAR_11);\n                VAR_2.trace(\"TXT record [{}] retrieved with content [{}].\", VAR_11, VAR_12);\n\n                if (VAR_12 instanceof DefaultDnsRawRecord) {\n                    final DefaultDnsRawRecord VAR_13 = (DefaultDnsRawRecord) VAR_12;\n\n                    final TxtDnsAnswer.Builder VAR_14 = VAR_15.builder();\n                    final String VAR_16 = decodeTxtRecord(VAR_13);\n                    VAR_2.trace(\"The decoded TXT record is [{}]\", VAR_16);\n\n                    VAR_14.value(VAR_16)\n                                    .dnsTTL(VAR_13.timeToLive())\n                                    .build();\n\n                    VAR_10.add(VAR_14.build());\n                }\n            }\n\n            return VAR_10;\n        } catch (TimeoutException VAR_17) {\n            throw new ExecutionException(\"Resolver future didn't return a result in \" + VAR_6 + \" ms\", VAR_17);\n        } finally {\n            if (VAR_3 != null) {\n                /* COMMENT_0 */\n                VAR_3.release();\n            }\n            VAR_1.returnLease(VAR_4);\n        }\n    }",
    "func_graph_path": "Graylog2/graylog2-server/466af814523cffae9fbc7e77bab7472988f03c3e/DnsClient.java/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n public List<TxtDnsAnswer> txtLookup(String hostName) throws InterruptedException, ExecutionException {\n \n-        if (isShutdown()) {\n+        if (resolverPool.isStopped()) {\n             throw new DnsClientNotRunningException();\n         }\n \n@@ -9,8 +9,9 @@\n         validateHostName(hostName);\n \n         DnsResponse content = null;\n+        final ResolverLease resolverLease = resolverPool.takeLease();\n         try {\n-            content = resolver.query(new DefaultDnsQuestion(hostName, DnsRecordType.TXT)).get(requestTimeout, TimeUnit.MILLISECONDS).content();\n+            content = resolverLease.getResolver().query(new DefaultDnsQuestion(hostName, DnsRecordType.TXT)).get(requestTimeout, TimeUnit.MILLISECONDS).content();\n             int count = content.count(DnsSection.ANSWER);\n             final ArrayList<TxtDnsAnswer> txtRecords = new ArrayList<>(count);\n             for (int i = 0; i < count; i++) {\n@@ -41,5 +42,6 @@\n                 // Must manually release references on content object since the DnsResponse class extends ReferenceCounted\n                 content.release();\n             }\n+            resolverPool.returnLease(resolverLease);\n         }\n     }",
    "diff_line_info": {
        "deleted_lines": [
            "        if (isShutdown()) {",
            "            content = resolver.query(new DefaultDnsQuestion(hostName, DnsRecordType.TXT)).get(requestTimeout, TimeUnit.MILLISECONDS).content();"
        ],
        "added_lines": [
            "        if (resolverPool.isStopped()) {",
            "        final ResolverLease resolverLease = resolverPool.takeLease();",
            "            content = resolverLease.getResolver().query(new DefaultDnsQuestion(hostName, DnsRecordType.TXT)).get(requestTimeout, TimeUnit.MILLISECONDS).content();",
            "            resolverPool.returnLease(resolverLease);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}