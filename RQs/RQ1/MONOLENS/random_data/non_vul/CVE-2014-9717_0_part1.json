{
    "cve_id": "CVE-2014-9717",
    "cwe_ids": [
        "CWE-284"
    ],
    "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:N",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "mnt: Honor MNT_LOCKED when detaching mounts\n\nModify umount(MNT_DETACH) to keep mounts in the hash table that are\nlocked to their parent mounts, when the parent is lazily unmounted.\n\nIn mntput_no_expire detach the children from the hash table, depending\non mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.\n\nIn __detach_mounts if there are any mounts that have been unmounted\nbut still are on the list of mounts of a mountpoint, remove their\nchildren from the mount hash table and those children to the unmounted\nlist so they won't linger potentially indefinitely waiting for their\nfinal mntput, now that the mounts serve no purpose.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "commit_hash": "ce07d891a0891d3c0d0c2d73d577490486b809e1",
    "git_url": "https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1",
    "file_path": "fs/namespace.c",
    "func_name": "umount_tree",
    "func_before": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
    "abstract_func_before": "static void umount_tree(struct mount *VAR_0, enum umount_tree_flags VAR_1)\n{\n\tLIST_HEAD(VAR_2);\n\tstruct mount *VAR_3;\n\n\tif (VAR_1 & VAR_4)\n\t\tpropagate_mount_unlock(VAR_0);\n\n\t/* COMMENT_0 */\n\tfor (VAR_3 = VAR_0; VAR_3; VAR_3 = next_mnt(VAR_3, VAR_0)) {\n\t\tVAR_3->mnt.mnt_flags |= VAR_5;\n\t\tlist_move(&VAR_3->mnt_list, &VAR_2);\n\t}\n\n\t/* COMMENT_1 */\n\tlist_for_each_entry(VAR_3, &VAR_2, VAR_6) {\n\t\tlist_del_init(&VAR_3->mnt_child);\n\t}\n\n\t/* COMMENT_2 */\n\tif (VAR_1 & VAR_4)\n\t\tpropagate_umount(&VAR_2);\n\n\twhile (!list_empty(&VAR_2)) {\n\t\tVAR_3 = list_first_entry(&VAR_2, struct mount, VAR_6);\n\t\tlist_del_init(&VAR_3->mnt_expire);\n\t\tlist_del_init(&VAR_3->mnt_list);\n\t\t__touch_mnt_namespace(VAR_3->mnt_ns);\n\t\tVAR_3->mnt_ns = NULL;\n\t\tif (VAR_1 & VAR_7)\n\t\t\tVAR_3->mnt.mnt_flags |= VAR_8;\n\n\t\tpin_insert_group(&VAR_3->mnt_umount, &VAR_3->mnt_parent->mnt, &VAR_9);\n\t\tif (mnt_has_parent(VAR_3)) {\n\t\t\tmnt_add_count(VAR_3->mnt_parent, -1);\n\t\t\tumount_mnt(VAR_3);\n\t\t}\n\t\tchange_mnt_propagation(VAR_3, VAR_10);\n\t}\n}",
    "func_graph_path_before": "torvalds/linux/ce07d891a0891d3c0d0c2d73d577490486b809e1/namespace.c/vul/before/1.json",
    "func": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
    "abstract_func": "static void umount_tree(struct mount *VAR_0, enum umount_tree_flags VAR_1)\n{\n\tLIST_HEAD(VAR_2);\n\tstruct mount *VAR_3;\n\n\tif (VAR_1 & VAR_4)\n\t\tpropagate_mount_unlock(VAR_0);\n\n\t/* COMMENT_0 */\n\tfor (VAR_3 = VAR_0; VAR_3; VAR_3 = next_mnt(VAR_3, VAR_0)) {\n\t\tVAR_3->mnt.mnt_flags |= VAR_5;\n\t\tlist_move(&VAR_3->mnt_list, &VAR_2);\n\t}\n\n\t/* COMMENT_1 */\n\tlist_for_each_entry(VAR_3, &VAR_2, VAR_6) {\n\t\tlist_del_init(&VAR_3->mnt_child);\n\t}\n\n\t/* COMMENT_2 */\n\tif (VAR_1 & VAR_4)\n\t\tpropagate_umount(&VAR_2);\n\n\twhile (!list_empty(&VAR_2)) {\n\t\tbool VAR_7;\n\t\tVAR_3 = list_first_entry(&VAR_2, struct mount, VAR_6);\n\t\tlist_del_init(&VAR_3->mnt_expire);\n\t\tlist_del_init(&VAR_3->mnt_list);\n\t\t__touch_mnt_namespace(VAR_3->mnt_ns);\n\t\tVAR_3->mnt_ns = NULL;\n\t\tif (VAR_1 & VAR_8)\n\t\t\tVAR_3->mnt.mnt_flags |= VAR_9;\n\n\t\tVAR_7 = !IS_MNT_LOCKED_AND_LAZY(VAR_3);\n\n\t\tpin_insert_group(&VAR_3->mnt_umount, &VAR_3->mnt_parent->mnt,\n\t\t\t\t VAR_7 ? &VAR_10 : NULL);\n\t\tif (mnt_has_parent(VAR_3)) {\n\t\t\tmnt_add_count(VAR_3->mnt_parent, -1);\n\t\t\tif (!VAR_7) {\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tlist_add_tail(&VAR_3->mnt_child, &VAR_3->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(VAR_3);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(VAR_3, VAR_11);\n\t}\n}",
    "func_graph_path": "torvalds/linux/ce07d891a0891d3c0d0c2d73d577490486b809e1/namespace.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,7 @@\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n@@ -30,10 +31,18 @@\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n \n-\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n+\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n+\n+\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n+\t\t\t\t disconnect ? &unmounted : NULL);\n \t\tif (mnt_has_parent(p)) {\n \t\t\tmnt_add_count(p->mnt_parent, -1);\n-\t\t\tumount_mnt(p);\n+\t\t\tif (!disconnect) {\n+\t\t\t\t/* Don't forget about p */\n+\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n+\t\t\t} else {\n+\t\t\t\tumount_mnt(p);\n+\t\t\t}\n \t\t}\n \t\tchange_mnt_propagation(p, MS_PRIVATE);\n \t}",
    "diff_line_info": {
        "deleted_lines": [
            "\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);",
            "\t\t\tumount_mnt(p);"
        ],
        "added_lines": [
            "\t\tbool disconnect;",
            "\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);",
            "",
            "\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
            "\t\t\t\t disconnect ? &unmounted : NULL);",
            "\t\t\tif (!disconnect) {",
            "\t\t\t\t/* Don't forget about p */",
            "\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);",
            "\t\t\t} else {",
            "\t\t\t\tumount_mnt(p);",
            "\t\t\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}