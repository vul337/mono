{
    "cve_id": "CVE-2014-3488",
    "cwe_ids": [
        "CWE-119"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "netty",
    "commit_msg": "Fix a bug where SslHandler does not handle SSLv2Hello correctly\n\nMotivation:\n\nWhen a SSLv2Hello message is received, SSLEngine expects the application buffer size to be more than 30KB which is larger than what SslBufferPool can provide.  SSLEngine will always return with BUFFER_OVERFLOW status, blocking the SSL session from continuing the handshake.\n\nModifications:\n\nWhen SSLEngine.getSession().getApplicationBufferSize() returns a value larger than what SslBufferPool provides, allocate a temporary heap buffer.\n\nResult:\n\nSSLv2Hello is handled correctly.",
    "commit_hash": "2fa9400a59d0563a66908aba55c41e7285a04994",
    "git_url": "https://github.com/netty/netty/commit/2fa9400a59d0563a66908aba55c41e7285a04994",
    "file_path": "src/main/java/org/jboss/netty/handler/ssl/SslHandler.java",
    "func_name": "unwrap",
    "func_before": "private ChannelBuffer unwrap(\n            ChannelHandlerContext ctx, Channel channel,\n            ChannelBuffer nettyInNetBuf, ByteBuffer nioInNetBuf,\n            int initialNettyOutAppBufCapacity) throws SSLException {\n\n        final int nettyInNetBufStartOffset = nettyInNetBuf.readerIndex();\n        final int nioInNetBufStartOffset = nioInNetBuf.position();\n        final ByteBuffer nioOutAppBuf = bufferPool.acquireBuffer();\n\n        ChannelBuffer nettyOutAppBuf = null;\n\n        try {\n            boolean needsWrap = false;\n            for (;;) {\n                SSLEngineResult result;\n                boolean needsHandshake = false;\n                synchronized (handshakeLock) {\n                    if (!handshaken && !handshaking &&\n                        !engine.getUseClientMode() &&\n                        !engine.isInboundDone() && !engine.isOutboundDone()) {\n                        needsHandshake = true;\n                    }\n                }\n\n                if (needsHandshake) {\n                    handshake();\n                }\n\n                synchronized (handshakeLock) {\n                    // Decrypt at least one record in the inbound network buffer.\n                    // It is impossible to consume no record here because we made sure the inbound network buffer\n                    // always contain at least one record in decode().  Therefore, if SSLEngine.unwrap() returns\n                    // BUFFER_OVERFLOW, it is always resolved by retrying after emptying the application buffer.\n                    for (;;) {\n                        try {\n                            result = engine.unwrap(nioInNetBuf, nioOutAppBuf);\n                            switch (result.getStatus()) {\n                                case CLOSED:\n                                    // notify about the CLOSED state of the SSLEngine. See #137\n                                    sslEngineCloseFuture.setClosed();\n                                    break;\n                                case BUFFER_OVERFLOW:\n                                    // Flush the unwrapped data in the outAppBuf into frame and try again.\n                                    // See the finally block.\n                                    continue;\n                            }\n\n                            break;\n                        } finally {\n                            nioOutAppBuf.flip();\n\n                            // Sync the offset of the inbound buffer.\n                            nettyInNetBuf.readerIndex(\n                                    nettyInNetBufStartOffset + nioInNetBuf.position() - nioInNetBufStartOffset);\n\n                            // Copy the unwrapped data into a smaller buffer.\n                            if (nioOutAppBuf.hasRemaining()) {\n                                if (nettyOutAppBuf == null) {\n                                    ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();\n                                    nettyOutAppBuf = factory.getBuffer(initialNettyOutAppBufCapacity);\n                                }\n                                nettyOutAppBuf.writeBytes(nioOutAppBuf);\n                            }\n                            nioOutAppBuf.clear();\n                        }\n                    }\n\n                    final HandshakeStatus handshakeStatus = result.getHandshakeStatus();\n                    handleRenegotiation(handshakeStatus);\n                    switch (handshakeStatus) {\n                    case NEED_UNWRAP:\n                        break;\n                    case NEED_WRAP:\n                        wrapNonAppData(ctx, channel);\n                        break;\n                    case NEED_TASK:\n                        runDelegatedTasks();\n                        break;\n                    case FINISHED:\n                        setHandshakeSuccess(channel);\n                        needsWrap = true;\n                        continue;\n                    case NOT_HANDSHAKING:\n                        if (setHandshakeSuccessIfStillHandshaking(channel)) {\n                            needsWrap = true;\n                            continue;\n                        }\n                        if (writeBeforeHandshakeDone) {\n                            // We need to call wrap(...) in case there was a flush done before the handshake completed.\n                            //\n                            // See https://github.com/netty/netty/pull/2437\n                            writeBeforeHandshakeDone = false;\n                            needsWrap = true;\n                        }\n                        break;\n                    default:\n                        throw new IllegalStateException(\n                                \"Unknown handshake status: \" + handshakeStatus);\n                    }\n\n                    if (result.getStatus() == Status.BUFFER_UNDERFLOW ||\n                        result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (needsWrap) {\n                // wrap() acquires pendingUnencryptedWrites first and then\n                // handshakeLock.  If handshakeLock is already hold by the\n                // current thread, calling wrap() will lead to a dead lock\n                // i.e. pendingUnencryptedWrites -> handshakeLock vs.\n                //      handshakeLock -> pendingUnencryptedLock -> handshakeLock\n                //\n                // There is also the same issue between pendingEncryptedWrites\n                // and pendingUnencryptedWrites.\n                if (!Thread.holdsLock(handshakeLock) && !pendingEncryptedWritesLock.isHeldByCurrentThread()) {\n                    wrap(ctx, channel);\n                }\n            }\n        } catch (SSLException e) {\n            setHandshakeFailure(channel, e);\n            throw e;\n        } finally {\n            bufferPool.releaseBuffer(nioOutAppBuf);\n        }\n\n        if (nettyOutAppBuf != null && nettyOutAppBuf.readable()) {\n            return nettyOutAppBuf;\n        } else {\n            return null;\n        }\n    }",
    "abstract_func_before": "private ChannelBuffer unwrap(\n            ChannelHandlerContext VAR_0, Channel VAR_1,\n            ChannelBuffer VAR_2, ByteBuffer VAR_3,\n            int VAR_4) throws SSLException {\n\n        final int VAR_5 = VAR_2.readerIndex();\n        final int VAR_6 = VAR_3.position();\n        final ByteBuffer VAR_7 = VAR_8.acquireBuffer();\n\n        ChannelBuffer VAR_9 = null;\n\n        try {\n            boolean VAR_10 = false;\n            for (;;) {\n                SSLEngineResult VAR_11;\n                boolean VAR_12 = false;\n                synchronized (VAR_13) {\n                    if (!VAR_14 && !VAR_15 &&\n                        !VAR_16.getUseClientMode() &&\n                        !VAR_16.isInboundDone() && !VAR_16.isOutboundDone()) {\n                        VAR_12 = true;\n                    }\n                }\n\n                if (VAR_12) {\n                    handshake();\n                }\n\n                synchronized (VAR_13) {\n                    /* COMMENT_0 */\n                    /* COMMENT_1 */\n                    /* COMMENT_2 */\n                    /* COMMENT_3 */\n                    for (;;) {\n                        try {\n                            VAR_11 = VAR_16.unwrap(VAR_3, VAR_7);\n                            switch (VAR_11.getStatus()) {\n                                case VAR_17:\n                                    /* COMMENT_4 */\n                                    VAR_18.setClosed();\n                                    break;\n                                case VAR_19:\n                                    /* COMMENT_5 */\n                                    /* COMMENT_6 */\n                                    continue;\n                            }\n\n                            break;\n                        } finally {\n                            VAR_7.flip();\n\n                            /* COMMENT_7 */\n                            VAR_2.readerIndex(\n                                    VAR_5 + VAR_3.position() - VAR_6);\n\n                            /* COMMENT_8 */\n                            if (VAR_7.hasRemaining()) {\n                                if (VAR_9 == null) {\n                                    ChannelBufferFactory VAR_20 = VAR_0.getChannel().getConfig().getBufferFactory();\n                                    VAR_9 = VAR_20.getBuffer(VAR_4);\n                                }\n                                VAR_9.writeBytes(VAR_7);\n                            }\n                            VAR_7.clear();\n                        }\n                    }\n\n                    final HandshakeStatus VAR_21 = VAR_11.getHandshakeStatus();\n                    handleRenegotiation(VAR_21);\n                    switch (VAR_21) {\n                    case VAR_22:\n                        break;\n                    case VAR_23:\n                        wrapNonAppData(VAR_0, VAR_1);\n                        break;\n                    case VAR_24:\n                        runDelegatedTasks();\n                        break;\n                    case VAR_25:\n                        setHandshakeSuccess(VAR_1);\n                        VAR_10 = true;\n                        continue;\n                    case VAR_26:\n                        if (setHandshakeSuccessIfStillHandshaking(VAR_1)) {\n                            VAR_10 = true;\n                            continue;\n                        }\n                        if (VAR_27) {\n                            /* COMMENT_9 */\n                            /* COMMENT_10 */\n                            /* COMMENT_11 */\n                            VAR_27 = false;\n                            VAR_10 = true;\n                        }\n                        break;\n                    default:\n                        throw new IllegalStateException(\n                                \"Unknown handshake status: \" + VAR_21);\n                    }\n\n                    if (VAR_11.getStatus() == VAR_28.BUFFER_UNDERFLOW ||\n                        VAR_11.bytesConsumed() == 0 && VAR_11.bytesProduced() == 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (VAR_10) {\n                /* COMMENT_12 */\n                /* COMMENT_13 */\n                /* COMMENT_14 */\n                /* COMMENT_15 */\n                /* COMMENT_16 */\n                /* COMMENT_10 */\n                /* COMMENT_17 */\n                /* COMMENT_18 */\n                if (!VAR_29.holdsLock(VAR_13) && !VAR_30.isHeldByCurrentThread()) {\n                    wrap(VAR_0, VAR_1);\n                }\n            }\n        } catch (SSLException VAR_31) {\n            setHandshakeFailure(VAR_1, VAR_31);\n            throw VAR_31;\n        } finally {\n            VAR_8.releaseBuffer(VAR_7);\n        }\n\n        if (VAR_9 != null && VAR_9.readable()) {\n            return VAR_9;\n        } else {\n            return null;\n        }\n    }",
    "func_graph_path_before": "netty/2fa9400a59d0563a66908aba55c41e7285a04994/SslHandler.java/vul/before/0.json",
    "func": "private ChannelBuffer unwrap(\n            ChannelHandlerContext ctx, Channel channel,\n            ChannelBuffer nettyInNetBuf, ByteBuffer nioInNetBuf,\n            int initialNettyOutAppBufCapacity) throws SSLException {\n\n        final int nettyInNetBufStartOffset = nettyInNetBuf.readerIndex();\n        final int nioInNetBufStartOffset = nioInNetBuf.position();\n        final ByteBuffer nioOutAppBuf = bufferPool.acquireBuffer();\n\n        ChannelBuffer nettyOutAppBuf = null;\n\n        try {\n            boolean needsWrap = false;\n            for (;;) {\n                SSLEngineResult result;\n                boolean needsHandshake = false;\n                synchronized (handshakeLock) {\n                    if (!handshaken && !handshaking &&\n                        !engine.getUseClientMode() &&\n                        !engine.isInboundDone() && !engine.isOutboundDone()) {\n                        needsHandshake = true;\n                    }\n                }\n\n                if (needsHandshake) {\n                    handshake();\n                }\n\n                synchronized (handshakeLock) {\n                    // Decrypt at least one record in the inbound network buffer.\n                    // It is impossible to consume no record here because we made sure the inbound network buffer\n                    // always contain at least one record in decode().  Therefore, if SSLEngine.unwrap() returns\n                    // BUFFER_OVERFLOW, it is always resolved by retrying after emptying the application buffer.\n                    for (;;) {\n                        final int outAppBufSize = engine.getSession().getApplicationBufferSize();\n                        final ByteBuffer outAppBuf;\n                        if (nioOutAppBuf.capacity() < outAppBufSize) {\n                            // SSLEngine wants a buffer larger than what the pool can provide.\n                            // Allocate a temporary heap buffer.\n                            outAppBuf = ByteBuffer.allocate(outAppBufSize);\n                        } else {\n                            outAppBuf = nioOutAppBuf;\n                        }\n\n                        try {\n                            result = engine.unwrap(nioInNetBuf, outAppBuf);\n                            switch (result.getStatus()) {\n                                case CLOSED:\n                                    // notify about the CLOSED state of the SSLEngine. See #137\n                                    sslEngineCloseFuture.setClosed();\n                                    break;\n                                case BUFFER_OVERFLOW:\n                                    // Flush the unwrapped data in the outAppBuf into frame and try again.\n                                    // See the finally block.\n                                    continue;\n                            }\n\n                            break;\n                        } finally {\n                            outAppBuf.flip();\n\n                            // Sync the offset of the inbound buffer.\n                            nettyInNetBuf.readerIndex(\n                                    nettyInNetBufStartOffset + nioInNetBuf.position() - nioInNetBufStartOffset);\n\n                            // Copy the unwrapped data into a smaller buffer.\n                            if (outAppBuf.hasRemaining()) {\n                                if (nettyOutAppBuf == null) {\n                                    ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();\n                                    nettyOutAppBuf = factory.getBuffer(initialNettyOutAppBufCapacity);\n                                }\n                                nettyOutAppBuf.writeBytes(outAppBuf);\n                            }\n                            outAppBuf.clear();\n                        }\n                    }\n\n                    final HandshakeStatus handshakeStatus = result.getHandshakeStatus();\n                    handleRenegotiation(handshakeStatus);\n                    switch (handshakeStatus) {\n                    case NEED_UNWRAP:\n                        break;\n                    case NEED_WRAP:\n                        wrapNonAppData(ctx, channel);\n                        break;\n                    case NEED_TASK:\n                        runDelegatedTasks();\n                        break;\n                    case FINISHED:\n                        setHandshakeSuccess(channel);\n                        needsWrap = true;\n                        continue;\n                    case NOT_HANDSHAKING:\n                        if (setHandshakeSuccessIfStillHandshaking(channel)) {\n                            needsWrap = true;\n                            continue;\n                        }\n                        if (writeBeforeHandshakeDone) {\n                            // We need to call wrap(...) in case there was a flush done before the handshake completed.\n                            //\n                            // See https://github.com/netty/netty/pull/2437\n                            writeBeforeHandshakeDone = false;\n                            needsWrap = true;\n                        }\n                        break;\n                    default:\n                        throw new IllegalStateException(\n                                \"Unknown handshake status: \" + handshakeStatus);\n                    }\n\n                    if (result.getStatus() == Status.BUFFER_UNDERFLOW ||\n                        result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (needsWrap) {\n                // wrap() acquires pendingUnencryptedWrites first and then\n                // handshakeLock.  If handshakeLock is already hold by the\n                // current thread, calling wrap() will lead to a dead lock\n                // i.e. pendingUnencryptedWrites -> handshakeLock vs.\n                //      handshakeLock -> pendingUnencryptedLock -> handshakeLock\n                //\n                // There is also the same issue between pendingEncryptedWrites\n                // and pendingUnencryptedWrites.\n                if (!Thread.holdsLock(handshakeLock) && !pendingEncryptedWritesLock.isHeldByCurrentThread()) {\n                    wrap(ctx, channel);\n                }\n            }\n        } catch (SSLException e) {\n            setHandshakeFailure(channel, e);\n            throw e;\n        } finally {\n            bufferPool.releaseBuffer(nioOutAppBuf);\n        }\n\n        if (nettyOutAppBuf != null && nettyOutAppBuf.readable()) {\n            return nettyOutAppBuf;\n        } else {\n            return null;\n        }\n    }",
    "abstract_func": "private ChannelBuffer unwrap(\n            ChannelHandlerContext VAR_0, Channel VAR_1,\n            ChannelBuffer VAR_2, ByteBuffer VAR_3,\n            int VAR_4) throws SSLException {\n\n        final int VAR_5 = VAR_2.readerIndex();\n        final int VAR_6 = VAR_3.position();\n        final ByteBuffer VAR_7 = VAR_8.acquireBuffer();\n\n        ChannelBuffer VAR_9 = null;\n\n        try {\n            boolean VAR_10 = false;\n            for (;;) {\n                SSLEngineResult VAR_11;\n                boolean VAR_12 = false;\n                synchronized (VAR_13) {\n                    if (!VAR_14 && !VAR_15 &&\n                        !VAR_16.getUseClientMode() &&\n                        !VAR_16.isInboundDone() && !VAR_16.isOutboundDone()) {\n                        VAR_12 = true;\n                    }\n                }\n\n                if (VAR_12) {\n                    handshake();\n                }\n\n                synchronized (VAR_13) {\n                    /* COMMENT_0 */\n                    /* COMMENT_1 */\n                    /* COMMENT_2 */\n                    /* COMMENT_3 */\n                    for (;;) {\n                        final int VAR_17 = VAR_16.getSession().getApplicationBufferSize();\n                        final ByteBuffer VAR_18;\n                        if (VAR_7.capacity() < VAR_17) {\n                            /* COMMENT_4 */\n                            /* COMMENT_5 */\n                            VAR_18 = VAR_19.allocate(VAR_17);\n                        } else {\n                            VAR_18 = VAR_7;\n                        }\n\n                        try {\n                            VAR_11 = VAR_16.unwrap(VAR_3, VAR_18);\n                            switch (VAR_11.getStatus()) {\n                                case VAR_20:\n                                    /* COMMENT_6 */\n                                    VAR_21.setClosed();\n                                    break;\n                                case VAR_22:\n                                    /* COMMENT_7 */\n                                    /* COMMENT_8 */\n                                    continue;\n                            }\n\n                            break;\n                        } finally {\n                            VAR_18.flip();\n\n                            /* COMMENT_9 */\n                            VAR_2.readerIndex(\n                                    VAR_5 + VAR_3.position() - VAR_6);\n\n                            /* COMMENT_10 */\n                            if (VAR_18.hasRemaining()) {\n                                if (VAR_9 == null) {\n                                    ChannelBufferFactory VAR_23 = VAR_0.getChannel().getConfig().getBufferFactory();\n                                    VAR_9 = VAR_23.getBuffer(VAR_4);\n                                }\n                                VAR_9.writeBytes(VAR_18);\n                            }\n                            VAR_18.clear();\n                        }\n                    }\n\n                    final HandshakeStatus VAR_24 = VAR_11.getHandshakeStatus();\n                    handleRenegotiation(VAR_24);\n                    switch (VAR_24) {\n                    case VAR_25:\n                        break;\n                    case VAR_26:\n                        wrapNonAppData(VAR_0, VAR_1);\n                        break;\n                    case VAR_27:\n                        runDelegatedTasks();\n                        break;\n                    case VAR_28:\n                        setHandshakeSuccess(VAR_1);\n                        VAR_10 = true;\n                        continue;\n                    case VAR_29:\n                        if (setHandshakeSuccessIfStillHandshaking(VAR_1)) {\n                            VAR_10 = true;\n                            continue;\n                        }\n                        if (VAR_30) {\n                            /* COMMENT_11 */\n                            /* COMMENT_12 */\n                            /* COMMENT_13 */\n                            VAR_30 = false;\n                            VAR_10 = true;\n                        }\n                        break;\n                    default:\n                        throw new IllegalStateException(\n                                \"Unknown handshake status: \" + VAR_24);\n                    }\n\n                    if (VAR_11.getStatus() == VAR_31.BUFFER_UNDERFLOW ||\n                        VAR_11.bytesConsumed() == 0 && VAR_11.bytesProduced() == 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (VAR_10) {\n                /* COMMENT_14 */\n                /* COMMENT_15 */\n                /* COMMENT_16 */\n                /* COMMENT_17 */\n                /* COMMENT_18 */\n                /* COMMENT_12 */\n                /* COMMENT_19 */\n                /* COMMENT_20 */\n                if (!VAR_32.holdsLock(VAR_13) && !VAR_33.isHeldByCurrentThread()) {\n                    wrap(VAR_0, VAR_1);\n                }\n            }\n        } catch (SSLException VAR_34) {\n            setHandshakeFailure(VAR_1, VAR_34);\n            throw VAR_34;\n        } finally {\n            VAR_8.releaseBuffer(VAR_7);\n        }\n\n        if (VAR_9 != null && VAR_9.readable()) {\n            return VAR_9;\n        } else {\n            return null;\n        }\n    }",
    "func_graph_path": "netty/2fa9400a59d0563a66908aba55c41e7285a04994/SslHandler.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -32,8 +32,18 @@\n                     // always contain at least one record in decode().  Therefore, if SSLEngine.unwrap() returns\n                     // BUFFER_OVERFLOW, it is always resolved by retrying after emptying the application buffer.\n                     for (;;) {\n+                        final int outAppBufSize = engine.getSession().getApplicationBufferSize();\n+                        final ByteBuffer outAppBuf;\n+                        if (nioOutAppBuf.capacity() < outAppBufSize) {\n+                            // SSLEngine wants a buffer larger than what the pool can provide.\n+                            // Allocate a temporary heap buffer.\n+                            outAppBuf = ByteBuffer.allocate(outAppBufSize);\n+                        } else {\n+                            outAppBuf = nioOutAppBuf;\n+                        }\n+\n                         try {\n-                            result = engine.unwrap(nioInNetBuf, nioOutAppBuf);\n+                            result = engine.unwrap(nioInNetBuf, outAppBuf);\n                             switch (result.getStatus()) {\n                                 case CLOSED:\n                                     // notify about the CLOSED state of the SSLEngine. See #137\n@@ -47,21 +57,21 @@\n \n                             break;\n                         } finally {\n-                            nioOutAppBuf.flip();\n+                            outAppBuf.flip();\n \n                             // Sync the offset of the inbound buffer.\n                             nettyInNetBuf.readerIndex(\n                                     nettyInNetBufStartOffset + nioInNetBuf.position() - nioInNetBufStartOffset);\n \n                             // Copy the unwrapped data into a smaller buffer.\n-                            if (nioOutAppBuf.hasRemaining()) {\n+                            if (outAppBuf.hasRemaining()) {\n                                 if (nettyOutAppBuf == null) {\n                                     ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();\n                                     nettyOutAppBuf = factory.getBuffer(initialNettyOutAppBufCapacity);\n                                 }\n-                                nettyOutAppBuf.writeBytes(nioOutAppBuf);\n+                                nettyOutAppBuf.writeBytes(outAppBuf);\n                             }\n-                            nioOutAppBuf.clear();\n+                            outAppBuf.clear();\n                         }\n                     }\n ",
    "diff_line_info": {
        "deleted_lines": [
            "                            result = engine.unwrap(nioInNetBuf, nioOutAppBuf);",
            "                            nioOutAppBuf.flip();",
            "                            if (nioOutAppBuf.hasRemaining()) {",
            "                                nettyOutAppBuf.writeBytes(nioOutAppBuf);",
            "                            nioOutAppBuf.clear();"
        ],
        "added_lines": [
            "                        final int outAppBufSize = engine.getSession().getApplicationBufferSize();",
            "                        final ByteBuffer outAppBuf;",
            "                        if (nioOutAppBuf.capacity() < outAppBufSize) {",
            "                            // SSLEngine wants a buffer larger than what the pool can provide.",
            "                            // Allocate a temporary heap buffer.",
            "                            outAppBuf = ByteBuffer.allocate(outAppBufSize);",
            "                        } else {",
            "                            outAppBuf = nioOutAppBuf;",
            "                        }",
            "",
            "                            result = engine.unwrap(nioInNetBuf, outAppBuf);",
            "                            outAppBuf.flip();",
            "                            if (outAppBuf.hasRemaining()) {",
            "                                nettyOutAppBuf.writeBytes(outAppBuf);",
            "                            outAppBuf.clear();"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}