{
    "cve_id": "CVE-2020-15212",
    "cwe_ids": [
        "CWE-787",
        "CWE-770"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "tensorflow",
    "commit_msg": "[tflite] Validate segment ids for segment_sum.\n\nSegment identifiers in segment_sum should be in a 1-D tensor of same size as the first dimension of the input. The values of the tensor should be integers from {0, 1, 2, ... k-1}, where k is the first dimension of the input. The segment identifiers must not contain jumps and must be increasing.\n\nSee https://www.tensorflow.org/api_docs/python/tf/math#Segmentation as the source for these constraints.\n\nPiperOrigin-RevId: 332510942\nChange-Id: I898beaba00642c918bcd4b4d4ce893ebb190d869",
    "commit_hash": "204945b19e44b57906c9344c0d00120eeeae178a",
    "git_url": "https://github.com/tensorflow/tensorflow/commit/204945b19e44b57906c9344c0d00120eeeae178a",
    "file_path": "tensorflow/lite/kernels/segment_sum.cc",
    "func_name": "ResizeOutputTensor",
    "func_before": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}",
    "abstract_func_before": "TfLiteStatus ResizeOutputTensor(TfLiteContext* VAR_0,\n                                const TfLiteTensor* VAR_1,\n                                const TfLiteTensor* VAR_2,\n                                TfLiteTensor* VAR_3) {\n  int VAR_4 = -1;\n  const int VAR_5 = VAR_2->dims->data[0];\n  if (VAR_5 > 0) {\n    VAR_4 = VAR_2->data.i32[VAR_5 - 1];\n  }\n  const int VAR_6 = NumDimensions(VAR_1);\n  TfLiteIntArray* VAR_7 = TfLiteIntArrayCreate(NumDimensions(VAR_1));\n  VAR_7->data[0] = VAR_4 + 1;\n  for (int VAR_8 = 1; VAR_8 < VAR_6; ++VAR_8) {\n    VAR_7->data[VAR_8] = VAR_1->dims->data[VAR_8];\n  }\n  return VAR_0->ResizeTensor(VAR_0, VAR_3, VAR_7);\n}",
    "func_graph_path_before": "tensorflow/204945b19e44b57906c9344c0d00120eeeae178a/segment_sum.cc/vul/before/0.json",
    "func": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  // Segment ids should be of same cardinality as first input dimension and they\n  // should be increasing by at most 1, from 0 (e.g., [0, 0, 1, 2, 3] is valid)\n  const int segment_id_size = segment_ids->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);\n  int previous_segment_id = -1;\n  for (int i = 0; i < segment_id_size; i++) {\n    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];\n    if (i == 0) {\n      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);\n    } else {\n      int delta = current_segment_id - previous_segment_id;\n      TF_LITE_ENSURE(context, delta == 0 || delta == 1);\n    }\n    previous_segment_id = current_segment_id;\n  }\n\n  const int max_index = previous_segment_id;\n\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}",
    "abstract_func": "TfLiteStatus ResizeOutputTensor(TfLiteContext* VAR_0,\n                                const TfLiteTensor* VAR_1,\n                                const TfLiteTensor* VAR_2,\n                                TfLiteTensor* VAR_3) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  const int VAR_4 = VAR_2->dims->data[0];\n  TF_LITE_ENSURE_EQ(VAR_0, VAR_4, VAR_1->dims->data[0]);\n  int VAR_5 = -1;\n  for (int VAR_6 = 0; VAR_6 < VAR_4; VAR_6++) {\n    const int VAR_7 = VAR_8<int32_t>(VAR_2)[VAR_6];\n    if (VAR_6 == 0) {\n      TF_LITE_ENSURE_EQ(VAR_0, VAR_7, 0);\n    } else {\n      int VAR_9 = VAR_7 - VAR_5;\n      TF_LITE_ENSURE(VAR_0, VAR_9 == 0 || VAR_9 == 1);\n    }\n    VAR_5 = VAR_7;\n  }\n\n  const int VAR_10 = VAR_5;\n\n  const int VAR_11 = NumDimensions(VAR_1);\n  TfLiteIntArray* VAR_12 = TfLiteIntArrayCreate(NumDimensions(VAR_1));\n  VAR_12->data[0] = VAR_10 + 1;\n  for (int VAR_6 = 1; VAR_6 < VAR_11; ++VAR_6) {\n    VAR_12->data[VAR_6] = VAR_1->dims->data[VAR_6];\n  }\n  return VAR_0->ResizeTensor(VAR_0, VAR_3, VAR_12);\n}",
    "func_graph_path": "tensorflow/204945b19e44b57906c9344c0d00120eeeae178a/segment_sum.cc/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,24 @@\n                                 const TfLiteTensor* data,\n                                 const TfLiteTensor* segment_ids,\n                                 TfLiteTensor* output) {\n-  int max_index = -1;\n+  // Segment ids should be of same cardinality as first input dimension and they\n+  // should be increasing by at most 1, from 0 (e.g., [0, 0, 1, 2, 3] is valid)\n   const int segment_id_size = segment_ids->dims->data[0];\n-  if (segment_id_size > 0) {\n-    max_index = segment_ids->data.i32[segment_id_size - 1];\n+  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);\n+  int previous_segment_id = -1;\n+  for (int i = 0; i < segment_id_size; i++) {\n+    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];\n+    if (i == 0) {\n+      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);\n+    } else {\n+      int delta = current_segment_id - previous_segment_id;\n+      TF_LITE_ENSURE(context, delta == 0 || delta == 1);\n+    }\n+    previous_segment_id = current_segment_id;\n   }\n+\n+  const int max_index = previous_segment_id;\n+\n   const int data_rank = NumDimensions(data);\n   TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n   output_shape->data[0] = max_index + 1;",
    "diff_line_info": {
        "deleted_lines": [
            "  int max_index = -1;",
            "  if (segment_id_size > 0) {",
            "    max_index = segment_ids->data.i32[segment_id_size - 1];"
        ],
        "added_lines": [
            "  // Segment ids should be of same cardinality as first input dimension and they",
            "  // should be increasing by at most 1, from 0 (e.g., [0, 0, 1, 2, 3] is valid)",
            "  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);",
            "  int previous_segment_id = -1;",
            "  for (int i = 0; i < segment_id_size; i++) {",
            "    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];",
            "    if (i == 0) {",
            "      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);",
            "    } else {",
            "      int delta = current_segment_id - previous_segment_id;",
            "      TF_LITE_ENSURE(context, delta == 0 || delta == 1);",
            "    }",
            "    previous_segment_id = current_segment_id;",
            "",
            "  const int max_index = previous_segment_id;",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}