{
    "cve_id": "CVE-2015-5364",
    "cwe_ids": [
        "CWE-399"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "udp: fix behavior of wrong checksums\n\nWe have two problems in UDP stack related to bogus checksums :\n\n1) We return -EAGAIN to application even if receive queue is not empty.\n   This breaks applications using edge trigger epoll()\n\n2) Under UDP flood, we can loop forever without yielding to other\n   processes, potentially hanging the host, especially on non SMP.\n\nThis patch is an attempt to make things better.\n\nWe might in the future add extra support for rt applications\nwanting to better control time spent doing a recv() in a hostile\nenvironment. For example we could validate checksums before queuing\npackets in socket receive queue.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Willem de Bruijn <willemb@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "commit_hash": "beb39db59d14990e401e235faf66a6b9b31240b0",
    "git_url": "https://github.com/torvalds/linux/commit/beb39db59d14990e401e235faf66a6b9b31240b0",
    "file_path": "net/ipv6/udp.c",
    "func_name": "udp_recvmsg",
    "func_before": "int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n\t\tint flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tbool slow;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ip_recv_error(sk, msg, len, addr_len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t    msg, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t\t     msg);\n\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udp_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!peeked)\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = udp_hdr(skb)->source;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\tif (noblock)\n\t\treturn -EAGAIN;\n\n\t/* starting over for a new packet */\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}",
    "abstract_func_before": "int udp_recvmsg(struct sock *VAR_0, struct msghdr *VAR_1, size_t VAR_2, int VAR_3,\n\t\tint VAR_4, int *VAR_5)\n{\n\tstruct inet_sock *VAR_6 = inet_sk(VAR_0);\n\tVAR_7(struct sockaddr_in *, VAR_8, VAR_1->msg_name);\n\tstruct sk_buff *VAR_9;\n\tunsigned int VAR_10, VAR_11;\n\tint VAR_12, VAR_13 = 0;\n\tint VAR_14;\n\tint VAR_15 = IS_UDPLITE(VAR_0);\n\tbool VAR_16;\n\n\tif (VAR_4 & VAR_17)\n\t\treturn ip_recv_error(VAR_0, VAR_1, VAR_2, VAR_5);\n\ntry_again:\n\tVAR_9 = __skb_recv_datagram(VAR_0, VAR_4 | (VAR_3 ? VAR_18 : 0),\n\t\t\t\t  &VAR_12, &VAR_13, &VAR_14);\n\tif (!VAR_9)\n\t\tgoto out;\n\n\tVAR_10 = VAR_9->len - sizeof(struct udphdr);\n\tVAR_11 = VAR_2;\n\tif (VAR_11 > VAR_10)\n\t\tVAR_11 = VAR_10;\n\telse if (VAR_11 < VAR_10)\n\t\tVAR_1->msg_flags |= VAR_19;\n\n\t/* COMMENT_0 */\n                                                                \n                                                                 \n                                                        \n    \n\n\tif (VAR_11 < VAR_10 || UDP_SKB_CB(VAR_9)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(VAR_9))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(VAR_9))\n\t\tVAR_14 = skb_copy_datagram_msg(VAR_9, sizeof(struct udphdr),\n\t\t\t\t\t    VAR_1, VAR_11);\n\telse {\n\t\tVAR_14 = skb_copy_and_csum_datagram_msg(VAR_9, sizeof(struct udphdr),\n\t\t\t\t\t\t     VAR_1);\n\n\t\tif (VAR_14 == -VAR_20)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (unlikely(VAR_14)) {\n\t\ttrace_kfree_skb(VAR_9, VAR_21);\n\t\tif (!VAR_12) {\n\t\t\tatomic_inc(&VAR_0->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(VAR_0),\n\t\t\t\t\t   VAR_22, VAR_15);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!VAR_12)\n\t\tUDP_INC_STATS_USER(sock_net(VAR_0),\n\t\t\t\tVAR_23, VAR_15);\n\n\tsock_recv_ts_and_drops(VAR_1, VAR_0, VAR_9);\n\n\t/* COMMENT_5 */\n\tif (VAR_8) {\n\t\tVAR_8->sin_family = VAR_24;\n\t\tVAR_8->sin_port = udp_hdr(VAR_9)->source;\n\t\tVAR_8->sin_addr.s_addr = ip_hdr(VAR_9)->saddr;\n\t\tmemset(VAR_8->sin_zero, 0, sizeof(VAR_8->sin_zero));\n\t\t*VAR_5 = sizeof(*VAR_8);\n\t}\n\tif (VAR_6->cmsg_flags)\n\t\tip_cmsg_recv_offset(VAR_1, VAR_9, sizeof(struct udphdr));\n\n\tVAR_14 = VAR_11;\n\tif (VAR_4 & VAR_19)\n\t\tVAR_14 = VAR_10;\n\nout_free:\n\tskb_free_datagram_locked(VAR_0, VAR_9);\nout:\n\treturn VAR_14;\n\ncsum_copy_err:\n\tVAR_16 = lock_sock_fast(VAR_0);\n\tif (!skb_kill_datagram(VAR_0, VAR_9, VAR_4)) {\n\t\tUDP_INC_STATS_USER(sock_net(VAR_0), VAR_25, VAR_15);\n\t\tUDP_INC_STATS_USER(sock_net(VAR_0), VAR_22, VAR_15);\n\t}\n\tunlock_sock_fast(VAR_0, VAR_16);\n\n\tif (VAR_3)\n\t\treturn -VAR_26;\n\n\t/* COMMENT_6 */\n\tVAR_1->msg_flags &= ~VAR_19;\n\tgoto try_again;\n}",
    "func_graph_path_before": "torvalds/linux/beb39db59d14990e401e235faf66a6b9b31240b0/udp.c/vul/before/0.json",
    "func": "int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n\t\tint flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tbool slow;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ip_recv_error(sk, msg, len, addr_len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t    msg, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t\t     msg);\n\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udp_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!peeked)\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = udp_hdr(skb)->source;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\t/* starting over for a new packet, but check if we need to yield */\n\tcond_resched();\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}",
    "abstract_func": "int udp_recvmsg(struct sock *VAR_0, struct msghdr *VAR_1, size_t VAR_2, int VAR_3,\n\t\tint VAR_4, int *VAR_5)\n{\n\tstruct inet_sock *VAR_6 = inet_sk(VAR_0);\n\tVAR_7(struct sockaddr_in *, VAR_8, VAR_1->msg_name);\n\tstruct sk_buff *VAR_9;\n\tunsigned int VAR_10, VAR_11;\n\tint VAR_12, VAR_13 = 0;\n\tint VAR_14;\n\tint VAR_15 = IS_UDPLITE(VAR_0);\n\tbool VAR_16;\n\n\tif (VAR_4 & VAR_17)\n\t\treturn ip_recv_error(VAR_0, VAR_1, VAR_2, VAR_5);\n\ntry_again:\n\tVAR_9 = __skb_recv_datagram(VAR_0, VAR_4 | (VAR_3 ? VAR_18 : 0),\n\t\t\t\t  &VAR_12, &VAR_13, &VAR_14);\n\tif (!VAR_9)\n\t\tgoto out;\n\n\tVAR_10 = VAR_9->len - sizeof(struct udphdr);\n\tVAR_11 = VAR_2;\n\tif (VAR_11 > VAR_10)\n\t\tVAR_11 = VAR_10;\n\telse if (VAR_11 < VAR_10)\n\t\tVAR_1->msg_flags |= VAR_19;\n\n\t/* COMMENT_0 */\n                                                                \n                                                                 \n                                                        \n    \n\n\tif (VAR_11 < VAR_10 || UDP_SKB_CB(VAR_9)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(VAR_9))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(VAR_9))\n\t\tVAR_14 = skb_copy_datagram_msg(VAR_9, sizeof(struct udphdr),\n\t\t\t\t\t    VAR_1, VAR_11);\n\telse {\n\t\tVAR_14 = skb_copy_and_csum_datagram_msg(VAR_9, sizeof(struct udphdr),\n\t\t\t\t\t\t     VAR_1);\n\n\t\tif (VAR_14 == -VAR_20)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (unlikely(VAR_14)) {\n\t\ttrace_kfree_skb(VAR_9, VAR_21);\n\t\tif (!VAR_12) {\n\t\t\tatomic_inc(&VAR_0->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(VAR_0),\n\t\t\t\t\t   VAR_22, VAR_15);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!VAR_12)\n\t\tUDP_INC_STATS_USER(sock_net(VAR_0),\n\t\t\t\tVAR_23, VAR_15);\n\n\tsock_recv_ts_and_drops(VAR_1, VAR_0, VAR_9);\n\n\t/* COMMENT_5 */\n\tif (VAR_8) {\n\t\tVAR_8->sin_family = VAR_24;\n\t\tVAR_8->sin_port = udp_hdr(VAR_9)->source;\n\t\tVAR_8->sin_addr.s_addr = ip_hdr(VAR_9)->saddr;\n\t\tmemset(VAR_8->sin_zero, 0, sizeof(VAR_8->sin_zero));\n\t\t*VAR_5 = sizeof(*VAR_8);\n\t}\n\tif (VAR_6->cmsg_flags)\n\t\tip_cmsg_recv_offset(VAR_1, VAR_9, sizeof(struct udphdr));\n\n\tVAR_14 = VAR_11;\n\tif (VAR_4 & VAR_19)\n\t\tVAR_14 = VAR_10;\n\nout_free:\n\tskb_free_datagram_locked(VAR_0, VAR_9);\nout:\n\treturn VAR_14;\n\ncsum_copy_err:\n\tVAR_16 = lock_sock_fast(VAR_0);\n\tif (!skb_kill_datagram(VAR_0, VAR_9, VAR_4)) {\n\t\tUDP_INC_STATS_USER(sock_net(VAR_0), VAR_25, VAR_15);\n\t\tUDP_INC_STATS_USER(sock_net(VAR_0), VAR_22, VAR_15);\n\t}\n\tunlock_sock_fast(VAR_0, VAR_16);\n\n\t/* COMMENT_6 */\n\tcond_resched();\n\tVAR_1->msg_flags &= ~VAR_19;\n\tgoto try_again;\n}",
    "func_graph_path": "torvalds/linux/beb39db59d14990e401e235faf66a6b9b31240b0/udp.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -92,10 +92,8 @@\n \t}\n \tunlock_sock_fast(sk, slow);\n \n-\tif (noblock)\n-\t\treturn -EAGAIN;\n-\n-\t/* starting over for a new packet */\n+\t/* starting over for a new packet, but check if we need to yield */\n+\tcond_resched();\n \tmsg->msg_flags &= ~MSG_TRUNC;\n \tgoto try_again;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\tif (noblock)",
            "\t\treturn -EAGAIN;",
            "",
            "\t/* starting over for a new packet */"
        ],
        "added_lines": [
            "\t/* starting over for a new packet, but check if we need to yield */",
            "\tcond_resched();"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}