{
    "cve_id": "CVE-2017-7948",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "ArtifexSoftware/ghostpdl",
    "commit_msg": "Bug 697762: Fix scan converter SEGVs.\n\nThe SEGVs are caused by the scan converter allowing less room\nin the table than is actually required. This happens due to\nthe mark_curve subdivision overflowing.\n\nFor example, if we have a curve such as:\n\n 0 0x80000000 moveto\n 0 0x80000000 0 0x80000000 0 0x80000000 curveto\n\nThen the current subdivision logic does:\n\n fixed ay = (sy + c1y)>>1\n\nFor sy = c1y = 0x80000000 this gives ay = 0, when clearly\nthe average should be 0x80000000.\n\nAn alternative formulation of the splitting code:\n\n fixed ay = (sy>>1) + (c1y>>1)\n\ngives the required result, at the expense of dropping accuracy at\nthe low end.\n\nThis commit therefore has 2 formulations of the splitting code, one\nfor 'big' values (values that might overflow), and ones for normal\nvalues (values that won't).\n\nWe select between the two pieces of code by comparing the top 2\nbits of each value; if they differ, then we use the big variant.\n\nAlso, when calculating the size of the table required, we were\nincorrectly closing the curve more often than we needed to. This\nhad no ill effect other than inflating the amount of memory we\nneeded.",
    "commit_hash": "8210a2864372723b49c526e2b102fdc00c9c4699",
    "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/8210a2864372723b49c526e2b102fdc00c9c4699",
    "file_path": "base/gxscanc.c",
    "func_name": "gx_scan_convert_tr",
    "func_before": "int gx_scan_convert_tr(gx_device     * restrict pdev,\n                       gx_path       * restrict path,\n                 const gs_fixed_rect * restrict clip,\n                       gx_edgebuffer * restrict edgebuffer,\n                       fixed                    fixed_flat)\n{\n    gs_fixed_rect  ibox;\n    int            scanlines;\n    const subpath *psub;\n    int           *index;\n    int           *table;\n    int            i;\n    int            code;\n    int            id = 0;\n\n    edgebuffer->index = NULL;\n    edgebuffer->table = NULL;\n\n    /* Bale out if no actual path. We see this with the clist */\n    if (path->first_subpath == NULL)\n        return 0;\n\n    code = make_bbox(path, clip, &ibox, fixed_half);\n    if (code < 0)\n        return code;\n\n    if (ibox.q.y <= ibox.p.y)\n        return 0;\n\n    code = make_table_tr(pdev, path, &ibox, &scanlines, &index, &table);\n    if (code < 0)\n        return code;\n\n    /* Step 3: Now we run through the path, filling in the real\n     * values. */\n    for (psub = path->first_subpath; psub != 0;) {\n        const segment *pseg = (const segment *)psub;\n        fixed ex = pseg->pt.x;\n        fixed ey = pseg->pt.y;\n        fixed ix = ex;\n        fixed iy = ey;\n\n        while ((pseg = pseg->next) != 0 &&\n               pseg->type != s_start\n            ) {\n            fixed sx = ex;\n            fixed sy = ey;\n            ex = pseg->pt.x;\n            ey = pseg->pt.y;\n\n            switch (pseg->type) {\n                default:\n                case s_start: /* Should never happen */\n                case s_dash:  /* We should never be seeing a dash here */\n                    assert(\"This should never happen\" == NULL);\n                    break;\n                case s_curve: {\n                    const curve_segment *const pcur = (const curve_segment *)pseg;\n                    int k = gx_curve_log2_samples(sx, sy, pcur, fixed_flat);\n\n                    mark_curve_tr(sx, sy, pcur->p1.x, pcur->p1.y, pcur->p2.x, pcur->p2.y, ex, ey, ibox.p.y, scanlines, table, index, &id, k);\n                    break;\n                }\n                case s_gap:\n                case s_line:\n                case s_line_close:\n                    if (sy != ey)\n                        mark_line_tr(sx, sy, ex, ey, ibox.p.y, scanlines, table, index, ++id);\n                    break;\n            }\n        }\n        /* And close any open segments */\n        if (iy != ey)\n            mark_line_tr(ex, ey, ix, iy, ibox.p.y, scanlines, table, index, ++id);\n        psub = (const subpath *)pseg;\n    }\n\n    /* Step 2 complete: We now have a complete list of intersection data in\n     * table, indexed by index. */\n\n    edgebuffer->base   = ibox.p.y;\n    edgebuffer->height = scanlines;\n    edgebuffer->xmin   = ibox.p.x;\n    edgebuffer->xmax   = ibox.q.x;\n    edgebuffer->index  = index;\n    edgebuffer->table  = table;\n\n#ifdef DEBUG_SCAN_CONVERTER\n    if (debugging_scan_converter) {\n        dlprintf(\"Before sorting:\\n\");\n        gx_edgebuffer_print_tr(edgebuffer);\n    }\n#endif\n\n    /* Step 4: Sort the intersects on x */\n    for (i=0; i < scanlines; i++) {\n        int *row = &table[index[i]];\n        int  rowlen = *row++;\n\n        /* Bubblesort short runs, qsort longer ones. */\n        /* FIXME: Verify the figure 6 below */\n        if (rowlen <= 6) {\n            int j, k;\n            for (j = 0; j < rowlen-1; j++) {\n                int * restrict t = &row[j<<1];\n                for (k = j+1; k < rowlen; k++) {\n                    int * restrict s = &row[k<<1];\n                    int tmp;\n                    if (t[0] < s[0])\n                        continue;\n                    if (t[0] == s[0]) {\n                        if (t[1] <= s[1])\n                            continue;\n                    } else\n                        tmp = t[0], t[0] = s[0], s[0] = tmp;\n                    tmp = t[1], t[1] = s[1], s[1] = tmp;\n                }\n            }\n        } else\n            qsort(row, rowlen, 2*sizeof(int), intcmp_tr);\n    }\n\n    return 0;\n}",
    "abstract_func_before": "int gx_scan_convert_tr(gx_device     * restrict VAR_0,\n                       gx_path       * restrict VAR_1,\n                 const gs_fixed_rect * restrict VAR_2,\n                       gx_edgebuffer * restrict VAR_3,\n                       fixed                    VAR_4)\n{\n    gs_fixed_rect  VAR_5;\n    int            VAR_6;\n    const subpath *VAR_7;\n    int           *VAR_8;\n    int           *VAR_9;\n    int            VAR_10;\n    int            VAR_11;\n    int            VAR_12 = 0;\n\n    VAR_3->index = NULL;\n    VAR_3->table = NULL;\n\n    /* COMMENT_0 */\n    if (VAR_1->first_subpath == NULL)\n        return 0;\n\n    VAR_11 = make_bbox(VAR_1, VAR_2, &VAR_5, VAR_13);\n    if (VAR_11 < 0)\n        return VAR_11;\n\n    if (VAR_5.q.y <= VAR_5.p.y)\n        return 0;\n\n    VAR_11 = make_table_tr(VAR_0, VAR_1, &VAR_5, &VAR_6, &VAR_8, &VAR_9);\n    if (VAR_11 < 0)\n        return VAR_11;\n\n    /* COMMENT_1 */\n                 \n    for (VAR_7 = VAR_1->first_subpath; VAR_7 != 0;) {\n        const segment *VAR_14 = (const segment *)VAR_7;\n        fixed VAR_15 = VAR_14->pt.x;\n        fixed VAR_16 = VAR_14->pt.y;\n        fixed VAR_17 = VAR_15;\n        fixed VAR_18 = VAR_16;\n\n        while ((VAR_14 = VAR_14->next) != 0 &&\n               VAR_14->type != VAR_19\n            ) {\n            fixed VAR_20 = VAR_15;\n            fixed VAR_21 = VAR_16;\n            VAR_15 = VAR_14->pt.x;\n            VAR_16 = VAR_14->pt.y;\n\n            switch (VAR_14->type) {\n                default:\n                case VAR_19: /* COMMENT_3 */\n                case VAR_22:  /* COMMENT_4 */\n                    assert(\"This should never happen\" == NULL);\n                    break;\n                case VAR_23: {\n                    const curve_segment *const VAR_24 = (const curve_segment *)VAR_14;\n                    int VAR_25 = gx_curve_log2_samples(VAR_20, VAR_21, VAR_24, VAR_4);\n\n                    mark_curve_tr(VAR_20, VAR_21, VAR_24->p1.x, VAR_24->p1.y, VAR_24->p2.x, VAR_24->p2.y, VAR_15, VAR_16, VAR_5.p.y, VAR_6, VAR_9, VAR_8, &VAR_12, VAR_25);\n                    break;\n                }\n                case VAR_26:\n                case VAR_27:\n                case VAR_28:\n                    if (VAR_21 != VAR_16)\n                        mark_line_tr(VAR_20, VAR_21, VAR_15, VAR_16, VAR_5.p.y, VAR_6, VAR_9, VAR_8, ++VAR_12);\n                    break;\n            }\n        }\n        /* COMMENT_5 */\n        if (VAR_18 != VAR_16)\n            mark_line_tr(VAR_15, VAR_16, VAR_17, VAR_18, VAR_5.p.y, VAR_6, VAR_9, VAR_8, ++VAR_12);\n        VAR_7 = (const subpath *)VAR_14;\n    }\n\n    /* COMMENT_6 */\n                                  \n\n    VAR_3->base   = VAR_5.p.y;\n    VAR_3->height = VAR_6;\n    VAR_3->xmin   = VAR_5.p.x;\n    VAR_3->xmax   = VAR_5.q.x;\n    VAR_3->index  = VAR_8;\n    VAR_3->table  = VAR_9;\n\n#ifdef VAR_29\n    if (VAR_30) {\n        dlprintf(\"Before sorting:\\n\");\n        gx_edgebuffer_print_tr(VAR_3);\n    }\n#endif\n\n    /* COMMENT_8 */\n    for (VAR_10=0; VAR_10 < VAR_6; VAR_10++) {\n        int *VAR_31 = &VAR_9[VAR_8[VAR_10]];\n        int  VAR_32 = *VAR_31++;\n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        if (VAR_32 <= 6) {\n            int VAR_33, VAR_25;\n            for (VAR_33 = 0; VAR_33 < VAR_32-1; VAR_33++) {\n                int * restrict VAR_34 = &VAR_31[VAR_33<<1];\n                for (VAR_25 = VAR_33+1; VAR_25 < VAR_32; VAR_25++) {\n                    int * restrict VAR_35 = &VAR_31[VAR_25<<1];\n                    int VAR_36;\n                    if (VAR_34[0] < VAR_35[0])\n                        continue;\n                    if (VAR_34[0] == VAR_35[0]) {\n                        if (VAR_34[1] <= VAR_35[1])\n                            continue;\n                    } else\n                        VAR_36 = VAR_34[0], VAR_34[0] = VAR_35[0], VAR_35[0] = VAR_36;\n                    VAR_36 = VAR_34[1], VAR_34[1] = VAR_35[1], VAR_35[1] = VAR_36;\n                }\n            }\n        } else\n            qsort(VAR_31, VAR_32, 2*sizeof(int), VAR_37);\n    }\n\n    return 0;\n}",
    "func_graph_path_before": "ArtifexSoftware/ghostpdl/8210a2864372723b49c526e2b102fdc00c9c4699/gxscanc.c/vul/before/3.json",
    "func": "int gx_scan_convert_tr(gx_device     * restrict pdev,\n                       gx_path       * restrict path,\n                 const gs_fixed_rect * restrict clip,\n                       gx_edgebuffer * restrict edgebuffer,\n                       fixed                    fixed_flat)\n{\n    gs_fixed_rect  ibox;\n    int            scanlines;\n    const subpath *psub;\n    int           *index;\n    int           *table;\n    int            i;\n    int            code;\n    int            id = 0;\n\n    edgebuffer->index = NULL;\n    edgebuffer->table = NULL;\n\n    /* Bale out if no actual path. We see this with the clist */\n    if (path->first_subpath == NULL)\n        return 0;\n\n    code = make_bbox(path, clip, &ibox, fixed_half);\n    if (code < 0)\n        return code;\n\n    if (ibox.q.y <= ibox.p.y)\n        return 0;\n\n    code = make_table_tr(pdev, path, &ibox, &scanlines, &index, &table);\n    if (code < 0)\n        return code;\n\n    /* Step 3: Now we run through the path, filling in the real\n     * values. */\n    for (psub = path->first_subpath; psub != 0;) {\n        const segment *pseg = (const segment *)psub;\n        fixed ex = pseg->pt.x;\n        fixed ey = pseg->pt.y;\n        fixed ix = ex;\n        fixed iy = ey;\n\n        while ((pseg = pseg->next) != 0 &&\n               pseg->type != s_start\n            ) {\n            fixed sx = ex;\n            fixed sy = ey;\n            ex = pseg->pt.x;\n            ey = pseg->pt.y;\n\n            switch (pseg->type) {\n                default:\n                case s_start: /* Should never happen */\n                case s_dash:  /* We should never be seeing a dash here */\n                    assert(\"This should never happen\" == NULL);\n                    break;\n                case s_curve: {\n                    const curve_segment *const pcur = (const curve_segment *)pseg;\n                    int k = gx_curve_log2_samples(sx, sy, pcur, fixed_flat);\n\n                    mark_curve_top_tr(sx, sy, pcur->p1.x, pcur->p1.y, pcur->p2.x, pcur->p2.y, ex, ey, ibox.p.y, scanlines, table, index, &id, k);\n                    break;\n                }\n                case s_gap:\n                case s_line:\n                case s_line_close:\n                    if (sy != ey)\n                        mark_line_tr(sx, sy, ex, ey, ibox.p.y, scanlines, table, index, ++id);\n                    break;\n            }\n        }\n        /* And close any open segments */\n        if (iy != ey)\n            mark_line_tr(ex, ey, ix, iy, ibox.p.y, scanlines, table, index, ++id);\n        psub = (const subpath *)pseg;\n    }\n\n    /* Step 2 complete: We now have a complete list of intersection data in\n     * table, indexed by index. */\n\n    edgebuffer->base   = ibox.p.y;\n    edgebuffer->height = scanlines;\n    edgebuffer->xmin   = ibox.p.x;\n    edgebuffer->xmax   = ibox.q.x;\n    edgebuffer->index  = index;\n    edgebuffer->table  = table;\n\n#ifdef DEBUG_SCAN_CONVERTER\n    if (debugging_scan_converter) {\n        dlprintf(\"Before sorting:\\n\");\n        gx_edgebuffer_print_tr(edgebuffer);\n    }\n#endif\n\n    /* Step 4: Sort the intersects on x */\n    for (i=0; i < scanlines; i++) {\n        int *row = &table[index[i]];\n        int  rowlen = *row++;\n\n        /* Bubblesort short runs, qsort longer ones. */\n        /* FIXME: Verify the figure 6 below */\n        if (rowlen <= 6) {\n            int j, k;\n            for (j = 0; j < rowlen-1; j++) {\n                int * restrict t = &row[j<<1];\n                for (k = j+1; k < rowlen; k++) {\n                    int * restrict s = &row[k<<1];\n                    int tmp;\n                    if (t[0] < s[0])\n                        continue;\n                    if (t[0] == s[0]) {\n                        if (t[1] <= s[1])\n                            continue;\n                    } else\n                        tmp = t[0], t[0] = s[0], s[0] = tmp;\n                    tmp = t[1], t[1] = s[1], s[1] = tmp;\n                }\n            }\n        } else\n            qsort(row, rowlen, 2*sizeof(int), intcmp_tr);\n    }\n\n    return 0;\n}",
    "abstract_func": "int gx_scan_convert_tr(gx_device     * restrict VAR_0,\n                       gx_path       * restrict VAR_1,\n                 const gs_fixed_rect * restrict VAR_2,\n                       gx_edgebuffer * restrict VAR_3,\n                       fixed                    VAR_4)\n{\n    gs_fixed_rect  VAR_5;\n    int            VAR_6;\n    const subpath *VAR_7;\n    int           *VAR_8;\n    int           *VAR_9;\n    int            VAR_10;\n    int            VAR_11;\n    int            VAR_12 = 0;\n\n    VAR_3->index = NULL;\n    VAR_3->table = NULL;\n\n    /* COMMENT_0 */\n    if (VAR_1->first_subpath == NULL)\n        return 0;\n\n    VAR_11 = make_bbox(VAR_1, VAR_2, &VAR_5, VAR_13);\n    if (VAR_11 < 0)\n        return VAR_11;\n\n    if (VAR_5.q.y <= VAR_5.p.y)\n        return 0;\n\n    VAR_11 = make_table_tr(VAR_0, VAR_1, &VAR_5, &VAR_6, &VAR_8, &VAR_9);\n    if (VAR_11 < 0)\n        return VAR_11;\n\n    /* COMMENT_1 */\n                 \n    for (VAR_7 = VAR_1->first_subpath; VAR_7 != 0;) {\n        const segment *VAR_14 = (const segment *)VAR_7;\n        fixed VAR_15 = VAR_14->pt.x;\n        fixed VAR_16 = VAR_14->pt.y;\n        fixed VAR_17 = VAR_15;\n        fixed VAR_18 = VAR_16;\n\n        while ((VAR_14 = VAR_14->next) != 0 &&\n               VAR_14->type != VAR_19\n            ) {\n            fixed VAR_20 = VAR_15;\n            fixed VAR_21 = VAR_16;\n            VAR_15 = VAR_14->pt.x;\n            VAR_16 = VAR_14->pt.y;\n\n            switch (VAR_14->type) {\n                default:\n                case VAR_19: /* COMMENT_3 */\n                case VAR_22:  /* COMMENT_4 */\n                    assert(\"This should never happen\" == NULL);\n                    break;\n                case VAR_23: {\n                    const curve_segment *const VAR_24 = (const curve_segment *)VAR_14;\n                    int VAR_25 = gx_curve_log2_samples(VAR_20, VAR_21, VAR_24, VAR_4);\n\n                    mark_curve_top_tr(VAR_20, VAR_21, VAR_24->p1.x, VAR_24->p1.y, VAR_24->p2.x, VAR_24->p2.y, VAR_15, VAR_16, VAR_5.p.y, VAR_6, VAR_9, VAR_8, &VAR_12, VAR_25);\n                    break;\n                }\n                case VAR_26:\n                case VAR_27:\n                case VAR_28:\n                    if (VAR_21 != VAR_16)\n                        mark_line_tr(VAR_20, VAR_21, VAR_15, VAR_16, VAR_5.p.y, VAR_6, VAR_9, VAR_8, ++VAR_12);\n                    break;\n            }\n        }\n        /* COMMENT_5 */\n        if (VAR_18 != VAR_16)\n            mark_line_tr(VAR_15, VAR_16, VAR_17, VAR_18, VAR_5.p.y, VAR_6, VAR_9, VAR_8, ++VAR_12);\n        VAR_7 = (const subpath *)VAR_14;\n    }\n\n    /* COMMENT_6 */\n                                  \n\n    VAR_3->base   = VAR_5.p.y;\n    VAR_3->height = VAR_6;\n    VAR_3->xmin   = VAR_5.p.x;\n    VAR_3->xmax   = VAR_5.q.x;\n    VAR_3->index  = VAR_8;\n    VAR_3->table  = VAR_9;\n\n#ifdef VAR_29\n    if (VAR_30) {\n        dlprintf(\"Before sorting:\\n\");\n        gx_edgebuffer_print_tr(VAR_3);\n    }\n#endif\n\n    /* COMMENT_8 */\n    for (VAR_10=0; VAR_10 < VAR_6; VAR_10++) {\n        int *VAR_31 = &VAR_9[VAR_8[VAR_10]];\n        int  VAR_32 = *VAR_31++;\n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        if (VAR_32 <= 6) {\n            int VAR_33, VAR_25;\n            for (VAR_33 = 0; VAR_33 < VAR_32-1; VAR_33++) {\n                int * restrict VAR_34 = &VAR_31[VAR_33<<1];\n                for (VAR_25 = VAR_33+1; VAR_25 < VAR_32; VAR_25++) {\n                    int * restrict VAR_35 = &VAR_31[VAR_25<<1];\n                    int VAR_36;\n                    if (VAR_34[0] < VAR_35[0])\n                        continue;\n                    if (VAR_34[0] == VAR_35[0]) {\n                        if (VAR_34[1] <= VAR_35[1])\n                            continue;\n                    } else\n                        VAR_36 = VAR_34[0], VAR_34[0] = VAR_35[0], VAR_35[0] = VAR_36;\n                    VAR_36 = VAR_34[1], VAR_34[1] = VAR_35[1], VAR_35[1] = VAR_36;\n                }\n            }\n        } else\n            qsort(VAR_31, VAR_32, 2*sizeof(int), VAR_37);\n    }\n\n    return 0;\n}",
    "func_graph_path": "ArtifexSoftware/ghostpdl/8210a2864372723b49c526e2b102fdc00c9c4699/gxscanc.c/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -58,7 +58,7 @@\n                     const curve_segment *const pcur = (const curve_segment *)pseg;\n                     int k = gx_curve_log2_samples(sx, sy, pcur, fixed_flat);\n \n-                    mark_curve_tr(sx, sy, pcur->p1.x, pcur->p1.y, pcur->p2.x, pcur->p2.y, ex, ey, ibox.p.y, scanlines, table, index, &id, k);\n+                    mark_curve_top_tr(sx, sy, pcur->p1.x, pcur->p1.y, pcur->p2.x, pcur->p2.y, ex, ey, ibox.p.y, scanlines, table, index, &id, k);\n                     break;\n                 }\n                 case s_gap:",
    "diff_line_info": {
        "deleted_lines": [
            "                    mark_curve_tr(sx, sy, pcur->p1.x, pcur->p1.y, pcur->p2.x, pcur->p2.y, ex, ey, ibox.p.y, scanlines, table, index, &id, k);"
        ],
        "added_lines": [
            "                    mark_curve_top_tr(sx, sy, pcur->p1.x, pcur->p1.y, pcur->p2.x, pcur->p2.y, ex, ey, ibox.p.y, scanlines, table, index, &id, k);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}