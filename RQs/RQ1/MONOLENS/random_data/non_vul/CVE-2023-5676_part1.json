{
    "cve_id": "CVE-2023-5676",
    "cwe_ids": [
        "CWE-362"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "eclipse-openj9/openj9",
    "commit_msg": "Don't invoke shutdown signal handler until JVM init completes\n\nJVM init path: J9_CreateJavaVM.\nJVM exit paths: protectedDestroyJavaVM and exitJavaVM.\n\nA segfault or other side-effects can happen if the JVM init and\nexit paths execute concurrently.\n\nThe exit path can be taken if a shutdown signal is raised and the\nshutdown handler is invoked. JVM shutdown signals are SIGINT, SIGTERM\nand SIGHUP.\n\nPreventing invocation of the exit path from the shutdown signal handler\nuntil the JVM initialization completes resolves the above side-effects.\n\nRelated:\n- #17101\n- #17438\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>",
    "commit_hash": "d4dfa6c62270ea34fcc859355a66bc25b8175237",
    "git_url": "https://github.com/eclipse-openj9/openj9/commit/d4dfa6c62270ea34fcc859355a66bc25b8175237",
    "file_path": "runtime/vm/jvminit.c",
    "func_name": "predefinedHandlerWrapper",
    "func_before": "static UDATA\npredefinedHandlerWrapper(struct J9PortLibrary *portLibrary, U_32 gpType, void *gpInfo, void *userData)\n{\n\tJ9JavaVM *vm = (J9JavaVM *)userData;\n\tJ9JavaVMAttachArgs attachArgs = {0};\n\tJ9VMThread *vmThread = NULL;\n\tIDATA result = JNI_ERR;\n\tBOOLEAN shutdownStarted = FALSE;\n\tI_32 signal = 0;\n\tPORT_ACCESS_FROM_JAVAVM(vm);\n\n\tsignal = j9sig_map_portlib_signal_to_os_signal(gpType);\n\t/* Don't invoke handler if signal is 0 or negative, or if -Xrs or -Xrs:async is specified */\n\tif ((signal <= 0) || J9_ARE_ANY_BITS_SET(vm->sigFlags, J9_SIG_XRS_ASYNC)) {\n\t\treturn 1;\n\t}\n\n\t/* Don't invoke handler if JVM exit has started. */\n\tomrthread_monitor_enter(vm->runtimeFlagsMutex);\n\tif (J9_ARE_ANY_BITS_SET(vm->runtimeFlags, J9_RUNTIME_EXIT_STARTED)) {\n\t\tshutdownStarted = TRUE;\n\t}\n\tomrthread_monitor_exit(vm->runtimeFlagsMutex);\n\n\tif (shutdownStarted) {\n\t\treturn 1;\n\t}\n\n\tattachArgs.version = JNI_VERSION_1_8;\n\tattachArgs.name = \"JVM Signal Thread\";\n\tattachArgs.group = vm->systemThreadGroupRef;\n\n\t/* Attach current thread as a daemon thread */\n\tresult = internalAttachCurrentThread(vm, &vmThread, &attachArgs,\n\t\t\t\tJ9_PRIVATE_FLAGS_DAEMON_THREAD | J9_PRIVATE_FLAGS_SYSTEM_THREAD | J9_PRIVATE_FLAGS_ATTACHED_THREAD,\n\t\t\t\tomrthread_self());\n\n\tif (JNI_OK != result) {\n\t\t/* Thread couldn't be attached. So, we can't run Java code. */\n\t\treturn 1;\n\t}\n\n\t/* Run handler (Java code). */\n\tsignalDispatch(vmThread, signal);\n\n\tDetachCurrentThread((JavaVM *)vm);\n\n\treturn 0;\n}",
    "abstract_func_before": "static UDATA\npredefinedHandlerWrapper(struct J9PortLibrary *VAR_0, U_32 VAR_1, void *VAR_2, void *VAR_3)\n{\n\tJ9JavaVM *VAR_4 = (J9JavaVM *)VAR_3;\n\tJ9JavaVMAttachArgs VAR_5 = {0};\n\tJ9VMThread *VAR_6 = NULL;\n\tIDATA VAR_7 = VAR_8;\n\tBOOLEAN VAR_9 = FALSE;\n\tI_32 VAR_10 = 0;\n\tPORT_ACCESS_FROM_JAVAVM(VAR_4);\n\n\tVAR_10 = j9sig_map_portlib_signal_to_os_signal(VAR_1);\n\t/* COMMENT_0 */\n\tif ((VAR_10 <= 0) || J9_ARE_ANY_BITS_SET(VAR_4->sigFlags, VAR_11)) {\n\t\treturn 1;\n\t}\n\n\t/* COMMENT_1 */\n\tomrthread_monitor_enter(VAR_4->runtimeFlagsMutex);\n\tif (J9_ARE_ANY_BITS_SET(VAR_4->runtimeFlags, VAR_12)) {\n\t\tVAR_9 = TRUE;\n\t}\n\tomrthread_monitor_exit(VAR_4->runtimeFlagsMutex);\n\n\tif (VAR_9) {\n\t\treturn 1;\n\t}\n\n\tVAR_5.version = VAR_13;\n\tVAR_5.name = \"JVM Signal Thread\";\n\tVAR_5.group = VAR_4->systemThreadGroupRef;\n\n\t/* COMMENT_2 */\n\tVAR_7 = internalAttachCurrentThread(VAR_4, &VAR_6, &VAR_5,\n\t\t\t\tVAR_14 | VAR_15 | VAR_16,\n\t\t\t\tomrthread_self());\n\n\tif (VAR_17 != VAR_7) {\n\t\t/* COMMENT_3 */\n\t\treturn 1;\n\t}\n\n\t/* COMMENT_4 */\n\tsignalDispatch(VAR_6, VAR_10);\n\n\tDetachCurrentThread((JavaVM *)VAR_4);\n\n\treturn 0;\n}",
    "func_graph_path_before": "eclipse-openj9/openj9/d4dfa6c62270ea34fcc859355a66bc25b8175237/jvminit.c/vul/before/0.json",
    "func": "static UDATA\npredefinedHandlerWrapper(struct J9PortLibrary *portLibrary, U_32 gpType, void *gpInfo, void *userData)\n{\n\tJ9JavaVM *vm = (J9JavaVM *)userData;\n\tJ9JavaVMAttachArgs attachArgs = {0};\n\tJ9VMThread *vmThread = NULL;\n\tIDATA result = JNI_ERR;\n\tBOOLEAN invokeHandler = TRUE;\n\tI_32 signal = 0;\n\tU_32 runtimeFlags = 0;\n\tPORT_ACCESS_FROM_JAVAVM(vm);\n\n\tsignal = j9sig_map_portlib_signal_to_os_signal(gpType);\n\t/* Don't invoke handler if signal is 0 or negative, or if -Xrs or -Xrs:async is specified */\n\tif ((signal <= 0) || J9_ARE_ANY_BITS_SET(vm->sigFlags, J9_SIG_XRS_ASYNC)) {\n\t\treturn 1;\n\t}\n\n\t/* Don't invoke handler if JVM hasn't initialized or JVM exit has started. */\n\tissueReadBarrier();\n\truntimeFlags = vm->runtimeFlags;\n\tif (J9_ARE_NO_BITS_SET(runtimeFlags, J9_RUNTIME_INITIALIZED)\n\t|| J9_ARE_ANY_BITS_SET(runtimeFlags, J9_RUNTIME_EXIT_STARTED)\n\t) {\n\t\tinvokeHandler = FALSE;\n\t}\n\n\tif (!invokeHandler) {\n\t\treturn 1;\n\t}\n\n\tattachArgs.version = JNI_VERSION_1_8;\n\tattachArgs.name = \"JVM Signal Thread\";\n\tattachArgs.group = vm->systemThreadGroupRef;\n\n\t/* Attach current thread as a daemon thread */\n\tresult = internalAttachCurrentThread(vm, &vmThread, &attachArgs,\n\t\t\t\tJ9_PRIVATE_FLAGS_DAEMON_THREAD | J9_PRIVATE_FLAGS_SYSTEM_THREAD | J9_PRIVATE_FLAGS_ATTACHED_THREAD,\n\t\t\t\tomrthread_self());\n\n\tif (JNI_OK != result) {\n\t\t/* Thread couldn't be attached. So, we can't run Java code. */\n\t\treturn 1;\n\t}\n\n\t/* Run handler (Java code). */\n\tsignalDispatch(vmThread, signal);\n\n\tDetachCurrentThread((JavaVM *)vm);\n\n\treturn 0;\n}",
    "abstract_func": "static UDATA\npredefinedHandlerWrapper(struct J9PortLibrary *VAR_0, U_32 VAR_1, void *VAR_2, void *VAR_3)\n{\n\tJ9JavaVM *VAR_4 = (J9JavaVM *)VAR_3;\n\tJ9JavaVMAttachArgs VAR_5 = {0};\n\tJ9VMThread *VAR_6 = NULL;\n\tIDATA VAR_7 = VAR_8;\n\tBOOLEAN VAR_9 = TRUE;\n\tI_32 VAR_10 = 0;\n\tU_32 VAR_11 = 0;\n\tPORT_ACCESS_FROM_JAVAVM(VAR_4);\n\n\tVAR_10 = j9sig_map_portlib_signal_to_os_signal(VAR_1);\n\t/* COMMENT_0 */\n\tif ((VAR_10 <= 0) || J9_ARE_ANY_BITS_SET(VAR_4->sigFlags, VAR_12)) {\n\t\treturn 1;\n\t}\n\n\t/* COMMENT_1 */\n\tissueReadBarrier();\n\tVAR_11 = VAR_4->runtimeFlags;\n\tif (J9_ARE_NO_BITS_SET(VAR_11, VAR_13)\n\t|| J9_ARE_ANY_BITS_SET(VAR_11, VAR_14)\n\t) {\n\t\tVAR_9 = FALSE;\n\t}\n\n\tif (!VAR_9) {\n\t\treturn 1;\n\t}\n\n\tVAR_5.version = VAR_15;\n\tVAR_5.name = \"JVM Signal Thread\";\n\tVAR_5.group = VAR_4->systemThreadGroupRef;\n\n\t/* COMMENT_2 */\n\tVAR_7 = internalAttachCurrentThread(VAR_4, &VAR_6, &VAR_5,\n\t\t\t\tVAR_16 | VAR_17 | VAR_18,\n\t\t\t\tomrthread_self());\n\n\tif (VAR_19 != VAR_7) {\n\t\t/* COMMENT_3 */\n\t\treturn 1;\n\t}\n\n\t/* COMMENT_4 */\n\tsignalDispatch(VAR_6, VAR_10);\n\n\tDetachCurrentThread((JavaVM *)VAR_4);\n\n\treturn 0;\n}",
    "func_graph_path": "eclipse-openj9/openj9/d4dfa6c62270ea34fcc859355a66bc25b8175237/jvminit.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,9 @@\n \tJ9JavaVMAttachArgs attachArgs = {0};\n \tJ9VMThread *vmThread = NULL;\n \tIDATA result = JNI_ERR;\n-\tBOOLEAN shutdownStarted = FALSE;\n+\tBOOLEAN invokeHandler = TRUE;\n \tI_32 signal = 0;\n+\tU_32 runtimeFlags = 0;\n \tPORT_ACCESS_FROM_JAVAVM(vm);\n \n \tsignal = j9sig_map_portlib_signal_to_os_signal(gpType);\n@@ -15,14 +16,16 @@\n \t\treturn 1;\n \t}\n \n-\t/* Don't invoke handler if JVM exit has started. */\n-\tomrthread_monitor_enter(vm->runtimeFlagsMutex);\n-\tif (J9_ARE_ANY_BITS_SET(vm->runtimeFlags, J9_RUNTIME_EXIT_STARTED)) {\n-\t\tshutdownStarted = TRUE;\n+\t/* Don't invoke handler if JVM hasn't initialized or JVM exit has started. */\n+\tissueReadBarrier();\n+\truntimeFlags = vm->runtimeFlags;\n+\tif (J9_ARE_NO_BITS_SET(runtimeFlags, J9_RUNTIME_INITIALIZED)\n+\t|| J9_ARE_ANY_BITS_SET(runtimeFlags, J9_RUNTIME_EXIT_STARTED)\n+\t) {\n+\t\tinvokeHandler = FALSE;\n \t}\n-\tomrthread_monitor_exit(vm->runtimeFlagsMutex);\n \n-\tif (shutdownStarted) {\n+\tif (!invokeHandler) {\n \t\treturn 1;\n \t}\n ",
    "diff_line_info": {
        "deleted_lines": [
            "\tBOOLEAN shutdownStarted = FALSE;",
            "\t/* Don't invoke handler if JVM exit has started. */",
            "\tomrthread_monitor_enter(vm->runtimeFlagsMutex);",
            "\tif (J9_ARE_ANY_BITS_SET(vm->runtimeFlags, J9_RUNTIME_EXIT_STARTED)) {",
            "\t\tshutdownStarted = TRUE;",
            "\tomrthread_monitor_exit(vm->runtimeFlagsMutex);",
            "\tif (shutdownStarted) {"
        ],
        "added_lines": [
            "\tBOOLEAN invokeHandler = TRUE;",
            "\tU_32 runtimeFlags = 0;",
            "\t/* Don't invoke handler if JVM hasn't initialized or JVM exit has started. */",
            "\tissueReadBarrier();",
            "\truntimeFlags = vm->runtimeFlags;",
            "\tif (J9_ARE_NO_BITS_SET(runtimeFlags, J9_RUNTIME_INITIALIZED)",
            "\t|| J9_ARE_ANY_BITS_SET(runtimeFlags, J9_RUNTIME_EXIT_STARTED)",
            "\t) {",
            "\t\tinvokeHandler = FALSE;",
            "\tif (!invokeHandler) {"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/eclipse-openj9/openj9/pull/18085",
    "description": "JVM init path: `J9_CreateJavaVM`.\r\nJVM exit paths: `protectedDestroyJavaVM` and `exitJavaVM`.\r\n\r\nA segfault or other side-effects can happen if the JVM init and\r\nexit paths execute concurrently.\r\n\r\nThe exit path can be taken if a shutdown signal is raised and the\r\nshutdown handler is invoked. JVM shutdown signals are `SIGINT`, `SIGTERM`\r\nand `SIGHUP`.\r\n\r\nPreventing invocation of the exit path from the shutdown signal handler\r\nuntil the JVM initialization completes resolves the above side-effects.\r\n\r\nRelated:\r\n- #17101\r\n- #17438"
}