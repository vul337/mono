{
    "cve_id": "CVE-2022-2056",
    "cwe_ids": [
        "CWE-369"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "libtiff",
    "commit_msg": "Fix FPE errors in tiffcrop (#415, #427, and #428)\n",
    "commit_hash": "ab6e93f10f7df01a43aacd51caa1ef6f61cf0ce5",
    "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/ab6e93f10f7df01a43aacd51caa1ef6f61cf0ce5",
    "file_path": "tools/tiffcrop.c",
    "func_name": "computeOutputPixelOffsets",
    "func_before": "static int\ncomputeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,\n                           struct pagedef *page, struct pageseg *sections,\n                           struct dump_opts* dump)\n  {\n  double scale;\n  double pwidth, plength;          /* Output page width and length in user units*/\n  uint32_t iwidth, ilength;          /* Input image width and length in pixels*/\n  uint32_t owidth, olength;          /* Output image width and length in pixels*/\n  uint32_t orows, ocols;             /* rows and cols for output */\n  uint32_t hmargin, vmargin;         /* Horizontal and vertical margins */\n  uint32_t x1, x2, y1, y2, line_bytes;\n  /* unsigned int orientation; */\n  uint32_t i, j, k;\n \n  scale = 1.0;\n  if (page->res_unit == RESUNIT_NONE)\n    page->res_unit = image->res_unit;\n\n  switch (image->res_unit) {\n    case RESUNIT_CENTIMETER:\n         if (page->res_unit == RESUNIT_INCH)\n\t   scale = 1.0/2.54;\n\t break;\n    case RESUNIT_INCH:\n\t if (page->res_unit == RESUNIT_CENTIMETER)\n\t     scale = 2.54;\n\t break;\n    case RESUNIT_NONE: /* Dimensions in pixels */\n    default:\n    break;\n    }\n\n  /* get width, height, resolutions of input image selection */\n  if (crop->combined_width > 0)\n    iwidth = crop->combined_width;\n  else\n    iwidth = image->width;\n  if (crop->combined_length > 0)\n    ilength = crop->combined_length;\n  else\n    ilength = image->length;\n\n  if (page->hres <= 1.0)\n    page->hres = image->xres;\n  if (page->vres <= 1.0)\n    page->vres = image->yres;\n\n  if ((page->hres < 1.0) || (page->vres < 1.0))\n    {\n    TIFFError(\"computeOutputPixelOffsets\",\n    \"Invalid horizontal or vertical resolution specified or read from input image\");\n    return (1);\n    }\n\n  /* If no page sizes are being specified, we just use the input image size to\n   * calculate maximum margins that can be taken from image.\n   */\n  if (page->width <= 0)\n    pwidth = iwidth;\n  else\n    pwidth = page->width;\n\n  if (page->length <= 0)\n    plength = ilength;\n  else\n    plength = page->length;\n\n  if (dump->debug)\n    {\n    TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n                   \"Hmargin: %3.2f, Vmargin: %3.2f\",\n\t     page->name, page->vres, page->hres,\n             page->hmargin, page->vmargin);\n    TIFFError(\"\", \"Res_unit: %\"PRIu16\", Scale: %3.2f, Page width: %3.2f, length: %3.2f\",\n           page->res_unit, scale, pwidth, plength);\n    }\n\n  /* compute margins at specified unit and resolution */\n  if (page->mode & PAGE_MODE_MARGINS)\n    {\n    if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER)\n      { /* inches or centimeters specified */\n      hmargin = (uint32_t)(page->hmargin * scale * page->hres * ((image->bps + 7) / 8));\n      vmargin = (uint32_t)(page->vmargin * scale * page->vres * ((image->bps + 7) / 8));\n      }\n    else\n      { /* Otherwise user has specified pixels as reference unit */\n      hmargin = (uint32_t)(page->hmargin * scale * ((image->bps + 7) / 8));\n      vmargin = (uint32_t)(page->vmargin * scale * ((image->bps + 7) / 8));\n      }\n\n    if ((hmargin * 2.0) > (pwidth * page->hres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined left and right margins exceed page width\");\n      hmargin = (uint32_t) 0;\n      return (-1);\n      }\n    if ((vmargin * 2.0) > (plength * page->vres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined top and bottom margins exceed page length\"); \n      vmargin = (uint32_t) 0;\n      return (-1);\n      }\n    }\n  else\n    {\n    hmargin = 0;\n    vmargin = 0;\n    }\n\n  if (page->mode & PAGE_MODE_ROWSCOLS )\n    {\n    /* Maybe someday but not for now */\n    if (page->mode & PAGE_MODE_MARGINS)\n      TIFFError(\"computeOutputPixelOffsets\", \n      \"Output margins cannot be specified with rows and columns\"); \n\n    owidth  = TIFFhowmany(iwidth, page->cols);\n    olength = TIFFhowmany(ilength, page->rows);\n    }\n  else\n    {\n    if (page->mode & PAGE_MODE_PAPERSIZE )\n      {\n      owidth  = (uint32_t)((pwidth * page->hres) - (hmargin * 2));\n      olength = (uint32_t)((plength * page->vres) - (vmargin * 2));\n      }\n    else\n      {\n      owidth = (uint32_t)(iwidth - (hmargin * 2 * page->hres));\n      olength = (uint32_t)(ilength - (vmargin * 2 * page->vres));\n      }\n    }\n\n  if (owidth > iwidth)\n    owidth = iwidth;\n  if (olength > ilength)\n    olength = ilength;\n\n  /* Compute the number of pages required for Portrait or Landscape */\n  switch (page->orient)\n    {\n    case ORIENTATION_NONE:\n    case ORIENTATION_PORTRAIT:\n         ocols = TIFFhowmany(iwidth, owidth);\n         orows = TIFFhowmany(ilength, olength);\n         /* orientation = ORIENTATION_PORTRAIT; */\n         break;\n\n    case ORIENTATION_LANDSCAPE:\n         ocols = TIFFhowmany(iwidth, olength);\n         orows = TIFFhowmany(ilength, owidth);\n         x1 = olength;\n         olength = owidth;\n         owidth = x1;\n         /* orientation = ORIENTATION_LANDSCAPE; */\n         break;\n\n    case ORIENTATION_AUTO:\n    default:\n         x1 = TIFFhowmany(iwidth, owidth);\n         x2 = TIFFhowmany(ilength, olength); \n         y1 = TIFFhowmany(iwidth, olength);\n         y2 = TIFFhowmany(ilength, owidth); \n\n         if ( (x1 * x2) < (y1 * y2))\n           { /* Portrait */\n           ocols = x1;\n           orows = x2;\n           /* orientation = ORIENTATION_PORTRAIT; */\n\t   }\n         else\n           { /* Landscape */\n           ocols = y1;\n           orows = y2;\n           x1 = olength;\n           olength = owidth;\n           owidth = x1;\n           /* orientation = ORIENTATION_LANDSCAPE; */\n           }\n    }\n\n  if (ocols < 1)\n    ocols = 1;\n  if (orows < 1)\n    orows = 1;\n\n  /* Always return rows and cols from calcuation above.\n   * (correct values needed external to this function)\n   * Warn, if user input settings has been changed.\n   */\n\n  if ((page->rows > 0) && (page->rows != orows)) {\n    TIFFError(\"computeOutputPixelOffsets\",\n          \"Number of user input section rows down (%\"PRIu32\") was changed to (%\"PRIu32\")\", page->rows, orows);\n  }\n  page->rows = orows;\n  if ((page->cols > 0) && (page->cols != ocols)) {\n    TIFFError(\"computeOutputPixelOffsets\",\n        \"Number of user input section cols across (%\"PRIu32\") was changed to (%\"PRIu32\")\", page->cols, ocols);\n  }\n  page->cols = ocols;\n\n  line_bytes = TIFFhowmany8(owidth * image->spp * image->bps);\n\n  if ((orows * ocols) > MAX_SECTIONS)\n   {\n   TIFFError(\"computeOutputPixelOffsets\",\n\t     \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");\n   return (-1);\n   }\n\n  /* build the list of offsets for each output section */\n  for (k = 0, i = 0; i < orows; i++)\n    {\n    y1 = (uint32_t)(olength * i);\n    y2 = (uint32_t)(olength * (i + 1) - 1);\n    if (y2 >= ilength)\n      y2 = ilength - 1;\n    for (j = 0; (j < ocols) && (k < MAX_SECTIONS); j++, k++)\n      {\n      x1 = (uint32_t)(owidth * j);\n      x2 = (uint32_t)(owidth * (j + 1) - 1);\n      if (x2 >= iwidth)\n        x2 = iwidth - 1;\n      sections[k].x1 = x1;\n      sections[k].x2 = x2;\n      sections[k].y1 = y1;\n      sections[k].y2 = y2;\n      sections[k].buffsize = line_bytes * olength;\n      sections[k].position = k + 1;\n      sections[k].total = orows * ocols;\n      } \n    } \n  return (0);\n  }",
    "abstract_func_before": "static int\ncomputeOutputPixelOffsets (struct crop_mask *VAR_0, struct image_data *VAR_1,\n                           struct pagedef *VAR_2, struct pageseg *VAR_3,\n                           struct dump_opts* VAR_4)\n  {\n  double VAR_5;\n  double VAR_6, VAR_7;          /* COMMENT_0 */\n  uint32_t VAR_8, VAR_9;          /* COMMENT_1 */\n  uint32_t VAR_10, VAR_11;          /* COMMENT_2 */\n  uint32_t VAR_12, VAR_13;             /* COMMENT_3 */\n  uint32_t VAR_14, VAR_15;         /* COMMENT_4 */\n  uint32_t VAR_16, VAR_17, VAR_18, VAR_19, VAR_20;\n  /* COMMENT_5 */\n  uint32_t VAR_21, VAR_22, VAR_23;\n \n  VAR_5 = 1.0;\n  if (VAR_2->res_unit == VAR_24)\n    VAR_2->res_unit = VAR_1->res_unit;\n\n  switch (VAR_1->res_unit) {\n    case VAR_25:\n         if (VAR_2->res_unit == VAR_26)\n\t   VAR_5 = 1.0/2.54;\n\t break;\n    case VAR_26:\n\t if (VAR_2->res_unit == VAR_25)\n\t     VAR_5 = 2.54;\n\t break;\n    case VAR_24: /* COMMENT_6 */\n    default:\n    break;\n    }\n\n  /* COMMENT_7 */\n  if (VAR_0->combined_width > 0)\n    VAR_8 = VAR_0->combined_width;\n  else\n    VAR_8 = VAR_1->width;\n  if (VAR_0->combined_length > 0)\n    VAR_9 = VAR_0->combined_length;\n  else\n    VAR_9 = VAR_1->length;\n\n  if (VAR_2->hres <= 1.0)\n    VAR_2->hres = VAR_1->xres;\n  if (VAR_2->vres <= 1.0)\n    VAR_2->vres = VAR_1->yres;\n\n  if ((VAR_2->hres < 1.0) || (VAR_2->vres < 1.0))\n    {\n    TIFFError(\"computeOutputPixelOffsets\",\n    \"Invalid horizontal or vertical resolution specified or read from input image\");\n    return (1);\n    }\n\n  /* COMMENT_8 */\n                                                            \n     \n  if (VAR_2->width <= 0)\n    VAR_6 = VAR_8;\n  else\n    VAR_6 = VAR_2->width;\n\n  if (VAR_2->length <= 0)\n    VAR_7 = VAR_9;\n  else\n    VAR_7 = VAR_2->length;\n\n  if (VAR_4->debug)\n    {\n    TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n                   \"Hmargin: %3.2f, Vmargin: %3.2f\",\n\t     VAR_2->name, VAR_2->vres, VAR_2->hres,\n             VAR_2->hmargin, VAR_2->vmargin);\n    TIFFError(\"\", \"Res_unit: %\"VAR_27\", Scale: %3.2f, Page width: %3.2f, length: %3.2f\",\n           VAR_2->res_unit, VAR_5, VAR_6, VAR_7);\n    }\n\n  /* COMMENT_11 */\n  if (VAR_2->mode & VAR_28)\n    {\n    if (VAR_2->res_unit == VAR_26 || VAR_2->res_unit == VAR_25)\n      { /* COMMENT_12 */\n      VAR_14 = (uint32_t)(VAR_2->hmargin * VAR_5 * VAR_2->hres * ((VAR_1->bps + 7) / 8));\n      VAR_15 = (uint32_t)(VAR_2->vmargin * VAR_5 * VAR_2->vres * ((VAR_1->bps + 7) / 8));\n      }\n    else\n      { /* COMMENT_13 */\n      VAR_14 = (uint32_t)(VAR_2->hmargin * VAR_5 * ((VAR_1->bps + 7) / 8));\n      VAR_15 = (uint32_t)(VAR_2->vmargin * VAR_5 * ((VAR_1->bps + 7) / 8));\n      }\n\n    if ((VAR_14 * 2.0) > (VAR_6 * VAR_2->hres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined left and right margins exceed page width\");\n      VAR_14 = (uint32_t) 0;\n      return (-1);\n      }\n    if ((VAR_15 * 2.0) > (VAR_7 * VAR_2->vres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined top and bottom margins exceed page length\"); \n      VAR_15 = (uint32_t) 0;\n      return (-1);\n      }\n    }\n  else\n    {\n    VAR_14 = 0;\n    VAR_15 = 0;\n    }\n\n  if (VAR_2->mode & VAR_29 )\n    {\n    /* COMMENT_14 */\n    if (VAR_2->mode & VAR_28)\n      TIFFError(\"computeOutputPixelOffsets\", \n      \"Output margins cannot be specified with rows and columns\"); \n\n    VAR_10  = TIFFhowmany(VAR_8, VAR_2->cols);\n    VAR_11 = TIFFhowmany(VAR_9, VAR_2->rows);\n    }\n  else\n    {\n    if (VAR_2->mode & VAR_30 )\n      {\n      VAR_10  = (uint32_t)((VAR_6 * VAR_2->hres) - (VAR_14 * 2));\n      VAR_11 = (uint32_t)((VAR_7 * VAR_2->vres) - (VAR_15 * 2));\n      }\n    else\n      {\n      VAR_10 = (uint32_t)(VAR_8 - (VAR_14 * 2 * VAR_2->hres));\n      VAR_11 = (uint32_t)(VAR_9 - (VAR_15 * 2 * VAR_2->vres));\n      }\n    }\n\n  if (VAR_10 > VAR_8)\n    VAR_10 = VAR_8;\n  if (VAR_11 > VAR_9)\n    VAR_11 = VAR_9;\n\n  /* COMMENT_15 */\n  switch (VAR_2->orient)\n    {\n    case VAR_31:\n    case VAR_32:\n         VAR_13 = TIFFhowmany(VAR_8, VAR_10);\n         VAR_12 = TIFFhowmany(VAR_9, VAR_11);\n         /* COMMENT_16 */\n         break;\n\n    case VAR_33:\n         VAR_13 = TIFFhowmany(VAR_8, VAR_11);\n         VAR_12 = TIFFhowmany(VAR_9, VAR_10);\n         VAR_16 = VAR_11;\n         VAR_11 = VAR_10;\n         VAR_10 = VAR_16;\n         /* COMMENT_17 */\n         break;\n\n    case VAR_34:\n    default:\n         VAR_16 = TIFFhowmany(VAR_8, VAR_10);\n         VAR_17 = TIFFhowmany(VAR_9, VAR_11); \n         VAR_18 = TIFFhowmany(VAR_8, VAR_11);\n         VAR_19 = TIFFhowmany(VAR_9, VAR_10); \n\n         if ( (VAR_16 * VAR_17) < (VAR_18 * VAR_19))\n           { /* COMMENT_18 */\n           VAR_13 = VAR_16;\n           VAR_12 = VAR_17;\n           /* COMMENT_16 */\n\t   }\n         else\n           { /* COMMENT_19 */\n           VAR_13 = VAR_18;\n           VAR_12 = VAR_19;\n           VAR_16 = VAR_11;\n           VAR_11 = VAR_10;\n           VAR_10 = VAR_16;\n           /* COMMENT_17 */\n           }\n    }\n\n  if (VAR_13 < 1)\n    VAR_13 = 1;\n  if (VAR_12 < 1)\n    VAR_12 = 1;\n\n  /* COMMENT_20 */\n                                                      \n                                                   \n     \n\n  if ((VAR_2->rows > 0) && (VAR_2->rows != VAR_12)) {\n    TIFFError(\"computeOutputPixelOffsets\",\n          \"Number of user input section rows down (%\"VAR_35\") was changed to (%\"VAR_35\")\", VAR_2->rows, VAR_12);\n  }\n  VAR_2->rows = VAR_12;\n  if ((VAR_2->cols > 0) && (VAR_2->cols != VAR_13)) {\n    TIFFError(\"computeOutputPixelOffsets\",\n        \"Number of user input section cols across (%\"VAR_35\") was changed to (%\"VAR_35\")\", VAR_2->cols, VAR_13);\n  }\n  VAR_2->cols = VAR_13;\n\n  VAR_20 = TIFFhowmany8(VAR_10 * VAR_1->spp * VAR_1->bps);\n\n  if ((VAR_12 * VAR_13) > VAR_36)\n   {\n   TIFFError(\"computeOutputPixelOffsets\",\n\t     \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");\n   return (-1);\n   }\n\n  /* COMMENT_24 */\n  for (VAR_23 = 0, VAR_21 = 0; VAR_21 < VAR_12; VAR_21++)\n    {\n    VAR_18 = (uint32_t)(VAR_11 * VAR_21);\n    VAR_19 = (uint32_t)(VAR_11 * (VAR_21 + 1) - 1);\n    if (VAR_19 >= VAR_9)\n      VAR_19 = VAR_9 - 1;\n    for (VAR_22 = 0; (VAR_22 < VAR_13) && (VAR_23 < VAR_36); VAR_22++, VAR_23++)\n      {\n      VAR_16 = (uint32_t)(VAR_10 * VAR_22);\n      VAR_17 = (uint32_t)(VAR_10 * (VAR_22 + 1) - 1);\n      if (VAR_17 >= VAR_8)\n        VAR_17 = VAR_8 - 1;\n      VAR_3[VAR_23].x1 = VAR_16;\n      VAR_3[VAR_23].x2 = VAR_17;\n      VAR_3[VAR_23].y1 = VAR_18;\n      VAR_3[VAR_23].y2 = VAR_19;\n      VAR_3[VAR_23].buffsize = VAR_20 * VAR_11;\n      VAR_3[VAR_23].position = VAR_23 + 1;\n      VAR_3[VAR_23].total = VAR_12 * VAR_13;\n      } \n    } \n  return (0);\n  }",
    "func_graph_path_before": "libtiff/ab6e93f10f7df01a43aacd51caa1ef6f61cf0ce5/tiffcrop.c/vul/before/1.json",
    "func": "static int\ncomputeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,\n                           struct pagedef *page, struct pageseg *sections,\n                           struct dump_opts* dump)\n  {\n  double scale;\n  double pwidth, plength;          /* Output page width and length in user units*/\n  uint32_t iwidth, ilength;          /* Input image width and length in pixels*/\n  uint32_t owidth, olength;          /* Output image width and length in pixels*/\n  uint32_t orows, ocols;             /* rows and cols for output */\n  uint32_t hmargin, vmargin;         /* Horizontal and vertical margins */\n  uint32_t x1, x2, y1, y2, line_bytes;\n  /* unsigned int orientation; */\n  uint32_t i, j, k;\n \n  scale = 1.0;\n  if (page->res_unit == RESUNIT_NONE)\n    page->res_unit = image->res_unit;\n\n  switch (image->res_unit) {\n    case RESUNIT_CENTIMETER:\n         if (page->res_unit == RESUNIT_INCH)\n\t   scale = 1.0/2.54;\n\t break;\n    case RESUNIT_INCH:\n\t if (page->res_unit == RESUNIT_CENTIMETER)\n\t     scale = 2.54;\n\t break;\n    case RESUNIT_NONE: /* Dimensions in pixels */\n    default:\n    break;\n    }\n\n  /* get width, height, resolutions of input image selection */\n  if (crop->combined_width > 0)\n    iwidth = crop->combined_width;\n  else\n    iwidth = image->width;\n  if (crop->combined_length > 0)\n    ilength = crop->combined_length;\n  else\n    ilength = image->length;\n\n  if (page->hres <= 1.0)\n    page->hres = image->xres;\n  if (page->vres <= 1.0)\n    page->vres = image->yres;\n\n  if ((page->hres < 1.0) || (page->vres < 1.0))\n    {\n    TIFFError(\"computeOutputPixelOffsets\",\n    \"Invalid horizontal or vertical resolution specified or read from input image\");\n    return (1);\n    }\n\n  /* If no page sizes are being specified, we just use the input image size to\n   * calculate maximum margins that can be taken from image.\n   */\n  if (page->width <= 0)\n    pwidth = iwidth;\n  else\n    pwidth = page->width;\n\n  if (page->length <= 0)\n    plength = ilength;\n  else\n    plength = page->length;\n\n  if (dump->debug)\n    {\n    TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n                   \"Hmargin: %3.2f, Vmargin: %3.2f\",\n\t     page->name, page->vres, page->hres,\n             page->hmargin, page->vmargin);\n    TIFFError(\"\", \"Res_unit: %\"PRIu16\", Scale: %3.2f, Page width: %3.2f, length: %3.2f\",\n           page->res_unit, scale, pwidth, plength);\n    }\n\n  /* compute margins at specified unit and resolution */\n  if (page->mode & PAGE_MODE_MARGINS)\n    {\n    if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER)\n      { /* inches or centimeters specified */\n      hmargin = _TIFFClampDoubleToUInt32(page->hmargin * scale * page->hres * ((image->bps + 7) / 8));\n      vmargin = _TIFFClampDoubleToUInt32(page->vmargin * scale * page->vres * ((image->bps + 7) / 8));\n      }\n    else\n      { /* Otherwise user has specified pixels as reference unit */\n      hmargin = _TIFFClampDoubleToUInt32(page->hmargin * scale * ((image->bps + 7) / 8));\n      vmargin = _TIFFClampDoubleToUInt32(page->vmargin * scale * ((image->bps + 7) / 8));\n      }\n\n    if ((hmargin * 2.0) > (pwidth * page->hres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined left and right margins exceed page width\");\n      hmargin = (uint32_t) 0;\n      return (-1);\n      }\n    if ((vmargin * 2.0) > (plength * page->vres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined top and bottom margins exceed page length\"); \n      vmargin = (uint32_t) 0;\n      return (-1);\n      }\n    }\n  else\n    {\n    hmargin = 0;\n    vmargin = 0;\n    }\n\n  if (page->mode & PAGE_MODE_ROWSCOLS )\n    {\n    /* Maybe someday but not for now */\n    if (page->mode & PAGE_MODE_MARGINS)\n      TIFFError(\"computeOutputPixelOffsets\", \n      \"Output margins cannot be specified with rows and columns\"); \n\n    owidth  = TIFFhowmany(iwidth, page->cols);\n    olength = TIFFhowmany(ilength, page->rows);\n    }\n  else\n    {\n    if (page->mode & PAGE_MODE_PAPERSIZE )\n      {\n      owidth  = _TIFFClampDoubleToUInt32((pwidth * page->hres) - (hmargin * 2));\n      olength = _TIFFClampDoubleToUInt32((plength * page->vres) - (vmargin * 2));\n      }\n    else\n      {\n      owidth = _TIFFClampDoubleToUInt32(iwidth - (hmargin * 2 * page->hres));\n      olength = _TIFFClampDoubleToUInt32(ilength - (vmargin * 2 * page->vres));\n      }\n    }\n\n  if (owidth > iwidth)\n    owidth = iwidth;\n  if (olength > ilength)\n    olength = ilength;\n\n  if (owidth == 0 || olength == 0)\n  {\n    TIFFError(\"computeOutputPixelOffsets\", \"Integer overflow when calculating the number of pages\");\n\t  exit(EXIT_FAILURE);\n  }\n\n  /* Compute the number of pages required for Portrait or Landscape */\n  switch (page->orient)\n    {\n    case ORIENTATION_NONE:\n    case ORIENTATION_PORTRAIT:\n         ocols = TIFFhowmany(iwidth, owidth);\n         orows = TIFFhowmany(ilength, olength);\n         /* orientation = ORIENTATION_PORTRAIT; */\n         break;\n\n    case ORIENTATION_LANDSCAPE:\n         ocols = TIFFhowmany(iwidth, olength);\n         orows = TIFFhowmany(ilength, owidth);\n         x1 = olength;\n         olength = owidth;\n         owidth = x1;\n         /* orientation = ORIENTATION_LANDSCAPE; */\n         break;\n\n    case ORIENTATION_AUTO:\n    default:\n         x1 = TIFFhowmany(iwidth, owidth);\n         x2 = TIFFhowmany(ilength, olength); \n         y1 = TIFFhowmany(iwidth, olength);\n         y2 = TIFFhowmany(ilength, owidth); \n\n         if ( (x1 * x2) < (y1 * y2))\n           { /* Portrait */\n           ocols = x1;\n           orows = x2;\n           /* orientation = ORIENTATION_PORTRAIT; */\n\t   }\n         else\n           { /* Landscape */\n           ocols = y1;\n           orows = y2;\n           x1 = olength;\n           olength = owidth;\n           owidth = x1;\n           /* orientation = ORIENTATION_LANDSCAPE; */\n           }\n    }\n\n  if (ocols < 1)\n    ocols = 1;\n  if (orows < 1)\n    orows = 1;\n\n  /* Always return rows and cols from calcuation above.\n   * (correct values needed external to this function)\n   * Warn, if user input settings has been changed.\n   */\n\n  if ((page->rows > 0) && (page->rows != orows)) {\n    TIFFError(\"computeOutputPixelOffsets\",\n          \"Number of user input section rows down (%\"PRIu32\") was changed to (%\"PRIu32\")\", page->rows, orows);\n  }\n  page->rows = orows;\n  if ((page->cols > 0) && (page->cols != ocols)) {\n    TIFFError(\"computeOutputPixelOffsets\",\n        \"Number of user input section cols across (%\"PRIu32\") was changed to (%\"PRIu32\")\", page->cols, ocols);\n  }\n  page->cols = ocols;\n\n  line_bytes = TIFFhowmany8(owidth * image->spp * image->bps);\n\n  if ((orows * ocols) > MAX_SECTIONS)\n   {\n   TIFFError(\"computeOutputPixelOffsets\",\n\t     \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");\n   return (-1);\n   }\n\n  /* build the list of offsets for each output section */\n  for (k = 0, i = 0; i < orows; i++)\n    {\n    y1 = (uint32_t)(olength * i);\n    y2 = (uint32_t)(olength * (i + 1) - 1);\n    if (y2 >= ilength)\n      y2 = ilength - 1;\n    for (j = 0; (j < ocols) && (k < MAX_SECTIONS); j++, k++)\n      {\n      x1 = (uint32_t)(owidth * j);\n      x2 = (uint32_t)(owidth * (j + 1) - 1);\n      if (x2 >= iwidth)\n        x2 = iwidth - 1;\n      sections[k].x1 = x1;\n      sections[k].x2 = x2;\n      sections[k].y1 = y1;\n      sections[k].y2 = y2;\n      sections[k].buffsize = line_bytes * olength;\n      sections[k].position = k + 1;\n      sections[k].total = orows * ocols;\n      } \n    } \n  return (0);\n  }",
    "abstract_func": "static int\ncomputeOutputPixelOffsets (struct crop_mask *VAR_0, struct image_data *VAR_1,\n                           struct pagedef *VAR_2, struct pageseg *VAR_3,\n                           struct dump_opts* VAR_4)\n  {\n  double VAR_5;\n  double VAR_6, VAR_7;          /* COMMENT_0 */\n  uint32_t VAR_8, VAR_9;          /* COMMENT_1 */\n  uint32_t VAR_10, VAR_11;          /* COMMENT_2 */\n  uint32_t VAR_12, VAR_13;             /* COMMENT_3 */\n  uint32_t VAR_14, VAR_15;         /* COMMENT_4 */\n  uint32_t VAR_16, VAR_17, VAR_18, VAR_19, VAR_20;\n  /* COMMENT_5 */\n  uint32_t VAR_21, VAR_22, VAR_23;\n \n  VAR_5 = 1.0;\n  if (VAR_2->res_unit == VAR_24)\n    VAR_2->res_unit = VAR_1->res_unit;\n\n  switch (VAR_1->res_unit) {\n    case VAR_25:\n         if (VAR_2->res_unit == VAR_26)\n\t   VAR_5 = 1.0/2.54;\n\t break;\n    case VAR_26:\n\t if (VAR_2->res_unit == VAR_25)\n\t     VAR_5 = 2.54;\n\t break;\n    case VAR_24: /* COMMENT_6 */\n    default:\n    break;\n    }\n\n  /* COMMENT_7 */\n  if (VAR_0->combined_width > 0)\n    VAR_8 = VAR_0->combined_width;\n  else\n    VAR_8 = VAR_1->width;\n  if (VAR_0->combined_length > 0)\n    VAR_9 = VAR_0->combined_length;\n  else\n    VAR_9 = VAR_1->length;\n\n  if (VAR_2->hres <= 1.0)\n    VAR_2->hres = VAR_1->xres;\n  if (VAR_2->vres <= 1.0)\n    VAR_2->vres = VAR_1->yres;\n\n  if ((VAR_2->hres < 1.0) || (VAR_2->vres < 1.0))\n    {\n    TIFFError(\"computeOutputPixelOffsets\",\n    \"Invalid horizontal or vertical resolution specified or read from input image\");\n    return (1);\n    }\n\n  /* COMMENT_8 */\n                                                            \n     \n  if (VAR_2->width <= 0)\n    VAR_6 = VAR_8;\n  else\n    VAR_6 = VAR_2->width;\n\n  if (VAR_2->length <= 0)\n    VAR_7 = VAR_9;\n  else\n    VAR_7 = VAR_2->length;\n\n  if (VAR_4->debug)\n    {\n    TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n                   \"Hmargin: %3.2f, Vmargin: %3.2f\",\n\t     VAR_2->name, VAR_2->vres, VAR_2->hres,\n             VAR_2->hmargin, VAR_2->vmargin);\n    TIFFError(\"\", \"Res_unit: %\"VAR_27\", Scale: %3.2f, Page width: %3.2f, length: %3.2f\",\n           VAR_2->res_unit, VAR_5, VAR_6, VAR_7);\n    }\n\n  /* COMMENT_11 */\n  if (VAR_2->mode & VAR_28)\n    {\n    if (VAR_2->res_unit == VAR_26 || VAR_2->res_unit == VAR_25)\n      { /* COMMENT_12 */\n      VAR_14 = _TIFFClampDoubleToUInt32(VAR_2->hmargin * VAR_5 * VAR_2->hres * ((VAR_1->bps + 7) / 8));\n      VAR_15 = _TIFFClampDoubleToUInt32(VAR_2->vmargin * VAR_5 * VAR_2->vres * ((VAR_1->bps + 7) / 8));\n      }\n    else\n      { /* COMMENT_13 */\n      VAR_14 = _TIFFClampDoubleToUInt32(VAR_2->hmargin * VAR_5 * ((VAR_1->bps + 7) / 8));\n      VAR_15 = _TIFFClampDoubleToUInt32(VAR_2->vmargin * VAR_5 * ((VAR_1->bps + 7) / 8));\n      }\n\n    if ((VAR_14 * 2.0) > (VAR_6 * VAR_2->hres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined left and right margins exceed page width\");\n      VAR_14 = (uint32_t) 0;\n      return (-1);\n      }\n    if ((VAR_15 * 2.0) > (VAR_7 * VAR_2->vres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined top and bottom margins exceed page length\"); \n      VAR_15 = (uint32_t) 0;\n      return (-1);\n      }\n    }\n  else\n    {\n    VAR_14 = 0;\n    VAR_15 = 0;\n    }\n\n  if (VAR_2->mode & VAR_29 )\n    {\n    /* COMMENT_14 */\n    if (VAR_2->mode & VAR_28)\n      TIFFError(\"computeOutputPixelOffsets\", \n      \"Output margins cannot be specified with rows and columns\"); \n\n    VAR_10  = TIFFhowmany(VAR_8, VAR_2->cols);\n    VAR_11 = TIFFhowmany(VAR_9, VAR_2->rows);\n    }\n  else\n    {\n    if (VAR_2->mode & VAR_30 )\n      {\n      VAR_10  = _TIFFClampDoubleToUInt32((VAR_6 * VAR_2->hres) - (VAR_14 * 2));\n      VAR_11 = _TIFFClampDoubleToUInt32((VAR_7 * VAR_2->vres) - (VAR_15 * 2));\n      }\n    else\n      {\n      VAR_10 = _TIFFClampDoubleToUInt32(VAR_8 - (VAR_14 * 2 * VAR_2->hres));\n      VAR_11 = _TIFFClampDoubleToUInt32(VAR_9 - (VAR_15 * 2 * VAR_2->vres));\n      }\n    }\n\n  if (VAR_10 > VAR_8)\n    VAR_10 = VAR_8;\n  if (VAR_11 > VAR_9)\n    VAR_11 = VAR_9;\n\n  if (VAR_10 == 0 || VAR_11 == 0)\n  {\n    TIFFError(\"computeOutputPixelOffsets\", \"Integer overflow when calculating the number of pages\");\n\t  exit(VAR_31);\n  }\n\n  /* COMMENT_15 */\n  switch (VAR_2->orient)\n    {\n    case VAR_32:\n    case VAR_33:\n         VAR_13 = TIFFhowmany(VAR_8, VAR_10);\n         VAR_12 = TIFFhowmany(VAR_9, VAR_11);\n         /* COMMENT_16 */\n         break;\n\n    case VAR_34:\n         VAR_13 = TIFFhowmany(VAR_8, VAR_11);\n         VAR_12 = TIFFhowmany(VAR_9, VAR_10);\n         VAR_16 = VAR_11;\n         VAR_11 = VAR_10;\n         VAR_10 = VAR_16;\n         /* COMMENT_17 */\n         break;\n\n    case VAR_35:\n    default:\n         VAR_16 = TIFFhowmany(VAR_8, VAR_10);\n         VAR_17 = TIFFhowmany(VAR_9, VAR_11); \n         VAR_18 = TIFFhowmany(VAR_8, VAR_11);\n         VAR_19 = TIFFhowmany(VAR_9, VAR_10); \n\n         if ( (VAR_16 * VAR_17) < (VAR_18 * VAR_19))\n           { /* COMMENT_18 */\n           VAR_13 = VAR_16;\n           VAR_12 = VAR_17;\n           /* COMMENT_16 */\n\t   }\n         else\n           { /* COMMENT_19 */\n           VAR_13 = VAR_18;\n           VAR_12 = VAR_19;\n           VAR_16 = VAR_11;\n           VAR_11 = VAR_10;\n           VAR_10 = VAR_16;\n           /* COMMENT_17 */\n           }\n    }\n\n  if (VAR_13 < 1)\n    VAR_13 = 1;\n  if (VAR_12 < 1)\n    VAR_12 = 1;\n\n  /* COMMENT_20 */\n                                                      \n                                                   \n     \n\n  if ((VAR_2->rows > 0) && (VAR_2->rows != VAR_12)) {\n    TIFFError(\"computeOutputPixelOffsets\",\n          \"Number of user input section rows down (%\"VAR_36\") was changed to (%\"VAR_36\")\", VAR_2->rows, VAR_12);\n  }\n  VAR_2->rows = VAR_12;\n  if ((VAR_2->cols > 0) && (VAR_2->cols != VAR_13)) {\n    TIFFError(\"computeOutputPixelOffsets\",\n        \"Number of user input section cols across (%\"VAR_36\") was changed to (%\"VAR_36\")\", VAR_2->cols, VAR_13);\n  }\n  VAR_2->cols = VAR_13;\n\n  VAR_20 = TIFFhowmany8(VAR_10 * VAR_1->spp * VAR_1->bps);\n\n  if ((VAR_12 * VAR_13) > VAR_37)\n   {\n   TIFFError(\"computeOutputPixelOffsets\",\n\t     \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");\n   return (-1);\n   }\n\n  /* COMMENT_24 */\n  for (VAR_23 = 0, VAR_21 = 0; VAR_21 < VAR_12; VAR_21++)\n    {\n    VAR_18 = (uint32_t)(VAR_11 * VAR_21);\n    VAR_19 = (uint32_t)(VAR_11 * (VAR_21 + 1) - 1);\n    if (VAR_19 >= VAR_9)\n      VAR_19 = VAR_9 - 1;\n    for (VAR_22 = 0; (VAR_22 < VAR_13) && (VAR_23 < VAR_37); VAR_22++, VAR_23++)\n      {\n      VAR_16 = (uint32_t)(VAR_10 * VAR_22);\n      VAR_17 = (uint32_t)(VAR_10 * (VAR_22 + 1) - 1);\n      if (VAR_17 >= VAR_8)\n        VAR_17 = VAR_8 - 1;\n      VAR_3[VAR_23].x1 = VAR_16;\n      VAR_3[VAR_23].x2 = VAR_17;\n      VAR_3[VAR_23].y1 = VAR_18;\n      VAR_3[VAR_23].y2 = VAR_19;\n      VAR_3[VAR_23].buffsize = VAR_20 * VAR_11;\n      VAR_3[VAR_23].position = VAR_23 + 1;\n      VAR_3[VAR_23].total = VAR_12 * VAR_13;\n      } \n    } \n  return (0);\n  }",
    "func_graph_path": "libtiff/ab6e93f10f7df01a43aacd51caa1ef6f61cf0ce5/tiffcrop.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -81,13 +81,13 @@\n     {\n     if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER)\n       { /* inches or centimeters specified */\n-      hmargin = (uint32_t)(page->hmargin * scale * page->hres * ((image->bps + 7) / 8));\n-      vmargin = (uint32_t)(page->vmargin * scale * page->vres * ((image->bps + 7) / 8));\n+      hmargin = _TIFFClampDoubleToUInt32(page->hmargin * scale * page->hres * ((image->bps + 7) / 8));\n+      vmargin = _TIFFClampDoubleToUInt32(page->vmargin * scale * page->vres * ((image->bps + 7) / 8));\n       }\n     else\n       { /* Otherwise user has specified pixels as reference unit */\n-      hmargin = (uint32_t)(page->hmargin * scale * ((image->bps + 7) / 8));\n-      vmargin = (uint32_t)(page->vmargin * scale * ((image->bps + 7) / 8));\n+      hmargin = _TIFFClampDoubleToUInt32(page->hmargin * scale * ((image->bps + 7) / 8));\n+      vmargin = _TIFFClampDoubleToUInt32(page->vmargin * scale * ((image->bps + 7) / 8));\n       }\n \n     if ((hmargin * 2.0) > (pwidth * page->hres))\n@@ -125,13 +125,13 @@\n     {\n     if (page->mode & PAGE_MODE_PAPERSIZE )\n       {\n-      owidth  = (uint32_t)((pwidth * page->hres) - (hmargin * 2));\n-      olength = (uint32_t)((plength * page->vres) - (vmargin * 2));\n+      owidth  = _TIFFClampDoubleToUInt32((pwidth * page->hres) - (hmargin * 2));\n+      olength = _TIFFClampDoubleToUInt32((plength * page->vres) - (vmargin * 2));\n       }\n     else\n       {\n-      owidth = (uint32_t)(iwidth - (hmargin * 2 * page->hres));\n-      olength = (uint32_t)(ilength - (vmargin * 2 * page->vres));\n+      owidth = _TIFFClampDoubleToUInt32(iwidth - (hmargin * 2 * page->hres));\n+      olength = _TIFFClampDoubleToUInt32(ilength - (vmargin * 2 * page->vres));\n       }\n     }\n \n@@ -139,6 +139,12 @@\n     owidth = iwidth;\n   if (olength > ilength)\n     olength = ilength;\n+\n+  if (owidth == 0 || olength == 0)\n+  {\n+    TIFFError(\"computeOutputPixelOffsets\", \"Integer overflow when calculating the number of pages\");\n+\t  exit(EXIT_FAILURE);\n+  }\n \n   /* Compute the number of pages required for Portrait or Landscape */\n   switch (page->orient)",
    "diff_line_info": {
        "deleted_lines": [
            "      hmargin = (uint32_t)(page->hmargin * scale * page->hres * ((image->bps + 7) / 8));",
            "      vmargin = (uint32_t)(page->vmargin * scale * page->vres * ((image->bps + 7) / 8));",
            "      hmargin = (uint32_t)(page->hmargin * scale * ((image->bps + 7) / 8));",
            "      vmargin = (uint32_t)(page->vmargin * scale * ((image->bps + 7) / 8));",
            "      owidth  = (uint32_t)((pwidth * page->hres) - (hmargin * 2));",
            "      olength = (uint32_t)((plength * page->vres) - (vmargin * 2));",
            "      owidth = (uint32_t)(iwidth - (hmargin * 2 * page->hres));",
            "      olength = (uint32_t)(ilength - (vmargin * 2 * page->vres));"
        ],
        "added_lines": [
            "      hmargin = _TIFFClampDoubleToUInt32(page->hmargin * scale * page->hres * ((image->bps + 7) / 8));",
            "      vmargin = _TIFFClampDoubleToUInt32(page->vmargin * scale * page->vres * ((image->bps + 7) / 8));",
            "      hmargin = _TIFFClampDoubleToUInt32(page->hmargin * scale * ((image->bps + 7) / 8));",
            "      vmargin = _TIFFClampDoubleToUInt32(page->vmargin * scale * ((image->bps + 7) / 8));",
            "      owidth  = _TIFFClampDoubleToUInt32((pwidth * page->hres) - (hmargin * 2));",
            "      olength = _TIFFClampDoubleToUInt32((plength * page->vres) - (vmargin * 2));",
            "      owidth = _TIFFClampDoubleToUInt32(iwidth - (hmargin * 2 * page->hres));",
            "      olength = _TIFFClampDoubleToUInt32(ilength - (vmargin * 2 * page->vres));",
            "",
            "  if (owidth == 0 || olength == 0)",
            "  {",
            "    TIFFError(\"computeOutputPixelOffsets\", \"Integer overflow when calculating the number of pages\");",
            "\t  exit(EXIT_FAILURE);",
            "  }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}