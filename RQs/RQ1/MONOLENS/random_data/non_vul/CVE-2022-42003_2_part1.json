{
    "cve_id": "CVE-2022-42003",
    "cwe_ids": [
        "CWE-502"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "FasterXML/jackson-databind",
    "commit_msg": "Fix #3590",
    "commit_hash": "d78d00ee7b5245b93103fef3187f70543d67ca33",
    "git_url": "https://github.com/FasterXML/jackson-databind/commit/d78d00ee7b5245b93103fef3187f70543d67ca33",
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java",
    "func_name": "_parseBooleanPrimitive",
    "func_before": "protected final boolean _parseBooleanPrimitive(JsonParser p, DeserializationContext ctxt)\n            throws IOException\n    {\n        String text;\n        switch (p.currentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            text = p.getText();\n            break;\n        case JsonTokenId.ID_NUMBER_INT:\n            // may accept ints too, (0 == false, otherwise true)\n\n            // call returns `null`, Boolean.TRUE or Boolean.FALSE so:\n            return Boolean.TRUE.equals(_coerceBooleanFromInt(p, ctxt, Boolean.TYPE));\n        case JsonTokenId.ID_TRUE: // usually caller should have handled but:\n            return true;\n        case JsonTokenId.ID_FALSE:\n            return false;\n        case JsonTokenId.ID_NULL: // null fine for non-primitive\n            _verifyNullForPrimitive(ctxt);\n            return false;\n        // 29-Jun-2020, tatu: New! \"Scalar from Object\" (mostly for XML)\n        case JsonTokenId.ID_START_OBJECT:\n            text = ctxt.extractScalarFromObject(p, this, Boolean.TYPE);\n            break;\n        case JsonTokenId.ID_START_ARRAY:\n            // 12-Jun-2020, tatu: For some reason calling `_deserializeFromArray()` won't work so:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                p.nextToken();\n                final boolean parsed = _parseBooleanPrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;\n            }\n            // fall through\n        default:\n            return ((Boolean) ctxt.handleUnexpectedToken(Boolean.TYPE, p)).booleanValue();\n        }\n\n        final CoercionAction act = _checkFromStringCoercion(ctxt, text,\n                LogicalType.Boolean, Boolean.TYPE);\n        if (act == CoercionAction.AsNull) {\n            _verifyNullForPrimitive(ctxt);\n            return false;\n        }\n        if (act == CoercionAction.AsEmpty) {\n            return false;\n        }\n        text = text.trim();\n        final int len = text.length();\n\n        // For [databind#1852] allow some case-insensitive matches (namely,\n        // true/True/TRUE, false/False/FALSE\n        if (len == 4) {\n            if (_isTrue(text)) {\n                return true;\n            }\n        } else if (len == 5) {\n            if (_isFalse(text)) {\n                return false;\n            }\n        }\n        if (_hasTextualNull(text)) {\n            _verifyNullForPrimitiveCoercion(ctxt, text);\n            return false;\n        }\n        Boolean b = (Boolean) ctxt.handleWeirdStringValue(Boolean.TYPE, text,\n                \"only \\\"true\\\"/\\\"True\\\"/\\\"TRUE\\\" or \\\"false\\\"/\\\"False\\\"/\\\"FALSE\\\" recognized\");\n        return Boolean.TRUE.equals(b);\n    }",
    "abstract_func_before": "protected final boolean _parseBooleanPrimitive(JsonParser VAR_0, DeserializationContext VAR_1)\n            throws IOException\n    {\n        String VAR_2;\n        switch (VAR_0.currentTokenId()) {\n        case VAR_3.ID_STRING:\n            VAR_2 = VAR_0.getText();\n            break;\n        case VAR_3.ID_NUMBER_INT:\n            /* COMMENT_0 */\n\n            /* COMMENT_1 */\n            return VAR_4.TRUE.equals(_coerceBooleanFromInt(VAR_0, VAR_1, VAR_4.TYPE));\n        case VAR_3.ID_TRUE: /* COMMENT_2 */\n            return true;\n        case VAR_3.ID_FALSE:\n            return false;\n        case VAR_3.ID_NULL: /* COMMENT_3 */\n            _verifyNullForPrimitive(VAR_1);\n            return false;\n        /* COMMENT_4 */\n        case VAR_3.ID_START_OBJECT:\n            VAR_2 = VAR_1.extractScalarFromObject(VAR_0, this, VAR_4.TYPE);\n            break;\n        case VAR_3.ID_START_ARRAY:\n            /* COMMENT_5 */\n            if (VAR_1.isEnabled(VAR_5.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                VAR_0.nextToken();\n                final boolean VAR_6 = _parseBooleanPrimitive(VAR_0, VAR_1);\n                _verifyEndArrayForSingle(VAR_0, VAR_1);\n                return VAR_6;\n            }\n            /* COMMENT_6 */\n        default:\n            return ((Boolean) VAR_1.handleUnexpectedToken(VAR_4.TYPE, VAR_0)).booleanValue();\n        }\n\n        final CoercionAction VAR_7 = _checkFromStringCoercion(VAR_1, VAR_2,\n                VAR_8.Boolean, VAR_4.TYPE);\n        if (VAR_7 == VAR_9.AsNull) {\n            _verifyNullForPrimitive(VAR_1);\n            return false;\n        }\n        if (VAR_7 == VAR_9.AsEmpty) {\n            return false;\n        }\n        VAR_2 = VAR_2.trim();\n        final int VAR_10 = VAR_2.length();\n\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_10 == 4) {\n            if (_isTrue(VAR_2)) {\n                return true;\n            }\n        } else if (VAR_10 == 5) {\n            if (_isFalse(VAR_2)) {\n                return false;\n            }\n        }\n        if (_hasTextualNull(VAR_2)) {\n            _verifyNullForPrimitiveCoercion(VAR_1, VAR_2);\n            return false;\n        }\n        Boolean VAR_11 = (Boolean) VAR_1.handleWeirdStringValue(VAR_4.TYPE, VAR_2,\n                \"only \\\"true\\\"/\\\"True\\\"/\\\"TRUE\\\" or \\\"false\\\"/\\\"False\\\"/\\\"FALSE\\\" recognized\");\n        return VAR_4.TRUE.equals(VAR_11);\n    }",
    "func_graph_path_before": "FasterXML/jackson-databind/d78d00ee7b5245b93103fef3187f70543d67ca33/StdDeserializer.java/vul/before/3.json",
    "func": "protected final boolean _parseBooleanPrimitive(JsonParser p, DeserializationContext ctxt)\n            throws IOException\n    {\n        String text;\n        switch (p.currentTokenId()) {\n        case JsonTokenId.ID_STRING:\n            text = p.getText();\n            break;\n        case JsonTokenId.ID_NUMBER_INT:\n            // may accept ints too, (0 == false, otherwise true)\n\n            // call returns `null`, Boolean.TRUE or Boolean.FALSE so:\n            return Boolean.TRUE.equals(_coerceBooleanFromInt(p, ctxt, Boolean.TYPE));\n        case JsonTokenId.ID_TRUE: // usually caller should have handled but:\n            return true;\n        case JsonTokenId.ID_FALSE:\n            return false;\n        case JsonTokenId.ID_NULL: // null fine for non-primitive\n            _verifyNullForPrimitive(ctxt);\n            return false;\n        // 29-Jun-2020, tatu: New! \"Scalar from Object\" (mostly for XML)\n        case JsonTokenId.ID_START_OBJECT:\n            text = ctxt.extractScalarFromObject(p, this, Boolean.TYPE);\n            break;\n        case JsonTokenId.ID_START_ARRAY:\n            // 12-Jun-2020, tatu: For some reason calling `_deserializeFromArray()` won't work so:\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                if (p.nextToken() == JsonToken.START_ARRAY) {\n                    return (boolean) handleNestedArrayForSingle(p, ctxt);\n                }\n                final boolean parsed = _parseBooleanPrimitive(p, ctxt);\n                _verifyEndArrayForSingle(p, ctxt);\n                return parsed;\n            }\n            // fall through\n        default:\n            return ((Boolean) ctxt.handleUnexpectedToken(Boolean.TYPE, p)).booleanValue();\n        }\n\n        final CoercionAction act = _checkFromStringCoercion(ctxt, text,\n                LogicalType.Boolean, Boolean.TYPE);\n        if (act == CoercionAction.AsNull) {\n            _verifyNullForPrimitive(ctxt);\n            return false;\n        }\n        if (act == CoercionAction.AsEmpty) {\n            return false;\n        }\n        text = text.trim();\n        final int len = text.length();\n\n        // For [databind#1852] allow some case-insensitive matches (namely,\n        // true/True/TRUE, false/False/FALSE\n        if (len == 4) {\n            if (_isTrue(text)) {\n                return true;\n            }\n        } else if (len == 5) {\n            if (_isFalse(text)) {\n                return false;\n            }\n        }\n        if (_hasTextualNull(text)) {\n            _verifyNullForPrimitiveCoercion(ctxt, text);\n            return false;\n        }\n        Boolean b = (Boolean) ctxt.handleWeirdStringValue(Boolean.TYPE, text,\n                \"only \\\"true\\\"/\\\"True\\\"/\\\"TRUE\\\" or \\\"false\\\"/\\\"False\\\"/\\\"FALSE\\\" recognized\");\n        return Boolean.TRUE.equals(b);\n    }",
    "abstract_func": "protected final boolean _parseBooleanPrimitive(JsonParser VAR_0, DeserializationContext VAR_1)\n            throws IOException\n    {\n        String VAR_2;\n        switch (VAR_0.currentTokenId()) {\n        case VAR_3.ID_STRING:\n            VAR_2 = VAR_0.getText();\n            break;\n        case VAR_3.ID_NUMBER_INT:\n            /* COMMENT_0 */\n\n            /* COMMENT_1 */\n            return VAR_4.TRUE.equals(_coerceBooleanFromInt(VAR_0, VAR_1, VAR_4.TYPE));\n        case VAR_3.ID_TRUE: /* COMMENT_2 */\n            return true;\n        case VAR_3.ID_FALSE:\n            return false;\n        case VAR_3.ID_NULL: /* COMMENT_3 */\n            _verifyNullForPrimitive(VAR_1);\n            return false;\n        /* COMMENT_4 */\n        case VAR_3.ID_START_OBJECT:\n            VAR_2 = VAR_1.extractScalarFromObject(VAR_0, this, VAR_4.TYPE);\n            break;\n        case VAR_3.ID_START_ARRAY:\n            /* COMMENT_5 */\n            if (VAR_1.isEnabled(VAR_5.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                if (VAR_0.nextToken() == VAR_6.START_ARRAY) {\n                    return (boolean) handleNestedArrayForSingle(VAR_0, VAR_1);\n                }\n                final boolean VAR_7 = _parseBooleanPrimitive(VAR_0, VAR_1);\n                _verifyEndArrayForSingle(VAR_0, VAR_1);\n                return VAR_7;\n            }\n            /* COMMENT_6 */\n        default:\n            return ((Boolean) VAR_1.handleUnexpectedToken(VAR_4.TYPE, VAR_0)).booleanValue();\n        }\n\n        final CoercionAction VAR_8 = _checkFromStringCoercion(VAR_1, VAR_2,\n                VAR_9.Boolean, VAR_4.TYPE);\n        if (VAR_8 == VAR_10.AsNull) {\n            _verifyNullForPrimitive(VAR_1);\n            return false;\n        }\n        if (VAR_8 == VAR_10.AsEmpty) {\n            return false;\n        }\n        VAR_2 = VAR_2.trim();\n        final int VAR_11 = VAR_2.length();\n\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_11 == 4) {\n            if (_isTrue(VAR_2)) {\n                return true;\n            }\n        } else if (VAR_11 == 5) {\n            if (_isFalse(VAR_2)) {\n                return false;\n            }\n        }\n        if (_hasTextualNull(VAR_2)) {\n            _verifyNullForPrimitiveCoercion(VAR_1, VAR_2);\n            return false;\n        }\n        Boolean VAR_12 = (Boolean) VAR_1.handleWeirdStringValue(VAR_4.TYPE, VAR_2,\n                \"only \\\"true\\\"/\\\"True\\\"/\\\"TRUE\\\" or \\\"false\\\"/\\\"False\\\"/\\\"FALSE\\\" recognized\");\n        return VAR_4.TRUE.equals(VAR_12);\n    }",
    "func_graph_path": "FasterXML/jackson-databind/d78d00ee7b5245b93103fef3187f70543d67ca33/StdDeserializer.java/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,9 @@\n         case JsonTokenId.ID_START_ARRAY:\n             // 12-Jun-2020, tatu: For some reason calling `_deserializeFromArray()` won't work so:\n             if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n-                p.nextToken();\n+                if (p.nextToken() == JsonToken.START_ARRAY) {\n+                    return (boolean) handleNestedArrayForSingle(p, ctxt);\n+                }\n                 final boolean parsed = _parseBooleanPrimitive(p, ctxt);\n                 _verifyEndArrayForSingle(p, ctxt);\n                 return parsed;",
    "diff_line_info": {
        "deleted_lines": [
            "                p.nextToken();"
        ],
        "added_lines": [
            "                if (p.nextToken() == JsonToken.START_ARRAY) {",
            "                    return (boolean) handleNestedArrayForSingle(p, ctxt);",
            "                }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}