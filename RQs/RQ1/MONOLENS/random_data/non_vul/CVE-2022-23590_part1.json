{
    "cve_id": "CVE-2022-23590",
    "cwe_ids": [
        "CWE-754"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "tensorflow",
    "commit_msg": "Check for type inference error on node construction.\n\nPiperOrigin-RevId: 409415804\nChange-Id: Ieb6e020906b96f522bf8e2fa103715ddbbdc434a",
    "commit_hash": "955059813cc325dc1db5e2daa6221271406d4439",
    "git_url": "https://github.com/tensorflow/tensorflow/commit/955059813cc325dc1db5e2daa6221271406d4439",
    "file_path": "tensorflow/core/graph/graph.cc",
    "func_name": "Graph::AddNode",
    "func_before": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}",
    "abstract_func_before": "Node* Graph::AddNode(NodeDef VAR_0, Status* VAR_1) {\n  const OpRegistrationData* VAR_2;\n  VAR_1->Update(VAR_3.LookUp(VAR_0.op(), &VAR_2));\n  if (!VAR_1->ok()) return nullptr;\n\n  DataTypeVector VAR_4;\n  DataTypeVector VAR_5;\n  VAR_1->Update(\n      InOutTypesForNode(VAR_0, VAR_2->op_def, &VAR_4, &VAR_5));\n  if (!VAR_1->ok()) {\n    *VAR_1 = AttachDef(*VAR_1, VAR_0);\n    return nullptr;\n  }\n\n  Node::NodeClass VAR_6 = VAR_2->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(VAR_0.op());\n\n  if (VAR_2->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << VAR_0.name();\n    const auto VAR_7 =\n        full_type::SpecializeType(AttrSlice(VAR_0), VAR_2->op_def);\n    const FullTypeDef VAR_8 = VAR_7.ValueOrDie();\n    if (VAR_8.type_id() != VAR_9) {\n      *(VAR_0.mutable_experimental_type()) = VAR_8;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << VAR_0.name();\n  }\n\n  Node* VAR_10 = AllocateNode(std::VAR_11<NodeProperties>(\n                                &VAR_2->op_def, std::move(VAR_0),\n                                VAR_4, VAR_5, VAR_2->fwd_type_fn),\n                            nullptr, VAR_6);\n  return VAR_10;\n}",
    "func_graph_path_before": "tensorflow/955059813cc325dc1db5e2daa6221271406d4439/graph.cc/vul/before/0.json",
    "func": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    if (!ctor_type.ok()) {\n      *status = errors::InvalidArgument(\"type error: \",\n                                        ctor_type.status().ToString());\n      return nullptr;\n    }\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}",
    "abstract_func": "Node* Graph::AddNode(NodeDef VAR_0, Status* VAR_1) {\n  const OpRegistrationData* VAR_2;\n  VAR_1->Update(VAR_3.LookUp(VAR_0.op(), &VAR_2));\n  if (!VAR_1->ok()) return nullptr;\n\n  DataTypeVector VAR_4;\n  DataTypeVector VAR_5;\n  VAR_1->Update(\n      InOutTypesForNode(VAR_0, VAR_2->op_def, &VAR_4, &VAR_5));\n  if (!VAR_1->ok()) {\n    *VAR_1 = AttachDef(*VAR_1, VAR_0);\n    return nullptr;\n  }\n\n  Node::NodeClass VAR_6 = VAR_2->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(VAR_0.op());\n\n  if (VAR_2->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << VAR_0.name();\n    const auto VAR_7 =\n        full_type::SpecializeType(AttrSlice(VAR_0), VAR_2->op_def);\n    if (!VAR_7.ok()) {\n      *VAR_1 = errors::InvalidArgument(\"type error: \",\n                                        VAR_7.status().ToString());\n      return nullptr;\n    }\n    const FullTypeDef VAR_8 = VAR_7.ValueOrDie();\n    if (VAR_8.type_id() != VAR_9) {\n      *(VAR_0.mutable_experimental_type()) = VAR_8;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << VAR_0.name();\n  }\n\n  Node* VAR_10 = AllocateNode(std::VAR_11<NodeProperties>(\n                                &VAR_2->op_def, std::move(VAR_0),\n                                VAR_4, VAR_5, VAR_2->fwd_type_fn),\n                            nullptr, VAR_6);\n  return VAR_10;\n}",
    "func_graph_path": "tensorflow/955059813cc325dc1db5e2daa6221271406d4439/graph.cc/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,11 @@\n     VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n     const auto ctor_type =\n         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n+    if (!ctor_type.ok()) {\n+      *status = errors::InvalidArgument(\"type error: \",\n+                                        ctor_type.status().ToString());\n+      return nullptr;\n+    }\n     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n     if (ctor_typedef.type_id() != TFT_UNSET) {\n       *(node_def.mutable_experimental_type()) = ctor_typedef;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "    if (!ctor_type.ok()) {",
            "      *status = errors::InvalidArgument(\"type error: \",",
            "                                        ctor_type.status().ToString());",
            "      return nullptr;",
            "    }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}