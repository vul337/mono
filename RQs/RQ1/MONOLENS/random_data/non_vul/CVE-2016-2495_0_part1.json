{
    "cve_id": "CVE-2016-2495",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "android",
    "commit_msg": "SampleTable.cpp: Fixed a regression caused by a fix for bug\n28076789.\n\nDetail: Before the original fix\n(Id207f369ab7b27787d83f5d8fc48dc53ed9fcdc9) for 28076789, the\ncode allowed a time-to-sample table size to be 0. The change\nmade in that fix disallowed such situation, which in fact should\nbe allowed. This current patch allows it again while maintaining\nthe security of the previous fix.\n\nBug: 28288202\nBug: 28076789\nChange-Id: I1c9a60c7f0cfcbd3d908f24998dde15d5136a295\n",
    "commit_hash": "b57b3967b1a42dd505dbe4fcf1e1d810e3ae3777",
    "git_url": "https://android.googlesource.com/platform/frameworks/av/+/b57b3967b1a42dd505dbe4fcf1e1d810e3ae3777",
    "file_path": "media/libstagefright/SampleTable.cpp",
    "func_name": "SampleTable::setTimeToSampleParams",
    "func_before": "status_t SampleTable::setTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    if (!mTimeToSample.empty() || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n    if ((uint64_t)mTimeToSampleCount >\n        (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {\n        // Choose this bound because\n        // 1) 2 * sizeof(uint32_t) is the amount of memory needed for one\n        //    time-to-sample entry in the time-to-sample table.\n        // 2) mTimeToSampleCount is the number of entries of the time-to-sample\n        //    table.\n        // 3) We hope that the table size does not exceed UINT32_MAX.\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    // Note: At this point, we know that mTimeToSampleCount * 2 will not\n    // overflow because of the above condition.\n    if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,\n                                mTimeToSampleCount * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n        mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n    }\n    return OK;\n}",
    "abstract_func_before": "status_t SampleTable::setTimeToSampleParams(\n        off64_t VAR_0, size_t VAR_1) {\n    if (!VAR_2.empty() || VAR_1 < 8) {\n        return VAR_3;\n    }\n\n    uint8_t VAR_4[8];\n    if (VAR_5->readAt(\n                VAR_0, VAR_4, sizeof(VAR_4)) < (ssize_t)sizeof(VAR_4)) {\n        return VAR_6;\n    }\n\n    if (U32_AT(VAR_4) != 0) {\n        /* COMMENT_0 */\n        return VAR_3;\n    }\n\n    VAR_7 = U32_AT(&VAR_4[4]);\n    if ((uint64_t)VAR_7 >\n        (uint64_t)VAR_8 / (2 * sizeof(uint32_t))) {\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n        return VAR_9;\n    }\n\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    if (!VAR_5->getVector(VAR_0 + 8, &VAR_2,\n                                VAR_7 * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n        return VAR_6;\n    }\n\n    for (size_t VAR_10 = 0; VAR_10 < VAR_2.size(); ++VAR_10) {\n        VAR_2.editItemAt(VAR_10) = ntohl(VAR_2[VAR_10]);\n    }\n    return VAR_11;\n}",
    "func_graph_path_before": "android/b57b3967b1a42dd505dbe4fcf1e1d810e3ae3777/SampleTable.cpp/vul/before/1.json",
    "func": "status_t SampleTable::setTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    if (mHasTimeToSample || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n    if ((uint64_t)mTimeToSampleCount >\n        (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {\n        // Choose this bound because\n        // 1) 2 * sizeof(uint32_t) is the amount of memory needed for one\n        //    time-to-sample entry in the time-to-sample table.\n        // 2) mTimeToSampleCount is the number of entries of the time-to-sample\n        //    table.\n        // 3) We hope that the table size does not exceed UINT32_MAX.\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    // Note: At this point, we know that mTimeToSampleCount * 2 will not\n    // overflow because of the above condition.\n    if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,\n                                mTimeToSampleCount * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n        mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n    }\n\n    mHasTimeToSample = true;\n    return OK;\n}",
    "abstract_func": "status_t SampleTable::setTimeToSampleParams(\n        off64_t VAR_0, size_t VAR_1) {\n    if (VAR_2 || VAR_1 < 8) {\n        return VAR_3;\n    }\n\n    uint8_t VAR_4[8];\n    if (VAR_5->readAt(\n                VAR_0, VAR_4, sizeof(VAR_4)) < (ssize_t)sizeof(VAR_4)) {\n        return VAR_6;\n    }\n\n    if (U32_AT(VAR_4) != 0) {\n        /* COMMENT_0 */\n        return VAR_3;\n    }\n\n    VAR_7 = U32_AT(&VAR_4[4]);\n    if ((uint64_t)VAR_7 >\n        (uint64_t)VAR_8 / (2 * sizeof(uint32_t))) {\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n        return VAR_9;\n    }\n\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    if (!VAR_5->getVector(VAR_0 + 8, &VAR_10,\n                                VAR_7 * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n        return VAR_6;\n    }\n\n    for (size_t VAR_11 = 0; VAR_11 < VAR_10.size(); ++VAR_11) {\n        VAR_10.editItemAt(VAR_11) = ntohl(VAR_10[VAR_11]);\n    }\n\n    VAR_2 = true;\n    return VAR_12;\n}",
    "func_graph_path": "android/b57b3967b1a42dd505dbe4fcf1e1d810e3ae3777/SampleTable.cpp/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n-    if (!mTimeToSample.empty() || data_size < 8) {\n+    if (mHasTimeToSample || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n@@ -40,5 +40,7 @@\n     for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n     }\n+\n+    mHasTimeToSample = true;\n     return OK;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "    if (!mTimeToSample.empty() || data_size < 8) {"
        ],
        "added_lines": [
            "    if (mHasTimeToSample || data_size < 8) {",
            "",
            "    mHasTimeToSample = true;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}