{
    "cve_id": "CVE-2016-1708",
    "cwe_ids": [
        "CWE-416"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "chromium",
    "commit_msg": "[Extensions] Rework inline installation observation\n\nInstead of observing through the WebstoreAPI, observe directly in the TabHelper.\nThis is a great deal less code, more direct, and also fixes a lifetime issue\nwith the TabHelper being deleted before the inline installation completes.\n\nBUG=613949\n\nReview-Url: https://codereview.chromium.org/2103663002\nCr-Commit-Position: refs/heads/master@{#403188}\n",
    "commit_hash": "d30a8bd191f17b61938fc87890bffc80049b0774",
    "git_url": "https://chromium.googlesource.com/chromium/src/+/d30a8bd191f17b61938fc87890bffc80049b0774",
    "file_path": "chrome/browser/extensions/webstore_standalone_installer.cc",
    "func_name": "WebstoreStandaloneInstaller::BeginInstall",
    "func_before": "void WebstoreStandaloneInstaller::BeginInstall() {\n  // Add a ref to keep this alive for WebstoreDataFetcher.\n  // All code paths from here eventually lead to either CompleteInstall or\n  // AbortInstall, which both release this ref.\n  AddRef();\n\n  if (!crx_file::id_util::IdIsValid(id_)) {\n    CompleteInstall(webstore_install::INVALID_ID, kInvalidWebstoreItemId);\n    return;\n  }\n\n  webstore_install::Result result = webstore_install::OTHER_ERROR;\n  std::string error;\n  if (!EnsureUniqueInstall(&result, &error)) {\n    CompleteInstall(result, error);\n    return;\n  }\n\n  // Use the requesting page as the referrer both since that is more correct\n  // (it is the page that caused this request to happen) and so that we can\n  // track top sites that trigger inline install requests.\n  webstore_data_fetcher_.reset(new WebstoreDataFetcher(\n      this,\n      profile_->GetRequestContext(),\n      GetRequestorURL(),\n      id_));\n  webstore_data_fetcher_->Start();\n}",
    "abstract_func_before": "void WebstoreStandaloneInstaller::BeginInstall() {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  AddRef();\n\n  if (!crx_file::id_util::IdIsValid(VAR_0)) {\n    CompleteInstall(webstore_install::INVALID_ID, VAR_1);\n    return;\n  }\n\n  webstore_install::Result VAR_2 = webstore_install::OTHER_ERROR;\n  std::string VAR_3;\n  if (!EnsureUniqueInstall(&VAR_2, &VAR_3)) {\n    CompleteInstall(VAR_2, VAR_3);\n    return;\n  }\n\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  VAR_4.reset(new WebstoreDataFetcher(\n      this,\n      VAR_5->GetRequestContext(),\n      GetRequestorURL(),\n      VAR_0));\n  VAR_4->Start();\n}",
    "func_graph_path_before": "chromium/d30a8bd191f17b61938fc87890bffc80049b0774/webstore_standalone_installer.cc/vul/before/2.json",
    "func": "void WebstoreStandaloneInstaller::BeginInstall() {\n  // Add a ref to keep this alive for WebstoreDataFetcher.\n  // All code paths from here eventually lead to either CompleteInstall or\n  // AbortInstall, which both release this ref.\n  AddRef();\n\n  if (!crx_file::id_util::IdIsValid(id_)) {\n    CompleteInstall(webstore_install::INVALID_ID,\n                    webstore_install::kInvalidWebstoreItemId);\n    return;\n  }\n\n  webstore_install::Result result = webstore_install::OTHER_ERROR;\n  std::string error;\n  if (!EnsureUniqueInstall(&result, &error)) {\n    CompleteInstall(result, error);\n    return;\n  }\n\n  // Use the requesting page as the referrer both since that is more correct\n  // (it is the page that caused this request to happen) and so that we can\n  // track top sites that trigger inline install requests.\n  webstore_data_fetcher_.reset(new WebstoreDataFetcher(\n      this,\n      profile_->GetRequestContext(),\n      GetRequestorURL(),\n      id_));\n  webstore_data_fetcher_->Start();\n}",
    "abstract_func": "void WebstoreStandaloneInstaller::BeginInstall() {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  AddRef();\n\n  if (!crx_file::id_util::IdIsValid(VAR_0)) {\n    CompleteInstall(webstore_install::INVALID_ID,\n                    webstore_install::kInvalidWebstoreItemId);\n    return;\n  }\n\n  webstore_install::Result VAR_1 = webstore_install::OTHER_ERROR;\n  std::string VAR_2;\n  if (!EnsureUniqueInstall(&VAR_1, &VAR_2)) {\n    CompleteInstall(VAR_1, VAR_2);\n    return;\n  }\n\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  VAR_3.reset(new WebstoreDataFetcher(\n      this,\n      VAR_4->GetRequestContext(),\n      GetRequestorURL(),\n      VAR_0));\n  VAR_3->Start();\n}",
    "func_graph_path": "chromium/d30a8bd191f17b61938fc87890bffc80049b0774/webstore_standalone_installer.cc/vul/after/2.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,8 @@\n   AddRef();\n \n   if (!crx_file::id_util::IdIsValid(id_)) {\n-    CompleteInstall(webstore_install::INVALID_ID, kInvalidWebstoreItemId);\n+    CompleteInstall(webstore_install::INVALID_ID,\n+                    webstore_install::kInvalidWebstoreItemId);\n     return;\n   }\n ",
    "diff_line_info": {
        "deleted_lines": [
            "    CompleteInstall(webstore_install::INVALID_ID, kInvalidWebstoreItemId);"
        ],
        "added_lines": [
            "    CompleteInstall(webstore_install::INVALID_ID,",
            "                    webstore_install::kInvalidWebstoreItemId);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}