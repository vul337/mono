{
    "cve_id": "CVE-2021-43784",
    "cwe_ids": [
        "CWE-190"
    ],
    "cvss_vector": "AV:N/AC:M/Au:S/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "opencontainers/runc",
    "commit_msg": "Open bind mount sources from the host userns\n\nThe source of the bind mount might not be accessible in a different user\nnamespace because a component of the source path might not be traversed\nunder the users and groups mapped inside the user namespace. This caused\nerrors such as the following:\n\n  # time=\"2020-06-22T13:48:26Z\" level=error msg=\"container_linux.go:367:\n  starting container process caused: process_linux.go:459:\n  container init caused: rootfs_linux.go:58:\n  mounting \\\"/tmp/busyboxtest/source-inaccessible/dir\\\"\n  to rootfs at \\\"/tmp/inaccessible\\\" caused:\n  stat /tmp/busyboxtest/source-inaccessible/dir: permission denied\"\n\nTo solve this problem, this patch performs the following:\n\n1. in nsexec.c, it opens the source path in the host userns (so we have\n   the right permissions to open it) but in the container mntns (so the\n   kernel cross mntns mount check let us mount it later:\n   https://github.com/torvalds/linux/blob/v5.8/fs/namespace.c#L2312).\n\n2. in nsexec.c, it passes the file descriptors of the source to the\n   child process with SCM_RIGHTS.\n\n3. In runc-init in Golang, it finishes the mounts while inside the\n   userns even without access to the some components of the source\n   paths.\n\nPassing the fds with SCM_RIGHTS is necessary because once the child\nprocess is in the container mntns, it is already in the container userns\nso it cannot temporarily join the host mntns.\n\nThis patch uses the existing mechanism with _LIBCONTAINER_* environment\nvariables to pass the file descriptors from runc to runc init.\n\nThis patch uses the existing mechanism with the Netlink-style bootstrap\nto pass information about the list of source mounts to nsexec.c.\n\nRootless containers don't use this bind mount sources fdpassing\nmechanism because we can't setns() to the target mntns in a rootless\ncontainer (we don't have the privileges when we are in the host userns).\n\nThis patch takes care of using O_CLOEXEC on mount fds, and close them\nearly.\n\nFixes: #2484.\n\nSigned-off-by: Alban Crequy <alban@kinvolk.io>\nSigned-off-by: Rodrigo Campos <rodrigo@kinvolk.io>\nCo-authored-by: Rodrigo Campos <rodrigo@kinvolk.io>",
    "commit_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
    "git_url": "https://github.com/opencontainers/runc/commit/9c444070ec7bb83995dbc0185da68284da71c554",
    "file_path": "libcontainer/nsenter/nsexec.c",
    "func_name": "nsexec",
    "func_before": "void nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * Setup a pipe to send logs to the parent. This should happen\n\t * first, because bail will use that pipe.\n\t */\n\tsetup_logpipe();\n\n\t/*\n\t * Get the init pipe fd from the environment. The init pipe is used to\n\t * read the bootstrap data and tell the parent what the new pids are\n\t * after the setup is done.\n\t */\n\tpipenum = getenv_int(\"_LIBCONTAINER_INITPIPE\");\n\tif (pipenum < 0) {\n\t\t/* We are not a runc init. Just return to go runtime. */\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to re-exec if we are not in a cloned binary. This is necessary\n\t * to ensure that containers won't be able to access the host binary\n\t * through /proc/self/exe. See CVE-2019-5736.\n\t */\n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/*\n\t * Inform the parent we're past initial setup.\n\t * For the other side of this, see initWaiter.\n\t */\n\tif (write(pipenum, \"\", 1) != 1)\n\t\tbail(\"could not inform the parent we are past initial setup\");\n\n\twrite_log(DEBUG, \"=> nsexec container setup\");\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\twrite_log(DEBUG, \"set process as non-dumpable\");\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tcurrent_stage = setjmp(env);\n\tswitch (current_stage) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: STAGE_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase STAGE_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t stage1_pid = -1, stage2_pid = -1;\n\t\t\tbool stage1_complete, stage2_complete;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-0\");\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\twrite_log(DEBUG, \"spawn stage-1\");\n\t\t\tstage1_pid = clone_parent(&env, STAGE_CHILD);\n\t\t\tif (stage1_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-1\");\n\n\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children. We only\n\t\t\t * return once both the child and grandchild are ready.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"-> stage-1 synchronisation loop\");\n\t\t\tstage1_complete = false;\n\t\t\twhile (!stage1_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with stage-1: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested userns mappings\");\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(stage1_pid, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, stage1_pid, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, stage1_pid, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested pid to be forwarded\");\n\n\t\t\t\t\t/* Get the stage-2 pid. */\n\t\t\t\t\tif (read(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: read(stage2_pid)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Send both the stage-1 and stage-2 pids back to runc.\n\t\t\t\t\t * runc needs the stage-2 to continue process management,\n\t\t\t\t\t * but because stage-1 was spawned with CLONE_PARENT we\n\t\t\t\t\t * cannot reap it within stage-0 and thus we need to ask\n\t\t\t\t\t * runc to reap the zombie for us.\n\t\t\t\t\t */\n\t\t\t\t\twrite_log(DEBUG, \"forward stage-1 (%d) and stage-2 (%d) pids to runc\",\n\t\t\t\t\t\t  stage1_pid, stage2_pid);\n\t\t\t\t\tlen =\n\t\t\t\t\t    dprintf(pipenum, \"{\\\"stage1_pid\\\":%d,\\\"stage2_pid\\\":%d}\\n\", stage1_pid,\n\t\t\t\t\t\t    stage2_pid);\n\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 complete\");\n\t\t\t\t\tstage1_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-1 synchronisation loop\");\n\n\t\t\t/* Now sync with grandchild. */\n\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\twrite_log(DEBUG, \"-> stage-2 synchronisation loop\");\n\t\t\tstage2_complete = false;\n\t\t\twhile (!stage2_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\twrite_log(DEBUG, \"signalling stage-2 to run\");\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-2 complete\");\n\t\t\t\t\tstage2_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-2 synchronisation loop\");\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-0\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all of\n\t\t *          the requested namespaces. If we've been asked to CLONE_NEWUSER,\n\t\t *          we will ask our parent (stage 0) to set up our user mappings\n\t\t *          for us. Then, we create a new child (stage 2: STAGE_INIT) for\n\t\t *          PID namespace. We then send the child's PID to our parent\n\t\t *          (stage 0).\n\t\t */\n\tcase STAGE_CHILD:{\n\t\t\tpid_t stage2_pid = -1;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tif (close(sync_child_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[1] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-1\");\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: STAGE_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\twrite_log(DEBUG, \"unshare user namespace\");\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We need to set ourselves as dumpable temporarily so that the\n\t\t\t\t * parent process can write to our procfs files.\n\t\t\t\t */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"temporarily set process as dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to temporarily set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal stage-0 to do the mapping for\n\t\t\t\t * us.\n\t\t\t\t */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\n\t\t\t\t/* Revert temporary re-dumpable setting. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"re-set process as non-dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to re-set process as non-dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"unshare remaining namespace (except cgroupns)\");\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"spawn stage-2\");\n\t\t\tstage2_pid = clone_parent(&env, STAGE_INIT);\n\t\t\tif (stage2_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-2\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\twrite_log(DEBUG, \"request stage-0 to forward stage-2 pid (%d)\", stage2_pid);\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(stage2_pid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: STAGE_INIT] is doing the rest of the work. */\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-1\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase STAGE_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tif (close(sync_grandchild_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[1] fd\");\n\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-2\");\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\twrite_log(DEBUG, \"<= nsexec container setup\");\n\t\t\twrite_log(DEBUG, \"booting up go runtime ...\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbail(\"unknown stage '%d' for jump value\", current_stage);\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}",
    "abstract_func_before": "void nsexec(void)\n{\n\tint VAR_0;\n\tjmp_buf VAR_1;\n\tint VAR_2[2], VAR_3[2];\n\tstruct nlconfig_t VAR_4 = { 0 };\n\n\t/* COMMENT_0 */\n                                                               \n                                           \n    \n\tsetup_logpipe();\n\n\t/* COMMENT_4 */\n                                                                       \n                                                                     \n                            \n    \n\tVAR_0 = getenv_int(\"_LIBCONTAINER_INITPIPE\");\n\tif (VAR_0 < 0) {\n\t\t/* COMMENT_9 */\n\t\treturn;\n\t}\n\n\t/* COMMENT_10 */\n                                                                          \n                                                                     \n                                              \n    \n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/* COMMENT_15 */\n                                               \n                                               \n    \n\tif (write(VAR_0, \"\", 1) != 1)\n\t\tbail(\"could not inform the parent we are past initial setup\");\n\n\twrite_log(VAR_5, \"=> nsexec container setup\");\n\n\t/* COMMENT_19 */\n\tnl_parse(VAR_0, &VAR_4);\n\n\t/* COMMENT_20 */\n                                                                         \n                                                                   \n                                                                    \n             \n    \n\tupdate_oom_score_adj(VAR_4.oom_score_adj, VAR_4.oom_score_adj_len);\n\n\t/* COMMENT_26 */\n                                                                        \n                                                                    \n                                            \n   \n                                                                        \n                                                                       \n                                                                  \n                                                                   \n    \n\tif (VAR_4.namespaces) {\n\t\twrite_log(VAR_5, \"set process as non-dumpable\");\n\t\tif (prctl(VAR_6, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* COMMENT_36 */\n\tif (socketpair(VAR_7, VAR_8, 0, VAR_2) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/* COMMENT_37 */\n                                                                     \n                              \n    \n\tif (socketpair(VAR_7, VAR_8, 0, VAR_3) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* COMMENT_41 */\n\n\t/* COMMENT_42 */\n                                    \n   \n                                                                           \n                                                                         \n                                                                    \n                                                                           \n                                                                           \n                                                                          \n                                                                         \n                                                                       \n                                                                            \n                                \n   \n                                                                           \n                          \n   \n                                                                            \n                                                                            \n                                                                           \n                                                                            \n   \n                                                                           \n                                                                           \n                                                                          \n                                                                             \n                                                                           \n                                                     \n                                          \n   \n                                                                             \n                                                                           \n                                                                             \n                                                                    \n   \n                                                                         \n                                                                            \n                                                                             \n                                                                        \n                                                                           \n                                                                      \n                                                                    \n                  \n   \n                                               \n    \n\n\tVAR_9 = setjmp(VAR_1);\n\tswitch (VAR_9) {\n\t\t/* COMMENT_82 */\n                                                                        \n                                                                      \n                                                                            \n                                                                         \n                      \n     \n\tcase VAR_10:{\n\t\t\tint VAR_11;\n\t\t\tpid_t VAR_12 = -1, VAR_13 = -1;\n\t\t\tbool VAR_14, VAR_15;\n\n\t\t\t/* COMMENT_89 */\n\t\t\tprctl(VAR_16, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\t\t\twrite_log(VAR_5, \"~> nsexec stage-0\");\n\n\t\t\t/* COMMENT_90 */\n\t\t\twrite_log(VAR_5, \"spawn stage-1\");\n\t\t\tVAR_12 = clone_parent(&VAR_1, VAR_17);\n\t\t\tif (VAR_12 < 0)\n\t\t\t\tbail(\"unable to spawn stage-1\");\n\n\t\t\tVAR_18 = VAR_2[1];\n\t\t\tif (close(VAR_2[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* COMMENT_91 */\n                                                                  \n                                                          \n      \n\t\t\twrite_log(VAR_5, \"-> stage-1 synchronisation loop\");\n\t\t\tVAR_14 = false;\n\t\t\twhile (!VAR_14) {\n\t\t\t\tenum sync_t VAR_19;\n\n\t\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\t\tbail(\"failed to sync with stage-1: next state\");\n\n\t\t\t\tswitch (VAR_19) {\n\t\t\t\tcase VAR_20:\n\t\t\t\t\twrite_log(VAR_5, \"stage-1 requested userns mappings\");\n\n\t\t\t\t\t/* COMMENT_95 */\n                                                               \n                                                        \n                                                               \n                                         \n                                            \n       \n                                                                              \n                                          \n        \n\t\t\t\t\tif (VAR_4.is_rootless_euid && !VAR_4.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(VAR_12, VAR_21);\n\n\t\t\t\t\t/* COMMENT_105 */\n\t\t\t\t\tupdate_uidmap(VAR_4.uidmappath, VAR_12, VAR_4.uidmap, VAR_4.uidmap_len);\n\t\t\t\t\tupdate_gidmap(VAR_4.gidmappath, VAR_12, VAR_4.gidmap, VAR_4.gidmap_len);\n\n\t\t\t\t\tVAR_19 = VAR_22;\n\t\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\t\tsane_kill(VAR_12, VAR_23);\n\t\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_24:\n\t\t\t\t\twrite_log(VAR_5, \"stage-1 requested pid to be forwarded\");\n\n\t\t\t\t\t/* COMMENT_106 */\n\t\t\t\t\tif (read(VAR_18, &VAR_13, sizeof(VAR_13)) != sizeof(VAR_13)) {\n\t\t\t\t\t\tsane_kill(VAR_12, VAR_23);\n\t\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: read(stage2_pid)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* COMMENT_107 */\n\t\t\t\t\tVAR_19 = VAR_25;\n\t\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\t\tsane_kill(VAR_12, VAR_23);\n\t\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* COMMENT_108 */\n                                                            \n                                                              \n                                                            \n                                                             \n                                       \n        \n\t\t\t\t\twrite_log(VAR_5, \"forward stage-1 (%d) and stage-2 (%d) pids to runc\",\n\t\t\t\t\t\t  VAR_12, VAR_13);\n\t\t\t\t\tVAR_11 =\n\t\t\t\t\t    dprintf(VAR_0, \"{\\\"stage1_pid\\\":%d,\\\"stage2_pid\\\":%d}\\n\", VAR_12,\n\t\t\t\t\t\t    VAR_13);\n\t\t\t\t\tif (VAR_11 < 0) {\n\t\t\t\t\t\tsane_kill(VAR_12, VAR_23);\n\t\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_26:\n\t\t\t\t\twrite_log(VAR_5, \"stage-1 complete\");\n\t\t\t\t\tVAR_14 = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", VAR_19);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(VAR_5, \"<- stage-1 synchronisation loop\");\n\n\t\t\t/* COMMENT_115 */\n\t\t\tVAR_18 = VAR_3[1];\n\t\t\tif (close(VAR_3[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\twrite_log(VAR_5, \"-> stage-2 synchronisation loop\");\n\t\t\tVAR_15 = false;\n\t\t\twhile (!VAR_15) {\n\t\t\t\tenum sync_t VAR_19;\n\n\t\t\t\twrite_log(VAR_5, \"signalling stage-2 to run\");\n\t\t\t\tVAR_19 = VAR_27;\n\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (VAR_19) {\n\t\t\t\tcase VAR_26:\n\t\t\t\t\twrite_log(VAR_5, \"stage-2 complete\");\n\t\t\t\t\tVAR_15 = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", VAR_19);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(VAR_5, \"<- stage-2 synchronisation loop\");\n\t\t\twrite_log(VAR_5, \"<~ nsexec stage-0\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/* COMMENT_116 */\n                                                                      \n                                                                           \n                                                                             \n                                                                          \n                                                                           \n                                                                       \n                        \n     \n\tcase VAR_17:{\n\t\t\tpid_t VAR_13 = -1;\n\t\t\tenum sync_t VAR_19;\n\n\t\t\t/* COMMENT_125 */\n\t\t\tVAR_18 = VAR_2[0];\n\t\t\tif (close(VAR_2[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[1] fd\");\n\n\t\t\t/* COMMENT_89 */\n\t\t\tprctl(VAR_16, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\t\t\twrite_log(VAR_5, \"~> nsexec stage-1\");\n\n\t\t\t/* COMMENT_126 */\n                                                                    \n                                                                \n                                                                    \n                                             \n      \n\t\t\tif (VAR_4.namespaces)\n\t\t\t\tjoin_namespaces(VAR_4.namespaces);\n\n\t\t\t/* COMMENT_132 */\n                                                                      \n                                                                    \n                                   \n     \n                                                                    \n                                                                  \n                                                                    \n                                                               \n                                                                      \n                                                  \n     \n                                                              \n                                                                   \n                                                                  \n                                                                    \n                                                                  \n              \n      \n\t\t\tif (VAR_4.cloneflags & VAR_28) {\n\t\t\t\twrite_log(VAR_5, \"unshare user namespace\");\n\t\t\t\tif (unshare(VAR_28) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tVAR_4.cloneflags &= ~VAR_28;\n\n\t\t\t\t/* COMMENT_150 */\n                                                                   \n                                                    \n       \n\t\t\t\tif (VAR_4.namespaces) {\n\t\t\t\t\twrite_log(VAR_5, \"temporarily set process as dumpable\");\n\t\t\t\t\tif (prctl(VAR_6, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to temporarily set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_154 */\n                                                                   \n                                                                  \n          \n       \n\t\t\t\twrite_log(VAR_5, \"request stage-0 to map user namespace\");\n\t\t\t\tVAR_19 = VAR_20;\n\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* COMMENT_159 */\n\t\t\t\twrite_log(VAR_5, \"request stage-0 to map user namespace\");\n\t\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (VAR_19 != VAR_22)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", VAR_19);\n\n\t\t\t\t/* COMMENT_160 */\n\t\t\t\tif (VAR_4.namespaces) {\n\t\t\t\t\twrite_log(VAR_5, \"re-set process as non-dumpable\");\n\t\t\t\t\tif (prctl(VAR_6, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to re-set process as non-dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_161 */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\n\t\t\t/* COMMENT_162 */\n                                                                      \n                                                                  \n                                                                    \n                                                                     \n     \n                                                                   \n                                                                       \n                                                          \n      \n\t\t\twrite_log(VAR_5, \"unshare remaining namespace (except cgroupns)\");\n\t\t\tif (unshare(VAR_4.cloneflags & ~VAR_29) < 0)\n\t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n\n\t\t\t/* COMMENT_172 */\n                                                                          \n     \n                                                                          \n                                                                       \n                                                                              \n                                                                        \n                                              \n      \n\t\t\twrite_log(VAR_5, \"spawn stage-2\");\n\t\t\tVAR_13 = clone_parent(&VAR_1, VAR_30);\n\t\t\tif (VAR_13 < 0)\n\t\t\t\tbail(\"unable to spawn stage-2\");\n\n\t\t\t/* COMMENT_181 */\n\t\t\twrite_log(VAR_5, \"request stage-0 to forward stage-2 pid (%d)\", VAR_13);\n\t\t\tVAR_19 = VAR_24;\n\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(VAR_18, &VAR_13, sizeof(VAR_13)) != sizeof(VAR_13)) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: write(stage2_pid)\");\n\t\t\t}\n\n\t\t\t/* COMMENT_182 */\n\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (VAR_19 != VAR_25) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", VAR_19);\n\t\t\t}\n\n\t\t\twrite_log(VAR_5, \"signal completion to stage-0\");\n\t\t\tVAR_19 = VAR_26;\n\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\t\t\t}\n\n\t\t\t/* COMMENT_183 */\n\t\t\twrite_log(VAR_5, \"<~ nsexec stage-1\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/* COMMENT_184 */\n                                                                           \n                                                                          \n                                                                            \n                                   \n     \n\tcase VAR_30:{\n\t\t\t/* COMMENT_190 */\n                                                        \n                                                     \n      \n\t\t\tenum sync_t VAR_19;\n\n\t\t\t/* COMMENT_125 */\n\t\t\tVAR_18 = VAR_3[0];\n\t\t\tif (close(VAR_3[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[1] fd\");\n\n\t\t\tif (close(VAR_2[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* COMMENT_89 */\n\t\t\tprctl(VAR_16, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\t\t\twrite_log(VAR_5, \"~> nsexec stage-2\");\n\n\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (VAR_19 != VAR_27)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", VAR_19);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!VAR_4.is_rootless_euid && VAR_4.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\tif (VAR_4.cloneflags & VAR_29) {\n\t\t\t\tif (unshare(VAR_29) < 0)\n\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t}\n\n\t\t\twrite_log(VAR_5, \"signal completion to stage-0\");\n\t\t\tVAR_19 = VAR_26;\n\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\n\t\t\t/* COMMENT_194 */\n\t\t\tif (close(VAR_3[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\t/* COMMENT_195 */\n\t\t\tnl_free(&VAR_4);\n\n\t\t\t/* COMMENT_196 */\n\t\t\twrite_log(VAR_5, \"<= nsexec container setup\");\n\t\t\twrite_log(VAR_5, \"booting up go runtime ...\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbail(\"unknown stage '%d' for jump value\", VAR_9);\n\t}\n\n\t/* COMMENT_197 */\n\tbail(\"should never be reached\");\n}",
    "func_graph_path_before": "opencontainers/runc/9c444070ec7bb83995dbc0185da68284da71c554/nsexec.c/vul/before/0.json",
    "func": "void nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * Setup a pipe to send logs to the parent. This should happen\n\t * first, because bail will use that pipe.\n\t */\n\tsetup_logpipe();\n\n\t/*\n\t * Get the init pipe fd from the environment. The init pipe is used to\n\t * read the bootstrap data and tell the parent what the new pids are\n\t * after the setup is done.\n\t */\n\tpipenum = getenv_int(\"_LIBCONTAINER_INITPIPE\");\n\tif (pipenum < 0) {\n\t\t/* We are not a runc init. Just return to go runtime. */\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to re-exec if we are not in a cloned binary. This is necessary\n\t * to ensure that containers won't be able to access the host binary\n\t * through /proc/self/exe. See CVE-2019-5736.\n\t */\n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/*\n\t * Inform the parent we're past initial setup.\n\t * For the other side of this, see initWaiter.\n\t */\n\tif (write(pipenum, \"\", 1) != 1)\n\t\tbail(\"could not inform the parent we are past initial setup\");\n\n\twrite_log(DEBUG, \"=> nsexec container setup\");\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\twrite_log(DEBUG, \"set process as non-dumpable\");\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tcurrent_stage = setjmp(env);\n\tswitch (current_stage) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: STAGE_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase STAGE_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t stage1_pid = -1, stage2_pid = -1;\n\t\t\tbool stage1_complete, stage2_complete;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-0\");\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\twrite_log(DEBUG, \"spawn stage-1\");\n\t\t\tstage1_pid = clone_parent(&env, STAGE_CHILD);\n\t\t\tif (stage1_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-1\");\n\n\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children. We only\n\t\t\t * return once both the child and grandchild are ready.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"-> stage-1 synchronisation loop\");\n\t\t\tstage1_complete = false;\n\t\t\twhile (!stage1_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with stage-1: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested userns mappings\");\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(stage1_pid, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, stage1_pid, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, stage1_pid, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested pid to be forwarded\");\n\n\t\t\t\t\t/* Get the stage-2 pid. */\n\t\t\t\t\tif (read(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: read(stage2_pid)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Send both the stage-1 and stage-2 pids back to runc.\n\t\t\t\t\t * runc needs the stage-2 to continue process management,\n\t\t\t\t\t * but because stage-1 was spawned with CLONE_PARENT we\n\t\t\t\t\t * cannot reap it within stage-0 and thus we need to ask\n\t\t\t\t\t * runc to reap the zombie for us.\n\t\t\t\t\t */\n\t\t\t\t\twrite_log(DEBUG, \"forward stage-1 (%d) and stage-2 (%d) pids to runc\",\n\t\t\t\t\t\t  stage1_pid, stage2_pid);\n\t\t\t\t\tlen =\n\t\t\t\t\t    dprintf(pipenum, \"{\\\"stage1_pid\\\":%d,\\\"stage2_pid\\\":%d}\\n\", stage1_pid,\n\t\t\t\t\t\t    stage2_pid);\n\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_MOUNTSOURCES_PLS:\n\t\t\t\t\tsend_mountsources(syncfd, stage1_pid, config.mountsources,\n\t\t\t\t\t\t\t  config.mountsources_len);\n\n\t\t\t\t\ts = SYNC_MOUNTSOURCES_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tkill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 complete\");\n\t\t\t\t\tstage1_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-1 synchronisation loop\");\n\n\t\t\t/* Now sync with grandchild. */\n\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\twrite_log(DEBUG, \"-> stage-2 synchronisation loop\");\n\t\t\tstage2_complete = false;\n\t\t\twhile (!stage2_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\twrite_log(DEBUG, \"signalling stage-2 to run\");\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-2 complete\");\n\t\t\t\t\tstage2_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-2 synchronisation loop\");\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-0\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all of\n\t\t *          the requested namespaces. If we've been asked to CLONE_NEWUSER,\n\t\t *          we will ask our parent (stage 0) to set up our user mappings\n\t\t *          for us. Then, we create a new child (stage 2: STAGE_INIT) for\n\t\t *          PID namespace. We then send the child's PID to our parent\n\t\t *          (stage 0).\n\t\t */\n\tcase STAGE_CHILD:{\n\t\t\tpid_t stage2_pid = -1;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tif (close(sync_child_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[1] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-1\");\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: STAGE_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\twrite_log(DEBUG, \"unshare user namespace\");\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We need to set ourselves as dumpable temporarily so that the\n\t\t\t\t * parent process can write to our procfs files.\n\t\t\t\t */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"temporarily set process as dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to temporarily set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal stage-0 to do the mapping for\n\t\t\t\t * us.\n\t\t\t\t */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\n\t\t\t\t/* Revert temporary re-dumpable setting. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"re-set process as non-dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to re-set process as non-dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"unshare remaining namespace (except cgroupns)\");\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n\n\t\t\t/* Ask our parent to send the mount sources fds. */\n\t\t\tif (config.mountsources) {\n\t\t\t\ts = SYNC_MOUNTSOURCES_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");\n\t\t\t\t}\n\n\t\t\t\t/* Receive and install all mount sources fds. */\n\t\t\t\treceive_mountsources(syncfd);\n\n\t\t\t\t/* Parent finished to send the mount sources fds. */\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");\n\t\t\t\t}\n\t\t\t\tif (s != SYNC_MOUNTSOURCES_ACK) {\n\t\t\t\t\tkill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"spawn stage-2\");\n\t\t\tstage2_pid = clone_parent(&env, STAGE_INIT);\n\t\t\tif (stage2_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-2\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\twrite_log(DEBUG, \"request stage-0 to forward stage-2 pid (%d)\", stage2_pid);\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(stage2_pid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: STAGE_INIT] is doing the rest of the work. */\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-1\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase STAGE_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tif (close(sync_grandchild_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[1] fd\");\n\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-2\");\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\twrite_log(DEBUG, \"<= nsexec container setup\");\n\t\t\twrite_log(DEBUG, \"booting up go runtime ...\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbail(\"unknown stage '%d' for jump value\", current_stage);\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}",
    "abstract_func": "void nsexec(void)\n{\n\tint VAR_0;\n\tjmp_buf VAR_1;\n\tint VAR_2[2], VAR_3[2];\n\tstruct nlconfig_t VAR_4 = { 0 };\n\n\t/* COMMENT_0 */\n                                                               \n                                           \n    \n\tsetup_logpipe();\n\n\t/* COMMENT_4 */\n                                                                       \n                                                                     \n                            \n    \n\tVAR_0 = getenv_int(\"_LIBCONTAINER_INITPIPE\");\n\tif (VAR_0 < 0) {\n\t\t/* COMMENT_9 */\n\t\treturn;\n\t}\n\n\t/* COMMENT_10 */\n                                                                          \n                                                                     \n                                              \n    \n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/* COMMENT_15 */\n                                               \n                                               \n    \n\tif (write(VAR_0, \"\", 1) != 1)\n\t\tbail(\"could not inform the parent we are past initial setup\");\n\n\twrite_log(VAR_5, \"=> nsexec container setup\");\n\n\t/* COMMENT_19 */\n\tnl_parse(VAR_0, &VAR_4);\n\n\t/* COMMENT_20 */\n                                                                         \n                                                                   \n                                                                    \n             \n    \n\tupdate_oom_score_adj(VAR_4.oom_score_adj, VAR_4.oom_score_adj_len);\n\n\t/* COMMENT_26 */\n                                                                        \n                                                                    \n                                            \n   \n                                                                        \n                                                                       \n                                                                  \n                                                                   \n    \n\tif (VAR_4.namespaces) {\n\t\twrite_log(VAR_5, \"set process as non-dumpable\");\n\t\tif (prctl(VAR_6, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* COMMENT_36 */\n\tif (socketpair(VAR_7, VAR_8, 0, VAR_2) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/* COMMENT_37 */\n                                                                     \n                              \n    \n\tif (socketpair(VAR_7, VAR_8, 0, VAR_3) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* COMMENT_41 */\n\n\t/* COMMENT_42 */\n                                    \n   \n                                                                           \n                                                                         \n                                                                    \n                                                                           \n                                                                           \n                                                                          \n                                                                         \n                                                                       \n                                                                            \n                                \n   \n                                                                           \n                          \n   \n                                                                            \n                                                                            \n                                                                           \n                                                                            \n   \n                                                                           \n                                                                           \n                                                                          \n                                                                             \n                                                                           \n                                                     \n                                          \n   \n                                                                             \n                                                                           \n                                                                             \n                                                                    \n   \n                                                                         \n                                                                            \n                                                                             \n                                                                        \n                                                                           \n                                                                      \n                                                                    \n                  \n   \n                                               \n    \n\n\tVAR_9 = setjmp(VAR_1);\n\tswitch (VAR_9) {\n\t\t/* COMMENT_82 */\n                                                                        \n                                                                      \n                                                                            \n                                                                         \n                      \n     \n\tcase VAR_10:{\n\t\t\tint VAR_11;\n\t\t\tpid_t VAR_12 = -1, VAR_13 = -1;\n\t\t\tbool VAR_14, VAR_15;\n\n\t\t\t/* COMMENT_89 */\n\t\t\tprctl(VAR_16, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\t\t\twrite_log(VAR_5, \"~> nsexec stage-0\");\n\n\t\t\t/* COMMENT_90 */\n\t\t\twrite_log(VAR_5, \"spawn stage-1\");\n\t\t\tVAR_12 = clone_parent(&VAR_1, VAR_17);\n\t\t\tif (VAR_12 < 0)\n\t\t\t\tbail(\"unable to spawn stage-1\");\n\n\t\t\tVAR_18 = VAR_2[1];\n\t\t\tif (close(VAR_2[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* COMMENT_91 */\n                                                                  \n                                                          \n      \n\t\t\twrite_log(VAR_5, \"-> stage-1 synchronisation loop\");\n\t\t\tVAR_14 = false;\n\t\t\twhile (!VAR_14) {\n\t\t\t\tenum sync_t VAR_19;\n\n\t\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\t\tbail(\"failed to sync with stage-1: next state\");\n\n\t\t\t\tswitch (VAR_19) {\n\t\t\t\tcase VAR_20:\n\t\t\t\t\twrite_log(VAR_5, \"stage-1 requested userns mappings\");\n\n\t\t\t\t\t/* COMMENT_95 */\n                                                               \n                                                        \n                                                               \n                                         \n                                            \n       \n                                                                              \n                                          \n        \n\t\t\t\t\tif (VAR_4.is_rootless_euid && !VAR_4.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(VAR_12, VAR_21);\n\n\t\t\t\t\t/* COMMENT_105 */\n\t\t\t\t\tupdate_uidmap(VAR_4.uidmappath, VAR_12, VAR_4.uidmap, VAR_4.uidmap_len);\n\t\t\t\t\tupdate_gidmap(VAR_4.gidmappath, VAR_12, VAR_4.gidmap, VAR_4.gidmap_len);\n\n\t\t\t\t\tVAR_19 = VAR_22;\n\t\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\t\tsane_kill(VAR_12, VAR_23);\n\t\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_24:\n\t\t\t\t\twrite_log(VAR_5, \"stage-1 requested pid to be forwarded\");\n\n\t\t\t\t\t/* COMMENT_106 */\n\t\t\t\t\tif (read(VAR_18, &VAR_13, sizeof(VAR_13)) != sizeof(VAR_13)) {\n\t\t\t\t\t\tsane_kill(VAR_12, VAR_23);\n\t\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: read(stage2_pid)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* COMMENT_107 */\n\t\t\t\t\tVAR_19 = VAR_25;\n\t\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\t\tsane_kill(VAR_12, VAR_23);\n\t\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* COMMENT_108 */\n                                                            \n                                                              \n                                                            \n                                                             \n                                       \n        \n\t\t\t\t\twrite_log(VAR_5, \"forward stage-1 (%d) and stage-2 (%d) pids to runc\",\n\t\t\t\t\t\t  VAR_12, VAR_13);\n\t\t\t\t\tVAR_11 =\n\t\t\t\t\t    dprintf(VAR_0, \"{\\\"stage1_pid\\\":%d,\\\"stage2_pid\\\":%d}\\n\", VAR_12,\n\t\t\t\t\t\t    VAR_13);\n\t\t\t\t\tif (VAR_11 < 0) {\n\t\t\t\t\t\tsane_kill(VAR_12, VAR_23);\n\t\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_26:\n\t\t\t\t\tsend_mountsources(VAR_18, VAR_12, VAR_4.mountsources,\n\t\t\t\t\t\t\t  VAR_4.mountsources_len);\n\n\t\t\t\t\tVAR_19 = VAR_27;\n\t\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\t\tkill(VAR_12, VAR_23);\n\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase VAR_28:\n\t\t\t\t\twrite_log(VAR_5, \"stage-1 complete\");\n\t\t\t\t\tVAR_14 = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", VAR_19);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(VAR_5, \"<- stage-1 synchronisation loop\");\n\n\t\t\t/* COMMENT_115 */\n\t\t\tVAR_18 = VAR_3[1];\n\t\t\tif (close(VAR_3[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\twrite_log(VAR_5, \"-> stage-2 synchronisation loop\");\n\t\t\tVAR_15 = false;\n\t\t\twhile (!VAR_15) {\n\t\t\t\tenum sync_t VAR_19;\n\n\t\t\t\twrite_log(VAR_5, \"signalling stage-2 to run\");\n\t\t\t\tVAR_19 = VAR_29;\n\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (VAR_19) {\n\t\t\t\tcase VAR_28:\n\t\t\t\t\twrite_log(VAR_5, \"stage-2 complete\");\n\t\t\t\t\tVAR_15 = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", VAR_19);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(VAR_5, \"<- stage-2 synchronisation loop\");\n\t\t\twrite_log(VAR_5, \"<~ nsexec stage-0\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/* COMMENT_116 */\n                                                                      \n                                                                           \n                                                                             \n                                                                          \n                                                                           \n                                                                       \n                        \n     \n\tcase VAR_17:{\n\t\t\tpid_t VAR_13 = -1;\n\t\t\tenum sync_t VAR_19;\n\n\t\t\t/* COMMENT_125 */\n\t\t\tVAR_18 = VAR_2[0];\n\t\t\tif (close(VAR_2[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[1] fd\");\n\n\t\t\t/* COMMENT_89 */\n\t\t\tprctl(VAR_16, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\t\t\twrite_log(VAR_5, \"~> nsexec stage-1\");\n\n\t\t\t/* COMMENT_126 */\n                                                                    \n                                                                \n                                                                    \n                                             \n      \n\t\t\tif (VAR_4.namespaces)\n\t\t\t\tjoin_namespaces(VAR_4.namespaces);\n\n\t\t\t/* COMMENT_132 */\n                                                                      \n                                                                    \n                                   \n     \n                                                                    \n                                                                  \n                                                                    \n                                                               \n                                                                      \n                                                  \n     \n                                                              \n                                                                   \n                                                                  \n                                                                    \n                                                                  \n              \n      \n\t\t\tif (VAR_4.cloneflags & VAR_30) {\n\t\t\t\twrite_log(VAR_5, \"unshare user namespace\");\n\t\t\t\tif (unshare(VAR_30) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tVAR_4.cloneflags &= ~VAR_30;\n\n\t\t\t\t/* COMMENT_150 */\n                                                                   \n                                                    \n       \n\t\t\t\tif (VAR_4.namespaces) {\n\t\t\t\t\twrite_log(VAR_5, \"temporarily set process as dumpable\");\n\t\t\t\t\tif (prctl(VAR_6, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to temporarily set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_154 */\n                                                                   \n                                                                  \n          \n       \n\t\t\t\twrite_log(VAR_5, \"request stage-0 to map user namespace\");\n\t\t\t\tVAR_19 = VAR_20;\n\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* COMMENT_159 */\n\t\t\t\twrite_log(VAR_5, \"request stage-0 to map user namespace\");\n\t\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (VAR_19 != VAR_22)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", VAR_19);\n\n\t\t\t\t/* COMMENT_160 */\n\t\t\t\tif (VAR_4.namespaces) {\n\t\t\t\t\twrite_log(VAR_5, \"re-set process as non-dumpable\");\n\t\t\t\t\tif (prctl(VAR_6, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to re-set process as non-dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_161 */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\n\t\t\t/* COMMENT_162 */\n                                                                      \n                                                                  \n                                                                    \n                                                                     \n     \n                                                                   \n                                                                       \n                                                          \n      \n\t\t\twrite_log(VAR_5, \"unshare remaining namespace (except cgroupns)\");\n\t\t\tif (unshare(VAR_4.cloneflags & ~VAR_31) < 0)\n\t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n\n\t\t\t/* COMMENT_172 */\n\t\t\tif (VAR_4.mountsources) {\n\t\t\t\tVAR_19 = VAR_26;\n\t\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\tkill(VAR_13, VAR_23);\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_173 */\n\t\t\t\treceive_mountsources(VAR_18);\n\n\t\t\t\t/* COMMENT_174 */\n\t\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\t\tkill(VAR_13, VAR_23);\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");\n\t\t\t\t}\n\t\t\t\tif (VAR_19 != VAR_27) {\n\t\t\t\t\tkill(VAR_13, VAR_23);\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", VAR_19);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_175 */\n                                                                          \n     \n                                                                          \n                                                                       \n                                                                              \n                                                                        \n                                              \n      \n\t\t\twrite_log(VAR_5, \"spawn stage-2\");\n\t\t\tVAR_13 = clone_parent(&VAR_1, VAR_32);\n\t\t\tif (VAR_13 < 0)\n\t\t\t\tbail(\"unable to spawn stage-2\");\n\n\t\t\t/* COMMENT_184 */\n\t\t\twrite_log(VAR_5, \"request stage-0 to forward stage-2 pid (%d)\", VAR_13);\n\t\t\tVAR_19 = VAR_24;\n\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(VAR_18, &VAR_13, sizeof(VAR_13)) != sizeof(VAR_13)) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: write(stage2_pid)\");\n\t\t\t}\n\n\t\t\t/* COMMENT_185 */\n\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (VAR_19 != VAR_25) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", VAR_19);\n\t\t\t}\n\n\t\t\twrite_log(VAR_5, \"signal completion to stage-0\");\n\t\t\tVAR_19 = VAR_28;\n\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19)) {\n\t\t\t\tsane_kill(VAR_13, VAR_23);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\t\t\t}\n\n\t\t\t/* COMMENT_186 */\n\t\t\twrite_log(VAR_5, \"<~ nsexec stage-1\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/* COMMENT_187 */\n                                                                           \n                                                                          \n                                                                            \n                                   \n     \n\tcase VAR_32:{\n\t\t\t/* COMMENT_193 */\n                                                        \n                                                     \n      \n\t\t\tenum sync_t VAR_19;\n\n\t\t\t/* COMMENT_125 */\n\t\t\tVAR_18 = VAR_3[0];\n\t\t\tif (close(VAR_3[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[1] fd\");\n\n\t\t\tif (close(VAR_2[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* COMMENT_89 */\n\t\t\tprctl(VAR_16, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\t\t\twrite_log(VAR_5, \"~> nsexec stage-2\");\n\n\t\t\tif (read(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (VAR_19 != VAR_29)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", VAR_19);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!VAR_4.is_rootless_euid && VAR_4.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\tif (VAR_4.cloneflags & VAR_31) {\n\t\t\t\tif (unshare(VAR_31) < 0)\n\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t}\n\n\t\t\twrite_log(VAR_5, \"signal completion to stage-0\");\n\t\t\tVAR_19 = VAR_28;\n\t\t\tif (write(VAR_18, &VAR_19, sizeof(VAR_19)) != sizeof(VAR_19))\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\n\t\t\t/* COMMENT_197 */\n\t\t\tif (close(VAR_3[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\t/* COMMENT_198 */\n\t\t\tnl_free(&VAR_4);\n\n\t\t\t/* COMMENT_199 */\n\t\t\twrite_log(VAR_5, \"<= nsexec container setup\");\n\t\t\twrite_log(VAR_5, \"booting up go runtime ...\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbail(\"unknown stage '%d' for jump value\", VAR_9);\n\t}\n\n\t/* COMMENT_200 */\n\tbail(\"should never be reached\");\n}",
    "func_graph_path": "opencontainers/runc/9c444070ec7bb83995dbc0185da68284da71c554/nsexec.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -228,6 +228,16 @@\n \t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n \t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n \t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase SYNC_MOUNTSOURCES_PLS:\n+\t\t\t\t\tsend_mountsources(syncfd, stage1_pid, config.mountsources,\n+\t\t\t\t\t\t\t  config.mountsources_len);\n+\n+\t\t\t\t\ts = SYNC_MOUNTSOURCES_ACK;\n+\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n+\t\t\t\t\t\tkill(stage1_pid, SIGKILL);\n+\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tcase SYNC_CHILD_FINISH:\n@@ -384,6 +394,28 @@\n \t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n \t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n \n+\t\t\t/* Ask our parent to send the mount sources fds. */\n+\t\t\tif (config.mountsources) {\n+\t\t\t\ts = SYNC_MOUNTSOURCES_PLS;\n+\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n+\t\t\t\t\tkill(stage2_pid, SIGKILL);\n+\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");\n+\t\t\t\t}\n+\n+\t\t\t\t/* Receive and install all mount sources fds. */\n+\t\t\t\treceive_mountsources(syncfd);\n+\n+\t\t\t\t/* Parent finished to send the mount sources fds. */\n+\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n+\t\t\t\t\tkill(stage2_pid, SIGKILL);\n+\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");\n+\t\t\t\t}\n+\t\t\t\tif (s != SYNC_MOUNTSOURCES_ACK) {\n+\t\t\t\t\tkill(stage2_pid, SIGKILL);\n+\t\t\t\t\tbail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\t/*\n \t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n \t\t\t *",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\t\t\t\t}",
            "\t\t\t\t\tbreak;",
            "\t\t\t\tcase SYNC_MOUNTSOURCES_PLS:",
            "\t\t\t\t\tsend_mountsources(syncfd, stage1_pid, config.mountsources,",
            "\t\t\t\t\t\t\t  config.mountsources_len);",
            "",
            "\t\t\t\t\ts = SYNC_MOUNTSOURCES_ACK;",
            "\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
            "\t\t\t\t\t\tkill(stage1_pid, SIGKILL);",
            "\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");",
            "\t\t\t/* Ask our parent to send the mount sources fds. */",
            "\t\t\tif (config.mountsources) {",
            "\t\t\t\ts = SYNC_MOUNTSOURCES_PLS;",
            "\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
            "\t\t\t\t\tkill(stage2_pid, SIGKILL);",
            "\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");",
            "\t\t\t\t}",
            "",
            "\t\t\t\t/* Receive and install all mount sources fds. */",
            "\t\t\t\treceive_mountsources(syncfd);",
            "",
            "\t\t\t\t/* Parent finished to send the mount sources fds. */",
            "\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {",
            "\t\t\t\t\tkill(stage2_pid, SIGKILL);",
            "\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");",
            "\t\t\t\t}",
            "\t\t\t\tif (s != SYNC_MOUNTSOURCES_ACK) {",
            "\t\t\t\t\tkill(stage2_pid, SIGKILL);",
            "\t\t\t\t\tbail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);",
            "\t\t\t\t}",
            "\t\t\t}",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/opencontainers/runc/pull/2576",
    "description": "The source of the bind mount might not be accessible in a different usernamespace because a component of the source path might not be traversed under the users and groups mapped inside the user namespace. This caused errors such as the following:\r\n```\r\n  # time=\"2020-06-22T13:48:26Z\" level=error msg=\"container_linux.go:367:\r\n  starting container process caused: process_linux.go:459:\r\n  container init caused: rootfs_linux.go:58:\r\n  mounting \\\"/tmp/busyboxtest/source-inaccessible/dir\\\"\r\n  to rootfs at \\\"/tmp/inaccessible\\\" caused:\r\n  stat /tmp/busyboxtest/source-inaccessible/dir: permission denied\"\r\n```\r\nTo solve this problem, this patch performs the following:\r\n\r\n1. in nsexec.c, it opens the source path in the host userns (so we have the right permissions to open it) but in the container mntns (so the kernel cross mntns mount check let us mount it later: https://github.com/torvalds/linux/blob/v5.8/fs/namespace.c#L2312).\r\n2. in nsexec.c, it passes the file descriptors of the source to the child process with SCM_RIGHTS.\r\n3. In runc-init in Golang, it finishes the mounts while inside the userns even without access to the some components of the source paths.\r\n\r\nPassing the fds with SCM_RIGHTS is necessary because once the child process is in the container mntns, it is already in the container userns so it cannot temporarily join the host mntns.\r\n\r\nThis patch uses the existing mechanism with _LIBCONTAINER_* environment variables to pass the file descriptors from runc to runc init.\r\n\r\nThis patch uses the existing mechanism with the Netlink-style bootstrap to pass information about the list of source mounts to nsexec.c.\r\n\r\n-----\r\n\r\nFixes: https://github.com/opencontainers/runc/issues/2484\r\n\r\nTODO:\r\n- [x] It does not work yet when the bind mount is configured as read-only in `config.json`.\r\n- [x] Unit tests fail.\r\n- [x] a single env var to pass on all the mount fds"
}