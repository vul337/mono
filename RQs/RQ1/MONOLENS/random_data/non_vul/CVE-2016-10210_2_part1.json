{
    "cve_id": "CVE-2016-10210",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "VirusTotal/yara",
    "commit_msg": "re_lexer: Make reading escape sequences more robust (#586)\n\n* Add test for issue #503\r\n\r\n* re_lexer: Make reading escape sequences more robust\r\n\r\nThis commit fixes parsing incomplete escape sequences at the end of a\r\nregular expression and parsing things like \\xxy (invalid hex digits)\r\nwhich before were silently turned into (char)255.\r\n\r\nClose #503\r\n\r\n* Update re_lexer.c",
    "commit_hash": "3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
    "git_url": "https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
    "file_path": "libyara/re_lexer.c",
    "func_name": "read_escaped_char",
    "func_before": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (text[2] == EOF)\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (text[3] == EOF)\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n\n  return 1;\n}",
    "abstract_func_before": "int read_escaped_char(\n    yyscan_t VAR_0,\n    uint8_t* VAR_1)\n{\n  char VAR_2[4] = {0, 0, 0, 0};\n\n  VAR_2[0] = '\\\\';\n  VAR_2[1] = RE_YY_INPUT(VAR_0);\n\n  if (VAR_2[1] == VAR_3)\n    return 0;\n\n  if (VAR_2[1] == 'x')\n  {\n    VAR_2[2] = RE_YY_INPUT(VAR_0);\n\n    if (VAR_2[2] == VAR_3)\n      return 0;\n\n    VAR_2[3] = RE_YY_INPUT(VAR_0);\n\n    if (VAR_2[3] == VAR_3)\n      return 0;\n  }\n\n  *VAR_1 = escaped_char_value(VAR_2);\n\n  return 1;\n}",
    "func_graph_path_before": "VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/before/3.json",
    "func": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF || text[1] == 0)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[2]))\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[3]))\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n\n  return 1;\n}",
    "abstract_func": "int read_escaped_char(\n    yyscan_t VAR_0,\n    uint8_t* VAR_1)\n{\n  char VAR_2[4] = {0, 0, 0, 0};\n\n  VAR_2[0] = '\\\\';\n  VAR_2[1] = RE_YY_INPUT(VAR_0);\n\n  if (VAR_2[1] == VAR_3 || VAR_2[1] == 0)\n    return 0;\n\n  if (VAR_2[1] == 'x')\n  {\n    VAR_2[2] = RE_YY_INPUT(VAR_0);\n\n    if (!isxdigit(VAR_2[2]))\n      return 0;\n\n    VAR_2[3] = RE_YY_INPUT(VAR_0);\n\n    if (!isxdigit(VAR_2[3]))\n      return 0;\n  }\n\n  *VAR_1 = escaped_char_value(VAR_2);\n\n  return 1;\n}",
    "func_graph_path": "VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -7,19 +7,19 @@\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n ",
    "diff_line_info": {
        "deleted_lines": [
            "  if (text[1] == EOF)",
            "    if (text[2] == EOF)",
            "    if (text[3] == EOF)"
        ],
        "added_lines": [
            "  if (text[1] == EOF || text[1] == 0)",
            "    if (!isxdigit(text[2]))",
            "    if (!isxdigit(text[3]))"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/VirusTotal/yara/pull/586",
    "description": "This is actually more like the easy way out. As I mentioned in #503, one might want to change the `yr_re_parse_*` functions to accept a SIZED_STRING argument and use `yy_scan_bytes` instead."
}