{
    "cve_id": "CVE-2023-1295",
    "cwe_ids": [
        "CWE-367"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "This works just like close(2), unsurprisingly. We remove the file\ndescriptor and post the completion inline, then offload the actual\n(potential) last file put to async context.\n\nMark the async part of this work as uncancellable, as we really must\nguarantee that the latter part of the close is run.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\n",
    "commit_hash": "b5dba59e0cf7e2cc4d3b3b1ac5fe81ddf21959eb",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=b5dba59e0cf7e2cc4d3b3b1ac5fe81ddf21959eb",
    "file_path": "fs/io_uring.c",
    "func_name": "io_issue_sqe",
    "func_before": "static int io_issue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\tstruct io_kiocb **nxt, bool force_nonblock)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tswitch (req->opcode) {\n\tcase IORING_OP_NOP:\n\t\tret = io_nop(req);\n\t\tbreak;\n\tcase IORING_OP_READV:\n\tcase IORING_OP_READ_FIXED:\n\t\tif (sqe) {\n\t\t\tret = io_read_prep(req, sqe, force_nonblock);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_read(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_WRITEV:\n\tcase IORING_OP_WRITE_FIXED:\n\t\tif (sqe) {\n\t\t\tret = io_write_prep(req, sqe, force_nonblock);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_write(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_FSYNC:\n\t\tif (sqe) {\n\t\t\tret = io_prep_fsync(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_fsync(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_POLL_ADD:\n\t\tif (sqe) {\n\t\t\tret = io_poll_add_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_poll_add(req, nxt);\n\t\tbreak;\n\tcase IORING_OP_POLL_REMOVE:\n\t\tif (sqe) {\n\t\t\tret = io_poll_remove_prep(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_poll_remove(req);\n\t\tbreak;\n\tcase IORING_OP_SYNC_FILE_RANGE:\n\t\tif (sqe) {\n\t\t\tret = io_prep_sfr(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_sync_file_range(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_SENDMSG:\n\t\tif (sqe) {\n\t\t\tret = io_sendmsg_prep(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_sendmsg(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_RECVMSG:\n\t\tif (sqe) {\n\t\t\tret = io_recvmsg_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_recvmsg(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT:\n\t\tif (sqe) {\n\t\t\tret = io_timeout_prep(req, sqe, false);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_timeout(req);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT_REMOVE:\n\t\tif (sqe) {\n\t\t\tret = io_timeout_remove_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_timeout_remove(req);\n\t\tbreak;\n\tcase IORING_OP_ACCEPT:\n\t\tif (sqe) {\n\t\t\tret = io_accept_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_accept(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_CONNECT:\n\t\tif (sqe) {\n\t\t\tret = io_connect_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_connect(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_ASYNC_CANCEL:\n\t\tif (sqe) {\n\t\t\tret = io_async_cancel_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_async_cancel(req, nxt);\n\t\tbreak;\n\tcase IORING_OP_FALLOCATE:\n\t\tif (sqe) {\n\t\t\tret = io_fallocate_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_fallocate(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_OPENAT:\n\t\tif (sqe) {\n\t\t\tret = io_openat_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_openat(req, nxt, force_nonblock);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tconst bool in_async = io_wq_current_is_worker();\n\n\t\tif (req->result == -EAGAIN)\n\t\t\treturn -EAGAIN;\n\n\t\t/* workqueue context doesn't hold uring_lock, grab it now */\n\t\tif (in_async)\n\t\t\tmutex_lock(&ctx->uring_lock);\n\n\t\tio_iopoll_req_issued(req);\n\n\t\tif (in_async)\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\n\treturn 0;\n}",
    "abstract_func_before": "static int io_issue_sqe(struct io_kiocb *VAR_0, const struct io_uring_sqe *VAR_1,\n\t\t\tstruct io_kiocb **VAR_2, bool VAR_3)\n{\n\tstruct io_ring_ctx *VAR_4 = VAR_0->ctx;\n\tint VAR_5;\n\n\tswitch (VAR_0->opcode) {\n\tcase VAR_6:\n\t\tVAR_5 = io_nop(VAR_0);\n\t\tbreak;\n\tcase VAR_7:\n\tcase VAR_8:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_read_prep(VAR_0, VAR_1, VAR_3);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_read(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_9:\n\tcase VAR_10:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_write_prep(VAR_0, VAR_1, VAR_3);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_write(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_11:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_prep_fsync(VAR_0, VAR_1);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_fsync(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_12:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_poll_add_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_poll_add(VAR_0, VAR_2);\n\t\tbreak;\n\tcase VAR_13:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_poll_remove_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_poll_remove(VAR_0);\n\t\tbreak;\n\tcase VAR_14:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_prep_sfr(VAR_0, VAR_1);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_sync_file_range(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_15:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_sendmsg_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_sendmsg(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_16:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_recvmsg_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_recvmsg(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_17:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_timeout_prep(VAR_0, VAR_1, false);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_timeout(VAR_0);\n\t\tbreak;\n\tcase VAR_18:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_timeout_remove_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_timeout_remove(VAR_0);\n\t\tbreak;\n\tcase VAR_19:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_accept_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_accept(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_20:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_connect_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_connect(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_21:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_async_cancel_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_async_cancel(VAR_0, VAR_2);\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_fallocate_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_fallocate(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_23:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_openat_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_openat(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tdefault:\n\t\tVAR_5 = -VAR_24;\n\t\tbreak;\n\t}\n\n\tif (VAR_5)\n\t\treturn VAR_5;\n\n\tif (VAR_4->flags & VAR_25) {\n\t\tconst bool VAR_26 = io_wq_current_is_worker();\n\n\t\tif (VAR_0->result == -VAR_27)\n\t\t\treturn -VAR_27;\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_26)\n\t\t\tmutex_lock(&VAR_4->uring_lock);\n\n\t\tio_iopoll_req_issued(VAR_0);\n\n\t\tif (VAR_26)\n\t\t\tmutex_unlock(&VAR_4->uring_lock);\n\t}\n\n\treturn 0;\n}",
    "func_graph_path_before": "torvalds/linux/b5dba59e0cf7e2cc4d3b3b1ac5fe81ddf21959eb/io_uring.c/vul/before/2.json",
    "func": "static int io_issue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\tstruct io_kiocb **nxt, bool force_nonblock)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tswitch (req->opcode) {\n\tcase IORING_OP_NOP:\n\t\tret = io_nop(req);\n\t\tbreak;\n\tcase IORING_OP_READV:\n\tcase IORING_OP_READ_FIXED:\n\t\tif (sqe) {\n\t\t\tret = io_read_prep(req, sqe, force_nonblock);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_read(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_WRITEV:\n\tcase IORING_OP_WRITE_FIXED:\n\t\tif (sqe) {\n\t\t\tret = io_write_prep(req, sqe, force_nonblock);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_write(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_FSYNC:\n\t\tif (sqe) {\n\t\t\tret = io_prep_fsync(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_fsync(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_POLL_ADD:\n\t\tif (sqe) {\n\t\t\tret = io_poll_add_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_poll_add(req, nxt);\n\t\tbreak;\n\tcase IORING_OP_POLL_REMOVE:\n\t\tif (sqe) {\n\t\t\tret = io_poll_remove_prep(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_poll_remove(req);\n\t\tbreak;\n\tcase IORING_OP_SYNC_FILE_RANGE:\n\t\tif (sqe) {\n\t\t\tret = io_prep_sfr(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_sync_file_range(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_SENDMSG:\n\t\tif (sqe) {\n\t\t\tret = io_sendmsg_prep(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_sendmsg(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_RECVMSG:\n\t\tif (sqe) {\n\t\t\tret = io_recvmsg_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_recvmsg(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT:\n\t\tif (sqe) {\n\t\t\tret = io_timeout_prep(req, sqe, false);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_timeout(req);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT_REMOVE:\n\t\tif (sqe) {\n\t\t\tret = io_timeout_remove_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_timeout_remove(req);\n\t\tbreak;\n\tcase IORING_OP_ACCEPT:\n\t\tif (sqe) {\n\t\t\tret = io_accept_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_accept(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_CONNECT:\n\t\tif (sqe) {\n\t\t\tret = io_connect_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_connect(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_ASYNC_CANCEL:\n\t\tif (sqe) {\n\t\t\tret = io_async_cancel_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_async_cancel(req, nxt);\n\t\tbreak;\n\tcase IORING_OP_FALLOCATE:\n\t\tif (sqe) {\n\t\t\tret = io_fallocate_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_fallocate(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_OPENAT:\n\t\tif (sqe) {\n\t\t\tret = io_openat_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_openat(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_CLOSE:\n\t\tif (sqe) {\n\t\t\tret = io_close_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_close(req, nxt, force_nonblock);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tconst bool in_async = io_wq_current_is_worker();\n\n\t\tif (req->result == -EAGAIN)\n\t\t\treturn -EAGAIN;\n\n\t\t/* workqueue context doesn't hold uring_lock, grab it now */\n\t\tif (in_async)\n\t\t\tmutex_lock(&ctx->uring_lock);\n\n\t\tio_iopoll_req_issued(req);\n\n\t\tif (in_async)\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\n\treturn 0;\n}",
    "abstract_func": "static int io_issue_sqe(struct io_kiocb *VAR_0, const struct io_uring_sqe *VAR_1,\n\t\t\tstruct io_kiocb **VAR_2, bool VAR_3)\n{\n\tstruct io_ring_ctx *VAR_4 = VAR_0->ctx;\n\tint VAR_5;\n\n\tswitch (VAR_0->opcode) {\n\tcase VAR_6:\n\t\tVAR_5 = io_nop(VAR_0);\n\t\tbreak;\n\tcase VAR_7:\n\tcase VAR_8:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_read_prep(VAR_0, VAR_1, VAR_3);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_read(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_9:\n\tcase VAR_10:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_write_prep(VAR_0, VAR_1, VAR_3);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_write(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_11:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_prep_fsync(VAR_0, VAR_1);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_fsync(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_12:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_poll_add_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_poll_add(VAR_0, VAR_2);\n\t\tbreak;\n\tcase VAR_13:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_poll_remove_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_poll_remove(VAR_0);\n\t\tbreak;\n\tcase VAR_14:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_prep_sfr(VAR_0, VAR_1);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_sync_file_range(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_15:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_sendmsg_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5 < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_sendmsg(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_16:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_recvmsg_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_recvmsg(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_17:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_timeout_prep(VAR_0, VAR_1, false);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_timeout(VAR_0);\n\t\tbreak;\n\tcase VAR_18:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_timeout_remove_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_timeout_remove(VAR_0);\n\t\tbreak;\n\tcase VAR_19:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_accept_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_accept(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_20:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_connect_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_connect(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_21:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_async_cancel_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_async_cancel(VAR_0, VAR_2);\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_fallocate_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_fallocate(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_23:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_openat_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_openat(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tcase VAR_24:\n\t\tif (VAR_1) {\n\t\t\tVAR_5 = io_close_prep(VAR_0, VAR_1);\n\t\t\tif (VAR_5)\n\t\t\t\tbreak;\n\t\t}\n\t\tVAR_5 = io_close(VAR_0, VAR_2, VAR_3);\n\t\tbreak;\n\tdefault:\n\t\tVAR_5 = -VAR_25;\n\t\tbreak;\n\t}\n\n\tif (VAR_5)\n\t\treturn VAR_5;\n\n\tif (VAR_4->flags & VAR_26) {\n\t\tconst bool VAR_27 = io_wq_current_is_worker();\n\n\t\tif (VAR_0->result == -VAR_28)\n\t\t\treturn -VAR_28;\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_27)\n\t\t\tmutex_lock(&VAR_4->uring_lock);\n\n\t\tio_iopoll_req_issued(VAR_0);\n\n\t\tif (VAR_27)\n\t\t\tmutex_unlock(&VAR_4->uring_lock);\n\t}\n\n\treturn 0;\n}",
    "func_graph_path": "torvalds/linux/b5dba59e0cf7e2cc4d3b3b1ac5fe81ddf21959eb/io_uring.c/vul/after/2.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -130,6 +130,14 @@\n \t\t}\n \t\tret = io_openat(req, nxt, force_nonblock);\n \t\tbreak;\n+\tcase IORING_OP_CLOSE:\n+\t\tif (sqe) {\n+\t\t\tret = io_close_prep(req, sqe);\n+\t\t\tif (ret)\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tret = io_close(req, nxt, force_nonblock);\n+\t\tbreak;\n \tdefault:\n \t\tret = -EINVAL;\n \t\tbreak;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\tcase IORING_OP_CLOSE:",
            "\t\tif (sqe) {",
            "\t\t\tret = io_close_prep(req, sqe);",
            "\t\t\tif (ret)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t\tret = io_close(req, nxt, force_nonblock);",
            "\t\tbreak;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}