{
    "cve_id": "CVE-2020-26247",
    "cwe_ids": [
        "CWE-611"
    ],
    "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:N/A:N",
    "cvss_is_v3": false,
    "repo_name": "sparklemotion/nokogiri",
    "commit_msg": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions\n\nI'm trying out a new pattern, which is that the parsed object carries\naround the ParseOptions it was created with, which should make some\ntesting a bit easier.\n\nI'm also not implementing the \"config block\" pattern in use for\nDocuments, because I think the UX is weird and I'm hoping to change\neverything to use kwargs in a 2.0 release, anyway.",
    "commit_hash": "9c87439d9afa14a365ff13e73adc809cb2c3d97b",
    "git_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
    "file_path": "ext/java/nokogiri/XmlSchema.java",
    "func_name": "createSchemaInstance",
    "func_before": "static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source) {\n        Ruby runtime = context.getRuntime();\n        XmlSchema xmlSchema = (XmlSchema) NokogiriService.XML_SCHEMA_ALLOCATOR.allocate(runtime, klazz);\n        xmlSchema.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n\n        try {\n            SchemaErrorHandler error_handler = new SchemaErrorHandler(context.getRuntime(), (RubyArray)xmlSchema.getInstanceVariable(\"@errors\"));\n            Schema schema = xmlSchema.getSchema(source, context.getRuntime().getCurrentDirectory(), context.getRuntime().getInstanceConfig().getScriptFileName(), error_handler);\n            xmlSchema.setValidator(schema.newValidator());\n            return xmlSchema;\n        } catch (SAXException ex) {\n            throw context.getRuntime().newRuntimeError(\"Could not parse document: \" + ex.getMessage());\n        }\n    }",
    "abstract_func_before": "static XmlSchema createSchemaInstance(ThreadContext VAR_0, RubyClass VAR_1, Source VAR_2) {\n        Ruby VAR_3 = VAR_0.getRuntime();\n        XmlSchema VAR_4 = (XmlSchema) VAR_5.XML_SCHEMA_ALLOCATOR.allocate(VAR_3, VAR_1);\n        VAR_4.setInstanceVariable(\"@errors\", VAR_3.newEmptyArray());\n\n        try {\n            SchemaErrorHandler VAR_6 = new SchemaErrorHandler(VAR_0.getRuntime(), (RubyArray)VAR_4.getInstanceVariable(\"@errors\"));\n            Schema VAR_7 = VAR_4.getSchema(VAR_2, VAR_0.getRuntime().getCurrentDirectory(), VAR_0.getRuntime().getInstanceConfig().getScriptFileName(), VAR_6);\n            VAR_4.setValidator(VAR_7.newValidator());\n            return VAR_4;\n        } catch (SAXException VAR_8) {\n            throw VAR_0.getRuntime().newRuntimeError(\"Could not parse document: \" + VAR_8.getMessage());\n        }\n    }",
    "func_graph_path_before": "sparklemotion/nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b/XmlSchema.java/vul/before/2.json",
    "func": "static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n        Ruby runtime = context.getRuntime();\n        XmlSchema xmlSchema = (XmlSchema) NokogiriService.XML_SCHEMA_ALLOCATOR.allocate(runtime, klazz);\n\n        if (parseOptions == null) {\n            parseOptions = defaultParseOptions(context.getRuntime());\n        }\n\n        xmlSchema.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n        xmlSchema.setInstanceVariable(\"@parse_options\", parseOptions);\n\n        try {\n            SchemaErrorHandler error_handler = new SchemaErrorHandler(context.getRuntime(), (RubyArray)xmlSchema.getInstanceVariable(\"@errors\"));\n            Schema schema = xmlSchema.getSchema(source, context.getRuntime().getCurrentDirectory(), context.getRuntime().getInstanceConfig().getScriptFileName(), error_handler);\n            xmlSchema.setValidator(schema.newValidator());\n            return xmlSchema;\n        } catch (SAXException ex) {\n            throw context.getRuntime().newRuntimeError(\"Could not parse document: \" + ex.getMessage());\n        }\n    }",
    "abstract_func": "static XmlSchema createSchemaInstance(ThreadContext VAR_0, RubyClass VAR_1, Source VAR_2, IRubyObject VAR_3) {\n        Ruby VAR_4 = VAR_0.getRuntime();\n        XmlSchema VAR_5 = (XmlSchema) VAR_6.XML_SCHEMA_ALLOCATOR.allocate(VAR_4, VAR_1);\n\n        if (VAR_3 == null) {\n            VAR_3 = defaultParseOptions(VAR_0.getRuntime());\n        }\n\n        VAR_5.setInstanceVariable(\"@errors\", VAR_4.newEmptyArray());\n        VAR_5.setInstanceVariable(\"@parse_options\", VAR_3);\n\n        try {\n            SchemaErrorHandler VAR_7 = new SchemaErrorHandler(VAR_0.getRuntime(), (RubyArray)VAR_5.getInstanceVariable(\"@errors\"));\n            Schema VAR_8 = VAR_5.getSchema(VAR_2, VAR_0.getRuntime().getCurrentDirectory(), VAR_0.getRuntime().getInstanceConfig().getScriptFileName(), VAR_7);\n            VAR_5.setValidator(VAR_8.newValidator());\n            return VAR_5;\n        } catch (SAXException VAR_9) {\n            throw VAR_0.getRuntime().newRuntimeError(\"Could not parse document: \" + VAR_9.getMessage());\n        }\n    }",
    "func_graph_path": "sparklemotion/nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b/XmlSchema.java/vul/after/2.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,13 @@\n-static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source) {\n+static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n         Ruby runtime = context.getRuntime();\n         XmlSchema xmlSchema = (XmlSchema) NokogiriService.XML_SCHEMA_ALLOCATOR.allocate(runtime, klazz);\n+\n+        if (parseOptions == null) {\n+            parseOptions = defaultParseOptions(context.getRuntime());\n+        }\n+\n         xmlSchema.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n+        xmlSchema.setInstanceVariable(\"@parse_options\", parseOptions);\n \n         try {\n             SchemaErrorHandler error_handler = new SchemaErrorHandler(context.getRuntime(), (RubyArray)xmlSchema.getInstanceVariable(\"@errors\"));",
    "diff_line_info": {
        "deleted_lines": [
            "static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source) {"
        ],
        "added_lines": [
            "static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {",
            "",
            "        if (parseOptions == null) {",
            "            parseOptions = defaultParseOptions(context.getRuntime());",
            "        }",
            "",
            "        xmlSchema.setInstanceVariable(\"@parse_options\", parseOptions);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}