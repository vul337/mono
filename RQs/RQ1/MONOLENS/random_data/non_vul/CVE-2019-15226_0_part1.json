{
    "cve_id": "CVE-2019-15226",
    "cwe_ids": [
        "CWE-400"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
    "cvss_is_v3": false,
    "repo_name": "envoyproxy/envoy",
    "commit_msg": "Track byteSize of HeaderMap internally.\n\nIntroduces a cached byte size updated internally in HeaderMap. The value\nis stored as an optional, and is cleared whenever a non-const pointer or\nreference to a HeaderEntry is accessed. The cached value can be set with\nrefreshByteSize() which performs an iteration over the HeaderMap to sum\nthe size of each key and value in the HeaderMap.\n\nSigned-off-by: Asra Ali <asraa@google.com>",
    "commit_hash": "afc39bea36fd436e54262f150c009e8d72db5014",
    "git_url": "https://github.com/envoyproxy/envoy/commit/afc39bea36fd436e54262f150c009e8d72db5014",
    "file_path": "source/common/http/http1/codec_impl.cc",
    "func_name": "ConnectionImpl::onHeaderValue",
    "func_before": "void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    // Ignore trailers.\n    return;\n  }\n\n  const absl::string_view header_value = absl::string_view(data, length);\n\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    // http-parser should filter for this\n    // (https://tools.ietf.org/html/rfc7230#section-3.2.6), but it doesn't today. HeaderStrings\n    // have an invariant that they must not contain embedded zero characters\n    // (NUL, ASCII 0x0).\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}",
    "abstract_func_before": "void ConnectionImpl::onHeaderValue(const char* VAR_0, size_t VAR_1) {\n  if (VAR_2 == HeaderParsingState::Done) {\n    /* COMMENT_0 */\n    return;\n  }\n\n  const absl::string_view VAR_3 = absl::string_view(VAR_0, VAR_1);\n\n  if (VAR_4) {\n    if (!Http::HeaderUtility::headerIsValid(VAR_3)) {\n      ENVOY_CONN_LOG(VAR_5, \"invalid header value: {}\", VAR_6, VAR_3);\n      VAR_7 = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (VAR_3.find('\\0') != absl::string_view::npos) {\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n\n  VAR_2 = HeaderParsingState::Value;\n  VAR_8.append(VAR_0, VAR_1);\n\n  const uint32_t VAR_9 =\n      VAR_10.size() + VAR_8.size() + VAR_11->byteSize();\n  if (VAR_9 > (VAR_12 * 1024)) {\n    VAR_7 = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}",
    "func_graph_path_before": "envoyproxy/envoy/afc39bea36fd436e54262f150c009e8d72db5014/codec_impl.cc/vul/before/1.json",
    "func": "void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    // Ignore trailers.\n    return;\n  }\n\n  const absl::string_view header_value = absl::string_view(data, length);\n\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    // http-parser should filter for this\n    // (https://tools.ietf.org/html/rfc7230#section-3.2.6), but it doesn't today. HeaderStrings\n    // have an invariant that they must not contain embedded zero characters\n    // (NUL, ASCII 0x0).\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n\n  // Verify that the cached value in byte size exists.\n  ASSERT(current_header_map_->byteSize().has_value());\n  const uint32_t total = current_header_field_.size() + current_header_value_.size() +\n                         current_header_map_->byteSize().value();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}",
    "abstract_func": "void ConnectionImpl::onHeaderValue(const char* VAR_0, size_t VAR_1) {\n  if (VAR_2 == HeaderParsingState::Done) {\n    /* COMMENT_0 */\n    return;\n  }\n\n  const absl::string_view VAR_3 = absl::string_view(VAR_0, VAR_1);\n\n  if (VAR_4) {\n    if (!Http::HeaderUtility::headerIsValid(VAR_3)) {\n      ENVOY_CONN_LOG(VAR_5, \"invalid header value: {}\", VAR_6, VAR_3);\n      VAR_7 = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (VAR_3.find('\\0') != absl::string_view::npos) {\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n\n  VAR_2 = HeaderParsingState::Value;\n  VAR_8.append(VAR_0, VAR_1);\n\n  /* COMMENT_5 */\n  ASSERT(VAR_9->byteSize().has_value());\n  const uint32_t VAR_10 = VAR_11.size() + VAR_8.size() +\n                         VAR_9->byteSize().value();\n  if (VAR_10 > (VAR_12 * 1024)) {\n    VAR_7 = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}",
    "func_graph_path": "envoyproxy/envoy/afc39bea36fd436e54262f150c009e8d72db5014/codec_impl.cc/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -24,8 +24,10 @@\n   header_parsing_state_ = HeaderParsingState::Value;\n   current_header_value_.append(data, length);\n \n-  const uint32_t total =\n-      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n+  // Verify that the cached value in byte size exists.\n+  ASSERT(current_header_map_->byteSize().has_value());\n+  const uint32_t total = current_header_field_.size() + current_header_value_.size() +\n+                         current_header_map_->byteSize().value();\n   if (total > (max_request_headers_kb_ * 1024)) {\n     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n     sendProtocolError();",
    "diff_line_info": {
        "deleted_lines": [
            "  const uint32_t total =",
            "      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();"
        ],
        "added_lines": [
            "  // Verify that the cached value in byte size exists.",
            "  ASSERT(current_header_map_->byteSize().has_value());",
            "  const uint32_t total = current_header_field_.size() + current_header_value_.size() +",
            "                         current_header_map_->byteSize().value();"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}