{
    "cve_id": "CVE-2021-45423",
    "cwe_ids": [
        "CWE-120"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "merces/libpe",
    "commit_msg": "Fix typo",
    "commit_hash": "8960f7d710c4d1a43badd2bbf273721248b864f8",
    "git_url": "https://github.com/merces/libpe/commit/8960f7d710c4d1a43badd2bbf273721248b864f8",
    "file_path": "exports.c",
    "func_name": "pe_exports",
    "func_before": "pe_exports_t *pe_exports(pe_ctx_t *ctx) {\n\tif (ctx->cached_data.exports != NULL)\n\t\treturn ctx->cached_data.exports;\n\n\tpe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t));\n\tif (exports == NULL) {\n\t\t// TODO(jweyrich): Should we report an error? If yes, we need a redesign.\n\t\treturn NULL;\n\t}\n\n\texports->err = LIBPE_E_OK;\n\n\tconst IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT);\n\tif (dir == NULL) { \n\t\treturn exports;\n\t}\n\n\tconst uint64_t va = dir->VirtualAddress;\n\tif (va == 0) {\n\t\t// NOTE: This file has no exported symbols.\n\t\treturn exports;\n\t}\n\n\tuint64_t ofs;\n\n\tofs = pe_rva2ofs(ctx, va);\n\tconst IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_DIR;\n\t\treturn exports;\n\t}\n\n\tofs = pe_rva2ofs(ctx, exp->Name);\n\tconst char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, name_ptr, 1)) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;\n\t\treturn exports;\n\t}\n\n\texports->name = strdup(name_ptr);\n\t\n\tconst uint32_t ordinal_base = exp->Base;\n\t\n\tofs = pe_rva2ofs(ctx, exp->AddressOfNames);\n\tconst uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;\n\t\treturn exports;\n\t}\n\n\t// If `NumberOfNames == 0` then all functions are exported by ordinal.\n\t// Otherwise `NumberOfNames` should be equal to `NumberOfFunctions`\n\t// if (exp->NumberOfNames != 0 && exp->NumberOfNames != exp->NumberOfFunctions) {\n\t// \texports->err = LIBPE_E_EXPORTS_FUNC_NEQ_NAMES;\n\t// \treturn exports;\n\t// }\n\n\t//\n\t// The format of IMAGE_EXPORT_DIRECTORY can be seen in http://i.msdn.microsoft.com/dynimg/IC60608.gif\n\t//\n\n\t// We want to use `NumberOfFunctions` for looping as it's the total number of functions/symbols\n\t// exported by the module. On the other hand, `NumberOfNames` is the number of\n\t// functions/symbols exported by name only.\n\n\texports->functions_count = exp->NumberOfFunctions;\n\texports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t));\n\tif (exports->functions == NULL) {\n\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\treturn exports;\n\t}\n\n\tconst uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions);\n\tconst uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames);\n\tconst uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals);\n\n\tuint64_t offsets_to_Names[exp->NumberOfFunctions];\n\tmemset(offsets_to_Names, 0, sizeof(offsets_to_Names));  // This is needed for VLAs.\n\n\t//\n\t// Names\n\t//\n\t\n\tfor (uint32_t i=0; i < exp->NumberOfNames; i++) {\n\t\tuint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i;\n\t\tuint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) {\n\t\t\t// TODO: Should we report something?\n\t\t\tbreak;\n\t\t}\n\t\tconst uint16_t ordinal = *entry_ordinal_list;\n\n\t\tuint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i;\n\t\tuint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) {\n\t\t\t// TODO: Should we report something?\n\t\t\tbreak;\n\t\t}\n\n\t\tconst uint32_t entry_name_rva = *entry_name_list;\n\t\tconst uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);\n\n        if (ordinal < exp->NumberOfFuntions) {\n            offsets_to_Names[ordinal] = entry_name_ofs;\n        }\n\t}\n\n\t//\n\t// Functions\n\t//\n\n\tfor (uint32_t i=0; i < exp->NumberOfFunctions; i++) {\n\t\tuint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i;\n\t\tuint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Add `Base` to the element of `AddressOfNameOrdinals` array to get the correct ordinal..\n\t\t//const uint16_t entry_ordinal = exp->Base + *entry_ordinal_list;\n\t\tconst uint32_t entry_va = *entry_va_list;\n\t\tconst uint64_t entry_name_ofs = offsets_to_Names[i];\n\n\t\t// FIX: Don't need to zero all elements!\n\t\t// FIXME: 300 bytes is enough or too much?\n\t\tchar fname[300];\n\t\tfname[0] = 0;\n\n\t\tif (entry_name_ofs != 0) {\n\t\t\tconst char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs);\n\n\t\t\t// Validate whether it's ok to access at least 1 byte after entry_name.\n\t\t\t// It might be '\\0', for example.\n\t\t\tif (!pe_can_read(ctx, entry_name, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//printf(\"ord=%d, va=%x, name=%s\\n\", entry_ordinal, entry_va, entry_name);\n\n\t\t\tconst size_t fname_size = sizeof(fname);\n\t\t\tstrncpy(fname, entry_name, fname_size-1);\n\t\t\t// Because `strncpy` does not guarantee to NUL terminate the string itself, this must be done explicitly.\n\t\t\tfname[fname_size - 1] = '\\0';\n\t\t}\n\n\t\texports->functions[i].ordinal = ordinal_base + i;\n\t\texports->functions[i].address = entry_va;\n\n\t\texports->functions[i].name = strdup(fname);\n\t\tif (exports->functions[i].name == NULL) {\n\t\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\t\treturn exports;\n\t\t}\n\n\t\t// Check whether the exported function is forwarded.\n\t\t// It's forwarded if its RVA is inside the exports section.\n\t\tif (entry_va >= va && entry_va <= va + dir->Size) {\n\t\t\t// When a symbol is forwarded, its RVA points to a string containing\n\t\t\t// the name of the DLL and symbol to which it is forwarded.\n\t\t\tconst uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va);\n\t\t\tconst char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs);\n\n\t\t\t// Validate whether it's ok to access at least 1 byte after fw_entry_name.\n\t\t\t// It might be '\\0', for example.\n\t\t\tif (!pe_can_read(ctx, fw_entry_name, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\texports->functions[i].fwd_name = strdup(fw_entry_name);\n\t\t\tif (exports->functions[i].fwd_name == NULL) {\n\t\t\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\t\t\treturn exports;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn exports;\n}",
    "abstract_func_before": "pe_exports_t *pe_exports(pe_ctx_t *VAR_0) {\n\tif (VAR_0->cached_data.exports != NULL)\n\t\treturn VAR_0->cached_data.exports;\n\n\tpe_exports_t *VAR_1 = VAR_0->cached_data.exports = calloc(1, sizeof(pe_exports_t));\n\tif (VAR_1 == NULL) {\n\t\t/* COMMENT_0 */\n\t\treturn NULL;\n\t}\n\n\tVAR_1->err = VAR_2;\n\n\tconst IMAGE_DATA_DIRECTORY *VAR_3 = pe_directory_by_entry(VAR_0, VAR_4);\n\tif (VAR_3 == NULL) { \n\t\treturn VAR_1;\n\t}\n\n\tconst uint64_t VAR_5 = VAR_3->VirtualAddress;\n\tif (VAR_5 == 0) {\n\t\t/* COMMENT_1 */\n\t\treturn VAR_1;\n\t}\n\n\tuint64_t VAR_6;\n\n\tVAR_6 = pe_rva2ofs(VAR_0, VAR_5);\n\tconst IMAGE_EXPORT_DIRECTORY *VAR_7 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);\n\tif (!pe_can_read(VAR_0, VAR_7, sizeof(IMAGE_EXPORT_DIRECTORY))) {\n\t\tVAR_1->err = VAR_8;\n\t\treturn VAR_1;\n\t}\n\n\tVAR_6 = pe_rva2ofs(VAR_0, VAR_7->Name);\n\tconst char *VAR_9 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);\n\tif (!pe_can_read(VAR_0, VAR_9, 1)) {\n\t\tVAR_1->err = VAR_10;\n\t\treturn VAR_1;\n\t}\n\n\tVAR_1->name = strdup(VAR_9);\n\t\n\tconst uint32_t VAR_11 = VAR_7->Base;\n\t\n\tVAR_6 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);\n\tconst uint32_t *VAR_12 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);\n\tif (!pe_can_read(VAR_0, VAR_12, sizeof(uint32_t))) {\n\t\tVAR_1->err = VAR_10;\n\t\treturn VAR_1;\n\t}\n\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\t/* COMMENT_7 */\n\n\t/* COMMENT_8 */\n\t/* COMMENT_9 */\n\t/* COMMENT_8 */\n\n\t/* COMMENT_10 */\n\t/* COMMENT_11 */\n\t/* COMMENT_12 */\n\n\tVAR_1->functions_count = VAR_7->NumberOfFunctions;\n\tVAR_1->functions = calloc(VAR_7->NumberOfFunctions, sizeof(VAR_13));\n\tif (VAR_1->functions == NULL) {\n\t\tVAR_1->err = VAR_14;\n\t\treturn VAR_1;\n\t}\n\n\tconst uint64_t VAR_15 = pe_rva2ofs(VAR_0, VAR_7->AddressOfFunctions);\n\tconst uint64_t VAR_16 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);\n\tconst uint64_t VAR_17 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNameOrdinals);\n\n\tuint64_t VAR_18[VAR_7->NumberOfFunctions];\n\tmemset(VAR_18, 0, sizeof(VAR_18));  /* COMMENT_13 */\n\n\t/* COMMENT_8 */\n\t/* COMMENT_14 */\n\t/* COMMENT_8 */\n\t\n\tfor (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfNames; VAR_19++) {\n\t\tuint64_t VAR_20 = VAR_17 + sizeof(uint16_t) * VAR_19;\n\t\tuint16_t *VAR_21 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_20);\n\n\t\tif (!pe_can_read(VAR_0, VAR_21, sizeof(uint16_t))) {\n\t\t\t/* COMMENT_15 */\n\t\t\tbreak;\n\t\t}\n\t\tconst uint16_t VAR_22 = *VAR_21;\n\n\t\tuint64_t VAR_23 = VAR_16 + sizeof(uint32_t) * VAR_19;\n\t\tuint32_t *VAR_24 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_23);\n\n\t\tif (!pe_can_read(VAR_0, VAR_24, sizeof(uint32_t))) {\n\t\t\t/* COMMENT_15 */\n\t\t\tbreak;\n\t\t}\n\n\t\tconst uint32_t VAR_25 = *VAR_24;\n\t\tconst uint64_t VAR_26 = pe_rva2ofs(VAR_0, VAR_25);\n\n        if (VAR_22 < VAR_7->NumberOfFuntions) {\n            VAR_18[VAR_22] = VAR_26;\n        }\n\t}\n\n\t/* COMMENT_8 */\n\t/* COMMENT_16 */\n\t/* COMMENT_8 */\n\n\tfor (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfFunctions; VAR_19++) {\n\t\tuint64_t VAR_27 = VAR_15 + sizeof(uint32_t) * VAR_19;\n\t\tuint32_t *VAR_28 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_27);\n\n\t\tif (!pe_can_read(VAR_0, VAR_28, sizeof(uint32_t))) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\tconst uint32_t VAR_29 = *VAR_28;\n\t\tconst uint64_t VAR_26 = VAR_18[VAR_19];\n\n\t\t/* COMMENT_19 */\n\t\t/* COMMENT_20 */\n\t\tchar VAR_30[300];\n\t\tVAR_30[0] = 0;\n\n\t\tif (VAR_26 != 0) {\n\t\t\tconst char *VAR_31 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_26);\n\n\t\t\t/* COMMENT_21 */\n\t\t\t/* COMMENT_22 */\n\t\t\tif (!pe_can_read(VAR_0, VAR_31, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* COMMENT_23 */\n\n\t\t\tconst size_t VAR_32 = sizeof(VAR_30);\n\t\t\tstrncpy(VAR_30, VAR_31, VAR_32-1);\n\t\t\t/* COMMENT_24 */\n\t\t\tVAR_30[VAR_32 - 1] = '\\0';\n\t\t}\n\n\t\tVAR_1->functions[VAR_19].ordinal = VAR_11 + VAR_19;\n\t\tVAR_1->functions[VAR_19].address = VAR_29;\n\n\t\tVAR_1->functions[VAR_19].name = strdup(VAR_30);\n\t\tif (VAR_1->functions[VAR_19].name == NULL) {\n\t\t\tVAR_1->err = VAR_14;\n\t\t\treturn VAR_1;\n\t\t}\n\n\t\t/* COMMENT_25 */\n\t\t/* COMMENT_26 */\n\t\tif (VAR_29 >= VAR_5 && VAR_29 <= VAR_5 + VAR_3->Size) {\n\t\t\t/* COMMENT_27 */\n\t\t\t/* COMMENT_28 */\n\t\t\tconst uint64_t VAR_33 = pe_rva2ofs(VAR_0, VAR_29);\n\t\t\tconst char *VAR_34 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_33);\n\n\t\t\t/* COMMENT_29 */\n\t\t\t/* COMMENT_22 */\n\t\t\tif (!pe_can_read(VAR_0, VAR_34, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_1->functions[VAR_19].fwd_name = strdup(VAR_34);\n\t\t\tif (VAR_1->functions[VAR_19].fwd_name == NULL) {\n\t\t\t\tVAR_1->err = VAR_14;\n\t\t\t\treturn VAR_1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn VAR_1;\n}",
    "func_graph_path_before": "merces/libpe/8960f7d710c4d1a43badd2bbf273721248b864f8/exports.c/vul/before/0.json",
    "func": "pe_exports_t *pe_exports(pe_ctx_t *ctx) {\n\tif (ctx->cached_data.exports != NULL)\n\t\treturn ctx->cached_data.exports;\n\n\tpe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t));\n\tif (exports == NULL) {\n\t\t// TODO(jweyrich): Should we report an error? If yes, we need a redesign.\n\t\treturn NULL;\n\t}\n\n\texports->err = LIBPE_E_OK;\n\n\tconst IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT);\n\tif (dir == NULL) { \n\t\treturn exports;\n\t}\n\n\tconst uint64_t va = dir->VirtualAddress;\n\tif (va == 0) {\n\t\t// NOTE: This file has no exported symbols.\n\t\treturn exports;\n\t}\n\n\tuint64_t ofs;\n\n\tofs = pe_rva2ofs(ctx, va);\n\tconst IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_DIR;\n\t\treturn exports;\n\t}\n\n\tofs = pe_rva2ofs(ctx, exp->Name);\n\tconst char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, name_ptr, 1)) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;\n\t\treturn exports;\n\t}\n\n\texports->name = strdup(name_ptr);\n\t\n\tconst uint32_t ordinal_base = exp->Base;\n\t\n\tofs = pe_rva2ofs(ctx, exp->AddressOfNames);\n\tconst uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;\n\t\treturn exports;\n\t}\n\n\t// If `NumberOfNames == 0` then all functions are exported by ordinal.\n\t// Otherwise `NumberOfNames` should be equal to `NumberOfFunctions`\n\t// if (exp->NumberOfNames != 0 && exp->NumberOfNames != exp->NumberOfFunctions) {\n\t// \texports->err = LIBPE_E_EXPORTS_FUNC_NEQ_NAMES;\n\t// \treturn exports;\n\t// }\n\n\t//\n\t// The format of IMAGE_EXPORT_DIRECTORY can be seen in http://i.msdn.microsoft.com/dynimg/IC60608.gif\n\t//\n\n\t// We want to use `NumberOfFunctions` for looping as it's the total number of functions/symbols\n\t// exported by the module. On the other hand, `NumberOfNames` is the number of\n\t// functions/symbols exported by name only.\n\n\texports->functions_count = exp->NumberOfFunctions;\n\texports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t));\n\tif (exports->functions == NULL) {\n\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\treturn exports;\n\t}\n\n\tconst uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions);\n\tconst uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames);\n\tconst uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals);\n\n\tuint64_t offsets_to_Names[exp->NumberOfFunctions];\n\tmemset(offsets_to_Names, 0, sizeof(offsets_to_Names));  // This is needed for VLAs.\n\n\t//\n\t// Names\n\t//\n\t\n\tfor (uint32_t i=0; i < exp->NumberOfNames; i++) {\n\t\tuint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i;\n\t\tuint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) {\n\t\t\t// TODO: Should we report something?\n\t\t\tbreak;\n\t\t}\n\t\tconst uint16_t ordinal = *entry_ordinal_list;\n\n\t\tuint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i;\n\t\tuint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) {\n\t\t\t// TODO: Should we report something?\n\t\t\tbreak;\n\t\t}\n\n\t\tconst uint32_t entry_name_rva = *entry_name_list;\n\t\tconst uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);\n\n        if (ordinal < exp->NumberOfFunctions) {\n            offsets_to_Names[ordinal] = entry_name_ofs;\n        }\n\t}\n\n\t//\n\t// Functions\n\t//\n\n\tfor (uint32_t i=0; i < exp->NumberOfFunctions; i++) {\n\t\tuint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i;\n\t\tuint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Add `Base` to the element of `AddressOfNameOrdinals` array to get the correct ordinal..\n\t\t//const uint16_t entry_ordinal = exp->Base + *entry_ordinal_list;\n\t\tconst uint32_t entry_va = *entry_va_list;\n\t\tconst uint64_t entry_name_ofs = offsets_to_Names[i];\n\n\t\t// FIX: Don't need to zero all elements!\n\t\t// FIXME: 300 bytes is enough or too much?\n\t\tchar fname[300];\n\t\tfname[0] = 0;\n\n\t\tif (entry_name_ofs != 0) {\n\t\t\tconst char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs);\n\n\t\t\t// Validate whether it's ok to access at least 1 byte after entry_name.\n\t\t\t// It might be '\\0', for example.\n\t\t\tif (!pe_can_read(ctx, entry_name, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//printf(\"ord=%d, va=%x, name=%s\\n\", entry_ordinal, entry_va, entry_name);\n\n\t\t\tconst size_t fname_size = sizeof(fname);\n\t\t\tstrncpy(fname, entry_name, fname_size-1);\n\t\t\t// Because `strncpy` does not guarantee to NUL terminate the string itself, this must be done explicitly.\n\t\t\tfname[fname_size - 1] = '\\0';\n\t\t}\n\n\t\texports->functions[i].ordinal = ordinal_base + i;\n\t\texports->functions[i].address = entry_va;\n\n\t\texports->functions[i].name = strdup(fname);\n\t\tif (exports->functions[i].name == NULL) {\n\t\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\t\treturn exports;\n\t\t}\n\n\t\t// Check whether the exported function is forwarded.\n\t\t// It's forwarded if its RVA is inside the exports section.\n\t\tif (entry_va >= va && entry_va <= va + dir->Size) {\n\t\t\t// When a symbol is forwarded, its RVA points to a string containing\n\t\t\t// the name of the DLL and symbol to which it is forwarded.\n\t\t\tconst uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va);\n\t\t\tconst char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs);\n\n\t\t\t// Validate whether it's ok to access at least 1 byte after fw_entry_name.\n\t\t\t// It might be '\\0', for example.\n\t\t\tif (!pe_can_read(ctx, fw_entry_name, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\texports->functions[i].fwd_name = strdup(fw_entry_name);\n\t\t\tif (exports->functions[i].fwd_name == NULL) {\n\t\t\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\t\t\treturn exports;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn exports;\n}",
    "abstract_func": "pe_exports_t *pe_exports(pe_ctx_t *VAR_0) {\n\tif (VAR_0->cached_data.exports != NULL)\n\t\treturn VAR_0->cached_data.exports;\n\n\tpe_exports_t *VAR_1 = VAR_0->cached_data.exports = calloc(1, sizeof(pe_exports_t));\n\tif (VAR_1 == NULL) {\n\t\t/* COMMENT_0 */\n\t\treturn NULL;\n\t}\n\n\tVAR_1->err = VAR_2;\n\n\tconst IMAGE_DATA_DIRECTORY *VAR_3 = pe_directory_by_entry(VAR_0, VAR_4);\n\tif (VAR_3 == NULL) { \n\t\treturn VAR_1;\n\t}\n\n\tconst uint64_t VAR_5 = VAR_3->VirtualAddress;\n\tif (VAR_5 == 0) {\n\t\t/* COMMENT_1 */\n\t\treturn VAR_1;\n\t}\n\n\tuint64_t VAR_6;\n\n\tVAR_6 = pe_rva2ofs(VAR_0, VAR_5);\n\tconst IMAGE_EXPORT_DIRECTORY *VAR_7 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);\n\tif (!pe_can_read(VAR_0, VAR_7, sizeof(IMAGE_EXPORT_DIRECTORY))) {\n\t\tVAR_1->err = VAR_8;\n\t\treturn VAR_1;\n\t}\n\n\tVAR_6 = pe_rva2ofs(VAR_0, VAR_7->Name);\n\tconst char *VAR_9 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);\n\tif (!pe_can_read(VAR_0, VAR_9, 1)) {\n\t\tVAR_1->err = VAR_10;\n\t\treturn VAR_1;\n\t}\n\n\tVAR_1->name = strdup(VAR_9);\n\t\n\tconst uint32_t VAR_11 = VAR_7->Base;\n\t\n\tVAR_6 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);\n\tconst uint32_t *VAR_12 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);\n\tif (!pe_can_read(VAR_0, VAR_12, sizeof(uint32_t))) {\n\t\tVAR_1->err = VAR_10;\n\t\treturn VAR_1;\n\t}\n\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\t/* COMMENT_7 */\n\n\t/* COMMENT_8 */\n\t/* COMMENT_9 */\n\t/* COMMENT_8 */\n\n\t/* COMMENT_10 */\n\t/* COMMENT_11 */\n\t/* COMMENT_12 */\n\n\tVAR_1->functions_count = VAR_7->NumberOfFunctions;\n\tVAR_1->functions = calloc(VAR_7->NumberOfFunctions, sizeof(VAR_13));\n\tif (VAR_1->functions == NULL) {\n\t\tVAR_1->err = VAR_14;\n\t\treturn VAR_1;\n\t}\n\n\tconst uint64_t VAR_15 = pe_rva2ofs(VAR_0, VAR_7->AddressOfFunctions);\n\tconst uint64_t VAR_16 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);\n\tconst uint64_t VAR_17 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNameOrdinals);\n\n\tuint64_t VAR_18[VAR_7->NumberOfFunctions];\n\tmemset(VAR_18, 0, sizeof(VAR_18));  /* COMMENT_13 */\n\n\t/* COMMENT_8 */\n\t/* COMMENT_14 */\n\t/* COMMENT_8 */\n\t\n\tfor (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfNames; VAR_19++) {\n\t\tuint64_t VAR_20 = VAR_17 + sizeof(uint16_t) * VAR_19;\n\t\tuint16_t *VAR_21 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_20);\n\n\t\tif (!pe_can_read(VAR_0, VAR_21, sizeof(uint16_t))) {\n\t\t\t/* COMMENT_15 */\n\t\t\tbreak;\n\t\t}\n\t\tconst uint16_t VAR_22 = *VAR_21;\n\n\t\tuint64_t VAR_23 = VAR_16 + sizeof(uint32_t) * VAR_19;\n\t\tuint32_t *VAR_24 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_23);\n\n\t\tif (!pe_can_read(VAR_0, VAR_24, sizeof(uint32_t))) {\n\t\t\t/* COMMENT_15 */\n\t\t\tbreak;\n\t\t}\n\n\t\tconst uint32_t VAR_25 = *VAR_24;\n\t\tconst uint64_t VAR_26 = pe_rva2ofs(VAR_0, VAR_25);\n\n        if (VAR_22 < VAR_7->NumberOfFunctions) {\n            VAR_18[VAR_22] = VAR_26;\n        }\n\t}\n\n\t/* COMMENT_8 */\n\t/* COMMENT_16 */\n\t/* COMMENT_8 */\n\n\tfor (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfFunctions; VAR_19++) {\n\t\tuint64_t VAR_27 = VAR_15 + sizeof(uint32_t) * VAR_19;\n\t\tuint32_t *VAR_28 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_27);\n\n\t\tif (!pe_can_read(VAR_0, VAR_28, sizeof(uint32_t))) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\tconst uint32_t VAR_29 = *VAR_28;\n\t\tconst uint64_t VAR_26 = VAR_18[VAR_19];\n\n\t\t/* COMMENT_19 */\n\t\t/* COMMENT_20 */\n\t\tchar VAR_30[300];\n\t\tVAR_30[0] = 0;\n\n\t\tif (VAR_26 != 0) {\n\t\t\tconst char *VAR_31 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_26);\n\n\t\t\t/* COMMENT_21 */\n\t\t\t/* COMMENT_22 */\n\t\t\tif (!pe_can_read(VAR_0, VAR_31, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* COMMENT_23 */\n\n\t\t\tconst size_t VAR_32 = sizeof(VAR_30);\n\t\t\tstrncpy(VAR_30, VAR_31, VAR_32-1);\n\t\t\t/* COMMENT_24 */\n\t\t\tVAR_30[VAR_32 - 1] = '\\0';\n\t\t}\n\n\t\tVAR_1->functions[VAR_19].ordinal = VAR_11 + VAR_19;\n\t\tVAR_1->functions[VAR_19].address = VAR_29;\n\n\t\tVAR_1->functions[VAR_19].name = strdup(VAR_30);\n\t\tif (VAR_1->functions[VAR_19].name == NULL) {\n\t\t\tVAR_1->err = VAR_14;\n\t\t\treturn VAR_1;\n\t\t}\n\n\t\t/* COMMENT_25 */\n\t\t/* COMMENT_26 */\n\t\tif (VAR_29 >= VAR_5 && VAR_29 <= VAR_5 + VAR_3->Size) {\n\t\t\t/* COMMENT_27 */\n\t\t\t/* COMMENT_28 */\n\t\t\tconst uint64_t VAR_33 = pe_rva2ofs(VAR_0, VAR_29);\n\t\t\tconst char *VAR_34 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_33);\n\n\t\t\t/* COMMENT_29 */\n\t\t\t/* COMMENT_22 */\n\t\t\tif (!pe_can_read(VAR_0, VAR_34, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_1->functions[VAR_19].fwd_name = strdup(VAR_34);\n\t\t\tif (VAR_1->functions[VAR_19].fwd_name == NULL) {\n\t\t\t\tVAR_1->err = VAR_14;\n\t\t\t\treturn VAR_1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn VAR_1;\n}",
    "func_graph_path": "merces/libpe/8960f7d710c4d1a43badd2bbf273721248b864f8/exports.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -102,7 +102,7 @@\n \t\tconst uint32_t entry_name_rva = *entry_name_list;\n \t\tconst uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);\n \n-        if (ordinal < exp->NumberOfFuntions) {\n+        if (ordinal < exp->NumberOfFunctions) {\n             offsets_to_Names[ordinal] = entry_name_ofs;\n         }\n \t}",
    "diff_line_info": {
        "deleted_lines": [
            "        if (ordinal < exp->NumberOfFuntions) {"
        ],
        "added_lines": [
            "        if (ordinal < exp->NumberOfFunctions) {"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/merces/libpe/pull/36",
    "description": "\u2026n element in an array\r\n\r\nFixes #35."
}