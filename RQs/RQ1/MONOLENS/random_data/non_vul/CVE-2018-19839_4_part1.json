{
    "cve_id": "CVE-2018-19839",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "sass/libsass",
    "commit_msg": "Update utfcpp to v2.3.6\n\nFixes #2657\n\nIncorporates the following utfcpp patches:\n\n1. Sass addition of `retreat`.\n   https://github.com/nemtrif/utfcpp/pull/20\n\n2. Fix for `replace_invalid` throwing on incomplete sequence at the end\n   of the input.\n   https://github.com/nemtrif/utfcpp/pull/21",
    "commit_hash": "a2dff1b59ea8c8ec10680f9e8e5593e4b38554a1",
    "git_url": "https://github.com/sass/libsass/commit/a2dff1b59ea8c8ec10680f9e8e5593e4b38554a1",
    "file_path": "src/utf8/core.h",
    "func_name": "validate_next",
    "func_before": "utf_error validate_next(octet_iterator& it, octet_iterator end, uint32_t& code_point)\n    {\n        // Save the original value of it so we can go back in case of failure\n        // Of course, it does not make much sense with i.e. stream iterators\n        octet_iterator original_it = it;\n\n        uint32_t cp = 0;\n        // Determine the sequence length based on the lead octet\n        typedef typename std::iterator_traits<octet_iterator>::difference_type octet_difference_type;\n        const octet_difference_type length = utf8::internal::sequence_length(it);\n\n        // Get trail octets and calculate the code point\n        utf_error err = UTF8_OK;\n        switch (length) {\n            case 0:\n                return INVALID_LEAD;\n            case 1:\n                err = utf8::internal::get_sequence_1(it, end, cp);\n                break;\n            case 2:\n                err = utf8::internal::get_sequence_2(it, end, cp);\n            break;\n            case 3:\n                err = utf8::internal::get_sequence_3(it, end, cp);\n            break;\n            case 4:\n                err = utf8::internal::get_sequence_4(it, end, cp);\n            break;\n        }\n\n        if (err == UTF8_OK) {\n            // Decoding succeeded. Now, security checks...\n            if (utf8::internal::is_code_point_valid(cp)) {\n                if (!utf8::internal::is_overlong_sequence(cp, length)){\n                    // Passed! Return here.\n                    code_point = cp;\n                    ++it;\n                    return UTF8_OK;\n                }\n                else\n                    err = OVERLONG_SEQUENCE;\n            }\n            else\n                err = INVALID_CODE_POINT;\n        }\n\n        // Failure branch - restore the original value of the iterator\n        it = original_it;\n        return err;\n    }",
    "abstract_func_before": "utf_error validate_next(octet_iterator& VAR_0, octet_iterator VAR_1, uint32_t& VAR_2)\n    {\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        octet_iterator VAR_3 = VAR_0;\n\n        uint32_t VAR_4 = 0;\n        /* COMMENT_2 */\n        typedef typename std::iterator_traits<octet_iterator>::difference_type octet_difference_type;\n        const octet_difference_type VAR_5 = utf8::internal::sequence_length(VAR_0);\n\n        /* COMMENT_3 */\n        utf_error VAR_6 = VAR_7;\n        switch (VAR_5) {\n            case 0:\n                return VAR_8;\n            case 1:\n                VAR_6 = utf8::internal::get_sequence_1(VAR_0, VAR_1, VAR_4);\n                break;\n            case 2:\n                VAR_6 = utf8::internal::get_sequence_2(VAR_0, VAR_1, VAR_4);\n            break;\n            case 3:\n                VAR_6 = utf8::internal::get_sequence_3(VAR_0, VAR_1, VAR_4);\n            break;\n            case 4:\n                VAR_6 = utf8::internal::get_sequence_4(VAR_0, VAR_1, VAR_4);\n            break;\n        }\n\n        if (VAR_6 == VAR_7) {\n            /* COMMENT_4 */\n            if (utf8::internal::is_code_point_valid(VAR_4)) {\n                if (!utf8::internal::is_overlong_sequence(VAR_4, VAR_5)){\n                    /* COMMENT_5 */\n                    VAR_2 = VAR_4;\n                    ++VAR_0;\n                    return VAR_7;\n                }\n                else\n                    VAR_6 = VAR_9;\n            }\n            else\n                VAR_6 = VAR_10;\n        }\n\n        /* COMMENT_6 */\n        VAR_0 = VAR_3;\n        return VAR_6;\n    }",
    "func_graph_path_before": "sass/libsass/a2dff1b59ea8c8ec10680f9e8e5593e4b38554a1/core.h/vul/before/0.json",
    "func": "utf_error validate_next(octet_iterator& it, octet_iterator end, uint32_t& code_point)\n    {\n        if (it == end)\n            return NOT_ENOUGH_ROOM;\n\n        // Save the original value of it so we can go back in case of failure\n        // Of course, it does not make much sense with i.e. stream iterators\n        octet_iterator original_it = it;\n\n        uint32_t cp = 0;\n        // Determine the sequence length based on the lead octet\n        typedef typename std::iterator_traits<octet_iterator>::difference_type octet_difference_type;\n        const octet_difference_type length = utf8::internal::sequence_length(it);\n\n        // Get trail octets and calculate the code point\n        utf_error err = UTF8_OK;\n        switch (length) {\n            case 0:\n                return INVALID_LEAD;\n            case 1:\n                err = utf8::internal::get_sequence_1(it, end, cp);\n                break;\n            case 2:\n                err = utf8::internal::get_sequence_2(it, end, cp);\n            break;\n            case 3:\n                err = utf8::internal::get_sequence_3(it, end, cp);\n            break;\n            case 4:\n                err = utf8::internal::get_sequence_4(it, end, cp);\n            break;\n        }\n\n        if (err == UTF8_OK) {\n            // Decoding succeeded. Now, security checks...\n            if (utf8::internal::is_code_point_valid(cp)) {\n                if (!utf8::internal::is_overlong_sequence(cp, length)){\n                    // Passed! Return here.\n                    code_point = cp;\n                    ++it;\n                    return UTF8_OK;\n                }\n                else\n                    err = OVERLONG_SEQUENCE;\n            }\n            else\n                err = INVALID_CODE_POINT;\n        }\n\n        // Failure branch - restore the original value of the iterator\n        it = original_it;\n        return err;\n    }",
    "abstract_func": "utf_error validate_next(octet_iterator& VAR_0, octet_iterator VAR_1, uint32_t& VAR_2)\n    {\n        if (VAR_0 == VAR_1)\n            return VAR_3;\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        octet_iterator VAR_4 = VAR_0;\n\n        uint32_t VAR_5 = 0;\n        /* COMMENT_2 */\n        typedef typename std::iterator_traits<octet_iterator>::difference_type octet_difference_type;\n        const octet_difference_type VAR_6 = utf8::internal::sequence_length(VAR_0);\n\n        /* COMMENT_3 */\n        utf_error VAR_7 = VAR_8;\n        switch (VAR_6) {\n            case 0:\n                return VAR_9;\n            case 1:\n                VAR_7 = utf8::internal::get_sequence_1(VAR_0, VAR_1, VAR_5);\n                break;\n            case 2:\n                VAR_7 = utf8::internal::get_sequence_2(VAR_0, VAR_1, VAR_5);\n            break;\n            case 3:\n                VAR_7 = utf8::internal::get_sequence_3(VAR_0, VAR_1, VAR_5);\n            break;\n            case 4:\n                VAR_7 = utf8::internal::get_sequence_4(VAR_0, VAR_1, VAR_5);\n            break;\n        }\n\n        if (VAR_7 == VAR_8) {\n            /* COMMENT_4 */\n            if (utf8::internal::is_code_point_valid(VAR_5)) {\n                if (!utf8::internal::is_overlong_sequence(VAR_5, VAR_6)){\n                    /* COMMENT_5 */\n                    VAR_2 = VAR_5;\n                    ++VAR_0;\n                    return VAR_8;\n                }\n                else\n                    VAR_7 = VAR_10;\n            }\n            else\n                VAR_7 = VAR_11;\n        }\n\n        /* COMMENT_6 */\n        VAR_0 = VAR_4;\n        return VAR_7;\n    }",
    "func_graph_path": "sass/libsass/a2dff1b59ea8c8ec10680f9e8e5593e4b38554a1/core.h/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n utf_error validate_next(octet_iterator& it, octet_iterator end, uint32_t& code_point)\n     {\n+        if (it == end)\n+            return NOT_ENOUGH_ROOM;\n+\n         // Save the original value of it so we can go back in case of failure\n         // Of course, it does not make much sense with i.e. stream iterators\n         octet_iterator original_it = it;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "        if (it == end)",
            "            return NOT_ENOUGH_ROOM;",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/sass/libsass/pull/2767",
    "description": "Updates to v2.3.6 with the following patches:\r\n\r\n1. Sass addition of `retreat`. https://github.com/nemtrif/utfcpp/pull/20\r\n\r\n2. Fix for `replace_invalid` throwing on incomplete sequence at the end of the input. https://github.com/nemtrif/utfcpp/pull/21\r\n\r\nFixes #2657. The buffer overflow had already been fixed in #2755. This PR also fixes the error message: previously it just said `Internal Error: Not enough space`, now it outputs the correct error with trace, such as:\r\n\r\n```\r\nError: Invalid UTF-8 sequence\r\n        on line 1:1 of ../../../tmp/libsass-2657/test_m001.txt\r\n>> \ufffd\r\n   ^\r\n```"
}