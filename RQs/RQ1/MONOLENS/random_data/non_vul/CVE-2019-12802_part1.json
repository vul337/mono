{
    "cve_id": "CVE-2019-12802",
    "cwe_ids": [
        "CWE-416"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "radareorg/radare2",
    "commit_msg": "Fix #14296 - Segfault in ragg2 (#14308)",
    "commit_hash": "93af319e0af787ede96537d46210369f5c24240c",
    "git_url": "https://github.com/radareorg/radare2/commit/93af319e0af787ede96537d46210369f5c24240c",
    "file_path": "libr/egg/egg_lang.c",
    "func_name": "r_egg_lang_parsechar",
    "func_before": "R_API int r_egg_lang_parsechar(REgg *egg, char c) {\n\tREggEmit *e = egg->remit;\n\tchar *ptr, str[64], *tmp_ptr = NULL;\n\tint i, j;\n\tif (c == '\\n') {\n\t\tegg->lang.line++;\n\t\tegg->lang.elem_n = 0;\n\t}\n\t/* comments */\n\tif (egg->lang.skipline) {\n\t\tif (c != '\\n') {\n\t\t\tegg->lang.oc = c;\n\t\t\treturn 0;\n\t\t}\n\t\tegg->lang.skipline = 0;\n\t}\n\tif (egg->lang.mode == DATA) {\n\t\treturn parsedatachar (egg, c);\n\t}\n\tif (egg->lang.mode == INLINE) {\n\t\treturn parseinlinechar (egg, c);\n\t}\n\t/* quotes */\n\tif (egg->lang.quoteline) {\n\t\tif (c != egg->lang.quoteline) {\n\t\t\tif (egg->lang.quotelinevar == 1) {\n\t\t\t\tif (c == '`') {\n\t\t\t\t\tegg->lang.elem[egg->lang.elem_n] = 0;\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\ttmp_ptr = r_egg_mkvar (egg, str, egg->lang.elem, 0);\n\t\t\t\t\tr_egg_printf (egg, \"%s\", tmp_ptr);\n\t\t\t\t\tfree (tmp_ptr);\n\t\t\t\t\tegg->lang.quotelinevar = 0;\n\t\t\t\t} else {\n\t\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c == '`') {\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\tegg->lang.quotelinevar = 1;\n\t\t\t\t} else {\n\t\t\t\t\tr_egg_printf (egg, \"%c\", c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tegg->lang.oc = c;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tr_egg_printf (egg, \"\\n\");\n\t\t\tegg->lang.quoteline = 0;\n\t\t}\n\t}\n\n\tif (egg->lang.commentmode) {\n\t\tif (c == '/' && egg->lang.oc == '*') {\n\t\t\tegg->lang.commentmode = 0;\n\t\t}\n\t\tegg->lang.oc = c;\n\t\treturn 0;\n\t} else if (c == '*' && egg->lang.oc == '/') {\n\t\tegg->lang.commentmode = 1;\n\t}\n\tif (egg->lang.slurp) {\n\t\tif (egg->lang.slurp != '\"' && c == egg->lang.slurpin) {\t// only happend when (...(...)...)\n\t\t\texit (eprintf (\n\t\t\t\t\t\"%s:%d Nesting of expressions not yet supported\\n\",\n\t\t\t\t\tegg->lang.file, egg->lang.line));\n\t\t}\n\t\tif (c == egg->lang.slurp && egg->lang.oc != '\\\\') {\t// close egg->lang.slurp\n\t\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t\t\tif (egg->lang.elem_n > 0) {\n\t\t\t\trcc_element (egg, egg->lang.elem);\n\t\t\t} else {\n\t\t\t\te->frame (egg, 0);\n\t\t\t}\n\t\t\tegg->lang.elem_n = 0;\n\t\t\tegg->lang.slurp = 0;\n\t\t} else {\n\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t}\n\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t} else {\n\t\tswitch (c) {\n\t\tcase ';':\n\t\t\trcc_next (egg);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tegg->lang.slurp = '\"';\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tegg->lang.slurpin = '(';\n\t\t\tegg->lang.slurp = ')';\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (CTX > 0) {\n\t\t\t\t// r_egg_printf (egg, \" %s:\\n\", get_frame_label (0));\n\t\t\t\tif (egg->lang.nested_callname[CTX] && strstr (egg->lang.nested_callname[CTX], \"if\") &&\n\t\t\t\t    strstr (egg->lang.elem, \"else\")) {\n\t\t\t\t\t*egg->lang.elem = '\\x00';\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\tR_FREE (egg->lang.ifelse_table[CTX][egg->lang.nestedi[CTX] - 1])\n\t\t\t\t\tegg->lang.ifelse_table[CTX][egg->lang.nestedi[CTX] - 1] =\n\t\t\t\t\t\tr_str_newf (\"  __end_%d_%d_%d\",\n\t\t\t\t\t\t\tegg->lang.nfunctions, CTX, egg->lang.nestedi[CTX]);\n\t\t\t\t}\n\t\t\t\tr_egg_printf (egg, \"  __begin_%d_%d_%d:\\n\",\n\t\t\t\t\tegg->lang.nfunctions, CTX, egg->lang.nestedi[CTX]);\t// %s:\\n\", get_frame_label (0));\n\t\t\t}\n\t\t\trcc_context (egg, 1);\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tegg->lang.endframe = egg->lang.nested[CTX];\n\t\t\tif (egg->lang.endframe) {\n\t\t\t\t// XXX: use egg->lang.endframe[context]\n\t\t\t\tr_egg_printf (egg, \"%s\", egg->lang.endframe);\n\t\t\t\tR_FREE (egg->lang.nested[CTX]);\n\t\t\t\t// R_FREE (egg->lang.endframe);\n\t\t\t}\n\t\t\tif (CTX > 1) {\n\t\t\t\tif (egg->lang.nested_callname[CTX - 1] && strstr (egg->lang.nested_callname[CTX - 1], \"if\")) {\n\t\t\t\t\ttmp_ptr = r_str_newf (\"__ifelse_%d_%d\", CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t\te->jmp (egg, tmp_ptr, 0);\n\t\t\t\t\tR_FREE (tmp_ptr);\t// mem leak\n\t\t\t\t\tegg->lang.ifelse_table[CTX - 1][egg->lang.nestedi[CTX - 1] - 1] =\n\t\t\t\t\t\tr_str_newf (\"__end_%d_%d_%d\",\n\t\t\t\t\t\t\tegg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t}\n\t\t\t\t// if (nestede[CTX]) {\n\t\t\t\t// r_egg_printf (egg, \"%s:\\n\", nestede[CTX]);\n\t\t\t\t////nestede[CTX] = NULL;\n\t\t\t\t// } else {\n\t\t\t\tr_egg_printf (egg, \"  __end_%d_%d_%d:\\n\",\n\t\t\t\t\tegg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t// get_end_frame_label (egg));\n\t\t\t\t// }\n\t\t\t}\n\t\t\tif (CTX > 0) {\n\t\t\t\tegg->lang.nbrackets++;\n\t\t\t}\n\t\t\trcc_context (egg, -1);\n\t\t\tif (CTX == 0) {\n\t\t\t\tr_egg_printf (egg, \"\\n\");\n\t\t\t\t// snprintf(str, 64, \"__end_%d\", egg->lang.nfunctions);\n\t\t\t\t// e->jmp(egg, str, 0);\n\t\t\t\t// edit this unnessary jmp to bypass tests\n\t\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t\tfor (j = 0; j < egg->lang.nestedi[i] && j < 32; j++) {\n\t\t\t\t\t\tif (egg->lang.ifelse_table[i][j]) {\n\t\t\t\t\t\t\tr_egg_printf (egg, \"  __ifelse_%d_%d:\\n\", i, j);\n\t\t\t\t\t\t\te->jmp (egg, egg->lang.ifelse_table[i][j], 0);\n\t\t\t\t\t\t\tR_FREE (egg->lang.ifelse_table[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// r_egg_printf(egg, \"  __end_%d:\\n\\n\", egg->lang.nfunctions);\n\t\t\t\t// edit this unnessary jmp to bypass tests\n\t\t\t\tegg->lang.nbrackets = 0;\n\t\t\t\tegg->lang.nfunctions++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (egg->lang.oc == '\\n' || egg->lang.oc == '}') {\n\t\t\t\tegg->lang.quoteline = '\\n';\n\t\t\t} else {\n\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tif (egg->lang.oc == '\\n') {\n\t\t\t\tegg->lang.skipline = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif (egg->lang.oc == '/') {\n\t\t\t\tegg->lang.skipline = 1;\n\t\t\t} else {\n\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t}\n\t\tif (egg->lang.slurp) {\n\t\t\tif (egg->lang.elem_n) {\n\t\t\t\tptr = egg->lang.elem;\n\t\t\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t\t\t\twhile (is_space (*ptr)) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\trcc_fun (egg, ptr);\n\t\t\t}\n\t\t\tegg->lang.elem_n = 0;\n\t\t}\n\t}\n\tif (c != '\\t' && c != ' ') {\n\t\tegg->lang.oc = c;\n\t}\n\treturn 0;\n}",
    "abstract_func_before": "R_API int r_egg_lang_parsechar(REgg *VAR_0, char VAR_1) {\n\tREggEmit *VAR_2 = VAR_0->remit;\n\tchar *VAR_3, VAR_4[64], *VAR_5 = NULL;\n\tint VAR_6, VAR_7;\n\tif (VAR_1 == '\\n') {\n\t\tVAR_0->lang.line++;\n\t\tVAR_0->lang.elem_n = 0;\n\t}\n\t/* COMMENT_0 */\n\tif (VAR_0->lang.skipline) {\n\t\tif (VAR_1 != '\\n') {\n\t\t\tVAR_0->lang.oc = VAR_1;\n\t\t\treturn 0;\n\t\t}\n\t\tVAR_0->lang.skipline = 0;\n\t}\n\tif (VAR_0->lang.mode == VAR_8) {\n\t\treturn parsedatachar (VAR_0, VAR_1);\n\t}\n\tif (VAR_0->lang.mode == VAR_9) {\n\t\treturn parseinlinechar (VAR_0, VAR_1);\n\t}\n\t/* COMMENT_1 */\n\tif (VAR_0->lang.quoteline) {\n\t\tif (VAR_1 != VAR_0->lang.quoteline) {\n\t\t\tif (VAR_0->lang.quotelinevar == 1) {\n\t\t\t\tif (VAR_1 == '`') {\n\t\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n] = 0;\n\t\t\t\t\tVAR_0->lang.elem_n = 0;\n\t\t\t\t\tVAR_5 = r_egg_mkvar (VAR_0, VAR_4, VAR_0->lang.elem, 0);\n\t\t\t\t\tr_egg_printf (VAR_0, \"%s\", VAR_5);\n\t\t\t\t\tfree (VAR_5);\n\t\t\t\t\tVAR_0->lang.quotelinevar = 0;\n\t\t\t\t} else {\n\t\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (VAR_1 == '`') {\n\t\t\t\t\tVAR_0->lang.elem_n = 0;\n\t\t\t\t\tVAR_0->lang.quotelinevar = 1;\n\t\t\t\t} else {\n\t\t\t\t\tr_egg_printf (VAR_0, \"%c\", VAR_1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_0->lang.oc = VAR_1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tr_egg_printf (VAR_0, \"\\n\");\n\t\t\tVAR_0->lang.quoteline = 0;\n\t\t}\n\t}\n\n\tif (VAR_0->lang.commentmode) {\n\t\tif (VAR_1 == '/' && VAR_0->lang.oc == '*') {\n\t\t\tVAR_0->lang.commentmode = 0;\n\t\t}\n\t\tVAR_0->lang.oc = VAR_1;\n\t\treturn 0;\n\t} else if (VAR_1 == '*' && VAR_0->lang.oc == '/') {\n\t\tVAR_0->lang.commentmode = 1;\n\t}\n\tif (VAR_0->lang.slurp) {\n\t\tif (VAR_0->lang.slurp != '\"' && VAR_1 == VAR_0->lang.slurpin) {\t/* COMMENT_2 */\n\t\t\texit (eprintf (\n\t\t\t\t\t\"%s:%d Nesting of expressions not yet supported\\n\",\n\t\t\t\t\tVAR_0->lang.file, VAR_0->lang.line));\n\t\t}\n\t\tif (VAR_1 == VAR_0->lang.slurp && VAR_0->lang.oc != '\\\\') {\t/* COMMENT_3 */\n\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n] = '\\0';\n\t\t\tif (VAR_0->lang.elem_n > 0) {\n\t\t\t\trcc_element (VAR_0, VAR_0->lang.elem);\n\t\t\t} else {\n\t\t\t\tVAR_2->frame (VAR_0, 0);\n\t\t\t}\n\t\t\tVAR_0->lang.elem_n = 0;\n\t\t\tVAR_0->lang.slurp = 0;\n\t\t} else {\n\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t}\n\t\tVAR_0->lang.elem[VAR_0->lang.elem_n] = '\\0';\n\t} else {\n\t\tswitch (VAR_1) {\n\t\tcase ';':\n\t\t\trcc_next (VAR_0);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tVAR_0->lang.slurp = '\"';\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tVAR_0->lang.slurpin = '(';\n\t\t\tVAR_0->lang.slurp = ')';\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (VAR_10 > 0) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tif (VAR_0->lang.nested_callname[VAR_10] && strstr (VAR_0->lang.nested_callname[VAR_10], \"if\") &&\n\t\t\t\t    strstr (VAR_0->lang.elem, \"else\")) {\n\t\t\t\t\t*VAR_0->lang.elem = '\\x00';\n\t\t\t\t\tVAR_0->lang.elem_n = 0;\n\t\t\t\t\tR_FREE (VAR_0->lang.ifelse_table[VAR_10][VAR_0->lang.nestedi[VAR_10] - 1])\n\t\t\t\t\tVAR_0->lang.ifelse_table[VAR_10][VAR_0->lang.nestedi[VAR_10] - 1] =\n\t\t\t\t\t\tr_str_newf (\"  __end_%d_%d_%d\",\n\t\t\t\t\t\t\tVAR_0->lang.nfunctions, VAR_10, VAR_0->lang.nestedi[VAR_10]);\n\t\t\t\t}\n\t\t\t\tr_egg_printf (VAR_0, \"  __begin_%d_%d_%d:\\n\",\n\t\t\t\t\tVAR_0->lang.nfunctions, VAR_10, VAR_0->lang.nestedi[VAR_10]);\t/* COMMENT_5 */\n\t\t\t}\n\t\t\trcc_context (VAR_0, 1);\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tVAR_0->lang.endframe = VAR_0->lang.nested[VAR_10];\n\t\t\tif (VAR_0->lang.endframe) {\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tr_egg_printf (VAR_0, \"%s\", VAR_0->lang.endframe);\n\t\t\t\tR_FREE (VAR_0->lang.nested[VAR_10]);\n\t\t\t\t/* COMMENT_7 */\n\t\t\t}\n\t\t\tif (VAR_10 > 1) {\n\t\t\t\tif (VAR_0->lang.nested_callname[VAR_10 - 1] && strstr (VAR_0->lang.nested_callname[VAR_10 - 1], \"if\")) {\n\t\t\t\t\tVAR_5 = r_str_newf (\"__ifelse_%d_%d\", VAR_10 - 1, VAR_0->lang.nestedi[VAR_10 - 1] - 1);\n\t\t\t\t\tVAR_2->jmp (VAR_0, VAR_5, 0);\n\t\t\t\t\tR_FREE (VAR_5);\t/* COMMENT_8 */\n\t\t\t\t\tVAR_0->lang.ifelse_table[VAR_10 - 1][VAR_0->lang.nestedi[VAR_10 - 1] - 1] =\n\t\t\t\t\t\tr_str_newf (\"__end_%d_%d_%d\",\n\t\t\t\t\t\t\tVAR_0->lang.nfunctions, VAR_10 - 1, VAR_0->lang.nestedi[VAR_10 - 1] - 1);\n\t\t\t\t}\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tr_egg_printf (VAR_0, \"  __end_%d_%d_%d:\\n\",\n\t\t\t\t\tVAR_0->lang.nfunctions, VAR_10 - 1, VAR_0->lang.nestedi[VAR_10 - 1] - 1);\n\t\t\t\t/* COMMENT_13 */\n\t\t\t\t/* COMMENT_14 */\n\t\t\t}\n\t\t\tif (VAR_10 > 0) {\n\t\t\t\tVAR_0->lang.nbrackets++;\n\t\t\t}\n\t\t\trcc_context (VAR_0, -1);\n\t\t\tif (VAR_10 == 0) {\n\t\t\t\tr_egg_printf (VAR_0, \"\\n\");\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tfor (VAR_6 = 0; VAR_6 < 32; VAR_6++) {\n\t\t\t\t\tfor (VAR_7 = 0; VAR_7 < VAR_0->lang.nestedi[VAR_6] && VAR_7 < 32; VAR_7++) {\n\t\t\t\t\t\tif (VAR_0->lang.ifelse_table[VAR_6][VAR_7]) {\n\t\t\t\t\t\t\tr_egg_printf (VAR_0, \"  __ifelse_%d_%d:\\n\", VAR_6, VAR_7);\n\t\t\t\t\t\t\tVAR_2->jmp (VAR_0, VAR_0->lang.ifelse_table[VAR_6][VAR_7], 0);\n\t\t\t\t\t\t\tR_FREE (VAR_0->lang.ifelse_table[VAR_6][VAR_7]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_0->lang.nbrackets = 0;\n\t\t\t\tVAR_0->lang.nfunctions++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (VAR_0->lang.oc == '\\n' || VAR_0->lang.oc == '}') {\n\t\t\t\tVAR_0->lang.quoteline = '\\n';\n\t\t\t} else {\n\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tif (VAR_0->lang.oc == '\\n') {\n\t\t\t\tVAR_0->lang.skipline = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif (VAR_0->lang.oc == '/') {\n\t\t\t\tVAR_0->lang.skipline = 1;\n\t\t\t} else {\n\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t}\n\t\tif (VAR_0->lang.slurp) {\n\t\t\tif (VAR_0->lang.elem_n) {\n\t\t\t\tVAR_3 = VAR_0->lang.elem;\n\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n] = '\\0';\n\t\t\t\twhile (is_space (*VAR_3)) {\n\t\t\t\t\tVAR_3++;\n\t\t\t\t}\n\t\t\t\trcc_fun (VAR_0, VAR_3);\n\t\t\t}\n\t\t\tVAR_0->lang.elem_n = 0;\n\t\t}\n\t}\n\tif (VAR_1 != '\\t' && VAR_1 != ' ') {\n\t\tVAR_0->lang.oc = VAR_1;\n\t}\n\treturn 0;\n}",
    "func_graph_path_before": null,
    "func": "R_API int r_egg_lang_parsechar(REgg *egg, char c) {\n\tREggEmit *e = egg->remit;\n\tchar *ptr, str[64], *tmp_ptr = NULL;\n\tint i, j;\n\tif (c == '\\n') {\n\t\tegg->lang.line++;\n\t\tegg->lang.elem_n = 0;\n\t}\n\t/* comments */\n\tif (egg->lang.skipline) {\n\t\tif (c != '\\n') {\n\t\t\tegg->lang.oc = c;\n\t\t\treturn 0;\n\t\t}\n\t\tegg->lang.skipline = 0;\n\t}\n\tif (egg->lang.mode == DATA) {\n\t\treturn parsedatachar (egg, c);\n\t}\n\tif (egg->lang.mode == INLINE) {\n\t\treturn parseinlinechar (egg, c);\n\t}\n\t/* quotes */\n\tif (egg->lang.quoteline) {\n\t\tif (c != egg->lang.quoteline) {\n\t\t\tif (egg->lang.quotelinevar == 1) {\n\t\t\t\tif (c == '`') {\n\t\t\t\t\tegg->lang.elem[egg->lang.elem_n] = 0;\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\ttmp_ptr = r_egg_mkvar (egg, str, egg->lang.elem, 0);\n\t\t\t\t\tr_egg_printf (egg, \"%s\", tmp_ptr);\n\t\t\t\t\tfree (tmp_ptr);\n\t\t\t\t\tegg->lang.quotelinevar = 0;\n\t\t\t\t} else {\n\t\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c == '`') {\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\tegg->lang.quotelinevar = 1;\n\t\t\t\t} else {\n\t\t\t\t\tr_egg_printf (egg, \"%c\", c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tegg->lang.oc = c;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tr_egg_printf (egg, \"\\n\");\n\t\t\tegg->lang.quoteline = 0;\n\t\t}\n\t}\n\n\tif (egg->lang.commentmode) {\n\t\tif (c == '/' && egg->lang.oc == '*') {\n\t\t\tegg->lang.commentmode = 0;\n\t\t}\n\t\tegg->lang.oc = c;\n\t\treturn 0;\n\t} else if (c == '*' && egg->lang.oc == '/') {\n\t\tegg->lang.commentmode = 1;\n\t}\n\tif (egg->lang.slurp) {\n\t\tif (egg->lang.slurp != '\"' && c == egg->lang.slurpin) {\t// only happend when (...(...)...)\n\t\t\texit (eprintf (\n\t\t\t\t\t\"%s:%d Nesting of expressions not yet supported\\n\",\n\t\t\t\t\tegg->lang.file, egg->lang.line));\n\t\t}\n\t\tif (c == egg->lang.slurp && egg->lang.oc != '\\\\') {\t// close egg->lang.slurp\n\t\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t\t\tif (egg->lang.elem_n > 0) {\n\t\t\t\trcc_element (egg, egg->lang.elem);\n\t\t\t} else {\n\t\t\t\te->frame (egg, 0);\n\t\t\t}\n\t\t\tegg->lang.elem_n = 0;\n\t\t\tegg->lang.slurp = 0;\n\t\t} else {\n\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t}\n\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t} else {\n\t\tswitch (c) {\n\t\tcase ';':\n\t\t\trcc_next (egg);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tegg->lang.slurp = '\"';\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tegg->lang.slurpin = '(';\n\t\t\tegg->lang.slurp = ')';\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (CTX > 0) {\n\t\t\t\tif (CTX > 31 || CTX < 0) {\n\t\t\t\t\teprintf (\"Sinking before overflow\\n\");\n\t\t\t\t\tCTX = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// r_egg_printf (egg, \" %s:\\n\", get_frame_label (0));\n\t\t\t\tif (egg->lang.nested_callname[CTX] && strstr (egg->lang.nested_callname[CTX], \"if\") &&\n\t\t\t\t    strstr (egg->lang.elem, \"else\")) {\n\t\t\t\t\t*egg->lang.elem = '\\x00';\n\t\t\t\t\tegg->lang.elem_n = 0;\n\t\t\t\t\tR_FREE (egg->lang.ifelse_table[CTX][egg->lang.nestedi[CTX] - 1])\n\t\t\t\t\tegg->lang.ifelse_table[CTX][egg->lang.nestedi[CTX] - 1] =\n\t\t\t\t\t\tr_str_newf (\"  __end_%d_%d_%d\",\n\t\t\t\t\t\t\tegg->lang.nfunctions, CTX, egg->lang.nestedi[CTX]);\n\t\t\t\t}\n\t\t\t\tr_egg_printf (egg, \"  __begin_%d_%d_%d:\\n\",\n\t\t\t\t\tegg->lang.nfunctions, CTX, egg->lang.nestedi[CTX]);\t// %s:\\n\", get_frame_label (0));\n\t\t\t}\n\t\t\trcc_context (egg, 1);\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tegg->lang.endframe = egg->lang.nested[CTX];\n\t\t\tif (egg->lang.endframe) {\n\t\t\t\t// XXX: use egg->lang.endframe[context]\n\t\t\t\tr_egg_printf (egg, \"%s\", egg->lang.endframe);\n\t\t\t\tR_FREE (egg->lang.nested[CTX]);\n\t\t\t\t// R_FREE (egg->lang.endframe);\n\t\t\t}\n\t\t\tif (CTX > 1) {\n\t\t\t\tif (egg->lang.nested_callname[CTX - 1] && strstr (egg->lang.nested_callname[CTX - 1], \"if\")) {\n\t\t\t\t\ttmp_ptr = r_str_newf (\"__ifelse_%d_%d\", CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t\te->jmp (egg, tmp_ptr, 0);\n\t\t\t\t\tR_FREE (tmp_ptr);\t// mem leak\n\t\t\t\t\tegg->lang.ifelse_table[CTX - 1][egg->lang.nestedi[CTX - 1] - 1] =\n\t\t\t\t\t\tr_str_newf (\"__end_%d_%d_%d\",\n\t\t\t\t\t\t\tegg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t}\n\t\t\t\t// if (nestede[CTX]) {\n\t\t\t\t// r_egg_printf (egg, \"%s:\\n\", nestede[CTX]);\n\t\t\t\t////nestede[CTX] = NULL;\n\t\t\t\t// } else {\n\t\t\t\tr_egg_printf (egg, \"  __end_%d_%d_%d:\\n\",\n\t\t\t\t\tegg->lang.nfunctions, CTX - 1, egg->lang.nestedi[CTX - 1] - 1);\n\t\t\t\t// get_end_frame_label (egg));\n\t\t\t\t// }\n\t\t\t}\n\t\t\tif (CTX > 0) {\n\t\t\t\tegg->lang.nbrackets++;\n\t\t\t}\n\t\t\trcc_context (egg, -1);\n\t\t\tif (CTX == 0) {\n\t\t\t\tr_egg_printf (egg, \"\\n\");\n\t\t\t\t// snprintf(str, 64, \"__end_%d\", egg->lang.nfunctions);\n\t\t\t\t// e->jmp(egg, str, 0);\n\t\t\t\t// edit this unnessary jmp to bypass tests\n\t\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t\tfor (j = 0; j < egg->lang.nestedi[i] && j < 32; j++) {\n\t\t\t\t\t\tif (egg->lang.ifelse_table[i][j]) {\n\t\t\t\t\t\t\tr_egg_printf (egg, \"  __ifelse_%d_%d:\\n\", i, j);\n\t\t\t\t\t\t\te->jmp (egg, egg->lang.ifelse_table[i][j], 0);\n\t\t\t\t\t\t\tR_FREE (egg->lang.ifelse_table[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// r_egg_printf(egg, \"  __end_%d:\\n\\n\", egg->lang.nfunctions);\n\t\t\t\t// edit this unnessary jmp to bypass tests\n\t\t\t\tegg->lang.nbrackets = 0;\n\t\t\t\tegg->lang.nfunctions++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (egg->lang.oc == '\\n' || egg->lang.oc == '}') {\n\t\t\t\tegg->lang.quoteline = '\\n';\n\t\t\t} else {\n\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tif (egg->lang.oc == '\\n') {\n\t\t\t\tegg->lang.skipline = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif (egg->lang.oc == '/') {\n\t\t\t\tegg->lang.skipline = 1;\n\t\t\t} else {\n\t\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tegg->lang.elem[egg->lang.elem_n++] = c;\n\t\t}\n\t\tif (egg->lang.slurp) {\n\t\t\tif (egg->lang.elem_n) {\n\t\t\t\tptr = egg->lang.elem;\n\t\t\t\tegg->lang.elem[egg->lang.elem_n] = '\\0';\n\t\t\t\twhile (is_space (*ptr)) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\trcc_fun (egg, ptr);\n\t\t\t}\n\t\t\tegg->lang.elem_n = 0;\n\t\t}\n\t}\n\tif (c != '\\t' && c != ' ') {\n\t\tegg->lang.oc = c;\n\t}\n\treturn 0;\n}",
    "abstract_func": "R_API int r_egg_lang_parsechar(REgg *VAR_0, char VAR_1) {\n\tREggEmit *VAR_2 = VAR_0->remit;\n\tchar *VAR_3, VAR_4[64], *VAR_5 = NULL;\n\tint VAR_6, VAR_7;\n\tif (VAR_1 == '\\n') {\n\t\tVAR_0->lang.line++;\n\t\tVAR_0->lang.elem_n = 0;\n\t}\n\t/* COMMENT_0 */\n\tif (VAR_0->lang.skipline) {\n\t\tif (VAR_1 != '\\n') {\n\t\t\tVAR_0->lang.oc = VAR_1;\n\t\t\treturn 0;\n\t\t}\n\t\tVAR_0->lang.skipline = 0;\n\t}\n\tif (VAR_0->lang.mode == VAR_8) {\n\t\treturn parsedatachar (VAR_0, VAR_1);\n\t}\n\tif (VAR_0->lang.mode == VAR_9) {\n\t\treturn parseinlinechar (VAR_0, VAR_1);\n\t}\n\t/* COMMENT_1 */\n\tif (VAR_0->lang.quoteline) {\n\t\tif (VAR_1 != VAR_0->lang.quoteline) {\n\t\t\tif (VAR_0->lang.quotelinevar == 1) {\n\t\t\t\tif (VAR_1 == '`') {\n\t\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n] = 0;\n\t\t\t\t\tVAR_0->lang.elem_n = 0;\n\t\t\t\t\tVAR_5 = r_egg_mkvar (VAR_0, VAR_4, VAR_0->lang.elem, 0);\n\t\t\t\t\tr_egg_printf (VAR_0, \"%s\", VAR_5);\n\t\t\t\t\tfree (VAR_5);\n\t\t\t\t\tVAR_0->lang.quotelinevar = 0;\n\t\t\t\t} else {\n\t\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (VAR_1 == '`') {\n\t\t\t\t\tVAR_0->lang.elem_n = 0;\n\t\t\t\t\tVAR_0->lang.quotelinevar = 1;\n\t\t\t\t} else {\n\t\t\t\t\tr_egg_printf (VAR_0, \"%c\", VAR_1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_0->lang.oc = VAR_1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tr_egg_printf (VAR_0, \"\\n\");\n\t\t\tVAR_0->lang.quoteline = 0;\n\t\t}\n\t}\n\n\tif (VAR_0->lang.commentmode) {\n\t\tif (VAR_1 == '/' && VAR_0->lang.oc == '*') {\n\t\t\tVAR_0->lang.commentmode = 0;\n\t\t}\n\t\tVAR_0->lang.oc = VAR_1;\n\t\treturn 0;\n\t} else if (VAR_1 == '*' && VAR_0->lang.oc == '/') {\n\t\tVAR_0->lang.commentmode = 1;\n\t}\n\tif (VAR_0->lang.slurp) {\n\t\tif (VAR_0->lang.slurp != '\"' && VAR_1 == VAR_0->lang.slurpin) {\t/* COMMENT_2 */\n\t\t\texit (eprintf (\n\t\t\t\t\t\"%s:%d Nesting of expressions not yet supported\\n\",\n\t\t\t\t\tVAR_0->lang.file, VAR_0->lang.line));\n\t\t}\n\t\tif (VAR_1 == VAR_0->lang.slurp && VAR_0->lang.oc != '\\\\') {\t/* COMMENT_3 */\n\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n] = '\\0';\n\t\t\tif (VAR_0->lang.elem_n > 0) {\n\t\t\t\trcc_element (VAR_0, VAR_0->lang.elem);\n\t\t\t} else {\n\t\t\t\tVAR_2->frame (VAR_0, 0);\n\t\t\t}\n\t\t\tVAR_0->lang.elem_n = 0;\n\t\t\tVAR_0->lang.slurp = 0;\n\t\t} else {\n\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t}\n\t\tVAR_0->lang.elem[VAR_0->lang.elem_n] = '\\0';\n\t} else {\n\t\tswitch (VAR_1) {\n\t\tcase ';':\n\t\t\trcc_next (VAR_0);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tVAR_0->lang.slurp = '\"';\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tVAR_0->lang.slurpin = '(';\n\t\t\tVAR_0->lang.slurp = ')';\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (VAR_10 > 0) {\n\t\t\t\tif (VAR_10 > 31 || VAR_10 < 0) {\n\t\t\t\t\teprintf (\"Sinking before overflow\\n\");\n\t\t\t\t\tVAR_10 = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tif (VAR_0->lang.nested_callname[VAR_10] && strstr (VAR_0->lang.nested_callname[VAR_10], \"if\") &&\n\t\t\t\t    strstr (VAR_0->lang.elem, \"else\")) {\n\t\t\t\t\t*VAR_0->lang.elem = '\\x00';\n\t\t\t\t\tVAR_0->lang.elem_n = 0;\n\t\t\t\t\tR_FREE (VAR_0->lang.ifelse_table[VAR_10][VAR_0->lang.nestedi[VAR_10] - 1])\n\t\t\t\t\tVAR_0->lang.ifelse_table[VAR_10][VAR_0->lang.nestedi[VAR_10] - 1] =\n\t\t\t\t\t\tr_str_newf (\"  __end_%d_%d_%d\",\n\t\t\t\t\t\t\tVAR_0->lang.nfunctions, VAR_10, VAR_0->lang.nestedi[VAR_10]);\n\t\t\t\t}\n\t\t\t\tr_egg_printf (VAR_0, \"  __begin_%d_%d_%d:\\n\",\n\t\t\t\t\tVAR_0->lang.nfunctions, VAR_10, VAR_0->lang.nestedi[VAR_10]);\t/* COMMENT_5 */\n\t\t\t}\n\t\t\trcc_context (VAR_0, 1);\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tVAR_0->lang.endframe = VAR_0->lang.nested[VAR_10];\n\t\t\tif (VAR_0->lang.endframe) {\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tr_egg_printf (VAR_0, \"%s\", VAR_0->lang.endframe);\n\t\t\t\tR_FREE (VAR_0->lang.nested[VAR_10]);\n\t\t\t\t/* COMMENT_7 */\n\t\t\t}\n\t\t\tif (VAR_10 > 1) {\n\t\t\t\tif (VAR_0->lang.nested_callname[VAR_10 - 1] && strstr (VAR_0->lang.nested_callname[VAR_10 - 1], \"if\")) {\n\t\t\t\t\tVAR_5 = r_str_newf (\"__ifelse_%d_%d\", VAR_10 - 1, VAR_0->lang.nestedi[VAR_10 - 1] - 1);\n\t\t\t\t\tVAR_2->jmp (VAR_0, VAR_5, 0);\n\t\t\t\t\tR_FREE (VAR_5);\t/* COMMENT_8 */\n\t\t\t\t\tVAR_0->lang.ifelse_table[VAR_10 - 1][VAR_0->lang.nestedi[VAR_10 - 1] - 1] =\n\t\t\t\t\t\tr_str_newf (\"__end_%d_%d_%d\",\n\t\t\t\t\t\t\tVAR_0->lang.nfunctions, VAR_10 - 1, VAR_0->lang.nestedi[VAR_10 - 1] - 1);\n\t\t\t\t}\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tr_egg_printf (VAR_0, \"  __end_%d_%d_%d:\\n\",\n\t\t\t\t\tVAR_0->lang.nfunctions, VAR_10 - 1, VAR_0->lang.nestedi[VAR_10 - 1] - 1);\n\t\t\t\t/* COMMENT_13 */\n\t\t\t\t/* COMMENT_14 */\n\t\t\t}\n\t\t\tif (VAR_10 > 0) {\n\t\t\t\tVAR_0->lang.nbrackets++;\n\t\t\t}\n\t\t\trcc_context (VAR_0, -1);\n\t\t\tif (VAR_10 == 0) {\n\t\t\t\tr_egg_printf (VAR_0, \"\\n\");\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tfor (VAR_6 = 0; VAR_6 < 32; VAR_6++) {\n\t\t\t\t\tfor (VAR_7 = 0; VAR_7 < VAR_0->lang.nestedi[VAR_6] && VAR_7 < 32; VAR_7++) {\n\t\t\t\t\t\tif (VAR_0->lang.ifelse_table[VAR_6][VAR_7]) {\n\t\t\t\t\t\t\tr_egg_printf (VAR_0, \"  __ifelse_%d_%d:\\n\", VAR_6, VAR_7);\n\t\t\t\t\t\t\tVAR_2->jmp (VAR_0, VAR_0->lang.ifelse_table[VAR_6][VAR_7], 0);\n\t\t\t\t\t\t\tR_FREE (VAR_0->lang.ifelse_table[VAR_6][VAR_7]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_0->lang.nbrackets = 0;\n\t\t\t\tVAR_0->lang.nfunctions++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (VAR_0->lang.oc == '\\n' || VAR_0->lang.oc == '}') {\n\t\t\t\tVAR_0->lang.quoteline = '\\n';\n\t\t\t} else {\n\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tif (VAR_0->lang.oc == '\\n') {\n\t\t\t\tVAR_0->lang.skipline = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif (VAR_0->lang.oc == '/') {\n\t\t\t\tVAR_0->lang.skipline = 1;\n\t\t\t} else {\n\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n++] = VAR_1;\n\t\t}\n\t\tif (VAR_0->lang.slurp) {\n\t\t\tif (VAR_0->lang.elem_n) {\n\t\t\t\tVAR_3 = VAR_0->lang.elem;\n\t\t\t\tVAR_0->lang.elem[VAR_0->lang.elem_n] = '\\0';\n\t\t\t\twhile (is_space (*VAR_3)) {\n\t\t\t\t\tVAR_3++;\n\t\t\t\t}\n\t\t\t\trcc_fun (VAR_0, VAR_3);\n\t\t\t}\n\t\t\tVAR_0->lang.elem_n = 0;\n\t\t}\n\t}\n\tif (VAR_1 != '\\t' && VAR_1 != ' ') {\n\t\tVAR_0->lang.oc = VAR_1;\n\t}\n\treturn 0;\n}",
    "func_graph_path": null,
    "diff_func": "--- func_before\n+++ func_after\n@@ -92,6 +92,11 @@\n \t\t\tbreak;\n \t\tcase '{':\n \t\t\tif (CTX > 0) {\n+\t\t\t\tif (CTX > 31 || CTX < 0) {\n+\t\t\t\t\teprintf (\"Sinking before overflow\\n\");\n+\t\t\t\t\tCTX = 0;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\t// r_egg_printf (egg, \" %s:\\n\", get_frame_label (0));\n \t\t\t\tif (egg->lang.nested_callname[CTX] && strstr (egg->lang.nested_callname[CTX], \"if\") &&\n \t\t\t\t    strstr (egg->lang.elem, \"else\")) {",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\t\t\t\tif (CTX > 31 || CTX < 0) {",
            "\t\t\t\t\teprintf (\"Sinking before overflow\\n\");",
            "\t\t\t\t\tCTX = 0;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}"
        ]
    },
    "is_vul": true,
    "pr_url": "https://github.com/radareorg/radare2/pull/14308",
    "description": "This fix is probably not good, but we should add a test for it, and at some point rework on the ragg2 api cleanup with some refactorings"
}