{
    "cve_id": "CVE-2021-23792",
    "cwe_ids": [
        "CWE-611"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
    "cvss_is_v3": false,
    "repo_name": "haraldk/TwelveMonkeys",
    "commit_msg": "Avoid fetching external resources in XMPReader.",
    "commit_hash": "da4efe98bf09e1cce91b7633cb251958a200fc80",
    "git_url": "https://github.com/haraldk/TwelveMonkeys/commit/da4efe98bf09e1cce91b7633cb251958a200fc80",
    "file_path": "imageio/imageio-metadata/src/main/java/com/twelvemonkeys/imageio/metadata/xmp/XMPReader.java",
    "func_name": "getChildTextValue",
    "func_before": "private Object getChildTextValue(final Node node) {\n        for (Node child : asIterable(node.getChildNodes())) {\n            if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();\n                for (Node alternative : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                        NamedNodeMap attributes = alternative.getAttributes();\n                        Node key = attributes.getNamedItem(\"xml:lang\");\n                        alternatives.put(key == null ? null : key.getTextContent(), getChildTextValue(alternative));\n                    }\n                }\n\n                return alternatives;\n            }\n            else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                // Support for <rdf:Seq><rdf:li> -> return array\n                // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n                List<Object> seq = new ArrayList<Object>();\n\n                for (Node sequence : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {\n                        Object value = getChildTextValue(sequence);\n                        seq.add(value);\n                    }\n                }\n\n                // TODO: Strictly a bag should not be a list, but there's no Bag type (or similar) in Java.\n                // Consider something like Google collections Multiset or Apache commons Bag (the former seems more well-defined)\n                // Note: Collection does not have defined equals() semantics, and so using\n                // Collections.unmodifiableCollection() doesn't work for comparing values (uses Object.equals())\n                return Collections.unmodifiableList(seq);\n            }\n        }\n\n        // Need to support rdf:parseType=\"Resource\" here as well...\n        if (isResourceType(node)) {\n            return parseAsResource(node);\n        }\n\n        Node child = node.getFirstChild();\n        String strVal = child != null ? child.getNodeValue() : null;\n        return strVal != null ? strVal.trim() : \"\";\n    }",
    "abstract_func_before": "private Object getChildTextValue(final Node VAR_0) {\n        for (Node VAR_1 : asIterable(VAR_0.getChildNodes())) {\n            if (VAR_2.NS_RDF.equals(VAR_1.getNamespaceURI()) && \"Alt\".equals(VAR_1.getLocalName())) {\n                /* COMMENT_0 */\n                Map<String, Object> VAR_3 = new LinkedHashMap<String, Object>();\n                for (Node VAR_4 : asIterable(VAR_1.getChildNodes())) {\n                    if (VAR_2.NS_RDF.equals(VAR_4.getNamespaceURI()) && \"li\".equals(VAR_4.getLocalName())) {\n                        NamedNodeMap VAR_5 = VAR_4.getAttributes();\n                        Node VAR_6 = VAR_5.getNamedItem(\"xml:lang\");\n                        VAR_3.put(VAR_6 == null ? null : VAR_6.getTextContent(), getChildTextValue(VAR_4));\n                    }\n                }\n\n                return VAR_3;\n            }\n            else if (VAR_2.NS_RDF.equals(VAR_1.getNamespaceURI()) && (\"Seq\".equals(VAR_1.getLocalName()) || \"Bag\".equals(VAR_1.getLocalName()))) {\n                /* COMMENT_1 */\n                /* COMMENT_2 */\n                List<Object> VAR_7 = new ArrayList<Object>();\n\n                for (Node VAR_8 : asIterable(VAR_1.getChildNodes())) {\n                    if (VAR_2.NS_RDF.equals(VAR_8.getNamespaceURI()) && \"li\".equals(VAR_8.getLocalName())) {\n                        Object VAR_9 = getChildTextValue(VAR_8);\n                        VAR_7.add(VAR_9);\n                    }\n                }\n\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                return VAR_10.unmodifiableList(VAR_7);\n            }\n        }\n\n        /* COMMENT_7 */\n        if (isResourceType(VAR_0)) {\n            return parseAsResource(VAR_0);\n        }\n\n        Node VAR_1 = VAR_0.getFirstChild();\n        String VAR_11 = VAR_1 != null ? VAR_1.getNodeValue() : null;\n        return VAR_11 != null ? VAR_11.trim() : \"\";\n    }",
    "func_graph_path_before": "haraldk/TwelveMonkeys/da4efe98bf09e1cce91b7633cb251958a200fc80/XMPReader.java/vul/before/3.json",
    "func": "private Object getChildTextValue(final Node node) {\n        for (Node child : asIterable(node.getChildNodes())) {\n            if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n                Map<String, Object> alternatives = new LinkedHashMap<>();\n                for (Node alternative : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                        NamedNodeMap attributes = alternative.getAttributes();\n                        Node key = attributes.getNamedItem(\"xml:lang\");\n                        alternatives.put(key == null ? null : key.getTextContent(), getChildTextValue(alternative));\n                    }\n                }\n\n                return alternatives;\n            }\n            else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                // Support for <rdf:Seq><rdf:li> -> return array\n                // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n                List<Object> seq = new ArrayList<>();\n\n                for (Node sequence : asIterable(child.getChildNodes())) {\n                    if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {\n                        Object value = getChildTextValue(sequence);\n                        seq.add(value);\n                    }\n                }\n\n                // TODO: Strictly a bag should not be a list, but there's no Bag type (or similar) in Java.\n                // Consider something like Google collections Multiset or Apache commons Bag (the former seems more well-defined)\n                // Note: Collection does not have defined equals() semantics, and so using\n                // Collections.unmodifiableCollection() doesn't work for comparing values (uses Object.equals())\n                return Collections.unmodifiableList(seq);\n            }\n        }\n\n        // Need to support rdf:parseType=\"Resource\" here as well...\n        if (isResourceType(node)) {\n            return parseAsResource(node);\n        }\n\n        Node child = node.getFirstChild();\n        String strVal = child != null ? child.getNodeValue() : null;\n        return strVal != null ? strVal.trim() : \"\";\n    }",
    "abstract_func": "private Object getChildTextValue(final Node VAR_0) {\n        for (Node VAR_1 : asIterable(VAR_0.getChildNodes())) {\n            if (VAR_2.NS_RDF.equals(VAR_1.getNamespaceURI()) && \"Alt\".equals(VAR_1.getLocalName())) {\n                /* COMMENT_0 */\n                Map<String, Object> VAR_3 = new LinkedHashMap<>();\n                for (Node VAR_4 : asIterable(VAR_1.getChildNodes())) {\n                    if (VAR_2.NS_RDF.equals(VAR_4.getNamespaceURI()) && \"li\".equals(VAR_4.getLocalName())) {\n                        NamedNodeMap VAR_5 = VAR_4.getAttributes();\n                        Node VAR_6 = VAR_5.getNamedItem(\"xml:lang\");\n                        VAR_3.put(VAR_6 == null ? null : VAR_6.getTextContent(), getChildTextValue(VAR_4));\n                    }\n                }\n\n                return VAR_3;\n            }\n            else if (VAR_2.NS_RDF.equals(VAR_1.getNamespaceURI()) && (\"Seq\".equals(VAR_1.getLocalName()) || \"Bag\".equals(VAR_1.getLocalName()))) {\n                /* COMMENT_1 */\n                /* COMMENT_2 */\n                List<Object> VAR_7 = new ArrayList<>();\n\n                for (Node VAR_8 : asIterable(VAR_1.getChildNodes())) {\n                    if (VAR_2.NS_RDF.equals(VAR_8.getNamespaceURI()) && \"li\".equals(VAR_8.getLocalName())) {\n                        Object VAR_9 = getChildTextValue(VAR_8);\n                        VAR_7.add(VAR_9);\n                    }\n                }\n\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                return VAR_10.unmodifiableList(VAR_7);\n            }\n        }\n\n        /* COMMENT_7 */\n        if (isResourceType(VAR_0)) {\n            return parseAsResource(VAR_0);\n        }\n\n        Node VAR_1 = VAR_0.getFirstChild();\n        String VAR_11 = VAR_1 != null ? VAR_1.getNodeValue() : null;\n        return VAR_11 != null ? VAR_11.trim() : \"\";\n    }",
    "func_graph_path": "haraldk/TwelveMonkeys/da4efe98bf09e1cce91b7633cb251958a200fc80/XMPReader.java/vul/after/3.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n         for (Node child : asIterable(node.getChildNodes())) {\n             if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {\n                 // Support for <rdf:Alt><rdf:li> -> return a Map<String, Object> keyed on xml:lang\n-                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();\n+                Map<String, Object> alternatives = new LinkedHashMap<>();\n                 for (Node alternative : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {\n                         NamedNodeMap attributes = alternative.getAttributes();\n@@ -16,7 +16,7 @@\n             else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {\n                 // Support for <rdf:Seq><rdf:li> -> return array\n                 // Support for <rdf:Bag><rdf:li> -> return array/unordered collection (how can a serialized collection not have order?)\n-                List<Object> seq = new ArrayList<Object>();\n+                List<Object> seq = new ArrayList<>();\n \n                 for (Node sequence : asIterable(child.getChildNodes())) {\n                     if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {",
    "diff_line_info": {
        "deleted_lines": [
            "                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();",
            "                List<Object> seq = new ArrayList<Object>();"
        ],
        "added_lines": [
            "                Map<String, Object> alternatives = new LinkedHashMap<>();",
            "                List<Object> seq = new ArrayList<>();"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}