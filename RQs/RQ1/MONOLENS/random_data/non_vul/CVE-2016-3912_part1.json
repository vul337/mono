{
    "cve_id": "CVE-2016-3912",
    "cwe_ids": [
        "CWE-264"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "android",
    "commit_msg": "DO NOT MERGE: Clean up when recycling a pid with a pending launch\n\nFix for accidental launch of a broadcast receiver in an\nincorrect app instance.\n\nBug: 30202481\nChange-Id: I8ec8f19c633f3aec8da084dab5fd5b312443336f\n(cherry picked from commit 55eacb944122ddc0a3bb693b36fe0f07b0fe18c9)\n",
    "commit_hash": "6c049120c2d749f0c0289d822ec7d0aa692f55c5",
    "git_url": "https://android.googlesource.com/platform/frameworks/base/+/6c049120c2d749f0c0289d822ec7d0aa692f55c5",
    "file_path": "services/core/java/com/android/server/am/ActivityManagerService.java",
    "func_name": "cleanUpApplicationRecordLocked",
    "func_before": "private final boolean cleanUpApplicationRecordLocked(ProcessRecord app,\n            boolean restarting, boolean allowRestart, int index) {\n        if (index >= 0) {\n            removeLruProcessLocked(app);\n            ProcessList.remove(app.pid);\n        }\n\n        mProcessesToGc.remove(app);\n        mPendingPssProcesses.remove(app);\n\n        // Dismiss any open dialogs.\n        if (app.crashDialog != null && !app.forceCrashReport) {\n            app.crashDialog.dismiss();\n            app.crashDialog = null;\n        }\n        if (app.anrDialog != null) {\n            app.anrDialog.dismiss();\n            app.anrDialog = null;\n        }\n        if (app.waitDialog != null) {\n            app.waitDialog.dismiss();\n            app.waitDialog = null;\n        }\n\n        app.crashing = false;\n        app.notResponding = false;\n\n        app.resetPackageList(mProcessStats);\n        app.unlinkDeathRecipient();\n        app.makeInactive(mProcessStats);\n        app.waitingToKill = null;\n        app.forcingToForeground = null;\n        updateProcessForegroundLocked(app, false, false);\n        app.foregroundActivities = false;\n        app.hasShownUi = false;\n        app.treatLikeActivity = false;\n        app.hasAboveClient = false;\n        app.hasClientActivities = false;\n\n        mServices.killServicesLocked(app, allowRestart);\n\n        boolean restart = false;\n\n        // Remove published content providers.\n        for (int i = app.pubProviders.size() - 1; i >= 0; i--) {\n            ContentProviderRecord cpr = app.pubProviders.valueAt(i);\n            final boolean always = app.bad || !allowRestart;\n            boolean inLaunching = removeDyingProviderLocked(app, cpr, always);\n            if ((inLaunching || always) && cpr.hasConnectionOrHandle()) {\n                // We left the provider in the launching list, need to\n                // restart it.\n                restart = true;\n            }\n\n            cpr.provider = null;\n            cpr.proc = null;\n        }\n        app.pubProviders.clear();\n\n        // Take care of any launching providers waiting for this process.\n        if (cleanupAppInLaunchingProvidersLocked(app, false)) {\n            restart = true;\n        }\n\n        // Unregister from connected content providers.\n        if (!app.conProviders.isEmpty()) {\n            for (int i = app.conProviders.size() - 1; i >= 0; i--) {\n                ContentProviderConnection conn = app.conProviders.get(i);\n                conn.provider.connections.remove(conn);\n                stopAssociationLocked(app.uid, app.processName, conn.provider.uid,\n                        conn.provider.name);\n            }\n            app.conProviders.clear();\n        }\n\n        // At this point there may be remaining entries in mLaunchingProviders\n        // where we were the only one waiting, so they are no longer of use.\n        // Look for these and clean up if found.\n        // XXX Commented out for now.  Trying to figure out a way to reproduce\n        // the actual situation to identify what is actually going on.\n        if (false) {\n            for (int i = mLaunchingProviders.size() - 1; i >= 0; i--) {\n                ContentProviderRecord cpr = mLaunchingProviders.get(i);\n                if (cpr.connections.size() <= 0 && !cpr.hasExternalProcessHandles()) {\n                    synchronized (cpr) {\n                        cpr.launchingApp = null;\n                        cpr.notifyAll();\n                    }\n                }\n            }\n        }\n\n        skipCurrentReceiverLocked(app);\n\n        // Unregister any receivers.\n        for (int i = app.receivers.size() - 1; i >= 0; i--) {\n            removeReceiverLocked(app.receivers.valueAt(i));\n        }\n        app.receivers.clear();\n\n        // If the app is undergoing backup, tell the backup manager about it\n        if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {\n            if (DEBUG_BACKUP || DEBUG_CLEANUP) Slog.d(TAG_CLEANUP, \"App \"\n                    + mBackupTarget.appInfo + \" died during backup\");\n            try {\n                IBackupManager bm = IBackupManager.Stub.asInterface(\n                        ServiceManager.getService(Context.BACKUP_SERVICE));\n                bm.agentDisconnected(app.info.packageName);\n            } catch (RemoteException e) {\n                // can't happen; backup manager is local\n            }\n        }\n\n        for (int i = mPendingProcessChanges.size() - 1; i >= 0; i--) {\n            ProcessChangeItem item = mPendingProcessChanges.get(i);\n            if (item.pid == app.pid) {\n                mPendingProcessChanges.remove(i);\n                mAvailProcessChanges.add(item);\n            }\n        }\n        mUiHandler.obtainMessage(DISPATCH_PROCESS_DIED_UI_MSG, app.pid, app.info.uid,\n                null).sendToTarget();\n\n        // If the caller is restarting this app, then leave it in its\n        // current lists and let the caller take care of it.\n        if (restarting) {\n            return false;\n        }\n\n        if (!app.persistent || app.isolated) {\n            if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,\n                    \"Removing non-persistent process during cleanup: \" + app);\n            removeProcessNameLocked(app.processName, app.uid);\n            if (mHeavyWeightProcess == app) {\n                mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,\n                        mHeavyWeightProcess.userId, 0));\n                mHeavyWeightProcess = null;\n            }\n        } else if (!app.removed) {\n            // This app is persistent, so we need to keep its record around.\n            // If it is not already on the pending app list, add it there\n            // and start a new process for it.\n            if (mPersistentStartingProcesses.indexOf(app) < 0) {\n                mPersistentStartingProcesses.add(app);\n                restart = true;\n            }\n        }\n        if ((DEBUG_PROCESSES || DEBUG_CLEANUP) && mProcessesOnHold.contains(app)) Slog.v(\n                TAG_CLEANUP, \"Clean-up removing on hold: \" + app);\n        mProcessesOnHold.remove(app);\n\n        if (app == mHomeProcess) {\n            mHomeProcess = null;\n        }\n        if (app == mPreviousProcess) {\n            mPreviousProcess = null;\n        }\n\n        if (restart && !app.isolated) {\n            // We have components that still need to be running in the\n            // process, so re-launch it.\n            if (index < 0) {\n                ProcessList.remove(app.pid);\n            }\n            addProcessNameLocked(app);\n            startProcessLocked(app, \"restart\", app.processName);\n            return true;\n        } else if (app.pid > 0 && app.pid != MY_PID) {\n            // Goodbye!\n            boolean removed;\n            synchronized (mPidsSelfLocked) {\n                mPidsSelfLocked.remove(app.pid);\n                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);\n            }\n            mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);\n            if (app.isolated) {\n                mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);\n            }\n            app.setPid(0);\n        }\n        return false;\n    }",
    "abstract_func_before": "private final boolean cleanUpApplicationRecordLocked(ProcessRecord VAR_0,\n            boolean VAR_1, boolean VAR_2, int VAR_3) {\n        if (VAR_3 >= 0) {\n            removeLruProcessLocked(VAR_0);\n            VAR_4.remove(VAR_0.pid);\n        }\n\n        VAR_5.remove(VAR_0);\n        VAR_6.remove(VAR_0);\n\n        /* COMMENT_0 */\n        if (VAR_0.crashDialog != null && !VAR_0.forceCrashReport) {\n            VAR_0.crashDialog.dismiss();\n            VAR_0.crashDialog = null;\n        }\n        if (VAR_0.anrDialog != null) {\n            VAR_0.anrDialog.dismiss();\n            VAR_0.anrDialog = null;\n        }\n        if (VAR_0.waitDialog != null) {\n            VAR_0.waitDialog.dismiss();\n            VAR_0.waitDialog = null;\n        }\n\n        VAR_0.crashing = false;\n        VAR_0.notResponding = false;\n\n        VAR_0.resetPackageList(VAR_7);\n        VAR_0.unlinkDeathRecipient();\n        VAR_0.makeInactive(VAR_7);\n        VAR_0.waitingToKill = null;\n        VAR_0.forcingToForeground = null;\n        updateProcessForegroundLocked(VAR_0, false, false);\n        VAR_0.foregroundActivities = false;\n        VAR_0.hasShownUi = false;\n        VAR_0.treatLikeActivity = false;\n        VAR_0.hasAboveClient = false;\n        VAR_0.hasClientActivities = false;\n\n        VAR_8.killServicesLocked(VAR_0, VAR_2);\n\n        boolean VAR_9 = false;\n\n        /* COMMENT_1 */\n        for (int VAR_10 = VAR_0.pubProviders.size() - 1; VAR_10 >= 0; VAR_10--) {\n            ContentProviderRecord VAR_11 = VAR_0.pubProviders.valueAt(VAR_10);\n            final boolean VAR_12 = VAR_0.bad || !VAR_2;\n            boolean VAR_13 = removeDyingProviderLocked(VAR_0, VAR_11, VAR_12);\n            if ((VAR_13 || VAR_12) && VAR_11.hasConnectionOrHandle()) {\n                /* COMMENT_2 */\n                /* COMMENT_3 */\n                VAR_9 = true;\n            }\n\n            VAR_11.provider = null;\n            VAR_11.proc = null;\n        }\n        VAR_0.pubProviders.clear();\n\n        /* COMMENT_4 */\n        if (cleanupAppInLaunchingProvidersLocked(VAR_0, false)) {\n            VAR_9 = true;\n        }\n\n        /* COMMENT_5 */\n        if (!VAR_0.conProviders.isEmpty()) {\n            for (int VAR_10 = VAR_0.conProviders.size() - 1; VAR_10 >= 0; VAR_10--) {\n                ContentProviderConnection VAR_14 = VAR_0.conProviders.get(VAR_10);\n                VAR_14.provider.connections.remove(VAR_14);\n                stopAssociationLocked(VAR_0.uid, VAR_0.processName, VAR_14.provider.uid,\n                        VAR_14.provider.name);\n            }\n            VAR_0.conProviders.clear();\n        }\n\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        if (false) {\n            for (int VAR_10 = VAR_15.size() - 1; VAR_10 >= 0; VAR_10--) {\n                ContentProviderRecord VAR_11 = VAR_15.get(VAR_10);\n                if (VAR_11.connections.size() <= 0 && !VAR_11.hasExternalProcessHandles()) {\n                    synchronized (VAR_11) {\n                        VAR_11.launchingApp = null;\n                        VAR_11.notifyAll();\n                    }\n                }\n            }\n        }\n\n        skipCurrentReceiverLocked(VAR_0);\n\n        /* COMMENT_11 */\n        for (int VAR_10 = VAR_0.receivers.size() - 1; VAR_10 >= 0; VAR_10--) {\n            removeReceiverLocked(VAR_0.receivers.valueAt(VAR_10));\n        }\n        VAR_0.receivers.clear();\n\n        /* COMMENT_12 */\n        if (VAR_16 != null && VAR_0.pid == VAR_16.app.pid) {\n            if (VAR_17 || VAR_18) VAR_19.d(VAR_20, \"App \"\n                    + VAR_16.appInfo + \" died during backup\");\n            try {\n                IBackupManager VAR_21 = VAR_22.Stub.asInterface(\n                        VAR_23.getService(VAR_24.BACKUP_SERVICE));\n                VAR_21.agentDisconnected(VAR_0.info.packageName);\n            } catch (RemoteException VAR_25) {\n                /* COMMENT_13 */\n            }\n        }\n\n        for (int VAR_10 = VAR_26.size() - 1; VAR_10 >= 0; VAR_10--) {\n            ProcessChangeItem VAR_27 = VAR_26.get(VAR_10);\n            if (VAR_27.pid == VAR_0.pid) {\n                VAR_26.remove(VAR_10);\n                VAR_28.add(VAR_27);\n            }\n        }\n        VAR_29.obtainMessage(VAR_30, VAR_0.pid, VAR_0.info.uid,\n                null).sendToTarget();\n\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        if (VAR_1) {\n            return false;\n        }\n\n        if (!VAR_0.persistent || VAR_0.isolated) {\n            if (VAR_31 || VAR_18) VAR_19.v(VAR_20,\n                    \"Removing non-persistent process during cleanup: \" + VAR_0);\n            removeProcessNameLocked(VAR_0.processName, VAR_0.uid);\n            if (VAR_32 == VAR_0) {\n                VAR_33.sendMessage(VAR_33.obtainMessage(VAR_34,\n                        VAR_32.userId, 0));\n                VAR_32 = null;\n            }\n        } else if (!VAR_0.removed) {\n            /* COMMENT_16 */\n            /* COMMENT_17 */\n            /* COMMENT_18 */\n            if (VAR_35.indexOf(VAR_0) < 0) {\n                VAR_35.add(VAR_0);\n                VAR_9 = true;\n            }\n        }\n        if ((VAR_31 || VAR_18) && VAR_36.contains(VAR_0)) VAR_19.v(\n                VAR_20, \"Clean-up removing on hold: \" + VAR_0);\n        VAR_36.remove(VAR_0);\n\n        if (VAR_0 == VAR_37) {\n            VAR_37 = null;\n        }\n        if (VAR_0 == VAR_38) {\n            VAR_38 = null;\n        }\n\n        if (VAR_9 && !VAR_0.isolated) {\n            /* COMMENT_19 */\n            /* COMMENT_20 */\n            if (VAR_3 < 0) {\n                VAR_4.remove(VAR_0.pid);\n            }\n            addProcessNameLocked(VAR_0);\n            startProcessLocked(VAR_0, \"restart\", VAR_0.processName);\n            return true;\n        } else if (VAR_0.pid > 0 && VAR_0.pid != VAR_39) {\n            /* COMMENT_21 */\n            boolean VAR_40;\n            synchronized (VAR_41) {\n                VAR_41.remove(VAR_0.pid);\n                VAR_33.removeMessages(VAR_42, VAR_0);\n            }\n            VAR_43.noteProcessFinish(VAR_0.processName, VAR_0.info.uid);\n            if (VAR_0.isolated) {\n                VAR_43.removeIsolatedUid(VAR_0.uid, VAR_0.info.uid);\n            }\n            VAR_0.setPid(0);\n        }\n        return false;\n    }",
    "func_graph_path_before": "android/6c049120c2d749f0c0289d822ec7d0aa692f55c5/ActivityManagerService.java/vul/before/0.json",
    "func": "private final boolean cleanUpApplicationRecordLocked(ProcessRecord app,\n            boolean restarting, boolean allowRestart, int index, boolean replacingPid) {\n        Slog.d(TAG, \"cleanUpApplicationRecord -- \" + app.pid);\n        if (index >= 0) {\n            removeLruProcessLocked(app);\n            ProcessList.remove(app.pid);\n        }\n\n        mProcessesToGc.remove(app);\n        mPendingPssProcesses.remove(app);\n\n        // Dismiss any open dialogs.\n        if (app.crashDialog != null && !app.forceCrashReport) {\n            app.crashDialog.dismiss();\n            app.crashDialog = null;\n        }\n        if (app.anrDialog != null) {\n            app.anrDialog.dismiss();\n            app.anrDialog = null;\n        }\n        if (app.waitDialog != null) {\n            app.waitDialog.dismiss();\n            app.waitDialog = null;\n        }\n\n        app.crashing = false;\n        app.notResponding = false;\n\n        app.resetPackageList(mProcessStats);\n        app.unlinkDeathRecipient();\n        app.makeInactive(mProcessStats);\n        app.waitingToKill = null;\n        app.forcingToForeground = null;\n        updateProcessForegroundLocked(app, false, false);\n        app.foregroundActivities = false;\n        app.hasShownUi = false;\n        app.treatLikeActivity = false;\n        app.hasAboveClient = false;\n        app.hasClientActivities = false;\n\n        mServices.killServicesLocked(app, allowRestart);\n\n        boolean restart = false;\n\n        // Remove published content providers.\n        for (int i = app.pubProviders.size() - 1; i >= 0; i--) {\n            ContentProviderRecord cpr = app.pubProviders.valueAt(i);\n            final boolean always = app.bad || !allowRestart;\n            boolean inLaunching = removeDyingProviderLocked(app, cpr, always);\n            if ((inLaunching || always) && cpr.hasConnectionOrHandle()) {\n                // We left the provider in the launching list, need to\n                // restart it.\n                restart = true;\n            }\n\n            cpr.provider = null;\n            cpr.proc = null;\n        }\n        app.pubProviders.clear();\n\n        // Take care of any launching providers waiting for this process.\n        if (cleanupAppInLaunchingProvidersLocked(app, false)) {\n            restart = true;\n        }\n\n        // Unregister from connected content providers.\n        if (!app.conProviders.isEmpty()) {\n            for (int i = app.conProviders.size() - 1; i >= 0; i--) {\n                ContentProviderConnection conn = app.conProviders.get(i);\n                conn.provider.connections.remove(conn);\n                stopAssociationLocked(app.uid, app.processName, conn.provider.uid,\n                        conn.provider.name);\n            }\n            app.conProviders.clear();\n        }\n\n        // At this point there may be remaining entries in mLaunchingProviders\n        // where we were the only one waiting, so they are no longer of use.\n        // Look for these and clean up if found.\n        // XXX Commented out for now.  Trying to figure out a way to reproduce\n        // the actual situation to identify what is actually going on.\n        if (false) {\n            for (int i = mLaunchingProviders.size() - 1; i >= 0; i--) {\n                ContentProviderRecord cpr = mLaunchingProviders.get(i);\n                if (cpr.connections.size() <= 0 && !cpr.hasExternalProcessHandles()) {\n                    synchronized (cpr) {\n                        cpr.launchingApp = null;\n                        cpr.notifyAll();\n                    }\n                }\n            }\n        }\n\n        skipCurrentReceiverLocked(app);\n\n        // Unregister any receivers.\n        for (int i = app.receivers.size() - 1; i >= 0; i--) {\n            removeReceiverLocked(app.receivers.valueAt(i));\n        }\n        app.receivers.clear();\n\n        // If the app is undergoing backup, tell the backup manager about it\n        if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {\n            if (DEBUG_BACKUP || DEBUG_CLEANUP) Slog.d(TAG_CLEANUP, \"App \"\n                    + mBackupTarget.appInfo + \" died during backup\");\n            try {\n                IBackupManager bm = IBackupManager.Stub.asInterface(\n                        ServiceManager.getService(Context.BACKUP_SERVICE));\n                bm.agentDisconnected(app.info.packageName);\n            } catch (RemoteException e) {\n                // can't happen; backup manager is local\n            }\n        }\n\n        for (int i = mPendingProcessChanges.size() - 1; i >= 0; i--) {\n            ProcessChangeItem item = mPendingProcessChanges.get(i);\n            if (item.pid == app.pid) {\n                mPendingProcessChanges.remove(i);\n                mAvailProcessChanges.add(item);\n            }\n        }\n        mUiHandler.obtainMessage(DISPATCH_PROCESS_DIED_UI_MSG, app.pid, app.info.uid,\n                null).sendToTarget();\n\n        // If the caller is restarting this app, then leave it in its\n        // current lists and let the caller take care of it.\n        if (restarting) {\n            return false;\n        }\n\n        if (!app.persistent || app.isolated) {\n            if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,\n                    \"Removing non-persistent process during cleanup: \" + app);\n            if (!replacingPid) {\n                removeProcessNameLocked(app.processName, app.uid);\n            }\n            if (mHeavyWeightProcess == app) {\n                mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,\n                        mHeavyWeightProcess.userId, 0));\n                mHeavyWeightProcess = null;\n            }\n        } else if (!app.removed) {\n            // This app is persistent, so we need to keep its record around.\n            // If it is not already on the pending app list, add it there\n            // and start a new process for it.\n            if (mPersistentStartingProcesses.indexOf(app) < 0) {\n                mPersistentStartingProcesses.add(app);\n                restart = true;\n            }\n        }\n        if ((DEBUG_PROCESSES || DEBUG_CLEANUP) && mProcessesOnHold.contains(app)) Slog.v(\n                TAG_CLEANUP, \"Clean-up removing on hold: \" + app);\n        mProcessesOnHold.remove(app);\n\n        if (app == mHomeProcess) {\n            mHomeProcess = null;\n        }\n        if (app == mPreviousProcess) {\n            mPreviousProcess = null;\n        }\n\n        if (restart && !app.isolated) {\n            // We have components that still need to be running in the\n            // process, so re-launch it.\n            if (index < 0) {\n                ProcessList.remove(app.pid);\n            }\n            addProcessNameLocked(app);\n            startProcessLocked(app, \"restart\", app.processName);\n            return true;\n        } else if (app.pid > 0 && app.pid != MY_PID) {\n            // Goodbye!\n            boolean removed;\n            synchronized (mPidsSelfLocked) {\n                mPidsSelfLocked.remove(app.pid);\n                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);\n            }\n            mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);\n            if (app.isolated) {\n                mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);\n            }\n            app.setPid(0);\n        }\n        return false;\n    }",
    "abstract_func": "private final boolean cleanUpApplicationRecordLocked(ProcessRecord VAR_0,\n            boolean VAR_1, boolean VAR_2, int VAR_3, boolean VAR_4) {\n        VAR_5.d(VAR_6, \"cleanUpApplicationRecord -- \" + VAR_0.pid);\n        if (VAR_3 >= 0) {\n            removeLruProcessLocked(VAR_0);\n            VAR_7.remove(VAR_0.pid);\n        }\n\n        VAR_8.remove(VAR_0);\n        VAR_9.remove(VAR_0);\n\n        /* COMMENT_0 */\n        if (VAR_0.crashDialog != null && !VAR_0.forceCrashReport) {\n            VAR_0.crashDialog.dismiss();\n            VAR_0.crashDialog = null;\n        }\n        if (VAR_0.anrDialog != null) {\n            VAR_0.anrDialog.dismiss();\n            VAR_0.anrDialog = null;\n        }\n        if (VAR_0.waitDialog != null) {\n            VAR_0.waitDialog.dismiss();\n            VAR_0.waitDialog = null;\n        }\n\n        VAR_0.crashing = false;\n        VAR_0.notResponding = false;\n\n        VAR_0.resetPackageList(VAR_10);\n        VAR_0.unlinkDeathRecipient();\n        VAR_0.makeInactive(VAR_10);\n        VAR_0.waitingToKill = null;\n        VAR_0.forcingToForeground = null;\n        updateProcessForegroundLocked(VAR_0, false, false);\n        VAR_0.foregroundActivities = false;\n        VAR_0.hasShownUi = false;\n        VAR_0.treatLikeActivity = false;\n        VAR_0.hasAboveClient = false;\n        VAR_0.hasClientActivities = false;\n\n        VAR_11.killServicesLocked(VAR_0, VAR_2);\n\n        boolean VAR_12 = false;\n\n        /* COMMENT_1 */\n        for (int VAR_13 = VAR_0.pubProviders.size() - 1; VAR_13 >= 0; VAR_13--) {\n            ContentProviderRecord VAR_14 = VAR_0.pubProviders.valueAt(VAR_13);\n            final boolean VAR_15 = VAR_0.bad || !VAR_2;\n            boolean VAR_16 = removeDyingProviderLocked(VAR_0, VAR_14, VAR_15);\n            if ((VAR_16 || VAR_15) && VAR_14.hasConnectionOrHandle()) {\n                /* COMMENT_2 */\n                /* COMMENT_3 */\n                VAR_12 = true;\n            }\n\n            VAR_14.provider = null;\n            VAR_14.proc = null;\n        }\n        VAR_0.pubProviders.clear();\n\n        /* COMMENT_4 */\n        if (cleanupAppInLaunchingProvidersLocked(VAR_0, false)) {\n            VAR_12 = true;\n        }\n\n        /* COMMENT_5 */\n        if (!VAR_0.conProviders.isEmpty()) {\n            for (int VAR_13 = VAR_0.conProviders.size() - 1; VAR_13 >= 0; VAR_13--) {\n                ContentProviderConnection VAR_17 = VAR_0.conProviders.get(VAR_13);\n                VAR_17.provider.connections.remove(VAR_17);\n                stopAssociationLocked(VAR_0.uid, VAR_0.processName, VAR_17.provider.uid,\n                        VAR_17.provider.name);\n            }\n            VAR_0.conProviders.clear();\n        }\n\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        if (false) {\n            for (int VAR_13 = VAR_18.size() - 1; VAR_13 >= 0; VAR_13--) {\n                ContentProviderRecord VAR_14 = VAR_18.get(VAR_13);\n                if (VAR_14.connections.size() <= 0 && !VAR_14.hasExternalProcessHandles()) {\n                    synchronized (VAR_14) {\n                        VAR_14.launchingApp = null;\n                        VAR_14.notifyAll();\n                    }\n                }\n            }\n        }\n\n        skipCurrentReceiverLocked(VAR_0);\n\n        /* COMMENT_11 */\n        for (int VAR_13 = VAR_0.receivers.size() - 1; VAR_13 >= 0; VAR_13--) {\n            removeReceiverLocked(VAR_0.receivers.valueAt(VAR_13));\n        }\n        VAR_0.receivers.clear();\n\n        /* COMMENT_12 */\n        if (VAR_19 != null && VAR_0.pid == VAR_19.app.pid) {\n            if (VAR_20 || VAR_21) VAR_5.d(VAR_22, \"App \"\n                    + VAR_19.appInfo + \" died during backup\");\n            try {\n                IBackupManager VAR_23 = VAR_24.Stub.asInterface(\n                        VAR_25.getService(VAR_26.BACKUP_SERVICE));\n                VAR_23.agentDisconnected(VAR_0.info.packageName);\n            } catch (RemoteException VAR_27) {\n                /* COMMENT_13 */\n            }\n        }\n\n        for (int VAR_13 = VAR_28.size() - 1; VAR_13 >= 0; VAR_13--) {\n            ProcessChangeItem VAR_29 = VAR_28.get(VAR_13);\n            if (VAR_29.pid == VAR_0.pid) {\n                VAR_28.remove(VAR_13);\n                VAR_30.add(VAR_29);\n            }\n        }\n        VAR_31.obtainMessage(VAR_32, VAR_0.pid, VAR_0.info.uid,\n                null).sendToTarget();\n\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        if (VAR_1) {\n            return false;\n        }\n\n        if (!VAR_0.persistent || VAR_0.isolated) {\n            if (VAR_33 || VAR_21) VAR_5.v(VAR_22,\n                    \"Removing non-persistent process during cleanup: \" + VAR_0);\n            if (!VAR_4) {\n                removeProcessNameLocked(VAR_0.processName, VAR_0.uid);\n            }\n            if (VAR_34 == VAR_0) {\n                VAR_35.sendMessage(VAR_35.obtainMessage(VAR_36,\n                        VAR_34.userId, 0));\n                VAR_34 = null;\n            }\n        } else if (!VAR_0.removed) {\n            /* COMMENT_16 */\n            /* COMMENT_17 */\n            /* COMMENT_18 */\n            if (VAR_37.indexOf(VAR_0) < 0) {\n                VAR_37.add(VAR_0);\n                VAR_12 = true;\n            }\n        }\n        if ((VAR_33 || VAR_21) && VAR_38.contains(VAR_0)) VAR_5.v(\n                VAR_22, \"Clean-up removing on hold: \" + VAR_0);\n        VAR_38.remove(VAR_0);\n\n        if (VAR_0 == VAR_39) {\n            VAR_39 = null;\n        }\n        if (VAR_0 == VAR_40) {\n            VAR_40 = null;\n        }\n\n        if (VAR_12 && !VAR_0.isolated) {\n            /* COMMENT_19 */\n            /* COMMENT_20 */\n            if (VAR_3 < 0) {\n                VAR_7.remove(VAR_0.pid);\n            }\n            addProcessNameLocked(VAR_0);\n            startProcessLocked(VAR_0, \"restart\", VAR_0.processName);\n            return true;\n        } else if (VAR_0.pid > 0 && VAR_0.pid != VAR_41) {\n            /* COMMENT_21 */\n            boolean VAR_42;\n            synchronized (VAR_43) {\n                VAR_43.remove(VAR_0.pid);\n                VAR_35.removeMessages(VAR_44, VAR_0);\n            }\n            VAR_45.noteProcessFinish(VAR_0.processName, VAR_0.info.uid);\n            if (VAR_0.isolated) {\n                VAR_45.removeIsolatedUid(VAR_0.uid, VAR_0.info.uid);\n            }\n            VAR_0.setPid(0);\n        }\n        return false;\n    }",
    "func_graph_path": "android/6c049120c2d749f0c0289d822ec7d0aa692f55c5/ActivityManagerService.java/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n private final boolean cleanUpApplicationRecordLocked(ProcessRecord app,\n-            boolean restarting, boolean allowRestart, int index) {\n+            boolean restarting, boolean allowRestart, int index, boolean replacingPid) {\n+        Slog.d(TAG, \"cleanUpApplicationRecord -- \" + app.pid);\n         if (index >= 0) {\n             removeLruProcessLocked(app);\n             ProcessList.remove(app.pid);\n@@ -130,7 +131,9 @@\n         if (!app.persistent || app.isolated) {\n             if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,\n                     \"Removing non-persistent process during cleanup: \" + app);\n-            removeProcessNameLocked(app.processName, app.uid);\n+            if (!replacingPid) {\n+                removeProcessNameLocked(app.processName, app.uid);\n+            }\n             if (mHeavyWeightProcess == app) {\n                 mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,\n                         mHeavyWeightProcess.userId, 0));",
    "diff_line_info": {
        "deleted_lines": [
            "            boolean restarting, boolean allowRestart, int index) {",
            "            removeProcessNameLocked(app.processName, app.uid);"
        ],
        "added_lines": [
            "            boolean restarting, boolean allowRestart, int index, boolean replacingPid) {",
            "        Slog.d(TAG, \"cleanUpApplicationRecord -- \" + app.pid);",
            "            if (!replacingPid) {",
            "                removeProcessNameLocked(app.processName, app.uid);",
            "            }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}