{
    "cve_id": "CVE-2018-12714",
    "cwe_ids": [
        "CWE-787"
    ],
    "cvss_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "Pull tracing fixes from Steven Rostedt:\n \"This contains a few fixes and a clean up.\n\n   - a bad merge caused an \"endif\" to go in the wrong place in\n     scripts/Makefile.build\n\n   - softirq tracing fix for tracing that corrupts lockdep and causes a\n     false splat\n\n   - histogram documentation typo fixes\n\n   - fix a bad memory reference when passing in no filter to the filter\n     code\n\n   - simplify code by using the swap macro instead of open coding the\n     swap\"\n\n* tag 'trace-v4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace:\n  tracing: Fix SKIP_STACK_VALIDATION=1 build due to bad merge with -mrecord-mcount\n  tracing: Fix some errors in histogram documentation\n  tracing: Use swap macro in update_max_tr\n  softirq: Reorder trace_softirqs_on to prevent lockdep splat\n  tracing: Check for no filter when processing event filters\n",
    "commit_hash": "81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
    "git_url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
    "file_path": "kernel/trace/trace_events_filter.c",
    "func_name": "predicate_parse",
    "func_before": "static struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kmalloc_array(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(prog_stack);\n\tkfree(inverts);\n\treturn ERR_PTR(ret);\n}",
    "abstract_func_before": "static struct prog_entry *\npredicate_parse(const char *VAR_0, int VAR_1, int VAR_2,\n\t\tparse_pred_fn VAR_3, void *VAR_4,\n\t\tstruct filter_parse_error *VAR_5)\n{\n\tstruct prog_entry *VAR_6;\n\tstruct prog_entry *VAR_7;\n\tconst char *VAR_8 = VAR_0;\n\tchar *VAR_9 = NULL;\n\tint *VAR_10;\n\tint *VAR_11;\n\tint VAR_12 = 0;\n\tint VAR_13 = -VAR_14;\n\tint VAR_15;\n\tint VAR_16 = 0;\n\tint VAR_17;\n\n\tVAR_2 += 2; /* COMMENT_0 */\n\n\tVAR_10 = kmalloc_array(VAR_1, sizeof(*VAR_10), VAR_18);\n\tif (!VAR_10)\n\t\treturn ERR_PTR(-VAR_14);\n\tVAR_6 = kmalloc_array(VAR_2, sizeof(*VAR_6), VAR_18);\n\tif (!VAR_6) {\n\t\tparse_error(VAR_5, -VAR_14, 0);\n\t\tgoto out_free;\n\t}\n\tVAR_9 = kmalloc_array(VAR_2, sizeof(*VAR_9), VAR_18);\n\tif (!VAR_9) {\n\t\tparse_error(VAR_5, -VAR_14, 0);\n\t\tgoto out_free;\n\t}\n\n\tVAR_11 = VAR_10;\n\tVAR_7 = VAR_6;\n\t*VAR_11 = 0;\n\n\t/* COMMENT_1 */\n\twhile (*VAR_8) {\t\t\t\t\t\t/* COMMENT_2 */\n\t\tconst char *VAR_19 = VAR_8++;\n\n\t\tif (isspace(*VAR_19))\n\t\t\tcontinue;\n\n\t\tswitch (*VAR_19) {\n\t\tcase '(':\t\t\t\t\t/* COMMENT_3 */\n\t\t\tif (VAR_11 - VAR_10 > VAR_1)\n\t\t\t\treturn ERR_PTR(-VAR_20);\n\t\t\t*(++VAR_11) = VAR_12;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* COMMENT_4 */\n\t\t\tif (!is_not(VAR_19))\n\t\t\t\tbreak;\n\t\t\tVAR_12 = !VAR_12;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (VAR_16 >= VAR_2) {\n\t\t\tparse_error(VAR_5, VAR_21, VAR_19 - VAR_0);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tVAR_9[VAR_16] = VAR_12;\t\t\t\t/* COMMENT_5 */\n\t\tVAR_7[VAR_16].target = VAR_16-1;\n\n\t\tVAR_15 = VAR_3(VAR_19, VAR_4, VAR_8 - VAR_0, VAR_5, &VAR_7[VAR_16].pred);\n\t\tif (VAR_15 < 0) {\n\t\t\tVAR_13 = VAR_15;\n\t\t\tgoto out_free;\n\t\t}\n\t\tVAR_8 = VAR_19 + VAR_15;\n\n\t\tVAR_16++;\n\n\t\tVAR_13 = -1;\n\t\twhile (1) {\t\t\t\t\t/* COMMENT_6 */\n\t\t\tVAR_19 = VAR_8++;\n\t\t\tif (isspace(*VAR_19))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*VAR_19) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (VAR_19[1] == VAR_19[0]) {\n\t\t\t\t\tVAR_8++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(VAR_5, VAR_21,\n\t\t\t\t\t    VAR_19 - VAR_0);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tVAR_12 = *VAR_11 & VAR_22;\n\n\t\t\tif (*VAR_11 & VAR_23) {\t\t/* COMMENT_7 */\n\t\t\t\tupdate_preds(VAR_7, VAR_16 - 1, VAR_12);\n\t\t\t\t*VAR_11 &= ~VAR_23;\n\t\t\t}\n\t\t\tif (*VAR_19 == '&') {\t\t\t/* COMMENT_8 */\n\t\t\t\t*VAR_11 |= VAR_23;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*VAR_11 & VAR_24) {\t\t/* COMMENT_9 */\n\t\t\t\tupdate_preds(VAR_7, VAR_16 - 1, !VAR_12);\n\t\t\t\t*VAR_11 &= ~VAR_24;\n\t\t\t}\n\t\t\tif (*VAR_19 == '|') {\t\t\t/* COMMENT_10 */\n\t\t\t\t*VAR_11 |= VAR_24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*VAR_19)\t\t\t\t/* COMMENT_11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (VAR_11 == VAR_10) {\n\t\t\t\tVAR_13 = -1;\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tparse_error(VAR_5, VAR_25, VAR_8 - VAR_0);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tVAR_11--;\t\t\t\t\t/* COMMENT_13 */\n\t\t}\n\t}\n out:\n\tif (VAR_11 != VAR_10) {\n\t\t/* COMMENT_14 */\n\t\tparse_error(VAR_5, VAR_26, VAR_8 - VAR_0);\n\t\tgoto out_free;\n\t}\n\n\tVAR_7[VAR_16].pred = NULL;\t\t\t\t\t/* COMMENT_15 */\n\tVAR_7[VAR_16].target = 1;\t\t/* COMMENT_16 */\n\tVAR_7[VAR_16+1].pred = NULL;\n\tVAR_7[VAR_16+1].target = 0;\t\t/* COMMENT_17 */\n\tVAR_7[VAR_16-1].target = VAR_16;\n\tVAR_7[VAR_16-1].when_to_branch = false;\n\n\t/* COMMENT_18 */\n\tfor (VAR_17 = VAR_16-1 ; VAR_17--; ) {\n\t\tint VAR_27 = VAR_7[VAR_17].target;\n\t\tif (VAR_7[VAR_17].when_to_branch == VAR_7[VAR_27].when_to_branch)\n\t\t\tVAR_7[VAR_17].target = VAR_7[VAR_27].target;\n\t}\n\n\t/* COMMENT_19 */\n\tfor (VAR_17 = 0; VAR_17 < VAR_16; VAR_17++) {\n\t\tVAR_12 = VAR_9[VAR_17] ^ VAR_7[VAR_17].when_to_branch;\n\t\tVAR_7[VAR_17].when_to_branch = VAR_12;\n\t\t/* COMMENT_20 */\n\t\tif (WARN_ON(VAR_7[VAR_17].target <= VAR_17)) {\n\t\t\tVAR_13 = -VAR_20;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn VAR_7;\nout_free:\n\tkfree(VAR_10);\n\tkfree(VAR_6);\n\tkfree(VAR_9);\n\treturn ERR_PTR(VAR_13);\n}",
    "func_graph_path_before": "torvalds/linux/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03/trace_events_filter.c/vul/before/0.json",
    "func": "static struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kmalloc_array(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(prog_stack);\n\tkfree(inverts);\n\treturn ERR_PTR(ret);\n}",
    "abstract_func": "static struct prog_entry *\npredicate_parse(const char *VAR_0, int VAR_1, int VAR_2,\n\t\tparse_pred_fn VAR_3, void *VAR_4,\n\t\tstruct filter_parse_error *VAR_5)\n{\n\tstruct prog_entry *VAR_6;\n\tstruct prog_entry *VAR_7;\n\tconst char *VAR_8 = VAR_0;\n\tchar *VAR_9 = NULL;\n\tint *VAR_10;\n\tint *VAR_11;\n\tint VAR_12 = 0;\n\tint VAR_13 = -VAR_14;\n\tint VAR_15;\n\tint VAR_16 = 0;\n\tint VAR_17;\n\n\tVAR_2 += 2; /* COMMENT_0 */\n\n\tVAR_10 = kmalloc_array(VAR_1, sizeof(*VAR_10), VAR_18);\n\tif (!VAR_10)\n\t\treturn ERR_PTR(-VAR_14);\n\tVAR_6 = kmalloc_array(VAR_2, sizeof(*VAR_6), VAR_18);\n\tif (!VAR_6) {\n\t\tparse_error(VAR_5, -VAR_14, 0);\n\t\tgoto out_free;\n\t}\n\tVAR_9 = kmalloc_array(VAR_2, sizeof(*VAR_9), VAR_18);\n\tif (!VAR_9) {\n\t\tparse_error(VAR_5, -VAR_14, 0);\n\t\tgoto out_free;\n\t}\n\n\tVAR_11 = VAR_10;\n\tVAR_7 = VAR_6;\n\t*VAR_11 = 0;\n\n\t/* COMMENT_1 */\n\twhile (*VAR_8) {\t\t\t\t\t\t/* COMMENT_2 */\n\t\tconst char *VAR_19 = VAR_8++;\n\n\t\tif (isspace(*VAR_19))\n\t\t\tcontinue;\n\n\t\tswitch (*VAR_19) {\n\t\tcase '(':\t\t\t\t\t/* COMMENT_3 */\n\t\t\tif (VAR_11 - VAR_10 > VAR_1)\n\t\t\t\treturn ERR_PTR(-VAR_20);\n\t\t\t*(++VAR_11) = VAR_12;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* COMMENT_4 */\n\t\t\tif (!is_not(VAR_19))\n\t\t\t\tbreak;\n\t\t\tVAR_12 = !VAR_12;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (VAR_16 >= VAR_2) {\n\t\t\tparse_error(VAR_5, VAR_21, VAR_19 - VAR_0);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tVAR_9[VAR_16] = VAR_12;\t\t\t\t/* COMMENT_5 */\n\t\tVAR_7[VAR_16].target = VAR_16-1;\n\n\t\tVAR_15 = VAR_3(VAR_19, VAR_4, VAR_8 - VAR_0, VAR_5, &VAR_7[VAR_16].pred);\n\t\tif (VAR_15 < 0) {\n\t\t\tVAR_13 = VAR_15;\n\t\t\tgoto out_free;\n\t\t}\n\t\tVAR_8 = VAR_19 + VAR_15;\n\n\t\tVAR_16++;\n\n\t\tVAR_13 = -1;\n\t\twhile (1) {\t\t\t\t\t/* COMMENT_6 */\n\t\t\tVAR_19 = VAR_8++;\n\t\t\tif (isspace(*VAR_19))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*VAR_19) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (VAR_19[1] == VAR_19[0]) {\n\t\t\t\t\tVAR_8++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(VAR_5, VAR_21,\n\t\t\t\t\t    VAR_19 - VAR_0);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tVAR_12 = *VAR_11 & VAR_22;\n\n\t\t\tif (*VAR_11 & VAR_23) {\t\t/* COMMENT_7 */\n\t\t\t\tupdate_preds(VAR_7, VAR_16 - 1, VAR_12);\n\t\t\t\t*VAR_11 &= ~VAR_23;\n\t\t\t}\n\t\t\tif (*VAR_19 == '&') {\t\t\t/* COMMENT_8 */\n\t\t\t\t*VAR_11 |= VAR_23;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*VAR_11 & VAR_24) {\t\t/* COMMENT_9 */\n\t\t\t\tupdate_preds(VAR_7, VAR_16 - 1, !VAR_12);\n\t\t\t\t*VAR_11 &= ~VAR_24;\n\t\t\t}\n\t\t\tif (*VAR_19 == '|') {\t\t\t/* COMMENT_10 */\n\t\t\t\t*VAR_11 |= VAR_24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*VAR_19)\t\t\t\t/* COMMENT_11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (VAR_11 == VAR_10) {\n\t\t\t\tVAR_13 = -1;\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tparse_error(VAR_5, VAR_25, VAR_8 - VAR_0);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tVAR_11--;\t\t\t\t\t/* COMMENT_13 */\n\t\t}\n\t}\n out:\n\tif (VAR_11 != VAR_10) {\n\t\t/* COMMENT_14 */\n\t\tparse_error(VAR_5, VAR_26, VAR_8 - VAR_0);\n\t\tgoto out_free;\n\t}\n\n\tif (!VAR_16) {\n\t\t/* COMMENT_15 */\n\t\tVAR_13 = -VAR_20;\n\t\tparse_error(VAR_5, VAR_27, VAR_8 - VAR_0);\n\t\tgoto out_free;\n\t}\n\n\tVAR_7[VAR_16].pred = NULL;\t\t\t\t\t/* COMMENT_16 */\n\tVAR_7[VAR_16].target = 1;\t\t/* COMMENT_17 */\n\tVAR_7[VAR_16+1].pred = NULL;\n\tVAR_7[VAR_16+1].target = 0;\t\t/* COMMENT_18 */\n\tVAR_7[VAR_16-1].target = VAR_16;\n\tVAR_7[VAR_16-1].when_to_branch = false;\n\n\t/* COMMENT_19 */\n\tfor (VAR_17 = VAR_16-1 ; VAR_17--; ) {\n\t\tint VAR_28 = VAR_7[VAR_17].target;\n\t\tif (VAR_7[VAR_17].when_to_branch == VAR_7[VAR_28].when_to_branch)\n\t\t\tVAR_7[VAR_17].target = VAR_7[VAR_28].target;\n\t}\n\n\t/* COMMENT_20 */\n\tfor (VAR_17 = 0; VAR_17 < VAR_16; VAR_17++) {\n\t\tVAR_12 = VAR_9[VAR_17] ^ VAR_7[VAR_17].when_to_branch;\n\t\tVAR_7[VAR_17].when_to_branch = VAR_12;\n\t\t/* COMMENT_21 */\n\t\tif (WARN_ON(VAR_7[VAR_17].target <= VAR_17)) {\n\t\t\tVAR_13 = -VAR_20;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn VAR_7;\nout_free:\n\tkfree(VAR_10);\n\tkfree(VAR_6);\n\tkfree(VAR_9);\n\treturn ERR_PTR(VAR_13);\n}",
    "func_graph_path": "torvalds/linux/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03/trace_events_filter.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -131,6 +131,13 @@\n \t\tgoto out_free;\n \t}\n \n+\tif (!N) {\n+\t\t/* No program? */\n+\t\tret = -EINVAL;\n+\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n+\t\tgoto out_free;\n+\t}\n+\n \tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n \tprog[N].target = 1;\t\t/* TRUE */\n \tprog[N+1].pred = NULL;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "\tif (!N) {",
            "\t\t/* No program? */",
            "\t\tret = -EINVAL;",
            "\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);",
            "\t\tgoto out_free;",
            "\t}",
            ""
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}