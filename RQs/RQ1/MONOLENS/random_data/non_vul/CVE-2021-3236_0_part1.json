{
    "cve_id": "CVE-2021-3236",
    "cwe_ids": [
        "CWE-476"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "vim",
    "commit_msg": "patch 8.2.2354: crash with a weird combination of autocommands\n\nProblem:    Crash with a weird combination of autocommands.\nSolution:   Increment b_nwindows when needed. (closes #7674)",
    "commit_hash": "797e63b9f2baa1853e7063aac478d663cd02f207",
    "git_url": "https://github.com/vim/vim/commit/797e63b9f2baa1853e7063aac478d663cd02f207",
    "file_path": "src/ex_cmds.c",
    "func_name": "do_ecmd",
    "func_before": "int\ndo_ecmd(\n    int\t\tfnum,\n    char_u\t*ffname,\n    char_u\t*sfname,\n    exarg_T\t*eap,\t\t\t// can be NULL!\n    linenr_T\tnewlnum,\n    int\t\tflags,\n    win_T\t*oldwin)\n{\n    int\t\tother_file;\t\t// TRUE if editing another file\n    int\t\toldbuf;\t\t\t// TRUE if using existing buffer\n    int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us\n\t\t\t\t\t// into the buffer unexpectedly\n    char_u\t*new_name = NULL;\n#if defined(FEAT_EVAL)\n    int\t\tdid_set_swapcommand = FALSE;\n#endif\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    bufref_T\told_curbuf;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    char_u\t*browse_file = NULL;\n#endif\n    int\t\tretval = FAIL;\n    long\tn;\n    pos_T\torig_pos;\n    linenr_T\ttopline = 0;\n    int\t\tnewcol = -1;\n    int\t\tsolcol = -1;\n    pos_T\t*pos;\n    char_u\t*command = NULL;\n#ifdef FEAT_SPELL\n    int\t\tdid_get_winopts = FALSE;\n#endif\n    int\t\treadfile_flags = 0;\n    int\t\tdid_inc_redrawing_disabled = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn FAIL;\n#endif\n\n    if (eap != NULL)\n\tcommand = eap->do_ecmd_cmd;\n    set_bufref(&old_curbuf, curbuf);\n\n    if (fnum != 0)\n    {\n\tif (fnum == curbuf->b_fnum)\t// file is already being edited\n\t    return OK;\t\t\t// nothing to do\n\tother_file = TRUE;\n    }\n    else\n    {\n#ifdef FEAT_BROWSE\n\tif ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n\t{\n\t    if (\n# ifdef FEAT_GUI\n\t\t!gui.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t// No browsing supported but we do have the file explorer:\n\t\t// Edit the directory.\n\t\tif (ffname == NULL || !mch_isdir(ffname))\n\t\t    ffname = dot_path;\n\t    }\n\t    else\n\t    {\n\t\tbrowse_file = do_browse(0, (char_u *)_(\"Edit File\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t\tif (browse_file == NULL)\n\t\t    goto theend;\n\t\tffname = browse_file;\n\t    }\n\t}\n#endif\n\t// if no short name given, use ffname for short name\n\tif (sfname == NULL)\n\t    sfname = ffname;\n#ifdef USE_FNAME_CASE\n\tif (sfname != NULL)\n\t    fname_case(sfname, 0);   // set correct case for sfname\n#endif\n\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t\t\t\t\t && (ffname == NULL || *ffname == NUL))\n\t    goto theend;\n\n\tif (ffname == NULL)\n\t    other_file = TRUE;\n\t\t\t\t\t    // there is no file name\n\telse if (*ffname == NUL && curbuf->b_ffname == NULL)\n\t    other_file = FALSE;\n\telse\n\t{\n\t    if (*ffname == NUL)\t\t    // re-edit with same file name\n\t    {\n\t\tffname = curbuf->b_ffname;\n\t\tsfname = curbuf->b_fname;\n\t    }\n\t    free_fname = fix_fname(ffname); // may expand to full path name\n\t    if (free_fname != NULL)\n\t\tffname = free_fname;\n\t    other_file = otherfile(ffname);\n\t}\n    }\n\n    /*\n     * If the file was changed we may not be allowed to abandon it:\n     * - if we are going to re-edit the same file\n     * - or if we are the only window on this file and if ECMD_HIDE is FALSE\n     */\n    if (  ((!other_file && !(flags & ECMD_OLDBUF))\n\t    || (curbuf->b_nwindows == 1\n\t\t&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))\n\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    /*\n     * End Visual mode before switching to another buffer, so the text can be\n     * copied into the GUI selection buffer.\n     */\n    reset_VIsual();\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)\n\t    len = (int)STRLEN(command) + 3;\n\telse\n\t    len = 30;\n\tp = alloc(len);\n\tif (p != NULL)\n\t{\n\t    if (command != NULL)\n\t\tvim_snprintf((char *)p, len, \":%s\\r\", command);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"%ldG\", (long)newlnum);\n\t    set_vim_var_string(VV_SWAPCOMMAND, p, -1);\n\t    did_set_swapcommand = TRUE;\n\t    vim_free(p);\n\t}\n    }\n#endif\n\n    /*\n     * If we are starting to edit another file, open a (new) buffer.\n     * Otherwise we re-use the current buffer.\n     */\n    if (other_file)\n    {\n\tif (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\tcurwin->w_alt_fnum = curbuf->b_fnum;\n\t    if (oldwin != NULL)\n\t\tbuflist_altfpos(oldwin);\n\t}\n\n\tif (fnum)\n\t    buf = buflist_findnr(fnum);\n\telse\n\t{\n\t    if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t    {\n\t\t// Default the line number to zero to avoid that a wininfo item\n\t\t// is added for the current window.\n\t\tlinenr_T\ttlnum = 0;\n\t\tbuf_T\t\t*newbuf;\n\n\t\tif (command != NULL)\n\t\t{\n\t\t    tlnum = atol((char *)command);\n\t\t    if (tlnum <= 0)\n\t\t\ttlnum = 1L;\n\t\t}\n\t\t// Add BLN_NOCURWIN to avoid a new wininfo items are associated\n\t\t// with the current window.\n\t\tnewbuf = buflist_new(ffname, sfname, tlnum,\n\t\t\t\t\t\t    BLN_LISTED | BLN_NOCURWIN);\n\t\tif (newbuf != NULL && (flags & ECMD_ALTBUF))\n\t\t    curwin->w_alt_fnum = newbuf->b_fnum;\n\t\tgoto theend;\n\t    }\n\t    buf = buflist_new(ffname, sfname, 0L,\n\t\t    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));\n\n\t    // autocommands may change curwin and curbuf\n\t    if (oldwin != NULL)\n\t\toldwin = curwin;\n\t    set_bufref(&old_curbuf, curbuf);\n\t}\n\tif (buf == NULL)\n\t    goto theend;\n\tif (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet\n\t{\n\t    oldbuf = FALSE;\n\t}\n\telse\t\t\t\t\t// existing memfile\n\t{\n\t    oldbuf = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    (void)buf_check_timestamp(buf, FALSE);\n\t    // Check if autocommands made the buffer invalid or changed the\n\t    // current buffer.\n\t    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)\n\t\tgoto theend;\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t\tgoto theend;\n#endif\n\t}\n\n\t// May jump to last used line number for a loaded buffer or when asked\n\t// for explicitly\n\tif ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)\n\t{\n\t    pos = buflist_findfpos(buf);\n\t    newlnum = pos->lnum;\n\t    solcol = pos->col;\n\t}\n\n\t/*\n\t * Make the (new) buffer the one used by the current window.\n\t * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.\n\t * If the current buffer was empty and has no file name, curbuf\n\t * is returned by buflist_new(), nothing to do here.\n\t */\n\tif (buf != curbuf)\n\t{\n\t    /*\n\t     * Be careful: The autocommands may delete any buffer and change\n\t     * the current buffer.\n\t     * - If the buffer we are going to edit is deleted, give up.\n\t     * - If the current buffer is deleted, prefer to load the new\n\t     *   buffer when loading a buffer is required.  This avoids\n\t     *   loading another buffer which then must be closed again.\n\t     * - If we ended up in the new buffer already, need to skip a few\n\t     *\t things, set auto_buf.\n\t     */\n\t    if (buf->b_fname != NULL)\n\t\tnew_name = vim_strsave(buf->b_fname);\n\t    set_bufref(&au_new_curbuf, buf);\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!bufref_valid(&au_new_curbuf))\n\t    {\n\t\t// new buffer has been deleted\n\t\tdelbuf_msg(new_name);\t// frees new_name\n\t\tgoto theend;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (buf == curbuf)\t\t// already in new buffer\n\t\tauto_buf = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *the_curwin = curwin;\n\n\t\t// Set the w_closing flag to avoid that autocommands close the\n\t\t// window.  And set b_locked for the same reason.\n\t\tthe_curwin->w_closing = TRUE;\n\t\t++buf->b_locked;\n\n\t\tif (curbuf == old_curbuf.br_buf)\n\t\t    buf_copy_options(buf, BCO_ENTER);\n\n\t\t// Close the link to the current buffer. This will set\n\t\t// oldwin->w_buffer to NULL.\n\t\tu_sync(FALSE);\n\t\tclose_buffer(oldwin, curbuf,\n\t\t\t (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);\n\n\t\tthe_curwin->w_closing = FALSE;\n\t\t--buf->b_locked;\n\n#ifdef FEAT_EVAL\n\t\t// autocmds may abort script processing\n\t\tif (aborting() && curwin->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(new_name);\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t// Be careful again, like above.\n\t\tif (!bufref_valid(&au_new_curbuf))\n\t\t{\n\t\t    // new buffer has been deleted\n\t\t    delbuf_msg(new_name);\t// frees new_name\n\t\t    goto theend;\n\t\t}\n\t\tif (buf == curbuf)\t\t// already in new buffer\n\t\t    auto_buf = TRUE;\n\t\telse\n\t\t{\n#ifdef FEAT_SYN_HL\n\t\t    /*\n\t\t     * <VN> We could instead free the synblock\n\t\t     * and re-attach to buffer, perhaps.\n\t\t     */\n\t\t    if (curwin->w_buffer == NULL\n\t\t\t    || curwin->w_s == &(curwin->w_buffer->b_s))\n\t\t\tcurwin->w_s = &(buf->b_s);\n#endif\n\t\t    curwin->w_buffer = buf;\n\t\t    curbuf = buf;\n\t\t    ++curbuf->b_nwindows;\n\n\t\t    // Set 'fileformat', 'binary' and 'fenc' when forced.\n\t\t    if (!oldbuf && eap != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, eap);\n\t\t\tset_forced_fenc(eap);\n\t\t    }\n\t\t}\n\n\t\t// May get the window options from the last time this buffer\n\t\t// was in this window (or another window).  If not used\n\t\t// before, reset the local window options to the global\n\t\t// values.  Also restores old folding stuff.\n\t\tget_winopts(curbuf);\n#ifdef FEAT_SPELL\n\t\tdid_get_winopts = TRUE;\n#endif\n\t    }\n\t    vim_free(new_name);\n\t    au_new_curbuf.br_buf = NULL;\n\t    au_new_curbuf.br_buf_free_count = 0;\n\t}\n\n\tcurwin->w_pcmark.lnum = 1;\n\tcurwin->w_pcmark.col = 0;\n    }\n    else // !other_file\n    {\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)\n\t    goto theend;\n\n\toldbuf = (flags & ECMD_OLDBUF);\n    }\n\n    // Don't redraw until the cursor is in the right line, otherwise\n    // autocommands may cause ml_get errors.\n    ++RedrawingDisabled;\n    did_inc_redrawing_disabled = TRUE;\n\n    buf = curbuf;\n    if ((flags & ECMD_SET_HELP) || keep_help_flag)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t// Don't make a buffer listed if it's a help buffer.  Useful when\n\t// using CTRL-O to go back to a help file.\n\tif (!curbuf->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    // If autocommands change buffers under our fingers, forget about\n    // editing the file.\n    if (buf != curbuf)\n\tgoto theend;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\tgoto theend;\n#endif\n\n    // Since we are starting to edit a file, consider the filetype to be\n    // unset.  Helps for when an autocommand changes files and expects syntax\n    // highlighting to work in the other file.\n    did_filetype = FALSE;\n\n/*\n * other_file\toldbuf\n *  FALSE\tFALSE\t    re-edit same file, buffer is re-used\n *  FALSE\tTRUE\t    re-edit same file, nothing changes\n *  TRUE\tFALSE\t    start editing new file, new buffer\n *  TRUE\tTRUE\t    start editing in existing buffer (nothing to do)\n */\n    if (!other_file && !oldbuf)\t\t// re-use the buffer\n    {\n\tset_last_cursor(curwin);\t// may set b_last_cursor\n\tif (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)\n\t{\n\t    newlnum = curwin->w_cursor.lnum;\n\t    solcol = curwin->w_cursor.col;\n\t}\n\tbuf = curbuf;\n\tif (buf->b_fname != NULL)\n\t    new_name = vim_strsave(buf->b_fname);\n\telse\n\t    new_name = NULL;\n\tset_bufref(&bufref, buf);\n\n\t// If the buffer was used before, store the current contents so that\n\t// the reload can be undone.  Do not do this if the (empty) buffer is\n\t// being re-used for another file.\n\tif (!(curbuf->b_flags & BF_NEVERLOADED)\n\t\t&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))\n\t{\n\t    // Sync first so that this is a separate undo-able action.\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == FAIL)\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(curbuf);\n\t    buf_freeall(curbuf, BFA_KEEP_UNDO);\n\n\t    // tell readfile() not to clear or reload undo info\n\t    readfile_flags = READ_KEEP_UNDO;\n\t}\n\telse\n\t    buf_freeall(curbuf, 0);   // free all things for buffer\n\n\t// If autocommands deleted the buffer we were going to re-edit, give\n\t// up and jump to the end.\n\tif (!bufref_valid(&bufref))\n\t{\n\t    delbuf_msg(new_name);\t// frees new_name\n\t    goto theend;\n\t}\n\tvim_free(new_name);\n\n\t// If autocommands change buffers under our fingers, forget about\n\t// re-editing the file.  Should do the buf_clear_file(), but perhaps\n\t// the autocommands changed the buffer...\n\tif (buf != curbuf)\n\t    goto theend;\n#ifdef FEAT_EVAL\n\tif (aborting())\t    // autocmds may abort script processing\n\t    goto theend;\n#endif\n\tbuf_clear_file(curbuf);\n\tcurbuf->b_op_start.lnum = 0;\t// clear '[ and '] marks\n\tcurbuf->b_op_end.lnum = 0;\n    }\n\n/*\n * If we get here we are sure to start editing\n */\n    // Assume success now\n    retval = OK;\n\n    /*\n     * Check if we are editing the w_arg_idx file in the argument list.\n     */\n    check_arg_idx(curwin);\n\n    if (!auto_buf)\n    {\n\t/*\n\t * Set cursor and init window before reading the file and executing\n\t * autocommands.  This allows for the autocommands to position the\n\t * cursor.\n\t */\n\tcurwin_init();\n\n#ifdef FEAT_FOLDING\n\t// It's possible that all lines in the buffer changed.  Need to update\n\t// automatic folding for all windows where it's used.\n\t{\n\t    win_T\t    *win;\n\t    tabpage_T\t    *tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, win)\n\t\tif (win->w_buffer == curbuf)\n\t\t    foldUpdateAll(win);\n\t}\n#endif\n\n\t// Change directories when the 'acd' option is set.\n\tDO_AUTOCHDIR;\n\n\t/*\n\t * Careful: open_buffer() and apply_autocmds() may change the current\n\t * buffer and window.\n\t */\n\torig_pos = curwin->w_cursor;\n\ttopline = curwin->w_topline;\n\tif (!oldbuf)\t\t\t    // need to read the file\n\t{\n#ifdef FEAT_PROP_POPUP\n\t    // Don't use the swap-exists dialog for a popup window, can't edit\n\t    // the buffer.\n\t    if (WIN_IS_POPUP(curwin))\n\t\tcurbuf->b_flags |= BF_NO_SEA;\n#endif\n\t    swap_exists_action = SEA_DIALOG;\n\t    curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag\n\n\t    /*\n\t     * Open the buffer and read the file.\n\t     */\n#if defined(FEAT_EVAL)\n\t    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))\n\t\tretval = FAIL;\n#else\n\t    (void)open_buffer(FALSE, eap, readfile_flags);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n\t    curbuf->b_flags &= ~BF_NO_SEA;\n#endif\n\t    if (swap_exists_action == SEA_QUIT)\n\t\tretval = FAIL;\n\t    handle_swap_exists(&old_curbuf);\n\t}\n\telse\n\t{\n\t    // Read the modelines, but only to set window-local options.  Any\n\t    // buffer-local options have already been set and may have been\n\t    // changed by the user.\n\t    do_modelines(OPT_WINONLY);\n\n\t    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,\n\t\t\t\t\t\t\t\t    &retval);\n\t    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,\n\t\t\t\t\t\t\t\t    &retval);\n\t}\n\tcheck_arg_idx(curwin);\n\n\t// If autocommands change the cursor position or topline, we should\n\t// keep it.  Also when it moves within a line. But not when it moves\n\t// to the first non-blank.\n\tif (!EQUAL_POS(curwin->w_cursor, orig_pos))\n\t{\n\t    char_u *text = ml_get_curline();\n\n\t    if (curwin->w_cursor.lnum != orig_pos.lnum\n\t\t    || curwin->w_cursor.col != (int)(skipwhite(text) - text))\n\t    {\n\t\tnewlnum = curwin->w_cursor.lnum;\n\t\tnewcol = curwin->w_cursor.col;\n\t    }\n\t}\n\tif (curwin->w_topline == topline)\n\t    topline = 0;\n\n\t// Even when cursor didn't move we need to recompute topline.\n\tchanged_line_abv_curs();\n\n#ifdef FEAT_TITLE\n\tmaketitle();\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\tif (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)\n\t    popup_set_title(curwin);\n#endif\n    }\n\n#ifdef FEAT_DIFF\n    // Tell the diff stuff that this buffer is new and/or needs updating.\n    // Also needed when re-editing the same buffer, because unloading will\n    // have removed it as a diff buffer.\n    if (curwin->w_p_diff)\n    {\n\tdiff_buf_add(curbuf);\n\tdiff_invalidate(curbuf);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // If the window options were changed may need to set the spell language.\n    // Can only do this after the buffer has been properly setup.\n    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n\n    if (command == NULL)\n    {\n\tif (newcol >= 0)\t// position set by autocommands\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    curwin->w_cursor.col = newcol;\n\t    check_cursor();\n\t}\n\telse if (newlnum > 0)\t// line number from caller or old position\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    check_cursor_lnum();\n\t    if (solcol >= 0 && !p_sol)\n\t    {\n\t\t// 'sol' is off: Use last known column.\n\t\tcurwin->w_cursor.col = solcol;\n\t\tcheck_cursor_col();\n\t\tcurwin->w_cursor.coladd = 0;\n\t\tcurwin->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(BL_SOL | BL_FIX);\n\t}\n\telse\t\t\t// no line number, go to last line in Ex mode\n\t{\n\t    if (exmode_active)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n    }\n\n    // Check if cursors in other windows on the same buffer are still valid\n    check_lnums(FALSE);\n\n    /*\n     * Did not read the file, need to show some info about the file.\n     * Do this after setting the cursor.\n     */\n    if (oldbuf && !auto_buf)\n    {\n\tint\tmsg_scroll_save = msg_scroll;\n\n\t// Obey the 'O' flag in 'cpoptions': overwrite any previous file\n\t// message.\n\tif (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\t    msg_scroll = FALSE;\n\tif (!msg_scroll)\t// wait a bit when overwriting an error msg\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tmsg_scroll = msg_scroll_save;\n\tmsg_scrolled_ign = TRUE;\n\n\tif (!shortmess(SHM_FILEINFO))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tmsg_scrolled_ign = FALSE;\n    }\n\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    if (command != NULL)\n\tdo_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n\n    --RedrawingDisabled;\n    did_inc_redrawing_disabled = FALSE;\n    if (!skip_redraw)\n    {\n\tn = *so_ptr;\n\tif (topline == 0 && command == NULL)\n\t    *so_ptr = 9999;\t\t// force cursor halfway the window\n\tupdate_topline();\n\tcurwin->w_scbind_pos = curwin->w_topline;\n\t*so_ptr = n;\n\tredraw_curbuf_later(NOT_VALID);\t// redraw this buffer later\n    }\n\n    if (p_im)\n\tneed_start_insertmode = TRUE;\n\n#ifdef FEAT_AUTOCHDIR\n    // Change directories when the 'acd' option is set and we aren't already in\n    // that directory (should already be done above). Expect getcwd() to be\n    // faster than calling shorten_fnames() unnecessarily.\n    if (p_acd && curbuf->b_ffname != NULL)\n    {\n\tchar_u\tcurdir[MAXPATHL];\n\tchar_u\tfiledir[MAXPATHL];\n\n\tvim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);\n\t*gettail_sep(filedir) = NUL;\n\tif (mch_dirname(curdir, MAXPATHL) != FAIL\n\t\t&& vim_fnamecmp(curdir, filedir) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(FEAT_NETBEANS_INTG)\n    if (curbuf->b_ffname != NULL)\n    {\n# ifdef FEAT_NETBEANS_INTG\n\tif ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)\n\t    netbeans_file_opened(curbuf);\n# endif\n    }\n#endif\n\ntheend:\n    if (did_inc_redrawing_disabled)\n\t--RedrawingDisabled;\n#if defined(FEAT_EVAL)\n    if (did_set_swapcommand)\n\tset_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}",
    "abstract_func_before": "int\ndo_ecmd(\n    int\t\tVAR_0,\n    char_u\t*VAR_1,\n    char_u\t*VAR_2,\n    exarg_T\t*VAR_3,\t\t\t/* COMMENT_0 */\n    linenr_T\tVAR_4,\n    int\t\tVAR_5,\n    win_T\t*VAR_6)\n{\n    int\t\tVAR_7;\t\t/* COMMENT_1 */\n    int\t\tVAR_8;\t\t\t/* COMMENT_2 */\n    int\t\tVAR_9 = FALSE;\t/* COMMENT_3 */\n\t\t\t\t\t/* COMMENT_4 */\n    char_u\t*VAR_10 = NULL;\n#if defined(VAR_11)\n    int\t\tVAR_12 = FALSE;\n#endif\n    buf_T\t*VAR_13;\n    bufref_T\tVAR_14;\n    bufref_T\tVAR_15;\n    char_u\t*VAR_16 = NULL;\n#ifdef VAR_17\n    char_u\tVAR_18[] = \".\";\n    char_u\t*VAR_19 = NULL;\n#endif\n    int\t\tVAR_20 = VAR_21;\n    long\tVAR_22;\n    pos_T\tVAR_23;\n    linenr_T\tVAR_24 = 0;\n    int\t\tVAR_25 = -1;\n    int\t\tVAR_26 = -1;\n    pos_T\t*VAR_27;\n    char_u\t*VAR_28 = NULL;\n#ifdef VAR_29\n    int\t\tVAR_30 = FALSE;\n#endif\n    int\t\tVAR_31 = 0;\n    int\t\tVAR_32 = FALSE;\n    long        *VAR_33 = VAR_34->w_p_so >= 0 ? &VAR_34->w_p_so : &VAR_35;\n\n#ifdef VAR_36\n    if (VAR_37)\n\treturn VAR_21;\n#endif\n\n    if (VAR_3 != NULL)\n\tVAR_28 = VAR_3->do_ecmd_cmd;\n    set_bufref(&VAR_15, VAR_38);\n\n    if (VAR_0 != 0)\n    {\n\tif (VAR_0 == VAR_38->b_fnum)\t/* COMMENT_5 */\n\t    return VAR_39;\t\t\t/* COMMENT_6 */\n\tVAR_7 = TRUE;\n    }\n    else\n    {\n#ifdef VAR_17\n\tif ((VAR_40.cmod_flags & VAR_41) && !VAR_42)\n\t{\n\t    if (\n# ifdef VAR_43\n\t\t!VAR_44.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t/* COMMENT_7 */\n\t\t/* COMMENT_8 */\n\t\tif (VAR_1 == NULL || !mch_isdir(VAR_1))\n\t\t    VAR_1 = VAR_18;\n\t    }\n\t    else\n\t    {\n\t\tVAR_19 = do_browse(0, (char_u *)_(\"Edit File\"), VAR_1,\n\t\t\t\t\t\t    NULL, NULL, NULL, VAR_38);\n\t\tif (VAR_19 == NULL)\n\t\t    goto theend;\n\t\tVAR_1 = VAR_19;\n\t    }\n\t}\n#endif\n\t/* COMMENT_9 */\n\tif (VAR_2 == NULL)\n\t    VAR_2 = VAR_1;\n#ifdef VAR_45\n\tif (VAR_2 != NULL)\n\t    fname_case(VAR_2, 0);   /* COMMENT_10 */\n#endif\n\n\tif ((VAR_5 & (VAR_46 | VAR_47))\n\t\t\t\t\t && (VAR_1 == NULL || *VAR_1 == VAR_48))\n\t    goto theend;\n\n\tif (VAR_1 == NULL)\n\t    VAR_7 = TRUE;\n\t\t\t\t\t    /* COMMENT_11 */\n\telse if (*VAR_1 == VAR_48 && VAR_38->b_ffname == NULL)\n\t    VAR_7 = FALSE;\n\telse\n\t{\n\t    if (*VAR_1 == VAR_48)\t\t    /* COMMENT_12 */\n\t    {\n\t\tVAR_1 = VAR_38->b_ffname;\n\t\tVAR_2 = VAR_38->b_fname;\n\t    }\n\t    VAR_16 = fix_fname(VAR_1); /* COMMENT_13 */\n\t    if (VAR_16 != NULL)\n\t\tVAR_1 = VAR_16;\n\t    VAR_7 = otherfile(VAR_1);\n\t}\n    }\n\n    /* COMMENT_14 */\n                                                                   \n                                                 \n                                                                            \n       \n    if (  ((!VAR_7 && !(VAR_5 & VAR_49))\n\t    || (VAR_38->b_nwindows == 1\n\t\t&& !(VAR_5 & (VAR_50 | VAR_46 | VAR_47))))\n\t&& check_changed(VAR_38, (VAR_51 ? VAR_52 : 0)\n\t\t\t       | (VAR_7 ? 0 : VAR_53)\n\t\t\t       | ((VAR_5 & VAR_54) ? VAR_55 : 0)\n\t\t\t       | (VAR_3 == NULL ? 0 : VAR_56)))\n    {\n\tif (VAR_0 == 0 && VAR_7 && VAR_1 != NULL)\n\t    (void)setaltfname(VAR_1, VAR_2, VAR_4 < 0 ? 0 : VAR_4);\n\tgoto theend;\n    }\n\n    /* COMMENT_19 */\n                                                                             \n                                            \n       \n    reset_VIsual();\n\n#if defined(VAR_11)\n    if ((VAR_28 != NULL || VAR_4 > (linenr_T)0)\n\t    && *get_vim_var_str(VAR_57) == VAR_48)\n    {\n\tint\tVAR_58;\n\tchar_u\t*VAR_59;\n\n\t/* COMMENT_23 */\n\tif (VAR_28 != NULL)\n\t    VAR_58 = (int)STRLEN(VAR_28) + 3;\n\telse\n\t    VAR_58 = 30;\n\tVAR_59 = alloc(VAR_58);\n\tif (VAR_59 != NULL)\n\t{\n\t    if (VAR_28 != NULL)\n\t\tvim_snprintf((char *)VAR_59, VAR_58, \":%s\\r\", VAR_28);\n\t    else\n\t\tvim_snprintf((char *)VAR_59, VAR_58, \"%ldG\", (long)VAR_4);\n\t    set_vim_var_string(VAR_57, VAR_59, -1);\n\t    VAR_12 = TRUE;\n\t    vim_free(VAR_59);\n\t}\n    }\n#endif\n\n    /* COMMENT_24 */\n                                                                    \n                                              \n       \n    if (VAR_7)\n    {\n\tif (!(VAR_5 & (VAR_46 | VAR_47)))\n\t{\n\t    if ((VAR_40.cmod_flags & VAR_60) == 0)\n\t\tVAR_34->w_alt_fnum = VAR_38->b_fnum;\n\t    if (VAR_6 != NULL)\n\t\tbuflist_altfpos(VAR_6);\n\t}\n\n\tif (VAR_0)\n\t    VAR_13 = buflist_findnr(VAR_0);\n\telse\n\t{\n\t    if (VAR_5 & (VAR_46 | VAR_47))\n\t    {\n\t\t/* COMMENT_28 */\n\t\t/* COMMENT_29 */\n\t\tlinenr_T\tVAR_61 = 0;\n\t\tbuf_T\t\t*VAR_62;\n\n\t\tif (VAR_28 != NULL)\n\t\t{\n\t\t    VAR_61 = atol((char *)VAR_28);\n\t\t    if (VAR_61 <= 0)\n\t\t\tVAR_61 = 1L;\n\t\t}\n\t\t/* COMMENT_30 */\n\t\t/* COMMENT_31 */\n\t\tVAR_62 = buflist_new(VAR_1, VAR_2, VAR_61,\n\t\t\t\t\t\t    VAR_63 | VAR_64);\n\t\tif (VAR_62 != NULL && (VAR_5 & VAR_47))\n\t\t    VAR_34->w_alt_fnum = VAR_62->b_fnum;\n\t\tgoto theend;\n\t    }\n\t    VAR_13 = buflist_new(VAR_1, VAR_2, 0L,\n\t\t    VAR_65 | ((VAR_5 & VAR_66) ? 0 : VAR_63));\n\n\t    /* COMMENT_32 */\n\t    if (VAR_6 != NULL)\n\t\tVAR_6 = VAR_34;\n\t    set_bufref(&VAR_15, VAR_38);\n\t}\n\tif (VAR_13 == NULL)\n\t    goto theend;\n\tif (VAR_13->b_ml.ml_mfp == NULL)\t\t/* COMMENT_33 */\n\t{\n\t    VAR_8 = FALSE;\n\t}\n\telse\t\t\t\t\t/* COMMENT_34 */\n\t{\n\t    VAR_8 = TRUE;\n\t    set_bufref(&VAR_14, VAR_13);\n\t    (void)buf_check_timestamp(VAR_13, FALSE);\n\t    /* COMMENT_35 */\n\t    /* COMMENT_36 */\n\t    if (!bufref_valid(&VAR_14) || VAR_38 != VAR_15.br_buf)\n\t\tgoto theend;\n#ifdef VAR_11\n\t    if (aborting())\t    /* COMMENT_37 */\n\t\tgoto theend;\n#endif\n\t}\n\n\t/* COMMENT_38 */\n\t/* COMMENT_39 */\n\tif ((VAR_8 && VAR_4 == VAR_67) || VAR_4 == VAR_68)\n\t{\n\t    VAR_27 = buflist_findfpos(VAR_13);\n\t    VAR_4 = VAR_27->lnum;\n\t    VAR_26 = VAR_27->col;\n\t}\n\n\t/* COMMENT_40 */\n                                                             \n                                                                    \n                                                                \n                                                     \n    \n\tif (VAR_13 != VAR_38)\n\t{\n\t    /* COMMENT_46 */\n                                                                     \n                           \n                                                                 \n                                                                  \n                                                                \n                                                                 \n                                                                      \n                              \n        \n\t    if (VAR_13->b_fname != NULL)\n\t\tVAR_10 = vim_strsave(VAR_13->b_fname);\n\t    set_bufref(&VAR_69, VAR_13);\n\t    apply_autocmds(VAR_70, NULL, NULL, FALSE, VAR_38);\n\t    if (!bufref_valid(&VAR_69))\n\t    {\n\t\t/* COMMENT_56 */\n\t\tdelbuf_msg(VAR_10);\t/* COMMENT_57 */\n\t\tgoto theend;\n\t    }\n#ifdef VAR_11\n\t    if (aborting())\t    /* COMMENT_37 */\n\t    {\n\t\tvim_free(VAR_10);\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (VAR_13 == VAR_38)\t\t/* COMMENT_58 */\n\t\tVAR_9 = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *VAR_71 = VAR_34;\n\n\t\t/* COMMENT_59 */\n\t\t/* COMMENT_60 */\n\t\tVAR_71->w_closing = TRUE;\n\t\t++VAR_13->b_locked;\n\n\t\tif (VAR_38 == VAR_15.br_buf)\n\t\t    buf_copy_options(VAR_13, VAR_72);\n\n\t\t/* COMMENT_61 */\n\t\t/* COMMENT_62 */\n\t\tu_sync(FALSE);\n\t\tclose_buffer(VAR_6, VAR_38,\n\t\t\t (VAR_5 & VAR_50) ? 0 : VAR_73, FALSE, FALSE);\n\n\t\tVAR_71->w_closing = FALSE;\n\t\t--VAR_13->b_locked;\n\n#ifdef VAR_11\n\t\t/* COMMENT_37 */\n\t\tif (aborting() && VAR_34->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(VAR_10);\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t/* COMMENT_63 */\n\t\tif (!bufref_valid(&VAR_69))\n\t\t{\n\t\t    /* COMMENT_56 */\n\t\t    delbuf_msg(VAR_10);\t/* COMMENT_57 */\n\t\t    goto theend;\n\t\t}\n\t\tif (VAR_13 == VAR_38)\t\t/* COMMENT_58 */\n\t\t    VAR_9 = TRUE;\n\t\telse\n\t\t{\n#ifdef VAR_74\n\t\t    /* COMMENT_64 */\n                                                \n                                          \n         \n\t\t    if (VAR_34->w_buffer == NULL\n\t\t\t    || VAR_34->w_s == &(VAR_34->w_buffer->b_s))\n\t\t\tVAR_34->w_s = &(VAR_13->b_s);\n#endif\n\t\t    VAR_34->w_buffer = VAR_13;\n\t\t    VAR_38 = VAR_13;\n\t\t    ++VAR_38->b_nwindows;\n\n\t\t    /* COMMENT_68 */\n\t\t    if (!VAR_8 && VAR_3 != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, VAR_3);\n\t\t\tset_forced_fenc(VAR_3);\n\t\t    }\n\t\t}\n\n\t\t/* COMMENT_69 */\n\t\t/* COMMENT_70 */\n\t\t/* COMMENT_71 */\n\t\t/* COMMENT_72 */\n\t\tget_winopts(VAR_38);\n#ifdef VAR_29\n\t\tVAR_30 = TRUE;\n#endif\n\t    }\n\t    vim_free(VAR_10);\n\t    VAR_69.br_buf = NULL;\n\t    VAR_69.br_buf_free_count = 0;\n\t}\n\n\tVAR_34->w_pcmark.lnum = 1;\n\tVAR_34->w_pcmark.col = 0;\n    }\n    else /* COMMENT_73 */\n    {\n\tif ((VAR_5 & (VAR_46 | VAR_47)) || check_fname() == VAR_21)\n\t    goto theend;\n\n\tVAR_8 = (VAR_5 & VAR_49);\n    }\n\n    /* COMMENT_74 */\n    /* COMMENT_75 */\n    ++VAR_75;\n    VAR_32 = TRUE;\n\n    VAR_13 = VAR_38;\n    if ((VAR_5 & VAR_66) || VAR_76)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t/* COMMENT_76 */\n\t/* COMMENT_77 */\n\tif (!VAR_38->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    /* COMMENT_78 */\n    /* COMMENT_79 */\n    if (VAR_13 != VAR_38)\n\tgoto theend;\n#ifdef VAR_11\n    if (aborting())\t    /* COMMENT_37 */\n\tgoto theend;\n#endif\n\n    /* COMMENT_80 */\n    /* COMMENT_81 */\n    /* COMMENT_82 */\n    VAR_77 = FALSE;\n\n/* COMMENT_83 */\n                    \n                                                        \n                                                     \n                                                     \n                                                                  \n   \n    if (!VAR_7 && !VAR_8)\t\t/* COMMENT_90 */\n    {\n\tset_last_cursor(VAR_34);\t/* COMMENT_91 */\n\tif (VAR_4 == VAR_68 || VAR_4 == VAR_67)\n\t{\n\t    VAR_4 = VAR_34->w_cursor.lnum;\n\t    VAR_26 = VAR_34->w_cursor.col;\n\t}\n\tVAR_13 = VAR_38;\n\tif (VAR_13->b_fname != NULL)\n\t    VAR_10 = vim_strsave(VAR_13->b_fname);\n\telse\n\t    VAR_10 = NULL;\n\tset_bufref(&VAR_14, VAR_13);\n\n\t/* COMMENT_92 */\n\t/* COMMENT_93 */\n\t/* COMMENT_94 */\n\tif (!(VAR_38->b_flags & VAR_78)\n\t\t&& (VAR_79 < 0 || VAR_38->b_ml.ml_line_count <= VAR_79))\n\t{\n\t    /* COMMENT_95 */\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, VAR_38->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == VAR_21)\n\t    {\n\t\tvim_free(VAR_10);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(VAR_38);\n\t    buf_freeall(VAR_38, VAR_80);\n\n\t    /* COMMENT_96 */\n\t    VAR_31 = VAR_81;\n\t}\n\telse\n\t    buf_freeall(VAR_38, 0);   /* COMMENT_97 */\n\n\t/* COMMENT_98 */\n\t/* COMMENT_99 */\n\tif (!bufref_valid(&VAR_14))\n\t{\n\t    delbuf_msg(VAR_10);\t/* COMMENT_57 */\n\t    goto theend;\n\t}\n\tvim_free(VAR_10);\n\n\t/* COMMENT_78 */\n\t/* COMMENT_100 */\n\t/* COMMENT_101 */\n\tif (VAR_13 != VAR_38)\n\t    goto theend;\n#ifdef VAR_11\n\tif (aborting())\t    /* COMMENT_37 */\n\t    goto theend;\n#endif\n\tbuf_clear_file(VAR_38);\n\tVAR_38->b_op_start.lnum = 0;\t/* COMMENT_102 */\n\tVAR_38->b_op_end.lnum = 0;\n    }\n\n/* COMMENT_103 */\n                                              \n   \n    /* COMMENT_106 */\n    VAR_20 = VAR_39;\n\n    /* COMMENT_107 */\n                                                                       \n       \n    check_arg_idx(VAR_34);\n\n    if (!VAR_9)\n    {\n\t/* COMMENT_110 */\n                                                                    \n                                                                   \n           \n    \n\tcurwin_init();\n\n#ifdef VAR_82\n\t/* COMMENT_115 */\n\t/* COMMENT_116 */\n\t{\n\t    win_T\t    *VAR_83;\n\t    tabpage_T\t    *VAR_84;\n\n\t    FOR_ALL_TAB_WINDOWS(VAR_84, VAR_83)\n\t\tif (VAR_83->w_buffer == VAR_38)\n\t\t    foldUpdateAll(VAR_83);\n\t}\n#endif\n\n\t/* COMMENT_117 */\n\tVAR_85;\n\n\t/* COMMENT_118 */\n                                                                      \n                      \n    \n\tVAR_23 = VAR_34->w_cursor;\n\tVAR_24 = VAR_34->w_topline;\n\tif (!VAR_8)\t\t\t    /* COMMENT_122 */\n\t{\n#ifdef VAR_36\n\t    /* COMMENT_123 */\n\t    /* COMMENT_124 */\n\t    if (WIN_IS_POPUP(VAR_34))\n\t\tVAR_38->b_flags |= VAR_86;\n#endif\n\t    VAR_87 = VAR_88;\n\t    VAR_38->b_flags |= VAR_89; /* COMMENT_125 */\n\n\t    /* COMMENT_126 */\n                                          \n        \n#if defined(VAR_11)\n\t    if (should_abort(open_buffer(FALSE, VAR_3, VAR_31)))\n\t\tVAR_20 = VAR_21;\n#else\n\t    (void)open_buffer(FALSE, VAR_3, VAR_31);\n#endif\n\n#ifdef VAR_36\n\t    VAR_38->b_flags &= ~VAR_86;\n#endif\n\t    if (VAR_87 == VAR_90)\n\t\tVAR_20 = VAR_21;\n\t    handle_swap_exists(&VAR_15);\n\t}\n\telse\n\t{\n\t    /* COMMENT_129 */\n\t    /* COMMENT_130 */\n\t    /* COMMENT_131 */\n\t    do_modelines(VAR_91);\n\n\t    apply_autocmds_retval(VAR_92, NULL, NULL, FALSE, VAR_38,\n\t\t\t\t\t\t\t\t    &VAR_20);\n\t    apply_autocmds_retval(VAR_93, NULL, NULL, FALSE, VAR_38,\n\t\t\t\t\t\t\t\t    &VAR_20);\n\t}\n\tcheck_arg_idx(VAR_34);\n\n\t/* COMMENT_132 */\n\t/* COMMENT_133 */\n\t/* COMMENT_134 */\n\tif (!EQUAL_POS(VAR_34->w_cursor, VAR_23))\n\t{\n\t    char_u *VAR_94 = ml_get_curline();\n\n\t    if (VAR_34->w_cursor.lnum != VAR_23.lnum\n\t\t    || VAR_34->w_cursor.col != (int)(skipwhite(VAR_94) - VAR_94))\n\t    {\n\t\tVAR_4 = VAR_34->w_cursor.lnum;\n\t\tVAR_25 = VAR_34->w_cursor.col;\n\t    }\n\t}\n\tif (VAR_34->w_topline == VAR_24)\n\t    VAR_24 = 0;\n\n\t/* COMMENT_135 */\n\tchanged_line_abv_curs();\n\n#ifdef VAR_95\n\tmaketitle();\n#endif\n#if defined(VAR_36) && defined(VAR_96)\n\tif (WIN_IS_POPUP(VAR_34) && VAR_34->w_p_pvw && VAR_20 != VAR_21)\n\t    popup_set_title(VAR_34);\n#endif\n    }\n\n#ifdef VAR_97\n    /* COMMENT_136 */\n    /* COMMENT_137 */\n    /* COMMENT_138 */\n    if (VAR_34->w_p_diff)\n    {\n\tdiff_buf_add(VAR_38);\n\tdiff_invalidate(VAR_38);\n    }\n#endif\n\n#ifdef VAR_29\n    /* COMMENT_139 */\n    /* COMMENT_140 */\n    if (VAR_30 && VAR_34->w_p_spell && *VAR_34->w_s->b_p_spl != VAR_48)\n\t(void)did_set_spelllang(VAR_34);\n#endif\n\n    if (VAR_28 == NULL)\n    {\n\tif (VAR_25 >= 0)\t/* COMMENT_141 */\n\t{\n\t    VAR_34->w_cursor.lnum = VAR_4;\n\t    VAR_34->w_cursor.col = VAR_25;\n\t    check_cursor();\n\t}\n\telse if (VAR_4 > 0)\t/* COMMENT_142 */\n\t{\n\t    VAR_34->w_cursor.lnum = VAR_4;\n\t    check_cursor_lnum();\n\t    if (VAR_26 >= 0 && !VAR_98)\n\t    {\n\t\t/* COMMENT_143 */\n\t\tVAR_34->w_cursor.col = VAR_26;\n\t\tcheck_cursor_col();\n\t\tVAR_34->w_cursor.coladd = 0;\n\t\tVAR_34->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(VAR_99 | VAR_100);\n\t}\n\telse\t\t\t/* COMMENT_144 */\n\t{\n\t    if (VAR_101)\n\t\tVAR_34->w_cursor.lnum = VAR_38->b_ml.ml_line_count;\n\t    beginline(VAR_102 | VAR_100);\n\t}\n    }\n\n    /* COMMENT_145 */\n    check_lnums(FALSE);\n\n    /* COMMENT_146 */\n                                                                    \n                                        \n       \n    if (VAR_8 && !VAR_9)\n    {\n\tint\tVAR_103 = VAR_104;\n\n\t/* COMMENT_150 */\n\t/* COMMENT_151 */\n\tif (shortmess(VAR_105) && !VAR_42 && VAR_106 == 0)\n\t    VAR_104 = FALSE;\n\tif (!VAR_104)\t/* COMMENT_152 */\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tVAR_104 = VAR_103;\n\tVAR_107 = TRUE;\n\n\tif (!shortmess(VAR_108))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tVAR_107 = FALSE;\n    }\n\n#ifdef VAR_109\n    VAR_38->b_last_used = vim_time();\n#endif\n\n    if (VAR_28 != NULL)\n\tdo_cmdline(VAR_28, NULL, NULL, VAR_110|VAR_111);\n\n#ifdef VAR_112\n    if (VAR_38->b_kmap_state & VAR_113)\n\t(void)keymap_init();\n#endif\n\n    --VAR_75;\n    VAR_32 = FALSE;\n    if (!VAR_114)\n    {\n\tVAR_22 = *VAR_33;\n\tif (VAR_24 == 0 && VAR_28 == NULL)\n\t    *VAR_33 = 9999;\t\t/* COMMENT_153 */\n\tupdate_topline();\n\tVAR_34->w_scbind_pos = VAR_34->w_topline;\n\t*VAR_33 = VAR_22;\n\tredraw_curbuf_later(VAR_115);\t/* COMMENT_154 */\n    }\n\n    if (VAR_116)\n\tVAR_117 = TRUE;\n\n#ifdef VAR_118\n    /* COMMENT_155 */\n    /* COMMENT_156 */\n    /* COMMENT_157 */\n    if (VAR_119 && VAR_38->b_ffname != NULL)\n    {\n\tchar_u\tVAR_120[VAR_121];\n\tchar_u\tVAR_122[VAR_121];\n\n\tvim_strncpy(VAR_122, VAR_38->b_ffname, VAR_121 - 1);\n\t*gettail_sep(VAR_122) = VAR_48;\n\tif (mch_dirname(VAR_120, VAR_121) != VAR_21\n\t\t&& vim_fnamecmp(VAR_120, VAR_122) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(VAR_123)\n    if (VAR_38->b_ffname != NULL)\n    {\n# ifdef VAR_123\n\tif ((VAR_5 & VAR_66) != VAR_66)\n\t    netbeans_file_opened(VAR_38);\n# endif\n    }\n#endif\n\ntheend:\n    if (VAR_32)\n\t--VAR_75;\n#if defined(VAR_11)\n    if (VAR_12)\n\tset_vim_var_string(VAR_57, NULL, -1);\n#endif\n#ifdef VAR_17\n    vim_free(VAR_19);\n#endif\n    vim_free(VAR_16);\n    return VAR_20;\n}",
    "func_graph_path_before": "vim/797e63b9f2baa1853e7063aac478d663cd02f207/ex_cmds.c/vul/before/0.json",
    "func": "int\ndo_ecmd(\n    int\t\tfnum,\n    char_u\t*ffname,\n    char_u\t*sfname,\n    exarg_T\t*eap,\t\t\t// can be NULL!\n    linenr_T\tnewlnum,\n    int\t\tflags,\n    win_T\t*oldwin)\n{\n    int\t\tother_file;\t\t// TRUE if editing another file\n    int\t\toldbuf;\t\t\t// TRUE if using existing buffer\n    int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us\n\t\t\t\t\t// into the buffer unexpectedly\n    char_u\t*new_name = NULL;\n#if defined(FEAT_EVAL)\n    int\t\tdid_set_swapcommand = FALSE;\n#endif\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    bufref_T\told_curbuf;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    char_u\t*browse_file = NULL;\n#endif\n    int\t\tretval = FAIL;\n    long\tn;\n    pos_T\torig_pos;\n    linenr_T\ttopline = 0;\n    int\t\tnewcol = -1;\n    int\t\tsolcol = -1;\n    pos_T\t*pos;\n    char_u\t*command = NULL;\n#ifdef FEAT_SPELL\n    int\t\tdid_get_winopts = FALSE;\n#endif\n    int\t\treadfile_flags = 0;\n    int\t\tdid_inc_redrawing_disabled = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn FAIL;\n#endif\n\n    if (eap != NULL)\n\tcommand = eap->do_ecmd_cmd;\n    set_bufref(&old_curbuf, curbuf);\n\n    if (fnum != 0)\n    {\n\tif (fnum == curbuf->b_fnum)\t// file is already being edited\n\t    return OK;\t\t\t// nothing to do\n\tother_file = TRUE;\n    }\n    else\n    {\n#ifdef FEAT_BROWSE\n\tif ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n\t{\n\t    if (\n# ifdef FEAT_GUI\n\t\t!gui.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t// No browsing supported but we do have the file explorer:\n\t\t// Edit the directory.\n\t\tif (ffname == NULL || !mch_isdir(ffname))\n\t\t    ffname = dot_path;\n\t    }\n\t    else\n\t    {\n\t\tbrowse_file = do_browse(0, (char_u *)_(\"Edit File\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t\tif (browse_file == NULL)\n\t\t    goto theend;\n\t\tffname = browse_file;\n\t    }\n\t}\n#endif\n\t// if no short name given, use ffname for short name\n\tif (sfname == NULL)\n\t    sfname = ffname;\n#ifdef USE_FNAME_CASE\n\tif (sfname != NULL)\n\t    fname_case(sfname, 0);   // set correct case for sfname\n#endif\n\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t\t\t\t\t && (ffname == NULL || *ffname == NUL))\n\t    goto theend;\n\n\tif (ffname == NULL)\n\t    other_file = TRUE;\n\t\t\t\t\t    // there is no file name\n\telse if (*ffname == NUL && curbuf->b_ffname == NULL)\n\t    other_file = FALSE;\n\telse\n\t{\n\t    if (*ffname == NUL)\t\t    // re-edit with same file name\n\t    {\n\t\tffname = curbuf->b_ffname;\n\t\tsfname = curbuf->b_fname;\n\t    }\n\t    free_fname = fix_fname(ffname); // may expand to full path name\n\t    if (free_fname != NULL)\n\t\tffname = free_fname;\n\t    other_file = otherfile(ffname);\n\t}\n    }\n\n    /*\n     * If the file was changed we may not be allowed to abandon it:\n     * - if we are going to re-edit the same file\n     * - or if we are the only window on this file and if ECMD_HIDE is FALSE\n     */\n    if (  ((!other_file && !(flags & ECMD_OLDBUF))\n\t    || (curbuf->b_nwindows == 1\n\t\t&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))\n\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    /*\n     * End Visual mode before switching to another buffer, so the text can be\n     * copied into the GUI selection buffer.\n     */\n    reset_VIsual();\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)\n\t    len = (int)STRLEN(command) + 3;\n\telse\n\t    len = 30;\n\tp = alloc(len);\n\tif (p != NULL)\n\t{\n\t    if (command != NULL)\n\t\tvim_snprintf((char *)p, len, \":%s\\r\", command);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"%ldG\", (long)newlnum);\n\t    set_vim_var_string(VV_SWAPCOMMAND, p, -1);\n\t    did_set_swapcommand = TRUE;\n\t    vim_free(p);\n\t}\n    }\n#endif\n\n    /*\n     * If we are starting to edit another file, open a (new) buffer.\n     * Otherwise we re-use the current buffer.\n     */\n    if (other_file)\n    {\n\tif (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\tcurwin->w_alt_fnum = curbuf->b_fnum;\n\t    if (oldwin != NULL)\n\t\tbuflist_altfpos(oldwin);\n\t}\n\n\tif (fnum)\n\t    buf = buflist_findnr(fnum);\n\telse\n\t{\n\t    if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t    {\n\t\t// Default the line number to zero to avoid that a wininfo item\n\t\t// is added for the current window.\n\t\tlinenr_T\ttlnum = 0;\n\t\tbuf_T\t\t*newbuf;\n\n\t\tif (command != NULL)\n\t\t{\n\t\t    tlnum = atol((char *)command);\n\t\t    if (tlnum <= 0)\n\t\t\ttlnum = 1L;\n\t\t}\n\t\t// Add BLN_NOCURWIN to avoid a new wininfo items are associated\n\t\t// with the current window.\n\t\tnewbuf = buflist_new(ffname, sfname, tlnum,\n\t\t\t\t\t\t    BLN_LISTED | BLN_NOCURWIN);\n\t\tif (newbuf != NULL && (flags & ECMD_ALTBUF))\n\t\t    curwin->w_alt_fnum = newbuf->b_fnum;\n\t\tgoto theend;\n\t    }\n\t    buf = buflist_new(ffname, sfname, 0L,\n\t\t    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));\n\n\t    // autocommands may change curwin and curbuf\n\t    if (oldwin != NULL)\n\t\toldwin = curwin;\n\t    set_bufref(&old_curbuf, curbuf);\n\t}\n\tif (buf == NULL)\n\t    goto theend;\n\tif (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet\n\t{\n\t    oldbuf = FALSE;\n\t}\n\telse\t\t\t\t\t// existing memfile\n\t{\n\t    oldbuf = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    (void)buf_check_timestamp(buf, FALSE);\n\t    // Check if autocommands made the buffer invalid or changed the\n\t    // current buffer.\n\t    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)\n\t\tgoto theend;\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t\tgoto theend;\n#endif\n\t}\n\n\t// May jump to last used line number for a loaded buffer or when asked\n\t// for explicitly\n\tif ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)\n\t{\n\t    pos = buflist_findfpos(buf);\n\t    newlnum = pos->lnum;\n\t    solcol = pos->col;\n\t}\n\n\t/*\n\t * Make the (new) buffer the one used by the current window.\n\t * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.\n\t * If the current buffer was empty and has no file name, curbuf\n\t * is returned by buflist_new(), nothing to do here.\n\t */\n\tif (buf != curbuf)\n\t{\n\t    /*\n\t     * Be careful: The autocommands may delete any buffer and change\n\t     * the current buffer.\n\t     * - If the buffer we are going to edit is deleted, give up.\n\t     * - If the current buffer is deleted, prefer to load the new\n\t     *   buffer when loading a buffer is required.  This avoids\n\t     *   loading another buffer which then must be closed again.\n\t     * - If we ended up in the new buffer already, need to skip a few\n\t     *\t things, set auto_buf.\n\t     */\n\t    if (buf->b_fname != NULL)\n\t\tnew_name = vim_strsave(buf->b_fname);\n\t    set_bufref(&au_new_curbuf, buf);\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!bufref_valid(&au_new_curbuf))\n\t    {\n\t\t// new buffer has been deleted\n\t\tdelbuf_msg(new_name);\t// frees new_name\n\t\tgoto theend;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (buf == curbuf)\t\t// already in new buffer\n\t\tauto_buf = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *the_curwin = curwin;\n\t\tint\t    did_decrement;\n\t\tbuf_T\t    *was_curbuf = curbuf;\n\n\t\t// Set the w_closing flag to avoid that autocommands close the\n\t\t// window.  And set b_locked for the same reason.\n\t\tthe_curwin->w_closing = TRUE;\n\t\t++buf->b_locked;\n\n\t\tif (curbuf == old_curbuf.br_buf)\n\t\t    buf_copy_options(buf, BCO_ENTER);\n\n\t\t// Close the link to the current buffer. This will set\n\t\t// oldwin->w_buffer to NULL.\n\t\tu_sync(FALSE);\n\t\tdid_decrement = close_buffer(oldwin, curbuf,\n\t\t\t (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);\n\n\t\tthe_curwin->w_closing = FALSE;\n\t\t--buf->b_locked;\n\n#ifdef FEAT_EVAL\n\t\t// autocmds may abort script processing\n\t\tif (aborting() && curwin->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(new_name);\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t// Be careful again, like above.\n\t\tif (!bufref_valid(&au_new_curbuf))\n\t\t{\n\t\t    // new buffer has been deleted\n\t\t    delbuf_msg(new_name);\t// frees new_name\n\t\t    goto theend;\n\t\t}\n\t\tif (buf == curbuf)\t\t// already in new buffer\n\t\t{\n\t\t    // close_buffer() has decremented the window count,\n\t\t    // increment it again here and restore w_buffer.\n\t\t    if (did_decrement && buf_valid(was_curbuf))\n\t\t\t++was_curbuf->b_nwindows;\n\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)\n\t\t\toldwin->w_buffer = was_curbuf;\n\t\t    auto_buf = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_SYN_HL\n\t\t    /*\n\t\t     * <VN> We could instead free the synblock\n\t\t     * and re-attach to buffer, perhaps.\n\t\t     */\n\t\t    if (curwin->w_buffer == NULL\n\t\t\t    || curwin->w_s == &(curwin->w_buffer->b_s))\n\t\t\tcurwin->w_s = &(buf->b_s);\n#endif\n\t\t    curwin->w_buffer = buf;\n\t\t    curbuf = buf;\n\t\t    ++curbuf->b_nwindows;\n\n\t\t    // Set 'fileformat', 'binary' and 'fenc' when forced.\n\t\t    if (!oldbuf && eap != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, eap);\n\t\t\tset_forced_fenc(eap);\n\t\t    }\n\t\t}\n\n\t\t// May get the window options from the last time this buffer\n\t\t// was in this window (or another window).  If not used\n\t\t// before, reset the local window options to the global\n\t\t// values.  Also restores old folding stuff.\n\t\tget_winopts(curbuf);\n#ifdef FEAT_SPELL\n\t\tdid_get_winopts = TRUE;\n#endif\n\t    }\n\t    vim_free(new_name);\n\t    au_new_curbuf.br_buf = NULL;\n\t    au_new_curbuf.br_buf_free_count = 0;\n\t}\n\n\tcurwin->w_pcmark.lnum = 1;\n\tcurwin->w_pcmark.col = 0;\n    }\n    else // !other_file\n    {\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)\n\t    goto theend;\n\n\toldbuf = (flags & ECMD_OLDBUF);\n    }\n\n    // Don't redraw until the cursor is in the right line, otherwise\n    // autocommands may cause ml_get errors.\n    ++RedrawingDisabled;\n    did_inc_redrawing_disabled = TRUE;\n\n    buf = curbuf;\n    if ((flags & ECMD_SET_HELP) || keep_help_flag)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t// Don't make a buffer listed if it's a help buffer.  Useful when\n\t// using CTRL-O to go back to a help file.\n\tif (!curbuf->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    // If autocommands change buffers under our fingers, forget about\n    // editing the file.\n    if (buf != curbuf)\n\tgoto theend;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\tgoto theend;\n#endif\n\n    // Since we are starting to edit a file, consider the filetype to be\n    // unset.  Helps for when an autocommand changes files and expects syntax\n    // highlighting to work in the other file.\n    did_filetype = FALSE;\n\n/*\n * other_file\toldbuf\n *  FALSE\tFALSE\t    re-edit same file, buffer is re-used\n *  FALSE\tTRUE\t    re-edit same file, nothing changes\n *  TRUE\tFALSE\t    start editing new file, new buffer\n *  TRUE\tTRUE\t    start editing in existing buffer (nothing to do)\n */\n    if (!other_file && !oldbuf)\t\t// re-use the buffer\n    {\n\tset_last_cursor(curwin);\t// may set b_last_cursor\n\tif (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)\n\t{\n\t    newlnum = curwin->w_cursor.lnum;\n\t    solcol = curwin->w_cursor.col;\n\t}\n\tbuf = curbuf;\n\tif (buf->b_fname != NULL)\n\t    new_name = vim_strsave(buf->b_fname);\n\telse\n\t    new_name = NULL;\n\tset_bufref(&bufref, buf);\n\n\t// If the buffer was used before, store the current contents so that\n\t// the reload can be undone.  Do not do this if the (empty) buffer is\n\t// being re-used for another file.\n\tif (!(curbuf->b_flags & BF_NEVERLOADED)\n\t\t&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))\n\t{\n\t    // Sync first so that this is a separate undo-able action.\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == FAIL)\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(curbuf);\n\t    buf_freeall(curbuf, BFA_KEEP_UNDO);\n\n\t    // tell readfile() not to clear or reload undo info\n\t    readfile_flags = READ_KEEP_UNDO;\n\t}\n\telse\n\t    buf_freeall(curbuf, 0);   // free all things for buffer\n\n\t// If autocommands deleted the buffer we were going to re-edit, give\n\t// up and jump to the end.\n\tif (!bufref_valid(&bufref))\n\t{\n\t    delbuf_msg(new_name);\t// frees new_name\n\t    goto theend;\n\t}\n\tvim_free(new_name);\n\n\t// If autocommands change buffers under our fingers, forget about\n\t// re-editing the file.  Should do the buf_clear_file(), but perhaps\n\t// the autocommands changed the buffer...\n\tif (buf != curbuf)\n\t    goto theend;\n#ifdef FEAT_EVAL\n\tif (aborting())\t    // autocmds may abort script processing\n\t    goto theend;\n#endif\n\tbuf_clear_file(curbuf);\n\tcurbuf->b_op_start.lnum = 0;\t// clear '[ and '] marks\n\tcurbuf->b_op_end.lnum = 0;\n    }\n\n/*\n * If we get here we are sure to start editing\n */\n    // Assume success now\n    retval = OK;\n\n    /*\n     * Check if we are editing the w_arg_idx file in the argument list.\n     */\n    check_arg_idx(curwin);\n\n    if (!auto_buf)\n    {\n\t/*\n\t * Set cursor and init window before reading the file and executing\n\t * autocommands.  This allows for the autocommands to position the\n\t * cursor.\n\t */\n\tcurwin_init();\n\n#ifdef FEAT_FOLDING\n\t// It's possible that all lines in the buffer changed.  Need to update\n\t// automatic folding for all windows where it's used.\n\t{\n\t    win_T\t    *win;\n\t    tabpage_T\t    *tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, win)\n\t\tif (win->w_buffer == curbuf)\n\t\t    foldUpdateAll(win);\n\t}\n#endif\n\n\t// Change directories when the 'acd' option is set.\n\tDO_AUTOCHDIR;\n\n\t/*\n\t * Careful: open_buffer() and apply_autocmds() may change the current\n\t * buffer and window.\n\t */\n\torig_pos = curwin->w_cursor;\n\ttopline = curwin->w_topline;\n\tif (!oldbuf)\t\t\t    // need to read the file\n\t{\n#ifdef FEAT_PROP_POPUP\n\t    // Don't use the swap-exists dialog for a popup window, can't edit\n\t    // the buffer.\n\t    if (WIN_IS_POPUP(curwin))\n\t\tcurbuf->b_flags |= BF_NO_SEA;\n#endif\n\t    swap_exists_action = SEA_DIALOG;\n\t    curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag\n\n\t    /*\n\t     * Open the buffer and read the file.\n\t     */\n#if defined(FEAT_EVAL)\n\t    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))\n\t\tretval = FAIL;\n#else\n\t    (void)open_buffer(FALSE, eap, readfile_flags);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n\t    curbuf->b_flags &= ~BF_NO_SEA;\n#endif\n\t    if (swap_exists_action == SEA_QUIT)\n\t\tretval = FAIL;\n\t    handle_swap_exists(&old_curbuf);\n\t}\n\telse\n\t{\n\t    // Read the modelines, but only to set window-local options.  Any\n\t    // buffer-local options have already been set and may have been\n\t    // changed by the user.\n\t    do_modelines(OPT_WINONLY);\n\n\t    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,\n\t\t\t\t\t\t\t\t    &retval);\n\t    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,\n\t\t\t\t\t\t\t\t    &retval);\n\t}\n\tcheck_arg_idx(curwin);\n\n\t// If autocommands change the cursor position or topline, we should\n\t// keep it.  Also when it moves within a line. But not when it moves\n\t// to the first non-blank.\n\tif (!EQUAL_POS(curwin->w_cursor, orig_pos))\n\t{\n\t    char_u *text = ml_get_curline();\n\n\t    if (curwin->w_cursor.lnum != orig_pos.lnum\n\t\t    || curwin->w_cursor.col != (int)(skipwhite(text) - text))\n\t    {\n\t\tnewlnum = curwin->w_cursor.lnum;\n\t\tnewcol = curwin->w_cursor.col;\n\t    }\n\t}\n\tif (curwin->w_topline == topline)\n\t    topline = 0;\n\n\t// Even when cursor didn't move we need to recompute topline.\n\tchanged_line_abv_curs();\n\n#ifdef FEAT_TITLE\n\tmaketitle();\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\tif (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)\n\t    popup_set_title(curwin);\n#endif\n    }\n\n#ifdef FEAT_DIFF\n    // Tell the diff stuff that this buffer is new and/or needs updating.\n    // Also needed when re-editing the same buffer, because unloading will\n    // have removed it as a diff buffer.\n    if (curwin->w_p_diff)\n    {\n\tdiff_buf_add(curbuf);\n\tdiff_invalidate(curbuf);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // If the window options were changed may need to set the spell language.\n    // Can only do this after the buffer has been properly setup.\n    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n\n    if (command == NULL)\n    {\n\tif (newcol >= 0)\t// position set by autocommands\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    curwin->w_cursor.col = newcol;\n\t    check_cursor();\n\t}\n\telse if (newlnum > 0)\t// line number from caller or old position\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    check_cursor_lnum();\n\t    if (solcol >= 0 && !p_sol)\n\t    {\n\t\t// 'sol' is off: Use last known column.\n\t\tcurwin->w_cursor.col = solcol;\n\t\tcheck_cursor_col();\n\t\tcurwin->w_cursor.coladd = 0;\n\t\tcurwin->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(BL_SOL | BL_FIX);\n\t}\n\telse\t\t\t// no line number, go to last line in Ex mode\n\t{\n\t    if (exmode_active)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n    }\n\n    // Check if cursors in other windows on the same buffer are still valid\n    check_lnums(FALSE);\n\n    /*\n     * Did not read the file, need to show some info about the file.\n     * Do this after setting the cursor.\n     */\n    if (oldbuf && !auto_buf)\n    {\n\tint\tmsg_scroll_save = msg_scroll;\n\n\t// Obey the 'O' flag in 'cpoptions': overwrite any previous file\n\t// message.\n\tif (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\t    msg_scroll = FALSE;\n\tif (!msg_scroll)\t// wait a bit when overwriting an error msg\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tmsg_scroll = msg_scroll_save;\n\tmsg_scrolled_ign = TRUE;\n\n\tif (!shortmess(SHM_FILEINFO))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tmsg_scrolled_ign = FALSE;\n    }\n\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    if (command != NULL)\n\tdo_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n\n    --RedrawingDisabled;\n    did_inc_redrawing_disabled = FALSE;\n    if (!skip_redraw)\n    {\n\tn = *so_ptr;\n\tif (topline == 0 && command == NULL)\n\t    *so_ptr = 9999;\t\t// force cursor halfway the window\n\tupdate_topline();\n\tcurwin->w_scbind_pos = curwin->w_topline;\n\t*so_ptr = n;\n\tredraw_curbuf_later(NOT_VALID);\t// redraw this buffer later\n    }\n\n    if (p_im)\n\tneed_start_insertmode = TRUE;\n\n#ifdef FEAT_AUTOCHDIR\n    // Change directories when the 'acd' option is set and we aren't already in\n    // that directory (should already be done above). Expect getcwd() to be\n    // faster than calling shorten_fnames() unnecessarily.\n    if (p_acd && curbuf->b_ffname != NULL)\n    {\n\tchar_u\tcurdir[MAXPATHL];\n\tchar_u\tfiledir[MAXPATHL];\n\n\tvim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);\n\t*gettail_sep(filedir) = NUL;\n\tif (mch_dirname(curdir, MAXPATHL) != FAIL\n\t\t&& vim_fnamecmp(curdir, filedir) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(FEAT_NETBEANS_INTG)\n    if (curbuf->b_ffname != NULL)\n    {\n# ifdef FEAT_NETBEANS_INTG\n\tif ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)\n\t    netbeans_file_opened(curbuf);\n# endif\n    }\n#endif\n\ntheend:\n    if (did_inc_redrawing_disabled)\n\t--RedrawingDisabled;\n#if defined(FEAT_EVAL)\n    if (did_set_swapcommand)\n\tset_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}",
    "abstract_func": "int\ndo_ecmd(\n    int\t\tVAR_0,\n    char_u\t*VAR_1,\n    char_u\t*VAR_2,\n    exarg_T\t*VAR_3,\t\t\t/* COMMENT_0 */\n    linenr_T\tVAR_4,\n    int\t\tVAR_5,\n    win_T\t*VAR_6)\n{\n    int\t\tVAR_7;\t\t/* COMMENT_1 */\n    int\t\tVAR_8;\t\t\t/* COMMENT_2 */\n    int\t\tVAR_9 = FALSE;\t/* COMMENT_3 */\n\t\t\t\t\t/* COMMENT_4 */\n    char_u\t*VAR_10 = NULL;\n#if defined(VAR_11)\n    int\t\tVAR_12 = FALSE;\n#endif\n    buf_T\t*VAR_13;\n    bufref_T\tVAR_14;\n    bufref_T\tVAR_15;\n    char_u\t*VAR_16 = NULL;\n#ifdef VAR_17\n    char_u\tVAR_18[] = \".\";\n    char_u\t*VAR_19 = NULL;\n#endif\n    int\t\tVAR_20 = VAR_21;\n    long\tVAR_22;\n    pos_T\tVAR_23;\n    linenr_T\tVAR_24 = 0;\n    int\t\tVAR_25 = -1;\n    int\t\tVAR_26 = -1;\n    pos_T\t*VAR_27;\n    char_u\t*VAR_28 = NULL;\n#ifdef VAR_29\n    int\t\tVAR_30 = FALSE;\n#endif\n    int\t\tVAR_31 = 0;\n    int\t\tVAR_32 = FALSE;\n    long        *VAR_33 = VAR_34->w_p_so >= 0 ? &VAR_34->w_p_so : &VAR_35;\n\n#ifdef VAR_36\n    if (VAR_37)\n\treturn VAR_21;\n#endif\n\n    if (VAR_3 != NULL)\n\tVAR_28 = VAR_3->do_ecmd_cmd;\n    set_bufref(&VAR_15, VAR_38);\n\n    if (VAR_0 != 0)\n    {\n\tif (VAR_0 == VAR_38->b_fnum)\t/* COMMENT_5 */\n\t    return VAR_39;\t\t\t/* COMMENT_6 */\n\tVAR_7 = TRUE;\n    }\n    else\n    {\n#ifdef VAR_17\n\tif ((VAR_40.cmod_flags & VAR_41) && !VAR_42)\n\t{\n\t    if (\n# ifdef VAR_43\n\t\t!VAR_44.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t/* COMMENT_7 */\n\t\t/* COMMENT_8 */\n\t\tif (VAR_1 == NULL || !mch_isdir(VAR_1))\n\t\t    VAR_1 = VAR_18;\n\t    }\n\t    else\n\t    {\n\t\tVAR_19 = do_browse(0, (char_u *)_(\"Edit File\"), VAR_1,\n\t\t\t\t\t\t    NULL, NULL, NULL, VAR_38);\n\t\tif (VAR_19 == NULL)\n\t\t    goto theend;\n\t\tVAR_1 = VAR_19;\n\t    }\n\t}\n#endif\n\t/* COMMENT_9 */\n\tif (VAR_2 == NULL)\n\t    VAR_2 = VAR_1;\n#ifdef VAR_45\n\tif (VAR_2 != NULL)\n\t    fname_case(VAR_2, 0);   /* COMMENT_10 */\n#endif\n\n\tif ((VAR_5 & (VAR_46 | VAR_47))\n\t\t\t\t\t && (VAR_1 == NULL || *VAR_1 == VAR_48))\n\t    goto theend;\n\n\tif (VAR_1 == NULL)\n\t    VAR_7 = TRUE;\n\t\t\t\t\t    /* COMMENT_11 */\n\telse if (*VAR_1 == VAR_48 && VAR_38->b_ffname == NULL)\n\t    VAR_7 = FALSE;\n\telse\n\t{\n\t    if (*VAR_1 == VAR_48)\t\t    /* COMMENT_12 */\n\t    {\n\t\tVAR_1 = VAR_38->b_ffname;\n\t\tVAR_2 = VAR_38->b_fname;\n\t    }\n\t    VAR_16 = fix_fname(VAR_1); /* COMMENT_13 */\n\t    if (VAR_16 != NULL)\n\t\tVAR_1 = VAR_16;\n\t    VAR_7 = otherfile(VAR_1);\n\t}\n    }\n\n    /* COMMENT_14 */\n                                                                   \n                                                 \n                                                                            \n       \n    if (  ((!VAR_7 && !(VAR_5 & VAR_49))\n\t    || (VAR_38->b_nwindows == 1\n\t\t&& !(VAR_5 & (VAR_50 | VAR_46 | VAR_47))))\n\t&& check_changed(VAR_38, (VAR_51 ? VAR_52 : 0)\n\t\t\t       | (VAR_7 ? 0 : VAR_53)\n\t\t\t       | ((VAR_5 & VAR_54) ? VAR_55 : 0)\n\t\t\t       | (VAR_3 == NULL ? 0 : VAR_56)))\n    {\n\tif (VAR_0 == 0 && VAR_7 && VAR_1 != NULL)\n\t    (void)setaltfname(VAR_1, VAR_2, VAR_4 < 0 ? 0 : VAR_4);\n\tgoto theend;\n    }\n\n    /* COMMENT_19 */\n                                                                             \n                                            \n       \n    reset_VIsual();\n\n#if defined(VAR_11)\n    if ((VAR_28 != NULL || VAR_4 > (linenr_T)0)\n\t    && *get_vim_var_str(VAR_57) == VAR_48)\n    {\n\tint\tVAR_58;\n\tchar_u\t*VAR_59;\n\n\t/* COMMENT_23 */\n\tif (VAR_28 != NULL)\n\t    VAR_58 = (int)STRLEN(VAR_28) + 3;\n\telse\n\t    VAR_58 = 30;\n\tVAR_59 = alloc(VAR_58);\n\tif (VAR_59 != NULL)\n\t{\n\t    if (VAR_28 != NULL)\n\t\tvim_snprintf((char *)VAR_59, VAR_58, \":%s\\r\", VAR_28);\n\t    else\n\t\tvim_snprintf((char *)VAR_59, VAR_58, \"%ldG\", (long)VAR_4);\n\t    set_vim_var_string(VAR_57, VAR_59, -1);\n\t    VAR_12 = TRUE;\n\t    vim_free(VAR_59);\n\t}\n    }\n#endif\n\n    /* COMMENT_24 */\n                                                                    \n                                              \n       \n    if (VAR_7)\n    {\n\tif (!(VAR_5 & (VAR_46 | VAR_47)))\n\t{\n\t    if ((VAR_40.cmod_flags & VAR_60) == 0)\n\t\tVAR_34->w_alt_fnum = VAR_38->b_fnum;\n\t    if (VAR_6 != NULL)\n\t\tbuflist_altfpos(VAR_6);\n\t}\n\n\tif (VAR_0)\n\t    VAR_13 = buflist_findnr(VAR_0);\n\telse\n\t{\n\t    if (VAR_5 & (VAR_46 | VAR_47))\n\t    {\n\t\t/* COMMENT_28 */\n\t\t/* COMMENT_29 */\n\t\tlinenr_T\tVAR_61 = 0;\n\t\tbuf_T\t\t*VAR_62;\n\n\t\tif (VAR_28 != NULL)\n\t\t{\n\t\t    VAR_61 = atol((char *)VAR_28);\n\t\t    if (VAR_61 <= 0)\n\t\t\tVAR_61 = 1L;\n\t\t}\n\t\t/* COMMENT_30 */\n\t\t/* COMMENT_31 */\n\t\tVAR_62 = buflist_new(VAR_1, VAR_2, VAR_61,\n\t\t\t\t\t\t    VAR_63 | VAR_64);\n\t\tif (VAR_62 != NULL && (VAR_5 & VAR_47))\n\t\t    VAR_34->w_alt_fnum = VAR_62->b_fnum;\n\t\tgoto theend;\n\t    }\n\t    VAR_13 = buflist_new(VAR_1, VAR_2, 0L,\n\t\t    VAR_65 | ((VAR_5 & VAR_66) ? 0 : VAR_63));\n\n\t    /* COMMENT_32 */\n\t    if (VAR_6 != NULL)\n\t\tVAR_6 = VAR_34;\n\t    set_bufref(&VAR_15, VAR_38);\n\t}\n\tif (VAR_13 == NULL)\n\t    goto theend;\n\tif (VAR_13->b_ml.ml_mfp == NULL)\t\t/* COMMENT_33 */\n\t{\n\t    VAR_8 = FALSE;\n\t}\n\telse\t\t\t\t\t/* COMMENT_34 */\n\t{\n\t    VAR_8 = TRUE;\n\t    set_bufref(&VAR_14, VAR_13);\n\t    (void)buf_check_timestamp(VAR_13, FALSE);\n\t    /* COMMENT_35 */\n\t    /* COMMENT_36 */\n\t    if (!bufref_valid(&VAR_14) || VAR_38 != VAR_15.br_buf)\n\t\tgoto theend;\n#ifdef VAR_11\n\t    if (aborting())\t    /* COMMENT_37 */\n\t\tgoto theend;\n#endif\n\t}\n\n\t/* COMMENT_38 */\n\t/* COMMENT_39 */\n\tif ((VAR_8 && VAR_4 == VAR_67) || VAR_4 == VAR_68)\n\t{\n\t    VAR_27 = buflist_findfpos(VAR_13);\n\t    VAR_4 = VAR_27->lnum;\n\t    VAR_26 = VAR_27->col;\n\t}\n\n\t/* COMMENT_40 */\n                                                             \n                                                                    \n                                                                \n                                                     \n    \n\tif (VAR_13 != VAR_38)\n\t{\n\t    /* COMMENT_46 */\n                                                                     \n                           \n                                                                 \n                                                                  \n                                                                \n                                                                 \n                                                                      \n                              \n        \n\t    if (VAR_13->b_fname != NULL)\n\t\tVAR_10 = vim_strsave(VAR_13->b_fname);\n\t    set_bufref(&VAR_69, VAR_13);\n\t    apply_autocmds(VAR_70, NULL, NULL, FALSE, VAR_38);\n\t    if (!bufref_valid(&VAR_69))\n\t    {\n\t\t/* COMMENT_56 */\n\t\tdelbuf_msg(VAR_10);\t/* COMMENT_57 */\n\t\tgoto theend;\n\t    }\n#ifdef VAR_11\n\t    if (aborting())\t    /* COMMENT_37 */\n\t    {\n\t\tvim_free(VAR_10);\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (VAR_13 == VAR_38)\t\t/* COMMENT_58 */\n\t\tVAR_9 = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *VAR_71 = VAR_34;\n\t\tint\t    VAR_72;\n\t\tbuf_T\t    *VAR_73 = VAR_38;\n\n\t\t/* COMMENT_59 */\n\t\t/* COMMENT_60 */\n\t\tVAR_71->w_closing = TRUE;\n\t\t++VAR_13->b_locked;\n\n\t\tif (VAR_38 == VAR_15.br_buf)\n\t\t    buf_copy_options(VAR_13, VAR_74);\n\n\t\t/* COMMENT_61 */\n\t\t/* COMMENT_62 */\n\t\tu_sync(FALSE);\n\t\tVAR_72 = close_buffer(VAR_6, VAR_38,\n\t\t\t (VAR_5 & VAR_50) ? 0 : VAR_75, FALSE, FALSE);\n\n\t\tVAR_71->w_closing = FALSE;\n\t\t--VAR_13->b_locked;\n\n#ifdef VAR_11\n\t\t/* COMMENT_37 */\n\t\tif (aborting() && VAR_34->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(VAR_10);\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t/* COMMENT_63 */\n\t\tif (!bufref_valid(&VAR_69))\n\t\t{\n\t\t    /* COMMENT_56 */\n\t\t    delbuf_msg(VAR_10);\t/* COMMENT_57 */\n\t\t    goto theend;\n\t\t}\n\t\tif (VAR_13 == VAR_38)\t\t/* COMMENT_58 */\n\t\t{\n\t\t    /* COMMENT_64 */\n\t\t    /* COMMENT_65 */\n\t\t    if (VAR_72 && buf_valid(VAR_73))\n\t\t\t++VAR_73->b_nwindows;\n\t\t    if (win_valid_any_tab(VAR_6) && VAR_6->w_buffer == NULL)\n\t\t\tVAR_6->w_buffer = VAR_73;\n\t\t    VAR_9 = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef VAR_76\n\t\t    /* COMMENT_66 */\n                                                \n                                          \n         \n\t\t    if (VAR_34->w_buffer == NULL\n\t\t\t    || VAR_34->w_s == &(VAR_34->w_buffer->b_s))\n\t\t\tVAR_34->w_s = &(VAR_13->b_s);\n#endif\n\t\t    VAR_34->w_buffer = VAR_13;\n\t\t    VAR_38 = VAR_13;\n\t\t    ++VAR_38->b_nwindows;\n\n\t\t    /* COMMENT_70 */\n\t\t    if (!VAR_8 && VAR_3 != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, VAR_3);\n\t\t\tset_forced_fenc(VAR_3);\n\t\t    }\n\t\t}\n\n\t\t/* COMMENT_71 */\n\t\t/* COMMENT_72 */\n\t\t/* COMMENT_73 */\n\t\t/* COMMENT_74 */\n\t\tget_winopts(VAR_38);\n#ifdef VAR_29\n\t\tVAR_30 = TRUE;\n#endif\n\t    }\n\t    vim_free(VAR_10);\n\t    VAR_69.br_buf = NULL;\n\t    VAR_69.br_buf_free_count = 0;\n\t}\n\n\tVAR_34->w_pcmark.lnum = 1;\n\tVAR_34->w_pcmark.col = 0;\n    }\n    else /* COMMENT_75 */\n    {\n\tif ((VAR_5 & (VAR_46 | VAR_47)) || check_fname() == VAR_21)\n\t    goto theend;\n\n\tVAR_8 = (VAR_5 & VAR_49);\n    }\n\n    /* COMMENT_76 */\n    /* COMMENT_77 */\n    ++VAR_77;\n    VAR_32 = TRUE;\n\n    VAR_13 = VAR_38;\n    if ((VAR_5 & VAR_66) || VAR_78)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t/* COMMENT_78 */\n\t/* COMMENT_79 */\n\tif (!VAR_38->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    /* COMMENT_80 */\n    /* COMMENT_81 */\n    if (VAR_13 != VAR_38)\n\tgoto theend;\n#ifdef VAR_11\n    if (aborting())\t    /* COMMENT_37 */\n\tgoto theend;\n#endif\n\n    /* COMMENT_82 */\n    /* COMMENT_83 */\n    /* COMMENT_84 */\n    VAR_79 = FALSE;\n\n/* COMMENT_85 */\n                    \n                                                        \n                                                     \n                                                     \n                                                                  \n   \n    if (!VAR_7 && !VAR_8)\t\t/* COMMENT_92 */\n    {\n\tset_last_cursor(VAR_34);\t/* COMMENT_93 */\n\tif (VAR_4 == VAR_68 || VAR_4 == VAR_67)\n\t{\n\t    VAR_4 = VAR_34->w_cursor.lnum;\n\t    VAR_26 = VAR_34->w_cursor.col;\n\t}\n\tVAR_13 = VAR_38;\n\tif (VAR_13->b_fname != NULL)\n\t    VAR_10 = vim_strsave(VAR_13->b_fname);\n\telse\n\t    VAR_10 = NULL;\n\tset_bufref(&VAR_14, VAR_13);\n\n\t/* COMMENT_94 */\n\t/* COMMENT_95 */\n\t/* COMMENT_96 */\n\tif (!(VAR_38->b_flags & VAR_80)\n\t\t&& (VAR_81 < 0 || VAR_38->b_ml.ml_line_count <= VAR_81))\n\t{\n\t    /* COMMENT_97 */\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, VAR_38->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == VAR_21)\n\t    {\n\t\tvim_free(VAR_10);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(VAR_38);\n\t    buf_freeall(VAR_38, VAR_82);\n\n\t    /* COMMENT_98 */\n\t    VAR_31 = VAR_83;\n\t}\n\telse\n\t    buf_freeall(VAR_38, 0);   /* COMMENT_99 */\n\n\t/* COMMENT_100 */\n\t/* COMMENT_101 */\n\tif (!bufref_valid(&VAR_14))\n\t{\n\t    delbuf_msg(VAR_10);\t/* COMMENT_57 */\n\t    goto theend;\n\t}\n\tvim_free(VAR_10);\n\n\t/* COMMENT_80 */\n\t/* COMMENT_102 */\n\t/* COMMENT_103 */\n\tif (VAR_13 != VAR_38)\n\t    goto theend;\n#ifdef VAR_11\n\tif (aborting())\t    /* COMMENT_37 */\n\t    goto theend;\n#endif\n\tbuf_clear_file(VAR_38);\n\tVAR_38->b_op_start.lnum = 0;\t/* COMMENT_104 */\n\tVAR_38->b_op_end.lnum = 0;\n    }\n\n/* COMMENT_105 */\n                                              \n   \n    /* COMMENT_108 */\n    VAR_20 = VAR_39;\n\n    /* COMMENT_109 */\n                                                                       \n       \n    check_arg_idx(VAR_34);\n\n    if (!VAR_9)\n    {\n\t/* COMMENT_112 */\n                                                                    \n                                                                   \n           \n    \n\tcurwin_init();\n\n#ifdef VAR_84\n\t/* COMMENT_117 */\n\t/* COMMENT_118 */\n\t{\n\t    win_T\t    *VAR_85;\n\t    tabpage_T\t    *VAR_86;\n\n\t    FOR_ALL_TAB_WINDOWS(VAR_86, VAR_85)\n\t\tif (VAR_85->w_buffer == VAR_38)\n\t\t    foldUpdateAll(VAR_85);\n\t}\n#endif\n\n\t/* COMMENT_119 */\n\tVAR_87;\n\n\t/* COMMENT_120 */\n                                                                      \n                      \n    \n\tVAR_23 = VAR_34->w_cursor;\n\tVAR_24 = VAR_34->w_topline;\n\tif (!VAR_8)\t\t\t    /* COMMENT_124 */\n\t{\n#ifdef VAR_36\n\t    /* COMMENT_125 */\n\t    /* COMMENT_126 */\n\t    if (WIN_IS_POPUP(VAR_34))\n\t\tVAR_38->b_flags |= VAR_88;\n#endif\n\t    VAR_89 = VAR_90;\n\t    VAR_38->b_flags |= VAR_91; /* COMMENT_127 */\n\n\t    /* COMMENT_128 */\n                                          \n        \n#if defined(VAR_11)\n\t    if (should_abort(open_buffer(FALSE, VAR_3, VAR_31)))\n\t\tVAR_20 = VAR_21;\n#else\n\t    (void)open_buffer(FALSE, VAR_3, VAR_31);\n#endif\n\n#ifdef VAR_36\n\t    VAR_38->b_flags &= ~VAR_88;\n#endif\n\t    if (VAR_89 == VAR_92)\n\t\tVAR_20 = VAR_21;\n\t    handle_swap_exists(&VAR_15);\n\t}\n\telse\n\t{\n\t    /* COMMENT_131 */\n\t    /* COMMENT_132 */\n\t    /* COMMENT_133 */\n\t    do_modelines(VAR_93);\n\n\t    apply_autocmds_retval(VAR_94, NULL, NULL, FALSE, VAR_38,\n\t\t\t\t\t\t\t\t    &VAR_20);\n\t    apply_autocmds_retval(VAR_95, NULL, NULL, FALSE, VAR_38,\n\t\t\t\t\t\t\t\t    &VAR_20);\n\t}\n\tcheck_arg_idx(VAR_34);\n\n\t/* COMMENT_134 */\n\t/* COMMENT_135 */\n\t/* COMMENT_136 */\n\tif (!EQUAL_POS(VAR_34->w_cursor, VAR_23))\n\t{\n\t    char_u *VAR_96 = ml_get_curline();\n\n\t    if (VAR_34->w_cursor.lnum != VAR_23.lnum\n\t\t    || VAR_34->w_cursor.col != (int)(skipwhite(VAR_96) - VAR_96))\n\t    {\n\t\tVAR_4 = VAR_34->w_cursor.lnum;\n\t\tVAR_25 = VAR_34->w_cursor.col;\n\t    }\n\t}\n\tif (VAR_34->w_topline == VAR_24)\n\t    VAR_24 = 0;\n\n\t/* COMMENT_137 */\n\tchanged_line_abv_curs();\n\n#ifdef VAR_97\n\tmaketitle();\n#endif\n#if defined(VAR_36) && defined(VAR_98)\n\tif (WIN_IS_POPUP(VAR_34) && VAR_34->w_p_pvw && VAR_20 != VAR_21)\n\t    popup_set_title(VAR_34);\n#endif\n    }\n\n#ifdef VAR_99\n    /* COMMENT_138 */\n    /* COMMENT_139 */\n    /* COMMENT_140 */\n    if (VAR_34->w_p_diff)\n    {\n\tdiff_buf_add(VAR_38);\n\tdiff_invalidate(VAR_38);\n    }\n#endif\n\n#ifdef VAR_29\n    /* COMMENT_141 */\n    /* COMMENT_142 */\n    if (VAR_30 && VAR_34->w_p_spell && *VAR_34->w_s->b_p_spl != VAR_48)\n\t(void)did_set_spelllang(VAR_34);\n#endif\n\n    if (VAR_28 == NULL)\n    {\n\tif (VAR_25 >= 0)\t/* COMMENT_143 */\n\t{\n\t    VAR_34->w_cursor.lnum = VAR_4;\n\t    VAR_34->w_cursor.col = VAR_25;\n\t    check_cursor();\n\t}\n\telse if (VAR_4 > 0)\t/* COMMENT_144 */\n\t{\n\t    VAR_34->w_cursor.lnum = VAR_4;\n\t    check_cursor_lnum();\n\t    if (VAR_26 >= 0 && !VAR_100)\n\t    {\n\t\t/* COMMENT_145 */\n\t\tVAR_34->w_cursor.col = VAR_26;\n\t\tcheck_cursor_col();\n\t\tVAR_34->w_cursor.coladd = 0;\n\t\tVAR_34->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(VAR_101 | VAR_102);\n\t}\n\telse\t\t\t/* COMMENT_146 */\n\t{\n\t    if (VAR_103)\n\t\tVAR_34->w_cursor.lnum = VAR_38->b_ml.ml_line_count;\n\t    beginline(VAR_104 | VAR_102);\n\t}\n    }\n\n    /* COMMENT_147 */\n    check_lnums(FALSE);\n\n    /* COMMENT_148 */\n                                                                    \n                                        \n       \n    if (VAR_8 && !VAR_9)\n    {\n\tint\tVAR_105 = VAR_106;\n\n\t/* COMMENT_152 */\n\t/* COMMENT_153 */\n\tif (shortmess(VAR_107) && !VAR_42 && VAR_108 == 0)\n\t    VAR_106 = FALSE;\n\tif (!VAR_106)\t/* COMMENT_154 */\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tVAR_106 = VAR_105;\n\tVAR_109 = TRUE;\n\n\tif (!shortmess(VAR_110))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tVAR_109 = FALSE;\n    }\n\n#ifdef VAR_111\n    VAR_38->b_last_used = vim_time();\n#endif\n\n    if (VAR_28 != NULL)\n\tdo_cmdline(VAR_28, NULL, NULL, VAR_112|VAR_113);\n\n#ifdef VAR_114\n    if (VAR_38->b_kmap_state & VAR_115)\n\t(void)keymap_init();\n#endif\n\n    --VAR_77;\n    VAR_32 = FALSE;\n    if (!VAR_116)\n    {\n\tVAR_22 = *VAR_33;\n\tif (VAR_24 == 0 && VAR_28 == NULL)\n\t    *VAR_33 = 9999;\t\t/* COMMENT_155 */\n\tupdate_topline();\n\tVAR_34->w_scbind_pos = VAR_34->w_topline;\n\t*VAR_33 = VAR_22;\n\tredraw_curbuf_later(VAR_117);\t/* COMMENT_156 */\n    }\n\n    if (VAR_118)\n\tVAR_119 = TRUE;\n\n#ifdef VAR_120\n    /* COMMENT_157 */\n    /* COMMENT_158 */\n    /* COMMENT_159 */\n    if (VAR_121 && VAR_38->b_ffname != NULL)\n    {\n\tchar_u\tVAR_122[VAR_123];\n\tchar_u\tVAR_124[VAR_123];\n\n\tvim_strncpy(VAR_124, VAR_38->b_ffname, VAR_123 - 1);\n\t*gettail_sep(VAR_124) = VAR_48;\n\tif (mch_dirname(VAR_122, VAR_123) != VAR_21\n\t\t&& vim_fnamecmp(VAR_122, VAR_124) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(VAR_125)\n    if (VAR_38->b_ffname != NULL)\n    {\n# ifdef VAR_125\n\tif ((VAR_5 & VAR_66) != VAR_66)\n\t    netbeans_file_opened(VAR_38);\n# endif\n    }\n#endif\n\ntheend:\n    if (VAR_32)\n\t--VAR_77;\n#if defined(VAR_11)\n    if (VAR_12)\n\tset_vim_var_string(VAR_57, NULL, -1);\n#endif\n#ifdef VAR_17\n    vim_free(VAR_19);\n#endif\n    vim_free(VAR_16);\n    return VAR_20;\n}",
    "func_graph_path": "vim/797e63b9f2baa1853e7063aac478d663cd02f207/ex_cmds.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -278,6 +278,8 @@\n \t    else\n \t    {\n \t\twin_T\t    *the_curwin = curwin;\n+\t\tint\t    did_decrement;\n+\t\tbuf_T\t    *was_curbuf = curbuf;\n \n \t\t// Set the w_closing flag to avoid that autocommands close the\n \t\t// window.  And set b_locked for the same reason.\n@@ -290,7 +292,7 @@\n \t\t// Close the link to the current buffer. This will set\n \t\t// oldwin->w_buffer to NULL.\n \t\tu_sync(FALSE);\n-\t\tclose_buffer(oldwin, curbuf,\n+\t\tdid_decrement = close_buffer(oldwin, curbuf,\n \t\t\t (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);\n \n \t\tthe_curwin->w_closing = FALSE;\n@@ -312,7 +314,15 @@\n \t\t    goto theend;\n \t\t}\n \t\tif (buf == curbuf)\t\t// already in new buffer\n+\t\t{\n+\t\t    // close_buffer() has decremented the window count,\n+\t\t    // increment it again here and restore w_buffer.\n+\t\t    if (did_decrement && buf_valid(was_curbuf))\n+\t\t\t++was_curbuf->b_nwindows;\n+\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)\n+\t\t\toldwin->w_buffer = was_curbuf;\n \t\t    auto_buf = TRUE;\n+\t\t}\n \t\telse\n \t\t{\n #ifdef FEAT_SYN_HL",
    "diff_line_info": {
        "deleted_lines": [
            "\t\tclose_buffer(oldwin, curbuf,"
        ],
        "added_lines": [
            "\t\tint\t    did_decrement;",
            "\t\tbuf_T\t    *was_curbuf = curbuf;",
            "\t\tdid_decrement = close_buffer(oldwin, curbuf,",
            "\t\t{",
            "\t\t    // close_buffer() has decremented the window count,",
            "\t\t    // increment it again here and restore w_buffer.",
            "\t\t    if (did_decrement && buf_valid(was_curbuf))",
            "\t\t\t++was_curbuf->b_nwindows;",
            "\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)",
            "\t\t\toldwin->w_buffer = was_curbuf;",
            "\t\t}"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}