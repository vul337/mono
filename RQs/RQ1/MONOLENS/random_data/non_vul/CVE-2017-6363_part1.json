{
    "cve_id": "CVE-2017-6363",
    "cwe_ids": [
        "CWE-125"
    ],
    "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "libgd",
    "commit_msg": "Fix #383 (amendment)\n\nWhen reading images in GD or GD2 format, we have to ensure that the\ntransparent color is not set, if it would refer to a non-extant palette\nentry.\n\nWe back that up with respective regression tests.",
    "commit_hash": "2dbd8f6e66b73ed43d9b81a45350922b80f75397",
    "git_url": "https://github.com/libgd/libgd/commit/2dbd8f6e66b73ed43d9b81a45350922b80f75397",
    "file_path": "src/gd_gd.c",
    "func_name": "_gdGetColors",
    "func_before": "int\n_gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag)\n{\n\tint i;\n\tif (gd2xFlag) {\n\t\tint trueColorFlag;\n\t\tif (!gdGetByte (&trueColorFlag, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* 2.0.12: detect bad truecolor .gd files created by pre-2.0.12.\n\t\t   Beginning in 2.0.12 truecolor is indicated by the initial 2-byte\n\t\t   signature. */\n\t\tif (trueColorFlag != im->trueColor) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* This should have been a word all along */\n\t\tif (!im->trueColor) {\n\t\t\tif (!gdGetWord (&im->colorsTotal, in)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (im->colorsTotal > gdMaxColors) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* Int to accommodate truecolor single-color transparency */\n\t\tif (!gdGetInt (&im->transparent, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t} else {\n\t\tif (!gdGetByte (&im->colorsTotal, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetWord (&im->transparent, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* Make sure transparent index is within bounds of the palette. */\n\t\tif (im->transparent >= 256 || im->transparent < 0) {\n\t\t\tim->transparent = (-1);\n\t\t}\n\t}\n\tGD2_DBG (printf\n\t         (\"Palette had %d colours (T=%d)\\n\", im->colorsTotal,\n\t          im->transparent));\n\tif (im->trueColor) {\n\t\treturn TRUE;\n\t}\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tif (!gdGetByte (&im->red[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&im->green[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&im->blue[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (gd2xFlag) {\n\t\t\tif (!gdGetByte (&im->alpha[i], in)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; (i < im->colorsTotal); i++) {\n\t\tim->open[i] = 0;\n\t};\n\n\treturn TRUE;\nfail1:\n\treturn FALSE;\n}",
    "abstract_func_before": "int\n_gdGetColors (gdIOCtx * VAR_0, gdImagePtr VAR_1, int VAR_2)\n{\n\tint VAR_3;\n\tif (VAR_2) {\n\t\tint VAR_4;\n\t\tif (!gdGetByte (&VAR_4, VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* COMMENT_0 */\n                                                                     \n                  \n\t\tif (VAR_4 != VAR_1->trueColor) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tif (!VAR_1->trueColor) {\n\t\t\tif (!gdGetWord (&VAR_1->colorsTotal, VAR_0)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (VAR_1->colorsTotal > VAR_5) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* COMMENT_4 */\n\t\tif (!gdGetInt (&VAR_1->transparent, VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t} else {\n\t\tif (!gdGetByte (&VAR_1->colorsTotal, VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetWord (&VAR_1->transparent, VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* COMMENT_5 */\n\t\tif (VAR_1->transparent >= 256 || VAR_1->transparent < 0) {\n\t\t\tVAR_1->transparent = (-1);\n\t\t}\n\t}\n\tGD2_DBG (printf\n\t         (\"Palette had %d colours (T=%d)\\n\", VAR_1->colorsTotal,\n\t          VAR_1->transparent));\n\tif (VAR_1->trueColor) {\n\t\treturn TRUE;\n\t}\n\tfor (VAR_3 = 0; (VAR_3 < VAR_5); VAR_3++) {\n\t\tif (!gdGetByte (&VAR_1->red[VAR_3], VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&VAR_1->green[VAR_3], VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&VAR_1->blue[VAR_3], VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (VAR_2) {\n\t\t\tif (!gdGetByte (&VAR_1->alpha[VAR_3], VAR_0)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (VAR_3 = 0; (VAR_3 < VAR_1->colorsTotal); VAR_3++) {\n\t\tVAR_1->open[VAR_3] = 0;\n\t};\n\n\treturn TRUE;\nfail1:\n\treturn FALSE;\n}",
    "func_graph_path_before": "libgd/2dbd8f6e66b73ed43d9b81a45350922b80f75397/gd_gd.c/vul/before/0.json",
    "func": "int\n_gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag)\n{\n\tint i;\n\tif (gd2xFlag) {\n\t\tint trueColorFlag;\n\t\tif (!gdGetByte (&trueColorFlag, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* 2.0.12: detect bad truecolor .gd files created by pre-2.0.12.\n\t\t   Beginning in 2.0.12 truecolor is indicated by the initial 2-byte\n\t\t   signature. */\n\t\tif (trueColorFlag != im->trueColor) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* This should have been a word all along */\n\t\tif (!im->trueColor) {\n\t\t\tif (!gdGetWord (&im->colorsTotal, in)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (im->colorsTotal > gdMaxColors) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* Int to accommodate truecolor single-color transparency */\n\t\tif (!gdGetInt (&im->transparent, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t} else {\n\t\tif (!gdGetByte (&im->colorsTotal, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetWord (&im->transparent, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\t/* Make sure transparent index is within bounds of the palette. */\n\tif (!(im->trueColor) && (im->transparent >= im->colorsTotal || im->transparent < 0)) {\n\t\tim->transparent = (-1);\n\t}\n\tGD2_DBG (printf\n\t         (\"Palette had %d colours (T=%d)\\n\", im->colorsTotal,\n\t          im->transparent));\n\tif (im->trueColor) {\n\t\treturn TRUE;\n\t}\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tif (!gdGetByte (&im->red[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&im->green[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&im->blue[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (gd2xFlag) {\n\t\t\tif (!gdGetByte (&im->alpha[i], in)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; (i < im->colorsTotal); i++) {\n\t\tim->open[i] = 0;\n\t};\n\n\treturn TRUE;\nfail1:\n\treturn FALSE;\n}",
    "abstract_func": "int\n_gdGetColors (gdIOCtx * VAR_0, gdImagePtr VAR_1, int VAR_2)\n{\n\tint VAR_3;\n\tif (VAR_2) {\n\t\tint VAR_4;\n\t\tif (!gdGetByte (&VAR_4, VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* COMMENT_0 */\n                                                                     \n                  \n\t\tif (VAR_4 != VAR_1->trueColor) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tif (!VAR_1->trueColor) {\n\t\t\tif (!gdGetWord (&VAR_1->colorsTotal, VAR_0)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (VAR_1->colorsTotal > VAR_5) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* COMMENT_4 */\n\t\tif (!gdGetInt (&VAR_1->transparent, VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t} else {\n\t\tif (!gdGetByte (&VAR_1->colorsTotal, VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetWord (&VAR_1->transparent, VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\t/* COMMENT_5 */\n\tif (!(VAR_1->trueColor) && (VAR_1->transparent >= VAR_1->colorsTotal || VAR_1->transparent < 0)) {\n\t\tVAR_1->transparent = (-1);\n\t}\n\tGD2_DBG (printf\n\t         (\"Palette had %d colours (T=%d)\\n\", VAR_1->colorsTotal,\n\t          VAR_1->transparent));\n\tif (VAR_1->trueColor) {\n\t\treturn TRUE;\n\t}\n\tfor (VAR_3 = 0; (VAR_3 < VAR_5); VAR_3++) {\n\t\tif (!gdGetByte (&VAR_1->red[VAR_3], VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&VAR_1->green[VAR_3], VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&VAR_1->blue[VAR_3], VAR_0)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (VAR_2) {\n\t\t\tif (!gdGetByte (&VAR_1->alpha[VAR_3], VAR_0)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (VAR_3 = 0; (VAR_3 < VAR_1->colorsTotal); VAR_3++) {\n\t\tVAR_1->open[VAR_3] = 0;\n\t};\n\n\treturn TRUE;\nfail1:\n\treturn FALSE;\n}",
    "func_graph_path": "libgd/2dbd8f6e66b73ed43d9b81a45350922b80f75397/gd_gd.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -33,10 +33,10 @@\n \t\tif (!gdGetWord (&im->transparent, in)) {\n \t\t\tgoto fail1;\n \t\t}\n-\t\t/* Make sure transparent index is within bounds of the palette. */\n-\t\tif (im->transparent >= 256 || im->transparent < 0) {\n-\t\t\tim->transparent = (-1);\n-\t\t}\n+\t}\n+\t/* Make sure transparent index is within bounds of the palette. */\n+\tif (!(im->trueColor) && (im->transparent >= im->colorsTotal || im->transparent < 0)) {\n+\t\tim->transparent = (-1);\n \t}\n \tGD2_DBG (printf\n \t         (\"Palette had %d colours (T=%d)\\n\", im->colorsTotal,",
    "diff_line_info": {
        "deleted_lines": [
            "\t\t/* Make sure transparent index is within bounds of the palette. */",
            "\t\tif (im->transparent >= 256 || im->transparent < 0) {",
            "\t\t\tim->transparent = (-1);",
            "\t\t}"
        ],
        "added_lines": [
            "\t}",
            "\t/* Make sure transparent index is within bounds of the palette. */",
            "\tif (!(im->trueColor) && (im->transparent >= im->colorsTotal || im->transparent < 0)) {",
            "\t\tim->transparent = (-1);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}