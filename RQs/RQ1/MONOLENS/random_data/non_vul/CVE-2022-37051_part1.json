{
    "cve_id": "CVE-2022-37051",
    "cwe_ids": [
        "CWE-617"
    ],
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "poppler",
    "commit_msg": "Issue #1276\n",
    "commit_hash": "4631115647c1e4f0482ffe0491c2f38d2231337b",
    "git_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=4631115647c1e4f0482ffe0491c2f38d2231337b",
    "file_path": "utils/pdfunite.cc",
    "func_name": "main",
    "func_before": "int main(int argc, char *argv[])\n///////////////////////////////////////////////////////////////////////////\n// Merge PDF files given by arguments 1 to argc-2 and write the result\n// to the file specified by argument argc-1.\n///////////////////////////////////////////////////////////////////////////\n{\n    int objectsCount = 0;\n    unsigned int numOffset = 0;\n    std::vector<Object> pages;\n    std::vector<unsigned int> offsets;\n    XRef *yRef, *countRef;\n    FILE *f;\n    OutStream *outStr;\n    int i;\n    int j, rootNum;\n    std::vector<PDFDoc *> docs;\n    int majorVersion = 0;\n    int minorVersion = 0;\n    char *fileName = argv[argc - 1];\n\n    const bool ok = parseArgs(argDesc, &argc, argv);\n    if (!ok || argc < 3 || printVersion || printHelp) {\n        fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n        fprintf(stderr, \"%s\\n\", popplerCopyright);\n        fprintf(stderr, \"%s\\n\", xpdfCopyright);\n        if (!printVersion) {\n            printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\", argDesc);\n        }\n        if (printVersion || printHelp) {\n            return 0;\n        }\n        return 99;\n    }\n    globalParams = std::make_unique<GlobalParams>();\n\n    for (i = 1; i < argc - 1; i++) {\n        PDFDoc *doc = new PDFDoc(std::make_unique<GooString>(argv[i]));\n        if (doc->isOk() && !doc->isEncrypted() && doc->getXRef()->getCatalog().isDict()) {\n            docs.push_back(doc);\n            if (doc->getPDFMajorVersion() > majorVersion) {\n                majorVersion = doc->getPDFMajorVersion();\n                minorVersion = doc->getPDFMinorVersion();\n            } else if (doc->getPDFMajorVersion() == majorVersion) {\n                if (doc->getPDFMinorVersion() > minorVersion) {\n                    minorVersion = doc->getPDFMinorVersion();\n                }\n            }\n        } else if (doc->isOk()) {\n            if (doc->isEncrypted()) {\n                error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n                return -1;\n            } else if (!doc->getXRef()->getCatalog().isDict()) {\n                error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary ('{0:s}')\", argv[i]);\n                return -1;\n            }\n        } else {\n            error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n            return -1;\n        }\n    }\n\n    if (!(f = fopen(fileName, \"wb\"))) {\n        error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n        return -1;\n    }\n    outStr = new FileOutStream(f, 0);\n\n    yRef = new XRef();\n    countRef = new XRef();\n    yRef->add(0, 65535, 0, false);\n    PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n    // handle OutputIntents, AcroForm, OCProperties & Names\n    Object intents;\n    Object names;\n    Object afObj;\n    Object ocObj;\n    if (docs.size() >= 1) {\n        Object catObj = docs[0]->getXRef()->getCatalog();\n        Dict *catDict = catObj.getDict();\n        intents = catDict->lookup(\"OutputIntents\");\n        afObj = catDict->lookupNF(\"AcroForm\").copy();\n        Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n        if (!afObj.isNull() && refPage) {\n            docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        ocObj = catDict->lookupNF(\"OCProperties\").copy();\n        if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n            docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        names = catDict->lookup(\"Names\");\n        if (!names.isNull() && names.isDict() && refPage) {\n            docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        if (intents.isArray() && intents.arrayGetLength() > 0) {\n            for (i = 1; i < (int)docs.size(); i++) {\n                Object pagecatObj = docs[i]->getXRef()->getCatalog();\n                Dict *pagecatDict = pagecatObj.getDict();\n                Object pageintents = pagecatDict->lookup(\"OutputIntents\");\n                if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n                    for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n                        Object intent = intents.arrayGet(j, 0);\n                        if (intent.isDict()) {\n                            Object idf = intent.dictLookup(\"OutputConditionIdentifier\");\n                            if (idf.isString()) {\n                                const GooString *gidf = idf.getString();\n                                bool removeIntent = true;\n                                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                                    Object pgintent = pageintents.arrayGet(k, 0);\n                                    if (pgintent.isDict()) {\n                                        Object pgidf = pgintent.dictLookup(\"OutputConditionIdentifier\");\n                                        if (pgidf.isString()) {\n                                            const GooString *gpgidf = pgidf.getString();\n                                            if (gpgidf->cmp(gidf) == 0) {\n                                                removeIntent = false;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                                if (removeIntent) {\n                                    intents.arrayRemove(j);\n                                    error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\", gidf->c_str(), docs[i]->getFileName()->c_str());\n                                }\n                            } else {\n                                intents.arrayRemove(j);\n                                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n                            }\n                        } else {\n                            intents.arrayRemove(j);\n                        }\n                    }\n                } else {\n                    error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n                    break;\n                }\n            }\n        }\n        if (intents.isArray() && intents.arrayGetLength() > 0) {\n            for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n                Object intent = intents.arrayGet(j, 0);\n                if (intent.isDict()) {\n                    docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n                } else {\n                    intents.arrayRemove(j);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < (int)docs.size(); i++) {\n        for (j = 1; j <= docs[i]->getNumPages(); j++) {\n            if (!docs[i]->getCatalog()->getPage(j)) {\n                continue;\n            }\n\n            const PDFRectangle *cropBox = nullptr;\n            if (docs[i]->getCatalog()->getPage(j)->isCropped()) {\n                cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n            }\n            docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox);\n            Ref *refPage = docs[i]->getCatalog()->getPageRef(j);\n            Object page = docs[i]->getXRef()->fetch(*refPage);\n            Dict *pageDict = page.getDict();\n            Object *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDictObject();\n            if (resDict->isDict()) {\n                pageDict->set(\"Resources\", resDict->copy());\n            }\n            pages.push_back(std::move(page));\n            offsets.push_back(numOffset);\n            docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n            Object annotsObj = pageDict->lookupNF(\"Annots\").copy();\n            if (!annotsObj.isNull()) {\n                docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n            }\n        }\n        Object pageCatObj = docs[i]->getXRef()->getCatalog();\n        Dict *pageCatDict = pageCatObj.getDict();\n        Object pageNames = pageCatDict->lookup(\"Names\");\n        if (!pageNames.isNull() && pageNames.isDict()) {\n            if (!names.isDict()) {\n                names = Object(new Dict(yRef));\n            }\n            doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n        }\n        Object pageForm = pageCatDict->lookup(\"AcroForm\");\n        if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n            if (afObj.isNull()) {\n                afObj = pageCatDict->lookupNF(\"AcroForm\").copy();\n            } else if (afObj.isDict()) {\n                doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n            }\n        }\n        objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, true);\n        numOffset = yRef->getNumObjects() + 1;\n    }\n\n    rootNum = yRef->getNumObjects() + 1;\n    yRef->add(rootNum, 0, outStr->getPos(), true);\n    outStr->printf(\"%d 0 obj\\n\", rootNum);\n    outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n    // insert OutputIntents\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n        outStr->printf(\" /OutputIntents [\");\n        for (j = 0; j < intents.arrayGetLength(); j++) {\n            Object intent = intents.arrayGet(j, 0);\n            if (intent.isDict()) {\n                PDFDoc::writeObject(&intent, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n            }\n        }\n        outStr->printf(\"]\");\n    }\n    // insert AcroForm\n    if (!afObj.isNull()) {\n        outStr->printf(\" /AcroForm \");\n        PDFDoc::writeObject(&afObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    // insert OCProperties\n    if (!ocObj.isNull() && ocObj.isDict()) {\n        outStr->printf(\" /OCProperties \");\n        PDFDoc::writeObject(&ocObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    // insert Names\n    if (!names.isNull() && names.isDict()) {\n        outStr->printf(\" /Names \");\n        PDFDoc::writeObject(&names, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    outStr->printf(\">>\\nendobj\\n\");\n    objectsCount++;\n\n    yRef->add(rootNum + 1, 0, outStr->getPos(), true);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n    outStr->printf(\"<< /Type /Pages /Kids [\");\n    for (j = 0; j < (int)pages.size(); j++) {\n        outStr->printf(\" %d 0 R\", rootNum + j + 2);\n    }\n    outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n    objectsCount++;\n\n    for (i = 0; i < (int)pages.size(); i++) {\n        yRef->add(rootNum + i + 2, 0, outStr->getPos(), true);\n        outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n        outStr->printf(\"<< \");\n        Dict *pageDict = pages[i].getDict();\n        for (j = 0; j < pageDict->getLength(); j++) {\n            if (j > 0) {\n                outStr->printf(\" \");\n            }\n            const char *key = pageDict->getKey(j);\n            Object value = pageDict->getValNF(j).copy();\n            if (strcmp(key, \"Parent\") == 0) {\n                outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n            } else {\n                outStr->printf(\"/%s \", key);\n                PDFDoc::writeObject(&value, outStr, yRef, offsets[i], nullptr, cryptRC4, 0, 0, 0);\n            }\n        }\n        outStr->printf(\" >>\\nendobj\\n\");\n        objectsCount++;\n    }\n    Goffset uxrefOffset = outStr->getPos();\n    Ref ref;\n    ref.num = rootNum;\n    ref.gen = 0;\n    Object trailerDict = PDFDoc::createTrailerDict(objectsCount, false, 0, &ref, yRef, fileName, outStr->getPos());\n    PDFDoc::writeXRefTableTrailer(std::move(trailerDict), yRef, true, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall\n                                                                      // contain only one subsection, whose object numbering begins at 0.\"\n                                  uxrefOffset, outStr, yRef);\n\n    outStr->close();\n    delete outStr;\n    fclose(f);\n    delete yRef;\n    delete countRef;\n    for (i = 0; i < (int)docs.size(); i++) {\n        delete docs[i];\n    }\n    return 0;\n}",
    "abstract_func_before": "int main(int VAR_0, char *VAR_1[])\n/* COMMENT_0 */\n/* COMMENT_1 */\n/* COMMENT_2 */\n/* COMMENT_0 */\n{\n    int VAR_2 = 0;\n    unsigned int VAR_3 = 0;\n    std::vector<Object> VAR_4;\n    std::vector<unsigned int> VAR_5;\n    XRef *VAR_6, *VAR_7;\n    FILE *VAR_8;\n    OutStream *VAR_9;\n    int VAR_10;\n    int VAR_11, VAR_12;\n    std::vector<PDFDoc *> VAR_13;\n    int VAR_14 = 0;\n    int VAR_15 = 0;\n    char *VAR_16 = VAR_1[VAR_0 - 1];\n\n    const bool VAR_17 = parseArgs(VAR_18, &VAR_0, VAR_1);\n    if (!VAR_17 || VAR_0 < 3 || VAR_19 || VAR_20) {\n        fprintf(VAR_21, \"pdfunite version %s\\n\", VAR_22);\n        fprintf(VAR_21, \"%s\\n\", VAR_23);\n        fprintf(VAR_21, \"%s\\n\", VAR_24);\n        if (!VAR_19) {\n            printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\", VAR_18);\n        }\n        if (VAR_19 || VAR_20) {\n            return 0;\n        }\n        return 99;\n    }\n    VAR_25 = std::VAR_26<GlobalParams>();\n\n    for (VAR_10 = 1; VAR_10 < VAR_0 - 1; VAR_10++) {\n        PDFDoc *VAR_27 = new PDFDoc(std::VAR_26<GooString>(VAR_1[VAR_10]));\n        if (VAR_27->isOk() && !VAR_27->isEncrypted() && VAR_27->getXRef()->getCatalog().isDict()) {\n            VAR_13.push_back(VAR_27);\n            if (VAR_27->getPDFMajorVersion() > VAR_14) {\n                VAR_14 = VAR_27->getPDFMajorVersion();\n                VAR_15 = VAR_27->getPDFMinorVersion();\n            } else if (VAR_27->getPDFMajorVersion() == VAR_14) {\n                if (VAR_27->getPDFMinorVersion() > VAR_15) {\n                    VAR_15 = VAR_27->getPDFMinorVersion();\n                }\n            }\n        } else if (VAR_27->isOk()) {\n            if (VAR_27->isEncrypted()) {\n                error(VAR_28, -1, \"Could not merge encrypted files ('{0:s}')\", VAR_1[VAR_10]);\n                return -1;\n            } else if (!VAR_27->getXRef()->getCatalog().isDict()) {\n                error(VAR_29, -1, \"XRef's Catalog is not a dictionary ('{0:s}')\", VAR_1[VAR_10]);\n                return -1;\n            }\n        } else {\n            error(VAR_29, -1, \"Could not merge damaged documents ('{0:s}')\", VAR_1[VAR_10]);\n            return -1;\n        }\n    }\n\n    if (!(VAR_8 = fopen(VAR_16, \"wb\"))) {\n        error(VAR_30, -1, \"Could not open file '{0:s}'\", VAR_16);\n        return -1;\n    }\n    VAR_9 = new FileOutStream(VAR_8, 0);\n\n    VAR_6 = new XRef();\n    VAR_7 = new XRef();\n    VAR_6->add(0, 65535, 0, false);\n    PDFDoc::writeHeader(VAR_9, VAR_14, VAR_15);\n\n    /* COMMENT_3 */\n    Object VAR_31;\n    Object VAR_32;\n    Object VAR_33;\n    Object VAR_34;\n    if (VAR_13.size() >= 1) {\n        Object VAR_35 = VAR_13[0]->getXRef()->getCatalog();\n        Dict *VAR_36 = VAR_35.getDict();\n        VAR_31 = VAR_36->lookup(\"OutputIntents\");\n        VAR_33 = VAR_36->lookupNF(\"AcroForm\").copy();\n        Ref *VAR_37 = VAR_13[0]->getCatalog()->getPageRef(1);\n        if (!VAR_33.isNull() && VAR_37) {\n            VAR_13[0]->markAcroForm(&VAR_33, VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);\n        }\n        VAR_34 = VAR_36->lookupNF(\"OCProperties\").copy();\n        if (!VAR_34.isNull() && VAR_34.isDict() && VAR_37) {\n            VAR_13[0]->markPageObjects(VAR_34.getDict(), VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);\n        }\n        VAR_32 = VAR_36->lookup(\"Names\");\n        if (!VAR_32.isNull() && VAR_32.isDict() && VAR_37) {\n            VAR_13[0]->markPageObjects(VAR_32.getDict(), VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);\n        }\n        if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {\n            for (VAR_10 = 1; VAR_10 < (int)VAR_13.size(); VAR_10++) {\n                Object VAR_38 = VAR_13[VAR_10]->getXRef()->getCatalog();\n                Dict *VAR_39 = VAR_38.getDict();\n                Object VAR_40 = VAR_39->lookup(\"OutputIntents\");\n                if (VAR_40.isArray() && VAR_40.arrayGetLength() > 0) {\n                    for (VAR_11 = VAR_31.arrayGetLength() - 1; VAR_11 >= 0; VAR_11--) {\n                        Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);\n                        if (VAR_41.isDict()) {\n                            Object VAR_42 = VAR_41.dictLookup(\"OutputConditionIdentifier\");\n                            if (VAR_42.isString()) {\n                                const GooString *VAR_43 = VAR_42.getString();\n                                bool VAR_44 = true;\n                                for (int VAR_45 = 0; VAR_45 < VAR_40.arrayGetLength(); VAR_45++) {\n                                    Object VAR_46 = VAR_40.arrayGet(VAR_45, 0);\n                                    if (VAR_46.isDict()) {\n                                        Object VAR_47 = VAR_46.dictLookup(\"OutputConditionIdentifier\");\n                                        if (VAR_47.isString()) {\n                                            const GooString *VAR_48 = VAR_47.getString();\n                                            if (VAR_48->cmp(VAR_43) == 0) {\n                                                VAR_44 = false;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                                if (VAR_44) {\n                                    VAR_31.arrayRemove(VAR_11);\n                                    error(VAR_49, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\", VAR_43->c_str(), VAR_13[VAR_10]->getFileName()->c_str());\n                                }\n                            } else {\n                                VAR_31.arrayRemove(VAR_11);\n                                error(VAR_49, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n                            }\n                        } else {\n                            VAR_31.arrayRemove(VAR_11);\n                        }\n                    }\n                } else {\n                    error(VAR_49, -1, \"Output intents differs, remove them all\");\n                    break;\n                }\n            }\n        }\n        if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {\n            for (VAR_11 = VAR_31.arrayGetLength() - 1; VAR_11 >= 0; VAR_11--) {\n                Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);\n                if (VAR_41.isDict()) {\n                    VAR_13[0]->markPageObjects(VAR_41.getDict(), VAR_6, VAR_7, VAR_3, 0, 0);\n                } else {\n                    VAR_31.arrayRemove(VAR_11);\n                }\n            }\n        }\n    }\n\n    for (VAR_10 = 0; VAR_10 < (int)VAR_13.size(); VAR_10++) {\n        for (VAR_11 = 1; VAR_11 <= VAR_13[VAR_10]->getNumPages(); VAR_11++) {\n            if (!VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)) {\n                continue;\n            }\n\n            const PDFRectangle *VAR_50 = nullptr;\n            if (VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->isCropped()) {\n                VAR_50 = VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getCropBox();\n            }\n            VAR_13[VAR_10]->replacePageDict(VAR_11, VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getRotate(), VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getMediaBox(), VAR_50);\n            Ref *VAR_37 = VAR_13[VAR_10]->getCatalog()->getPageRef(VAR_11);\n            Object VAR_51 = VAR_13[VAR_10]->getXRef()->fetch(*VAR_37);\n            Dict *VAR_52 = VAR_51.getDict();\n            Object *VAR_53 = VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getResourceDictObject();\n            if (VAR_53->isDict()) {\n                VAR_52->set(\"Resources\", VAR_53->copy());\n            }\n            VAR_4.push_back(std::move(VAR_51));\n            VAR_5.push_back(VAR_3);\n            VAR_13[VAR_10]->markPageObjects(VAR_52, VAR_6, VAR_7, VAR_3, VAR_37->num, VAR_37->num);\n            Object VAR_54 = VAR_52->lookupNF(\"Annots\").copy();\n            if (!VAR_54.isNull()) {\n                VAR_13[VAR_10]->markAnnotations(&VAR_54, VAR_6, VAR_7, VAR_3, VAR_37->num, VAR_37->num);\n            }\n        }\n        Object VAR_55 = VAR_13[VAR_10]->getXRef()->getCatalog();\n        Dict *VAR_56 = VAR_55.getDict();\n        Object VAR_57 = VAR_56->lookup(\"Names\");\n        if (!VAR_57.isNull() && VAR_57.isDict()) {\n            if (!VAR_32.isDict()) {\n                VAR_32 = Object(new Dict(VAR_6));\n            }\n            doMergeNameDict(VAR_13[VAR_10], VAR_6, VAR_7, 0, 0, VAR_32.getDict(), VAR_57.getDict(), VAR_3);\n        }\n        Object VAR_58 = VAR_56->lookup(\"AcroForm\");\n        if (VAR_10 > 0 && !VAR_58.isNull() && VAR_58.isDict()) {\n            if (VAR_33.isNull()) {\n                VAR_33 = VAR_56->lookupNF(\"AcroForm\").copy();\n            } else if (VAR_33.isDict()) {\n                doMergeFormDict(VAR_33.getDict(), VAR_58.getDict(), VAR_3);\n            }\n        }\n        VAR_2 += VAR_13[VAR_10]->writePageObjects(VAR_9, VAR_6, VAR_3, true);\n        VAR_3 = VAR_6->getNumObjects() + 1;\n    }\n\n    VAR_12 = VAR_6->getNumObjects() + 1;\n    VAR_6->add(VAR_12, 0, VAR_9->getPos(), true);\n    VAR_9->printf(\"%d 0 obj\\n\", VAR_12);\n    VAR_9->printf(\"<< /Type /Catalog /Pages %d 0 R\", VAR_12 + 1);\n    /* COMMENT_4 */\n    if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {\n        VAR_9->printf(\" /OutputIntents [\");\n        for (VAR_11 = 0; VAR_11 < VAR_31.arrayGetLength(); VAR_11++) {\n            Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);\n            if (VAR_41.isDict()) {\n                PDFDoc::writeObject(&VAR_41, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);\n            }\n        }\n        VAR_9->printf(\"]\");\n    }\n    /* COMMENT_5 */\n    if (!VAR_33.isNull()) {\n        VAR_9->printf(\" /AcroForm \");\n        PDFDoc::writeObject(&VAR_33, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);\n    }\n    /* COMMENT_6 */\n    if (!VAR_34.isNull() && VAR_34.isDict()) {\n        VAR_9->printf(\" /OCProperties \");\n        PDFDoc::writeObject(&VAR_34, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);\n    }\n    /* COMMENT_7 */\n    if (!VAR_32.isNull() && VAR_32.isDict()) {\n        VAR_9->printf(\" /Names \");\n        PDFDoc::writeObject(&VAR_32, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);\n    }\n    VAR_9->printf(\">>\\nendobj\\n\");\n    VAR_2++;\n\n    VAR_6->add(VAR_12 + 1, 0, VAR_9->getPos(), true);\n    VAR_9->printf(\"%d 0 obj\\n\", VAR_12 + 1);\n    VAR_9->printf(\"<< /Type /Pages /Kids [\");\n    for (VAR_11 = 0; VAR_11 < (int)VAR_4.size(); VAR_11++) {\n        VAR_9->printf(\" %d 0 R\", VAR_12 + VAR_11 + 2);\n    }\n    VAR_9->printf(\" ] /Count %zd >>\\nendobj\\n\", VAR_4.size());\n    VAR_2++;\n\n    for (VAR_10 = 0; VAR_10 < (int)VAR_4.size(); VAR_10++) {\n        VAR_6->add(VAR_12 + VAR_10 + 2, 0, VAR_9->getPos(), true);\n        VAR_9->printf(\"%d 0 obj\\n\", VAR_12 + VAR_10 + 2);\n        VAR_9->printf(\"<< \");\n        Dict *VAR_52 = VAR_4[VAR_10].getDict();\n        for (VAR_11 = 0; VAR_11 < VAR_52->getLength(); VAR_11++) {\n            if (VAR_11 > 0) {\n                VAR_9->printf(\" \");\n            }\n            const char *VAR_60 = VAR_52->getKey(VAR_11);\n            Object VAR_61 = VAR_52->getValNF(VAR_11).copy();\n            if (strcmp(VAR_60, \"Parent\") == 0) {\n                VAR_9->printf(\"/Parent %d 0 R\", VAR_12 + 1);\n            } else {\n                VAR_9->printf(\"/%s \", VAR_60);\n                PDFDoc::writeObject(&VAR_61, VAR_9, VAR_6, VAR_5[VAR_10], nullptr, VAR_59, 0, 0, 0);\n            }\n        }\n        VAR_9->printf(\" >>\\nendobj\\n\");\n        VAR_2++;\n    }\n    Goffset VAR_62 = VAR_9->getPos();\n    Ref VAR_63;\n    VAR_63.num = VAR_12;\n    VAR_63.gen = 0;\n    Object VAR_64 = PDFDoc::createTrailerDict(VAR_2, false, 0, &VAR_63, VAR_6, VAR_16, VAR_9->getPos());\n    PDFDoc::writeXRefTableTrailer(std::move(VAR_64), VAR_6, true, /* COMMENT_8 */\n                                                                      /* COMMENT_9 */\n                                  VAR_62, VAR_9, VAR_6);\n\n    VAR_9->close();\n    delete VAR_9;\n    fclose(VAR_8);\n    delete VAR_6;\n    delete VAR_7;\n    for (VAR_10 = 0; VAR_10 < (int)VAR_13.size(); VAR_10++) {\n        delete VAR_13[VAR_10];\n    }\n    return 0;\n}",
    "func_graph_path_before": "poppler/4631115647c1e4f0482ffe0491c2f38d2231337b/pdfunite.cc/vul/before/0.json",
    "func": "int main(int argc, char *argv[])\n///////////////////////////////////////////////////////////////////////////\n// Merge PDF files given by arguments 1 to argc-2 and write the result\n// to the file specified by argument argc-1.\n///////////////////////////////////////////////////////////////////////////\n{\n    int objectsCount = 0;\n    unsigned int numOffset = 0;\n    std::vector<Object> pages;\n    std::vector<unsigned int> offsets;\n    XRef *yRef, *countRef;\n    FILE *f;\n    OutStream *outStr;\n    int i;\n    int j, rootNum;\n    std::vector<PDFDoc *> docs;\n    int majorVersion = 0;\n    int minorVersion = 0;\n    char *fileName = argv[argc - 1];\n\n    const bool ok = parseArgs(argDesc, &argc, argv);\n    if (!ok || argc < 3 || printVersion || printHelp) {\n        fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n        fprintf(stderr, \"%s\\n\", popplerCopyright);\n        fprintf(stderr, \"%s\\n\", xpdfCopyright);\n        if (!printVersion) {\n            printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\", argDesc);\n        }\n        if (printVersion || printHelp) {\n            return 0;\n        }\n        return 99;\n    }\n    globalParams = std::make_unique<GlobalParams>();\n\n    for (i = 1; i < argc - 1; i++) {\n        PDFDoc *doc = new PDFDoc(std::make_unique<GooString>(argv[i]));\n        if (doc->isOk() && !doc->isEncrypted() && doc->getXRef()->getCatalog().isDict()) {\n            docs.push_back(doc);\n            if (doc->getPDFMajorVersion() > majorVersion) {\n                majorVersion = doc->getPDFMajorVersion();\n                minorVersion = doc->getPDFMinorVersion();\n            } else if (doc->getPDFMajorVersion() == majorVersion) {\n                if (doc->getPDFMinorVersion() > minorVersion) {\n                    minorVersion = doc->getPDFMinorVersion();\n                }\n            }\n        } else if (doc->isOk()) {\n            if (doc->isEncrypted()) {\n                error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n                return -1;\n            } else if (!doc->getXRef()->getCatalog().isDict()) {\n                error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary ('{0:s}')\", argv[i]);\n                return -1;\n            }\n        } else {\n            error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n            return -1;\n        }\n    }\n\n    if (!(f = fopen(fileName, \"wb\"))) {\n        error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n        return -1;\n    }\n    outStr = new FileOutStream(f, 0);\n\n    yRef = new XRef();\n    countRef = new XRef();\n    yRef->add(0, 65535, 0, false);\n    PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n    // handle OutputIntents, AcroForm, OCProperties & Names\n    Object intents;\n    Object names;\n    Object afObj;\n    Object ocObj;\n    if (docs.size() >= 1) {\n        Object catObj = docs[0]->getXRef()->getCatalog();\n        if(!catObj.isDict()){\n            fclose(f);\n            delete yRef;\n            delete countRef;\n            delete outStr;\n            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");\n            return -1;\n        }\n        Dict *catDict = catObj.getDict();\n        intents = catDict->lookup(\"OutputIntents\");\n        afObj = catDict->lookupNF(\"AcroForm\").copy();\n        Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n        if (!afObj.isNull() && refPage) {\n            docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        ocObj = catDict->lookupNF(\"OCProperties\").copy();\n        if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n            docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        names = catDict->lookup(\"Names\");\n        if (!names.isNull() && names.isDict() && refPage) {\n            docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        if (intents.isArray() && intents.arrayGetLength() > 0) {\n            for (i = 1; i < (int)docs.size(); i++) {\n                Object pagecatObj = docs[i]->getXRef()->getCatalog();\n                Dict *pagecatDict = pagecatObj.getDict();\n                Object pageintents = pagecatDict->lookup(\"OutputIntents\");\n                if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n                    for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n                        Object intent = intents.arrayGet(j, 0);\n                        if (intent.isDict()) {\n                            Object idf = intent.dictLookup(\"OutputConditionIdentifier\");\n                            if (idf.isString()) {\n                                const GooString *gidf = idf.getString();\n                                bool removeIntent = true;\n                                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                                    Object pgintent = pageintents.arrayGet(k, 0);\n                                    if (pgintent.isDict()) {\n                                        Object pgidf = pgintent.dictLookup(\"OutputConditionIdentifier\");\n                                        if (pgidf.isString()) {\n                                            const GooString *gpgidf = pgidf.getString();\n                                            if (gpgidf->cmp(gidf) == 0) {\n                                                removeIntent = false;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                                if (removeIntent) {\n                                    intents.arrayRemove(j);\n                                    error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\", gidf->c_str(), docs[i]->getFileName()->c_str());\n                                }\n                            } else {\n                                intents.arrayRemove(j);\n                                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n                            }\n                        } else {\n                            intents.arrayRemove(j);\n                        }\n                    }\n                } else {\n                    error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n                    break;\n                }\n            }\n        }\n        if (intents.isArray() && intents.arrayGetLength() > 0) {\n            for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n                Object intent = intents.arrayGet(j, 0);\n                if (intent.isDict()) {\n                    docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n                } else {\n                    intents.arrayRemove(j);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < (int)docs.size(); i++) {\n        for (j = 1; j <= docs[i]->getNumPages(); j++) {\n            if (!docs[i]->getCatalog()->getPage(j)) {\n                continue;\n            }\n\n            const PDFRectangle *cropBox = nullptr;\n            if (docs[i]->getCatalog()->getPage(j)->isCropped()) {\n                cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n            }\n            docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox);\n            Ref *refPage = docs[i]->getCatalog()->getPageRef(j);\n            Object page = docs[i]->getXRef()->fetch(*refPage);\n            Dict *pageDict = page.getDict();\n            Object *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDictObject();\n            if (resDict->isDict()) {\n                pageDict->set(\"Resources\", resDict->copy());\n            }\n            pages.push_back(std::move(page));\n            offsets.push_back(numOffset);\n            docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n            Object annotsObj = pageDict->lookupNF(\"Annots\").copy();\n            if (!annotsObj.isNull()) {\n                docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n            }\n        }\n        Object pageCatObj = docs[i]->getXRef()->getCatalog();\n        if(!pageCatObj.isDict()){\n            fclose(f);\n            delete yRef;\n            delete countRef;\n            delete outStr;\n            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");\n            return -1;\n        }\n        Dict *pageCatDict = pageCatObj.getDict();\n        Object pageNames = pageCatDict->lookup(\"Names\");\n        if (!pageNames.isNull() && pageNames.isDict()) {\n            if (!names.isDict()) {\n                names = Object(new Dict(yRef));\n            }\n            doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n        }\n        Object pageForm = pageCatDict->lookup(\"AcroForm\");\n        if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n            if (afObj.isNull()) {\n                afObj = pageCatDict->lookupNF(\"AcroForm\").copy();\n            } else if (afObj.isDict()) {\n                doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n            }\n        }\n        objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, true);\n        numOffset = yRef->getNumObjects() + 1;\n    }\n\n    rootNum = yRef->getNumObjects() + 1;\n    yRef->add(rootNum, 0, outStr->getPos(), true);\n    outStr->printf(\"%d 0 obj\\n\", rootNum);\n    outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n    // insert OutputIntents\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n        outStr->printf(\" /OutputIntents [\");\n        for (j = 0; j < intents.arrayGetLength(); j++) {\n            Object intent = intents.arrayGet(j, 0);\n            if (intent.isDict()) {\n                PDFDoc::writeObject(&intent, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n            }\n        }\n        outStr->printf(\"]\");\n    }\n    // insert AcroForm\n    if (!afObj.isNull()) {\n        outStr->printf(\" /AcroForm \");\n        PDFDoc::writeObject(&afObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    // insert OCProperties\n    if (!ocObj.isNull() && ocObj.isDict()) {\n        outStr->printf(\" /OCProperties \");\n        PDFDoc::writeObject(&ocObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    // insert Names\n    if (!names.isNull() && names.isDict()) {\n        outStr->printf(\" /Names \");\n        PDFDoc::writeObject(&names, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    outStr->printf(\">>\\nendobj\\n\");\n    objectsCount++;\n\n    yRef->add(rootNum + 1, 0, outStr->getPos(), true);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n    outStr->printf(\"<< /Type /Pages /Kids [\");\n    for (j = 0; j < (int)pages.size(); j++) {\n        outStr->printf(\" %d 0 R\", rootNum + j + 2);\n    }\n    outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n    objectsCount++;\n\n    for (i = 0; i < (int)pages.size(); i++) {\n        yRef->add(rootNum + i + 2, 0, outStr->getPos(), true);\n        outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n        outStr->printf(\"<< \");\n        Dict *pageDict = pages[i].getDict();\n        for (j = 0; j < pageDict->getLength(); j++) {\n            if (j > 0) {\n                outStr->printf(\" \");\n            }\n            const char *key = pageDict->getKey(j);\n            Object value = pageDict->getValNF(j).copy();\n            if (strcmp(key, \"Parent\") == 0) {\n                outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n            } else {\n                outStr->printf(\"/%s \", key);\n                PDFDoc::writeObject(&value, outStr, yRef, offsets[i], nullptr, cryptRC4, 0, 0, 0);\n            }\n        }\n        outStr->printf(\" >>\\nendobj\\n\");\n        objectsCount++;\n    }\n    Goffset uxrefOffset = outStr->getPos();\n    Ref ref;\n    ref.num = rootNum;\n    ref.gen = 0;\n    Object trailerDict = PDFDoc::createTrailerDict(objectsCount, false, 0, &ref, yRef, fileName, outStr->getPos());\n    PDFDoc::writeXRefTableTrailer(std::move(trailerDict), yRef, true, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall\n                                                                      // contain only one subsection, whose object numbering begins at 0.\"\n                                  uxrefOffset, outStr, yRef);\n\n    outStr->close();\n    delete outStr;\n    fclose(f);\n    delete yRef;\n    delete countRef;\n    for (i = 0; i < (int)docs.size(); i++) {\n        delete docs[i];\n    }\n    return 0;\n}",
    "abstract_func": "int main(int VAR_0, char *VAR_1[])\n/* COMMENT_0 */\n/* COMMENT_1 */\n/* COMMENT_2 */\n/* COMMENT_0 */\n{\n    int VAR_2 = 0;\n    unsigned int VAR_3 = 0;\n    std::vector<Object> VAR_4;\n    std::vector<unsigned int> VAR_5;\n    XRef *VAR_6, *VAR_7;\n    FILE *VAR_8;\n    OutStream *VAR_9;\n    int VAR_10;\n    int VAR_11, VAR_12;\n    std::vector<PDFDoc *> VAR_13;\n    int VAR_14 = 0;\n    int VAR_15 = 0;\n    char *VAR_16 = VAR_1[VAR_0 - 1];\n\n    const bool VAR_17 = parseArgs(VAR_18, &VAR_0, VAR_1);\n    if (!VAR_17 || VAR_0 < 3 || VAR_19 || VAR_20) {\n        fprintf(VAR_21, \"pdfunite version %s\\n\", VAR_22);\n        fprintf(VAR_21, \"%s\\n\", VAR_23);\n        fprintf(VAR_21, \"%s\\n\", VAR_24);\n        if (!VAR_19) {\n            printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\", VAR_18);\n        }\n        if (VAR_19 || VAR_20) {\n            return 0;\n        }\n        return 99;\n    }\n    VAR_25 = std::VAR_26<GlobalParams>();\n\n    for (VAR_10 = 1; VAR_10 < VAR_0 - 1; VAR_10++) {\n        PDFDoc *VAR_27 = new PDFDoc(std::VAR_26<GooString>(VAR_1[VAR_10]));\n        if (VAR_27->isOk() && !VAR_27->isEncrypted() && VAR_27->getXRef()->getCatalog().isDict()) {\n            VAR_13.push_back(VAR_27);\n            if (VAR_27->getPDFMajorVersion() > VAR_14) {\n                VAR_14 = VAR_27->getPDFMajorVersion();\n                VAR_15 = VAR_27->getPDFMinorVersion();\n            } else if (VAR_27->getPDFMajorVersion() == VAR_14) {\n                if (VAR_27->getPDFMinorVersion() > VAR_15) {\n                    VAR_15 = VAR_27->getPDFMinorVersion();\n                }\n            }\n        } else if (VAR_27->isOk()) {\n            if (VAR_27->isEncrypted()) {\n                error(VAR_28, -1, \"Could not merge encrypted files ('{0:s}')\", VAR_1[VAR_10]);\n                return -1;\n            } else if (!VAR_27->getXRef()->getCatalog().isDict()) {\n                error(VAR_29, -1, \"XRef's Catalog is not a dictionary ('{0:s}')\", VAR_1[VAR_10]);\n                return -1;\n            }\n        } else {\n            error(VAR_29, -1, \"Could not merge damaged documents ('{0:s}')\", VAR_1[VAR_10]);\n            return -1;\n        }\n    }\n\n    if (!(VAR_8 = fopen(VAR_16, \"wb\"))) {\n        error(VAR_30, -1, \"Could not open file '{0:s}'\", VAR_16);\n        return -1;\n    }\n    VAR_9 = new FileOutStream(VAR_8, 0);\n\n    VAR_6 = new XRef();\n    VAR_7 = new XRef();\n    VAR_6->add(0, 65535, 0, false);\n    PDFDoc::writeHeader(VAR_9, VAR_14, VAR_15);\n\n    /* COMMENT_3 */\n    Object VAR_31;\n    Object VAR_32;\n    Object VAR_33;\n    Object VAR_34;\n    if (VAR_13.size() >= 1) {\n        Object VAR_35 = VAR_13[0]->getXRef()->getCatalog();\n        if(!VAR_35.isDict()){\n            fclose(VAR_8);\n            delete VAR_6;\n            delete VAR_7;\n            delete VAR_9;\n            error(VAR_29, -1, \"XRef's Catalog is not a dictionary.\");\n            return -1;\n        }\n        Dict *VAR_36 = VAR_35.getDict();\n        VAR_31 = VAR_36->lookup(\"OutputIntents\");\n        VAR_33 = VAR_36->lookupNF(\"AcroForm\").copy();\n        Ref *VAR_37 = VAR_13[0]->getCatalog()->getPageRef(1);\n        if (!VAR_33.isNull() && VAR_37) {\n            VAR_13[0]->markAcroForm(&VAR_33, VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);\n        }\n        VAR_34 = VAR_36->lookupNF(\"OCProperties\").copy();\n        if (!VAR_34.isNull() && VAR_34.isDict() && VAR_37) {\n            VAR_13[0]->markPageObjects(VAR_34.getDict(), VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);\n        }\n        VAR_32 = VAR_36->lookup(\"Names\");\n        if (!VAR_32.isNull() && VAR_32.isDict() && VAR_37) {\n            VAR_13[0]->markPageObjects(VAR_32.getDict(), VAR_6, VAR_7, 0, VAR_37->num, VAR_37->num);\n        }\n        if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {\n            for (VAR_10 = 1; VAR_10 < (int)VAR_13.size(); VAR_10++) {\n                Object VAR_38 = VAR_13[VAR_10]->getXRef()->getCatalog();\n                Dict *VAR_39 = VAR_38.getDict();\n                Object VAR_40 = VAR_39->lookup(\"OutputIntents\");\n                if (VAR_40.isArray() && VAR_40.arrayGetLength() > 0) {\n                    for (VAR_11 = VAR_31.arrayGetLength() - 1; VAR_11 >= 0; VAR_11--) {\n                        Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);\n                        if (VAR_41.isDict()) {\n                            Object VAR_42 = VAR_41.dictLookup(\"OutputConditionIdentifier\");\n                            if (VAR_42.isString()) {\n                                const GooString *VAR_43 = VAR_42.getString();\n                                bool VAR_44 = true;\n                                for (int VAR_45 = 0; VAR_45 < VAR_40.arrayGetLength(); VAR_45++) {\n                                    Object VAR_46 = VAR_40.arrayGet(VAR_45, 0);\n                                    if (VAR_46.isDict()) {\n                                        Object VAR_47 = VAR_46.dictLookup(\"OutputConditionIdentifier\");\n                                        if (VAR_47.isString()) {\n                                            const GooString *VAR_48 = VAR_47.getString();\n                                            if (VAR_48->cmp(VAR_43) == 0) {\n                                                VAR_44 = false;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                                if (VAR_44) {\n                                    VAR_31.arrayRemove(VAR_11);\n                                    error(VAR_49, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\", VAR_43->c_str(), VAR_13[VAR_10]->getFileName()->c_str());\n                                }\n                            } else {\n                                VAR_31.arrayRemove(VAR_11);\n                                error(VAR_49, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n                            }\n                        } else {\n                            VAR_31.arrayRemove(VAR_11);\n                        }\n                    }\n                } else {\n                    error(VAR_49, -1, \"Output intents differs, remove them all\");\n                    break;\n                }\n            }\n        }\n        if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {\n            for (VAR_11 = VAR_31.arrayGetLength() - 1; VAR_11 >= 0; VAR_11--) {\n                Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);\n                if (VAR_41.isDict()) {\n                    VAR_13[0]->markPageObjects(VAR_41.getDict(), VAR_6, VAR_7, VAR_3, 0, 0);\n                } else {\n                    VAR_31.arrayRemove(VAR_11);\n                }\n            }\n        }\n    }\n\n    for (VAR_10 = 0; VAR_10 < (int)VAR_13.size(); VAR_10++) {\n        for (VAR_11 = 1; VAR_11 <= VAR_13[VAR_10]->getNumPages(); VAR_11++) {\n            if (!VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)) {\n                continue;\n            }\n\n            const PDFRectangle *VAR_50 = nullptr;\n            if (VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->isCropped()) {\n                VAR_50 = VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getCropBox();\n            }\n            VAR_13[VAR_10]->replacePageDict(VAR_11, VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getRotate(), VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getMediaBox(), VAR_50);\n            Ref *VAR_37 = VAR_13[VAR_10]->getCatalog()->getPageRef(VAR_11);\n            Object VAR_51 = VAR_13[VAR_10]->getXRef()->fetch(*VAR_37);\n            Dict *VAR_52 = VAR_51.getDict();\n            Object *VAR_53 = VAR_13[VAR_10]->getCatalog()->getPage(VAR_11)->getResourceDictObject();\n            if (VAR_53->isDict()) {\n                VAR_52->set(\"Resources\", VAR_53->copy());\n            }\n            VAR_4.push_back(std::move(VAR_51));\n            VAR_5.push_back(VAR_3);\n            VAR_13[VAR_10]->markPageObjects(VAR_52, VAR_6, VAR_7, VAR_3, VAR_37->num, VAR_37->num);\n            Object VAR_54 = VAR_52->lookupNF(\"Annots\").copy();\n            if (!VAR_54.isNull()) {\n                VAR_13[VAR_10]->markAnnotations(&VAR_54, VAR_6, VAR_7, VAR_3, VAR_37->num, VAR_37->num);\n            }\n        }\n        Object VAR_55 = VAR_13[VAR_10]->getXRef()->getCatalog();\n        if(!VAR_55.isDict()){\n            fclose(VAR_8);\n            delete VAR_6;\n            delete VAR_7;\n            delete VAR_9;\n            error(VAR_29, -1, \"XRef's Catalog is not a dictionary.\");\n            return -1;\n        }\n        Dict *VAR_56 = VAR_55.getDict();\n        Object VAR_57 = VAR_56->lookup(\"Names\");\n        if (!VAR_57.isNull() && VAR_57.isDict()) {\n            if (!VAR_32.isDict()) {\n                VAR_32 = Object(new Dict(VAR_6));\n            }\n            doMergeNameDict(VAR_13[VAR_10], VAR_6, VAR_7, 0, 0, VAR_32.getDict(), VAR_57.getDict(), VAR_3);\n        }\n        Object VAR_58 = VAR_56->lookup(\"AcroForm\");\n        if (VAR_10 > 0 && !VAR_58.isNull() && VAR_58.isDict()) {\n            if (VAR_33.isNull()) {\n                VAR_33 = VAR_56->lookupNF(\"AcroForm\").copy();\n            } else if (VAR_33.isDict()) {\n                doMergeFormDict(VAR_33.getDict(), VAR_58.getDict(), VAR_3);\n            }\n        }\n        VAR_2 += VAR_13[VAR_10]->writePageObjects(VAR_9, VAR_6, VAR_3, true);\n        VAR_3 = VAR_6->getNumObjects() + 1;\n    }\n\n    VAR_12 = VAR_6->getNumObjects() + 1;\n    VAR_6->add(VAR_12, 0, VAR_9->getPos(), true);\n    VAR_9->printf(\"%d 0 obj\\n\", VAR_12);\n    VAR_9->printf(\"<< /Type /Catalog /Pages %d 0 R\", VAR_12 + 1);\n    /* COMMENT_4 */\n    if (VAR_31.isArray() && VAR_31.arrayGetLength() > 0) {\n        VAR_9->printf(\" /OutputIntents [\");\n        for (VAR_11 = 0; VAR_11 < VAR_31.arrayGetLength(); VAR_11++) {\n            Object VAR_41 = VAR_31.arrayGet(VAR_11, 0);\n            if (VAR_41.isDict()) {\n                PDFDoc::writeObject(&VAR_41, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);\n            }\n        }\n        VAR_9->printf(\"]\");\n    }\n    /* COMMENT_5 */\n    if (!VAR_33.isNull()) {\n        VAR_9->printf(\" /AcroForm \");\n        PDFDoc::writeObject(&VAR_33, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);\n    }\n    /* COMMENT_6 */\n    if (!VAR_34.isNull() && VAR_34.isDict()) {\n        VAR_9->printf(\" /OCProperties \");\n        PDFDoc::writeObject(&VAR_34, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);\n    }\n    /* COMMENT_7 */\n    if (!VAR_32.isNull() && VAR_32.isDict()) {\n        VAR_9->printf(\" /Names \");\n        PDFDoc::writeObject(&VAR_32, VAR_9, VAR_6, 0, nullptr, VAR_59, 0, 0, 0);\n    }\n    VAR_9->printf(\">>\\nendobj\\n\");\n    VAR_2++;\n\n    VAR_6->add(VAR_12 + 1, 0, VAR_9->getPos(), true);\n    VAR_9->printf(\"%d 0 obj\\n\", VAR_12 + 1);\n    VAR_9->printf(\"<< /Type /Pages /Kids [\");\n    for (VAR_11 = 0; VAR_11 < (int)VAR_4.size(); VAR_11++) {\n        VAR_9->printf(\" %d 0 R\", VAR_12 + VAR_11 + 2);\n    }\n    VAR_9->printf(\" ] /Count %zd >>\\nendobj\\n\", VAR_4.size());\n    VAR_2++;\n\n    for (VAR_10 = 0; VAR_10 < (int)VAR_4.size(); VAR_10++) {\n        VAR_6->add(VAR_12 + VAR_10 + 2, 0, VAR_9->getPos(), true);\n        VAR_9->printf(\"%d 0 obj\\n\", VAR_12 + VAR_10 + 2);\n        VAR_9->printf(\"<< \");\n        Dict *VAR_52 = VAR_4[VAR_10].getDict();\n        for (VAR_11 = 0; VAR_11 < VAR_52->getLength(); VAR_11++) {\n            if (VAR_11 > 0) {\n                VAR_9->printf(\" \");\n            }\n            const char *VAR_60 = VAR_52->getKey(VAR_11);\n            Object VAR_61 = VAR_52->getValNF(VAR_11).copy();\n            if (strcmp(VAR_60, \"Parent\") == 0) {\n                VAR_9->printf(\"/Parent %d 0 R\", VAR_12 + 1);\n            } else {\n                VAR_9->printf(\"/%s \", VAR_60);\n                PDFDoc::writeObject(&VAR_61, VAR_9, VAR_6, VAR_5[VAR_10], nullptr, VAR_59, 0, 0, 0);\n            }\n        }\n        VAR_9->printf(\" >>\\nendobj\\n\");\n        VAR_2++;\n    }\n    Goffset VAR_62 = VAR_9->getPos();\n    Ref VAR_63;\n    VAR_63.num = VAR_12;\n    VAR_63.gen = 0;\n    Object VAR_64 = PDFDoc::createTrailerDict(VAR_2, false, 0, &VAR_63, VAR_6, VAR_16, VAR_9->getPos());\n    PDFDoc::writeXRefTableTrailer(std::move(VAR_64), VAR_6, true, /* COMMENT_8 */\n                                                                      /* COMMENT_9 */\n                                  VAR_62, VAR_9, VAR_6);\n\n    VAR_9->close();\n    delete VAR_9;\n    fclose(VAR_8);\n    delete VAR_6;\n    delete VAR_7;\n    for (VAR_10 = 0; VAR_10 < (int)VAR_13.size(); VAR_10++) {\n        delete VAR_13[VAR_10];\n    }\n    return 0;\n}",
    "func_graph_path": "poppler/4631115647c1e4f0482ffe0491c2f38d2231337b/pdfunite.cc/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,14 @@\n     Object ocObj;\n     if (docs.size() >= 1) {\n         Object catObj = docs[0]->getXRef()->getCatalog();\n+        if(!catObj.isDict()){\n+            fclose(f);\n+            delete yRef;\n+            delete countRef;\n+            delete outStr;\n+            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");\n+            return -1;\n+        }\n         Dict *catDict = catObj.getDict();\n         intents = catDict->lookup(\"OutputIntents\");\n         afObj = catDict->lookupNF(\"AcroForm\").copy();\n@@ -175,6 +183,14 @@\n             }\n         }\n         Object pageCatObj = docs[i]->getXRef()->getCatalog();\n+        if(!pageCatObj.isDict()){\n+            fclose(f);\n+            delete yRef;\n+            delete countRef;\n+            delete outStr;\n+            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");\n+            return -1;\n+        }\n         Dict *pageCatDict = pageCatObj.getDict();\n         Object pageNames = pageCatDict->lookup(\"Names\");\n         if (!pageNames.isNull() && pageNames.isDict()) {",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "        if(!catObj.isDict()){",
            "            fclose(f);",
            "            delete yRef;",
            "            delete countRef;",
            "            delete outStr;",
            "            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");",
            "            return -1;",
            "        }",
            "        if(!pageCatObj.isDict()){",
            "            fclose(f);",
            "            delete yRef;",
            "            delete countRef;",
            "            delete outStr;",
            "            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");",
            "            return -1;",
            "        }"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}