{
    "cve_id": "CVE-2023-0030",
    "cwe_ids": [
        "CWE-416"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "drm/nouveau/mmu: add more general vmm free/node handling functions\n\nAside from being a nice cleanup, these will to allow the upcoming direct\npage mapping interfaces to play nicely with normal mappings.\n\nSigned-off-by: Ben Skeggs <bskeggs@redhat.com>",
    "commit_hash": "729eba3355674f2d9524629b73683ba1d1cd3f10",
    "git_url": "https://github.com/torvalds/linux/commit/729eba3355674f2d9524629b73683ba1d1cd3f10",
    "file_path": "drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c",
    "func_name": "nvkm_vmm_unmap_region",
    "func_before": "void\nnvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *next;\n\n\tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);\n\tnvkm_memory_unref(&vma->memory);\n\n\tif (vma->part) {\n\t\tstruct nvkm_vma *prev = node(vma, prev);\n\t\tif (!prev->memory) {\n\t\t\tprev->size += vma->size;\n\t\t\trb_erase(&vma->tree, &vmm->root);\n\t\t\tlist_del(&vma->head);\n\t\t\tkfree(vma);\n\t\t\tvma = prev;\n\t\t}\n\t}\n\n\tnext = node(vma, next);\n\tif (next && next->part) {\n\t\tif (!next->memory) {\n\t\t\tvma->size += next->size;\n\t\t\trb_erase(&next->tree, &vmm->root);\n\t\t\tlist_del(&next->head);\n\t\t\tkfree(next);\n\t\t}\n\t}\n}",
    "abstract_func_before": "void\nnvkm_vmm_unmap_region(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)\n{\n\tstruct nvkm_vma *VAR_2;\n\n\tnvkm_memory_tags_put(VAR_1->memory, VAR_0->mmu->subdev.device, &VAR_1->tags);\n\tnvkm_memory_unref(&VAR_1->memory);\n\n\tif (VAR_1->part) {\n\t\tstruct nvkm_vma *VAR_3 = node(VAR_1, VAR_3);\n\t\tif (!VAR_3->memory) {\n\t\t\tVAR_3->size += VAR_1->size;\n\t\t\trb_erase(&VAR_1->tree, &VAR_0->root);\n\t\t\tlist_del(&VAR_1->head);\n\t\t\tkfree(VAR_1);\n\t\t\tVAR_1 = VAR_3;\n\t\t}\n\t}\n\n\tVAR_2 = node(VAR_1, VAR_2);\n\tif (VAR_2 && VAR_2->part) {\n\t\tif (!VAR_2->memory) {\n\t\t\tVAR_1->size += VAR_2->size;\n\t\t\trb_erase(&VAR_2->tree, &VAR_0->root);\n\t\t\tlist_del(&VAR_2->head);\n\t\t\tkfree(VAR_2);\n\t\t}\n\t}\n}",
    "func_graph_path_before": "torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/before/0.json",
    "func": "void\nnvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *next = node(vma, next);\n\tstruct nvkm_vma *prev = NULL;\n\n\tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);\n\tnvkm_memory_unref(&vma->memory);\n\n\tif (!vma->part || ((prev = node(vma, prev)), prev->memory))\n\t\tprev = NULL;\n\tif (!next->part || next->memory)\n\t\tnext = NULL;\n\tnvkm_vmm_node_merge(vmm, prev, vma, next, vma->size);\n}",
    "abstract_func": "void\nnvkm_vmm_unmap_region(struct nvkm_vmm *VAR_0, struct nvkm_vma *VAR_1)\n{\n\tstruct nvkm_vma *VAR_2 = node(VAR_1, VAR_2);\n\tstruct nvkm_vma *VAR_3 = NULL;\n\n\tnvkm_memory_tags_put(VAR_1->memory, VAR_0->mmu->subdev.device, &VAR_1->tags);\n\tnvkm_memory_unref(&VAR_1->memory);\n\n\tif (!VAR_1->part || ((VAR_3 = node(VAR_1, VAR_3)), VAR_3->memory))\n\t\tVAR_3 = NULL;\n\tif (!VAR_2->part || VAR_2->memory)\n\t\tVAR_2 = NULL;\n\tnvkm_vmm_node_merge(VAR_0, VAR_3, VAR_1, VAR_2, VAR_1->size);\n}",
    "func_graph_path": "torvalds/linux/729eba3355674f2d9524629b73683ba1d1cd3f10/vmm.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -1,29 +1,15 @@\n void\n nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n {\n-\tstruct nvkm_vma *next;\n+\tstruct nvkm_vma *next = node(vma, next);\n+\tstruct nvkm_vma *prev = NULL;\n \n \tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);\n \tnvkm_memory_unref(&vma->memory);\n \n-\tif (vma->part) {\n-\t\tstruct nvkm_vma *prev = node(vma, prev);\n-\t\tif (!prev->memory) {\n-\t\t\tprev->size += vma->size;\n-\t\t\trb_erase(&vma->tree, &vmm->root);\n-\t\t\tlist_del(&vma->head);\n-\t\t\tkfree(vma);\n-\t\t\tvma = prev;\n-\t\t}\n-\t}\n-\n-\tnext = node(vma, next);\n-\tif (next && next->part) {\n-\t\tif (!next->memory) {\n-\t\t\tvma->size += next->size;\n-\t\t\trb_erase(&next->tree, &vmm->root);\n-\t\t\tlist_del(&next->head);\n-\t\t\tkfree(next);\n-\t\t}\n-\t}\n+\tif (!vma->part || ((prev = node(vma, prev)), prev->memory))\n+\t\tprev = NULL;\n+\tif (!next->part || next->memory)\n+\t\tnext = NULL;\n+\tnvkm_vmm_node_merge(vmm, prev, vma, next, vma->size);\n }",
    "diff_line_info": {
        "deleted_lines": [
            "\tstruct nvkm_vma *next;",
            "\tif (vma->part) {",
            "\t\tstruct nvkm_vma *prev = node(vma, prev);",
            "\t\tif (!prev->memory) {",
            "\t\t\tprev->size += vma->size;",
            "\t\t\trb_erase(&vma->tree, &vmm->root);",
            "\t\t\tlist_del(&vma->head);",
            "\t\t\tkfree(vma);",
            "\t\t\tvma = prev;",
            "\t\t}",
            "\t}",
            "",
            "\tnext = node(vma, next);",
            "\tif (next && next->part) {",
            "\t\tif (!next->memory) {",
            "\t\t\tvma->size += next->size;",
            "\t\t\trb_erase(&next->tree, &vmm->root);",
            "\t\t\tlist_del(&next->head);",
            "\t\t\tkfree(next);",
            "\t\t}",
            "\t}"
        ],
        "added_lines": [
            "\tstruct nvkm_vma *next = node(vma, next);",
            "\tstruct nvkm_vma *prev = NULL;",
            "\tif (!vma->part || ((prev = node(vma, prev)), prev->memory))",
            "\t\tprev = NULL;",
            "\tif (!next->part || next->memory)",
            "\t\tnext = NULL;",
            "\tnvkm_vmm_node_merge(vmm, prev, vma, next, vma->size);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}