{
    "cve_id": "CVE-2021-46925",
    "cwe_ids": [
        "CWE-362"
    ],
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cvss_is_v3": true,
    "repo_name": "torvalds/linux",
    "commit_msg": "[ Upstream commit 349d43127dac00c15231e8ffbcaabd70f7b0e544 ]\n\nA crash occurs when smc_cdc_tx_handler() tries to access smc_sock\nbut smc_release() has already freed it.\n\n[ 4570.695099] BUG: unable to handle page fault for address: 000000002eae9e88\n[ 4570.696048] #PF: supervisor write access in kernel mode\n[ 4570.696728] #PF: error_code(0x0002) - not-present page\n[ 4570.697401] PGD 0 P4D 0\n[ 4570.697716] Oops: 0002 [#1] PREEMPT SMP NOPTI\n[ 4570.698228] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.16.0-rc4+ #111\n[ 4570.699013] Hardware name: Alibaba Cloud Alibaba Cloud ECS, BIOS 8c24b4c 04/0\n[ 4570.699933] RIP: 0010:_raw_spin_lock+0x1a/0x30\n<...>\n[ 4570.711446] Call Trace:\n[ 4570.711746]  <IRQ>\n[ 4570.711992]  smc_cdc_tx_handler+0x41/0xc0\n[ 4570.712470]  smc_wr_tx_tasklet_fn+0x213/0x560\n[ 4570.712981]  ? smc_cdc_tx_dismisser+0x10/0x10\n[ 4570.713489]  tasklet_action_common.isra.17+0x66/0x140\n[ 4570.714083]  __do_softirq+0x123/0x2f4\n[ 4570.714521]  irq_exit_rcu+0xc4/0xf0\n[ 4570.714934]  common_interrupt+0xba/0xe0\n\nThough smc_cdc_tx_handler() checked the existence of smc connection,\nsmc_release() may have already dismissed and released the smc socket\nbefore smc_cdc_tx_handler() further visits it.\n\nsmc_cdc_tx_handler()           |smc_release()\nif (!conn)                     |\n                               |\n                               |smc_cdc_tx_dismiss_slots()\n                               |      smc_cdc_tx_dismisser()\n                               |\n                               |sock_put(&smc->sk) <- last sock_put,\n                               |                      smc_sock freed\nbh_lock_sock(&smc->sk) (panic) |\n\nTo make sure we won't receive any CDC messages after we free the\nsmc_sock, add a refcount on the smc_connection for inflight CDC\nmessage(posted to the QP but haven't received related CQE), and\ndon't release the smc_connection until all the inflight CDC messages\nhaven been done, for both success or failed ones.\n\nUsing refcount on CDC messages brings another problem: when the link\nis going to be destroyed, smcr_link_clear() will reset the QP, which\nthen remove all the pending CQEs related to the QP in the CQ. To make\nsure all the CQEs will always come back so the refcount on the\nsmc_connection can always reach 0, smc_ib_modify_qp_reset() was replaced\nby smc_ib_modify_qp_error().\nAnd remove the timeout in smc_wr_tx_wait_no_pending_sends() since we\nneed to wait for all pending WQEs done, or we may encounter use-after-\nfree when handling CQEs.\n\nFor IB device removal routine, we need to wait for all the QPs on that\ndevice been destroyed before we can destroy CQs on the device, or\nthe refcount on smc_connection won't reach 0 and smc_sock cannot be\nreleased.\n\nFixes: 5f08318f617b (\"smc: connection data control (CDC)\")\nReported-by: Wen Gu <guwen@linux.alibaba.com>\nSigned-off-by: Dust Li <dust.li@linux.alibaba.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Sasha Levin <sashal@kernel.org>\n",
    "commit_hash": "b85f751d71ae8e2a15e9bda98852ea9af35282eb",
    "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=b85f751d71ae8e2a15e9bda98852ea9af35282eb",
    "file_path": "net/smc/smc_core.c",
    "func_name": "smc_conn_kill",
    "func_before": "static void smc_conn_kill(struct smc_connection *conn, bool soft)\n{\n\tstruct smc_sock *smc = container_of(conn, struct smc_sock, conn);\n\n\tif (conn->lgr->is_smcd && conn->lgr->peer_shutdown)\n\t\tconn->local_tx_ctrl.conn_state_flags.peer_conn_abort = 1;\n\telse\n\t\tsmc_close_abort(conn);\n\tconn->killed = 1;\n\tsmc->sk.sk_err = ECONNABORTED;\n\tsmc_sk_wake_ups(smc);\n\tif (conn->lgr->is_smcd) {\n\t\tsmc_ism_unset_conn(conn);\n\t\tif (soft)\n\t\t\ttasklet_kill(&conn->rx_tsklet);\n\t\telse\n\t\t\ttasklet_unlock_wait(&conn->rx_tsklet);\n\t} else {\n\t\tsmc_cdc_tx_dismiss_slots(conn);\n\t}\n\tsmc_lgr_unregister_conn(conn);\n\tsmc_close_active_abort(smc);\n}",
    "abstract_func_before": "static void smc_conn_kill(struct smc_connection *VAR_0, bool VAR_1)\n{\n\tstruct smc_sock *VAR_2 = container_of(VAR_0, struct smc_sock, VAR_0);\n\n\tif (VAR_0->lgr->is_smcd && VAR_0->lgr->peer_shutdown)\n\t\tVAR_0->local_tx_ctrl.conn_state_flags.peer_conn_abort = 1;\n\telse\n\t\tsmc_close_abort(VAR_0);\n\tVAR_0->killed = 1;\n\tVAR_2->sk.sk_err = VAR_3;\n\tsmc_sk_wake_ups(VAR_2);\n\tif (VAR_0->lgr->is_smcd) {\n\t\tsmc_ism_unset_conn(VAR_0);\n\t\tif (VAR_1)\n\t\t\ttasklet_kill(&VAR_0->rx_tsklet);\n\t\telse\n\t\t\ttasklet_unlock_wait(&VAR_0->rx_tsklet);\n\t} else {\n\t\tsmc_cdc_tx_dismiss_slots(VAR_0);\n\t}\n\tsmc_lgr_unregister_conn(VAR_0);\n\tsmc_close_active_abort(VAR_2);\n}",
    "func_graph_path_before": "torvalds/linux/b85f751d71ae8e2a15e9bda98852ea9af35282eb/smc_core.c/vul/before/1.json",
    "func": "static void smc_conn_kill(struct smc_connection *conn, bool soft)\n{\n\tstruct smc_sock *smc = container_of(conn, struct smc_sock, conn);\n\n\tif (conn->lgr->is_smcd && conn->lgr->peer_shutdown)\n\t\tconn->local_tx_ctrl.conn_state_flags.peer_conn_abort = 1;\n\telse\n\t\tsmc_close_abort(conn);\n\tconn->killed = 1;\n\tsmc->sk.sk_err = ECONNABORTED;\n\tsmc_sk_wake_ups(smc);\n\tif (conn->lgr->is_smcd) {\n\t\tsmc_ism_unset_conn(conn);\n\t\tif (soft)\n\t\t\ttasklet_kill(&conn->rx_tsklet);\n\t\telse\n\t\t\ttasklet_unlock_wait(&conn->rx_tsklet);\n\t} else {\n\t\tsmc_cdc_wait_pend_tx_wr(conn);\n\t}\n\tsmc_lgr_unregister_conn(conn);\n\tsmc_close_active_abort(smc);\n}",
    "abstract_func": "static void smc_conn_kill(struct smc_connection *VAR_0, bool VAR_1)\n{\n\tstruct smc_sock *VAR_2 = container_of(VAR_0, struct smc_sock, VAR_0);\n\n\tif (VAR_0->lgr->is_smcd && VAR_0->lgr->peer_shutdown)\n\t\tVAR_0->local_tx_ctrl.conn_state_flags.peer_conn_abort = 1;\n\telse\n\t\tsmc_close_abort(VAR_0);\n\tVAR_0->killed = 1;\n\tVAR_2->sk.sk_err = VAR_3;\n\tsmc_sk_wake_ups(VAR_2);\n\tif (VAR_0->lgr->is_smcd) {\n\t\tsmc_ism_unset_conn(VAR_0);\n\t\tif (VAR_1)\n\t\t\ttasklet_kill(&VAR_0->rx_tsklet);\n\t\telse\n\t\t\ttasklet_unlock_wait(&VAR_0->rx_tsklet);\n\t} else {\n\t\tsmc_cdc_wait_pend_tx_wr(VAR_0);\n\t}\n\tsmc_lgr_unregister_conn(VAR_0);\n\tsmc_close_active_abort(VAR_2);\n}",
    "func_graph_path": "torvalds/linux/b85f751d71ae8e2a15e9bda98852ea9af35282eb/smc_core.c/vul/after/1.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \t\telse\n \t\t\ttasklet_unlock_wait(&conn->rx_tsklet);\n \t} else {\n-\t\tsmc_cdc_tx_dismiss_slots(conn);\n+\t\tsmc_cdc_wait_pend_tx_wr(conn);\n \t}\n \tsmc_lgr_unregister_conn(conn);\n \tsmc_close_active_abort(smc);",
    "diff_line_info": {
        "deleted_lines": [
            "\t\tsmc_cdc_tx_dismiss_slots(conn);"
        ],
        "added_lines": [
            "\t\tsmc_cdc_wait_pend_tx_wr(conn);"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}