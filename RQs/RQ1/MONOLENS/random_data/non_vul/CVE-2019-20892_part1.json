{
    "cve_id": "CVE-2019-20892",
    "cwe_ids": [
        "CWE-415"
    ],
    "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
    "cvss_is_v3": false,
    "repo_name": "net-snmp",
    "commit_msg": "libsnmp, USM: Introduce a reference count in struct usmStateReference\n\nThis patch fixes https://sourceforge.net/p/net-snmp/bugs/2956/.",
    "commit_hash": "5f881d3bf24599b90d67a45cae7a3eb099cd71c9",
    "git_url": "https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9",
    "file_path": "snmplib/snmp_client.c",
    "func_name": "_clone_pdu_header",
    "func_before": "static\nnetsnmp_pdu    *\n_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n\n    if (!pdu)\n        return NULL;\n\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n\n    /*\n     * reset copied pointers if copy fails \n     */\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n\n    /*\n     * copy buffers individually. If any copy fails, all are freed. \n     */\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n\n    if (pdu->securityStateRef &&\n        pdu->command == SNMP_MSG_TRAP2) {\n\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n                (struct usmStateReference **) &newpdu->securityStateRef );\n\n        if (ret)\n        {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n\n    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n        sptr->pdu_clone != NULL) {\n        /*\n         * call security model if it needs to know about this \n         */\n        (*sptr->pdu_clone) (pdu, newpdu);\n    }\n\n    return newpdu;\n}",
    "abstract_func_before": "static\nnetsnmp_pdu    *\n_clone_pdu_header(netsnmp_pdu *VAR_0)\n{\n    netsnmp_pdu    *VAR_1;\n    struct snmp_secmod_def *VAR_2;\n    int VAR_3;\n\n    if (!VAR_0)\n        return NULL;\n\n    VAR_1 = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!VAR_1)\n        return NULL;\n    memmove(VAR_1, VAR_0, sizeof(netsnmp_pdu));\n\n    /* COMMENT_0 */\n                                           \n       \n    VAR_1->variables = NULL;\n    VAR_1->enterprise = NULL;\n    VAR_1->community = NULL;\n    VAR_1->securityEngineID = NULL;\n    VAR_1->securityName = NULL;\n    VAR_1->contextEngineID = NULL;\n    VAR_1->contextName = NULL;\n    VAR_1->transport_data = NULL;\n\n    /* COMMENT_3 */\n                                                                    \n       \n    if (snmp_clone_mem((void **) &VAR_1->enterprise, VAR_0->enterprise,\n                       sizeof(VAR_4) * VAR_0->enterprise_length) ||\n        snmp_clone_mem((void **) &VAR_1->community, VAR_0->community,\n                       VAR_0->community_len) ||\n        snmp_clone_mem((void **) &VAR_1->contextEngineID,\n                       VAR_0->contextEngineID, VAR_0->contextEngineIDLen)\n        || snmp_clone_mem((void **) &VAR_1->securityEngineID,\n                          VAR_0->securityEngineID, VAR_0->securityEngineIDLen)\n        || snmp_clone_mem((void **) &VAR_1->contextName, VAR_0->contextName,\n                          VAR_0->contextNameLen)\n        || snmp_clone_mem((void **) &VAR_1->securityName,\n                          VAR_0->securityName, VAR_0->securityNameLen)\n        || snmp_clone_mem((void **) &VAR_1->transport_data,\n                          VAR_0->transport_data,\n                          VAR_0->transport_data_length)) {\n        snmp_free_pdu(VAR_1);\n        return NULL;\n    }\n\n    if (VAR_0->securityStateRef &&\n        VAR_0->command == VAR_5) {\n\n        netsnmp_assert(VAR_0->securityModel == VAR_6);\n        VAR_3 = usm_clone_usmStateReference((struct usmStateReference *) VAR_0->securityStateRef,\n                (struct usmStateReference **) &VAR_1->securityStateRef );\n\n        if (VAR_3)\n        {\n            snmp_free_pdu(VAR_1);\n            return NULL;\n        }\n    }\n\n    if ((VAR_2 = find_sec_mod(VAR_1->securityModel)) != NULL &&\n        VAR_2->pdu_clone != NULL) {\n        /* COMMENT_6 */\n                                                              \n           \n        (*VAR_2->pdu_clone) (VAR_0, VAR_1);\n    }\n\n    return VAR_1;\n}",
    "func_graph_path_before": "net-snmp/5f881d3bf24599b90d67a45cae7a3eb099cd71c9/snmp_client.c/vul/before/0.json",
    "func": "static\nnetsnmp_pdu    *\n_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n\n    if (!pdu)\n        return NULL;\n\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n\n    /*\n     * reset copied pointers if copy fails \n     */\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n\n    /*\n     * copy buffers individually. If any copy fails, all are freed. \n     */\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n\n    sptr = find_sec_mod(newpdu->securityModel);\n    if (sptr && sptr->pdu_clone) {\n        /* call security model if it needs to know about this */\n        ret = sptr->pdu_clone(pdu, newpdu);\n        if (ret) {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n\n    return newpdu;\n}",
    "abstract_func": "static\nnetsnmp_pdu    *\n_clone_pdu_header(netsnmp_pdu *VAR_0)\n{\n    netsnmp_pdu    *VAR_1;\n    struct snmp_secmod_def *VAR_2;\n    int VAR_3;\n\n    if (!VAR_0)\n        return NULL;\n\n    VAR_1 = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!VAR_1)\n        return NULL;\n    memmove(VAR_1, VAR_0, sizeof(netsnmp_pdu));\n\n    /* COMMENT_0 */\n                                           \n       \n    VAR_1->variables = NULL;\n    VAR_1->enterprise = NULL;\n    VAR_1->community = NULL;\n    VAR_1->securityEngineID = NULL;\n    VAR_1->securityName = NULL;\n    VAR_1->contextEngineID = NULL;\n    VAR_1->contextName = NULL;\n    VAR_1->transport_data = NULL;\n\n    /* COMMENT_3 */\n                                                                    \n       \n    if (snmp_clone_mem((void **) &VAR_1->enterprise, VAR_0->enterprise,\n                       sizeof(VAR_4) * VAR_0->enterprise_length) ||\n        snmp_clone_mem((void **) &VAR_1->community, VAR_0->community,\n                       VAR_0->community_len) ||\n        snmp_clone_mem((void **) &VAR_1->contextEngineID,\n                       VAR_0->contextEngineID, VAR_0->contextEngineIDLen)\n        || snmp_clone_mem((void **) &VAR_1->securityEngineID,\n                          VAR_0->securityEngineID, VAR_0->securityEngineIDLen)\n        || snmp_clone_mem((void **) &VAR_1->contextName, VAR_0->contextName,\n                          VAR_0->contextNameLen)\n        || snmp_clone_mem((void **) &VAR_1->securityName,\n                          VAR_0->securityName, VAR_0->securityNameLen)\n        || snmp_clone_mem((void **) &VAR_1->transport_data,\n                          VAR_0->transport_data,\n                          VAR_0->transport_data_length)) {\n        snmp_free_pdu(VAR_1);\n        return NULL;\n    }\n\n    VAR_2 = find_sec_mod(VAR_1->securityModel);\n    if (VAR_2 && VAR_2->pdu_clone) {\n        /* COMMENT_6 */\n        VAR_3 = VAR_2->pdu_clone(VAR_0, VAR_1);\n        if (VAR_3) {\n            snmp_free_pdu(VAR_1);\n            return NULL;\n        }\n    }\n\n    return VAR_1;\n}",
    "func_graph_path": "net-snmp/5f881d3bf24599b90d67a45cae7a3eb099cd71c9/snmp_client.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -48,27 +48,15 @@\n         return NULL;\n     }\n \n-    if (pdu->securityStateRef &&\n-        pdu->command == SNMP_MSG_TRAP2) {\n-\n-        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n-        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n-                (struct usmStateReference **) &newpdu->securityStateRef );\n-\n-        if (ret)\n-        {\n+    sptr = find_sec_mod(newpdu->securityModel);\n+    if (sptr && sptr->pdu_clone) {\n+        /* call security model if it needs to know about this */\n+        ret = sptr->pdu_clone(pdu, newpdu);\n+        if (ret) {\n             snmp_free_pdu(newpdu);\n             return NULL;\n         }\n     }\n \n-    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n-        sptr->pdu_clone != NULL) {\n-        /*\n-         * call security model if it needs to know about this \n-         */\n-        (*sptr->pdu_clone) (pdu, newpdu);\n-    }\n-\n     return newpdu;\n }",
    "diff_line_info": {
        "deleted_lines": [
            "    if (pdu->securityStateRef &&",
            "        pdu->command == SNMP_MSG_TRAP2) {",
            "",
            "        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);",
            "        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,",
            "                (struct usmStateReference **) &newpdu->securityStateRef );",
            "",
            "        if (ret)",
            "        {",
            "    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&",
            "        sptr->pdu_clone != NULL) {",
            "        /*",
            "         * call security model if it needs to know about this ",
            "         */",
            "        (*sptr->pdu_clone) (pdu, newpdu);",
            "    }",
            ""
        ],
        "added_lines": [
            "    sptr = find_sec_mod(newpdu->securityModel);",
            "    if (sptr && sptr->pdu_clone) {",
            "        /* call security model if it needs to know about this */",
            "        ret = sptr->pdu_clone(pdu, newpdu);",
            "        if (ret) {"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}