{
    "cve_id": "CVE-2013-4254",
    "cwe_ids": [
        "CWE-20"
    ],
    "cvss_vector": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
    "cvss_is_v3": false,
    "repo_name": "torvalds/linux",
    "commit_msg": "ARM: 7809/1: perf: fix event validation for software group leaders\n\nIt is possible to construct an event group with a software event as a\ngroup leader and then subsequently add a hardware event to the group.\nThis results in the event group being validated by adding all members\nof the group to a fake PMU and attempting to allocate each event on\ntheir respective PMU.\n\nUnfortunately, for software events wthout a corresponding arm_pmu, this\nresults in a kernel crash attempting to dereference the ->get_event_idx\nfunction pointer.\n\nThis patch fixes the problem by checking explicitly for software events\nand ignoring those in event validation (since they can always be\nscheduled). We will probably want to revisit this for 3.12, since the\nvalidation checks don't appear to work correctly when dealing with\nmultiple hardware PMUs anyway.\n\nCc: <stable@vger.kernel.org>\nReported-by: Vince Weaver <vincent.weaver@maine.edu>\nTested-by: Vince Weaver <vincent.weaver@maine.edu>\nTested-by: Mark Rutland <mark.rutland@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>",
    "commit_hash": "c95eb3184ea1a3a2551df57190c81da695e2144b",
    "git_url": "https://github.com/torvalds/linux/commit/c95eb3184ea1a3a2551df57190c81da695e2144b",
    "file_path": "arch/arm/kernel/perf_event.c",
    "func_name": "validate_event",
    "func_before": "static int\nvalidate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}",
    "abstract_func_before": "static int\nvalidate_event(struct pmu_hw_events *VAR_0,\n\t       struct perf_event *VAR_1)\n{\n\tstruct arm_pmu *VAR_2 = to_arm_pmu(VAR_1->pmu);\n\tstruct pmu *VAR_3 = VAR_1->group_leader->pmu;\n\n\tif (VAR_1->pmu != VAR_3 || VAR_1->state < VAR_4)\n\t\treturn 1;\n\n\tif (VAR_1->state == VAR_4 && !VAR_1->attr.enable_on_exec)\n\t\treturn 1;\n\n\treturn VAR_2->get_event_idx(VAR_0, VAR_1) >= 0;\n}",
    "func_graph_path_before": "torvalds/linux/c95eb3184ea1a3a2551df57190c81da695e2144b/perf_event.c/vul/before/0.json",
    "func": "static int\nvalidate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\n\tif (is_software_event(event))\n\t\treturn 1;\n\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}",
    "abstract_func": "static int\nvalidate_event(struct pmu_hw_events *VAR_0,\n\t       struct perf_event *VAR_1)\n{\n\tstruct arm_pmu *VAR_2 = to_arm_pmu(VAR_1->pmu);\n\tstruct pmu *VAR_3 = VAR_1->group_leader->pmu;\n\n\tif (is_software_event(VAR_1))\n\t\treturn 1;\n\n\tif (VAR_1->pmu != VAR_3 || VAR_1->state < VAR_4)\n\t\treturn 1;\n\n\tif (VAR_1->state == VAR_4 && !VAR_1->attr.enable_on_exec)\n\t\treturn 1;\n\n\treturn VAR_2->get_event_idx(VAR_0, VAR_1) >= 0;\n}",
    "func_graph_path": "torvalds/linux/c95eb3184ea1a3a2551df57190c81da695e2144b/perf_event.c/vul/after/0.json",
    "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n {\n \tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n+\n+\tif (is_software_event(event))\n+\t\treturn 1;\n \n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;",
    "diff_line_info": {
        "deleted_lines": [],
        "added_lines": [
            "",
            "\tif (is_software_event(event))",
            "\t\treturn 1;"
        ]
    },
    "is_vul": true,
    "pr_url": null,
    "description": "no more info"
}