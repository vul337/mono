{
  "id": 3859,
  "language": "C/C++",
  "commit_url": "https://github.com/linux-audit/audit-kernel/commit/e73e81975f2447e6f556100cada64a18ec631cbb",
  "commit_sha": "e73e81975f2447e6f556100cada64a18ec631cbb",
  "commit_msg": "sched/debug: Fix potential deadlock when writing to sched_features\n\nThe following lockdep report can be triggered by writing to /sys/kernel/debug/sched_features:\n\n  ======================================================\n  WARNING: possible circular locking dependency detected\n  4.18.0-rc6-00152-gcd3f77d74ac3-dirty #18 Not tainted\n  ------------------------------------------------------\n  sh/3358 is trying to acquire lock:\n  000000004ad3989d (cpu_hotplug_lock.rw_sem){++++}, at: static_key_enable+0x14/0x30\n  but task is already holding lock:\n  00000000c1b31a88 (&sb->s_type->i_mutex_key#3){+.+.}, at: sched_feat_write+0x160/0x428\n  which lock already depends on the new lock.\n  the existing dependency chain (in reverse order) is:\n  -> #3 (&sb->s_type->i_mutex_key#3){+.+.}:\n         lock_acquire+0xb8/0x148\n         down_write+0xac/0x140\n         start_creating+0x5c/0x168\n         debugfs_create_dir+0x18/0x220\n         opp_debug_register+0x8c/0x120\n         _add_opp_dev+0x104/0x1f8\n         dev_pm_opp_get_opp_table+0x174/0x340\n         _of_add_opp_table_v2+0x110/0x760\n         dev_pm_opp_of_add_table+0x5c/0x240\n         dev_pm_opp_of_cpumask_add_table+0x5c/0x100\n         cpufreq_init+0x160/0x430\n         cpufreq_online+0x1cc/0xe30\n         cpufreq_add_dev+0x78/0x198\n         subsys_interface_register+0x168/0x270\n         cpufreq_register_driver+0x1c8/0x278\n         dt_cpufreq_probe+0xdc/0x1b8\n         platform_drv_probe+0xb4/0x168\n         driver_probe_device+0x318/0x4b0\n         __device_attach_driver+0xfc/0x1f0\n         bus_for_each_drv+0xf8/0x180\n         __device_attach+0x164/0x200\n         device_initial_probe+0x10/0x18\n         bus_probe_device+0x110/0x178\n         device_add+0x6d8/0x908\n         platform_device_add+0x138/0x3d8\n         platform_device_register_full+0x1cc/0x1f8\n         cpufreq_dt_platdev_init+0x174/0x1bc\n         do_one_initcall+0xb8/0x310\n         kernel_init_freeable+0x4b8/0x56c\n         kernel_init+0x10/0x138\n         ret_from_fork+0x10/0x18\n  -> #2 (opp_table_lock){+.+.}:\n         lock_acquire+0xb8/0x148\n         __mutex_lock+0x104/0xf50\n         mutex_lock_nested+0x1c/0x28\n         _of_add_opp_table_v2+0xb4/0x760\n         dev_pm_opp_of_add_table+0x5c/0x240\n         dev_pm_opp_of_cpumask_add_table+0x5c/0x100\n         cpufreq_init+0x160/0x430\n         cpufreq_online+0x1cc/0xe30\n         cpufreq_add_dev+0x78/0x198\n         subsys_interface_register+0x168/0x270\n         cpufreq_register_driver+0x1c8/0x278\n         dt_cpufreq_probe+0xdc/0x1b8\n         platform_drv_probe+0xb4/0x168\n         driver_probe_device+0x318/0x4b0\n         __device_attach_driver+0xfc/0x1f0\n         bus_for_each_drv+0xf8/0x180\n         __device_attach+0x164/0x200\n         device_initial_probe+0x10/0x18\n         bus_probe_device+0x110/0x178\n         device_add+0x6d8/0x908\n         platform_device_add+0x138/0x3d8\n         platform_device_register_full+0x1cc/0x1f8\n         cpufreq_dt_platdev_init+0x174/0x1bc\n         do_one_initcall+0xb8/0x310\n         kernel_init_freeable+0x4b8/0x56c\n         kernel_init+0x10/0x138\n         ret_from_fork+0x10/0x18\n  -> #1 (subsys mutex#6){+.+.}:\n         lock_acquire+0xb8/0x148\n         __mutex_lock+0x104/0xf50\n         mutex_lock_nested+0x1c/0x28\n         subsys_interface_register+0xd8/0x270\n         cpufreq_register_driver+0x1c8/0x278\n         dt_cpufreq_probe+0xdc/0x1b8\n         platform_drv_probe+0xb4/0x168\n         driver_probe_device+0x318/0x4b0\n         __device_attach_driver+0xfc/0x1f0\n         bus_for_each_drv+0xf8/0x180\n         __device_attach+0x164/0x200\n         device_initial_probe+0x10/0x18\n         bus_probe_device+0x110/0x178\n         device_add+0x6d8/0x908\n         platform_device_add+0x138/0x3d8\n         platform_device_register_full+0x1cc/0x1f8\n         cpufreq_dt_platdev_init+0x174/0x1bc\n         do_one_initcall+0xb8/0x310\n         kernel_init_freeable+0x4b8/0x56c\n         kernel_init+0x10/0x138\n         ret_from_fork+0x10/0x18\n  -> #0 (cpu_hotplug_lock.rw_sem){++++}:\n         __lock_acquire+0x203c/0x21d0\n         lock_acquire+0xb8/0x148\n         cpus_read_lock+0x58/0x1c8\n         static_key_enable+0x14/0x30\n         sched_feat_write+0x314/0x428\n         full_proxy_write+0xa0/0x138\n         __vfs_write+0xd8/0x388\n         vfs_write+0xdc/0x318\n         ksys_write+0xb4/0x138\n         sys_write+0xc/0x18\n         __sys_trace_return+0x0/0x4\n  other info that might help us debug this:\n  Chain exists of:\n    cpu_hotplug_lock.rw_sem --> opp_table_lock --> &sb->s_type->i_mutex_key#3\n   Possible unsafe locking scenario:\n         CPU0                    CPU1\n         ----                    ----\n    lock(&sb->s_type->i_mutex_key#3);\n                                 lock(opp_table_lock);\n                                 lock(&sb->s_type->i_mutex_key#3);\n    lock(cpu_hotplug_lock.rw_sem);\n   *** DEADLOCK ***\n  2 locks held by sh/3358:\n   #0: 00000000a8c4b363 (sb_writers#10){.+.+}, at: vfs_write+0x238/0x318\n   #1: 00000000c1b31a88 (&sb->s_type->i_mutex_key#3){+.+.}, at: sched_feat_write+0x160/0x428\n  stack backtrace:\n  CPU: 5 PID: 3358 Comm: sh Not tainted 4.18.0-rc6-00152-gcd3f77d74ac3-dirty #18\n  Hardware name: Renesas H3ULCB Kingfisher board based on r8a7795 ES2.0+ (DT)\n  Call trace:\n   dump_backtrace+0x0/0x288\n   show_stack+0x14/0x20\n   dump_stack+0x13c/0x1ac\n   print_circular_bug.isra.10+0x270/0x438\n   check_prev_add.constprop.16+0x4dc/0xb98\n   __lock_acquire+0x203c/0x21d0\n   lock_acquire+0xb8/0x148\n   cpus_read_lock+0x58/0x1c8\n   static_key_enable+0x14/0x30\n   sched_feat_write+0x314/0x428\n   full_proxy_write+0xa0/0x138\n   __vfs_write+0xd8/0x388\n   vfs_write+0xdc/0x318\n   ksys_write+0xb4/0x138\n   sys_write+0xc/0x18\n   __sys_trace_return+0x0/0x4\n\nThis is because when loading the cpufreq_dt module we first acquire\ncpu_hotplug_lock.rw_sem lock, then in cpufreq_init(), we are taking\nthe &sb->s_type->i_mutex_key lock.\n\nBut when writing to /sys/kernel/debug/sched_features, the\ncpu_hotplug_lock.rw_sem lock depends on the &sb->s_type->i_mutex_key lock.\n\nTo fix this bug, reverse the lock acquisition order when writing to\nsched_features, this way cpu_hotplug_lock.rw_sem no longer depends on\n&sb->s_type->i_mutex_key.\n\nTested-by: Dietmar Eggemann <dietmar.eggemann@arm.com>\nSigned-off-by: Jiada Wang <jiada_wang@mentor.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Eugeniu Rosca <erosca@de.adit-jv.com>\nCc: George G. Davis <george_davis@mentor.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nLink: http://lkml.kernel.org/r/20180731121222.26195-1-jiada_wang@mentor.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "kernel/sched/debug.c",
  "func_name": "sched_feat_enable",
  "func_before": "static void sched_feat_enable(int i)\n{\n\tstatic_key_enable(&sched_feat_keys[i]);\n}",
  "func_after": "static void sched_feat_enable(int i)\n{\n\tstatic_key_enable_cpuslocked(&sched_feat_keys[i]);\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void sched_feat_enable(int i)\n {\n-\tstatic_key_enable(&sched_feat_keys[i]);\n+\tstatic_key_enable_cpuslocked(&sched_feat_keys[i]);\n }",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a deadlock issue in the Linux kernel by adjusting the lock acquisition order. This prevents the system from hanging, improving availability. However, it doesn't fix a security vulnerability, making it a defect remediation.\n\n**Final Output:**\nAnalysis: The patch fixes a deadlock issue by changing the lock order, improving system availability. It doesn't address a security vulnerability.\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 1.0"
}