{
  "id": 1145,
  "language": "Java",
  "commit_url": "https://github.com/omnirom/android_frameworks_base/commit/5238a70be8c3348f9592de5e625f6311e4d51032",
  "commit_sha": "5238a70be8c3348f9592de5e625f6311e4d51032",
  "commit_msg": "Ignore malformed shortcuts\n\nAfter an app publishes a shortcut that contains malformed intent, the\nsystem can be stuck in boot-loop due to uncaught exception caused by\nparsing the malformed intent.\n\nThis CL ignores that particular malformed entry. Since shortcuts are\nconstantly writes back into the xml from system memory, the malformed\nentry will be removed from the xml the next time system persists\nshortcuts from memory to file system.\n\nBug: 246540168\nTest: manual\nChange-Id: I9492fcbd499ab2792c1d08884e3af394c5a4c79f",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/pm/ShortcutPackage.java",
  "func_name": "loadFromXml",
  "func_before": "public static ShortcutPackage loadFromXml(ShortcutService s, ShortcutUser shortcutUser,\n            TypedXmlPullParser parser, boolean fromBackup)\n            throws IOException, XmlPullParserException {\n\n        final String packageName = ShortcutService.parseStringAttribute(parser,\n                ATTR_NAME);\n\n        final ShortcutPackage ret = new ShortcutPackage(shortcutUser,\n                shortcutUser.getUserId(), packageName);\n        synchronized (ret.mLock) {\n            ret.mIsAppSearchSchemaUpToDate = ShortcutService.parseIntAttribute(\n                    parser, ATTR_SCHEMA_VERSON, 0) == AppSearchShortcutInfo.SCHEMA_VERSION;\n\n            ret.mApiCallCount = ShortcutService.parseIntAttribute(parser, ATTR_CALL_COUNT);\n            ret.mLastResetTime = ShortcutService.parseLongAttribute(parser, ATTR_LAST_RESET);\n\n            final int outerDepth = parser.getDepth();\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                if (type != XmlPullParser.START_TAG) {\n                    continue;\n                }\n                final int depth = parser.getDepth();\n                final String tag = parser.getName();\n                if (depth == outerDepth + 1) {\n                    switch (tag) {\n                        case ShortcutPackageInfo.TAG_ROOT:\n                            ret.getPackageInfo().loadFromXml(parser, fromBackup);\n\n                            continue;\n                        case TAG_SHORTCUT:\n                            final ShortcutInfo si = parseShortcut(parser, packageName,\n                                    shortcutUser.getUserId(), fromBackup);\n                            // Don't use addShortcut(), we don't need to save the icon.\n                            ret.mShortcuts.put(si.getId(), si);\n                            continue;\n                        case TAG_SHARE_TARGET:\n                            ret.mShareTargets.add(ShareTargetInfo.loadFromXml(parser));\n                            continue;\n                    }\n                }\n                ShortcutService.warnForInvalidTag(depth, tag);\n            }\n        }\n        return ret;\n    }",
  "func_after": "public static ShortcutPackage loadFromXml(ShortcutService s, ShortcutUser shortcutUser,\n            TypedXmlPullParser parser, boolean fromBackup)\n            throws IOException, XmlPullParserException {\n\n        final String packageName = ShortcutService.parseStringAttribute(parser,\n                ATTR_NAME);\n\n        final ShortcutPackage ret = new ShortcutPackage(shortcutUser,\n                shortcutUser.getUserId(), packageName);\n        synchronized (ret.mLock) {\n            ret.mIsAppSearchSchemaUpToDate = ShortcutService.parseIntAttribute(\n                    parser, ATTR_SCHEMA_VERSON, 0) == AppSearchShortcutInfo.SCHEMA_VERSION;\n\n            ret.mApiCallCount = ShortcutService.parseIntAttribute(parser, ATTR_CALL_COUNT);\n            ret.mLastResetTime = ShortcutService.parseLongAttribute(parser, ATTR_LAST_RESET);\n\n            final int outerDepth = parser.getDepth();\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                if (type != XmlPullParser.START_TAG) {\n                    continue;\n                }\n                final int depth = parser.getDepth();\n                final String tag = parser.getName();\n                if (depth == outerDepth + 1) {\n                    switch (tag) {\n                        case ShortcutPackageInfo.TAG_ROOT:\n                            ret.getPackageInfo().loadFromXml(parser, fromBackup);\n\n                            continue;\n                        case TAG_SHORTCUT:\n                            try {\n                                final ShortcutInfo si = parseShortcut(parser, packageName,\n                                        shortcutUser.getUserId(), fromBackup);\n                                // Don't use addShortcut(), we don't need to save the icon.\n                                ret.mShortcuts.put(si.getId(), si);\n                            } catch (Exception e) {\n                                // b/246540168 malformed shortcuts should be ignored\n                                Slog.e(TAG, \"Failed parsing shortcut.\", e);\n                            }\n                            continue;\n                        case TAG_SHARE_TARGET:\n                            ret.mShareTargets.add(ShareTargetInfo.loadFromXml(parser));\n                            continue;\n                    }\n                }\n                ShortcutService.warnForInvalidTag(depth, tag);\n            }\n        }\n        return ret;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public static ShortcutPackage loadFromXml(ShortcutService s, ShortcutUser shortcutUser,\n             TypedXmlPullParser parser, boolean fromBackup)\n             throws IOException, XmlPullParserException {\n \n         final String packageName = ShortcutService.parseStringAttribute(parser,\n                 ATTR_NAME);\n \n         final ShortcutPackage ret = new ShortcutPackage(shortcutUser,\n                 shortcutUser.getUserId(), packageName);\n         synchronized (ret.mLock) {\n             ret.mIsAppSearchSchemaUpToDate = ShortcutService.parseIntAttribute(\n                     parser, ATTR_SCHEMA_VERSON, 0) == AppSearchShortcutInfo.SCHEMA_VERSION;\n \n             ret.mApiCallCount = ShortcutService.parseIntAttribute(parser, ATTR_CALL_COUNT);\n             ret.mLastResetTime = ShortcutService.parseLongAttribute(parser, ATTR_LAST_RESET);\n \n             final int outerDepth = parser.getDepth();\n             int type;\n             while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                     && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                 if (type != XmlPullParser.START_TAG) {\n                     continue;\n                 }\n                 final int depth = parser.getDepth();\n                 final String tag = parser.getName();\n                 if (depth == outerDepth + 1) {\n                     switch (tag) {\n                         case ShortcutPackageInfo.TAG_ROOT:\n                             ret.getPackageInfo().loadFromXml(parser, fromBackup);\n \n                             continue;\n                         case TAG_SHORTCUT:\n+                            try {\n-                            final ShortcutInfo si = parseShortcut(parser, packageName,\n+                                final ShortcutInfo si = parseShortcut(parser, packageName,\n-                                    shortcutUser.getUserId(), fromBackup);\n+                                        shortcutUser.get",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a bug where malformed shortcuts could cause a system crash, leading to a boot loop. The fix adds exception handling to ignore such malformed entries, preventing crashes. While it affects system availability, it's a bug fix rather than a security vulnerability.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.85"
}