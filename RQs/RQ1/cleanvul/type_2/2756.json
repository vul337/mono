{
  "id": 2756,
  "language": "Java",
  "commit_url": "https://github.com/nuxeo/nuxeo/commit/ae007bcf6cba019158b29a3398fbb3e7cfec9f23",
  "commit_sha": "ae007bcf6cba019158b29a3398fbb3e7cfec9f23",
  "commit_msg": "NXP-30260: avoid infinite loop in DirectoryEntryResolver#getReference",
  "pr_url": "https://github.com/Blaquez-home/nuxeo/pull/3",
  "pr_info": "- made it possible to use the commit message on tag + post commit message\n- added Jenkins scripts to make it easier to follow bugfixes and share scripts between jobs\n- do not try to any terminal size and use 80 as width\n- fixed parsing of options (but remaining bug when using single quotes in the commit message for instance)\n- fixed badly NO_STAGGING option usage so that deploy of maven artifacts + push on repo are only done when performing the release (otherwise setting the -d option on prepare will deploy artifacts twice when calling perform after)\n- made the build fail if an error happens when calling release scripts\n",
  "file_name": "nuxeo-services/nuxeo-platform-directory/nuxeo-platform-directory-core/src/main/java/org/nuxeo/ecm/directory/DirectoryEntryResolver.java",
  "func_name": "IllegalStateException",
  "func_before": "@Override\n    public Serializable getReference(Object entity) throws IllegalStateException {\n        checkConfig();\n        DocumentModel entry = null;\n        if (entity != null) {\n            if (entity instanceof DirectoryEntry) {\n                entry = ((DirectoryEntry) entity).getDocumentModel();\n            } else if (entity instanceof DocumentModel) {\n                entry = (DocumentModel) entity;\n            }\n            if (entry != null) {\n                if (!entry.hasSchema(schema)) {\n                    return null;\n                }\n                String result = (String) entry.getProperty(schema, idField);\n                if (hierarchical) {\n                    String parent = (String) entry.getProperty(schema, parentField);\n                    try (Session session = getDirectory().getSession()) {\n                        while (parent != null) {\n                            String finalParent = parent; // Effectively final\n                            entry = Framework.doPrivileged(() -> session.getEntry(finalParent));\n                            if (entry == null) {\n                                break;\n                            }\n                            result = parent + separator + result;\n                            parent = (String) entry.getProperty(schema, parentField);\n                        }\n                    }\n                }\n                return result;\n            }\n        }\n        return null;\n    }",
  "func_after": "@Override\n    public Serializable getReference(Object entity) throws IllegalStateException {\n        checkConfig();\n        DocumentModel entry = null;\n        if (entity != null) {\n            if (entity instanceof DirectoryEntry) {\n                entry = ((DirectoryEntry) entity).getDocumentModel();\n            } else if (entity instanceof DocumentModel) {\n                entry = (DocumentModel) entity;\n            }\n            if (entry != null) {\n                if (!entry.hasSchema(schema)) {\n                    return null;\n                }\n\n                return hierarchical ? getHierarchicalReference(entry) : (String) entry.getProperty(schema, idField);\n            }\n        }\n        return null;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public Serializable getReference(Object entity) throws IllegalStateException {\n         checkConfig();\n         DocumentModel entry = null;\n         if (entity != null) {\n             if (entity instanceof DirectoryEntry) {\n                 entry = ((DirectoryEntry) entity).getDocumentModel();\n             } else if (entity instanceof DocumentModel) {\n                 entry = (DocumentModel) entity;\n             }\n             if (entry != null) {\n                 if (!entry.hasSchema(schema)) {\n                     return null;\n                 }\n+\n+                return hierarchical ? getHierarchicalReference(entry) : (String) entry.getProperty(schema, idField);\n-                String result = (String) entry.getProperty(schema, idField);\n-                if (hierarchical) {\n-                    String parent = (String) entry.getProperty(schema, parentField);\n-                    try (Session session = getDirectory().getSession()) {\n-                        while (parent != null) {\n-                            String finalParent = parent; // Effectively final\n-                            entry = Framework.doPrivileged(() -> session.getEntry(finalParent));\n-                            if (entry == null) {\n-                                break;\n-                            }\n-                            result = parent + separator + result;\n-                            parent = (String) entry.getProperty(schema, parentField);\n-                        }\n-                    }\n-                }\n-                return result;\n             }\n         }\n         return null;\n     }",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\nThe patch addresses an infinite loop in a method that could lead to a denial of service. While the loop could be triggered by cyclic parent references, the lack of evidence that these references are attacker-controllable makes it a performance bug rather than a security vulnerability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.7"
}