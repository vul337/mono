{
  "id": 4942,
  "language": "C/C++",
  "commit_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062",
  "commit_sha": "8108e0a6db133f3375608303fdd2083eb5115062",
  "commit_msg": "cipher: don't set dummy encryption key in Cipher#initialize\n\nRemove the encryption key initialization from Cipher#initialize. This\nis effectively a revert of r32723 (\"Avoid possible SEGV from AES\nencryption/decryption\", 2011-07-28).\n\nr32723, which added the key initialization, was a workaround for\nRuby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()\nbefore setting an encryption key caused segfault. It was not a problem\nuntil OpenSSL implemented GCM mode - the encryption key could be\noverridden by repeated calls of EVP_CipherInit_ex(). But, it is not the\ncase for AES-GCM ciphers. Setting a key, an IV, a key, in this order\ncauses the IV to be reset to an all-zero IV.\n\nThe problem of Bug #2768 persists on the current versions of OpenSSL.\nSo, make Cipher#update raise an exception if a key is not yet set by the\nuser. Since encrypting or decrypting without key does not make any\nsense, this should not break existing applications.\n\nUsers can still call Cipher#key= and Cipher#iv= multiple times with\ntheir own responsibility.\n\nReference: https://bugs.ruby-lang.org/issues/2768\nReference: https://bugs.ruby-lang.org/issues/8221\nReference: https://github.com/ruby/openssl/issues/49",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "ext/openssl/ossl_cipher.c",
  "func_name": "ossl_cipher_set_key",
  "func_before": "static VALUE\nossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return key;\n}",
  "func_after": "static VALUE\nossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    rb_ivar_set(self, id_key_set, Qtrue);\n\n    return key;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static VALUE\n ossl_cipher_set_key(VALUE self, VALUE key)\n {\n     EVP_CIPHER_CTX *ctx;\n     int key_len;\n \n     StringValue(key);\n     GetCipher(self, ctx);\n \n     key_len = EVP_CIPHER_CTX_key_length(ctx);\n     if (RSTRING_LEN(key) != key_len)\n \tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n \n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return key;\n }",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a bug related to cipher initialization by removing a dummy key setup and adding a check for a properly set key. This prevents crashes but doesn't fix a security vulnerability.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.85"
}