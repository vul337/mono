{
  "id": 7161,
  "language": "C/C++",
  "commit_url": "https://github.com/VirusTotal/yara/commit/d438c8a8ba9d7bba105c3bb8bc294ccd0b70c5ba",
  "commit_sha": "d438c8a8ba9d7bba105c3bb8bc294ccd0b70c5ba",
  "commit_msg": "Fix issue #646 (#648)\n\n* Fix issue #646 and some edge cases with wide regexps using \\b and \\B\n\n* Rename function IS_WORD_CHAR to _yr_re_is_word_char",
  "pr_url": "https://github.com/VirusTotal/yara/pull/713",
  "pr_info": "Show warnings even on \".+\" in regexp",
  "file_name": "libyara/re.c",
  "func_name": "yr_re_exec",
  "func_before": "int yr_re_exec(\n    uint8_t* re_code,\n    uint8_t* input_data,\n    size_t input_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args)\n{\n  uint8_t* ip;\n  uint8_t* input;\n  uint8_t mask;\n  uint8_t value;\n\n  RE_FIBER_LIST fibers;\n  RE_THREAD_STORAGE* storage;\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n\n  int error;\n  int bytes_matched;\n  int max_bytes_matched;\n  int match;\n  int character_size;\n  int input_incr;\n  int kill;\n  int action;\n  int result = -1;\n\n  #define ACTION_NONE       0\n  #define ACTION_CONTINUE   1\n  #define ACTION_KILL       2\n  #define ACTION_KILL_TAIL  3\n\n  #define prolog if (bytes_matched >= max_bytes_matched) \\\n      { \\\n        action = ACTION_KILL; \\\n        break; \\\n      }\n\n  #define fail_if_error(e) switch (e) { \\\n        case ERROR_INSUFFICIENT_MEMORY: \\\n          return -2; \\\n        case ERROR_TOO_MANY_RE_FIBERS: \\\n          return -4; \\\n      }\n\n  if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n    return -2;\n\n  if (flags & RE_FLAGS_WIDE)\n    character_size = 2;\n  else\n    character_size = 1;\n\n  input = input_data;\n  input_incr = character_size;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n  {\n    input -= character_size;\n    input_incr = -input_incr;\n  }\n\n  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);\n\n  // Round down max_bytes_matched to a multiple of character_size, this way if\n  // character_size is 2 and input_size is odd we are ignoring the\n  // extra byte which can't match anyways.\n\n  max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n  bytes_matched = 0;\n\n  error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n  fail_if_error(error);\n\n  fiber->ip = re_code;\n  fibers.head = fiber;\n  fibers.tail = fiber;\n\n  error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n  fail_if_error(error);\n\n  while (fibers.head != NULL)\n  {\n    fiber = fibers.head;\n\n    while(fiber != NULL)\n    {\n      ip = fiber->ip;\n      action = ACTION_NONE;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_ANY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_GREEDY:\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n\n          // The instruction pointer is not incremented here. The current fiber\n          // spins in this instruction until reaching the required number of\n          // repetitions. The code controlling the number of repetitions is in\n          // _yr_re_fiber_sync.\n\n          break;\n\n        case RE_OPCODE_LITERAL:\n          prolog;\n          if (flags & RE_FLAGS_NO_CASE)\n            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];\n          else\n            match = (*input == *(ip + 1));\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 2;\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n          prolog;\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          // We don't need to take into account the case-insensitive\n          // case because this opcode is only used with hex strings,\n          // which can't be case-insensitive.\n\n          match = ((*input & mask) == value);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 3;\n          break;\n\n        case RE_OPCODE_CLASS:\n          prolog;\n          match = CHAR_IN_CLASS(*input, ip + 1);\n          if (!match && (flags & RE_FLAGS_NO_CASE))\n            match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 33;\n          break;\n\n        case RE_OPCODE_WORD_CHAR:\n          prolog;\n          match = IS_WORD_CHAR(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_WORD_CHAR:\n          prolog;\n          match = !IS_WORD_CHAR(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_SPACE:\n        case RE_OPCODE_NON_SPACE:\n\n          prolog;\n\n          switch(*input)\n          {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n            case '\\v':\n            case '\\f':\n              match = TRUE;\n              break;\n            default:\n              match = FALSE;\n          }\n\n          if (*ip == RE_OPCODE_NON_SPACE)\n            match = !match;\n\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_DIGIT:\n          prolog;\n          match = isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_DIGIT:\n          prolog;\n          match = !isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_WORD_BOUNDARY:\n        case RE_OPCODE_NON_WORD_BOUNDARY:\n\n          if (bytes_matched == 0 &&\n              !(flags & RE_FLAGS_NOT_AT_START) &&\n              !(flags & RE_FLAGS_BACKWARDS))\n            match = TRUE;\n          else if (bytes_matched >= max_bytes_matched)\n            match = TRUE;\n          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))\n            match = TRUE;\n          else\n            match = FALSE;\n\n          if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n            match = !match;\n\n          action = match ? ACTION_CONTINUE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_START:\n          if (flags & RE_FLAGS_BACKWARDS)\n            kill = input_size > (size_t) bytes_matched;\n          else\n            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_END:\n          kill = flags & RE_FLAGS_BACKWARDS ||\n                 input_size > (size_t) bytes_matched;\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH:\n\n          result = bytes_matched;\n\n          if (flags & RE_FLAGS_EXHAUSTIVE)\n          {\n            if (callback != NULL)\n            {\n              int cb_result;\n\n              if (flags & RE_FLAGS_BACKWARDS)\n                cb_result = callback(\n                    input + character_size,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n              else\n                cb_result = callback(\n                    input_data,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n\n              switch(cb_result)\n              {\n                case ERROR_INSUFFICIENT_MEMORY:\n                  return -2;\n                case ERROR_TOO_MANY_MATCHES:\n                  return -3;\n                default:\n                  if (cb_result != ERROR_SUCCESS)\n                    return -4;\n              }\n            }\n\n            action = ACTION_KILL;\n          }\n          else\n          {\n            action = ACTION_KILL_TAIL;\n          }\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n\n      switch(action)\n      {\n        case ACTION_KILL:\n          fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);\n          break;\n\n        case ACTION_KILL_TAIL:\n          _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);\n          fiber = NULL;\n          break;\n\n        case ACTION_CONTINUE:\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          break;\n\n        default:\n          next_fiber = fiber->next;\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          fiber = next_fiber;\n      }\n    }\n\n    if (flags & RE_FLAGS_WIDE &&\n        bytes_matched < max_bytes_matched &&\n        *(input + 1) != 0)\n    {\n      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);\n    }\n\n    input += input_incr;\n    bytes_matched += character_size;\n\n    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)\n    {\n      error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n      fail_if_error(error);\n\n      fiber->ip = re_code;\n      _yr_re_fiber_append(&fibers, fiber);\n\n      error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n      fail_if_error(error);\n    }\n  }\n\n  return result;\n}",
  "func_after": "int yr_re_exec(\n    uint8_t* re_code,\n    uint8_t* input_data,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args)\n{\n  uint8_t* ip;\n  uint8_t* input;\n  uint8_t mask;\n  uint8_t value;\n\n  RE_FIBER_LIST fibers;\n  RE_THREAD_STORAGE* storage;\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n\n  int error;\n  int bytes_matched;\n  int max_bytes_matched;\n  int match;\n  int character_size;\n  int input_incr;\n  int kill;\n  int action;\n  int result = -1;\n\n  #define ACTION_NONE       0\n  #define ACTION_CONTINUE   1\n  #define ACTION_KILL       2\n  #define ACTION_KILL_TAIL  3\n\n  #define prolog { \\\n      if ((bytes_matched >= max_bytes_matched) || \\\n          (character_size == 2 && *(input + 1) != 0)) \\\n      { \\\n        action = ACTION_KILL; \\\n        break; \\\n      } \\\n    }\n\n  #define fail_if_error(e) { \\\n      switch (e) { \\\n        case ERROR_INSUFFICIENT_MEMORY: \\\n          return -2; \\\n        case ERROR_TOO_MANY_RE_FIBERS: \\\n          return -4; \\\n      } \\\n    }\n\n  if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n    return -2;\n\n  if (flags & RE_FLAGS_WIDE)\n    character_size = 2;\n  else\n    character_size = 1;\n\n  input = input_data;\n  input_incr = character_size;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n  {\n    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);\n    input -= character_size;\n    input_incr = -input_incr;\n  }\n  else\n  {\n    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);\n  }\n\n  // Round down max_bytes_matched to a multiple of character_size, this way if\n  // character_size is 2 and max_bytes_matched is odd we are ignoring the\n  // extra byte which can't match anyways.\n\n  max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n  bytes_matched = 0;\n\n  error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n  fail_if_error(error);\n\n  fiber->ip = re_code;\n  fibers.head = fiber;\n  fibers.tail = fiber;\n\n  error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n  fail_if_error(error);\n\n  while (fibers.head != NULL)\n  {\n    fiber = fibers.head;\n\n    while(fiber != NULL)\n    {\n      ip = fiber->ip;\n      action = ACTION_NONE;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_ANY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_GREEDY:\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n\n          // The instruction pointer is not incremented here. The current fiber\n          // spins in this instruction until reaching the required number of\n          // repetitions. The code controlling the number of repetitions is in\n          // _yr_re_fiber_sync.\n\n          break;\n\n        case RE_OPCODE_LITERAL:\n          prolog;\n          if (flags & RE_FLAGS_NO_CASE)\n            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];\n          else\n            match = (*input == *(ip + 1));\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 2;\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n          prolog;\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          // We don't need to take into account the case-insensitive\n          // case because this opcode is only used with hex strings,\n          // which can't be case-insensitive.\n\n          match = ((*input & mask) == value);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 3;\n          break;\n\n        case RE_OPCODE_CLASS:\n          prolog;\n          match = CHAR_IN_CLASS(*input, ip + 1);\n          if (!match && (flags & RE_FLAGS_NO_CASE))\n            match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 33;\n          break;\n\n        case RE_OPCODE_WORD_CHAR:\n          prolog;\n          match = _yr_re_is_word_char(input, character_size);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_WORD_CHAR:\n          prolog;\n          match = !_yr_re_is_word_char(input, character_size);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_SPACE:\n        case RE_OPCODE_NON_SPACE:\n\n          prolog;\n\n          switch(*input)\n          {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n            case '\\v':\n            case '\\f':\n              match = TRUE;\n              break;\n            default:\n              match = FALSE;\n          }\n\n          if (*ip == RE_OPCODE_NON_SPACE)\n            match = !match;\n\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_DIGIT:\n          prolog;\n          match = isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_DIGIT:\n          prolog;\n          match = !isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_WORD_BOUNDARY:\n        case RE_OPCODE_NON_WORD_BOUNDARY:\n\n          if (bytes_matched == 0 && input_backwards_size < character_size)\n          {\n            match = TRUE;\n          }\n          else if (bytes_matched >= max_bytes_matched)\n          {\n            match = TRUE;\n          }\n          else\n          {\n            assert(input <  input_data + input_forwards_size);\n            assert(input >= input_data - input_backwards_size);\n\n            assert(input - input_incr <  input_data + input_forwards_size);\n            assert(input - input_incr >= input_data - input_backwards_size);\n\n            match = _yr_re_is_word_char(input, character_size) != \\\n                    _yr_re_is_word_char(input - input_incr, character_size);\n          }\n\n          if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n            match = !match;\n\n          action = match ? ACTION_CONTINUE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_START:\n          if (flags & RE_FLAGS_BACKWARDS)\n            kill = input_backwards_size > (size_t) bytes_matched;\n          else\n            kill = input_backwards_size > 0 || (bytes_matched != 0);\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_END:\n          kill = flags & RE_FLAGS_BACKWARDS ||\n                 input_forwards_size > (size_t) bytes_matched;\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH:\n\n          result = bytes_matched;\n\n          if (flags & RE_FLAGS_EXHAUSTIVE)\n          {\n            if (callback != NULL)\n            {\n              int cb_result;\n\n              if (flags & RE_FLAGS_BACKWARDS)\n                cb_result = callback(\n                    input + character_size,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n              else\n                cb_result = callback(\n                    input_data,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n\n              switch(cb_result)\n              {\n                case ERROR_INSUFFICIENT_MEMORY:\n                  return -2;\n                case ERROR_TOO_MANY_MATCHES:\n                  return -3;\n                default:\n                  if (cb_result != ERROR_SUCCESS)\n                    return -4;\n              }\n            }\n\n            action = ACTION_KILL;\n          }\n          else\n          {\n            action = ACTION_KILL_TAIL;\n          }\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n\n      switch(action)\n      {\n        case ACTION_KILL:\n          fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);\n          break;\n\n        case ACTION_KILL_TAIL:\n          _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);\n          fiber = NULL;\n          break;\n\n        case ACTION_CONTINUE:\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          break;\n\n        default:\n          next_fiber = fiber->next;\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          fiber = next_fiber;\n      }\n    }\n\n    input += input_incr;\n    bytes_matched += character_size;\n\n    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)\n    {\n      error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n      fail_if_error(error);\n\n      fiber->ip = re_code;\n      _yr_re_fiber_append(&fibers, fiber);\n\n      error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n      fail_if_error(error);\n    }\n  }\n\n  return result;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int yr_re_exec(\n     uint8_t* re_code,\n     uint8_t* input_data,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n {\n   uint8_t* ip;\n   uint8_t* input;\n   uint8_t mask;\n   uint8_t value;\n \n   RE_FIBER_LIST fibers;\n   RE_THREAD_STORAGE* storage;\n   RE_FIBER* fiber;\n   RE_FIBER* next_fiber;\n \n   int error;\n   int bytes_matched;\n   int max_bytes_matched;\n   int match;\n   int character_size;\n   int input_incr;\n   int kill;\n   int action;\n   int result = -1;\n \n   #define ACTION_NONE       0\n   #define ACTION_CONTINUE   1\n   #define ACTION_KILL       2\n   #define ACTION_KILL_TAIL  3\n \n+  #define prolog { \\\n-  #define prolog if (bytes_matched >= max_bytes_matched) \\\n+      if ((bytes_matched >= max_bytes_matched) || \\\n+          (character_size == 2 && *(input + 1) != 0)) \\\n       { \\\n         action = ACTION_KILL; \\\n         break; \\\n-      }\n+      } \\\n+    }\n \n-  #define fail_if_error(e) switch (e) { \\\n+  #define fail_if_error(e) { \\\n+      switch (e) { \\\n         case ERROR_INSUFFICIENT_MEMORY: \\\n           return -2; \\\n         case ERROR_TOO_MANY_RE_FIBERS: \\\n           return -4; \\\n-      }\n+      } \\\n+    }\n \n   if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n     return -2;\n \n   if (flags & RE_FLAGS_WIDE)\n     character_size = 2;\n   else\n     character_size = 1;\n \n   input = input_data;\n   input_incr = character_size;\n \n   if (flags & RE_FLAGS_BACKWARDS)\n   {\n+    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);\n     input -= character_size;\n     input_incr = -input_incr;\n   }\n-\n+  else\n+  {\n-  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);\n+    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);\n+  }\n \n   // Round down max_bytes_matched to a multiple of character_size, this way if\n-  // character_size is 2 and input_size is odd we are ignoring the\n+  // ",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n1. The commit message indicates a fix for issue #646, addressing edge cases with wide regexps using \\b and \\B, and renaming a function.\n2. The code diff modifies the function parameters, adds input_forwards_size and input_backwards_size, and adjusts how max_bytes_matched is calculated based on flags.\n3. Changes include redefining macros prolog and fail_if_error, adding braces and conditions.\n4. The primary purpose is to improve regex processing, specifically handling word boundaries in wide regexps.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.9"
}