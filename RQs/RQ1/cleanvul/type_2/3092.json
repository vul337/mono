{
  "id": 3092,
  "language": "Java",
  "commit_url": "https://github.com/BG-Software-LLC/WildStacker/commit/9b63a964dc0b78b1a6a49738f4214ffb4fdf0df4",
  "commit_sha": "9b63a964dc0b78b1a6a49738f4214ffb4fdf0df4",
  "commit_msg": "Fixed entities spawn from spawners bypass minimum-required checks (#670)",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "v1_7_R4/src/main/java/com/bgsoftware/wildstacker/nms/v1_7_R4/spawner/StackedMobSpawner.java",
  "func_name": "g",
  "func_before": "@Override\n    public void g() {\n        WStackedSpawner stackedSpawner = this.stackedSpawner.get();\n\n        if (stackedSpawner == null) {\n            super.g();\n            return;\n        }\n\n        if (!hasNearbyPlayers()) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"No nearby players in range (\" + this.requiredPlayerRange + \")\");\n            failureReason = \"There are no nearby players.\";\n            return;\n        }\n\n        if (this.spawnDelay == -1)\n            resetSpawnDelay();\n\n        if (this.spawnDelay > 0) {\n            --this.spawnDelay;\n            return;\n        }\n\n        if (demoEntity == null) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"Demo entity is null\");\n            super.g();\n            return;\n        }\n\n        Entity demoNMSEntity = ((CraftEntity) demoEntity.getLivingEntity()).getHandle();\n        String entityType = EntityTypes.b(demoNMSEntity);\n\n        if (entityType == null || !entityType.equals(getMobName())) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"No valid entity to spawn\");\n            updateDemoEntity();\n\n            if (demoEntity == null) {\n                if (stackedSpawner.isDebug())\n                    Debug.debug(\"StackedMobSpawner\", \"g\", \"Demo entity is null after trying to update it\");\n                super.g();\n                return;\n            }\n\n            updateUpgrade(stackedSpawner.getUpgradeId());\n\n            demoNMSEntity = ((CraftEntity) demoEntity.getLivingEntity()).getHandle();\n        }\n\n        int stackAmount = stackedSpawner.getStackAmount();\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"stackAmount=\" + stackAmount);\n\n        //noinspection unchecked\n        List<? extends Entity> nearbyEntities = world.a(demoNMSEntity.getClass(), AxisAlignedBB.a(\n                position.x, position.y, position.z,\n                position.x + 1, position.y + 1, position.z + 1\n        ).grow(this.spawnRange, this.spawnRange, this.spawnRange));\n\n        StackedEntity targetEntity = getTargetEntity(stackedSpawner, demoEntity, nearbyEntities);\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"targetEntity=\" + targetEntity);\n\n        if (targetEntity == null && nearbyEntities.size() >= this.maxNearbyEntities) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"There are too many nearby entities (\" + nearbyEntities.size() + \">\" + this.maxNearbyEntities + \")\");\n            failureReason = \"There are too many nearby entities.\";\n            return;\n        }\n\n        boolean spawnStacked = EventsCaller.callSpawnerStackedEntitySpawnEvent(stackedSpawner.getSpawner());\n        failureReason = \"\";\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"spawnStacked=\" + spawnStacked);\n\n        int spawnCount = !spawnStacked || !demoEntity.isCached() ? Random.nextInt(1, this.spawnCount, stackAmount) :\n                Random.nextInt(1, this.spawnCount, stackAmount, 1.5);\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"spawnCount=\" + spawnCount);\n\n        int amountPerEntity = 1;\n        int mobsToSpawn;\n\n        short particlesAmount = 0;\n\n        // Try stacking into the target entity first\n        if (targetEntity != null && EventsCaller.callEntityStackEvent(targetEntity, demoEntity)) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"Stacking into the target entity\");\n\n            int targetEntityStackLimit = targetEntity.getStackLimit();\n            int currentStackAmount = targetEntity.getStackAmount();\n            int increaseStackAmount = Math.min(spawnCount, targetEntityStackLimit - currentStackAmount);\n\n            if (increaseStackAmount != spawnCount) {\n                mobsToSpawn = spawnCount - increaseStackAmount;\n            } else {\n                mobsToSpawn = 0;\n            }\n\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"increaseStackAmount=\" + increaseStackAmount);\n\n            if (increaseStackAmount > 0) {\n                spawnedEntities += increaseStackAmount;\n\n                targetEntity.increaseStackAmount(increaseStackAmount, true);\n                demoEntity.spawnStackParticle(true);\n\n                if (plugin.getSettings().linkedEntitiesEnabled && targetEntity.getLivingEntity() != stackedSpawner.getLinkedEntity())\n                    stackedSpawner.setLinkedEntity(targetEntity.getLivingEntity());\n\n                world.triggerEffect(2004, position.x, position.y, position.z, 0);\n                particlesAmount++;\n            }\n        } else {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"Stacking naturally\");\n            mobsToSpawn = spawnCount;\n        }\n\n        if (mobsToSpawn > 0 && demoEntity.isCached() && spawnStacked) {\n            amountPerEntity = Math.min(mobsToSpawn, demoEntity.getStackLimit());\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"amountPerEntity=\" + amountPerEntity);\n            mobsToSpawn = mobsToSpawn / amountPerEntity;\n        }\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"mobsToSpawn=\" + mobsToSpawn);\n\n        while (spawnedEntities < stackAmount) {\n            if (!attemptMobSpawning(mobsToSpawn, amountPerEntity, spawnCount, particlesAmount, stackedSpawner))\n                return;\n        }\n\n        resetSpawnDelay();\n    }",
  "func_after": "@Override\n    public void g() {\n        WStackedSpawner stackedSpawner = this.stackedSpawner.get();\n\n        if (stackedSpawner == null) {\n            super.g();\n            return;\n        }\n\n        if (!hasNearbyPlayers()) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"No nearby players in range (\" + this.requiredPlayerRange + \")\");\n            failureReason = \"There are no nearby players.\";\n            return;\n        }\n\n        if (this.spawnDelay == -1)\n            resetSpawnDelay();\n\n        if (this.spawnDelay > 0) {\n            --this.spawnDelay;\n            return;\n        }\n\n        if (demoEntity == null) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"Demo entity is null\");\n            super.g();\n            return;\n        }\n\n        Entity demoNMSEntity = ((CraftEntity) demoEntity.getLivingEntity()).getHandle();\n        String entityType = EntityTypes.b(demoNMSEntity);\n\n        if (entityType == null || !entityType.equals(getMobName())) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"No valid entity to spawn\");\n            updateDemoEntity();\n\n            if (demoEntity == null) {\n                if (stackedSpawner.isDebug())\n                    Debug.debug(\"StackedMobSpawner\", \"g\", \"Demo entity is null after trying to update it\");\n                super.g();\n                return;\n            }\n\n            updateUpgrade(stackedSpawner.getUpgradeId());\n\n            demoNMSEntity = ((CraftEntity) demoEntity.getLivingEntity()).getHandle();\n        }\n\n        int stackAmount = stackedSpawner.getStackAmount();\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"stackAmount=\" + stackAmount);\n\n        //noinspection unchecked\n        List<? extends Entity> nearbyEntities = world.a(demoNMSEntity.getClass(), AxisAlignedBB.a(\n                position.x, position.y, position.z,\n                position.x + 1, position.y + 1, position.z + 1\n        ).grow(this.spawnRange, this.spawnRange, this.spawnRange));\n\n        AtomicInteger nearbyAndStackableCount = new AtomicInteger(0);\n        List<StackedEntity> nearbyAndStackableEntities = new LinkedList<>();\n\n        nearbyEntities.forEach(entity -> {\n            CraftEntity craftEntity = entity.getBukkitEntity();\n            if (EntityUtils.isStackable(craftEntity)) {\n                StackedEntity stackedEntity = WStackedEntity.of(craftEntity);\n                if (this.demoEntity.runStackCheck(stackedEntity) == StackCheckResult.SUCCESS) {\n                    nearbyAndStackableCount.set(nearbyAndStackableCount.get() + stackedEntity.getStackAmount());\n                    nearbyAndStackableEntities.add(stackedEntity);\n                }\n            }\n        });\n\n        StackedEntity targetEntity = getTargetEntity(stackedSpawner, this.demoEntity, nearbyAndStackableEntities);\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"targetEntity=\" + targetEntity);\n\n        if (targetEntity == null && nearbyEntities.size() >= this.maxNearbyEntities) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"There are too many nearby entities (\" + nearbyEntities.size() + \">\" + this.maxNearbyEntities + \")\");\n            failureReason = \"There are too many nearby entities.\";\n            return;\n        }\n\n        int minimumEntityRequirement = GeneralUtils.get(plugin.getSettings().minimumRequiredEntities, this.demoEntity, 1);\n\n        int stackedEntityCount = Random.nextInt(1, this.spawnCount, stackAmount, 1.5);\n\n        boolean canStackToTarget = nearbyAndStackableCount.get() + stackedEntityCount >= minimumEntityRequirement;\n\n        boolean spawnStacked = plugin.getSettings().entitiesStackingEnabled && canStackToTarget &&\n                EventsCaller.callSpawnerStackedEntitySpawnEvent(stackedSpawner.getSpawner());\n        failureReason = \"\";\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"spawnStacked=\" + spawnStacked);\n\n        int spawnCount = !spawnStacked || !demoEntity.isCached() ? Random.nextInt(1, this.spawnCount, stackAmount) :\n                stackedEntityCount;\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"spawnCount=\" + spawnCount);\n\n        int amountPerEntity = 1;\n        int mobsToSpawn;\n\n        short particlesAmount = 0;\n\n        // Try stacking into the target entity first\n        if (targetEntity != null && canStackToTarget && EventsCaller.callEntityStackEvent(targetEntity, demoEntity)) {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"Stacking into the target entity\");\n\n            int targetEntityStackLimit = targetEntity.getStackLimit();\n            int currentStackAmount = targetEntity.getStackAmount();\n            int increaseStackAmount = Math.min(spawnCount, targetEntityStackLimit - currentStackAmount);\n\n            if (increaseStackAmount != spawnCount) {\n                mobsToSpawn = spawnCount - increaseStackAmount;\n            } else {\n                mobsToSpawn = 0;\n            }\n\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"increaseStackAmount=\" + increaseStackAmount);\n\n            if (increaseStackAmount > 0) {\n                spawnedEntities += increaseStackAmount;\n\n                if (minimumEntityRequirement > 1) {\n                    // We want to stack all nearby entities into target as well.\n                    increaseStackAmount += nearbyAndStackableCount.get() - targetEntity.getStackAmount();\n                    nearbyAndStackableEntities.forEach(nearbyEntity -> {\n                        if (nearbyEntity != targetEntity) {\n                            nearbyEntity.remove();\n                            nearbyEntity.spawnStackParticle(true);\n                        }\n                    });\n                }\n\n                targetEntity.increaseStackAmount(increaseStackAmount, true);\n                demoEntity.spawnStackParticle(true);\n\n                if (plugin.getSettings().linkedEntitiesEnabled && targetEntity.getLivingEntity() != stackedSpawner.getLinkedEntity())\n                    stackedSpawner.setLinkedEntity(targetEntity.getLivingEntity());\n\n                world.triggerEffect(2004, position.x, position.y, position.z, 0);\n                particlesAmount++;\n            }\n        } else {\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"Stacking naturally\");\n            mobsToSpawn = spawnCount;\n        }\n\n        if (mobsToSpawn > 0 && demoEntity.isCached() && spawnStacked) {\n            amountPerEntity = Math.min(mobsToSpawn, demoEntity.getStackLimit());\n            if (stackedSpawner.isDebug())\n                Debug.debug(\"StackedMobSpawner\", \"g\", \"amountPerEntity=\" + amountPerEntity);\n            mobsToSpawn = mobsToSpawn / amountPerEntity;\n        }\n\n        if (stackedSpawner.isDebug())\n            Debug.debug(\"StackedMobSpawner\", \"g\", \"mobsToSpawn=\" + mobsToSpawn);\n\n        while (spawnedEntities < stackAmount) {\n            if (!attemptMobSpawning(mobsToSpawn, amountPerEntity, spawnCount, particlesAmount, stackedSpawner))\n                return;\n        }\n\n        resetSpawnDelay();\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public void g() {\n         WStackedSpawner stackedSpawner = this.stackedSpawner.get();\n \n         if (stackedSpawner == null) {\n             super.g();\n             return;\n         }\n \n         if (!hasNearbyPlayers()) {\n             if (stackedSpawner.isDebug())\n                 Debug.debug(\"StackedMobSpawner\", \"g\", \"No nearby players in range (\" + this.requiredPlayerRange + \")\");\n             failureReason = \"There are no nearby players.\";\n             return;\n         }\n \n         if (this.spawnDelay == -1)\n             resetSpawnDelay();\n \n         if (this.spawnDelay > 0) {\n             --this.spawnDelay;\n             return;\n         }\n \n         if (demoEntity == null) {\n             if (stackedSpawner.isDebug())\n                 Debug.debug(\"StackedMobSpawner\", \"g\", \"Demo entity is null\");\n             super.g();\n             return;\n         }\n \n         Entity demoNMSEntity = ((CraftEntity) demoEntity.getLivingEntity()).getHandle();\n         String entityType = EntityTypes.b(demoNMSEntity);\n \n         if (entityType == null || !entityType.equals(getMobName())) {\n             if (stackedSpawner.isDebug())\n                 Debug.debug(\"StackedMobSpawner\", \"g\", \"No valid entity to spawn\");\n             updateDemoEntity();\n \n             if (demoEntity == null) {\n                 if (stackedSpawner.isDebug())\n                     Debug.debug(\"StackedMobSpawner\", \"g\", \"Demo entity is null after trying to update it\");\n                 super.g();\n                 return;\n             }\n \n             updateUpgrade(stackedSpawner.getUpgradeId());\n \n             demoNMSEntity = ((CraftEntity) demoEntity.getLivingEntity()).getHandle();\n         }\n \n         int stackAmount = stackedSpawner.getStackAmount();\n \n         if (stackedSpawner.isDebug())\n             Debug.debug(\"StackedMobSpawner\", \"g\", \"stackAmount=\" + stackAmount);\n \n         //noinspection unchecked\n         List<? extends Entity> nearbyEntities = world.a",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an issue where entities were spawning without proper validation. It adds checks to ensure entities meet required conditions before spawning, potentially preventing invalid entities from spawning. While this could have security implications, the context isn't clear enough to classify it as a security fix.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.7"
}