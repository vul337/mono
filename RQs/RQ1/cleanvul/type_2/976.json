{
  "id": 976,
  "language": "Java",
  "commit_url": "https://github.com/AutoMQ/automq/commit/dc011992712805e22009bbc3eb81be81228ed0b9",
  "commit_sha": "dc011992712805e22009bbc3eb81be81228ed0b9",
  "commit_msg": "KAFAK-14660: Fix divide-by-zero vulnerability (#13175)\n\nThis PR adds a safe-guard for divide-by-zero. While `totalCapacity` can never be zero, an explicit error message is desirable.\r\n\r\nReviewers: Bill Bejeck <bill@confluent.io>, Guozhang Wang <guozhang@confluent.io>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignor.java",
  "func_name": "assignActive",
  "func_before": "private void assignActive() {\n        final int totalCapacity = sumCapacity(clients.values());\n        final int tasksPerThread = allTaskIds.size() / totalCapacity;\n        final Set<TaskId> assigned = new HashSet<>();\n\n        // first try and re-assign existing active tasks to clients that previously had\n        // the same active task\n        for (final Map.Entry<TaskId, UUID> entry : previousActiveTaskAssignment.entrySet()) {\n            final TaskId taskId = entry.getKey();\n            if (allTaskIds.contains(taskId)) {\n                final ClientState client = clients.get(entry.getValue());\n                if (mustPreserveActiveTaskAssignment || client.hasUnfulfilledQuota(tasksPerThread)) {\n                    assignTaskToClient(assigned, taskId, client);\n                }\n            }\n        }\n\n        final Set<TaskId> unassigned = new HashSet<>(allTaskIds);\n        unassigned.removeAll(assigned);\n\n        // try and assign any remaining unassigned tasks to clients that previously\n        // have seen the task.\n        for (final Iterator<TaskId> iterator = unassigned.iterator(); iterator.hasNext(); ) {\n            final TaskId taskId = iterator.next();\n            final Set<UUID> clientIds = previousStandbyTaskAssignment.get(taskId);\n            if (clientIds != null) {\n                for (final UUID clientId : clientIds) {\n                    final ClientState client = clients.get(clientId);\n                    if (client.hasUnfulfilledQuota(tasksPerThread)) {\n                        assignTaskToClient(assigned, taskId, client);\n                        iterator.remove();\n                        break;\n                    }\n                }\n            }\n        }\n\n        // assign any remaining unassigned tasks\n        final List<TaskId> sortedTasks = new ArrayList<>(unassigned);\n        Collections.sort(sortedTasks);\n        for (final TaskId taskId : sortedTasks) {\n            allocateTaskWithClientCandidates(taskId, clients.keySet(), true);\n        }\n    }",
  "func_after": "private void assignActive() {\n        final int totalCapacity = sumCapacity(clients.values());\n        if (totalCapacity == 0) {\n            throw new IllegalStateException(\"`totalCapacity` should never be zero.\");\n        }\n\n        final int tasksPerThread = allTaskIds.size() / totalCapacity;\n        final Set<TaskId> assigned = new HashSet<>();\n\n        // first try and re-assign existing active tasks to clients that previously had\n        // the same active task\n        for (final Map.Entry<TaskId, UUID> entry : previousActiveTaskAssignment.entrySet()) {\n            final TaskId taskId = entry.getKey();\n            if (allTaskIds.contains(taskId)) {\n                final ClientState client = clients.get(entry.getValue());\n                if (mustPreserveActiveTaskAssignment || client.hasUnfulfilledQuota(tasksPerThread)) {\n                    assignTaskToClient(assigned, taskId, client);\n                }\n            }\n        }\n\n        final Set<TaskId> unassigned = new HashSet<>(allTaskIds);\n        unassigned.removeAll(assigned);\n\n        // try and assign any remaining unassigned tasks to clients that previously\n        // have seen the task.\n        for (final Iterator<TaskId> iterator = unassigned.iterator(); iterator.hasNext(); ) {\n            final TaskId taskId = iterator.next();\n            final Set<UUID> clientIds = previousStandbyTaskAssignment.get(taskId);\n            if (clientIds != null) {\n                for (final UUID clientId : clientIds) {\n                    final ClientState client = clients.get(clientId);\n                    if (client.hasUnfulfilledQuota(tasksPerThread)) {\n                        assignTaskToClient(assigned, taskId, client);\n                        iterator.remove();\n                        break;\n                    }\n                }\n            }\n        }\n\n        // assign any remaining unassigned tasks\n        final List<TaskId> sortedTasks = new ArrayList<>(unassigned);\n        Collections.sort(sortedTasks);\n        for (final TaskId taskId : sortedTasks) {\n            allocateTaskWithClientCandidates(taskId, clients.keySet(), true);\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n private void assignActive() {\n         final int totalCapacity = sumCapacity(clients.values());\n+        if (totalCapacity == 0) {\n+            throw new IllegalStateException(\"`totalCapacity` should never be zero.\");\n+        }\n+\n         final int tasksPerThread = allTaskIds.size() / totalCapacity;\n         final Set<TaskId> assigned = new HashSet<>();\n \n         // first try and re-assign existing active tasks to clients that previously had\n         // the same active task\n         for (final Map.Entry<TaskId, UUID> entry : previousActiveTaskAssignment.entrySet()) {\n             final TaskId taskId = entry.getKey();\n             if (allTaskIds.contains(taskId)) {\n                 final ClientState client = clients.get(entry.getValue());\n                 if (mustPreserveActiveTaskAssignment || client.hasUnfulfilledQuota(tasksPerThread)) {\n                     assignTaskToClient(assigned, taskId, client);\n                 }\n             }\n         }\n \n         final Set<TaskId> unassigned = new HashSet<>(allTaskIds);\n         unassigned.removeAll(assigned);\n \n         // try and assign any remaining unassigned tasks to clients that previously\n         // have seen the task.\n         for (final Iterator<TaskId> iterator = unassigned.iterator(); iterator.hasNext(); ) {\n             final TaskId taskId = iterator.next();\n             final Set<UUID> clientIds = previousStandbyTaskAssignment.get(taskId);\n             if (clientIds != null) {\n                 for (final UUID clientId : clientIds) {\n                     final ClientState client = clients.get(clientId);\n                     if (client.hasUnfulfilledQuota(tasksPerThread)) {\n                         assignTaskToClient(assigned, taskId, client);\n                         iterator.remove();\n                         break;\n                     }\n                 }\n             }\n         }\n \n         // assign any remaining unassigned tasks\n         final List<TaskId> sortedTasks",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a divide-by-zero issue by adding a check for `totalCapacity` being zero. While the commit message labels it as a vulnerability, the code change primarily prevents a crash, which may not be a security issue unless exploitable. Given the lack of evidence on exploitability, it's classified as a defect fix.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.8"
}