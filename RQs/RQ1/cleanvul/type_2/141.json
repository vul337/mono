{
  "id": 141,
  "language": "Java",
  "commit_url": "https://github.com/LineageOS/android_frameworks_base/commit/74b4af53ca57a1dc5a94b1da895c8ab681ec6ecd",
  "commit_sha": "74b4af53ca57a1dc5a94b1da895c8ab681ec6ecd",
  "commit_msg": "Fix potential OOM issues when APEXs are too large.\n\nOn low RAM devices, there can be potentially OOM issues when\nAPEXs are too large, causing large buffers to be allocated when\ncomputing the SHA256 digest of those APEX packages.\n\nThis change introduces the usage of DigestInputStream with\ndifferent buffer sizes according to the state of device (whether\nit is a low ram device or not) to cap the memory usage.\n\nBuffer size is currently derived experimentally at either 1kB or\n1MB.\n\nBug: 217596264\nTest: Manual.\nChange-Id: I1964ef9d7047496a758c7f427910f116be89fc51",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/BinaryTransparencyService.java",
  "func_name": "updateBinaryMeasurements",
  "func_before": "private boolean updateBinaryMeasurements() {\n        if (mBinaryHashes.size() == 0) {\n            Slog.d(TAG, \"No apex in cache yet.\");\n            doFreshBinaryMeasurements();\n            return true;\n        }\n\n        PackageManager pm = mContext.getPackageManager();\n        if (pm == null) {\n            Slog.e(TAG, \"Failed to obtain a valid PackageManager instance.\");\n            return false;\n        }\n\n        // We're assuming updates to existing modules and APEXs can happen, but not brand new\n        // ones appearing out of the blue. Thus, we're going to only go through our cache to check\n        // for changes, rather than freshly invoking `getInstalledPackages()` and\n        // `getInstalledModules()`\n        for (Map.Entry<String, Long> entry : mBinaryLastUpdateTimes.entrySet()) {\n            String packageName = entry.getKey();\n            try {\n                PackageInfo packageInfo = pm.getPackageInfo(packageName,\n                        PackageManager.PackageInfoFlags.of(PackageManager.MATCH_APEX));\n                long cachedUpdateTime = entry.getValue();\n\n                if (packageInfo.lastUpdateTime > cachedUpdateTime) {\n                    Slog.d(TAG, packageName + \" has been updated!\");\n                    entry.setValue(packageInfo.lastUpdateTime);\n\n                    // compute the digest for the updated package\n                    String sha256digest = computeSha256DigestOfFile(\n                            packageInfo.applicationInfo.sourceDir);\n                    if (sha256digest == null) {\n                        Slog.e(TAG, \"Failed to compute SHA256sum for file at \"\n                                + packageInfo.applicationInfo.sourceDir);\n                        mBinaryHashes.put(packageName, BINARY_HASH_ERROR);\n                    } else {\n                        mBinaryHashes.put(packageName, sha256digest);\n                    }\n\n                    if (packageInfo.isApex) {\n                        FrameworkStatsLog.write(FrameworkStatsLog.APEX_INFO_GATHERED,\n                                packageInfo.packageName,\n                                packageInfo.getLongVersionCode(),\n                                mBinaryHashes.get(packageInfo.packageName));\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                Slog.e(TAG, \"Could not find package with name \" + packageName);\n                continue;\n            }\n        }\n\n        return true;\n    }",
  "func_after": "private boolean updateBinaryMeasurements() {\n        if (mBinaryHashes.size() == 0) {\n            Slog.d(TAG, \"No apex in cache yet.\");\n            doFreshBinaryMeasurements();\n            return true;\n        }\n\n        PackageManager pm = mContext.getPackageManager();\n        if (pm == null) {\n            Slog.e(TAG, \"Failed to obtain a valid PackageManager instance.\");\n            return false;\n        }\n\n        // We're assuming updates to existing modules and APEXs can happen, but not brand new\n        // ones appearing out of the blue. Thus, we're going to only go through our cache to check\n        // for changes, rather than freshly invoking `getInstalledPackages()` and\n        // `getInstalledModules()`\n        for (Map.Entry<String, Long> entry : mBinaryLastUpdateTimes.entrySet()) {\n            String packageName = entry.getKey();\n            try {\n                PackageInfo packageInfo = pm.getPackageInfo(packageName,\n                        PackageManager.PackageInfoFlags.of(PackageManager.MATCH_APEX));\n                long cachedUpdateTime = entry.getValue();\n\n                if (packageInfo.lastUpdateTime > cachedUpdateTime) {\n                    Slog.d(TAG, packageName + \" has been updated!\");\n                    entry.setValue(packageInfo.lastUpdateTime);\n\n                    // compute the digest for the updated package\n                    String sha256digest = PackageUtils.computeSha256DigestForLargeFile(\n                            packageInfo.applicationInfo.sourceDir);\n                    if (sha256digest == null) {\n                        Slog.e(TAG, \"Failed to compute SHA256sum for file at \"\n                                + packageInfo.applicationInfo.sourceDir);\n                        mBinaryHashes.put(packageName, BINARY_HASH_ERROR);\n                    } else {\n                        mBinaryHashes.put(packageName, sha256digest);\n                    }\n\n                    if (packageInfo.isApex) {\n                        FrameworkStatsLog.write(FrameworkStatsLog.APEX_INFO_GATHERED,\n                                packageInfo.packageName,\n                                packageInfo.getLongVersionCode(),\n                                mBinaryHashes.get(packageInfo.packageName));\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                Slog.e(TAG, \"Could not find package with name \" + packageName);\n                continue;\n            }\n        }\n\n        return true;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n private boolean updateBinaryMeasurements() {\n         if (mBinaryHashes.size() == 0) {\n             Slog.d(TAG, \"No apex in cache yet.\");\n             doFreshBinaryMeasurements();\n             return true;\n         }\n \n         PackageManager pm = mContext.getPackageManager();\n         if (pm == null) {\n             Slog.e(TAG, \"Failed to obtain a valid PackageManager instance.\");\n             return false;\n         }\n \n         // We're assuming updates to existing modules and APEXs can happen, but not brand new\n         // ones appearing out of the blue. Thus, we're going to only go through our cache to check\n         // for changes, rather than freshly invoking `getInstalledPackages()` and\n         // `getInstalledModules()`\n         for (Map.Entry<String, Long> entry : mBinaryLastUpdateTimes.entrySet()) {\n             String packageName = entry.getKey();\n             try {\n                 PackageInfo packageInfo = pm.getPackageInfo(packageName,\n                         PackageManager.PackageInfoFlags.of(PackageManager.MATCH_APEX));\n                 long cachedUpdateTime = entry.getValue();\n \n                 if (packageInfo.lastUpdateTime > cachedUpdateTime) {\n                     Slog.d(TAG, packageName + \" has been updated!\");\n                     entry.setValue(packageInfo.lastUpdateTime);\n \n                     // compute the digest for the updated package\n-                    String sha256digest = computeSha256DigestOfFile(\n+                    String sha256digest = PackageUtils.computeSha256DigestForLargeFile(\n                             packageInfo.applicationInfo.sourceDir);\n                     if (sha256digest == null) {\n                         Slog.e(TAG, \"Failed to compute SHA256sum for file at \"\n                                 + packageInfo.applicationInfo.sourceDir);\n                         mBinaryHashes.put(packageName, BINARY_HASH_ERROR);\n                     } else {\n                         mBinaryHashes.put",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n1. The commit addresses OOM issues caused by large APEX packages, optimizing memory usage with DigestInputStream.\n2. The fix doesn't involve attacker-controlled inputs or exploit vectors, focusing instead on resource management.\n3. The change doesn't meet security criteria but improves system stability.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.95"
}