{
  "id": 39,
  "language": "Java",
  "commit_url": "https://github.com/apache/ignite/commit/44f9464400b0725ac557f0af777acb700117e693",
  "commit_sha": "44f9464400b0725ac557f0af777acb700117e693",
  "commit_msg": "IGNITE-16581 Prevent checkpoint buffer overflow in case of the speed-based throttling\n\n- speed-based throttling had a bug that prevented it to protect CP Buffer when CP progress was not yet reported; it's fixed here\n- speed-based throttling has been heavily refactored to make it easier to understand\n- the machinery comprising and surrounding write throttling has been commented",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/pagemem/PagesWriteThrottle.java",
  "func_name": "onMarkDirty",
  "func_before": "@Override public void onMarkDirty(boolean isPageInCheckpoint) {\n        assert stateChecker.checkpointLockIsHeldByThread();\n\n        boolean shouldThrottle = false;\n\n        if (isPageInCheckpoint)\n            shouldThrottle = shouldThrottle();\n\n        if (!shouldThrottle && !throttleOnlyPagesInCheckpoint) {\n            CheckpointProgress progress = cpProgress.apply();\n\n            AtomicInteger writtenPagesCntr = progress == null ? null : cpProgress.apply().writtenPagesCounter();\n\n            if (progress == null || writtenPagesCntr == null)\n                return; // Don't throttle if checkpoint is not running.\n\n            int cpWrittenPages = writtenPagesCntr.get();\n\n            int cpTotalPages = progress.currentCheckpointPagesCount();\n\n            if (cpWrittenPages == cpTotalPages) {\n                // Checkpoint is already in fsync stage, increasing maximum ratio of dirty pages to 3/4\n                shouldThrottle = pageMemory.shouldThrottle(3.0 / 4);\n            } else {\n                double dirtyRatioThreshold = ((double)cpWrittenPages) / cpTotalPages;\n\n                // Starting with 0.05 to avoid throttle right after checkpoint start\n                // 7/12 is maximum ratio of dirty pages\n                dirtyRatioThreshold = (dirtyRatioThreshold * 0.95 + 0.05) * 7 / 12;\n\n                shouldThrottle = pageMemory.shouldThrottle(dirtyRatioThreshold);\n            }\n        }\n\n        AtomicInteger cntr = isPageInCheckpoint ? inCheckpointBackoffCntr : notInCheckpointBackoffCntr;\n\n        if (shouldThrottle) {\n            int throttleLevel = cntr.getAndIncrement();\n\n            long throttleParkTimeNs = (long)(STARTING_THROTTLE_NANOS * Math.pow(BACKOFF_RATIO, throttleLevel));\n\n            Thread curThread = Thread.currentThread();\n\n            if (throttleParkTimeNs > LOGGING_THRESHOLD) {\n                U.warn(log, \"Parking thread=\" + curThread.getName()\n                    + \" for timeout(ms)=\" + (throttleParkTimeNs / 1_000_000));\n            }\n\n            long startTime = U.currentTimeMillis();\n\n            if (isPageInCheckpoint) {\n                cpBufThrottledThreads.put(curThread.getId(), curThread);\n\n                try {\n                    LockSupport.parkNanos(throttleParkTimeNs);\n                }\n                finally {\n                    cpBufThrottledThreads.remove(curThread.getId());\n\n                    if (throttleParkTimeNs > LOGGING_THRESHOLD) {\n                        U.warn(log, \"Unparking thread=\" + curThread.getName()\n                            + \" with park timeout(ms)=\" + (throttleParkTimeNs / 1_000_000));\n                    }\n                }\n            }\n            else\n                LockSupport.parkNanos(throttleParkTimeNs);\n\n            pageMemory.metrics().addThrottlingTime(U.currentTimeMillis() - startTime);\n        }\n        else {\n            int oldCntr = cntr.getAndSet(0);\n\n            if (isPageInCheckpoint && oldCntr != 0)\n                cpBufThrottledThreads.values().forEach(LockSupport::unpark);\n        }\n    }",
  "func_after": "@Override public void onMarkDirty(boolean isPageInCheckpoint) {\n        assert stateChecker.checkpointLockIsHeldByThread();\n\n        boolean shouldThrottle = false;\n\n        if (isPageInCheckpoint)\n            shouldThrottle = isCpBufferOverflowThresholdExceeded();\n\n        if (!shouldThrottle && !throttleOnlyPagesInCheckpoint) {\n            CheckpointProgress progress = cpProgress.apply();\n\n            AtomicInteger writtenPagesCntr = progress == null ? null : cpProgress.apply().writtenPagesCounter();\n\n            if (progress == null || writtenPagesCntr == null)\n                return; // Don't throttle if checkpoint is not running.\n\n            int cpWrittenPages = writtenPagesCntr.get();\n\n            int cpTotalPages = progress.currentCheckpointPagesCount();\n\n            if (cpWrittenPages == cpTotalPages) {\n                // Checkpoint is already in fsync stage, increasing maximum ratio of dirty pages to 3/4\n                shouldThrottle = pageMemory.shouldThrottle(3.0 / 4);\n            } else {\n                double dirtyRatioThreshold = ((double)cpWrittenPages) / cpTotalPages;\n\n                // Starting with 0.05 to avoid throttle right after checkpoint start\n                // 7/12 is maximum ratio of dirty pages\n                dirtyRatioThreshold = (dirtyRatioThreshold * 0.95 + 0.05) * 7 / 12;\n\n                shouldThrottle = pageMemory.shouldThrottle(dirtyRatioThreshold);\n            }\n        }\n\n        ExponentialBackoffThrottlingStrategy exponentialThrottle = isPageInCheckpoint\n                ? inCheckpointProtection : notInCheckpointProtection;\n\n        if (shouldThrottle) {\n            long throttleParkTimeNs = exponentialThrottle.protectionParkTime();\n\n            Thread curThread = Thread.currentThread();\n\n            if (throttleParkTimeNs > LOGGING_THRESHOLD) {\n                U.warn(log, \"Parking thread=\" + curThread.getName()\n                    + \" for timeout(ms)=\" + (throttleParkTimeNs / 1_000_000));\n            }\n\n            long startTime = U.currentTimeMillis();\n\n            if (isPageInCheckpoint) {\n                cpBufThrottledThreads.put(curThread.getId(), curThread);\n\n                try {\n                    LockSupport.parkNanos(throttleParkTimeNs);\n                }\n                finally {\n                    cpBufThrottledThreads.remove(curThread.getId());\n\n                    if (throttleParkTimeNs > LOGGING_THRESHOLD) {\n                        U.warn(log, \"Unparking thread=\" + curThread.getName()\n                            + \" with park timeout(ms)=\" + (throttleParkTimeNs / 1_000_000));\n                    }\n                }\n            }\n            else\n                LockSupport.parkNanos(throttleParkTimeNs);\n\n            pageMemory.metrics().addThrottlingTime(U.currentTimeMillis() - startTime);\n        }\n        else {\n            boolean backoffWasAlreadyStarted = exponentialThrottle.resetBackoff();\n\n            if (isPageInCheckpoint && backoffWasAlreadyStarted)\n                unparkParkedThreads();\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override public void onMarkDirty(boolean isPageInCheckpoint) {\n         assert stateChecker.checkpointLockIsHeldByThread();\n \n         boolean shouldThrottle = false;\n \n         if (isPageInCheckpoint)\n-            shouldThrottle = shouldThrottle();\n+            shouldThrottle = isCpBufferOverflowThresholdExceeded();\n \n         if (!shouldThrottle && !throttleOnlyPagesInCheckpoint) {\n             CheckpointProgress progress = cpProgress.apply();\n \n             AtomicInteger writtenPagesCntr = progress == null ? null : cpProgress.apply().writtenPagesCounter();\n \n             if (progress == null || writtenPagesCntr == null)\n                 return; // Don't throttle if checkpoint is not running.\n \n             int cpWrittenPages = writtenPagesCntr.get();\n \n             int cpTotalPages = progress.currentCheckpointPagesCount();\n \n             if (cpWrittenPages == cpTotalPages) {\n                 // Checkpoint is already in fsync stage, increasing maximum ratio of dirty pages to 3/4\n                 shouldThrottle = pageMemory.shouldThrottle(3.0 / 4);\n             } else {\n                 double dirtyRatioThreshold = ((double)cpWrittenPages) / cpTotalPages;\n \n                 // Starting with 0.05 to avoid throttle right after checkpoint start\n                 // 7/12 is maximum ratio of dirty pages\n                 dirtyRatioThreshold = (dirtyRatioThreshold * 0.95 + 0.05) * 7 / 12;\n \n                 shouldThrottle = pageMemory.shouldThrottle(dirtyRatioThreshold);\n             }\n         }\n \n-        AtomicInteger cntr = isPageInCheckpoint ? inCheckpointBackoffCntr : notInCheckpointBackoffCntr;\n+        ExponentialBackoffThrottlingStrategy exponentialThrottle = isPageInCheckpoint\n+                ? inCheckpointProtection : notInCheckpointProtection;\n \n         if (shouldThrottle) {\n+            long throttleParkTimeNs = exponentialThrottle.protectionParkTime();\n-            int throttleLevel = cntr.getAndIncrement();\n-\n-            l",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses a bug causing buffer overflow during checkpointing by improving throttling mechanisms, enhancing system availability without directly mitigating a security exploit.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.9"
}