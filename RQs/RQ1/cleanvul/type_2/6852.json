{
  "id": 6852,
  "language": "C/C++",
  "commit_url": "https://github.com/wazuh/wazuh/commit/120852e9e639129b14395add74263acebc608032",
  "commit_sha": "120852e9e639129b14395add74263acebc608032",
  "commit_msg": "Replace system with wpopenv and remove unnecessary code from all involved AR scripts",
  "pr_url": "https://github.com/wazuh/wazuh/pull/10809",
  "pr_info": "|Related issue|\r\n|---|\r\n|#10858|\r\n\r\n## Description\r\n\r\nThis PR aims to fix a problem detected in some AR scripts:\r\n\r\n- On the agent side, replace `system` function calls with `wpopenv`.\r\n- On the manager side, escape the following characters in JSON alerts: **!** **$** **'** **`**\r\n\r\n## Tests\r\n\r\n<!-- Minimum checks required -->\r\n- Compilation without warnings in every supported platform\r\n  - [x] Linux\r\n  - [x] Windows\r\n  - [x] MAC OS X\r\n- [x] Source installation\r\n- [x] Source upgrade",
  "file_name": "src/active-response/firewalls/default-firewall-drop.c",
  "func_name": "main",
  "func_before": "int main (int argc, char **argv) {\n    (void)argc;\n    char iptables[COMMANDSIZE_4096];\n    char iptables_tmp[COMMANDSIZE_4096 - 5] = \"\";\n    char log_msg[OS_MAXSTR];\n    int action = OS_INVALID;\n    cJSON *input_json = NULL;\n    struct utsname uname_buffer;\n\n    action = setup_and_check_message(argv, &input_json);\n    if ((action != ADD_COMMAND) && (action != DELETE_COMMAND)) {\n        return OS_INVALID;\n    }\n\n    // Get srcip\n    const char *srcip = get_srcip_from_json(input_json);\n    if (!srcip) {\n        write_debug_file(argv[0], \"Cannot read 'srcip' from data\");\n        cJSON_Delete(input_json);\n        return OS_INVALID;\n    }\n\n    if (action == ADD_COMMAND) {\n        char **keys = NULL;\n        int action2 = OS_INVALID;\n\n        os_calloc(2, sizeof(char *), keys);\n        os_strdup(srcip, keys[0]);\n        keys[1] = NULL;\n\n        action2 = send_keys_and_check_message(argv, keys);\n\n        os_free(keys);\n\n        // If necessary, abort execution\n        if (action2 != CONTINUE_COMMAND) {\n            cJSON_Delete(input_json);\n\n            if (action2 == ABORT_COMMAND) {\n                write_debug_file(argv[0], \"Aborted\");\n                return OS_SUCCESS;\n            } else {\n                return OS_INVALID;\n            }\n        }\n    }\n\n    int ip_version = get_ip_version(srcip);\n    if (ip_version == 4) {\n        strcpy(iptables_tmp, IP4TABLES);\n    } else if (ip_version == 6) {\n        strcpy(iptables_tmp, IP6TABLES);\n    } else {\n        memset(log_msg, '\\0', OS_MAXSTR);\n        snprintf(log_msg, OS_MAXSTR -1, \"Unable to run active response (invalid IP: '%s').\", srcip);\n        write_debug_file(argv[0], log_msg);\n        cJSON_Delete(input_json);\n        return OS_INVALID;\n    }\n\n    if (uname(&uname_buffer) < 0) {\n        write_debug_file(argv[0], \"Cannot get system name\");\n        cJSON_Delete(input_json);\n        return OS_INVALID;\n    }\n\n    if (!strcmp(\"Linux\", uname_buffer.sysname)) {\n        char lock_path[COMMANDSIZE_4096];\n        char lock_pid_path[COMMANDSIZE_4096];\n        wfd_t *wfd = NULL;\n\n        memset(iptables, '\\0', COMMANDSIZE_4096);\n\n        // Checking if iptables is present\n        if (access(iptables_tmp, F_OK) < 0) {\n            char iptables_path[COMMANDSIZE_4096];\n            memset(iptables_path, '\\0', COMMANDSIZE_4096);\n            snprintf(iptables_path, COMMANDSIZE_4096 - 1, \"/usr%s\", iptables_tmp);\n            if (access(iptables_path, F_OK) < 0) {\n                memset(log_msg, '\\0', OS_MAXSTR);\n                snprintf(log_msg, OS_MAXSTR -1, \"The iptables file '%s' is not accessible: %s (%d)\", iptables_path, strerror(errno), errno);\n                write_debug_file(argv[0], log_msg);\n                cJSON_Delete(input_json);\n                return OS_SUCCESS;\n            }\n            strncpy(iptables, iptables_path, COMMANDSIZE_4096 - 1);\n        } else {\n            strncpy(iptables, iptables_tmp, COMMANDSIZE_4096 - 1);\n        }\n\n        char arg[3];\n        memset(arg, '\\0', 3);\n        if (action == ADD_COMMAND) {\n            strcpy(arg, \"-I\");\n        } else {\n            strcpy(arg, \"-D\");\n        }\n\n        memset(lock_path, '\\0', COMMANDSIZE_4096);\n        memset(lock_pid_path, '\\0', COMMANDSIZE_4096);\n        snprintf(lock_path, COMMANDSIZE_4096 - 1, \"%s\", LOCK_PATH);\n        snprintf(lock_pid_path, COMMANDSIZE_4096 - 1, \"%s\", LOCK_FILE);\n\n        // Taking lock\n        if (lock(lock_path, lock_pid_path, argv[0], basename(argv[0])) == OS_INVALID) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR -1, \"Unable to take lock. End.\");\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_INVALID;\n        }\n\n        int count = 0;\n        bool flag = true;\n        while (flag) {\n            char *exec_cmd1[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n            const char *arg1[8] = { iptables, arg, \"INPUT\", \"-s\", srcip, \"-j\", \"DROP\", NULL };\n            memcpy(exec_cmd1, arg1, sizeof(exec_cmd1));\n\n            wfd = wpopenv(iptables, exec_cmd1, W_BIND_STDERR);\n            if (!wfd) {\n                count++;\n                write_debug_file(argv[0], \"Unable to run iptables\");\n                sleep(count);\n\n                if (count > 4) {\n                    flag = false;\n                }\n            } else {\n                flag = false;\n                wpclose(wfd);\n            }\n        }\n\n        count = 0;\n        flag = true;\n        while (flag) {\n            char *exec_cmd2[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n            const char *arg2[8] = { iptables, arg, \"FORWARD\", \"-s\", srcip, \"-j\", \"DROP\", NULL };\n            memcpy(exec_cmd2, arg2, sizeof(exec_cmd2));\n\n            wfd = wpopenv(iptables, exec_cmd2, W_BIND_STDERR);\n            if (!wfd) {\n                count++;\n                write_debug_file(argv[0], \"Unable to run iptables\");\n                sleep(count);\n\n                if (count > 4) {\n                    flag = false;\n                }\n            } else {\n                flag = false;\n                wpclose(wfd);\n            }\n        }\n        unlock(lock_path, argv[0]);\n\n    } else if (!strcmp(\"FreeBSD\", uname_buffer.sysname) || !strcmp(\"SunOS\", uname_buffer.sysname) || !strcmp(\"NetBSD\", uname_buffer.sysname)) {\n        char arg1[COMMANDSIZE_4096];\n        char arg2[COMMANDSIZE_4096];\n        char ipfarg[COMMANDSIZE_4096];\n        wfd_t *wfd = NULL;\n\n        // Checking if ipfilter is present\n        char ipfilter_path[COMMANDSIZE_4096];\n        memset(ipfilter_path, '\\0', COMMANDSIZE_4096);\n        if (!strcmp(\"SunOS\", uname_buffer.sysname)) {\n            strcpy(ipfilter_path, \"/usr/sbin/ipf\");\n        } else {\n            strcpy(ipfilter_path, \"/sbin/ipf\");\n        }\n\n        if (access(ipfilter_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The ipfilter file '%s' is not accessible: %s (%d)\", ipfilter_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        // Checking if echo is present\n        if (access(ECHO, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The echo file '%s' is not accessible: %s (%d)\", ECHO, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        memset(arg1, '\\0', COMMANDSIZE_4096);\n        memset(arg2, '\\0', COMMANDSIZE_4096);\n        memset(ipfarg, '\\0', COMMANDSIZE_4096);\n\n        snprintf(arg1, COMMANDSIZE_4096 -1, \"block out quick from any to %s\", srcip);\n        snprintf(arg2, COMMANDSIZE_4096 -1, \"block in quick from %s to any\", srcip);\n        if (action == ADD_COMMAND) {\n            snprintf(ipfarg, COMMANDSIZE_4096 -1,\"-f\");\n        } else {\n            snprintf(ipfarg, COMMANDSIZE_4096 -1,\"-rf\");\n        }\n\n        char *exec_cmd1[4] = { ipfilter_path, ipfarg, \"-\", NULL };\n        char *exec_cmd2[4] = { ipfilter_path, ipfarg, \"-\", NULL };\n\n        wfd = wpopenv(ipfilter_path, exec_cmd1, W_BIND_STDIN);\n        if (!wfd) {\n            write_debug_file(argv[0], \"Unable to run ipf\");\n        } else {\n            fprintf(wfd->file_in, \"%s\\n\", arg1);\n            fflush(wfd->file_in);\n            wpclose(wfd);\n        }\n\n        wfd = wpopenv(ipfilter_path, exec_cmd2, W_BIND_STDIN);\n        if (!wfd) {\n            write_debug_file(argv[0], \"Unable to run ipf\");\n        } else {\n            fprintf(wfd->file_in, \"%s\\n\", arg2);\n            fflush(wfd->file_in);\n            wpclose(wfd);\n        }\n\n    } else if (!strcmp(\"AIX\", uname_buffer.sysname)) {\n        char genfilt_path[20] = \"/usr/sbin/genfilt\";\n        char lsfilt_path[20] = \"/usr/sbin/lsfilt\";\n        char mkfilt_path[20] = \"/usr/sbin/mkfilt\";\n        char rmfilt_path[20] = \"/usr/sbin/rmfilt\";\n        wfd_t *wfd = NULL;\n\n        // Checking if genfilt is present\n        if (access(genfilt_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The genfilt file '%s' is not accessible: %s (%d)\", genfilt_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        // Checking if lsfilt is present\n        if (access(lsfilt_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The lsfilt file '%s' is not accessible: %s (%d)\", lsfilt_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        // Checking if mkfilt is present\n        if (access(mkfilt_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The mkfilt file '%s' is not accessible: %s (%d)\", mkfilt_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        // Checking if rmfilt is present\n        if (access(rmfilt_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The rmfilt file '%s' is not accessible: %s (%d)\", rmfilt_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        if (action == ADD_COMMAND) {\n            char *exec_cmd1[18] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\n            const char *arg1[18] = { genfilt_path, \"-v\", \"4\", \"-a\", \"D\", \"-s\", srcip, \"-m\", \"255.255.255.255\", \"-d\", \"0.0.0.0\", \"-M\", \"0.0.0.0\", \"-w\", \"B\", \"-D\", \"\\\"Access Denied by WAZUH\\\"\", NULL };\n            memcpy(exec_cmd1, arg1, sizeof(exec_cmd1));\n\n            wfd = wpopenv(genfilt_path, exec_cmd1, W_BIND_STDERR);\n            if (!wfd) {\n                write_debug_file(argv[0], \"Unable to run genfilt\");\n            } else {\n                wpclose(wfd);\n            }\n        } else {\n            char *exec_cmd1[5] = { lsfilt_path, \"-v\", \"4\", \"-O\", NULL };\n\n            wfd = wpopenv(lsfilt_path, exec_cmd1, W_BIND_STDOUT);\n            if (!wfd) {\n                write_debug_file(argv[0], \"Unable to run lsfilt\");\n            } else {\n                char output_buf[OS_MAXSTR];\n                while (fgets(output_buf, OS_MAXSTR, wfd->file_out)) {\n                    if (strstr(output_buf, srcip) != NULL) {\n                        // Removing a specific rule\n                        char *rule_str = strtok(output_buf, \"|\");\n                        char *exec_cmd2[6] = { rmfilt_path, \"-v\", \"4\", \"-n\", rule_str, NULL };\n\n                        wfd_t *wfd2 = wpopenv(rmfilt_path, exec_cmd2, W_BIND_STDERR);\n                        if (!wfd2) {\n                            write_debug_file(argv[0], \"Unable to run rmfilt\");\n                        } else {\n                            wpclose(wfd2);\n                        }\n                    }\n                }\n                wpclose(wfd);\n            }\n        }\n\n        // Deactivate and activate the filter rules\n        char *exec_cmd3[5] = { mkfilt_path, \"-v\", \"4\", \"-d\", NULL };\n\n        wfd = wpopenv(mkfilt_path, exec_cmd3, W_BIND_STDERR);\n        if (!wfd) {\n            write_debug_file(argv[0], \"Unable to run mkfilt\");\n        } else {\n            wpclose(wfd);\n        }\n\n        char *exec_cmd4[5] = { mkfilt_path, \"-v\", \"4\", \"-u\", NULL };\n\n        wfd = wpopenv(mkfilt_path, exec_cmd4, W_BIND_STDERR);\n        if (!wfd) {\n            write_debug_file(argv[0], \"Unable to run mkfilt\");\n        } else {\n            wpclose(wfd);\n        }\n\n    } else {\n        write_debug_file(argv[0], \"Invalid system\");\n    }\n\n    write_debug_file(argv[0], \"Ended\");\n\n    cJSON_Delete(input_json);\n\n    return OS_SUCCESS;\n}",
  "func_after": "int main (int argc, char **argv) {\n    (void)argc;\n    char iptables[COMMANDSIZE_4096];\n    char iptables_tmp[COMMANDSIZE_4096 - 5] = \"\";\n    char log_msg[OS_MAXSTR];\n    int action = OS_INVALID;\n    cJSON *input_json = NULL;\n    struct utsname uname_buffer;\n\n    action = setup_and_check_message(argv, &input_json);\n    if ((action != ADD_COMMAND) && (action != DELETE_COMMAND)) {\n        return OS_INVALID;\n    }\n\n    // Get srcip\n    const char *srcip = get_srcip_from_json(input_json);\n    if (!srcip) {\n        write_debug_file(argv[0], \"Cannot read 'srcip' from data\");\n        cJSON_Delete(input_json);\n        return OS_INVALID;\n    }\n\n    if (action == ADD_COMMAND) {\n        char **keys = NULL;\n        int action2 = OS_INVALID;\n\n        os_calloc(2, sizeof(char *), keys);\n        os_strdup(srcip, keys[0]);\n        keys[1] = NULL;\n\n        action2 = send_keys_and_check_message(argv, keys);\n\n        os_free(keys);\n\n        // If necessary, abort execution\n        if (action2 != CONTINUE_COMMAND) {\n            cJSON_Delete(input_json);\n\n            if (action2 == ABORT_COMMAND) {\n                write_debug_file(argv[0], \"Aborted\");\n                return OS_SUCCESS;\n            } else {\n                return OS_INVALID;\n            }\n        }\n    }\n\n    int ip_version = get_ip_version(srcip);\n    if (ip_version == 4) {\n        strcpy(iptables_tmp, IP4TABLES);\n    } else if (ip_version == 6) {\n        strcpy(iptables_tmp, IP6TABLES);\n    } else {\n        memset(log_msg, '\\0', OS_MAXSTR);\n        snprintf(log_msg, OS_MAXSTR -1, \"Unable to run active response (invalid IP: '%s').\", srcip);\n        write_debug_file(argv[0], log_msg);\n        cJSON_Delete(input_json);\n        return OS_INVALID;\n    }\n\n    if (uname(&uname_buffer) < 0) {\n        write_debug_file(argv[0], \"Cannot get system name\");\n        cJSON_Delete(input_json);\n        return OS_INVALID;\n    }\n\n    if (!strcmp(\"Linux\", uname_buffer.sysname)) {\n        char lock_path[COMMANDSIZE_4096];\n        char lock_pid_path[COMMANDSIZE_4096];\n        wfd_t *wfd = NULL;\n\n        memset(iptables, '\\0', COMMANDSIZE_4096);\n\n        // Checking if iptables is present\n        if (access(iptables_tmp, F_OK) < 0) {\n            char iptables_path[COMMANDSIZE_4096];\n            memset(iptables_path, '\\0', COMMANDSIZE_4096);\n            snprintf(iptables_path, COMMANDSIZE_4096 - 1, \"/usr%s\", iptables_tmp);\n            if (access(iptables_path, F_OK) < 0) {\n                memset(log_msg, '\\0', OS_MAXSTR);\n                snprintf(log_msg, OS_MAXSTR -1, \"The iptables file '%s' is not accessible: %s (%d)\", iptables_path, strerror(errno), errno);\n                write_debug_file(argv[0], log_msg);\n                cJSON_Delete(input_json);\n                return OS_SUCCESS;\n            }\n            strncpy(iptables, iptables_path, COMMANDSIZE_4096 - 1);\n        } else {\n            strncpy(iptables, iptables_tmp, COMMANDSIZE_4096 - 1);\n        }\n\n        char arg[3];\n        memset(arg, '\\0', 3);\n        if (action == ADD_COMMAND) {\n            strcpy(arg, \"-I\");\n        } else {\n            strcpy(arg, \"-D\");\n        }\n\n        memset(lock_path, '\\0', COMMANDSIZE_4096);\n        memset(lock_pid_path, '\\0', COMMANDSIZE_4096);\n        snprintf(lock_path, COMMANDSIZE_4096 - 1, \"%s\", LOCK_PATH);\n        snprintf(lock_pid_path, COMMANDSIZE_4096 - 1, \"%s\", LOCK_FILE);\n\n        // Taking lock\n        if (lock(lock_path, lock_pid_path, argv[0], basename(argv[0])) == OS_INVALID) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR -1, \"Unable to take lock. End.\");\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_INVALID;\n        }\n\n        int count = 0;\n        bool flag = true;\n        while (flag) {\n            char *exec_cmd1[8] = { iptables, arg, \"INPUT\", \"-s\", (char *)srcip, \"-j\", \"DROP\", NULL };\n\n            wfd = wpopenv(iptables, exec_cmd1, W_BIND_STDERR);\n            if (!wfd) {\n                count++;\n                if (count > 4) {\n                    flag = false;\n                    write_debug_file(argv[0], \"Unable to run iptables\");\n                } else {\n                    sleep(count);\n                }\n            } else {\n                flag = false;\n                wpclose(wfd);\n            }\n        }\n\n        count = 0;\n        flag = true;\n        while (flag) {\n            char *exec_cmd2[8] = { iptables, arg, \"FORWARD\", \"-s\", (char *)srcip, \"-j\", \"DROP\", NULL };\n\n            wfd = wpopenv(iptables, exec_cmd2, W_BIND_STDERR);\n            if (!wfd) {\n                count++;\n                if (count > 4) {\n                    flag = false;\n                    write_debug_file(argv[0], \"Unable to run iptables\");\n                } else {\n                    sleep(count);\n                }\n            } else {\n                flag = false;\n                wpclose(wfd);\n            }\n        }\n        unlock(lock_path, argv[0]);\n\n    } else if (!strcmp(\"FreeBSD\", uname_buffer.sysname) || !strcmp(\"SunOS\", uname_buffer.sysname) || !strcmp(\"NetBSD\", uname_buffer.sysname)) {\n        char arg1[COMMANDSIZE_4096];\n        char arg2[COMMANDSIZE_4096];\n        char ipfarg[COMMANDSIZE_4096];\n        wfd_t *wfd = NULL;\n\n        // Checking if ipfilter is present\n        char ipfilter_path[COMMANDSIZE_4096];\n        memset(ipfilter_path, '\\0', COMMANDSIZE_4096);\n        if (!strcmp(\"SunOS\", uname_buffer.sysname)) {\n            strcpy(ipfilter_path, \"/usr/sbin/ipf\");\n        } else {\n            strcpy(ipfilter_path, \"/sbin/ipf\");\n        }\n\n        if (access(ipfilter_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The ipfilter file '%s' is not accessible: %s (%d)\", ipfilter_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        // Checking if echo is present\n        if (access(ECHO, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The echo file '%s' is not accessible: %s (%d)\", ECHO, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        memset(arg1, '\\0', COMMANDSIZE_4096);\n        memset(arg2, '\\0', COMMANDSIZE_4096);\n        memset(ipfarg, '\\0', COMMANDSIZE_4096);\n\n        snprintf(arg1, COMMANDSIZE_4096 -1, \"block out quick from any to %s\", srcip);\n        snprintf(arg2, COMMANDSIZE_4096 -1, \"block in quick from %s to any\", srcip);\n        if (action == ADD_COMMAND) {\n            snprintf(ipfarg, COMMANDSIZE_4096 -1,\"-f\");\n        } else {\n            snprintf(ipfarg, COMMANDSIZE_4096 -1,\"-rf\");\n        }\n\n        char *exec_cmd1[4] = { ipfilter_path, ipfarg, \"-\", NULL };\n\n        wfd = wpopenv(ipfilter_path, exec_cmd1, W_BIND_STDIN);\n        if (!wfd) {\n            write_debug_file(argv[0], \"Unable to run ipf\");\n        } else {\n            fprintf(wfd->file_in, \"%s\\n\", arg1);\n            fflush(wfd->file_in);\n            wpclose(wfd);\n        }\n\n        wfd = wpopenv(ipfilter_path, exec_cmd1, W_BIND_STDIN);\n        if (!wfd) {\n            write_debug_file(argv[0], \"Unable to run ipf\");\n        } else {\n            fprintf(wfd->file_in, \"%s\\n\", arg2);\n            fflush(wfd->file_in);\n            wpclose(wfd);\n        }\n\n    } else if (!strcmp(\"AIX\", uname_buffer.sysname)) {\n        char genfilt_path[20] = \"/usr/sbin/genfilt\";\n        char lsfilt_path[20] = \"/usr/sbin/lsfilt\";\n        char mkfilt_path[20] = \"/usr/sbin/mkfilt\";\n        char rmfilt_path[20] = \"/usr/sbin/rmfilt\";\n        wfd_t *wfd = NULL;\n\n        // Checking if genfilt is present\n        if (access(genfilt_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The genfilt file '%s' is not accessible: %s (%d)\", genfilt_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        // Checking if lsfilt is present\n        if (access(lsfilt_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The lsfilt file '%s' is not accessible: %s (%d)\", lsfilt_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        // Checking if mkfilt is present\n        if (access(mkfilt_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The mkfilt file '%s' is not accessible: %s (%d)\", mkfilt_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        // Checking if rmfilt is present\n        if (access(rmfilt_path, F_OK) < 0) {\n            memset(log_msg, '\\0', OS_MAXSTR);\n            snprintf(log_msg, OS_MAXSTR - 1, \"The rmfilt file '%s' is not accessible: %s (%d)\", rmfilt_path, strerror(errno), errno);\n            write_debug_file(argv[0], log_msg);\n            cJSON_Delete(input_json);\n            return OS_SUCCESS;\n        }\n\n        if (action == ADD_COMMAND) {\n            char *exec_cmd1[18] = { genfilt_path, \"-v\", \"4\", \"-a\", \"D\", \"-s\", (char *)srcip, \"-m\", \"255.255.255.255\", \"-d\", \"0.0.0.0\", \"-M\", \"0.0.0.0\", \"-w\", \"B\", \"-D\", \"\\\"Access Denied by WAZUH\\\"\", NULL };\n\n            wfd = wpopenv(genfilt_path, exec_cmd1, W_BIND_STDERR);\n            if (!wfd) {\n                write_debug_file(argv[0], \"Unable to run genfilt\");\n            } else {\n                wpclose(wfd);\n            }\n        } else {\n            char *exec_cmd1[5] = { lsfilt_path, \"-v\", \"4\", \"-O\", NULL };\n\n            wfd = wpopenv(lsfilt_path, exec_cmd1, W_BIND_STDOUT);\n            if (!wfd) {\n                write_debug_file(argv[0], \"Unable to run lsfilt\");\n            } else {\n                char output_buf[OS_MAXSTR];\n                while (fgets(output_buf, OS_MAXSTR, wfd->file_out)) {\n                    if (strstr(output_buf, srcip) != NULL) {\n                        // Removing a specific rule\n                        char *rule_str = strtok(output_buf, \"|\");\n                        char *exec_cmd2[6] = { rmfilt_path, \"-v\", \"4\", \"-n\", rule_str, NULL };\n\n                        wfd_t *wfd2 = wpopenv(rmfilt_path, exec_cmd2, W_BIND_STDERR);\n                        if (!wfd2) {\n                            write_debug_file(argv[0], \"Unable to run rmfilt\");\n                        } else {\n                            wpclose(wfd2);\n                        }\n                    }\n                }\n                wpclose(wfd);\n            }\n        }\n\n        // Deactivate and activate the filter rules\n        char *exec_cmd3[5] = { mkfilt_path, \"-v\", \"4\", \"-d\", NULL };\n\n        wfd = wpopenv(mkfilt_path, exec_cmd3, W_BIND_STDERR);\n        if (!wfd) {\n            write_debug_file(argv[0], \"Unable to run mkfilt\");\n        } else {\n            wpclose(wfd);\n        }\n\n        char *exec_cmd4[5] = { mkfilt_path, \"-v\", \"4\", \"-u\", NULL };\n\n        wfd = wpopenv(mkfilt_path, exec_cmd4, W_BIND_STDERR);\n        if (!wfd) {\n            write_debug_file(argv[0], \"Unable to run mkfilt\");\n        } else {\n            wpclose(wfd);\n        }\n\n    } else {\n        write_debug_file(argv[0], \"Invalid system\");\n    }\n\n    write_debug_file(argv[0], \"Ended\");\n\n    cJSON_Delete(input_json);\n\n    return OS_SUCCESS;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int main (int argc, char **argv) {\n     (void)argc;\n     char iptables[COMMANDSIZE_4096];\n     char iptables_tmp[COMMANDSIZE_4096 - 5] = \"\";\n     char log_msg[OS_MAXSTR];\n     int action = OS_INVALID;\n     cJSON *input_json = NULL;\n     struct utsname uname_buffer;\n \n     action = setup_and_check_message(argv, &input_json);\n     if ((action != ADD_COMMAND) && (action != DELETE_COMMAND)) {\n         return OS_INVALID;\n     }\n \n     // Get srcip\n     const char *srcip = get_srcip_from_json(input_json);\n     if (!srcip) {\n         write_debug_file(argv[0], \"Cannot read 'srcip' from data\");\n         cJSON_Delete(input_json);\n         return OS_INVALID;\n     }\n \n     if (action == ADD_COMMAND) {\n         char **keys = NULL;\n         int action2 = OS_INVALID;\n \n         os_calloc(2, sizeof(char *), keys);\n         os_strdup(srcip, keys[0]);\n         keys[1] = NULL;\n \n         action2 = send_keys_and_check_message(argv, keys);\n \n         os_free(keys);\n \n         // If necessary, abort execution\n         if (action2 != CONTINUE_COMMAND) {\n             cJSON_Delete(input_json);\n \n             if (action2 == ABORT_COMMAND) {\n                 write_debug_file(argv[0], \"Aborted\");\n                 return OS_SUCCESS;\n             } else {\n                 return OS_INVALID;\n             }\n         }\n     }\n \n     int ip_version = get_ip_version(srcip);\n     if (ip_version == 4) {\n         strcpy(iptables_tmp, IP4TABLES);\n     } else if (ip_version == 6) {\n         strcpy(iptables_tmp, IP6TABLES);\n     } else {\n         memset(log_msg, '\\0', OS_MAXSTR);\n         snprintf(log_msg, OS_MAXSTR -1, \"Unable to run active response (invalid IP: '%s').\", srcip);\n         write_debug_file(argv[0], log_msg);\n         cJSON_Delete(input_json);\n         return OS_INVALID;\n     }\n \n     if (uname(&uname_buffer) < 0) {\n         write_debug_file(argv[0], \"Cannot get system name\");\n         cJSON_Delete(input_json);\n         return OS_INVALID;\n     }\n \n     if (!st",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nFinal Output:\n\nAnalysis: The patch replaces the 'system' function with 'wpopenv' and removes unnecessary code, which may improve security by preventing command injection. However, without explicit mention of a security issue, it's classified as a defect remediation.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.8"
}