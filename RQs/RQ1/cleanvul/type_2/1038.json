{
  "id": 1038,
  "language": "Java",
  "commit_url": "https://github.com/JetBrains/JetBrainsRuntime/commit/aed4d3e0ff96d026391f4598f4e10952fa425ae4",
  "commit_sha": "aed4d3e0ff96d026391f4598f4e10952fa425ae4",
  "commit_msg": "JBR-3623 SIGSEGV at [libawt_xawt] Java_sun_awt_X11GraphicsDevice_getConfigColormap\n\nThis fix addresses two possible causes of crashes:\n1. makeDefaultConfig() returning NULL. The fix is to die gracefully\ninstead of crashing in an attempt to de-reference the NULL pointer.\n\n2. A race condition when the number of screens change (this is only an\nissue with the number of xinerama screens; the number of X11 screens is\nstatic for the duration of the X session).\n\nThe race scenario: X11GraphisDevice.makeDefaultConfiguration() is called\non EDT so the call can race with X11GraphisDevice.invalidate() that\nre-sets the screen number of the device; the latter is invoked on the\n\"AWT-XAWT\" thread from X11GraphicsEnvironment.rebuildDevices(). So by\nthe time makeDefaultConfiguration() makes a native call with the\ndevice's current screen number, the x11Screens array maintained by the\nnative code could have become shorter. And the native methods like\nJava_sun_awt_X11GraphicsDevice_getConfigColormap() assume that the\nscreen number passed to them is always current and valid. The AWT lock\nonly protects against the changes during the native methods invocation,\nbut does not protect against them being called with an outdated screen\nnumber.\n\nThe fix is to eliminate the race by protecting X11GraphisDevice.screen\nwith the AWT lock.\n\n(cherry picked from commit 0b53cd291fac8c031f84ea1bdac23693e68f259e)\n(cherry picked from commit 3a15dfad37e57c124733a6360f008cfe61dd95ec)",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/java.desktop/unix/classes/sun/awt/X11GraphicsDevice.java",
  "func_name": "makeConfigurations",
  "func_before": "private void makeConfigurations() {\n        if (configs == null) {\n            int i = 1;  // Index 0 is always the default config\n            int num = getNumConfigs(screen);\n            GraphicsConfiguration[] ret = new GraphicsConfiguration[num];\n            if (defaultConfig == null) {\n                ret [0] = getDefaultConfiguration();\n            }\n            else {\n                ret [0] = defaultConfig;\n            }\n\n            boolean glxSupported = X11GraphicsEnvironment.isGLXAvailable();\n            boolean xrenderSupported = X11GraphicsEnvironment.isXRenderAvailable();\n\n            boolean dbeSupported = isDBESupported();\n            if (dbeSupported && doubleBufferVisuals == null) {\n                doubleBufferVisuals = new HashSet<>();\n                getDoubleBufferVisuals(screen);\n            }\n            for ( ; i < num; i++) {\n                int visNum = getConfigVisualId(i, screen);\n                int depth = getConfigDepth (i, screen);\n                if (glxSupported) {\n                    ret[i] = GLXGraphicsConfig.getConfig(this, visNum);\n                }\n                if (ret[i] == null) {\n                    boolean doubleBuffer =\n                        (dbeSupported &&\n                         doubleBufferVisuals.contains(Integer.valueOf(visNum)));\n\n                    if (xrenderSupported) {\n                        ret[i] = XRGraphicsConfig.getConfig(this, visNum, depth,\n                                getConfigColormap(i, screen), doubleBuffer);\n                    } else {\n                       ret[i] = X11GraphicsConfig.getConfig(this, visNum, depth,\n                              getConfigColormap(i, screen),\n                              doubleBuffer);\n                    }\n                }\n            }\n            configs = ret;\n        }\n    }",
  "func_after": "private void makeConfigurations() {\n        if (configs == null) {\n            XToolkit.awtLock();\n            try {\n                int i = 1;  // Index 0 is always the default config\n                int num = getNumConfigs(screen);\n                GraphicsConfiguration[] ret = new GraphicsConfiguration[num];\n                if (defaultConfig == null) {\n                    ret[0] = getDefaultConfiguration();\n                } else {\n                    ret[0] = defaultConfig;\n                }\n\n                boolean glxSupported = X11GraphicsEnvironment.isGLXAvailable();\n                boolean xrenderSupported = X11GraphicsEnvironment.isXRenderAvailable();\n\n                boolean dbeSupported = isDBESupported();\n                if (dbeSupported && doubleBufferVisuals == null) {\n                    doubleBufferVisuals = new HashSet<>();\n                    getDoubleBufferVisuals(screen);\n                }\n                for (; i < num; i++) {\n                    int visNum = getConfigVisualId(i, screen);\n                    int depth = getConfigDepth(i, screen);\n                    if (glxSupported) {\n                        ret[i] = GLXGraphicsConfig.getConfig(this, visNum);\n                    }\n                    if (ret[i] == null) {\n                        boolean doubleBuffer =\n                                (dbeSupported &&\n                                        doubleBufferVisuals.contains(Integer.valueOf(visNum)));\n\n                        if (xrenderSupported) {\n                            ret[i] = XRGraphicsConfig.getConfig(this, visNum, depth,\n                                    getConfigColormap(i, screen), doubleBuffer);\n                        } else {\n                            ret[i] = X11GraphicsConfig.getConfig(this, visNum, depth,\n                                    getConfigColormap(i, screen),\n                                    doubleBuffer);\n                        }\n                    }\n                }\n                configs = ret;\n            } finally {\n                XToolkit.awtUnlock();\n            }\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n private void makeConfigurations() {\n         if (configs == null) {\n+            XToolkit.awtLock();\n+            try {\n-            int i = 1;  // Index 0 is always the default config\n+                int i = 1;  // Index 0 is always the default config\n-            int num = getNumConfigs(screen);\n+                int num = getNumConfigs(screen);\n-            GraphicsConfiguration[] ret = new GraphicsConfiguration[num];\n+                GraphicsConfiguration[] ret = new GraphicsConfiguration[num];\n-            if (defaultConfig == null) {\n+                if (defaultConfig == null) {\n-                ret [0] = getDefaultConfiguration();\n+                    ret[0] = getDefaultConfiguration();\n-            }\n-            else {\n+                } else {\n-                ret [0] = defaultConfig;\n+                    ret[0] = defaultConfig;\n-            }\n+                }\n \n-            boolean glxSupported = X11GraphicsEnvironment.isGLXAvailable();\n+                boolean glxSupported = X11GraphicsEnvironment.isGLXAvailable();\n-            boolean xrenderSupported = X11GraphicsEnvironment.isXRenderAvailable();\n+                boolean xrenderSupported = X11GraphicsEnvironment.isXRenderAvailable();\n \n-            boolean dbeSupported = isDBESupported();\n+                boolean dbeSupported = isDBESupported();\n-            if (dbeSupported && doubleBufferVisuals == null) {\n+                if (dbeSupported && doubleBufferVisuals == null) {\n-                doubleBufferVisuals = new HashSet<>();\n+                    doubleBufferVisuals = new HashSet<>();\n-                getDoubleBufferVisuals(screen);\n+                    getDoubleBufferVisuals(screen);\n-            }\n-            for ( ; i < num; i++) {\n-                int visNum = getConfigVisualId(i, screen);\n-                int depth = getConfigDepth (i, screen);\n-                if (glxSupported) {\n-                    ret[i] = GLXGraphicsConfig.getConfig(this, visNum);\n      ",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a null pointer dereference and a race condition, which could cause crashes but don't directly expose security vulnerabilities. The code changes improve stability and prevent crashes, which are functional bug fixes.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.9"
}