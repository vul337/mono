{
  "id": 7296,
  "language": "C/C++",
  "commit_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "commit_sha": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "pr_info": "When decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "file_name": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvRMDIR",
  "func_before": "int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    word32 sz;\n    int    ret = 0;\n    char*  dir;\n    word32 idx = 0;\n    byte*  out;\n    word32 outSz = 0;\n    byte   type;\n\n    char err[] = \"Remove Directory Error\";\n    char suc[] = \"Removed Directory\";\n    char* res  = NULL;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_RMDIR\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == 0) {\n    #ifndef USE_WINDOWS_API\n        ret = WRMDIR(ssh->fs, dir);\n    #else /* USE_WINDOWS_API */\n        ret = WS_RemoveDirectoryA(dir, ssh->ctx->heap) == 0;\n    #endif /* USE_WINDOWS_API */\n    }\n    WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    res  = (ret != 0)? err : suc;\n    type = (ret != 0)? WOLFSSH_FTP_FAILURE : WOLFSSH_FTP_OK;\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != 0) {\n        /* @TODO errno holds reason for rmdir failure. Status sent could be\n         * better if using errno value to send reason i.e. permissions .. */\n        WLOG(WS_LOG_SFTP, \"Error removing directory %s\", dir);\n        ret = WS_BAD_FILE_E;\n    }\n    else {\n        ret = WS_SUCCESS;\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "func_after": "int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    word32 sz;\n    int    ret = 0;\n    char*  dir;\n    word32 idx = 0;\n    byte*  out;\n    word32 outSz = 0;\n    byte   type;\n\n    char err[] = \"Remove Directory Error\";\n    char suc[] = \"Removed Directory\";\n    char* res  = NULL;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_RMDIR\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == 0) {\n    #ifndef USE_WINDOWS_API\n        ret = WRMDIR(ssh->fs, dir);\n    #else /* USE_WINDOWS_API */\n        ret = WS_RemoveDirectoryA(dir, ssh->ctx->heap) == 0;\n    #endif /* USE_WINDOWS_API */\n    }\n    WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    res  = (ret != 0)? err : suc;\n    type = (ret != 0)? WOLFSSH_FTP_FAILURE : WOLFSSH_FTP_OK;\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != 0) {\n        /* @TODO errno holds reason for rmdir failure. Status sent could be\n         * better if using errno value to send reason i.e. permissions .. */\n        WLOG(WS_LOG_SFTP, \"Error removing directory %s\", dir);\n        ret = WS_BAD_FILE_E;\n    }\n    else {\n        ret = WS_SUCCESS;\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n {\n     word32 sz;\n     int    ret = 0;\n     char*  dir;\n     word32 idx = 0;\n     byte*  out;\n     word32 outSz = 0;\n     byte   type;\n \n     char err[] = \"Remove Directory Error\";\n     char suc[] = \"Removed Directory\";\n     char* res  = NULL;\n \n     if (ssh == NULL) {\n         return WS_BAD_ARGUMENT;\n     }\n \n     WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_RMDIR\");\n \n     ato32(data + idx, &sz); idx += UINT32_SZ;\n-    if (sz + idx > maxSz) {\n+    if (sz > maxSz - idx) {\n         return WS_BUFFER_E;\n     }\n \n     /* plus one to make sure is null terminated */\n     dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n     if (dir == NULL) {\n         return WS_MEMORY_E;\n     }\n     WMEMCPY(dir, data + idx, sz);\n     dir[sz] = '\\0';\n \n     if (wolfSSH_CleanPath(ssh, dir) < 0) {\n         ret = WS_FATAL_ERROR;\n     }\n \n     if (ret == 0) {\n     #ifndef USE_WINDOWS_API\n         ret = WRMDIR(ssh->fs, dir);\n     #else /* USE_WINDOWS_API */\n         ret = WS_RemoveDirectoryA(dir, ssh->ctx->heap) == 0;\n     #endif /* USE_WINDOWS_API */\n     }\n     WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n \n     res  = (ret != 0)? err : suc;\n     type = (ret != 0)? WOLFSSH_FTP_FAILURE : WOLFSSH_FTP_OK;\n     if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res,\n                 \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n         return WS_FATAL_ERROR;\n     }\n \n     out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n     if (out == NULL) {\n         return WS_MEMORY_E;\n     }\n \n     if (ret != 0) {\n         /* @TODO errno holds reason for rmdir failure. Status sent could be\n          * better if using errno value to send reason i.e. permissions .. */\n         WLOG(WS_LOG_SFTP, \"Error removing directory %s\", dir);\n         ret = WS_BAD_FILE_E;\n     }\n     else {\n         ret = WS_SUCCESS;\n     }\n \n     if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an integer overflow in SFTP message decoding, which could lead to buffer overflow vulnerabilities. The fix ensures proper size checks without wrapping, mitigating a security risk.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}