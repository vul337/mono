{
  "id": 7019,
  "language": "C/C++",
  "commit_url": "https://github.com/weidai11/cryptopp/commit/399a1546de71f41598c15edada28e7f0d616f541",
  "commit_sha": "399a1546de71f41598c15edada28e7f0d616f541",
  "commit_msg": "Add CRYPTOPP_ASSERT (Issue 277, CVE-2016-7420)\ntrap.h and CRYPTOPP_ASSERT has existed for over a year in Master. We deferred on the cut-over waiting for a minor version bump (5.7). We have to use it now due to CVE-2016-7420",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "emsa2.cpp",
  "func_name": "ComputeMessageRepresentative",
  "func_before": "void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator& /*rng*/,\n\tconst byte* recoverableMessage, size_t recoverableMessageLength,\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tCRYPTOPP_UNUSED(recoverableMessage), CRYPTOPP_UNUSED(recoverableMessageLength), CRYPTOPP_UNUSED(representativeBitLength);\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tif (representativeBitLength % 8 != 7)\n\t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n\n\tsize_t digestSize = hash.DigestSize();\n\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n\n\trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n\tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n\tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n\tafterP2[0] = 0xba;\n\thash.Final(afterP2+1);\n\trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n\trepresentative[representativeByteLength-1] = 0xcc;\n}",
  "func_after": "void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator& /*rng*/,\n\tconst byte* recoverableMessage, size_t recoverableMessageLength,\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tCRYPTOPP_UNUSED(recoverableMessage), CRYPTOPP_UNUSED(recoverableMessageLength), CRYPTOPP_UNUSED(representativeBitLength);\n\tCRYPTOPP_ASSERT(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tif (representativeBitLength % 8 != 7)\n\t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n\n\tsize_t digestSize = hash.DigestSize();\n\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n\n\trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n\tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n\tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n\tafterP2[0] = 0xba;\n\thash.Final(afterP2+1);\n\trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n\trepresentative[representativeByteLength-1] = 0xcc;\n}",
  "diff_func": "--- func_before\n+++ func_after\n void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator& /*rng*/,\n \tconst byte* recoverableMessage, size_t recoverableMessageLength,\n \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n \tbyte *representative, size_t representativeBitLength) const\n {\n \tCRYPTOPP_UNUSED(recoverableMessage), CRYPTOPP_UNUSED(recoverableMessageLength), CRYPTOPP_UNUSED(representativeBitLength);\n-\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n+\tCRYPTOPP_ASSERT(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n \n \tif (representativeBitLength % 8 != 7)\n \t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n \n \tsize_t digestSize = hash.DigestSize();\n \tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n \n \trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n \tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n \tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n \tafterP2[0] = 0xba;\n \thash.Final(afterP2+1);\n \trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n \trepresentative[representativeByteLength-1] = 0xcc;\n }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n- The commit message references a CVE (CVE-2016-7420), indicating a security issue.\n- The code changes replace 'assert' with 'CRYPTOPP_ASSERT', ensuring the check remains active in production.\n- The function is part of cryptographic operations, and the check prevents potential security breaches.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}