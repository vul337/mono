{
  "id": 7133,
  "language": "C#",
  "commit_url": "https://github.com/jellyfin/jellyfin/commit/a656799dc879d16d21bf2ce7ad412ebd5d45394a",
  "commit_sha": "a656799dc879d16d21bf2ce7ad412ebd5d45394a",
  "commit_msg": "Merge pull request from GHSA-866x-wj5j-2vf4\n\nValidate codec and container",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "Jellyfin.Api/Controllers/UniversalAudioController.cs",
  "func_name": "HttpGet",
  "func_before": "[HttpGet(\"Audio/{itemId}/universal\")]\n        [HttpHead(\"Audio/{itemId}/universal\", Name = \"HeadUniversalAudioStream\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status302Found)]\n        [ProducesAudioFile]\n        public async Task<ActionResult> GetUniversalAudioStream(\n            [FromRoute, Required] Guid itemId,\n            [FromQuery, ModelBinder(typeof(CommaDelimitedArrayModelBinder))] string[] container,\n            [FromQuery] string? mediaSourceId,\n            [FromQuery] string? deviceId,\n            [FromQuery] Guid? userId,\n            [FromQuery] string? audioCodec,\n            [FromQuery] int? maxAudioChannels,\n            [FromQuery] int? transcodingAudioChannels,\n            [FromQuery] int? maxStreamingBitrate,\n            [FromQuery] int? audioBitRate,\n            [FromQuery] long? startTimeTicks,\n            [FromQuery] string? transcodingContainer,\n            [FromQuery] string? transcodingProtocol,\n            [FromQuery] int? maxAudioSampleRate,\n            [FromQuery] int? maxAudioBitDepth,\n            [FromQuery] bool? enableRemoteMedia,\n            [FromQuery] bool breakOnNonKeyFrames = false,\n            [FromQuery] bool enableRedirection = true)\n        {\n            var deviceProfile = GetDeviceProfile(container, transcodingContainer, audioCodec, transcodingProtocol, breakOnNonKeyFrames, transcodingAudioChannels, maxAudioSampleRate, maxAudioBitDepth, maxAudioChannels);\n            var authorizationInfo = await _authorizationContext.GetAuthorizationInfo(Request).ConfigureAwait(false);\n            authorizationInfo.DeviceId = deviceId;\n\n            if (!userId.HasValue || userId.Value.Equals(Guid.Empty))\n            {\n                userId = authorizationInfo.UserId;\n            }\n\n            var authInfo = await _authorizationContext.GetAuthorizationInfo(Request).ConfigureAwait(false);\n\n            _logger.LogInformation(\"GetPostedPlaybackInfo profile: {@Profile}\", deviceProfile);\n\n            if (deviceProfile == null)\n            {\n                var clientCapabilities = _deviceManager.GetCapabilities(authInfo.DeviceId);\n                if (clientCapabilities != null)\n                {\n                    deviceProfile = clientCapabilities.DeviceProfile;\n                }\n            }\n\n            var info = await _mediaInfoHelper.GetPlaybackInfo(\n                    itemId,\n                    userId,\n                    mediaSourceId)\n                .ConfigureAwait(false);\n\n            if (deviceProfile != null)\n            {\n                // set device specific data\n                var item = _libraryManager.GetItemById(itemId);\n\n                foreach (var sourceInfo in info.MediaSources)\n                {\n                    _mediaInfoHelper.SetDeviceSpecificData(\n                        item,\n                        sourceInfo,\n                        deviceProfile,\n                        authInfo,\n                        maxStreamingBitrate ?? deviceProfile.MaxStreamingBitrate,\n                        startTimeTicks ?? 0,\n                        mediaSourceId ?? string.Empty,\n                        null,\n                        null,\n                        maxAudioChannels,\n                        info.PlaySessionId!,\n                        userId ?? Guid.Empty,\n                        true,\n                        true,\n                        true,\n                        true,\n                        true,\n                        Request.HttpContext.GetNormalizedRemoteIp());\n                }\n\n                _mediaInfoHelper.SortMediaSources(info, maxStreamingBitrate);\n            }\n\n            if (info.MediaSources != null)\n            {\n                foreach (var source in info.MediaSources)\n                {\n                    _mediaInfoHelper.NormalizeMediaSourceContainer(source, deviceProfile!, DlnaProfileType.Video);\n                }\n            }\n\n            var mediaSource = info.MediaSources![0];\n            if (mediaSource.SupportsDirectPlay && mediaSource.Protocol == MediaProtocol.Http)\n            {\n                if (enableRedirection)\n                {\n                    if (mediaSource.IsRemote && enableRemoteMedia.HasValue && enableRemoteMedia.Value)\n                    {\n                        return Redirect(mediaSource.Path);\n                    }\n                }\n            }\n\n            var isStatic = mediaSource.SupportsDirectStream;\n            if (!isStatic && string.Equals(mediaSource.TranscodingSubProtocol, \"hls\", StringComparison.OrdinalIgnoreCase))\n            {\n                // hls segment container can only be mpegts or fmp4 per ffmpeg documentation\n                // ffmpeg option -> file extension\n                //        mpegts -> ts\n                //          fmp4 -> mp4\n                // TODO: remove this when we switch back to the segment muxer\n                var supportedHlsContainers = new[] { \"ts\", \"mp4\" };\n\n                var dynamicHlsRequestDto = new HlsAudioRequestDto\n                {\n                    Id = itemId,\n                    Container = \".m3u8\",\n                    Static = isStatic,\n                    PlaySessionId = info.PlaySessionId,\n                    // fallback to mpegts if device reports some weird value unsupported by hls\n                    SegmentContainer = Array.Exists(supportedHlsContainers, element => element == transcodingContainer) ? transcodingContainer : \"ts\",\n                    MediaSourceId = mediaSourceId,\n                    DeviceId = deviceId,\n                    AudioCodec = audioCodec,\n                    EnableAutoStreamCopy = true,\n                    AllowAudioStreamCopy = true,\n                    AllowVideoStreamCopy = true,\n                    BreakOnNonKeyFrames = breakOnNonKeyFrames,\n                    AudioSampleRate = maxAudioSampleRate,\n                    MaxAudioChannels = maxAudioChannels,\n                    MaxAudioBitDepth = maxAudioBitDepth,\n                    AudioBitRate = audioBitRate ?? maxStreamingBitrate,\n                    StartTimeTicks = startTimeTicks,\n                    SubtitleMethod = SubtitleDeliveryMethod.Hls,\n                    RequireAvc = false,\n                    DeInterlace = false,\n                    RequireNonAnamorphic = false,\n                    EnableMpegtsM2TsMode = false,\n                    TranscodeReasons = mediaSource.TranscodeReasons == 0 ? null : mediaSource.TranscodeReasons.ToString(),\n                    Context = EncodingContext.Static,\n                    StreamOptions = new Dictionary<string, string>(),\n                    EnableAdaptiveBitrateStreaming = true\n                };\n\n                return await _dynamicHlsHelper.GetMasterHlsPlaylist(TranscodingJobType.Hls, dynamicHlsRequestDto, true)\n                    .ConfigureAwait(false);\n            }\n\n            var audioStreamingDto = new StreamingRequestDto\n            {\n                Id = itemId,\n                Container = isStatic ? null : (\".\" + mediaSource.TranscodingContainer),\n                Static = isStatic,\n                PlaySessionId = info.PlaySessionId,\n                MediaSourceId = mediaSourceId,\n                DeviceId = deviceId,\n                AudioCodec = audioCodec,\n                EnableAutoStreamCopy = true,\n                AllowAudioStreamCopy = true,\n                AllowVideoStreamCopy = true,\n                BreakOnNonKeyFrames = breakOnNonKeyFrames,\n                AudioSampleRate = maxAudioSampleRate,\n                MaxAudioChannels = maxAudioChannels,\n                AudioBitRate = isStatic ? (int?)null : (audioBitRate ?? maxStreamingBitrate),\n                MaxAudioBitDepth = maxAudioBitDepth,\n                AudioChannels = maxAudioChannels,\n                CopyTimestamps = true,\n                StartTimeTicks = startTimeTicks,\n                SubtitleMethod = SubtitleDeliveryMethod.Embed,\n                TranscodeReasons = mediaSource.TranscodeReasons == 0 ? null : mediaSource.TranscodeReasons.ToString(),\n                Context = EncodingContext.Static\n            };\n\n            return await _audioHelper.GetAudioStream(TranscodingJobType.Progressive, audioStreamingDto).ConfigureAwait(false);\n        }",
  "func_after": "[HttpGet(\"Audio/{itemId}/universal\")]\n        [HttpHead(\"Audio/{itemId}/universal\", Name = \"HeadUniversalAudioStream\")]\n        [Authorize(Policy = Policies.DefaultAuthorization)]\n        [ProducesResponseType(StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status302Found)]\n        [ProducesAudioFile]\n        public async Task<ActionResult> GetUniversalAudioStream(\n            [FromRoute, Required] Guid itemId,\n            [FromQuery, ModelBinder(typeof(CommaDelimitedArrayModelBinder))] string[] container,\n            [FromQuery] string? mediaSourceId,\n            [FromQuery] string? deviceId,\n            [FromQuery] Guid? userId,\n            [FromQuery][RegularExpression(EncodingHelper.ValidationRegex)] string? audioCodec,\n            [FromQuery] int? maxAudioChannels,\n            [FromQuery] int? transcodingAudioChannels,\n            [FromQuery] int? maxStreamingBitrate,\n            [FromQuery] int? audioBitRate,\n            [FromQuery] long? startTimeTicks,\n            [FromQuery][RegularExpression(EncodingHelper.ValidationRegex)] string? transcodingContainer,\n            [FromQuery] string? transcodingProtocol,\n            [FromQuery] int? maxAudioSampleRate,\n            [FromQuery] int? maxAudioBitDepth,\n            [FromQuery] bool? enableRemoteMedia,\n            [FromQuery] bool breakOnNonKeyFrames = false,\n            [FromQuery] bool enableRedirection = true)\n        {\n            var deviceProfile = GetDeviceProfile(container, transcodingContainer, audioCodec, transcodingProtocol, breakOnNonKeyFrames, transcodingAudioChannels, maxAudioSampleRate, maxAudioBitDepth, maxAudioChannels);\n            var authorizationInfo = await _authorizationContext.GetAuthorizationInfo(Request).ConfigureAwait(false);\n            authorizationInfo.DeviceId = deviceId;\n\n            if (!userId.HasValue || userId.Value.Equals(Guid.Empty))\n            {\n                userId = authorizationInfo.UserId;\n            }\n\n            var authInfo = await _authorizationContext.GetAuthorizationInfo(Request).ConfigureAwait(false);\n\n            _logger.LogInformation(\"GetPostedPlaybackInfo profile: {@Profile}\", deviceProfile);\n\n            if (deviceProfile == null)\n            {\n                var clientCapabilities = _deviceManager.GetCapabilities(authInfo.DeviceId);\n                if (clientCapabilities != null)\n                {\n                    deviceProfile = clientCapabilities.DeviceProfile;\n                }\n            }\n\n            var info = await _mediaInfoHelper.GetPlaybackInfo(\n                    itemId,\n                    userId,\n                    mediaSourceId)\n                .ConfigureAwait(false);\n\n            if (deviceProfile != null)\n            {\n                // set device specific data\n                var item = _libraryManager.GetItemById(itemId);\n\n                foreach (var sourceInfo in info.MediaSources)\n                {\n                    _mediaInfoHelper.SetDeviceSpecificData(\n                        item,\n                        sourceInfo,\n                        deviceProfile,\n                        authInfo,\n                        maxStreamingBitrate ?? deviceProfile.MaxStreamingBitrate,\n                        startTimeTicks ?? 0,\n                        mediaSourceId ?? string.Empty,\n                        null,\n                        null,\n                        maxAudioChannels,\n                        info.PlaySessionId!,\n                        userId ?? Guid.Empty,\n                        true,\n                        true,\n                        true,\n                        true,\n                        true,\n                        Request.HttpContext.GetNormalizedRemoteIp());\n                }\n\n                _mediaInfoHelper.SortMediaSources(info, maxStreamingBitrate);\n            }\n\n            if (info.MediaSources != null)\n            {\n                foreach (var source in info.MediaSources)\n                {\n                    _mediaInfoHelper.NormalizeMediaSourceContainer(source, deviceProfile!, DlnaProfileType.Video);\n                }\n            }\n\n            var mediaSource = info.MediaSources![0];\n            if (mediaSource.SupportsDirectPlay && mediaSource.Protocol == MediaProtocol.Http)\n            {\n                if (enableRedirection)\n                {\n                    if (mediaSource.IsRemote && enableRemoteMedia.HasValue && enableRemoteMedia.Value)\n                    {\n                        return Redirect(mediaSource.Path);\n                    }\n                }\n            }\n\n            var isStatic = mediaSource.SupportsDirectStream;\n            if (!isStatic && string.Equals(mediaSource.TranscodingSubProtocol, \"hls\", StringComparison.OrdinalIgnoreCase))\n            {\n                // hls segment container can only be mpegts or fmp4 per ffmpeg documentation\n                // ffmpeg option -> file extension\n                //        mpegts -> ts\n                //          fmp4 -> mp4\n                // TODO: remove this when we switch back to the segment muxer\n                var supportedHlsContainers = new[] { \"ts\", \"mp4\" };\n\n                var dynamicHlsRequestDto = new HlsAudioRequestDto\n                {\n                    Id = itemId,\n                    Container = \".m3u8\",\n                    Static = isStatic,\n                    PlaySessionId = info.PlaySessionId,\n                    // fallback to mpegts if device reports some weird value unsupported by hls\n                    SegmentContainer = Array.Exists(supportedHlsContainers, element => element == transcodingContainer) ? transcodingContainer : \"ts\",\n                    MediaSourceId = mediaSourceId,\n                    DeviceId = deviceId,\n                    AudioCodec = audioCodec,\n                    EnableAutoStreamCopy = true,\n                    AllowAudioStreamCopy = true,\n                    AllowVideoStreamCopy = true,\n                    BreakOnNonKeyFrames = breakOnNonKeyFrames,\n                    AudioSampleRate = maxAudioSampleRate,\n                    MaxAudioChannels = maxAudioChannels,\n                    MaxAudioBitDepth = maxAudioBitDepth,\n                    AudioBitRate = audioBitRate ?? maxStreamingBitrate,\n                    StartTimeTicks = startTimeTicks,\n                    SubtitleMethod = SubtitleDeliveryMethod.Hls,\n                    RequireAvc = false,\n                    DeInterlace = false,\n                    RequireNonAnamorphic = false,\n                    EnableMpegtsM2TsMode = false,\n                    TranscodeReasons = mediaSource.TranscodeReasons == 0 ? null : mediaSource.TranscodeReasons.ToString(),\n                    Context = EncodingContext.Static,\n                    StreamOptions = new Dictionary<string, string>(),\n                    EnableAdaptiveBitrateStreaming = true\n                };\n\n                return await _dynamicHlsHelper.GetMasterHlsPlaylist(TranscodingJobType.Hls, dynamicHlsRequestDto, true)\n                    .ConfigureAwait(false);\n            }\n\n            var audioStreamingDto = new StreamingRequestDto\n            {\n                Id = itemId,\n                Container = isStatic ? null : (\".\" + mediaSource.TranscodingContainer),\n                Static = isStatic,\n                PlaySessionId = info.PlaySessionId,\n                MediaSourceId = mediaSourceId,\n                DeviceId = deviceId,\n                AudioCodec = audioCodec,\n                EnableAutoStreamCopy = true,\n                AllowAudioStreamCopy = true,\n                AllowVideoStreamCopy = true,\n                BreakOnNonKeyFrames = breakOnNonKeyFrames,\n                AudioSampleRate = maxAudioSampleRate,\n                MaxAudioChannels = maxAudioChannels,\n                AudioBitRate = isStatic ? (int?)null : (audioBitRate ?? maxStreamingBitrate),\n                MaxAudioBitDepth = maxAudioBitDepth,\n                AudioChannels = maxAudioChannels,\n                CopyTimestamps = true,\n                StartTimeTicks = startTimeTicks,\n                SubtitleMethod = SubtitleDeliveryMethod.Embed,\n                TranscodeReasons = mediaSource.TranscodeReasons == 0 ? null : mediaSource.TranscodeReasons.ToString(),\n                Context = EncodingContext.Static\n            };\n\n            return await _audioHelper.GetAudioStream(TranscodingJobType.Progressive, audioStreamingDto).ConfigureAwait(false);\n        }",
  "diff_func": "--- func_before\n+++ func_after\n [HttpGet(\"Audio/{itemId}/universal\")]\n         [HttpHead(\"Audio/{itemId}/universal\", Name = \"HeadUniversalAudioStream\")]\n         [Authorize(Policy = Policies.DefaultAuthorization)]\n         [ProducesResponseType(StatusCodes.Status200OK)]\n         [ProducesResponseType(StatusCodes.Status302Found)]\n         [ProducesAudioFile]\n         public async Task<ActionResult> GetUniversalAudioStream(\n             [FromRoute, Required] Guid itemId,\n             [FromQuery, ModelBinder(typeof(CommaDelimitedArrayModelBinder))] string[] container,\n             [FromQuery] string? mediaSourceId,\n             [FromQuery] string? deviceId,\n             [FromQuery] Guid? userId,\n-            [FromQuery] string? audioCodec,\n+            [FromQuery][RegularExpression(EncodingHelper.ValidationRegex)] string? audioCodec,\n             [FromQuery] int? maxAudioChannels,\n             [FromQuery] int? transcodingAudioChannels,\n             [FromQuery] int? maxStreamingBitrate,\n             [FromQuery] int? audioBitRate,\n             [FromQuery] long? startTimeTicks,\n-            [FromQuery] string? transcodingContainer,\n+            [FromQuery][RegularExpression(EncodingHelper.ValidationRegex)] string? transcodingContainer,\n             [FromQuery] string? transcodingProtocol,\n             [FromQuery] int? maxAudioSampleRate,\n             [FromQuery] int? maxAudioBitDepth,\n             [FromQuery] bool? enableRemoteMedia,\n             [FromQuery] bool breakOnNonKeyFrames = false,\n             [FromQuery] bool enableRedirection = true)\n         {\n             var deviceProfile = GetDeviceProfile(container, transcodingContainer, audioCodec, transcodingProtocol, breakOnNonKeyFrames, transcodingAudioChannels, maxAudioSampleRate, maxAudioBitDepth, maxAudioChannels);\n             var authorizationInfo = await _authorizationContext.GetAuthorizationInfo(Request).ConfigureAwait(false);\n             authorizationInfo.DeviceId = deviceId;\n \n             if (!userId.HasVa",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch adds RegularExpression validation to the audioCodec and transcodingContainer parameters, indicating a security measure to prevent malicious inputs.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}