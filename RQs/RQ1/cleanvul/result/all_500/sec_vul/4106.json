{
  "id": 4106,
  "language": "C/C++",
  "commit_url": "https://github.com/TokTok/c-toxcore/commit/6b97acb773622f9abca5ef305cd55bdef1ecc484",
  "commit_sha": "6b97acb773622f9abca5ef305cd55bdef1ecc484",
  "commit_msg": "Restrict packet kinds that can be sent through onion path.",
  "pr_url": "https://github.com/TokTok/c-toxcore/pull/872",
  "pr_info": "\n\n<!-- Reviewable:start -->\nThis change isâ€‚[<img src=\"https://reviewable.io/review_button.svg\" height=\"34\" align=\"absmiddle\" alt=\"Reviewable\"/>](https://reviewable.io/reviews/toktok/c-toxcore/872)\n<!-- Reviewable:end -->\n",
  "file_name": "toxcore/onion.c",
  "func_name": "handle_send_2",
  "func_before": "static int handle_send_2(void *object, IP_Port source, const uint8_t *packet, uint16_t length, void *userdata)\n{\n    Onion *onion = (Onion *)object;\n\n    if (length > ONION_MAX_PACKET_SIZE) {\n        return 1;\n    }\n\n    if (length <= 1 + SEND_3) {\n        return 1;\n    }\n\n    change_symmetric_key(onion);\n\n    uint8_t plain[ONION_MAX_PACKET_SIZE];\n    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];\n    get_shared_key(&onion->shared_keys_3, shared_key, dht_get_self_secret_key(onion->dht), packet + 1 + CRYPTO_NONCE_SIZE);\n    int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,\n                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);\n\n    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {\n        return 1;\n    }\n\n    IP_Port send_to;\n\n    if (ipport_unpack(&send_to, plain, len, 0) == -1) {\n        return 1;\n    }\n\n    uint8_t data[ONION_MAX_PACKET_SIZE];\n    memcpy(data, plain + SIZE_IPPORT, len - SIZE_IPPORT);\n    uint16_t data_len = (len - SIZE_IPPORT);\n    uint8_t *ret_part = data + (len - SIZE_IPPORT);\n    random_nonce(ret_part);\n    uint8_t ret_data[RETURN_2 + SIZE_IPPORT];\n    ipport_pack(ret_data, &source);\n    memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);\n    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),\n                                 ret_part + CRYPTO_NONCE_SIZE);\n\n    if (len != RETURN_3 - CRYPTO_NONCE_SIZE) {\n        return 1;\n    }\n\n    data_len += RETURN_3;\n\n    if ((uint32_t)sendpacket(onion->net, send_to, data, data_len) != data_len) {\n        return 1;\n    }\n\n    return 0;\n}",
  "func_after": "static int handle_send_2(void *object, IP_Port source, const uint8_t *packet, uint16_t length, void *userdata)\n{\n    Onion *onion = (Onion *)object;\n\n    if (length > ONION_MAX_PACKET_SIZE) {\n        return 1;\n    }\n\n    if (length <= 1 + SEND_3) {\n        return 1;\n    }\n\n    change_symmetric_key(onion);\n\n    uint8_t plain[ONION_MAX_PACKET_SIZE];\n    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];\n    get_shared_key(&onion->shared_keys_3, shared_key, dht_get_self_secret_key(onion->dht), packet + 1 + CRYPTO_NONCE_SIZE);\n    int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,\n                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);\n\n    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {\n        return 1;\n    }\n\n    if (len <= SIZE_IPPORT) {\n        return 1;\n    }\n\n    if (plain[SIZE_IPPORT] != NET_PACKET_ANNOUNCE_REQUEST &&\n            plain[SIZE_IPPORT] != NET_PACKET_ONION_DATA_REQUEST) {\n        return 1;\n    }\n\n    IP_Port send_to;\n\n    if (ipport_unpack(&send_to, plain, len, 0) == -1) {\n        return 1;\n    }\n\n    uint8_t data[ONION_MAX_PACKET_SIZE];\n    memcpy(data, plain + SIZE_IPPORT, len - SIZE_IPPORT);\n    uint16_t data_len = (len - SIZE_IPPORT);\n    uint8_t *ret_part = data + (len - SIZE_IPPORT);\n    random_nonce(ret_part);\n    uint8_t ret_data[RETURN_2 + SIZE_IPPORT];\n    ipport_pack(ret_data, &source);\n    memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);\n    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),\n                                 ret_part + CRYPTO_NONCE_SIZE);\n\n    if (len != RETURN_3 - CRYPTO_NONCE_SIZE) {\n        return 1;\n    }\n\n    data_len += RETURN_3;\n\n    if ((uint32_t)sendpacket(onion->net, send_to, data, data_len) != data_len) {\n        return 1;\n    }\n\n    return 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int handle_send_2(void *object, IP_Port source, const uint8_t *packet, uint16_t length, void *userdata)\n {\n     Onion *onion = (Onion *)object;\n \n     if (length > ONION_MAX_PACKET_SIZE) {\n         return 1;\n     }\n \n     if (length <= 1 + SEND_3) {\n         return 1;\n     }\n \n     change_symmetric_key(onion);\n \n     uint8_t plain[ONION_MAX_PACKET_SIZE];\n     uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];\n     get_shared_key(&onion->shared_keys_3, shared_key, dht_get_self_secret_key(onion->dht), packet + 1 + CRYPTO_NONCE_SIZE);\n     int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,\n                                      length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);\n \n     if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {\n+        return 1;\n+    }\n+\n+    if (len <= SIZE_IPPORT) {\n+        return 1;\n+    }\n+\n+    if (plain[SIZE_IPPORT] != NET_PACKET_ANNOUNCE_REQUEST &&\n+            plain[SIZE_IPPORT] != NET_PACKET_ONION_DATA_REQUEST) {\n         return 1;\n     }\n \n     IP_Port send_to;\n \n     if (ipport_unpack(&send_to, plain, len, 0) == -1) {\n         return 1;\n     }\n \n     uint8_t data[ONION_MAX_PACKET_SIZE];\n     memcpy(data, plain + SIZE_IPPORT, len - SIZE_IPPORT);\n     uint16_t data_len = (len - SIZE_IPPORT);\n     uint8_t *ret_part = data + (len - SIZE_IPPORT);\n     random_nonce(ret_part);\n     uint8_t ret_data[RETURN_2 + SIZE_IPPORT];\n     ipport_pack(ret_data, &source);\n     memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);\n     len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),\n                                  ret_part + CRYPTO_NONCE_SIZE);\n \n     if (len != RETURN_3 - CRYPTO_NONCE_SIZE) {\n         return 1;\n     }\n \n     data_len += RETURN_3;\n \n     if ((uint32_t)sendpacket(onion->net, send_to, data, data_len) != ",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch adds checks to restrict packet types, preventing unauthorized packets from being processed, which addresses a security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}