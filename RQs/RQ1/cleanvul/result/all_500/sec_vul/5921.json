{
  "id": 5921,
  "language": "C/C++",
  "commit_url": "https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c",
  "commit_sha": "81f466d05f2a89cb4f122ef7f593ff3f279b165c",
  "commit_msg": "attach: do not send procfd to attached process\n\nSo far, we opened a file descriptor refering to proc on the host inside the\nhost namespace and handed that fd to the attached process in\nattach_child_main(). This was done to ensure that LSM labels were correctly\nsetup. However, by exploiting a potential kernel bug, ptrace could be used to\nprevent the file descriptor from being closed which in turn could be used by an\nunprivileged container to gain access to the host namespace. Aside from this\nneeding an upstream kernel fix, we should make sure that we don't pass the fd\nfor proc itself to the attached process. However, we cannot completely prevent\nthis, as the attached process needs to be able to change its apparmor profile\nby writing to /proc/self/attr/exec or /proc/self/attr/current. To minimize the\nattack surface, we only send the fd for /proc/self/attr/exec or\n/proc/self/attr/current to the attached process. To do this we introduce a\nlittle more IPC between the child and parent:\n\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\nThe attached child tells the parent when it is ready to have its LSM labels set\nup. The parent then opens an approriate fd for the child PID to\n/proc/<pid>/attr/exec or /proc/<pid>/attr/current and sends it via SCM_RIGHTS\nto the child. The child can then set its LSM laben. Both sides then close the\nsocket fds and the child execs the requested process.\n\nSigned-off-by: Christian Brauner <christian.brauner@canonical.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/lxc/attach.c",
  "func_name": "lsm_set_label_at",
  "func_before": "int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {\n\tint labelfd = -1;\n\tint ret = 0;\n\tconst char* name;\n\tchar* command = NULL;\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\tgoto out;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\tgoto out;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec) {\n\t\tlabelfd = openat(procfd, \"self/attr/exec\", O_RDWR);\n\t}\n\telse {\n\t\tlabelfd = openat(procfd, \"self/attr/current\", O_RDWR);\n\t}\n\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open LSM label\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (write(labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\telse if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\telse {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\tfree(command);\n\n\tif (labelfd != -1)\n\t\tclose(labelfd);\n\n\treturn ret;\n}",
  "func_after": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\n\nout:\n\tfree(command);\n\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\n\treturn fret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n@@ -84 +85 @@\n-int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {\n+static int lsm_openat(int procfd, pid_t pid, int on_exec)\n+{\n+\tint ret = -1;\n int labelfd = -1;\n-\tint ret = 0;\n const char* name;\n-\tchar* command = NULL;\n+#define __LSMATTRLEN /* /proc */ (5 + /* /pid-to-str */ 21 + /* /current */ 7 + /* \\0 */ 1)\n+\tchar path[__LSMATTRLEN];\n \n name = lsm_name();\n \n-\t\tgoto out;\n+\t\treturn 0;\n \n if (strcmp(name, \"none\") == 0)\n-\t\tgoto out;\n+\t\treturn 0;\n \n /* We don't support on-exec with AppArmor */\n if (strcmp(name, \"AppArmor\") == 0)\n-\t\tlabelfd = openat(procfd, \"self/attr/exec\", O_RDWR);\n-\t}\n-\telse {\n-\t\tlabelfd = openat(procfd, \"self/attr/current\", O_RDWR);\n+\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n+\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n+\t\t\treturn -1;\n+\t\tlabelfd = openat(procfd, path, O_RDWR);\n+\t} else {\n+\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n+\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n+\t\t\treturn -1;\n+\t\tlabelfd = openat(procfd, path, O_RDWR);\n }\n \n if (labelfd < 0) {\n-\t\tret = -1;\n-\t\tgoto out;\n+\t\treturn -1;\n }\n \n+\treturn labelfd;\n+}\n+\n+static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n+{\n+\tint fret = -1;\n+\tconst char* name;\n+\tchar *command = NULL;\n+\n+\tname = lsm_name();\n+\n+\tif (strcmp(name, \"nop\") == 0)\n+\t\treturn 0;\n+\n+\tif (strcmp(name, \"none\") == 0)\n+\t\treturn 0;\n+\n+\t/* We don't support on-exec with AppArmor */\n+\tif (strcmp(name, \"AppArmor\") == 0)\n+\t\ton_exec = 0;\n+\n if (strcmp(name, \"AppArmor\") == 0) {\n int size;\n \n-\t\t\tret = -1;\n goto out;\n }\n \n-\t\t\tret = -1;\n goto out;\n }\n \n-\t\tif (write(labelfd, command, size + 1) < 0) {\n-\t\t\tSYSERROR(\"Unable to set LSM label\");\n-\t\t\tret = -1;\n+\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n+\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n goto out;\n }\n-\t}\n-\telse if (strcmp(name, \"SELinux\") == 0) {\n-\t\tif (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n+\t\tINFO(\"Set LSM label to: %s.\", command);\n+\t} else if (strcmp(nam",
  "diff_source": "api",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n1. The commit message indicates a security fix by addressing a potential kernel bug exploited via ptrace to access the host namespace.\n2. The code changes introduce IPC to limit file descriptors sent to the attached process, specifically targeting LSM label handling to minimize attack surface.\n3. The patch directly addresses a security vulnerability by preventing unauthorized access.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}