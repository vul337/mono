{
  "id": 1008,
  "language": "Java",
  "commit_url": "https://github.com/google/gson/commit/2d01d6a20f39881c692977564c1ea591d9f39027",
  "commit_sha": "2d01d6a20f39881c692977564c1ea591d9f39027",
  "commit_msg": "Make `Object` and `JsonElement` deserialization iterative (#1912)\n\n* Make Object and JsonElement deserialization iterative\r\n\r\nOften when Object and JsonElement are deserialized the format of the JSON\r\ndata is unknown and it might come from an untrusted source. To avoid a\r\nStackOverflowError from maliciously crafted JSON, deserialize Object and\r\nJsonElement iteratively instead of recursively.\r\n\r\nConcept based on https://github.com/FasterXML/jackson-databind/commit/51fd2faab70c9c8eb7ae43c200f8480f24ba74d8\r\nBut implementation is not based on it.\r\n\r\n* Improve imports grouping\r\n\r\n* Address review feedback",
  "pr_url": "https://github.com/google/gson/pull/1912",
  "pr_info": "Often when `Object` and `JsonElement` are deserialized the format of the JSON data is unknown and it might come from an untrusted source. To avoid a `StackOverflowError` from maliciously crafted JSON, deserialize `Object` and `JsonElement` iteratively instead of recursively.\r\nNote that in most cases Gson already catches `StackOverflowError` so users of current Gson versions would not encounter them.\r\n\r\nConcept based on https://github.com/FasterXML/jackson-databind/commit/51fd2faab70c9c8eb7ae43c200f8480f24ba74d8\r\nBut implementation is not based on it.",
  "file_name": "gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java",
  "func_name": "IOException",
  "func_before": "@Override public Object read(JsonReader in) throws IOException {\n    JsonToken token = in.peek();\n    switch (token) {\n    case BEGIN_ARRAY:\n      List<Object> list = new ArrayList<>();\n      in.beginArray();\n      while (in.hasNext()) {\n        list.add(read(in));\n      }\n      in.endArray();\n      return list;\n\n    case BEGIN_OBJECT:\n      Map<String, Object> map = new LinkedTreeMap<>();\n      in.beginObject();\n      while (in.hasNext()) {\n        map.put(in.nextName(), read(in));\n      }\n      in.endObject();\n      return map;\n\n    case STRING:\n      return in.nextString();\n\n    case NUMBER:\n      return toNumberStrategy.readNumber(in);\n\n    case BOOLEAN:\n      return in.nextBoolean();\n\n    case NULL:\n      in.nextNull();\n      return null;\n\n    default:\n      throw new IllegalStateException();\n    }\n  }",
  "func_after": "@Override public Object read(JsonReader in) throws IOException {\n    // Either List or Map\n    Object current;\n    JsonToken peeked = in.peek();\n\n    current = tryBeginNesting(in, peeked);\n    if (current == null) {\n      return readTerminal(in, peeked);\n    }\n\n    Deque<Object> stack = new ArrayDeque<>();\n\n    while (true) {\n      while (in.hasNext()) {\n        String name = null;\n        // Name is only used for JSON object members\n        if (current instanceof Map) {\n          name = in.nextName();\n        }\n\n        peeked = in.peek();\n        Object value = tryBeginNesting(in, peeked);\n        boolean isNesting = value != null;\n\n        if (value == null) {\n          value = readTerminal(in, peeked);\n        }\n\n        if (current instanceof List) {\n          @SuppressWarnings(\"unchecked\")\n          List<Object> list = (List<Object>) current;\n          list.add(value);\n        } else {\n          @SuppressWarnings(\"unchecked\")\n          Map<String, Object> map = (Map<String, Object>) current;\n          map.put(name, value);\n        }\n\n        if (isNesting) {\n          stack.addLast(current);\n          current = value;\n        }\n      }\n\n      // End current element\n      if (current instanceof List) {\n        in.endArray();\n      } else {\n        in.endObject();\n      }\n\n      if (stack.isEmpty()) {\n        return current;\n      } else {\n        // Continue with enclosing element\n        current = stack.removeLast();\n      }\n    }\n  }",
  "diff_func": "--- func_before\n+++ func_after\n @Override public Object read(JsonReader in) throws IOException {\n+    // Either List or Map\n+    Object current;\n-    JsonToken token = in.peek();\n+    JsonToken peeked = in.peek();\n-    switch (token) {\n-    case BEGIN_ARRAY:\n-      List<Object> list = new ArrayList<>();\n-      in.beginArray();\n+\n+    current = tryBeginNesting(in, peeked);\n+    if (current == null) {\n+      return readTerminal(in, peeked);\n+    }\n+\n+    Deque<Object> stack = new ArrayDeque<>();\n+\n+    while (true) {\n       while (in.hasNext()) {\n+        String name = null;\n+        // Name is only used for JSON object members\n+        if (current instanceof Map) {\n+          name = in.nextName();\n+        }\n+\n+        peeked = in.peek();\n+        Object value = tryBeginNesting(in, peeked);\n+        boolean isNesting = value != null;\n+\n+        if (value == null) {\n+          value = readTerminal(in, peeked);\n+        }\n+\n+        if (current instanceof List) {\n+          @SuppressWarnings(\"unchecked\")\n+          List<Object> list = (List<Object>) current;\n-        list.add(read(in));\n+          list.add(value);\n+        } else {\n+          @SuppressWarnings(\"unchecked\")\n+          Map<String, Object> map = (Map<String, Object>) current;\n+          map.put(name, value);\n+        }\n+\n+        if (isNesting) {\n+          stack.addLast(current);\n+          current = value;\n+        }\n       }\n-      in.endArray();\n-      return list;\n \n-    case BEGIN_OBJECT:\n-      Map<String, Object> map = new LinkedTreeMap<>();\n+      // End current element\n+      if (current instanceof List) {\n+        in.endArray();\n+      } else {\n-      in.beginObject();\n+        in.endObject();\n-      while (in.hasNext()) {\n-        map.put(in.nextName(), read(in));\n       }\n-      in.endObject();\n-      return map;\n \n+      if (stack.isEmpty()) {\n+        return current;\n+      } else {\n+        // Continue with enclosing element\n+        current = stack.removeLast();\n+      }\n-    case STRING:",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing stack overflow attacks during JSON deserialization. The iterative approach replaces the recursive method to handle malicious inputs safely.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}