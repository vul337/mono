{
  "id": 5590,
  "language": "C/C++",
  "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16",
  "commit_sha": "6b485b146a1b9d6ce72dfd7b5f36456c166e7a16",
  "commit_msg": "Fixed oob read in irp_write and similar",
  "pr_url": "https://github.com/FreeRDP/FreeRDP/pull/6151",
  "pr_info": "no more info",
  "file_name": "channels/serial/client/serial_main.c",
  "func_name": "serial_process_irp_create",
  "func_before": "static UINT serial_process_irp_create(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tDWORD DesiredAccess;\n\tDWORD SharedAccess;\n\tDWORD CreateDisposition;\n\tUINT32 PathLength;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     /* DesiredAccess (4 bytes) */\n\tStream_Seek_UINT64(irp->input);                    /* AllocationSize (8 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* FileAttributes (4 bytes) */\n\tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n\tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n\tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Seek(irp->input, PathLength); /* Path (variable) */\n\tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n#ifndef _WIN32\n\t/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n\t *     CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * then Windows 2012 sends :\n\t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n\t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |\n\t * FILE_SHARE_WRITE | FILE_SHARE_READ CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * assert(DesiredAccess == (GENERIC_READ | GENERIC_WRITE));\n\t * assert(SharedAccess == 0);\n\t * assert(CreateDisposition == OPEN_EXISTING);\n\t *\n\t */\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"DesiredAccess: 0x%\" PRIX32 \", SharedAccess: 0x%\" PRIX32\n\t           \", CreateDisposition: 0x%\" PRIX32 \"\",\n\t           DesiredAccess, SharedAccess, CreateDisposition);\n\t/* FIXME: As of today only the flags below are supported by CommCreateFileA: */\n\tDesiredAccess = GENERIC_READ | GENERIC_WRITE;\n\tSharedAccess = 0;\n\tCreateDisposition = OPEN_EXISTING;\n#endif\n\tserial->hComm =\n\t    CreateFile(serial->device.name, DesiredAccess, SharedAccess, NULL, /* SecurityAttributes */\n\t               CreateDisposition, 0,                                   /* FlagsAndAttributes */\n\t               NULL);                                                  /* TemplateFile */\n\n\tif (!serial->hComm || (serial->hComm == INVALID_HANDLE_VALUE))\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"CreateFile failure: %s last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, GetLastError());\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tgoto error_handle;\n\t}\n\n\t_comm_setServerSerialDriver(serial->hComm, serial->ServerSerialDriverId);\n\t_comm_set_permissive(serial->hComm, serial->permissive);\n\t/* NOTE: binary mode/raw mode required for the redirection. On\n\t * Linux, CommCreateFileA forces this setting.\n\t */\n\t/* ZeroMemory(&dcb, sizeof(DCB)); */\n\t/* dcb.DCBlength = sizeof(DCB); */\n\t/* GetCommState(serial->hComm, &dcb); */\n\t/* dcb.fBinary = TRUE; */\n\t/* SetCommState(serial->hComm, &dcb); */\n\tassert(irp->FileId == 0);\n\tirp->FileId = irp->devman->id_sequence++; /* FIXME: why not ((WINPR_COMM*)hComm)->fd? */\n\tirp->IoStatus = STATUS_SUCCESS;\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%s (DeviceId: %\" PRIu32 \", FileId: %\" PRIu32 \") created.\",\n\t           serial->device.name, irp->device->id, irp->FileId);\nerror_handle:\n\tStream_Write_UINT32(irp->output, irp->FileId); /* FileId (4 bytes) */\n\tStream_Write_UINT8(irp->output, 0);            /* Information (1 byte) */\n\treturn CHANNEL_RC_OK;\n}",
  "func_after": "static UINT serial_process_irp_create(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tDWORD DesiredAccess;\n\tDWORD SharedAccess;\n\tDWORD CreateDisposition;\n\tUINT32 PathLength;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     /* DesiredAccess (4 bytes) */\n\tStream_Seek_UINT64(irp->input);                    /* AllocationSize (8 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* FileAttributes (4 bytes) */\n\tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n\tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n\tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n\n\tif (!Stream_SafeSeek(irp->input, PathLength)) /* Path (variable) */\n\t\treturn ERROR_INVALID_DATA;\n\n\tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n#ifndef _WIN32\n\t/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n\t *     CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * then Windows 2012 sends :\n\t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n\t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |\n\t * FILE_SHARE_WRITE | FILE_SHARE_READ CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * assert(DesiredAccess == (GENERIC_READ | GENERIC_WRITE));\n\t * assert(SharedAccess == 0);\n\t * assert(CreateDisposition == OPEN_EXISTING);\n\t *\n\t */\n\tWLog_Print(serial->log, WLOG_DEBUG,\n\t           \"DesiredAccess: 0x%\" PRIX32 \", SharedAccess: 0x%\" PRIX32\n\t           \", CreateDisposition: 0x%\" PRIX32 \"\",\n\t           DesiredAccess, SharedAccess, CreateDisposition);\n\t/* FIXME: As of today only the flags below are supported by CommCreateFileA: */\n\tDesiredAccess = GENERIC_READ | GENERIC_WRITE;\n\tSharedAccess = 0;\n\tCreateDisposition = OPEN_EXISTING;\n#endif\n\tserial->hComm =\n\t    CreateFile(serial->device.name, DesiredAccess, SharedAccess, NULL, /* SecurityAttributes */\n\t               CreateDisposition, 0,                                   /* FlagsAndAttributes */\n\t               NULL);                                                  /* TemplateFile */\n\n\tif (!serial->hComm || (serial->hComm == INVALID_HANDLE_VALUE))\n\t{\n\t\tWLog_Print(serial->log, WLOG_WARN, \"CreateFile failure: %s last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, GetLastError());\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tgoto error_handle;\n\t}\n\n\t_comm_setServerSerialDriver(serial->hComm, serial->ServerSerialDriverId);\n\t_comm_set_permissive(serial->hComm, serial->permissive);\n\t/* NOTE: binary mode/raw mode required for the redirection. On\n\t * Linux, CommCreateFileA forces this setting.\n\t */\n\t/* ZeroMemory(&dcb, sizeof(DCB)); */\n\t/* dcb.DCBlength = sizeof(DCB); */\n\t/* GetCommState(serial->hComm, &dcb); */\n\t/* dcb.fBinary = TRUE; */\n\t/* SetCommState(serial->hComm, &dcb); */\n\tassert(irp->FileId == 0);\n\tirp->FileId = irp->devman->id_sequence++; /* FIXME: why not ((WINPR_COMM*)hComm)->fd? */\n\tirp->IoStatus = STATUS_SUCCESS;\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%s (DeviceId: %\" PRIu32 \", FileId: %\" PRIu32 \") created.\",\n\t           serial->device.name, irp->device->id, irp->FileId);\nerror_handle:\n\tStream_Write_UINT32(irp->output, irp->FileId); /* FileId (4 bytes) */\n\tStream_Write_UINT8(irp->output, 0);            /* Information (1 byte) */\n\treturn CHANNEL_RC_OK;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static UINT serial_process_irp_create(SERIAL_DEVICE* serial, IRP* irp)\n {\n \tDWORD DesiredAccess;\n \tDWORD SharedAccess;\n \tDWORD CreateDisposition;\n \tUINT32 PathLength;\n \n \tif (Stream_GetRemainingLength(irp->input) < 32)\n \t\treturn ERROR_INVALID_DATA;\n \n \tStream_Read_UINT32(irp->input, DesiredAccess);     /* DesiredAccess (4 bytes) */\n \tStream_Seek_UINT64(irp->input);                    /* AllocationSize (8 bytes) */\n \tStream_Seek_UINT32(irp->input);                    /* FileAttributes (4 bytes) */\n \tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n \tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n \tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n \tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n \n-\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n+\tif (!Stream_SafeSeek(irp->input, PathLength)) /* Path (variable) */\n \t\treturn ERROR_INVALID_DATA;\n \n-\tStream_Seek(irp->input, PathLength); /* Path (variable) */\n \tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n #ifndef _WIN32\n \t/* Windows 2012 server sends on a first call :\n \t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n \t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n \t *     CreateDisposition = 0x00000001: CREATE_NEW\n \t *\n \t * then Windows 2012 sends :\n \t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n \t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |\n \t * FILE_SHARE_WRITE | FILE_SHARE_READ CreateDisposition = 0x00000001: CREATE_NEW\n \t *\n \t * assert(DesiredAccess == (GENERIC_READ | GENERIC_WRITE));\n \t * assert(SharedAccess == 0);\n \t * assert(CreateDisposition == OPEN_EXISTING);\n \t *\n \t */\n \tWLog_Print(serial->log, WLOG_DEBUG,\n \t           \"DesiredAccess: 0x%\" PRIX32 \", SharedAccess: 0x%\" ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an out-of-bounds read vulnerability in the function `serial_process_irp_create` by replacing an unsafe seek operation with a safe one, thus preventing potential memory corruption or information disclosure.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}