{
  "id": 6452,
  "language": "Python",
  "commit_url": "https://github.com/openstack/keystone/commit/8735009dc5b895db265a1cd573f39f4acfca2a19",
  "commit_sha": "8735009dc5b895db265a1cd573f39f4acfca2a19",
  "commit_msg": "Ensures User is member of tenant in ec2 validation\n\nIt is possible that a user is no longer a member of a tenant when\nthey attempt to use an ec2 token. This checks to make sure that\nthe user still has at least one valid role in the tenant before\nauthenticating them. This should automatically work for the s3\nversion as well since it is a subclass.\n\nFixes bug 1064914\n\nChange-Id: Ieb237bae936a7b00ce7ba4d4c59aec6c7a69ec21",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "keystone/contrib/ec2/core.py",
  "func_name": "authenticate",
  "func_before": "def authenticate(self, context, credentials=None,\n                         ec2Credentials=None):\n        \"\"\"Validate a signed EC2 request and provide a token.\n\n        Other services (such as Nova) use this **admin** call to determine\n        if a request they signed received is from a valid user.\n\n        If it is a valid signature, an openstack token that maps\n        to the user/tenant is returned to the caller, along with\n        all the other details returned from a normal token validation\n        call.\n\n        The returned token is useful for making calls to other\n        OpenStack services within the context of the request.\n\n        :param context: standard context\n        :param credentials: dict of ec2 signature\n        :param ec2Credentials: DEPRECATED dict of ec2 signature\n        :returns: token: openstack token equivalent to access key along\n                         with the corresponding service catalog and roles\n        \"\"\"\n\n        # FIXME(ja): validate that a service token was used!\n\n        # NOTE(termie): backwards compat hack\n        if not credentials and ec2Credentials:\n            credentials = ec2Credentials\n\n        if not 'access' in credentials:\n            raise exception.Unauthorized(message='EC2 signature not supplied.')\n\n        creds_ref = self._get_credentials(context,\n                                          credentials['access'])\n        self.check_signature(creds_ref, credentials)\n\n        # TODO(termie): don't create new tokens every time\n        # TODO(termie): this is copied from TokenController.authenticate\n        token_id = uuid.uuid4().hex\n        tenant_ref = self.identity_api.get_tenant(\n                context=context,\n                tenant_id=creds_ref['tenant_id'])\n        user_ref = self.identity_api.get_user(\n                context=context,\n                user_id=creds_ref['user_id'])\n        metadata_ref = self.identity_api.get_metadata(\n                context=context,\n                user_id=user_ref['id'],\n                tenant_id=tenant_ref['id'])\n        catalog_ref = self.catalog_api.get_catalog(\n                context=context,\n                user_id=user_ref['id'],\n                tenant_id=tenant_ref['id'],\n                    metadata=metadata_ref)\n\n        token_ref = self.token_api.create_token(\n                context, token_id, dict(id=token_id,\n                                        user=user_ref,\n                                        tenant=tenant_ref,\n                                        metadata=metadata_ref))\n\n        # TODO(termie): optimize this call at some point and put it into the\n        #               the return for metadata\n        # fill out the roles in the metadata\n        roles_ref = []\n        for role_id in metadata_ref.get('roles', []):\n            roles_ref.append(self.identity_api.get_role(context, role_id))\n\n        # TODO(termie): make this a util function or something\n        # TODO(termie): i don't think the ec2 middleware currently expects a\n        #               full return, but it contains a note saying that it\n        #               would be better to expect a full return\n        token_controller = service.TokenController()\n        return token_controller._format_authenticate(\n                token_ref, roles_ref, catalog_ref)",
  "func_after": "def authenticate(self, context, credentials=None,\n                         ec2Credentials=None):\n        \"\"\"Validate a signed EC2 request and provide a token.\n\n        Other services (such as Nova) use this **admin** call to determine\n        if a request they signed received is from a valid user.\n\n        If it is a valid signature, an openstack token that maps\n        to the user/tenant is returned to the caller, along with\n        all the other details returned from a normal token validation\n        call.\n\n        The returned token is useful for making calls to other\n        OpenStack services within the context of the request.\n\n        :param context: standard context\n        :param credentials: dict of ec2 signature\n        :param ec2Credentials: DEPRECATED dict of ec2 signature\n        :returns: token: openstack token equivalent to access key along\n                         with the corresponding service catalog and roles\n        \"\"\"\n\n        # FIXME(ja): validate that a service token was used!\n\n        # NOTE(termie): backwards compat hack\n        if not credentials and ec2Credentials:\n            credentials = ec2Credentials\n\n        if not 'access' in credentials:\n            raise exception.Unauthorized(message='EC2 signature not supplied.')\n\n        creds_ref = self._get_credentials(context,\n                                          credentials['access'])\n        self.check_signature(creds_ref, credentials)\n\n        # TODO(termie): don't create new tokens every time\n        # TODO(termie): this is copied from TokenController.authenticate\n        token_id = uuid.uuid4().hex\n        tenant_ref = self.identity_api.get_tenant(\n                context=context,\n                tenant_id=creds_ref['tenant_id'])\n        user_ref = self.identity_api.get_user(\n                context=context,\n                user_id=creds_ref['user_id'])\n        metadata_ref = self.identity_api.get_metadata(\n            context=context,\n            user_id=user_ref['id'],\n            tenant_id=tenant_ref['id'])\n\n        # TODO(termie): optimize this call at some point and put it into the\n        #               the return for metadata\n        # fill out the roles in the metadata\n        roles = metadata_ref.get('roles', [])\n        if not roles:\n            raise exception.Unauthorized(message='User not valid for tenant.')\n        roles_ref = [self.identity_api.get_role(context, role_id)\n                     for role_id in roles]\n\n        catalog_ref = self.catalog_api.get_catalog(\n                context=context,\n                user_id=user_ref['id'],\n                tenant_id=tenant_ref['id'],\n                    metadata=metadata_ref)\n\n        token_ref = self.token_api.create_token(\n                context, token_id, dict(id=token_id,\n                                        user=user_ref,\n                                        tenant=tenant_ref,\n                                        metadata=metadata_ref))\n\n        # TODO(termie): make this a util function or something\n        # TODO(termie): i don't think the ec2 middleware currently expects a\n        #               full return, but it contains a note saying that it\n        #               would be better to expect a full return\n        token_controller = service.TokenController()\n        return token_controller._format_authenticate(\n                token_ref, roles_ref, catalog_ref)",
  "diff_func": "--- func_before\n+++ func_after\n def authenticate(self, context, credentials=None,\n                          ec2Credentials=None):\n         \"\"\"Validate a signed EC2 request and provide a token.\n \n         Other services (such as Nova) use this **admin** call to determine\n         if a request they signed received is from a valid user.\n \n         If it is a valid signature, an openstack token that maps\n         to the user/tenant is returned to the caller, along with\n         all the other details returned from a normal token validation\n         call.\n \n         The returned token is useful for making calls to other\n         OpenStack services within the context of the request.\n \n         :param context: standard context\n         :param credentials: dict of ec2 signature\n         :param ec2Credentials: DEPRECATED dict of ec2 signature\n         :returns: token: openstack token equivalent to access key along\n                          with the corresponding service catalog and roles\n         \"\"\"\n \n         # FIXME(ja): validate that a service token was used!\n \n         # NOTE(termie): backwards compat hack\n         if not credentials and ec2Credentials:\n             credentials = ec2Credentials\n \n         if not 'access' in credentials:\n             raise exception.Unauthorized(message='EC2 signature not supplied.')\n \n         creds_ref = self._get_credentials(context,\n                                           credentials['access'])\n         self.check_signature(creds_ref, credentials)\n \n         # TODO(termie): don't create new tokens every time\n         # TODO(termie): this is copied from TokenController.authenticate\n         token_id = uuid.uuid4().hex\n         tenant_ref = self.identity_api.get_tenant(\n                 context=context,\n                 tenant_id=creds_ref['tenant_id'])\n         user_ref = self.identity_api.get_user(\n                 context=context,\n                 user_id=creds_ref['user_id'])\n         metadata_ref = self.identity_api.get_metadata",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Analysis:**\n1. **Commit Message Insight:** The commit focuses on ensuring users are valid members of a tenant before EC2 authentication. This implies fixing a security issue where unauthorized users might gain access.\n2. **Code Diff Analysis:** The `authenticate` function now includes checks for valid user roles, preventing unauthorized access by ensuring users are still part of the tenant.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}