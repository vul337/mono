{
  "id": 2524,
  "language": "Java",
  "commit_url": "https://github.com/RPTools/maptool/commit/30367a6622cbbb2cfd676711e558d54d18b25f25",
  "commit_sha": "30367a6622cbbb2cfd676711e558d54d18b25f25",
  "commit_msg": "Handshake: Change symmetric key algorithm to CBC\n\nThe \"AES\" cipher is \"AES/ECB/PKCS5Padding\".\nECB mode ciphers are susceiptible to replay and chosen-plaintext attacks\nand while there's no known possible vulnerabilities using them\nsome cipher suites may not support ECB mode as a precaution\nwhich makes interoperability more difficult.\n\nThe 16-byte block size already makes a codebook attack impractical,\nbut adding an IV makes it even less so as recorded codes from previous\nsessions can't be reused.",
  "pr_url": "https://github.com/RPTools/maptool/pull/3361",
  "pr_info": "### Identify the Bug or Feature request\r\n\r\nresolves #3360 \r\n\r\n### Description of the Change\r\n\r\nChanges the CryptoUtil cipher to \"AES/CBC/PKCS5Padding\", adds an IV field to handshake messages, and generates a new IV per message.\r\n\r\nIn the process, found a couple of bugs, and removed CipherUtil objects, which were only used to immediately retrieve the key out of.\r\n\r\n### Possible Drawbacks\r\n\r\nSlightly more CPU cost involved in generating and transmitting the IV, and chaining blocks together.\r\n\r\nIt's more changes to cryptography that could result in a vulnerability.\r\n\r\n### Release Notes\r\n\r\n- Fixed a bug which could rarely cause a false handshake failure\r\n- Fixed error message reporting public key authentication failure while using password authentication.\r\n- Upgraded handshake cipher to CBC for better interoperability and precaution.\n\n<!-- Reviewable:start -->\n---\nThis change isâ€‚[<img src=\"https://reviewable.io/review_button.svg\" height=\"34\" align=\"absmiddle\" alt=\"Reviewable\"/>](https://reviewable.io/reviews/rptools/maptool/3361)\n<!-- Reviewable:end -->\n",
  "file_name": "src/main/java/net/rptools/maptool/server/ServerHandshake.java",
  "func_name": "handle",
  "func_before": "private void handle(ClientAuthMsg clientAuthMessage)\n      throws NoSuchAlgorithmException, InvalidKeySpecException, ExecutionException,\n          InterruptedException {\n    byte[] response = clientAuthMessage.getChallengeResponse().toByteArray();\n    if (handshakeChallenges.length > 1) {\n      if (Arrays.compare(response, handshakeChallenges[GM_CHALLENGE].getExpectedResponse()) == 0) {\n        setPlayer(playerDatabase.getPlayerWithRole(player.getName(), Role.GM));\n      } else if (Arrays.compare(\n              response, handshakeChallenges[PLAYER_CHALLENGE].getExpectedResponse())\n          == 0) {\n        setPlayer(playerDatabase.getPlayerWithRole(player.getName(), Role.PLAYER));\n      } else {\n        sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PASSWORD);\n        return;\n      }\n    } else if (currentState == State.AwaitingClientPasswordAuth) {\n      if (Arrays.compare(response, handshakeChallenges[0].getExpectedResponse()) != 0) {\n        sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PASSWORD);\n        return;\n      }\n    } else {\n      if (Arrays.compare(response, handshakeChallenges[0].getExpectedResponse()) != 0) {\n        sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PUBLIC_KEY);\n        return;\n      }\n    }\n    sendConnectionSuccessful();\n  }",
  "func_after": "private void handle(ClientAuthMsg clientAuthMessage)\n      throws NoSuchAlgorithmException, InvalidKeySpecException, ExecutionException,\n          InterruptedException, NoSuchPaddingException, IllegalBlockSizeException,\n          NoSuchAlgorithmException, BadPaddingException, InvalidKeyException,\n          InvalidAlgorithmParameterException {\n    byte[] response = clientAuthMessage.getChallengeResponse().toByteArray();\n    if (handshakeChallenges.length > 1) {\n      var iv = clientAuthMessage.getIv().toByteArray();\n      if (Arrays.compare(response, handshakeChallenges[GM_CHALLENGE].getExpectedResponse(iv))\n          == 0) {\n        setPlayer(playerDatabase.getPlayerWithRole(player.getName(), Role.GM));\n      } else if (Arrays.compare(\n              response, handshakeChallenges[PLAYER_CHALLENGE].getExpectedResponse(iv))\n          == 0) {\n        setPlayer(playerDatabase.getPlayerWithRole(player.getName(), Role.PLAYER));\n      } else {\n        sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PASSWORD);\n        return;\n      }\n    } else if (currentState == State.AwaitingClientPasswordAuth) {\n      var iv = clientAuthMessage.getIv().toByteArray();\n      if (Arrays.compare(response, handshakeChallenges[0].getExpectedResponse(iv)) != 0) {\n        sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PASSWORD);\n        return;\n      }\n    } else {\n      if (Arrays.compare(response, handshakeChallenges[0].getExpectedResponse()) != 0) {\n        sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PUBLIC_KEY);\n        return;\n      }\n    }\n    sendConnectionSuccessful();\n  }",
  "diff_func": "--- func_before\n+++ func_after\n private void handle(ClientAuthMsg clientAuthMessage)\n       throws NoSuchAlgorithmException, InvalidKeySpecException, ExecutionException,\n-          InterruptedException {\n+          InterruptedException, NoSuchPaddingException, IllegalBlockSizeException,\n+          NoSuchAlgorithmException, BadPaddingException, InvalidKeyException,\n+          InvalidAlgorithmParameterException {\n     byte[] response = clientAuthMessage.getChallengeResponse().toByteArray();\n     if (handshakeChallenges.length > 1) {\n+      var iv = clientAuthMessage.getIv().toByteArray();\n-      if (Arrays.compare(response, handshakeChallenges[GM_CHALLENGE].getExpectedResponse()) == 0) {\n+      if (Arrays.compare(response, handshakeChallenges[GM_CHALLENGE].getExpectedResponse(iv))\n+          == 0) {\n         setPlayer(playerDatabase.getPlayerWithRole(player.getName(), Role.GM));\n       } else if (Arrays.compare(\n-              response, handshakeChallenges[PLAYER_CHALLENGE].getExpectedResponse())\n+              response, handshakeChallenges[PLAYER_CHALLENGE].getExpectedResponse(iv))\n           == 0) {\n         setPlayer(playerDatabase.getPlayerWithRole(player.getName(), Role.PLAYER));\n       } else {\n         sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PASSWORD);\n         return;\n       }\n     } else if (currentState == State.AwaitingClientPasswordAuth) {\n+      var iv = clientAuthMessage.getIv().toByteArray();\n-      if (Arrays.compare(response, handshakeChallenges[0].getExpectedResponse()) != 0) {\n+      if (Arrays.compare(response, handshakeChallenges[0].getExpectedResponse(iv)) != 0) {\n         sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PASSWORD);\n         return;\n       }\n     } else {\n       if (Arrays.compare(response, handshakeChallenges[0].getExpectedResponse()) != 0) {\n         sendErrorResponseAndNotify(HandshakeResponseCodeMsg.INVALID_PUBLIC_KEY);\n         return;\n       }\n     }\n     sendConnectionSuccessful();\n   }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch changes the encryption algorithm from ECB to CBC mode, enhancing security by preventing replay and chosen-plaintext attacks. The code now uses an IV, improving resistance against such attacks. This addresses a known vulnerability in ECB mode.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}