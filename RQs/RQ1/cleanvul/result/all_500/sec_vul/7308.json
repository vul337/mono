{
  "id": 7308,
  "language": "C/C++",
  "commit_url": "https://github.com/OpenSC/OpenSC/commit/8fe377e93b4b56060e5bbfb6f3142ceaeca744fa",
  "commit_sha": "8fe377e93b4b56060e5bbfb6f3142ceaeca744fa",
  "commit_msg": "fixed out of bounds reads\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting and suggesting security fixes.",
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "pr_info": "This PR merges changes addressing issues identified by fuzzing OpenSC driver by Eric Sesterhenn. The separate commits are authored mostly by @frankmorgner, @dengert, Eric and me.\r\n\r\nFor more information, see the blog post:\r\n\r\nhttps://www.x41-dsec.de/lab/blog/smartcards/\r\n\r\nThe changes were tested to ensure they still work for the cards we have, but testing with more cards would be always appreciated.\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [X] PKCS#11 module is tested\r\n- [ ] Windows minidriver is tested\r\n- [ ] macOS tokend is tested\r\n",
  "file_name": "src/libopensc/asn1.c",
  "func_name": "sc_asn1_read_tag",
  "func_before": "int sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,\n\t\t     unsigned int *tag_out, size_t *taglen)\n{\n\tconst u8 *p = *buf;\n\tsize_t left = buflen, len;\n\tunsigned int cla, tag, i;\n\n\tif (left < 2)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t*buf = NULL;\n\tif (*p == 0xff || *p == 0) {\n\t\t/* end of data reached */\n\t\t*taglen = 0;\n\t\t*tag_out = SC_ASN1_TAG_EOC;\n\t\treturn SC_SUCCESS;\n\t}\n\t/* parse tag byte(s)\n\t * Resulted tag is presented by integer that has not to be\n\t * confused with the 'tag number' part of ASN.1 tag.\n\t */\n\tcla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);\n\ttag = *p & SC_ASN1_TAG_PRIMITIVE;\n\tp++;\n\tleft--;\n\tif (tag == SC_ASN1_TAG_PRIMITIVE) {\n\t\t/* high tag number */\n\t\tsize_t n = SC_ASN1_TAGNUM_SIZE - 1;\n\t\t/* search the last tag octet */\n\t\twhile (left-- != 0 && n != 0) {\n\t\t\ttag <<= 8;\n\t\t\ttag |= *p;\n\t\t\tif ((*p++ & 0x80) == 0)\n\t\t\t\tbreak;\n\t\t\tn--;\n\t\t}\n\t\tif (left == 0 || n == 0)\n\t\t\t/* either an invalid tag or it doesn't fit in\n\t\t\t * unsigned int */\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\n\t/* parse length byte(s) */\n\tlen = *p & 0x7f;\n\tif (*p++ & 0x80) {\n\t\tunsigned int a = 0;\n\t\tif (len > 4 || len > left)\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\tleft -= len;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= *p;\n\t\t\tp++;\n\t\t}\n\t\tlen = a;\n\t}\n\n\t*cla_out = cla;\n\t*tag_out = tag;\n\t*taglen = len;\n\t*buf = p;\n\n\tif (len > left)\n\t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;\n\n\treturn SC_SUCCESS;\n}",
  "func_after": "int sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,\n\t\t     unsigned int *tag_out, size_t *taglen)\n{\n\tconst u8 *p = *buf;\n\tsize_t left = buflen, len;\n\tunsigned int cla, tag, i;\n\n\tif (left < 2)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t*buf = NULL;\n\tif (*p == 0xff || *p == 0) {\n\t\t/* end of data reached */\n\t\t*taglen = 0;\n\t\t*tag_out = SC_ASN1_TAG_EOC;\n\t\treturn SC_SUCCESS;\n\t}\n\t/* parse tag byte(s)\n\t * Resulted tag is presented by integer that has not to be\n\t * confused with the 'tag number' part of ASN.1 tag.\n\t */\n\tcla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);\n\ttag = *p & SC_ASN1_TAG_PRIMITIVE;\n\tp++;\n\tleft--;\n\tif (tag == SC_ASN1_TAG_PRIMITIVE) {\n\t\t/* high tag number */\n\t\tsize_t n = SC_ASN1_TAGNUM_SIZE - 1;\n\t\t/* search the last tag octet */\n\t\twhile (left-- != 0 && n != 0) {\n\t\t\ttag <<= 8;\n\t\t\ttag |= *p;\n\t\t\tif ((*p++ & 0x80) == 0)\n\t\t\t\tbreak;\n\t\t\tn--;\n\t\t}\n\t\tif (left == 0 || n == 0)\n\t\t\t/* either an invalid tag or it doesn't fit in\n\t\t\t * unsigned int */\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\n\t/* parse length byte(s) */\n\tlen = *p & 0x7f;\n\tif (*p++ & 0x80) {\n\t\tunsigned int a = 0;\n\t\tleft--;\n\t\tif (len > 4 || len > left)\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\tleft -= len;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= *p;\n\t\t\tp++;\n\t\t}\n\t\tlen = a;\n\t}\n\n\t*cla_out = cla;\n\t*tag_out = tag;\n\t*taglen = len;\n\t*buf = p;\n\n\tif (len > left)\n\t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;\n\n\treturn SC_SUCCESS;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,\n \t\t     unsigned int *tag_out, size_t *taglen)\n {\n \tconst u8 *p = *buf;\n \tsize_t left = buflen, len;\n \tunsigned int cla, tag, i;\n \n \tif (left < 2)\n \t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n \t*buf = NULL;\n \tif (*p == 0xff || *p == 0) {\n \t\t/* end of data reached */\n \t\t*taglen = 0;\n \t\t*tag_out = SC_ASN1_TAG_EOC;\n \t\treturn SC_SUCCESS;\n \t}\n \t/* parse tag byte(s)\n \t * Resulted tag is presented by integer that has not to be\n \t * confused with the 'tag number' part of ASN.1 tag.\n \t */\n \tcla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);\n \ttag = *p & SC_ASN1_TAG_PRIMITIVE;\n \tp++;\n \tleft--;\n \tif (tag == SC_ASN1_TAG_PRIMITIVE) {\n \t\t/* high tag number */\n \t\tsize_t n = SC_ASN1_TAGNUM_SIZE - 1;\n \t\t/* search the last tag octet */\n \t\twhile (left-- != 0 && n != 0) {\n \t\t\ttag <<= 8;\n \t\t\ttag |= *p;\n \t\t\tif ((*p++ & 0x80) == 0)\n \t\t\t\tbreak;\n \t\t\tn--;\n \t\t}\n \t\tif (left == 0 || n == 0)\n \t\t\t/* either an invalid tag or it doesn't fit in\n \t\t\t * unsigned int */\n \t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n \t}\n \n \t/* parse length byte(s) */\n \tlen = *p & 0x7f;\n \tif (*p++ & 0x80) {\n \t\tunsigned int a = 0;\n+\t\tleft--;\n \t\tif (len > 4 || len > left)\n \t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n \t\tleft -= len;\n \t\tfor (i = 0; i < len; i++) {\n \t\t\ta <<= 8;\n \t\t\ta |= *p;\n \t\t\tp++;\n \t\t}\n \t\tlen = a;\n \t}\n \n \t*cla_out = cla;\n \t*tag_out = tag;\n \t*taglen = len;\n \t*buf = p;\n \n \tif (len > left)\n \t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;\n \n \treturn SC_SUCCESS;\n }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses an out-of-bounds read vulnerability by correctly managing the buffer length, preventing unauthorized data access.\n\n**Final Output:**\nAnalysis: The patch fixes an out-of-bounds read vulnerability in the ASN.1 parsing function, preventing potential data exposure or crashes. The commit message and code changes confirm this is a security fix.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}