{
  "id": 303,
  "language": "Java",
  "commit_url": "https://github.com/aosp-mirror/platform_frameworks_base/commit/a4131c50d07c7b58c496bd82b9ab3389b6721654",
  "commit_sha": "a4131c50d07c7b58c496bd82b9ab3389b6721654",
  "commit_msg": "Secure REMOTE_BUGREPORT_DISPATCH\n\nIn remote bugreport collection, Shell sends REMOTE_BUGREPORT_DISPATCH to\nDevicePolicyManagerService which in turn notifies Device Owners that a\nbug report is ready for collection. There existed a threat where a\nmalicous user could spoof the REMOTE_BUGREPORT_DISPATCH broadcast via\nADB to send a crafted bugreport to the Device Owner. Securing\nREMOTE_BUGREPORT_DISPATCH is not as easy as it appears: putting a\npermission on REMOTE_BUGREPORT_DISPATCH does not work since both the\nlegitimate sender and the malicious user are UID_SHELL. Instead, we\nintroduces a nonce which was sent from DPMS to Shell when bugreport is\ntriggered, and DPM will only accept REMOTE_BUGREPORT_DISPATCH when\na matching nonce is seen.\n\nIgnore-AOSP-First: security fix\n\nBug: 171495100\nTest: atest DeviceOwnerTest#testRemoteBugreportWithTwoUsers\nTest: atest DeviceOwnerTest#testAdminActionBookkeeping\nTest: atest BugreportManagerTest\nChange-Id: I7649b4f22b74647d152d76bb46d5ca70bfa3617d",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/RemoteBugreportManager.java",
  "func_name": "onBugreportFinished",
  "func_before": "private void onBugreportFinished(Intent intent) {\n        mHandler.removeCallbacks(mRemoteBugreportTimeoutRunnable);\n        mRemoteBugreportServiceIsActive.set(false);\n        final Uri bugreportUri = intent.getData();\n        String bugreportUriString = null;\n        if (bugreportUri != null) {\n            bugreportUriString = bugreportUri.toString();\n        }\n        final String bugreportHash = intent.getStringExtra(EXTRA_REMOTE_BUGREPORT_HASH);\n        if (mRemoteBugreportSharingAccepted.get()) {\n            shareBugreportWithDeviceOwnerIfExists(bugreportUriString, bugreportHash);\n            mInjector.getNotificationManager().cancel(LOG_TAG,\n                    NOTIFICATION_ID);\n        } else {\n            mService.setDeviceOwnerRemoteBugreportUriAndHash(bugreportUriString, bugreportHash);\n            mInjector.getNotificationManager().notifyAsUser(LOG_TAG, NOTIFICATION_ID,\n                    buildNotification(NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED),\n                    UserHandle.ALL);\n        }\n        mContext.unregisterReceiver(mRemoteBugreportFinishedReceiver);\n    }",
  "func_after": "private void onBugreportFinished(Intent intent) {\n        long nonce = intent.getLongExtra(DevicePolicyManager.EXTRA_REMOTE_BUGREPORT_NONCE, 0);\n        if (nonce == 0 || mRemoteBugreportNonce.get() != nonce) {\n            Slogf.w(LOG_TAG, \"Invalid nonce provided, ignoring \" + nonce);\n            return;\n        }\n        mHandler.removeCallbacks(mRemoteBugreportTimeoutRunnable);\n        mRemoteBugreportServiceIsActive.set(false);\n        final Uri bugreportUri = intent.getData();\n        String bugreportUriString = null;\n        if (bugreportUri != null) {\n            bugreportUriString = bugreportUri.toString();\n        }\n        final String bugreportHash = intent.getStringExtra(EXTRA_REMOTE_BUGREPORT_HASH);\n        if (mRemoteBugreportSharingAccepted.get()) {\n            shareBugreportWithDeviceOwnerIfExists(bugreportUriString, bugreportHash);\n            mInjector.getNotificationManager().cancel(LOG_TAG,\n                    NOTIFICATION_ID);\n        } else {\n            mService.setDeviceOwnerRemoteBugreportUriAndHash(bugreportUriString, bugreportHash);\n            mInjector.getNotificationManager().notifyAsUser(LOG_TAG, NOTIFICATION_ID,\n                    buildNotification(NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED),\n                    UserHandle.ALL);\n        }\n        mContext.unregisterReceiver(mRemoteBugreportFinishedReceiver);\n    }",
  "diff_func": "--- func_before\n+++ func_after\n private void onBugreportFinished(Intent intent) {\n+        long nonce = intent.getLongExtra(DevicePolicyManager.EXTRA_REMOTE_BUGREPORT_NONCE, 0);\n+        if (nonce == 0 || mRemoteBugreportNonce.get() != nonce) {\n+            Slogf.w(LOG_TAG, \"Invalid nonce provided, ignoring \" + nonce);\n+            return;\n+        }\n         mHandler.removeCallbacks(mRemoteBugreportTimeoutRunnable);\n         mRemoteBugreportServiceIsActive.set(false);\n         final Uri bugreportUri = intent.getData();\n         String bugreportUriString = null;\n         if (bugreportUri != null) {\n             bugreportUriString = bugreportUri.toString();\n         }\n         final String bugreportHash = intent.getStringExtra(EXTRA_REMOTE_BUGREPORT_HASH);\n         if (mRemoteBugreportSharingAccepted.get()) {\n             shareBugreportWithDeviceOwnerIfExists(bugreportUriString, bugreportHash);\n             mInjector.getNotificationManager().cancel(LOG_TAG,\n                     NOTIFICATION_ID);\n         } else {\n             mService.setDeviceOwnerRemoteBugreportUriAndHash(bugreportUriString, bugreportHash);\n             mInjector.getNotificationManager().notifyAsUser(LOG_TAG, NOTIFICATION_ID,\n                     buildNotification(NOTIFICATION_BUGREPORT_FINISHED_NOT_ACCEPTED),\n                     UserHandle.ALL);\n         }\n         mContext.unregisterReceiver(mRemoteBugreportFinishedReceiver);\n     }",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Analysis:**\nThe patch addresses a security vulnerability where a malicious user could spoof a broadcast to send a crafted bug report. The fix introduces a nonce mechanism to validate the broadcast, preventing unauthorized access.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}