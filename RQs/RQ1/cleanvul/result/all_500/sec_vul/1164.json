{
  "id": 1164,
  "language": "Java",
  "commit_url": "https://github.com/omnirom/android_frameworks_base/commit/8c90891a38ecb5047e115e13baf700a8b486a5d1",
  "commit_sha": "8c90891a38ecb5047e115e13baf700a8b486a5d1",
  "commit_msg": "DO NOT MERGE: Context#startInstrumentation could be started from SHELL only now.\n\nOr, if an instrumentation starts another instrumentation and so on,\nand the original instrumentation is started from SHELL, allow all\nContext#startInstrumentation calls in this chain.\n\nOtherwise, it'll throw a SecurityException.\n\nBug: 237766679\nTest: atest CtsAppTestCases:InstrumentationTest\nMerged-In: Ia08f225c21a3933067d066a578ea4af9c23e7d4c\nMerged-In: I1b76f61c5fd6c9f7e738978592260945a606f40c\nMerged-In: I3ea7aa27bd776fec546908a37f667f680da9c892\nChange-Id: I7ca7345b064e8e74f7037b8fa3ed45bb6423e406",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/am/ActivityManagerService.java",
  "func_name": "startInstrumentation",
  "func_before": "public boolean startInstrumentation(ComponentName className,\n            String profileFile, int flags, Bundle arguments,\n            IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection,\n            int userId, String abiOverride) {\n        enforceNotIsolatedCaller(\"startInstrumentation\");\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        userId = mUserController.handleIncomingUser(callingPid, callingUid,\n                userId, false, ALLOW_FULL_ONLY, \"startInstrumentation\", null);\n        // Refuse possible leaked file descriptors\n        if (arguments != null && arguments.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Bundle\");\n        }\n\n        synchronized(this) {\n            InstrumentationInfo ii = null;\n            ApplicationInfo ai = null;\n            try {\n                ii = mContext.getPackageManager().getInstrumentationInfo(\n                    className, STOCK_PM_FLAGS);\n                ai = AppGlobals.getPackageManager().getApplicationInfo(\n                        ii.targetPackage, STOCK_PM_FLAGS, userId);\n            } catch (PackageManager.NameNotFoundException e) {\n            } catch (RemoteException e) {\n            }\n            if (ii == null) {\n                reportStartInstrumentationFailureLocked(watcher, className,\n                        \"Unable to find instrumentation info for: \" + className);\n                return false;\n            }\n            if (ai == null) {\n                reportStartInstrumentationFailureLocked(watcher, className,\n                        \"Unable to find instrumentation target package: \" + ii.targetPackage);\n                return false;\n            }\n            if (!ai.hasCode()) {\n                reportStartInstrumentationFailureLocked(watcher, className,\n                        \"Instrumentation target has no code: \" + ii.targetPackage);\n                return false;\n            }\n\n            int match = mContext.getPackageManager().checkSignatures(\n                    ii.targetPackage, ii.packageName);\n            if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {\n                String msg = \"Permission Denial: starting instrumentation \"\n                        + className + \" from pid=\"\n                        + Binder.getCallingPid()\n                        + \", uid=\" + Binder.getCallingPid()\n                        + \" not allowed because package \" + ii.packageName\n                        + \" does not have a signature matching the target \"\n                        + ii.targetPackage;\n                reportStartInstrumentationFailureLocked(watcher, className, msg);\n                throw new SecurityException(msg);\n            }\n\n            ActiveInstrumentation activeInstr = new ActiveInstrumentation(this);\n            activeInstr.mClass = className;\n            String defProcess = ai.processName;;\n            if (ii.targetProcesses == null) {\n                activeInstr.mTargetProcesses = new String[]{ai.processName};\n            } else if (ii.targetProcesses.equals(\"*\")) {\n                activeInstr.mTargetProcesses = new String[0];\n            } else {\n                activeInstr.mTargetProcesses = ii.targetProcesses.split(\",\");\n                defProcess = activeInstr.mTargetProcesses[0];\n            }\n            activeInstr.mTargetInfo = ai;\n            activeInstr.mProfileFile = profileFile;\n            activeInstr.mArguments = arguments;\n            activeInstr.mWatcher = watcher;\n            activeInstr.mUiAutomationConnection = uiAutomationConnection;\n            activeInstr.mResultClass = className;\n            activeInstr.mHasBackgroundActivityStartsPermission = checkPermission(\n                    START_ACTIVITIES_FROM_BACKGROUND, callingPid, callingUid)\n                            == PackageManager.PERMISSION_GRANTED;\n\n            boolean disableHiddenApiChecks = ai.usesNonSdkApi()\n                    || (flags & INSTR_FLAG_DISABLE_HIDDEN_API_CHECKS) != 0;\n            boolean disableTestApiChecks = disableHiddenApiChecks\n                    || (flags & INSTR_FLAG_DISABLE_TEST_API_CHECKS) != 0;\n            if (disableHiddenApiChecks || disableTestApiChecks) {\n                enforceCallingPermission(android.Manifest.permission.DISABLE_HIDDEN_API_CHECKS,\n                        \"disable hidden API checks\");\n            }\n\n            // TODO(b/158750470): remove\n            final boolean mountExtStorageFull = isCallerShell()\n                    && (flags & INSTR_FLAG_DISABLE_ISOLATED_STORAGE) != 0;\n\n            final long origId = Binder.clearCallingIdentity();\n            // Instrumentation can kill and relaunch even persistent processes\n            forceStopPackageLocked(ii.targetPackage, -1, true, false, true, true, false, userId,\n                    \"start instr\");\n            // Inform usage stats to make the target package active\n            if (mUsageStatsService != null) {\n                mUsageStatsService.reportEvent(ii.targetPackage, userId,\n                        UsageEvents.Event.SYSTEM_INTERACTION);\n            }\n\n            ProcessRecord app = addAppLocked(ai, defProcess, false, disableHiddenApiChecks,\n                    disableTestApiChecks, mountExtStorageFull, abiOverride,\n                    ZYGOTE_POLICY_FLAG_EMPTY);\n            app.setActiveInstrumentation(activeInstr);\n            activeInstr.mFinished = false;\n            activeInstr.mSourceUid = callingUid;\n            activeInstr.mRunningProcesses.add(app);\n            if (!mActiveInstrumentation.contains(activeInstr)) {\n                mActiveInstrumentation.add(activeInstr);\n            }\n\n            if ((flags & INSTR_FLAG_DISABLE_ISOLATED_STORAGE) != 0) {\n                // Allow OP_NO_ISOLATED_STORAGE app op for the package running instrumentation with\n                // --no-isolated-storage flag.\n                mAppOpsService.setMode(AppOpsManager.OP_NO_ISOLATED_STORAGE, ai.uid,\n                        ii.packageName, AppOpsManager.MODE_ALLOWED);\n            }\n            Binder.restoreCallingIdentity(origId);\n        }\n\n        return true;\n    }",
  "func_after": "public boolean startInstrumentation(ComponentName className,\n            String profileFile, int flags, Bundle arguments,\n            IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection,\n            int userId, String abiOverride) {\n        enforceNotIsolatedCaller(\"startInstrumentation\");\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        userId = mUserController.handleIncomingUser(callingPid, callingUid,\n                userId, false, ALLOW_FULL_ONLY, \"startInstrumentation\", null);\n        // Refuse possible leaked file descriptors\n        if (arguments != null && arguments.hasFileDescriptors()) {\n            throw new IllegalArgumentException(\"File descriptors passed in Bundle\");\n        }\n\n        synchronized(this) {\n            InstrumentationInfo ii = null;\n            ApplicationInfo ai = null;\n            try {\n                ii = mContext.getPackageManager().getInstrumentationInfo(\n                    className, STOCK_PM_FLAGS);\n                ai = AppGlobals.getPackageManager().getApplicationInfo(\n                        ii.targetPackage, STOCK_PM_FLAGS, userId);\n            } catch (PackageManager.NameNotFoundException e) {\n            } catch (RemoteException e) {\n            }\n            if (ii == null) {\n                reportStartInstrumentationFailureLocked(watcher, className,\n                        \"Unable to find instrumentation info for: \" + className);\n                return false;\n            }\n            if (ai == null) {\n                reportStartInstrumentationFailureLocked(watcher, className,\n                        \"Unable to find instrumentation target package: \" + ii.targetPackage);\n                return false;\n            }\n            if (!ai.hasCode()) {\n                reportStartInstrumentationFailureLocked(watcher, className,\n                        \"Instrumentation target has no code: \" + ii.targetPackage);\n                return false;\n            }\n\n            int match = mContext.getPackageManager().checkSignatures(\n                    ii.targetPackage, ii.packageName);\n            if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {\n                String msg = \"Permission Denial: starting instrumentation \"\n                        + className + \" from pid=\"\n                        + Binder.getCallingPid()\n                        + \", uid=\" + Binder.getCallingPid()\n                        + \" not allowed because package \" + ii.packageName\n                        + \" does not have a signature matching the target \"\n                        + ii.targetPackage;\n                reportStartInstrumentationFailureLocked(watcher, className, msg);\n                throw new SecurityException(msg);\n            }\n            if (!Build.IS_DEBUGGABLE && callingUid != ROOT_UID && callingUid != SHELL_UID\n                    && callingUid != SYSTEM_UID && !hasActiveInstrumentationLocked(callingPid)) {\n                // If it's not debug build and not called from root/shell/system uid, reject it.\n                final String msg = \"Permission Denial: instrumentation test \"\n                        + className + \" from pid=\" + callingPid + \", uid=\" + callingUid\n                        + \", pkgName=\" + getPackageNameByPid(callingPid)\n                        + \" not allowed because it's not started from SHELL\";\n                Slog.wtfQuiet(TAG, msg);\n                reportStartInstrumentationFailureLocked(watcher, className, msg);\n                throw new SecurityException(msg);\n            }\n\n            ActiveInstrumentation activeInstr = new ActiveInstrumentation(this);\n            activeInstr.mClass = className;\n            String defProcess = ai.processName;;\n            if (ii.targetProcesses == null) {\n                activeInstr.mTargetProcesses = new String[]{ai.processName};\n            } else if (ii.targetProcesses.equals(\"*\")) {\n                activeInstr.mTargetProcesses = new String[0];\n            } else {\n                activeInstr.mTargetProcesses = ii.targetProcesses.split(\",\");\n                defProcess = activeInstr.mTargetProcesses[0];\n            }\n            activeInstr.mTargetInfo = ai;\n            activeInstr.mProfileFile = profileFile;\n            activeInstr.mArguments = arguments;\n            activeInstr.mWatcher = watcher;\n            activeInstr.mUiAutomationConnection = uiAutomationConnection;\n            activeInstr.mResultClass = className;\n            activeInstr.mHasBackgroundActivityStartsPermission = checkPermission(\n                    START_ACTIVITIES_FROM_BACKGROUND, callingPid, callingUid)\n                            == PackageManager.PERMISSION_GRANTED;\n\n            boolean disableHiddenApiChecks = ai.usesNonSdkApi()\n                    || (flags & INSTR_FLAG_DISABLE_HIDDEN_API_CHECKS) != 0;\n            boolean disableTestApiChecks = disableHiddenApiChecks\n                    || (flags & INSTR_FLAG_DISABLE_TEST_API_CHECKS) != 0;\n            if (disableHiddenApiChecks || disableTestApiChecks) {\n                enforceCallingPermission(android.Manifest.permission.DISABLE_HIDDEN_API_CHECKS,\n                        \"disable hidden API checks\");\n            }\n\n            // TODO(b/158750470): remove\n            final boolean mountExtStorageFull = isCallerShell()\n                    && (flags & INSTR_FLAG_DISABLE_ISOLATED_STORAGE) != 0;\n\n            final long origId = Binder.clearCallingIdentity();\n            // Instrumentation can kill and relaunch even persistent processes\n            forceStopPackageLocked(ii.targetPackage, -1, true, false, true, true, false, userId,\n                    \"start instr\");\n            // Inform usage stats to make the target package active\n            if (mUsageStatsService != null) {\n                mUsageStatsService.reportEvent(ii.targetPackage, userId,\n                        UsageEvents.Event.SYSTEM_INTERACTION);\n            }\n\n            ProcessRecord app = addAppLocked(ai, defProcess, false, disableHiddenApiChecks,\n                    disableTestApiChecks, mountExtStorageFull, abiOverride,\n                    ZYGOTE_POLICY_FLAG_EMPTY);\n            app.setActiveInstrumentation(activeInstr);\n            activeInstr.mFinished = false;\n            activeInstr.mSourceUid = callingUid;\n            activeInstr.mRunningProcesses.add(app);\n            if (!mActiveInstrumentation.contains(activeInstr)) {\n                mActiveInstrumentation.add(activeInstr);\n            }\n\n            if ((flags & INSTR_FLAG_DISABLE_ISOLATED_STORAGE) != 0) {\n                // Allow OP_NO_ISOLATED_STORAGE app op for the package running instrumentation with\n                // --no-isolated-storage flag.\n                mAppOpsService.setMode(AppOpsManager.OP_NO_ISOLATED_STORAGE, ai.uid,\n                        ii.packageName, AppOpsManager.MODE_ALLOWED);\n            }\n            Binder.restoreCallingIdentity(origId);\n        }\n\n        return true;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public boolean startInstrumentation(ComponentName className,\n             String profileFile, int flags, Bundle arguments,\n             IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection,\n             int userId, String abiOverride) {\n         enforceNotIsolatedCaller(\"startInstrumentation\");\n         final int callingUid = Binder.getCallingUid();\n         final int callingPid = Binder.getCallingPid();\n         userId = mUserController.handleIncomingUser(callingPid, callingUid,\n                 userId, false, ALLOW_FULL_ONLY, \"startInstrumentation\", null);\n         // Refuse possible leaked file descriptors\n         if (arguments != null && arguments.hasFileDescriptors()) {\n             throw new IllegalArgumentException(\"File descriptors passed in Bundle\");\n         }\n \n         synchronized(this) {\n             InstrumentationInfo ii = null;\n             ApplicationInfo ai = null;\n             try {\n                 ii = mContext.getPackageManager().getInstrumentationInfo(\n                     className, STOCK_PM_FLAGS);\n                 ai = AppGlobals.getPackageManager().getApplicationInfo(\n                         ii.targetPackage, STOCK_PM_FLAGS, userId);\n             } catch (PackageManager.NameNotFoundException e) {\n             } catch (RemoteException e) {\n             }\n             if (ii == null) {\n                 reportStartInstrumentationFailureLocked(watcher, className,\n                         \"Unable to find instrumentation info for: \" + className);\n                 return false;\n             }\n             if (ai == null) {\n                 reportStartInstrumentationFailureLocked(watcher, className,\n                         \"Unable to find instrumentation target package: \" + ii.targetPackage);\n                 return false;\n             }\n             if (!ai.hasCode()) {\n                 reportStartInstrumentationFailureLocked(watcher, className,\n                         \"Instrumentati",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}