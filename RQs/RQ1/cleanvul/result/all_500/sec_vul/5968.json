{
  "id": 5968,
  "language": "Python",
  "commit_url": "https://github.com/urllib3/urllib3/commit/a74c9cfbaed9f811e7563cfc3dce894928e0221a",
  "commit_sha": "a74c9cfbaed9f811e7563cfc3dce894928e0221a",
  "commit_msg": "Percent-encode invalid characters with request target (#1586)",
  "pr_url": "https://github.com/urllib3/urllib3/pull/1586",
  "pr_info": "Closes #1585. cc @theacodes @sigmavirus24 \r\n",
  "file_name": "src/urllib3/util/url.py",
  "func_name": "parse_url",
  "func_before": "def parse_url(url):\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 compliant.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urlparse`.\n\n    Example::\n\n        >>> parse_url('http://google.com/mail/')\n        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n        >>> parse_url('google.com:80')\n        Url(scheme=None, host='google.com', port=80, path=None, ...)\n        >>> parse_url('/foo?bar')\n        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    is_string = not isinstance(url, six.binary_type)\n    if not is_string:\n        url = url.decode(\"utf-8\")\n\n    # RFC 3986 doesn't like URLs that have a host but don't start\n    # with a scheme and we support URLs like that so we need to\n    # detect that problem and add an empty scheme indication.\n    # We don't get hurt on path-only URLs here as it's stripped\n    # off and given an empty scheme anyways.\n    if not SCHEME_REGEX.search(url):\n        url = \"//\" + url\n\n    try:\n        iri_ref = rfc3986.IRIReference.from_string(url, encoding=\"utf-8\")\n    except (ValueError, RFC3986Exception):\n        six.raise_from(LocationParseError(url), None)\n\n    def idna_encode(name):\n        if name and any([ord(x) > 128 for x in name]):\n            try:\n                import idna\n            except ImportError:\n                raise LocationParseError(\"Unable to parse URL without the 'idna' module\")\n            try:\n                return idna.encode(name.lower(), strict=True, std3_rules=True)\n            except idna.IDNAError:\n                raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)\n        return name\n\n    has_authority = iri_ref.authority is not None\n    uri_ref = iri_ref.encode(idna_encoder=idna_encode)\n\n    # rfc3986 strips the authority if it's invalid\n    if has_authority and uri_ref.authority is None:\n        raise LocationParseError(url)\n\n    # Only normalize schemes we understand to not break http+unix\n    # or other schemes that don't follow RFC 3986.\n    if uri_ref.scheme is None or uri_ref.scheme.lower() in NORMALIZABLE_SCHEMES:\n        uri_ref = uri_ref.normalize()\n\n    # Validate all URIReference components and ensure that all\n    # components that were set before are still set after\n    # normalization has completed.\n    validator = Validator()\n    try:\n        validator.check_validity_of(\n            *validator.COMPONENT_NAMES\n        ).validate(uri_ref)\n    except ValidationError:\n        six.raise_from(LocationParseError(url), None)\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    path = uri_ref.path\n    if not path:\n        if (uri_ref.query is not None\n                or uri_ref.fragment is not None):\n            path = \"\"\n        else:\n            path = None\n\n    # Ensure that each part of the URL is a `str` for\n    # backwards compatibility.\n    def to_input_type(x):\n        if x is None:\n            return None\n        elif not is_string and not isinstance(x, six.binary_type):\n            return x.encode('utf-8')\n        return x\n\n    return Url(\n        scheme=to_input_type(uri_ref.scheme),\n        auth=to_input_type(uri_ref.userinfo),\n        host=to_input_type(uri_ref.host),\n        port=int(uri_ref.port) if uri_ref.port is not None else None,\n        path=to_input_type(path),\n        query=to_input_type(uri_ref.query),\n        fragment=to_input_type(uri_ref.fragment)\n    )",
  "func_after": "def parse_url(url):\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 compliant.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urlparse`.\n\n    Example::\n\n        >>> parse_url('http://google.com/mail/')\n        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n        >>> parse_url('google.com:80')\n        Url(scheme=None, host='google.com', port=80, path=None, ...)\n        >>> parse_url('/foo?bar')\n        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    is_string = not isinstance(url, six.binary_type)\n\n    # RFC 3986 doesn't like URLs that have a host but don't start\n    # with a scheme and we support URLs like that so we need to\n    # detect that problem and add an empty scheme indication.\n    # We don't get hurt on path-only URLs here as it's stripped\n    # off and given an empty scheme anyways.\n    if not SCHEME_REGEX.search(url):\n        url = \"//\" + url\n\n    def idna_encode(name):\n        if name and any([ord(x) > 128 for x in name]):\n            try:\n                import idna\n            except ImportError:\n                raise LocationParseError(\"Unable to parse URL without the 'idna' module\")\n            try:\n                return idna.encode(name.lower(), strict=True, std3_rules=True)\n            except idna.IDNAError:\n                raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)\n        return name\n\n    try:\n        split_iri = misc.IRI_MATCHER.match(compat.to_str(url)).groupdict()\n        iri_ref = rfc3986.IRIReference(\n            split_iri['scheme'], split_iri['authority'],\n            _encode_invalid_chars(split_iri['path'], PATH_CHARS),\n            _encode_invalid_chars(split_iri['query'], QUERY_CHARS),\n            _encode_invalid_chars(split_iri['fragment'], FRAGMENT_CHARS)\n        )\n        has_authority = iri_ref.authority is not None\n        uri_ref = iri_ref.encode(idna_encoder=idna_encode)\n    except (ValueError, RFC3986Exception):\n        return six.raise_from(LocationParseError(url), None)\n\n    # rfc3986 strips the authority if it's invalid\n    if has_authority and uri_ref.authority is None:\n        raise LocationParseError(url)\n\n    # Only normalize schemes we understand to not break http+unix\n    # or other schemes that don't follow RFC 3986.\n    if uri_ref.scheme is None or uri_ref.scheme.lower() in NORMALIZABLE_SCHEMES:\n        uri_ref = uri_ref.normalize()\n\n    # Validate all URIReference components and ensure that all\n    # components that were set before are still set after\n    # normalization has completed.\n    validator = Validator()\n    try:\n        validator.check_validity_of(\n            *validator.COMPONENT_NAMES\n        ).validate(uri_ref)\n    except ValidationError:\n        return six.raise_from(LocationParseError(url), None)\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    path = uri_ref.path\n    if not path:\n        if (uri_ref.query is not None\n                or uri_ref.fragment is not None):\n            path = \"\"\n        else:\n            path = None\n\n    # Ensure that each part of the URL is a `str` for\n    # backwards compatibility.\n    def to_input_type(x):\n        if x is None:\n            return None\n        elif not is_string and not isinstance(x, six.binary_type):\n            return x.encode('utf-8')\n        return x\n\n    return Url(\n        scheme=to_input_type(uri_ref.scheme),\n        auth=to_input_type(uri_ref.userinfo),\n        host=to_input_type(uri_ref.host),\n        port=int(uri_ref.port) if uri_ref.port is not None else None,\n        path=to_input_type(path),\n        query=to_input_type(uri_ref.query),\n        fragment=to_input_type(uri_ref.fragment)\n    )",
  "diff_func": "--- func_before\n+++ func_after\n def parse_url(url):\n     \"\"\"\n     Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n     performed to parse incomplete urls. Fields not provided will be None.\n     This parser is RFC 3986 compliant.\n \n     :param str url: URL to parse into a :class:`.Url` namedtuple.\n \n     Partly backwards-compatible with :mod:`urlparse`.\n \n     Example::\n \n         >>> parse_url('http://google.com/mail/')\n         Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n         >>> parse_url('google.com:80')\n         Url(scheme=None, host='google.com', port=80, path=None, ...)\n         >>> parse_url('/foo?bar')\n         Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n     \"\"\"\n     if not url:\n         # Empty\n         return Url()\n \n     is_string = not isinstance(url, six.binary_type)\n-    if not is_string:\n-        url = url.decode(\"utf-8\")\n \n     # RFC 3986 doesn't like URLs that have a host but don't start\n     # with a scheme and we support URLs like that so we need to\n     # detect that problem and add an empty scheme indication.\n     # We don't get hurt on path-only URLs here as it's stripped\n     # off and given an empty scheme anyways.\n     if not SCHEME_REGEX.search(url):\n         url = \"//\" + url\n-\n-    try:\n-        iri_ref = rfc3986.IRIReference.from_string(url, encoding=\"utf-8\")\n-    except (ValueError, RFC3986Exception):\n-        six.raise_from(LocationParseError(url), None)\n \n     def idna_encode(name):\n         if name and any([ord(x) > 128 for x in name]):\n             try:\n                 import idna\n             except ImportError:\n                 raise LocationParseError(\"Unable to parse URL without the 'idna' module\")\n             try:\n                 return idna.encode(name.lower(), strict=True, std3_rules=True)\n             except idna.IDNAError:\n                 raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)\n         return name\n \n+    try:\n+ ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the URL parsing function to correctly handle invalid characters by percent-encoding them, preventing potential security issues like injection attacks.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}