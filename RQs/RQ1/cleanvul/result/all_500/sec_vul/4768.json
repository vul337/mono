{
  "id": 4768,
  "language": "C/C++",
  "commit_url": "https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa",
  "commit_sha": "efbe126e3ebb9123ac9d058aa2bb044261342aaa",
  "commit_msg": "Fix missing NULL checks in CKE processing\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "pr_info": "This adds support callbacks for \"custom\" TLS Extensions, on both the Client and Server side.  On top of that, it adds a notion of a \"serverinfo\" or \"serverinfo file\", which is a block of data containing TLS Extensions to be returned in response to ClientHello Extensions.\n\nThis can be used to implement Certificate Transparency's SignedCertificateTimestampList, as well as TACK's TackExtension.  It could be used by any other proposal that want to staple server info into the handshake.\n\nThis patch should be complete, and includes some light tests.  If this is accepted, I could follow-on with improved tests and docs.\n",
  "file_name": "ssl/statem/statem_clnt.c",
  "func_name": "tls_construct_cke_ecdhe",
  "func_before": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    ckey = ssl_generate_pkey(skey);\n\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    /* Generate encoding of client key */\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n\n    *len = encoded_pt_len;\n\n    /* length of encoded point */\n    **p = *len;\n    *p += 1;\n    /* copy the point */\n    memcpy(*p, encodedPoint, *len);\n    /* increment len to account for length field */\n    *len += 1;\n\n    OPENSSL_free(encodedPoint);\n\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}",
  "func_after": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    /* Generate encoding of client key */\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n\n    *len = encoded_pt_len;\n\n    /* length of encoded point */\n    **p = *len;\n    *p += 1;\n    /* copy the point */\n    memcpy(*p, encodedPoint, *len);\n    /* increment len to account for length field */\n    *len += 1;\n\n    OPENSSL_free(encodedPoint);\n\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n {\n #ifndef OPENSSL_NO_EC\n     unsigned char *encodedPoint = NULL;\n     int encoded_pt_len = 0;\n     EVP_PKEY *ckey = NULL, *skey = NULL;\n \n     skey = s->s3->peer_tmp;\n     if (skey == NULL) {\n         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n         return 0;\n     }\n \n     ckey = ssl_generate_pkey(skey);\n+    if (ckey == NULL) {\n+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n \n     if (ssl_derive(s, ckey, skey) == 0) {\n         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n         goto err;\n     }\n \n     /* Generate encoding of client key */\n     encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n \n     if (encoded_pt_len == 0) {\n         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n         goto err;\n     }\n \n     EVP_PKEY_free(ckey);\n     ckey = NULL;\n \n     *len = encoded_pt_len;\n \n     /* length of encoded point */\n     **p = *len;\n     *p += 1;\n     /* copy the point */\n     memcpy(*p, encodedPoint, *len);\n     /* increment len to account for length field */\n     *len += 1;\n \n     OPENSSL_free(encodedPoint);\n \n     return 1;\n  err:\n     EVP_PKEY_free(ckey);\n     return 0;\n #else\n     SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n     *al = SSL_AD_INTERNAL_ERROR;\n     return 0;\n #endif\n }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.8",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch adds a NULL check for `ckey` in the TLS key exchange processing function. This fix addresses a potential crash or incorrect state due to a missing check, which could lead to a denial of service. Given the context of OpenSSL's critical role in security, this is classified as a security fix.\n\n**Final Output:**\nAnalysis: The patch adds a NULL check for `ckey` to prevent potential crashes or incorrect processing in the TLS key exchange, which could lead to a denial of service. This is a security fix as it mitigates a potential exploit in a security-critical library.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.8"
}