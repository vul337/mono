{
  "id": 3151,
  "language": "Java",
  "commit_url": "https://github.com/dogtagpki/pki/commit/eea6184452505f1755b7e5b9d12b0fb765742fec",
  "commit_sha": "eea6184452505f1755b7e5b9d12b0fb765742fec",
  "commit_msg": "Bug1979710-TPS: separate config actions by profile permission list\n\nThis patch addresses the issue that TPS agent operations on tokens,\nactivities, and profiles are not limited by the types (profiles)\npermmtted to the agent (as described in the documentation).\nThis is a regression from 8.x.\n\nThe affected operations are:\n - findProfiles\n - getProfiles\n - updateProfile\n - changeStatus (of a profile)\n - retrieveTokens\n - getToken\n - modifyToken\n - changeTokenStatus\n - retrieveActivities\n - getActivity\n\nNote that some operations that seem like should be affected are not\ndue to the fact that they are TPS admin operations and are shielded\nfrom entering the TPS service at the activity level.  For example,\ndeleting a token would be such a case.\n\nThe authorization enforcement added in this patch should affect both\naccess from the web UI as well as access from PKI CLI.\nReference: https://github.com/dogtagpki/pki/wiki/PKI-TPS-CLI\n\nAnother note: the VLV complicates the resulting page.  If the returned\nentries on the page are all restricted then nothing would be shown.  To\nadd a bit more clarity, an <restricted> entry is added to reflect such\neffect so that it would be less confusing to the role user.\nThe <restricted> entries are left with the epoch date.\nThis would affect both WEB UI and PKI CLI.\n\nAlso, a list minute addition to address an issue with 1911472 in\nCertService.java where the subject DN of the CA signing cert should\nbe used instead of the issuer.\n\nfixes https://bugzilla.redhat.com/show_bug.cgi?id=1979710",
  "pr_url": "https://github.com/dogtagpki/pki/pull/3655",
  "pr_info": "    Bug1979710-TPS: separate config actions by profile permission list\r\n    \r\n    This patch addresses the issue that TPS agent operations on tokens,\r\n    activities, and profiles are not limited by the types (profiles)\r\n    permmtted to the agent (as described in the documentation).\r\n    This is a regression from 8.x.\r\n    \r\n    The affected operations are:\r\n     - findProfiles\r\n     - getProfiles\r\n     - updateProfile\r\n     - changeStatus (of a profile)\r\n     - retrieveTokens\r\n     - getToken\r\n     - modifyToken\r\n     - changeTokenStatus\r\n     - retrieveActivities\r\n     - getActivity\r\n    \r\n    Note that some operations that seem like should be affected are not\r\n    due to the fact that they are TPS admin operations and are shielded\r\n    from entering the TPS service at the activity level.  For example,\r\n    deleting a token would be such a case.\r\n    \r\n    The authorization enforcement added in this patch should affect both\r\n    access from the web UI as well as access from PKI CLI.\r\n    Reference: https://github.com/dogtagpki/pki/wiki/PKI-TPS-CLI\r\n    \r\n    Another note: the VLV complicates the resulting page.  If the returned\r\n    entries on the page are all restricted then nothing would be shown.  To\r\n    add a bit more clarity, an <restricted> entry is added to reflect such\r\n    effect so that it would be less confusing to the role user. The <restricted>\r\n    entries are left with the epoch date.\r\n    This would affect both WEB UI and PKI CLI.\r\n    \r\n    fixes https://bugzilla.redhat.com/show_bug.cgi?id=1979710",
  "file_name": "base/tps/src/org/dogtagpki/server/tps/rest/ActivityService.java",
  "func_name": "retrieveActivitiesWithVLV",
  "func_before": "protected void retrieveActivitiesWithVLV(\n            ActivityDatabase database,\n            Integer start,\n            Integer size,\n            ActivityCollection response) throws Exception {\n\n        // search with VLV sorted by date in reverse order\n        IDBVirtualList<ActivityRecord> list = database.findRecords(\n                null, null, new String[] { \"-date\" }, size);\n\n        int total = list.getSize();\n\n        // return entries in the requested page\n        for (int i = start; i < start + size && i < total; i++) {\n            ActivityRecord record = list.getElementAt(i);\n\n            if (record == null) {\n                CMS.debug(\"ActivityService: Activity record not found\");\n                throw new PKIException(\"Activity record not found\");\n            }\n\n            response.addEntry(createActivityData(record));\n        }\n\n        response.setTotal(total);\n    }",
  "func_after": "protected void retrieveActivitiesWithVLV(\n            ActivityDatabase database,\n            Integer start,\n            Integer size,\n            ActivityCollection response) throws Exception {\n\n        String method = \"ActivityService.retrieveActivitiesWithVLV: \";\n        CMS.debug(method);\n        // search with VLV sorted by date in reverse order\n        IDBVirtualList<ActivityRecord> list = database.findRecords(\n                null, null, new String[] { \"-date\" }, size);\n\n        List<String> authorizedProfiles = getAuthorizedProfiles();\n\n        int total = list.getSize();\n        CMS.debug(method + \"total: \" + total);\n        int retTotal = 0; // debugging only\n\n        // return entries in the requested page\n        if (authorizedProfiles != null) {\n            if (authorizedProfiles.contains(UserResource.ALL_PROFILES)) {\n                for (int i = start; i < start + size && i < total; i++) {\n                    ActivityRecord record = list.getElementAt(i);\n\n                    response.addEntry(createActivityData(record));\n                    retTotal++;\n                }\n            } else { // not authorized for all profiles\n                for (int i = start; i < start + size && i < total; i++) {\n                    ActivityRecord record = list.getElementAt(i);\n\n                    //CMS.debug(method + \"record.Id=\"+ record.getId());\n                    // On some rare occasions, some activities don't have\n                    // their token type filled in. It is therefore necessary\n                    // to get it from the token record directly.\n                    String type = record.getType();\n                    //CMS.debug(method + \"record.tokenType=\"+ type);\n                    if ((type == null) || type.isEmpty()) {\n                        CMS.debug(method + \"record.tokenType null...getting from token record\");\n                        String tokenID = record.getTokenID();\n                        if ((tokenID != null) && !tokenID.isEmpty()) {\n                            TPSSubsystem subsystem = (TPSSubsystem) CMS.getSubsystem(TPSSubsystem.ID);\n                            TokenDatabase t_database = subsystem.getTokenDatabase();\n                            TokenRecord t_record = t_database.getRecord(tokenID);\n                            if (t_record != null)\n                                type = t_record.getType();\n                        }\n                    }\n\n                    //CMS.debug(method + \"type=\"+ type);\n                    if ((type == null) || type.isEmpty() || authorizedProfiles.contains(type)) {\n                        //CMS.debug(method + \"token type allowed\");\n                        retTotal++;\n                        response.addEntry(createActivityData(record));\n                    } else {\n                        CMS.debug(method + \"token type restricted; adding 'restricted' record\");\n                        response.addEntry(createRestrictedActivityData());\n                    }\n                } //for\n            }\n        } else { //authorizedProfiles null; no permission\n            CMS.debug(method + \"authorized profiles is null\");\n        }\n\n        CMS.debug(method + \"retTotal = \" + retTotal);\n        response.setTotal(total);\n    }",
  "diff_func": "--- func_before\n+++ func_after\n protected void retrieveActivitiesWithVLV(\n             ActivityDatabase database,\n             Integer start,\n             Integer size,\n             ActivityCollection response) throws Exception {\n \n+        String method = \"ActivityService.retrieveActivitiesWithVLV: \";\n+        CMS.debug(method);\n         // search with VLV sorted by date in reverse order\n         IDBVirtualList<ActivityRecord> list = database.findRecords(\n                 null, null, new String[] { \"-date\" }, size);\n \n+        List<String> authorizedProfiles = getAuthorizedProfiles();\n+\n         int total = list.getSize();\n+        CMS.debug(method + \"total: \" + total);\n+        int retTotal = 0; // debugging only\n \n         // return entries in the requested page\n+        if (authorizedProfiles != null) {\n+            if (authorizedProfiles.contains(UserResource.ALL_PROFILES)) {\n-        for (int i = start; i < start + size && i < total; i++) {\n+                for (int i = start; i < start + size && i < total; i++) {\n-            ActivityRecord record = list.getElementAt(i);\n+                    ActivityRecord record = list.getElementAt(i);\n \n-            if (record == null) {\n-                CMS.debug(\"ActivityService: Activity record not found\");\n-                throw new PKIException(\"Activity record not found\");\n+                    response.addEntry(createActivityData(record));\n+                    retTotal++;\n+                }\n+            } else { // not authorized for all profiles\n+                for (int i = start; i < start + size && i < total; i++) {\n+                    ActivityRecord record = list.getElementAt(i);\n+\n+                    //CMS.debug(method + \"record.Id=\"+ record.getId());\n+                    // On some rare occasions, some activities don't have\n+                    // their token type filled in. It is therefore necessary\n+                    // to get it from the token record directly.\n+                    String type = record.ge",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch introduces authorization checks to restrict agent operations, preventing unauthorized access and thus addressing a security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}