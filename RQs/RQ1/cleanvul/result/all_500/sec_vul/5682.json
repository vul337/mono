{
  "id": 5682,
  "language": "Python",
  "commit_url": "https://github.com/Pylons/waitress/commit/9e0b8c801e4d505c2ffc91b891af4ba48af715e0",
  "commit_sha": "9e0b8c801e4d505c2ffc91b891af4ba48af715e0",
  "commit_msg": "Merge pull request from GHSA-4f7p-27jc-3c36\n\nFix for HTTP request smuggling due to incorrect validation",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/waitress/receiver.py",
  "func_name": "received",
  "func_before": "def received(self, s):\n        # Returns the number of bytes consumed.\n\n        if self.completed:\n            return 0\n        orig_size = len(s)\n\n        while s:\n            rm = self.chunk_remainder\n\n            if rm > 0:\n                # Receive the remainder of a chunk.\n                to_write = s[:rm]\n                self.buf.append(to_write)\n                written = len(to_write)\n                s = s[written:]\n\n                self.chunk_remainder -= written\n\n                if self.chunk_remainder == 0:\n                    self.validate_chunk_end = True\n            elif self.validate_chunk_end:\n                s = self.chunk_end + s\n\n                pos = s.find(b\"\\r\\n\")\n\n                if pos < 0 and len(s) < 2:\n                    self.chunk_end = s\n                    s = b\"\"\n                else:\n                    self.chunk_end = b\"\"\n                    if pos == 0:\n                        # Chop off the terminating CR LF from the chunk\n                        s = s[2:]\n                    else:\n                        self.error = BadRequest(\"Chunk not properly terminated\")\n                        self.all_chunks_received = True\n\n                    # Always exit this loop\n                    self.validate_chunk_end = False\n            elif not self.all_chunks_received:\n                # Receive a control line.\n                s = self.control_line + s\n                pos = s.find(b\"\\r\\n\")\n\n                if pos < 0:\n                    # Control line not finished.\n                    self.control_line = s\n                    s = b\"\"\n                else:\n                    # Control line finished.\n                    line = s[:pos]\n                    s = s[pos + 2 :]\n                    self.control_line = b\"\"\n                    line = line.strip()\n\n                    if line:\n                        # Begin a new chunk.\n                        semi = line.find(b\";\")\n\n                        if semi >= 0:\n                            # discard extension info.\n                            line = line[:semi]\n                        try:\n                            sz = int(line.strip(), 16)  # hexadecimal\n                        except ValueError:  # garbage in input\n                            self.error = BadRequest(\"garbage in chunked encoding input\")\n                            sz = 0\n\n                        if sz > 0:\n                            # Start a new chunk.\n                            self.chunk_remainder = sz\n                        else:\n                            # Finished chunks.\n                            self.all_chunks_received = True\n                    # else expect a control line.\n            else:\n                # Receive the trailer.\n                trailer = self.trailer + s\n\n                if trailer.startswith(b\"\\r\\n\"):\n                    # No trailer.\n                    self.completed = True\n\n                    return orig_size - (len(trailer) - 2)\n                pos = find_double_newline(trailer)\n\n                if pos < 0:\n                    # Trailer not finished.\n                    self.trailer = trailer\n                    s = b\"\"\n                else:\n                    # Finished the trailer.\n                    self.completed = True\n                    self.trailer = trailer[:pos]\n\n                    return orig_size - (len(trailer) - pos)\n\n        return orig_size",
  "func_after": "def received(self, s):\n        # Returns the number of bytes consumed.\n\n        if self.completed:\n            return 0\n        orig_size = len(s)\n\n        while s:\n            rm = self.chunk_remainder\n\n            if rm > 0:\n                # Receive the remainder of a chunk.\n                to_write = s[:rm]\n                self.buf.append(to_write)\n                written = len(to_write)\n                s = s[written:]\n\n                self.chunk_remainder -= written\n\n                if self.chunk_remainder == 0:\n                    self.validate_chunk_end = True\n            elif self.validate_chunk_end:\n                s = self.chunk_end + s\n\n                pos = s.find(b\"\\r\\n\")\n\n                if pos < 0 and len(s) < 2:\n                    self.chunk_end = s\n                    s = b\"\"\n                else:\n                    self.chunk_end = b\"\"\n\n                    if pos == 0:\n                        # Chop off the terminating CR LF from the chunk\n                        s = s[2:]\n                    else:\n                        self.error = BadRequest(\"Chunk not properly terminated\")\n                        self.all_chunks_received = True\n\n                    # Always exit this loop\n                    self.validate_chunk_end = False\n            elif not self.all_chunks_received:\n                # Receive a control line.\n                s = self.control_line + s\n                pos = s.find(b\"\\r\\n\")\n\n                if pos < 0:\n                    # Control line not finished.\n                    self.control_line = s\n                    s = b\"\"\n                else:\n                    # Control line finished.\n                    line = s[:pos]\n                    s = s[pos + 2 :]\n                    self.control_line = b\"\"\n\n                    if line:\n                        # Begin a new chunk.\n                        semi = line.find(b\";\")\n\n                        if semi >= 0:\n                            extinfo = line[semi:]\n                            valid_ext_info = CHUNK_EXT_RE.match(extinfo)\n\n                            if not valid_ext_info:\n                                self.error = BadRequest(\"Invalid chunk extension\")\n                                self.all_chunks_received = True\n\n                                break\n\n                            line = line[:semi]\n\n                        if not ONLY_HEXDIG_RE.match(line):\n                            self.error = BadRequest(\"Invalid chunk size\")\n                            self.all_chunks_received = True\n\n                            break\n\n                        # Can not fail due to matching against the regular\n                        # expression above\n                        sz = int(line, 16)  # hexadecimal\n\n                        if sz > 0:\n                            # Start a new chunk.\n                            self.chunk_remainder = sz\n                        else:\n                            # Finished chunks.\n                            self.all_chunks_received = True\n                    # else expect a control line.\n            else:\n                # Receive the trailer.\n                trailer = self.trailer + s\n\n                if trailer.startswith(b\"\\r\\n\"):\n                    # No trailer.\n                    self.completed = True\n\n                    return orig_size - (len(trailer) - 2)\n                pos = find_double_newline(trailer)\n\n                if pos < 0:\n                    # Trailer not finished.\n                    self.trailer = trailer\n                    s = b\"\"\n                else:\n                    # Finished the trailer.\n                    self.completed = True\n                    self.trailer = trailer[:pos]\n\n                    return orig_size - (len(trailer) - pos)\n\n        return orig_size",
  "diff_func": "--- func_before\n+++ func_after\n def received(self, s):\n         # Returns the number of bytes consumed.\n \n         if self.completed:\n             return 0\n         orig_size = len(s)\n \n         while s:\n             rm = self.chunk_remainder\n \n             if rm > 0:\n                 # Receive the remainder of a chunk.\n                 to_write = s[:rm]\n                 self.buf.append(to_write)\n                 written = len(to_write)\n                 s = s[written:]\n \n                 self.chunk_remainder -= written\n \n                 if self.chunk_remainder == 0:\n                     self.validate_chunk_end = True\n             elif self.validate_chunk_end:\n                 s = self.chunk_end + s\n \n                 pos = s.find(b\"\\r\\n\")\n \n                 if pos < 0 and len(s) < 2:\n                     self.chunk_end = s\n                     s = b\"\"\n                 else:\n                     self.chunk_end = b\"\"\n+\n                     if pos == 0:\n                         # Chop off the terminating CR LF from the chunk\n                         s = s[2:]\n                     else:\n                         self.error = BadRequest(\"Chunk not properly terminated\")\n                         self.all_chunks_received = True\n \n                     # Always exit this loop\n                     self.validate_chunk_end = False\n             elif not self.all_chunks_received:\n                 # Receive a control line.\n                 s = self.control_line + s\n                 pos = s.find(b\"\\r\\n\")\n \n                 if pos < 0:\n                     # Control line not finished.\n                     self.control_line = s\n                     s = b\"\"\n                 else:\n                     # Control line finished.\n                     line = s[:pos]\n                     s = s[pos + 2 :]\n                     self.control_line = b\"\"\n-                    line = line.strip()\n \n                     if line:\n                         # Begin a new chunk.\n                         se",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The commit addresses an HTTP request smuggling vulnerability by correcting chunk validation. The code changes ensure proper chunk termination, preventing potential attacks. \n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}