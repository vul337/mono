{
  "id": 3732,
  "language": "Python",
  "commit_url": "https://github.com/simonw/datasette/commit/26fc539312bca2551b6f048b6bcf4ffbb491289f",
  "commit_sha": "26fc539312bca2551b6f048b6bcf4ffbb491289f",
  "commit_msg": "Correctly escape output of ?_trace, refs #1360",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "datasette/tracer.py",
  "func_name": "wrapped_send",
  "func_before": "async def wrapped_send(message):\n            nonlocal accumulated_body, size_limit_exceeded, response_headers\n            if message[\"type\"] == \"http.response.start\":\n                response_headers = message[\"headers\"]\n                await send(message)\n                return\n\n            if message[\"type\"] != \"http.response.body\" or size_limit_exceeded:\n                await send(message)\n                return\n\n            # Accumulate body until the end or until size is exceeded\n            accumulated_body += message[\"body\"]\n            if len(accumulated_body) > self.max_body_bytes:\n                await send(\n                    {\n                        \"type\": \"http.response.body\",\n                        \"body\": accumulated_body,\n                        \"more_body\": True,\n                    }\n                )\n                size_limit_exceeded = True\n                return\n\n            if not message.get(\"more_body\"):\n                # We have all the body - modify it and send the result\n                # TODO: What to do about Content-Type or other cases?\n                trace_info = {\n                    \"request_duration_ms\": 1000 * (time.perf_counter() - trace_start),\n                    \"sum_trace_duration_ms\": sum(t[\"duration_ms\"] for t in traces),\n                    \"num_traces\": len(traces),\n                    \"traces\": traces,\n                }\n                try:\n                    content_type = [\n                        v.decode(\"utf8\")\n                        for k, v in response_headers\n                        if k.lower() == b\"content-type\"\n                    ][0]\n                except IndexError:\n                    content_type = \"\"\n                if \"text/html\" in content_type and b\"</body>\" in accumulated_body:\n                    extra = json.dumps(trace_info, indent=2)\n                    extra_html = f\"<pre>{extra}</pre></body>\".encode(\"utf8\")\n                    accumulated_body = accumulated_body.replace(b\"</body>\", extra_html)\n                elif \"json\" in content_type and accumulated_body.startswith(b\"{\"):\n                    data = json.loads(accumulated_body.decode(\"utf8\"))\n                    if \"_trace\" not in data:\n                        data[\"_trace\"] = trace_info\n                    accumulated_body = json.dumps(data).encode(\"utf8\")\n                await send({\"type\": \"http.response.body\", \"body\": accumulated_body})",
  "func_after": "async def wrapped_send(message):\n            nonlocal accumulated_body, size_limit_exceeded, response_headers\n            if message[\"type\"] == \"http.response.start\":\n                response_headers = message[\"headers\"]\n                await send(message)\n                return\n\n            if message[\"type\"] != \"http.response.body\" or size_limit_exceeded:\n                await send(message)\n                return\n\n            # Accumulate body until the end or until size is exceeded\n            accumulated_body += message[\"body\"]\n            if len(accumulated_body) > self.max_body_bytes:\n                await send(\n                    {\n                        \"type\": \"http.response.body\",\n                        \"body\": accumulated_body,\n                        \"more_body\": True,\n                    }\n                )\n                size_limit_exceeded = True\n                return\n\n            if not message.get(\"more_body\"):\n                # We have all the body - modify it and send the result\n                # TODO: What to do about Content-Type or other cases?\n                trace_info = {\n                    \"request_duration_ms\": 1000 * (time.perf_counter() - trace_start),\n                    \"sum_trace_duration_ms\": sum(t[\"duration_ms\"] for t in traces),\n                    \"num_traces\": len(traces),\n                    \"traces\": traces,\n                }\n                try:\n                    content_type = [\n                        v.decode(\"utf8\")\n                        for k, v in response_headers\n                        if k.lower() == b\"content-type\"\n                    ][0]\n                except IndexError:\n                    content_type = \"\"\n                if \"text/html\" in content_type and b\"</body>\" in accumulated_body:\n                    extra = escape(json.dumps(trace_info, indent=2))\n                    extra_html = f\"<pre>{extra}</pre></body>\".encode(\"utf8\")\n                    accumulated_body = accumulated_body.replace(b\"</body>\", extra_html)\n                elif \"json\" in content_type and accumulated_body.startswith(b\"{\"):\n                    data = json.loads(accumulated_body.decode(\"utf8\"))\n                    if \"_trace\" not in data:\n                        data[\"_trace\"] = trace_info\n                    accumulated_body = json.dumps(data).encode(\"utf8\")\n                await send({\"type\": \"http.response.body\", \"body\": accumulated_body})",
  "diff_func": "--- func_before\n+++ func_after\n async def wrapped_send(message):\n             nonlocal accumulated_body, size_limit_exceeded, response_headers\n             if message[\"type\"] == \"http.response.start\":\n                 response_headers = message[\"headers\"]\n                 await send(message)\n                 return\n \n             if message[\"type\"] != \"http.response.body\" or size_limit_exceeded:\n                 await send(message)\n                 return\n \n             # Accumulate body until the end or until size is exceeded\n             accumulated_body += message[\"body\"]\n             if len(accumulated_body) > self.max_body_bytes:\n                 await send(\n                     {\n                         \"type\": \"http.response.body\",\n                         \"body\": accumulated_body,\n                         \"more_body\": True,\n                     }\n                 )\n                 size_limit_exceeded = True\n                 return\n \n             if not message.get(\"more_body\"):\n                 # We have all the body - modify it and send the result\n                 # TODO: What to do about Content-Type or other cases?\n                 trace_info = {\n                     \"request_duration_ms\": 1000 * (time.perf_counter() - trace_start),\n                     \"sum_trace_duration_ms\": sum(t[\"duration_ms\"] for t in traces),\n                     \"num_traces\": len(traces),\n                     \"traces\": traces,\n                 }\n                 try:\n                     content_type = [\n                         v.decode(\"utf8\")\n                         for k, v in response_headers\n                         if k.lower() == b\"content-type\"\n                     ][0]\n                 except IndexError:\n                     content_type = \"\"\n                 if \"text/html\" in content_type and b\"</body>\" in accumulated_body:\n-                    extra = json.dumps(trace_info, indent=2)\n+                    extra = escape(json.dumps(trace_info, indent=2))\n             ",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by escaping output to prevent XSS attacks. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}