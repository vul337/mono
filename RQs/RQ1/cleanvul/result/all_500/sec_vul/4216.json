{
  "id": 4216,
  "language": "C/C++",
  "commit_url": "https://github.com/lecram/gifdec/commit/970558212348b60359f967a5d999078b6f9efe04",
  "commit_sha": "970558212348b60359f967a5d999078b6f9efe04",
  "commit_msg": "Fix: Security: entry.prefix may be a bigger value than table->nentries, causing oob read.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "gifdec.c",
  "func_name": "read_image_data",
  "func_before": "static int\nread_image_data(gd_GIF *gif, int interlace)\n{\n    uint8_t sub_len, shift, byte;\n    int init_key_size, key_size, table_is_full = 0;\n    int frm_off, frm_size, str_len = 0, i, p, x, y;\n    uint16_t key, clear, stop;\n    int ret;\n    Table *table;\n    Entry entry = { 0 };\n    off_t start, end;\n\n    read(gif->fd, &byte, 1);\n    key_size = (int) byte;\n    if (key_size < 2 || key_size > 8)\n        return -1;\n    \n    start = lseek(gif->fd, 0, SEEK_CUR);\n    discard_sub_blocks(gif);\n    end = lseek(gif->fd, 0, SEEK_CUR);\n    lseek(gif->fd, start, SEEK_SET);\n    clear = 1 << key_size;\n    stop = clear + 1;\n    table = new_table(key_size);\n    key_size++;\n    init_key_size = key_size;\n    sub_len = shift = 0;\n    key = get_key(gif, key_size, &sub_len, &shift, &byte); /* clear code */\n    frm_off = 0;\n    ret = 0;\n    frm_size = gif->fw*gif->fh;\n    while (frm_off < frm_size) {\n        if (key == clear) {\n            key_size = init_key_size;\n            table->nentries = (1 << (key_size - 1)) + 2;\n            table_is_full = 0;\n        } else if (!table_is_full) {\n            ret = add_entry(&table, str_len + 1, key, entry.suffix);\n            if (ret == -1) {\n                free(table);\n                return -1;\n            }\n            if (table->nentries == 0x1000) {\n                ret = 0;\n                table_is_full = 1;\n            }\n        }\n        key = get_key(gif, key_size, &sub_len, &shift, &byte);\n        if (key == clear) continue;\n        if (key == stop || key == 0x1000) break;\n        if (key >= table->nentries) break;\n        if (ret == 1) key_size++;\n        entry = table->entries[key];\n        str_len = entry.length;\n        for (i = 0; i < str_len; i++) {\n            p = frm_off + entry.length - 1;\n            x = p % gif->fw;\n            y = p / gif->fw;\n            if (interlace)\n                y = interlaced_line_index((int) gif->fh, y);\n            gif->frame[(gif->fy + y) * gif->width + gif->fx + x] = entry.suffix;\n            if (entry.prefix == 0xFFF)\n                break;\n            else\n                entry = table->entries[entry.prefix];\n        }\n        frm_off += str_len;\n        if (key < table->nentries - 1 && !table_is_full)\n            table->entries[table->nentries - 1].suffix = entry.suffix;\n    }\n    free(table);\n    if (key == stop)\n        read(gif->fd, &sub_len, 1); /* Must be zero! */\n    lseek(gif->fd, end, SEEK_SET);\n    return 0;\n}",
  "func_after": "static int\nread_image_data(gd_GIF *gif, int interlace)\n{\n    uint8_t sub_len, shift, byte;\n    int init_key_size, key_size, table_is_full = 0;\n    int frm_off, frm_size, str_len = 0, i, p, x, y;\n    uint16_t key, clear, stop;\n    int ret;\n    Table *table;\n    Entry entry = { 0 };\n    off_t start, end;\n\n    read(gif->fd, &byte, 1);\n    key_size = (int) byte;\n    if (key_size < 2 || key_size > 8)\n        return -1;\n    \n    start = lseek(gif->fd, 0, SEEK_CUR);\n    discard_sub_blocks(gif);\n    end = lseek(gif->fd, 0, SEEK_CUR);\n    lseek(gif->fd, start, SEEK_SET);\n    clear = 1 << key_size;\n    stop = clear + 1;\n    table = new_table(key_size);\n    key_size++;\n    init_key_size = key_size;\n    sub_len = shift = 0;\n    key = get_key(gif, key_size, &sub_len, &shift, &byte); /* clear code */\n    frm_off = 0;\n    ret = 0;\n    frm_size = gif->fw*gif->fh;\n    while (frm_off < frm_size) {\n        if (key == clear) {\n            key_size = init_key_size;\n            table->nentries = (1 << (key_size - 1)) + 2;\n            table_is_full = 0;\n        } else if (!table_is_full) {\n            ret = add_entry(&table, str_len + 1, key, entry.suffix);\n            if (ret == -1) {\n                free(table);\n                return -1;\n            }\n            if (table->nentries == 0x1000) {\n                ret = 0;\n                table_is_full = 1;\n            }\n        }\n        key = get_key(gif, key_size, &sub_len, &shift, &byte);\n        if (key == clear) continue;\n        if (key == stop || key == 0x1000) break;\n        if (key >= table->nentries) break;\n        if (ret == 1) key_size++;\n        entry = table->entries[key];\n        str_len = entry.length;\n        for (i = 0; i < str_len; i++) {\n            p = frm_off + entry.length - 1;\n            x = p % gif->fw;\n            y = p / gif->fw;\n            if (interlace)\n                y = interlaced_line_index((int) gif->fh, y);\n            gif->frame[(gif->fy + y) * gif->width + gif->fx + x] = entry.suffix;\n            if (entry.prefix == 0xFFF || entry.prefix >= table->nentries)\n                break;\n            else\n                entry = table->entries[entry.prefix];\n        }\n        frm_off += str_len;\n        if (key < table->nentries - 1 && !table_is_full)\n            table->entries[table->nentries - 1].suffix = entry.suffix;\n    }\n    free(table);\n    if (key == stop)\n        read(gif->fd, &sub_len, 1); /* Must be zero! */\n    lseek(gif->fd, end, SEEK_SET);\n    return 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int\n read_image_data(gd_GIF *gif, int interlace)\n {\n     uint8_t sub_len, shift, byte;\n     int init_key_size, key_size, table_is_full = 0;\n     int frm_off, frm_size, str_len = 0, i, p, x, y;\n     uint16_t key, clear, stop;\n     int ret;\n     Table *table;\n     Entry entry = { 0 };\n     off_t start, end;\n \n     read(gif->fd, &byte, 1);\n     key_size = (int) byte;\n     if (key_size < 2 || key_size > 8)\n         return -1;\n     \n     start = lseek(gif->fd, 0, SEEK_CUR);\n     discard_sub_blocks(gif);\n     end = lseek(gif->fd, 0, SEEK_CUR);\n     lseek(gif->fd, start, SEEK_SET);\n     clear = 1 << key_size;\n     stop = clear + 1;\n     table = new_table(key_size);\n     key_size++;\n     init_key_size = key_size;\n     sub_len = shift = 0;\n     key = get_key(gif, key_size, &sub_len, &shift, &byte); /* clear code */\n     frm_off = 0;\n     ret = 0;\n     frm_size = gif->fw*gif->fh;\n     while (frm_off < frm_size) {\n         if (key == clear) {\n             key_size = init_key_size;\n             table->nentries = (1 << (key_size - 1)) + 2;\n             table_is_full = 0;\n         } else if (!table_is_full) {\n             ret = add_entry(&table, str_len + 1, key, entry.suffix);\n             if (ret == -1) {\n                 free(table);\n                 return -1;\n             }\n             if (table->nentries == 0x1000) {\n                 ret = 0;\n                 table_is_full = 1;\n             }\n         }\n         key = get_key(gif, key_size, &sub_len, &shift, &byte);\n         if (key == clear) continue;\n         if (key == stop || key == 0x1000) break;\n         if (key >= table->nentries) break;\n         if (ret == 1) key_size++;\n         entry = table->entries[key];\n         str_len = entry.length;\n         for (i = 0; i < str_len; i++) {\n             p = frm_off + entry.length - 1;\n             x = p % gif->fw;\n             y = p / gif->fw;\n             if (interlace)\n                 y = interlaced_line_index((int) gif->fh, y);\n    ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The commit addresses an out-of-bounds read vulnerability in the GIF image processing function. The patch adds a boundary check to prevent accessing array elements beyond the allocated size, mitigating potential information disclosure or crashes.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}