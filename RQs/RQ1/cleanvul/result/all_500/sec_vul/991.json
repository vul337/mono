{
  "id": 991,
  "language": "Java",
  "commit_url": "https://github.com/neo4j/apoc/commit/f175f1f1f663d29fc151c297b56d154255eb7016",
  "commit_sha": "f175f1f1f663d29fc151c297b56d154255eb7016",
  "commit_msg": "[AJmycukR] vuln-fix: Securing XML parser against XXE (CVE-2023-23926)\n\nFixing a XML External Entity (XXE) vulnerability, that was impacting the apoc.import.graphml procedure.",
  "pr_url": "https://github.com/neo4j/apoc/pull/310",
  "pr_info": "no more info",
  "file_name": "core/src/main/java/apoc/export/graphml/XmlGraphMLReader.java",
  "func_name": "XMLStreamException",
  "func_before": "public long parseXML(Reader input) throws XMLStreamException {\n        Map<String, String> cache = new HashMap<>(1024*32);\n        XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n        inputFactory.setProperty(\"javax.xml.stream.isCoalescing\", true);\n        inputFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, true);\n        XMLEventReader reader = inputFactory.createXMLEventReader(input);\n        Entity last = null;\n        Map<String, Key> nodeKeys = new HashMap<>();\n        Map<String, Key> relKeys = new HashMap<>();\n        int count = 0;\n        BatchTransaction tx = new BatchTransaction(db, batchSize * 10, reporter);\n        try {\n\n            while (reader.hasNext()) {\n                XMLEvent event;\n                try {\n                    event = (XMLEvent) reader.next();\n                } catch (Exception e) {\n                    // in case of unicode invalid chars we skip the event, or we exit in case of EOF\n                    if (e.getMessage().contains(\"Unexpected EOF\")) {\n                        break;\n                    }\n                    continue;\n                }\n                if (event.isStartElement()) {\n\n                    StartElement element = event.asStartElement();\n                    String name = element.getName().getLocalPart();\n\n                    if (name.equals(\"graphml\") || name.equals(\"graph\")) continue;\n                    if (name.equals(\"key\")) {\n                        String id = getAttribute(element, ID);\n                        Key key = new Key(getAttribute(element, NAME), getAttribute(element, TYPE), getAttribute(element, LIST), getAttribute(element, FOR));\n\n                        XMLEvent next = peek(reader);\n                        if (next.isStartElement() && next.asStartElement().getName().getLocalPart().equals(\"default\")) {\n                            reader.nextEvent().asStartElement();\n                            key.setDefault(reader.nextEvent().asCharacters().getData());\n                        }\n                        if (key.forNode) nodeKeys.put(id, key);\n                        else relKeys.put(id, key);\n                        continue;\n                    }\n                    if (name.equals(\"data\")) {\n                        if (last == null) continue;\n                        String id = getAttribute(element, KEY);\n                        boolean isNode = last instanceof Node;\n                        Key key = isNode ? nodeKeys.get(id) : relKeys.get(id);\n                        if (key == null) key = Key.defaultKey(id, isNode);\n                        final Map.Entry<XMLEvent, Object> eventEntry = getDataEventEntry(reader, key);\n                        final XMLEvent next = eventEntry.getKey();\n                        final Object value = eventEntry.getValue();\n                        if (value != null) {\n                            if (this.labels && isNode && id.equals(\"labels\")) {\n                                addLabels((Node)last,value.toString());\n                            } else if (!this.labels || isNode || !id.equals(\"label\")) {\n                                last.setProperty(key.nameOrId, value);\n                                if (reporter != null) reporter.update(0, 0, 1);\n                            }\n                        } else if (next.getEventType() == XMLStreamConstants.END_ELEMENT) {\n                            last.setProperty(key.nameOrId, StringUtils.EMPTY);\n                            reporter.update(0, 0, 1);\n                        }\n                        continue;\n                    }\n                    if (name.equals(\"node\")) {\n                        tx.increment();\n                        String id = getAttribute(element, ID);\n                        Node node = tx.getTransaction().createNode();\n                        if (this.labels) {\n                            String labels = getAttribute(element, LABELS);\n                            addLabels(node, labels);\n                        }\n                        if (storeNodeIds) node.setProperty(\"id\", id);\n                        setDefaults(nodeKeys, node);\n                        last = node;\n                        cache.put(id, node.getElementId());\n                        if (reporter != null) reporter.update(1, 0, 0);\n                        count++;\n                        continue;\n                    }\n                    if (name.equals(\"edge\")) {\n                        tx.increment();\n                        String label = getAttribute(element, LABEL);\n                        Node from = getByNodeId(cache, tx.getTransaction(), element, XmlNodeExport.NodeType.SOURCE);\n                        Node to = getByNodeId(cache, tx.getTransaction(), element, XmlNodeExport.NodeType.TARGET);\n\n                        RelationshipType relationshipType = label == null ? getRelationshipType(reader) : RelationshipType.withName(label);\n                        Relationship relationship = from.createRelationshipTo(to, relationshipType);\n                        setDefaults(relKeys, relationship);\n                        last = relationship;\n                        if (reporter != null) reporter.update(0, 1, 0);\n                        count++;\n                    }\n                }\n            }\n            tx.doCommit();\n        } catch (Exception e) {\n            tx.rollback();\n            throw e;\n        } finally { \n            tx.close();\n        }\n        return count;\n    }",
  "func_after": "public long parseXML(Reader input) throws XMLStreamException {\n        Map<String, String> cache = new HashMap<>(1024*32);\n        XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n        inputFactory.setProperty(\"javax.xml.stream.isCoalescing\", true);\n        inputFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, true);\n        inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        XMLEventReader reader = inputFactory.createXMLEventReader(input);\n        Entity last = null;\n        Map<String, Key> nodeKeys = new HashMap<>();\n        Map<String, Key> relKeys = new HashMap<>();\n        int count = 0;\n        BatchTransaction tx = new BatchTransaction(db, batchSize * 10, reporter);\n        try {\n\n            while (reader.hasNext()) {\n                XMLEvent event;\n                try {\n                    event = (XMLEvent) reader.next();\n                    if ( event.getEventType() == XMLStreamConstants.DTD) {\n                        generateXmlDoctypeException();\n                    }\n                } catch (Exception e) {\n                    // in case of unicode invalid chars we skip the event, or we exit in case of EOF\n                    if (e.getMessage().contains(\"Unexpected EOF\")) {\n                        break;\n                    } else if (e.getMessage().contains(\"DOCTYPE\")) {\n                        throw e;\n                    }\n                    continue;\n                }\n                if (event.isStartElement()) {\n\n                    StartElement element = event.asStartElement();\n                    String name = element.getName().getLocalPart();\n\n                    if (name.equals(\"graphml\") || name.equals(\"graph\")) continue;\n                    if (name.equals(\"key\")) {\n                        String id = getAttribute(element, ID);\n                        Key key = new Key(getAttribute(element, NAME), getAttribute(element, TYPE), getAttribute(element, LIST), getAttribute(element, FOR));\n\n                        XMLEvent next = peek(reader);\n                        if (next.isStartElement() && next.asStartElement().getName().getLocalPart().equals(\"default\")) {\n                            reader.nextEvent().asStartElement();\n                            key.setDefault(reader.nextEvent().asCharacters().getData());\n                        }\n                        if (key.forNode) nodeKeys.put(id, key);\n                        else relKeys.put(id, key);\n                        continue;\n                    }\n                    if (name.equals(\"data\")) {\n                        if (last == null) continue;\n                        String id = getAttribute(element, KEY);\n                        boolean isNode = last instanceof Node;\n                        Key key = isNode ? nodeKeys.get(id) : relKeys.get(id);\n                        if (key == null) key = Key.defaultKey(id, isNode);\n                        final Map.Entry<XMLEvent, Object> eventEntry = getDataEventEntry(reader, key);\n                        final XMLEvent next = eventEntry.getKey();\n                        final Object value = eventEntry.getValue();\n                        if (value != null) {\n                            if (this.labels && isNode && id.equals(\"labels\")) {\n                                addLabels((Node)last,value.toString());\n                            } else if (!this.labels || isNode || !id.equals(\"label\")) {\n                                last.setProperty(key.nameOrId, value);\n                                if (reporter != null) reporter.update(0, 0, 1);\n                            }\n                        } else if (next.getEventType() == XMLStreamConstants.END_ELEMENT) {\n                            last.setProperty(key.nameOrId, StringUtils.EMPTY);\n                            reporter.update(0, 0, 1);\n                        }\n                        continue;\n                    }\n                    if (name.equals(\"node\")) {\n                        tx.increment();\n                        String id = getAttribute(element, ID);\n                        Node node = tx.getTransaction().createNode();\n                        if (this.labels) {\n                            String labels = getAttribute(element, LABELS);\n                            addLabels(node, labels);\n                        }\n                        if (storeNodeIds) node.setProperty(\"id\", id);\n                        setDefaults(nodeKeys, node);\n                        last = node;\n                        cache.put(id, node.getElementId());\n                        if (reporter != null) reporter.update(1, 0, 0);\n                        count++;\n                        continue;\n                    }\n                    if (name.equals(\"edge\")) {\n                        tx.increment();\n                        String label = getAttribute(element, LABEL);\n                        Node from = getByNodeId(cache, tx.getTransaction(), element, XmlNodeExport.NodeType.SOURCE);\n                        Node to = getByNodeId(cache, tx.getTransaction(), element, XmlNodeExport.NodeType.TARGET);\n\n                        RelationshipType relationshipType = label == null ? getRelationshipType(reader) : RelationshipType.withName(label);\n                        Relationship relationship = from.createRelationshipTo(to, relationshipType);\n                        setDefaults(relKeys, relationship);\n                        last = relationship;\n                        if (reporter != null) reporter.update(0, 1, 0);\n                        count++;\n                    }\n                }\n            }\n            tx.doCommit();\n        } catch (Exception e) {\n            tx.rollback();\n            throw e;\n        } finally { \n            tx.close();\n        }\n        return count;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public long parseXML(Reader input) throws XMLStreamException {\n         Map<String, String> cache = new HashMap<>(1024*32);\n         XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n         inputFactory.setProperty(\"javax.xml.stream.isCoalescing\", true);\n         inputFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, true);\n+        inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n+        inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n         XMLEventReader reader = inputFactory.createXMLEventReader(input);\n         Entity last = null;\n         Map<String, Key> nodeKeys = new HashMap<>();\n         Map<String, Key> relKeys = new HashMap<>();\n         int count = 0;\n         BatchTransaction tx = new BatchTransaction(db, batchSize * 10, reporter);\n         try {\n \n             while (reader.hasNext()) {\n                 XMLEvent event;\n                 try {\n                     event = (XMLEvent) reader.next();\n+                    if ( event.getEventType() == XMLStreamConstants.DTD) {\n+                        generateXmlDoctypeException();\n+                    }\n                 } catch (Exception e) {\n                     // in case of unicode invalid chars we skip the event, or we exit in case of EOF\n                     if (e.getMessage().contains(\"Unexpected EOF\")) {\n                         break;\n+                    } else if (e.getMessage().contains(\"DOCTYPE\")) {\n+                        throw e;\n                     }\n                     continue;\n                 }\n                 if (event.isStartElement()) {\n \n                     StartElement element = event.asStartElement();\n                     String name = element.getName().getLocalPart();\n \n                     if (name.equals(\"graphml\") || name.equals(\"graph\")) continue;\n                     if (name.equals(\"key\")) {\n                         String id = getAttribute(element, ID);\n               ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by disabling support for DTDs and external entities in an XML parser, thereby mitigating an XXE attack risk. The commit message and code changes clearly indicate a security fix.\n\n**Final Output:**\nAnalysis: The patch modifies XML parsing settings to prevent XXE attacks, a known security issue.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}