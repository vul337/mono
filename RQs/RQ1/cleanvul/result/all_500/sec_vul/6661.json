{
  "id": 6661,
  "language": "C/C++",
  "commit_url": "https://github.com/wernsey/bitmap/commit/1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b",
  "commit_sha": "1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b",
  "commit_msg": "Added a bunch of `assert(b)`'s to address CVE-2018-17073\nSee https://github.com/wernsey/bitmap/issues/1",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "bmp.c",
  "func_name": "bm_fillpoly",
  "func_before": "void bm_fillpoly(Bitmap *b, BmPoint points[], unsigned int n) {\n    /* http://alienryderflex.com/polygon_fill/\n    https://hackernoon.com/computer-graphics-scan-line-polygon-fill-algorithm-3cb47283df6\n\n    You might also be interested in this article:\n    http://nothings.org/gamedev/rasterize/\n    */\n    unsigned int i, j, c = bm_get_color(b);\n    int x, y;\n    if(n < 2)\n        return;\n    else if(n == 2) {\n        bm_line(b, points[0].x, points[0].y, points[1].x, points[1].y);\n        return;\n    }\n\n    int nodeX_static[MAX_POLY_CORNERS], *nodeX = nodeX_static;\n    unsigned int nodes;\n\n    if(n > MAX_POLY_CORNERS) {\n        nodeX = calloc(n, sizeof *nodeX);\n        if(!nodeX) return;\n    }\n\n    BmRect area = {b->w, b->h, 0, 0};\n    for(i = 0; i < n; i++) {\n        x = points[i].x;\n        y = points[i].y;\n        if(x < area.x0) area.x0 = x;\n        if(y < area.y0) area.y0 = y;\n        if(x > area.x1) area.x1 = x;\n        if(y > area.y1) area.y1 = y;\n    }\n    if(area.x0 < b->clip.x0) area.x0 = b->clip.x0;\n    if(area.y0 < b->clip.y0) area.y0 = b->clip.y0;\n    if(area.x1 >= b->clip.x1) area.x1 = b->clip.x1 - 1;\n    if(area.y1 >= b->clip.y1) area.y1 = b->clip.y1 - 1;\n\n    for(y = area.y0; y <= area.y1; y++) {\n        nodes = 0;\n        j = n - 1;\n\n        for(i = 0; i < n; i++) {\n            if((points[i].y < y && points[j].y >= y)\n                || (points[j].y < y && points[i].y >= y)) {\n                nodeX[nodes++] = (int)(points[i].x + (double)(y - points[i].y) * (points[j].x - points[i].x) / (points[j].y - points[i].y));\n            }\n            j = i;\n        }\n\n        assert(nodes < n);\n        if(nodes < 1) continue;\n\n        i = 0;\n        while(i < nodes - 1) {\n            if(nodeX[i] > nodeX[i+1]) {\n                int swap = nodeX[i];\n                nodeX[i] = nodeX[i + 1];\n                nodeX[i + 1] = swap;\n                if(i) i--;\n            } else {\n                i++;\n            }\n        }\n\n        for(i = 0; i < nodes; i += 2) {\n            if(nodeX[i] >= area.x1)\n                break;\n            if(nodeX[i + 1] > area.x0) {\n                if(nodeX[i] < area.x0)\n                    nodeX[i] = area.x0;\n                if(nodeX[i+1] > area.x1)\n                    nodeX[i+1] = area.x1;\n\n                for(x = nodeX[i]; x <= nodeX[i+1]; x++)\n                    BM_SET(b, x, y, c);\n            }\n        }\n    }\n\n    if(nodeX != nodeX_static)\n        free(nodeX);\n}",
  "func_after": "void bm_fillpoly(Bitmap *b, BmPoint points[], unsigned int n) {\n    /* http://alienryderflex.com/polygon_fill/\n    https://hackernoon.com/computer-graphics-scan-line-polygon-fill-algorithm-3cb47283df6\n\n    You might also be interested in this article:\n    http://nothings.org/gamedev/rasterize/\n    */\n    unsigned int i, j, c; \n    int x, y;\n\tassert(b);\n\tc = bm_get_color(b);\n    if(n < 2)\n        return;\n    else if(n == 2) {\n        bm_line(b, points[0].x, points[0].y, points[1].x, points[1].y);\n        return;\n    }\n\n    int nodeX_static[MAX_POLY_CORNERS], *nodeX = nodeX_static;\n    unsigned int nodes;\n\n    if(n > MAX_POLY_CORNERS) {\n        nodeX = calloc(n, sizeof *nodeX);\n        if(!nodeX) return;\n    }\n\n    BmRect area = {b->w, b->h, 0, 0};\n    for(i = 0; i < n; i++) {\n        x = points[i].x;\n        y = points[i].y;\n        if(x < area.x0) area.x0 = x;\n        if(y < area.y0) area.y0 = y;\n        if(x > area.x1) area.x1 = x;\n        if(y > area.y1) area.y1 = y;\n    }\n    if(area.x0 < b->clip.x0) area.x0 = b->clip.x0;\n    if(area.y0 < b->clip.y0) area.y0 = b->clip.y0;\n    if(area.x1 >= b->clip.x1) area.x1 = b->clip.x1 - 1;\n    if(area.y1 >= b->clip.y1) area.y1 = b->clip.y1 - 1;\n\n    for(y = area.y0; y <= area.y1; y++) {\n        nodes = 0;\n        j = n - 1;\n\n        for(i = 0; i < n; i++) {\n            if((points[i].y < y && points[j].y >= y)\n                || (points[j].y < y && points[i].y >= y)) {\n                nodeX[nodes++] = (int)(points[i].x + (double)(y - points[i].y) * (points[j].x - points[i].x) / (points[j].y - points[i].y));\n            }\n            j = i;\n        }\n\n        assert(nodes < n);\n        if(nodes < 1) continue;\n\n        i = 0;\n        while(i < nodes - 1) {\n            if(nodeX[i] > nodeX[i+1]) {\n                int swap = nodeX[i];\n                nodeX[i] = nodeX[i + 1];\n                nodeX[i + 1] = swap;\n                if(i) i--;\n            } else {\n                i++;\n            }\n        }\n\n        for(i = 0; i < nodes; i += 2) {\n            if(nodeX[i] >= area.x1)\n                break;\n            if(nodeX[i + 1] > area.x0) {\n                if(nodeX[i] < area.x0)\n                    nodeX[i] = area.x0;\n                if(nodeX[i+1] > area.x1)\n                    nodeX[i+1] = area.x1;\n\n                for(x = nodeX[i]; x <= nodeX[i+1]; x++)\n                    BM_SET(b, x, y, c);\n            }\n        }\n    }\n\n    if(nodeX != nodeX_static)\n        free(nodeX);\n}",
  "diff_func": "--- func_before\n+++ func_after\n void bm_fillpoly(Bitmap *b, BmPoint points[], unsigned int n) {\n     /* http://alienryderflex.com/polygon_fill/\n     https://hackernoon.com/computer-graphics-scan-line-polygon-fill-algorithm-3cb47283df6\n \n     You might also be interested in this article:\n     http://nothings.org/gamedev/rasterize/\n     */\n-    unsigned int i, j, c = bm_get_color(b);\n+    unsigned int i, j, c; \n     int x, y;\n+\tassert(b);\n+\tc = bm_get_color(b);\n     if(n < 2)\n         return;\n     else if(n == 2) {\n         bm_line(b, points[0].x, points[0].y, points[1].x, points[1].y);\n         return;\n     }\n \n     int nodeX_static[MAX_POLY_CORNERS], *nodeX = nodeX_static;\n     unsigned int nodes;\n \n     if(n > MAX_POLY_CORNERS) {\n         nodeX = calloc(n, sizeof *nodeX);\n         if(!nodeX) return;\n     }\n \n     BmRect area = {b->w, b->h, 0, 0};\n     for(i = 0; i < n; i++) {\n         x = points[i].x;\n         y = points[i].y;\n         if(x < area.x0) area.x0 = x;\n         if(y < area.y0) area.y0 = y;\n         if(x > area.x1) area.x1 = x;\n         if(y > area.y1) area.y1 = y;\n     }\n     if(area.x0 < b->clip.x0) area.x0 = b->clip.x0;\n     if(area.y0 < b->clip.y0) area.y0 = b->clip.y0;\n     if(area.x1 >= b->clip.x1) area.x1 = b->clip.x1 - 1;\n     if(area.y1 >= b->clip.y1) area.y1 = b->clip.y1 - 1;\n \n     for(y = area.y0; y <= area.y1; y++) {\n         nodes = 0;\n         j = n - 1;\n \n         for(i = 0; i < n; i++) {\n             if((points[i].y < y && points[j].y >= y)\n                 || (points[j].y < y && points[i].y >= y)) {\n                 nodeX[nodes++] = (int)(points[i].x + (double)(y - points[i].y) * (points[j].x - points[i].x) / (points[j].y - points[i].y));\n             }\n             j = i;\n         }\n \n         assert(nodes < n);\n         if(nodes < 1) continue;\n \n         i = 0;\n         while(i < nodes - 1) {\n             if(nodeX[i] > nodeX[i+1]) {\n                 int swap = nodeX[i];\n                 nodeX[i] = nodeX[i + 1];\n                 nodeX[",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch adds an assertion to check if the `Bitmap` pointer is valid before using it, addressing a known security vulnerability (CVE-2018-17073). This prevents potential null pointer dereferences and mitigates the risk of buffer overflow attacks.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}