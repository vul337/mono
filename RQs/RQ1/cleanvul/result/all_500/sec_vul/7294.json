{
  "id": 7294,
  "language": "C/C++",
  "commit_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "commit_sha": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "pr_info": "When decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "file_name": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvSTAT",
  "func_before": "int wolfSSH_SFTP_RecvSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    WS_SFTP_FILEATRB atr;\n    char* name = NULL;\n    int   ret = WS_SUCCESS;\n\n    word32 sz;\n    word32 idx = 0;\n\n    byte*  out = NULL;\n    word32 outSz = 0;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_STAT\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (name == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(name, data + idx, sz);\n    name[sz] = '\\0';\n\n    /* try to get file attributes and send back to client */\n    if (wolfSSH_CleanPath(ssh, name) < 0) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n            WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == WS_SUCCESS) {\n        WMEMSET((byte*)&atr, 0, sizeof(WS_SFTP_FILEATRB));\n        if (SFTP_GetAttributes(ssh->fs, name, &atr, 0, ssh->ctx->heap)\n            != WS_SUCCESS) {\n            WLOG(WS_LOG_SFTP, \"Unable to get stat of file/directory\");\n            if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                    \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n                WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n                return WS_FATAL_ERROR;\n            }\n            ret = WS_BAD_FILE_E;\n        }\n        else {\n            sz = SFTP_AtributesSz(ssh, &atr);\n            outSz = sz + WOLFSSH_SFTP_HEADER;\n        }\n    }\n    WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != WS_SUCCESS) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"STAT error\", \"English\", out, &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        if (SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_ATTRS, sz, out) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        SFTP_SetAttributes(ssh, out + WOLFSSH_SFTP_HEADER, sz, &atr);\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "func_after": "int wolfSSH_SFTP_RecvSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    WS_SFTP_FILEATRB atr;\n    char* name = NULL;\n    int   ret = WS_SUCCESS;\n\n    word32 sz;\n    word32 idx = 0;\n\n    byte*  out = NULL;\n    word32 outSz = 0;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_STAT\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (name == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(name, data + idx, sz);\n    name[sz] = '\\0';\n\n    /* try to get file attributes and send back to client */\n    if (wolfSSH_CleanPath(ssh, name) < 0) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n            WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == WS_SUCCESS) {\n        WMEMSET((byte*)&atr, 0, sizeof(WS_SFTP_FILEATRB));\n        if (SFTP_GetAttributes(ssh->fs, name, &atr, 0, ssh->ctx->heap)\n            != WS_SUCCESS) {\n            WLOG(WS_LOG_SFTP, \"Unable to get stat of file/directory\");\n            if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                    \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n                WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n                return WS_FATAL_ERROR;\n            }\n            ret = WS_BAD_FILE_E;\n        }\n        else {\n            sz = SFTP_AtributesSz(ssh, &atr);\n            outSz = sz + WOLFSSH_SFTP_HEADER;\n        }\n    }\n    WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != WS_SUCCESS) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"STAT error\", \"English\", out, &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        if (SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_ATTRS, sz, out) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        SFTP_SetAttributes(ssh, out + WOLFSSH_SFTP_HEADER, sz, &atr);\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int wolfSSH_SFTP_RecvSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n {\n     WS_SFTP_FILEATRB atr;\n     char* name = NULL;\n     int   ret = WS_SUCCESS;\n \n     word32 sz;\n     word32 idx = 0;\n \n     byte*  out = NULL;\n     word32 outSz = 0;\n \n     if (ssh == NULL) {\n         return WS_BAD_ARGUMENT;\n     }\n \n     WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_STAT\");\n \n     ato32(data + idx, &sz); idx += UINT32_SZ;\n-    if (sz + idx > maxSz) {\n+    if (sz > maxSz - idx) {\n         return WS_BUFFER_E;\n     }\n \n     /* plus one to make sure is null terminated */\n     name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n     if (name == NULL) {\n         return WS_MEMORY_E;\n     }\n     WMEMCPY(name, data + idx, sz);\n     name[sz] = '\\0';\n \n     /* try to get file attributes and send back to client */\n     if (wolfSSH_CleanPath(ssh, name) < 0) {\n         if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                 \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n             WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n             return WS_FATAL_ERROR;\n         }\n         ret = WS_FATAL_ERROR;\n     }\n \n     if (ret == WS_SUCCESS) {\n         WMEMSET((byte*)&atr, 0, sizeof(WS_SFTP_FILEATRB));\n         if (SFTP_GetAttributes(ssh->fs, name, &atr, 0, ssh->ctx->heap)\n             != WS_SUCCESS) {\n             WLOG(WS_LOG_SFTP, \"Unable to get stat of file/directory\");\n             if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                     \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n                 WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n                 return WS_FATAL_ERROR;\n             }\n             ret = WS_BAD_FILE_E;\n         }\n         else {\n             sz = SFTP_AtributesSz(ssh, &atr);\n             outSz = sz + WOLFSSH_SFTP_HEADER;\n         }\n     }\n     WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n \n     out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYN",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a buffer overflow issue in SFTP message decoding, preventing size checks from wrapping. This fix mitigates a potential security vulnerability.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}