{
  "id": 3991,
  "language": "C/C++",
  "commit_url": "https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd",
  "commit_sha": "57415dda6cf04e73ffc3723be518eddfae599bfd",
  "commit_msg": "Add recursion limit for ASN.1 indefinite lengths\n\nThe libkrb5 ASN.1 decoder supports BER indefinite lengths.  It\ncomputes the tag length using recursion; the lack of a recursion limit\nallows an attacker to overrun the stack and cause the process to\ncrash.  Reported by Demi Obenour.\n\nCVE-2020-28196:\n\nIn MIT krb5 releases 1.11 and later, an unauthenticated attacker can\ncause a denial of service for any client or server to which it can\nsend an ASN.1-encoded Kerberos message of sufficient length.\n\nticket: 8959 (new)\ntags: pullup\ntarget_version: 1.18-next\ntarget_version: 1.17-next",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/lib/krb5/asn.1/asn1_encode.c",
  "func_name": "k5_asn1_full_decode",
  "func_before": "krb5_error_code\nk5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    /* rlen should be 0, but we don't check it (and due to padding in\n     * non-length-preserving enctypes, it will sometimes be nonzero). */\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}",
  "func_after": "krb5_error_code\nk5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    /* rlen should be 0, but we don't check it (and due to padding in\n     * non-length-preserving enctypes, it will sometimes be nonzero). */\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}",
  "diff_func": "--- func_before\n+++ func_after\n krb5_error_code\n k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                     void **retrep)\n {\n     krb5_error_code ret;\n     const uint8_t *contents, *remainder;\n     size_t clen, rlen;\n     taginfo t;\n \n     *retrep = NULL;\n     ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n-                  &clen, &remainder, &rlen);\n+                  &clen, &remainder, &rlen, 0);\n     if (ret)\n         return ret;\n     /* rlen should be 0, but we don't check it (and due to padding in\n      * non-length-preserving enctypes, it will sometimes be nonzero). */\n     if (!check_atype_tag(a, &t))\n         return ASN1_BAD_ID;\n     return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n }",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by adding a recursion limit to prevent stack overflow attacks, which could cause a denial of service.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}