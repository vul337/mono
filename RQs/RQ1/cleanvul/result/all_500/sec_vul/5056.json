{
  "id": 5056,
  "language": "Python",
  "commit_url": "https://github.com/matrix-org/sydent/commit/4e1cfff53429c49c87d5c457a18ed435520044fc",
  "commit_sha": "4e1cfff53429c49c87d5c457a18ed435520044fc",
  "commit_msg": "Require that parsed mail addresses match raw input\n\nPython's email parser turns malformed addresses into valid ones\nby removing anything after and including the second '@'. This\nmeant that sydent sent emails to the validated address but stored\nthe raw address as validated.\n\nThis rejects any requests where the parsed email address does not\nmatch the raw input.",
  "pr_url": "https://github.com/matrix-org/sydent/pull/301",
  "pr_info": "Based off https://github.com/matrix-org/sydent/pull/297",
  "file_name": "sydent/util/emailutils.py",
  "func_name": "sendEmail",
  "func_before": "def sendEmail(sydent, templateName, mailTo, substitutions):\n        mailFrom = sydent.cfg.get('email', 'email.from')\n        mailTemplateFile = sydent.cfg.get('email', templateName)\n\n        myHostname = sydent.cfg.get('email', 'email.hostname')\n        if myHostname == '':\n            myHostname = socket.getfqdn()\n        midRandom = \"\".join([random.choice(string.ascii_letters) for _ in range(16)])\n        messageid = \"<%d%s@%s>\" % (time_msec(), midRandom, myHostname)\n\n        allSubstitutions = {}\n        allSubstitutions.update(substitutions)\n        allSubstitutions.update({\n            'messageid': messageid,\n            'date': email.utils.formatdate(localtime=False),\n            'to': mailTo,\n            'from': mailFrom,\n        })\n\n        for k,v in allSubstitutions.items():\n            allSubstitutions[k] = v.decode('utf8')\n            allSubstitutions[k+\"_forhtml\"] = cgi.escape(v.decode('utf8'))\n            allSubstitutions[k+\"_forurl\"] = urllib.quote(v)\n\n        mailString = open(mailTemplateFile).read() % allSubstitutions\n        rawFrom = email.utils.parseaddr(mailFrom)[1]\n        rawTo = email.utils.parseaddr(mailTo)[1]\n        if rawFrom == '' or rawTo == '':\n            logger.info(\"Couldn't parse from / to address %s / %s\", mailFrom, mailTo)\n            raise EmailAddressException()\n        mailServer = sydent.cfg.get('email', 'email.smtphost')\n        mailPort = sydent.cfg.get('email', 'email.smtpport')\n        mailUsername = sydent.cfg.get('email', 'email.smtpusername')\n        mailPassword = sydent.cfg.get('email', 'email.smtppassword')\n        mailTLSMode = sydent.cfg.get('email', 'email.tlsmode')\n        logger.info(\"Sending mail to %s with mail server: %s\" % (mailTo, mailServer,))\n        try:\n            if mailTLSMode == 'SSL' or mailTLSMode == 'TLS':\n                smtp = smtplib.SMTP_SSL(mailServer, mailPort, myHostname)\n            elif mailTLSMode == 'STARTTLS':\n                smtp = smtplib.SMTP(mailServer, mailPort, myHostname)\n                smtp.starttls()\n            else:\n                smtp = smtplib.SMTP(mailServer, mailPort, myHostname)\n            if mailUsername != '':\n                smtp.login(mailUsername, mailPassword)\n            smtp.sendmail(rawFrom, rawTo, mailString.encode('utf-8'))\n            smtp.quit()\n        except Exception as origException:\n            twisted.python.log.err()\n            ese = EmailSendException()\n            ese.cause = origException\n            raise ese",
  "func_after": "def sendEmail(sydent, templateName, mailTo, substitutions):\n        mailFrom = sydent.cfg.get('email', 'email.from')\n        mailTemplateFile = sydent.cfg.get('email', templateName)\n\n        myHostname = sydent.cfg.get('email', 'email.hostname')\n        if myHostname == '':\n            myHostname = socket.getfqdn()\n        midRandom = \"\".join([random.choice(string.ascii_letters) for _ in range(16)])\n        messageid = \"<%d%s@%s>\" % (time_msec(), midRandom, myHostname)\n\n        allSubstitutions = {}\n        allSubstitutions.update(substitutions)\n        allSubstitutions.update({\n            'messageid': messageid,\n            'date': email.utils.formatdate(localtime=False),\n            'to': mailTo,\n            'from': mailFrom,\n        })\n\n        for k,v in allSubstitutions.items():\n            allSubstitutions[k] = v.decode('utf8')\n            allSubstitutions[k+\"_forhtml\"] = cgi.escape(v.decode('utf8'))\n            allSubstitutions[k+\"_forurl\"] = urllib.quote(v)\n\n        mailString = open(mailTemplateFile).read().decode('utf8') % allSubstitutions\n        parsedFrom = email.utils.parseaddr(mailFrom)[1]\n        parsedTo = email.utils.parseaddr(mailTo)[1]\n        if parsedFrom == '' or parsedTo == '':\n            logger.info(\"Couldn't parse from / to address %s / %s\", mailFrom, mailTo)\n            raise EmailAddressException()\n\n        mailServer = sydent.cfg.get('email', 'email.smtphost')\n        mailPort = sydent.cfg.get('email', 'email.smtpport')\n        mailUsername = sydent.cfg.get('email', 'email.smtpusername')\n        mailPassword = sydent.cfg.get('email', 'email.smtppassword')\n        mailTLSMode = sydent.cfg.get('email', 'email.tlsmode')\n        logger.info(\"Sending mail to %s with mail server: %s\" % (mailTo, mailServer,))\n        try:\n            if mailTLSMode == 'SSL' or mailTLSMode == 'TLS':\n                smtp = smtplib.SMTP_SSL(mailServer, mailPort, myHostname)\n            elif mailTLSMode == 'STARTTLS':\n                smtp = smtplib.SMTP(mailServer, mailPort, myHostname)\n                smtp.starttls()\n            else:\n                smtp = smtplib.SMTP(mailServer, mailPort, myHostname)\n            if mailUsername != '':\n                smtp.login(mailUsername, mailPassword)\n\n            # We're using the parsing above to do basic validation, but instead of\n            # failing it may munge the address it returns. So we should *not* use\n            # that parsed address, as it may not match any validation done\n            # elsewhere.\n            smtp.sendmail(mailFrom, mailTo, mailString.encode('utf-8'))\n            smtp.quit()\n        except Exception as origException:\n            twisted.python.log.err()\n            ese = EmailSendException()\n            ese.cause = origException\n            raise ese",
  "diff_func": "--- func_before\n+++ func_after\n def sendEmail(sydent, templateName, mailTo, substitutions):\n         mailFrom = sydent.cfg.get('email', 'email.from')\n         mailTemplateFile = sydent.cfg.get('email', templateName)\n \n         myHostname = sydent.cfg.get('email', 'email.hostname')\n         if myHostname == '':\n             myHostname = socket.getfqdn()\n         midRandom = \"\".join([random.choice(string.ascii_letters) for _ in range(16)])\n         messageid = \"<%d%s@%s>\" % (time_msec(), midRandom, myHostname)\n \n         allSubstitutions = {}\n         allSubstitutions.update(substitutions)\n         allSubstitutions.update({\n             'messageid': messageid,\n             'date': email.utils.formatdate(localtime=False),\n             'to': mailTo,\n             'from': mailFrom,\n         })\n \n         for k,v in allSubstitutions.items():\n             allSubstitutions[k] = v.decode('utf8')\n             allSubstitutions[k+\"_forhtml\"] = cgi.escape(v.decode('utf8'))\n             allSubstitutions[k+\"_forurl\"] = urllib.quote(v)\n \n-        mailString = open(mailTemplateFile).read() % allSubstitutions\n+        mailString = open(mailTemplateFile).read().decode('utf8') % allSubstitutions\n-        rawFrom = email.utils.parseaddr(mailFrom)[1]\n+        parsedFrom = email.utils.parseaddr(mailFrom)[1]\n-        rawTo = email.utils.parseaddr(mailTo)[1]\n+        parsedTo = email.utils.parseaddr(mailTo)[1]\n-        if rawFrom == '' or rawTo == '':\n+        if parsedFrom == '' or parsedTo == '':\n             logger.info(\"Couldn't parse from / to address %s / %s\", mailFrom, mailTo)\n             raise EmailAddressException()\n+\n         mailServer = sydent.cfg.get('email', 'email.smtphost')\n         mailPort = sydent.cfg.get('email', 'email.smtpport')\n         mailUsername = sydent.cfg.get('email', 'email.smtpusername')\n         mailPassword = sydent.cfg.get('email', 'email.smtppassword')\n         mailTLSMode = sydent.cfg.get('email', 'email.tlsmode')\n         logger.info(\"Sending mail to %s",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by ensuring that email addresses are correctly validated, preventing potential data misrouting.\n\n**Final Output:**\nAnalysis: The patch modifies the sendEmail function to validate email addresses, ensuring that parsed addresses match raw inputs. This prevents the system from processing malformed addresses, mitigating risks of data misrouting and unauthorized access.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}