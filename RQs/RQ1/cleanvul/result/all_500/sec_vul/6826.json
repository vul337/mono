{
  "id": 6826,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/a08d3b3b99efd509133946056531cdf8f3a0c09b",
  "commit_sha": "a08d3b3b99efd509133946056531cdf8f3a0c09b",
  "commit_msg": "kvm: x86: fix emulator buffer overflow (CVE-2014-0049)\n\nThe problem occurs when the guest performs a pusha with the stack\naddress pointing to an mmio address (or an invalid guest physical\naddress) to start with, but then extending into an ordinary guest\nphysical address.  When doing repeated emulated pushes\nemulator_read_write sets mmio_needed to 1 on the first one.  On a\nlater push when the stack points to regular memory,\nmmio_nr_fragments is set to 0, but mmio_is_needed is not set to 0.\n\nAs a result, KVM exits to userspace, and then returns to\ncomplete_emulated_mmio.  In complete_emulated_mmio\nvcpu->mmio_cur_fragment is incremented.  The termination condition of\nvcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments is never achieved.\nThe code bounces back and fourth to userspace incrementing\nmmio_cur_fragment past it's buffer.  If the guest does nothing else it\neventually leads to a a crash on a memcpy from invalid memory address.\n\nHowever if a guest code can cause the vm to be destroyed in another\nvcpu with excellent timing, then kvm_clear_async_pf_completion_queue\ncan be used by the guest to control the data that's pointed to by the\ncall to cancel_work_item, which can be used to gain execution.\n\nFixes: f78146b0f9230765c6315b2e14f56112513389ad\nSigned-off-by: Andrew Honig <ahonig@google.com>\nCc: stable@vger.kernel.org (3.5+)\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "arch/x86/kvm/x86.c",
  "func_name": "complete_emulated_mmio",
  "func_before": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}",
  "func_after": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n {\n \tstruct kvm_run *run = vcpu->run;\n \tstruct kvm_mmio_fragment *frag;\n \tunsigned len;\n \n \tBUG_ON(!vcpu->mmio_needed);\n \n \t/* Complete previous fragment */\n \tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n \tlen = min(8u, frag->len);\n \tif (!vcpu->mmio_is_write)\n \t\tmemcpy(frag->data, run->mmio.data, len);\n \n \tif (frag->len <= 8) {\n \t\t/* Switch to the next fragment. */\n \t\tfrag++;\n \t\tvcpu->mmio_cur_fragment++;\n \t} else {\n \t\t/* Go forward to the next mmio piece. */\n \t\tfrag->data += len;\n \t\tfrag->gpa += len;\n \t\tfrag->len -= len;\n \t}\n \n-\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n+\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n \t\tvcpu->mmio_needed = 0;\n \n \t\t/* FIXME: return into emulator if single-stepping.  */\n \t\tif (vcpu->mmio_is_write)\n \t\t\treturn 1;\n \t\tvcpu->mmio_read_completed = 1;\n \t\treturn complete_emulated_io(vcpu);\n \t}\n \n \trun->exit_reason = KVM_EXIT_MMIO;\n \trun->mmio.phys_addr = frag->gpa;\n \tif (vcpu->mmio_is_write)\n \t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n \trun->mmio.len = min(8u, frag->len);\n \trun->mmio.is_write = vcpu->mmio_is_write;\n \tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n \treturn 0;\n }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses a buffer overflow vulnerability in the KVM emulator, which could lead to arbitrary code execution. The code change modifies the termination condition to prevent overflow, aligning with the CVE-2014-0049 fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}