{
  "id": 5315,
  "language": "Python",
  "commit_url": "https://github.com/canonical/cloud-init/commit/b794d426b9ab43ea9d6371477466070d86e10668",
  "commit_sha": "b794d426b9ab43ea9d6371477466070d86e10668",
  "commit_msg": "write passwords only to serial console, lock down cloud-init-output.log (#847)\n\nPrior to this commit, when a user specified configuration which would\r\ngenerate random passwords for users, cloud-init would cause those\r\npasswords to be written to the serial console by emitting them on\r\nstderr.  In the default configuration, any stdout or stderr emitted by\r\ncloud-init is also written to `/var/log/cloud-init-output.log`.  This\r\nfile is world-readable, meaning that those randomly-generated passwords\r\nwere available to be read by any user with access to the system.  This\r\npresents an obvious security issue.\r\n\r\nThis commit responds to this issue in two ways:\r\n\r\n* We address the direct issue by moving from writing the passwords to\r\n  sys.stderr to writing them directly to /dev/console (via\r\n  util.multi_log); this means that the passwords will never end up in\r\n  cloud-init-output.log\r\n* To avoid future issues like this, we also modify the logging code so\r\n  that any files created in a log sink subprocess will only be\r\n  owner/group readable and, if it exists, will be owned by the adm\r\n  group.  This results in `/var/log/cloud-init-output.log` no longer\r\n  being world-readable, meaning that if there are other parts of the\r\n  codebase that are emitting sensitive data intended for the serial\r\n  console, that data is no longer available to all users of the system.\r\n\r\nLP: #1918303",
  "pr_url": "https://github.com/canonical/cloud-init/pull/847",
  "pr_info": "## Proposed Commit Message\r\n```\r\nwrite passwords only to serial console, lock down cloud-init-output.log\r\n\r\nPrior to this commit, when a user specified configuration which would\r\ngenerate random passwords for users, cloud-init would cause those\r\npasswords to be written to the serial console by emitting them on\r\nstderr.  In the default configuration, any stdout or stderr emitted by\r\ncloud-init is also written to `/var/log/cloud-init-output.log`.  This\r\nfile is world-readable, meaning that those randomly-generated passwords\r\nwere available to be read by any user with access to the system.  This\r\npresents an obvious security issue.\r\n\r\nThis commit responds to this issue in two ways:\r\n\r\n* We address the direct issue by moving from writing the passwords to\r\n  sys.stderr to writing them directly to /dev/console (via\r\n  util.multi_log); this means that the passwords will never end up in\r\n  cloud-init-output.log\r\n* To avoid future issues like this, we also modify the logging code so\r\n  that any files created in a log sink subprocess will only be\r\n  owner/group readable and, if it exists, will be owned by the adm\r\n  group.  This results in `/var/log/cloud-init-output.log` no longer\r\n  being world-readable, meaning that if there are other parts of the\r\n  codebase that are emitting sensitive data intended for the serial\r\n  console, that data is no longer available to all users of the system.\r\n\r\nLP: #1918303\r\n```\r\n\r\n## Test Steps\r\n\r\nSee the included integration tests.\r\n\r\n## Checklist:\r\n - [x] My code follows the process laid out in [the documentation](https://cloudinit.readthedocs.io/en/latest/topics/hacking.html)\r\n - [x] I have updated or added any unit tests accordingly\r\n - [x] I have updated or added any documentation accordingly",
  "file_name": "cloudinit/util.py",
  "func_name": "multi_log",
  "func_before": "def multi_log(text, console=True, stderr=True,\n              log=None, log_level=logging.DEBUG):\n    if stderr:\n        sys.stderr.write(text)\n    if console:\n        conpath = \"/dev/console\"\n        if os.path.exists(conpath):\n            with open(conpath, 'w') as wfh:\n                wfh.write(text)\n                wfh.flush()\n        else:\n            # A container may lack /dev/console (arguably a container bug).  If\n            # it does not exist, then write output to stdout.  this will result\n            # in duplicate stderr and stdout messages if stderr was True.\n            #\n            # even though upstart or systemd might have set up output to go to\n            # /dev/console, the user may have configured elsewhere via\n            # cloud-config 'output'.  If there is /dev/console, messages will\n            # still get there.\n            sys.stdout.write(text)\n    if log:\n        if text[-1] == \"\\n\":\n            log.log(log_level, text[:-1])\n        else:\n            log.log(log_level, text)",
  "func_after": "def multi_log(text, console=True, stderr=True,\n              log=None, log_level=logging.DEBUG, fallback_to_stdout=True):\n    if stderr:\n        sys.stderr.write(text)\n    if console:\n        conpath = \"/dev/console\"\n        if os.path.exists(conpath):\n            with open(conpath, 'w') as wfh:\n                wfh.write(text)\n                wfh.flush()\n        elif fallback_to_stdout:\n            # A container may lack /dev/console (arguably a container bug).  If\n            # it does not exist, then write output to stdout.  this will result\n            # in duplicate stderr and stdout messages if stderr was True.\n            #\n            # even though upstart or systemd might have set up output to go to\n            # /dev/console, the user may have configured elsewhere via\n            # cloud-config 'output'.  If there is /dev/console, messages will\n            # still get there.\n            sys.stdout.write(text)\n    if log:\n        if text[-1] == \"\\n\":\n            log.log(log_level, text[:-1])\n        else:\n            log.log(log_level, text)",
  "diff_func": "--- func_before\n+++ func_after\n def multi_log(text, console=True, stderr=True,\n-              log=None, log_level=logging.DEBUG):\n+              log=None, log_level=logging.DEBUG, fallback_to_stdout=True):\n     if stderr:\n         sys.stderr.write(text)\n     if console:\n         conpath = \"/dev/console\"\n         if os.path.exists(conpath):\n             with open(conpath, 'w') as wfh:\n                 wfh.write(text)\n                 wfh.flush()\n-        else:\n+        elif fallback_to_stdout:\n             # A container may lack /dev/console (arguably a container bug).  If\n             # it does not exist, then write output to stdout.  this will result\n             # in duplicate stderr and stdout messages if stderr was True.\n             #\n             # even though upstart or systemd might have set up output to go to\n             # /dev/console, the user may have configured elsewhere via\n             # cloud-config 'output'.  If there is /dev/console, messages will\n             # still get there.\n             sys.stdout.write(text)\n     if log:\n         if text[-1] == \"\\n\":\n             log.log(log_level, text[:-1])\n         else:\n             log.log(log_level, text)",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security issue where passwords were exposed in a world-readable log file. The changes prevent passwords from being written to this log and secure its permissions. \n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}