{
  "id": 4832,
  "language": "C/C++",
  "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7d57ca4d9a75562fa32e40766211de150f8b3ee7",
  "commit_sha": "7d57ca4d9a75562fa32e40766211de150f8b3ee7",
  "commit_msg": "avformat/rtmppkt: Check for packet size mismatches\n\nFixes out of array access\n\nFound-by: Paul Cher <paulcher@icloud.com>\nReviewed-by: Paul Cher <paulcher@icloud.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "libavformat/rtmppkt.c",
  "func_name": "rtmp_packet_read_one_chunk",
  "func_before": "static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n\n    written++;\n    channel_id = hdr & 0x3F;\n\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    }\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n            }\n        }\n    }\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    }\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    }\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    }\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       p->data      = NULL;\n       return AVERROR(EAGAIN);\n    }\n\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;\n}",
  "func_after": "static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n\n    written++;\n    channel_id = hdr & 0x3F;\n\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    }\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n            }\n        }\n    }\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    }\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n\n    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {\n        av_log(NULL, AV_LOG_ERROR, \"RTMP packet size mismatch %d != %d\\n\",\n                size,\n                prev_pkt[channel_id].size);\n        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);\n        prev_pkt[channel_id].read = 0;\n    }\n\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    }\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    }\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       p->data      = NULL;\n       return AVERROR(EAGAIN);\n    }\n\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                       int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                       int *nb_prev_pkt, uint8_t hdr)\n {\n \n     uint8_t buf[16];\n     int channel_id, timestamp, size;\n     uint32_t ts_field; // non-extended timestamp or delta field\n     uint32_t extra = 0;\n     enum RTMPPacketType type;\n     int written = 0;\n     int ret, toread;\n     RTMPPacket *prev_pkt;\n \n     written++;\n     channel_id = hdr & 0x3F;\n \n     if (channel_id < 2) { //special case for channel number >= 64\n         buf[1] = 0;\n         if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n             return AVERROR(EIO);\n         written += channel_id + 1;\n         channel_id = AV_RL16(buf) + 64;\n     }\n     if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                          channel_id)) < 0)\n         return ret;\n     prev_pkt = *prev_pkt_ptr;\n     size  = prev_pkt[channel_id].size;\n     type  = prev_pkt[channel_id].type;\n     extra = prev_pkt[channel_id].extra;\n \n     hdr >>= 6; // header size indicator\n     if (hdr == RTMP_PS_ONEBYTE) {\n         ts_field = prev_pkt[channel_id].ts_field;\n     } else {\n         if (ffurl_read_complete(h, buf, 3) != 3)\n             return AVERROR(EIO);\n         written += 3;\n         ts_field = AV_RB24(buf);\n         if (hdr != RTMP_PS_FOURBYTES) {\n             if (ffurl_read_complete(h, buf, 3) != 3)\n                 return AVERROR(EIO);\n             written += 3;\n             size = AV_RB24(buf);\n             if (ffurl_read_complete(h, buf, 1) != 1)\n                 return AVERROR(EIO);\n             written++;\n             type = buf[0];\n             if (hdr == RTMP_PS_TWELVEBYTES) {\n                 if (ffurl_read_complete(h, buf, 4) != 4)\n                     return AVERROR(EIO);\n                 written += 4;\n                 extra = AV_RL32(buf);\n             }\n   ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an out-of-bounds array access issue in the RTMP packet handling code, which is a security vulnerability. The code changes ensure that data reads are within buffer limits, preventing buffer overflow attacks.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}