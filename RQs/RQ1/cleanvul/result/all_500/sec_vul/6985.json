{
  "id": 6985,
  "language": "C/C++",
  "commit_url": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a",
  "commit_sha": "91f2fa59e8ed80dfbf400add0164ee0e508e412a",
  "commit_msg": "Fix a buffer overflow / heap corruption issue that could occur if a\nmalformed JSON string was passed on the control channel.  This issue,\npresent in the cJSON library, was already fixed upstream, so was\naddressed here in iperf3 by importing a newer version of cJSON (plus\nlocal ESnet modifications).\n\nDiscovered and reported by Dave McDaniel, Cisco Talos.\n\nBased on a patch by @dopheide-esnet, with input from @DaveGamble.\n\nCross-references:  TALOS-CAN-0164, ESNET-SECADV-2016-0001,\nCVE-2016-4303\n\n(cherry picked from commit ed94082be27d971a5e1b08b666e2c217cf470a40)\nSigned-off-by: Bruce A. Mah <bmah@es.net>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/iperf_api.c",
  "func_name": "get_results",
  "func_before": "static int\nget_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_cpu_util_total;\n    cJSON *j_cpu_util_user;\n    cJSON *j_cpu_util_system;\n    cJSON *j_sender_has_retransmits;\n    int result_has_retransmits;\n    cJSON *j_streams;\n    int n, i;\n    cJSON *j_stream;\n    cJSON *j_id;\n    cJSON *j_bytes;\n    cJSON *j_retransmits;\n    cJSON *j_jitter;\n    cJSON *j_errors;\n    cJSON *j_packets;\n    cJSON *j_server_output;\n    int sid, cerror, pcount;\n    double jitter;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n    struct iperf_stream *sp;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVRESULTS;\n        r = -1;\n    } else {\n\tj_cpu_util_total = cJSON_GetObjectItem(j, \"cpu_util_total\");\n\tj_cpu_util_user = cJSON_GetObjectItem(j, \"cpu_util_user\");\n\tj_cpu_util_system = cJSON_GetObjectItem(j, \"cpu_util_system\");\n\tj_sender_has_retransmits = cJSON_GetObjectItem(j, \"sender_has_retransmits\");\n\tif (j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL) {\n\t    i_errno = IERECVRESULTS;\n\t    r = -1;\n\t} else {\n\t    if (test->debug) {\n\t\tprintf(\"get_results\\n%s\\n\", cJSON_Print(j));\n\t    }\n\n\t    test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;\n\t    test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;\n\t    test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;\n\t    result_has_retransmits = j_sender_has_retransmits->valueint;\n\t    if (! test->sender)\n\t\ttest->sender_has_retransmits = result_has_retransmits;\n\t    j_streams = cJSON_GetObjectItem(j, \"streams\");\n\t    if (j_streams == NULL) {\n\t\ti_errno = IERECVRESULTS;\n\t\tr = -1;\n\t    } else {\n\t        n = cJSON_GetArraySize(j_streams);\n\t\tfor (i=0; i<n; ++i) {\n\t\t    j_stream = cJSON_GetArrayItem(j_streams, i);\n\t\t    if (j_stream == NULL) {\n\t\t\ti_errno = IERECVRESULTS;\n\t\t\tr = -1;\n\t\t    } else {\n\t\t\tj_id = cJSON_GetObjectItem(j_stream, \"id\");\n\t\t\tj_bytes = cJSON_GetObjectItem(j_stream, \"bytes\");\n\t\t\tj_retransmits = cJSON_GetObjectItem(j_stream, \"retransmits\");\n\t\t\tj_jitter = cJSON_GetObjectItem(j_stream, \"jitter\");\n\t\t\tj_errors = cJSON_GetObjectItem(j_stream, \"errors\");\n\t\t\tj_packets = cJSON_GetObjectItem(j_stream, \"packets\");\n\t\t\tif (j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL) {\n\t\t\t    i_errno = IERECVRESULTS;\n\t\t\t    r = -1;\n\t\t\t} else {\n\t\t\t    sid = j_id->valueint;\n\t\t\t    bytes_transferred = j_bytes->valueint;\n\t\t\t    retransmits = j_retransmits->valueint;\n\t\t\t    jitter = j_jitter->valuefloat;\n\t\t\t    cerror = j_errors->valueint;\n\t\t\t    pcount = j_packets->valueint;\n\t\t\t    SLIST_FOREACH(sp, &test->streams, streams)\n\t\t\t\tif (sp->id == sid) break;\n\t\t\t    if (sp == NULL) {\n\t\t\t\ti_errno = IESTREAMID;\n\t\t\t\tr = -1;\n\t\t\t    } else {\n\t\t\t\tif (test->sender) {\n\t\t\t\t    sp->jitter = jitter;\n\t\t\t\t    sp->cnt_error = cerror;\n\t\t\t\t    sp->packet_count = pcount;\n\t\t\t\t    sp->result->bytes_received = bytes_transferred;\n\t\t\t\t} else {\n\t\t\t\t    sp->result->bytes_sent = bytes_transferred;\n\t\t\t\t    sp->result->stream_retrans = retransmits;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * If we're the client and we're supposed to get remote results,\n\t\t * look them up and process accordingly.\n\t\t */\n\t\tif (test->role == 'c' && iperf_get_test_get_server_output(test)) {\n\t\t    /* Look for JSON.  If we find it, grab the object so it doesn't get deleted. */\n\t\t    j_server_output = cJSON_DetachItemFromObject(j, \"server_output_json\");\n\t\t    if (j_server_output != NULL) {\n\t\t\ttest->json_server_output = j_server_output;\n\t\t    }\n\t\t    else {\n\t\t\t/* No JSON, look for textual output.  Make a copy of the text for later. */\n\t\t\tj_server_output = cJSON_GetObjectItem(j, \"server_output_text\");\n\t\t\tif (j_server_output != NULL) {\n\t\t\t    test->server_output_text = strdup(j_server_output->valuestring);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}",
  "func_after": "static int\nget_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_cpu_util_total;\n    cJSON *j_cpu_util_user;\n    cJSON *j_cpu_util_system;\n    cJSON *j_sender_has_retransmits;\n    int result_has_retransmits;\n    cJSON *j_streams;\n    int n, i;\n    cJSON *j_stream;\n    cJSON *j_id;\n    cJSON *j_bytes;\n    cJSON *j_retransmits;\n    cJSON *j_jitter;\n    cJSON *j_errors;\n    cJSON *j_packets;\n    cJSON *j_server_output;\n    int sid, cerror, pcount;\n    double jitter;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n    struct iperf_stream *sp;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVRESULTS;\n        r = -1;\n    } else {\n\tj_cpu_util_total = cJSON_GetObjectItem(j, \"cpu_util_total\");\n\tj_cpu_util_user = cJSON_GetObjectItem(j, \"cpu_util_user\");\n\tj_cpu_util_system = cJSON_GetObjectItem(j, \"cpu_util_system\");\n\tj_sender_has_retransmits = cJSON_GetObjectItem(j, \"sender_has_retransmits\");\n\tif (j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL) {\n\t    i_errno = IERECVRESULTS;\n\t    r = -1;\n\t} else {\n\t    if (test->debug) {\n\t\tprintf(\"get_results\\n%s\\n\", cJSON_Print(j));\n\t    }\n\n\t    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;\n\t    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;\n\t    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;\n\t    result_has_retransmits = j_sender_has_retransmits->valueint;\n\t    if (! test->sender)\n\t\ttest->sender_has_retransmits = result_has_retransmits;\n\t    j_streams = cJSON_GetObjectItem(j, \"streams\");\n\t    if (j_streams == NULL) {\n\t\ti_errno = IERECVRESULTS;\n\t\tr = -1;\n\t    } else {\n\t        n = cJSON_GetArraySize(j_streams);\n\t\tfor (i=0; i<n; ++i) {\n\t\t    j_stream = cJSON_GetArrayItem(j_streams, i);\n\t\t    if (j_stream == NULL) {\n\t\t\ti_errno = IERECVRESULTS;\n\t\t\tr = -1;\n\t\t    } else {\n\t\t\tj_id = cJSON_GetObjectItem(j_stream, \"id\");\n\t\t\tj_bytes = cJSON_GetObjectItem(j_stream, \"bytes\");\n\t\t\tj_retransmits = cJSON_GetObjectItem(j_stream, \"retransmits\");\n\t\t\tj_jitter = cJSON_GetObjectItem(j_stream, \"jitter\");\n\t\t\tj_errors = cJSON_GetObjectItem(j_stream, \"errors\");\n\t\t\tj_packets = cJSON_GetObjectItem(j_stream, \"packets\");\n\t\t\tif (j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL) {\n\t\t\t    i_errno = IERECVRESULTS;\n\t\t\t    r = -1;\n\t\t\t} else {\n\t\t\t    sid = j_id->valueint;\n\t\t\t    bytes_transferred = j_bytes->valueint;\n\t\t\t    retransmits = j_retransmits->valueint;\n\t\t\t    jitter = j_jitter->valuedouble;\n\t\t\t    cerror = j_errors->valueint;\n\t\t\t    pcount = j_packets->valueint;\n\t\t\t    SLIST_FOREACH(sp, &test->streams, streams)\n\t\t\t\tif (sp->id == sid) break;\n\t\t\t    if (sp == NULL) {\n\t\t\t\ti_errno = IESTREAMID;\n\t\t\t\tr = -1;\n\t\t\t    } else {\n\t\t\t\tif (test->sender) {\n\t\t\t\t    sp->jitter = jitter;\n\t\t\t\t    sp->cnt_error = cerror;\n\t\t\t\t    sp->packet_count = pcount;\n\t\t\t\t    sp->result->bytes_received = bytes_transferred;\n\t\t\t\t} else {\n\t\t\t\t    sp->result->bytes_sent = bytes_transferred;\n\t\t\t\t    sp->result->stream_retrans = retransmits;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * If we're the client and we're supposed to get remote results,\n\t\t * look them up and process accordingly.\n\t\t */\n\t\tif (test->role == 'c' && iperf_get_test_get_server_output(test)) {\n\t\t    /* Look for JSON.  If we find it, grab the object so it doesn't get deleted. */\n\t\t    j_server_output = cJSON_DetachItemFromObject(j, \"server_output_json\");\n\t\t    if (j_server_output != NULL) {\n\t\t\ttest->json_server_output = j_server_output;\n\t\t    }\n\t\t    else {\n\t\t\t/* No JSON, look for textual output.  Make a copy of the text for later. */\n\t\t\tj_server_output = cJSON_GetObjectItem(j, \"server_output_text\");\n\t\t\tif (j_server_output != NULL) {\n\t\t\t    test->server_output_text = strdup(j_server_output->valuestring);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int\n get_results(struct iperf_test *test)\n {\n     int r = 0;\n     cJSON *j;\n     cJSON *j_cpu_util_total;\n     cJSON *j_cpu_util_user;\n     cJSON *j_cpu_util_system;\n     cJSON *j_sender_has_retransmits;\n     int result_has_retransmits;\n     cJSON *j_streams;\n     int n, i;\n     cJSON *j_stream;\n     cJSON *j_id;\n     cJSON *j_bytes;\n     cJSON *j_retransmits;\n     cJSON *j_jitter;\n     cJSON *j_errors;\n     cJSON *j_packets;\n     cJSON *j_server_output;\n     int sid, cerror, pcount;\n     double jitter;\n     iperf_size_t bytes_transferred;\n     int retransmits;\n     struct iperf_stream *sp;\n \n     j = JSON_read(test->ctrl_sck);\n     if (j == NULL) {\n \ti_errno = IERECVRESULTS;\n         r = -1;\n     } else {\n \tj_cpu_util_total = cJSON_GetObjectItem(j, \"cpu_util_total\");\n \tj_cpu_util_user = cJSON_GetObjectItem(j, \"cpu_util_user\");\n \tj_cpu_util_system = cJSON_GetObjectItem(j, \"cpu_util_system\");\n \tj_sender_has_retransmits = cJSON_GetObjectItem(j, \"sender_has_retransmits\");\n \tif (j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL) {\n \t    i_errno = IERECVRESULTS;\n \t    r = -1;\n \t} else {\n \t    if (test->debug) {\n \t\tprintf(\"get_results\\n%s\\n\", cJSON_Print(j));\n \t    }\n \n-\t    test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;\n+\t    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;\n-\t    test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;\n+\t    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;\n-\t    test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;\n+\t    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;\n \t    result_has_retransmits = j_sender_has_retransmits->valueint;\n \t    if (! test->sender)\n \t\ttest->sender_has_retransmits = result_has_retransmits;\n \t    j_streams = cJSON_GetObjectItem(j, \"streams\");\n \t    if (j_streams == NULL) {\n \t\ti_errno = IERECVRESULTS;\n \t\tr = -1;\n \t    } else {\n \t        n = cJSON_GetArraySize(j_streams",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by fixing a buffer overflow in cJSON, preventing potential attacks. The code changes modify JSON value handling to prevent overflow, aligning with the commit's security focus.\n\n**Final Output:**\nAnalysis: The patch fixes a buffer overflow in cJSON, preventing security issues. Code changes use valuedouble instead of valuefloat, enhancing data handling. The commit references a CVE, indicating a security fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}