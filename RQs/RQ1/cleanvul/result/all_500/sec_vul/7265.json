{
  "id": 7265,
  "language": "C/C++",
  "commit_url": "https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b",
  "commit_sha": "bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b",
  "commit_msg": "Merge pull request from GHSA-525h-wxcc-f66m\n\nSigned-off-by: Ming-Wei Shih <mishih@microsoft.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "syscall/devices/hostsock/hostsock.c",
  "func_name": "_hostsock_recvmsg",
  "func_before": "static ssize_t _hostsock_recvmsg(\n    oe_fd_t* sock_,\n    struct oe_msghdr* msg,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_errno = 0;\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    /* Check the parameters. */\n    if (!sock || !msg || (msg->msg_iovlen && !msg->msg_iov))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(msg->msg_iov, (int)msg->msg_iovlen, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    {\n        if (oe_syscall_recvmsg_ocall(\n                &ret,\n                sock->host_fd,\n                msg->msg_name,\n                msg->msg_namelen,\n                &msg->msg_namelen,\n                buf,\n                msg->msg_iovlen,\n                buf_size,\n                msg->msg_control,\n                msg->msg_controllen,\n                &msg->msg_controllen,\n                flags) != OE_OK)\n        {\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        if (ret == -1)\n            OE_RAISE_ERRNO(oe_errno);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(msg->msg_iov, (int)msg->msg_iovlen, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}",
  "func_after": "static ssize_t _hostsock_recvmsg(\n    oe_fd_t* sock_,\n    struct oe_msghdr* msg,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_errno = 0;\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n    oe_socklen_t namelen_out = 0;\n    size_t controllen_out = 0;\n\n    /* Check the parameters. */\n    if (!sock || !msg || (msg->msg_iovlen && !msg->msg_iov))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(\n            msg->msg_iov, (int)msg->msg_iovlen, &buf, &buf_size, &data_size) !=\n        0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    {\n        if (oe_syscall_recvmsg_ocall(\n                &ret,\n                sock->host_fd,\n                msg->msg_name,\n                msg->msg_namelen,\n                &namelen_out,\n                buf,\n                msg->msg_iovlen,\n                buf_size,\n                msg->msg_control,\n                msg->msg_controllen,\n                &controllen_out,\n                flags) != OE_OK)\n        {\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        if (ret == -1)\n            OE_RAISE_ERRNO(oe_errno);\n    }\n\n    if (!msg->msg_name)\n        msg->msg_namelen = 0;\n    else\n    {\n        /*\n         * Error out the case if the namelen_out is greater than the size\n         * of sockaddr_storage.\n         */\n        if (namelen_out > sizeof(struct oe_sockaddr_storage))\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        /*\n         * Note that the returned value can still exceed the supplied one,\n         * which indicates a truncation.\n         */\n        if (msg->msg_namelen >= namelen_out)\n            msg->msg_namelen = namelen_out;\n    }\n\n    if (!msg->msg_control)\n        msg->msg_controllen = 0;\n    else\n    {\n        /*\n         * Update the msg_controllen only if the supplied value is greater than\n         * or equal to the returned value. Otherwise, keep the msg_controllen\n         * unchanged, which indicates a truncation. In addition, explicitly\n         * setting the MSG_CTRUNC flag when the truncation occurs.\n         */\n        if (msg->msg_controllen >= controllen_out)\n            msg->msg_controllen = controllen_out;\n        else\n            msg->msg_flags |= OE_MSG_CTRUNC;\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(msg->msg_iov, (int)msg->msg_iovlen, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static ssize_t _hostsock_recvmsg(\n     oe_fd_t* sock_,\n     struct oe_msghdr* msg,\n     int flags)\n {\n     ssize_t ret = -1;\n     sock_t* sock = _cast_sock(sock_);\n     oe_errno = 0;\n     void* buf = NULL;\n     size_t buf_size = 0;\n+    size_t data_size = 0;\n+    oe_socklen_t namelen_out = 0;\n+    size_t controllen_out = 0;\n \n     /* Check the parameters. */\n     if (!sock || !msg || (msg->msg_iovlen && !msg->msg_iov))\n         OE_RAISE_ERRNO(OE_EINVAL);\n \n     /* Flatten the IO vector into contiguous heap memory. */\n+    if (oe_iov_pack(\n-    if (oe_iov_pack(msg->msg_iov, (int)msg->msg_iovlen, &buf, &buf_size) != 0)\n+            msg->msg_iov, (int)msg->msg_iovlen, &buf, &buf_size, &data_size) !=\n+        0)\n         OE_RAISE_ERRNO(OE_ENOMEM);\n+\n+    /*\n+     * According to the POSIX specification, when the data_size is greater\n+     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n+     * error in this case.\n+     * Refer to\n+     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html\n+     * for more detail.\n+     */\n+    if (data_size > OE_SSIZE_MAX)\n+        OE_RAISE_ERRNO(OE_EINVAL);\n \n     /* Call the host. */\n     {\n         if (oe_syscall_recvmsg_ocall(\n                 &ret,\n                 sock->host_fd,\n                 msg->msg_name,\n                 msg->msg_namelen,\n-                &msg->msg_namelen,\n+                &namelen_out,\n                 buf,\n                 msg->msg_iovlen,\n                 buf_size,\n                 msg->msg_control,\n                 msg->msg_controllen,\n-                &msg->msg_controllen,\n+                &controllen_out,\n                 flags) != OE_OK)\n         {\n             OE_RAISE_ERRNO(OE_EINVAL);\n         }\n \n         if (ret == -1)\n             OE_RAISE_ERRNO(oe_errno);\n+    }\n+\n+    if (!msg->msg_name)\n+        msg->msg_namelen = 0;\n+    else\n+    {\n+        /*\n+         * Error out the case if the namelen_out is greater than the size\n+",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n1. The commit message references a GitHub Security Advisory (GHSA), indicating a security-related issue.\n2. The code changes introduce checks for buffer overflows and correct handling of message lengths, which are critical for preventing security vulnerabilities like buffer overflow attacks.\n3. These modifications address potential security risks, such as unauthorized data access or code execution.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}