{
  "id": 7348,
  "language": "C/C++",
  "commit_url": "https://github.com/tbeu/matio/commit/5fa49ef9fc4368fe3d19b5fdaa36d8fa5e7f4606",
  "commit_sha": "5fa49ef9fc4368fe3d19b5fdaa36d8fa5e7f4606",
  "commit_msg": "Fix integer addition overflow\n\nAs reported by https://github.com/tbeu/matio/issues/121",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/mat5.c",
  "func_name": "ReadNextCell",
  "func_before": "static size_t\nReadNextCell( mat_t *mat, matvar_t *matvar )\n{\n    size_t bytesread = 0, i;\n    int err;\n    matvar_t **cells = NULL;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n    matvar->data_size = sizeof(matvar_t *);\n    err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n\n    matvar->data = calloc(nelems, matvar->data_size);\n    if ( NULL == matvar->data ) {\n        if ( NULL != matvar->name )\n            Mat_Critical(\"Couldn't allocate memory for %s->data\", matvar->name);\n        return bytesread;\n    }\n    cells = (matvar_t **)matvar->data;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            cells[i] = Mat_VarCalloc();\n            if ( NULL == cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            uncomp_buf[0] = 0;\n            uncomp_buf[1] = 0;\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( 0 == nbytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"], Uncompressed type not MAT_T_MATRIX\", i);\n                break;\n            }\n            cells[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array Flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\"Expected MAT_T_UINT32 for array tags, got %d\",\n                               uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( cells[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and Dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    cells[i]->rank = uncomp_buf[1];\n                    nbytes -= cells[i]->rank;\n                    cells[i]->rank /= 4;\n                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = dims[j];\n                    }\n                    if ( cells[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Handle cell elements written with a variable name */\n                if ( uncomp_buf[1] > 0 ) {\n                    /* Name of variable */\n                    if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                        mat_uint32_t len = uncomp_buf[1];\n\n                        if ( len % 8 > 0 )\n                            len = len+(8-(len % 8));\n                        cells[i]->name = (char*)malloc(len+1);\n                        nbytes -= len;\n                        if ( NULL != cells[i]->name ) {\n                            /* Variable name */\n                            bytesread += InflateVarName(mat,matvar,cells[i]->name,len);\n                            cells[i]->name[len] = '\\0';\n                        }\n                    } else {\n                        mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                        if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                            /* Name packed in tag */\n                            cells[i]->name = (char*)malloc(len+1);\n                            if ( NULL != cells[i]->name ) {\n                                memcpy(cells[i]->name,uncomp_buf+1,len);\n                                cells[i]->name[len] = '\\0';\n                            }\n                        }\n                    }\n                }\n                cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( cells[i]->internal->z != NULL ) {\n                    err = inflateCopy(cells[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( cells[i]->internal->datapos != -1L ) {\n                            cells[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( cells[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,cells[i]);\n                            else if ( cells[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,cells[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,cells[i]);\n                                cells[i]->internal->data = cells[i]->data;\n                                cells[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\"Couldn't determine file position\");\n                        }\n                        if ( cells[i]->internal->data != NULL ||\n                             cells[i]->class_type == MAT_C_STRUCT ||\n                             cells[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(cells[i]->internal->z);\n                            free(cells[i]->internal->z);\n                            cells[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\"Couldn't allocate memory\");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\"Not compiled with zlib support\");\n#endif\n\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            int cell_bytes_read,name_len;\n            cells[i] = Mat_VarCalloc();\n            if ( !cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            cell_bytes_read = fread(buf,4,2,(FILE*)mat->fp);\n\n            /* Empty cells at the end of a file may cause an EOF */\n            if ( !cell_bytes_read )\n                continue;\n            bytesread += cell_bytes_read;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( 0 == nBytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"] not MAT_T_MATRIX, fpos = %ld\", i,\n                    ftell((FILE*)mat->fp));\n                break;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = buf[3];\n               }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            name_len = 0;\n            if ( buf[1] > 0 ) {\n                /* Name of variable */\n                if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    name_len = buf[1];\n                    if ( name_len % 8 > 0 )\n                        name_len = name_len+(8-(name_len % 8));\n                    nBytes -= name_len;\n                    (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);\n                }\n            }\n            cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( cells[i]->internal->datapos != -1L ) {\n                if ( cells[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,cells[i]);\n                if ( cells[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,cells[i]);\n                (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        }\n    }\n\n    return bytesread;\n}",
  "func_after": "static size_t\nReadNextCell( mat_t *mat, matvar_t *matvar )\n{\n    size_t bytesread = 0, i;\n    int err;\n    matvar_t **cells = NULL;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n    matvar->data_size = sizeof(matvar_t *);\n    err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n\n    matvar->data = calloc(nelems, matvar->data_size);\n    if ( NULL == matvar->data ) {\n        if ( NULL != matvar->name )\n            Mat_Critical(\"Couldn't allocate memory for %s->data\", matvar->name);\n        return bytesread;\n    }\n    cells = (matvar_t **)matvar->data;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            cells[i] = Mat_VarCalloc();\n            if ( NULL == cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            uncomp_buf[0] = 0;\n            uncomp_buf[1] = 0;\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( 0 == nbytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"], Uncompressed type not MAT_T_MATRIX\", i);\n                break;\n            }\n            cells[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array Flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\"Expected MAT_T_UINT32 for array tags, got %d\",\n                               uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( cells[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and Dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    cells[i]->rank = uncomp_buf[1];\n                    nbytes -= cells[i]->rank;\n                    cells[i]->rank /= 4;\n                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = dims[j];\n                    }\n                    if ( cells[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Handle cell elements written with a variable name */\n                if ( uncomp_buf[1] > 0 ) {\n                    /* Name of variable */\n                    if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                        mat_uint32_t len = uncomp_buf[1];\n\n                        if ( len % 8 > 0 ) {\n                            if ( len < UINT32_MAX - 8 + (len % 8) )\n                              len = len + 8 - (len % 8);\n                            else {\n                                Mat_VarFree(cells[i]);\n                                cells[i] = NULL;\n                                break;\n                            }\n                        }\n                        cells[i]->name = (char*)malloc(len + 1);\n                        nbytes -= len;\n                        if ( NULL != cells[i]->name ) {\n                            /* Variable name */\n                            bytesread += InflateVarName(mat,matvar,cells[i]->name,len);\n                            cells[i]->name[len] = '\\0';\n                        }\n                    } else {\n                        mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                        if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                            /* Name packed in tag */\n                            cells[i]->name = (char*)malloc(len+1);\n                            if ( NULL != cells[i]->name ) {\n                                memcpy(cells[i]->name,uncomp_buf+1,len);\n                                cells[i]->name[len] = '\\0';\n                            }\n                        }\n                    }\n                }\n                cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( cells[i]->internal->z != NULL ) {\n                    err = inflateCopy(cells[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( cells[i]->internal->datapos != -1L ) {\n                            cells[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( cells[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,cells[i]);\n                            else if ( cells[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,cells[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,cells[i]);\n                                cells[i]->internal->data = cells[i]->data;\n                                cells[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\"Couldn't determine file position\");\n                        }\n                        if ( cells[i]->internal->data != NULL ||\n                             cells[i]->class_type == MAT_C_STRUCT ||\n                             cells[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(cells[i]->internal->z);\n                            free(cells[i]->internal->z);\n                            cells[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\"Couldn't allocate memory\");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\"Not compiled with zlib support\");\n#endif\n\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            int cell_bytes_read;\n            mat_uint32_t name_len;\n            cells[i] = Mat_VarCalloc();\n            if ( !cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            cell_bytes_read = fread(buf,4,2,(FILE*)mat->fp);\n\n            /* Empty cells at the end of a file may cause an EOF */\n            if ( !cell_bytes_read )\n                continue;\n            bytesread += cell_bytes_read;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( 0 == nBytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"] not MAT_T_MATRIX, fpos = %ld\", i,\n                    ftell((FILE*)mat->fp));\n                break;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = buf[3];\n               }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            name_len = 0;\n            if ( buf[1] > 0 ) {\n                /* Name of variable */\n                if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    name_len = buf[1];\n                    if ( name_len % 8 > 0 )\n                        if ( name_len < UINT32_MAX - 8 + (name_len % 8) )\n                            name_len = name_len + 8 - (name_len % 8);\n                        else {\n                            Mat_VarFree(cells[i]);\n                            cells[i] = NULL;\n                            break;\n                        }\n                    nBytes -= name_len;\n                    (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);\n                }\n            }\n            cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( cells[i]->internal->datapos != -1L ) {\n                if ( cells[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,cells[i]);\n                if ( cells[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,cells[i]);\n                (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        }\n    }\n\n    return bytesread;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static size_t\n ReadNextCell( mat_t *mat, matvar_t *matvar )\n {\n     size_t bytesread = 0, i;\n     int err;\n     matvar_t **cells = NULL;\n     size_t nelems = 1;\n \n     err = SafeMulDims(matvar, &nelems);\n     if ( err ) {\n         Mat_Critical(\"Integer multiplication overflow\");\n         return bytesread;\n     }\n     matvar->data_size = sizeof(matvar_t *);\n     err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n     if ( err ) {\n         Mat_Critical(\"Integer multiplication overflow\");\n         return bytesread;\n     }\n \n     matvar->data = calloc(nelems, matvar->data_size);\n     if ( NULL == matvar->data ) {\n         if ( NULL != matvar->name )\n             Mat_Critical(\"Couldn't allocate memory for %s->data\", matvar->name);\n         return bytesread;\n     }\n     cells = (matvar_t **)matvar->data;\n \n     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n #if defined(HAVE_ZLIB)\n         mat_uint32_t uncomp_buf[16] = {0,};\n         int nbytes;\n         mat_uint32_t array_flags;\n \n         for ( i = 0; i < nelems; i++ ) {\n             cells[i] = Mat_VarCalloc();\n             if ( NULL == cells[i] ) {\n                 Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                 continue;\n             }\n \n             /* Read variable tag for cell */\n             uncomp_buf[0] = 0;\n             uncomp_buf[1] = 0;\n             bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n             if ( mat->byteswap ) {\n                 (void)Mat_uint32Swap(uncomp_buf);\n                 (void)Mat_uint32Swap(uncomp_buf+1);\n             }\n             nbytes = uncomp_buf[1];\n             if ( 0 == nbytes ) {\n                 /* Empty cell: Memory optimization */\n                 free(cells[i]->internal);\n                 cells[i]->internal = NULL;\n                 continue;\n             } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                 Mat_VarFree(cells[i]);\n                 cells[i] = NULL;\n        ",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses an integer overflow vulnerability by adding checks to prevent overflow during multiplication, which could lead to buffer overflow attacks. This is a clear security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}