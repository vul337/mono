{
  "id": 1188,
  "language": "Java",
  "commit_url": "https://github.com/omnirom/android_frameworks_base/commit/3c92d74d7d74e1d781ae1b071da97b3b2cbc6be9",
  "commit_sha": "3c92d74d7d74e1d781ae1b071da97b3b2cbc6be9",
  "commit_msg": "Verify caller before auto granting slice permission\n\nCurrently SliceManagerService#checkSlicePermission does not verify the\ncaller's identity. This leads to a security vulnerability because\ncheckSlicePermission does more than checking the permission as opposed\nto simply return a boolean value -- it additionally grants slice access\nunder a certain condition. A malicious app can spoof the calling package\nto acquire slice access.\n\nThis CL verifies the caller before granting slice access.\n\nBug: 208232850, 179699767\nTest: manual\nChange-Id: I2539c9ff5ea977c91bb58185c95280b4d533a520\nMerged-In: I2539c9ff5ea977c91bb58185c95280b4d533a520\n(cherry picked from commit 5bd2196c537ae42a5c1626bdc23c3c6db41fb97f)",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/slice/SliceManagerService.java",
  "func_name": "checkSlicePermission",
  "func_before": "@Override\n    public int checkSlicePermission(Uri uri, String callingPkg, String pkg, int pid, int uid,\n            String[] autoGrantPermissions) {\n        int userId = UserHandle.getUserId(uid);\n        if (pkg == null) {\n            for (String p : mContext.getPackageManager().getPackagesForUid(uid)) {\n                if (checkSlicePermission(uri, callingPkg, p, pid, uid, autoGrantPermissions)\n                        == PERMISSION_GRANTED) {\n                    return PERMISSION_GRANTED;\n                }\n            }\n            return PERMISSION_DENIED;\n        }\n        if (hasFullSliceAccess(pkg, userId)) {\n            return PackageManager.PERMISSION_GRANTED;\n        }\n        if (mPermissions.hasPermission(pkg, userId, uri)) {\n            return PackageManager.PERMISSION_GRANTED;\n        }\n        if (autoGrantPermissions != null && callingPkg != null) {\n            // Need to own the Uri to call in with permissions to grant.\n            enforceOwner(callingPkg, uri, userId);\n            for (String perm : autoGrantPermissions) {\n                if (mContext.checkPermission(perm, pid, uid) == PERMISSION_GRANTED) {\n                    int providerUser = ContentProvider.getUserIdFromUri(uri, userId);\n                    String providerPkg = getProviderPkg(uri, providerUser);\n                    mPermissions.grantSliceAccess(pkg, userId, providerPkg, providerUser, uri);\n                    return PackageManager.PERMISSION_GRANTED;\n                }\n            }\n        }\n        // Fallback to allowing uri permissions through.\n        if (mContext.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION)\n                == PERMISSION_GRANTED) {\n            return PackageManager.PERMISSION_GRANTED;\n        }\n        return PackageManager.PERMISSION_DENIED;\n    }",
  "func_after": "@Override\n    public int checkSlicePermission(Uri uri, String callingPkg, String pkg, int pid, int uid,\n            String[] autoGrantPermissions) {\n        int userId = UserHandle.getUserId(uid);\n        if (pkg == null) {\n            for (String p : mContext.getPackageManager().getPackagesForUid(uid)) {\n                if (checkSlicePermission(uri, callingPkg, p, pid, uid, autoGrantPermissions)\n                        == PERMISSION_GRANTED) {\n                    return PERMISSION_GRANTED;\n                }\n            }\n            return PERMISSION_DENIED;\n        }\n        if (hasFullSliceAccess(pkg, userId)) {\n            return PackageManager.PERMISSION_GRANTED;\n        }\n        if (mPermissions.hasPermission(pkg, userId, uri)) {\n            return PackageManager.PERMISSION_GRANTED;\n        }\n        if (autoGrantPermissions != null && callingPkg != null) {\n            // Need to own the Uri to call in with permissions to grant.\n            enforceOwner(callingPkg, uri, userId);\n            // b/208232850: Needs to verify caller before granting slice access\n            verifyCaller(callingPkg);\n            for (String perm : autoGrantPermissions) {\n                if (mContext.checkPermission(perm, pid, uid) == PERMISSION_GRANTED) {\n                    int providerUser = ContentProvider.getUserIdFromUri(uri, userId);\n                    String providerPkg = getProviderPkg(uri, providerUser);\n                    mPermissions.grantSliceAccess(pkg, userId, providerPkg, providerUser, uri);\n                    return PackageManager.PERMISSION_GRANTED;\n                }\n            }\n        }\n        // Fallback to allowing uri permissions through.\n        if (mContext.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION)\n                == PERMISSION_GRANTED) {\n            return PackageManager.PERMISSION_GRANTED;\n        }\n        return PackageManager.PERMISSION_DENIED;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public int checkSlicePermission(Uri uri, String callingPkg, String pkg, int pid, int uid,\n             String[] autoGrantPermissions) {\n         int userId = UserHandle.getUserId(uid);\n         if (pkg == null) {\n             for (String p : mContext.getPackageManager().getPackagesForUid(uid)) {\n                 if (checkSlicePermission(uri, callingPkg, p, pid, uid, autoGrantPermissions)\n                         == PERMISSION_GRANTED) {\n                     return PERMISSION_GRANTED;\n                 }\n             }\n             return PERMISSION_DENIED;\n         }\n         if (hasFullSliceAccess(pkg, userId)) {\n             return PackageManager.PERMISSION_GRANTED;\n         }\n         if (mPermissions.hasPermission(pkg, userId, uri)) {\n             return PackageManager.PERMISSION_GRANTED;\n         }\n         if (autoGrantPermissions != null && callingPkg != null) {\n             // Need to own the Uri to call in with permissions to grant.\n             enforceOwner(callingPkg, uri, userId);\n+            // b/208232850: Needs to verify caller before granting slice access\n+            verifyCaller(callingPkg);\n             for (String perm : autoGrantPermissions) {\n                 if (mContext.checkPermission(perm, pid, uid) == PERMISSION_GRANTED) {\n                     int providerUser = ContentProvider.getUserIdFromUri(uri, userId);\n                     String providerPkg = getProviderPkg(uri, providerUser);\n                     mPermissions.grantSliceAccess(pkg, userId, providerPkg, providerUser, uri);\n                     return PackageManager.PERMISSION_GRANTED;\n                 }\n             }\n         }\n         // Fallback to allowing uri permissions through.\n         if (mContext.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION)\n                 == PERMISSION_GRANTED) {\n             return PackageManager.PERMISSION_GRANTED;\n         }\n         return PackageManager.PERMISSION_DENIED;\n  ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security vulnerability by verifying the caller's identity before granting slice access, preventing unauthorized access.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}