{
  "id": 4985,
  "language": "C/C++",
  "commit_url": "https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961",
  "commit_sha": "899a5d9f0ed13b8e32449a08a361e0de127dd961",
  "commit_msg": "Detect infinite recursion in parameter entities\n\nWhen expanding a parameter entity in a DTD, infinite recursion could\nlead to an infinite loop or memory exhaustion.\n\nThanks to Wei Lei for the first of many reports.\n\nFixes bug 759579.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "parser.c",
  "func_name": "xmlParsePEReference",
  "func_before": "void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n\treturn;\n    }\n    if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"PEReference: %s\\n\", name);\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {\n                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                                 \"PEReference: %%%s; not found\\n\",\n                                 name, NULL);\n            } else\n                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                              \"PEReference: %%%s; not found\\n\",\n                              name, NULL);\n            ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n\t} else {\n            xmlChar start[4];\n            xmlCharEncoding enc;\n\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n\t\t(ctxt->replaceEntities == 0) &&\n\t\t(ctxt->validate == 0))\n\t\treturn;\n\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\n\t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                /*\n                 * Get the 4 first bytes and decode the charset\n                 * if enc != XML_CHAR_ENCODING_NONE\n                 * plug some encoding conversion routines.\n                 * Note that, since we may have some non-UTF8\n                 * encoding (like UTF16, bug 135229), the 'length'\n                 * is not known, but we can calculate based upon\n                 * the amount of data in the buffer.\n                 */\n                GROW\n                if (ctxt->instate == XML_PARSER_EOF)\n                    return;\n                if ((ctxt->input->end - ctxt->input->cur)>=4) {\n                    start[0] = RAW;\n                    start[1] = NXT(1);\n                    start[2] = NXT(2);\n                    start[3] = NXT(3);\n                    enc = xmlDetectCharEncoding(start, 4);\n                    if (enc != XML_CHAR_ENCODING_NONE) {\n                        xmlSwitchEncoding(ctxt, enc);\n                    }\n                }\n\n                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n                    (IS_BLANK_CH(NXT(5)))) {\n                    xmlParseTextDecl(ctxt);\n                }\n            }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}",
  "func_after": "void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n\treturn;\n    }\n    if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"PEReference: %s\\n\", name);\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {\n                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                                 \"PEReference: %%%s; not found\\n\",\n                                 name, NULL);\n            } else\n                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                              \"PEReference: %%%s; not found\\n\",\n                              name, NULL);\n            ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n\t} else {\n            xmlChar start[4];\n            xmlCharEncoding enc;\n\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n\t\t(ctxt->replaceEntities == 0) &&\n\t\t(ctxt->validate == 0))\n\t\treturn;\n\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0) {\n                xmlFreeInputStream(input);\n\t\treturn;\n            }\n\n\t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                /*\n                 * Get the 4 first bytes and decode the charset\n                 * if enc != XML_CHAR_ENCODING_NONE\n                 * plug some encoding conversion routines.\n                 * Note that, since we may have some non-UTF8\n                 * encoding (like UTF16, bug 135229), the 'length'\n                 * is not known, but we can calculate based upon\n                 * the amount of data in the buffer.\n                 */\n                GROW\n                if (ctxt->instate == XML_PARSER_EOF)\n                    return;\n                if ((ctxt->input->end - ctxt->input->cur)>=4) {\n                    start[0] = RAW;\n                    start[1] = NXT(1);\n                    start[2] = NXT(2);\n                    start[3] = NXT(3);\n                    enc = xmlDetectCharEncoding(start, 4);\n                    if (enc != XML_CHAR_ENCODING_NONE) {\n                        xmlSwitchEncoding(ctxt, enc);\n                    }\n                }\n\n                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n                    (IS_BLANK_CH(NXT(5)))) {\n                    xmlParseTextDecl(ctxt);\n                }\n            }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}",
  "diff_func": "--- func_before\n+++ func_after\n void\n xmlParsePEReference(xmlParserCtxtPtr ctxt)\n {\n     const xmlChar *name;\n     xmlEntityPtr entity = NULL;\n     xmlParserInputPtr input;\n \n     if (RAW != '%')\n         return;\n     NEXT;\n     name = xmlParseName(ctxt);\n     if (name == NULL) {\n \txmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n \treturn;\n     }\n     if (xmlParserDebugEntities)\n \txmlGenericError(xmlGenericErrorContext,\n \t\t\"PEReference: %s\\n\", name);\n     if (RAW != ';') {\n \txmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n         return;\n     }\n \n     NEXT;\n \n     /*\n      * Increate the number of entity references parsed\n      */\n     ctxt->nbentities++;\n \n     /*\n      * Request the entity from SAX\n      */\n     if ((ctxt->sax != NULL) &&\n \t(ctxt->sax->getParameterEntity != NULL))\n \tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n     if (ctxt->instate == XML_PARSER_EOF)\n \treturn;\n     if (entity == NULL) {\n \t/*\n \t * [ WFC: Entity Declared ]\n \t * In a document without any DTD, a document with only an\n \t * internal DTD subset which contains no parameter entity\n \t * references, or a document with \"standalone='yes'\", ...\n \t * ... The declaration of a parameter entity must precede\n \t * any reference to it...\n \t */\n \tif ((ctxt->standalone == 1) ||\n \t    ((ctxt->hasExternalSubset == 0) &&\n \t     (ctxt->hasPErefs == 0))) {\n \t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n \t\t\t      \"PEReference: %%%s; not found\\n\",\n \t\t\t      name);\n \t} else {\n \t    /*\n \t     * [ VC: Entity Declared ]\n \t     * In a document with an external subset or external\n \t     * parameter entities with \"standalone='no'\", ...\n \t     * ... The declaration of a parameter entity must\n \t     * precede any reference to it...\n \t     */\n             if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {\n                 xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                                  \"PEReference: %%%s; not found\\n\",\n                    ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses an infinite recursion issue in parameter entity parsing, which could cause memory exhaustion, a security concern impacting availability.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}