{
  "id": 4263,
  "language": "C/C++",
  "commit_url": "https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168",
  "commit_sha": "01c658f8c45cb92a343be5f32aa6da70b2032168",
  "commit_msg": "redo the environment inheritance to not inherit. it was intended to make life easier, but it can be surprising or even unsafe. instead, reset just about everything to the target user's values. ok deraadt martijn Thanks to Sander Bos in particular for pointing out some nasty edge cases.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "doas.c",
  "func_name": "main",
  "func_before": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n#ifdef __OpenBSD__\n\tchar mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];\n#else\n\tchar *mypwbuf = NULL, *targpwbuf = NULL;\n#endif\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n#ifdef USE_BSD_AUTH\n\tchar *login_style = NULL;\n#endif\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n#ifdef USE_BSD_AUTH\n# define OPTSTRING \"a:C:Lnsu:\"\n#else\n# define OPTSTRING \"+C:Lnsu:\"\n#endif\n\n\twhile ((ch = getopt(argc, argv, OPTSTRING)) != -1) {\n\t\tswitch (ch) {\n#ifdef USE_BSD_AUTH\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_BSD_AUTH)\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i == -1);\n#elif defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\tmypwbuf = reallocarray(mypwbuf, sz, sizeof (char));\n\t\tif (mypwbuf == NULL)\n\t\t\terrx(1, \"can't allocate mypwbuf\");\n\t\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sz, &mypw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(\"/etc/doas.conf\", 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(__OpenBSD__) || defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n# ifdef __OpenBSD__\n\t\tauthuser(mypw->pw_name, login_style, rule->options & PERSIST);\n# else\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n# endif\n\t}\n\n# ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n# endif\n\n#elif !defined(USE_PAM)\n\t(void) nflag;\n\tif (!(rule->options & NOPASS)) {\n\t\terrx(1, \"Authorization required\");\n\t}\n#endif /* !(__OpenBSD__ || USE_SHADOW) && !USE_PAM */\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(target, &targpwstore, targpwbuf, sizeof(targpwbuf), &targpw);\n\tif (rv != 0)\n\t\terrx(1, \"no passwd entry for target\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\ttargpwbuf = reallocarray(targpwbuf, sz, sizeof (char));\n\t\tif (targpwbuf == NULL)\n\t\t\terrx(1, \"can't allocate targpwbuf\");\n\t\trv = getpwuid_r(target, &targpwstore, targpwbuf, sz, &targpw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (targpw == NULL)\n\t\terr(1, \"getpwuid_r failed\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_SETUSERCONTEXT\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\n\tenvp = prepenv(rule);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
  "func_after": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n#ifdef __OpenBSD__\n\tchar mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];\n#else\n\tchar *mypwbuf = NULL, *targpwbuf = NULL;\n#endif\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n#ifdef USE_BSD_AUTH\n\tchar *login_style = NULL;\n#endif\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n#ifdef USE_BSD_AUTH\n# define OPTSTRING \"a:C:Lnsu:\"\n#else\n# define OPTSTRING \"+C:Lnsu:\"\n#endif\n\n\twhile ((ch = getopt(argc, argv, OPTSTRING)) != -1) {\n\t\tswitch (ch) {\n#ifdef USE_BSD_AUTH\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_BSD_AUTH)\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i == -1);\n#elif defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\tmypwbuf = reallocarray(mypwbuf, sz, sizeof (char));\n\t\tif (mypwbuf == NULL)\n\t\t\terrx(1, \"can't allocate mypwbuf\");\n\t\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sz, &mypw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(\"/etc/doas.conf\", 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(__OpenBSD__) || defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n# ifdef __OpenBSD__\n\t\tauthuser(mypw->pw_name, login_style, rule->options & PERSIST);\n# else\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n# endif\n\t}\n\n# ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n# endif\n\n#elif !defined(USE_PAM)\n\t(void) nflag;\n\tif (!(rule->options & NOPASS)) {\n\t\terrx(1, \"Authorization required\");\n\t}\n#endif /* !(__OpenBSD__ || USE_SHADOW) && !USE_PAM */\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(target, &targpwstore, targpwbuf, sizeof(targpwbuf), &targpw);\n\tif (rv != 0)\n\t\terrx(1, \"no passwd entry for target\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\ttargpwbuf = reallocarray(targpwbuf, sz, sizeof (char));\n\t\tif (targpwbuf == NULL)\n\t\t\terrx(1, \"can't allocate targpwbuf\");\n\t\trv = getpwuid_r(target, &targpwstore, targpwbuf, sz, &targpw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (targpw == NULL)\n\t\terr(1, \"getpwuid_r failed\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_SETUSERCONTEXT\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPATH |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\tif (rule->cmd) {\n\t\t/* do this again after setusercontext reset it */\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
  "diff_func": "--- func_before\n+++ func_after\n int\n main(int argc, char **argv)\n {\n \tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n \t    \"/usr/local/bin:/usr/local/sbin\";\n \tconst char *confpath = NULL;\n \tchar *shargv[] = { NULL, NULL };\n \tchar *sh;\n \tconst char *cmd;\n \tchar cmdline[LINE_MAX];\n #ifdef __OpenBSD__\n \tchar mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];\n #else\n \tchar *mypwbuf = NULL, *targpwbuf = NULL;\n #endif\n \tstruct passwd mypwstore, targpwstore;\n \tstruct passwd *mypw, *targpw;\n \tconst struct rule *rule;\n \tuid_t uid;\n \tuid_t target = 0;\n \tgid_t groups[NGROUPS_MAX + 1];\n \tint ngroups;\n \tint i, ch, rv;\n \tint sflag = 0;\n \tint nflag = 0;\n \tchar cwdpath[PATH_MAX];\n \tconst char *cwd;\n \tchar **envp;\n #ifdef USE_BSD_AUTH\n \tchar *login_style = NULL;\n #endif\n \n \tsetprogname(\"doas\");\n \n \tclosefrom(STDERR_FILENO + 1);\n \n \tuid = getuid();\n \n #ifdef USE_BSD_AUTH\n # define OPTSTRING \"a:C:Lnsu:\"\n #else\n # define OPTSTRING \"+C:Lnsu:\"\n #endif\n \n \twhile ((ch = getopt(argc, argv, OPTSTRING)) != -1) {\n \t\tswitch (ch) {\n #ifdef USE_BSD_AUTH\n \t\tcase 'a':\n \t\t\tlogin_style = optarg;\n \t\t\tbreak;\n #endif\n \t\tcase 'C':\n \t\t\tconfpath = optarg;\n \t\t\tbreak;\n \t\tcase 'L':\n #if defined(USE_BSD_AUTH)\n \t\t\ti = open(\"/dev/tty\", O_RDWR);\n \t\t\tif (i != -1)\n \t\t\t\tioctl(i, TIOCCLRVERAUTH);\n \t\t\texit(i == -1);\n #elif defined(USE_TIMESTAMP)\n \t\t\texit(timestamp_clear() == -1);\n #else\n \t\t\texit(0);\n #endif\n \t\tcase 'u':\n \t\t\tif (parseuid(optarg, &target) != 0)\n \t\t\t\terrx(1, \"unknown user\");\n \t\t\tbreak;\n \t\tcase 'n':\n \t\t\tnflag = 1;\n \t\t\tbreak;\n \t\tcase 's':\n \t\t\tsflag = 1;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tusage();\n \t\t\tbreak;\n \t\t}\n \t}\n \targv += optind;\n \targc -= optind;\n \n \tif (confpath) {\n \t\tif (sflag)\n \t\t\tusage();\n \t} else if ((!sflag && !argc) || (sflag && argc))\n \t\tusage();\n \n #ifdef __OpenBSD__\n \trv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);\n \tif (rv != 0)\n \t\terr(1, \"getpwuid_r failed\");\n #else\n \tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n \t\tmypwbuf = reallocarray(mypwbuf, sz, sizeof (char));\n \t\ti",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by modifying environment inheritance to prevent potential attacks, thus ensuring system security.\n\n**Final Output:**\n\nAnalysis: The patch modifies environment inheritance to prevent potential security risks, specifically by resetting variables to the target user's values. This addresses a known security concern related to environment variable attacks.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}