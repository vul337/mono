{
  "id": 3181,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/883a1d49f0d77d30012f114b2e19fc141beb3e8e",
  "commit_sha": "883a1d49f0d77d30012f114b2e19fc141beb3e8e",
  "commit_msg": "ALSA: control: Make sure that id->index does not overflow\n\nThe ALSA control code expects that the range of assigned indices to a control is\ncontinuous and does not overflow. Currently there are no checks to enforce this.\nIf a control with a overflowing index range is created that control becomes\neffectively inaccessible and unremovable since snd_ctl_find_id() will not be\nable to find it. This patch adds a check that makes sure that controls with a\noverflowing index range can not be created.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "sound/core/control.c",
  "func_name": "snd_ctl_add",
  "func_before": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}",
  "func_after": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n {\n \tstruct snd_ctl_elem_id id;\n \tunsigned int idx;\n \tunsigned int count;\n \tint err = -EINVAL;\n \n \tif (! kcontrol)\n \t\treturn err;\n \tif (snd_BUG_ON(!card || !kcontrol->info))\n \t\tgoto error;\n \tid = kcontrol->id;\n+\tif (id.index > UINT_MAX - kcontrol->count)\n+\t\tgoto error;\n+\n \tdown_write(&card->controls_rwsem);\n \tif (snd_ctl_find_id(card, &id)) {\n \t\tup_write(&card->controls_rwsem);\n \t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n \t\t\t\t\tid.iface,\n \t\t\t\t\tid.device,\n \t\t\t\t\tid.subdevice,\n \t\t\t\t\tid.name,\n \t\t\t\t\tid.index);\n \t\terr = -EBUSY;\n \t\tgoto error;\n \t}\n \tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n \t\tup_write(&card->controls_rwsem);\n \t\terr = -ENOMEM;\n \t\tgoto error;\n \t}\n \tlist_add_tail(&kcontrol->list, &card->controls);\n \tcard->controls_count += kcontrol->count;\n \tkcontrol->id.numid = card->last_numid + 1;\n \tcard->last_numid += kcontrol->count;\n \tcount = kcontrol->count;\n \tup_write(&card->controls_rwsem);\n \tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n \t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n \treturn 0;\n \n  error:\n \tsnd_ctl_free_one(kcontrol);\n \treturn err;\n }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch adds a bounds check to prevent index overflow in ALSA controls, which could otherwise lead to system instability or security issues.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}