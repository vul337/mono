{
  "id": 4701,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd",
  "commit_sha": "096fe9eaea40a17e125569f9e657e34cdb6d73bd",
  "commit_msg": "KEYS: Fix handling of stored error in a negatively instantiated user key\n\nIf a user key gets negatively instantiated, an error code is cached in the\npayload area.  A negatively instantiated key may be then be positively\ninstantiated by updating it with valid data.  However, the ->update key\ntype method must be aware that the error code may be there.\n\nThe following may be used to trigger the bug in the user key type:\n\n    keyctl request2 user user \"\" @u\n    keyctl add user user \"a\" @u\n\nwhich manifests itself as:\n\n\tBUG: unable to handle kernel paging request at 00000000ffffff8a\n\tIP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046\n\tPGD 7cc30067 PUD 0\n\tOops: 0002 [#1] SMP\n\tModules linked in:\n\tCPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49\n\tHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n\ttask: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000\n\tRIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280\n\t [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046\n\tRSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246\n\tRAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001\n\tRDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82\n\tRBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000\n\tR10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82\n\tR13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700\n\tFS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000\n\tCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n\tCR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0\n\tStack:\n\t ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82\n\t ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5\n\t ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620\n\tCall Trace:\n\t [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136\n\t [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129\n\t [<     inline     >] __key_update security/keys/key.c:730\n\t [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908\n\t [<     inline     >] SYSC_add_key security/keys/keyctl.c:125\n\t [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60\n\t [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185\n\nNote the error code (-ENOKEY) in EDX.\n\nA similar bug can be tripped by:\n\n    keyctl request2 trusted user \"\" @u\n    keyctl add trusted user \"a\" @u\n\nThis should also affect encrypted keys - but that has to be correctly\nparameterised or it will fail with EINVAL before getting to the bit that\nwill crashes.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "security/keys/user_defined.c",
  "func_name": "user_update",
  "func_before": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data[0];\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}",
  "func_after": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\t\tzap = key->payload.data[0];\n\t\telse\n\t\t\tzap = NULL;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int user_update(struct key *key, struct key_preparsed_payload *prep)\n {\n \tstruct user_key_payload *upayload, *zap;\n \tsize_t datalen = prep->datalen;\n \tint ret;\n \n \tret = -EINVAL;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\tgoto error;\n \n \t/* construct a replacement payload */\n \tret = -ENOMEM;\n \tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n \tif (!upayload)\n \t\tgoto error;\n \n \tupayload->datalen = datalen;\n \tmemcpy(upayload->data, prep->data, datalen);\n \n \t/* check the quota and attach the new data */\n \tzap = upayload;\n \n \tret = key_payload_reserve(key, datalen);\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n-\t\tzap = key->payload.data[0];\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}\n \n \tif (zap)\n \t\tkfree_rcu(zap, rcu);\n \n error:\n \treturn ret;\n }",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing a kernel crash due to improper handling of a cached error in user keys. The fix ensures that the payload isn't accessed when the key is in a negative state, thus mitigating a potential denial of service.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}