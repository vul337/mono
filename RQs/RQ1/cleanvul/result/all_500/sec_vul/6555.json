{
  "id": 6555,
  "language": "C/C++",
  "commit_url": "https://github.com/RIOT-OS/RIOT/commit/59a7e01bbfa3b8870bedb7c6820723ee69cd8ca2",
  "commit_sha": "59a7e01bbfa3b8870bedb7c6820723ee69cd8ca2",
  "commit_msg": "ipv6_addr: provide fix for off-by-x error",
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/6962",
  "pr_info": "2017.04 backport for #6961.",
  "file_name": "sys/net/network_layer/ipv6/addr/ipv6_addr_from_str.c",
  "func_name": "ipv6_addr_from_str",
  "func_before": "ipv6_addr_t *ipv6_addr_from_str(ipv6_addr_t *result, const char *addr)\n{\n    uint8_t *colonp = 0;\n#ifdef MODULE_IPV4_ADDR\n    const char *curtok = addr;\n#endif\n    uint32_t val = 0;\n    char ch;\n    uint8_t saw_xdigit = 0;\n    uint8_t i = 0;\n\n    if ((result == NULL) || (addr == NULL)) {\n        return NULL;\n    }\n\n    ipv6_addr_set_unspecified(result);\n\n    /* Leading :: requires some special handling. */\n    if (*addr == ':') {\n        if (*++addr != ':') {\n            return NULL;\n        }\n    }\n\n    while ((ch = *addr++) != '\\0') {\n        const char *pch;\n        const char *xdigits;\n\n        if ((pch = strchr((xdigits = HEX_L), ch)) == NULL) {\n            pch = strchr((xdigits = HEX_U), ch);\n        }\n\n        if (pch != NULL) {\n            val <<= 4;\n            val |= (pch - xdigits);\n\n            if (val > 0xffff) {\n                return NULL;\n            }\n\n            saw_xdigit = 1;\n            continue;\n        }\n\n        if (ch == ':') {\n#ifdef MODULE_IPV4_ADDR\n            curtok = addr;\n#endif\n\n            if (!saw_xdigit) {\n                if (colonp != NULL) {\n                    return NULL;\n                }\n\n                colonp = &(result->u8[i]);\n                continue;\n            }\n\n            if (i > sizeof(ipv6_addr_t)) {\n                return NULL;\n            }\n\n            result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n            result->u8[i++] = (uint8_t) val & 0xff;\n            saw_xdigit = 0;\n            val = 0;\n            continue;\n        }\n\n#ifdef MODULE_IPV4_ADDR\n        if (ch == '.' && (i <= sizeof(ipv6_addr_t)) &&\n            ipv4_addr_from_str((ipv4_addr_t *)(&(result->u8[i])),\n                               curtok) != NULL) {\n            i += sizeof(ipv4_addr_t);\n            saw_xdigit = 0;\n            break;  /* '\\0' was seen by ipv4_addr_from_str(). */\n        }\n#endif\n\n        return NULL;\n    }\n\n    if (saw_xdigit) {\n        if (i + sizeof(uint16_t) > sizeof(ipv6_addr_t)) {\n            return NULL;\n        }\n\n        result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n        result->u8[i++] = (uint8_t) val & 0xff;\n    }\n\n    if (colonp != NULL) {\n        /*\n         * Since some memmove()'s erroneously fail to handle\n         * overlapping regions, we'll do the shift by hand.\n         */\n        const int32_t n = &(result->u8[i++]) - colonp;\n\n        for (int32_t j = 1; j <= n; j++) {\n            result->u8[sizeof(ipv6_addr_t) - j] = colonp[n - j];\n            colonp[n - j] = 0;\n        }\n\n        i = sizeof(ipv6_addr_t);\n    }\n\n    if (i != sizeof(ipv6_addr_t)) {\n        return NULL;\n    }\n\n    return result;\n}",
  "func_after": "ipv6_addr_t *ipv6_addr_from_str(ipv6_addr_t *result, const char *addr)\n{\n    uint8_t *colonp = 0;\n#ifdef MODULE_IPV4_ADDR\n    const char *curtok = addr;\n#endif\n    uint32_t val = 0;\n    char ch;\n    uint8_t saw_xdigit = 0;\n    uint8_t i = 0;\n\n    if ((result == NULL) || (addr == NULL)) {\n        return NULL;\n    }\n\n    ipv6_addr_set_unspecified(result);\n\n    /* Leading :: requires some special handling. */\n    if (*addr == ':') {\n        if (*++addr != ':') {\n            return NULL;\n        }\n    }\n\n    while ((ch = *addr++) != '\\0') {\n        const char *pch;\n        const char *xdigits;\n\n        if ((pch = strchr((xdigits = HEX_L), ch)) == NULL) {\n            pch = strchr((xdigits = HEX_U), ch);\n        }\n\n        if (pch != NULL) {\n            val <<= 4;\n            val |= (pch - xdigits);\n\n            if (val > 0xffff) {\n                return NULL;\n            }\n\n            saw_xdigit = 1;\n            continue;\n        }\n\n        if (ch == ':') {\n#ifdef MODULE_IPV4_ADDR\n            curtok = addr;\n#endif\n\n            if (!saw_xdigit) {\n                if (colonp != NULL) {\n                    return NULL;\n                }\n\n                colonp = &(result->u8[i]);\n                continue;\n            }\n\n            if ((i + sizeof(uint16_t)) > sizeof(ipv6_addr_t)) {\n                return NULL;\n            }\n\n            result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n            result->u8[i++] = (uint8_t) val & 0xff;\n            saw_xdigit = 0;\n            val = 0;\n            continue;\n        }\n\n#ifdef MODULE_IPV4_ADDR\n        if (ch == '.' && ((i + sizeof(ipv4_addr_t)) <= sizeof(ipv6_addr_t)) &&\n            ipv4_addr_from_str((ipv4_addr_t *)(&(result->u8[i])),\n                               curtok) != NULL) {\n            i += sizeof(ipv4_addr_t);\n            saw_xdigit = 0;\n            break;  /* '\\0' was seen by ipv4_addr_from_str(). */\n        }\n#endif\n\n        return NULL;\n    }\n\n    if (saw_xdigit) {\n        if (i + sizeof(uint16_t) > sizeof(ipv6_addr_t)) {\n            return NULL;\n        }\n\n        result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n        result->u8[i++] = (uint8_t) val & 0xff;\n    }\n\n    if (colonp != NULL) {\n        /*\n         * Since some memmove()'s erroneously fail to handle\n         * overlapping regions, we'll do the shift by hand.\n         */\n        const int32_t n = &(result->u8[i++]) - colonp;\n\n        for (int32_t j = 1; j <= n; j++) {\n            result->u8[sizeof(ipv6_addr_t) - j] = colonp[n - j];\n            colonp[n - j] = 0;\n        }\n\n        i = sizeof(ipv6_addr_t);\n    }\n\n    if (i != sizeof(ipv6_addr_t)) {\n        return NULL;\n    }\n\n    return result;\n}",
  "diff_func": "--- func_before\n+++ func_after\n ipv6_addr_t *ipv6_addr_from_str(ipv6_addr_t *result, const char *addr)\n {\n     uint8_t *colonp = 0;\n #ifdef MODULE_IPV4_ADDR\n     const char *curtok = addr;\n #endif\n     uint32_t val = 0;\n     char ch;\n     uint8_t saw_xdigit = 0;\n     uint8_t i = 0;\n \n     if ((result == NULL) || (addr == NULL)) {\n         return NULL;\n     }\n \n     ipv6_addr_set_unspecified(result);\n \n     /* Leading :: requires some special handling. */\n     if (*addr == ':') {\n         if (*++addr != ':') {\n             return NULL;\n         }\n     }\n \n     while ((ch = *addr++) != '\\0') {\n         const char *pch;\n         const char *xdigits;\n \n         if ((pch = strchr((xdigits = HEX_L), ch)) == NULL) {\n             pch = strchr((xdigits = HEX_U), ch);\n         }\n \n         if (pch != NULL) {\n             val <<= 4;\n             val |= (pch - xdigits);\n \n             if (val > 0xffff) {\n                 return NULL;\n             }\n \n             saw_xdigit = 1;\n             continue;\n         }\n \n         if (ch == ':') {\n #ifdef MODULE_IPV4_ADDR\n             curtok = addr;\n #endif\n \n             if (!saw_xdigit) {\n                 if (colonp != NULL) {\n                     return NULL;\n                 }\n \n                 colonp = &(result->u8[i]);\n                 continue;\n             }\n \n-            if (i > sizeof(ipv6_addr_t)) {\n+            if ((i + sizeof(uint16_t)) > sizeof(ipv6_addr_t)) {\n                 return NULL;\n             }\n \n             result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n             result->u8[i++] = (uint8_t) val & 0xff;\n             saw_xdigit = 0;\n             val = 0;\n             continue;\n         }\n \n #ifdef MODULE_IPV4_ADDR\n-        if (ch == '.' && (i <= sizeof(ipv6_addr_t)) &&\n+        if (ch == '.' && ((i + sizeof(ipv4_addr_t)) <= sizeof(ipv6_addr_t)) &&\n             ipv4_addr_from_str((ipv4_addr_t *)(&(result->u8[i])),\n                                curtok) != NULL) {\n             i += sizeof(ipv4_addr_t);\n      ",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses buffer overflow issues in IPv6 address parsing, which could be exploited to cause security vulnerabilities. The changes ensure proper buffer checks, preventing unauthorized code execution.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}