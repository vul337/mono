{
  "id": 4379,
  "language": "C/C++",
  "commit_url": "https://github.com/mapserver/mapserver/commit/e52a436c0e1c5e9f7ef13428dba83194a800f4df",
  "commit_sha": "e52a436c0e1c5e9f7ef13428dba83194a800f4df",
  "commit_msg": "security fix (patch by EvenR)",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "mapogcfiltercommon.c",
  "func_name": "FLTGetIsLikeComparisonCommonExpression",
  "func_before": "char *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n  FEPropertyIsLike* propIsLike;\n\n  int nLength=0, i=0, iTmp=0;\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode || !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = '\\0';\n  sprintf(szTmp, \"%s\", \"(\\\"[\");\n  szTmp[4] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  /* #3521 */\n  if (bCaseInsensitive == 1)\n    sprintf(szTmp, \"%s\", \"]\\\" ~* \\\"\");\n  else\n    sprintf(szTmp, \"%s\", \"]\\\" ~ \\\"\");\n  szTmp[7] = '\\0';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n\n  iTmp =0;\n  if (nLength > 0 && pszValue[0] != pszWild[0] && pszValue[0] != pszSingle[0] && pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= '^';\n    iTmp++;\n  }\n  for (i=0; i<nLength; i++) {\n    if (pszValue[i] != pszWild[0] && pszValue[i] != pszSingle[0] && pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = '.';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = '\\\\';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszWild[0]) {\n      szTmp[iTmp++] = '.';\n      szTmp[iTmp++] = '*';\n      szTmp[iTmp] = '\\0';\n    }\n  }\n  szTmp[iTmp] = '\"';\n  szTmp[++iTmp] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n  return msStrdup(szBuffer);\n}",
  "func_after": "char *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n  FEPropertyIsLike* propIsLike;\n\n  int nLength=0, i=0, iTmp=0;\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode || !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = '\\0';\n  sprintf(szTmp, \"%s\", \"(\\\"[\");\n  szTmp[4] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  /* #3521 */\n  if (bCaseInsensitive == 1)\n    sprintf(szTmp, \"%s\", \"]\\\" ~* \\\"\");\n  else\n    sprintf(szTmp, \"%s\", \"]\\\" ~ \\\"\");\n  szTmp[7] = '\\0';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n  if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )\n      return NULL;\n\n  iTmp =0;\n  if (nLength > 0 && pszValue[0] != pszWild[0] && pszValue[0] != pszSingle[0] && pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= '^';\n    iTmp++;\n  }\n  for (i=0; i<nLength; i++) {\n    if (pszValue[i] != pszWild[0] && pszValue[i] != pszSingle[0] && pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = '.';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = '\\\\';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if (pszValue[i] == pszWild[0]) {\n      szTmp[iTmp++] = '.';\n      szTmp[iTmp++] = '*';\n      szTmp[iTmp] = '\\0';\n    }\n  }\n  szTmp[iTmp] = '\"';\n  szTmp[++iTmp] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n  return msStrdup(szBuffer);\n}",
  "diff_func": "--- func_before\n+++ func_after\n char *FLTGetIsLikeComparisonCommonExpression(FilterEncodingNode *psFilterNode)\n {\n   const size_t bufferSize = 1024;\n   char szBuffer[1024];\n   char szTmp[256];\n   char *pszValue = NULL;\n \n   const char *pszWild = NULL;\n   const char *pszSingle = NULL;\n   const char *pszEscape = NULL;\n   int  bCaseInsensitive = 0;\n   FEPropertyIsLike* propIsLike;\n \n   int nLength=0, i=0, iTmp=0;\n \n   if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode || !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n     return NULL;\n \n   propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n   pszWild = propIsLike->pszWildCard;\n   pszSingle = propIsLike->pszSingleChar;\n   pszEscape = propIsLike->pszEscapeChar;\n   bCaseInsensitive = propIsLike->bCaseInsensitive;\n \n   if (!pszWild || strlen(pszWild) == 0 || !pszSingle || strlen(pszSingle) == 0 || !pszEscape || strlen(pszEscape) == 0)\n     return NULL;\n \n   /* -------------------------------------------------------------------- */\n   /*      Use operand with regular expressions.                           */\n   /* -------------------------------------------------------------------- */\n   szBuffer[0] = '\\0';\n   sprintf(szTmp, \"%s\", \"(\\\"[\");\n   szTmp[4] = '\\0';\n \n   strlcat(szBuffer, szTmp, bufferSize);\n \n   /* attribute */\n   strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n   szBuffer[strlen(szBuffer)] = '\\0';\n \n   /* #3521 */\n   if (bCaseInsensitive == 1)\n     sprintf(szTmp, \"%s\", \"]\\\" ~* \\\"\");\n   else\n     sprintf(szTmp, \"%s\", \"]\\\" ~ \\\"\");\n   szTmp[7] = '\\0';\n   strlcat(szBuffer, szTmp, bufferSize);\n   szBuffer[strlen(szBuffer)] = '\\0';\n \n   pszValue = psFilterNode->psRightNode->pszValue;\n   nLength = strlen(pszValue);\n+  if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )\n+      return NULL;\n \n   iTmp =0;\n   if (nLength > 0 && pszValue[0] != pszWild[0] && pszValue[0] != pszSingle[0] && pszValue[0] != pszEscape[0]) {\n     szTmp[iTmp]= '^';\n     iTmp++;\n   }\n   for",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch adds a bounds check to prevent a buffer overflow in a function handling comparison operations, which is a security vulnerability. The commit message explicitly states it's a security fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}