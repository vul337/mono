{
  "id": 2640,
  "language": "Java",
  "commit_url": "https://github.com/GrapheneOS/platform_frameworks_base/commit/414644a2f7b56160dfc37ae823d70dec98d95796",
  "commit_sha": "414644a2f7b56160dfc37ae823d70dec98d95796",
  "commit_msg": "AudioService: validate uid / package name match\n\nWhen checking app ops, check for exceptions that indicate uid\nand package name mismatch.\nThis affects the code paths for methods:\n- adjustStreamVolume\n- setStreamVolume\n- setMicrophoneMute\n- setMasterMute\n\nBug: 194110891 194110526\nTest: see bug exploit app, verify real/bogus package shows uninstalled\nChange-Id: Ice7a84993c68e7ec736fdf0b9fd5b8171b37b725\nMerged-In: Ice7a84993c68e7ec736fdf0b9fd5b8171b37b725\n(cherry picked from commit e0141e5be0337b6eea75ef75076ac69e8bfddc6a)",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/audio/AudioService.java",
  "func_name": "adjustStreamVolume",
  "func_before": "protected void adjustStreamVolume(int streamType, int direction, int flags,\n            String callingPackage, String caller, int uid, boolean hasModifyAudioSettings,\n            int keyEventMode) {\n        if (mUseFixedVolume) {\n            return;\n        }\n        if (DEBUG_VOL) Log.d(TAG, \"adjustStreamVolume() stream=\" + streamType + \", dir=\" + direction\n                + \", flags=\" + flags + \", caller=\" + caller);\n\n        ensureValidDirection(direction);\n        ensureValidStreamType(streamType);\n\n        boolean isMuteAdjust = isMuteAdjust(direction);\n\n        if (isMuteAdjust && !isStreamAffectedByMute(streamType)) {\n            return;\n        }\n\n        // If adjust is mute and the stream is STREAM_VOICE_CALL or STREAM_BLUETOOTH_SCO, make sure\n        // that the calling app have the MODIFY_PHONE_STATE permission.\n        if (isMuteAdjust &&\n            (streamType == AudioSystem.STREAM_VOICE_CALL ||\n                streamType == AudioSystem.STREAM_BLUETOOTH_SCO) &&\n            mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.MODIFY_PHONE_STATE)\n                    != PackageManager.PERMISSION_GRANTED) {\n            Log.w(TAG, \"MODIFY_PHONE_STATE Permission Denial: adjustStreamVolume from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid());\n            return;\n        }\n\n        // If the stream is STREAM_ASSISTANT,\n        // make sure that the calling app have the MODIFY_AUDIO_ROUTING permission.\n        if (streamType == AudioSystem.STREAM_ASSISTANT &&\n            mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.MODIFY_AUDIO_ROUTING)\n                    != PackageManager.PERMISSION_GRANTED) {\n            Log.w(TAG, \"MODIFY_AUDIO_ROUTING Permission Denial: adjustStreamVolume from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid());\n            return;\n        }\n\n        // use stream type alias here so that streams with same alias have the same behavior,\n        // including with regard to silent mode control (e.g the use of STREAM_RING below and in\n        // checkForRingerModeChange() in place of STREAM_RING or STREAM_NOTIFICATION)\n        int streamTypeAlias = mStreamVolumeAlias[streamType];\n\n        VolumeStreamState streamState = mStreamStates[streamTypeAlias];\n\n        final int device = getDeviceForStream(streamTypeAlias);\n\n        int aliasIndex = streamState.getIndex(device);\n        boolean adjustVolume = true;\n        int step;\n\n        // skip a2dp absolute volume control request when the device\n        // is not an a2dp device\n        if (!AudioSystem.DEVICE_OUT_ALL_A2DP_SET.contains(device)\n                && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {\n            return;\n        }\n\n        // If we are being called by the system (e.g. hardware keys) check for current user\n        // so we handle user restrictions correctly.\n        if (uid == android.os.Process.SYSTEM_UID) {\n            uid = UserHandle.getUid(getCurrentUserId(), UserHandle.getAppId(uid));\n        }\n        if (mAppOps.noteOp(STREAM_VOLUME_OPS[streamTypeAlias], uid, callingPackage)\n                != AppOpsManager.MODE_ALLOWED) {\n            return;\n        }\n\n        // reset any pending volume command\n        synchronized (mSafeMediaVolumeStateLock) {\n            mPendingVolumeCommand = null;\n        }\n\n        flags &= ~AudioManager.FLAG_FIXED_VOLUME;\n        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && isFixedVolumeDevice(device)) {\n            flags |= AudioManager.FLAG_FIXED_VOLUME;\n\n            // Always toggle between max safe volume and 0 for fixed volume devices where safe\n            // volume is enforced, and max and 0 for the others.\n            // This is simulated by stepping by the full allowed volume range\n            if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE &&\n                    mSafeMediaVolumeDevices.contains(device)) {\n                step = safeMediaVolumeIndex(device);\n            } else {\n                step = streamState.getMaxIndex();\n            }\n            if (aliasIndex != 0) {\n                aliasIndex = step;\n            }\n        } else {\n            // convert one UI step (+/-1) into a number of internal units on the stream alias\n            step = rescaleStep(10, streamType, streamTypeAlias);\n        }\n\n        // If either the client forces allowing ringer modes for this adjustment,\n        // or the stream type is one that is affected by ringer modes\n        if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) ||\n                (isUiSoundsStreamType(streamTypeAlias))) {\n            int ringerMode = getRingerModeInternal();\n            // do not vibrate if already in vibrate mode\n            if (ringerMode == AudioManager.RINGER_MODE_VIBRATE) {\n                flags &= ~AudioManager.FLAG_VIBRATE;\n            }\n            // Check if the ringer mode handles this adjustment. If it does we don't\n            // need to adjust the volume further.\n            final int result = checkForRingerModeChange(aliasIndex, direction, step,\n                    streamState.mIsMuted, callingPackage, flags);\n            adjustVolume = (result & FLAG_ADJUST_VOLUME) != 0;\n            // If suppressing a volume adjustment in silent mode, display the UI hint\n            if ((result & AudioManager.FLAG_SHOW_SILENT_HINT) != 0) {\n                flags |= AudioManager.FLAG_SHOW_SILENT_HINT;\n            }\n            // If suppressing a volume down adjustment in vibrate mode, display the UI hint\n            if ((result & AudioManager.FLAG_SHOW_VIBRATE_HINT) != 0) {\n                flags |= AudioManager.FLAG_SHOW_VIBRATE_HINT;\n            }\n        }\n\n        // If the ringer mode or zen is muting the stream, do not change stream unless\n        // it'll cause us to exit dnd\n        if (!volumeAdjustmentAllowedByDnd(streamTypeAlias, flags)) {\n            adjustVolume = false;\n        }\n        int oldIndex = mStreamStates[streamType].getIndex(device);\n\n        if (adjustVolume\n                && (direction != AudioManager.ADJUST_SAME) && (keyEventMode != VOL_ADJUST_END)) {\n            mAudioHandler.removeMessages(MSG_UNMUTE_STREAM);\n\n            if (isMuteAdjust && !mFullVolumeDevices.contains(device)) {\n                boolean state;\n                if (direction == AudioManager.ADJUST_TOGGLE_MUTE) {\n                    state = !streamState.mIsMuted;\n                } else {\n                    state = direction == AudioManager.ADJUST_MUTE;\n                }\n                if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {\n                    setSystemAudioMute(state);\n                }\n                for (int stream = 0; stream < mStreamStates.length; stream++) {\n                    if (streamTypeAlias == mStreamVolumeAlias[stream]) {\n                        if (!(readCameraSoundForced()\n                                    && (mStreamStates[stream].getStreamType()\n                                        == AudioSystem.STREAM_SYSTEM_ENFORCED))) {\n                            mStreamStates[stream].mute(state);\n                        }\n                    }\n                }\n            } else if ((direction == AudioManager.ADJUST_RAISE) &&\n                    !checkSafeMediaVolume(streamTypeAlias, aliasIndex + step, device)) {\n                Log.e(TAG, \"adjustStreamVolume() safe volume index = \" + oldIndex);\n                mVolumeController.postDisplaySafeVolumeWarning(flags);\n            } else if (!isFullVolumeDevice(device)\n                    && (streamState.adjustIndex(direction * step, device, caller,\n                            hasModifyAudioSettings)\n                            || streamState.mIsMuted)) {\n                // Post message to set system volume (it in turn will post a\n                // message to persist).\n                if (streamState.mIsMuted) {\n                    // Unmute the stream if it was previously muted\n                    if (direction == AudioManager.ADJUST_RAISE) {\n                        // unmute immediately for volume up\n                        streamState.mute(false);\n                    } else if (direction == AudioManager.ADJUST_LOWER) {\n                        if (mIsSingleVolume) {\n                            sendMsg(mAudioHandler, MSG_UNMUTE_STREAM, SENDMSG_QUEUE,\n                                    streamTypeAlias, flags, null, UNMUTE_STREAM_DELAY);\n                        }\n                    }\n                }\n                sendMsg(mAudioHandler,\n                        MSG_SET_DEVICE_VOLUME,\n                        SENDMSG_QUEUE,\n                        device,\n                        0,\n                        streamState,\n                        0);\n            }\n\n            int newIndex = mStreamStates[streamType].getIndex(device);\n\n            // Check if volume update should be send to AVRCP\n            if (streamTypeAlias == AudioSystem.STREAM_MUSIC\n                    && AudioSystem.DEVICE_OUT_ALL_A2DP_SET.contains(device)\n                    && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {\n                if (DEBUG_VOL) {\n                    Log.d(TAG, \"adjustSreamVolume: postSetAvrcpAbsoluteVolumeIndex index=\"\n                            + newIndex + \"stream=\" + streamType);\n                }\n                mDeviceBroker.postSetAvrcpAbsoluteVolumeIndex(newIndex / 10);\n            }\n\n            // Check if volume update should be send to Hearing Aid\n            if (device == AudioSystem.DEVICE_OUT_HEARING_AID) {\n                // only modify the hearing aid attenuation when the stream to modify matches\n                // the one expected by the hearing aid\n                if (streamType == getHearingAidStreamType()) {\n                    if (DEBUG_VOL) {\n                        Log.d(TAG, \"adjustSreamVolume postSetHearingAidVolumeIndex index=\"\n                                + newIndex + \" stream=\" + streamType);\n                    }\n                    mDeviceBroker.postSetHearingAidVolumeIndex(newIndex, streamType);\n                }\n            }\n\n            // Check if volume update should be sent to Hdmi system audio.\n            if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {\n                setSystemAudioVolume(oldIndex, newIndex, getStreamMaxVolume(streamType), flags);\n            }\n        }\n\n        final int newIndex = mStreamStates[streamType].getIndex(device);\n\n        if (adjustVolume) {\n            synchronized (mHdmiClientLock) {\n                if (mHdmiManager != null) {\n                    if (mHdmiPlaybackClient != null\n                            && mHdmiCecVolumeControlEnabled\n                            && streamTypeAlias == AudioSystem.STREAM_MUSIC\n                            // vol change on a full volume device\n                            && isFullVolumeDevice(device)) {\n                        int keyCode = KeyEvent.KEYCODE_UNKNOWN;\n                        switch (direction) {\n                            case AudioManager.ADJUST_RAISE:\n                                keyCode = KeyEvent.KEYCODE_VOLUME_UP;\n                                break;\n                            case AudioManager.ADJUST_LOWER:\n                                keyCode = KeyEvent.KEYCODE_VOLUME_DOWN;\n                                break;\n                            case AudioManager.ADJUST_TOGGLE_MUTE:\n                                keyCode = KeyEvent.KEYCODE_VOLUME_MUTE;\n                                break;\n                            default:\n                                break;\n                        }\n                        if (keyCode != KeyEvent.KEYCODE_UNKNOWN) {\n                            final long ident = Binder.clearCallingIdentity();\n                            try {\n                                final long time = java.lang.System.currentTimeMillis();\n                                switch (keyEventMode) {\n                                    case VOL_ADJUST_NORMAL:\n                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);\n                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);\n                                        break;\n                                    case VOL_ADJUST_START:\n                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);\n                                        break;\n                                    case VOL_ADJUST_END:\n                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);\n                                        break;\n                                    default:\n                                        Log.e(TAG, \"Invalid keyEventMode \" + keyEventMode);\n                                }\n                            } finally {\n                                Binder.restoreCallingIdentity(ident);\n                            }\n                        }\n                    }\n\n                    if (streamTypeAlias == AudioSystem.STREAM_MUSIC\n                            && (oldIndex != newIndex || isMuteAdjust)) {\n                        maybeSendSystemAudioStatusCommand(isMuteAdjust);\n                    }\n                }\n            }\n        }\n        sendVolumeUpdate(streamType, oldIndex, newIndex, flags, device);\n    }",
  "func_after": "protected void adjustStreamVolume(int streamType, int direction, int flags,\n            String callingPackage, String caller, int uid, boolean hasModifyAudioSettings,\n            int keyEventMode) {\n        if (mUseFixedVolume) {\n            return;\n        }\n        if (DEBUG_VOL) Log.d(TAG, \"adjustStreamVolume() stream=\" + streamType + \", dir=\" + direction\n                + \", flags=\" + flags + \", caller=\" + caller);\n\n        ensureValidDirection(direction);\n        ensureValidStreamType(streamType);\n\n        boolean isMuteAdjust = isMuteAdjust(direction);\n\n        if (isMuteAdjust && !isStreamAffectedByMute(streamType)) {\n            return;\n        }\n\n        // If adjust is mute and the stream is STREAM_VOICE_CALL or STREAM_BLUETOOTH_SCO, make sure\n        // that the calling app have the MODIFY_PHONE_STATE permission.\n        if (isMuteAdjust &&\n            (streamType == AudioSystem.STREAM_VOICE_CALL ||\n                streamType == AudioSystem.STREAM_BLUETOOTH_SCO) &&\n            mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.MODIFY_PHONE_STATE)\n                    != PackageManager.PERMISSION_GRANTED) {\n            Log.w(TAG, \"MODIFY_PHONE_STATE Permission Denial: adjustStreamVolume from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid());\n            return;\n        }\n\n        // If the stream is STREAM_ASSISTANT,\n        // make sure that the calling app have the MODIFY_AUDIO_ROUTING permission.\n        if (streamType == AudioSystem.STREAM_ASSISTANT &&\n            mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.MODIFY_AUDIO_ROUTING)\n                    != PackageManager.PERMISSION_GRANTED) {\n            Log.w(TAG, \"MODIFY_AUDIO_ROUTING Permission Denial: adjustStreamVolume from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid());\n            return;\n        }\n\n        // use stream type alias here so that streams with same alias have the same behavior,\n        // including with regard to silent mode control (e.g the use of STREAM_RING below and in\n        // checkForRingerModeChange() in place of STREAM_RING or STREAM_NOTIFICATION)\n        int streamTypeAlias = mStreamVolumeAlias[streamType];\n\n        VolumeStreamState streamState = mStreamStates[streamTypeAlias];\n\n        final int device = getDeviceForStream(streamTypeAlias);\n\n        int aliasIndex = streamState.getIndex(device);\n        boolean adjustVolume = true;\n        int step;\n\n        // skip a2dp absolute volume control request when the device\n        // is not an a2dp device\n        if (!AudioSystem.DEVICE_OUT_ALL_A2DP_SET.contains(device)\n                && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {\n            return;\n        }\n\n        // If we are being called by the system (e.g. hardware keys) check for current user\n        // so we handle user restrictions correctly.\n        if (uid == android.os.Process.SYSTEM_UID) {\n            uid = UserHandle.getUid(getCurrentUserId(), UserHandle.getAppId(uid));\n        }\n        // validate calling package and app op\n        if (!checkNoteAppOp(STREAM_VOLUME_OPS[streamTypeAlias], uid, callingPackage)) {\n            return;\n        }\n\n        // reset any pending volume command\n        synchronized (mSafeMediaVolumeStateLock) {\n            mPendingVolumeCommand = null;\n        }\n\n        flags &= ~AudioManager.FLAG_FIXED_VOLUME;\n        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && isFixedVolumeDevice(device)) {\n            flags |= AudioManager.FLAG_FIXED_VOLUME;\n\n            // Always toggle between max safe volume and 0 for fixed volume devices where safe\n            // volume is enforced, and max and 0 for the others.\n            // This is simulated by stepping by the full allowed volume range\n            if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE &&\n                    mSafeMediaVolumeDevices.contains(device)) {\n                step = safeMediaVolumeIndex(device);\n            } else {\n                step = streamState.getMaxIndex();\n            }\n            if (aliasIndex != 0) {\n                aliasIndex = step;\n            }\n        } else {\n            // convert one UI step (+/-1) into a number of internal units on the stream alias\n            step = rescaleStep(10, streamType, streamTypeAlias);\n        }\n\n        // If either the client forces allowing ringer modes for this adjustment,\n        // or the stream type is one that is affected by ringer modes\n        if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) ||\n                (isUiSoundsStreamType(streamTypeAlias))) {\n            int ringerMode = getRingerModeInternal();\n            // do not vibrate if already in vibrate mode\n            if (ringerMode == AudioManager.RINGER_MODE_VIBRATE) {\n                flags &= ~AudioManager.FLAG_VIBRATE;\n            }\n            // Check if the ringer mode handles this adjustment. If it does we don't\n            // need to adjust the volume further.\n            final int result = checkForRingerModeChange(aliasIndex, direction, step,\n                    streamState.mIsMuted, callingPackage, flags);\n            adjustVolume = (result & FLAG_ADJUST_VOLUME) != 0;\n            // If suppressing a volume adjustment in silent mode, display the UI hint\n            if ((result & AudioManager.FLAG_SHOW_SILENT_HINT) != 0) {\n                flags |= AudioManager.FLAG_SHOW_SILENT_HINT;\n            }\n            // If suppressing a volume down adjustment in vibrate mode, display the UI hint\n            if ((result & AudioManager.FLAG_SHOW_VIBRATE_HINT) != 0) {\n                flags |= AudioManager.FLAG_SHOW_VIBRATE_HINT;\n            }\n        }\n\n        // If the ringer mode or zen is muting the stream, do not change stream unless\n        // it'll cause us to exit dnd\n        if (!volumeAdjustmentAllowedByDnd(streamTypeAlias, flags)) {\n            adjustVolume = false;\n        }\n        int oldIndex = mStreamStates[streamType].getIndex(device);\n\n        if (adjustVolume\n                && (direction != AudioManager.ADJUST_SAME) && (keyEventMode != VOL_ADJUST_END)) {\n            mAudioHandler.removeMessages(MSG_UNMUTE_STREAM);\n\n            if (isMuteAdjust && !mFullVolumeDevices.contains(device)) {\n                boolean state;\n                if (direction == AudioManager.ADJUST_TOGGLE_MUTE) {\n                    state = !streamState.mIsMuted;\n                } else {\n                    state = direction == AudioManager.ADJUST_MUTE;\n                }\n                if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {\n                    setSystemAudioMute(state);\n                }\n                for (int stream = 0; stream < mStreamStates.length; stream++) {\n                    if (streamTypeAlias == mStreamVolumeAlias[stream]) {\n                        if (!(readCameraSoundForced()\n                                    && (mStreamStates[stream].getStreamType()\n                                        == AudioSystem.STREAM_SYSTEM_ENFORCED))) {\n                            mStreamStates[stream].mute(state);\n                        }\n                    }\n                }\n            } else if ((direction == AudioManager.ADJUST_RAISE) &&\n                    !checkSafeMediaVolume(streamTypeAlias, aliasIndex + step, device)) {\n                Log.e(TAG, \"adjustStreamVolume() safe volume index = \" + oldIndex);\n                mVolumeController.postDisplaySafeVolumeWarning(flags);\n            } else if (!isFullVolumeDevice(device)\n                    && (streamState.adjustIndex(direction * step, device, caller,\n                            hasModifyAudioSettings)\n                            || streamState.mIsMuted)) {\n                // Post message to set system volume (it in turn will post a\n                // message to persist).\n                if (streamState.mIsMuted) {\n                    // Unmute the stream if it was previously muted\n                    if (direction == AudioManager.ADJUST_RAISE) {\n                        // unmute immediately for volume up\n                        streamState.mute(false);\n                    } else if (direction == AudioManager.ADJUST_LOWER) {\n                        if (mIsSingleVolume) {\n                            sendMsg(mAudioHandler, MSG_UNMUTE_STREAM, SENDMSG_QUEUE,\n                                    streamTypeAlias, flags, null, UNMUTE_STREAM_DELAY);\n                        }\n                    }\n                }\n                sendMsg(mAudioHandler,\n                        MSG_SET_DEVICE_VOLUME,\n                        SENDMSG_QUEUE,\n                        device,\n                        0,\n                        streamState,\n                        0);\n            }\n\n            int newIndex = mStreamStates[streamType].getIndex(device);\n\n            // Check if volume update should be send to AVRCP\n            if (streamTypeAlias == AudioSystem.STREAM_MUSIC\n                    && AudioSystem.DEVICE_OUT_ALL_A2DP_SET.contains(device)\n                    && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {\n                if (DEBUG_VOL) {\n                    Log.d(TAG, \"adjustSreamVolume: postSetAvrcpAbsoluteVolumeIndex index=\"\n                            + newIndex + \"stream=\" + streamType);\n                }\n                mDeviceBroker.postSetAvrcpAbsoluteVolumeIndex(newIndex / 10);\n            }\n\n            // Check if volume update should be send to Hearing Aid\n            if (device == AudioSystem.DEVICE_OUT_HEARING_AID) {\n                // only modify the hearing aid attenuation when the stream to modify matches\n                // the one expected by the hearing aid\n                if (streamType == getHearingAidStreamType()) {\n                    if (DEBUG_VOL) {\n                        Log.d(TAG, \"adjustSreamVolume postSetHearingAidVolumeIndex index=\"\n                                + newIndex + \" stream=\" + streamType);\n                    }\n                    mDeviceBroker.postSetHearingAidVolumeIndex(newIndex, streamType);\n                }\n            }\n\n            // Check if volume update should be sent to Hdmi system audio.\n            if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {\n                setSystemAudioVolume(oldIndex, newIndex, getStreamMaxVolume(streamType), flags);\n            }\n        }\n\n        final int newIndex = mStreamStates[streamType].getIndex(device);\n\n        if (adjustVolume) {\n            synchronized (mHdmiClientLock) {\n                if (mHdmiManager != null) {\n                    if (mHdmiPlaybackClient != null\n                            && mHdmiCecVolumeControlEnabled\n                            && streamTypeAlias == AudioSystem.STREAM_MUSIC\n                            // vol change on a full volume device\n                            && isFullVolumeDevice(device)) {\n                        int keyCode = KeyEvent.KEYCODE_UNKNOWN;\n                        switch (direction) {\n                            case AudioManager.ADJUST_RAISE:\n                                keyCode = KeyEvent.KEYCODE_VOLUME_UP;\n                                break;\n                            case AudioManager.ADJUST_LOWER:\n                                keyCode = KeyEvent.KEYCODE_VOLUME_DOWN;\n                                break;\n                            case AudioManager.ADJUST_TOGGLE_MUTE:\n                                keyCode = KeyEvent.KEYCODE_VOLUME_MUTE;\n                                break;\n                            default:\n                                break;\n                        }\n                        if (keyCode != KeyEvent.KEYCODE_UNKNOWN) {\n                            final long ident = Binder.clearCallingIdentity();\n                            try {\n                                final long time = java.lang.System.currentTimeMillis();\n                                switch (keyEventMode) {\n                                    case VOL_ADJUST_NORMAL:\n                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);\n                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);\n                                        break;\n                                    case VOL_ADJUST_START:\n                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, true);\n                                        break;\n                                    case VOL_ADJUST_END:\n                                        mHdmiPlaybackClient.sendVolumeKeyEvent(keyCode, false);\n                                        break;\n                                    default:\n                                        Log.e(TAG, \"Invalid keyEventMode \" + keyEventMode);\n                                }\n                            } finally {\n                                Binder.restoreCallingIdentity(ident);\n                            }\n                        }\n                    }\n\n                    if (streamTypeAlias == AudioSystem.STREAM_MUSIC\n                            && (oldIndex != newIndex || isMuteAdjust)) {\n                        maybeSendSystemAudioStatusCommand(isMuteAdjust);\n                    }\n                }\n            }\n        }\n        sendVolumeUpdate(streamType, oldIndex, newIndex, flags, device);\n    }",
  "diff_func": "--- func_before\n+++ func_after\n protected void adjustStreamVolume(int streamType, int direction, int flags,\n             String callingPackage, String caller, int uid, boolean hasModifyAudioSettings,\n             int keyEventMode) {\n         if (mUseFixedVolume) {\n             return;\n         }\n         if (DEBUG_VOL) Log.d(TAG, \"adjustStreamVolume() stream=\" + streamType + \", dir=\" + direction\n                 + \", flags=\" + flags + \", caller=\" + caller);\n \n         ensureValidDirection(direction);\n         ensureValidStreamType(streamType);\n \n         boolean isMuteAdjust = isMuteAdjust(direction);\n \n         if (isMuteAdjust && !isStreamAffectedByMute(streamType)) {\n             return;\n         }\n \n         // If adjust is mute and the stream is STREAM_VOICE_CALL or STREAM_BLUETOOTH_SCO, make sure\n         // that the calling app have the MODIFY_PHONE_STATE permission.\n         if (isMuteAdjust &&\n             (streamType == AudioSystem.STREAM_VOICE_CALL ||\n                 streamType == AudioSystem.STREAM_BLUETOOTH_SCO) &&\n             mContext.checkCallingOrSelfPermission(\n                 android.Manifest.permission.MODIFY_PHONE_STATE)\n                     != PackageManager.PERMISSION_GRANTED) {\n             Log.w(TAG, \"MODIFY_PHONE_STATE Permission Denial: adjustStreamVolume from pid=\"\n                     + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid());\n             return;\n         }\n \n         // If the stream is STREAM_ASSISTANT,\n         // make sure that the calling app have the MODIFY_AUDIO_ROUTING permission.\n         if (streamType == AudioSystem.STREAM_ASSISTANT &&\n             mContext.checkCallingOrSelfPermission(\n                 android.Manifest.permission.MODIFY_AUDIO_ROUTING)\n                     != PackageManager.PERMISSION_GRANTED) {\n             Log.w(TAG, \"MODIFY_AUDIO_ROUTING Permission Denial: adjustStreamVolume from pid=\"\n                     + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid());\n             ret",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.9",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by ensuring that the uid and package name match, preventing unauthorized access. This fix mitigates potential exploitation, hence it's classified as a Security Vulnerability Fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.9"
}