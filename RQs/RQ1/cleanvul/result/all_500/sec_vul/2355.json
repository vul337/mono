{
  "id": 2355,
  "language": "Java",
  "commit_url": "https://github.com/MuntashirAkon/AppManager/commit/200454d82c0771782628fa59eb48a1cd7bbed5d1",
  "commit_sha": "200454d82c0771782628fa59eb48a1cd7bbed5d1",
  "commit_msg": "[tar] Skip creating directory affected by zip slip attack",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "app/src/main/java/io/github/muntashirakon/AppManager/utils/TarUtils.java",
  "func_name": "extract",
  "func_before": "@WorkerThread\n    public static void extract(@NonNull @TarType String type, @NonNull File[] sources, @NonNull File dest,\n                                  @Nullable String[] filters, @Nullable String[] exclude)\n            throws IOException, RemoteException {\n        try (SplitInputStream sis = new SplitInputStream(sources);\n             BufferedInputStream bis = new BufferedInputStream(sis)) {\n            InputStream is;\n            if (TAR_GZIP.equals(type)) {\n                is = new GzipCompressorInputStream(bis);\n            } else if (TAR_BZIP2.equals(type)) {\n                is = new BZip2CompressorInputStream(bis);\n            } else {\n                throw new IllegalArgumentException(\"Invalid compression type: \" + type);\n            }\n            try (TarArchiveInputStream tis = new TarArchiveInputStream(is)) {\n                String realDestPath = dest.getCanonicalFile().toURI().getPath();\n                TarArchiveEntry entry;\n                while ((entry = tis.getNextEntry()) != null) {\n                    File file = new ProxyFile(dest, entry.getName());\n                    if (!entry.isDirectory() && (!isUnderFilter(file, dest, filters) || willExclude(file, dest, exclude))) {\n                        // Unlike create, there's no efficient way to detect if a directory contains any filters.\n                        // Therefore, directory can't be filtered during extraction\n                        continue;\n                    }\n                    // Zip slip vulnerability check\n                    if (!file.getCanonicalFile().toURI().getPath().startsWith(realDestPath)) {\n                        if (file.isDirectory()) {\n                            Log.w(\"TarUtils\", \"Zip slip vulnerability detected!\" +\n                                    \" Skipping since it's a directory.\" +\n                                    \"\\nExpected dest: \" + new File(realDestPath, entry.getName()) +\n                                    \"\\nActual path: \" + file.getCanonicalFile().toURI().getPath());\n                        } else {\n                            throw new IOException(\"Zip slip vulnerability detected!\" +\n                                    \"\\nExpected dest: \" + new File(realDestPath, entry.getName()) +\n                                    \"\\nActual path: \" + file.getCanonicalFile().toURI().getPath());\n                        }\n                    }\n                    if (entry.isDirectory()) {\n                        file.mkdir();\n                    } else {\n                        try (OutputStream os = new ProxyOutputStream(file)) {\n                            IOUtils.copy(tis, os);\n                        }\n                    }\n                    // Fix permissions\n                    ProxyFiles.chmod(file, entry.getMode());\n                    ProxyFiles.chown(file, entry.getUserId(), entry.getGroupId());\n                }\n                // Delete unwanted files\n                validateFiles(dest, dest, filters, exclude);\n            } catch (ErrnoException | RemoteException e) {\n                throw new IOException(e);\n            } finally {\n                is.close();\n            }\n        }\n    }",
  "func_after": "@WorkerThread\n    public static void extract(@NonNull @TarType String type, @NonNull File[] sources, @NonNull File dest,\n                                  @Nullable String[] filters, @Nullable String[] exclude)\n            throws IOException, RemoteException {\n        try (SplitInputStream sis = new SplitInputStream(sources);\n             BufferedInputStream bis = new BufferedInputStream(sis)) {\n            InputStream is;\n            if (TAR_GZIP.equals(type)) {\n                is = new GzipCompressorInputStream(bis);\n            } else if (TAR_BZIP2.equals(type)) {\n                is = new BZip2CompressorInputStream(bis);\n            } else {\n                throw new IllegalArgumentException(\"Invalid compression type: \" + type);\n            }\n            try (TarArchiveInputStream tis = new TarArchiveInputStream(is)) {\n                String realDestPath = dest.getCanonicalFile().toURI().getPath();\n                TarArchiveEntry entry;\n                while ((entry = tis.getNextEntry()) != null) {\n                    File file = new ProxyFile(dest, entry.getName());\n                    if (!entry.isDirectory() && (!isUnderFilter(file, dest, filters) || willExclude(file, dest, exclude))) {\n                        // Unlike create, there's no efficient way to detect if a directory contains any filters.\n                        // Therefore, directory can't be filtered during extraction\n                        continue;\n                    }\n                    // Zip slip vulnerability check\n                    if (!file.getCanonicalFile().toURI().getPath().startsWith(realDestPath)) {\n                        if (file.isDirectory()) {\n                            Log.w(\"TarUtils\", \"Zip slip vulnerability detected!\" +\n                                    \" Skipping since it's a directory.\" +\n                                    \"\\nExpected dest: \" + new File(realDestPath, entry.getName()) +\n                                    \"\\nActual path: \" + file.getCanonicalFile().toURI().getPath());\n                            continue;\n                        } else {\n                            throw new IOException(\"Zip slip vulnerability detected!\" +\n                                    \"\\nExpected dest: \" + new File(realDestPath, entry.getName()) +\n                                    \"\\nActual path: \" + file.getCanonicalFile().toURI().getPath());\n                        }\n                    }\n                    if (entry.isDirectory()) {\n                        file.mkdir();\n                    } else {\n                        try (OutputStream os = new ProxyOutputStream(file)) {\n                            IOUtils.copy(tis, os);\n                        }\n                    }\n                    // Fix permissions\n                    ProxyFiles.chmod(file, entry.getMode());\n                    ProxyFiles.chown(file, entry.getUserId(), entry.getGroupId());\n                }\n                // Delete unwanted files\n                validateFiles(dest, dest, filters, exclude);\n            } catch (ErrnoException | RemoteException e) {\n                throw new IOException(e);\n            } finally {\n                is.close();\n            }\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @WorkerThread\n     public static void extract(@NonNull @TarType String type, @NonNull File[] sources, @NonNull File dest,\n                                   @Nullable String[] filters, @Nullable String[] exclude)\n             throws IOException, RemoteException {\n         try (SplitInputStream sis = new SplitInputStream(sources);\n              BufferedInputStream bis = new BufferedInputStream(sis)) {\n             InputStream is;\n             if (TAR_GZIP.equals(type)) {\n                 is = new GzipCompressorInputStream(bis);\n             } else if (TAR_BZIP2.equals(type)) {\n                 is = new BZip2CompressorInputStream(bis);\n             } else {\n                 throw new IllegalArgumentException(\"Invalid compression type: \" + type);\n             }\n             try (TarArchiveInputStream tis = new TarArchiveInputStream(is)) {\n                 String realDestPath = dest.getCanonicalFile().toURI().getPath();\n                 TarArchiveEntry entry;\n                 while ((entry = tis.getNextEntry()) != null) {\n                     File file = new ProxyFile(dest, entry.getName());\n                     if (!entry.isDirectory() && (!isUnderFilter(file, dest, filters) || willExclude(file, dest, exclude))) {\n                         // Unlike create, there's no efficient way to detect if a directory contains any filters.\n                         // Therefore, directory can't be filtered during extraction\n                         continue;\n                     }\n                     // Zip slip vulnerability check\n                     if (!file.getCanonicalFile().toURI().getPath().startsWith(realDestPath)) {\n                         if (file.isDirectory()) {\n                             Log.w(\"TarUtils\", \"Zip slip vulnerability detected!\" +\n                                     \" Skipping since it's a directory.\" +\n                                     \"\\nExpected dest: \" + new File(realDestPath, entry.getName()) +\n                   ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The commit addresses a zip slip vulnerability by adding a check to prevent directory traversal attacks during extraction. This directly mitigates a security risk.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}