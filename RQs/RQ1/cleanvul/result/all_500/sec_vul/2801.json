{
  "id": 2801,
  "language": "Java",
  "commit_url": "https://github.com/Netflix/metacat/commit/b439760c9cd9fc615f4d77dc60a9459312e78c9e",
  "commit_sha": "b439760c9cd9fc615f4d77dc60a9459312e78c9e",
  "commit_msg": "Fix Sql Vulnerability in Tag service (#426)",
  "pr_url": "https://github.com/Netflix/metacat/pull/426",
  "pr_info": "- Parametrize the IN clause",
  "file_name": "metacat-metadata-mysql/src/main/java/com/netflix/metacat/metadata/mysql/MySqlTagService.java",
  "func_name": "Transactional",
  "func_before": "@Override\n    @Transactional(readOnly = true)\n    public List<QualifiedName> list(\n        @Nullable final Set<String> includeTags,\n        @Nullable final Set<String> excludeTags,\n        @Nullable final String sourceName,\n        @Nullable final String databaseName,\n        @Nullable final String tableName,\n        @Nullable final QualifiedName.Type type\n    ) {\n        Set<String> includedNames = Sets.newHashSet();\n        final Set<String> excludedNames = Sets.newHashSet();\n        final String wildCardName =\n            QualifiedName.qualifiedNameToWildCardQueryString(sourceName, databaseName, tableName);\n        //Includes\n        final Set<String> localIncludes = includeTags != null ? includeTags : Sets.newHashSet();\n        try {\n            StringBuilder query = new StringBuilder(\n                String.format(QUERY_LIST, \"in ('\" + Joiner.on(\"','\").skipNulls().join(localIncludes) + \"')\"\n                ));\n            final Object[] params = {\n                localIncludes.size() == 0 ? 1 : 0,\n                wildCardName == null ? 1 : 0,\n                wildCardName,\n                type == null ? 1 : 0,\n                type == null ? \".*\" : type.getRegexValue(),\n            };\n            includedNames.addAll(jdbcTemplate.query(query.toString(),\n                params,\n                new int[]{Types.INTEGER,\n                    Types.INTEGER,\n                    Types.VARCHAR,\n                    Types.INTEGER,\n                    Types.VARCHAR,\n                },\n                (rs, rowNum) -> rs.getString(\"name\")));\n            if (excludeTags != null && !excludeTags.isEmpty()) {\n                //Excludes\n                query = new StringBuilder(\n                    String.format(QUERY_LIST, \"in ('\" + Joiner.on(\"','\").skipNulls().join(excludeTags) + \"')\"));\n                final Object[] eParams = {\n                    excludeTags.size() == 0 ? 1 : 0,\n                    wildCardName == null ? 1 : 0,\n                    wildCardName,\n                    type == null ? 1 : 0,\n                    type == null ? \".*\" : type.getRegexValue(),\n                };\n                excludedNames.addAll(jdbcTemplate.query(query.toString(),\n                    eParams,\n                    new int[]{Types.INTEGER,\n                        Types.INTEGER,\n                        Types.VARCHAR,\n                        Types.INTEGER,\n                        Types.VARCHAR,\n                    },\n                    (rs, rowNum) -> rs.getString(\"name\")));\n            }\n        } catch (Exception e) {\n            final String message = String.format(\"Failed getting the list of qualified names for tags %s\", includeTags);\n            log.error(message, e);\n            throw new UserMetadataServiceException(message, e);\n        }\n        if (excludeTags != null && !excludeTags.isEmpty()) {\n            includedNames = Sets.difference(includedNames, excludedNames);\n        }\n        return includedNames.stream().map(s -> QualifiedName.fromString(s, false)).collect(Collectors.toList());\n    }",
  "func_after": "@Override\n    @Transactional(readOnly = true)\n    public List<QualifiedName> list(\n        @Nullable final Set<String> includeTags,\n        @Nullable final Set<String> excludeTags,\n        @Nullable final String sourceName,\n        @Nullable final String databaseName,\n        @Nullable final String tableName,\n        @Nullable final QualifiedName.Type type\n    ) {\n        Set<String> includedNames = Sets.newHashSet();\n        final Set<String> excludedNames = Sets.newHashSet();\n        final String wildCardName =\n            QualifiedName.qualifiedNameToWildCardQueryString(sourceName, databaseName, tableName);\n        final Set<String> localIncludes = includeTags != null ? includeTags : Sets.newHashSet();\n        validateRequestTagCount(localIncludes);\n        try {\n            includedNames.addAll(queryTaggedItems(wildCardName, type, localIncludes));\n            if (excludeTags != null && !excludeTags.isEmpty()) {\n                excludedNames.addAll(queryTaggedItems(wildCardName, type, excludeTags));\n            }\n        } catch (Exception e) {\n            final String message = String.format(\"Failed getting the list of qualified names for tags %s\", includeTags);\n            log.error(message, e);\n            throw new UserMetadataServiceException(message, e);\n        }\n        if (excludeTags != null && !excludeTags.isEmpty()) {\n            includedNames = Sets.difference(includedNames, excludedNames);\n        }\n        return includedNames.stream().map(s -> QualifiedName.fromString(s, false)).collect(Collectors.toList());\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     @Transactional(readOnly = true)\n     public List<QualifiedName> list(\n         @Nullable final Set<String> includeTags,\n         @Nullable final Set<String> excludeTags,\n         @Nullable final String sourceName,\n         @Nullable final String databaseName,\n         @Nullable final String tableName,\n         @Nullable final QualifiedName.Type type\n     ) {\n         Set<String> includedNames = Sets.newHashSet();\n         final Set<String> excludedNames = Sets.newHashSet();\n         final String wildCardName =\n             QualifiedName.qualifiedNameToWildCardQueryString(sourceName, databaseName, tableName);\n-        //Includes\n         final Set<String> localIncludes = includeTags != null ? includeTags : Sets.newHashSet();\n+        validateRequestTagCount(localIncludes);\n         try {\n+            includedNames.addAll(queryTaggedItems(wildCardName, type, localIncludes));\n-            StringBuilder query = new StringBuilder(\n-                String.format(QUERY_LIST, \"in ('\" + Joiner.on(\"','\").skipNulls().join(localIncludes) + \"')\"\n-                ));\n-            final Object[] params = {\n-                localIncludes.size() == 0 ? 1 : 0,\n-                wildCardName == null ? 1 : 0,\n-                wildCardName,\n-                type == null ? 1 : 0,\n-                type == null ? \".*\" : type.getRegexValue(),\n-            };\n-            includedNames.addAll(jdbcTemplate.query(query.toString(),\n-                params,\n-                new int[]{Types.INTEGER,\n-                    Types.INTEGER,\n-                    Types.VARCHAR,\n-                    Types.INTEGER,\n-                    Types.VARCHAR,\n-                },\n-                (rs, rowNum) -> rs.getString(\"name\")));\n             if (excludeTags != null && !excludeTags.isEmpty()) {\n+                excludedNames.addAll(queryTaggedItems(wildCardName, type, excludeTags));\n-                //Excludes\n-                query = new StringBuilder(\n-          ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a SQL injection vulnerability by replacing unsafe string concatenation with a safer method, thus preventing unauthorized SQL execution. This directly mitigates a security threat.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}