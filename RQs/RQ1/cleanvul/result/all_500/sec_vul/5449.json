{
  "id": 5449,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/739790605705ddcf18f21782b9c99ad7d53a8c11",
  "commit_sha": "739790605705ddcf18f21782b9c99ad7d53a8c11",
  "commit_msg": "prlimit: do_prlimit needs to have a speculation check\n\ndo_prlimit() adds the user-controlled resource value to a pointer that\nwill subsequently be dereferenced.  In order to help prevent this\ncodepath from being used as a spectre \"gadget\" a barrier needs to be\nadded after checking the range.\n\nReported-by: Jordy Zomer <jordyzomer@google.com>\nTested-by: Jordy Zomer <jordyzomer@google.com>\nSuggested-by: Linus Torvalds <torvalds@linuxfoundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "kernel/sys.c",
  "func_name": "do_prlimit",
  "func_before": "static int do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Holding a refcount on tsk protects tsk->signal from disappearing. */\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\t/*\n\t\t * Keep the capable check against init_user_ns until cgroups can\n\t\t * contain all limits.\n\t\t */\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\n\t/*\n\t * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not\n\t * infinite. In case of RLIM_INFINITY the posix CPU timer code\n\t * ignores the rlimit.\n\t */\n\tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t    new_rlim->rlim_cur != RLIM_INFINITY &&\n\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n\t\t/*\n\t\t * update_rlimit_cpu can fail if the task is exiting, but there\n\t\t * may be other tasks in the thread group that are not exiting,\n\t\t * and they need their cpu timers adjusted.\n\t\t *\n\t\t * The group_leader is the last task to be released, so if we\n\t\t * cannot update_rlimit_cpu on it, then the entire process is\n\t\t * exiting and we do not need to update at all.\n\t\t */\n\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n\t}\n\n\treturn retval;\n}",
  "func_after": "static int do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Holding a refcount on tsk protects tsk->signal from disappearing. */\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\t/*\n\t\t * Keep the capable check against init_user_ns until cgroups can\n\t\t * contain all limits.\n\t\t */\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\n\t/*\n\t * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not\n\t * infinite. In case of RLIM_INFINITY the posix CPU timer code\n\t * ignores the rlimit.\n\t */\n\tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t    new_rlim->rlim_cur != RLIM_INFINITY &&\n\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n\t\t/*\n\t\t * update_rlimit_cpu can fail if the task is exiting, but there\n\t\t * may be other tasks in the thread group that are not exiting,\n\t\t * and they need their cpu timers adjusted.\n\t\t *\n\t\t * The group_leader is the last task to be released, so if we\n\t\t * cannot update_rlimit_cpu on it, then the entire process is\n\t\t * exiting and we do not need to update at all.\n\t\t */\n\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n\t}\n\n\treturn retval;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int do_prlimit(struct task_struct *tsk, unsigned int resource,\n \t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n {\n \tstruct rlimit *rlim;\n \tint retval = 0;\n \n \tif (resource >= RLIM_NLIMITS)\n \t\treturn -EINVAL;\n+\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n+\n \tif (new_rlim) {\n \t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n \t\t\treturn -EINVAL;\n \t\tif (resource == RLIMIT_NOFILE &&\n \t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n \t\t\treturn -EPERM;\n \t}\n \n \t/* Holding a refcount on tsk protects tsk->signal from disappearing. */\n \trlim = tsk->signal->rlim + resource;\n \ttask_lock(tsk->group_leader);\n \tif (new_rlim) {\n \t\t/*\n \t\t * Keep the capable check against init_user_ns until cgroups can\n \t\t * contain all limits.\n \t\t */\n \t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n \t\t\t\t!capable(CAP_SYS_RESOURCE))\n \t\t\tretval = -EPERM;\n \t\tif (!retval)\n \t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n \t}\n \tif (!retval) {\n \t\tif (old_rlim)\n \t\t\t*old_rlim = *rlim;\n \t\tif (new_rlim)\n \t\t\t*rlim = *new_rlim;\n \t}\n \ttask_unlock(tsk->group_leader);\n \n \t/*\n \t * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not\n \t * infinite. In case of RLIM_INFINITY the posix CPU timer code\n \t * ignores the rlimit.\n \t */\n \tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n \t    new_rlim->rlim_cur != RLIM_INFINITY &&\n \t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n \t\t/*\n \t\t * update_rlimit_cpu can fail if the task is exiting, but there\n \t\t * may be other tasks in the thread group that are not exiting,\n \t\t * and they need their cpu timers adjusted.\n \t\t *\n \t\t * The group_leader is the last task to be released, so if we\n \t\t * cannot update_rlimit_cpu on it, then the entire process is\n \t\t * exiting and we do not need to update at all.\n \t\t */\n \t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n \t}\n \n \treturn retval;\n }",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a Spectre vulnerability by adding a speculation check, preventing potential exploitation. The code change uses array_index_nospec to sanitize the resource index, mitigating the risk of a Spectre attack. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}