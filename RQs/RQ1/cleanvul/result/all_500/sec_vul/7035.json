{
  "id": 7035,
  "language": "C/C++",
  "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/726812fa2fa7ce16bcf58f6e115f65427a1c0950",
  "commit_sha": "726812fa2fa7ce16bcf58f6e115f65427a1c0950",
  "commit_msg": "Prevent buffer overflow in magick/draw.c",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "MagickCore/draw.c",
  "func_name": "DrawDashPolygon",
  "func_before": "static MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,\n  const PrimitiveInfo *primitive_info,Image *image,ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  double\n    length,\n    maximum_length,\n    offset,\n    scale,\n    total_length;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *dash_polygon;\n\n  register ssize_t\n    i;\n\n  register double\n    dx,\n    dy;\n\n  size_t\n    number_vertices;\n\n  ssize_t\n    j,\n    n;\n\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-dash\");\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;\n  number_vertices=(size_t) i;\n  dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    (2UL*number_vertices+1UL),sizeof(*dash_polygon));\n  if (dash_polygon == (PrimitiveInfo *) NULL)\n    return(MagickFalse);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->miterlimit=0;\n  dash_polygon[0]=primitive_info[0];\n  scale=ExpandAffine(&draw_info->affine);\n  length=scale*(draw_info->dash_pattern[0]-0.5);\n  offset=draw_info->dash_offset != 0.0 ? scale*draw_info->dash_offset : 0.0;\n  j=1;\n  for (n=0; offset > 0.0; j=0)\n  {\n    if (draw_info->dash_pattern[n] <= 0.0)\n      break;\n    length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n    if (offset > length)\n      {\n        offset-=length;\n        n++;\n        length=scale*(draw_info->dash_pattern[n]+0.5);\n        continue;\n      }\n    if (offset < length)\n      {\n        length-=offset;\n        offset=0.0;\n        break;\n      }\n    offset=0.0;\n    n++;\n  }\n  status=MagickTrue;\n  maximum_length=0.0;\n  total_length=0.0;\n  for (i=1; (i < number_vertices) && (length >= 0.0); i++)\n  {\n    dx=primitive_info[i].point.x-primitive_info[i-1].point.x;\n    dy=primitive_info[i].point.y-primitive_info[i-1].point.y;\n    maximum_length=hypot((double) dx,dy);\n    if (length == 0.0)\n      {\n        n++;\n        if (draw_info->dash_pattern[n] == 0.0)\n          n=0;\n        length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n      }\n    for (total_length=0.0; (length >= 0.0) && (maximum_length >= (total_length+length)); )\n    {\n      total_length+=length;\n      if ((n & 0x01) != 0)\n        {\n          dash_polygon[0]=primitive_info[0];\n          dash_polygon[0].point.x=(double) (primitive_info[i-1].point.x+dx*\n            total_length/maximum_length);\n          dash_polygon[0].point.y=(double) (primitive_info[i-1].point.y+dy*\n            total_length/maximum_length);\n          j=1;\n        }\n      else\n        {\n          if ((j+1) > (ssize_t) (2*number_vertices))\n            break;\n          dash_polygon[j]=primitive_info[i-1];\n          dash_polygon[j].point.x=(double) (primitive_info[i-1].point.x+dx*\n            total_length/maximum_length);\n          dash_polygon[j].point.y=(double) (primitive_info[i-1].point.y+dy*\n            total_length/maximum_length);\n          dash_polygon[j].coordinates=1;\n          j++;\n          dash_polygon[0].coordinates=(size_t) j;\n          dash_polygon[j].primitive=UndefinedPrimitive;\n          status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);\n        }\n      n++;\n      if (draw_info->dash_pattern[n] == 0.0)\n        n=0;\n      length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n    }\n    length-=(maximum_length-total_length);\n    if ((n & 0x01) != 0)\n      continue;\n    dash_polygon[j]=primitive_info[i];\n    dash_polygon[j].coordinates=1;\n    j++;\n  }\n  if ((total_length <= maximum_length) && ((n & 0x01) == 0) && (j > 1))\n    {\n      dash_polygon[j]=primitive_info[i-1];\n      dash_polygon[j].point.x+=MagickEpsilon;\n      dash_polygon[j].point.y+=MagickEpsilon;\n      dash_polygon[j].coordinates=1;\n      j++;\n      dash_polygon[0].coordinates=(size_t) j;\n      dash_polygon[j].primitive=UndefinedPrimitive;\n      status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);\n    }\n  dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end draw-dash\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
  "func_after": "static MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,\n  const PrimitiveInfo *primitive_info,Image *image,ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  double\n    length,\n    maximum_length,\n    offset,\n    scale,\n    total_length;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *dash_polygon;\n\n  register ssize_t\n    i;\n\n  register double\n    dx,\n    dy;\n\n  size_t\n    number_vertices;\n\n  ssize_t\n    j,\n    n;\n\n  assert(draw_info != (const DrawInfo *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-dash\");\n  for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;\n  number_vertices=(size_t) i;\n  dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n    (2UL*number_vertices+1UL),sizeof(*dash_polygon));\n  if (dash_polygon == (PrimitiveInfo *) NULL)\n    return(MagickFalse);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->miterlimit=0;\n  dash_polygon[0]=primitive_info[0];\n  scale=ExpandAffine(&draw_info->affine);\n  length=scale*(draw_info->dash_pattern[0]-0.5);\n  offset=draw_info->dash_offset != 0.0 ? scale*draw_info->dash_offset : 0.0;\n  j=1;\n  for (n=0; offset > 0.0; j=0)\n  {\n    if (draw_info->dash_pattern[n] <= 0.0)\n      break;\n    length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n    if (offset > length)\n      {\n        offset-=length;\n        n++;\n        length=scale*(draw_info->dash_pattern[n]+0.5);\n        continue;\n      }\n    if (offset < length)\n      {\n        length-=offset;\n        offset=0.0;\n        break;\n      }\n    offset=0.0;\n    n++;\n  }\n  status=MagickTrue;\n  maximum_length=0.0;\n  total_length=0.0;\n  for (i=1; (i < (ssize_t) number_vertices) && (length >= 0.0); i++)\n  {\n    dx=primitive_info[i].point.x-primitive_info[i-1].point.x;\n    dy=primitive_info[i].point.y-primitive_info[i-1].point.y;\n    maximum_length=hypot((double) dx,dy);\n    if (length == 0.0)\n      {\n        n++;\n        if (draw_info->dash_pattern[n] == 0.0)\n          n=0;\n        length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n      }\n    for (total_length=0.0; (length >= 0.0) && (maximum_length >= (total_length+length)); )\n    {\n      total_length+=length;\n      if ((n & 0x01) != 0)\n        {\n          dash_polygon[0]=primitive_info[0];\n          dash_polygon[0].point.x=(double) (primitive_info[i-1].point.x+dx*\n            total_length/maximum_length);\n          dash_polygon[0].point.y=(double) (primitive_info[i-1].point.y+dy*\n            total_length/maximum_length);\n          j=1;\n        }\n      else\n        {\n          if ((j+1) > (ssize_t) (2*number_vertices))\n            break;\n          dash_polygon[j]=primitive_info[i-1];\n          dash_polygon[j].point.x=(double) (primitive_info[i-1].point.x+dx*\n            total_length/maximum_length);\n          dash_polygon[j].point.y=(double) (primitive_info[i-1].point.y+dy*\n            total_length/maximum_length);\n          dash_polygon[j].coordinates=1;\n          j++;\n          dash_polygon[0].coordinates=(size_t) j;\n          dash_polygon[j].primitive=UndefinedPrimitive;\n          status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);\n        }\n      n++;\n      if (draw_info->dash_pattern[n] == 0.0)\n        n=0;\n      length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n    }\n    length-=(maximum_length-total_length);\n    if ((n & 0x01) != 0)\n      continue;\n    dash_polygon[j]=primitive_info[i];\n    dash_polygon[j].coordinates=1;\n    j++;\n  }\n  if ((total_length <= maximum_length) && ((n & 0x01) == 0) && (j > 1))\n    {\n      dash_polygon[j]=primitive_info[i-1];\n      dash_polygon[j].point.x+=MagickEpsilon;\n      dash_polygon[j].point.y+=MagickEpsilon;\n      dash_polygon[j].coordinates=1;\n      j++;\n      dash_polygon[0].coordinates=(size_t) j;\n      dash_polygon[j].primitive=UndefinedPrimitive;\n      status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);\n    }\n  dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    end draw-dash\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
  "diff_func": "--- func_before\n+++ func_after\n static MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,\n   const PrimitiveInfo *primitive_info,Image *image,ExceptionInfo *exception)\n {\n   DrawInfo\n     *clone_info;\n \n   double\n     length,\n     maximum_length,\n     offset,\n     scale,\n     total_length;\n \n   MagickStatusType\n     status;\n \n   PrimitiveInfo\n     *dash_polygon;\n \n   register ssize_t\n     i;\n \n   register double\n     dx,\n     dy;\n \n   size_t\n     number_vertices;\n \n   ssize_t\n     j,\n     n;\n \n   assert(draw_info != (const DrawInfo *) NULL);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"    begin draw-dash\");\n   for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;\n   number_vertices=(size_t) i;\n   dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)\n     (2UL*number_vertices+1UL),sizeof(*dash_polygon));\n   if (dash_polygon == (PrimitiveInfo *) NULL)\n     return(MagickFalse);\n   clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n   clone_info->miterlimit=0;\n   dash_polygon[0]=primitive_info[0];\n   scale=ExpandAffine(&draw_info->affine);\n   length=scale*(draw_info->dash_pattern[0]-0.5);\n   offset=draw_info->dash_offset != 0.0 ? scale*draw_info->dash_offset : 0.0;\n   j=1;\n   for (n=0; offset > 0.0; j=0)\n   {\n     if (draw_info->dash_pattern[n] <= 0.0)\n       break;\n     length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));\n     if (offset > length)\n       {\n         offset-=length;\n         n++;\n         length=scale*(draw_info->dash_pattern[n]+0.5);\n         continue;\n       }\n     if (offset < length)\n       {\n         length-=offset;\n         offset=0.0;\n         break;\n       }\n     offset=0.0;\n     n++;\n   }\n   status=MagickTrue;\n   maximum_length=0.0;\n   total_length=0.0;\n-  for (i=1; (i < number_vertices) && (length >= 0.0); i++)\n+  for (i=1; (i < (ssize_t) number_vertices) && (length >= 0.0); i++)\n   {\n     dx=primitive_info[i].point.x-primitive_info[i-1].point.x;\n   ",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a buffer overflow vulnerability by correcting an off-by-one error in a loop condition, preventing unauthorized memory access.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}