{
  "id": 7138,
  "language": "C/C++",
  "commit_url": "https://github.com/kkos/oniguruma/commit/4097828d7cc87589864fecf452f2cd46c5f37180",
  "commit_sha": "4097828d7cc87589864fecf452f2cd46c5f37180",
  "commit_msg": "fix #147: Stack Exhaustion Problem caused by some parsing functions in regcomp.c making recursive calls to themselves.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/regparse.c",
  "func_name": "parse_exp",
  "func_before": "static int\nparse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n          ScanEnv* env, int group_head)\n{\n  int r, len, group = 0;\n  Node* qn;\n  Node** tp;\n\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n    *np = node_new_empty();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    return tok->type;\n  break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) { /* group */\n      if (group_head == 0)\n        group = 1;\n      else {\n        Node* target = *np;\n        *np = node_new_group(target);\n        if (IS_NULL(*np)) {\n          onig_node_free(target);\n          return ONIGERR_MEMORY;\n        }\n        group = 2;\n      }\n    }\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->options;\n\n      env->options = BAG_(*np)->o.options;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(&target, tok, term, src, end, env, 0);\n      env->options = prev;\n      if (r < 0) {\n        onig_node_free(target);\n        return r;\n      }\n      NODE_BODY(*np) = target;\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n      while (1) {\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_STRING) break;\n\n        r = onig_node_str_cat(*np, tok->backp, *src);\n        if (r < 0) return r;\n      }\n\n    string_end:\n      tp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n        if (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n          if (len == enclen(env->enc, STR_(*np)->s)) {\n            r = fetch_token(tok, src, end, env);\n            goto tk_raw_byte_end;\n          }\n        }\n\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_RAW_BYTE)\n          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\n        r = node_str_cat_char(*np, (UChar )tok->u.c);\n        if (r < 0) return r;\n\n        len++;\n      }\n\n    tk_raw_byte_end:\n      if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))\n        return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n      NODE_STRING_CLEAR_RAW(*np);\n      goto string_end;\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n      len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);\n      if (len < 0) return len;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      *np = node_new_str_raw(buf, buf + len);\n#else\n      *np = node_new_str(buf, buf + len);\n#endif\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n        nextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        break;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n        {\n          CClassNode* cc;\n\n          *np = node_new_cclass();\n          CHECK_NULL_RETURN_MEMERR(*np);\n          cc = CCLASS_(*np);\n          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);\n          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n        }\n        break;\n\n      default:\n        return ONIGERR_PARSER_BUG;\n        break;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      CClassNode* cc;\n\n      r = parse_char_class(np, tok, src, end, env);\n      if (r != 0) return r;\n\n      cc = CCLASS_(*np);\n      if (IS_IGNORECASE(env->options)) {\n        IApplyCaseFoldArg iarg;\n\n        iarg.env      = env;\n        iarg.cc       = cc;\n        iarg.alt_root = NULL_NODE;\n        iarg.ptail    = &(iarg.alt_root);\n\n        r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n                                        i_apply_case_fold, &iarg);\n        if (r != 0) {\n          onig_node_free(iarg.alt_root);\n          return r;\n        }\n        if (IS_NOT_NULL(iarg.alt_root)) {\n          Node* work = onig_node_new_alt(*np, iarg.alt_root);\n          if (IS_NULL(work)) {\n            onig_node_free(iarg.alt_root);\n            return ONIGERR_MEMORY;\n          }\n          *np = work;\n        }\n      }\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, INFINITE_REPEAT, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NODE_BODY(qn) = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n                  (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n                  tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                           tok->u.backref.exist_level,\n                           tok->u.backref.level,\n#endif\n                           env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end,\n                          gnum, tok->u.call.by_number);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n      if (tok->u.call.by_number != 0 && gnum == 0) {\n        env->has_call_zero = 1;\n      }\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    {\n      int ascii_mode =\n        IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;\n      *np = onig_node_new_anchor(tok->u.anchor, ascii_mode);\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else {\n        *np = node_new_empty();\n        CHECK_NULL_RETURN_MEMERR(*np);\n      }\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  case TK_KEEP:\n    r = node_new_keep(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_GENERAL_NEWLINE:\n    r = node_new_general_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_NO_NEWLINE:\n    r = node_new_no_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TRUE_ANYCHAR:\n    r = node_new_true_anychar(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TEXT_SEGMENT:\n    r = make_text_segment(np, env);\n    if (r < 0) return r;\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    tp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_REPEAT || r == TK_INTERVAL) {\n      Node* target;\n\n      if (is_invalid_quantifier_target(*tp))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n                               r == TK_INTERVAL);\n      CHECK_NULL_RETURN_MEMERR(qn);\n      QUANT_(qn)->greedy = tok->u.repeat.greedy;\n      if (group == 2) {\n        target = node_drop_group(*tp);\n        *tp = NULL_NODE;\n      }\n      else {\n        target = *tp;\n      }\n      r = set_quantifier(qn, target, group, env);\n      if (r < 0) {\n        onig_node_free(qn);\n        return r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n        Node* en;\n        en = node_new_bag(BAG_STOP_BACKTRACK);\n        if (IS_NULL(en)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        NODE_BODY(en) = qn;\n        qn = en;\n      }\n\n      if (r == 0) {\n        *tp = qn;\n      }\n      else if (r == 1) { /* x{1,1} ==> x */\n        onig_node_free(qn);\n        *tp = target;\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n        Node *tmp;\n\n        *tp = node_new_list(*tp, NULL);\n        if (IS_NULL(*tp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);\n        if (IS_NULL(tmp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tp = &(NODE_CAR(tmp));\n      }\n      group = 0;\n      goto re_entry;\n    }\n  }\n\n  return r;\n}",
  "func_after": "static int\nparse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n          ScanEnv* env, int group_head)\n{\n  int r, len, group;\n  Node* qn;\n  Node** tp;\n  unsigned int parse_depth;\n\n  group = 0;\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  parse_depth = env->parse_depth;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n    *np = node_new_empty();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    return tok->type;\n  break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) { /* group */\n      if (group_head == 0)\n        group = 1;\n      else {\n        Node* target = *np;\n        *np = node_new_group(target);\n        if (IS_NULL(*np)) {\n          onig_node_free(target);\n          return ONIGERR_MEMORY;\n        }\n        group = 2;\n      }\n    }\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->options;\n\n      env->options = BAG_(*np)->o.options;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(&target, tok, term, src, end, env, 0);\n      env->options = prev;\n      if (r < 0) {\n        onig_node_free(target);\n        return r;\n      }\n      NODE_BODY(*np) = target;\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n      while (1) {\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_STRING) break;\n\n        r = onig_node_str_cat(*np, tok->backp, *src);\n        if (r < 0) return r;\n      }\n\n    string_end:\n      tp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n        if (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n          if (len == enclen(env->enc, STR_(*np)->s)) {\n            r = fetch_token(tok, src, end, env);\n            goto tk_raw_byte_end;\n          }\n        }\n\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_RAW_BYTE)\n          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\n        r = node_str_cat_char(*np, (UChar )tok->u.c);\n        if (r < 0) return r;\n\n        len++;\n      }\n\n    tk_raw_byte_end:\n      if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))\n        return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n      NODE_STRING_CLEAR_RAW(*np);\n      goto string_end;\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n      len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);\n      if (len < 0) return len;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      *np = node_new_str_raw(buf, buf + len);\n#else\n      *np = node_new_str(buf, buf + len);\n#endif\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n        nextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        break;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n        {\n          CClassNode* cc;\n\n          *np = node_new_cclass();\n          CHECK_NULL_RETURN_MEMERR(*np);\n          cc = CCLASS_(*np);\n          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);\n          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n        }\n        break;\n\n      default:\n        return ONIGERR_PARSER_BUG;\n        break;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      CClassNode* cc;\n\n      r = parse_char_class(np, tok, src, end, env);\n      if (r != 0) return r;\n\n      cc = CCLASS_(*np);\n      if (IS_IGNORECASE(env->options)) {\n        IApplyCaseFoldArg iarg;\n\n        iarg.env      = env;\n        iarg.cc       = cc;\n        iarg.alt_root = NULL_NODE;\n        iarg.ptail    = &(iarg.alt_root);\n\n        r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n                                        i_apply_case_fold, &iarg);\n        if (r != 0) {\n          onig_node_free(iarg.alt_root);\n          return r;\n        }\n        if (IS_NOT_NULL(iarg.alt_root)) {\n          Node* work = onig_node_new_alt(*np, iarg.alt_root);\n          if (IS_NULL(work)) {\n            onig_node_free(iarg.alt_root);\n            return ONIGERR_MEMORY;\n          }\n          *np = work;\n        }\n      }\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, INFINITE_REPEAT, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NODE_BODY(qn) = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n                  (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n                  tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                           tok->u.backref.exist_level,\n                           tok->u.backref.level,\n#endif\n                           env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end,\n                          gnum, tok->u.call.by_number);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n      if (tok->u.call.by_number != 0 && gnum == 0) {\n        env->has_call_zero = 1;\n      }\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    {\n      int ascii_mode =\n        IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;\n      *np = onig_node_new_anchor(tok->u.anchor, ascii_mode);\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else {\n        *np = node_new_empty();\n        CHECK_NULL_RETURN_MEMERR(*np);\n      }\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  case TK_KEEP:\n    r = node_new_keep(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_GENERAL_NEWLINE:\n    r = node_new_general_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_NO_NEWLINE:\n    r = node_new_no_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TRUE_ANYCHAR:\n    r = node_new_true_anychar(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TEXT_SEGMENT:\n    r = make_text_segment(np, env);\n    if (r < 0) return r;\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    tp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_REPEAT || r == TK_INTERVAL) {\n      Node* target;\n\n      if (is_invalid_quantifier_target(*tp))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      parse_depth++;\n      if (parse_depth > ParseDepthLimit)\n        return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n                               r == TK_INTERVAL);\n      CHECK_NULL_RETURN_MEMERR(qn);\n      QUANT_(qn)->greedy = tok->u.repeat.greedy;\n      if (group == 2) {\n        target = node_drop_group(*tp);\n        *tp = NULL_NODE;\n      }\n      else {\n        target = *tp;\n      }\n      r = set_quantifier(qn, target, group, env);\n      if (r < 0) {\n        onig_node_free(qn);\n        return r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n        Node* en;\n        en = node_new_bag(BAG_STOP_BACKTRACK);\n        if (IS_NULL(en)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        NODE_BODY(en) = qn;\n        qn = en;\n      }\n\n      if (r == 0) {\n        *tp = qn;\n      }\n      else if (r == 1) { /* x{1,1} ==> x */\n        onig_node_free(qn);\n        *tp = target;\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n        Node *tmp;\n\n        *tp = node_new_list(*tp, NULL);\n        if (IS_NULL(*tp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);\n        if (IS_NULL(tmp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tp = &(NODE_CAR(tmp));\n      }\n      group = 0;\n      goto re_entry;\n    }\n  }\n\n  return r;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int\n parse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n           ScanEnv* env, int group_head)\n {\n-  int r, len, group = 0;\n+  int r, len, group;\n   Node* qn;\n   Node** tp;\n+  unsigned int parse_depth;\n \n+  group = 0;\n   *np = NULL;\n   if (tok->type == (enum TokenSyms )term)\n     goto end_of_token;\n+\n+  parse_depth = env->parse_depth;\n \n   switch (tok->type) {\n   case TK_ALT:\n   case TK_EOT:\n   end_of_token:\n     *np = node_new_empty();\n     CHECK_NULL_RETURN_MEMERR(*np);\n     return tok->type;\n   break;\n \n   case TK_SUBEXP_OPEN:\n     r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n     if (r < 0) return r;\n     if (r == 1) { /* group */\n       if (group_head == 0)\n         group = 1;\n       else {\n         Node* target = *np;\n         *np = node_new_group(target);\n         if (IS_NULL(*np)) {\n           onig_node_free(target);\n           return ONIGERR_MEMORY;\n         }\n         group = 2;\n       }\n     }\n     else if (r == 2) { /* option only */\n       Node* target;\n       OnigOptionType prev = env->options;\n \n       env->options = BAG_(*np)->o.options;\n       r = fetch_token(tok, src, end, env);\n       if (r < 0) return r;\n       r = parse_subexp(&target, tok, term, src, end, env, 0);\n       env->options = prev;\n       if (r < 0) {\n         onig_node_free(target);\n         return r;\n       }\n       NODE_BODY(*np) = target;\n       return tok->type;\n     }\n     break;\n \n   case TK_SUBEXP_CLOSE:\n     if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n       return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n \n     if (tok->escaped) goto tk_raw_byte;\n     else goto tk_byte;\n     break;\n \n   case TK_STRING:\n   tk_byte:\n     {\n       *np = node_new_str(tok->backp, *src);\n       CHECK_NULL_RETURN_MEMERR(*np);\n \n       while (1) {\n         r = fetch_token(tok, src, end, env);\n         if (r < 0) return r;\n         if (r != TK_STRING) break;\n \n         r = onig_node_str_cat(*np, tok->backp, ",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Analysis:**\n\nThe patch addresses a stack exhaustion issue caused by excessive recursive calls in the `parse_exp` function. The code introduces a `parse_depth` variable to track recursion depth, likely to prevent stack overflow. This is a security fix as it mitigates potential denial of service attacks.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}