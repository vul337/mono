{
  "id": 1740,
  "language": "Java",
  "commit_url": "https://github.com/Zimbra/zm-mailbox/commit/3b29ca359548f4d0e4466a7490d3f33543da0947",
  "commit_sha": "3b29ca359548f4d0e4466a7490d3f33543da0947",
  "commit_msg": "ZBUG-3105: PreAuth servlet open redirection vulnerability",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "store/src/java/com/zimbra/cs/service/PreAuthServlet.java",
  "func_name": "doGet",
  "func_before": "@Override\n    public void doGet(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n    {\n        ZimbraLog.clearContext();\n        try {\n            Provisioning prov = Provisioning.getInstance();\n            Server server = prov.getLocalServer();\n            String referMode = server.getAttr(Provisioning.A_zimbraMailReferMode, \"wronghost\");\n\n            boolean isRedirect = getOptionalParam(req, PARAM_ISREDIRECT, \"0\").equals(\"1\");\n            String rawAuthToken = getOptionalParam(req, PARAM_AUTHTOKEN, null);\n            AuthToken authToken = null;\n            if (rawAuthToken != null) {\n                authToken = AuthProvider.getAuthToken(rawAuthToken);\n                if (authToken == null) {\n                    throw new AuthTokenException(\"unable to get auth token from \" + PARAM_AUTHTOKEN);\n                } else if (authToken.isExpired()) {\n                    throw new AuthTokenException(\"auth token expired\");\n                } else if (!authToken.isRegistered()) {\n                    throw new AuthTokenException(\"authtoken is invalid\");\n                }\n            }\n\n            if (rawAuthToken != null) {\n                if (!authToken.isRegistered()) {\n                    throw new AuthTokenException(\"authtoken is not registered\");\n                }\n                if (authToken.isExpired()) {\n                    throw new AuthTokenException(\"authtoken is expired registered\");\n                }\n                // we've got an auth token in the request:\n                // See if we need a redirect to the correct server\n                boolean isAdmin = authToken != null && AuthToken.isAnyAdmin(authToken);\n                Account acct = prov.get(AccountBy.id, authToken.getAccountId(), authToken);\n                if (isAdmin || !needReferral(acct, referMode, isRedirect)) {\n                    //authtoken in get request is for one time use only. Deregister and generate new one.\n                    if (authToken instanceof ZimbraAuthToken) {\n                        ZimbraAuthToken  oneTimeToken = (ZimbraAuthToken) authToken;\n                        ZimbraAuthToken newZimbraAuthToken = null;\n                        try {\n                            newZimbraAuthToken = oneTimeToken.clone();\n                        } catch (CloneNotSupportedException e) {\n                            throw new ServletException(e);\n                        }\n                        newZimbraAuthToken.resetTokenId();\n                        \n                        oneTimeToken.deRegister();\n                        authToken = newZimbraAuthToken;\n                        ZimbraLog.account.debug(\"Deregistered the one time preauth token and issuing new one to the user.\");\n                    }\n\n                    authToken.setCsrfTokenEnabled(true); // ZBUG-2662\n                    // no need to redirect to the correct server, just send them off to do business\n                    setCookieAndRedirect(req, resp, authToken);\n                } else {\n                    // redirect to the correct server with the incoming auth token\n                    // we no longer send the auth token we generate over when we redirect to the correct server,\n                    // but customer can be sending a token in their preauth URL, in this case, just\n                    // send over the auth token as is.\n                    redirectToCorrectServer(req, resp, acct, rawAuthToken);\n                }\n            } else {\n                // no auth token in the request URL.  See if we should redirect this request\n                // to the correct server, or should do the preauth locally.\n\n                String preAuth = getRequiredParam(req, resp, PARAM_PREAUTH);\n                String account = getRequiredParam(req, resp, PARAM_ACCOUNT);\n                String accountBy = getOptionalParam(req, PARAM_BY, AccountBy.name.name());\n                AccountBy by = AccountBy.fromString(accountBy);\n\n                boolean admin = getOptionalParam(req, PARAM_ADMIN, \"0\").equals(\"1\") && isAdminRequest(req);\n                long timestamp = Long.parseLong(getRequiredParam(req, resp, PARAM_TIMESTAMP));\n                long expires = Long.parseLong(getRequiredParam(req, resp, PARAM_EXPIRES));\n\n                Account acct = null;\n                acct = prov.get(by, account, authToken);\n\n                Map<String, Object> authCtxt = new HashMap<String, Object>();\n                authCtxt.put(AuthContext.AC_ORIGINATING_CLIENT_IP, ZimbraServlet.getOrigIp(req));\n                authCtxt.put(AuthContext.AC_REMOTE_IP, ZimbraServlet.getClientIp(req));\n                authCtxt.put(AuthContext.AC_ACCOUNT_NAME_PASSEDIN, account);\n                authCtxt.put(AuthContext.AC_USER_AGENT, req.getHeader(\"User-Agent\"));\n\n                boolean acctAutoProvisioned = false;\n                if (acct == null) {\n                    //\n                    // try auto provision the account\n                    //\n                    if (by == AccountBy.name && !admin) {\n                        try {\n                            EmailAddress email = new EmailAddress(account, false);\n                            String domainName = email.getDomain();\n                            Domain domain = domainName == null ? null : prov.get(Key.DomainBy.name, domainName);\n                            prov.preAuthAccount(domain, account, accountBy, timestamp, expires, preAuth, authCtxt);\n                            acct = prov.autoProvAccountLazy(domain, account, null, AutoProvAuthMech.PREAUTH);\n\n                            if (acct != null) {\n                                acctAutoProvisioned = true;\n                            }\n                        } catch (AuthFailedServiceException e) {\n                            ZimbraLog.account.debug(\"auth failed, unable to auto provision acct \" + account, e);\n                        } catch (ServiceException e) {\n                            ZimbraLog.account.info(\"unable to auto provision acct \" + account, e);\n                        }\n                    }\n                }\n\n                if (acct == null) {\n                    throw AuthFailedServiceException.AUTH_FAILED(account, account, \"account not found\");\n                }\n                \n                String accountStatus = acct.getAccountStatus(prov);\n                if (!Provisioning.ACCOUNT_STATUS_ACTIVE.equalsIgnoreCase(accountStatus)) {\n                    if(Provisioning.ACCOUNT_STATUS_MAINTENANCE.equalsIgnoreCase(accountStatus)) {\n                        throw AccountServiceException.MAINTENANCE_MODE();\n                    } else {\n                        throw AccountServiceException.ACCOUNT_INACTIVE(acct.getName());\n                    }\n                } \n\n                if (admin) {\n                    boolean isDomainAdminAccount = acct.getBooleanAttr(Provisioning.A_zimbraIsDomainAdminAccount, false);\n                    boolean isAdminAccount = acct.getBooleanAttr(Provisioning.A_zimbraIsAdminAccount, false);\n                    boolean isDelegatedAdminAccount = acct.getBooleanAttr(Provisioning.A_zimbraIsDelegatedAdminAccount, false);\n                    boolean ok = (isDomainAdminAccount || isAdminAccount || isDelegatedAdminAccount);\n                    if (!ok)\n                        throw ServiceException.PERM_DENIED(\"not an admin account\");\n                }\n\n                // all params are well, now see if we should preauth locally or redirect to the correct server.\n\n                if (admin || !needReferral(acct, referMode, isRedirect)) {\n                    // do preauth locally\n                    if (!acctAutoProvisioned) {\n                        prov.preAuthAccount(acct, account, accountBy, timestamp, expires, preAuth, admin, authCtxt);\n                    }\n\n                    AuthToken at;\n\n                    if (admin)\n                        at = (expires ==  0) ? AuthProvider.getAuthToken(acct, admin) : AuthProvider.getAuthToken(acct, expires, admin, null);\n                    else\n                        at = (expires ==  0) ? AuthProvider.getAuthToken(acct) : AuthProvider.getAuthToken(acct, expires);\n\n                    at.setCsrfTokenEnabled(true); // ZBUG-2662\n                    setCookieAndRedirect(req, resp, at);\n\n                } else {\n                    // redirect to the correct server.\n                    // Note: we do not send over the generated auth token (the auth token param passed to\n                    // redirectToCorrectServer is null).\n                    redirectToCorrectServer(req, resp, acct, null);\n                }\n            }\n        } catch (ServiceException e) {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n        } catch (AuthTokenException e) {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n        }\n    }",
  "func_after": "@Override\n    public void doGet(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n    {\n        ZimbraLog.clearContext();\n        try {\n            Provisioning prov = Provisioning.getInstance();\n            Server server = prov.getLocalServer();\n            String referMode = server.getAttr(Provisioning.A_zimbraMailReferMode, \"wronghost\");\n\n            boolean isRedirect = getOptionalParam(req, PARAM_ISREDIRECT, \"0\").equals(\"1\");\n            String rawAuthToken = getOptionalParam(req, PARAM_AUTHTOKEN, null);\n            AuthToken authToken = null;\n            if (rawAuthToken != null) {\n                authToken = AuthProvider.getAuthToken(rawAuthToken);\n                if (authToken == null) {\n                    throw new AuthTokenException(\"unable to get auth token from \" + PARAM_AUTHTOKEN);\n                } else if (authToken.isExpired()) {\n                    throw new AuthTokenException(\"auth token expired\");\n                } else if (!authToken.isRegistered()) {\n                    throw new AuthTokenException(\"authtoken is invalid\");\n                }\n            }\n\n            if (rawAuthToken != null) {\n                if (!authToken.isRegistered()) {\n                    throw new AuthTokenException(\"authtoken is not registered\");\n                }\n                if (authToken.isExpired()) {\n                    throw new AuthTokenException(\"authtoken is expired registered\");\n                }\n                // we've got an auth token in the request:\n                // See if we need a redirect to the correct server\n                boolean isAdmin = authToken != null && AuthToken.isAnyAdmin(authToken);\n                Account acct = prov.get(AccountBy.id, authToken.getAccountId(), authToken);\n                if (isAdmin || !needReferral(acct, referMode, isRedirect)) {\n                    //authtoken in get request is for one time use only. Deregister and generate new one.\n                    if (authToken instanceof ZimbraAuthToken) {\n                        ZimbraAuthToken  oneTimeToken = (ZimbraAuthToken) authToken;\n                        ZimbraAuthToken newZimbraAuthToken = null;\n                        try {\n                            newZimbraAuthToken = oneTimeToken.clone();\n                        } catch (CloneNotSupportedException e) {\n                            throw new ServletException(e);\n                        }\n                        newZimbraAuthToken.resetTokenId();\n                        \n                        oneTimeToken.deRegister();\n                        authToken = newZimbraAuthToken;\n                        ZimbraLog.account.debug(\"Deregistered the one time preauth token and issuing new one to the user.\");\n                    }\n\n                    authToken.setCsrfTokenEnabled(true); // ZBUG-2662\n                    // no need to redirect to the correct server, just send them off to do business\n                    setCookieAndRedirect(req, resp, authToken, acct);\n                } else {\n                    // redirect to the correct server with the incoming auth token\n                    // we no longer send the auth token we generate over when we redirect to the correct server,\n                    // but customer can be sending a token in their preauth URL, in this case, just\n                    // send over the auth token as is.\n                    redirectToCorrectServer(req, resp, acct, rawAuthToken);\n                }\n            } else {\n                // no auth token in the request URL.  See if we should redirect this request\n                // to the correct server, or should do the preauth locally.\n\n                String preAuth = getRequiredParam(req, resp, PARAM_PREAUTH);\n                String account = getRequiredParam(req, resp, PARAM_ACCOUNT);\n                String accountBy = getOptionalParam(req, PARAM_BY, AccountBy.name.name());\n                AccountBy by = AccountBy.fromString(accountBy);\n\n                boolean admin = getOptionalParam(req, PARAM_ADMIN, \"0\").equals(\"1\") && isAdminRequest(req);\n                long timestamp = Long.parseLong(getRequiredParam(req, resp, PARAM_TIMESTAMP));\n                long expires = Long.parseLong(getRequiredParam(req, resp, PARAM_EXPIRES));\n\n                Account acct = null;\n                acct = prov.get(by, account, authToken);\n\n                Map<String, Object> authCtxt = new HashMap<String, Object>();\n                authCtxt.put(AuthContext.AC_ORIGINATING_CLIENT_IP, ZimbraServlet.getOrigIp(req));\n                authCtxt.put(AuthContext.AC_REMOTE_IP, ZimbraServlet.getClientIp(req));\n                authCtxt.put(AuthContext.AC_ACCOUNT_NAME_PASSEDIN, account);\n                authCtxt.put(AuthContext.AC_USER_AGENT, req.getHeader(\"User-Agent\"));\n\n                boolean acctAutoProvisioned = false;\n                if (acct == null) {\n                    //\n                    // try auto provision the account\n                    //\n                    if (by == AccountBy.name && !admin) {\n                        try {\n                            EmailAddress email = new EmailAddress(account, false);\n                            String domainName = email.getDomain();\n                            Domain domain = domainName == null ? null : prov.get(Key.DomainBy.name, domainName);\n                            prov.preAuthAccount(domain, account, accountBy, timestamp, expires, preAuth, authCtxt);\n                            acct = prov.autoProvAccountLazy(domain, account, null, AutoProvAuthMech.PREAUTH);\n\n                            if (acct != null) {\n                                acctAutoProvisioned = true;\n                            }\n                        } catch (AuthFailedServiceException e) {\n                            ZimbraLog.account.debug(\"auth failed, unable to auto provision acct \" + account, e);\n                        } catch (ServiceException e) {\n                            ZimbraLog.account.info(\"unable to auto provision acct \" + account, e);\n                        }\n                    }\n                }\n\n                if (acct == null) {\n                    throw AuthFailedServiceException.AUTH_FAILED(account, account, \"account not found\");\n                }\n                \n                String accountStatus = acct.getAccountStatus(prov);\n                if (!Provisioning.ACCOUNT_STATUS_ACTIVE.equalsIgnoreCase(accountStatus)) {\n                    if(Provisioning.ACCOUNT_STATUS_MAINTENANCE.equalsIgnoreCase(accountStatus)) {\n                        throw AccountServiceException.MAINTENANCE_MODE();\n                    } else {\n                        throw AccountServiceException.ACCOUNT_INACTIVE(acct.getName());\n                    }\n                } \n\n                if (admin) {\n                    boolean isDomainAdminAccount = acct.getBooleanAttr(Provisioning.A_zimbraIsDomainAdminAccount, false);\n                    boolean isAdminAccount = acct.getBooleanAttr(Provisioning.A_zimbraIsAdminAccount, false);\n                    boolean isDelegatedAdminAccount = acct.getBooleanAttr(Provisioning.A_zimbraIsDelegatedAdminAccount, false);\n                    boolean ok = (isDomainAdminAccount || isAdminAccount || isDelegatedAdminAccount);\n                    if (!ok)\n                        throw ServiceException.PERM_DENIED(\"not an admin account\");\n                }\n\n                // all params are well, now see if we should preauth locally or redirect to the correct server.\n\n                if (admin || !needReferral(acct, referMode, isRedirect)) {\n                    // do preauth locally\n                    if (!acctAutoProvisioned) {\n                        prov.preAuthAccount(acct, account, accountBy, timestamp, expires, preAuth, admin, authCtxt);\n                    }\n\n                    AuthToken at;\n\n                    if (admin)\n                        at = (expires ==  0) ? AuthProvider.getAuthToken(acct, admin) : AuthProvider.getAuthToken(acct, expires, admin, null);\n                    else\n                        at = (expires ==  0) ? AuthProvider.getAuthToken(acct) : AuthProvider.getAuthToken(acct, expires);\n\n                    at.setCsrfTokenEnabled(true); // ZBUG-2662\n                    setCookieAndRedirect(req, resp, at, acct);\n                } else {\n                    // redirect to the correct server.\n                    // Note: we do not send over the generated auth token (the auth token param passed to\n                    // redirectToCorrectServer is null).\n                    redirectToCorrectServer(req, resp, acct, null);\n                }\n            }\n        } catch (ServiceException e) {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n        } catch (AuthTokenException e) {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public void doGet(HttpServletRequest req, HttpServletResponse resp)\n     throws ServletException, IOException\n     {\n         ZimbraLog.clearContext();\n         try {\n             Provisioning prov = Provisioning.getInstance();\n             Server server = prov.getLocalServer();\n             String referMode = server.getAttr(Provisioning.A_zimbraMailReferMode, \"wronghost\");\n \n             boolean isRedirect = getOptionalParam(req, PARAM_ISREDIRECT, \"0\").equals(\"1\");\n             String rawAuthToken = getOptionalParam(req, PARAM_AUTHTOKEN, null);\n             AuthToken authToken = null;\n             if (rawAuthToken != null) {\n                 authToken = AuthProvider.getAuthToken(rawAuthToken);\n                 if (authToken == null) {\n                     throw new AuthTokenException(\"unable to get auth token from \" + PARAM_AUTHTOKEN);\n                 } else if (authToken.isExpired()) {\n                     throw new AuthTokenException(\"auth token expired\");\n                 } else if (!authToken.isRegistered()) {\n                     throw new AuthTokenException(\"authtoken is invalid\");\n                 }\n             }\n \n             if (rawAuthToken != null) {\n                 if (!authToken.isRegistered()) {\n                     throw new AuthTokenException(\"authtoken is not registered\");\n                 }\n                 if (authToken.isExpired()) {\n                     throw new AuthTokenException(\"authtoken is expired registered\");\n                 }\n                 // we've got an auth token in the request:\n                 // See if we need a redirect to the correct server\n                 boolean isAdmin = authToken != null && AuthToken.isAnyAdmin(authToken);\n                 Account acct = prov.get(AccountBy.id, authToken.getAccountId(), authToken);\n                 if (isAdmin || !needReferral(acct, referMode, isRedirect)) {\n                     //authtoken in get request is for one time use only. Dereg",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses an open redirection vulnerability in a servlet, preventing unauthorized redirects by adding necessary checks. This clearly falls under security vulnerability fixes.\n\n**Final Output:**\n\nAnalysis: The commit message and code changes indicate a fix for an open redirection vulnerability, a security issue. The code adds checks to prevent unauthorized redirects, confirming it's a security fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}