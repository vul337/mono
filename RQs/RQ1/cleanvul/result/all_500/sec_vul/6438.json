{
  "id": 6438,
  "language": "Python",
  "commit_url": "https://github.com/yt-dlp/yt-dlp/commit/f8b4bcc0a791274223723488bfbfc23ea3276641",
  "commit_sha": "f8b4bcc0a791274223723488bfbfc23ea3276641",
  "commit_msg": "[core] Prevent `Cookie` leaks on HTTP redirect\n\nRef: https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-v8mc-9377-rwjj\n\nAuthored by: coletdjnz",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "yt_dlp/utils/_utils.py",
  "func_name": "redirect_request",
  "func_before": "def redirect_request(self, req, fp, code, msg, headers, newurl):\n        if code not in (301, 302, 303, 307, 308):\n            raise urllib.error.HTTPError(req.full_url, code, msg, headers, fp)\n\n        new_method = req.get_method()\n        new_data = req.data\n        remove_headers = []\n        # A 303 must either use GET or HEAD for subsequent request\n        # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.4\n        if code == 303 and req.get_method() != 'HEAD':\n            new_method = 'GET'\n        # 301 and 302 redirects are commonly turned into a GET from a POST\n        # for subsequent requests by browsers, so we'll do the same.\n        # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.2\n        # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.3\n        elif code in (301, 302) and req.get_method() == 'POST':\n            new_method = 'GET'\n\n        # only remove payload if method changed (e.g. POST to GET)\n        if new_method != req.get_method():\n            new_data = None\n            remove_headers.extend(['Content-Length', 'Content-Type'])\n\n        new_headers = {k: v for k, v in req.headers.items() if k.lower() not in remove_headers}\n\n        return urllib.request.Request(\n            newurl, headers=new_headers, origin_req_host=req.origin_req_host,\n            unverifiable=True, method=new_method, data=new_data)",
  "func_after": "def redirect_request(self, req, fp, code, msg, headers, newurl):\n        if code not in (301, 302, 303, 307, 308):\n            raise urllib.error.HTTPError(req.full_url, code, msg, headers, fp)\n\n        new_method = req.get_method()\n        new_data = req.data\n\n        # Technically the Cookie header should be in unredirected_hdrs,\n        # however in practice some may set it in normal headers anyway.\n        # We will remove it here to prevent any leaks.\n        remove_headers = ['Cookie']\n\n        # A 303 must either use GET or HEAD for subsequent request\n        # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.4\n        if code == 303 and req.get_method() != 'HEAD':\n            new_method = 'GET'\n        # 301 and 302 redirects are commonly turned into a GET from a POST\n        # for subsequent requests by browsers, so we'll do the same.\n        # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.2\n        # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.3\n        elif code in (301, 302) and req.get_method() == 'POST':\n            new_method = 'GET'\n\n        # only remove payload if method changed (e.g. POST to GET)\n        if new_method != req.get_method():\n            new_data = None\n            remove_headers.extend(['Content-Length', 'Content-Type'])\n\n        new_headers = {k: v for k, v in req.headers.items() if k.title() not in remove_headers}\n\n        return urllib.request.Request(\n            newurl, headers=new_headers, origin_req_host=req.origin_req_host,\n            unverifiable=True, method=new_method, data=new_data)",
  "diff_func": "--- func_before\n+++ func_after\n def redirect_request(self, req, fp, code, msg, headers, newurl):\n         if code not in (301, 302, 303, 307, 308):\n             raise urllib.error.HTTPError(req.full_url, code, msg, headers, fp)\n \n         new_method = req.get_method()\n         new_data = req.data\n+\n+        # Technically the Cookie header should be in unredirected_hdrs,\n+        # however in practice some may set it in normal headers anyway.\n+        # We will remove it here to prevent any leaks.\n-        remove_headers = []\n+        remove_headers = ['Cookie']\n+\n         # A 303 must either use GET or HEAD for subsequent request\n         # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.4\n         if code == 303 and req.get_method() != 'HEAD':\n             new_method = 'GET'\n         # 301 and 302 redirects are commonly turned into a GET from a POST\n         # for subsequent requests by browsers, so we'll do the same.\n         # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.2\n         # https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.3\n         elif code in (301, 302) and req.get_method() == 'POST':\n             new_method = 'GET'\n \n         # only remove payload if method changed (e.g. POST to GET)\n         if new_method != req.get_method():\n             new_data = None\n             remove_headers.extend(['Content-Length', 'Content-Type'])\n \n-        new_headers = {k: v for k, v in req.headers.items() if k.lower() not in remove_headers}\n+        new_headers = {k: v for k, v in req.headers.items() if k.title() not in remove_headers}\n \n         return urllib.request.Request(\n             newurl, headers=new_headers, origin_req_host=req.origin_req_host,\n             unverifiable=True, method=new_method, data=new_data)",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing the leakage of Cookie headers during HTTP redirects, which could expose sensitive session data.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}