{
  "id": 7106,
  "language": "Python",
  "commit_url": "https://github.com/sqlalchemy/sqlalchemy/commit/30307c4616ad67c01ddae2e1e8e34fabf6028414",
  "commit_sha": "30307c4616ad67c01ddae2e1e8e34fabf6028414",
  "commit_msg": "Remove all remaining text() coercions and ensure identifiers are safe\n\nFully removed the behavior of strings passed directly as components of a\n:func:`.select` or :class:`.Query` object being coerced to :func:`.text`\nconstructs automatically; the warning that has been emitted is now an\nArgumentError or in the case of order_by() / group_by() a CompileError.\nThis has emitted a warning since version 1.0 however its presence continues\nto create concerns for the potential of mis-use of this behavior.\n\nNote that public CVEs have been posted for order_by() / group_by() which\nare resolved by this commit:  CVE-2019-7164  CVE-2019-7548\n\nAdded \"SQL phrase validation\" to key DDL phrases that are accepted as plain\nstrings, including :paramref:`.ForeignKeyConstraint.on_delete`,\n:paramref:`.ForeignKeyConstraint.on_update`,\n:paramref:`.ExcludeConstraint.using`,\n:paramref:`.ForeignKeyConstraint.initially`, for areas where a series of SQL\nkeywords only are expected.Any non-space characters that suggest the phrase\nwould need to be quoted will raise a :class:`.CompileError`.   This change\nis related to the series of changes committed as part of :ticket:`4481`.\n\nFixed issue where using an uppercase name for an index type (e.g. GIST,\nBTREE, etc. ) or an EXCLUDE constraint would treat it as an identifier to\nbe quoted, rather than rendering it as is. The new behavior converts these\ntypes to lowercase and ensures they contain only valid SQL characters.\n\nQuoting is applied to :class:`.Function` names, those which are usually but\nnot necessarily generated from the :attr:`.sql.func` construct,  at compile\ntime if they contain illegal characters, such as spaces or punctuation. The\nnames are as before treated as case insensitive however, meaning if the\nnames contain uppercase or mixed case characters, that alone does not\ntrigger quoting. The case insensitivity is currently maintained for\nbackwards compatibility.\n\nFixes: #4481\nFixes: #4473\nFixes: #4467\nChange-Id: Ib22a27d62930e24702e2f0f7c74a0473385a08eb",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "lib/sqlalchemy/util/langhelpers.py",
  "func_name": "decorate",
  "func_before": "def decorate(fn):\n        if not inspect.isfunction(fn) and not inspect.ismethod(fn):\n            raise Exception(\"not a decoratable function\")\n\n        spec = compat.inspect_getfullargspec(fn)\n        names = tuple(spec[0]) + spec[1:3] + (fn.__name__,)\n        targ_name, fn_name = _unique_symbols(names, \"target\", \"fn\")\n\n        metadata = dict(target=targ_name, fn=fn_name)\n        metadata.update(format_argspec_plus(spec, grouped=False))\n        metadata[\"name\"] = fn.__name__\n        code = (\n            \"\"\"\\\ndef %(name)s(%(args)s):\n    return %(target)s(%(fn)s, %(apply_kw)s)\n\"\"\"\n            % metadata\n        )\n        decorated = _exec_code_in_env(\n            code, {targ_name: target, fn_name: fn}, fn.__name__\n        )\n        decorated.__defaults__ = getattr(fn, \"im_func\", fn).__defaults__\n        decorated.__wrapped__ = fn\n        return update_wrapper(decorated, fn)",
  "func_after": "def decorate(fn):\n        doc = fn.__doc__ is not None and fn.__doc__ or \"\"\n        if doc:\n            doc = inject_param_text(doc, {param: text for param in params})\n        fn.__doc__ = doc\n        return fn",
  "diff_func": "--- func_before\n+++ func_after\n def decorate(fn):\n+        doc = fn.__doc__ is not None and fn.__doc__ or \"\"\n+        if doc:\n+            doc = inject_param_text(doc, {param: text for param in params})\n+        fn.__doc__ = doc\n+        return fn\n-        if not inspect.isfunction(fn) and not inspect.ismethod(fn):\n-            raise Exception(\"not a decoratable function\")\n-\n-        spec = compat.inspect_getfullargspec(fn)\n-        names = tuple(spec[0]) + spec[1:3] + (fn.__name__,)\n-        targ_name, fn_name = _unique_symbols(names, \"target\", \"fn\")\n-\n-        metadata = dict(target=targ_name, fn=fn_name)\n-        metadata.update(format_argspec_plus(spec, grouped=False))\n-        metadata[\"name\"] = fn.__name__\n-        code = (\n-            \"\"\"\\\n-def %(name)s(%(args)s):\n-    return %(target)s(%(fn)s, %(apply_kw)s)\n-\"\"\"\n-            % metadata\n-        )\n-        decorated = _exec_code_in_env(\n-            code, {targ_name: target, fn_name: fn}, fn.__name__\n-        )\n-        decorated.__defaults__ = getattr(fn, \"im_func\", fn).__defaults__\n-        decorated.__wrapped__ = fn\n-        return update_wrapper(decorated, fn)",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses known security vulnerabilities (CVE-2019-7164 and CVE-2019-7548) by removing unsafe text() coercions and enhancing SQL validation. These changes mitigate SQL injection risks, thus qualifying as a Security Vulnerability Fix.\n\n**Final Output:**\nAnalysis: The patch resolves security issues related to SQL injection by validating inputs and ensuring proper handling of SQL phrases. It references specific CVEs, indicating a direct security fix.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}