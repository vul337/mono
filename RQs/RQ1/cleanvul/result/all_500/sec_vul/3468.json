{
  "id": 3468,
  "language": "C/C++",
  "commit_url": "https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77",
  "commit_sha": "a550daeecf6bc689ade371349892ea17b5b97c77",
  "commit_msg": "Fix libarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds",
  "pr_url": "https://github.com/libarchive/libarchive/pull/715",
  "pr_info": " Version of libarchive: libarchive-3.2.0\n How you obtained it:  Source from git release  libarchive-3.2.0.tar.gz\n Operating system and version: Ubuntu 14.04\n What compiler and/or IDE you are using (include version): arm-none-linux-gnueabi\n\nThis patch fix a bug (see below) that we found while crosscompiling libarchive-3.2.0 to build opkg for arm platform. \n\n```\nmake  all-am\nmake[1]: Entering directory `/mnt/host/libarchive-3.2.0'\n  CC       libarchive/archive_read_support_format_mtree.lo\ncc1: warnings being treated as errors\nlibarchive/archive_read_support_format_mtree.c: In function 'parse_device':\nlibarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds\nmake[1]: *** [libarchive/archive_read_support_format_mtree.lo] Error 1\nmake[1]: Leaving directory `/mnt/host/libarchive-3.2.0'\nmake: *** [all] Error \n```\n",
  "file_name": "libarchive/archive_read_support_format_mtree.c",
  "func_name": "parse_device",
  "func_before": "static int\nparse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}",
  "func_after": "static int\nparse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tif (argc >= MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int\n parse_device(dev_t *pdev, struct archive *a, char *val)\n {\n #define MAX_PACK_ARGS 3\n \tunsigned long numbers[MAX_PACK_ARGS];\n \tchar *p, *dev;\n \tint argc;\n \tpack_t *pack;\n \tdev_t result;\n \tconst char *error = NULL;\n \n \tmemset(pdev, 0, sizeof(*pdev));\n \tif ((dev = strchr(val, ',')) != NULL) {\n \t\t/*\n \t\t * Device's major/minor are given in a specified format.\n \t\t * Decode and pack it accordingly.\n \t\t */\n \t\t*dev++ = '\\0';\n \t\tif ((pack = pack_find(val)) == NULL) {\n \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t    \"Unknown format `%s'\", val);\n \t\t\treturn ARCHIVE_WARN;\n \t\t}\n \t\targc = 0;\n \t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n \t\t\tif (*p == '\\0') {\n \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t    \"Missing number\");\n \t\t\t\treturn ARCHIVE_WARN;\n \t\t\t}\n-\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n-\t\t\tif (argc > MAX_PACK_ARGS) {\n+\t\t\tif (argc >= MAX_PACK_ARGS) {\n \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t    \"Too many arguments\");\n \t\t\t\treturn ARCHIVE_WARN;\n \t\t\t}\n+\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n \t\t}\n \t\tif (argc < 2) {\n \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t    \"Not enough arguments\");\n \t\t\treturn ARCHIVE_WARN;\n \t\t}\n \t\tresult = (*pack)(argc, numbers, &error);\n \t\tif (error != NULL) {\n \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t    \"%s\", error);\n \t\t\treturn ARCHIVE_WARN;\n \t\t}\n \t} else {\n \t\t/* file system raw value. */\n \t\tresult = (dev_t)mtree_atol(&val);\n \t}\n \t*pdev = result;\n \treturn ARCHIVE_OK;\n #undef MAX_PACK_ARGS\n }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an array bounds issue that could lead to a buffer overflow, a classic security vulnerability. The code change prevents exceeding the array's capacity, mitigating potential exploitation.\n\n**Final Output:**\n\nAnalysis: The patch fixes an array bounds error, preventing potential buffer overflow. This is a security vulnerability as it could be exploited.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}