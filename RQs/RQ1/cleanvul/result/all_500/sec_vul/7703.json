{
  "id": 7703,
  "language": "JavaScript",
  "commit_url": "https://github.com/ritterim/definely/commit/b31a022ba4d8d17148445a13ebb5a42ad593dbaa",
  "commit_sha": "b31a022ba4d8d17148445a13ebb5a42ad593dbaa",
  "commit_msg": "Fix XSS on term-detailed web client view.\nPrevious behavior would render unencoded HTML in the view based on the term's definition-data.\nNew behavior encodes HTML-tags in the DB-module via a separate sanitize module.\nHowever, be aware this functionality should be called prior to any markdown-related conversion in the future.\nOtherwise, the resulting HTML will be encoded.\nRelated to https://github.com/ritterim/definely/issues/49.\n\nAlso added a new gulp task for running TDD-style tests.\nAnd, incorporated this into the existing test-task.",
  "pr_url": "https://github.com/ritterim/definely/pull/51",
  "pr_info": "Previous behavior would render unencoded HTML in the view based on the term's definition-data.\nNew behavior encodes HTML-tags in the DB-module via a separate sanitize module.\nHowever, be aware this functionality should be called prior to any markdown-related conversion in the future.\nOtherwise, the resulting HTML will be encoded.\nRelated to https://github.com/ritterim/definely/issues/49.\n\nAlso added a new gulp task for running TDD-style tests.\nAnd, incorporated this into the existing test-task.\n",
  "file_name": "src/database.js",
  "func_name": "search",
  "func_before": "search(searchTerm, callback) {\n        pg.connect(this.connectionUri, function (err, client, done) {\n            if (err) {\n                return console.error('Could not connect to postgres', err);\n                done(client);\n            }\n\n\n            searchTerm = (searchTerm || '').trim().replace(/\\s+/g, ' | ');\n\n            if (!searchTerm) {\n                client.query('select id, term, tags, definition from terms', function (err, result) {\n\n                    var terms = result.rows.map(row => new Term(row.id, row.term, row.definition, row.tags || undefined))\n                    callback(terms)\n                })\n            } else {\n                client.query('select id, term, tags, definition, rank from terms, to_tsquery($1) as query, ts_rank_cd(weightedVector, query) as rank where weightedVector @@ query order by rank desc;', [searchTerm],\n                    function (err, result) {\n                        if (err) {\n                            return console.error('Error running query', err);\n                            done(client);\n                        }\n\n                        done();\n                        var terms = result.rows.map(row => new Term(row.id, row.term, row.definition, row.tags || undefined))\n                        callback(terms);\n                    })\n            }\n        })\n    }",
  "func_after": "search(searchTerm, callback) {\n        var self = this;\n\n        pg.connect(this.connectionUri, function (err, client, done) {\n            if (err) {\n                return console.error('Could not connect to postgres', err);\n                done(client);\n            }\n\n\n            searchTerm = (searchTerm || '').trim().replace(/\\s+/g, ' | ');\n\n            if (!searchTerm) {\n                client.query('select id, term, tags, definition from terms', function (err, result) {\n\n                    var terms = result.rows.map(row => new Term(row.id, row.term, self.sanitize.htmlSanitize(row.definition), row.tags || undefined))\n                    callback(terms)\n                })\n            } else {\n                client.query('select id, term, tags, definition, rank from terms, to_tsquery($1) as query, ts_rank_cd(weightedVector, query) as rank where weightedVector @@ query order by rank desc;', [searchTerm],\n                    function (err, result) {\n                        if (err) {\n                            return console.error('Error running query', err);\n                            done(client);\n                        }\n\n                        done();\n                        var terms = result.rows.map(row => new Term(row.id, row.term, self.sanitize.htmlSanitize(row.definition), row.tags || undefined))\n                        callback(terms);\n                    })\n            }\n        })\n    }",
  "diff_func": "--- func_before\n+++ func_after\n search(searchTerm, callback) {\n+        var self = this;\n+\n         pg.connect(this.connectionUri, function (err, client, done) {\n             if (err) {\n                 return console.error('Could not connect to postgres', err);\n                 done(client);\n             }\n \n \n             searchTerm = (searchTerm || '').trim().replace(/\\s+/g, ' | ');\n \n             if (!searchTerm) {\n                 client.query('select id, term, tags, definition from terms', function (err, result) {\n \n-                    var terms = result.rows.map(row => new Term(row.id, row.term, row.definition, row.tags || undefined))\n+                    var terms = result.rows.map(row => new Term(row.id, row.term, self.sanitize.htmlSanitize(row.definition), row.tags || undefined))\n                     callback(terms)\n                 })\n             } else {\n                 client.query('select id, term, tags, definition, rank from terms, to_tsquery($1) as query, ts_rank_cd(weightedVector, query) as rank where weightedVector @@ query order by rank desc;', [searchTerm],\n                     function (err, result) {\n                         if (err) {\n                             return console.error('Error running query', err);\n                             done(client);\n                         }\n \n                         done();\n-                        var terms = result.rows.map(row => new Term(row.id, row.term, row.definition, row.tags || undefined))\n+                        var terms = result.rows.map(row => new Term(row.id, row.term, self.sanitize.htmlSanitize(row.definition), row.tags || undefined))\n                         callback(terms);\n                     })\n             }\n         })\n     }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The commit addresses an XSS vulnerability by sanitizing HTML in the term definition, preventing untrusted HTML from being rendered. The code change introduces `self.sanitize.htmlSanitize()` to encode HTML tags, mitigating the risk of script injection.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}