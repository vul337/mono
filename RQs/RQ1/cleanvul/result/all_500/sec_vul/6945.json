{
  "id": 6945,
  "language": "C/C++",
  "commit_url": "https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970",
  "commit_sha": "ffb35baac6981f9e8914f8f3bffd37f284b85970",
  "commit_msg": "Prevent KDC unset status assertion failures\n\nAssign status values if S4U2Self padata fails to decode, if an\nS4U2Proxy request uses invalid KDC options, or if an S4U2Proxy request\nuses an evidence ticket which does not match the canonicalized request\nserver principal name.  Reported by Samuel Cabrero.\n\nIf a status value is not assigned during KDC processing, default to\n\"UNKNOWN_REASON\" rather than failing an assertion.  This change will\nprevent future denial of service bugs due to similar mistakes, and\nwill allow us to omit assigning status values for unlikely errors such\nas small memory allocation failures.\n\nCVE-2017-11368:\n\nIn MIT krb5 1.7 and later, an authenticated attacker can cause an\nassertion failure in krb5kdc by sending an invalid S4U2Self or\nS4U2Proxy request.\n\n  CVSSv3 Vector: AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H/E:H/RL:O/RC:C\n\nticket: 8599 (new)\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup",
  "pr_url": "https://github.com/krb5/krb5/pull/678",
  "pr_info": "Assign status values if S4U2Self padata fails to decode, if an\r\nS4U2Proxy request uses invalid KDC options, or if an S4U2Proxy request\r\nuses an evidence ticket which does not match the canonicalized request\r\nserver principal name.  Reported by Samuel Cabrero.\r\n    \r\nIf a status value is not assigned during KDC processing, default to\r\n\"UNKNOWN_REASON\" rather than failing an assertion.  This change will\r\nprevent future denial of service bugs due to similar mistakes, and\r\nwill allow us to omit assigning status values for unlikely errors such\r\nas small memory allocation failures.\r\n\r\n[There is a second non-backport commit to remove status assignments for error conditions which don't look practically reachable to me.]",
  "file_name": "src/kdc/kdc_util.c",
  "func_name": "kdc_process_s4u_x509_user",
  "func_before": "static krb5_error_code\nkdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}",
  "func_after": "static krb5_error_code\nkdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code) {\n        *status = \"DECODE_PA_S4U_X509_USER\";\n        return code;\n    }\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static krb5_error_code\n kdc_process_s4u_x509_user(krb5_context context,\n                           krb5_kdc_req *request,\n                           krb5_pa_data *pa_data,\n                           krb5_keyblock *tgs_subkey,\n                           krb5_keyblock *tgs_session,\n                           krb5_pa_s4u_x509_user **s4u_x509_user,\n                           const char **status)\n {\n     krb5_error_code             code;\n     krb5_data                   req_data;\n \n     req_data.length = pa_data->length;\n     req_data.data = (char *)pa_data->contents;\n \n     code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n-    if (code)\n+    if (code) {\n+        *status = \"DECODE_PA_S4U_X509_USER\";\n         return code;\n+    }\n \n     code = verify_s4u_x509_user_checksum(context,\n                                          tgs_subkey ? tgs_subkey :\n                                          tgs_session,\n                                          &req_data,\n                                          request->nonce, *s4u_x509_user);\n \n     if (code) {\n         *status = \"INVALID_S4U2SELF_CHECKSUM\";\n         krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n         *s4u_x509_user = NULL;\n         return code;\n     }\n \n     if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n         (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n         *status = \"INVALID_S4U2SELF_REQUEST\";\n         krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n         *s4u_x509_user = NULL;\n         return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n     }\n \n     return 0;\n }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing assertion failures in the KDC when processing invalid requests, thus mitigating a denial of service risk.\n\n**Final Output:**\nAnalysis: The patch fixes a security vulnerability by handling errors in KDC processing, preventing assertion failures. It addresses a CVE-2017-11368, which is a known security issue. The code changes ensure proper error handling, avoiding crashes and potential denial of service attacks.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}