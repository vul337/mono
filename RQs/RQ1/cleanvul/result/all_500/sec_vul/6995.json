{
  "id": 6995,
  "language": "C/C++",
  "commit_url": "https://github.com/ivmai/bdwgc/commit/2ea6d85adc5fe07d7e9c5d35f2e5886857338681",
  "commit_sha": "2ea6d85adc5fe07d7e9c5d35f2e5886857338681",
  "commit_msg": "Fix malloc routines to prevent size value wrap-around\n(Cherry-pick commit 0b68187 from 'release-7_4' branch.)\n\nSee issue #135 on Github.\n\n* allchblk.c (GC_allochblk, GC_allochblk_nth): Use\nOBJ_SZ_TO_BLOCKS_CHECKED instead of OBJ_SZ_TO_BLOCKS.\n* malloc.c (GC_alloc_large): Likewise.\n* alloc.c (GC_expand_hp_inner): Type of \"bytes\" local variable changed\nfrom word to size_t; cast ROUNDUP_PAGESIZE argument to size_t; prevent\noverflow when computing GC_heapsize+bytes > GC_max_heapsize.\n* dbg_mlc.c (GC_debug_malloc, GC_debug_malloc_ignore_off_page,\nGC_debug_malloc_atomic_ignore_off_page,\nGC_debug_generic_malloc_inner,\nGC_debug_generic_malloc_inner_ignore_off_page,\nGC_debug_malloc_stubborn, GC_debug_malloc_atomic,\nGC_debug_malloc_uncollectable, GC_debug_malloc_atomic_uncollectable):\nUse SIZET_SAT_ADD (instead of \"+\" operator) to add extra bytes to lb\nvalue.\n* gcj_mlc.c (GC_debug_gcj_malloc): Likewise.\n* include/private/gc_priv.h (ROUNDUP_GRANULE_SIZE, ROUNDED_UP_GRANULES,\nADD_SLOP, ROUNDUP_PAGESIZE): Likewise.\n* include/private/gcconfig.h (GET_MEM): Likewise.\n* mallocx.c (GC_malloc_many, GC_memalign): Likewise.\n* os_dep.c (GC_wince_get_mem, GC_win32_get_mem): Likewise.\n* typd_mlc.c (GC_malloc_explicitly_typed,\nGC_malloc_explicitly_typed_ignore_off_page,\nGC_calloc_explicitly_typed): Likewise.\n* headers.c (GC_scratch_alloc): Change type of bytes_to_get from word\nto size_t (because ROUNDUP_PAGESIZE_IF_MMAP result type changed).\n* include/private/gc_priv.h: Include limits.h (unless SIZE_MAX already\ndefined).\n* include/private/gc_priv.h (GC_SIZE_MAX, GC_SQRT_SIZE_MAX): Move from\nmalloc.c file.\n* include/private/gc_priv.h (SIZET_SAT_ADD): New macro (defined before\ninclude gcconfig.h).\n* include/private/gc_priv.h (EXTRA_BYTES, GC_page_size): Change type\nto size_t.\n* os_dep.c (GC_page_size): Likewise.\n* include/private/gc_priv.h (ROUNDUP_GRANULE_SIZE, ROUNDED_UP_GRANULES,\nADD_SLOP, ROUNDUP_PAGESIZE): Add comment about the argument.\n* include/private/gcconfig.h (GET_MEM): Likewise.\n* include/private/gc_priv.h (ROUNDUP_GRANULE_SIZE, ROUNDED_UP_GRANULES,\nADD_SLOP, OBJ_SZ_TO_BLOCKS, ROUNDUP_PAGESIZE,\nROUNDUP_PAGESIZE_IF_MMAP): Rename argument to \"lb\".\n* include/private/gc_priv.h (OBJ_SZ_TO_BLOCKS_CHECKED): New macro.\n* include/private/gcconfig.h (GC_win32_get_mem, GC_wince_get_mem,\nGC_unix_get_mem): Change argument type from word to int.\n* os_dep.c (GC_unix_mmap_get_mem, GC_unix_get_mem,\nGC_unix_sbrk_get_mem, GC_wince_get_mem, GC_win32_get_mem): Likewise.\n* malloc.c (GC_alloc_large_and_clear): Call OBJ_SZ_TO_BLOCKS only\nif no value wrap around is guaranteed.\n* malloc.c (GC_generic_malloc): Do not check for lb_rounded < lb case\n(because ROUNDED_UP_GRANULES and GRANULES_TO_BYTES guarantees no value\nwrap around).\n* mallocx.c (GC_generic_malloc_ignore_off_page): Likewise.\n* misc.c (GC_init_size_map): Change \"i\" local variable type from int\nto size_t.\n* os_dep.c (GC_write_fault_handler, catch_exception_raise): Likewise.\n* misc.c (GC_envfile_init): Cast len to size_t when passed to\nROUNDUP_PAGESIZE_IF_MMAP.\n* os_dep.c (GC_setpagesize): Cast GC_sysinfo.dwPageSize and\nGETPAGESIZE() to size_t (when setting GC_page_size).\n* os_dep.c (GC_unix_mmap_get_mem):\nExpand ROUNDUP_PAGESIZE macro but without value wrap-around checking\n(the argument is of word type).\n* os_dep.c (GC_unix_mmap_get_mem): Replace -GC_page_size with\n~GC_page_size+1 (because GC_page_size is unsigned); remove redundant\ncast to size_t.\n* os_dep.c (GC_unix_sbrk_get_mem): Add explicit cast of GC_page_size\nto SBRK_ARG_T.\n* os_dep.c (GC_wince_get_mem): Change type of res_bytes local variable\nto size_t.\n* typd_mlc.c: Do not include limits.h.\n* typd_mlc.c (GC_SIZE_MAX, GC_SQRT_SIZE_MAX): Remove (as defined in\ngc_priv.h now).",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "os_dep.c",
  "func_name": "GC_unix_mmap_get_mem",
  "func_before": "STATIC ptr_t GC_unix_mmap_get_mem(word bytes)\n{\n    void *result;\n    static ptr_t last_addr = HEAP_START;\n\n#   ifndef USE_MMAP_ANON\n      static GC_bool initialized = FALSE;\n\n      if (!initialized) {\n          zero_fd = open(\"/dev/zero\", O_RDONLY);\n          if (zero_fd == -1)\n            ABORT(\"Could not open /dev/zero\");\n\n          fcntl(zero_fd, F_SETFD, FD_CLOEXEC);\n          initialized = TRUE;\n      }\n#   endif\n\n    if (bytes & (GC_page_size - 1)) ABORT(\"Bad GET_MEM arg\");\n    result = mmap(last_addr, bytes, (PROT_READ | PROT_WRITE)\n                                    | (GC_pages_executable ? PROT_EXEC : 0),\n                  GC_MMAP_FLAGS | OPT_MAP_ANON, zero_fd, 0/* offset */);\n#   undef IGNORE_PAGES_EXECUTABLE\n\n    if (result == MAP_FAILED) return(0);\n    last_addr = (ptr_t)result + bytes + GC_page_size - 1;\n    last_addr = (ptr_t)((word)last_addr & ~(GC_page_size - 1));\n#   if !defined(LINUX)\n      if (last_addr == 0) {\n        /* Oops.  We got the end of the address space.  This isn't      */\n        /* usable by arbitrary C code, since one-past-end pointers      */\n        /* don't work, so we discard it and try again.                  */\n        munmap(result, (size_t)(-GC_page_size) - (size_t)result);\n                        /* Leave last page mapped, so we can't repeat.  */\n        return GC_unix_mmap_get_mem(bytes);\n      }\n#   else\n      GC_ASSERT(last_addr != 0);\n#   endif\n    return((ptr_t)result);\n}",
  "func_after": "STATIC ptr_t GC_unix_mmap_get_mem(size_t bytes)\n{\n    void *result;\n    static ptr_t last_addr = HEAP_START;\n\n#   ifndef USE_MMAP_ANON\n      static GC_bool initialized = FALSE;\n\n      if (!initialized) {\n          zero_fd = open(\"/dev/zero\", O_RDONLY);\n          if (zero_fd == -1)\n            ABORT(\"Could not open /dev/zero\");\n\n          fcntl(zero_fd, F_SETFD, FD_CLOEXEC);\n          initialized = TRUE;\n      }\n#   endif\n\n    if (bytes & (GC_page_size - 1)) ABORT(\"Bad GET_MEM arg\");\n    result = mmap(last_addr, bytes, (PROT_READ | PROT_WRITE)\n                                    | (GC_pages_executable ? PROT_EXEC : 0),\n                  GC_MMAP_FLAGS | OPT_MAP_ANON, zero_fd, 0/* offset */);\n#   undef IGNORE_PAGES_EXECUTABLE\n\n    if (result == MAP_FAILED) return(0);\n    last_addr = (ptr_t)result + bytes + GC_page_size - 1;\n    last_addr = (ptr_t)((word)last_addr & ~(GC_page_size - 1));\n#   if !defined(LINUX)\n      if (last_addr == 0) {\n        /* Oops.  We got the end of the address space.  This isn't      */\n        /* usable by arbitrary C code, since one-past-end pointers      */\n        /* don't work, so we discard it and try again.                  */\n        munmap(result, ~GC_page_size - (size_t)result + 1);\n                        /* Leave last page mapped, so we can't repeat.  */\n        return GC_unix_mmap_get_mem(bytes);\n      }\n#   else\n      GC_ASSERT(last_addr != 0);\n#   endif\n    return((ptr_t)result);\n}",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2035 +2035 @@\n-STATIC ptr_t GC_unix_mmap_get_mem(word bytes)\n+STATIC ptr_t GC_unix_mmap_get_mem(size_t bytes)\n {\n void *result;\n static ptr_t last_addr = HEAP_START;",
  "diff_source": "api",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing integer overflow in memory allocation functions, which could be exploited to cause system instability or unauthorized access.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}