{
  "id": 3827,
  "language": "C/C++",
  "commit_url": "https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7",
  "commit_sha": "1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7",
  "commit_msg": "Avoid integer overflows in SETRANGE and SORT (CVE-2022-35977) (#11720)\n\nAuthenticated users issuing specially crafted SETRANGE and SORT(_RO)\r\ncommands can trigger an integer overflow, resulting with Redis attempting\r\nto allocate impossible amounts of memory and abort with an OOM panic.",
  "pr_url": "https://github.com/redis/redis/pull/11720",
  "pr_info": "Authenticated users issuing specially crafted SETRANGE and SORT(_RO) commands can trigger an integer overflow, resulting with Redis attempting to allocate impossible amounts of memory and abort with an OOM panic.",
  "file_name": "src/t_string.c",
  "func_name": "appendCommand",
  "func_before": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}",
  "func_after": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}",
  "diff_func": "--- func_before\n+++ func_after\n void appendCommand(client *c) {\n     size_t totlen;\n     robj *o, *append;\n \n     o = lookupKeyWrite(c->db,c->argv[1]);\n     if (o == NULL) {\n         /* Create the key */\n         c->argv[2] = tryObjectEncoding(c->argv[2]);\n         dbAdd(c->db,c->argv[1],c->argv[2]);\n         incrRefCount(c->argv[2]);\n         totlen = stringObjectLen(c->argv[2]);\n     } else {\n         /* Key exists, check type */\n         if (checkType(c,o,OBJ_STRING))\n             return;\n \n         /* \"append\" is an argument, so always an sds */\n         append = c->argv[2];\n+        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n-        totlen = stringObjectLen(o)+sdslen(append->ptr);\n-        if (checkStringLength(c,totlen) != C_OK)\n             return;\n \n         /* Append the value */\n         o = dbUnshareStringValue(c->db,c->argv[1],o);\n         o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n         totlen = sdslen(o->ptr);\n     }\n     signalModifiedKey(c,c->db,c->argv[1]);\n     notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n     server.dirty++;\n     addReplyLongLong(c,totlen);\n }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95\n\n**Step-by-Step Explanation:**\n1. **Commit Message Analysis:** The message mentions a CVE and describes an exploit leading to memory issues, indicating a security concern.\n2. **Code Diff Review:** The changes introduce checks for string lengths to prevent integer overflows, directly addressing a security flaw.\n3. **Security Impact:** The vulnerability could cause system crashes, affecting availability, a key security aspect.\n4. **Confidence:** High due to clear evidence of a security fix in both message and code.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses an integer overflow vulnerability in Redis commands, which could lead to memory exhaustion and system crashes. The code changes include checks to prevent such overflows, aligning with security fixes.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95\n\n**Step-by-Step Explanation:**\n1. **Commit Message Analysis:** The message mentions a CVE and describes an exploit leading to memory issues, indicating a security concern.\n2. **Code Diff Review:** The changes introduce checks for string lengths to prevent integer overflows, directly addressing a security flaw.\n3. **Security Impact:** The vulnerability could cause system crashes, affecting availability, a key security aspect.\n4. **Confidence:** High due to clear evidence of a security fix in both message and code.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}