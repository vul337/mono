{
  "id": 4469,
  "language": "Python",
  "commit_url": "https://github.com/ansible/ansible-modules-extras/commit/8c6fe646ee79f5e55361b885b7efed5bec72d4a4",
  "commit_sha": "8c6fe646ee79f5e55361b885b7efed5bec72d4a4",
  "commit_msg": "CVE-2016-3096: do not use predictable paths in lxc_container\n\n* do not use a predictable filename for the LXC attach script\n* don't use predictable filenames for LXC attach script logging\n* don't set a predictable archive_path\n\nthis should prevent symlink attacks which could result in\n* data corruption\n* data leakage\n* privilege escalation",
  "pr_url": "https://github.com/ansible/ansible-modules-extras/pull/1941",
  "pr_info": "##### ISSUE TYPE\n- Bugfix Pull Request\n##### COMPONENT NAME\n\nlxc_container\n##### ANSIBLE VERSION\n\nGit\n##### SUMMARY\n\nThe attach script of the LXC module currently uses predictable names, allowing symlink attacks.\nUsing mkstemp and not NamedTempFile to keep Py 2.4 compat :(\n\nCVE-2016-3096\n\nPoC:\n\n```\nroot@container:/# cd /opt/\nroot@container:/opt# echo foo > foo\nroot@container:/opt# ln -s foo .lxc-attach-script\nroot@container:/opt# ls -alh\ntotal 12K\ndrwxr-xr-x  2 root root 4.0K Apr  1 13:46 .\ndrwxr-xr-x 22 root root 4.0K Apr  1 13:39 ..\nlrwxrwxrwx  1 root root    3 Apr  1 13:46 .lxc-attach-script -> foo\n-rw-r--r--  1 root root    4 Apr  1 13:46 foo\nroot@container:/opt# cat foo \nfoo\n\n# run ansible with \"container_command: echo bar\"\n\nroot@container:/opt# cat foo \n#!/usr/bin/env bash\npushd \"$(grep $(whoami) /etc/passwd | awk -F':' '{print $6}')\"\n    if [[ -f \".bashrc\" ]];then\n        source .bashrc\n    fi\npopd\n\n# User defined command\necho bar\n```\n",
  "file_name": "cloud/lxc/lxc_container.py",
  "func_name": "main",
  "func_before": "def main():\n    \"\"\"Ansible Main module.\"\"\"\n\n    module = AnsibleModule(\n        argument_spec=dict(\n            name=dict(\n                type='str',\n                required=True\n            ),\n            template=dict(\n                type='str',\n                default='ubuntu'\n            ),\n            backing_store=dict(\n                type='str',\n                choices=LXC_BACKING_STORE.keys(),\n                default='dir'\n            ),\n            template_options=dict(\n                type='str'\n            ),\n            config=dict(\n                type='str',\n            ),\n            vg_name=dict(\n                type='str',\n                default='lxc'\n            ),\n            thinpool=dict(\n                type='str'\n            ),\n            fs_type=dict(\n                type='str',\n                default='ext4'\n            ),\n            fs_size=dict(\n                type='str',\n                default='5G'\n            ),\n            directory=dict(\n                type='str'\n            ),\n            zfs_root=dict(\n                type='str'\n            ),\n            lv_name=dict(\n                type='str'\n            ),\n            lxc_path=dict(\n                type='str'\n            ),\n            state=dict(\n                choices=LXC_ANSIBLE_STATES.keys(),\n                default='started'\n            ),\n            container_command=dict(\n                type='str'\n            ),\n            container_config=dict(\n                type='str'\n            ),\n            container_log=dict(\n                type='bool',\n                default='false'\n            ),\n            container_log_level=dict(\n                choices=[n for i in LXC_LOGGING_LEVELS.values() for n in i],\n                default='INFO'\n            ),\n            clone_name=dict(\n                type='str',\n                required=False\n            ),\n            clone_snapshot=dict(\n                type='bool',\n                default='false'\n            ),\n            archive=dict(\n                type='bool',\n                default='false'\n            ),\n            archive_path=dict(\n                type='str',\n                default='/tmp'\n            ),\n            archive_compression=dict(\n                choices=LXC_COMPRESSION_MAP.keys(),\n                default='gzip'\n            )\n        ),\n        supports_check_mode=False,\n    )\n\n    if not HAS_LXC:\n        module.fail_json(\n            msg='The `lxc` module is not importable. Check the requirements.'\n        )\n\n    lv_name = module.params.get('lv_name')\n    if not lv_name:\n        module.params['lv_name'] = module.params.get('name')\n\n    lxc_manage = LxcContainerManagement(module=module)\n    lxc_manage.run()",
  "func_after": "def main():\n    \"\"\"Ansible Main module.\"\"\"\n\n    module = AnsibleModule(\n        argument_spec=dict(\n            name=dict(\n                type='str',\n                required=True\n            ),\n            template=dict(\n                type='str',\n                default='ubuntu'\n            ),\n            backing_store=dict(\n                type='str',\n                choices=LXC_BACKING_STORE.keys(),\n                default='dir'\n            ),\n            template_options=dict(\n                type='str'\n            ),\n            config=dict(\n                type='str',\n            ),\n            vg_name=dict(\n                type='str',\n                default='lxc'\n            ),\n            thinpool=dict(\n                type='str'\n            ),\n            fs_type=dict(\n                type='str',\n                default='ext4'\n            ),\n            fs_size=dict(\n                type='str',\n                default='5G'\n            ),\n            directory=dict(\n                type='str'\n            ),\n            zfs_root=dict(\n                type='str'\n            ),\n            lv_name=dict(\n                type='str'\n            ),\n            lxc_path=dict(\n                type='str'\n            ),\n            state=dict(\n                choices=LXC_ANSIBLE_STATES.keys(),\n                default='started'\n            ),\n            container_command=dict(\n                type='str'\n            ),\n            container_config=dict(\n                type='str'\n            ),\n            container_log=dict(\n                type='bool',\n                default='false'\n            ),\n            container_log_level=dict(\n                choices=[n for i in LXC_LOGGING_LEVELS.values() for n in i],\n                default='INFO'\n            ),\n            clone_name=dict(\n                type='str',\n                required=False\n            ),\n            clone_snapshot=dict(\n                type='bool',\n                default='false'\n            ),\n            archive=dict(\n                type='bool',\n                default='false'\n            ),\n            archive_path=dict(\n                type='str',\n            ),\n            archive_compression=dict(\n                choices=LXC_COMPRESSION_MAP.keys(),\n                default='gzip'\n            )\n        ),\n        supports_check_mode=False,\n        required_if = ([\n            ('archive', True, ['archive_path'])\n        ]),\n    )\n\n    if not HAS_LXC:\n        module.fail_json(\n            msg='The `lxc` module is not importable. Check the requirements.'\n        )\n\n    lv_name = module.params.get('lv_name')\n    if not lv_name:\n        module.params['lv_name'] = module.params.get('name')\n\n    lxc_manage = LxcContainerManagement(module=module)\n    lxc_manage.run()",
  "diff_func": "--- func_before\n+++ func_after\n def main():\n     \"\"\"Ansible Main module.\"\"\"\n \n     module = AnsibleModule(\n         argument_spec=dict(\n             name=dict(\n                 type='str',\n                 required=True\n             ),\n             template=dict(\n                 type='str',\n                 default='ubuntu'\n             ),\n             backing_store=dict(\n                 type='str',\n                 choices=LXC_BACKING_STORE.keys(),\n                 default='dir'\n             ),\n             template_options=dict(\n                 type='str'\n             ),\n             config=dict(\n                 type='str',\n             ),\n             vg_name=dict(\n                 type='str',\n                 default='lxc'\n             ),\n             thinpool=dict(\n                 type='str'\n             ),\n             fs_type=dict(\n                 type='str',\n                 default='ext4'\n             ),\n             fs_size=dict(\n                 type='str',\n                 default='5G'\n             ),\n             directory=dict(\n                 type='str'\n             ),\n             zfs_root=dict(\n                 type='str'\n             ),\n             lv_name=dict(\n                 type='str'\n             ),\n             lxc_path=dict(\n                 type='str'\n             ),\n             state=dict(\n                 choices=LXC_ANSIBLE_STATES.keys(),\n                 default='started'\n             ),\n             container_command=dict(\n                 type='str'\n             ),\n             container_config=dict(\n                 type='str'\n             ),\n             container_log=dict(\n                 type='bool',\n                 default='false'\n             ),\n             container_log_level=dict(\n                 choices=[n for i in LXC_LOGGING_LEVELS.values() for n in i],\n                 default='INFO'\n             ),\n             clone_name=dict(\n                 type='str',\n                 required=False\n             ),\n    ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis:**\n   - The commit message references a CVE, indicating a security issue.\n   - The message details changes to prevent predictable paths, mitigating symlink attacks.\n\n2. **Security Vulnerability Assessment:**\n   - The patch aims to fix a security vulnerability by preventing attacks that compromise confidentiality, integrity, and availability.\n\n3. **Classification:**\n   - Despite the code diff not showing changes, the commit message clearly indicates a security fix.\n\n4. **Confidence Scoring:**\n   - High confidence due to the explicit mention of a security vulnerability in the commit message.\n\n**Final Output:**\nAnalysis: The patch addresses a security vulnerability (CVE-2016-3096) by preventing symlink attacks, as indicated by the commit message. The code diff doesn't show the changes, but the commit message is explicit about the security fix.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.9",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\nThe commit message clearly indicates that the patch addresses a security vulnerability (CVE-2016-3096) by preventing symlink attacks, which could lead to data corruption, leakage, or privilege escalation. The code diff provided doesn't show the specific security-related changes but the commit message strongly suggests a security fix.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis:**\n   - The commit message references a CVE, indicating a security issue.\n   - The message details changes to prevent predictable paths, mitigating symlink attacks.\n\n2. **Security Vulnerability Assessment:**\n   - The patch aims to fix a security vulnerability by preventing attacks that compromise confidentiality, integrity, and availability.\n\n3. **Classification:**\n   - Despite the code diff not showing changes, the commit message clearly indicates a security fix.\n\n4. **Confidence Scoring:**\n   - High confidence due to the explicit mention of a security vulnerability in the commit message.\n\n**Final Output:**\nAnalysis: The patch addresses a security vulnerability (CVE-2016-3096) by preventing symlink attacks, as indicated by the commit message. The code diff doesn't show the changes, but the commit message is explicit about the security fix.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.9"
}