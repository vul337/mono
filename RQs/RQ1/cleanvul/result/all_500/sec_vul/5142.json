{
  "id": 5142,
  "language": "C/C++",
  "commit_url": "https://github.com/uclouvain/openjpeg/commit/c277159986c80142180fbe5efb256bbf3bdf3edc",
  "commit_sha": "c277159986c80142180fbe5efb256bbf3bdf3edc",
  "commit_msg": "[MJ2] Avoid index out of bounds access to pi->include[]\n\nSigned-off-by: Young_X <YangX92@hotmail.com>",
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/1168",
  "pr_info": "Fix multiple potential vulnerabilities and bugs",
  "file_name": "src/lib/openmj2/pi.c",
  "func_name": "pi_next_rlcp",
  "func_before": "static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                    index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                            pi->step_c + pi->precno * pi->step_p;\n                    if (!pi->include[index]) {\n                        pi->include[index] = 1;\n                        return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}",
  "func_after": "static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                    index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                            pi->step_c + pi->precno * pi->step_p;\n                    /* Avoids index out of bounds access with include*/\n                    if (index >= pi->include_size) {\n                        opj_pi_emit_error(pi, \"Invalid access to pi->include\");\n                        return OPJ_FALSE;\n                    }\n                    if (!pi->include[index]) {\n                        pi->include[index] = 1;\n                        return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)\n {\n     opj_pi_comp_t *comp = NULL;\n     opj_pi_resolution_t *res = NULL;\n     long index = 0;\n \n     if (!pi->first) {\n         comp = &pi->comps[pi->compno];\n         res = &comp->resolutions[pi->resno];\n         goto LABEL_SKIP;\n     } else {\n         pi->first = 0;\n     }\n \n     for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n         for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n             for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                 comp = &pi->comps[pi->compno];\n                 if (pi->resno >= comp->numresolutions) {\n                     continue;\n                 }\n                 res = &comp->resolutions[pi->resno];\n                 if (!pi->tp_on) {\n                     pi->poc.precno1 = res->pw * res->ph;\n                 }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n+                    /* Avoids index out of bounds access with include*/\n+                    if (index >= pi->include_size) {\n+                        opj_pi_emit_error(pi, \"Invalid access to pi->include\");\n+                        return OPJ_FALSE;\n+                    }\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                     }\n LABEL_SKIP:\n                     ;\n                 }\n             }\n         }\n     }\n \n     return OPJ_FALSE;\n }",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an out-of-bounds array access, which is a security concern. The added check prevents potential buffer overflow attacks, thus mitigating a security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}