{
  "id": 2974,
  "language": "Java",
  "commit_url": "https://github.com/AOSPA/android_frameworks_base/commit/d4c436d9492ff10672fde6ccc5488a7094474074",
  "commit_sha": "d4c436d9492ff10672fde6ccc5488a7094474074",
  "commit_msg": "Only allow system to apply relinquishTaskIdentity\n\nAny malicious application could hijack tasks by\nandroid:relinquishTaskIdentity. This vulnerability can perform UI\nspoofing or spy on userâ€™s activities.\n\nThis CL limit the usage which only allow system to apply\nrelinquishTaskIdentity\n\nBug: 185810717\nTest: atest IntentTests\n      atest ActivityStarterTests\n      atest com.android.server.wm.TaskTests\nChange-Id: Iddbb9c04237fdc8bdc0c2223ee597f43f37cb178",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/wm/Task.java",
  "func_name": "setIntent",
  "func_before": "private void setIntent(Intent _intent, ActivityInfo info) {\n        if (!isLeafTask()) return;\n\n        mNeverRelinquishIdentity = (info.flags & FLAG_RELINQUISH_TASK_IDENTITY) == 0;\n        affinity = info.taskAffinity;\n        if (intent == null) {\n            // If this task already has an intent associated with it, don't set the root\n            // affinity -- we don't want it changing after initially set, but the initially\n            // set value may be null.\n            rootAffinity = affinity;\n        }\n        effectiveUid = info.applicationInfo.uid;\n        stringName = null;\n\n        if (info.targetActivity == null) {\n            if (_intent != null) {\n                // If this Intent has a selector, we want to clear it for the\n                // recent task since it is not relevant if the user later wants\n                // to re-launch the app.\n                if (_intent.getSelector() != null || _intent.getSourceBounds() != null) {\n                    _intent = new Intent(_intent);\n                    _intent.setSelector(null);\n                    _intent.setSourceBounds(null);\n                }\n            }\n            ProtoLog.v(WM_DEBUG_TASKS, \"Setting Intent of %s to %s\", this, _intent);\n            intent = _intent;\n            realActivity = _intent != null ? _intent.getComponent() : null;\n            origActivity = null;\n        } else {\n            ComponentName targetComponent = new ComponentName(\n                    info.packageName, info.targetActivity);\n            if (_intent != null) {\n                Intent targetIntent = new Intent(_intent);\n                targetIntent.setSelector(null);\n                targetIntent.setSourceBounds(null);\n                ProtoLog.v(WM_DEBUG_TASKS, \"Setting Intent of %s to target %s\", this, targetIntent);\n                intent = targetIntent;\n                realActivity = targetComponent;\n                origActivity = _intent.getComponent();\n            } else {\n                intent = null;\n                realActivity = targetComponent;\n                origActivity = new ComponentName(info.packageName, info.name);\n            }\n        }\n        mWindowLayoutAffinity =\n                info.windowLayout == null ? null : info.windowLayout.windowLayoutAffinity;\n\n        final int intentFlags = intent == null ? 0 : intent.getFlags();\n        if ((intentFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {\n            // Once we are set to an Intent with this flag, we count this\n            // task as having a true root activity.\n            rootWasReset = true;\n        }\n        mUserId = UserHandle.getUserId(info.applicationInfo.uid);\n        mUserSetupComplete = Settings.Secure.getIntForUser(\n                mAtmService.mContext.getContentResolver(), USER_SETUP_COMPLETE, 0, mUserId) != 0;\n        if ((info.flags & ActivityInfo.FLAG_AUTO_REMOVE_FROM_RECENTS) != 0) {\n            // If the activity itself has requested auto-remove, then just always do it.\n            autoRemoveRecents = true;\n        } else if ((intentFlags & (FLAG_ACTIVITY_NEW_DOCUMENT | FLAG_ACTIVITY_RETAIN_IN_RECENTS))\n                == FLAG_ACTIVITY_NEW_DOCUMENT) {\n            // If the caller has not asked for the document to be retained, then we may\n            // want to turn on auto-remove, depending on whether the target has set its\n            // own document launch mode.\n            if (info.documentLaunchMode != ActivityInfo.DOCUMENT_LAUNCH_NONE) {\n                autoRemoveRecents = false;\n            } else {\n                autoRemoveRecents = true;\n            }\n        } else {\n            autoRemoveRecents = false;\n        }\n        if (mResizeMode != info.resizeMode) {\n            mResizeMode = info.resizeMode;\n            updateTaskDescription();\n        }\n        mSupportsPictureInPicture = info.supportsPictureInPicture();\n    }",
  "func_after": "private void setIntent(Intent _intent, ActivityInfo info) {\n        if (!isLeafTask()) return;\n\n        if (info.applicationInfo.uid == Process.SYSTEM_UID\n                || info.applicationInfo.isSystemApp()) {\n            // Only allow the apps that pre-installed on the system image to apply\n            // relinquishTaskIdentity\n            mNeverRelinquishIdentity = (info.flags & FLAG_RELINQUISH_TASK_IDENTITY) == 0;\n        } else {\n            mNeverRelinquishIdentity = true;\n        }\n        affinity = info.taskAffinity;\n        if (intent == null) {\n            // If this task already has an intent associated with it, don't set the root\n            // affinity -- we don't want it changing after initially set, but the initially\n            // set value may be null.\n            rootAffinity = affinity;\n        }\n        effectiveUid = info.applicationInfo.uid;\n        stringName = null;\n\n        if (info.targetActivity == null) {\n            if (_intent != null) {\n                // If this Intent has a selector, we want to clear it for the\n                // recent task since it is not relevant if the user later wants\n                // to re-launch the app.\n                if (_intent.getSelector() != null || _intent.getSourceBounds() != null) {\n                    _intent = new Intent(_intent);\n                    _intent.setSelector(null);\n                    _intent.setSourceBounds(null);\n                }\n            }\n            ProtoLog.v(WM_DEBUG_TASKS, \"Setting Intent of %s to %s\", this, _intent);\n            intent = _intent;\n            realActivity = _intent != null ? _intent.getComponent() : null;\n            origActivity = null;\n        } else {\n            ComponentName targetComponent = new ComponentName(\n                    info.packageName, info.targetActivity);\n            if (_intent != null) {\n                Intent targetIntent = new Intent(_intent);\n                targetIntent.setSelector(null);\n                targetIntent.setSourceBounds(null);\n                ProtoLog.v(WM_DEBUG_TASKS, \"Setting Intent of %s to target %s\", this, targetIntent);\n                intent = targetIntent;\n                realActivity = targetComponent;\n                origActivity = _intent.getComponent();\n            } else {\n                intent = null;\n                realActivity = targetComponent;\n                origActivity = new ComponentName(info.packageName, info.name);\n            }\n        }\n        mWindowLayoutAffinity =\n                info.windowLayout == null ? null : info.windowLayout.windowLayoutAffinity;\n\n        final int intentFlags = intent == null ? 0 : intent.getFlags();\n        if ((intentFlags & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {\n            // Once we are set to an Intent with this flag, we count this\n            // task as having a true root activity.\n            rootWasReset = true;\n        }\n        mUserId = UserHandle.getUserId(info.applicationInfo.uid);\n        mUserSetupComplete = Settings.Secure.getIntForUser(\n                mAtmService.mContext.getContentResolver(), USER_SETUP_COMPLETE, 0, mUserId) != 0;\n        if ((info.flags & ActivityInfo.FLAG_AUTO_REMOVE_FROM_RECENTS) != 0) {\n            // If the activity itself has requested auto-remove, then just always do it.\n            autoRemoveRecents = true;\n        } else if ((intentFlags & (FLAG_ACTIVITY_NEW_DOCUMENT | FLAG_ACTIVITY_RETAIN_IN_RECENTS))\n                == FLAG_ACTIVITY_NEW_DOCUMENT) {\n            // If the caller has not asked for the document to be retained, then we may\n            // want to turn on auto-remove, depending on whether the target has set its\n            // own document launch mode.\n            if (info.documentLaunchMode != ActivityInfo.DOCUMENT_LAUNCH_NONE) {\n                autoRemoveRecents = false;\n            } else {\n                autoRemoveRecents = true;\n            }\n        } else {\n            autoRemoveRecents = false;\n        }\n        if (mResizeMode != info.resizeMode) {\n            mResizeMode = info.resizeMode;\n            updateTaskDescription();\n        }\n        mSupportsPictureInPicture = info.supportsPictureInPicture();\n    }",
  "diff_func": "--- func_before\n+++ func_after\n private void setIntent(Intent _intent, ActivityInfo info) {\n         if (!isLeafTask()) return;\n \n+        if (info.applicationInfo.uid == Process.SYSTEM_UID\n+                || info.applicationInfo.isSystemApp()) {\n+            // Only allow the apps that pre-installed on the system image to apply\n+            // relinquishTaskIdentity\n-        mNeverRelinquishIdentity = (info.flags & FLAG_RELINQUISH_TASK_IDENTITY) == 0;\n+            mNeverRelinquishIdentity = (info.flags & FLAG_RELINQUISH_TASK_IDENTITY) == 0;\n+        } else {\n+            mNeverRelinquishIdentity = true;\n+        }\n         affinity = info.taskAffinity;\n         if (intent == null) {\n             // If this task already has an intent associated with it, don't set the root\n             // affinity -- we don't want it changing after initially set, but the initially\n             // set value may be null.\n             rootAffinity = affinity;\n         }\n         effectiveUid = info.applicationInfo.uid;\n         stringName = null;\n \n         if (info.targetActivity == null) {\n             if (_intent != null) {\n                 // If this Intent has a selector, we want to clear it for the\n                 // recent task since it is not relevant if the user later wants\n                 // to re-launch the app.\n                 if (_intent.getSelector() != null || _intent.getSourceBounds() != null) {\n                     _intent = new Intent(_intent);\n                     _intent.setSelector(null);\n                     _intent.setSourceBounds(null);\n                 }\n             }\n             ProtoLog.v(WM_DEBUG_TASKS, \"Setting Intent of %s to %s\", this, _intent);\n             intent = _intent;\n             realActivity = _intent != null ? _intent.getComponent() : null;\n             origActivity = null;\n         } else {\n             ComponentName targetComponent = new ComponentName(\n                     info.packageName, info.targetActivity);\n             if (_intent ",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n- The commit message clearly indicates the intention to fix a security vulnerability where malicious applications could hijack tasks using android:relinquishTaskIdentity. This could lead to UI spoofing or spying on user activities, which are security issues.\n- The code changes introduce a condition that allows only system UID or system apps to apply relinquishTaskIdentity, thereby restricting the usage to prevent potential attacks.\n- The primary purpose of the patch is to address a security vulnerability by limiting the use of a specific feature to system components.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}