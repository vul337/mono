{
  "id": 377,
  "language": "Java",
  "commit_url": "https://github.com/aosp-mirror/platform_frameworks_base/commit/6b86ed849780dedd0f9319833e53bb194d74fefa",
  "commit_sha": "6b86ed849780dedd0f9319833e53bb194d74fefa",
  "commit_msg": "[RESTRICT AUTOMERGE] Revert \"Don't abandon child sessions (1/n)\"\n\nRevert submission 16575908-dont_abandon_child_qt_dev\n\nReason for revert:  Reverting CVE-2021-39624 on qt-dev\nReverted Changes:\nI4ede6b7a4:Persist destroyed staged sessions until they are c...\nIb0ba9f378:Don't abandon child sessions (1/n)\n\nChange-Id: I7915e3f0ba6dd8430a9b938a518aeeeb4d6b1805",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/pm/PackageInstallerService.java",
  "func_name": "freeStageDirs",
  "func_before": "public void freeStageDirs(String volumeUuid) {\n        final ArraySet<File> unclaimedStagingDirsOnVolume = getStagingDirsOnVolume(volumeUuid);\n        final long currentTimeMillis = System.currentTimeMillis();\n        synchronized (mSessions) {\n            for (int i = 0; i < mSessions.size(); i++) {\n                final PackageInstallerSession session = mSessions.valueAt(i);\n                if (!unclaimedStagingDirsOnVolume.contains(session.stageDir)) {\n                    // Only handles sessions stored on the target volume\n                    continue;\n                }\n                final long age = currentTimeMillis - session.createdMillis;\n                if (age >= MAX_SESSION_AGE_ON_LOW_STORAGE_MILLIS) {\n                    // Aggressively close old sessions because we are running low on storage\n                    // Their staging dirs will be removed too\n                    PackageInstallerSession root = !session.hasParentSessionId()\n                            ? session : mSessions.get(session.getParentSessionId());\n                    if (!root.isDestroyed() && \n                            (!root.isStaged() || (root.isStaged() && root.isStagedSessionReady()))) \n                    {\n                        root.abandon();\n                    }\n                } else {\n                    // Session is new enough, so it deserves to be kept even on low storage\n                    unclaimedStagingDirsOnVolume.remove(session.stageDir);\n                }\n            }\n        }\n        removeStagingDirs(unclaimedStagingDirsOnVolume);\n    }",
  "func_after": "public void freeStageDirs(String volumeUuid) {\n        final ArraySet<File> unclaimedStagingDirsOnVolume = getStagingDirsOnVolume(volumeUuid);\n        final long currentTimeMillis = System.currentTimeMillis();\n        synchronized (mSessions) {\n            for (int i = 0; i < mSessions.size(); i++) {\n                final PackageInstallerSession session = mSessions.valueAt(i);\n                if (!unclaimedStagingDirsOnVolume.contains(session.stageDir)) {\n                    // Only handles sessions stored on the target volume\n                    continue;\n                }\n                final long age = currentTimeMillis - session.createdMillis;\n                if (age >= MAX_SESSION_AGE_ON_LOW_STORAGE_MILLIS) {\n                    // Aggressively close old sessions because we are running low on storage\n                    // Their staging dirs will be removed too\n                    session.abandon();\n                } else {\n                    // Session is new enough, so it deserves to be kept even on low storage\n                    unclaimedStagingDirsOnVolume.remove(session.stageDir);\n                }\n            }\n        }\n        removeStagingDirs(unclaimedStagingDirsOnVolume);\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public void freeStageDirs(String volumeUuid) {\n         final ArraySet<File> unclaimedStagingDirsOnVolume = getStagingDirsOnVolume(volumeUuid);\n         final long currentTimeMillis = System.currentTimeMillis();\n         synchronized (mSessions) {\n             for (int i = 0; i < mSessions.size(); i++) {\n                 final PackageInstallerSession session = mSessions.valueAt(i);\n                 if (!unclaimedStagingDirsOnVolume.contains(session.stageDir)) {\n                     // Only handles sessions stored on the target volume\n                     continue;\n                 }\n                 final long age = currentTimeMillis - session.createdMillis;\n                 if (age >= MAX_SESSION_AGE_ON_LOW_STORAGE_MILLIS) {\n                     // Aggressively close old sessions because we are running low on storage\n                     // Their staging dirs will be removed too\n-                    PackageInstallerSession root = !session.hasParentSessionId()\n-                            ? session : mSessions.get(session.getParentSessionId());\n-                    if (!root.isDestroyed() && \n-                            (!root.isStaged() || (root.isStaged() && root.isStagedSessionReady()))) \n-                    {\n-                        root.abandon();\n+                    session.abandon();\n-                    }\n                 } else {\n                     // Session is new enough, so it deserves to be kept even on low storage\n                     unclaimedStagingDirsOnVolume.remove(session.stageDir);\n                 }\n             }\n         }\n         removeStagingDirs(unclaimedStagingDirsOnVolume);\n     }",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The commit reverts a change related to a known security vulnerability (CVE-2021-39624), indicating the patch addresses a security issue. The code change modifies session abandonment logic, which could affect security by preventing improper handling of sessions that might lead to unauthorized access or data exposure.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}