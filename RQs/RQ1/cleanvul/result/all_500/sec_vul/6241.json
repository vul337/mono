{
  "id": 6241,
  "language": "C/C++",
  "commit_url": "https://github.com/asterisk/asterisk/commit/d7d7764cb07c8a1872804321302ef93bf62cba05",
  "commit_sha": "d7d7764cb07c8a1872804321302ef93bf62cba05",
  "commit_msg": "res_rtp_asterisk.c: Check DTLS packets against ICE candidate list\n\nWhen ICE is in use, we can prevent a possible DOS attack by allowing\nDTLS protocol messages (client hello, etc) only from sources that\nare in the active remote candidates list.\n\nResolves: GHSA-hxj9-xwr8-w8pq",
  "pr_url": "https://github.com/asterisk/asterisk/pull/495",
  "pr_info": "When ICE is in use, we can prevent a possible DOS attack by allowing\nDTLS protocol messages (client hello, etc) only from sources that\nare in the active remote candidates list.\n\nResolves: GHSA-hxj9-xwr8-w8pq\n",
  "file_name": "res/res_rtp_asterisk.c",
  "func_name": "__rtp_recvfrom",
  "func_before": "static int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp)\n{\n\tint len;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tchar *in = buf;\n#endif\n#ifdef HAVE_PJPROJECT\n\tstruct ast_sockaddr *loop = rtcp ? &rtp->rtcp_loop : &rtp->rtp_loop;\n#endif\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n#endif\n\n\tif ((len = ast_recvfrom(rtcp ? rtp->rtcp->s : rtp->s, buf, size, flags, sa)) < 0) {\n\t\treturn len;\n\t}\n\n#ifdef TEST_FRAMEWORK\n\tif (test && test->packets_to_drop > 0) {\n\t\ttest->packets_to_drop--;\n\t\treturn 0;\n\t}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If this is an SSL packet pass it to OpenSSL for processing. RFC section for first byte value:\n\t * https://tools.ietf.org/html/rfc5764#section-5.1.2 */\n\tif ((*in >= 20) && (*in <= 63)) {\n\t\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\t\tint res = 0;\n\n\t\t/* If no SSL session actually exists terminate things */\n\t\tif (!dtls->ssl) {\n\t\t\tast_log(LOG_ERROR, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n\n\t\t/*\n\t\t * A race condition is prevented between dtls_perform_handshake()\n\t\t * and this function because both functions have to get the\n\t\t * instance lock before they can do anything.  The\n\t\t * dtls_perform_handshake() function needs to start the timer\n\t\t * before we stop it below.\n\t\t */\n\n\t\t/* Before we feed data into OpenSSL ensure that the timeout timer is either stopped or completed */\n\t\tao2_unlock(instance);\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, rtcp);\n\t\tao2_lock(instance);\n\n\t\t/* If we don't yet know if we are active or passive and we receive a packet... we are obviously passive */\n\t\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {\n\t\t\tdtls->dtls_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\t\tSSL_set_accept_state(dtls->ssl);\n\t\t}\n\n\t\tBIO_write(dtls->read_bio, buf, len);\n\n\t\tlen = SSL_read(dtls->ssl, buf, len);\n\n\t\tif ((len < 0) && (SSL_get_error(dtls->ssl, len) == SSL_ERROR_SSL)) {\n\t\t\tunsigned long error = ERR_get_error();\n\t\t\tast_log(LOG_ERROR, \"DTLS failure occurred on RTP instance '%p' due to reason '%s', terminating\\n\",\n\t\t\t\tinstance, ERR_reason_error_string(error));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SSL_is_init_finished(dtls->ssl)) {\n\t\t\t/* Any further connections will be existing since this is now established */\n\t\t\tdtls->connection = AST_RTP_DTLS_CONNECTION_EXISTING;\n\t\t\t/* Use the keying material to set up key/salt information */\n\t\t\tif ((res = dtls_srtp_setup(rtp, instance, rtcp))) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t/* Notify that dtls has been established */\n\t\t\tres = RTP_DTLS_ESTABLISHED;\n\n\t\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - established'\\n\", instance, rtp);\n\t\t} else {\n\t\t\t/* Since we've sent additional traffic start the timeout timer for retransmission */\n\t\t\tdtls_srtp_start_timeout_timer(instance, rtp, rtcp);\n\t\t}\n\n\t\treturn res;\n\t}\n#endif\n\n#ifdef HAVE_PJPROJECT\n\tif (!ast_sockaddr_isnull(loop) && !ast_sockaddr_cmp(loop, sa)) {\n\t\t/* ICE traffic will have been handled in the TURN callback, so skip it but update the address\n\t\t * so it reflects the actual source and not the loopback\n\t\t */\n\t\tif (rtcp) {\n\t\t\tast_sockaddr_copy(sa, &rtp->rtcp->them);\n\t\t} else {\n\t\t\tast_rtp_instance_get_remote_address(instance, sa);\n\t\t}\n\t} else if (rtp->ice) {\n\t\tpj_str_t combined = pj_str(ast_sockaddr_stringify(sa));\n\t\tpj_sockaddr address;\n\t\tpj_status_t status;\n\t\tstruct ice_wrap *ice;\n\n\t\tpj_thread_register_check();\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tao2_unlock(instance);\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice,\n\t\t\trtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,\n\t\t\trtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,\n\t\t\tpj_sockaddr_get_len(&address));\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar err_buf[100];\n\n\t\t\tpj_strerror(status, err_buf, sizeof(err_buf));\n\t\t\tast_log(LOG_WARNING, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)status, err_buf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!rtp->passthrough) {\n\t\t\t/* If a unidirectional ICE negotiation occurs then lock on to the source of the\n\t\t\t * ICE traffic and use it as the target. This will occur if the remote side only\n\t\t\t * wants to receive media but never send to us.\n\t\t\t */\n\t\t\tif (!rtp->ice_active_remote_candidates && !rtp->ice_proposed_remote_candidates) {\n\t\t\t\tif (rtcp) {\n\t\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, sa);\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_remote_address(instance, sa);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\trtp->passthrough = 0;\n\t}\n#endif\n\n\treturn len;\n}",
  "func_after": "static int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp)\n{\n\tint len;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tchar *in = buf;\n#endif\n#ifdef HAVE_PJPROJECT\n\tstruct ast_sockaddr *loop = rtcp ? &rtp->rtcp_loop : &rtp->rtp_loop;\n#endif\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n#endif\n\n\tif ((len = ast_recvfrom(rtcp ? rtp->rtcp->s : rtp->s, buf, size, flags, sa)) < 0) {\n\t\treturn len;\n\t}\n\n#ifdef TEST_FRAMEWORK\n\tif (test && test->packets_to_drop > 0) {\n\t\ttest->packets_to_drop--;\n\t\treturn 0;\n\t}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If this is an SSL packet pass it to OpenSSL for processing. RFC section for first byte value:\n\t * https://tools.ietf.org/html/rfc5764#section-5.1.2 */\n\tif ((*in >= 20) && (*in <= 63)) {\n\t\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\t\tint res = 0;\n\n\t\t/* If no SSL session actually exists terminate things */\n\t\tif (!dtls->ssl) {\n\t\t\tast_log(LOG_ERROR, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n\n\t\t/*\n\t\t * If ICE is in use, we can prevent a possible DOS attack\n\t\t * by allowing DTLS protocol messages (client hello, etc)\n\t\t * only from sources that are in the active remote\n\t\t * candidates list.\n\t\t */\n\n\t\tif (rtp->ice) {\n\t\t\tint pass_src_check = 0;\n\t\t\tstruct ao2_iterator i;\n\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n\t\t\tint cand_cnt = 0;\n\n\t\t\t/*\n\t\t\t * You'd think that this check would cause a \"deadlock\"\n\t\t\t * because ast_rtp_ice_start_media calls dtls_perform_handshake\n\t\t\t * before it sets ice_media_started = 1 so how can we do a\n\t\t\t * handshake if we're dropping packets before we send them\n\t\t\t * to openssl.  Fortunately, dtls_perform_handshake just sets\n\t\t\t * up openssl to do the handshake and doesn't actually perform it\n\t\t\t * itself and the locking prevents __rtp_recvfrom from\n\t\t\t * running before the ice_media_started flag is set.  So only\n\t\t\t * unexpected DTLS packets can get dropped here.\n\t\t\t */\n\t\t\tif (!rtp->ice_media_started) {\n\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. ICE not completed yet.\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\t\t\tast_sockaddr_stringify(sa));\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we got this far, then ice_active_remote_candidates\n\t\t\t * can't be NULL.\n\t\t\t */\n\t\t\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);\n\t\t\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {\n\t\t\t\tres = ast_sockaddr_cmp_addr(&candidate->address, sa);\n\t\t\t\tao2_ref(candidate, -1);\n\t\t\t\tif (res == 0) {\n\t\t\t\t\tpass_src_check = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcand_cnt++;\n\t\t\t}\n\t\t\tao2_iterator_destroy(&i);\n\n\t\t\tif (!pass_src_check) {\n\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. Source not in ICE active candidate list.\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\t\t\tast_sockaddr_stringify(sa));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * A race condition is prevented between dtls_perform_handshake()\n\t\t * and this function because both functions have to get the\n\t\t * instance lock before they can do anything.  The\n\t\t * dtls_perform_handshake() function needs to start the timer\n\t\t * before we stop it below.\n\t\t */\n\n\t\t/* Before we feed data into OpenSSL ensure that the timeout timer is either stopped or completed */\n\t\tao2_unlock(instance);\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, rtcp);\n\t\tao2_lock(instance);\n\n\t\t/* If we don't yet know if we are active or passive and we receive a packet... we are obviously passive */\n\t\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {\n\t\t\tdtls->dtls_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\t\tSSL_set_accept_state(dtls->ssl);\n\t\t}\n\n\t\tBIO_write(dtls->read_bio, buf, len);\n\n\t\tlen = SSL_read(dtls->ssl, buf, len);\n\n\t\tif ((len < 0) && (SSL_get_error(dtls->ssl, len) == SSL_ERROR_SSL)) {\n\t\t\tunsigned long error = ERR_get_error();\n\t\t\tast_log(LOG_ERROR, \"DTLS failure occurred on RTP instance '%p' due to reason '%s', terminating\\n\",\n\t\t\t\tinstance, ERR_reason_error_string(error));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SSL_is_init_finished(dtls->ssl)) {\n\t\t\t/* Any further connections will be existing since this is now established */\n\t\t\tdtls->connection = AST_RTP_DTLS_CONNECTION_EXISTING;\n\t\t\t/* Use the keying material to set up key/salt information */\n\t\t\tif ((res = dtls_srtp_setup(rtp, instance, rtcp))) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t/* Notify that dtls has been established */\n\t\t\tres = RTP_DTLS_ESTABLISHED;\n\n\t\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - established'\\n\", instance, rtp);\n\t\t} else {\n\t\t\t/* Since we've sent additional traffic start the timeout timer for retransmission */\n\t\t\tdtls_srtp_start_timeout_timer(instance, rtp, rtcp);\n\t\t}\n\n\t\treturn res;\n\t}\n#endif\n\n#ifdef HAVE_PJPROJECT\n\tif (!ast_sockaddr_isnull(loop) && !ast_sockaddr_cmp(loop, sa)) {\n\t\t/* ICE traffic will have been handled in the TURN callback, so skip it but update the address\n\t\t * so it reflects the actual source and not the loopback\n\t\t */\n\t\tif (rtcp) {\n\t\t\tast_sockaddr_copy(sa, &rtp->rtcp->them);\n\t\t} else {\n\t\t\tast_rtp_instance_get_remote_address(instance, sa);\n\t\t}\n\t} else if (rtp->ice) {\n\t\tpj_str_t combined = pj_str(ast_sockaddr_stringify(sa));\n\t\tpj_sockaddr address;\n\t\tpj_status_t status;\n\t\tstruct ice_wrap *ice;\n\n\t\tpj_thread_register_check();\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tao2_unlock(instance);\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice,\n\t\t\trtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,\n\t\t\trtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,\n\t\t\tpj_sockaddr_get_len(&address));\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar err_buf[100];\n\n\t\t\tpj_strerror(status, err_buf, sizeof(err_buf));\n\t\t\tast_log(LOG_WARNING, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)status, err_buf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!rtp->passthrough) {\n\t\t\t/* If a unidirectional ICE negotiation occurs then lock on to the source of the\n\t\t\t * ICE traffic and use it as the target. This will occur if the remote side only\n\t\t\t * wants to receive media but never send to us.\n\t\t\t */\n\t\t\tif (!rtp->ice_active_remote_candidates && !rtp->ice_proposed_remote_candidates) {\n\t\t\t\tif (rtcp) {\n\t\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, sa);\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_remote_address(instance, sa);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\trtp->passthrough = 0;\n\t}\n#endif\n\n\treturn len;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp)\n {\n \tint len;\n \tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n #if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n \tchar *in = buf;\n #endif\n #ifdef HAVE_PJPROJECT\n \tstruct ast_sockaddr *loop = rtcp ? &rtp->rtcp_loop : &rtp->rtp_loop;\n #endif\n #ifdef TEST_FRAMEWORK\n \tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n #endif\n \n \tif ((len = ast_recvfrom(rtcp ? rtp->rtcp->s : rtp->s, buf, size, flags, sa)) < 0) {\n \t\treturn len;\n \t}\n \n #ifdef TEST_FRAMEWORK\n \tif (test && test->packets_to_drop > 0) {\n \t\ttest->packets_to_drop--;\n \t\treturn 0;\n \t}\n #endif\n \n #if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n \t/* If this is an SSL packet pass it to OpenSSL for processing. RFC section for first byte value:\n \t * https://tools.ietf.org/html/rfc5764#section-5.1.2 */\n \tif ((*in >= 20) && (*in <= 63)) {\n \t\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n \t\tint res = 0;\n \n \t\t/* If no SSL session actually exists terminate things */\n \t\tif (!dtls->ssl) {\n \t\t\tast_log(LOG_ERROR, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n \t\t\t\tinstance);\n \t\t\treturn -1;\n \t\t}\n \n \t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n+\n+\t\t/*\n+\t\t * If ICE is in use, we can prevent a possible DOS attack\n+\t\t * by allowing DTLS protocol messages (client hello, etc)\n+\t\t * only from sources that are in the active remote\n+\t\t * candidates list.\n+\t\t */\n+\n+\t\tif (rtp->ice) {\n+\t\t\tint pass_src_check = 0;\n+\t\t\tstruct ao2_iterator i;\n+\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n+\t\t\tint cand_cnt = 0;\n+\n+\t\t\t/*\n+\t\t\t * You'd think that this check would cause a \"deadlock\"\n+\t\t\t * because ast_rtp_ice_start_media calls dtls_perform_handshake\n+\t\t\t",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing unauthorized DTLS packets, thus mitigating a DOS attack. It fits the criteria for a Security Vulnerability Fix with high confidence.\n\n**Final Output:**\nAnalysis: The patch modifies the function to check DTLS packets against ICE candidates, preventing unauthorized sources from causing a DOS attack. This directly addresses a security issue related to availability.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}