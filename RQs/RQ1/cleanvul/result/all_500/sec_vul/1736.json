{
  "id": 1736,
  "language": "Java",
  "commit_url": "https://github.com/Zimbra/zm-mailbox/commit/c2d35d4c78e9531e3c3602b106f064d86c8cdfb0",
  "commit_sha": "c2d35d4c78e9531e3c3602b106f064d86c8cdfb0",
  "commit_msg": "ZBUG-2914: Proxy servlet SSRF (#1372)\n\n* ZBUG-2914: Strategy for filtering 3xx Locations\r\n\r\n* ZBUG-2914: Broken stab at writing unit tests\r\n\r\n* ZBUG-2914: First Location, reject relative\r\n\r\nCheck only the first Location header, which shouldn't be a problem\r\nsince multiple ones aren't kosher anyway.\r\n\r\nReject relative Location since they can't be instantiated into\r\na URL object.\r\n\r\n* ZBUG-2914: Double-check Location header\r\n\r\n* ZBUG-2914: Add isRedirectStatus tests",
  "pr_url": "https://github.com/Zimbra/zm-mailbox/pull/1372",
  "pr_info": "**Problem**: https://jira.corp.synacor.com/browse/ZBUG-2914 describes this as a potential issue, but gives no indication of an actual problem in the real world.  So, going by the details and proposed fixes in that description, we want to prevent a proxied request from following any redirect that isn't also on our whitelist.\r\n\r\n**Solution**: First, I wrote a custom redirect strategy that checked our whitelist. That should stop us from being redirected while the proxying request is running. Then I needed to re-check any ultimate \"Location\" header sent to report the proper client error  instead of allowing that header to fall through and (probably) fail due to existing browser CORS restrictions.\r\n\r\n**Testing**: I grabbed a small URL-shortening go project to generate redirects and ensured our proxy did not follow them unless they matched a domain within our whitelist.",
  "file_name": "store/src/java/com/zimbra/cs/zimlet/ProxyServlet.java",
  "func_name": "IOException",
  "func_before": "protected void doProxy(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        ZimbraLog.clearContext();\n        boolean isAdmin = isAdminRequest(req);\n        AuthToken authToken = isAdmin ?\n                getAdminAuthTokenFromCookie(req, resp, true) : getAuthTokenFromCookie(req, resp, true);\n        if (authToken == null) {\n            String zAuthToken = req.getParameter(QP_ZAUTHTOKEN);\n            if (zAuthToken != null) {\n                try {\n                    authToken = AuthProvider.getAuthToken(zAuthToken);\n                    if (authToken.isExpired()) {\n                        resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"authtoken expired\");\n                        return;\n                    }\n                } catch (AuthTokenException e) {\n                    resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to parse authtoken\");\n                    return;\n                }\n            }\n        }\n        if (authToken == null) {\n            resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"no authtoken cookie\");\n            return;\n        }\n        if (!authToken.isRegistered()) {\n            resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"authtoken is invalid\");\n            return;\n        }\n        if (isAdmin && !authToken.isAdmin()) {\n            resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"permission denied\");\n            return;\n        }\n\n        // get the posted body before the server read and parse them.\n        byte[] body = copyPostedData(req);\n\n        // sanity check\n        String target = req.getParameter(TARGET_PARAM);\n        if (target == null) {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // check for permission\n        URL url = new URL(target);\n        if (!isAdmin && !checkPermissionOnTarget(url, authToken)) {\n            resp.sendError(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n\n        // determine whether to return the target inline or store it as an upload\n        String uploadParam = req.getParameter(UPLOAD_PARAM);\n        boolean asUpload = uploadParam != null && (uploadParam.equals(\"1\") || uploadParam.equalsIgnoreCase(\"true\"));\n\n        HttpRequestBase method = null;\n        try {\n            HttpClientBuilder clientBuilder = ZimbraHttpConnectionManager.getExternalHttpConnMgr().newHttpClient();\n            HttpProxyUtil.configureProxy(clientBuilder);\n            String reqMethod = req.getMethod();\n            if (reqMethod.equalsIgnoreCase(\"GET\")) {\n                method = new HttpGet(target);\n            } else if (reqMethod.equalsIgnoreCase(\"POST\")) {\n                HttpPost post = new HttpPost(target);\n                if (body != null)\n                    post.setEntity(new ByteArrayEntity(body, org.apache.http.entity.ContentType.create(req.getContentType())));\n                method = post;\n            } else if (reqMethod.equalsIgnoreCase(\"PUT\")) {\n                HttpPut put = new HttpPut(target);\n                if (body != null)\n                    put.setEntity(new ByteArrayEntity(body, org.apache.http.entity.ContentType.create(req.getContentType())));\n                method = put;\n            } else if (reqMethod.equalsIgnoreCase(\"DELETE\")) {\n                method = new HttpDelete(target);\n            } else {\n                ZimbraLog.zimlet.info(\"unsupported request method: \" + reqMethod);\n                resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n                return;\n            }\n\n            // handle basic auth\n            String auth, user, pass;\n            auth = req.getParameter(AUTH_PARAM);\n            user = req.getParameter(USER_PARAM);\n            pass = req.getParameter(PASS_PARAM);\n            if (auth != null && user != null && pass != null) {\n                if (!auth.equals(AUTH_BASIC)) {\n                    ZimbraLog.zimlet.info(\"unsupported auth type: \" + auth);\n                    resp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n                CredentialsProvider provider = new BasicCredentialsProvider();\n                provider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(user, pass));\n                clientBuilder.setDefaultCredentialsProvider(provider);\n            }\n\n            Enumeration headers = req.getHeaderNames();\n            while (headers.hasMoreElements()) {\n                String hdr = (String) headers.nextElement();\n                ZimbraLog.zimlet.debug(\"incoming: \" + hdr + \": \" + req.getHeader(hdr));\n                if (canProxyHeader(hdr)) {\n                    ZimbraLog.zimlet.debug(\"outgoing: \" + hdr + \": \" + req.getHeader(hdr));\n                    method.addHeader(hdr, req.getHeader(hdr));\n                }\n            }\n\n            HttpResponse httpResp = null;\n            try {\n                if (!(reqMethod.equalsIgnoreCase(\"POST\") || reqMethod.equalsIgnoreCase(\"PUT\"))) {\n                    clientBuilder.setRedirectStrategy(new DefaultRedirectStrategy());\n                }\n\n                HttpClient client = clientBuilder.build();\n                httpResp = HttpClientUtil.executeMethod(client, method);\n            } catch (HttpException ex) {\n                ZimbraLog.zimlet.info(\"exception while proxying \" + target, ex);\n                resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n\n            int status = httpResp.getStatusLine() == null ? HttpServletResponse.SC_INTERNAL_SERVER_ERROR :httpResp.getStatusLine().getStatusCode();\n\n            // workaround for Alexa Thumbnails paid web service, which doesn't bother to return a content-type line\n            Header ctHeader = httpResp.getFirstHeader(\"Content-Type\");\n            String contentType = ctHeader == null || ctHeader.getValue() == null ? DEFAULT_CTYPE : ctHeader.getValue();\n\n            // getEntity may return null if no response body (e.g. HTTP 204)\n            InputStream targetResponseBody = null;\n            HttpEntity targetResponseEntity = httpResp.getEntity();\n            if (targetResponseEntity != null) {\n                targetResponseBody = targetResponseEntity.getContent();\n            }\n\n            if (asUpload) {\n                String filename = req.getParameter(FILENAME_PARAM);\n                if (filename == null || filename.equals(\"\"))\n                    filename = new ContentType(contentType).getParameter(\"name\");\n                if ((filename == null || filename.equals(\"\")) && httpResp.getFirstHeader(\"Content-Disposition\") != null)\n                    filename = new ContentDisposition(httpResp.getFirstHeader(\"Content-Disposition\").getValue()).getParameter(\"filename\");\n                if (filename == null || filename.equals(\"\"))\n                    filename = \"unknown\";\n\n                List<Upload> uploads = null;\n\n                if (targetResponseBody != null) {\n                    try {\n                        Upload up = FileUploadServlet.saveUpload(targetResponseBody, filename, contentType, authToken.getAccountId());\n                        uploads = Arrays.asList(up);\n                    } catch (ServiceException e) {\n                        if (e.getCode().equals(MailServiceException.UPLOAD_REJECTED))\n                            status = HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE;\n                        else\n                            status = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n                    }\n                }\n\n                resp.setStatus(status);\n                FileUploadServlet.sendResponse(resp, status, req.getParameter(FORMAT_PARAM), null, uploads, null);\n            } else {\n                resp.setStatus(status);\n                resp.setContentType(contentType);\n                for (Header h : httpResp.getAllHeaders())\n                    if (canProxyHeader(h.getName()))\n                        resp.addHeader(h.getName(), h.getValue());\n                if (targetResponseBody != null)\n                \tByteUtil.copy(targetResponseBody, true, resp.getOutputStream(), true);\n            }\n        } finally {\n            if (method != null)\n                method.releaseConnection();\n        }\n    }",
  "func_after": "protected void doProxy(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        ZimbraLog.clearContext();\n        boolean isAdmin = isAdminRequest(req);\n        AuthToken authToken = isAdmin ?\n                getAdminAuthTokenFromCookie(req, resp, true) : getAuthTokenFromCookie(req, resp, true);\n        if (authToken == null) {\n            String zAuthToken = req.getParameter(QP_ZAUTHTOKEN);\n            if (zAuthToken != null) {\n                try {\n                    authToken = AuthProvider.getAuthToken(zAuthToken);\n                    if (authToken.isExpired()) {\n                        resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"authtoken expired\");\n                        return;\n                    }\n                } catch (AuthTokenException e) {\n                    resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to parse authtoken\");\n                    return;\n                }\n            }\n        }\n        if (authToken == null) {\n            resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"no authtoken cookie\");\n            return;\n        }\n        if (!authToken.isRegistered()) {\n            resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"authtoken is invalid\");\n            return;\n        }\n        if (isAdmin && !authToken.isAdmin()) {\n            resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"permission denied\");\n            return;\n        }\n\n        // get the posted body before the server read and parse them.\n        byte[] body = copyPostedData(req);\n\n        // sanity check\n        String target = req.getParameter(TARGET_PARAM);\n        if (target == null) {\n            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // check for permission\n        URL url = new URL(target);\n        if (!isAdmin && !checkPermissionOnTarget(url, authToken)) {\n            resp.sendError(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n\n        // determine whether to return the target inline or store it as an upload\n        String uploadParam = req.getParameter(UPLOAD_PARAM);\n        boolean asUpload = uploadParam != null && (uploadParam.equals(\"1\") || uploadParam.equalsIgnoreCase(\"true\"));\n\n        HttpRequestBase method = null;\n        try {\n            HttpClientBuilder clientBuilder = ZimbraHttpConnectionManager.getExternalHttpConnMgr().newHttpClient();\n            HttpProxyUtil.configureProxy(clientBuilder);\n            String reqMethod = req.getMethod();\n            if (reqMethod.equalsIgnoreCase(\"GET\")) {\n                method = new HttpGet(target);\n            } else if (reqMethod.equalsIgnoreCase(\"POST\")) {\n                HttpPost post = new HttpPost(target);\n                if (body != null)\n                    post.setEntity(new ByteArrayEntity(body, org.apache.http.entity.ContentType.create(req.getContentType())));\n                method = post;\n            } else if (reqMethod.equalsIgnoreCase(\"PUT\")) {\n                HttpPut put = new HttpPut(target);\n                if (body != null)\n                    put.setEntity(new ByteArrayEntity(body, org.apache.http.entity.ContentType.create(req.getContentType())));\n                method = put;\n            } else if (reqMethod.equalsIgnoreCase(\"DELETE\")) {\n                method = new HttpDelete(target);\n            } else {\n                ZimbraLog.zimlet.info(\"unsupported request method: \" + reqMethod);\n                resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n                return;\n            }\n\n            // handle basic auth\n            String auth, user, pass;\n            auth = req.getParameter(AUTH_PARAM);\n            user = req.getParameter(USER_PARAM);\n            pass = req.getParameter(PASS_PARAM);\n            if (auth != null && user != null && pass != null) {\n                if (!auth.equals(AUTH_BASIC)) {\n                    ZimbraLog.zimlet.info(\"unsupported auth type: \" + auth);\n                    resp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n                CredentialsProvider provider = new BasicCredentialsProvider();\n                provider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(user, pass));\n                clientBuilder.setDefaultCredentialsProvider(provider);\n            }\n\n            Enumeration headers = req.getHeaderNames();\n            while (headers.hasMoreElements()) {\n                String hdr = (String) headers.nextElement();\n                ZimbraLog.zimlet.debug(\"incoming: \" + hdr + \": \" + req.getHeader(hdr));\n                if (canProxyHeader(hdr)) {\n                    ZimbraLog.zimlet.debug(\"outgoing: \" + hdr + \": \" + req.getHeader(hdr));\n                    method.addHeader(hdr, req.getHeader(hdr));\n                }\n            }\n\n            HttpResponse httpResp = null;\n            try {\n                if (!(reqMethod.equalsIgnoreCase(\"POST\") || reqMethod.equalsIgnoreCase(\"PUT\"))) {\n                    clientBuilder.setRedirectStrategy(new RestrictiveRedirectStrategy(authToken));\n                }\n\n                HttpClient client = clientBuilder.build();\n                httpResp = HttpClientUtil.executeMethod(client, method);\n            } catch (HttpException ex) {\n                ZimbraLog.zimlet.info(\"exception while proxying \" + target, ex);\n                resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n\n            int status = httpResp.getStatusLine() == null ? HttpServletResponse.SC_INTERNAL_SERVER_ERROR : httpResp.getStatusLine().getStatusCode();\n\n            if (isRedirectStatus(status) && !shouldFollowRedirectLocation(httpResp.getFirstHeader(\"Location\"), authToken)) {\n                resp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                return;\n            }\n\n            // workaround for Alexa Thumbnails paid web service, which doesn't bother to return a content-type line\n            Header ctHeader = httpResp.getFirstHeader(\"Content-Type\");\n            String contentType = ctHeader == null || ctHeader.getValue() == null ? DEFAULT_CTYPE : ctHeader.getValue();\n\n            // getEntity may return null if no response body (e.g. HTTP 204)\n            InputStream targetResponseBody = null;\n            HttpEntity targetResponseEntity = httpResp.getEntity();\n            if (targetResponseEntity != null) {\n                targetResponseBody = targetResponseEntity.getContent();\n            }\n\n            if (asUpload) {\n                String filename = req.getParameter(FILENAME_PARAM);\n                if (filename == null || filename.equals(\"\"))\n                    filename = new ContentType(contentType).getParameter(\"name\");\n                if ((filename == null || filename.equals(\"\")) && httpResp.getFirstHeader(\"Content-Disposition\") != null)\n                    filename = new ContentDisposition(httpResp.getFirstHeader(\"Content-Disposition\").getValue()).getParameter(\"filename\");\n                if (filename == null || filename.equals(\"\"))\n                    filename = \"unknown\";\n\n                List<Upload> uploads = null;\n\n                if (targetResponseBody != null) {\n                    try {\n                        Upload up = FileUploadServlet.saveUpload(targetResponseBody, filename, contentType, authToken.getAccountId());\n                        uploads = Arrays.asList(up);\n                    } catch (ServiceException e) {\n                        if (e.getCode().equals(MailServiceException.UPLOAD_REJECTED))\n                            status = HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE;\n                        else\n                            status = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n                    }\n                }\n\n                resp.setStatus(status);\n                FileUploadServlet.sendResponse(resp, status, req.getParameter(FORMAT_PARAM), null, uploads, null);\n            } else {\n                resp.setStatus(status);\n                resp.setContentType(contentType);\n                for (Header h : httpResp.getAllHeaders())\n                    if (canProxyHeader(h.getName()))\n                        resp.addHeader(h.getName(), h.getValue());\n                if (targetResponseBody != null)\n                    ByteUtil.copy(targetResponseBody, true, resp.getOutputStream(), true);\n            }\n        } finally {\n            if (method != null)\n                method.releaseConnection();\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n protected void doProxy(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n         ZimbraLog.clearContext();\n         boolean isAdmin = isAdminRequest(req);\n         AuthToken authToken = isAdmin ?\n                 getAdminAuthTokenFromCookie(req, resp, true) : getAuthTokenFromCookie(req, resp, true);\n         if (authToken == null) {\n             String zAuthToken = req.getParameter(QP_ZAUTHTOKEN);\n             if (zAuthToken != null) {\n                 try {\n                     authToken = AuthProvider.getAuthToken(zAuthToken);\n                     if (authToken.isExpired()) {\n                         resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"authtoken expired\");\n                         return;\n                     }\n                 } catch (AuthTokenException e) {\n                     resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to parse authtoken\");\n                     return;\n                 }\n             }\n         }\n         if (authToken == null) {\n             resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"no authtoken cookie\");\n             return;\n         }\n         if (!authToken.isRegistered()) {\n             resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"authtoken is invalid\");\n             return;\n         }\n         if (isAdmin && !authToken.isAdmin()) {\n             resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"permission denied\");\n             return;\n         }\n \n         // get the posted body before the server read and parse them.\n         byte[] body = copyPostedData(req);\n \n         // sanity check\n         String target = req.getParameter(TARGET_PARAM);\n         if (target == null) {\n             resp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n             return;\n         }\n \n         // check for permission\n         URL url = new URL(target);\n         if (!isAdmin && !checkPermissionOnTarget(url, authToken)) {\n             resp.sendEr",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The commit addresses a security issue related to SSRF in a proxy servlet. The code changes enforce checks on the target URL to prevent unauthorized redirects, which mitigates the risk of server-side request forgery attacks.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}