{
  "id": 830,
  "language": "Java",
  "commit_url": "https://github.com/PixelExperience/frameworks_base/commit/9546f607f68814f5269374b5c5e714c9d8d8b0b8",
  "commit_sha": "9546f607f68814f5269374b5c5e714c9d8d8b0b8",
  "commit_msg": "Add ActivityOption to remove insecure keyguard when activity is launched.\n\nAdd a new ActivityOption#setDismissKeyguardIfInsecure remove keyguard\nwhen an activity is launched while an insecure keyguard is shown. If\nthis option is set, WMS waits until the launched activity finishes\ndrawing its surface, then starts KEYGUARD_GOING_AWAY app transition.\n\nBug: 203044476\nTest: atest KeyguardLockedTests KeyguardTransitionTests\nChange-Id: I0f6a501baa2a60ae044bf1ef888e5e6f57a5f13e",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/wm/KeyguardController.java",
  "func_name": "updateVisibility",
  "func_before": "void updateVisibility(KeyguardController controller, DisplayContent display) {\n            final boolean lastOccluded = mOccluded;\n\n            final ActivityRecord lastDismissKeyguardActivity = mDismissingKeyguardActivity;\n            final ActivityRecord lastTurnScreenOnActivity = mTopTurnScreenOnActivity;\n\n            mRequestDismissKeyguard = false;\n            mOccluded = false;\n\n            mTopOccludesActivity = null;\n            mDismissingKeyguardActivity = null;\n            mTopTurnScreenOnActivity = null;\n\n            boolean occludedByActivity = false;\n            final Task task = getRootTaskForControllingOccluding(display);\n            final ActivityRecord top = task != null ? task.getTopNonFinishingActivity() : null;\n            if (top != null) {\n                if (top.containsDismissKeyguardWindow()) {\n                    mDismissingKeyguardActivity = top;\n                }\n                if (top.getTurnScreenOnFlag() && top.currentLaunchCanTurnScreenOn()) {\n                    mTopTurnScreenOnActivity = top;\n                }\n\n                final boolean showWhenLocked = top.canShowWhenLocked();\n                if (showWhenLocked) {\n                    mTopOccludesActivity = top;\n                }\n\n                // Only the top activity may control occluded, as we can't occlude the Keyguard\n                // if the top app doesn't want to occlude it.\n                occludedByActivity = showWhenLocked || (mDismissingKeyguardActivity != null\n                        && task.topRunningActivity() == mDismissingKeyguardActivity\n                        && controller.canShowWhileOccluded(\n                                true /* dismissKeyguard */, false /* showWhenLocked */));\n                // FLAG_CAN_SHOW_WITH_INSECURE_KEYGUARD only apply for secondary display.\n                if (mDisplayId != DEFAULT_DISPLAY) {\n                    occludedByActivity |= display.canShowWithInsecureKeyguard()\n                            && controller.canDismissKeyguard();\n                }\n            }\n\n            final boolean dreaming = display.getDisplayPolicy().isShowingDreamLw() && (top != null\n                    && top.getActivityType() == ACTIVITY_TYPE_DREAM);\n            mOccluded = dreaming || occludedByActivity;\n            mRequestDismissKeyguard = lastDismissKeyguardActivity != mDismissingKeyguardActivity\n                    && !mOccluded\n                    && mDismissingKeyguardActivity != null\n                    && controller.mWindowManager.isKeyguardSecure(\n                    controller.mService.getCurrentUserId());\n\n            if (mTopTurnScreenOnActivity != lastTurnScreenOnActivity\n                    && mTopTurnScreenOnActivity != null\n                    && !mService.mWindowManager.mPowerManager.isInteractive()\n                    && (mRequestDismissKeyguard || occludedByActivity)) {\n                controller.mTaskSupervisor.wakeUp(\"handleTurnScreenOn\");\n                mTopTurnScreenOnActivity.setCurrentLaunchCanTurnScreenOn(false);\n            }\n\n            if (lastOccluded != mOccluded) {\n                controller.handleOccludedChanged(mDisplayId, mTopOccludesActivity);\n            }\n        }",
  "func_after": "void updateVisibility(KeyguardController controller, DisplayContent display) {\n            final boolean lastOccluded = mOccluded;\n            final boolean lastKeyguardGoingAway = mKeyguardGoingAway;\n\n            final ActivityRecord lastDismissKeyguardActivity = mDismissingKeyguardActivity;\n            final ActivityRecord lastTurnScreenOnActivity = mTopTurnScreenOnActivity;\n\n            mRequestDismissKeyguard = false;\n            mOccluded = false;\n\n            mTopOccludesActivity = null;\n            mDismissingKeyguardActivity = null;\n            mTopTurnScreenOnActivity = null;\n\n            boolean occludedByActivity = false;\n            final Task task = getRootTaskForControllingOccluding(display);\n            final ActivityRecord top = task != null ? task.getTopNonFinishingActivity() : null;\n            if (top != null) {\n                if (top.containsDismissKeyguardWindow()) {\n                    mDismissingKeyguardActivity = top;\n                }\n                if (top.getTurnScreenOnFlag() && top.currentLaunchCanTurnScreenOn()) {\n                    mTopTurnScreenOnActivity = top;\n                }\n\n                final boolean isKeyguardSecure = controller.mWindowManager.isKeyguardSecure(\n                        controller.mService.getCurrentUserId());\n                if (top.mDismissKeyguardIfInsecure && mKeyguardShowing && !isKeyguardSecure) {\n                    mKeyguardGoingAway = true;\n                } else if (top.canShowWhenLocked()) {\n                    mTopOccludesActivity = top;\n                }\n\n                // Only the top activity may control occluded, as we can't occlude the Keyguard\n                // if the top app doesn't want to occlude it.\n                occludedByActivity = mTopOccludesActivity != null\n                        || (mDismissingKeyguardActivity != null\n                        && task.topRunningActivity() == mDismissingKeyguardActivity\n                        && controller.canShowWhileOccluded(\n                                true /* dismissKeyguard */, false /* showWhenLocked */));\n                // FLAG_CAN_SHOW_WITH_INSECURE_KEYGUARD only apply for secondary display.\n                if (mDisplayId != DEFAULT_DISPLAY) {\n                    occludedByActivity |= display.canShowWithInsecureKeyguard()\n                            && controller.canDismissKeyguard();\n                }\n            }\n\n            final boolean dreaming = display.getDisplayPolicy().isShowingDreamLw() && (top != null\n                    && top.getActivityType() == ACTIVITY_TYPE_DREAM);\n            mOccluded = dreaming || occludedByActivity;\n            mRequestDismissKeyguard = lastDismissKeyguardActivity != mDismissingKeyguardActivity\n                    && !mOccluded && !mKeyguardGoingAway\n                    && mDismissingKeyguardActivity != null;\n\n            if (mTopTurnScreenOnActivity != lastTurnScreenOnActivity\n                    && mTopTurnScreenOnActivity != null\n                    && !mService.mWindowManager.mPowerManager.isInteractive()\n                    && (mRequestDismissKeyguard || occludedByActivity)) {\n                controller.mTaskSupervisor.wakeUp(\"handleTurnScreenOn\");\n                mTopTurnScreenOnActivity.setCurrentLaunchCanTurnScreenOn(false);\n            }\n\n            if (lastOccluded != mOccluded) {\n                controller.handleOccludedChanged(mDisplayId, mTopOccludesActivity);\n            } else if (!lastKeyguardGoingAway && mKeyguardGoingAway) {\n                controller.handleKeyguardGoingAwayChanged(display);\n            }\n        }",
  "diff_func": "--- func_before\n+++ func_after\n void updateVisibility(KeyguardController controller, DisplayContent display) {\n             final boolean lastOccluded = mOccluded;\n+            final boolean lastKeyguardGoingAway = mKeyguardGoingAway;\n \n             final ActivityRecord lastDismissKeyguardActivity = mDismissingKeyguardActivity;\n             final ActivityRecord lastTurnScreenOnActivity = mTopTurnScreenOnActivity;\n \n             mRequestDismissKeyguard = false;\n             mOccluded = false;\n \n             mTopOccludesActivity = null;\n             mDismissingKeyguardActivity = null;\n             mTopTurnScreenOnActivity = null;\n \n             boolean occludedByActivity = false;\n             final Task task = getRootTaskForControllingOccluding(display);\n             final ActivityRecord top = task != null ? task.getTopNonFinishingActivity() : null;\n             if (top != null) {\n                 if (top.containsDismissKeyguardWindow()) {\n                     mDismissingKeyguardActivity = top;\n                 }\n                 if (top.getTurnScreenOnFlag() && top.currentLaunchCanTurnScreenOn()) {\n                     mTopTurnScreenOnActivity = top;\n                 }\n \n-                final boolean showWhenLocked = top.canShowWhenLocked();\n+                final boolean isKeyguardSecure = controller.mWindowManager.isKeyguardSecure(\n+                        controller.mService.getCurrentUserId());\n+                if (top.mDismissKeyguardIfInsecure && mKeyguardShowing && !isKeyguardSecure) {\n+                    mKeyguardGoingAway = true;\n-                if (showWhenLocked) {\n+                } else if (top.canShowWhenLocked()) {\n                     mTopOccludesActivity = top;\n                 }\n \n                 // Only the top activity may control occluded, as we can't occlude the Keyguard\n                 // if the top app doesn't want to occlude it.\n+                occludedByActivity = mTopOccludesActivity != null\n-                occludedByActivity = showW",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95\n\nThe patch addresses a security issue by ensuring the keyguard is dismissed securely when necessary, preventing potential unauthorized access.",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\nThe patch introduces a new ActivityOption to handle the dismissal of an insecure keyguard when an activity is launched. It modifies the updateVisibility function to check if the keyguard is secure and if the activity opts to dismiss it, ensuring proper handling to prevent unauthorized access.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95\n\nThe patch addresses a security issue by ensuring the keyguard is dismissed securely when necessary, preventing potential unauthorized access."
}