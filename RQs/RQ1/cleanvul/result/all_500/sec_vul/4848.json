{
  "id": 4848,
  "language": "C/C++",
  "commit_url": "https://github.com/contiki-ng/contiki-ng/commit/82356e516a91200857f52ed3e9945739cba2c051",
  "commit_sha": "82356e516a91200857f52ed3e9945739cba2c051",
  "commit_msg": "Fix buffer overflow in ble-l2cap",
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1662",
  "pr_info": "This PR fixes a buffer overflow in the BLE L2CAP credit-based flow control.  \r\n\r\nThe overflow occurs in the `input_l2cap_frame_flow_channel` function, as an adversary is able to control the amount of data copied by memcpy ([source](https://github.com/contiki-ng/contiki-ng/blob/release/v4.4/os/net/mac/ble/ble-l2cap.c#L424)).\r\n\r\nTo fix this issue I suggest to:\r\n\r\n- Add a condition for the first fragment that checks, whether the received `payload_len` is larger than `BLE_L2CAP_NODE_MTU`, which is the length of the destination array.\r\n- Add an integer overflow resistant condition for the subsequent fragments that checks, whether the sum of the received `payload_len` of the current fragment and the `current_index` of the `rx_buffer` is larger than `BLE_L2CAP_NODE_MTU`, which is the length of the destination array.\r\n\r\nIn both cases illegal frames are simply dropped.\r\n",
  "file_name": "os/net/mac/ble/ble-l2cap.c",
  "func_name": "input_l2cap_frame_flow_channel",
  "func_before": "static void\ninput_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)\n{\n  uint16_t frame_len;\n  uint16_t payload_len;\n\n  if(data_len < 4) {\n    LOG_WARN(\"l2cap_frame: illegal L2CAP frame data_len: %d\\n\", data_len);\n    /* a L2CAP frame has a minimum length of 4 */\n    return;\n  }\n\n  if(channel->rx_buffer.sdu_length == 0) {\n    /* handle first fragment */\n    memcpy(&frame_len, &data[0], 2);\n    memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);\n    payload_len = frame_len - 2;\n\n    memcpy(channel->rx_buffer.sdu, &data[6], payload_len);\n    channel->rx_buffer.current_index = payload_len;\n  } else {\n    /* subsequent fragment */\n    memcpy(&frame_len, &data[0], 2);\n    payload_len = frame_len;\n\n    memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);\n    channel->rx_buffer.current_index += payload_len;\n  }\n\n  if((channel->rx_buffer.sdu_length > 0) &&\n     (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {\n    /* do not use packetbuf_copyfrom here because the packetbuf_attr\n     * must not be cleared */\n    memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);\n    packetbuf_set_datalen(channel->rx_buffer.sdu_length);\n    NETSTACK_NETWORK.input();\n\n    /* reset counters */\n    channel->rx_buffer.sdu_length = 0;\n    channel->rx_buffer.current_index = 0;\n  }\n}",
  "func_after": "static void\ninput_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)\n{\n  uint16_t frame_len;\n  uint16_t payload_len;\n\n  if(data_len < 4) {\n    LOG_WARN(\"l2cap_frame: illegal L2CAP frame data_len: %d\\n\", data_len);\n    /* a L2CAP frame has a minimum length of 4 */\n    return;\n  }\n\n  if(channel->rx_buffer.sdu_length == 0) {\n    /* handle first fragment */\n    memcpy(&frame_len, &data[0], 2);\n    payload_len = frame_len - 2;\n\n    if(payload_len > BLE_L2CAP_NODE_MTU) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n    \t/* the payload length may not be larger than the destination buffer */\n    \treturn;\n    }\n\n    memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);\n\n    memcpy(channel->rx_buffer.sdu, &data[6], payload_len);\n    channel->rx_buffer.current_index = payload_len;\n  } else {\n    /* subsequent fragment */\n    memcpy(&frame_len, &data[0], 2);\n    payload_len = frame_len;\n    \n    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n    \t/* the current index plus the payload length may not be larger than \n\t * the destination buffer */\n    \treturn;\n    }\n\n    memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);\n    channel->rx_buffer.current_index += payload_len;\n  }\n\n  if((channel->rx_buffer.sdu_length > 0) &&\n     (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {\n    /* do not use packetbuf_copyfrom here because the packetbuf_attr\n     * must not be cleared */\n    memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);\n    packetbuf_set_datalen(channel->rx_buffer.sdu_length);\n    NETSTACK_NETWORK.input();\n\n    /* reset counters */\n    channel->rx_buffer.sdu_length = 0;\n    channel->rx_buffer.current_index = 0;\n  }\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void\n input_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)\n {\n   uint16_t frame_len;\n   uint16_t payload_len;\n \n   if(data_len < 4) {\n     LOG_WARN(\"l2cap_frame: illegal L2CAP frame data_len: %d\\n\", data_len);\n     /* a L2CAP frame has a minimum length of 4 */\n     return;\n   }\n \n   if(channel->rx_buffer.sdu_length == 0) {\n     /* handle first fragment */\n     memcpy(&frame_len, &data[0], 2);\n+    payload_len = frame_len - 2;\n+\n+    if(payload_len > BLE_L2CAP_NODE_MTU) {\n+    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n+    \t/* the payload length may not be larger than the destination buffer */\n+    \treturn;\n+    }\n+\n     memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);\n-    payload_len = frame_len - 2;\n \n     memcpy(channel->rx_buffer.sdu, &data[6], payload_len);\n     channel->rx_buffer.current_index = payload_len;\n   } else {\n     /* subsequent fragment */\n     memcpy(&frame_len, &data[0], 2);\n     payload_len = frame_len;\n+    \n+    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {\n+    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n+    \t/* the current index plus the payload length may not be larger than \n+\t * the destination buffer */\n+    \treturn;\n+    }\n \n     memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);\n     channel->rx_buffer.current_index += payload_len;\n   }\n \n   if((channel->rx_buffer.sdu_length > 0) &&\n      (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {\n     /* do not use packetbuf_copyfrom here because the packetbuf_attr\n      * must not be cleared */\n     memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);\n     packetbuf_set_datalen(channel->rx_buffer.sdu_length);\n     NETSTACK_NETWORK.input();\n \n     /* reset counters */\n     channel->rx_buffer.sdu_length = 0;\n     channel->rx_buffer",
  "diff_source": "custom",
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses a buffer overflow issue in the L2CAP frame handling function by adding checks to prevent data exceeding the buffer's capacity. This mitigates a potential security vulnerability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}