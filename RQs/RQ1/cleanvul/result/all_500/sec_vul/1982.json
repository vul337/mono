{
  "id": 1982,
  "language": "Java",
  "commit_url": "https://github.com/AOSPA/android_frameworks_base/commit/eb9a0566a583fa13f8aff671c41f78a9e33eab82",
  "commit_sha": "eb9a0566a583fa13f8aff671c41f78a9e33eab82",
  "commit_msg": "Add safety checks on KEY_INTENT mismatch.\n\nFor many years, Parcel mismatch typed exploits has been using the\nAccoungManagerService's passing of KEY_INTENT workflow, as a foothold of\nlaunching arbitrary intents. We are adding an extra check on the service\nside to simulate the final deserialization of the KEY_INTENT value, to\nmake sure the client side won't get a mismatched KEY_INTENT value.\n\nBug: 250588548\nBug: 240138294\nTest: atest CtsAccountManagerTestCases\nTest: local test, also see b/250588548\nChange-Id: I433e34f6e21ce15c89825044a15b1dec46bb25cc",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
  "func_name": "getAuthToken",
  "func_before": "@Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        List<String> callerOwnedPackageNames;\n        ident = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = Arrays.asList(mPackageManager.getPackagesForUid(callerUid));\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        if (callerPkg == null || !callerOwnedPackageNames.contains(callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                String token = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (token != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, token);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    intent)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }",
  "func_after": "@Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        List<String> callerOwnedPackageNames;\n        ident = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = Arrays.asList(mPackageManager.getPackagesForUid(callerUid));\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        if (callerPkg == null || !callerOwnedPackageNames.contains(callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                String token = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (token != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, token);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public void getAuthToken(\n             IAccountManagerResponse response,\n             final Account account,\n             final String authTokenType,\n             final boolean notifyOnAuthFailure,\n             final boolean expectActivityLaunch,\n             final Bundle loginOptions) {\n         Bundle.setDefusable(loginOptions, true);\n         if (Log.isLoggable(TAG, Log.VERBOSE)) {\n             Log.v(TAG, \"getAuthToken: \" + account\n                     + \", response \" + response\n                     + \", authTokenType \" + authTokenType\n                     + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                     + \", expectActivityLaunch \" + expectActivityLaunch\n                     + \", caller's uid \" + Binder.getCallingUid()\n                     + \", pid \" + Binder.getCallingPid());\n         }\n         Preconditions.checkArgument(response != null, \"response cannot be null\");\n         try {\n             if (account == null) {\n                 Slog.w(TAG, \"getAuthToken called with null account\");\n                 response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                 return;\n             }\n             if (authTokenType == null) {\n                 Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                 response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                 return;\n             }\n         } catch (RemoteException e) {\n             Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n             return;\n         }\n         int userId = UserHandle.getCallingUserId();\n         long ident = Binder.clearCallingIdentity();\n         final UserAccounts accounts;\n         final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n         try {\n             accounts = getUserAccounts(userId);\n             authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n          ",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a known security exploit by adding checks to prevent KEY_INTENT mismatches, which could allow arbitrary intents. This directly mitigates a security vulnerability, making it a clear Security Vulnerability Fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}