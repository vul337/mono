{
  "id": 6072,
  "language": "C/C++",
  "commit_url": "https://github.com/timescale/timescaledb/commit/014b40fb7e8d59087cf1c1988a68dd1979f86cb3",
  "commit_sha": "014b40fb7e8d59087cf1c1988a68dd1979f86cb3",
  "commit_msg": "Lock down search_path in SPI calls",
  "pr_url": "https://github.com/timescale/timescaledb/pull/5259",
  "pr_info": "no more info",
  "file_name": "tsl/src/reorder.c",
  "func_name": "tsl_copy_or_move_chunk_proc",
  "func_before": "static void\ntsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node)\n{\n\tOid chunk_id = PG_ARGISNULL(0) ? InvalidOid : PG_GETARG_OID(0);\n\tconst char *src_node_name = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1));\n\tconst char *dst_node_name = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2));\n\tconst char *op_id = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3));\n\tint rc;\n\tbool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) &&\n\t\t\t\t\t !castNode(CallContext, fcinfo->context)->atomic;\n\n\tTS_PREVENT_FUNC_IF_READ_ONLY();\n\n\tPreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo)));\n\n\t/* src_node and dst_node both have to be non-NULL */\n\tif (src_node_name == NULL || dst_node_name == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid source or destination node\")));\n\n\tif (!OidIsValid(chunk_id))\n\t\tereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"invalid chunk\")));\n\n\tif ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed: %s\", SPI_result_code_string(rc));\n\n\t/* perform the actual distributed chunk move after a few sanity checks */\n\tchunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node);\n\n\tif ((rc = SPI_finish()) != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed: %s\", SPI_result_code_string(rc));\n}",
  "func_after": "static void\ntsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node)\n{\n\tOid chunk_id = PG_ARGISNULL(0) ? InvalidOid : PG_GETARG_OID(0);\n\tconst char *src_node_name = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1));\n\tconst char *dst_node_name = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2));\n\tconst char *op_id = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3));\n\tint rc;\n\tbool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) &&\n\t\t\t\t\t !castNode(CallContext, fcinfo->context)->atomic;\n\n\tTS_PREVENT_FUNC_IF_READ_ONLY();\n\n\tPreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo)));\n\n\t/* src_node and dst_node both have to be non-NULL */\n\tif (src_node_name == NULL || dst_node_name == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid source or destination node\")));\n\n\tif (!OidIsValid(chunk_id))\n\t\tereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"invalid chunk\")));\n\n\tif ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed: %s\", SPI_result_code_string(rc));\n\n\t/* Lock down search_path */\n\trc = SPI_exec(\"SET LOCAL search_path TO pg_catalog, pg_temp\", 0);\n\tif (rc < 0)\n\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(\"could not set search_path\"))));\n\n\t/* perform the actual distributed chunk move after a few sanity checks */\n\tchunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node);\n\n\tif ((rc = SPI_finish()) != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed: %s\", SPI_result_code_string(rc));\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void\n tsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node)\n {\n \tOid chunk_id = PG_ARGISNULL(0) ? InvalidOid : PG_GETARG_OID(0);\n \tconst char *src_node_name = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1));\n \tconst char *dst_node_name = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2));\n \tconst char *op_id = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3));\n \tint rc;\n \tbool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) &&\n \t\t\t\t\t !castNode(CallContext, fcinfo->context)->atomic;\n \n \tTS_PREVENT_FUNC_IF_READ_ONLY();\n \n \tPreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo)));\n \n \t/* src_node and dst_node both have to be non-NULL */\n \tif (src_node_name == NULL || dst_node_name == NULL)\n \t\tereport(ERROR,\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"invalid source or destination node\")));\n \n \tif (!OidIsValid(chunk_id))\n \t\tereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"invalid chunk\")));\n \n \tif ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)\n \t\telog(ERROR, \"SPI_connect failed: %s\", SPI_result_code_string(rc));\n \n+\t/* Lock down search_path */\n+\trc = SPI_exec(\"SET LOCAL search_path TO pg_catalog, pg_temp\", 0);\n+\tif (rc < 0)\n+\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(\"could not set search_path\"))));\n+\n \t/* perform the actual distributed chunk move after a few sanity checks */\n \tchunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node);\n \n \tif ((rc = SPI_finish()) != SPI_OK_FINISH)\n \t\telog(ERROR, \"SPI_finish failed: %s\", SPI_result_code_string(rc));\n }",
  "diff_source": "custom",
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch modifies a function to restrict the search_path in SPI calls, preventing potential security issues. This change is a direct fix for a security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}