{
  "id": 3626,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33",
  "commit_sha": "79549c6dfda0603dba9a70a53467ce62d9335c33",
  "commit_msg": "cred: copy_process() should clear child->replacement_session_keyring\n\nkeyctl_session_to_parent(task) sets ->replacement_session_keyring,\nit should be processed and cleared by key_replace_session_keyring().\n\nHowever, this task can fork before it notices TIF_NOTIFY_RESUME and\nthe new child gets the bogus ->replacement_session_keyring copied by\ndup_task_struct(). This is obviously wrong and, if nothing else, this\nleads to put_cred(already_freed_cred).\n\nchange copy_creds() to clear this member. If copy_process() fails\nbefore this point the wrong ->replacement_session_keyring doesn't\nmatter, exit_creds() won't be called.\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "kernel/cred.c",
  "func_name": "copy_creds",
  "func_before": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}",
  "func_after": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\n\tp->replacement_session_keyring = NULL;\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int copy_creds(struct task_struct *p, unsigned long clone_flags)\n {\n #ifdef CONFIG_KEYS\n \tstruct thread_group_cred *tgcred;\n #endif\n \tstruct cred *new;\n \tint ret;\n+\n+\tp->replacement_session_keyring = NULL;\n \n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n #endif\n \t\tclone_flags & CLONE_THREAD\n \t    ) {\n \t\tp->real_cred = get_cred(p->cred);\n \t\tget_cred(p->cred);\n \t\talter_cred_subscribers(p->cred, 2);\n \t\tkdebug(\"share_creds(%p{%d,%d})\",\n \t\t       p->cred, atomic_read(&p->cred->usage),\n \t\t       read_cred_subscribers(p->cred));\n \t\tatomic_inc(&p->cred->user->processes);\n \t\treturn 0;\n \t}\n \n \tnew = prepare_creds();\n \tif (!new)\n \t\treturn -ENOMEM;\n \n \tif (clone_flags & CLONE_NEWUSER) {\n \t\tret = create_user_ns(new);\n \t\tif (ret < 0)\n \t\t\tgoto error_put;\n \t}\n \n \t/* cache user_ns in cred.  Doesn't need a refcount because it will\n \t * stay pinned by cred->user\n \t */\n \tnew->user_ns = new->user->user_ns;\n \n #ifdef CONFIG_KEYS\n \t/* new threads get their own thread keyrings if their parent already\n \t * had one */\n \tif (new->thread_keyring) {\n \t\tkey_put(new->thread_keyring);\n \t\tnew->thread_keyring = NULL;\n \t\tif (clone_flags & CLONE_THREAD)\n \t\t\tinstall_thread_keyring_to_cred(new);\n \t}\n \n \t/* we share the process and session keyrings between all the threads in\n \t * a process - this is slightly icky as we violate COW credentials a\n \t * bit */\n \tif (!(clone_flags & CLONE_THREAD)) {\n \t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n \t\tif (!tgcred) {\n \t\t\tret = -ENOMEM;\n \t\t\tgoto error_put;\n \t\t}\n \t\tatomic_set(&tgcred->usage, 1);\n \t\tspin_lock_init(&tgcred->lock);\n \t\ttgcred->process_keyring = NULL;\n \t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n \n \t\trelease_tgcred(new);\n \t\tnew->tgcred = tgcred;\n \t}\n #endif\n \n \tatomic_inc(&new->user->processes);\n \tp->cred = p->real_cred = get_cred(new);\n \talter_cred_subscribers(new, 2);\n \tvalidate_creds(new);\n \treturn 0;\n \n error_put:\n \tput_cred(new);\n \treturn ret;\n }",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a bug in the credential handling during process forking by clearing the replacement_session_keyring to prevent accessing already freed credentials, which could cause crashes or resource leaks.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.8"
}