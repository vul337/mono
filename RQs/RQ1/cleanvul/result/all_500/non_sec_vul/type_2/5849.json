{
  "id": 5849,
  "language": "C/C++",
  "commit_url": "https://github.com/Exim/exim/commit/d4bc023436e4cce7c23c5f8bb5199e178b4cc743",
  "commit_sha": "d4bc023436e4cce7c23c5f8bb5199e178b4cc743",
  "commit_msg": "Fix host_name_lookup (Close 2747)\n\nThanks to Nico R for providing a reproducing configuration.\n\n        host_lookup             = *\n        message_size_limit      = ${if def:sender_host_name {32M}{32M}}\n        acl_smtp_connect        = acl_smtp_connect\n        acl_smtp_rcpt           = acl_smtp_rcpt\n\n        begin acl\n          acl_smtp_connect:\n                warn ratelimit = 256 / 1m / per_conn\n                accept\n\n          acl_smtp_rcpt:\n                accept hosts = 127.0.0.*\n\n        begin routers\n        null:\n          driver          = accept\n          transport       = null\n\n        begin transports\n        null:\n          driver          = appendfile\n          file            = /dev/null\n\nTested with\n\n        swaks -f mailbox@example.org -t mailbox@example.org --pipe 'exim -bh 127.0.0.1 -C /opt/exim/etc/exim-bug.conf'\n\nThe IP must have a PTR to \"localhost.\" to reproduce it.\n\n(cherry picked from commit 20812729e3e47a193a21d326ecd036d67a8b2724)",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/src/host.c",
  "func_name": "host_name_lookup_byaddr",
  "func_before": "static int\nhost_name_lookup_byaddr(void)\n{\nstruct hostent * hosts;\nstruct in_addr addr;\nunsigned long time_msec = 0;\t/* init to quieten dumb static analysis */\n\nif (slow_lookup_log) time_msec = get_time_in_ms();\n\n/* Lookup on IPv6 system */\n\n#if HAVE_IPV6\nif (Ustrchr(sender_host_address, ':') != NULL)\n  {\n  struct in6_addr addr6;\n  if (inet_pton(AF_INET6, CS sender_host_address, &addr6) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv6 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr6, sizeof(addr6), AF_INET6, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr6, sizeof(addr6), AF_INET6);\n  #endif\n  }\nelse\n  {\n  if (inet_pton(AF_INET, CS sender_host_address, &addr) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv4 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr, sizeof(addr), AF_INET, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr, sizeof(addr), AF_INET);\n  #endif\n  }\n\n/* Do lookup on IPv4 system */\n\n#else\naddr.s_addr = (S_ADDR_TYPE)inet_addr(CS sender_host_address);\nhosts = gethostbyaddr(CS(&addr), sizeof(addr), AF_INET);\n#endif\n\nif (  slow_lookup_log\n   && (time_msec = get_time_in_ms() - time_msec) > slow_lookup_log\n   )\n  log_long_lookup(US\"gethostbyaddr\", sender_host_address, time_msec);\n\n/* Failed to look up the host. */\n\nif (!hosts)\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup failed: h_errno=%d\\n\",\n    h_errno);\n  return (h_errno == TRY_AGAIN || h_errno == NO_RECOVERY) ? DEFER : FAIL;\n  }\n\n/* It seems there are some records in the DNS that yield an empty name. We\ntreat this as non-existent. In some operating systems, this is returned as an\nempty string; in others as a single dot. */\n\nif (!hosts->h_name || !hosts->h_name[0] || hosts->h_name[0] == '.')\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup yielded an empty name: \"\n    \"treated as non-existent host name\\n\");\n  return FAIL;\n  }\n\n/* Copy and lowercase the name, which is in static storage in many systems.\nPut it in permanent memory. */\n\n  {\n  int old_pool = store_pool;\n  store_pool = POOL_TAINT_PERM;\t\t/* names are tainted */\n\n  sender_host_name = string_copylc(US hosts->h_name);\n\n  /* If the host has aliases, build a copy of the alias list */\n\n  if (hosts->h_aliases)\n    {\n    int count = 1;\n    uschar **ptr;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++) count++;\n    store_pool = POOL_PERM;\n    ptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);\n    store_pool = POOL_TAINT_PERM;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++)\n      *ptr++ = string_copylc(*aliases);\n    *ptr = NULL;\n    }\n  store_pool = old_pool;\n  }\n\nreturn OK;\n}",
  "func_after": "static int\nhost_name_lookup_byaddr(void)\n{\nstruct hostent * hosts;\nstruct in_addr addr;\nunsigned long time_msec = 0;\t/* init to quieten dumb static analysis */\n\nif (slow_lookup_log) time_msec = get_time_in_ms();\n\n/* Lookup on IPv6 system */\n\n#if HAVE_IPV6\nif (Ustrchr(sender_host_address, ':') != NULL)\n  {\n  struct in6_addr addr6;\n  if (inet_pton(AF_INET6, CS sender_host_address, &addr6) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv6 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr6, sizeof(addr6), AF_INET6, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr6, sizeof(addr6), AF_INET6);\n  #endif\n  }\nelse\n  {\n  if (inet_pton(AF_INET, CS sender_host_address, &addr) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv4 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr, sizeof(addr), AF_INET, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr, sizeof(addr), AF_INET);\n  #endif\n  }\n\n/* Do lookup on IPv4 system */\n\n#else\naddr.s_addr = (S_ADDR_TYPE)inet_addr(CS sender_host_address);\nhosts = gethostbyaddr(CS(&addr), sizeof(addr), AF_INET);\n#endif\n\nif (  slow_lookup_log\n   && (time_msec = get_time_in_ms() - time_msec) > slow_lookup_log\n   )\n  log_long_lookup(US\"gethostbyaddr\", sender_host_address, time_msec);\n\n/* Failed to look up the host. */\n\nif (!hosts)\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup failed: h_errno=%d\\n\",\n    h_errno);\n  return (h_errno == TRY_AGAIN || h_errno == NO_RECOVERY) ? DEFER : FAIL;\n  }\n\n/* It seems there are some records in the DNS that yield an empty name. We\ntreat this as non-existent. In some operating systems, this is returned as an\nempty string; in others as a single dot. */\n\nif (!hosts->h_name || !hosts->h_name[0] || hosts->h_name[0] == '.')\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup yielded an empty name: \"\n    \"treated as non-existent host name\\n\");\n  return FAIL;\n  }\n\n/* Copy and lowercase the name, which is in static storage in many systems.\nPut it in permanent memory. */\n\n  {\n  int old_pool = store_pool;\n  store_pool = POOL_TAINT_PERM;\t\t/* names are tainted */\n\n  sender_host_name = string_copylc(US hosts->h_name);\n\n  /* If the host has aliases, build a copy of the alias list */\n\n  if (hosts->h_aliases)\n    {\n    int count = 1;  /* need 1 more for terminating NULL */\n    uschar **ptr;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++) count++;\n    store_pool = POOL_PERM;\n    ptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);\n    store_pool = POOL_TAINT_PERM;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++)\n      *ptr++ = string_copylc(*aliases);\n    *ptr = NULL;\n    }\n  store_pool = old_pool;\n  }\n\nreturn OK;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int\n host_name_lookup_byaddr(void)\n {\n struct hostent * hosts;\n struct in_addr addr;\n unsigned long time_msec = 0;\t/* init to quieten dumb static analysis */\n \n if (slow_lookup_log) time_msec = get_time_in_ms();\n \n /* Lookup on IPv6 system */\n \n #if HAVE_IPV6\n if (Ustrchr(sender_host_address, ':') != NULL)\n   {\n   struct in6_addr addr6;\n   if (inet_pton(AF_INET6, CS sender_host_address, &addr6) != 1)\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n       \"IPv6 address\", sender_host_address);\n   #if HAVE_GETIPNODEBYADDR\n   hosts = getipnodebyaddr(CS &addr6, sizeof(addr6), AF_INET6, &h_errno);\n   #else\n   hosts = gethostbyaddr(CS &addr6, sizeof(addr6), AF_INET6);\n   #endif\n   }\n else\n   {\n   if (inet_pton(AF_INET, CS sender_host_address, &addr) != 1)\n     log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n       \"IPv4 address\", sender_host_address);\n   #if HAVE_GETIPNODEBYADDR\n   hosts = getipnodebyaddr(CS &addr, sizeof(addr), AF_INET, &h_errno);\n   #else\n   hosts = gethostbyaddr(CS &addr, sizeof(addr), AF_INET);\n   #endif\n   }\n \n /* Do lookup on IPv4 system */\n \n #else\n addr.s_addr = (S_ADDR_TYPE)inet_addr(CS sender_host_address);\n hosts = gethostbyaddr(CS(&addr), sizeof(addr), AF_INET);\n #endif\n \n if (  slow_lookup_log\n    && (time_msec = get_time_in_ms() - time_msec) > slow_lookup_log\n    )\n   log_long_lookup(US\"gethostbyaddr\", sender_host_address, time_msec);\n \n /* Failed to look up the host. */\n \n if (!hosts)\n   {\n   HDEBUG(D_host_lookup) debug_printf(\"IP address lookup failed: h_errno=%d\\n\",\n     h_errno);\n   return (h_errno == TRY_AGAIN || h_errno == NO_RECOVERY) ? DEFER : FAIL;\n   }\n \n /* It seems there are some records in the DNS that yield an empty name. We\n treat this as non-existent. In some operating systems, this is returned as an\n empty string; in others as a single dot. */\n \n if (!hosts->h_name || !hosts->h_name[0] || hosts->h_name[0] == '.')\n   {\n   HDEBUG(D_host_lookup",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nFinal Output:\nAnalysis: The patch addresses a bug in the hostname lookup function, handling IPv4 and IPv6 addresses and improving error handling. It doesn't directly fix a security vulnerability but corrects a functional issue.\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.8"
}