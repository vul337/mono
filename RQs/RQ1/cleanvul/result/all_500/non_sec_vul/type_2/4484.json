{
  "id": 4484,
  "language": "C/C++",
  "commit_url": "https://github.com/alandekok/freeradius-server/commit/ff94dd35673bba1476594299d31ce8293b8bd223",
  "commit_sha": "ff94dd35673bba1476594299d31ce8293b8bd223",
  "commit_msg": "Do not delete \"old\" requests until they are free.\n\nIf the request is in the queue for 30+ seconds, do NOT delete it.\nInstead, mark it as \"STOP PROCESSING\", and do \"wait_for_child_to_die\",\nwhich waits for a child thread to pick it up, and acknowledge that it's\ndone.  Once it's marked done, we can finally clean it up.\n\nThis may be the underlying issue behind bug #35",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/main/event.c",
  "func_name": "wait_a_bit",
  "func_before": "static void wait_a_bit(void *ctx)\n{\n\tstruct timeval when;\n\tREQUEST *request = ctx;\n\tfr_event_callback_t callback = NULL;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\n#ifdef WITH_COA\n\t/*\n\t *\tThe CoA request is a new (internally generated)\n\t *\trequest, created in a child thread.  We therefore need\n\t *\tsome way to tie its events back into the main event\n\t *\thandler.\n\t */\n\tif (request->coa && !request->coa->proxy_reply &&\n\t    request->coa->next_callback) {\n\t\trequest->coa->when = request->coa->next_when;\n\t\tINSERT_EVENT(request->coa->next_callback, request->coa);\n\t\trequest->coa->next_callback = NULL;\n\t\trequest->coa->parent = NULL;\n\t\trequest->coa = NULL;\n\t}\n#endif\n\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\twhen = request->received;\n\t\twhen.tv_sec += request->root->max_request_time;\n\n\t\t/*\n\t\t *\tNormally called from the event loop with the\n\t\t *\tproper event loop time.  Otherwise, called from\n\t\t *\tpost proxy fail handler, which sets \"now\", and\n\t\t *\tthis call won't re-set it, because we're not\n\t\t *\tin the event loop.\n\t\t */\n\t\tfr_event_now(el, &now);\n\n\t\t/*\n\t\t *\tRequest still has more time.  Continue\n\t\t *\twaiting.\n\t\t */\n\t\tif (timercmp(&now, &when, <) ||\n\t\t    ((request->listener->type == RAD_LISTEN_DETAIL) &&\n\t\t     (request->child_state == REQUEST_QUEUED))) {\n\t\t\tif (request->delay < (USEC / 10)) {\n\t\t\t\trequest->delay = USEC / 10;\n\t\t\t}\n\t\t\trequest->delay += request->delay >> 1;\n\n#ifdef WITH_DETAIL\n\t\t\t/*\n\t\t\t *\tCap wait at some sane value for detail\n\t\t\t *\tfiles.\n\t\t\t */\n\t\t\tif ((request->listener->type == RAD_LISTEN_DETAIL) &&\n\t\t\t    (request->delay > (request->root->max_request_time * USEC))) {\n\t\t\t\trequest->delay = request->root->max_request_time * USEC;\n\t\t\t}\n#endif\n\n\t\t\trequest->when = now;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_a_bit;\n\t\t\tbreak;\n\t\t}\n\n#if defined(HAVE_PTHREAD_H)\n\t\t/*\n\t\t *\tA child thread MAY still be running on the\n\t\t *\trequest.  Ask the thread to stop working on\n\t\t *\tthe request.\n\t\t */\n\t\tif (have_children &&\n\t\t    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {\n\t\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n\n\t\t\tradlog(L_ERR, \"WARNING: Unresponsive child for request %u, in module %s component %s\",\n\t\t\t       request->number,\n\t\t\t       request->module ? request->module : \"<server core>\",\n\t\t\t       request->component ? request->component : \"<server core>\");\n\t\t\t\n\t\t\trequest->delay = USEC / 4;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_for_child_to_die;\n\t\t\tbreak;\n\t\t}\n#endif\n\n\t\t/*\n\t\t *\tElse no child thread is processing the\n\t\t *\trequest.  We probably should have just marked\n\t\t *\tthe request as 'done' elsewhere, like in the\n\t\t *\tpost-proxy-fail handler.  But doing that would\n\t\t *\tinvolve checking for max_request_time in\n\t\t *\tmultiple places, so this may be simplest.\n\t\t */\n\t\trequest->child_state = REQUEST_DONE;\n\t\t/* FALL-THROUGH */\n\n\t\t/*\n\t\t *\tMark the request as no longer running,\n\t\t *\tand clean it up.\n\t\t */\n\tcase REQUEST_DONE:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n#ifdef WITH_COA\n\t\t/*\n\t\t *\tThis is a CoA request.  It's been divorced\n\t\t *\tfrom everything else, so we clean it up now.\n\t\t */\n\t\tif (!request->in_request_hash &&\n\t\t    request->proxy &&\n\t\t    (request->packet->code != request->proxy->code) &&\n\t\t    ((request->proxy->code == PW_COA_REQUEST) ||\n\t\t     (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t\t\t/*\n\t\t\t *\tFIXME: Do CoA MIBs\n\t\t\t */\n\t\t\tev_request_free(&request);\n\t\t\treturn;\n\t\t}\n#endif\n\t\trequest_stats_final(request);\n\t\tcleanup_delay(request);\n\t\treturn;\n\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\trequest_stats_final(request);\n\n\tcase REQUEST_PROXIED:\n\t\trad_assert(request->next_callback != NULL);\n\t\trad_assert(request->next_callback != wait_a_bit);\n\n\t\trequest->when = request->next_when;\n\t\tcallback = request->next_callback;\n\t\trequest->next_callback = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\trad_panic(\"Internal sanity check failure\");\n\t\treturn;\n\t}\n\n\t/*\n\t *\tSomething major went wrong.  Discard the request, and\n\t *\tkeep running.\n\t *\n\t *\tFIXME: No idea why this happens or how to fix it...\n\t *\tIt seems to happen *only* when requests are proxied,\n\t *\tand where the home server doesn't respond.  So it looks\n\t *\tlike a race condition above, but it happens in debug\n\t *\tmode, with no threads...\n\t */\n\tif (!callback) {\n\t\tRDEBUG(\"WARNING: Internal sanity check failed in event handler for request %u: Discarding the request!\", request->number);\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\n\tINSERT_EVENT(callback, request);\n}",
  "func_after": "static void wait_a_bit(void *ctx)\n{\n\tstruct timeval when;\n\tREQUEST *request = ctx;\n\tfr_event_callback_t callback = NULL;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\n#ifdef WITH_COA\n\t/*\n\t *\tThe CoA request is a new (internally generated)\n\t *\trequest, created in a child thread.  We therefore need\n\t *\tsome way to tie its events back into the main event\n\t *\thandler.\n\t */\n\tif (request->coa && !request->coa->proxy_reply &&\n\t    request->coa->next_callback) {\n\t\trequest->coa->when = request->coa->next_when;\n\t\tINSERT_EVENT(request->coa->next_callback, request->coa);\n\t\trequest->coa->next_callback = NULL;\n\t\trequest->coa->parent = NULL;\n\t\trequest->coa = NULL;\n\t}\n#endif\n\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\t/*\n\t\t *\tIf we're not thread-capable, OR we're capable,\n\t\t *\tbut have been told to run without threads,\n\t\t *\tcomplain when the requests is queued for a\n\t\t *\tthread, or running in a child thread.\n\t\t */\n#ifdef HAVE_PTHREAD_H\n\t\tif (!have_children)\n#endif\n\t\t{\n\t\t\trad_assert(\"We do not have threads, but the request is marked as queued or running in a child thread\" == NULL);\n\t\t\tbreak;\n\t\t}\n\n#ifdef HAVE_PTHREAD_H\n\t\t/*\n\t\t *\tIf we have threads, wait for the child thread\n\t\t *\tto stop.\n\t\t */\n\t\twhen = request->received;\n\t\twhen.tv_sec += request->root->max_request_time;\n\n\t\t/*\n\t\t *\tNormally called from the event loop with the\n\t\t *\tproper event loop time.  Otherwise, called from\n\t\t *\tpost proxy fail handler, which sets \"now\", and\n\t\t *\tthis call won't re-set it, because we're not\n\t\t *\tin the event loop.\n\t\t */\n\t\tfr_event_now(el, &now);\n\n\t\t/*\n\t\t *\tRequest still has more time.  Continue\n\t\t *\twaiting.\n\t\t */\n\t\tif (timercmp(&now, &when, <)) {\n\t\t\tif (request->delay < (USEC / 10)) {\n\t\t\t\trequest->delay = USEC / 10;\n\t\t\t}\n\t\t\trequest->delay += request->delay >> 1;\n\n\t\t\t/*\n\t\t\t *\tCap delays at something reasonable.\n\t\t\t */\n\t\t\tif (request->delay > (request->root->max_request_time * USEC)) {\n\t\t\t\trequest->delay = request->root->max_request_time * USEC;\n\t\t\t}\n\n\t\t\trequest->when = now;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_a_bit;\n\t\t\tbreak;\n\t\t}\n\n\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n\n\t\t/*\n\t\t *\tA child thread MAY still be running on the\n\t\t *\trequest.  Ask the thread to stop working on\n\t\t *\tthe request.\n\t\t */\n\t\tif (have_children &&\n\t\t    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {\n\t\t\tradlog(L_ERR, \"WARNING: Unresponsive child for request %u, in module %s component %s\",\n\t\t\t       request->number,\n\t\t\t       request->module ? request->module : \"<server core>\",\n\t\t\t       request->component ? request->component : \"<server core>\");\n\t\t}\n\t\t\t\n\t\trequest->delay = USEC;\n\t\ttv_add(&request->when, request->delay);\n\t\tcallback = wait_for_child_to_die;\n\t\tbreak;\n#endif\n\n\t\t/*\n\t\t *\tMark the request as no longer running,\n\t\t *\tand clean it up.\n\t\t */\n\tcase REQUEST_DONE:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n#ifdef WITH_COA\n\t\t/*\n\t\t *\tThis is a CoA request.  It's been divorced\n\t\t *\tfrom everything else, so we clean it up now.\n\t\t */\n\t\tif (!request->in_request_hash &&\n\t\t    request->proxy &&\n\t\t    (request->packet->code != request->proxy->code) &&\n\t\t    ((request->proxy->code == PW_COA_REQUEST) ||\n\t\t     (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t\t\t/*\n\t\t\t *\tFIXME: Do CoA MIBs\n\t\t\t */\n\t\t\tev_request_free(&request);\n\t\t\treturn;\n\t\t}\n#endif\n\t\trequest_stats_final(request);\n\t\tcleanup_delay(request);\n\t\treturn;\n\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\trequest_stats_final(request);\n\n\tcase REQUEST_PROXIED:\n\t\trad_assert(request->next_callback != NULL);\n\t\trad_assert(request->next_callback != wait_a_bit);\n\n\t\trequest->when = request->next_when;\n\t\tcallback = request->next_callback;\n\t\trequest->next_callback = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\trad_panic(\"Internal sanity check failure\");\n\t\treturn;\n\t}\n\n\t/*\n\t *\tSomething major went wrong.  Discard the request, and\n\t *\tkeep running.\n\t *\n\t *\tFIXME: No idea why this happens or how to fix it...\n\t *\tIt seems to happen *only* when requests are proxied,\n\t *\tand where the home server doesn't respond.  So it looks\n\t *\tlike a race condition above, but it happens in debug\n\t *\tmode, with no threads...\n\t */\n\tif (!callback) {\n\t\tRDEBUG(\"WARNING: Internal sanity check failed in event handler for request %u: Discarding the request!\", request->number);\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\n\tINSERT_EVENT(callback, request);\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void wait_a_bit(void *ctx)\n {\n \tstruct timeval when;\n \tREQUEST *request = ctx;\n \tfr_event_callback_t callback = NULL;\n \n \trad_assert(request->magic == REQUEST_MAGIC);\n \n #ifdef WITH_COA\n \t/*\n \t *\tThe CoA request is a new (internally generated)\n \t *\trequest, created in a child thread.  We therefore need\n \t *\tsome way to tie its events back into the main event\n \t *\thandler.\n \t */\n \tif (request->coa && !request->coa->proxy_reply &&\n \t    request->coa->next_callback) {\n \t\trequest->coa->when = request->coa->next_when;\n \t\tINSERT_EVENT(request->coa->next_callback, request->coa);\n \t\trequest->coa->next_callback = NULL;\n \t\trequest->coa->parent = NULL;\n \t\trequest->coa = NULL;\n \t}\n #endif\n \n \tswitch (request->child_state) {\n \tcase REQUEST_QUEUED:\n \tcase REQUEST_RUNNING:\n+\t\t/*\n+\t\t *\tIf we're not thread-capable, OR we're capable,\n+\t\t *\tbut have been told to run without threads,\n+\t\t *\tcomplain when the requests is queued for a\n+\t\t *\tthread, or running in a child thread.\n+\t\t */\n+#ifdef HAVE_PTHREAD_H\n+\t\tif (!have_children)\n+#endif\n+\t\t{\n+\t\t\trad_assert(\"We do not have threads, but the request is marked as queued or running in a child thread\" == NULL);\n+\t\t\tbreak;\n+\t\t}\n+\n+#ifdef HAVE_PTHREAD_H\n+\t\t/*\n+\t\t *\tIf we have threads, wait for the child thread\n+\t\t *\tto stop.\n+\t\t */\n \t\twhen = request->received;\n \t\twhen.tv_sec += request->root->max_request_time;\n \n \t\t/*\n \t\t *\tNormally called from the event loop with the\n \t\t *\tproper event loop time.  Otherwise, called from\n \t\t *\tpost proxy fail handler, which sets \"now\", and\n \t\t *\tthis call won't re-set it, because we're not\n \t\t *\tin the event loop.\n \t\t */\n \t\tfr_event_now(el, &now);\n \n \t\t/*\n \t\t *\tRequest still has more time.  Continue\n \t\t *\twaiting.\n \t\t */\n-\t\tif (timercmp(&now, &when, <) ||\n+\t\tif (timercmp(&now, &when, <)) {\n-\t\t    ((request->listener->type == RAD_LISTEN_DETAIL) &&\n-\t\t     (request->child_state == REQUEST_QUEUED))) {\n \t\t\tif (request->delay < (USEC / 10)) {\n \t\t\t\trequest->delay = USEC / 10;\n \t\t",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch modifies the `wait_a_bit` function to handle request states correctly, preventing premature deletion and ensuring proper cleanup, particularly in non-threaded environments. It adds assertions and modifies timeout conditions. The changes address a bug affecting request processing but do not fix a security vulnerability.\n\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis**: The commit modifies request handling in a non-threaded environment, adding assertions and adjusting timeout logic to prevent incorrect states and premature cleanup.\n\n2. **Security Assessment**: The changes don't address security issues like unauthorized access or data breaches. They focus on system stability and request management.\n\n3. **Classification**: The fix resolves a bug affecting system behavior, not a security vulnerability, thus classified under Defect Remediation.\n\n4. **Confidence**: High confidence as the code changes clearly target bug correction without security implications."
}