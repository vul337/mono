{
  "id": 7162,
  "language": "C/C++",
  "commit_url": "https://github.com/klange/toaruos/commit/5d36d27bb9da768ae45dadd5a6b50c8981935d82",
  "commit_sha": "5d36d27bb9da768ae45dadd5a6b50c8981935d82",
  "commit_msg": "readelf: Add several sanity checks.\n\nShould resolve several reported issues.\n\nFixes #245\nFixes #244\nFixes #243",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "apps/readelf.c",
  "func_name": "main",
  "func_before": "int main(int argc, char * argv[]) {\n\n\tstatic struct option long_opts[] = {\n\t\t{\"all\",             no_argument, 0, 'a'},\n\t\t{\"file-header\",     no_argument, 0, 'h'},\n\t\t{\"program-headers\", no_argument, 0, 'l'},\n\t\t{\"section-headers\", no_argument, 0, 'S'},\n\t\t{\"headers\",         no_argument, 0, 'e'},\n\t\t{\"syms\",            no_argument, 0, 's'},\n\t\t{\"dynamic\",         no_argument, 0, 'd'},\n\t\t{\"relocs\",          no_argument, 0, 'r'},\n\t\t{\"help\",            no_argument, 0, 'H'},\n\n\t\t{\"segments\",        no_argument, 0, 'l'}, /* Alias for --program-headers */\n\t\t{\"sections\",        no_argument, 0, 'S'}, /* Alias for --section-headers */\n\t\t{\"symbols\",         no_argument, 0, 's'}, /* Alias for --syms */\n\t\t{0,0,0,0}\n\t};\n\n\tint show_bits = 0;\n\tint index, c;\n\n\twhile ((c = getopt_long(argc, argv, \"ahlSesdrH\", long_opts, &index)) != -1) {\n\t\tif (!c) {\n\t\t\tif (long_opts[index].flag == 0) {\n\t\t\t\tc = long_opts[index].val;\n\t\t\t}\n\t\t}\n\t\tswitch (c) {\n\t\t\tcase 'H':\n\t\t\t\treturn usage(argv);\n\t\t\tcase 'a':\n\t\t\t\tshow_bits |= SHOW_FILE_HEADER | SHOW_SECTION_HEADERS | SHOW_PROGRAM_HEADERS | SHOW_SYMBOLS | SHOW_DYNAMIC | SHOW_RELOCATIONS;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tshow_bits |= SHOW_DYNAMIC;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tshow_bits |= SHOW_FILE_HEADER;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tshow_bits |= SHOW_PROGRAM_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshow_bits |= SHOW_SECTION_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tshow_bits |= SHOW_FILE_HEADER | SHOW_PROGRAM_HEADERS | SHOW_SECTION_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tshow_bits |= SHOW_SYMBOLS;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tshow_bits |= SHOW_RELOCATIONS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Unrecognized option: %c\\n\", c);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind >= argc || !show_bits) {\n\t\treturn usage(argv);\n\t}\n\n\tint out = 0;\n\tint print_names = 0;\n\n\tif (optind + 1 < argc) {\n\t\tprint_names = 1;\n\t}\n\n\tfor (; optind < argc; optind++) {\n\t\tFILE * f = fopen(argv[optind],\"r\");\n\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"%s: %s: %s\\n\", argv[0], argv[optind], strerror(errno));\n\t\t\tout = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (print_names) {\n\t\t\tprintf(\"\\nFile: %s\\n\", argv[optind]);\n\t\t}\n\n\t\t/**\n\t\t * Validate header.\n\t\t */\n\t\tElf64_Header header;\n\t\tfread(&header, sizeof(Elf64_Header), 1, f);\n\n\t\tif (memcmp(\"\\x7F\" \"ELF\",&header,4)) {\n\t\t\tfprintf(stderr, \"%s: %s: not an elf\\n\", argv[0], argv[optind]);\n\t\t\tout = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (show_bits & SHOW_FILE_HEADER) {\n\t\t\tprintf(\"ELF Header:\\n\");\n\t\t\tprintf(\"  Magic:   %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\\n\",\n\t\t\t\theader.e_ident[0],  header.e_ident[1],  header.e_ident[2],  header.e_ident[3],\n\t\t\t\theader.e_ident[4],  header.e_ident[5],  header.e_ident[6],  header.e_ident[7],\n\t\t\t\theader.e_ident[8],  header.e_ident[9],  header.e_ident[10], header.e_ident[11],\n\t\t\t\theader.e_ident[12], header.e_ident[13], header.e_ident[14], header.e_ident[15]);\n\t\t\tprintf(\"  Class:                             %s\\n\", elf_classToStr(header.e_ident[EI_CLASS]));\n\t\t\tprintf(\"  Data:                              %s\\n\", elf_dataToStr(header.e_ident[EI_DATA]));\n\t\t\tprintf(\"  Version:                           %s\\n\", elf_versionToStr(header.e_ident[EI_VERSION]));\n\t\t\tprintf(\"  OS/ABI:                            %s\\n\", elf_osabiToStr(header.e_ident[EI_OSABI]));\n\t\t\tprintf(\"  ABI Version:                       %u\\n\", header.e_ident[EI_ABIVERSION]);\n\t\t}\n\n\t\tif (header.e_ident[EI_CLASS] != ELFCLASS64) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (show_bits & SHOW_FILE_HEADER) {\n\t\t\t/* Byte-order dependent from here on out... */\n\t\t\tprintf(\"  Type:                              %s\\n\", elf_typeToStr(header.e_type));\n\t\t\tprintf(\"  Machine:                           %s\\n\", elf_machineToStr(header.e_machine));\n\t\t\tprintf(\"  Version:                           0x%x\\n\", header.e_version);\n\t\t\tprintf(\"  Entry point address:               0x%lx\\n\", header.e_entry);\n\t\t\tprintf(\"  Start of program headers:          %lu (bytes into file)\\n\", header.e_phoff);\n\t\t\tprintf(\"  Start of section headers:          %lu (bytes into file)\\n\", header.e_shoff);\n\t\t\tprintf(\"  Flags:                             0x%x\\n\", header.e_flags);\n\t\t\tprintf(\"  Size of this header:               %u (bytes)\\n\", header.e_ehsize);\n\t\t\tprintf(\"  Size of program headers:           %u (bytes)\\n\", header.e_phentsize);\n\t\t\tprintf(\"  Number of program headers:         %u\\n\", header.e_phnum);\n\t\t\tprintf(\"  Size of section headers:           %u (bytes)\\n\", header.e_shentsize);\n\t\t\tprintf(\"  Number of section headers:         %u\\n\", header.e_shnum);\n\t\t\tprintf(\"  Section header string table index: %u\\n\", header.e_shstrndx);\n\t\t}\n\n\t\t/* Get the section header string table */\n\t\tElf64_Shdr shstr_hdr;\n\t\tfseek(f, header.e_shoff + header.e_shentsize * header.e_shstrndx, SEEK_SET);\n\t\tfread(&shstr_hdr, sizeof(Elf64_Shdr), 1, f);\n\n\t\tchar * stringTable = malloc(shstr_hdr.sh_size);\n\t\tfseek(f, shstr_hdr.sh_offset, SEEK_SET);\n\t\tfread(stringTable, shstr_hdr.sh_size, 1, f);\n\n\t\t/**\n\t\t * Section Headers\n\t\t */\n\t\tif (show_bits & SHOW_SECTION_HEADERS) {\n\t\t\tprintf(\"\\nSection Headers:\\n\");\n\t\t\tprintf(\"  [Nr] Name              Type             Address           Offset\\n\");\n\t\t\tprintf(\"       Size              EntSize          Flags  Link  Info  Align\\n\");\n\t\t\tfor (unsigned int i = 0; i < header.e_shnum; ++i) {\n\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * i, SEEK_SET);\n\t\t\t\tElf64_Shdr sectionHeader;\n\t\t\t\tfread(&sectionHeader, sizeof(Elf64_Shdr), 1, f);\n\n\t\t\t\tprintf(\"  [%2d] %-17.17s %-16.16s %016lx  %08lx\\n\",\n\t\t\t\t\ti, stringTable + sectionHeader.sh_name, sectionHeaderTypeToStr(sectionHeader.sh_type),\n\t\t\t\t\tsectionHeader.sh_addr, sectionHeader.sh_offset);\n\t\t\t\tprintf(\"       %016lx  %016lx %4ld %6d %5d %5ld\\n\",\n\t\t\t\t\tsectionHeader.sh_size, sectionHeader.sh_entsize, sectionHeader.sh_flags,\n\t\t\t\t\tsectionHeader.sh_link, sectionHeader.sh_info, sectionHeader.sh_addralign);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Program Headers\n\t\t */\n\t\tif (show_bits & SHOW_PROGRAM_HEADERS && header.e_phoff && header.e_phnum) {\n\t\t\tprintf(\"\\nProgram Headers:\\n\");\n\t\t\tprintf(\"  Type           Offset             VirtAddr           PhysAddr\\n\");\n\t\t\tprintf(\"                 FileSiz            MemSiz              Flags  Align\\n\");\n\t\t\tfor (unsigned int i = 0; i < header.e_phnum; ++i) {\n\t\t\t\tfseek(f, header.e_phoff + header.e_phentsize * i, SEEK_SET);\n\t\t\t\tElf64_Phdr programHeader;\n\t\t\t\tfread(&programHeader, sizeof(Elf64_Phdr), 1, f);\n\n\t\t\t\tprintf(\"  %-14.14s 0x%016lx 0x%016lx 0x%016lx\\n\",\n\t\t\t\t\tprogramHeaderTypeToStr(programHeader.p_type),\n\t\t\t\t\tprogramHeader.p_offset, programHeader.p_vaddr, programHeader.p_paddr);\n\t\t\t\tprintf(\"                 0x%016lx 0x%016lx  %s 0x%lx\\n\",\n\t\t\t\t\tprogramHeader.p_filesz, programHeader.p_memsz,\n\t\t\t\t\tprogramHeaderFlagsToStr(programHeader.p_flags), programHeader.p_align);\n\n\t\t\t\tif (programHeader.p_type == PT_INTERP) {\n\t\t\t\t\t/* Read interpreter string */\n\t\t\t\t\tchar * tmp = malloc(programHeader.p_filesz);\n\t\t\t\t\tfseek(f, programHeader.p_offset, SEEK_SET);\n\t\t\t\t\tfread(tmp, programHeader.p_filesz, 1, f);\n\t\t\t\t\tprintf(\"    [Requesting program interpreter: %.*s]\\n\",\n\t\t\t\t\t\t(int)programHeader.p_filesz, tmp);\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* TODO Section to segment mapping? */\n\n\t\t/**\n\t\t * Dump section information.\n\t\t */\n\t\tfor (unsigned int i = 0; i < header.e_shnum; ++i) {\n\t\t\tfseek(f, header.e_shoff + header.e_shentsize * i, SEEK_SET);\n\t\t\tElf64_Shdr sectionHeader;\n\t\t\tfread(&sectionHeader, sizeof(Elf64_Shdr), 1, f);\n\n\t\t\t/* I think there should only be one of these... */\n\t\t\tswitch (sectionHeader.sh_type) {\n\t\t\t\tcase SHT_DYNAMIC:\n\t\t\t\t\tif (show_bits & SHOW_DYNAMIC) {\n\t\t\t\t\t\tprintf(\"\\nDynamic section at offset 0x%lx contains (up to) %ld entries:\\n\",\n\t\t\t\t\t\t\tsectionHeader.sh_offset, sectionHeader.sh_size / sectionHeader.sh_entsize);\n\t\t\t\t\t\tprintf(\"  Tag        Type                         Name/Value\\n\");\n\n\t\t\t\t\t\t/* Read the linked string table */\n\t\t\t\t\t\tElf64_Shdr dynstr;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * sectionHeader.sh_link, SEEK_SET);\n\t\t\t\t\t\tfread(&dynstr, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\tchar * dynStr = malloc(dynstr.sh_size);\n\t\t\t\t\t\tfseek(f, dynstr.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(dynStr, dynstr.sh_size, 1, f);\n\n\t\t\t\t\t\tchar * dynTable = malloc(sectionHeader.sh_size);\n\t\t\t\t\t\tfseek(f, sectionHeader.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(dynTable, sectionHeader.sh_size, 1, f);\n\n\t\t\t\t\t\tfor (unsigned int i = 0; i < sectionHeader.sh_size / sectionHeader.sh_entsize; i++) {\n\t\t\t\t\t\t\tElf64_Dyn * dynEntry = (Elf64_Dyn *)(dynTable + sectionHeader.sh_entsize * i);\n\n\t\t\t\t\t\t\tprintf(\" 0x%016lx %s\\n\",\n\t\t\t\t\t\t\t\tdynEntry->d_tag,\n\t\t\t\t\t\t\t\tdynamicTagToStr(dynEntry, dynStr));\n\n\t\t\t\t\t\t\tif (dynEntry->d_tag == DT_NULL) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(dynStr);\n\t\t\t\t\t\tfree(dynTable);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SHT_RELA:\n\t\t\t\t\tif (show_bits & SHOW_RELOCATIONS) {\n\t\t\t\t\t\tprintf(\"\\nRelocation section '%s' at offset 0x%lx contains %ld entries.\\n\",\n\t\t\t\t\t\t\tstringTable + sectionHeader.sh_name, sectionHeader.sh_offset,\n\t\t\t\t\t\t\tsectionHeader.sh_size / sizeof(Elf64_Rela));\n\t\t\t\t\t\tprintf(\"  Offset          Info           Type           Sym. Value    Sym. Name + Addend\\n\");\n\n\t\t\t\t\t\t/* Section this relocation is in */\n\t\t\t\t\t\tElf64_Shdr shdr_this;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * sectionHeader.sh_info, SEEK_SET);\n\t\t\t\t\t\tfread(&shdr_this, sizeof(Elf64_Shdr), 1, f);\n\n\t\t\t\t\t\t/* Symbol table link */\n\t\t\t\t\t\tElf64_Shdr shdr_symtab;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * sectionHeader.sh_link, SEEK_SET);\n\t\t\t\t\t\tfread(&shdr_symtab, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\tElf64_Sym * symtab = malloc(shdr_symtab.sh_size);\n\t\t\t\t\t\tfseek(f, shdr_symtab.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(symtab, shdr_symtab.sh_size, 1, f);\n\n\t\t\t\t\t\t/* Symbol table's string table link */\n\t\t\t\t\t\tElf64_Shdr shdr_strtab;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * shdr_symtab.sh_link, SEEK_SET);\n\t\t\t\t\t\tfread(&shdr_strtab, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\tchar * strtab = malloc(shdr_strtab.sh_size);\n\t\t\t\t\t\tfseek(f, shdr_strtab.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(strtab, shdr_strtab.sh_size, 1, f);\n\n\t\t\t\t\t\t/* Load relocations from file */\n\t\t\t\t\t\tElf64_Rela * relocations = malloc(sectionHeader.sh_size);\n\t\t\t\t\t\tfseek(f, sectionHeader.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread((void*)relocations, sectionHeader.sh_size, 1, f);\n\n\t\t\t\t\t\tfor (unsigned int i = 0; i < sectionHeader.sh_size / sizeof(Elf64_Rela); ++i) {\n\t\t\t\t\t\t\tElf64_Shdr shdr;\n\t\t\t\t\t\t\tElf64_Sym * this = &symtab[ELF64_R_SYM(relocations[i].r_info)];\n\t\t\t\t\t\t\tchar * symName;\n\n\t\t\t\t\t\t\t/* Get symbol name for this relocation */\n\t\t\t\t\t\t\tif ((this->st_info & 0xF) == STT_SECTION) {\n\t\t\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * this->st_shndx, SEEK_SET);\n\t\t\t\t\t\t\t\tfread(&shdr, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\t\t\tsymName = stringTable + shdr.sh_name;\n\t\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\t\tsymName = strtab + this->st_name;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Get the value currently in the section data */\n\t\t\t\t\t\t\tElf64_Xword value = 0;\n\t\t\t\t\t\t\tint valueSize = sizeOfRelocationValue(ELF64_R_TYPE(relocations[i].r_info));\n\t\t\t\t\t\t\tfseek(f, shdr_this.sh_offset + relocations[i].r_offset, SEEK_SET);\n\t\t\t\t\t\t\tswitch (valueSize) {\n\t\t\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tuint64_t val;\n\t\t\t\t\t\t\t\t\t\tfread(&val, valueSize, 1, f);\n\t\t\t\t\t\t\t\t\t\tvalue = val;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tuint32_t val;\n\t\t\t\t\t\t\t\t\t\tfread(&val, valueSize, 1, f);\n\t\t\t\t\t\t\t\t\t\tvalue = val;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tuint16_t val;\n\t\t\t\t\t\t\t\t\t\tfread(&val, valueSize, 1, f);\n\t\t\t\t\t\t\t\t\t\tvalue = val;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tuint8_t val;\n\t\t\t\t\t\t\t\t\t\tfread(&val, valueSize, 1, f);\n\t\t\t\t\t\t\t\t\t\tvalue = val;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprintf(\"%012lx  %012lx %-15.15s %016lx %s + %lx\\n\",\n\t\t\t\t\t\t\t\trelocations[i].r_offset, relocations[i].r_info,\n\t\t\t\t\t\t\t\trelocationInfoToStr(ELF64_R_TYPE(relocations[i].r_info)),\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\tsymName,\n\t\t\t\t\t\t\t\trelocations[i].r_addend);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(relocations);\n\t\t\t\t\t\tfree(strtab);\n\t\t\t\t\t\tfree(symtab);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SHT_DYNSYM:\n\t\t\t\tcase SHT_SYMTAB:\n\t\t\t\t\tif (show_bits & SHOW_SYMBOLS) {\n\t\t\t\t\t\tprintf(\"\\nSymbol table '%s' contains %ld entries.\\n\",\n\t\t\t\t\t\t\tstringTable + sectionHeader.sh_name,\n\t\t\t\t\t\t\tsectionHeader.sh_size / sizeof(Elf64_Sym));\n\t\t\t\t\t\tprintf(\"   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n\");\n\n\t\t\t\t\t\tElf64_Sym * symtab = malloc(sectionHeader.sh_size);\n\t\t\t\t\t\tfseek(f, sectionHeader.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(symtab, sectionHeader.sh_size, 1, f);\n\n\t\t\t\t\t\tElf64_Shdr shdr_strtab;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * sectionHeader.sh_link, SEEK_SET);\n\t\t\t\t\t\tfread(&shdr_strtab, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\tchar * strtab = malloc(shdr_strtab.sh_size);\n\t\t\t\t\t\tfseek(f, shdr_strtab.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(strtab, shdr_strtab.sh_size, 1, f);\n\n\t\t\t\t\t\tfor (unsigned int i = 0; i < sectionHeader.sh_size / sizeof(Elf64_Sym); ++i) {\n\t\t\t\t\t\t\tprintf(\"%6u: %016lx %6lu %-7.7s %-6.6s %-4d %6d %s\\n\",\n\t\t\t\t\t\t\t\ti, symtab[i].st_value, symtab[i].st_size,\n\t\t\t\t\t\t\t\tsymbolTypeToStr(symtab[i].st_info & 0xF),\n\t\t\t\t\t\t\t\tsymbolBindToStr(symtab[i].st_info >> 4),\n\t\t\t\t\t\t\t\tsymtab[i].st_other,\n\t\t\t\t\t\t\t\tsymtab[i].st_shndx,\n\t\t\t\t\t\t\t\tstrtab + symtab[i].st_name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(strtab);\n\t\t\t\t\t\tfree(symtab);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out;\n}",
  "func_after": "int main(int argc, char * argv[]) {\n\n\tstatic struct option long_opts[] = {\n\t\t{\"all\",             no_argument, 0, 'a'},\n\t\t{\"file-header\",     no_argument, 0, 'h'},\n\t\t{\"program-headers\", no_argument, 0, 'l'},\n\t\t{\"section-headers\", no_argument, 0, 'S'},\n\t\t{\"headers\",         no_argument, 0, 'e'},\n\t\t{\"syms\",            no_argument, 0, 's'},\n\t\t{\"dynamic\",         no_argument, 0, 'd'},\n\t\t{\"relocs\",          no_argument, 0, 'r'},\n\t\t{\"help\",            no_argument, 0, 'H'},\n\n\t\t{\"segments\",        no_argument, 0, 'l'}, /* Alias for --program-headers */\n\t\t{\"sections\",        no_argument, 0, 'S'}, /* Alias for --section-headers */\n\t\t{\"symbols\",         no_argument, 0, 's'}, /* Alias for --syms */\n\t\t{0,0,0,0}\n\t};\n\n\tint show_bits = 0;\n\tint index, c;\n\n\twhile ((c = getopt_long(argc, argv, \"ahlSesdrH\", long_opts, &index)) != -1) {\n\t\tif (!c) {\n\t\t\tif (long_opts[index].flag == 0) {\n\t\t\t\tc = long_opts[index].val;\n\t\t\t}\n\t\t}\n\t\tswitch (c) {\n\t\t\tcase 'H':\n\t\t\t\treturn usage(argv);\n\t\t\tcase 'a':\n\t\t\t\tshow_bits |= SHOW_FILE_HEADER | SHOW_SECTION_HEADERS | SHOW_PROGRAM_HEADERS | SHOW_SYMBOLS | SHOW_DYNAMIC | SHOW_RELOCATIONS;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tshow_bits |= SHOW_DYNAMIC;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tshow_bits |= SHOW_FILE_HEADER;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tshow_bits |= SHOW_PROGRAM_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshow_bits |= SHOW_SECTION_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tshow_bits |= SHOW_FILE_HEADER | SHOW_PROGRAM_HEADERS | SHOW_SECTION_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tshow_bits |= SHOW_SYMBOLS;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tshow_bits |= SHOW_RELOCATIONS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Unrecognized option: %c\\n\", c);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind >= argc || !show_bits) {\n\t\treturn usage(argv);\n\t}\n\n\tint out = 0;\n\tint print_names = 0;\n\n\tif (optind + 1 < argc) {\n\t\tprint_names = 1;\n\t}\n\n\tfor (; optind < argc; optind++) {\n\t\tFILE * f = fopen(argv[optind],\"r\");\n\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"%s: %s: %s\\n\", argv[0], argv[optind], strerror(errno));\n\t\t\tout = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (print_names) {\n\t\t\tprintf(\"\\nFile: %s\\n\", argv[optind]);\n\t\t}\n\n\t\t/**\n\t\t * Validate header.\n\t\t */\n\t\tElf64_Header header;\n\t\tfread(&header, sizeof(Elf64_Header), 1, f);\n\n\t\tif (memcmp(\"\\x7F\" \"ELF\",&header,4)) {\n\t\t\tfprintf(stderr, \"%s: %s: not an elf\\n\", argv[0], argv[optind]);\n\t\t\tout = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (show_bits & SHOW_FILE_HEADER) {\n\t\t\tprintf(\"ELF Header:\\n\");\n\t\t\tprintf(\"  Magic:   %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\\n\",\n\t\t\t\theader.e_ident[0],  header.e_ident[1],  header.e_ident[2],  header.e_ident[3],\n\t\t\t\theader.e_ident[4],  header.e_ident[5],  header.e_ident[6],  header.e_ident[7],\n\t\t\t\theader.e_ident[8],  header.e_ident[9],  header.e_ident[10], header.e_ident[11],\n\t\t\t\theader.e_ident[12], header.e_ident[13], header.e_ident[14], header.e_ident[15]);\n\t\t\tprintf(\"  Class:                             %s\\n\", elf_classToStr(header.e_ident[EI_CLASS]));\n\t\t\tprintf(\"  Data:                              %s\\n\", elf_dataToStr(header.e_ident[EI_DATA]));\n\t\t\tprintf(\"  Version:                           %s\\n\", elf_versionToStr(header.e_ident[EI_VERSION]));\n\t\t\tprintf(\"  OS/ABI:                            %s\\n\", elf_osabiToStr(header.e_ident[EI_OSABI]));\n\t\t\tprintf(\"  ABI Version:                       %u\\n\", header.e_ident[EI_ABIVERSION]);\n\t\t}\n\n\t\tif (header.e_ident[EI_CLASS] != ELFCLASS64) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (show_bits & SHOW_FILE_HEADER) {\n\t\t\t/* Byte-order dependent from here on out... */\n\t\t\tprintf(\"  Type:                              %s\\n\", elf_typeToStr(header.e_type));\n\t\t\tprintf(\"  Machine:                           %s\\n\", elf_machineToStr(header.e_machine));\n\t\t\tprintf(\"  Version:                           0x%x\\n\", header.e_version);\n\t\t\tprintf(\"  Entry point address:               0x%lx\\n\", header.e_entry);\n\t\t\tprintf(\"  Start of program headers:          %lu (bytes into file)\\n\", header.e_phoff);\n\t\t\tprintf(\"  Start of section headers:          %lu (bytes into file)\\n\", header.e_shoff);\n\t\t\tprintf(\"  Flags:                             0x%x\\n\", header.e_flags);\n\t\t\tprintf(\"  Size of this header:               %u (bytes)\\n\", header.e_ehsize);\n\t\t\tprintf(\"  Size of program headers:           %u (bytes)\\n\", header.e_phentsize);\n\t\t\tprintf(\"  Number of program headers:         %u\\n\", header.e_phnum);\n\t\t\tprintf(\"  Size of section headers:           %u (bytes)\\n\", header.e_shentsize);\n\t\t\tprintf(\"  Number of section headers:         %u\\n\", header.e_shnum);\n\t\t\tprintf(\"  Section header string table index: %u\\n\", header.e_shstrndx);\n\t\t}\n\n\t\t/* Get the section header string table */\n\t\tElf64_Shdr shstr_hdr;\n\t\tfseek(f, header.e_shoff + header.e_shentsize * header.e_shstrndx, SEEK_SET);\n\t\tfread(&shstr_hdr, sizeof(Elf64_Shdr), 1, f);\n\n\t\tstruct StringTable * stringTable = load_string_table(f, &shstr_hdr);\n\n\t\t/**\n\t\t * Section Headers\n\t\t */\n\t\tif (show_bits & SHOW_SECTION_HEADERS) {\n\t\t\tprintf(\"\\nSection Headers:\\n\");\n\t\t\tprintf(\"  [Nr] Name              Type             Address           Offset\\n\");\n\t\t\tprintf(\"       Size              EntSize          Flags  Link  Info  Align\\n\");\n\t\t\tfor (unsigned int i = 0; i < header.e_shnum; ++i) {\n\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * i, SEEK_SET);\n\t\t\t\tElf64_Shdr sectionHeader;\n\t\t\t\tfread(&sectionHeader, sizeof(Elf64_Shdr), 1, f);\n\n\t\t\t\tprintf(\"  [%2d] %-17.17s %-16.16s %016lx  %08lx\\n\",\n\t\t\t\t\ti, string_from_table(stringTable, sectionHeader.sh_name), sectionHeaderTypeToStr(sectionHeader.sh_type),\n\t\t\t\t\tsectionHeader.sh_addr, sectionHeader.sh_offset);\n\t\t\t\tprintf(\"       %016lx  %016lx %4ld %6d %5d %5ld\\n\",\n\t\t\t\t\tsectionHeader.sh_size, sectionHeader.sh_entsize, sectionHeader.sh_flags,\n\t\t\t\t\tsectionHeader.sh_link, sectionHeader.sh_info, sectionHeader.sh_addralign);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Program Headers\n\t\t */\n\t\tif (show_bits & SHOW_PROGRAM_HEADERS && header.e_phoff && header.e_phnum) {\n\t\t\tprintf(\"\\nProgram Headers:\\n\");\n\t\t\tprintf(\"  Type           Offset             VirtAddr           PhysAddr\\n\");\n\t\t\tprintf(\"                 FileSiz            MemSiz              Flags  Align\\n\");\n\t\t\tfor (unsigned int i = 0; i < header.e_phnum; ++i) {\n\t\t\t\tfseek(f, header.e_phoff + header.e_phentsize * i, SEEK_SET);\n\t\t\t\tElf64_Phdr programHeader;\n\t\t\t\tfread(&programHeader, sizeof(Elf64_Phdr), 1, f);\n\n\t\t\t\tprintf(\"  %-14.14s 0x%016lx 0x%016lx 0x%016lx\\n\",\n\t\t\t\t\tprogramHeaderTypeToStr(programHeader.p_type),\n\t\t\t\t\tprogramHeader.p_offset, programHeader.p_vaddr, programHeader.p_paddr);\n\t\t\t\tprintf(\"                 0x%016lx 0x%016lx  %s 0x%lx\\n\",\n\t\t\t\t\tprogramHeader.p_filesz, programHeader.p_memsz,\n\t\t\t\t\tprogramHeaderFlagsToStr(programHeader.p_flags), programHeader.p_align);\n\n\t\t\t\tif (programHeader.p_type == PT_INTERP) {\n\t\t\t\t\t/* Read interpreter string */\n\t\t\t\t\tchar * tmp = malloc(programHeader.p_filesz);\n\t\t\t\t\tfseek(f, programHeader.p_offset, SEEK_SET);\n\t\t\t\t\tfread(tmp, programHeader.p_filesz, 1, f);\n\t\t\t\t\tprintf(\"    [Requesting program interpreter: %.*s]\\n\",\n\t\t\t\t\t\t(int)programHeader.p_filesz, tmp);\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* TODO Section to segment mapping? */\n\n\t\t/**\n\t\t * Dump section information.\n\t\t */\n\t\tfor (unsigned int i = 0; i < header.e_shnum; ++i) {\n\t\t\tfseek(f, header.e_shoff + header.e_shentsize * i, SEEK_SET);\n\t\t\tElf64_Shdr sectionHeader;\n\t\t\tfread(&sectionHeader, sizeof(Elf64_Shdr), 1, f);\n\n\t\t\tif (sectionHeader.sh_size > 0x40000000) {\n\t\t\t\t/* Suspiciously large section header... */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* I think there should only be one of these... */\n\t\t\tswitch (sectionHeader.sh_type) {\n\t\t\t\tcase SHT_DYNAMIC:\n\t\t\t\t\tif (show_bits & SHOW_DYNAMIC) {\n\t\t\t\t\t\tprintf(\"\\nDynamic section at offset 0x%lx contains (up to) %ld entries:\\n\",\n\t\t\t\t\t\t\tsectionHeader.sh_offset, sectionHeader.sh_size / sectionHeader.sh_entsize);\n\t\t\t\t\t\tprintf(\"  Tag        Type                         Name/Value\\n\");\n\n\t\t\t\t\t\t/* Read the linked string table */\n\t\t\t\t\t\tElf64_Shdr dynstr;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * sectionHeader.sh_link, SEEK_SET);\n\t\t\t\t\t\tfread(&dynstr, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\tchar * dynStr = malloc(dynstr.sh_size);\n\t\t\t\t\t\tfseek(f, dynstr.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(dynStr, dynstr.sh_size, 1, f);\n\n\t\t\t\t\t\tchar * dynTable = malloc(sectionHeader.sh_size);\n\t\t\t\t\t\tfseek(f, sectionHeader.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(dynTable, sectionHeader.sh_size, 1, f);\n\n\t\t\t\t\t\tfor (unsigned int i = 0; i < sectionHeader.sh_size / sectionHeader.sh_entsize; i++) {\n\t\t\t\t\t\t\tElf64_Dyn * dynEntry = (Elf64_Dyn *)(dynTable + sectionHeader.sh_entsize * i);\n\n\t\t\t\t\t\t\tprintf(\" 0x%016lx %s\\n\",\n\t\t\t\t\t\t\t\tdynEntry->d_tag,\n\t\t\t\t\t\t\t\tdynamicTagToStr(dynEntry, dynStr));\n\n\t\t\t\t\t\t\tif (dynEntry->d_tag == DT_NULL) break;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(dynStr);\n\t\t\t\t\t\tfree(dynTable);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SHT_RELA:\n\t\t\t\t\tif (show_bits & SHOW_RELOCATIONS) {\n\t\t\t\t\t\tprintf(\"\\nRelocation section '%s' at offset 0x%lx contains %ld entries.\\n\",\n\t\t\t\t\t\t\tstring_from_table(stringTable, sectionHeader.sh_name), sectionHeader.sh_offset,\n\t\t\t\t\t\t\tsectionHeader.sh_size / sizeof(Elf64_Rela));\n\t\t\t\t\t\tprintf(\"  Offset          Info           Type           Sym. Value    Sym. Name + Addend\\n\");\n\n\t\t\t\t\t\t/* Section this relocation is in */\n\t\t\t\t\t\tElf64_Shdr shdr_this;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * sectionHeader.sh_info, SEEK_SET);\n\t\t\t\t\t\tfread(&shdr_this, sizeof(Elf64_Shdr), 1, f);\n\n\t\t\t\t\t\t/* Symbol table link */\n\t\t\t\t\t\tElf64_Shdr shdr_symtab;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * sectionHeader.sh_link, SEEK_SET);\n\t\t\t\t\t\tfread(&shdr_symtab, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\tElf64_Sym * symtab = malloc(shdr_symtab.sh_size);\n\t\t\t\t\t\tfseek(f, shdr_symtab.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(symtab, shdr_symtab.sh_size, 1, f);\n\n\t\t\t\t\t\t/* Symbol table's string table link */\n\t\t\t\t\t\tElf64_Shdr shdr_strtab;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * shdr_symtab.sh_link, SEEK_SET);\n\t\t\t\t\t\tfread(&shdr_strtab, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\tstruct StringTable * strtab = load_string_table(f, &shdr_strtab);\n\n\t\t\t\t\t\t/* Load relocations from file */\n\t\t\t\t\t\tElf64_Rela * relocations = malloc(sectionHeader.sh_size);\n\t\t\t\t\t\tfseek(f, sectionHeader.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread((void*)relocations, sectionHeader.sh_size, 1, f);\n\n\t\t\t\t\t\tfor (unsigned int i = 0; i < sectionHeader.sh_size / sizeof(Elf64_Rela); ++i) {\n\t\t\t\t\t\t\tElf64_Shdr shdr;\n\t\t\t\t\t\t\tsize_t offset = ELF64_R_SYM(relocations[i].r_info);\n\t\t\t\t\t\t\tElf64_Xword value = 0;\n\t\t\t\t\t\t\tconst char * symName = \"(null)\";\n\t\t\t\t\t\t\tif (offset < shdr_symtab.sh_size) {\n\t\t\t\t\t\t\t\tElf64_Sym * this = &symtab[offset];\n\n\t\t\t\t\t\t\t\t/* Get symbol name for this relocation */\n\t\t\t\t\t\t\t\tif ((this->st_info & 0xF) == STT_SECTION) {\n\t\t\t\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * this->st_shndx, SEEK_SET);\n\t\t\t\t\t\t\t\t\tfread(&shdr, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\t\t\t\tsymName = string_from_table(stringTable, shdr.sh_name);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsymName = string_from_table(strtab, this->st_name);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* Get the value currently in the section data */\n\t\t\t\t\t\t\t\tint valueSize = sizeOfRelocationValue(ELF64_R_TYPE(relocations[i].r_info));\n\t\t\t\t\t\t\t\tfseek(f, shdr_this.sh_offset + relocations[i].r_offset, SEEK_SET);\n\t\t\t\t\t\t\t\tswitch (valueSize) {\n\t\t\t\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint64_t val;\n\t\t\t\t\t\t\t\t\t\t\tfread(&val, valueSize, 1, f);\n\t\t\t\t\t\t\t\t\t\t\tvalue = val;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint32_t val;\n\t\t\t\t\t\t\t\t\t\t\tfread(&val, valueSize, 1, f);\n\t\t\t\t\t\t\t\t\t\t\tvalue = val;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint16_t val;\n\t\t\t\t\t\t\t\t\t\t\tfread(&val, valueSize, 1, f);\n\t\t\t\t\t\t\t\t\t\t\tvalue = val;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint8_t val;\n\t\t\t\t\t\t\t\t\t\t\tfread(&val, valueSize, 1, f);\n\t\t\t\t\t\t\t\t\t\t\tvalue = val;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprintf(\"%012lx  %012lx %-15.15s %016lx %s + %lx\\n\",\n\t\t\t\t\t\t\t\trelocations[i].r_offset, relocations[i].r_info,\n\t\t\t\t\t\t\t\trelocationInfoToStr(ELF64_R_TYPE(relocations[i].r_info)),\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\tsymName,\n\t\t\t\t\t\t\t\trelocations[i].r_addend);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(relocations);\n\t\t\t\t\t\tfree(strtab);\n\t\t\t\t\t\tfree(symtab);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SHT_DYNSYM:\n\t\t\t\tcase SHT_SYMTAB:\n\t\t\t\t\tif (show_bits & SHOW_SYMBOLS) {\n\t\t\t\t\t\tprintf(\"\\nSymbol table '%s' contains %ld entries.\\n\",\n\t\t\t\t\t\t\tstring_from_table(stringTable, sectionHeader.sh_name),\n\t\t\t\t\t\t\tsectionHeader.sh_size / sizeof(Elf64_Sym));\n\t\t\t\t\t\tprintf(\"   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n\");\n\n\t\t\t\t\t\tElf64_Sym * symtab = malloc(sectionHeader.sh_size);\n\t\t\t\t\t\tfseek(f, sectionHeader.sh_offset, SEEK_SET);\n\t\t\t\t\t\tfread(symtab, sectionHeader.sh_size, 1, f);\n\n\t\t\t\t\t\tElf64_Shdr shdr_strtab;\n\t\t\t\t\t\tfseek(f, header.e_shoff + header.e_shentsize * sectionHeader.sh_link, SEEK_SET);\n\t\t\t\t\t\tfread(&shdr_strtab, sizeof(Elf64_Shdr), 1, f);\n\t\t\t\t\t\tstruct StringTable * strtab = load_string_table(f, &shdr_strtab);\n\n\t\t\t\t\t\tfor (unsigned int i = 0; i < sectionHeader.sh_size / sizeof(Elf64_Sym); ++i) {\n\t\t\t\t\t\t\tprintf(\"%6u: %016lx %6lu %-7.7s %-6.6s %-4d %6d %s\\n\",\n\t\t\t\t\t\t\t\ti, symtab[i].st_value, symtab[i].st_size,\n\t\t\t\t\t\t\t\tsymbolTypeToStr(symtab[i].st_info & 0xF),\n\t\t\t\t\t\t\t\tsymbolBindToStr(symtab[i].st_info >> 4),\n\t\t\t\t\t\t\t\tsymtab[i].st_other,\n\t\t\t\t\t\t\t\tsymtab[i].st_shndx,\n\t\t\t\t\t\t\t\tstring_from_table(strtab, symtab[i].st_name));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(strtab);\n\t\t\t\t\t\tfree(symtab);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\tfree(stringTable);\n\t}\n\n\treturn out;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int main(int argc, char * argv[]) {\n \n \tstatic struct option long_opts[] = {\n \t\t{\"all\",             no_argument, 0, 'a'},\n \t\t{\"file-header\",     no_argument, 0, 'h'},\n \t\t{\"program-headers\", no_argument, 0, 'l'},\n \t\t{\"section-headers\", no_argument, 0, 'S'},\n \t\t{\"headers\",         no_argument, 0, 'e'},\n \t\t{\"syms\",            no_argument, 0, 's'},\n \t\t{\"dynamic\",         no_argument, 0, 'd'},\n \t\t{\"relocs\",          no_argument, 0, 'r'},\n \t\t{\"help\",            no_argument, 0, 'H'},\n \n \t\t{\"segments\",        no_argument, 0, 'l'}, /* Alias for --program-headers */\n \t\t{\"sections\",        no_argument, 0, 'S'}, /* Alias for --section-headers */\n \t\t{\"symbols\",         no_argument, 0, 's'}, /* Alias for --syms */\n \t\t{0,0,0,0}\n \t};\n \n \tint show_bits = 0;\n \tint index, c;\n \n \twhile ((c = getopt_long(argc, argv, \"ahlSesdrH\", long_opts, &index)) != -1) {\n \t\tif (!c) {\n \t\t\tif (long_opts[index].flag == 0) {\n \t\t\t\tc = long_opts[index].val;\n \t\t\t}\n \t\t}\n \t\tswitch (c) {\n \t\t\tcase 'H':\n \t\t\t\treturn usage(argv);\n \t\t\tcase 'a':\n \t\t\t\tshow_bits |= SHOW_FILE_HEADER | SHOW_SECTION_HEADERS | SHOW_PROGRAM_HEADERS | SHOW_SYMBOLS | SHOW_DYNAMIC | SHOW_RELOCATIONS;\n \t\t\t\tbreak;\n \t\t\tcase 'd':\n \t\t\t\tshow_bits |= SHOW_DYNAMIC;\n \t\t\t\tbreak;\n \t\t\tcase 'h':\n \t\t\t\tshow_bits |= SHOW_FILE_HEADER;\n \t\t\t\tbreak;\n \t\t\tcase 'l':\n \t\t\t\tshow_bits |= SHOW_PROGRAM_HEADERS;\n \t\t\t\tbreak;\n \t\t\tcase 'S':\n \t\t\t\tshow_bits |= SHOW_SECTION_HEADERS;\n \t\t\t\tbreak;\n \t\t\tcase 'e':\n \t\t\t\tshow_bits |= SHOW_FILE_HEADER | SHOW_PROGRAM_HEADERS | SHOW_SECTION_HEADERS;\n \t\t\t\tbreak;\n \t\t\tcase 's':\n \t\t\t\tshow_bits |= SHOW_SYMBOLS;\n \t\t\t\tbreak;\n \t\t\tcase 'r':\n \t\t\t\tshow_bits |= SHOW_RELOCATIONS;\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tfprintf(stderr, \"Unrecognized option: %c\\n\", c);\n \t\t\t\tbreak;\n \t\t}\n \t}\n \n \tif (optind >= argc || !show_bits) {\n \t\treturn usage(argv);\n \t}\n \n \tint out = 0;\n \tint print_names = 0;\n \n \tif (optind + 1 < argc) {\n \t\tprint_names = 1;\n \t}\n \n \tfor (; optind < argc; optind++) {\n \t\tFILE * f = fopen(argv[optind],\"r\");\n \n \t\tif (",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch adds sanity checks to the option parsing in the readelf tool, addressing several reported issues. While the commit message doesn't specify security, the changes could prevent incorrect behavior but lack evidence of security impact.\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.7"
}