{
  "id": 5137,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/d3217b15a19a4779c39b212358a5c71d725822ee",
  "commit_sha": "d3217b15a19a4779c39b212358a5c71d725822ee",
  "commit_msg": "sctp: Fix sk_ack_backlog wrap-around problem\n\nConsider the scenario:\nFor a TCP-style socket, while processing the COOKIE_ECHO chunk in\nsctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,\na new association would be created in sctp_unpack_cookie(), but afterwards,\nsome processing maybe failed, and sctp_association_free() will be called to\nfree the previously allocated association, in sctp_association_free(),\nsk_ack_backlog value is decremented for this socket, since the initial\nvalue for sk_ack_backlog is 0, after the decrement, it will be 65535,\na wrap-around problem happens, and if we want to establish new associations\nafterward in the same socket, ABORT would be triggered since sctp deem the\naccept queue as full.\nFix this issue by only decrementing sk_ack_backlog for associations in\nthe endpoint's list.\n\nFix-suggested-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "net/sctp/associola.c",
  "func_name": "sctp_association_free",
  "func_before": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\n\t/* Only real associations count against the endpoint, so\n\t * don't bother for if this is a temporary association.\n\t */\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\n\t\t/* Decrement the backlog value for a TCP-style listening\n\t\t * socket.\n\t\t */\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\n\t/* Mark as dead, so other users can know this structure is\n\t * going away.\n\t */\n\tasoc->base.dead = true;\n\n\t/* Dispose of any data lying around in the outqueue. */\n\tsctp_outq_free(&asoc->outqueue);\n\n\t/* Dispose of any pending messages for the upper layer. */\n\tsctp_ulpq_free(&asoc->ulpq);\n\n\t/* Dispose of any pending chunks on the inqueue. */\n\tsctp_inq_free(&asoc->base.inqueue);\n\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\n\t/* Free ssnmap storage. */\n\tsctp_ssnmap_free(asoc->ssnmap);\n\n\t/* Clean up the bound address list. */\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\n\t/* Do we need to go through all of our timers and\n\t * delete them?   To be safe we will try to delete all, but we\n\t * should be able to go through and make a guess based\n\t * on our state.\n\t */\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\n\t/* Free peer's cached cookie. */\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\n\t/* Release the transport structures. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\n\tasoc->peer.transport_count = 0;\n\n\tsctp_asconf_queue_teardown(asoc);\n\n\t/* Free pending address space being deleted */\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\n\t/* AUTH - Free the endpoint shared keys */\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\n\t/* AUTH - Free the association shared key */\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\n\tsctp_association_put(asoc);\n}",
  "func_after": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\n\t/* Only real associations count against the endpoint, so\n\t * don't bother for if this is a temporary association.\n\t */\n\tif (!list_empty(&asoc->asocs)) {\n\t\tlist_del(&asoc->asocs);\n\n\t\t/* Decrement the backlog value for a TCP-style listening\n\t\t * socket.\n\t\t */\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\n\t/* Mark as dead, so other users can know this structure is\n\t * going away.\n\t */\n\tasoc->base.dead = true;\n\n\t/* Dispose of any data lying around in the outqueue. */\n\tsctp_outq_free(&asoc->outqueue);\n\n\t/* Dispose of any pending messages for the upper layer. */\n\tsctp_ulpq_free(&asoc->ulpq);\n\n\t/* Dispose of any pending chunks on the inqueue. */\n\tsctp_inq_free(&asoc->base.inqueue);\n\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\n\t/* Free ssnmap storage. */\n\tsctp_ssnmap_free(asoc->ssnmap);\n\n\t/* Clean up the bound address list. */\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\n\t/* Do we need to go through all of our timers and\n\t * delete them?   To be safe we will try to delete all, but we\n\t * should be able to go through and make a guess based\n\t * on our state.\n\t */\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\n\t/* Free peer's cached cookie. */\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\n\t/* Release the transport structures. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\n\tasoc->peer.transport_count = 0;\n\n\tsctp_asconf_queue_teardown(asoc);\n\n\t/* Free pending address space being deleted */\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\n\t/* AUTH - Free the endpoint shared keys */\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\n\t/* AUTH - Free the association shared key */\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\n\tsctp_association_put(asoc);\n}",
  "diff_func": "--- func_before\n+++ func_after\n void sctp_association_free(struct sctp_association *asoc)\n {\n \tstruct sock *sk = asoc->base.sk;\n \tstruct sctp_transport *transport;\n \tstruct list_head *pos, *temp;\n \tint i;\n \n \t/* Only real associations count against the endpoint, so\n \t * don't bother for if this is a temporary association.\n \t */\n-\tif (!asoc->temp) {\n+\tif (!list_empty(&asoc->asocs)) {\n \t\tlist_del(&asoc->asocs);\n \n \t\t/* Decrement the backlog value for a TCP-style listening\n \t\t * socket.\n \t\t */\n \t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n \t\t\tsk->sk_ack_backlog--;\n \t}\n \n \t/* Mark as dead, so other users can know this structure is\n \t * going away.\n \t */\n \tasoc->base.dead = true;\n \n \t/* Dispose of any data lying around in the outqueue. */\n \tsctp_outq_free(&asoc->outqueue);\n \n \t/* Dispose of any pending messages for the upper layer. */\n \tsctp_ulpq_free(&asoc->ulpq);\n \n \t/* Dispose of any pending chunks on the inqueue. */\n \tsctp_inq_free(&asoc->base.inqueue);\n \n \tsctp_tsnmap_free(&asoc->peer.tsn_map);\n \n \t/* Free ssnmap storage. */\n \tsctp_ssnmap_free(asoc->ssnmap);\n \n \t/* Clean up the bound address list. */\n \tsctp_bind_addr_free(&asoc->base.bind_addr);\n \n \t/* Do we need to go through all of our timers and\n \t * delete them?   To be safe we will try to delete all, but we\n \t * should be able to go through and make a guess based\n \t * on our state.\n \t */\n \tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n \t\tif (del_timer(&asoc->timers[i]))\n \t\t\tsctp_association_put(asoc);\n \t}\n \n \t/* Free peer's cached cookie. */\n \tkfree(asoc->peer.cookie);\n \tkfree(asoc->peer.peer_random);\n \tkfree(asoc->peer.peer_chunks);\n \tkfree(asoc->peer.peer_hmacs);\n \n \t/* Release the transport structures. */\n \tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n \t\ttransport = list_entry(pos, struct sctp_transport, transports);\n \t\tlist_del_rcu(pos);\n \t\tsctp_transport_free(transport);\n \t}\n \n \tasoc->peer.transport_count = 0;\n \n \tsctp_asconf_queue_teardown(asoc);\n \n \t",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a bug causing `sk_ack_backlog` to wrap around, leading to aborted connections. It fixes the condition to only decrement when the association is valid, preventing the wrap-around. This resolves a bug affecting availability but not a security issue.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.9"
}