{
  "id": 5543,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5",
  "commit_sha": "297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5",
  "commit_msg": "net: phy: mdio-bcm-unimac: fix potential NULL dereference in unimac_mdio_probe()\n\nplatform_get_resource() may fail and return NULL, so we should\nbetter check it's return value to avoid a NULL pointer dereference\na bit later in the code.\n\nThis is detected by Coccinelle semantic patch.\n\n@@\nexpression pdev, res, n, t, e, e1, e2;\n@@\n\nres = platform_get_resource(pdev, t, n);\n+ if (!res)\n+   return -EINVAL;\n... when != res == NULL\ne = devm_ioremap(e1, res->start, e2);\n\nSigned-off-by: Wei Yongjun <weiyongjun1@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "drivers/net/phy/mdio-bcm-unimac.c",
  "func_name": "unimac_mdio_probe",
  "func_before": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\t/* Just ioremap, as this MDIO block is usually integrated into an\n\t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}",
  "func_after": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\n\t/* Just ioremap, as this MDIO block is usually integrated into an\n\t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int unimac_mdio_probe(struct platform_device *pdev)\n {\n \tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n \tstruct unimac_mdio_priv *priv;\n \tstruct device_node *np;\n \tstruct mii_bus *bus;\n \tstruct resource *r;\n \tint ret;\n \n \tnp = pdev->dev.of_node;\n \n \tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n \n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n+\tif (!r)\n+\t\treturn -EINVAL;\n \n \t/* Just ioremap, as this MDIO block is usually integrated into an\n \t * Ethernet MAC controller register range\n \t */\n \tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n \tif (!priv->base) {\n \t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n \t\treturn -ENOMEM;\n \t}\n \n \tpriv->mii_bus = mdiobus_alloc();\n \tif (!priv->mii_bus)\n \t\treturn -ENOMEM;\n \n \tbus = priv->mii_bus;\n \tbus->priv = priv;\n \tif (pdata) {\n \t\tbus->name = pdata->bus_name;\n \t\tpriv->wait_func = pdata->wait_func;\n \t\tpriv->wait_func_data = pdata->wait_func_data;\n \t\tbus->phy_mask = ~pdata->phy_mask;\n \t} else {\n \t\tbus->name = \"unimac MII bus\";\n \t\tpriv->wait_func_data = priv;\n \t\tpriv->wait_func = unimac_mdio_poll;\n \t}\n \tbus->parent = &pdev->dev;\n \tbus->read = unimac_mdio_read;\n \tbus->write = unimac_mdio_write;\n \tbus->reset = unimac_mdio_reset;\n \tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n \n \tret = of_mdiobus_register(bus, np);\n \tif (ret) {\n \t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n \t\tgoto out_mdio_free;\n \t}\n \n \tplatform_set_drvdata(pdev, priv);\n \n \tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n \n \treturn 0;\n \n out_mdio_free:\n \tmdiobus_free(bus);\n \treturn ret;\n }",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\nThe patch addresses a potential NULL pointer dereference in the `unimac_mdio_probe` function. It adds a check after `platform_get_resource()` to return an error if the resource is not found, preventing a crash. The commit message suggests this was detected by a tool but doesn't indicate a security exploit.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.7\n\nThe change fixes a bug that could cause a crash but lacks evidence of being a security vulnerability."
}