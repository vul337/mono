{
  "id": 5853,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/7f821fc9c77a9b01fe7b1d6e72717b33d8d64142",
  "commit_sha": "7f821fc9c77a9b01fe7b1d6e72717b33d8d64142",
  "commit_msg": "powerpc/tm: Check for already reclaimed tasks\n\nCurrently we can hit a scenario where we'll tm_reclaim() twice.  This\nresults in a TM bad thing exception because the second reclaim occurs\nwhen not in suspend mode.\n\nThe scenario in which this can happen is the following.  We attempt to\ndeliver a signal to userspace.  To do this we need obtain the stack\npointer to write the signal context.  To get this stack pointer we\nmust tm_reclaim() in case we need to use the checkpointed stack\npointer (see get_tm_stackpointer()).  Normally we'd then return\ndirectly to userspace to deliver the signal without going through\n__switch_to().\n\nUnfortunatley, if at this point we get an error (such as a bad\nuserspace stack pointer), we need to exit the process.  The exit will\nresult in a __switch_to().  __switch_to() will attempt to save the\nprocess state which results in another tm_reclaim().  This\ntm_reclaim() now causes a TM Bad Thing exception as this state has\nalready been saved and the processor is no longer in TM suspend mode.\nWhee!\n\nThis patch checks the state of the MSR to ensure we are TM suspended\nbefore we attempt the tm_reclaim().  If we've already saved the state\naway, we should no longer be in TM suspend mode.  This has the\nadditional advantage of checking for a potential TM Bad Thing\nexception.\n\nFound using syscall fuzzer.\n\nFixes: fb09692e71f1 (\"powerpc: Add reclaim and recheckpoint functions for context switching transactional memory processes\")\nCc: stable@vger.kernel.org # v3.9+\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "arch/powerpc/kernel/process.c",
  "func_name": "tm_reclaim_thread",
  "func_before": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
  "func_after": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\t/*\n\t * Use the current MSR TM suspended bit to track if we have\n\t * checkpointed state outstanding.\n\t * On signal delivery, we'd normally reclaim the checkpointed\n\t * state to obtain stack pointer (see:get_tm_stackpointer()).\n\t * This will then directly return to userspace without going\n\t * through __switch_to(). However, if the stack frame is bad,\n\t * we need to exit this thread which calls __switch_to() which\n\t * will again attempt to reclaim the already saved tm state.\n\t * Hence we need to check that we've not already reclaimed\n\t * this state.\n\t * We do this using the current MSR, rather tracking it in\n\t * some specific thread_struct bit, as it has the additional\n\t * benifit of checking for a potential TM bad thing exception.\n\t */\n\tif (!MSR_TM_SUSPENDED(mfmsr()))\n\t\treturn;\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void tm_reclaim_thread(struct thread_struct *thr,\n \t\t\t      struct thread_info *ti, uint8_t cause)\n {\n \tunsigned long msr_diff = 0;\n \n \t/*\n \t * If FP/VSX registers have been already saved to the\n \t * thread_struct, move them to the transact_fp array.\n \t * We clear the TIF_RESTORE_TM bit since after the reclaim\n \t * the thread will no longer be transactional.\n \t */\n \tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n \t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n \t\tif (msr_diff & MSR_FP)\n \t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n \t\t\t       sizeof(struct thread_fp_state));\n \t\tif (msr_diff & MSR_VEC)\n \t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n \t\t\t       sizeof(struct thread_vr_state));\n \t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n \t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n \t}\n \n+\t/*\n+\t * Use the current MSR TM suspended bit to track if we have\n+\t * checkpointed state outstanding.\n+\t * On signal delivery, we'd normally reclaim the checkpointed\n+\t * state to obtain stack pointer (see:get_tm_stackpointer()).\n+\t * This will then directly return to userspace without going\n+\t * through __switch_to(). However, if the stack frame is bad,\n+\t * we need to exit this thread which calls __switch_to() which\n+\t * will again attempt to reclaim the already saved tm state.\n+\t * Hence we need to check that we've not already reclaimed\n+\t * this state.\n+\t * We do this using the current MSR, rather tracking it in\n+\t * some specific thread_struct bit, as it has the additional\n+\t * benifit of checking for a potential TM bad thing exception.\n+\t */\n+\tif (!MSR_TM_SUSPENDED(mfmsr()))\n+\t\treturn;\n+\n \ttm_reclaim(thr, thr->regs->msr, cause);\n \n \t/* Having done the reclaim, we now have the checkpointed\n \t * FP/VSX values in the registers.  These might be valid\n \t * even if we have previously called enable_kernel_fp() or\n \t * flush_fp_to_thread(), so update thr->regs->msr to\n \t * indicate their current validity.\n \t */\n \tthr->regs->msr ",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a bug where `tm_reclaim()` is called twice, leading to a TM Bad Thing exception. The fix checks the MSR to prevent this, avoiding an exception but not addressing a security vulnerability.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.95"
}