{
  "id": 6240,
  "language": "Python",
  "commit_url": "https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508",
  "commit_sha": "2c73f8352635c0a433423a5b94740de1a118e508",
  "commit_msg": "Merge pull request from GHSA-7vrm-3jc8-5wwm\n\n* add more tests for string comparison\n\nexplicitly test the codepath with <= 32 bytes\n\n* refactor keccak256 helper a bit\n\n* fix bytestring equality\n\nexisting bytestring equality checks do not check length equality or for\ndirty bytes.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "vyper/codegen/keccak256_helper.py",
  "func_name": "keccak256_helper",
  "func_before": "def keccak256_helper(expr, ir_arg, context):\n    sub = ir_arg  # TODO get rid of useless variable\n    _check_byteslike(sub.typ, expr)\n\n    # Can hash literals\n    # TODO this is dead code.\n    if isinstance(sub, bytes):\n        return IRnode.from_list(bytes_to_int(keccak256(sub)), typ=BaseType(\"bytes32\"))\n\n    # Can hash bytes32 objects\n    if is_base_type(sub.typ, \"bytes32\"):\n        return IRnode.from_list(\n            [\n                \"seq\",\n                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, sub],\n                [\"sha3\", MemoryPositions.FREE_VAR_SPACE, 32],\n            ],\n            typ=BaseType(\"bytes32\"),\n            add_gas_estimate=_gas_bound(1),\n        )\n\n    sub = ensure_in_memory(sub, context)\n\n    return IRnode.from_list(\n        [\n            \"with\",\n            \"_buf\",\n            sub,\n            [\"sha3\", [\"add\", \"_buf\", 32], [\"mload\", \"_buf\"]],\n        ],\n        typ=BaseType(\"bytes32\"),\n        annotation=\"keccak256\",\n        add_gas_estimate=_gas_bound(ceil(sub.typ.maxlen / 32)),\n    )",
  "func_after": "def keccak256_helper(expr, to_hash, context):\n    _check_byteslike(to_hash.typ, expr)\n\n    # Can hash literals\n    # TODO this is dead code.\n    if isinstance(to_hash, bytes):\n        return IRnode.from_list(bytes_to_int(keccak256(to_hash)), typ=BaseType(\"bytes32\"))\n\n    # Can hash bytes32 objects\n    if is_base_type(to_hash.typ, \"bytes32\"):\n        return IRnode.from_list(\n            [\n                \"seq\",\n                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, to_hash],\n                [\"sha3\", MemoryPositions.FREE_VAR_SPACE, 32],\n            ],\n            typ=BaseType(\"bytes32\"),\n            add_gas_estimate=_gas_bound(1),\n        )\n\n    to_hash = ensure_in_memory(to_hash, context)\n\n    with to_hash.cache_when_complex(\"buf\") as (b1, to_hash):\n        data = bytes_data_ptr(to_hash)\n        len_ = get_bytearray_length(to_hash)\n        return b1.resolve(\n            IRnode.from_list(\n                [\"sha3\", data, len_],\n                typ=\"bytes32\",\n                annotation=\"keccak256\",\n                add_gas_estimate=_gas_bound(ceil(to_hash.typ.maxlen / 32)),\n            )\n        )",
  "diff_func": "--- func_before\n+++ func_after\n-def keccak256_helper(expr, ir_arg, context):\n+def keccak256_helper(expr, to_hash, context):\n-    sub = ir_arg  # TODO get rid of useless variable\n-    _check_byteslike(sub.typ, expr)\n+    _check_byteslike(to_hash.typ, expr)\n \n     # Can hash literals\n     # TODO this is dead code.\n-    if isinstance(sub, bytes):\n+    if isinstance(to_hash, bytes):\n-        return IRnode.from_list(bytes_to_int(keccak256(sub)), typ=BaseType(\"bytes32\"))\n+        return IRnode.from_list(bytes_to_int(keccak256(to_hash)), typ=BaseType(\"bytes32\"))\n \n     # Can hash bytes32 objects\n-    if is_base_type(sub.typ, \"bytes32\"):\n+    if is_base_type(to_hash.typ, \"bytes32\"):\n         return IRnode.from_list(\n             [\n                 \"seq\",\n-                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, sub],\n+                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, to_hash],\n                 [\"sha3\", MemoryPositions.FREE_VAR_SPACE, 32],\n             ],\n             typ=BaseType(\"bytes32\"),\n             add_gas_estimate=_gas_bound(1),\n         )\n \n-    sub = ensure_in_memory(sub, context)\n+    to_hash = ensure_in_memory(to_hash, context)\n \n+    with to_hash.cache_when_complex(\"buf\") as (b1, to_hash):\n+        data = bytes_data_ptr(to_hash)\n+        len_ = get_bytearray_length(to_hash)\n+        return b1.resolve(\n-    return IRnode.from_list(\n+            IRnode.from_list(\n+                [\"sha3\", data, len_],\n+                typ=\"bytes32\",\n+                annotation=\"keccak256\",\n+                add_gas_estimate=_gas_bound(ceil(to_hash.typ.maxlen / 32)),\n+            )\n-        [\n+        )\n-            \"with\",\n-            \"_buf\",\n-            sub,\n-            [\"sha3\", [\"add\", \"_buf\", 32], [\"mload\", \"_buf\"]],\n-        ],\n-        typ=BaseType(\"bytes32\"),\n-        annotation=\"keccak256\",\n-        add_gas_estimate=_gas_bound(ceil(sub.typ.maxlen / 32)),\n-    )",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\nThe patch addresses a bug in the keccak256 helper function, ensuring proper handling of bytestrings. While this could impact security by preventing incorrect hash outputs, the commit doesn't explicitly state a security vulnerability. The primary focus is on functional correction rather than security.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.7"
}