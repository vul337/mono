{
  "id": 5013,
  "language": "C/C++",
  "commit_url": "https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8",
  "commit_sha": "cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8",
  "commit_msg": "patch 8.1.0633: crash when out of memory while opening a terminal window\n\nProblem:    Crash when out of memory while opening a terminal window.\nSolution:   Handle out-of-memory more gracefully.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/terminal.c",
  "func_name": "create_vterm",
  "func_before": "static void\ncreate_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    screen = vterm_obtain_screen(vterm);\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    /* TODO: depends on 'encoding'. */\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    vterm_obtain_state(vterm),\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    /* Required to initialize most things. */\n    vterm_screen_reset(screen, 1 /* hard */);\n\n    /* Allow using alternate screen. */\n    vterm_screen_enable_altscreen(screen, 1);\n\n    /* For unix do not use a blinking cursor.  In an xterm this causes the\n     * cursor to blink if it's blinking in the xterm.\n     * For Windows we respect the system wide setting. */\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    state = vterm_obtain_state(vterm);\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n}",
  "func_after": "static int\ncreate_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    if (vterm == NULL)\n\treturn FAIL;\n\n    // Allocate screen and state here, so we can bail out if that fails.\n    state = vterm_obtain_state(vterm);\n    screen = vterm_obtain_screen(vterm);\n    if (state == NULL || screen == NULL)\n    {\n\tvterm_free(vterm);\n\treturn FAIL;\n    }\n\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    /* TODO: depends on 'encoding'. */\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    state,\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    /* Required to initialize most things. */\n    vterm_screen_reset(screen, 1 /* hard */);\n\n    /* Allow using alternate screen. */\n    vterm_screen_enable_altscreen(screen, 1);\n\n    /* For unix do not use a blinking cursor.  In an xterm this causes the\n     * cursor to blink if it's blinking in the xterm.\n     * For Windows we respect the system wide setting. */\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n\n    return OK;\n}",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5629 +5643 @@\n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\tgoto failed;\n \n #if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n if (opt->jo_set2 & JO2_ANSI_COLORS)\n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\treturn FAIL;\n \n vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n GetCurrentProcessId(),\n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\treturn FAIL;\n \n #if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n if (opt->jo_set2 & JO2_ANSI_COLORS)",
  "diff_source": "api",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses a crash due to out-of-memory conditions by improving error handling. It doesn't fix a security vulnerability but rather enhances stability.\n\n**Final Output:**\n\nAnalysis: The patch fixes a crash caused by out-of-memory conditions when opening a terminal window by adding error handling for create_vterm function calls. It prevents crashes under memory pressure but doesn't address a security exploit.\n\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.9"
}