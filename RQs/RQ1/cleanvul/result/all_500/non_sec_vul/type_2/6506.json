{
  "id": 6506,
  "language": "C/C++",
  "commit_url": "https://github.com/cesanta/mjs/commit/21eb0715f0b92fd6f1b9a3dfb590269976d734e5",
  "commit_sha": "21eb0715f0b92fd6f1b9a3dfb590269976d734e5",
  "commit_msg": "Fix #254: Segmentation fault in Built-in APIs",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "mjs.c",
  "func_name": "exec_expr",
  "func_before": "static void exec_expr(struct mjs *mjs, int op) {\n  switch (op) {\n    case TOK_DOT:\n      break;\n    case TOK_MINUS:\n    case TOK_PLUS:\n    case TOK_MUL:\n    case TOK_DIV:\n    case TOK_REM:\n    case TOK_XOR:\n    case TOK_AND:\n    case TOK_OR:\n    case TOK_LSHIFT:\n    case TOK_RSHIFT:\n    case TOK_URSHIFT: {\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_push(mjs, do_op(mjs, a, b, op));\n      break;\n    }\n    case TOK_UNARY_MINUS: {\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_number(mjs, -a));\n      break;\n    }\n    case TOK_NOT: {\n      mjs_val_t val = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, !mjs_is_truthy(mjs, val)));\n      break;\n    }\n    case TOK_TILDA: {\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_number(mjs, (double) (~(int64_t) a)));\n      break;\n    }\n    case TOK_UNARY_PLUS:\n      break;\n    case TOK_EQ:\n      mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use ===, not ==\");\n      break;\n    case TOK_NE:\n      mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use !==, not !=\");\n      break;\n    case TOK_EQ_EQ: {\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, check_equal(mjs, a, b)));\n      break;\n    }\n    case TOK_NE_NE: {\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_push(mjs, mjs_mk_boolean(mjs, !check_equal(mjs, a, b)));\n      break;\n    }\n    case TOK_LT: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a < b));\n      break;\n    }\n    case TOK_GT: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a > b));\n      break;\n    }\n    case TOK_LE: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a <= b));\n      break;\n    }\n    case TOK_GE: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      mjs_push(mjs, mjs_mk_boolean(mjs, a >= b));\n      break;\n    }\n    case TOK_ASSIGN: {\n      mjs_val_t val = mjs_pop(mjs);\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj)) {\n        mjs_set_v(mjs, obj, key, val);\n      } else if (mjs_is_foreign(obj)) {\n        /*\n         * We don't have setters, so in order to support properties which behave\n         * like setters, we have to parse key right here, instead of having real\n         * built-in prototype objects\n         */\n\n        int ikey = mjs_get_int(mjs, key);\n        int ival = mjs_get_int(mjs, val);\n\n        if (!mjs_is_number(key)) {\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"index must be a number\");\n          val = MJS_UNDEFINED;\n        } else if (!mjs_is_number(val) || ival < 0 || ival > 0xff) {\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                             \"only number 0 .. 255 can be assigned\");\n          val = MJS_UNDEFINED;\n        } else {\n          uint8_t *ptr = (uint8_t *) mjs_get_ptr(mjs, obj);\n          *(ptr + ikey) = (uint8_t) ival;\n        }\n      } else {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"unsupported object type\");\n      }\n      mjs_push(mjs, val);\n      break;\n    }\n    case TOK_POSTFIX_PLUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        mjs_val_t v1 = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_PLUS);\n        mjs_set_v(mjs, obj, key, v1);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for ++\");\n      }\n      break;\n    }\n    case TOK_POSTFIX_MINUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        mjs_val_t v1 = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_MINUS);\n        mjs_set_v(mjs, obj, key, v1);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for --\");\n      }\n      break;\n    }\n    case TOK_MINUS_MINUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        v = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_MINUS);\n        mjs_set_v(mjs, obj, key, v);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for --\");\n      }\n      break;\n    }\n    case TOK_PLUS_PLUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        v = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_PLUS);\n        mjs_set_v(mjs, obj, key, v);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for ++\");\n      }\n      break;\n    }\n    /*\n     * NOTE: TOK_LOGICAL_AND and TOK_LOGICAL_OR don't need to be here, because\n     * they are just naturally handled by the short-circuit evaluation.\n     * See PARSE_LTR_BINOP() macro in mjs_parser.c.\n     */\n\n    /* clang-format off */\n    case TOK_MINUS_ASSIGN:    op_assign(mjs, TOK_MINUS);    break;\n    case TOK_PLUS_ASSIGN:     op_assign(mjs, TOK_PLUS);     break;\n    case TOK_MUL_ASSIGN:      op_assign(mjs, TOK_MUL);      break;\n    case TOK_DIV_ASSIGN:      op_assign(mjs, TOK_DIV);      break;\n    case TOK_REM_ASSIGN:      op_assign(mjs, TOK_REM);      break;\n    case TOK_AND_ASSIGN:      op_assign(mjs, TOK_AND);      break;\n    case TOK_OR_ASSIGN:       op_assign(mjs, TOK_OR);       break;\n    case TOK_XOR_ASSIGN:      op_assign(mjs, TOK_XOR);      break;\n    case TOK_LSHIFT_ASSIGN:   op_assign(mjs, TOK_LSHIFT);   break;\n    case TOK_RSHIFT_ASSIGN:   op_assign(mjs, TOK_RSHIFT);   break;\n    case TOK_URSHIFT_ASSIGN:  op_assign(mjs, TOK_URSHIFT);  break;\n    case TOK_COMMA: break;\n    /* clang-format on */\n    case TOK_KEYWORD_TYPEOF:\n      mjs_push(mjs, mjs_mk_string(mjs, mjs_typeof(mjs_pop(mjs)), ~0, 1));\n      break;\n    default:\n      LOG(LL_ERROR, (\"Unknown expr: %d\", op));\n      break;\n  }\n}",
  "func_after": "static void exec_expr(struct mjs *mjs, int op) {\n  switch (op) {\n    case TOK_DOT:\n      break;\n    case TOK_MINUS:\n    case TOK_PLUS:\n    case TOK_MUL:\n    case TOK_DIV:\n    case TOK_REM:\n    case TOK_XOR:\n    case TOK_AND:\n    case TOK_OR:\n    case TOK_LSHIFT:\n    case TOK_RSHIFT:\n    case TOK_URSHIFT: {\n      mjs_val_t b = mjs_pop(mjs);\n      mjs_val_t a = mjs_pop(mjs);\n      if (check_builtin_object(a) || check_builtin_object(b)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, do_op(mjs, a, b, op));\n      break;\n    }\n    case TOK_UNARY_MINUS: {\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      if (check_builtin_object(a)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_number(mjs, -a));\n      break;\n    }\n    case TOK_NOT: {\n      mjs_val_t val = mjs_pop(mjs);\n      if (check_builtin_object(val)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_boolean(mjs, !mjs_is_truthy(mjs, val)));\n      break;\n    }\n    case TOK_TILDA: {\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      if (check_builtin_object(a)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_number(mjs, (double) (~(int64_t) a)));\n      break;\n    }\n    case TOK_UNARY_PLUS:\n      break;\n    case TOK_EQ:\n      mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use ===, not ==\");\n      break;\n    case TOK_NE:\n      mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use !==, not !=\");\n      break;\n    case TOK_EQ_EQ: {\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_val_t b = mjs_pop(mjs);\n      if (check_builtin_object(a) || check_builtin_object(b)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_boolean(mjs, check_equal(mjs, a, b)));\n      break;\n    }\n    case TOK_NE_NE: {\n      mjs_val_t a = mjs_pop(mjs);\n      mjs_val_t b = mjs_pop(mjs);\n      if (check_builtin_object(a) || check_builtin_object(b)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_boolean(mjs, !check_equal(mjs, a, b)));\n      break;\n    }\n    case TOK_LT: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      if (check_builtin_object(a) || check_builtin_object(b)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_boolean(mjs, a < b));\n      break;\n    }\n    case TOK_GT: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      if (check_builtin_object(a) || check_builtin_object(b)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_boolean(mjs, a > b));\n      break;\n    }\n    case TOK_LE: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      if (check_builtin_object(a) || check_builtin_object(b)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_boolean(mjs, a <= b));\n      break;\n    }\n    case TOK_GE: {\n      double b = mjs_get_double(mjs, mjs_pop(mjs));\n      double a = mjs_get_double(mjs, mjs_pop(mjs));\n      if (check_builtin_object(a) || check_builtin_object(b)) {\n        printf(\"Operators cannot be used on built-in objects.\\n\");\n        exit(-1);\n      }\n      mjs_push(mjs, mjs_mk_boolean(mjs, a >= b));\n      break;\n    }\n    case TOK_ASSIGN: {\n      mjs_val_t val = mjs_pop(mjs);\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj)) {\n        mjs_set_v(mjs, obj, key, val);\n      } else if (mjs_is_foreign(obj) && !check_builtin_object(obj)) {\n        /*\n         * We don't have setters, so in order to support properties which behave\n         * like setters, we have to parse key right here, instead of having real\n         * built-in prototype objects\n         */\n\n        int ikey = mjs_get_int(mjs, key);\n        int ival = mjs_get_int(mjs, val);\n\n        if (!mjs_is_number(key)) {\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"index must be a number\");\n          val = MJS_UNDEFINED;\n        } else if (!mjs_is_number(val) || ival < 0 || ival > 0xff) {\n          mjs_prepend_errorf(mjs, MJS_TYPE_ERROR,\n                             \"only number 0 .. 255 can be assigned\");\n          val = MJS_UNDEFINED;\n        } else {\n          uint8_t *ptr = (uint8_t *) mjs_get_ptr(mjs, obj);\n          *(ptr + ikey) = (uint8_t) ival;\n        }\n      } else {\n        mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \"unsupported object type\");\n      }\n      mjs_push(mjs, val);\n      break;\n    }\n    case TOK_POSTFIX_PLUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        if (check_builtin_object(v)) {\n          printf(\"Operators cannot be used on built-in objects.\\n\");\n          exit(-1);\n        }\n        mjs_val_t v1 = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_PLUS);\n        mjs_set_v(mjs, obj, key, v1);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for ++\");\n      }\n      break;\n    }\n    case TOK_POSTFIX_MINUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        if (check_builtin_object(v)) {\n          printf(\"Operators cannot be used on built-in objects.\\n\");\n          exit(-1);\n        }\n        mjs_val_t v1 = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_MINUS);\n        mjs_set_v(mjs, obj, key, v1);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for --\");\n      }\n      break;\n    }\n    case TOK_MINUS_MINUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        if (check_builtin_object(v)) {\n          printf(\"Operators cannot be used on built-in objects.\\n\");\n          exit(-1);\n        }\n        v = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_MINUS);\n        mjs_set_v(mjs, obj, key, v);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for --\");\n      }\n      break;\n    }\n    case TOK_PLUS_PLUS: {\n      mjs_val_t obj = mjs_pop(mjs);\n      mjs_val_t key = mjs_pop(mjs);\n      if (mjs_is_object(obj) && mjs_is_string(key)) {\n        mjs_val_t v = mjs_get_v(mjs, obj, key);\n        if (check_builtin_object(v)) {\n          printf(\"Operators cannot be used on built-in objects.\\n\");\n          exit(-1);\n        }\n        v = do_op(mjs, v, mjs_mk_number(mjs, 1), TOK_PLUS);\n        mjs_set_v(mjs, obj, key, v);\n        mjs_push(mjs, v);\n      } else {\n        mjs_set_errorf(mjs, MJS_TYPE_ERROR, \"invalid operand for ++\");\n      }\n      break;\n    }\n    /*\n     * NOTE: TOK_LOGICAL_AND and TOK_LOGICAL_OR don't need to be here, because\n     * they are just naturally handled by the short-circuit evaluation.\n     * See PARSE_LTR_BINOP() macro in mjs_parser.c.\n     */\n\n    /* clang-format off */\n    case TOK_MINUS_ASSIGN:    op_assign(mjs, TOK_MINUS);    break;\n    case TOK_PLUS_ASSIGN:     op_assign(mjs, TOK_PLUS);     break;\n    case TOK_MUL_ASSIGN:      op_assign(mjs, TOK_MUL);      break;\n    case TOK_DIV_ASSIGN:      op_assign(mjs, TOK_DIV);      break;\n    case TOK_REM_ASSIGN:      op_assign(mjs, TOK_REM);      break;\n    case TOK_AND_ASSIGN:      op_assign(mjs, TOK_AND);      break;\n    case TOK_OR_ASSIGN:       op_assign(mjs, TOK_OR);       break;\n    case TOK_XOR_ASSIGN:      op_assign(mjs, TOK_XOR);      break;\n    case TOK_LSHIFT_ASSIGN:   op_assign(mjs, TOK_LSHIFT);   break;\n    case TOK_RSHIFT_ASSIGN:   op_assign(mjs, TOK_RSHIFT);   break;\n    case TOK_URSHIFT_ASSIGN:  op_assign(mjs, TOK_URSHIFT);  break;\n    case TOK_COMMA: break;\n    /* clang-format on */\n    case TOK_KEYWORD_TYPEOF:\n      mjs_push(mjs, mjs_mk_string(mjs, mjs_typeof(mjs_pop(mjs)), ~0, 1));\n      break;\n    default:\n      LOG(LL_ERROR, (\"Unknown expr: %d\", op));\n      break;\n  }\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void exec_expr(struct mjs *mjs, int op) {\n   switch (op) {\n     case TOK_DOT:\n       break;\n     case TOK_MINUS:\n     case TOK_PLUS:\n     case TOK_MUL:\n     case TOK_DIV:\n     case TOK_REM:\n     case TOK_XOR:\n     case TOK_AND:\n     case TOK_OR:\n     case TOK_LSHIFT:\n     case TOK_RSHIFT:\n     case TOK_URSHIFT: {\n       mjs_val_t b = mjs_pop(mjs);\n       mjs_val_t a = mjs_pop(mjs);\n+      if (check_builtin_object(a) || check_builtin_object(b)) {\n+        printf(\"Operators cannot be used on built-in objects.\\n\");\n+        exit(-1);\n+      }\n       mjs_push(mjs, do_op(mjs, a, b, op));\n       break;\n     }\n     case TOK_UNARY_MINUS: {\n       double a = mjs_get_double(mjs, mjs_pop(mjs));\n+      if (check_builtin_object(a)) {\n+        printf(\"Operators cannot be used on built-in objects.\\n\");\n+        exit(-1);\n+      }\n       mjs_push(mjs, mjs_mk_number(mjs, -a));\n       break;\n     }\n     case TOK_NOT: {\n       mjs_val_t val = mjs_pop(mjs);\n+      if (check_builtin_object(val)) {\n+        printf(\"Operators cannot be used on built-in objects.\\n\");\n+        exit(-1);\n+      }\n       mjs_push(mjs, mjs_mk_boolean(mjs, !mjs_is_truthy(mjs, val)));\n       break;\n     }\n     case TOK_TILDA: {\n       double a = mjs_get_double(mjs, mjs_pop(mjs));\n+      if (check_builtin_object(a)) {\n+        printf(\"Operators cannot be used on built-in objects.\\n\");\n+        exit(-1);\n+      }\n       mjs_push(mjs, mjs_mk_number(mjs, (double) (~(int64_t) a)));\n       break;\n     }\n     case TOK_UNARY_PLUS:\n       break;\n     case TOK_EQ:\n       mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use ===, not ==\");\n       break;\n     case TOK_NE:\n       mjs_set_errorf(mjs, MJS_NOT_IMPLEMENTED_ERROR, \"Use !==, not !=\");\n       break;\n     case TOK_EQ_EQ: {\n       mjs_val_t a = mjs_pop(mjs);\n       mjs_val_t b = mjs_pop(mjs);\n+      if (check_builtin_object(a) || check_builtin_object(b)) {\n+        printf(\"Operators cannot be used on built-in objects.\\n\");\n+      ",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\nThe patch addresses a bug causing a segmentation fault when using operators on built-in objects. It adds checks to prevent such crashes by validating inputs. While the crash could be triggered by user input, the fix doesn't directly address a security vulnerability but improves stability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.85"
}