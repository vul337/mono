{
  "id": 3126,
  "language": "Java",
  "commit_url": "https://github.com/GrapheneOS/platform_frameworks_base/commit/416a04e4c6e9fc876b0c35562967e933ac98046e",
  "commit_sha": "416a04e4c6e9fc876b0c35562967e933ac98046e",
  "commit_msg": "Fix permission state missing when backup is restored.\n\nThe BackupAgent of an application may run before package post\ninstallation, so the permission state must be ready by then. So\ninstead of calling onPackageInstalled() in post install, we can revert\nto calling it in updateSettingsInternalLI() as in R (before\nag/13144022 which introduced the regression).\n\nThis changes the grant permissions etc to be done before package\npost-installation, but this might be actually a correct change as\napplication code may expect permissions, and we are already doing it\nlike this in installExistingPackageAsUser() so this change is making\nit consistent.\n\nFixes: 175932103\nTest: manual\nTest: Wipe and restore a backup and ensure Keep is no longer crashing.\nTest: presubmit\nChange-Id: Ie2e0dbd7a1a8454f9935527b9c303c26010ff592",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/pm/PackageManagerService.java",
  "func_name": "doHandleMessage",
  "func_before": "void doHandleMessage(Message msg) {\n            switch (msg.what) {\n                case INIT_COPY: {\n                    HandlerParams params = (HandlerParams) msg.obj;\n                    if (params != null) {\n                        if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy: \" + params);\n                        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"queueInstall\",\n                                System.identityHashCode(params));\n                        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"startCopy\");\n                        params.startCopy();\n                        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                    }\n                    break;\n                }\n                case SEND_PENDING_BROADCAST: {\n                    String packages[];\n                    ArrayList<String> components[];\n                    int size = 0;\n                    int uids[];\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                    synchronized (mLock) {\n                        size = mPendingBroadcasts.size();\n                        if (size <= 0) {\n                            // Nothing to be done. Just return\n                            return;\n                        }\n                        packages = new String[size];\n                        components = new ArrayList[size];\n                        uids = new int[size];\n                        int i = 0;  // filling out the above arrays\n\n                        for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {\n                            final int packageUserId = mPendingBroadcasts.userIdAt(n);\n                            final ArrayMap<String, ArrayList<String>> componentsToBroadcast =\n                                    mPendingBroadcasts.packagesForUserId(packageUserId);\n                            final int numComponents = componentsToBroadcast.size();\n                            for (int index = 0; i < size && index < numComponents; index++) {\n                                packages[i] = componentsToBroadcast.keyAt(index);\n                                components[i] = componentsToBroadcast.valueAt(index);\n                                final PackageSetting ps = mSettings.getPackageLPr(packages[i]);\n                                uids[i] = (ps != null)\n                                        ? UserHandle.getUid(packageUserId, ps.appId)\n                                        : -1;\n                                i++;\n                            }\n                        }\n                        size = i;\n                        mPendingBroadcasts.clear();\n                    }\n                    // Send broadcasts\n                    for (int i = 0; i < size; i++) {\n                        sendPackageChangedBroadcast(packages[i], true /* dontKillApp */,\n                                components[i], uids[i], null /* reason */);\n                    }\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                    break;\n                }\n                case POST_INSTALL: {\n                    if (DEBUG_INSTALL) Log.v(TAG, \"Handling post-install for \" + msg.arg1);\n\n                    PostInstallData data = mRunningInstalls.get(msg.arg1);\n                    final boolean didRestore = (msg.arg2 != 0);\n                    mRunningInstalls.delete(msg.arg1);\n\n                    if (data != null && data.res.freezer != null) {\n                        data.res.freezer.close();\n                    }\n\n                    if (data != null && data.mPostInstallRunnable != null) {\n                        data.mPostInstallRunnable.run();\n                    } else if (data != null && data.args != null) {\n                        InstallArgs args = data.args;\n                        PackageInstalledInfo parentRes = data.res;\n\n                        final boolean grantPermissions = (args.installFlags\n                                & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0;\n                        final boolean killApp = (args.installFlags\n                                & PackageManager.INSTALL_DONT_KILL_APP) == 0;\n                        final boolean virtualPreload = ((args.installFlags\n                                & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);\n                        final String[] grantedPermissions = args.installGrantPermissions;\n                        final List<String> whitelistedRestrictedPermissions = ((args.installFlags\n                                & PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS) != 0\n                                    && parentRes.pkg != null)\n                                ? parentRes.pkg.getRequestedPermissions()\n                                : args.whitelistedRestrictedPermissions;\n                        int autoRevokePermissionsMode = args.autoRevokePermissionsMode;\n\n                        handlePackagePostInstall(parentRes, grantPermissions,\n                                killApp, virtualPreload, grantedPermissions,\n                                whitelistedRestrictedPermissions, autoRevokePermissionsMode,\n                                didRestore, args.installSource.installerPackageName, args.observer,\n                                args.mDataLoaderType);\n\n                        // Log tracing if needed\n                        if (args.traceMethod != null) {\n                            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, args.traceMethod,\n                                    args.traceCookie);\n                        }\n                    } else if (DEBUG_INSTALL) {\n                        // No post-install when we run restore from installExistingPackageForUser\n                        Slog.i(TAG, \"Nothing to do for post-install token \" + msg.arg1);\n                    }\n\n                    Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"postInstall\", msg.arg1);\n                } break;\n                case DEFERRED_NO_KILL_POST_DELETE: {\n                    synchronized (mInstallLock) {\n                        InstallArgs args = (InstallArgs) msg.obj;\n                        if (args != null) {\n                            args.doPostDeleteLI(true);\n                        }\n                    }\n                } break;\n                case DEFERRED_NO_KILL_INSTALL_OBSERVER: {\n                    String packageName = (String) msg.obj;\n                    if (packageName != null) {\n                        notifyInstallObserver(packageName);\n                    }\n                } break;\n                case WRITE_SETTINGS: {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                    synchronized (mLock) {\n                        removeMessages(WRITE_SETTINGS);\n                        removeMessages(WRITE_PACKAGE_RESTRICTIONS);\n                        writeSettingsLPrTEMP();\n                        mDirtyUsers.clear();\n                    }\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                } break;\n                case WRITE_PACKAGE_RESTRICTIONS: {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                    synchronized (mLock) {\n                        removeMessages(WRITE_PACKAGE_RESTRICTIONS);\n                        for (int userId : mDirtyUsers) {\n                            mSettings.writePackageRestrictionsLPr(userId);\n                        }\n                        mDirtyUsers.clear();\n                    }\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                } break;\n                case WRITE_PACKAGE_LIST: {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                    synchronized (mLock) {\n                        removeMessages(WRITE_PACKAGE_LIST);\n                        mSettings.writePackageListLPr(msg.arg1);\n                    }\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                } break;\n                case CHECK_PENDING_VERIFICATION: {\n                    final int verificationId = msg.arg1;\n                    final PackageVerificationState state = mPendingVerification.get(verificationId);\n\n                    if ((state != null) && !state.isVerificationComplete()\n                            && !state.timeoutExtended()) {\n                        final VerificationParams params = state.getVerificationParams();\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                        Slog.i(TAG, \"Verification timed out for \" + originUri);\n\n                        final UserHandle user = params.getUser();\n                        if (getDefaultVerificationResponse(user)\n                                == PackageManager.VERIFICATION_ALLOW) {\n                            Slog.i(TAG, \"Continuing with installation of \" + originUri);\n                            state.setVerifierResponse(Binder.getCallingUid(),\n                                    PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);\n                            broadcastPackageVerified(verificationId, originUri,\n                                    PackageManager.VERIFICATION_ALLOW, null, params.mDataLoaderType,\n                                    user);\n                        } else {\n                            broadcastPackageVerified(verificationId, originUri,\n                                    PackageManager.VERIFICATION_REJECT, null,\n                                    params.mDataLoaderType, user);\n                            params.setReturnCode(\n                                    PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE);\n                            state.setVerifierResponse(Binder.getCallingUid(),\n                                    PackageManager.VERIFICATION_REJECT);\n                        }\n\n                        if (state.areAllVerificationsComplete()) {\n                            mPendingVerification.remove(verificationId);\n                        }\n\n                        Trace.asyncTraceEnd(\n                                TRACE_TAG_PACKAGE_MANAGER, \"verification\", verificationId);\n\n                        params.handleVerificationFinished();\n\n                    }\n                    break;\n                }\n                case CHECK_PENDING_INTEGRITY_VERIFICATION: {\n                    final int verificationId = msg.arg1;\n                    final PackageVerificationState state = mPendingVerification.get(verificationId);\n\n                    if (state != null && !state.isIntegrityVerificationComplete()) {\n                        final VerificationParams params = state.getVerificationParams();\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                        Slog.i(TAG, \"Integrity verification timed out for \" + originUri);\n\n                        state.setIntegrityVerificationResult(\n                                getDefaultIntegrityVerificationResponse());\n\n                        if (getDefaultIntegrityVerificationResponse()\n                                == PackageManagerInternal.INTEGRITY_VERIFICATION_ALLOW) {\n                            Slog.i(TAG, \"Integrity check times out, continuing with \" + originUri);\n                        } else {\n                            params.setReturnCode(\n                                    PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE);\n                        }\n\n                        if (state.areAllVerificationsComplete()) {\n                            mPendingVerification.remove(verificationId);\n                        }\n\n                        Trace.asyncTraceEnd(\n                                TRACE_TAG_PACKAGE_MANAGER,\n                                \"integrity_verification\",\n                                verificationId);\n\n                        params.handleIntegrityVerificationFinished();\n                    }\n                    break;\n                }\n                case PACKAGE_VERIFIED: {\n                    final int verificationId = msg.arg1;\n\n                    final PackageVerificationState state = mPendingVerification.get(verificationId);\n                    if (state == null) {\n                        Slog.w(TAG, \"Verification with id \" + verificationId\n                                + \" not found.\"\n                                + \" It may be invalid or overridden by integrity verification\");\n                        break;\n                    }\n\n                    final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;\n\n                    state.setVerifierResponse(response.callerUid, response.code);\n\n                    if (state.isVerificationComplete()) {\n                        final VerificationParams params = state.getVerificationParams();\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                        if (state.isInstallAllowed()) {\n                            broadcastPackageVerified(verificationId, originUri,\n                                    response.code, null, params.mDataLoaderType, params.getUser());\n                        } else {\n                            params.setReturnCode(\n                                    PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE);\n                        }\n\n                        if (state.areAllVerificationsComplete()) {\n                            mPendingVerification.remove(verificationId);\n                        }\n\n                        Trace.asyncTraceEnd(\n                                TRACE_TAG_PACKAGE_MANAGER, \"verification\", verificationId);\n\n                        params.handleVerificationFinished();\n                    }\n\n                    break;\n                }\n                case INTEGRITY_VERIFICATION_COMPLETE: {\n                    final int verificationId = msg.arg1;\n\n                    final PackageVerificationState state = mPendingVerification.get(verificationId);\n                    if (state == null) {\n                        Slog.w(TAG, \"Integrity verification with id \" + verificationId\n                                + \" not found. It may be invalid or overridden by verifier\");\n                        break;\n                    }\n\n                    final int response = (Integer) msg.obj;\n                    final VerificationParams params = state.getVerificationParams();\n                    final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                    state.setIntegrityVerificationResult(response);\n\n                    if (response == PackageManagerInternal.INTEGRITY_VERIFICATION_ALLOW) {\n                        Slog.i(TAG, \"Integrity check passed for \" + originUri);\n                    } else {\n                        params.setReturnCode(\n                                PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE);\n                    }\n\n                    if (state.areAllVerificationsComplete()) {\n                        mPendingVerification.remove(verificationId);\n                    }\n\n                    Trace.asyncTraceEnd(\n                            TRACE_TAG_PACKAGE_MANAGER,\n                            \"integrity_verification\",\n                            verificationId);\n\n                    params.handleIntegrityVerificationFinished();\n                    break;\n                }\n                case INSTANT_APP_RESOLUTION_PHASE_TWO: {\n                    InstantAppResolver.doInstantAppResolutionPhaseTwo(mContext,\n                            mInstantAppResolverConnection,\n                            (InstantAppRequest) msg.obj,\n                            mInstantAppInstallerActivity,\n                            mHandler);\n                    break;\n                }\n                case ENABLE_ROLLBACK_STATUS: {\n                    final int enableRollbackToken = msg.arg1;\n                    final int enableRollbackCode = msg.arg2;\n                    final VerificationParams params =\n                            mPendingEnableRollback.get(enableRollbackToken);\n                    if (params == null) {\n                        Slog.w(TAG, \"Invalid rollback enabled token \"\n                                + enableRollbackToken + \" received\");\n                        break;\n                    }\n\n                    mPendingEnableRollback.remove(enableRollbackToken);\n\n                    if (enableRollbackCode != PackageManagerInternal.ENABLE_ROLLBACK_SUCCEEDED) {\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n                        Slog.w(TAG, \"Failed to enable rollback for \" + originUri);\n                        Slog.w(TAG, \"Continuing with installation of \" + originUri);\n                    }\n\n                    Trace.asyncTraceEnd(\n                            TRACE_TAG_PACKAGE_MANAGER, \"enable_rollback\", enableRollbackToken);\n\n                    params.handleRollbackEnabled();\n                    break;\n                }\n                case ENABLE_ROLLBACK_TIMEOUT: {\n                    final int enableRollbackToken = msg.arg1;\n                    final int sessionId = msg.arg2;\n                    final VerificationParams params =\n                            mPendingEnableRollback.get(enableRollbackToken);\n                    if (params != null) {\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                        Slog.w(TAG, \"Enable rollback timed out for \" + originUri);\n                        mPendingEnableRollback.remove(enableRollbackToken);\n\n                        Slog.w(TAG, \"Continuing with installation of \" + originUri);\n                        Trace.asyncTraceEnd(\n                                TRACE_TAG_PACKAGE_MANAGER, \"enable_rollback\", enableRollbackToken);\n                        params.handleRollbackEnabled();\n                        Intent rollbackTimeoutIntent = new Intent(\n                                Intent.ACTION_CANCEL_ENABLE_ROLLBACK);\n                        rollbackTimeoutIntent.putExtra(\n                                PackageManagerInternal.EXTRA_ENABLE_ROLLBACK_SESSION_ID,\n                                sessionId);\n                        rollbackTimeoutIntent.addFlags(\n                                Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);\n                        mContext.sendBroadcastAsUser(rollbackTimeoutIntent, UserHandle.SYSTEM,\n                                android.Manifest.permission.PACKAGE_ROLLBACK_AGENT);\n                    }\n                    break;\n                }\n                case DOMAIN_VERIFICATION: {\n                    int messageCode = msg.arg1;\n                    Object object = msg.obj;\n                    mDomainVerificationManager.runMessage(messageCode, object);\n                    break;\n                }\n            }\n        }",
  "func_after": "void doHandleMessage(Message msg) {\n            switch (msg.what) {\n                case INIT_COPY: {\n                    HandlerParams params = (HandlerParams) msg.obj;\n                    if (params != null) {\n                        if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy: \" + params);\n                        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"queueInstall\",\n                                System.identityHashCode(params));\n                        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"startCopy\");\n                        params.startCopy();\n                        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                    }\n                    break;\n                }\n                case SEND_PENDING_BROADCAST: {\n                    String packages[];\n                    ArrayList<String> components[];\n                    int size = 0;\n                    int uids[];\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                    synchronized (mLock) {\n                        size = mPendingBroadcasts.size();\n                        if (size <= 0) {\n                            // Nothing to be done. Just return\n                            return;\n                        }\n                        packages = new String[size];\n                        components = new ArrayList[size];\n                        uids = new int[size];\n                        int i = 0;  // filling out the above arrays\n\n                        for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {\n                            final int packageUserId = mPendingBroadcasts.userIdAt(n);\n                            final ArrayMap<String, ArrayList<String>> componentsToBroadcast =\n                                    mPendingBroadcasts.packagesForUserId(packageUserId);\n                            final int numComponents = componentsToBroadcast.size();\n                            for (int index = 0; i < size && index < numComponents; index++) {\n                                packages[i] = componentsToBroadcast.keyAt(index);\n                                components[i] = componentsToBroadcast.valueAt(index);\n                                final PackageSetting ps = mSettings.getPackageLPr(packages[i]);\n                                uids[i] = (ps != null)\n                                        ? UserHandle.getUid(packageUserId, ps.appId)\n                                        : -1;\n                                i++;\n                            }\n                        }\n                        size = i;\n                        mPendingBroadcasts.clear();\n                    }\n                    // Send broadcasts\n                    for (int i = 0; i < size; i++) {\n                        sendPackageChangedBroadcast(packages[i], true /* dontKillApp */,\n                                components[i], uids[i], null /* reason */);\n                    }\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                    break;\n                }\n                case POST_INSTALL: {\n                    if (DEBUG_INSTALL) Log.v(TAG, \"Handling post-install for \" + msg.arg1);\n\n                    PostInstallData data = mRunningInstalls.get(msg.arg1);\n                    final boolean didRestore = (msg.arg2 != 0);\n                    mRunningInstalls.delete(msg.arg1);\n\n                    if (data != null && data.res.freezer != null) {\n                        data.res.freezer.close();\n                    }\n\n                    if (data != null && data.mPostInstallRunnable != null) {\n                        data.mPostInstallRunnable.run();\n                    } else if (data != null && data.args != null) {\n                        InstallArgs args = data.args;\n                        PackageInstalledInfo parentRes = data.res;\n\n                        final boolean killApp = (args.installFlags\n                                & PackageManager.INSTALL_DONT_KILL_APP) == 0;\n                        final boolean virtualPreload = ((args.installFlags\n                                & PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0);\n\n                        handlePackagePostInstall(parentRes, killApp, virtualPreload,\n                                didRestore, args.installSource.installerPackageName, args.observer,\n                                args.mDataLoaderType);\n\n                        // Log tracing if needed\n                        if (args.traceMethod != null) {\n                            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, args.traceMethod,\n                                    args.traceCookie);\n                        }\n                    } else if (DEBUG_INSTALL) {\n                        // No post-install when we run restore from installExistingPackageForUser\n                        Slog.i(TAG, \"Nothing to do for post-install token \" + msg.arg1);\n                    }\n\n                    Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"postInstall\", msg.arg1);\n                } break;\n                case DEFERRED_NO_KILL_POST_DELETE: {\n                    synchronized (mInstallLock) {\n                        InstallArgs args = (InstallArgs) msg.obj;\n                        if (args != null) {\n                            args.doPostDeleteLI(true);\n                        }\n                    }\n                } break;\n                case DEFERRED_NO_KILL_INSTALL_OBSERVER: {\n                    String packageName = (String) msg.obj;\n                    if (packageName != null) {\n                        notifyInstallObserver(packageName);\n                    }\n                } break;\n                case WRITE_SETTINGS: {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                    synchronized (mLock) {\n                        removeMessages(WRITE_SETTINGS);\n                        removeMessages(WRITE_PACKAGE_RESTRICTIONS);\n                        writeSettingsLPrTEMP();\n                        mDirtyUsers.clear();\n                    }\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                } break;\n                case WRITE_PACKAGE_RESTRICTIONS: {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                    synchronized (mLock) {\n                        removeMessages(WRITE_PACKAGE_RESTRICTIONS);\n                        for (int userId : mDirtyUsers) {\n                            mSettings.writePackageRestrictionsLPr(userId);\n                        }\n                        mDirtyUsers.clear();\n                    }\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                } break;\n                case WRITE_PACKAGE_LIST: {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                    synchronized (mLock) {\n                        removeMessages(WRITE_PACKAGE_LIST);\n                        mSettings.writePackageListLPr(msg.arg1);\n                    }\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                } break;\n                case CHECK_PENDING_VERIFICATION: {\n                    final int verificationId = msg.arg1;\n                    final PackageVerificationState state = mPendingVerification.get(verificationId);\n\n                    if ((state != null) && !state.isVerificationComplete()\n                            && !state.timeoutExtended()) {\n                        final VerificationParams params = state.getVerificationParams();\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                        Slog.i(TAG, \"Verification timed out for \" + originUri);\n\n                        final UserHandle user = params.getUser();\n                        if (getDefaultVerificationResponse(user)\n                                == PackageManager.VERIFICATION_ALLOW) {\n                            Slog.i(TAG, \"Continuing with installation of \" + originUri);\n                            state.setVerifierResponse(Binder.getCallingUid(),\n                                    PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);\n                            broadcastPackageVerified(verificationId, originUri,\n                                    PackageManager.VERIFICATION_ALLOW, null, params.mDataLoaderType,\n                                    user);\n                        } else {\n                            broadcastPackageVerified(verificationId, originUri,\n                                    PackageManager.VERIFICATION_REJECT, null,\n                                    params.mDataLoaderType, user);\n                            params.setReturnCode(\n                                    PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE);\n                            state.setVerifierResponse(Binder.getCallingUid(),\n                                    PackageManager.VERIFICATION_REJECT);\n                        }\n\n                        if (state.areAllVerificationsComplete()) {\n                            mPendingVerification.remove(verificationId);\n                        }\n\n                        Trace.asyncTraceEnd(\n                                TRACE_TAG_PACKAGE_MANAGER, \"verification\", verificationId);\n\n                        params.handleVerificationFinished();\n\n                    }\n                    break;\n                }\n                case CHECK_PENDING_INTEGRITY_VERIFICATION: {\n                    final int verificationId = msg.arg1;\n                    final PackageVerificationState state = mPendingVerification.get(verificationId);\n\n                    if (state != null && !state.isIntegrityVerificationComplete()) {\n                        final VerificationParams params = state.getVerificationParams();\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                        Slog.i(TAG, \"Integrity verification timed out for \" + originUri);\n\n                        state.setIntegrityVerificationResult(\n                                getDefaultIntegrityVerificationResponse());\n\n                        if (getDefaultIntegrityVerificationResponse()\n                                == PackageManagerInternal.INTEGRITY_VERIFICATION_ALLOW) {\n                            Slog.i(TAG, \"Integrity check times out, continuing with \" + originUri);\n                        } else {\n                            params.setReturnCode(\n                                    PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE);\n                        }\n\n                        if (state.areAllVerificationsComplete()) {\n                            mPendingVerification.remove(verificationId);\n                        }\n\n                        Trace.asyncTraceEnd(\n                                TRACE_TAG_PACKAGE_MANAGER,\n                                \"integrity_verification\",\n                                verificationId);\n\n                        params.handleIntegrityVerificationFinished();\n                    }\n                    break;\n                }\n                case PACKAGE_VERIFIED: {\n                    final int verificationId = msg.arg1;\n\n                    final PackageVerificationState state = mPendingVerification.get(verificationId);\n                    if (state == null) {\n                        Slog.w(TAG, \"Verification with id \" + verificationId\n                                + \" not found.\"\n                                + \" It may be invalid or overridden by integrity verification\");\n                        break;\n                    }\n\n                    final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;\n\n                    state.setVerifierResponse(response.callerUid, response.code);\n\n                    if (state.isVerificationComplete()) {\n                        final VerificationParams params = state.getVerificationParams();\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                        if (state.isInstallAllowed()) {\n                            broadcastPackageVerified(verificationId, originUri,\n                                    response.code, null, params.mDataLoaderType, params.getUser());\n                        } else {\n                            params.setReturnCode(\n                                    PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE);\n                        }\n\n                        if (state.areAllVerificationsComplete()) {\n                            mPendingVerification.remove(verificationId);\n                        }\n\n                        Trace.asyncTraceEnd(\n                                TRACE_TAG_PACKAGE_MANAGER, \"verification\", verificationId);\n\n                        params.handleVerificationFinished();\n                    }\n\n                    break;\n                }\n                case INTEGRITY_VERIFICATION_COMPLETE: {\n                    final int verificationId = msg.arg1;\n\n                    final PackageVerificationState state = mPendingVerification.get(verificationId);\n                    if (state == null) {\n                        Slog.w(TAG, \"Integrity verification with id \" + verificationId\n                                + \" not found. It may be invalid or overridden by verifier\");\n                        break;\n                    }\n\n                    final int response = (Integer) msg.obj;\n                    final VerificationParams params = state.getVerificationParams();\n                    final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                    state.setIntegrityVerificationResult(response);\n\n                    if (response == PackageManagerInternal.INTEGRITY_VERIFICATION_ALLOW) {\n                        Slog.i(TAG, \"Integrity check passed for \" + originUri);\n                    } else {\n                        params.setReturnCode(\n                                PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE);\n                    }\n\n                    if (state.areAllVerificationsComplete()) {\n                        mPendingVerification.remove(verificationId);\n                    }\n\n                    Trace.asyncTraceEnd(\n                            TRACE_TAG_PACKAGE_MANAGER,\n                            \"integrity_verification\",\n                            verificationId);\n\n                    params.handleIntegrityVerificationFinished();\n                    break;\n                }\n                case INSTANT_APP_RESOLUTION_PHASE_TWO: {\n                    InstantAppResolver.doInstantAppResolutionPhaseTwo(mContext,\n                            mInstantAppResolverConnection,\n                            (InstantAppRequest) msg.obj,\n                            mInstantAppInstallerActivity,\n                            mHandler);\n                    break;\n                }\n                case ENABLE_ROLLBACK_STATUS: {\n                    final int enableRollbackToken = msg.arg1;\n                    final int enableRollbackCode = msg.arg2;\n                    final VerificationParams params =\n                            mPendingEnableRollback.get(enableRollbackToken);\n                    if (params == null) {\n                        Slog.w(TAG, \"Invalid rollback enabled token \"\n                                + enableRollbackToken + \" received\");\n                        break;\n                    }\n\n                    mPendingEnableRollback.remove(enableRollbackToken);\n\n                    if (enableRollbackCode != PackageManagerInternal.ENABLE_ROLLBACK_SUCCEEDED) {\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n                        Slog.w(TAG, \"Failed to enable rollback for \" + originUri);\n                        Slog.w(TAG, \"Continuing with installation of \" + originUri);\n                    }\n\n                    Trace.asyncTraceEnd(\n                            TRACE_TAG_PACKAGE_MANAGER, \"enable_rollback\", enableRollbackToken);\n\n                    params.handleRollbackEnabled();\n                    break;\n                }\n                case ENABLE_ROLLBACK_TIMEOUT: {\n                    final int enableRollbackToken = msg.arg1;\n                    final int sessionId = msg.arg2;\n                    final VerificationParams params =\n                            mPendingEnableRollback.get(enableRollbackToken);\n                    if (params != null) {\n                        final Uri originUri = Uri.fromFile(params.origin.resolvedFile);\n\n                        Slog.w(TAG, \"Enable rollback timed out for \" + originUri);\n                        mPendingEnableRollback.remove(enableRollbackToken);\n\n                        Slog.w(TAG, \"Continuing with installation of \" + originUri);\n                        Trace.asyncTraceEnd(\n                                TRACE_TAG_PACKAGE_MANAGER, \"enable_rollback\", enableRollbackToken);\n                        params.handleRollbackEnabled();\n                        Intent rollbackTimeoutIntent = new Intent(\n                                Intent.ACTION_CANCEL_ENABLE_ROLLBACK);\n                        rollbackTimeoutIntent.putExtra(\n                                PackageManagerInternal.EXTRA_ENABLE_ROLLBACK_SESSION_ID,\n                                sessionId);\n                        rollbackTimeoutIntent.addFlags(\n                                Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);\n                        mContext.sendBroadcastAsUser(rollbackTimeoutIntent, UserHandle.SYSTEM,\n                                android.Manifest.permission.PACKAGE_ROLLBACK_AGENT);\n                    }\n                    break;\n                }\n                case DOMAIN_VERIFICATION: {\n                    int messageCode = msg.arg1;\n                    Object object = msg.obj;\n                    mDomainVerificationManager.runMessage(messageCode, object);\n                    break;\n                }\n            }\n        }",
  "diff_func": "--- func_before\n+++ func_after\n void doHandleMessage(Message msg) {\n             switch (msg.what) {\n                 case INIT_COPY: {\n                     HandlerParams params = (HandlerParams) msg.obj;\n                     if (params != null) {\n                         if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy: \" + params);\n                         Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"queueInstall\",\n                                 System.identityHashCode(params));\n                         Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"startCopy\");\n                         params.startCopy();\n                         Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n                     }\n                     break;\n                 }\n                 case SEND_PENDING_BROADCAST: {\n                     String packages[];\n                     ArrayList<String> components[];\n                     int size = 0;\n                     int uids[];\n                     Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n                     synchronized (mLock) {\n                         size = mPendingBroadcasts.size();\n                         if (size <= 0) {\n                             // Nothing to be done. Just return\n                             return;\n                         }\n                         packages = new String[size];\n                         components = new ArrayList[size];\n                         uids = new int[size];\n                         int i = 0;  // filling out the above arrays\n \n                         for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {\n                             final int packageUserId = mPendingBroadcasts.userIdAt(n);\n                             final ArrayMap<String, ArrayList<String>> componentsToBroadcast =\n                                     mPendingBroadcasts.packagesForUserId(packageUserId);\n                             final int numComponents = componentsToBroadcast.size();\n             ",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a functional bug where permissions weren't correctly set during backup restoration, leading to application crashes. It doesn't resolve a security vulnerability but ensures proper application behavior.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.9"
}