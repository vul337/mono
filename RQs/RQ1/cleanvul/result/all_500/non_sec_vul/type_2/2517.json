{
  "id": 2517,
  "language": "Java",
  "commit_url": "https://github.com/openjdk/leyden/commit/1e9ed54d362b8c57be5fbbac2de5afbd0f05435f",
  "commit_sha": "1e9ed54d362b8c57be5fbbac2de5afbd0f05435f",
  "commit_msg": "8193682: Infinite loop in ZipOutputStream.close()\n\nReviewed-by: lancea, coffeys",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/java.base/share/classes/java/util/zip/GZIPOutputStream.java",
  "func_name": "IOException",
  "func_before": "public void finish() throws IOException {\n        if (!def.finished()) {\n            def.finish();\n            while (!def.finished()) {\n                int len = def.deflate(buf, 0, buf.length);\n                if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n                    // last deflater buffer. Fit trailer at the end\n                    writeTrailer(buf, len);\n                    len = len + TRAILER_SIZE;\n                    out.write(buf, 0, len);\n                    return;\n                }\n                if (len > 0)\n                    out.write(buf, 0, len);\n            }\n            // if we can't fit the trailer at the end of the last\n            // deflater buffer, we write it separately\n            byte[] trailer = new byte[TRAILER_SIZE];\n            writeTrailer(trailer, 0);\n            out.write(trailer);\n        }\n    }",
  "func_after": "public void finish() throws IOException {\n        if (!def.finished()) {\n            try {\n                def.finish();\n                while (!def.finished()) {\n                    int len = def.deflate(buf, 0, buf.length);\n                    if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n                        // last deflater buffer. Fit trailer at the end\n                        writeTrailer(buf, len);\n                        len = len + TRAILER_SIZE;\n                        out.write(buf, 0, len);\n                        return;\n                    }\n                    if (len > 0)\n                        out.write(buf, 0, len);\n                }\n                // if we can't fit the trailer at the end of the last\n                // deflater buffer, we write it separately\n                byte[] trailer = new byte[TRAILER_SIZE];\n                writeTrailer(trailer, 0);\n                out.write(trailer);\n            } catch (IOException e) {\n                if (usesDefaultDeflater)\n                    def.end();\n                throw e;\n            }\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public void finish() throws IOException {\n         if (!def.finished()) {\n+            try {\n-            def.finish();\n+                def.finish();\n-            while (!def.finished()) {\n+                while (!def.finished()) {\n-                int len = def.deflate(buf, 0, buf.length);\n+                    int len = def.deflate(buf, 0, buf.length);\n-                if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n+                    if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n-                    // last deflater buffer. Fit trailer at the end\n+                        // last deflater buffer. Fit trailer at the end\n-                    writeTrailer(buf, len);\n+                        writeTrailer(buf, len);\n-                    len = len + TRAILER_SIZE;\n+                        len = len + TRAILER_SIZE;\n-                    out.write(buf, 0, len);\n+                        out.write(buf, 0, len);\n-                    return;\n+                        return;\n+                    }\n+                    if (len > 0)\n+                        out.write(buf, 0, len);\n                 }\n-                if (len > 0)\n+                // if we can't fit the trailer at the end of the last\n+                // deflater buffer, we write it separately\n+                byte[] trailer = new byte[TRAILER_SIZE];\n+                writeTrailer(trailer, 0);\n-                    out.write(buf, 0, len);\n+                out.write(trailer);\n+            } catch (IOException e) {\n+                if (usesDefaultDeflater)\n+                    def.end();\n+                throw e;\n             }\n-            // if we can't fit the trailer at the end of the last\n-            // deflater buffer, we write it separately\n-            byte[] trailer = new byte[TRAILER_SIZE];\n-            writeTrailer(trailer, 0);\n-            out.write(trailer);\n         }\n     }",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses an infinite loop in the `ZipOutputStream.close()` method, preventing a denial of service by ensuring proper termination. While it's a critical bug fix, it doesn't involve external input exploitation, thus not a security vulnerability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.9"
}