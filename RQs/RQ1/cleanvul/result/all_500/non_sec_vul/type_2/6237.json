{
  "id": 6237,
  "language": "C/C++",
  "commit_url": "https://github.com/vim/vim/commit/6f98371532fcff911b462d51bc64f2ce8a6ae682",
  "commit_sha": "6f98371532fcff911b462d51bc64f2ce8a6ae682",
  "commit_msg": "patch 8.2.3884: crash when clearing the argument list while using it\n\nProblem:    Crash when clearing the argument list while using it.\nSolution:   Lock the argument list for \":all\".",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/arglist.c",
  "func_name": "do_arg_all",
  "func_before": "static void\ndo_arg_all(\n    int\tcount,\n    int\tforceit,\t\t// hide buffers in current windows\n    int keep_tabs)\t\t// keep current tabs, for \":tab drop file\"\n{\n    int\t\ti;\n    win_T\t*wp, *wpnext;\n    char_u\t*opened;\t// Array of weight for which args are open:\n\t\t\t\t//  0: not opened\n\t\t\t\t//  1: opened in other tab\n\t\t\t\t//  2: opened in curtab\n\t\t\t\t//  3: opened in curtab and curwin\n\t\t\t\t//\n    int\t\topened_len;\t// length of opened[]\n    int\t\tuse_firstwin = FALSE;\t// use first window for arglist\n    int\t\ttab_drop_empty_window = FALSE;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    alist_T\t*alist;\t\t// argument list to be used\n    buf_T\t*buf;\n    tabpage_T\t*tpnext;\n    int\t\thad_tab = cmdmod.cmod_tab;\n    win_T\t*old_curwin, *last_curwin;\n    tabpage_T\t*old_curtab, *last_curtab;\n    win_T\t*new_curwin = NULL;\n    tabpage_T\t*new_curtab = NULL;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn;\n    }\n#endif\n    if (ARGCOUNT <= 0)\n    {\n\t// Don't give an error message.  We don't want it when the \":all\"\n\t// command is in the .vimrc.\n\treturn;\n    }\n    setpcmark();\n\n    opened_len = ARGCOUNT;\n    opened = alloc_clear(opened_len);\n    if (opened == NULL)\n\treturn;\n\n    // Autocommands may do anything to the argument list.  Make sure it's not\n    // freed while we are working here by \"locking\" it.  We still have to\n    // watch out for its size to be changed.\n    alist = curwin->w_alist;\n    ++alist->al_refcount;\n\n    old_curwin = curwin;\n    old_curtab = curtab;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    // Try closing all windows that are not in the argument list.\n    // Also close windows that are not full width;\n    // When 'hidden' or \"forceit\" set the buffer becomes hidden.\n    // Windows that have a changed buffer and can't be hidden won't be closed.\n    // When the \":tab\" modifier was used do this for all tab pages.\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    buf = wp->w_buffer;\n\t    if (buf->b_ffname == NULL\n\t\t    || (!keep_tabs && (buf->b_nwindows > 1\n\t\t\t    || wp->w_width != Columns)))\n\t\ti = opened_len;\n\t    else\n\t    {\n\t\t// check if the buffer in this window is in the arglist\n\t\tfor (i = 0; i < opened_len; ++i)\n\t\t{\n\t\t    if (i < alist->al_ga.ga_len\n\t\t\t    && (AARGLIST(alist)[i].ae_fnum == buf->b_fnum\n\t\t\t\t|| fullpathcmp(alist_name(&AARGLIST(alist)[i]),\n\t\t\t\t\tbuf->b_ffname, TRUE, TRUE) & FPC_SAME))\n\t\t    {\n\t\t\tint weight = 1;\n\n\t\t\tif (old_curtab == curtab)\n\t\t\t{\n\t\t\t    ++weight;\n\t\t\t    if (old_curwin == wp)\n\t\t\t\t++weight;\n\t\t\t}\n\n\t\t\tif (weight > (int)opened[i])\n\t\t\t{\n\t\t\t    opened[i] = (char_u)weight;\n\t\t\t    if (i == 0)\n\t\t\t    {\n\t\t\t\tif (new_curwin != NULL)\n\t\t\t\t    new_curwin->w_arg_idx = opened_len;\n\t\t\t\tnew_curwin = wp;\n\t\t\t\tnew_curtab = curtab;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (keep_tabs)\n\t\t\t    i = opened_len;\n\n\t\t\tif (wp->w_alist != alist)\n\t\t\t{\n\t\t\t    // Use the current argument list for all windows\n\t\t\t    // containing a file from it.\n\t\t\t    alist_unlink(wp->w_alist);\n\t\t\t    wp->w_alist = alist;\n\t\t\t    ++wp->w_alist->al_refcount;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    wp->w_arg_idx = i;\n\n\t    if (i == opened_len && !keep_tabs)// close this window\n\t    {\n\t\tif (buf_hide(buf) || forceit || buf->b_nwindows > 1\n\t\t\t\t\t\t\t|| !bufIsChanged(buf))\n\t\t{\n\t\t    // If the buffer was changed, and we would like to hide it,\n\t\t    // try autowriting.\n\t\t    if (!buf_hide(buf) && buf->b_nwindows <= 1\n\t\t\t\t\t\t\t && bufIsChanged(buf))\n\t\t    {\n\t\t\tbufref_T    bufref;\n\n\t\t\tset_bufref(&bufref, buf);\n\n\t\t\t(void)autowrite(buf, FALSE);\n\n\t\t\t// check if autocommands removed the window\n\t\t\tif (!win_valid(wp) || !bufref_valid(&bufref))\n\t\t\t{\n\t\t\t    wpnext = firstwin;\t// start all over...\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\t\t    // don't close last window\n\t\t    if (ONE_WINDOW\n\t\t\t    && (first_tabpage->tp_next == NULL || !had_tab))\n\t\t\tuse_firstwin = TRUE;\n\t\t    else\n\t\t    {\n\t\t\twin_close(wp, !buf_hide(buf) && !bufIsChanged(buf));\n\n\t\t\t// check if autocommands removed the next window\n\t\t\tif (!win_valid(wpnext))\n\t\t\t    wpnext = firstwin;\t// start all over...\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\n\t// check if autocommands removed the next tab page\n\tif (!valid_tabpage(tpnext))\n\t    tpnext = first_tabpage;\t// start all over...\n\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    // Open a window for files in the argument list that don't have one.\n    // ARGCOUNT may change while doing this, because of autocommands.\n    if (count > opened_len || count <= 0)\n\tcount = opened_len;\n\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    ++autocmd_no_leave;\n    last_curwin = curwin;\n    last_curtab = curtab;\n    win_enter(lastwin, FALSE);\n    // \":tab drop file\" should re-use an empty window to avoid \"--remote-tab\"\n    // leaving an empty tab page when executed locally.\n    if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1\n\t\t\t    && curbuf->b_ffname == NULL && !curbuf->b_changed)\n    {\n\tuse_firstwin = TRUE;\n\ttab_drop_empty_window = TRUE;\n    }\n\n    for (i = 0; i < count && !got_int; ++i)\n    {\n\tif (alist == &global_alist && i == global_alist.al_ga.ga_len - 1)\n\t    arg_had_last = TRUE;\n\tif (opened[i] > 0)\n\t{\n\t    // Move the already present window to below the current window\n\t    if (curwin->w_arg_idx != i)\n\t    {\n\t\tFOR_ALL_WINDOWS(wpnext)\n\t\t{\n\t\t    if (wpnext->w_arg_idx == i)\n\t\t    {\n\t\t\tif (keep_tabs)\n\t\t\t{\n\t\t\t    new_curwin = wpnext;\n\t\t\t    new_curtab = curtab;\n\t\t\t}\n\t\t\telse if (wpnext->w_frame->fr_parent\n\t\t\t\t\t\t != curwin->w_frame->fr_parent)\n\t\t\t{\n\t\t\t    emsg(_(\"E249: window layout changed unexpectedly\"));\n\t\t\t    i = count;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse\n\t\t\t    win_move_after(wpnext, curwin);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (split_ret == OK)\n\t{\n\t    // trigger events for tab drop\n\t    if (tab_drop_empty_window && i == count - 1)\n\t\t--autocmd_no_enter;\n\t    if (!use_firstwin)\t\t// split current window\n\t    {\n\t\tp_ea_save = p_ea;\n\t\tp_ea = TRUE;\t\t// use space from all windows\n\t\tsplit_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t\tp_ea = p_ea_save;\n\t\tif (split_ret == FAIL)\n\t\t    continue;\n\t    }\n\t    else    // first window: do autocmd for leaving this buffer\n\t\t--autocmd_no_leave;\n\n\t    // edit file \"i\"\n\t    curwin->w_arg_idx = i;\n\t    if (i == 0)\n\t    {\n\t\tnew_curwin = curwin;\n\t\tnew_curtab = curtab;\n\t    }\n\t    (void)do_ecmd(0, alist_name(&AARGLIST(alist)[i]), NULL, NULL,\n\t\t      ECMD_ONE,\n\t\t      ((buf_hide(curwin->w_buffer)\n\t\t\t   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)\n\t\t\t\t\t\t       + ECMD_OLDBUF, curwin);\n\t    if (tab_drop_empty_window && i == count - 1)\n\t\t++autocmd_no_enter;\n\t    if (use_firstwin)\n\t\t++autocmd_no_leave;\n\t    use_firstwin = FALSE;\n\t}\n\tui_breakcheck();\n\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n\n    // Remove the \"lock\" on the argument list.\n    alist_unlink(alist);\n\n    --autocmd_no_enter;\n\n    // restore last referenced tabpage's curwin\n    if (last_curtab != new_curtab)\n    {\n\tif (valid_tabpage(last_curtab))\n\t    goto_tabpage_tp(last_curtab, TRUE, TRUE);\n\tif (win_valid(last_curwin))\n\t    win_enter(last_curwin, FALSE);\n    }\n    // to window with first arg\n    if (valid_tabpage(new_curtab))\n\tgoto_tabpage_tp(new_curtab, TRUE, TRUE);\n    if (win_valid(new_curwin))\n\twin_enter(new_curwin, FALSE);\n\n    --autocmd_no_leave;\n    vim_free(opened);\n}",
  "func_after": "static void\ndo_arg_all(\n    int\tcount,\n    int\tforceit,\t\t// hide buffers in current windows\n    int keep_tabs)\t\t// keep current tabs, for \":tab drop file\"\n{\n    int\t\ti;\n    win_T\t*wp, *wpnext;\n    char_u\t*opened;\t// Array of weight for which args are open:\n\t\t\t\t//  0: not opened\n\t\t\t\t//  1: opened in other tab\n\t\t\t\t//  2: opened in curtab\n\t\t\t\t//  3: opened in curtab and curwin\n\t\t\t\t//\n    int\t\topened_len;\t// length of opened[]\n    int\t\tuse_firstwin = FALSE;\t// use first window for arglist\n    int\t\ttab_drop_empty_window = FALSE;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    alist_T\t*alist;\t\t// argument list to be used\n    buf_T\t*buf;\n    tabpage_T\t*tpnext;\n    int\t\thad_tab = cmdmod.cmod_tab;\n    win_T\t*old_curwin, *last_curwin;\n    tabpage_T\t*old_curtab, *last_curtab;\n    win_T\t*new_curwin = NULL;\n    tabpage_T\t*new_curtab = NULL;\n    int\t\tprev_arglist_locked = arglist_locked;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn;\n    }\n#endif\n    if (ARGCOUNT <= 0)\n    {\n\t// Don't give an error message.  We don't want it when the \":all\"\n\t// command is in the .vimrc.\n\treturn;\n    }\n    setpcmark();\n\n    opened_len = ARGCOUNT;\n    opened = alloc_clear(opened_len);\n    if (opened == NULL)\n\treturn;\n\n    // Autocommands may do anything to the argument list.  Make sure it's not\n    // freed while we are working here by \"locking\" it.  We still have to\n    // watch out for its size to be changed.\n    alist = curwin->w_alist;\n    ++alist->al_refcount;\n    arglist_locked = TRUE;\n\n    old_curwin = curwin;\n    old_curtab = curtab;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    // Try closing all windows that are not in the argument list.\n    // Also close windows that are not full width;\n    // When 'hidden' or \"forceit\" set the buffer becomes hidden.\n    // Windows that have a changed buffer and can't be hidden won't be closed.\n    // When the \":tab\" modifier was used do this for all tab pages.\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    buf = wp->w_buffer;\n\t    if (buf->b_ffname == NULL\n\t\t    || (!keep_tabs && (buf->b_nwindows > 1\n\t\t\t    || wp->w_width != Columns)))\n\t\ti = opened_len;\n\t    else\n\t    {\n\t\t// check if the buffer in this window is in the arglist\n\t\tfor (i = 0; i < opened_len; ++i)\n\t\t{\n\t\t    if (i < alist->al_ga.ga_len\n\t\t\t    && (AARGLIST(alist)[i].ae_fnum == buf->b_fnum\n\t\t\t\t|| fullpathcmp(alist_name(&AARGLIST(alist)[i]),\n\t\t\t\t\tbuf->b_ffname, TRUE, TRUE) & FPC_SAME))\n\t\t    {\n\t\t\tint weight = 1;\n\n\t\t\tif (old_curtab == curtab)\n\t\t\t{\n\t\t\t    ++weight;\n\t\t\t    if (old_curwin == wp)\n\t\t\t\t++weight;\n\t\t\t}\n\n\t\t\tif (weight > (int)opened[i])\n\t\t\t{\n\t\t\t    opened[i] = (char_u)weight;\n\t\t\t    if (i == 0)\n\t\t\t    {\n\t\t\t\tif (new_curwin != NULL)\n\t\t\t\t    new_curwin->w_arg_idx = opened_len;\n\t\t\t\tnew_curwin = wp;\n\t\t\t\tnew_curtab = curtab;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (keep_tabs)\n\t\t\t    i = opened_len;\n\n\t\t\tif (wp->w_alist != alist)\n\t\t\t{\n\t\t\t    // Use the current argument list for all windows\n\t\t\t    // containing a file from it.\n\t\t\t    alist_unlink(wp->w_alist);\n\t\t\t    wp->w_alist = alist;\n\t\t\t    ++wp->w_alist->al_refcount;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    wp->w_arg_idx = i;\n\n\t    if (i == opened_len && !keep_tabs)// close this window\n\t    {\n\t\tif (buf_hide(buf) || forceit || buf->b_nwindows > 1\n\t\t\t\t\t\t\t|| !bufIsChanged(buf))\n\t\t{\n\t\t    // If the buffer was changed, and we would like to hide it,\n\t\t    // try autowriting.\n\t\t    if (!buf_hide(buf) && buf->b_nwindows <= 1\n\t\t\t\t\t\t\t && bufIsChanged(buf))\n\t\t    {\n\t\t\tbufref_T    bufref;\n\n\t\t\tset_bufref(&bufref, buf);\n\n\t\t\t(void)autowrite(buf, FALSE);\n\n\t\t\t// check if autocommands removed the window\n\t\t\tif (!win_valid(wp) || !bufref_valid(&bufref))\n\t\t\t{\n\t\t\t    wpnext = firstwin;\t// start all over...\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\t\t    // don't close last window\n\t\t    if (ONE_WINDOW\n\t\t\t    && (first_tabpage->tp_next == NULL || !had_tab))\n\t\t\tuse_firstwin = TRUE;\n\t\t    else\n\t\t    {\n\t\t\twin_close(wp, !buf_hide(buf) && !bufIsChanged(buf));\n\n\t\t\t// check if autocommands removed the next window\n\t\t\tif (!win_valid(wpnext))\n\t\t\t    wpnext = firstwin;\t// start all over...\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\n\t// check if autocommands removed the next tab page\n\tif (!valid_tabpage(tpnext))\n\t    tpnext = first_tabpage;\t// start all over...\n\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    // Open a window for files in the argument list that don't have one.\n    // ARGCOUNT may change while doing this, because of autocommands.\n    if (count > opened_len || count <= 0)\n\tcount = opened_len;\n\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    ++autocmd_no_leave;\n    last_curwin = curwin;\n    last_curtab = curtab;\n    win_enter(lastwin, FALSE);\n    // \":tab drop file\" should re-use an empty window to avoid \"--remote-tab\"\n    // leaving an empty tab page when executed locally.\n    if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1\n\t\t\t    && curbuf->b_ffname == NULL && !curbuf->b_changed)\n    {\n\tuse_firstwin = TRUE;\n\ttab_drop_empty_window = TRUE;\n    }\n\n    for (i = 0; i < count && !got_int; ++i)\n    {\n\tif (alist == &global_alist && i == global_alist.al_ga.ga_len - 1)\n\t    arg_had_last = TRUE;\n\tif (opened[i] > 0)\n\t{\n\t    // Move the already present window to below the current window\n\t    if (curwin->w_arg_idx != i)\n\t    {\n\t\tFOR_ALL_WINDOWS(wpnext)\n\t\t{\n\t\t    if (wpnext->w_arg_idx == i)\n\t\t    {\n\t\t\tif (keep_tabs)\n\t\t\t{\n\t\t\t    new_curwin = wpnext;\n\t\t\t    new_curtab = curtab;\n\t\t\t}\n\t\t\telse if (wpnext->w_frame->fr_parent\n\t\t\t\t\t\t != curwin->w_frame->fr_parent)\n\t\t\t{\n\t\t\t    emsg(_(\"E249: window layout changed unexpectedly\"));\n\t\t\t    i = count;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse\n\t\t\t    win_move_after(wpnext, curwin);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse if (split_ret == OK)\n\t{\n\t    // trigger events for tab drop\n\t    if (tab_drop_empty_window && i == count - 1)\n\t\t--autocmd_no_enter;\n\t    if (!use_firstwin)\t\t// split current window\n\t    {\n\t\tp_ea_save = p_ea;\n\t\tp_ea = TRUE;\t\t// use space from all windows\n\t\tsplit_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t\tp_ea = p_ea_save;\n\t\tif (split_ret == FAIL)\n\t\t    continue;\n\t    }\n\t    else    // first window: do autocmd for leaving this buffer\n\t\t--autocmd_no_leave;\n\n\t    // edit file \"i\"\n\t    curwin->w_arg_idx = i;\n\t    if (i == 0)\n\t    {\n\t\tnew_curwin = curwin;\n\t\tnew_curtab = curtab;\n\t    }\n\t    (void)do_ecmd(0, alist_name(&AARGLIST(alist)[i]), NULL, NULL,\n\t\t      ECMD_ONE,\n\t\t      ((buf_hide(curwin->w_buffer)\n\t\t\t   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)\n\t\t\t\t\t\t       + ECMD_OLDBUF, curwin);\n\t    if (tab_drop_empty_window && i == count - 1)\n\t\t++autocmd_no_enter;\n\t    if (use_firstwin)\n\t\t++autocmd_no_leave;\n\t    use_firstwin = FALSE;\n\t}\n\tui_breakcheck();\n\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n\n    // Remove the \"lock\" on the argument list.\n    alist_unlink(alist);\n    arglist_locked = prev_arglist_locked;\n\n    --autocmd_no_enter;\n\n    // restore last referenced tabpage's curwin\n    if (last_curtab != new_curtab)\n    {\n\tif (valid_tabpage(last_curtab))\n\t    goto_tabpage_tp(last_curtab, TRUE, TRUE);\n\tif (win_valid(last_curwin))\n\t    win_enter(last_curwin, FALSE);\n    }\n    // to window with first arg\n    if (valid_tabpage(new_curtab))\n\tgoto_tabpage_tp(new_curtab, TRUE, TRUE);\n    if (win_valid(new_curwin))\n\twin_enter(new_curwin, FALSE);\n\n    --autocmd_no_leave;\n    vim_free(opened);\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void\n do_arg_all(\n     int\tcount,\n     int\tforceit,\t\t// hide buffers in current windows\n     int keep_tabs)\t\t// keep current tabs, for \":tab drop file\"\n {\n     int\t\ti;\n     win_T\t*wp, *wpnext;\n     char_u\t*opened;\t// Array of weight for which args are open:\n \t\t\t\t//  0: not opened\n \t\t\t\t//  1: opened in other tab\n \t\t\t\t//  2: opened in curtab\n \t\t\t\t//  3: opened in curtab and curwin\n \t\t\t\t//\n     int\t\topened_len;\t// length of opened[]\n     int\t\tuse_firstwin = FALSE;\t// use first window for arglist\n     int\t\ttab_drop_empty_window = FALSE;\n     int\t\tsplit_ret = OK;\n     int\t\tp_ea_save;\n     alist_T\t*alist;\t\t// argument list to be used\n     buf_T\t*buf;\n     tabpage_T\t*tpnext;\n     int\t\thad_tab = cmdmod.cmod_tab;\n     win_T\t*old_curwin, *last_curwin;\n     tabpage_T\t*old_curtab, *last_curtab;\n     win_T\t*new_curwin = NULL;\n     tabpage_T\t*new_curtab = NULL;\n+    int\t\tprev_arglist_locked = arglist_locked;\n \n #ifdef FEAT_CMDWIN\n     if (cmdwin_type != 0)\n     {\n \temsg(_(e_invalid_in_cmdline_window));\n \treturn;\n     }\n #endif\n     if (ARGCOUNT <= 0)\n     {\n \t// Don't give an error message.  We don't want it when the \":all\"\n \t// command is in the .vimrc.\n \treturn;\n     }\n     setpcmark();\n \n     opened_len = ARGCOUNT;\n     opened = alloc_clear(opened_len);\n     if (opened == NULL)\n \treturn;\n \n     // Autocommands may do anything to the argument list.  Make sure it's not\n     // freed while we are working here by \"locking\" it.  We still have to\n     // watch out for its size to be changed.\n     alist = curwin->w_alist;\n     ++alist->al_refcount;\n+    arglist_locked = TRUE;\n \n     old_curwin = curwin;\n     old_curtab = curtab;\n \n # ifdef FEAT_GUI\n     need_mouse_correct = TRUE;\n # endif\n \n     // Try closing all windows that are not in the argument list.\n     // Also close windows that are not full width;\n     // When 'hidden' or \"forceit\" set the buffer becomes hidden.\n     // Windows that have a changed buffer and can't be hidden won't be cl",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses a crash by locking the argument list, which is a functional bug fix without security implications.\n\n**Final Output:**\nAnalysis: The patch fixes a crash by locking the argument list, indicating a stability issue rather than a security vulnerability. The code change prevents a crash during argument list operations without addressing unauthorized access or data compromise.\n\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.9"
}