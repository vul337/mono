{
  "id": 3718,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/fb5be6a7b4863ecc44963bb80ca614584b6c7817",
  "commit_sha": "fb5be6a7b4863ecc44963bb80ca614584b6c7817",
  "commit_msg": "can: gs_usb: gs_can_open(): prevent memory leak\n\nIn gs_can_open() if usb_submit_urb() fails the allocated urb should be\nreleased.\n\nFixes: d08e973a77d1 (\"can: gs_usb: Added support for the GS_USB CAN devices\")\nCc: linux-stable <stable@vger.kernel.org>\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "drivers/net/can/usb/gs_usb.c",
  "func_name": "gs_can_open",
  "func_before": "static int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}",
  "func_after": "static int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int gs_can_open(struct net_device *netdev)\n {\n \tstruct gs_can *dev = netdev_priv(netdev);\n \tstruct gs_usb *parent = dev->parent;\n \tint rc, i;\n \tstruct gs_device_mode *dm;\n \tu32 ctrlmode;\n \n \trc = open_candev(netdev);\n \tif (rc)\n \t\treturn rc;\n \n \tif (atomic_add_return(1, &parent->active_channels) == 1) {\n \t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n \t\t\tstruct urb *urb;\n \t\t\tu8 *buf;\n \n \t\t\t/* alloc rx urb */\n \t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n \t\t\tif (!urb)\n \t\t\t\treturn -ENOMEM;\n \n \t\t\t/* alloc rx buffer */\n \t\t\tbuf = usb_alloc_coherent(dev->udev,\n \t\t\t\t\t\t sizeof(struct gs_host_frame),\n \t\t\t\t\t\t GFP_KERNEL,\n \t\t\t\t\t\t &urb->transfer_dma);\n \t\t\tif (!buf) {\n \t\t\t\tnetdev_err(netdev,\n \t\t\t\t\t   \"No memory left for USB buffer\\n\");\n \t\t\t\tusb_free_urb(urb);\n \t\t\t\treturn -ENOMEM;\n \t\t\t}\n \n \t\t\t/* fill, anchor, and submit rx urb */\n \t\t\tusb_fill_bulk_urb(urb,\n \t\t\t\t\t  dev->udev,\n \t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n \t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n \t\t\t\t\t  buf,\n \t\t\t\t\t  sizeof(struct gs_host_frame),\n \t\t\t\t\t  gs_usb_receive_bulk_callback,\n \t\t\t\t\t  parent);\n \t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n \n \t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n \n \t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n \t\t\tif (rc) {\n \t\t\t\tif (rc == -ENODEV)\n \t\t\t\t\tnetif_device_detach(dev->netdev);\n \n \t\t\t\tnetdev_err(netdev,\n \t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n \t\t\t\t\t   rc);\n \n \t\t\t\tusb_unanchor_urb(urb);\n+\t\t\t\tusb_free_urb(urb);\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\t/* Drop reference,\n \t\t\t * USB core will take care of freeing it\n \t\t\t */\n \t\t\tusb_free_urb(urb);\n \t\t}\n \t}\n \n \tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n \tif (!dm)\n \t\treturn -ENOMEM;\n \n \t/* flags */\n \tctrlmode = dev->can.ctrlmode;\n \tdm->flags = 0;\n \n \tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n \t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n \telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n \t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n \n \t/* Controller is not allowed to retry TX\n \t * this mode is unavailable on atmels uc3c hardware\n \t */\n \tif (ctrlmode & CAN_CTRLMODE_",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.85"
}