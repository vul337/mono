{
  "id": 5413,
  "language": "C/C++",
  "commit_url": "https://github.com/nu774/fdkaac/commit/4ec1422bd951a137225ffa4052da120e2ab0a0f4",
  "commit_sha": "4ec1422bd951a137225ffa4052da120e2ab0a0f4",
  "commit_msg": "wav/caf parser: ensure fmt/desc chunk\n\nfixes https://github.com/nu774/fdkaac/issues/52",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/wav_reader.c",
  "func_name": "wav_parse",
  "func_before": "static\nint wav_parse(wav_reader_t *reader, int64_t *data_length)\n{\n    uint32_t container, fcc, chunk_size;\n\n    *data_length = 0;\n    container = riff_next_chunk(reader, &chunk_size);\n    ENSURE(container == RIFF_FOURCC('R','I','F','F') ||\n           container == RIFF_FOURCC('R','F','6','4'));\n    TRY_IO(pcm_read32le(&reader->io, &fcc));\n    ENSURE(fcc == RIFF_FOURCC('W','A','V','E'));\n\n    if (container == RIFF_FOURCC('R','F','6','4'))\n        riff_ds64(reader, data_length);\n    while ((fcc = riff_next_chunk(reader, &chunk_size)) != 0) {\n        if (fcc == RIFF_FOURCC('f','m','t',' ')) {\n            if (wav_fmt(reader, chunk_size) < 0)\n                goto FAIL;\n        } else if (fcc == RIFF_FOURCC('d','a','t','a')) {\n            if (container == RIFF_FOURCC('R','I','F','F'))\n                *data_length = chunk_size;\n            reader->data_offset = pcm_tell(&reader->io);\n            break;\n        } else {\n            TRY_IO(pcm_skip(&reader->io, (chunk_size + 1) & ~1));\n        }\n    }\n    if (fcc == RIFF_FOURCC('d','a','t','a'))\n        return 0;\nFAIL:\n    return -1;\n}",
  "func_after": "static\nint wav_parse(wav_reader_t *reader, int64_t *data_length)\n{\n    uint32_t container, fcc, chunk_size;\n    int fmt_seen = 0;\n\n    *data_length = 0;\n    container = riff_next_chunk(reader, &chunk_size);\n    ENSURE(container == RIFF_FOURCC('R','I','F','F') ||\n           container == RIFF_FOURCC('R','F','6','4'));\n    TRY_IO(pcm_read32le(&reader->io, &fcc));\n    ENSURE(fcc == RIFF_FOURCC('W','A','V','E'));\n\n    if (container == RIFF_FOURCC('R','F','6','4'))\n        riff_ds64(reader, data_length);\n    while ((fcc = riff_next_chunk(reader, &chunk_size)) != 0) {\n        if (fcc == RIFF_FOURCC('f','m','t',' ')) {\n            fmt_seen = 1;\n            if (wav_fmt(reader, chunk_size) < 0)\n                goto FAIL;\n        } else if (fcc == RIFF_FOURCC('d','a','t','a')) {\n            if (container == RIFF_FOURCC('R','I','F','F'))\n                *data_length = chunk_size;\n            reader->data_offset = pcm_tell(&reader->io);\n            break;\n        } else {\n            TRY_IO(pcm_skip(&reader->io, (chunk_size + 1) & ~1));\n        }\n    }\n    ENSURE(fmt_seen && fcc == RIFF_FOURCC('d', 'a', 't', 'a'));\n    return 0;\nFAIL:\n    return -1;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static\n int wav_parse(wav_reader_t *reader, int64_t *data_length)\n {\n     uint32_t container, fcc, chunk_size;\n+    int fmt_seen = 0;\n \n     *data_length = 0;\n     container = riff_next_chunk(reader, &chunk_size);\n     ENSURE(container == RIFF_FOURCC('R','I','F','F') ||\n            container == RIFF_FOURCC('R','F','6','4'));\n     TRY_IO(pcm_read32le(&reader->io, &fcc));\n     ENSURE(fcc == RIFF_FOURCC('W','A','V','E'));\n \n     if (container == RIFF_FOURCC('R','F','6','4'))\n         riff_ds64(reader, data_length);\n     while ((fcc = riff_next_chunk(reader, &chunk_size)) != 0) {\n         if (fcc == RIFF_FOURCC('f','m','t',' ')) {\n+            fmt_seen = 1;\n             if (wav_fmt(reader, chunk_size) < 0)\n                 goto FAIL;\n         } else if (fcc == RIFF_FOURCC('d','a','t','a')) {\n             if (container == RIFF_FOURCC('R','I','F','F'))\n                 *data_length = chunk_size;\n             reader->data_offset = pcm_tell(&reader->io);\n             break;\n         } else {\n             TRY_IO(pcm_skip(&reader->io, (chunk_size + 1) & ~1));\n         }\n     }\n-    if (fcc == RIFF_FOURCC('d','a','t','a'))\n+    ENSURE(fmt_seen && fcc == RIFF_FOURCC('d', 'a', 't', 'a'));\n-        return 0;\n+    return 0;\n FAIL:\n     return -1;\n }",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch modifies the WAV parser to ensure the presence of the 'fmt' chunk before processing the 'data' chunk, preventing incorrect parsing. While this could theoretically have security implications, the evidence isn't conclusive. \n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.8"
}