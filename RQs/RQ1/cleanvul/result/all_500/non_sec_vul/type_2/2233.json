{
  "id": 2233,
  "language": "Java",
  "commit_url": "https://github.com/logpresso/CVE-2021-44228-Scanner/commit/1a49d2401a5632f48ed0eeb0b749a6de387bae7e",
  "commit_sha": "1a49d2401a5632f48ed0eeb0b749a6de387bae7e",
  "commit_msg": "Resolves logpresso/CVE-2021-44228-Scanner#151 log4j2-2.17.0 should not be marked as potential vulnerable\n\n\"Copyright © 2021 Atruvia AG <opensource@atruvia.de>\"",
  "pr_url": "https://github.com/logpresso/CVE-2021-44228-Scanner/pull/152",
  "pr_info": "log4j2-2.17.0 should not be marked as potential vulnerable\r\n\r\n\"Copyright © 2021 Atruvia AG <opensource@atruvia.de>\"",
  "file_name": "src/main/java/com/logpresso/scanner/Detector.java",
  "func_name": "IOException",
  "func_before": "private DetectResult scanStream(File jarFile, InputStream is, List<String> pathChain) throws IOException {\n\t\tZipInputStream zis = null;\n\t\tDetectResult result = new DetectResult();\n\t\tString log4j2Version = null;\n\t\tString log4j1Version = null;\n\t\tString logbackVersion = null;\n\n\t\tboolean log4j2Mitigated = true;\n\n\t\t// log4j1 class\n\t\tboolean foundJmsAppender = false;\n\n\t\t// logback class\n\t\tboolean foundJndiUtil = false;\n\n\t\t// shade class\n\t\tSet<String> shadedJndiLookupPaths = new TreeSet<String>();\n\t\tSet<String> shadedJmsAppenderPaths = new TreeSet<String>();\n\n\t\ttry {\n\t\t\tzis = new ZipInputStream(new DummyInputStream(is));\n\n\t\t\twhile (true) {\n\t\t\t\tZipEntry entry = zis.getNextEntry();\n\t\t\t\tif (entry == null)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (entry.getName().equals(LOG4J_CORE_POM_PROPS))\n\t\t\t\t\tlog4j2Version = loadVulnerableLog4jVersion(zis);\n\n\t\t\t\tif (entry.getName().equals(JNDI_LOOKUP_CLASS_PATH))\n\t\t\t\t\tlog4j2Mitigated = false;\n\n\t\t\t\tif (entry.getName().endsWith(JNDI_LOOKUP_CLASS_SHADE_PATH))\n\t\t\t\t\tshadedJndiLookupPaths.add(entry.getName());\n\n\t\t\t\tif (config.isScanForLog4j1()) {\n\t\t\t\t\tif (entry.getName().equals(LOG4J_12_CORE_POM_PROPS))\n\t\t\t\t\t\tlog4j1Version = loadVulnerableLog4j1(zis);\n\n\t\t\t\t\tif (entry.getName().equals(LOG4J_12_JMSAPPENDER))\n\t\t\t\t\t\tfoundJmsAppender = true;\n\n\t\t\t\t\tif (entry.getName().endsWith(LOG4J_12_JMSAPPENDER_SHADE_PATH))\n\t\t\t\t\t\tshadedJmsAppenderPaths.add(entry.getName());\n\t\t\t\t}\n\n\t\t\t\tif (config.isScanForLogback()) {\n\t\t\t\t\tif (entry.getName().equals(LOGBACK_CLASSIC_POM_PROPS))\n\t\t\t\t\t\tlogbackVersion = loadVulnerableLogback(zis);\n\n\t\t\t\t\tif (entry.getName().equals(LOGBACK_JNDI_CLASS_PATH))\n\t\t\t\t\t\tfoundJndiUtil = true;\n\t\t\t\t}\n\n\t\t\t\tif (ZipUtils.isScanTarget(entry.getName(), config.isScanZip())) {\n\t\t\t\t\tpathChain.add(entry.getName());\n\n\t\t\t\t\tDetectResult nestedResult = scanStream(jarFile, zis, pathChain);\n\t\t\t\t\tresult.merge(nestedResult);\n\n\t\t\t\t\tpathChain.remove(pathChain.size() - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog4j2Mitigated &= shadedJndiLookupPaths.isEmpty();\n\t\t\tif (log4j2Version != null) {\n\t\t\t\tprintDetectionForLog4j2(jarFile, pathChain, log4j2Version, log4j2Mitigated, false);\n\t\t\t\tif (log4j2Mitigated)\n\t\t\t\t\tresult.setMitigated();\n\t\t\t\telse\n\t\t\t\t\tresult.setVulnerable();\n\t\t\t} else if (!log4j2Mitigated) {\n\t\t\t\tprintDetectionForLog4j2(jarFile, pathChain, POTENTIALLY_VULNERABLE, false, true);\n\t\t\t\tresult.setPotentiallyVulnerableLog4j2();\n\t\t\t}\n\n\t\t\tif (log4j1Version != null) {\n\t\t\t\tprintDetectionForLog4j1(jarFile, pathChain, log4j1Version, !foundJmsAppender);\n\t\t\t\tif (foundJmsAppender)\n\t\t\t\t\tresult.setPotentiallyVulnerableLog4j1();\n\t\t\t\telse\n\t\t\t\t\tresult.setMitigated();\n\t\t\t} else if (foundJmsAppender) {\n\t\t\t\tprintDetectionForLog4j1(jarFile, pathChain, POTENTIALLY_VULNERABLE, false);\n\t\t\t}\n\n\t\t\tif (logbackVersion != null) {\n\t\t\t\tprintDetectionForLogback(jarFile, pathChain, logbackVersion, !foundJndiUtil);\n\t\t\t\tif (foundJndiUtil)\n\t\t\t\t\tresult.setPotentiallyVulnerableLogback();\n\t\t\t\telse\n\t\t\t\t\tresult.setMitigated();\n\t\t\t} else if (foundJndiUtil) {\n\t\t\t\tprintDetectionForLogback(jarFile, pathChain, POTENTIALLY_VULNERABLE, false);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (IOException e) {\n\t\t\t// ignore WinRAR\n\t\t\tString entryName = pathChain.get(pathChain.size() - 1);\n\t\t\tif (entryName.toLowerCase().endsWith(\".rar\"))\n\t\t\t\treturn result;\n\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tIoUtils.ensureClose(zis);\n\t\t}\n\t}",
  "func_after": "private DetectResult scanStream(File jarFile, InputStream is, List<String> pathChain) throws IOException {\n\t\tZipInputStream zis = null;\n\t\tDetectResult result = new DetectResult();\n\t\tString log4j2Version = null;\n\t\tString log4j1Version = null;\n\t\tString logbackVersion = null;\n\n\t\tboolean log4j2Mitigated = true;\n\n\t\t// log4j1 class\n\t\tboolean foundJmsAppender = false;\n\n\t\t// logback class\n\t\tboolean foundJndiUtil = false;\n\n\t\t// shade class\n\t\tSet<String> shadedJndiLookupPaths = new TreeSet<String>();\n\t\tSet<String> shadedJmsAppenderPaths = new TreeSet<String>();\n\n\t\ttry {\n\t\t\tzis = new ZipInputStream(new DummyInputStream(is));\n\n\t\t\twhile (true) {\n\t\t\t\tZipEntry entry = zis.getNextEntry();\n\t\t\t\tif (entry == null)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (entry.getName().equals(LOG4J_CORE_POM_PROPS))\n\t\t\t\t\tlog4j2Version = loadVulnerableLog4jVersion(zis);\n\n\t\t\t\tif (entry.getName().equals(JNDI_LOOKUP_CLASS_PATH))\n\t\t\t\t\tlog4j2Mitigated = false;\n\n\t\t\t\tif (entry.getName().endsWith(JNDI_LOOKUP_CLASS_SHADE_PATH))\n\t\t\t\t\tshadedJndiLookupPaths.add(entry.getName());\n\n\t\t\t\tif (config.isScanForLog4j1()) {\n\t\t\t\t\tif (entry.getName().equals(LOG4J_12_CORE_POM_PROPS))\n\t\t\t\t\t\tlog4j1Version = loadVulnerableLog4j1(zis);\n\n\t\t\t\t\tif (entry.getName().equals(LOG4J_12_JMSAPPENDER))\n\t\t\t\t\t\tfoundJmsAppender = true;\n\n\t\t\t\t\tif (entry.getName().endsWith(LOG4J_12_JMSAPPENDER_SHADE_PATH))\n\t\t\t\t\t\tshadedJmsAppenderPaths.add(entry.getName());\n\t\t\t\t}\n\n\t\t\t\tif (config.isScanForLogback()) {\n\t\t\t\t\tif (entry.getName().equals(LOGBACK_CLASSIC_POM_PROPS))\n\t\t\t\t\t\tlogbackVersion = loadVulnerableLogback(zis);\n\n\t\t\t\t\tif (entry.getName().equals(LOGBACK_JNDI_CLASS_PATH))\n\t\t\t\t\t\tfoundJndiUtil = true;\n\t\t\t\t}\n\n\t\t\t\tif (ZipUtils.isScanTarget(entry.getName(), config.isScanZip())) {\n\t\t\t\t\tpathChain.add(entry.getName());\n\n\t\t\t\t\tDetectResult nestedResult = scanStream(jarFile, zis, pathChain);\n\t\t\t\t\tresult.merge(nestedResult);\n\n\t\t\t\t\tpathChain.remove(pathChain.size() - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog4j2Mitigated &= shadedJndiLookupPaths.isEmpty();\n\t\t\tif(log4j2Version != null) {\n\t\t\t\tif(isVulnerableLog4j2(Version.parse(log4j2Version))) {\n\t\t\t\t\tprintDetectionForLog4j2(jarFile, pathChain, log4j2Version, log4j2Mitigated, false);\n\t\t\t\t\tif (log4j2Mitigated)\n\t\t\t\t\t\tresult.setMitigated();\n\t\t\t\t\telse\n\t\t\t\t\t\tresult.setVulnerable();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!log4j2Mitigated) {\n\t\t\t\tprintDetectionForLog4j2(jarFile, pathChain, POTENTIALLY_VULNERABLE, false, true);\n\t\t\t\tresult.setPotentiallyVulnerableLog4j2();\n\t\t\t}\n\n\t\t\tif (log4j1Version != null) {\n\t\t\t\tprintDetectionForLog4j1(jarFile, pathChain, log4j1Version, !foundJmsAppender);\n\t\t\t\tif (foundJmsAppender)\n\t\t\t\t\tresult.setPotentiallyVulnerableLog4j1();\n\t\t\t\telse\n\t\t\t\t\tresult.setMitigated();\n\t\t\t} else if (foundJmsAppender) {\n\t\t\t\tprintDetectionForLog4j1(jarFile, pathChain, POTENTIALLY_VULNERABLE, false);\n\t\t\t}\n\n\t\t\tif (logbackVersion != null) {\n\t\t\t\tprintDetectionForLogback(jarFile, pathChain, logbackVersion, !foundJndiUtil);\n\t\t\t\tif (foundJndiUtil)\n\t\t\t\t\tresult.setPotentiallyVulnerableLogback();\n\t\t\t\telse\n\t\t\t\t\tresult.setMitigated();\n\t\t\t} else if (foundJndiUtil) {\n\t\t\t\tprintDetectionForLogback(jarFile, pathChain, POTENTIALLY_VULNERABLE, false);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (IOException e) {\n\t\t\t// ignore WinRAR\n\t\t\tString entryName = pathChain.get(pathChain.size() - 1);\n\t\t\tif (entryName.toLowerCase().endsWith(\".rar\"))\n\t\t\t\treturn result;\n\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tIoUtils.ensureClose(zis);\n\t\t}\n\t}",
  "diff_func": "--- func_before\n+++ func_after\n private DetectResult scanStream(File jarFile, InputStream is, List<String> pathChain) throws IOException {\n \t\tZipInputStream zis = null;\n \t\tDetectResult result = new DetectResult();\n \t\tString log4j2Version = null;\n \t\tString log4j1Version = null;\n \t\tString logbackVersion = null;\n \n \t\tboolean log4j2Mitigated = true;\n \n \t\t// log4j1 class\n \t\tboolean foundJmsAppender = false;\n \n \t\t// logback class\n \t\tboolean foundJndiUtil = false;\n \n \t\t// shade class\n \t\tSet<String> shadedJndiLookupPaths = new TreeSet<String>();\n \t\tSet<String> shadedJmsAppenderPaths = new TreeSet<String>();\n \n \t\ttry {\n \t\t\tzis = new ZipInputStream(new DummyInputStream(is));\n \n \t\t\twhile (true) {\n \t\t\t\tZipEntry entry = zis.getNextEntry();\n \t\t\t\tif (entry == null)\n \t\t\t\t\tbreak;\n \n \t\t\t\tif (entry.getName().equals(LOG4J_CORE_POM_PROPS))\n \t\t\t\t\tlog4j2Version = loadVulnerableLog4jVersion(zis);\n \n \t\t\t\tif (entry.getName().equals(JNDI_LOOKUP_CLASS_PATH))\n \t\t\t\t\tlog4j2Mitigated = false;\n \n \t\t\t\tif (entry.getName().endsWith(JNDI_LOOKUP_CLASS_SHADE_PATH))\n \t\t\t\t\tshadedJndiLookupPaths.add(entry.getName());\n \n \t\t\t\tif (config.isScanForLog4j1()) {\n \t\t\t\t\tif (entry.getName().equals(LOG4J_12_CORE_POM_PROPS))\n \t\t\t\t\t\tlog4j1Version = loadVulnerableLog4j1(zis);\n \n \t\t\t\t\tif (entry.getName().equals(LOG4J_12_JMSAPPENDER))\n \t\t\t\t\t\tfoundJmsAppender = true;\n \n \t\t\t\t\tif (entry.getName().endsWith(LOG4J_12_JMSAPPENDER_SHADE_PATH))\n \t\t\t\t\t\tshadedJmsAppenderPaths.add(entry.getName());\n \t\t\t\t}\n \n \t\t\t\tif (config.isScanForLogback()) {\n \t\t\t\t\tif (entry.getName().equals(LOGBACK_CLASSIC_POM_PROPS))\n \t\t\t\t\t\tlogbackVersion = loadVulnerableLogback(zis);\n \n \t\t\t\t\tif (entry.getName().equals(LOGBACK_JNDI_CLASS_PATH))\n \t\t\t\t\t\tfoundJndiUtil = true;\n \t\t\t\t}\n \n \t\t\t\tif (ZipUtils.isScanTarget(entry.getName(), config.isScanZip())) {\n \t\t\t\t\tpathChain.add(entry.getName());\n \n \t\t\t\t\tDetectResult nestedResult = scanStream(jarFile, zis, pathChain);\n \t\t\t\t\tresult.merge(nestedResult);\n \n \t\t\t\t\tpathChain.remove(pathChain.size() - 1);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tlog4",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an issue where the scanner incorrectly flagged log4j2-2.17.0 as vulnerable. It modifies the detection logic to correctly identify non-vulnerable versions, ensuring accurate security scanning.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.95"
}