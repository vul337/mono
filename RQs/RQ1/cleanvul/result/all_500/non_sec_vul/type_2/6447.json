{
  "id": 6447,
  "language": "C/C++",
  "commit_url": "https://github.com/bluez/bluez/commit/1cd644db8c23a2f530ddb93cebed7dacc5f5721a",
  "commit_sha": "1cd644db8c23a2f530ddb93cebed7dacc5f5721a",
  "commit_msg": "shared/att: Fix possible crash on disconnect\n\nIf there are pending request while disconnecting they would be notified\nbut clients may endup being freed in the proccess which will then be\ncalling bt_att_cancel to cancal its requests causing the following\ntrace:\n\nInvalid read of size 4\n   at 0x1D894C: enable_ccc_callback (gatt-client.c:1627)\n   by 0x1D247B: disc_att_send_op (att.c:417)\n   by 0x1CCC17: queue_remove_all (queue.c:354)\n   by 0x1D47B7: disconnect_cb (att.c:635)\n   by 0x1E0707: watch_callback (io-glib.c:170)\n   by 0x48E963B: g_main_context_dispatch (in /usr/lib/libglib-2.0.so.0.6400.4)\n   by 0x48E9AC7: ??? (in /usr/lib/libglib-2.0.so.0.6400.4)\n   by 0x48E9ECF: g_main_loop_run (in /usr/lib/libglib-2.0.so.0.6400.4)\n   by 0x1E0E97: mainloop_run (mainloop-glib.c:79)\n   by 0x1E13B3: mainloop_run_with_signal (mainloop-notify.c:201)\n   by 0x12BC3B: main (main.c:770)\n Address 0x7d40a28 is 24 bytes inside a block of size 32 free'd\n   at 0x484A2E0: free (vg_replace_malloc.c:540)\n   by 0x1CCC17: queue_remove_all (queue.c:354)\n   by 0x1CCC83: queue_destroy (queue.c:73)\n   by 0x1D7DD7: bt_gatt_client_free (gatt-client.c:2209)\n   by 0x16497B: batt_free (battery.c:77)\n   by 0x16497B: batt_remove (battery.c:286)\n   by 0x1A0013: service_remove (service.c:176)\n   by 0x1A9B7B: device_remove_gatt_service (device.c:3691)\n   by 0x1A9B7B: gatt_service_removed (device.c:3805)\n   by 0x1CC90B: queue_foreach (queue.c:220)\n   by 0x1DE27B: notify_service_changed.isra.0.part.0 (gatt-db.c:369)\n   by 0x1DE387: notify_service_changed (gatt-db.c:361)\n   by 0x1DE387: gatt_db_service_destroy (gatt-db.c:385)\n   by 0x1DE3EF: gatt_db_remove_service (gatt-db.c:519)\n   by 0x1D674F: discovery_op_complete (gatt-client.c:388)\n   by 0x1D6877: discover_primary_cb (gatt-client.c:1260)\n   by 0x1E220B: discovery_op_complete (gatt-helpers.c:628)\n   by 0x1E249B: read_by_grp_type_cb (gatt-helpers.c:730)\n   by 0x1D247B: disc_att_send_op (att.c:417)\n   by 0x1CCC17: queue_remove_all (queue.c:354)\n   by 0x1D47B7: disconnect_cb (att.c:635)",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/shared/att.c",
  "func_name": "bt_att_cancel",
  "func_before": "bool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\t/* Lookuo request on each channel first */\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\tif (!op)\n\t\treturn false;\n\ndone:\n\tdestroy_att_send_op(op);\n\n\twakeup_writer(att);\n\n\treturn true;\n}",
  "func_after": "bool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\t/* Lookuo request on each channel first */\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\n\tif (att->in_disc)\n\t\treturn bt_att_disc_cancel(att, id);\n\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\tif (!op)\n\t\treturn false;\n\ndone:\n\tdestroy_att_send_op(op);\n\n\twakeup_writer(att);\n\n\treturn true;\n}",
  "diff_func": "--- func_before\n+++ func_after\n bool bt_att_cancel(struct bt_att *att, unsigned int id)\n {\n \tconst struct queue_entry *entry;\n \tstruct att_send_op *op;\n \n \tif (!att || !id)\n \t\treturn false;\n \n \t/* Lookuo request on each channel first */\n \tfor (entry = queue_get_entries(att->chans); entry;\n \t\t\t\t\t\tentry = entry->next) {\n \t\tstruct bt_att_chan *chan = entry->data;\n \n \t\tif (bt_att_chan_cancel(chan, id))\n \t\t\treturn true;\n \t}\n+\n+\tif (att->in_disc)\n+\t\treturn bt_att_disc_cancel(att, id);\n \n \top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n \tif (op)\n \t\tgoto done;\n \n \top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n \tif (op)\n \t\tgoto done;\n \n \top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n \tif (op)\n \t\tgoto done;\n \n \tif (!op)\n \t\treturn false;\n \n done:\n \tdestroy_att_send_op(op);\n \n \twakeup_writer(att);\n \n \treturn true;\n }",
  "diff_source": "custom",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n- The commit addresses a crash during disconnect, specifically a use-after-free scenario.\n- The code adds a check to handle disconnect operations correctly, preventing memory corruption.\n- While memory issues can be security risks, this fix is primarily for system stability.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.8"
}