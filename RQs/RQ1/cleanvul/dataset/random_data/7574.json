{
  "id": 7574,
  "language": "JavaScript",
  "commit_url": "https://github.com/npm/npm/commit/fea8cc92cee02c720b58f95f14d315507ccad401",
  "commit_sha": "fea8cc92cee02c720b58f95f14d315507ccad401",
  "commit_msg": "config: only send token to registry hosts\n\nFixes: #8380\nCredit: @othiym23\nReviewed-By: @zkat",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "lib/cache.js",
  "func_name": "add",
  "func_before": "function add (args, where, cb) {\n  // this is hot code.  almost everything passes through here.\n  // the args can be any of:\n  // [\"url\"]\n  // [\"pkg\", \"version\"]\n  // [\"pkg@version\"]\n  // [\"pkg\", \"url\"]\n  // This is tricky, because urls can contain @\n  // Also, in some cases we get [name, null] rather\n  // that just a single argument.\n\n  var usage = \"Usage:\\n\"\n            + \"    npm cache add <tarball-url>\\n\"\n            + \"    npm cache add <pkg>@<ver>\\n\"\n            + \"    npm cache add <tarball>\\n\"\n            + \"    npm cache add <folder>\\n\"\n    , spec\n\n  log.silly(\"cache add\", \"args\", args)\n\n  if (args[1] === undefined) args[1] = null\n\n  // at this point the args length must ==2\n  if (args[1] !== null) {\n    spec = args[0]+\"@\"+args[1]\n  } else if (args.length === 2) {\n    spec = args[0]\n  }\n\n  log.verbose(\"cache add\", \"spec\", spec)\n\n  if (!spec) return cb(usage)\n\n  if (adding <= 0) {\n    npm.spinner.start()\n  }\n  adding++\n  cb = afterAdd(cb)\n\n  realizePackageSpecifier(spec, where, function (err, p) {\n    if (err) return cb(err)\n\n    log.silly(\"cache add\", \"parsed spec\", p)\n\n    switch (p.type) {\n      case \"local\":\n      case \"directory\":\n        addLocal(p, null, cb)\n        break\n      case \"remote\":\n        // get auth, if possible\n        mapToRegistry(spec, npm.config, function (err, uri, auth) {\n          if (err) return cb(err)\n\n          addRemoteTarball(p.spec, {name : p.name}, null, auth, cb)\n        })\n        break\n      case \"git\":\n      case \"hosted\":\n        addRemoteGit(p.rawSpec, cb)\n        break\n      default:\n        if (p.name) return addNamed(p.name, p.spec, null, cb)\n\n        cb(new Error(\"couldn't figure out how to install \" + spec))\n    }\n  })\n}",
  "func_after": "function add (args, where, cb) {\n  // this is hot code.  almost everything passes through here.\n  // the args can be any of:\n  // [\"url\"]\n  // [\"pkg\", \"version\"]\n  // [\"pkg@version\"]\n  // [\"pkg\", \"url\"]\n  // This is tricky, because urls can contain @\n  // Also, in some cases we get [name, null] rather\n  // that just a single argument.\n\n  var usage = \"Usage:\\n\"\n            + \"    npm cache add <tarball-url>\\n\"\n            + \"    npm cache add <pkg>@<ver>\\n\"\n            + \"    npm cache add <tarball>\\n\"\n            + \"    npm cache add <folder>\\n\"\n    , spec\n\n  log.silly(\"cache add\", \"args\", args)\n\n  if (args[1] === undefined) args[1] = null\n\n  // at this point the args length must ==2\n  if (args[1] !== null) {\n    spec = args[0]+\"@\"+args[1]\n  } else if (args.length === 2) {\n    spec = args[0]\n  }\n\n  log.verbose(\"cache add\", \"spec\", spec)\n\n  if (!spec) return cb(usage)\n\n  if (adding <= 0) {\n    npm.spinner.start()\n  }\n  adding++\n  cb = afterAdd(cb)\n\n  realizePackageSpecifier(spec, where, function (err, p) {\n    if (err) return cb(err)\n\n    log.silly(\"cache add\", \"parsed spec\", p)\n\n    switch (p.type) {\n      case \"local\":\n      case \"directory\":\n        addLocal(p, null, cb)\n        break\n      case \"remote\":\n        // get auth, if possible\n        mapToRegistry(p.raw, npm.config, function (err, uri, auth) {\n          if (err) return cb(err)\n\n          addRemoteTarball(p.spec, {name : p.name}, null, auth, cb)\n        })\n        break\n      case \"git\":\n      case \"hosted\":\n        addRemoteGit(p.rawSpec, cb)\n        break\n      default:\n        if (p.name) return addNamed(p.name, p.spec, null, cb)\n\n        cb(new Error(\"couldn't figure out how to install \" + spec))\n    }\n  })\n}",
  "diff_func": "--- func_before\n+++ func_after\n function add (args, where, cb) {\n   // this is hot code.  almost everything passes through here.\n   // the args can be any of:\n   // [\"url\"]\n   // [\"pkg\", \"version\"]\n   // [\"pkg@version\"]\n   // [\"pkg\", \"url\"]\n   // This is tricky, because urls can contain @\n   // Also, in some cases we get [name, null] rather\n   // that just a single argument.\n \n   var usage = \"Usage:\\n\"\n             + \"    npm cache add <tarball-url>\\n\"\n             + \"    npm cache add <pkg>@<ver>\\n\"\n             + \"    npm cache add <tarball>\\n\"\n             + \"    npm cache add <folder>\\n\"\n     , spec\n \n   log.silly(\"cache add\", \"args\", args)\n \n   if (args[1] === undefined) args[1] = null\n \n   // at this point the args length must ==2\n   if (args[1] !== null) {\n     spec = args[0]+\"@\"+args[1]\n   } else if (args.length === 2) {\n     spec = args[0]\n   }\n \n   log.verbose(\"cache add\", \"spec\", spec)\n \n   if (!spec) return cb(usage)\n \n   if (adding <= 0) {\n     npm.spinner.start()\n   }\n   adding++\n   cb = afterAdd(cb)\n \n   realizePackageSpecifier(spec, where, function (err, p) {\n     if (err) return cb(err)\n \n     log.silly(\"cache add\", \"parsed spec\", p)\n \n     switch (p.type) {\n       case \"local\":\n       case \"directory\":\n         addLocal(p, null, cb)\n         break\n       case \"remote\":\n         // get auth, if possible\n-        mapToRegistry(spec, npm.config, function (err, uri, auth) {\n+        mapToRegistry(p.raw, npm.config, function (err, uri, auth) {\n           if (err) return cb(err)\n \n           addRemoteTarball(p.spec, {name : p.name}, null, auth, cb)\n         })\n         break\n       case \"git\":\n       case \"hosted\":\n         addRemoteGit(p.rawSpec, cb)\n         break\n       default:\n         if (p.name) return addNamed(p.name, p.spec, null, cb)\n \n         cb(new Error(\"couldn't figure out how to install \" + spec))\n     }\n   })\n }",
  "diff_source": "custom"
}