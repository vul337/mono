{
  "id": 5829,
  "language": "C/C++",
  "commit_url": "https://github.com/accel-ppp/accel-ppp/commit/e9d369aa0054312b7633e964e9f7eb323f1f3d69",
  "commit_sha": "e9d369aa0054312b7633e964e9f7eb323f1f3d69",
  "commit_msg": "radius: sanity check for vendor attribute length",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "accel-pppd/radius/packet.c",
  "func_name": "rad_packet_recv",
  "func_before": "int rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}",
  "func_after": "int rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t\tif (len < 0) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (2 + len > n) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", id, len);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n {\n \tstruct rad_packet_t *pack;\n \tstruct rad_attr_t *attr;\n \tstruct rad_dict_attr_t *da;\n \tstruct rad_dict_vendor_t *vendor;\n \tuint8_t *ptr;\n \tint n, id, len, vendor_id;\n \tsocklen_t addr_len = sizeof(*addr);\n \n \t*p = NULL;\n \n \tpack = rad_packet_alloc(0);\n \tif (!pack)\n \t\treturn 0;\n \n \t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n \tptr = mempool_alloc(buf_pool);\n \tif (ptr == MAP_FAILED) {\n \t\tlog_emerg(\"radius:packet: out of memory\\n\");\n \t\tgoto out_err;\n \t}\n \n \tpack->buf = ptr;\n \tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n \n \twhile (1) {\n \t\tif (addr)\n \t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n \t\telse\n \t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n \t\tif (n < 0) {\n \t\t\trad_packet_free(pack);\n \t\t\tif (errno == EAGAIN)\n \t\t\t\treturn 1;\n \n \t\t\tif (errno != ECONNREFUSED)\n \t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n \n \t\t\treturn -1;\n \t\t}\n \t\tbreak;\n \t}\n \n \tif (n < 20) {\n \t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n \t\tgoto out_err;\n \t}\n \n \tpack->code = *ptr; ptr++;\n \tpack->id = *ptr; ptr++;\n \tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n \n \tif (pack->len > n) {\n \t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n \t\tgoto out_err;\n \t}\n \n \tptr += 16;\n \tn -= 20;\n \n \twhile (n>0) {\n \t\tid = *ptr; ptr++;\n \t\tlen = *ptr - 2; ptr++;\n \t\tif (len < 0) {\n \t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n \t\t\tgoto out_err;\n \t\t}\n \t\tif (2 + len > n) {\n \t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n \t\t\tgoto out_err;\n \t\t}\n \t\tif (id == 26) {\n \t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n \t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n \t\t\tif (vendor) {\n \t\t\t\tptr += 4;\n \n \t\t\t\tif (vendor->tag == 2)\n \t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n \t\t\t\telse\n \t\t\t\t\tid = *ptr;\n \n \t\t\t\tptr += vendor->tag;\n \n \t\t\t\t",
  "diff_source": "custom"
}