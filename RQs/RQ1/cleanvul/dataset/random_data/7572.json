{
  "id": 7572,
  "language": "JavaScript",
  "commit_url": "https://github.com/yairEO/tagify/commit/198c0451fad188390390395ccfc84ab371def4c7",
  "commit_sha": "198c0451fad188390390395ccfc84ab371def4c7",
  "commit_msg": "fixes #989 - fix XSS",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/tagify.js",
  "func_name": "applySettings",
  "func_before": "applySettings( input, settings ){\n        DEFAULTS.templates = this.templates\n\n        var _s = this.settings = extend({}, DEFAULTS, settings)\n\n        _s.disabled = input.hasAttribute('disabled')\n        _s.readonly = _s.readonly || input.hasAttribute('readonly')\n        _s.placeholder = input.getAttribute('placeholder') || _s.placeholder || \"\"\n        _s.required = input.hasAttribute('required')\n\n        for( let name in _s.classNames )\n            Object.defineProperty(_s.classNames, name + \"Selector\" , {\n                get(){ return \".\"+this[name].split(\" \")[0] }\n            })\n\n        if( this.isIE )\n            _s.autoComplete = false; // IE goes crazy if this isn't false\n\n        [\"whitelist\", \"blacklist\"].forEach(name => {\n            var attrVal = input.getAttribute('data-' + name)\n            if( attrVal ){\n                attrVal = attrVal.split(_s.delimiters)\n                if( attrVal instanceof Array )\n                    _s[name] = attrVal\n            }\n        })\n\n        // backward-compatibility for old version of \"autoComplete\" setting:\n        if( \"autoComplete\" in settings && !isObject(settings.autoComplete) ){\n            _s.autoComplete = DEFAULTS.autoComplete\n            _s.autoComplete.enabled = settings.autoComplete\n        }\n\n        if( _s.mode == 'mix' ){\n            _s.autoComplete.rightKey = true\n            _s.delimiters = settings.delimiters || null // default dlimiters in mix-mode must be NULL\n\n            // needed for \"filterListItems\". This assumes the user might have forgotten to manually\n            // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\n            // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\n            if( _s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp) )\n                _s.dropdown.searchKeys.push(_s.tagTextProp)\n        }\n\n        if( input.pattern )\n            try { _s.pattern = new RegExp(input.pattern)  }\n            catch(e){}\n\n        // Convert the \"delimiters\" setting into a REGEX object\n        if( this.settings.delimiters ){\n            try { _s.delimiters = new RegExp(this.settings.delimiters, \"g\") }\n            catch(e){}\n        }\n\n        if( _s.disabled )\n            _s.userInput = false;\n\n        this.TEXTS = {...TEXTS, ...(_s.texts || {})}\n\n        // make sure the dropdown will be shown on \"focus\" and not only after typing something (in \"select\" mode)\n        if( _s.mode == 'select' || !_s.userInput )\n            _s.dropdown.enabled = 0\n\n        _s.dropdown.appendTarget = settings.dropdown && settings.dropdown.appendTarget\n            ? settings.dropdown.appendTarget\n            : document.body\n\n\n        // get & merge persisted data with current data\n        let persistedWhitelist = this.getPersistedData('whitelist');\n\n        if( Array.isArray(persistedWhitelist))\n            this.whitelist = Array.isArray(_s.whitelist)\n                ? concatWithoutDups(_s.whitelist, persistedWhitelist)\n                : persistedWhitelist;\n    }",
  "func_after": "applySettings( input, settings ){\n        DEFAULTS.templates = this.templates\n\n        var _s = this.settings = extend({}, DEFAULTS, settings)\n\n        _s.disabled = input.hasAttribute('disabled')\n        _s.readonly = _s.readonly || input.hasAttribute('readonly')\n        _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || \"\")\n        _s.required = input.hasAttribute('required')\n\n        for( let name in _s.classNames )\n            Object.defineProperty(_s.classNames, name + \"Selector\" , {\n                get(){ return \".\"+this[name].split(\" \")[0] }\n            })\n\n        if( this.isIE )\n            _s.autoComplete = false; // IE goes crazy if this isn't false\n\n        [\"whitelist\", \"blacklist\"].forEach(name => {\n            var attrVal = input.getAttribute('data-' + name)\n            if( attrVal ){\n                attrVal = attrVal.split(_s.delimiters)\n                if( attrVal instanceof Array )\n                    _s[name] = attrVal\n            }\n        })\n\n        // backward-compatibility for old version of \"autoComplete\" setting:\n        if( \"autoComplete\" in settings && !isObject(settings.autoComplete) ){\n            _s.autoComplete = DEFAULTS.autoComplete\n            _s.autoComplete.enabled = settings.autoComplete\n        }\n\n        if( _s.mode == 'mix' ){\n            _s.autoComplete.rightKey = true\n            _s.delimiters = settings.delimiters || null // default dlimiters in mix-mode must be NULL\n\n            // needed for \"filterListItems\". This assumes the user might have forgotten to manually\n            // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\n            // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\n            if( _s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp) )\n                _s.dropdown.searchKeys.push(_s.tagTextProp)\n        }\n\n        if( input.pattern )\n            try { _s.pattern = new RegExp(input.pattern)  }\n            catch(e){}\n\n        // Convert the \"delimiters\" setting into a REGEX object\n        if( this.settings.delimiters ){\n            try { _s.delimiters = new RegExp(this.settings.delimiters, \"g\") }\n            catch(e){}\n        }\n\n        if( _s.disabled )\n            _s.userInput = false;\n\n        this.TEXTS = {...TEXTS, ...(_s.texts || {})}\n\n        // make sure the dropdown will be shown on \"focus\" and not only after typing something (in \"select\" mode)\n        if( _s.mode == 'select' || !_s.userInput )\n            _s.dropdown.enabled = 0\n\n        _s.dropdown.appendTarget = settings.dropdown && settings.dropdown.appendTarget\n            ? settings.dropdown.appendTarget\n            : document.body\n\n\n        // get & merge persisted data with current data\n        let persistedWhitelist = this.getPersistedData('whitelist');\n\n        if( Array.isArray(persistedWhitelist))\n            this.whitelist = Array.isArray(_s.whitelist)\n                ? concatWithoutDups(_s.whitelist, persistedWhitelist)\n                : persistedWhitelist;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n applySettings( input, settings ){\n         DEFAULTS.templates = this.templates\n \n         var _s = this.settings = extend({}, DEFAULTS, settings)\n \n         _s.disabled = input.hasAttribute('disabled')\n         _s.readonly = _s.readonly || input.hasAttribute('readonly')\n-        _s.placeholder = input.getAttribute('placeholder') || _s.placeholder || \"\"\n+        _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || \"\")\n         _s.required = input.hasAttribute('required')\n \n         for( let name in _s.classNames )\n             Object.defineProperty(_s.classNames, name + \"Selector\" , {\n                 get(){ return \".\"+this[name].split(\" \")[0] }\n             })\n \n         if( this.isIE )\n             _s.autoComplete = false; // IE goes crazy if this isn't false\n \n         [\"whitelist\", \"blacklist\"].forEach(name => {\n             var attrVal = input.getAttribute('data-' + name)\n             if( attrVal ){\n                 attrVal = attrVal.split(_s.delimiters)\n                 if( attrVal instanceof Array )\n                     _s[name] = attrVal\n             }\n         })\n \n         // backward-compatibility for old version of \"autoComplete\" setting:\n         if( \"autoComplete\" in settings && !isObject(settings.autoComplete) ){\n             _s.autoComplete = DEFAULTS.autoComplete\n             _s.autoComplete.enabled = settings.autoComplete\n         }\n \n         if( _s.mode == 'mix' ){\n             _s.autoComplete.rightKey = true\n             _s.delimiters = settings.delimiters || null // default dlimiters in mix-mode must be NULL\n \n             // needed for \"filterListItems\". This assumes the user might have forgotten to manually\n             // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\n             // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\n             if( _s.tagTextProp && !_s.dropdown.searchKeys.include",
  "diff_source": "custom"
}