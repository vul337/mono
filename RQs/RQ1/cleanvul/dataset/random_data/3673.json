{
  "id": 3673,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a",
  "commit_sha": "7caac62ed598a196d6ddf8d9c121e12e082cac3a",
  "commit_msg": "mwifiex: Fix three heap overflow at parsing element in cfg80211_ap_settings\n\nmwifiex_update_vs_ie(),mwifiex_set_uap_rates() and\nmwifiex_set_wmm_params() call memcpy() without checking\nthe destination size.Since the source is given from\nuser-space, this may trigger a heap buffer overflow.\n\nFix them by putting the length check before performing memcpy().\n\nThis fix addresses CVE-2019-14814,CVE-2019-14815,CVE-2019-14816.\n\nSigned-off-by: Wen Huang <huangwenabc@gmail.com>\nAcked-by: Ganapathi Bhat <gbhat@marvell.comg>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "drivers/net/wireless/marvell/mwifiex/ie.c",
  "func_name": "mwifiex_update_vs_ie",
  "func_before": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}",
  "func_after": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n \t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n \t\t\t\tunsigned int oui, u8 oui_type)\n {\n \tstruct ieee_types_header *vs_ie;\n \tstruct mwifiex_ie *ie = *ie_ptr;\n \tconst u8 *vendor_ie;\n \n \tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n \tif (vendor_ie) {\n \t\tif (!*ie_ptr) {\n \t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n \t\t\t\t\t  GFP_KERNEL);\n \t\t\tif (!*ie_ptr)\n \t\t\t\treturn -ENOMEM;\n \t\t\tie = *ie_ptr;\n \t\t}\n \n \t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n+\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n+\t\t\tIEEE_MAX_IE_SIZE)\n+\t\t\treturn -EINVAL;\n \t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n \t\t       vs_ie, vs_ie->len + 2);\n \t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n \t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n \t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n \t}\n \n \t*ie_ptr = ie;\n \treturn 0;\n }",
  "diff_source": "custom"
}