{
  "id": 6229,
  "language": "Python",
  "commit_url": "https://github.com/cookiecutter/cookiecutter/commit/fdffddb31fd2b46344dfa317531ff155e7999f77",
  "commit_sha": "fdffddb31fd2b46344dfa317531ff155e7999f77",
  "commit_msg": "Merge pull request #1689 from cookiecutter/sanitize-mercurial-checkout\n\nSanitize Mercurial branch information before checkout.",
  "pr_url": "https://github.com/cookiecutter/cookiecutter/pull/1689",
  "pr_info": "no more info",
  "file_name": "cookiecutter/vcs.py",
  "func_name": "clone",
  "func_before": "def clone(repo_url, checkout=None, clone_to_dir='.', no_input=False):\n    \"\"\"Clone a repo to the current directory.\n\n    :param repo_url: Repo URL of unknown type.\n    :param checkout: The branch, tag or commit ID to checkout after clone.\n    :param clone_to_dir: The directory to clone to.\n                         Defaults to the current directory.\n    :param no_input: Suppress all user prompts when calling via API.\n    :returns: str with path to the new directory of the repository.\n    \"\"\"\n    # Ensure that clone_to_dir exists\n    clone_to_dir = os.path.expanduser(clone_to_dir)\n    make_sure_path_exists(clone_to_dir)\n\n    # identify the repo_type\n    repo_type, repo_url = identify_repo(repo_url)\n\n    # check that the appropriate VCS for the repo_type is installed\n    if not is_vcs_installed(repo_type):\n        msg = f\"'{repo_type}' is not installed.\"\n        raise VCSNotInstalled(msg)\n\n    repo_url = repo_url.rstrip('/')\n    repo_name = os.path.split(repo_url)[1]\n    if repo_type == 'git':\n        repo_name = repo_name.split(':')[-1].rsplit('.git')[0]\n        repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))\n    if repo_type == 'hg':\n        repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))\n    logger.debug(f'repo_dir is {repo_dir}')\n\n    if os.path.isdir(repo_dir):\n        clone = prompt_and_delete(repo_dir, no_input=no_input)\n    else:\n        clone = True\n\n    if clone:\n        try:\n            subprocess.check_output(  # nosec\n                [repo_type, 'clone', repo_url],\n                cwd=clone_to_dir,\n                stderr=subprocess.STDOUT,\n            )\n            if checkout is not None:\n                subprocess.check_output(  # nosec\n                    [repo_type, 'checkout', checkout],\n                    cwd=repo_dir,\n                    stderr=subprocess.STDOUT,\n                )\n        except subprocess.CalledProcessError as clone_error:\n            output = clone_error.output.decode('utf-8')\n            if 'not found' in output.lower():\n                raise RepositoryNotFound(\n                    'The repository {} could not be found, '\n                    'have you made a typo?'.format(repo_url)\n                )\n            if any(error in output for error in BRANCH_ERRORS):\n                raise RepositoryCloneFailed(\n                    'The {} branch of repository {} could not found, '\n                    'have you made a typo?'.format(checkout, repo_url)\n                )\n            logger.error('git clone failed with error: %s', output)\n            raise\n\n    return repo_dir",
  "func_after": "def clone(repo_url, checkout=None, clone_to_dir='.', no_input=False):\n    \"\"\"Clone a repo to the current directory.\n\n    :param repo_url: Repo URL of unknown type.\n    :param checkout: The branch, tag or commit ID to checkout after clone.\n    :param clone_to_dir: The directory to clone to.\n                         Defaults to the current directory.\n    :param no_input: Suppress all user prompts when calling via API.\n    :returns: str with path to the new directory of the repository.\n    \"\"\"\n    # Ensure that clone_to_dir exists\n    clone_to_dir = os.path.expanduser(clone_to_dir)\n    make_sure_path_exists(clone_to_dir)\n\n    # identify the repo_type\n    repo_type, repo_url = identify_repo(repo_url)\n\n    # check that the appropriate VCS for the repo_type is installed\n    if not is_vcs_installed(repo_type):\n        msg = f\"'{repo_type}' is not installed.\"\n        raise VCSNotInstalled(msg)\n\n    repo_url = repo_url.rstrip('/')\n    repo_name = os.path.split(repo_url)[1]\n    if repo_type == 'git':\n        repo_name = repo_name.split(':')[-1].rsplit('.git')[0]\n        repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))\n    if repo_type == 'hg':\n        repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))\n    logger.debug(f'repo_dir is {repo_dir}')\n\n    if os.path.isdir(repo_dir):\n        clone = prompt_and_delete(repo_dir, no_input=no_input)\n    else:\n        clone = True\n\n    if clone:\n        try:\n            subprocess.check_output(  # nosec\n                [repo_type, 'clone', repo_url],\n                cwd=clone_to_dir,\n                stderr=subprocess.STDOUT,\n            )\n            if checkout is not None:\n                checkout_params = [checkout]\n                # Avoid Mercurial \"--config\" and \"--debugger\" injection vulnerability\n                if repo_type == \"hg\":\n                    checkout_params.insert(0, \"--\")\n                subprocess.check_output(  # nosec\n                    [repo_type, 'checkout', *checkout_params],\n                    cwd=repo_dir,\n                    stderr=subprocess.STDOUT,\n                )\n        except subprocess.CalledProcessError as clone_error:\n            output = clone_error.output.decode('utf-8')\n            if 'not found' in output.lower():\n                raise RepositoryNotFound(\n                    f'The repository {repo_url} could not be found, '\n                    'have you made a typo?'\n                )\n            if any(error in output for error in BRANCH_ERRORS):\n                raise RepositoryCloneFailed(\n                    f'The {checkout} branch of repository '\n                    f'{repo_url} could not found, have you made a typo?'\n                )\n            logger.error('git clone failed with error: %s', output)\n            raise\n\n    return repo_dir",
  "diff_func": "--- func_before\n+++ func_after\n def clone(repo_url, checkout=None, clone_to_dir='.', no_input=False):\n     \"\"\"Clone a repo to the current directory.\n \n     :param repo_url: Repo URL of unknown type.\n     :param checkout: The branch, tag or commit ID to checkout after clone.\n     :param clone_to_dir: The directory to clone to.\n                          Defaults to the current directory.\n     :param no_input: Suppress all user prompts when calling via API.\n     :returns: str with path to the new directory of the repository.\n     \"\"\"\n     # Ensure that clone_to_dir exists\n     clone_to_dir = os.path.expanduser(clone_to_dir)\n     make_sure_path_exists(clone_to_dir)\n \n     # identify the repo_type\n     repo_type, repo_url = identify_repo(repo_url)\n \n     # check that the appropriate VCS for the repo_type is installed\n     if not is_vcs_installed(repo_type):\n         msg = f\"'{repo_type}' is not installed.\"\n         raise VCSNotInstalled(msg)\n \n     repo_url = repo_url.rstrip('/')\n     repo_name = os.path.split(repo_url)[1]\n     if repo_type == 'git':\n         repo_name = repo_name.split(':')[-1].rsplit('.git')[0]\n         repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))\n     if repo_type == 'hg':\n         repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))\n     logger.debug(f'repo_dir is {repo_dir}')\n \n     if os.path.isdir(repo_dir):\n         clone = prompt_and_delete(repo_dir, no_input=no_input)\n     else:\n         clone = True\n \n     if clone:\n         try:\n             subprocess.check_output(  # nosec\n                 [repo_type, 'clone', repo_url],\n                 cwd=clone_to_dir,\n                 stderr=subprocess.STDOUT,\n             )\n             if checkout is not None:\n+                checkout_params = [checkout]\n+                # Avoid Mercurial \"--config\" and \"--debugger\" injection vulnerability\n+                if repo_type == \"hg\":\n+                    checkout_params.insert(0, \"--\")\n                 subprocess.check_o",
  "diff_source": "custom"
}