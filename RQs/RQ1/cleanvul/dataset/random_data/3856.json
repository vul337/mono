{
  "id": 3856,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/764f4eb6846f5475f1244767d24d25dd86528a4a",
  "commit_sha": "764f4eb6846f5475f1244767d24d25dd86528a4a",
  "commit_msg": "llc: fix netdevice reference leaks in llc_ui_bind()\n\nWhenever llc_ui_bind() and/or llc_ui_autobind()\ntook a reference on a netdevice but subsequently fail,\nthey must properly release their reference\nor risk the infamous message from unregister_netdevice()\nat device dismantle.\n\nunregister_netdevice: waiting for eth0 to become free. Usage count = 3\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: 赵子轩 <beraphin@gmail.com>\nReported-by: Stoyan Manolov <smanolov@suse.de>\nLink: https://lore.kernel.org/r/20220323004147.1990845-1-eric.dumazet@gmail.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "net/llc/af_llc.c",
  "func_name": "llc_ui_autobind",
  "func_before": "static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; /* some other network layer is using the sap */\n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t/* assign new connection to its SAP */\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\treturn rc;\n}",
  "func_after": "static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; /* some other network layer is using the sap */\n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t/* assign new connection to its SAP */\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\tif (rc) {\n\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n\t\tllc->dev = NULL;\n\t}\n\treturn rc;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n {\n \tstruct sock *sk = sock->sk;\n \tstruct llc_sock *llc = llc_sk(sk);\n \tstruct llc_sap *sap;\n \tint rc = -EINVAL;\n \n \tif (!sock_flag(sk, SOCK_ZAPPED))\n \t\tgoto out;\n \tif (!addr->sllc_arphrd)\n \t\taddr->sllc_arphrd = ARPHRD_ETHER;\n \tif (addr->sllc_arphrd != ARPHRD_ETHER)\n \t\tgoto out;\n \trc = -ENODEV;\n \tif (sk->sk_bound_dev_if) {\n \t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n \t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n \t\t\tdev_put(llc->dev);\n \t\t\tllc->dev = NULL;\n \t\t}\n \t} else\n \t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n \tif (!llc->dev)\n \t\tgoto out;\n \tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n \trc = -EUSERS;\n \tllc->laddr.lsap = llc_ui_autoport();\n \tif (!llc->laddr.lsap)\n \t\tgoto out;\n \trc = -EBUSY; /* some other network layer is using the sap */\n \tsap = llc_sap_open(llc->laddr.lsap, NULL);\n \tif (!sap)\n \t\tgoto out;\n \tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n \tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n \t/* assign new connection to its SAP */\n \tllc_sap_add_socket(sap, sk);\n \tsock_reset_flag(sk, SOCK_ZAPPED);\n \trc = 0;\n out:\n+\tif (rc) {\n+\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n+\t\tllc->dev = NULL;\n+\t}\n \treturn rc;\n }",
  "diff_source": "custom"
}