{
  "id": 986,
  "language": "Java",
  "commit_url": "https://github.com/neo4j/apoc/commit/e5b4ecc7bc47b1f54ceb5d06a175df72d0d9c6ab",
  "commit_sha": "e5b4ecc7bc47b1f54ceb5d06a175df72d0d9c6ab",
  "commit_msg": "vuln-fix: Partial Path Traversal Vulnerability (#3080) (#3094)\n\nThis fixes a partial path traversal vulnerability.\r\n\r\nReplaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\r\n\r\nTo demonstrate this vulnerability, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\r\nThe check is bypassed although `/outnot` is not under the `/out` directory.\r\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\r\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\r\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\r\n\r\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\r\nSeverity: Medium\r\nCVSSS: 6.1\r\nDetection: CodeQL & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.PartialPathTraversalVulnerability)\r\n\r\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\r\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\r\n\r\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/13\r\n\r\nCo-authored-by: Moderne <team@moderne.io>\r\n\r\nCo-authored-by: Moderne <team@moderne.io>\r\n(cherry picked from commit d2f415c6f703bbc2cda4a753928821ff15d5c620)\r\n\r\nCo-authored-by: Jonathan Leitschuh <jonathan.leitschuh@gmail.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "common/src/main/java/apoc/log/Neo4jLogStream.java",
  "func_name": "Procedure",
  "func_before": "@Admin\n    @Procedure(mode=Mode.DBMS)\n    @Description( \"apoc.log.stream('neo4j.log', { last: n }) - retrieve log file contents, optionally return only the last n lines\" )\n    public Stream<FileEntry> stream(\n            @Name(\"path\") String logName,\n            @Name(value = \"config\",defaultValue = \"{}\") Map<String, Object> config) {\n\n        File logDir = FileUtils.getLogDirectory();\n\n        if (logDir == null) {\n            throw new RuntimeException(\"Neo4j configured server.directories.logs points to a directory that \" +\n                    \"does not exist or is not readable.  Please ensure this configuration is correct.\");\n        }\n\n        // Prepend neo4jHome if it's a relative path, and use the user's path otherwise.\n        File f = new File(logDir, logName);\n\n        try {\n            String canonicalPath = f.getCanonicalPath();\n            if (!canonicalPath.startsWith(logDir.getAbsolutePath())) {\n                throw new RuntimeException(\"The path you are trying to access has a canonical path outside of the logs \" +\n                        \"directory, and this procedure is only permitted to access files in the log directory.  This may \" +\n                        \"occur if the path in question is a symlink or other link.\");\n            }\n        } catch (IOException ioe) {\n            throw new RuntimeException(\"Unable to resolve basic log file canonical path\", ioe);\n        }\n\n        try {\n            Stream<String> stream = Files.lines(Paths.get(f.toURI()));\n            final AtomicLong lineNumber = new AtomicLong(0);\n            final String p = f.getCanonicalPath();\n\n            Stream<FileEntry> entries = stream.map(line -> new FileEntry(lineNumber.getAndIncrement(), line, p));\n\n            // Useful for tailing logfiles.\n            if(config.containsKey(\"last\")) {\n                return entries.sorted(Collections.reverseOrder()).limit(new Double(config.get(\"last\").toString()).longValue());\n            }\n\n            return entries;\n        } catch(NoSuchFileException nsf) {\n            // This special case we want to throw a custom message and not let this error propagate, because the\n            // trace exposes the full path we were checking.\n            throw new RuntimeException(\"No log file exists by that name\");\n        } catch (IOException exc) {\n            throw new RuntimeException(exc);\n        }\n    }",
  "func_after": "@Admin\n    @Procedure(mode=Mode.DBMS)\n    @Description( \"apoc.log.stream('neo4j.log', { last: n }) - retrieve log file contents, optionally return only the last n lines\" )\n    public Stream<FileEntry> stream(\n            @Name(\"path\") String logName,\n            @Name(value = \"config\",defaultValue = \"{}\") Map<String, Object> config) {\n\n        File logDir = FileUtils.getLogDirectory();\n\n        if (logDir == null) {\n            throw new RuntimeException(\"Neo4j configured server.directories.logs points to a directory that \" +\n                    \"does not exist or is not readable.  Please ensure this configuration is correct.\");\n        }\n\n        // Prepend neo4jHome if it's a relative path, and use the user's path otherwise.\n        File f = new File(logDir, logName);\n\n        try {\n            if (!f.getCanonicalFile().toPath().startsWith(logDir.getAbsolutePath())) {\n                throw new RuntimeException(\"The path you are trying to access has a canonical path outside of the logs \" +\n                        \"directory, and this procedure is only permitted to access files in the log directory.  This may \" +\n                        \"occur if the path in question is a symlink or other link.\");\n            }\n        } catch (IOException ioe) {\n            throw new RuntimeException(\"Unable to resolve basic log file canonical path\", ioe);\n        }\n\n        try {\n            Stream<String> stream = Files.lines(Paths.get(f.toURI()));\n            final AtomicLong lineNumber = new AtomicLong(0);\n            final String p = f.getCanonicalPath();\n\n            Stream<FileEntry> entries = stream.map(line -> new FileEntry(lineNumber.getAndIncrement(), line, p));\n\n            // Useful for tailing logfiles.\n            if(config.containsKey(\"last\")) {\n                return entries.sorted(Collections.reverseOrder()).limit(new Double(config.get(\"last\").toString()).longValue());\n            }\n\n            return entries;\n        } catch(NoSuchFileException nsf) {\n            // This special case we want to throw a custom message and not let this error propagate, because the\n            // trace exposes the full path we were checking.\n            throw new RuntimeException(\"No log file exists by that name\");\n        } catch (IOException exc) {\n            throw new RuntimeException(exc);\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Admin\n     @Procedure(mode=Mode.DBMS)\n     @Description( \"apoc.log.stream('neo4j.log', { last: n }) - retrieve log file contents, optionally return only the last n lines\" )\n     public Stream<FileEntry> stream(\n             @Name(\"path\") String logName,\n             @Name(value = \"config\",defaultValue = \"{}\") Map<String, Object> config) {\n \n         File logDir = FileUtils.getLogDirectory();\n \n         if (logDir == null) {\n             throw new RuntimeException(\"Neo4j configured server.directories.logs points to a directory that \" +\n                     \"does not exist or is not readable.  Please ensure this configuration is correct.\");\n         }\n \n         // Prepend neo4jHome if it's a relative path, and use the user's path otherwise.\n         File f = new File(logDir, logName);\n \n         try {\n-            String canonicalPath = f.getCanonicalPath();\n-            if (!canonicalPath.startsWith(logDir.getAbsolutePath())) {\n+            if (!f.getCanonicalFile().toPath().startsWith(logDir.getAbsolutePath())) {\n                 throw new RuntimeException(\"The path you are trying to access has a canonical path outside of the logs \" +\n                         \"directory, and this procedure is only permitted to access files in the log directory.  This may \" +\n                         \"occur if the path in question is a symlink or other link.\");\n             }\n         } catch (IOException ioe) {\n             throw new RuntimeException(\"Unable to resolve basic log file canonical path\", ioe);\n         }\n \n         try {\n             Stream<String> stream = Files.lines(Paths.get(f.toURI()));\n             final AtomicLong lineNumber = new AtomicLong(0);\n             final String p = f.getCanonicalPath();\n \n             Stream<FileEntry> entries = stream.map(line -> new FileEntry(lineNumber.getAndIncrement(), line, p));\n \n             // Useful for tailing logfiles.\n             if(config.containsKey(\"last\")) {\n                 return ent",
  "diff_source": "custom"
}