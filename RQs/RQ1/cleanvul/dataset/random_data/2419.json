{
  "id": 2419,
  "language": "Java",
  "commit_url": "https://github.com/omnirom/android_frameworks_base/commit/287657ca9325aec92df5f3741b5ebe0e27b11036",
  "commit_sha": "287657ca9325aec92df5f3741b5ebe0e27b11036",
  "commit_msg": "Do not resume activity if behind a translucent task\n\nThe top-focusable activity resides in the RESUMED state while the app\nprocess is newly created and attached. The behavior may enable UI\nhijacking attacks against apps implementing authentication.\n\nThis CL disallows the system to resume the activity for the case if it\nis not visible or is occluded by other translucent tasks.\n\nBug: 211481342\nTest: atest CtsWindowManagerDeviceTestCases:ActivityLifecycleTests\nChange-Id: I7903494cf928b5b5613700262b7c5fff10f3c5a0",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/wm/EnsureActivitiesVisibleHelper.java",
  "func_name": "process",
  "func_before": "void process(@Nullable ActivityRecord starting, int configChanges, boolean preserveWindows,\n            boolean notifyClients) {\n        reset(starting, configChanges, preserveWindows, notifyClients);\n\n        if (DEBUG_VISIBILITY) {\n            Slog.v(TAG_VISIBILITY, \"ensureActivitiesVisible behind \" + mTop\n                    + \" configChanges=0x\" + Integer.toHexString(configChanges));\n        }\n        if (mTop != null && mTaskFragment.asTask() != null) {\n            // TODO(14709632): Check if this needed to be implemented in TaskFragment.\n            mTaskFragment.asTask().checkTranslucentActivityWaiting(mTop);\n        }\n\n        // We should not resume activities that being launched behind because these\n        // activities are actually behind other fullscreen activities, but still required\n        // to be visible (such as performing Recents animation).\n        final boolean resumeTopActivity = mTop != null && !mTop.mLaunchTaskBehind\n                && mTaskFragment.isTopActivityFocusable()\n                && (starting == null || !starting.isDescendantOf(mTaskFragment));\n\n        ArrayList<TaskFragment> adjacentTaskFragments = null;\n        for (int i = mTaskFragment.mChildren.size() - 1; i >= 0; --i) {\n            final WindowContainer child = mTaskFragment.mChildren.get(i);\n            final TaskFragment childTaskFragment = child.asTaskFragment();\n            if (childTaskFragment != null && childTaskFragment.topRunningActivity() != null) {\n                childTaskFragment.updateActivityVisibilities(starting, configChanges,\n                        preserveWindows, notifyClients);\n                mBehindFullyOccludedContainer |=\n                        childTaskFragment.getBounds().equals(mTaskFragment.getBounds());\n                if (mAboveTop && mTop.getTaskFragment() == childTaskFragment) {\n                    mAboveTop = false;\n                }\n\n                if (mBehindFullyOccludedContainer) {\n                    continue;\n                }\n\n                if (adjacentTaskFragments != null && adjacentTaskFragments.contains(\n                        childTaskFragment)) {\n                    if (!childTaskFragment.isTranslucent(starting)\n                            && !childTaskFragment.getAdjacentTaskFragment().isTranslucent(\n                                    starting)) {\n                        // Everything behind two adjacent TaskFragments are occluded.\n                        mBehindFullyOccludedContainer = true;\n                    }\n                    continue;\n                }\n\n                final TaskFragment adjacentTaskFrag = childTaskFragment.getAdjacentTaskFragment();\n                if (adjacentTaskFrag != null) {\n                    if (adjacentTaskFragments == null) {\n                        adjacentTaskFragments = new ArrayList<>();\n                    }\n                    adjacentTaskFragments.add(adjacentTaskFrag);\n                }\n            } else if (child.asActivityRecord() != null) {\n                setActivityVisibilityState(child.asActivityRecord(), starting, resumeTopActivity);\n            }\n        }\n    }",
  "func_after": "void process(@Nullable ActivityRecord starting, int configChanges, boolean preserveWindows,\n            boolean notifyClients) {\n        reset(starting, configChanges, preserveWindows, notifyClients);\n\n        if (DEBUG_VISIBILITY) {\n            Slog.v(TAG_VISIBILITY, \"ensureActivitiesVisible behind \" + mTop\n                    + \" configChanges=0x\" + Integer.toHexString(configChanges));\n        }\n        if (mTop != null && mTaskFragment.asTask() != null) {\n            // TODO(14709632): Check if this needed to be implemented in TaskFragment.\n            mTaskFragment.asTask().checkTranslucentActivityWaiting(mTop);\n        }\n\n        // We should not resume activities that being launched behind because these\n        // activities are actually behind other fullscreen activities, but still required\n        // to be visible (such as performing Recents animation).\n        final boolean resumeTopActivity = mTop != null && !mTop.mLaunchTaskBehind\n                && mTaskFragment.canBeResumed(starting)\n                && (starting == null || !starting.isDescendantOf(mTaskFragment));\n\n        ArrayList<TaskFragment> adjacentTaskFragments = null;\n        for (int i = mTaskFragment.mChildren.size() - 1; i >= 0; --i) {\n            final WindowContainer child = mTaskFragment.mChildren.get(i);\n            final TaskFragment childTaskFragment = child.asTaskFragment();\n            if (childTaskFragment != null && childTaskFragment.topRunningActivity() != null) {\n                childTaskFragment.updateActivityVisibilities(starting, configChanges,\n                        preserveWindows, notifyClients);\n                mBehindFullyOccludedContainer |=\n                        childTaskFragment.getBounds().equals(mTaskFragment.getBounds());\n                if (mAboveTop && mTop.getTaskFragment() == childTaskFragment) {\n                    mAboveTop = false;\n                }\n\n                if (mBehindFullyOccludedContainer) {\n                    continue;\n                }\n\n                if (adjacentTaskFragments != null && adjacentTaskFragments.contains(\n                        childTaskFragment)) {\n                    if (!childTaskFragment.isTranslucent(starting)\n                            && !childTaskFragment.getAdjacentTaskFragment().isTranslucent(\n                                    starting)) {\n                        // Everything behind two adjacent TaskFragments are occluded.\n                        mBehindFullyOccludedContainer = true;\n                    }\n                    continue;\n                }\n\n                final TaskFragment adjacentTaskFrag = childTaskFragment.getAdjacentTaskFragment();\n                if (adjacentTaskFrag != null) {\n                    if (adjacentTaskFragments == null) {\n                        adjacentTaskFragments = new ArrayList<>();\n                    }\n                    adjacentTaskFragments.add(adjacentTaskFrag);\n                }\n            } else if (child.asActivityRecord() != null) {\n                setActivityVisibilityState(child.asActivityRecord(), starting, resumeTopActivity);\n            }\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n void process(@Nullable ActivityRecord starting, int configChanges, boolean preserveWindows,\n             boolean notifyClients) {\n         reset(starting, configChanges, preserveWindows, notifyClients);\n \n         if (DEBUG_VISIBILITY) {\n             Slog.v(TAG_VISIBILITY, \"ensureActivitiesVisible behind \" + mTop\n                     + \" configChanges=0x\" + Integer.toHexString(configChanges));\n         }\n         if (mTop != null && mTaskFragment.asTask() != null) {\n             // TODO(14709632): Check if this needed to be implemented in TaskFragment.\n             mTaskFragment.asTask().checkTranslucentActivityWaiting(mTop);\n         }\n \n         // We should not resume activities that being launched behind because these\n         // activities are actually behind other fullscreen activities, but still required\n         // to be visible (such as performing Recents animation).\n         final boolean resumeTopActivity = mTop != null && !mTop.mLaunchTaskBehind\n-                && mTaskFragment.isTopActivityFocusable()\n+                && mTaskFragment.canBeResumed(starting)\n                 && (starting == null || !starting.isDescendantOf(mTaskFragment));\n \n         ArrayList<TaskFragment> adjacentTaskFragments = null;\n         for (int i = mTaskFragment.mChildren.size() - 1; i >= 0; --i) {\n             final WindowContainer child = mTaskFragment.mChildren.get(i);\n             final TaskFragment childTaskFragment = child.asTaskFragment();\n             if (childTaskFragment != null && childTaskFragment.topRunningActivity() != null) {\n                 childTaskFragment.updateActivityVisibilities(starting, configChanges,\n                         preserveWindows, notifyClients);\n                 mBehindFullyOccludedContainer |=\n                         childTaskFragment.getBounds().equals(mTaskFragment.getBounds());\n                 if (mAboveTop && mTop.getTaskFragment() == childTaskFragment) {\n                     mAboveTop = false;\n      ",
  "diff_source": "custom"
}