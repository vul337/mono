{
  "id": 979,
  "language": "Java",
  "commit_url": "https://github.com/Xilinx/RapidWright/commit/acbe05349dca765b184159fa114ea9875f50d0f7",
  "commit_sha": "acbe05349dca765b184159fa114ea9875f50d0f7",
  "commit_msg": "vuln-fix: Zip Slip Vulnerability (#536)\n\n* vuln-fix: Zip Slip Vulnerability\r\n\r\nThis fixes a Zip-Slip vulnerability.\r\n\r\nThis change does one of two things. This change either\r\n\r\n1. Inserts a guard to protect against Zip Slip.\r\nOR\r\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\r\n\r\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\r\nThe check is bypassed although `/outnot` is not under the `/out` directory.\r\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\r\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\r\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\r\n\r\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\r\nSeverity: High\r\nCVSSS: 7.4\r\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\r\n\r\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\r\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\r\n\r\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\r\n\r\nCo-authored-by: Moderne <team@moderne.io>\r\n\r\nSigned-off-by: Eddie Hung <eddie.hung@amd.com>\r\n\r\nConflicts:\r\n\ttest/RapidWrightDCP\r\n\r\n* Update src/com/xilinx/rapidwright/util/Installer.java\r\n\r\nSigned-off-by: Chris Lavin <chris.lavin@xilinx.com>\r\n\r\nSigned-off-by: Chris Lavin <chris.lavin@xilinx.com>\r\nCo-authored-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\r\nCo-authored-by: Chris Lavin <clavin@xilinx.com>",
  "pr_url": "https://github.com/Xilinx/RapidWright/pull/536",
  "pr_info": "Supersedes https://github.com/Xilinx/RapidWright/pull/487 since that doesn't apply cleanly anymore.\r\n\r\n-----\r\n\r\nThis fixes a Zip-Slip vulnerability.\r\n\r\nThis change does one of two things. This change either\r\n\r\n1. Inserts a guard to protect against Zip Slip. OR\r\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\r\n\r\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`. The check is bypassed although `/outnot` is not under the `/out` directory. It's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object. For example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`; however, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\r\n\r\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') Severity: High\r\nCVSSS: 7.4\r\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\r\n\r\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\r\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\r\n\r\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\r\n\r\nCo-authored-by: Moderne <team@moderne.io>\r\n\r\nSigned-off-by: Eddie Hung <eddie.hung@amd.com>\r\n\r\nConflicts:\r\n\ttest/RapidWrightDCP",
  "file_name": "src/com/xilinx/rapidwright/util/Installer.java",
  "func_name": "unzipFile",
  "func_before": "public static void unzipFile(String zipFile, String destDir) {\n        File dir = new File(destDir);\n        // create output directory if it doesn't exist\n        if(!dir.exists()) dir.mkdirs();\n        \n        //buffer for read and write data to file\n        byte[] buffer = new byte[1024];\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {\n            ZipEntry ze = zis.getNextEntry();\n            while(ze != null){\n                String fileName = ze.getName();\n                File newFile = new File(destDir + File.separator + fileName);\n                System.out.println(\"Unzipping to \"+newFile.getAbsolutePath());\n                \n                if(ze.isDirectory()){\n                \tnewFile.mkdirs();\n                }else{\n                \tnew File(newFile.getParent()).mkdirs();\n                \t FileOutputStream fos = new FileOutputStream(newFile);\n                     int len;\n                     while ((len = zis.read(buffer)) > 0) {\n                     fos.write(buffer, 0, len);\n                     }\n                     fos.close();\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n            zis.closeEntry();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }",
  "func_after": "public static void unzipFile(String zipFile, String destDir) {\n        File dir = new File(destDir);\n        // create output directory if it doesn't exist\n        if(!dir.exists()) dir.mkdirs();\n        \n        //buffer for read and write data to file\n        byte[] buffer = new byte[1024];\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {\n            ZipEntry ze = zis.getNextEntry();\n            while(ze != null){\n                String fileName = ze.getName();\n                File newFile = new File(destDir, fileName);\n                if(!newFile.toPath().normalize().startsWith(destDir)) {\n                    throw new RuntimeException(\"Bad zip entry\");\n                }\n                System.out.println(\"Unzipping to \"+newFile.getAbsolutePath());\n                \n                if(ze.isDirectory()){\n                \tnewFile.mkdirs();\n                }else{\n                \tnew File(newFile.getParent()).mkdirs();\n                \t FileOutputStream fos = new FileOutputStream(newFile);\n                     int len;\n                     while ((len = zis.read(buffer)) > 0) {\n                     fos.write(buffer, 0, len);\n                     }\n                     fos.close();\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n            zis.closeEntry();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public static void unzipFile(String zipFile, String destDir) {\n         File dir = new File(destDir);\n         // create output directory if it doesn't exist\n         if(!dir.exists()) dir.mkdirs();\n         \n         //buffer for read and write data to file\n         byte[] buffer = new byte[1024];\n         try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {\n             ZipEntry ze = zis.getNextEntry();\n             while(ze != null){\n                 String fileName = ze.getName();\n-                File newFile = new File(destDir + File.separator + fileName);\n+                File newFile = new File(destDir, fileName);\n+                if(!newFile.toPath().normalize().startsWith(destDir)) {\n+                    throw new RuntimeException(\"Bad zip entry\");\n+                }\n                 System.out.println(\"Unzipping to \"+newFile.getAbsolutePath());\n                 \n                 if(ze.isDirectory()){\n                 \tnewFile.mkdirs();\n                 }else{\n                 \tnew File(newFile.getParent()).mkdirs();\n                 \t FileOutputStream fos = new FileOutputStream(newFile);\n                      int len;\n                      while ((len = zis.read(buffer)) > 0) {\n                      fos.write(buffer, 0, len);\n                      }\n                      fos.close();\n                 }\n                 zis.closeEntry();\n                 ze = zis.getNextEntry();\n             }\n             zis.closeEntry();\n         } catch (IOException e) {\n             e.printStackTrace();\n         }\n     }",
  "diff_source": "custom"
}