{
  "id": 1231,
  "language": "Java",
  "commit_url": "https://github.com/omnirom/android_frameworks_base/commit/b0bcbce79c5db1571789fac107dfa356e0375c0f",
  "commit_sha": "b0bcbce79c5db1571789fac107dfa356e0375c0f",
  "commit_msg": "Lock down the ability to read from the locksettings database\n\nCurrently the getString(), getLong(), and getBoolean() methods of\nILockSettings don't require any permission by default.  There are some\nspecific database keys that they enforce ACCESS_KEYGUARD_SECURE_STORAGE\nfor, and some other keys that they enforce READ_CONTACTS for.  This is\nmuch too lenient, since it means that anything new that gets added to\nthe database is automatically readable without any permission.\n\nI've searched through the users of these methods as much as I can.\nVirtually all their callers are from SystemUI / Keyguard or Settings, or\nfrom system_server itself with a cleared calling identity, and therefore\nwould be fine with ACCESS_KEYGUARD_SECURE_STORAGE.  The only potential\nexception I found is the public API android.provider.Settings, which\nintentionally allows apps targeted to an old API level to read three\nLOCK_PATTERN_* settings.  I've kept these three settings unprotected.\n\nRegarding potential unsupported app usage, the non-SDK dashboards show\nno hits for any of the following, which should cover all relevant\n@UnsupportedAppUsage entry points:\n\n    * ILockSettings.getBoolean()\n    * ILockSettings.getLong()\n    * ILockSettings.getString()\n    * LockPatternUtils.getOwnerInfo()\n    * LockPatternUtils.getString()\n    * LockPatternUtils.isLockScreenDisabled()\n    * LockPatternUtils.isVisiblePatternEnabled()\n\nLOCK_SCREEN_OWNER_INFO and LOCK_SCREEN_OWNER_INFO_ENABLED are an\ninteresting case in that they were protected by READ_CONTACTS.  However,\nlooking at the change that added that code (commit 158fe19ff88e,\nhttp://ag/298629) and its associated bug, it seems that READ_CONTACTS\nwas just used because of the nature of the bug report: it was a security\nvulnerability report that was presented as apps being able to get\npersonal user information without the READ_CONTACTS permission.\n\nThat doesn't mean that READ_CONTACTS is the right permission, however.\nThe \"owner info\" is somewhat misnamed in that it isn't really owner\ninfo, but rather just the text configured in `Settings -> Display ->\nLock screen -> Add text on lock screen`.  So it can be any sort of\nfree-form text the user puts there.  It's only Settings and System UI /\nKeyguard that access this text.  It's also totally separate from the\nemergency information that can be configured via `Settings -> Safety &\nemergency`.  Thus, switching to ACCESS_KEYGUARD_SECURE_STORAGE (a\n\"system-only\" permission, instead of a permission that apps can get) for\nthe owner info seems like the right choice.\n\nAll in all, it's likely that this change is safe to make.  If an issue\narises, we can always relax the permission check for specific keys.\n\nBug: 156606120\nBug: 256170784\nTest: Tested setting PIN, rebooting, unlocking, changing PIN\nTest: Tested that \"Add text on lock screen\" still works\nTest: atest com.android.server.locksettings\nChange-Id: I574d6a3f29b6fc76d964ddd5e9e0f8e4c680084f",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/locksettings/LockSettingsService.java",
  "func_name": "getSeparateProfileChallengeEnabled",
  "func_before": "@Override\n    public boolean getSeparateProfileChallengeEnabled(int userId) {\n        checkReadPermission(SEPARATE_PROFILE_CHALLENGE_KEY, userId);\n        return getSeparateProfileChallengeEnabledInternal(userId);\n    }",
  "func_after": "@Override\n    public boolean getSeparateProfileChallengeEnabled(int userId) {\n        checkDatabaseReadPermission(SEPARATE_PROFILE_CHALLENGE_KEY, userId);\n        return getSeparateProfileChallengeEnabledInternal(userId);\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public boolean getSeparateProfileChallengeEnabled(int userId) {\n-        checkReadPermission(SEPARATE_PROFILE_CHALLENGE_KEY, userId);\n+        checkDatabaseReadPermission(SEPARATE_PROFILE_CHALLENGE_KEY, userId);\n         return getSeparateProfileChallengeEnabledInternal(userId);\n     }",
  "diff_source": "custom"
}