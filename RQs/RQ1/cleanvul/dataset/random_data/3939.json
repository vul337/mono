{
  "id": 3939,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/cc16eecae687912238ee6efbff71ad31e2bc414e",
  "commit_sha": "cc16eecae687912238ee6efbff71ad31e2bc414e",
  "commit_msg": "jbd2: fix use-after-free of transaction_t race\n\njbd2_journal_wait_updates() is called with j_state_lock held. But if\nthere is a commit in progress, then this transaction might get committed\nand freed via jbd2_journal_commit_transaction() ->\njbd2_journal_free_transaction(), when we release j_state_lock.\nSo check for journal->j_running_transaction everytime we release and\nacquire j_state_lock to avoid use-after-free issue.\n\nLink: https://lore.kernel.org/r/948c2fed518ae739db6a8f7f83f1d58b504f87d0.1644497105.git.ritesh.list@gmail.com\nFixes: 4f98186848707f53 (\"jbd2: refactor wait logic for transaction updates into a common function\")\nCc: stable@kernel.org\nReported-and-tested-by: syzbot+afa2ca5171d93e44b348@syzkaller.appspotmail.com\nReviewed-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Ritesh Harjani <riteshh@linux.ibm.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "fs/jbd2/transaction.c",
  "func_name": "jbd2_journal_wait_updates",
  "func_before": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\n\tif (!commit_transaction)\n\t\treturn;\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}",
  "func_after": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (1) {\n\t\t/*\n\t\t * Note that the running transaction can get freed under us if\n\t\t * this transaction is getting committed in\n\t\t * jbd2_journal_commit_transaction() ->\n\t\t * jbd2_journal_free_transaction(). This can only happen when we\n\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.\n\t\t * Hence we should everytime retrieve new j_running_transaction\n\t\t * value (after j_state_lock release acquire cycle), else it may\n\t\t * lead to use-after-free of old freed transaction.\n\t\t */\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n}",
  "diff_func": "--- func_before\n+++ func_after\n void jbd2_journal_wait_updates(journal_t *journal)\n {\n-\ttransaction_t *commit_transaction = journal->j_running_transaction;\n+\tDEFINE_WAIT(wait);\n \n-\tif (!commit_transaction)\n-\t\treturn;\n+\twhile (1) {\n+\t\t/*\n+\t\t * Note that the running transaction can get freed under us if\n+\t\t * this transaction is getting committed in\n+\t\t * jbd2_journal_commit_transaction() ->\n+\t\t * jbd2_journal_free_transaction(). This can only happen when we\n+\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.\n+\t\t * Hence we should everytime retrieve new j_running_transaction\n+\t\t * value (after j_state_lock release acquire cycle), else it may\n+\t\t * lead to use-after-free of old freed transaction.\n+\t\t */\n+\t\ttransaction_t *transaction = journal->j_running_transaction;\n \n+\t\tif (!transaction)\n+\t\t\tbreak;\n-\tspin_lock(&commit_transaction->t_handle_lock);\n-\twhile (atomic_read(&commit_transaction->t_updates)) {\n-\t\tDEFINE_WAIT(wait);\n \n+\t\tspin_lock(&transaction->t_handle_lock);\n \t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n-\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n+\t\t\t\tTASK_UNINTERRUPTIBLE);\n-\t\tif (atomic_read(&commit_transaction->t_updates)) {\n+\t\tif (!atomic_read(&transaction->t_updates)) {\n-\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n+\t\t\tspin_unlock(&transaction->t_handle_lock);\n+\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n+\t\t\tbreak;\n-\t\t\twrite_unlock(&journal->j_state_lock);\n-\t\t\tschedule();\n-\t\t\twrite_lock(&journal->j_state_lock);\n-\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n \t\t}\n+\t\tspin_unlock(&transaction->t_handle_lock);\n+\t\twrite_unlock(&journal->j_state_lock);\n+\t\tschedule();\n \t\tfinish_wait(&journal->j_wait_updates, &wait);\n+\t\twrite_lock(&journal->j_state_lock);\n \t}\n-\tspin_unlock(&commit_transaction->t_handle_lock);\n }",
  "diff_source": "custom"
}