{
  "id": 4689,
  "language": "C/C++",
  "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
  "commit_sha": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "commit_msg": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
  "pr_url": "https://github.com/libuv/libuv/pull/41",
  "pr_info": "R=@saghul\n\nThis breaks the fs_fstat test on Linux and only in the gyp build because neither _BSD_SOURCE, _SVID_SOURCE or _XOPEN_SOURCE seem to be defined.  Still investigating that.\n\n```\n$ out/Debug/run-tests fs_fstat fs_fstat\nAssertion failed in ../test/test-fs.c on line 1081: s->st_atim.tv_nsec == t.st_atim.tv_nsec\nAborted (core dumped)\n```\n",
  "file_name": "src/unix/process.c",
  "func_name": "uv__process_child_init",
  "func_before": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set\n         */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}",
  "func_after": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set\n         */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    /* When dropping privileges from root, the `setgroups` call will\n     * remove any extraneous groups. If we don't call this, then\n     * even though our uid has dropped, we may still have groups\n     * that enable us to do super-user things. This will fail if we\n     * aren't root, so don't bother checking the return value, this\n     * is just done as an optimistic privilege dropping function.\n     */\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void uv__process_child_init(const uv_process_options_t* options,\n                                    int stdio_count,\n                                    int (*pipes)[2],\n                                    int error_fd) {\n   int close_fd;\n   int use_fd;\n   int fd;\n \n   if (options->flags & UV_PROCESS_DETACHED)\n     setsid();\n \n   for (fd = 0; fd < stdio_count; fd++) {\n     close_fd = pipes[fd][0];\n     use_fd = pipes[fd][1];\n \n     if (use_fd < 0) {\n       if (fd >= 3)\n         continue;\n       else {\n         /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n          * set\n          */\n         use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n         close_fd = use_fd;\n \n         if (use_fd == -1) {\n         uv__write_int(error_fd, -errno);\n           perror(\"failed to open stdio\");\n           _exit(127);\n         }\n       }\n     }\n \n     if (fd == use_fd)\n       uv__cloexec(use_fd, 0);\n     else\n       dup2(use_fd, fd);\n \n     if (fd <= 2)\n       uv__nonblock(fd, 0);\n \n     if (close_fd != -1)\n       uv__close(close_fd);\n   }\n \n   for (fd = 0; fd < stdio_count; fd++) {\n     use_fd = pipes[fd][1];\n \n     if (use_fd >= 0 && fd != use_fd)\n       close(use_fd);\n   }\n \n   if (options->cwd != NULL && chdir(options->cwd)) {\n     uv__write_int(error_fd, -errno);\n     perror(\"chdir()\");\n     _exit(127);\n   }\n \n+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n+    /* When dropping privileges from root, the `setgroups` call will\n+     * remove any extraneous groups. If we don't call this, then\n+     * even though our uid has dropped, we may still have groups\n+     * that enable us to do super-user things. This will fail if we\n+     * aren't root, so don't bother checking the return value, this\n+     * is just done as an optimistic privilege dropping function.\n+     */\n+    SAVE_ERRNO(setgroups(0, NULL));\n+  }\n+\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     u",
  "diff_source": "custom"
}