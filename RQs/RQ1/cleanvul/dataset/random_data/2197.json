{
  "id": 2197,
  "language": "Java",
  "commit_url": "https://github.com/JetBrains/JetBrainsRuntime/commit/339a8b7c57fd685c630044c8d94d3655ade1badf",
  "commit_sha": "339a8b7c57fd685c630044c8d94d3655ade1badf",
  "commit_msg": "JBR-3623 SIGSEGV at [libawt_xawt] Java_sun_awt_X11GraphicsDevice_getConfigColormap\n\nThis fix addresses two possible causes of crashes:\n1. makeDefaultConfig() returning NULL. The fix is to die gracefully\ninstead of crashing in an attempt to de-reference the NULL pointer.\n\n2. A race condition when the number of screens change (this is only an\nissue with the number of xinerama screens; the number of X11 screens is\nstatic for the duration of the X session).\n\nThe race scenario: X11GraphisDevice.makeDefaultConfiguration() is called\non EDT so the call can race with X11GraphisDevice.invalidate() that\nre-sets the screen number of the device; the latter is invoked on the\n\"AWT-XAWT\" thread from X11GraphicsEnvironment.rebuildDevices(). So by\nthe time makeDefaultConfiguration() makes a native call with the\ndevice's current screen number, the x11Screens array maintained by the\nnative code could have become shorter. And the native methods like\nJava_sun_awt_X11GraphicsDevice_getConfigColormap() assume that the\nscreen number passed to them is always current and valid. The AWT lock\nonly protects against the changes during the native methods invocation,\nbut does not protect against them being called with an outdated screen\nnumber.\n\nThe fix is to eliminate the race by protecting X11GraphisDevice.screen\nwith the AWT lock.\n\n(cherry picked from commit 0b53cd291fac8c031f84ea1bdac23693e68f259e)\n(cherry picked from commit 3a15dfad37e57c124733a6360f008cfe61dd95ec)",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/java.desktop/unix/classes/sun/awt/X11GraphicsDevice.java",
  "func_name": "makeDefaultConfiguration",
  "func_before": "private void makeDefaultConfiguration() {\n        if (defaultConfig == null) {\n            int visNum = getConfigVisualId(0, screen);\n            if (X11GraphicsEnvironment.isGLXAvailable()) {\n                defaultConfig = GLXGraphicsConfig.getConfig(this, visNum);\n                if (X11GraphicsEnvironment.isGLXVerbose()) {\n                    if (defaultConfig != null) {\n                        System.out.print(\"OpenGL pipeline enabled\");\n                    } else {\n                        System.out.print(\"Could not enable OpenGL pipeline\");\n                    }\n                    System.out.println(\" for default config on screen \" +\n                                       screen);\n                }\n            }\n            if (defaultConfig == null) {\n                int depth = getConfigDepth(0, screen);\n                boolean doubleBuffer = false;\n                if (isDBESupported() && doubleBufferVisuals == null) {\n                    doubleBufferVisuals = new HashSet<>();\n                    getDoubleBufferVisuals(screen);\n                    doubleBuffer =\n                        doubleBufferVisuals.contains(Integer.valueOf(visNum));\n                }\n\n                if (X11GraphicsEnvironment.isXRenderAvailable()) {\n                    if (X11GraphicsEnvironment.isXRenderVerbose()) {\n                        System.out.println(\"XRender pipeline enabled\");\n                    }\n                    defaultConfig = XRGraphicsConfig.getConfig(this, visNum,\n                            depth, getConfigColormap(0, screen),\n                            doubleBuffer);\n                } else {\n                    defaultConfig = X11GraphicsConfig.getConfig(this, visNum,\n                                        depth, getConfigColormap(0, screen),\n                                        doubleBuffer);\n                }\n            }\n        }\n    }",
  "func_after": "private void makeDefaultConfiguration() {\n        if (defaultConfig == null) {\n            XToolkit.awtLock();\n            try {\n                // what if this was called after the screen number has changed\n                // and initNativeData() was called to re-set x11Screens, but before invalidate()\n                // was called to set the right this.screen?\n                // Then getConfigColormap() may get called with a wrong screen.\n                int visNum = getConfigVisualId(0, screen);\n                if (X11GraphicsEnvironment.isGLXAvailable()) {\n                    defaultConfig = GLXGraphicsConfig.getConfig(this, visNum);\n                    if (X11GraphicsEnvironment.isGLXVerbose()) {\n                        if (defaultConfig != null) {\n                            System.out.print(\"OpenGL pipeline enabled\");\n                        } else {\n                            System.out.print(\"Could not enable OpenGL pipeline\");\n                        }\n                        System.out.println(\" for default config on screen \" +\n                                screen);\n                    }\n                }\n                if (defaultConfig == null) {\n                    int depth = getConfigDepth(0, screen);\n                    boolean doubleBuffer = false;\n                    if (isDBESupported() && doubleBufferVisuals == null) {\n                        doubleBufferVisuals = new HashSet<>();\n                        getDoubleBufferVisuals(screen);\n                        doubleBuffer =\n                                doubleBufferVisuals.contains(Integer.valueOf(visNum));\n                    }\n\n                    if (X11GraphicsEnvironment.isXRenderAvailable()) {\n                        if (X11GraphicsEnvironment.isXRenderVerbose()) {\n                            System.out.println(\"XRender pipeline enabled\");\n                        }\n                        defaultConfig = XRGraphicsConfig.getConfig(this, visNum,\n                                depth, getConfigColormap(0, screen),\n                                doubleBuffer);\n                    } else {\n                        defaultConfig = X11GraphicsConfig.getConfig(this, visNum,\n                                depth, getConfigColormap(0, screen),\n                                doubleBuffer);\n                    }\n                }\n            } finally {\n                XToolkit.awtUnlock();\n            }\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n private void makeDefaultConfiguration() {\n         if (defaultConfig == null) {\n+            XToolkit.awtLock();\n+            try {\n+                // what if this was called after the screen number has changed\n+                // and initNativeData() was called to re-set x11Screens, but before invalidate()\n+                // was called to set the right this.screen?\n+                // Then getConfigColormap() may get called with a wrong screen.\n-            int visNum = getConfigVisualId(0, screen);\n+                int visNum = getConfigVisualId(0, screen);\n-            if (X11GraphicsEnvironment.isGLXAvailable()) {\n+                if (X11GraphicsEnvironment.isGLXAvailable()) {\n-                defaultConfig = GLXGraphicsConfig.getConfig(this, visNum);\n+                    defaultConfig = GLXGraphicsConfig.getConfig(this, visNum);\n-                if (X11GraphicsEnvironment.isGLXVerbose()) {\n+                    if (X11GraphicsEnvironment.isGLXVerbose()) {\n-                    if (defaultConfig != null) {\n+                        if (defaultConfig != null) {\n-                        System.out.print(\"OpenGL pipeline enabled\");\n+                            System.out.print(\"OpenGL pipeline enabled\");\n+                        } else {\n+                            System.out.print(\"Could not enable OpenGL pipeline\");\n+                        }\n+                        System.out.println(\" for default config on screen \" +\n+                                screen);\n+                    }\n+                }\n+                if (defaultConfig == null) {\n+                    int depth = getConfigDepth(0, screen);\n+                    boolean doubleBuffer = false;\n+                    if (isDBESupported() && doubleBufferVisuals == null) {\n+                        doubleBufferVisuals = new HashSet<>();\n+                        getDoubleBufferVisuals(screen);\n+                        doubleBuffer =\n+                                doubleBuff",
  "diff_source": "custom"
}