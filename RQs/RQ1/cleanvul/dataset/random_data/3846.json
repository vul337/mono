{
  "id": 3846,
  "language": "C/C++",
  "commit_url": "https://github.com/jsummers/imageworsener/commit/dc74009a3cbcbc51dd29b3856043754d3c107449",
  "commit_sha": "dc74009a3cbcbc51dd29b3856043754d3c107449",
  "commit_msg": "Fixed a GIF decoding bug (buffer overrun)\n\nFixes issues #9, #11",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/imagew-gif.c",
  "func_name": "iwgif_record_pixel",
  "func_before": "static void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n\t\tint offset)\n{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs /*,ys*/; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\t// ys = rctx->image_top + yi;\n\n\t// Check if the x-coordinate is on the screen.\n\tif(xs>=(size_t)rctx->screen_width) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}",
  "func_after": "static void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n\t\tint offset)\n{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs,ys; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\tys = rctx->image_top + yi;\n\n\t// Make sure the coordinate is within the image, and on the screen.\n\tif(yi>=(size_t)rctx->image_height) return;\n\tif(xs>=(size_t)rctx->screen_width) return;\n\tif(ys>=(size_t)rctx->screen_height) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n \t\tint offset)\n {\n \tstruct iw_image *img;\n \tunsigned int r,g,b,a;\n \tsize_t pixnum;\n \tsize_t xi,yi; // position in image coordinates\n-\tsize_t xs /*,ys*/; // position in screen coordinates\n+\tsize_t xs,ys; // position in screen coordinates\n \tiw_byte *ptr;\n \n \timg = rctx->img;\n \n \t// Figure out which pixel to set.\n \n \tpixnum = rctx->pixels_set + offset;\n \txi = pixnum%rctx->image_width;\n \tyi = pixnum/rctx->image_width;\n \txs = rctx->image_left + xi;\n-\t// ys = rctx->image_top + yi;\n+\tys = rctx->image_top + yi;\n \n-\t// Check if the x-coordinate is on the screen.\n+\t// Make sure the coordinate is within the image, and on the screen.\n+\tif(yi>=(size_t)rctx->image_height) return;\n \tif(xs>=(size_t)rctx->screen_width) return;\n+\tif(ys>=(size_t)rctx->screen_height) return;\n \n \t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n \t// is on the screen. The easiest way is to check if the row pointer is NULL.\n \tif(rctx->row_pointers[yi]==NULL) return;\n \n \t// Figure out what color to set the pixel to.\n \n \tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n \t\tr=rctx->colortable.entry[coloridx].r;\n \t\tg=rctx->colortable.entry[coloridx].g;\n \t\tb=rctx->colortable.entry[coloridx].b;\n \t\ta=rctx->colortable.entry[coloridx].a;\n \t}\n \telse {\n \t\treturn; // Illegal palette index\n \t}\n \n \t// Set the pixel.\n \n \tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n \tptr[0]=r; ptr[1]=g; ptr[2]=b;\n \tif(img->imgtype==IW_IMGTYPE_RGBA) {\n \t\tptr[3]=a;\n \t}\n }",
  "diff_source": "custom"
}