{
  "id": 6915,
  "language": "Python",
  "commit_url": "https://github.com/nautobot/nautobot/commit/362850f5a94689a4c75e3188bf6de826c3b012b2",
  "commit_sha": "362850f5a94689a4c75e3188bf6de826c3b012b2",
  "commit_msg": "[1.6] Fix unsafe `mark_safe` use in various features (#4833)\n\n* Audit all uses of mark_safe() and change to format_html() where appropriate\r\n\r\n* Test updates and change fragment\r\n\r\n* Add ruff for linting, add S308 disables to audited code\r\n\r\n* Test fixes\r\n\r\n* Update change fragments\r\n\r\n* One more change fragment\r\n\r\n* add get_absolute_url check back to handle_protectederror\r\n\r\n* fix ruff\r\n\r\n---------",
  "pr_url": "https://github.com/nautobot/nautobot/pull/6703",
  "pr_info": "# What's Changed\r\n\r\nDirect cross-port of #6672 to LTM 1.6 branch.",
  "file_name": "nautobot/extras/models/relationships.py",
  "func_name": "required_related_objects_errors",
  "func_before": "def required_related_objects_errors(\n        cls, output_for=\"ui\", initial_data=None, relationships_key_specified=False, instance=None\n    ):\n        \"\"\"\n        Args:\n            output_for: either \"ui\" or \"api\" depending on usage\n            initial_data: submitted form/serializer data to validate against\n            relationships_key_specified: if the \"relationships\" key was provided or not\n            instance: an optional model instance to validate against\n        Returns:\n            List of field error dicts if any are found\n        \"\"\"\n\n        required_relationships = Relationship.objects.get_required_for_model(cls)\n        relationships_field_errors = {}\n        for relation in required_relationships:\n            opposite_side = RelationshipSideChoices.OPPOSITE[relation.required_on]\n\n            if relation.skip_required(cls, opposite_side):\n                continue\n\n            if relation.has_many(opposite_side):\n                num_required_verbose = \"at least one\"\n            else:\n                num_required_verbose = \"a\"\n\n            if output_for == \"api\":\n                # If this is a model instance and the relationships json data key is missing, check to see if\n                # required relationship associations already exist, and continue (ignore validation) if so\n                if (\n                    getattr(instance, \"present_in_database\", False) is True\n                    and initial_data.get(relation, {}).get(opposite_side, {}) == {}\n                    and not relationships_key_specified\n                ):\n                    filter_kwargs = {\"relationship\": relation, f\"{relation.required_on}_id\": instance.pk}\n                    if RelationshipAssociation.objects.filter(**filter_kwargs).exists():\n                        continue\n\n            required_model_class = getattr(relation, f\"{opposite_side}_type\").model_class()\n            required_model_meta = required_model_class._meta\n            cr_field_name = f\"cr_{relation.slug}__{opposite_side}\"\n            name_plural = cls._meta.verbose_name_plural\n            field_key = relation.slug if output_for == \"api\" else cr_field_name\n            field_errors = {field_key: []}\n\n            if not required_model_class.objects.exists():\n                hint = (\n                    f\"You need to create {num_required_verbose} {required_model_meta.verbose_name} \"\n                    f\"before instantiating a {cls._meta.verbose_name}.\"\n                )\n\n                if output_for == \"ui\":\n                    try:\n                        add_url = reverse(get_route_for_model(required_model_class, \"add\"))\n                        hint = (\n                            f\"<a target='_blank' href='{add_url}'>Click here</a> to create \"\n                            f\"a {required_model_meta.verbose_name}.\"\n                        )\n                    except NoReverseMatch:\n                        pass\n\n                elif output_for == \"api\":\n                    try:\n                        api_post_url = reverse(get_route_for_model(required_model_class, \"list\", api=True))\n                        hint = f\"Create a {required_model_meta.verbose_name} by posting to {api_post_url}\"\n                    except NoReverseMatch:\n                        pass\n\n                error_message = mark_safe(\n                    f\"{name_plural[0].upper()}{name_plural[1:]} require \"\n                    f\"{num_required_verbose} {required_model_meta.verbose_name}, but no \"\n                    f\"{required_model_meta.verbose_name_plural} exist yet. {hint}\"\n                )\n                field_errors[field_key].append(error_message)\n\n            if initial_data is not None:\n                supplied_data = []\n\n                if output_for == \"ui\":\n                    supplied_data = initial_data.get(field_key, [])\n\n                elif output_for == \"api\":\n                    supplied_data = initial_data.get(relation, {}).get(opposite_side, {})\n\n                if not supplied_data:\n                    if output_for == \"ui\":\n                        field_errors[field_key].append(\n                            f\"You need to select {num_required_verbose} {required_model_meta.verbose_name}.\"\n                        )\n                    elif output_for == \"api\":\n                        field_errors[field_key].append(\n                            f'You need to specify [\"relationships\"][\"{relation.slug}\"][\"{opposite_side}\"][\"objects\"].'\n                        )\n\n            if len(field_errors[field_key]) > 0:\n                relationships_field_errors[field_key] = field_errors[field_key]\n\n        return relationships_field_errors",
  "func_after": "def required_related_objects_errors(\n        cls, output_for=\"ui\", initial_data=None, relationships_key_specified=False, instance=None\n    ):\n        \"\"\"\n        Args:\n            output_for: either \"ui\" or \"api\" depending on usage\n            initial_data: submitted form/serializer data to validate against\n            relationships_key_specified: if the \"relationships\" key was provided or not\n            instance: an optional model instance to validate against\n        Returns:\n            List of field error dicts if any are found\n        \"\"\"\n\n        required_relationships = Relationship.objects.get_required_for_model(cls)\n        relationships_field_errors = {}\n        for relation in required_relationships:\n            opposite_side = RelationshipSideChoices.OPPOSITE[relation.required_on]\n\n            if relation.skip_required(cls, opposite_side):\n                continue\n\n            if relation.has_many(opposite_side):\n                num_required_verbose = \"at least one\"\n            else:\n                num_required_verbose = \"a\"\n\n            if output_for == \"api\":\n                # If this is a model instance and the relationships json data key is missing, check to see if\n                # required relationship associations already exist, and continue (ignore validation) if so\n                if (\n                    getattr(instance, \"present_in_database\", False) is True\n                    and initial_data.get(relation, {}).get(opposite_side, {}) == {}\n                    and not relationships_key_specified\n                ):\n                    filter_kwargs = {\"relationship\": relation, f\"{relation.required_on}_id\": instance.pk}\n                    if RelationshipAssociation.objects.filter(**filter_kwargs).exists():\n                        continue\n\n            required_model_class = getattr(relation, f\"{opposite_side}_type\").model_class()\n            required_model_meta = required_model_class._meta\n            cr_field_name = f\"cr_{relation.slug}__{opposite_side}\"\n            name_plural = cls._meta.verbose_name_plural\n            field_key = relation.slug if output_for == \"api\" else cr_field_name\n            field_errors = {field_key: []}\n\n            if not required_model_class.objects.exists():\n                hint = (\n                    f\"You need to create {num_required_verbose} {required_model_meta.verbose_name} \"\n                    f\"before instantiating a {cls._meta.verbose_name}.\"\n                )\n\n                if output_for == \"ui\":\n                    try:\n                        add_url = reverse(get_route_for_model(required_model_class, \"add\"))\n                        hint = format_html(\n                            '<a target=\"_blank\" href=\"{}\">Click here</a> to create a {}.',\n                            add_url,\n                            required_model_meta.verbose_name,\n                        )\n                    except NoReverseMatch:\n                        pass\n\n                elif output_for == \"api\":\n                    try:\n                        api_post_url = reverse(get_route_for_model(required_model_class, \"list\", api=True))\n                        hint = f\"Create a {required_model_meta.verbose_name} by posting to {api_post_url}\"\n                    except NoReverseMatch:\n                        pass\n\n                error_message = format_html(\n                    \"{} require {} {}, but no {} exist yet. \",\n                    bettertitle(name_plural),\n                    num_required_verbose,\n                    required_model_meta.verbose_name,\n                    required_model_meta.verbose_name_plural,\n                )\n                error_message += hint\n                field_errors[field_key].append(error_message)\n\n            if initial_data is not None:\n                supplied_data = []\n\n                if output_for == \"ui\":\n                    supplied_data = initial_data.get(field_key, [])\n\n                elif output_for == \"api\":\n                    supplied_data = initial_data.get(relation, {}).get(opposite_side, {})\n\n                if not supplied_data:\n                    if output_for == \"ui\":\n                        field_errors[field_key].append(\n                            f\"You need to select {num_required_verbose} {required_model_meta.verbose_name}.\"\n                        )\n                    elif output_for == \"api\":\n                        field_errors[field_key].append(\n                            f'You need to specify [\"relationships\"][\"{relation.slug}\"][\"{opposite_side}\"][\"objects\"].'\n                        )\n\n            if len(field_errors[field_key]) > 0:\n                relationships_field_errors[field_key] = field_errors[field_key]\n\n        return relationships_field_errors",
  "diff_func": "--- func_before\n+++ func_after\n def required_related_objects_errors(\n         cls, output_for=\"ui\", initial_data=None, relationships_key_specified=False, instance=None\n     ):\n         \"\"\"\n         Args:\n             output_for: either \"ui\" or \"api\" depending on usage\n             initial_data: submitted form/serializer data to validate against\n             relationships_key_specified: if the \"relationships\" key was provided or not\n             instance: an optional model instance to validate against\n         Returns:\n             List of field error dicts if any are found\n         \"\"\"\n \n         required_relationships = Relationship.objects.get_required_for_model(cls)\n         relationships_field_errors = {}\n         for relation in required_relationships:\n             opposite_side = RelationshipSideChoices.OPPOSITE[relation.required_on]\n \n             if relation.skip_required(cls, opposite_side):\n                 continue\n \n             if relation.has_many(opposite_side):\n                 num_required_verbose = \"at least one\"\n             else:\n                 num_required_verbose = \"a\"\n \n             if output_for == \"api\":\n                 # If this is a model instance and the relationships json data key is missing, check to see if\n                 # required relationship associations already exist, and continue (ignore validation) if so\n                 if (\n                     getattr(instance, \"present_in_database\", False) is True\n                     and initial_data.get(relation, {}).get(opposite_side, {}) == {}\n                     and not relationships_key_specified\n                 ):\n                     filter_kwargs = {\"relationship\": relation, f\"{relation.required_on}_id\": instance.pk}\n                     if RelationshipAssociation.objects.filter(**filter_kwargs).exists():\n                         continue\n \n             required_model_class = getattr(relation, f\"{opposite_side}_type\").model_class()\n             required_model_meta = required_m",
  "diff_source": "custom"
}