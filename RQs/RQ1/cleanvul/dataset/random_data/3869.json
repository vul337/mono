{
  "id": 3869,
  "language": "C/C++",
  "commit_url": "https://github.com/libgit2/libgit2/commit/4ac39c76c0153d1ee6889a0984c39e97731684b2",
  "commit_sha": "4ac39c76c0153d1ee6889a0984c39e97731684b2",
  "commit_msg": "smart_pkt: verify packet length exceeds PKT_LEN_SIZE\n\nEach packet line in the Git protocol is prefixed by a four-byte\nlength of how much data will follow, which we parse in\n`git_pkt_parse_line`. The transmitted length can either be equal\nto zero in case of a flush packet or has to be at least of length\nfour, as it also includes the encoded length itself. Not\nchecking this may result in a buffer overflow as we directly pass\nthe length to functions which accept a `size_t` length as\nparameter.\n\nFix the issue by verifying that non-flush packets have at least a\nlength of `PKT_LEN_SIZE`.",
  "pr_url": "https://github.com/libgit2/libgit2/pull/4075",
  "pr_info": "This fixes a buffer boundary check error and a certificate validity check which can be bogus under certain conditions.",
  "file_name": "src/transports/smart_pkt.c",
  "func_name": "git_pkt_parse_line",
  "func_before": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
  "func_after": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int git_pkt_parse_line(\n \tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n {\n \tint ret;\n \tint32_t len;\n \n \t/* Not even enough for the length */\n \tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n \t\treturn GIT_EBUFS;\n \n \tlen = parse_len(line);\n \tif (len < 0) {\n \t\t/*\n \t\t * If we fail to parse the length, it might be because the\n \t\t * server is trying to send us the packfile already.\n \t\t */\n \t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n \t\t\tgiterr_clear();\n \t\t\t*out = line;\n \t\t\treturn pack_pkt(head);\n \t\t}\n \n \t\treturn (int)len;\n \t}\n \n \t/*\n \t * If we were given a buffer length, then make sure there is\n \t * enough in the buffer to satisfy this line\n \t */\n \tif (bufflen > 0 && bufflen < (size_t)len)\n \t\treturn GIT_EBUFS;\n+\n+\t/*\n+\t * The length has to be exactly 0 in case of a flush\n+\t * packet or greater than PKT_LEN_SIZE, as the decoded\n+\t * length includes its own encoded length of four bytes.\n+\t */\n+\tif (len != 0 && len < PKT_LEN_SIZE)\n+\t\treturn GIT_ERROR;\n \n \tline += PKT_LEN_SIZE;\n \t/*\n \t * TODO: How do we deal with empty lines? Try again? with the next\n \t * line?\n \t */\n \tif (len == PKT_LEN_SIZE) {\n \t\t*head = NULL;\n \t\t*out = line;\n \t\treturn 0;\n \t}\n \n \tif (len == 0) { /* Flush pkt */\n \t\t*out = line;\n \t\treturn flush_pkt(head);\n \t}\n \n \tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n \n \tif (*line == GIT_SIDE_BAND_DATA)\n \t\tret = data_pkt(head, line, len);\n \telse if (*line == GIT_SIDE_BAND_PROGRESS)\n \t\tret = sideband_progress_pkt(head, line, len);\n \telse if (*line == GIT_SIDE_BAND_ERROR)\n \t\tret = sideband_error_pkt(head, line, len);\n \telse if (!git__prefixcmp(line, \"ACK\"))\n \t\tret = ack_pkt(head, line, len);\n \telse if (!git__prefixcmp(line, \"NAK\"))\n \t\tret = nak_pkt(head);\n \telse if (!git__prefixcmp(line, \"ERR \"))\n \t\tret = err_pkt(head, line, len);\n \telse if (*line == '#')\n \t\tret = comment_pkt(head, line, len);\n \telse if (!git__prefixcmp(line, \"ok\"))\n \t\tret = ok_pkt(head, line, len);\n \telse if (!git__pref",
  "diff_source": "custom"
}