{
  "id": 6888,
  "language": "C/C++",
  "commit_url": "https://github.com/LibRaw/LibRaw/commit/11909cc59e712e09b508dda729b99aeaac2b29ad",
  "commit_sha": "11909cc59e712e09b508dda729b99aeaac2b29ad",
  "commit_msg": "cumulated data checks patch",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "dcraw/dcraw.c",
  "func_name": "lossless_jpeg_load_raw",
  "func_before": "void CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jrow, jcol, val, i, row=0, col=0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  int jidx,j;\n#endif\n  struct jhead jh;\n  ushort *rp;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int save_min = 0;\n  unsigned slicesW[16],slicesWcnt=0,slices;\n  unsigned *offset;\n  unsigned t_y=0,t_x=0,t_s=0,slice=0,pixelsInSlice,pixno;\n  if (!strcasecmp(make,\"KODAK\"))\n      save_min = 1;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (cr2_slice[0]>15)\n      throw LIBRAW_EXCEPTION_IO_EOF; // change many slices\n#else\n  if (cr2_slice[0]>15)\n  {\n      fprintf(stderr,\"Too many CR2 slices: %d\\n\",cr2_slice[0]+1);\n      return;\n  }\n#endif\n\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = jh.wide * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(cr2_slice[0])\n      {\n          for(i=0;i<cr2_slice[0];i++)\n              slicesW[slicesWcnt++] = cr2_slice[1];\n          slicesW[slicesWcnt++] = cr2_slice[2];\n      }\n  else\n      {\n          // not sliced\n          slicesW[slicesWcnt++] = raw_width; // safe fallback\n      }\n       \n  slices = slicesWcnt * jh.high;\n  offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n\n  for(slice=0;slice<slices;slice++)\n      {\n          offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n          if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n              throw LIBRAW_EXCEPTION_IO_BADFILE; \n          t_y++;\n          if(t_y == jh.high)\n              {\n                  t_y = 0;\n                  t_x += slicesW[t_s++];\n              }\n      }\n  offset[slices] = offset[slices-1];\n  slice = 1; // next slice\n  pixno = offset[0]; \n  pixelsInSlice = slicesW[0];\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (buf)\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n      else\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n#ifndef LIBRAW_LIBRARY_BUILD\n      // slow dcraw way to calculate row/col\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*jh.high);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*jh.high);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n#else\n      // new fast one, but for data_size defined only (i.e. new CR2 format, not 1D/1Ds)\n      if(buf) \n          {\n              if(!(load_flags & 1))\n                  row = pixno/raw_width;\n              col = pixno % raw_width;\n              pixno++;\n              if (0 == --pixelsInSlice)\n                  {\n                      unsigned o = offset[slice++];\n                      pixno = o & 0x0fffffff;\n                      pixelsInSlice = slicesW[o>>28];\n                  }\n          }\n#endif\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if (row >= 0) RAW(row,col) = val;\n#ifndef LIBRAW_LIBRARY_BUILD\n      if (++col >= raw_width)\n\tcol = (row++,0);\n#else\n      if(!buf) // 1D or 1Ds case\n         if (++col >= raw_width)\n            col = (row++,0);\n#endif\n    }\n  }\n  ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf)\n      delete buf;\n  free(offset);\n#endif\n}",
  "func_after": "void CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jrow, jcol, val, i, row=0, col=0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  int jidx,j;\n#endif\n  struct jhead jh;\n  ushort *rp;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int save_min = 0;\n  unsigned slicesW[16],slicesWcnt=0,slices;\n  unsigned *offset;\n  unsigned t_y=0,t_x=0,t_s=0,slice=0,pixelsInSlice,pixno;\n  if (!strcasecmp(make,\"KODAK\"))\n      save_min = 1;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (cr2_slice[0]>15)\n      throw LIBRAW_EXCEPTION_IO_EOF; // change many slices\n#else\n  if (cr2_slice[0]>15)\n  {\n      fprintf(stderr,\"Too many CR2 slices: %d\\n\",cr2_slice[0]+1);\n      return;\n  }\n#endif\n\n  if (!ljpeg_start (&jh, 0)) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  jwide = jh.wide * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(cr2_slice[0])\n      {\n          for(i=0;i<cr2_slice[0];i++)\n              slicesW[slicesWcnt++] = cr2_slice[1];\n          slicesW[slicesWcnt++] = cr2_slice[2];\n      }\n  else\n      {\n          // not sliced\n          slicesW[slicesWcnt++] = raw_width; // safe fallback\n      }\n       \n  slices = slicesWcnt * jh.high;\n  if(!slices)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n\n  for(slice=0;slice<slices;slice++)\n      {\n          offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n          if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n            {\n              free(offset);\n              throw LIBRAW_EXCEPTION_IO_BADFILE; \n            }\n          t_y++;\n          if(t_y == jh.high)\n              {\n                  t_y = 0;\n                  t_x += slicesW[t_s++];\n              }\n      }\n  offset[slices] = offset[slices-1];\n  slice = 1; // next slice\n  pixno = offset[0]; \n  pixelsInSlice = slicesW[0];\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  LibRaw_byte_buffer *buf=NULL;\n  if(data_size)\n      buf = ifp->make_byte_buffer(data_size);\n  LibRaw_bit_buffer bits;\n#endif\n\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (buf)\n          rp = ljpeg_row_new (jrow, &jh,bits,buf);\n      else\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n#ifndef LIBRAW_LIBRARY_BUILD\n      // slow dcraw way to calculate row/col\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*jh.high);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*jh.high);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n#else\n      // new fast one, but for data_size defined only (i.e. new CR2 format, not 1D/1Ds)\n      if(buf) \n          {\n              if(!(load_flags & 1))\n                  row = pixno/raw_width;\n              col = pixno % raw_width;\n              pixno++;\n              if (0 == --pixelsInSlice)\n                  {\n                    if(slice > slices)\n                      {\n                        free(offset);\n                        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n                      }\n                      unsigned o = offset[slice++];\n                      pixno = o & 0x0fffffff;\n                      pixelsInSlice = slicesW[o>>28];\n                  }\n          }\n#endif\n\n      if(row>raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        free(offset);\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n#else\n        longjmp (failure, 3);\n#endif\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if (row >= 0) RAW(row,col) = val;\n#ifndef LIBRAW_LIBRARY_BUILD\n      if (++col >= raw_width)\n\tcol = (row++,0);\n#else\n      if(!buf) // 1D or 1Ds case\n         if (++col >= raw_width)\n            col = (row++,0);\n#endif\n    }\n  }\n  ljpeg_end (&jh);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(buf)\n      delete buf;\n  free(offset);\n#endif\n}",
  "diff_func": "--- func_before\n+++ func_after\n void CLASS lossless_jpeg_load_raw()\n {\n   int jwide, jrow, jcol, val, i, row=0, col=0;\n #ifndef LIBRAW_LIBRARY_BUILD\n   int jidx,j;\n #endif\n   struct jhead jh;\n   ushort *rp;\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   int save_min = 0;\n   unsigned slicesW[16],slicesWcnt=0,slices;\n   unsigned *offset;\n   unsigned t_y=0,t_x=0,t_s=0,slice=0,pixelsInSlice,pixno;\n   if (!strcasecmp(make,\"KODAK\"))\n       save_min = 1;\n #endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   if (cr2_slice[0]>15)\n       throw LIBRAW_EXCEPTION_IO_EOF; // change many slices\n #else\n   if (cr2_slice[0]>15)\n   {\n       fprintf(stderr,\"Too many CR2 slices: %d\\n\",cr2_slice[0]+1);\n       return;\n   }\n #endif\n \n-\n   if (!ljpeg_start (&jh, 0)) return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   jwide = jh.wide * jh.clrs;\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   if(cr2_slice[0])\n       {\n           for(i=0;i<cr2_slice[0];i++)\n               slicesW[slicesWcnt++] = cr2_slice[1];\n           slicesW[slicesWcnt++] = cr2_slice[2];\n       }\n   else\n       {\n           // not sliced\n           slicesW[slicesWcnt++] = raw_width; // safe fallback\n       }\n        \n   slices = slicesWcnt * jh.high;\n+  if(!slices)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n   offset = (unsigned*)calloc(slices+1,sizeof(offset[0]));\n \n   for(slice=0;slice<slices;slice++)\n       {\n           offset[slice] = (t_x + t_y * raw_width)| (t_s<<28);\n           if((offset[slice] & 0x0fffffff) >= raw_width * raw_height)\n+            {\n+              free(offset);\n               throw LIBRAW_EXCEPTION_IO_BADFILE; \n+            }\n           t_y++;\n           if(t_y == jh.high)\n               {\n                   t_y = 0;\n                   t_x += slicesW[t_s++];\n               }\n       }\n   offset[slices] = offset[slices-1];\n   slice = 1; // next slice\n   pixno = offset[0]; \n   pixelsInSlice = slicesW[0];\n #endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   LibR",
  "diff_source": "custom"
}