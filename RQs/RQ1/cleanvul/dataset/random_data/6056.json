{
  "id": 6056,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
  "commit_sha": "9c52057c698fb96f8f07e7a4bcf4801a092bda89",
  "commit_msg": "Btrfs: fix hash overflow handling\n\nThe handling for directory crc hash overflows was fairly obscure,\nsplit_leaf returns EOVERFLOW when we try to extend the item and that is\nsupposed to bubble up to userland.  For a while it did so, but along the\nway we added better handling of errors and forced the FS readonly if we\nhit IO errors during the directory insertion.\n\nAlong the way, we started testing only for EEXIST and the EOVERFLOW case\nwas dropped.  The end result is that we may force the FS readonly if we\ncatch a directory hash bucket overflow.\n\nThis fixes a few problem spots.  First I add tests for EOVERFLOW in the\nplaces where we can safely just return the error up the chain.\n\nbtrfs_rename is harder though, because it tries to insert the new\ndirectory item only after it has already unlinked anything the rename\nwas going to overwrite.  Rather than adding very complex logic, I added\na helper to test for the hash overflow case early while it is still safe\nto bail out.\n\nSnapshot and subvolume creation had a similar problem, so they are using\nthe new helper now too.\n\nSigned-off-by: Chris Mason <chris.mason@fusionio.com>\nReported-by: Pascal Junod <pascal@junod.info>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "fs/btrfs/inode.c",
  "func_name": "btrfs_add_link",
  "func_before": "int btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tbtrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}",
  "func_after": "int btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tbtrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST || ret == -EOVERFLOW)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int btrfs_add_link(struct btrfs_trans_handle *trans,\n \t\t   struct inode *parent_inode, struct inode *inode,\n \t\t   const char *name, int name_len, int add_backref, u64 index)\n {\n \tint ret = 0;\n \tstruct btrfs_key key;\n \tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n \tu64 ino = btrfs_ino(inode);\n \tu64 parent_ino = btrfs_ino(parent_inode);\n \n \tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n \t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n \t} else {\n \t\tkey.objectid = ino;\n \t\tbtrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);\n \t\tkey.offset = 0;\n \t}\n \n \tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n \t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n \t\t\t\t\t key.objectid, root->root_key.objectid,\n \t\t\t\t\t parent_ino, index, name, name_len);\n \t} else if (add_backref) {\n \t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n \t\t\t\t\t     parent_ino, index);\n \t}\n \n \t/* Nothing to clean up yet */\n \tif (ret)\n \t\treturn ret;\n \n \tret = btrfs_insert_dir_item(trans, root, name, name_len,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    btrfs_inode_type(inode), index);\n-\tif (ret == -EEXIST)\n+\tif (ret == -EEXIST || ret == -EOVERFLOW)\n \t\tgoto fail_dir_item;\n \telse if (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n \t\treturn ret;\n \t}\n \n \tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n \t\t\t   name_len * 2);\n \tinode_inc_iversion(parent_inode);\n \tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n \tret = btrfs_update_inode(trans, root, parent_inode);\n \tif (ret)\n \t\tbtrfs_abort_transaction(trans, root, ret);\n \treturn ret;\n \n fail_dir_item:\n \tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n \t\tu64 local_index;\n \t\tint err;\n \t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n \t\t\t\t key.objectid, root->root_key.objectid,\n \t\t\t\t parent_ino, &local_index, name, name_len);\n \n \t} else if (add_backref) {\n \t\tu64 local_index;\n \t\tint err;\n \n \t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n \t\t\t\t\t  ino, ",
  "diff_source": "custom"
}