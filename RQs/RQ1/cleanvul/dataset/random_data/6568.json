{
  "id": 6568,
  "language": "C/C++",
  "commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/7a923447fd49a069a0fd3b6c3547438ab5ee2123",
  "commit_sha": "7a923447fd49a069a0fd3b6c3547438ab5ee2123",
  "commit_msg": "CVE-2017-13001/NFS: Don't copy more data than is in the file handle.\n\nAlso, put the buffer on the stack; no reason to make it static.  (65\nbytes isn't a lot.)\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "print-nfs.c",
  "func_name": "nfs_printfh",
  "func_before": "static void\nnfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\n\t\t/* Make sure string is null-terminated */\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\t/* Remove trailing spaces */\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\t/* Print the undecoded handle */\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}",
  "func_after": "static void\nnfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tchar temp[NFSX_V3FHMAX+1];\n\t\tu_int stringlen;\n\n\t\t/* Make sure string is null-terminated */\n\t\tstringlen = len;\n\t\tif (stringlen > NFSX_V3FHMAX)\n\t\t\tstringlen = NFSX_V3FHMAX;\n\t\tstrncpy(temp, sfsname, stringlen);\n\t\ttemp[stringlen] = '\\0';\n\t\t/* Remove trailing spaces */\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\t/* Print the undecoded handle */\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void\n nfs_printfh(netdissect_options *ndo,\n             register const uint32_t *dp, const u_int len)\n {\n \tmy_fsid fsid;\n \tuint32_t ino;\n \tconst char *sfsname = NULL;\n \tchar *spacep;\n \n \tif (ndo->ndo_uflag) {\n \t\tu_int i;\n \t\tchar const *sep = \"\";\n \n \t\tND_PRINT((ndo, \" fh[\"));\n \t\tfor (i=0; i<len; i++) {\n \t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n \t\t\tsep = \":\";\n \t\t}\n \t\tND_PRINT((ndo, \"]\"));\n \t\treturn;\n \t}\n \n \tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n \n \tif (sfsname) {\n \t\t/* file system ID is ASCII, not numeric, for this server OS */\n-\t\tstatic char temp[NFSX_V3FHMAX+1];\n+\t\tchar temp[NFSX_V3FHMAX+1];\n+\t\tu_int stringlen;\n \n \t\t/* Make sure string is null-terminated */\n-\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n-\t\ttemp[sizeof(temp) - 1] = '\\0';\n+\t\tstringlen = len;\n+\t\tif (stringlen > NFSX_V3FHMAX)\n+\t\t\tstringlen = NFSX_V3FHMAX;\n+\t\tstrncpy(temp, sfsname, stringlen);\n+\t\ttemp[stringlen] = '\\0';\n \t\t/* Remove trailing spaces */\n \t\tspacep = strchr(temp, ' ');\n \t\tif (spacep)\n \t\t\t*spacep = '\\0';\n \n \t\tND_PRINT((ndo, \" fh %s/\", temp));\n \t} else {\n \t\tND_PRINT((ndo, \" fh %d,%d/\",\n \t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n \t}\n \n \tif(fsid.Fsid_dev.Minor == 257)\n \t\t/* Print the undecoded handle */\n \t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n \telse\n \t\tND_PRINT((ndo, \"%ld\", (long) ino));\n }",
  "diff_source": "custom"
}