{
  "id": 3844,
  "language": "C/C++",
  "commit_url": "https://github.com/systemd/systemd/commit/5de6cce58b3e8b79239b6e83653459d91af6e57c",
  "commit_sha": "5de6cce58b3e8b79239b6e83653459d91af6e57c",
  "commit_msg": "chown-recursive: let's rework the recursive logic to use O_PATH\n\nThat way we can pin a specific inode and analyze it and manipulate it\nwithout it being swapped out beneath our hands.\n\nFixes a vulnerability originally found by Jann Horn from Google.\n\nCVE-2018-15687\nLP: #1796692\nhttps://bugzilla.redhat.com/show_bug.cgi?id=1639076",
  "pr_url": "https://github.com/systemd/systemd/pull/10517",
  "pr_info": "no more info",
  "file_name": "src/core/chown-recursive.c",
  "func_name": "chown_recursive_internal",
  "func_before": "static int chown_recursive_internal(int fd, const struct stat *st, uid_t uid, gid_t gid) {\n        bool changed = false;\n        int r;\n\n        assert(fd >= 0);\n        assert(st);\n\n        if (S_ISDIR(st->st_mode)) {\n                _cleanup_closedir_ DIR *d = NULL;\n                struct dirent *de;\n\n                d = fdopendir(fd);\n                if (!d) {\n                        r = -errno;\n                        goto finish;\n                }\n                fd = -1;\n\n                FOREACH_DIRENT_ALL(de, d, r = -errno; goto finish) {\n                        struct stat fst;\n\n                        if (dot_or_dot_dot(de->d_name))\n                                continue;\n\n                        if (fstatat(dirfd(d), de->d_name, &fst, AT_SYMLINK_NOFOLLOW) < 0) {\n                                r = -errno;\n                                goto finish;\n                        }\n\n                        if (S_ISDIR(fst.st_mode)) {\n                                int subdir_fd;\n\n                                subdir_fd = openat(dirfd(d), de->d_name, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                                if (subdir_fd < 0) {\n                                        r = -errno;\n                                        goto finish;\n                                }\n\n                                r = chown_recursive_internal(subdir_fd, &fst, uid, gid);\n                                if (r < 0)\n                                        goto finish;\n                                if (r > 0)\n                                        changed = true;\n                        } else {\n                                r = chown_one(dirfd(d), de->d_name, &fst, uid, gid);\n                                if (r < 0)\n                                        goto finish;\n                                if (r > 0)\n                                        changed = true;\n                        }\n                }\n\n                r = chown_one(dirfd(d), NULL, st, uid, gid);\n        } else\n                r = chown_one(fd, NULL, st, uid, gid);\n        if (r < 0)\n                goto finish;\n\n        r = r > 0 || changed;\n\nfinish:\n        safe_close(fd);\n        return r;\n}",
  "func_after": "static int chown_recursive_internal(int fd, const struct stat *st, uid_t uid, gid_t gid) {\n        _cleanup_closedir_ DIR *d = NULL;\n        bool changed = false;\n        struct dirent *de;\n        int r;\n\n        assert(fd >= 0);\n        assert(st);\n\n        d = fdopendir(fd);\n        if (!d) {\n                safe_close(fd);\n                return -errno;\n        }\n\n        FOREACH_DIRENT_ALL(de, d, return -errno) {\n                _cleanup_close_ int path_fd = -1;\n                struct stat fst;\n\n                if (dot_or_dot_dot(de->d_name))\n                        continue;\n\n                /* Let's pin the child inode we want to fix now with an O_PATH fd, so that it cannot be swapped out\n                 * while we manipulate it. */\n                path_fd = openat(dirfd(d), de->d_name, O_PATH|O_CLOEXEC|O_NOFOLLOW);\n                if (path_fd < 0)\n                        return -errno;\n\n                if (fstat(path_fd, &fst) < 0)\n                        return -errno;\n\n                if (S_ISDIR(fst.st_mode)) {\n                        int subdir_fd;\n\n                        /* Convert it to a \"real\" (i.e. non-O_PATH) fd now */\n                        subdir_fd = fd_reopen(path_fd, O_RDONLY|O_CLOEXEC|O_NOATIME);\n                        if (subdir_fd < 0)\n                                return subdir_fd;\n\n                        r = chown_recursive_internal(subdir_fd, &fst, uid, gid); /* takes possession of subdir_fd even on failure */\n                        if (r < 0)\n                                return r;\n                        if (r > 0)\n                                changed = true;\n                } else {\n                        r = chown_one(path_fd, &fst, uid, gid);\n                        if (r < 0)\n                                return r;\n                        if (r > 0)\n                                changed = true;\n                }\n        }\n\n        r = chown_one(dirfd(d), st, uid, gid);\n        if (r < 0)\n                return r;\n\n        return r > 0 || changed;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int chown_recursive_internal(int fd, const struct stat *st, uid_t uid, gid_t gid) {\n+        _cleanup_closedir_ DIR *d = NULL;\n         bool changed = false;\n+        struct dirent *de;\n         int r;\n \n         assert(fd >= 0);\n         assert(st);\n \n-        if (S_ISDIR(st->st_mode)) {\n-                _cleanup_closedir_ DIR *d = NULL;\n-                struct dirent *de;\n+        d = fdopendir(fd);\n+        if (!d) {\n+                safe_close(fd);\n+                return -errno;\n+        }\n \n-                d = fdopendir(fd);\n+        FOREACH_DIRENT_ALL(de, d, return -errno) {\n+                _cleanup_close_ int path_fd = -1;\n+                struct stat fst;\n+\n+                if (dot_or_dot_dot(de->d_name))\n+                        continue;\n+\n+                /* Let's pin the child inode we want to fix now with an O_PATH fd, so that it cannot be swapped out\n+                 * while we manipulate it. */\n+                path_fd = openat(dirfd(d), de->d_name, O_PATH|O_CLOEXEC|O_NOFOLLOW);\n-                if (!d) {\n+                if (path_fd < 0)\n-                        r = -errno;\n+                        return -errno;\n+\n+                if (fstat(path_fd, &fst) < 0)\n+                        return -errno;\n+\n+                if (S_ISDIR(fst.st_mode)) {\n-                        goto finish;\n+                        int subdir_fd;\n+\n+                        /* Convert it to a \"real\" (i.e. non-O_PATH) fd now */\n+                        subdir_fd = fd_reopen(path_fd, O_RDONLY|O_CLOEXEC|O_NOATIME);\n+                        if (subdir_fd < 0)\n+                                return subdir_fd;\n+\n+                        r = chown_recursive_internal(subdir_fd, &fst, uid, gid); /* takes possession of subdir_fd even on failure */\n+                        if (r < 0)\n+                                return r;\n+                        if (r > 0)\n+                                changed = true;\n+                } else {\n+      ",
  "diff_source": "custom"
}