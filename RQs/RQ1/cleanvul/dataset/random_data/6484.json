{
  "id": 6484,
  "language": "C/C++",
  "commit_url": "https://github.com/OP-TEE/optee_os/commit/95f36d661f2b75887772ea28baaad904bde96970",
  "commit_sha": "95f36d661f2b75887772ea28baaad904bde96970",
  "commit_msg": "core: tee_mmu_check_access_rights() check all pages\n\nPrior to this patch tee_mmu_check_access_rights() checks an address in\neach page of a supplied range. If both the start and length of that\nrange is unaligned the last page in the range is sometimes not checked.\nWith this patch the first address of each page in the range is checked\nto simplify the logic of checking each page and the range and also to\ncover the last page under all circumstances.\n\nFixes: OP-TEE-2018-0005: \"tee_mmu_check_access_rights does not check\nfinal page of TA buffer\"\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/2745",
  "pr_info": "This patch series address a list of potential security issues and (lack of) hardening as identified by [Riscure](https://www.riscure.com/). More details about the issues themselves will be submitted to https://www.op-tee.org/security-advisories in the coming weeks. \r\n\r\nNote that patches here are already \"pre-reviewed\" (internally at Linaro) and the reason for that is that all patches have already been circulated to trustworthy stakeholders according to our disclosure plan (see the draft [here](https://optee.readthedocs.io/general/disclousure.html)). Having that said, we encourage OP-TEE maintainers and other users to chime in and do a final review here on GitHub.\r\n\r\nI've just rebased it on top of master and all tests in xtest passes. ",
  "file_name": "core/arch/arm/mm/tee_mmu.c",
  "func_name": "tee_mmu_check_access_rights",
  "func_before": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}",
  "func_after": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tuaddr_t end_addr = 0;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}",
  "diff_func": "--- func_before\n+++ func_after\n TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n \t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n+\tuaddr_t end_addr = 0;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n-\tif (ADD_OVERFLOW(uaddr, len, &a))\n+\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n \t    (flags & TEE_MEMORY_ACCESS_SECURE))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \t/*\n \t * Rely on TA private memory test to check if address range is private\n \t * to TA or not.\n \t */\n \tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n-\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n+\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n \t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n \t\tif (res != TEE_SUCCESS)\n \t\t\treturn res;\n \n \t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n \t\t    (attr & TEE_MATTR_SECURE))\n \t\t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n \t\t    !(attr & TEE_MATTR_SECURE))\n \t\t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n \t\t\treturn TEE_ERROR_ACCESS_DENIED;\n \t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n \t\t\treturn TEE_ERROR_ACCESS_DENIED;\n \t}\n \n \treturn TEE_SUCCESS;\n }",
  "diff_source": "custom"
}