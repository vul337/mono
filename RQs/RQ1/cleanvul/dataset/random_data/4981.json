{
  "id": 4981,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
  "commit_sha": "1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
  "commit_msg": "fscrypt: remove broken support for detecting keyring key revocation\n\nFilesystem encryption ostensibly supported revoking a keyring key that\nhad been used to \"unlock\" encrypted files, causing those files to become\n\"locked\" again.  This was, however, buggy for several reasons, the most\nsevere of which was that when key revocation happened to be detected for\nan inode, its fscrypt_info was immediately freed, even while other\nthreads could be using it for encryption or decryption concurrently.\nThis could be exploited to crash the kernel or worse.\n\nThis patch fixes the use-after-free by removing the code which detects\nthe keyring key having been revoked, invalidated, or expired.  Instead,\nan encrypted inode that is \"unlocked\" now simply remains unlocked until\nit is evicted from memory.  Note that this is no worse than the case for\nblock device-level encryption, e.g. dm-crypt, and it still remains\npossible for a privileged user to evict unused pages, inodes, and\ndentries by running 'sync; echo 3 > /proc/sys/vm/drop_caches', or by\nsimply unmounting the filesystem.  In fact, one of those actions was\nalready needed anyway for key revocation to work even somewhat sanely.\nThis change is not expected to break any applications.\n\nIn the future I'd like to implement a real API for fscrypt key\nrevocation that interacts sanely with ongoing filesystem operations ---\nwaiting for existing operations to complete and blocking new operations,\nand invalidating and sanitizing key material and plaintext from the VFS\ncaches.  But this is a hard problem, and for now this bug must be fixed.\n\nThis bug affected almost all versions of ext4, f2fs, and ubifs\nencryption, and it was potentially reachable in any kernel configured\nwith encryption support (CONFIG_EXT4_ENCRYPTION=y,\nCONFIG_EXT4_FS_ENCRYPTION=y, CONFIG_F2FS_FS_ENCRYPTION=y, or\nCONFIG_UBIFS_FS_ENCRYPTION=y).  Note that older kernels did not use the\nshared fs/crypto/ code, but due to the potential security implications\nof this bug, it may still be worthwhile to backport this fix to them.\n\nFixes: b7236e21d55f (\"ext4 crypto: reorganize how we store keys in the inode\")\nCc: stable@vger.kernel.org # v4.2+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nAcked-by: Michael Halcrow <mhalcrow@google.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "fs/crypto/keyinfo.c",
  "func_name": "fscrypt_get_encryption_info",
  "func_before": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}",
  "func_after": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *crypt_info;\n\tstruct fscrypt_context ctx;\n\tstruct crypto_skcipher *ctfm;\n\tconst char *cipher_str;\n\tint keysize;\n\tu8 *raw_key = NULL;\n\tint res;\n\n\tif (inode->i_crypt_info)\n\t\treturn 0;\n\n\tres = fscrypt_initialize(inode->i_sb->s_cop->flags);\n\tif (res)\n\t\treturn res;\n\n\tif (!inode->i_sb->s_cop->get_context)\n\t\treturn -EOPNOTSUPP;\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res < 0) {\n\t\tif (!fscrypt_dummy_context_enabled(inode) ||\n\t\t    inode->i_sb->s_cop->is_encrypted(inode))\n\t\t\treturn res;\n\t\t/* Fake up a context for an unencrypted directory */\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\t\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\t\tctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\n\t\tctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\n\t\tmemset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);\n\t} else if (res != sizeof(ctx)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)\n\t\treturn -EINVAL;\n\n\tif (ctx.flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tcrypt_info = kmem_cache_alloc(fscrypt_info_cachep, GFP_NOFS);\n\tif (!crypt_info)\n\t\treturn -ENOMEM;\n\n\tcrypt_info->ci_flags = ctx.flags;\n\tcrypt_info->ci_data_mode = ctx.contents_encryption_mode;\n\tcrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\n\tcrypt_info->ci_ctfm = NULL;\n\tmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\n\t\t\t\tsizeof(crypt_info->ci_master_key));\n\n\tres = determine_cipher_type(crypt_info, inode, &cipher_str, &keysize);\n\tif (res)\n\t\tgoto out;\n\n\t/*\n\t * This cannot be a stack buffer because it is passed to the scatterlist\n\t * crypto API as part of key derivation.\n\t */\n\tres = -ENOMEM;\n\traw_key = kmalloc(FS_MAX_KEY_SIZE, GFP_NOFS);\n\tif (!raw_key)\n\t\tgoto out;\n\n\tres = validate_user_key(crypt_info, &ctx, raw_key, FS_KEY_DESC_PREFIX);\n\tif (res && inode->i_sb->s_cop->key_prefix) {\n\t\tint res2 = validate_user_key(crypt_info, &ctx, raw_key,\n\t\t\t\t\t     inode->i_sb->s_cop->key_prefix);\n\t\tif (res2) {\n\t\t\tif (res2 == -ENOKEY)\n\t\t\t\tres = -ENOKEY;\n\t\t\tgoto out;\n\t\t}\n\t} else if (res) {\n\t\tgoto out;\n\t}\n\tctfm = crypto_alloc_skcipher(cipher_str, 0, 0);\n\tif (!ctfm || IS_ERR(ctfm)) {\n\t\tres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: error %d (inode %u) allocating crypto tfm\\n\",\n\t\t       __func__, res, (unsigned) inode->i_ino);\n\t\tgoto out;\n\t}\n\tcrypt_info->ci_ctfm = ctfm;\n\tcrypto_skcipher_clear_flags(ctfm, ~0);\n\tcrypto_skcipher_set_flags(ctfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tres = crypto_skcipher_setkey(ctfm, raw_key, keysize);\n\tif (res)\n\t\tgoto out;\n\n\tif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) == NULL)\n\t\tcrypt_info = NULL;\nout:\n\tif (res == -ENOKEY)\n\t\tres = 0;\n\tput_crypt_info(crypt_info);\n\tkzfree(raw_key);\n\treturn res;\n}",
  "diff_func": "--- func_before\n+++ func_after\n@@ -169 +162 @@\n+int fscrypt_get_encryption_info(struct inode *inode)\n {\n struct fscrypt_info *crypt_info;\n struct fscrypt_context ctx;",
  "diff_source": "api"
}