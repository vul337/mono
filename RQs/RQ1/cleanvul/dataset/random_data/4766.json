{
  "id": 4766,
  "language": "C/C++",
  "commit_url": "https://github.com/vim/vim/commit/870219c58c0804bdc55419b2e455c06ac715a835",
  "commit_sha": "870219c58c0804bdc55419b2e455c06ac715a835",
  "commit_msg": "patch 9.0.1247: divide by zero with 'smoothscroll' set and a narrow window\n\nProblem:    Divide by zero with 'smoothscroll' set and a narrow window.\nSolution:   Bail out when the window is too narrow.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/move.c",
  "func_name": "adjust_skipcol",
  "func_before": "void\nadjust_skipcol(void)\n{\n    if (!curwin->w_p_wrap\n\t    || !curwin->w_p_sms\n\t    || curwin->w_cursor.lnum != curwin->w_topline)\n\treturn;\n\n    int\t    width1 = curwin->w_width - curwin_col_off();\n    int\t    width2 = width1 + curwin_col_off2();\n    long    so = get_scrolloff_value();\n    int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n    int\t    scrolled = FALSE;\n\n    validate_cheight();\n    if (curwin->w_cline_height == curwin->w_height\n\t    // w_cline_height may be capped at w_height, check there aren't\n\t    // actually more lines.\n\t    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)\n\t\t\t\t\t\t\t   <= curwin->w_height)\n    {\n\t// the line just fits in the window, don't scroll\n\treset_skipcol();\n\treturn;\n    }\n\n    validate_virtcol();\n    while (curwin->w_skipcol > 0\n\t\t && curwin->w_virtcol < curwin->w_skipcol + 3 + scrolloff_cols)\n    {\n\t// scroll a screen line down\n\tif (curwin->w_skipcol >= width1 + width2)\n\t    curwin->w_skipcol -= width2;\n\telse\n\t    curwin->w_skipcol -= width1;\n\tredraw_later(UPD_NOT_VALID);\n\tscrolled = TRUE;\n\tvalidate_virtcol();\n    }\n    if (scrolled)\n\treturn;  // don't scroll in the other direction now\n\n    int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n    int row = 0;\n    if (col >= width1)\n    {\n\tcol -= width1;\n\t++row;\n    }\n    if (col > width2)\n    {\n\trow += col / width2;\n\tcol = col % width2;\n    }\n    if (row >= curwin->w_height)\n    {\n\tif (curwin->w_skipcol == 0)\n\t{\n\t    curwin->w_skipcol += width1;\n\t    --row;\n\t}\n\tif (row >= curwin->w_height)\n\t    curwin->w_skipcol += (row - curwin->w_height) * width2;\n\tredraw_later(UPD_NOT_VALID);\n    }\n}",
  "func_after": "void\nadjust_skipcol(void)\n{\n    if (!curwin->w_p_wrap\n\t    || !curwin->w_p_sms\n\t    || curwin->w_cursor.lnum != curwin->w_topline)\n\treturn;\n\n    int\t    width1 = curwin->w_width - curwin_col_off();\n    if (width1 <= 0)\n\treturn;  // no text will be displayed\n\n    int\t    width2 = width1 + curwin_col_off2();\n    long    so = get_scrolloff_value();\n    int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n    int\t    scrolled = FALSE;\n\n    validate_cheight();\n    if (curwin->w_cline_height == curwin->w_height\n\t    // w_cline_height may be capped at w_height, check there aren't\n\t    // actually more lines.\n\t    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)\n\t\t\t\t\t\t\t   <= curwin->w_height)\n    {\n\t// the line just fits in the window, don't scroll\n\treset_skipcol();\n\treturn;\n    }\n\n    validate_virtcol();\n    while (curwin->w_skipcol > 0\n\t\t && curwin->w_virtcol < curwin->w_skipcol + 3 + scrolloff_cols)\n    {\n\t// scroll a screen line down\n\tif (curwin->w_skipcol >= width1 + width2)\n\t    curwin->w_skipcol -= width2;\n\telse\n\t    curwin->w_skipcol -= width1;\n\tredraw_later(UPD_NOT_VALID);\n\tscrolled = TRUE;\n\tvalidate_virtcol();\n    }\n    if (scrolled)\n\treturn;  // don't scroll in the other direction now\n\n    int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n    int row = 0;\n    if (col >= width1)\n    {\n\tcol -= width1;\n\t++row;\n    }\n    if (col > width2)\n    {\n\trow += col / width2;\n\tcol = col % width2;\n    }\n    if (row >= curwin->w_height)\n    {\n\tif (curwin->w_skipcol == 0)\n\t{\n\t    curwin->w_skipcol += width1;\n\t    --row;\n\t}\n\tif (row >= curwin->w_height)\n\t    curwin->w_skipcol += (row - curwin->w_height) * width2;\n\tredraw_later(UPD_NOT_VALID);\n    }\n}",
  "diff_func": "--- func_before\n+++ func_after\n void\n adjust_skipcol(void)\n {\n     if (!curwin->w_p_wrap\n \t    || !curwin->w_p_sms\n \t    || curwin->w_cursor.lnum != curwin->w_topline)\n \treturn;\n \n     int\t    width1 = curwin->w_width - curwin_col_off();\n+    if (width1 <= 0)\n+\treturn;  // no text will be displayed\n+\n     int\t    width2 = width1 + curwin_col_off2();\n     long    so = get_scrolloff_value();\n     int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n     int\t    scrolled = FALSE;\n \n     validate_cheight();\n     if (curwin->w_cline_height == curwin->w_height\n \t    // w_cline_height may be capped at w_height, check there aren't\n \t    // actually more lines.\n \t    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)\n \t\t\t\t\t\t\t   <= curwin->w_height)\n     {\n \t// the line just fits in the window, don't scroll\n \treset_skipcol();\n \treturn;\n     }\n \n     validate_virtcol();\n     while (curwin->w_skipcol > 0\n \t\t && curwin->w_virtcol < curwin->w_skipcol + 3 + scrolloff_cols)\n     {\n \t// scroll a screen line down\n \tif (curwin->w_skipcol >= width1 + width2)\n \t    curwin->w_skipcol -= width2;\n \telse\n \t    curwin->w_skipcol -= width1;\n \tredraw_later(UPD_NOT_VALID);\n \tscrolled = TRUE;\n \tvalidate_virtcol();\n     }\n     if (scrolled)\n \treturn;  // don't scroll in the other direction now\n \n     int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n     int row = 0;\n     if (col >= width1)\n     {\n \tcol -= width1;\n \t++row;\n     }\n     if (col > width2)\n     {\n \trow += col / width2;\n \tcol = col % width2;\n     }\n     if (row >= curwin->w_height)\n     {\n \tif (curwin->w_skipcol == 0)\n \t{\n \t    curwin->w_skipcol += width1;\n \t    --row;\n \t}\n \tif (row >= curwin->w_height)\n \t    curwin->w_skipcol += (row - curwin->w_height) * width2;\n \tredraw_later(UPD_NOT_VALID);\n     }\n }",
  "diff_source": "custom"
}