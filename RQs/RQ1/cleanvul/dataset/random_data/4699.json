{
  "id": 4699,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd",
  "commit_sha": "096fe9eaea40a17e125569f9e657e34cdb6d73bd",
  "commit_msg": "KEYS: Fix handling of stored error in a negatively instantiated user key\n\nIf a user key gets negatively instantiated, an error code is cached in the\npayload area.  A negatively instantiated key may be then be positively\ninstantiated by updating it with valid data.  However, the ->update key\ntype method must be aware that the error code may be there.\n\nThe following may be used to trigger the bug in the user key type:\n\n    keyctl request2 user user \"\" @u\n    keyctl add user user \"a\" @u\n\nwhich manifests itself as:\n\n\tBUG: unable to handle kernel paging request at 00000000ffffff8a\n\tIP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046\n\tPGD 7cc30067 PUD 0\n\tOops: 0002 [#1] SMP\n\tModules linked in:\n\tCPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49\n\tHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n\ttask: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000\n\tRIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280\n\t [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046\n\tRSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246\n\tRAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001\n\tRDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82\n\tRBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000\n\tR10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82\n\tR13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700\n\tFS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000\n\tCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n\tCR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0\n\tStack:\n\t ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82\n\t ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5\n\t ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620\n\tCall Trace:\n\t [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136\n\t [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129\n\t [<     inline     >] __key_update security/keys/key.c:730\n\t [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908\n\t [<     inline     >] SYSC_add_key security/keys/keyctl.c:125\n\t [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60\n\t [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185\n\nNote the error code (-ENOKEY) in EDX.\n\nA similar bug can be tripped by:\n\n    keyctl request2 trusted user \"\" @u\n    keyctl add trusted user \"a\" @u\n\nThis should also affect encrypted keys - but that has to be correctly\nparameterised or it will fail with EINVAL before getting to the bit that\nwill crashes.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "security/keys/encrypted-keys/encrypted.c",
  "func_name": "encrypted_update",
  "func_before": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}",
  "func_after": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n \tstruct encrypted_key_payload *epayload = key->payload.data[0];\n \tstruct encrypted_key_payload *new_epayload;\n \tchar *buf;\n \tchar *new_master_desc = NULL;\n \tconst char *format = NULL;\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n \n \tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n \tif (!buf)\n \t\treturn -ENOMEM;\n \n \tbuf[datalen] = 0;\n \tmemcpy(buf, prep->data, datalen);\n \tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n \tif (ret < 0)\n \t\tgoto out;\n \n \tret = valid_master_desc(new_master_desc, epayload->master_desc);\n \tif (ret < 0)\n \t\tgoto out;\n \n \tnew_epayload = encrypted_key_alloc(key, epayload->format,\n \t\t\t\t\t   new_master_desc, epayload->datalen);\n \tif (IS_ERR(new_epayload)) {\n \t\tret = PTR_ERR(new_epayload);\n \t\tgoto out;\n \t}\n \n \t__ekey_init(new_epayload, epayload->format, new_master_desc,\n \t\t    epayload->datalen);\n \n \tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n \tmemcpy(new_epayload->payload_data, epayload->payload_data,\n \t       epayload->payload_datalen);\n \n \trcu_assign_keypointer(key, new_epayload);\n \tcall_rcu(&epayload->rcu, encrypted_rcu_free);\n out:\n \tkfree(buf);\n \treturn ret;\n }",
  "diff_source": "custom"
}