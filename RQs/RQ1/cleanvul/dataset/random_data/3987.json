{
  "id": 3987,
  "language": "C/C++",
  "commit_url": "https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd",
  "commit_sha": "57415dda6cf04e73ffc3723be518eddfae599bfd",
  "commit_msg": "Add recursion limit for ASN.1 indefinite lengths\n\nThe libkrb5 ASN.1 decoder supports BER indefinite lengths.  It\ncomputes the tag length using recursion; the lack of a recursion limit\nallows an attacker to overrun the stack and cause the process to\ncrash.  Reported by Demi Obenour.\n\nCVE-2020-28196:\n\nIn MIT krb5 releases 1.11 and later, an unauthenticated attacker can\ncause a denial of service for any client or server to which it can\nsend an ASN.1-encoded Kerberos message of sufficient length.\n\nticket: 8959 (new)\ntags: pullup\ntarget_version: 1.18-next\ntarget_version: 1.17-next",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/lib/krb5/asn.1/asn1_encode.c",
  "func_name": "decode_atype",
  "func_before": "static krb5_error_code\ndecode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n             const struct atype_info *a, void *val)\n{\n    krb5_error_code ret;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->dec != NULL);\n        return fn->dec(t, asn1, len, val);\n    }\n    case atype_sequence:\n        return decode_sequence(asn1, len, a->tinfo, val);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        assert(ptrinfo->basetype != NULL);\n        if (ptr != NULL) {\n            /* Container was already allocated by a previous sequence field. */\n            return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);\n        } else {\n            ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);\n            if (ret)\n                return ret;\n            STOREPTR(ptr, ptrinfo, val);\n            break;\n        }\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return decode_atype(t, asn1, len, off->basetype,\n                            (char *)val + off->dataoff);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return decode_atype(t, asn1, len, opt->basetype, val);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);\n        if (ret)\n            return ret;\n        return store_count(count, counted, val);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        taginfo inner_tag;\n        const taginfo *tp = t;\n        const uint8_t *rem;\n        size_t rlen;\n        if (!tag->implicit) {\n            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);\n            if (ret)\n                return ret;\n            /* Note: we don't check rlen (it should be 0). */\n            tp = &inner_tag;\n            if (!check_atype_tag(tag->basetype, tp))\n                return ASN1_BAD_ID;\n        }\n        return decode_atype(tp, asn1, len, tag->basetype, val);\n    }\n    case atype_bool: {\n        intmax_t intval;\n        ret = k5_asn1_decode_bool(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_int: {\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_uint: {\n        uintmax_t intval;\n        ret = k5_asn1_decode_uint(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_uint(intval, a->size, val);\n    }\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        if (intval != imm->val && imm->err != 0)\n            return imm->err;\n        break;\n    }\n    default:\n        /* Null-terminated sequence types are handled in decode_atype_to_ptr,\n         * since they create variable-sized objects. */\n        assert(a->type != atype_nullterm_sequence_of);\n        assert(a->type != atype_nonempty_nullterm_sequence_of);\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n    return 0;\n}",
  "func_after": "static krb5_error_code\ndecode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n             const struct atype_info *a, void *val)\n{\n    krb5_error_code ret;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->dec != NULL);\n        return fn->dec(t, asn1, len, val);\n    }\n    case atype_sequence:\n        return decode_sequence(asn1, len, a->tinfo, val);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        assert(ptrinfo->basetype != NULL);\n        if (ptr != NULL) {\n            /* Container was already allocated by a previous sequence field. */\n            return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);\n        } else {\n            ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);\n            if (ret)\n                return ret;\n            STOREPTR(ptr, ptrinfo, val);\n            break;\n        }\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return decode_atype(t, asn1, len, off->basetype,\n                            (char *)val + off->dataoff);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return decode_atype(t, asn1, len, opt->basetype, val);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);\n        if (ret)\n            return ret;\n        return store_count(count, counted, val);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        taginfo inner_tag;\n        const taginfo *tp = t;\n        const uint8_t *rem;\n        size_t rlen;\n        if (!tag->implicit) {\n            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);\n            if (ret)\n                return ret;\n            /* Note: we don't check rlen (it should be 0). */\n            tp = &inner_tag;\n            if (!check_atype_tag(tag->basetype, tp))\n                return ASN1_BAD_ID;\n        }\n        return decode_atype(tp, asn1, len, tag->basetype, val);\n    }\n    case atype_bool: {\n        intmax_t intval;\n        ret = k5_asn1_decode_bool(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_int: {\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_uint: {\n        uintmax_t intval;\n        ret = k5_asn1_decode_uint(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_uint(intval, a->size, val);\n    }\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        if (intval != imm->val && imm->err != 0)\n            return imm->err;\n        break;\n    }\n    default:\n        /* Null-terminated sequence types are handled in decode_atype_to_ptr,\n         * since they create variable-sized objects. */\n        assert(a->type != atype_nullterm_sequence_of);\n        assert(a->type != atype_nonempty_nullterm_sequence_of);\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n    return 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static krb5_error_code\n decode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n              const struct atype_info *a, void *val)\n {\n     krb5_error_code ret;\n \n     switch (a->type) {\n     case atype_fn: {\n         const struct fn_info *fn = a->tinfo;\n         assert(fn->dec != NULL);\n         return fn->dec(t, asn1, len, val);\n     }\n     case atype_sequence:\n         return decode_sequence(asn1, len, a->tinfo, val);\n     case atype_ptr: {\n         const struct ptr_info *ptrinfo = a->tinfo;\n         void *ptr = LOADPTR(val, ptrinfo);\n         assert(ptrinfo->basetype != NULL);\n         if (ptr != NULL) {\n             /* Container was already allocated by a previous sequence field. */\n             return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);\n         } else {\n             ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);\n             if (ret)\n                 return ret;\n             STOREPTR(ptr, ptrinfo, val);\n             break;\n         }\n     }\n     case atype_offset: {\n         const struct offset_info *off = a->tinfo;\n         assert(off->basetype != NULL);\n         return decode_atype(t, asn1, len, off->basetype,\n                             (char *)val + off->dataoff);\n     }\n     case atype_optional: {\n         const struct optional_info *opt = a->tinfo;\n         return decode_atype(t, asn1, len, opt->basetype, val);\n     }\n     case atype_counted: {\n         const struct counted_info *counted = a->tinfo;\n         void *dataptr = (char *)val + counted->dataoff;\n         size_t count;\n         assert(counted->basetype != NULL);\n         ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);\n         if (ret)\n             return ret;\n         return store_count(count, counted, val);\n     }\n     case atype_tagged_thing: {\n         const struct tagged_info *tag = a->tinfo;\n         taginfo inner_tag;\n         const taginfo *tp = t;\n         const uint8_t *rem;\n         si",
  "diff_source": "custom"
}