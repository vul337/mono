{
  "id": 835,
  "language": "Java",
  "commit_url": "https://github.com/PixelExperience/frameworks_base/commit/7a8d56b2fe3496f7717ad1afe45d2ef523b7e252",
  "commit_sha": "7a8d56b2fe3496f7717ad1afe45d2ef523b7e252",
  "commit_msg": "[RESTRICT AUTOMERGE] Add protections agains use-after-free issues if cancel() or queue() is called after a device connection has been closed.\n\nThis is a backport of ag/7528082 and ag/20033068.\n\nBug: 132319116\nBug: 130571162\nBug: 204584366\nTest: CTS Verifier: USB Accessory Test & USB Device Test\nChange-Id: I952ab566e26a808997e362dc85ebd1d8eb4574b9",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "core/java/android/hardware/usb/UsbRequest.java",
  "func_name": "queue",
  "func_before": "public boolean queue(@Nullable ByteBuffer buffer) {\n        // Request need to be initialized\n        Preconditions.checkState(mNativeContext != 0, \"request is not initialized\");\n\n        // Request can not be currently queued\n        Preconditions.checkState(!mIsUsingNewQueue, \"this request is currently queued\");\n\n        boolean isSend = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);\n        boolean wasQueued;\n\n        synchronized (mLock) {\n            mBuffer = buffer;\n\n            if (buffer == null) {\n                // Null buffers enqueue empty USB requests which is supported\n                mIsUsingNewQueue = true;\n                wasQueued = native_queue(null, 0, 0);\n            } else {\n                if (mConnection.getContext().getApplicationInfo().targetSdkVersion\n                        < Build.VERSION_CODES.P) {\n                    // Can only send/receive MAX_USBFS_BUFFER_SIZE bytes at once\n                    Preconditions.checkArgumentInRange(buffer.remaining(), 0, MAX_USBFS_BUFFER_SIZE,\n                            \"number of remaining bytes\");\n                }\n\n                // Can not receive into read-only buffers.\n                Preconditions.checkArgument(!(buffer.isReadOnly() && !isSend), \"buffer can not be \"\n                        + \"read-only when receiving data\");\n\n                if (!buffer.isDirect()) {\n                    mTempBuffer = ByteBuffer.allocateDirect(mBuffer.remaining());\n\n                    if (isSend) {\n                        // Copy buffer into temporary buffer\n                        mBuffer.mark();\n                        mTempBuffer.put(mBuffer);\n                        mTempBuffer.flip();\n                        mBuffer.reset();\n                    }\n\n                    // Send/Receive into the temp buffer instead\n                    buffer = mTempBuffer;\n                }\n\n                mIsUsingNewQueue = true;\n                wasQueued = native_queue(buffer, buffer.position(), buffer.remaining());\n            }\n        }\n\n        if (!wasQueued) {\n            mIsUsingNewQueue = false;\n            mTempBuffer = null;\n            mBuffer = null;\n        }\n\n        return wasQueued;\n    }",
  "func_after": "public boolean queue(@Nullable ByteBuffer buffer) {\n        UsbDeviceConnection connection = mConnection;\n        if (connection == null) {\n            // The expected exception by CTS Verifier - USB Device test\n            throw new IllegalStateException(\"invalid connection\");\n        }\n\n        // Calling into the underlying UsbDeviceConnection to synchronize on its lock, to prevent\n        // the connection being closed while queueing.\n        return connection.queueRequest(this, buffer);\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public boolean queue(@Nullable ByteBuffer buffer) {\n+        UsbDeviceConnection connection = mConnection;\n+        if (connection == null) {\n+            // The expected exception by CTS Verifier - USB Device test\n+            throw new IllegalStateException(\"invalid connection\");\n-        // Request need to be initialized\n-        Preconditions.checkState(mNativeContext != 0, \"request is not initialized\");\n-\n-        // Request can not be currently queued\n-        Preconditions.checkState(!mIsUsingNewQueue, \"this request is currently queued\");\n-\n-        boolean isSend = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);\n-        boolean wasQueued;\n-\n-        synchronized (mLock) {\n-            mBuffer = buffer;\n-\n-            if (buffer == null) {\n-                // Null buffers enqueue empty USB requests which is supported\n-                mIsUsingNewQueue = true;\n-                wasQueued = native_queue(null, 0, 0);\n-            } else {\n-                if (mConnection.getContext().getApplicationInfo().targetSdkVersion\n-                        < Build.VERSION_CODES.P) {\n-                    // Can only send/receive MAX_USBFS_BUFFER_SIZE bytes at once\n-                    Preconditions.checkArgumentInRange(buffer.remaining(), 0, MAX_USBFS_BUFFER_SIZE,\n-                            \"number of remaining bytes\");\n-                }\n-\n-                // Can not receive into read-only buffers.\n-                Preconditions.checkArgument(!(buffer.isReadOnly() && !isSend), \"buffer can not be \"\n-                        + \"read-only when receiving data\");\n-\n-                if (!buffer.isDirect()) {\n-                    mTempBuffer = ByteBuffer.allocateDirect(mBuffer.remaining());\n-\n-                    if (isSend) {\n-                        // Copy buffer into temporary buffer\n-                        mBuffer.mark();\n-                        mTempBuffer.put(mBuffer);\n-                        mTempBuffer.flip();\n-                 ",
  "diff_source": "custom"
}