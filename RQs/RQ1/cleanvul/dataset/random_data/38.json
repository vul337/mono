{
  "id": 38,
  "language": "Java",
  "commit_url": "https://github.com/mock-server/mockserver/commit/0edf52983230257fb61562d5dd8890be0924a017",
  "commit_sha": "0edf52983230257fb61562d5dd8890be0924a017",
  "commit_msg": "# Issue ID: CVE-2021-32827\n\n# Issue Description: MockServer is open source software which enables easy mocking of any system you integrate with via HTTP or HTTPS. An attacker that can trick a victim into visiting a malicious site while running MockServer locally, will be able to run arbitrary code on the MockServer machine. With an overly broad default CORS configuration MockServer allows any site to send cross-site requests. Additionally, MockServer allows you to create dynamic expectations using Javascript or Velocity templates. Both engines may allow an attacker to execute arbitrary code on-behalf of MockServer. By combining these two issues (Overly broad CORS configuration + Script injection), an attacker could serve a malicious page so that if a developer running MockServer visits it, they will get compromised. For more details including a PoC see the referenced GHSL-2021-059\n\n# Affected versions: 5.13.2 and earlier\n\n# Vulnerability Type:\tRemote Code Execution (RCE)\n\n# Fix:\nPlease note that, the fix added here is via properties (enabling these properties, will address the issue). This will ensure that we are not breaking functionality for existing users.\nJava Script Template:\n- The issue reported here is, the java code is injected in javascript engine with a statement like: this.engine.factory.scriptEngine.eval(<malicious java class to be exposed>). Ex:  this.engine.factory.scriptEngine.eval(‘java.lang.Runtime.getRuntime(“calc.exe”)’).\n- Here there are two points to be noted: 1. it allows triggering java classes that can exploit the target machine, 2. the engine object is exposed to the users via javascript\n- For issue #1, where it allows triggering a malicious code (like java.lang.Runtime in this case), We can mitigate this vulnerability in javascripts, by implementing ClassFilter interface provided by JDK. This interface contains a method exposeToScripts. By overriding this method, we can prevent dangerous methods from being called via reflection API. Added changes in JavaScriptTemplateEngine to create a new class filter. Here a new property “mockserver.javascript.classes.deny” is added, which contains a list of java classes to be restricted (comma separated), if a javascript triggers these classes, the engine prevents the same.\n- For issue #2, where engine object is exposed. The fix required here is, we need to block engine object getting exposed. The issue here is, the statement  this.engine.factory.scriptEngine breaks down to: this.engine,  global engine, factory, getFactory()  NashornScriptEngineFactory instance, scriptEngine  getScriptEngine() creates a fresh engine instance with default (== no ClassFilter, etc..) configuration, and finally .eval([script]), execute JavaScript code with full access to the Java world. So, the fix here should be to prevent exposing engine and factory objects, thereby preventing user to create his own new engine instances. In order to do this, adding a new property “mockserver.javascript.text.deny” which contains a list of backlisted strings (comma separated), that will result in preventing the script getting triggered.\n- In addition to fixing the issue reported, the newly added properties also help in fixing few other cases: where a malicious java  code is triggered with existing engine, rather than creating a new one.\n\nVelocity Template:\n- The issue reported here is, the java code is injected in velocity engine with a statement like: $!request.class.forName('java.lang.Runtime').getRuntime().exec(encodeURIComponent('notepad.exe'))\n- Here the issue is due to vulnerability in velocity-engine-core, which is addressed in 2.3 version. Here, the velocity code provides a uberspector implementation: SecureUberspector, which says: “Use a custom introspector that prevents classloader related method calls. Use this introspector for situations in which template writers are numerous or untrusted. Specifically, this introspector prevents creation of arbitrary objects or reflection on objects.”\n- Mockserver already uses 2.3 version of velocity-engine-core, however there is no uberspector configured.\n- Added changes here to configure the default apache velocity uberspector, in VelocityTemplateEngine. This change again is enabled when property mockserver.velocity.class.deny=true is set.\n\n# Workarounds:\nFor Javascript templates\n- Launching mockserver with an additional nashorn argument “—no-java” will prevent exposing any java code to java scripts. But this will result in preventing any java code.\n- If mockserver is triggered with two things: a security manager and a class filter. This will prevent exposing the engine object, thereby preventing any java code from getting triggered. Again, this will prevent any java code.\nFor Velocity templates\n- No workaround available\n\n# Unit Testing:\n- Verified that the RCE vulnerability is no more applicable for \"JavaScript\" and \"Velocity\" templates.\n- Verified the fix in Chrome, Mozilla and Firefox browsers.\n- All the test cases for this change is covered in unit test code: in JavaScriptTemplateEngineTest.java and VelocityTemplateEngineTest.java",
  "pr_url": "https://github.com/mock-server/mockserver/pull/1466",
  "pr_info": "### Issue ID: \r\nCVE-2021-32827\r\n\r\n### Issue Description: \r\nMockServer is open source software which enables easy mocking of any system you integrate with via HTTP or HTTPS. An attacker that can trick a victim into visiting a malicious site while running MockServer locally, will be able to run arbitrary code on the MockServer machine. With an overly broad default CORS configuration MockServer allows any site to send cross-site requests. Additionally, MockServer allows you to create dynamic expectations using Javascript or Velocity templates. Both engines may allow an attacker to execute arbitrary code on-behalf of MockServer. By combining these two issues (Overly broad CORS configuration + Script injection), an attacker could serve a malicious page so that if a developer running MockServer visits it, they will get compromised. For more details including a PoC see the referenced GHSL-2021-059\r\n\r\n### Affected versions: \r\n5.13.2 and earlier\r\n\r\n### Vulnerability Type: \r\nRemote Code Execution (RCE)\r\n\r\n### Fix:\r\n\r\n_**Please note that, the fix added here is via properties (enabling these properties, will address the issue). This will ensure that we are not breaking functionality for existing users.**_\r\n\r\n**Java Script Template:**\r\n- The issue reported here is, the java code is injected in javascript engine with a statement like: this.engine.factory.scriptEngine.eval(<malicious java class to be exposed>). Ex:  this.engine.factory.scriptEngine.eval(‘java.lang.Runtime.getRuntime(“calc.exe”)’).\r\n- Here there are two points to be noted: 1. it allows triggering java classes that can exploit the target machine, 2. the engine object is exposed to the users via javascript\r\n- **For point 1, where it allows triggering a malicious code** (like java.lang.Runtime in this case), We can mitigate this vulnerability in javascripts, by implementing ClassFilter interface provided by JDK. This interface contains a method exposeToScripts. By overriding this method, we can prevent dangerous methods from being called via reflection API. Added changes in JavaScriptTemplateEngine to create a new class filter. Here a new property “mockserver.javascript.class.deny” is added, which contains a list of java classes to be restricted (comma separated), if a javascript triggers these classes, the engine prevents the same.\r\n- **For point 2, where engine object is exposed**. The fix required here is, we need to block engine object getting exposed. The issue here is, the statement  **this.engine.factory.scriptEngine.eval** breaks down to: \r\n> - this.engine --> global engine, \r\n> - factory --> getFactory(), returns NashornScriptEngineFactory instance, \r\n> - scriptEngine --> getScriptEngine() creates a fresh engine instance with default (== no ClassFilter, etc..) configuration, \r\n> - and finally .eval([script]), execute JavaScript code with full access to the Java world. \r\n\r\n- So, the fix here should be to prevent exposing engine and factory objects, thereby preventing user to create his own new engine instances. In order to do this, adding a new property “mockserver.javascript.text.deny” which contains a list of backlisted strings (comma separated), that will result in preventing the script getting triggered.\r\n\r\n- In addition to fixing the issue reported, the newly added properties also help in fixing few other cases: where a malicious java  code is triggered with existing engine, rather than creating a new one.\r\n\r\n**Velocity Template:**\r\n- The issue reported here is, the java code is injected in velocity engine with a statement like: **$!request.class.forName('java.lang.Runtime').getRuntime().exec(encodeURIComponent('notepad.exe'))**\r\n- Here the issue is due to vulnerability in velocity-engine-core, which is addressed in 2.3 version. Here, the velocity code provides a uberspector implementation: SecureUberspector, which says: “Use a custom introspector that prevents classloader related method calls. Use this introspector for situations in which template writers are numerous or untrusted. Specifically, this introspector prevents creation of arbitrary objects or reflection on objects.”\r\n- Mockserver already uses 2.3 version of velocity-engine-core, however there is no uberspector configured.\r\n- Added changes here to configure the default apache velocity uberspector, in VelocityTemplateEngine. This change again is enabled when property mockserver.velocity.class.deny=true is set.\r\n\r\n### Workarounds:\r\n**For Javascript templates**\r\n- Launching mockserver with an additional nashorn argument “—no-java” will prevent exposing any java code to java scripts. But this will result in preventing any java code.\r\n- If mockserver is triggered with two things: a security manager and a class filter. This will prevent exposing the engine object, thereby preventing any java code from getting triggered. Again, this will prevent any java code.\r\n\r\n**For Velocity templates**\r\n- No workaround available\r\n\r\n### Unit Testing:\r\n- Verified that the RCE vulnerability is no more applicable for \"JavaScript\" and \"Velocity\" templates.\r\n- Verified the fix in Chrome, Mozilla and Firefox browsers.\r\n- All the test cases for this change is covered in unit test code: in JavaScriptTemplateEngineTest.java and VelocityTemplateEngineTest.java\r\n\r\n### Summary:\r\n- The changes added in the pull request, takes effect only if the newly added properties are set. This ensures that existing users of mockserver are not affected by this change. \r\n- The new properties can be configured based on the environment and user needs.\r\n- In order to fix CVE-2021-32827, we need to restrict two things: 1. accessing java.lang.Runtime and 2. accessing engine object. \r\n- Fix for **JavaScript templates**: \r\n**mockserver.javascript.text.deny=engine.factory** and **mockserver.javascript.class.deny=java.lang.Runtime**\r\n- Fix for **Velocity templates**: \r\n**mockserver.velocity.class.deny=java.lang.Runtime**\r\n\r\n",
  "file_name": "mockserver-core/src/main/java/org/mockserver/templates/engine/javascript/JavaScriptTemplateEngine.java",
  "func_name": "executeTemplate",
  "func_before": "@Override\n    public <T> T executeTemplate(String template, HttpRequest request, Class<? extends DTO<T>> dtoClass) {\n        T result = null;\n        String script = wrapTemplate(template);\n        try {\n            if (engine != null) {\n                Compilable compilable = (Compilable) engine;\n                // HttpResponse handle(HttpRequest httpRequest) - ES6\n                CompiledScript compiledScript = compilable.compile(script + \" function serialise(request) { return JSON.stringify(handle(JSON.parse(request)), null, 2); }\");\n\n                Bindings serialiseBindings = engine.createBindings();\n                engine.setBindings(new ScriptBindings(TemplateFunctions.BUILT_IN_FUNCTIONS), ScriptContext.ENGINE_SCOPE);\n                compiledScript.eval(serialiseBindings);\n\n                ScriptObjectMirror scriptObjectMirror = (ScriptObjectMirror) serialiseBindings.get(\"serialise\");\n                Object stringifiedResponse = scriptObjectMirror.call(null, new HttpRequestTemplateObject(request));\n\n                JsonNode generatedObject = null;\n                try {\n                    generatedObject = objectMapper.readTree(String.valueOf(stringifiedResponse));\n                } catch (Throwable throwable) {\n                    if (MockServerLogger.isEnabled(Level.INFO)) {\n                        mockServerLogger.logEvent(\n                            new LogEntry()\n                                .setLogLevel(Level.INFO)\n                                .setHttpRequest(request)\n                                .setMessageFormat(\"exception deserialising generated content:{}into json node for request:{}\")\n                                .setArguments(stringifiedResponse, request)\n                        );\n                    }\n                }\n                if (MockServerLogger.isEnabled(Level.INFO)) {\n                    mockServerLogger.logEvent(\n                        new LogEntry()\n                            .setType(TEMPLATE_GENERATED)\n                            .setLogLevel(Level.INFO)\n                            .setHttpRequest(request)\n                            .setMessageFormat(TEMPLATE_GENERATED_MESSAGE_FORMAT)\n                            .setArguments(generatedObject != null ? generatedObject : stringifiedResponse, script, request)\n                    );\n                }\n                result = httpTemplateOutputDeserializer.deserializer(request, (String) stringifiedResponse, dtoClass);\n            } else {\n                mockServerLogger.logEvent(\n                    new LogEntry()\n                        .setLogLevel(Level.ERROR)\n                        .setHttpRequest(request)\n                        .setMessageFormat(\n                            \"JavaScript based templating is only available in a JVM with the \\\"nashorn\\\" JavaScript engine, \" +\n                                \"please use a JVM with the \\\"nashorn\\\" JavaScript engine, such as Oracle Java 8+\"\n                        )\n                        .setArguments(new RuntimeException(\"\\\"nashorn\\\" JavaScript engine not available\"))\n                );\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(formatLogMessage(\"Exception:{}transforming template:{}for request:{}\", isNotBlank(e.getMessage()) ? e.getMessage() : e.getClass().getSimpleName(), template, request), e);\n        }\n        return result;\n    }",
  "func_after": "@Override\n    public <T> T executeTemplate(String template, HttpRequest request, Class<? extends DTO<T>> dtoClass) {\n        T result = null;\n        String script = wrapTemplate(template);\n        try {\n            if (!validateTemplate(template)) {\n                throw new UnsupportedOperationException(\"Invalid template string specified: \" + template);\n            }\n            if (engine != null) {\n                Compilable compilable = (Compilable) engine;\n                // HttpResponse handle(HttpRequest httpRequest) - ES6\n                CompiledScript compiledScript = compilable.compile(script + \" function serialise(request) { return JSON.stringify(handle(JSON.parse(request)), null, 2); }\");\n\n                Bindings serialiseBindings = engine.createBindings();\n                engine.setBindings(new ScriptBindings(TemplateFunctions.BUILT_IN_FUNCTIONS), ScriptContext.ENGINE_SCOPE);\n                compiledScript.eval(serialiseBindings);\n\n                ScriptObjectMirror scriptObjectMirror = (ScriptObjectMirror) serialiseBindings.get(\"serialise\");\n                Object stringifiedResponse = scriptObjectMirror.call(null, new HttpRequestTemplateObject(request));\n\n                JsonNode generatedObject = null;\n                try {\n                    generatedObject = objectMapper.readTree(String.valueOf(stringifiedResponse));\n                } catch (Throwable throwable) {\n                    if (MockServerLogger.isEnabled(Level.INFO)) {\n                        mockServerLogger.logEvent(\n                            new LogEntry()\n                                .setLogLevel(Level.INFO)\n                                .setHttpRequest(request)\n                                .setMessageFormat(\"exception deserialising generated content:{}into json node for request:{}\")\n                                .setArguments(stringifiedResponse, request)\n                        );\n                    }\n                }\n                if (MockServerLogger.isEnabled(Level.INFO)) {\n                    mockServerLogger.logEvent(\n                        new LogEntry()\n                            .setType(TEMPLATE_GENERATED)\n                            .setLogLevel(Level.INFO)\n                            .setHttpRequest(request)\n                            .setMessageFormat(TEMPLATE_GENERATED_MESSAGE_FORMAT)\n                            .setArguments(generatedObject != null ? generatedObject : stringifiedResponse, script, request)\n                    );\n                }\n                result = httpTemplateOutputDeserializer.deserializer(request, (String) stringifiedResponse, dtoClass);\n            } else {\n                mockServerLogger.logEvent(\n                    new LogEntry()\n                        .setLogLevel(Level.ERROR)\n                        .setHttpRequest(request)\n                        .setMessageFormat(\n                            \"JavaScript based templating is only available in a JVM with the \\\"nashorn\\\" JavaScript engine, \" +\n                                \"please use a JVM with the \\\"nashorn\\\" JavaScript engine, such as Oracle Java 8+\"\n                        )\n                        .setArguments(new RuntimeException(\"\\\"nashorn\\\" JavaScript engine not available\"))\n                );\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(formatLogMessage(\"Exception:{}transforming template:{}for request:{}\", isNotBlank(e.getMessage()) ? e.getMessage() : e.getClass().getSimpleName(), template, request), e);\n        }\n        return result;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public <T> T executeTemplate(String template, HttpRequest request, Class<? extends DTO<T>> dtoClass) {\n         T result = null;\n         String script = wrapTemplate(template);\n         try {\n+            if (!validateTemplate(template)) {\n+                throw new UnsupportedOperationException(\"Invalid template string specified: \" + template);\n+            }\n             if (engine != null) {\n                 Compilable compilable = (Compilable) engine;\n                 // HttpResponse handle(HttpRequest httpRequest) - ES6\n                 CompiledScript compiledScript = compilable.compile(script + \" function serialise(request) { return JSON.stringify(handle(JSON.parse(request)), null, 2); }\");\n \n                 Bindings serialiseBindings = engine.createBindings();\n                 engine.setBindings(new ScriptBindings(TemplateFunctions.BUILT_IN_FUNCTIONS), ScriptContext.ENGINE_SCOPE);\n                 compiledScript.eval(serialiseBindings);\n \n                 ScriptObjectMirror scriptObjectMirror = (ScriptObjectMirror) serialiseBindings.get(\"serialise\");\n                 Object stringifiedResponse = scriptObjectMirror.call(null, new HttpRequestTemplateObject(request));\n \n                 JsonNode generatedObject = null;\n                 try {\n                     generatedObject = objectMapper.readTree(String.valueOf(stringifiedResponse));\n                 } catch (Throwable throwable) {\n                     if (MockServerLogger.isEnabled(Level.INFO)) {\n                         mockServerLogger.logEvent(\n                             new LogEntry()\n                                 .setLogLevel(Level.INFO)\n                                 .setHttpRequest(request)\n                                 .setMessageFormat(\"exception deserialising generated content:{}into json node for request:{}\")\n                                 .setArguments(stringifiedResponse, request)\n                         );\n                     }\n  ",
  "diff_source": "custom"
}