{
  "id": 4462,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/9cc02ede696272c5271a401e4f27c262359bc2f6",
  "commit_sha": "9cc02ede696272c5271a401e4f27c262359bc2f6",
  "commit_msg": "net: rose: fix UAF bugs caused by timer handler\n\nThere are UAF bugs in rose_heartbeat_expiry(), rose_timer_expiry()\nand rose_idletimer_expiry(). The root cause is that del_timer()\ncould not stop the timer handler that is running and the refcount\nof sock is not managed properly.\n\nOne of the UAF bugs is shown below:\n\n    (thread 1)          |        (thread 2)\n                        |  rose_bind\n                        |  rose_connect\n                        |    rose_start_heartbeat\nrose_release            |    (wait a time)\n  case ROSE_STATE_0     |\n  rose_destroy_socket   |  rose_heartbeat_expiry\n    rose_stop_heartbeat |\n    sock_put(sk)        |    ...\n  sock_put(sk) // FREE  |\n                        |    bh_lock_sock(sk) // USE\n\nThe sock is deallocated by sock_put() in rose_release() and\nthen used by bh_lock_sock() in rose_heartbeat_expiry().\n\nAlthough rose_destroy_socket() calls rose_stop_heartbeat(),\nit could not stop the timer that is running.\n\nThe KASAN report triggered by POC is shown below:\n\nBUG: KASAN: use-after-free in _raw_spin_lock+0x5a/0x110\nWrite of size 4 at addr ffff88800ae59098 by task swapper/3/0\n...\nCall Trace:\n <IRQ>\n dump_stack_lvl+0xbf/0xee\n print_address_description+0x7b/0x440\n print_report+0x101/0x230\n ? irq_work_single+0xbb/0x140\n ? _raw_spin_lock+0x5a/0x110\n kasan_report+0xed/0x120\n ? _raw_spin_lock+0x5a/0x110\n kasan_check_range+0x2bd/0x2e0\n _raw_spin_lock+0x5a/0x110\n rose_heartbeat_expiry+0x39/0x370\n ? rose_start_heartbeat+0xb0/0xb0\n call_timer_fn+0x2d/0x1c0\n ? rose_start_heartbeat+0xb0/0xb0\n expire_timers+0x1f3/0x320\n __run_timers+0x3ff/0x4d0\n run_timer_softirq+0x41/0x80\n __do_softirq+0x233/0x544\n irq_exit_rcu+0x41/0xa0\n sysvec_apic_timer_interrupt+0x8c/0xb0\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x1b/0x20\nRIP: 0010:default_idle+0xb/0x10\nRSP: 0018:ffffc9000012fea0 EFLAGS: 00000202\nRAX: 000000000000bcae RBX: ffff888006660f00 RCX: 000000000000bcae\nRDX: 0000000000000001 RSI: ffffffff843a11c0 RDI: ffffffff843a1180\nRBP: dffffc0000000000 R08: dffffc0000000000 R09: ffffed100da36d46\nR10: dfffe9100da36d47 R11: ffffffff83cf0950 R12: 0000000000000000\nR13: 1ffff11000ccc1e0 R14: ffffffff8542af28 R15: dffffc0000000000\n...\nAllocated by task 146:\n __kasan_kmalloc+0xc4/0xf0\n sk_prot_alloc+0xdd/0x1a0\n sk_alloc+0x2d/0x4e0\n rose_create+0x7b/0x330\n __sock_create+0x2dd/0x640\n __sys_socket+0xc7/0x270\n __x64_sys_socket+0x71/0x80\n do_syscall_64+0x43/0x90\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nFreed by task 152:\n kasan_set_track+0x4c/0x70\n kasan_set_free_info+0x1f/0x40\n ____kasan_slab_free+0x124/0x190\n kfree+0xd3/0x270\n __sk_destruct+0x314/0x460\n rose_release+0x2fa/0x3b0\n sock_close+0xcb/0x230\n __fput+0x2d9/0x650\n task_work_run+0xd6/0x160\n exit_to_user_mode_loop+0xc7/0xd0\n exit_to_user_mode_prepare+0x4e/0x80\n syscall_exit_to_user_mode+0x20/0x40\n do_syscall_64+0x4f/0x90\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThis patch adds refcount of sock when we use functions\nsuch as rose_start_heartbeat() and so on to start timer,\nand decreases the refcount of sock when timer is finished\nor deleted by functions such as rose_stop_heartbeat()\nand so on. As a result, the UAF bugs could be mitigated.\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nTested-by: Duoming Zhou <duoming@zju.edu.cn>\nLink: https://lore.kernel.org/r/20220629002640.5693-1-duoming@zju.edu.cn\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "net/rose/rose_timer.c",
  "func_name": "rose_stop_timer",
  "func_before": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}",
  "func_after": "void rose_stop_timer(struct sock *sk)\n{\n\tsk_stop_timer(sk, &rose_sk(sk)->timer);\n}",
  "diff_func": "--- func_before\n+++ func_after\n void rose_stop_timer(struct sock *sk)\n {\n-\tdel_timer(&rose_sk(sk)->timer);\n+\tsk_stop_timer(sk, &rose_sk(sk)->timer);\n }",
  "diff_source": "custom"
}