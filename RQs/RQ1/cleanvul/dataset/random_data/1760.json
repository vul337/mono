{
  "id": 1760,
  "language": "Java",
  "commit_url": "https://github.com/AOSPA/android_frameworks_base/commit/107e6377328486fca55131ea06ca9d6a3c1585e0",
  "commit_sha": "107e6377328486fca55131ea06ca9d6a3c1585e0",
  "commit_msg": "Fix checkKeyIntentParceledCorrectly's bypass\n\nThe checkKeyIntentParceledCorrectly method was added in checkKeyIntent, which was originaly  only invoked when AccountManagerService deserializes the KEY_INTENT value as not NULL. However, due to the self-changing bundle technique in Parcel mismatch problems, the Intent value can change after reparceling; hence would bypass the added checkKeyIntentParceledCorrectly call.\n\nThis CL did the following:\n\n- Ensure the checkKeyIntent method is also called when result.getParcelable(AccountManager.KEY_INTENT, Intent.class) == null.\n- Migrate to the safer Bundle.getParcelable(String, Class<T>) API call\n  in AccountManagerService.\n\nBug: 260567867\nBug: 262230405\nTest: local test, see b/262230405\nTest: atest CtsAccountManagerTestCases\nMerged-In: I7b528f52c41767ae12731838fdd36aa26a8f3477\nChange-Id: I7b528f52c41767ae12731838fdd36aa26a8f3477\n(cherry picked from commit 3723f400e2f7f6b72be5d76ae6058e2be579b002)\nMerged-In: I7b528f52c41767ae12731838fdd36aa26a8f3477",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
  "func_name": "checkKeyIntent",
  "func_before": "protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n            \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(targetUid, authUid, CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }",
  "func_after": "protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n            \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(targetUid, authUid, CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }",
  "diff_func": "--- func_before\n+++ func_after\n protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n             if (!checkKeyIntentParceledCorrectly(bundle)) {\n             \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                 return false;\n             }\n-\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            if (intent == null) {\n+                return true;\n+            }\n             // Explicitly set an empty ClipData to ensure that we don't offer to\n             // promote any Uris contained inside for granting purposes\n             if (intent.getClipData() == null) {\n                 intent.setClipData(ClipData.newPlainText(null, null));\n             }\n             intent.setFlags(intent.getFlags() & ~(Intent.FLAG_GRANT_READ_URI_PERMISSION\n                     | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                     | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                     | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION));\n             final long bid = Binder.clearCallingIdentity();\n             try {\n                 PackageManager pm = mContext.getPackageManager();\n                 ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                 if (resolveInfo == null) {\n                     return false;\n                 }\n                 ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                 int targetUid = targetActivityInfo.applicationInfo.uid;\n                 PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                 if (!isExportedSystemActivity(targetActivityInfo)\n                         && !pmi.hasSignatureCapability(targetUid, authUid, CertCapabilities.AUTH)) {\n                     String pkgName = targetActivityInfo.packageName;\n                     String activityName = targetActivityInfo.name;\n                     String tmpl = \"KEY_INTENT resolved to an Activity (%s",
  "diff_source": "custom"
}