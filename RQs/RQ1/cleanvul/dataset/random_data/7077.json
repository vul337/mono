{
  "id": 7077,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b",
  "commit_sha": "28d76df18f0ad5bcf5fa48510b225f0ed262a99b",
  "commit_msg": "scsi: mptfusion: Fix double fetch bug in ioctl\n\nTom Hatskevich reported that we look up \"iocp\" then, in the called\nfunctions we do a second copy_from_user() and look it up again.\nThe problem that could cause is:\n\ndrivers/message/fusion/mptctl.c\n   674          /* All of these commands require an interrupt or\n   675           * are unknown/illegal.\n   676           */\n   677          if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n                                               ^^^^\nWe take this lock.\n\n   678                  return ret;\n   679\n   680          if (cmd == MPTFWDOWNLOAD)\n   681                  ret = mptctl_fw_download(arg);\n                                                 ^^^\nThen the user memory changes and we look up \"iocp\" again but a different\none so now we are holding the incorrect lock and have a race condition.\n\n   682          else if (cmd == MPTCOMMAND)\n   683                  ret = mptctl_mpt_command(arg);\n\nThe security impact of this bug is not as bad as it could have been\nbecause these operations are all privileged and root already has\nenormous destructive power.  But it's still worth fixing.\n\nThis patch passes the \"iocp\" pointer to the functions to avoid the\nsecond lookup.  That deletes 100 lines of code from the driver so\nit's a nice clean up as well.\n\nLink: https://lore.kernel.org/r/20200114123414.GA7957@kadam\nReported-by: Tom Hatskevich <tom2001tom.23@gmail.com>\nReviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "drivers/message/fusion/mptctl.c",
  "func_name": "mptctl_gettargetinfo",
  "func_before": "static int\nmptctl_gettargetinfo (unsigned long arg)\n{\n\tstruct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_targetinfo karg;\n\tMPT_ADAPTER\t\t*ioc;\n\tVirtDevice\t\t*vdevice;\n\tchar\t\t\t*pmem;\n\tint\t\t\t*pdata;\n\tint\t\t\tiocnum;\n\tint\t\t\tnumDevices = 0;\n\tint\t\t\tlun;\n\tint\t\t\tmaxWordsLeft;\n\tint\t\t\tnumBytes;\n\tu8\t\t\tport;\n\tstruct scsi_device \t*sdev;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to read in mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_gettargetinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_gettargetinfo called.\\n\",\n\t    ioc->name));\n\t/* Get the port number and set the maximum number of bytes\n\t * in the returned structure.\n\t * Ignore the port setting.\n\t */\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxWordsLeft = numBytes/sizeof(int);\n\tport = karg.hdr.port;\n\n\tif (maxWordsLeft <= 0) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n\t/* struct mpt_ioctl_targetinfo does not contain sufficient space\n\t * for the target structures so when the IOCTL is called, there is\n\t * not sufficient stack space for the structure. Allocate memory,\n\t * populate the memory, copy back to the user, then free memory.\n\t * targetInfo format:\n\t * bits 31-24: reserved\n\t *      23-16: LUN\n\t *      15- 8: Bus Number\n\t *       7- 0: Target ID\n\t */\n\tpmem = kzalloc(numBytes, GFP_KERNEL);\n\tif (!pmem) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\tpdata =  (int *) pmem;\n\n\t/* Get number of devices\n         */\n\tif (ioc->sh){\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tif (!maxWordsLeft)\n\t\t\t\tcontinue;\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tlun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;\n\t\t\t*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +\n\t\t\t    (vdevice->vtarget->id ));\n\t\t\tpdata++;\n\t\t\tnumDevices++;\n\t\t\t--maxWordsLeft;\n\t\t}\n\t}\n\tkarg.numDevices = numDevices;\n\n\t/* Copy part of the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg,\n\t\t\t\tsizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Copy the remaining data from kernel memory to user memory\n\t */\n\tif (copy_to_user(uarg->targetInfo, pmem, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, pdata);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(pmem);\n\n\treturn 0;\n}",
  "func_after": "static int\nmptctl_gettargetinfo (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_targetinfo karg;\n\tVirtDevice\t\t*vdevice;\n\tchar\t\t\t*pmem;\n\tint\t\t\t*pdata;\n\tint\t\t\tnumDevices = 0;\n\tint\t\t\tlun;\n\tint\t\t\tmaxWordsLeft;\n\tint\t\t\tnumBytes;\n\tu8\t\t\tport;\n\tstruct scsi_device \t*sdev;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to read in mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_gettargetinfo called.\\n\",\n\t    ioc->name));\n\t/* Get the port number and set the maximum number of bytes\n\t * in the returned structure.\n\t * Ignore the port setting.\n\t */\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxWordsLeft = numBytes/sizeof(int);\n\tport = karg.hdr.port;\n\n\tif (maxWordsLeft <= 0) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n\t/* struct mpt_ioctl_targetinfo does not contain sufficient space\n\t * for the target structures so when the IOCTL is called, there is\n\t * not sufficient stack space for the structure. Allocate memory,\n\t * populate the memory, copy back to the user, then free memory.\n\t * targetInfo format:\n\t * bits 31-24: reserved\n\t *      23-16: LUN\n\t *      15- 8: Bus Number\n\t *       7- 0: Target ID\n\t */\n\tpmem = kzalloc(numBytes, GFP_KERNEL);\n\tif (!pmem) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo() - no memory available!\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\tpdata =  (int *) pmem;\n\n\t/* Get number of devices\n         */\n\tif (ioc->sh){\n\t\tshost_for_each_device(sdev, ioc->sh) {\n\t\t\tif (!maxWordsLeft)\n\t\t\t\tcontinue;\n\t\t\tvdevice = sdev->hostdata;\n\t\t\tif (vdevice == NULL || vdevice->vtarget == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (vdevice->vtarget->tflags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\t\tcontinue;\n\t\t\tlun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;\n\t\t\t*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +\n\t\t\t    (vdevice->vtarget->id ));\n\t\t\tpdata++;\n\t\t\tnumDevices++;\n\t\t\t--maxWordsLeft;\n\t\t}\n\t}\n\tkarg.numDevices = numDevices;\n\n\t/* Copy part of the data from kernel memory to user memory\n\t */\n\tif (copy_to_user((char __user *)arg, &karg,\n\t\t\t\tsizeof(struct mpt_ioctl_targetinfo))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Copy the remaining data from kernel memory to user memory\n\t */\n\tif (copy_to_user(uarg->targetInfo, pmem, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_gettargetinfo - \"\n\t\t\t\"Unable to write out mpt_ioctl_targetinfo struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, pdata);\n\t\tkfree(pmem);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(pmem);\n\n\treturn 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n@@ -100 +100 @@\n-static int mptctl_gettargetinfo(unsigned long arg);\n-static int mptctl_readtest(unsigned long arg);\n-static int mptctl_mpt_command(unsigned long arg);\n-static int mptctl_eventquery(unsigned long arg);\n-static int mptctl_eventenable(unsigned long arg);\n-static int mptctl_eventreport(unsigned long arg);\n-static int mptctl_replace_fw(unsigned long arg);\n-\n-static int mptctl_do_reset(unsigned long arg);\n-static int mptctl_hp_hostinfo(unsigned long arg, unsigned int cmd);\n-static int mptctl_hp_targetinfo(unsigned long arg);\n+static int mptctl_fw_download(MPT_ADAPTER *iocp, unsigned long arg);\n+static int mptctl_getiocinfo(MPT_ADAPTER *iocp, unsigned long arg, unsigned int cmd);\n+static int mptctl_gettargetinfo(MPT_ADAPTER *iocp, unsigned long arg);\n+static int mptctl_readtest(MPT_ADAPTER *iocp, unsigned long arg);\n+static int mptctl_mpt_command(MPT_ADAPTER *iocp, unsigned long arg);\n+static int mptctl_eventquery(MPT_ADAPTER *iocp, unsigned long arg);\n+static int mptctl_eventenable(MPT_ADAPTER *iocp, unsigned long arg);\n+static int mptctl_eventreport(MPT_ADAPTER *iocp, unsigned long arg);\n+static int mptctl_replace_fw(MPT_ADAPTER *iocp, unsigned long arg);\n+\n+static int mptctl_do_reset(MPT_ADAPTER *iocp, unsigned long arg);\n+static int mptctl_hp_hostinfo(MPT_ADAPTER *iocp, unsigned long arg, unsigned int cmd);\n+static int mptctl_hp_targetinfo(MPT_ADAPTER *iocp, unsigned long arg);\n \n static int  mptctl_probe(struct pci_dev *, const struct pci_device_id *);\n static void mptctl_remove(struct pci_dev *);\n-\t\treturn mptctl_gettargetinfo(arg);\n+\t\treturn mptctl_gettargetinfo(iocp, arg);\n } else if (cmd == MPTTEST) {\n-\t\treturn mptctl_readtest(arg);\n+\t\treturn mptctl_readtest(iocp, arg);\n } else if (cmd == MPTEVENTQUERY) {\n-\t\treturn mptctl_eventquery(arg);\n+\t\treturn mptctl_eventquery(iocp, arg);\n } else if (cmd == MPTEVENTENABLE) {\n-\t\treturn mptctl_eventenable(arg);\n+\t\treturn mptctl_eventenable(iocp, arg);\n } else if (cmd == MPTEVENTR",
  "diff_source": "api"
}