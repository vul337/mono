{
  "id": 7496,
  "language": "JavaScript",
  "commit_url": "https://github.com/automattic/mongoose/commit/305ce4ff789261df7e3f6e72363d0703e025f80d",
  "commit_sha": "305ce4ff789261df7e3f6e72363d0703e025f80d",
  "commit_msg": "fix: avoid prototype pollution on init",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "lib/document.js",
  "func_name": "_init",
  "func_before": "function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schemaType = docSchema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n\n        if (schemaType && !wasPopulated) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(obj[i], self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }",
  "func_after": "function _init(index) {\n    i = keys[index];\n    // avoid prototype pollution\n    if (i === '__proto__' || i === 'constructor') {\n      return;\n    }\n    path = prefix + i;\n    schemaType = docSchema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n\n        if (schemaType && !wasPopulated) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(obj[i], self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }",
  "diff_func": "--- func_before\n+++ func_after\n function _init(index) {\n     i = keys[index];\n+    // avoid prototype pollution\n+    if (i === '__proto__' || i === 'constructor') {\n+      return;\n+    }\n     path = prefix + i;\n     schemaType = docSchema.path(path);\n \n     // Should still work if not a model-level discriminator, but should not be\n     // necessary. This is *only* to catch the case where we queried using the\n     // base model and the discriminated model has a projection\n     if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n       return;\n     }\n \n     if (!schemaType && utils.isPOJO(obj[i])) {\n       // assume nested object\n       if (!doc[i]) {\n         doc[i] = {};\n         if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n           self[i] = doc[i];\n         }\n       }\n       init(self, obj[i], doc[i], opts, path + '.');\n     } else if (!schemaType) {\n       doc[i] = obj[i];\n       if (!strict && !prefix) {\n         self[i] = obj[i];\n       }\n     } else {\n       // Retain order when overwriting defaults\n       if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n         delete doc[i];\n       }\n       if (obj[i] === null) {\n         doc[i] = schemaType._castNullish(null);\n       } else if (obj[i] !== undefined) {\n         const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n \n         if (schemaType && !wasPopulated) {\n           try {\n             if (opts && opts.setters) {\n               // Call applySetters with `init = false` because otherwise setters are a noop\n               const overrideInit = false;\n               doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\n             } else {\n               doc[i] = schemaType.cast(obj[i], self, true);\n             }\n           } catch (e) {\n             self.invalidate(e.path, new ValidatorError({\n               path: e.path,\n               message: e.message,\n               type: 'cast',\n               value: ",
  "diff_source": "custom"
}