{
  "id": 5212,
  "language": "Python",
  "commit_url": "https://github.com/theupdateframework/python-tuf/commit/4ad7ae48fda594b640139c3b7eae21ed5155a102",
  "commit_sha": "4ad7ae48fda594b640139c3b7eae21ed5155a102",
  "commit_msg": "Merge pull request from GHSA-wjw6-2cqr-j4qr\n\nFix client issue with rolenames as filenames",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "tuf/client/updater.py",
  "func_name": "_update_metadata",
  "func_before": "def _update_metadata(self, metadata_role, upperbound_filelength, version=None):\n    \"\"\"\n    <Purpose>\n      Non-public method that downloads, verifies, and 'installs' the metadata\n      belonging to 'metadata_role'.  Calling this method implies that the\n      'metadata_role' on the repository is newer than the client's, and thus\n      needs to be re-downloaded.  The current and previous metadata stores are\n      updated if the newly downloaded metadata is successfully downloaded and\n      verified.  This method also assumes that the store of top-level metadata\n      is the latest and exists.\n\n    <Arguments>\n      metadata_role:\n        The name of the metadata. This is a role name and should not end\n        in '.json'.  Examples: 'root', 'targets', 'targets/linux/x86'.\n\n      upperbound_filelength:\n        The expected length, or upper bound, of the metadata file to be\n        downloaded.\n\n      version:\n        The expected and required version number of the 'metadata_role' file\n        downloaded.  'expected_version' is an integer.\n\n    <Exceptions>\n      tuf.exceptions.NoWorkingMirrorError:\n        The metadata cannot be updated. This is not specific to a single\n        failure but rather indicates that all possible ways to update the\n        metadata have been tried and failed.\n\n    <Side Effects>\n      The metadata file belonging to 'metadata_role' is downloaded from a\n      repository mirror.  If the metadata is valid, it is stored in the\n      metadata store.\n\n    <Returns>\n      None.\n    \"\"\"\n\n    # Construct the metadata filename as expected by the download/mirror\n    # modules.\n    metadata_filename = metadata_role + '.json'\n\n    # Attempt a file download from each mirror until the file is downloaded and\n    # verified.  If the signature of the downloaded file is valid, proceed,\n    # otherwise log a warning and try the next mirror.  'metadata_file_object'\n    # is the file-like object returned by 'download.py'.  'metadata_signable'\n    # is the object extracted from 'metadata_file_object'.  Metadata saved to\n    # files are regarded as 'signable' objects, conformant to\n    # 'tuf.formats.SIGNABLE_SCHEMA'.\n    #\n    # Some metadata (presently timestamp) will be downloaded \"unsafely\", in the\n    # sense that we can only estimate its true length and know nothing about\n    # its version.  This is because not all metadata will have other metadata\n    # for it; otherwise we will have an infinite regress of metadata signing\n    # for each other. In this case, we will download the metadata up to the\n    # best length we can get for it, not request a specific version, but\n    # perform the rest of the checks (e.g., signature verification).\n\n    remote_filename = metadata_filename\n    filename_version = ''\n\n    if self.consistent_snapshot and version:\n      filename_version = version\n      dirname, basename = os.path.split(remote_filename)\n      remote_filename = os.path.join(\n          dirname, str(filename_version) + '.' + basename)\n\n    metadata_file_object = \\\n      self._get_metadata_file(metadata_role, remote_filename,\n        upperbound_filelength, version)\n\n    # The metadata has been verified. Move the metadata file into place.\n    # First, move the 'current' metadata file to the 'previous' directory\n    # if it exists.\n    current_filepath = os.path.join(self.metadata_directory['current'],\n                metadata_filename)\n    current_filepath = os.path.abspath(current_filepath)\n    sslib_util.ensure_parent_dir(current_filepath)\n\n    previous_filepath = os.path.join(self.metadata_directory['previous'],\n        metadata_filename)\n    previous_filepath = os.path.abspath(previous_filepath)\n\n    if os.path.exists(current_filepath):\n      # Previous metadata might not exist, say when delegations are added.\n      sslib_util.ensure_parent_dir(previous_filepath)\n      shutil.move(current_filepath, previous_filepath)\n\n    # Next, move the verified updated metadata file to the 'current' directory.\n    metadata_file_object.seek(0)\n    metadata_signable = \\\n      sslib_util.load_json_string(metadata_file_object.read().decode('utf-8'))\n\n    sslib_util.persist_temp_file(metadata_file_object, current_filepath)\n\n    # Extract the metadata object so we can store it to the metadata store.\n    # 'current_metadata_object' set to 'None' if there is not an object\n    # stored for 'metadata_role'.\n    updated_metadata_object = metadata_signable['signed']\n    current_metadata_object = self.metadata['current'].get(metadata_role)\n\n    # Finally, update the metadata and fileinfo stores, and rebuild the\n    # key and role info for the top-level roles if 'metadata_role' is root.\n    # Rebuilding the key and role info is required if the newly-installed\n    # root metadata has revoked keys or updated any top-level role information.\n    logger.debug('Updated ' + repr(current_filepath) + '.')\n    self.metadata['previous'][metadata_role] = current_metadata_object\n    self.metadata['current'][metadata_role] = updated_metadata_object\n    self._update_versioninfo(metadata_filename)",
  "func_after": "def _update_metadata(self, metadata_role, upperbound_filelength, version=None):\n    \"\"\"\n    <Purpose>\n      Non-public method that downloads, verifies, and 'installs' the metadata\n      belonging to 'metadata_role'.  Calling this method implies that the\n      'metadata_role' on the repository is newer than the client's, and thus\n      needs to be re-downloaded.  The current and previous metadata stores are\n      updated if the newly downloaded metadata is successfully downloaded and\n      verified.  This method also assumes that the store of top-level metadata\n      is the latest and exists.\n\n    <Arguments>\n      metadata_role:\n        The name of the metadata. This is a role name and should not end\n        in '.json'.  Examples: 'root', 'targets', 'targets/linux/x86'.\n\n      upperbound_filelength:\n        The expected length, or upper bound, of the metadata file to be\n        downloaded.\n\n      version:\n        The expected and required version number of the 'metadata_role' file\n        downloaded.  'expected_version' is an integer.\n\n    <Exceptions>\n      tuf.exceptions.NoWorkingMirrorError:\n        The metadata cannot be updated. This is not specific to a single\n        failure but rather indicates that all possible ways to update the\n        metadata have been tried and failed.\n\n    <Side Effects>\n      The metadata file belonging to 'metadata_role' is downloaded from a\n      repository mirror.  If the metadata is valid, it is stored in the\n      metadata store.\n\n    <Returns>\n      None.\n    \"\"\"\n\n    # Attempt a file download from each mirror until the file is downloaded and\n    # verified.  If the signature of the downloaded file is valid, proceed,\n    # otherwise log a warning and try the next mirror.  'metadata_file_object'\n    # is the file-like object returned by 'download.py'.  'metadata_signable'\n    # is the object extracted from 'metadata_file_object'.  Metadata saved to\n    # files are regarded as 'signable' objects, conformant to\n    # 'tuf.formats.SIGNABLE_SCHEMA'.\n    #\n    # Some metadata (presently timestamp) will be downloaded \"unsafely\", in the\n    # sense that we can only estimate its true length and know nothing about\n    # its version.  This is because not all metadata will have other metadata\n    # for it; otherwise we will have an infinite regress of metadata signing\n    # for each other. In this case, we will download the metadata up to the\n    # best length we can get for it, not request a specific version, but\n    # perform the rest of the checks (e.g., signature verification).\n\n    # Construct the metadata filename as expected by the download/mirror\n    # modules. Local filename is quoted to protect against names like\"../file\".\n\n    remote_filename = metadata_role + '.json'\n    local_filename = self._get_local_filename(metadata_role)\n    filename_version = ''\n\n    if self.consistent_snapshot and version:\n      filename_version = version\n      dirname, basename = os.path.split(remote_filename)\n      remote_filename = os.path.join(\n          dirname, str(filename_version) + '.' + basename)\n\n    metadata_file_object = \\\n      self._get_metadata_file(metadata_role, remote_filename,\n        upperbound_filelength, version)\n\n    # The metadata has been verified. Move the metadata file into place.\n    # First, move the 'current' metadata file to the 'previous' directory\n    # if it exists.\n    current_filepath = os.path.join(self.metadata_directory['current'],\n                local_filename)\n    current_filepath = os.path.abspath(current_filepath)\n    sslib_util.ensure_parent_dir(current_filepath)\n\n    previous_filepath = os.path.join(self.metadata_directory['previous'],\n        local_filename)\n    previous_filepath = os.path.abspath(previous_filepath)\n\n    if os.path.exists(current_filepath):\n      # Previous metadata might not exist, say when delegations are added.\n      sslib_util.ensure_parent_dir(previous_filepath)\n      shutil.move(current_filepath, previous_filepath)\n\n    # Next, move the verified updated metadata file to the 'current' directory.\n    metadata_file_object.seek(0)\n    metadata_signable = \\\n      sslib_util.load_json_string(metadata_file_object.read().decode('utf-8'))\n\n    sslib_util.persist_temp_file(metadata_file_object, current_filepath)\n\n    # Extract the metadata object so we can store it to the metadata store.\n    # 'current_metadata_object' set to 'None' if there is not an object\n    # stored for 'metadata_role'.\n    updated_metadata_object = metadata_signable['signed']\n    current_metadata_object = self.metadata['current'].get(metadata_role)\n\n    # Finally, update the metadata and fileinfo stores, and rebuild the\n    # key and role info for the top-level roles if 'metadata_role' is root.\n    # Rebuilding the key and role info is required if the newly-installed\n    # root metadata has revoked keys or updated any top-level role information.\n    logger.debug('Updated ' + repr(current_filepath) + '.')\n    self.metadata['previous'][metadata_role] = current_metadata_object\n    self.metadata['current'][metadata_role] = updated_metadata_object\n    self._update_versioninfo(remote_filename)",
  "diff_func": "--- func_before\n+++ func_after\n def _update_metadata(self, metadata_role, upperbound_filelength, version=None):\n     \"\"\"\n     <Purpose>\n       Non-public method that downloads, verifies, and 'installs' the metadata\n       belonging to 'metadata_role'.  Calling this method implies that the\n       'metadata_role' on the repository is newer than the client's, and thus\n       needs to be re-downloaded.  The current and previous metadata stores are\n       updated if the newly downloaded metadata is successfully downloaded and\n       verified.  This method also assumes that the store of top-level metadata\n       is the latest and exists.\n \n     <Arguments>\n       metadata_role:\n         The name of the metadata. This is a role name and should not end\n         in '.json'.  Examples: 'root', 'targets', 'targets/linux/x86'.\n \n       upperbound_filelength:\n         The expected length, or upper bound, of the metadata file to be\n         downloaded.\n \n       version:\n         The expected and required version number of the 'metadata_role' file\n         downloaded.  'expected_version' is an integer.\n \n     <Exceptions>\n       tuf.exceptions.NoWorkingMirrorError:\n         The metadata cannot be updated. This is not specific to a single\n         failure but rather indicates that all possible ways to update the\n         metadata have been tried and failed.\n \n     <Side Effects>\n       The metadata file belonging to 'metadata_role' is downloaded from a\n       repository mirror.  If the metadata is valid, it is stored in the\n       metadata store.\n \n     <Returns>\n       None.\n     \"\"\"\n \n-    # Construct the metadata filename as expected by the download/mirror\n-    # modules.\n-    metadata_filename = metadata_role + '.json'\n-\n     # Attempt a file download from each mirror until the file is downloaded and\n     # verified.  If the signature of the downloaded file is valid, proceed,\n     # otherwise log a warning and try the next mirror.  'metadata_file_object'\n     # is the file-like",
  "diff_source": "custom"
}