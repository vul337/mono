{
  "id": 4377,
  "language": "Python",
  "commit_url": "https://github.com/oppia/oppia/commit/25a9893061f82794d5fef5714957f262675190f1",
  "commit_sha": "25a9893061f82794d5fef5714957f262675190f1",
  "commit_msg": "Strengthen CSRF Protections\n\nAdds the following protections:\n* A nonce to prevent collisions. This is best practice per OWASP.\n* A constant-time comparison of expected and received tokens.\n* HMAC-SHA256 instead of HMAC-MD5. Even though HMAC-MD5 is not broken\n  yet, attacks against MD5 have been getting better, and there's no\n  reason not to switch to SHA256.",
  "pr_url": "https://github.com/oppia/oppia/pull/18769",
  "pr_info": "## Overview\r\n<!--\r\nREAD ME FIRST:\r\nPlease answer *both* questions below and check off every point from the Essential Checklist!\r\nIf there is no corresponding issue number, fill in N/A where it says [fill_in_number_here] below in 1.\r\n-->\r\n\r\n1. This PR fixes [GHSA-49jp-pjc3-2532](https://github.com/oppia/oppia/security/advisories/GHSA-49jp-pjc3-2532), an un-disclosed security vulnerability.\r\n2. This PR does the following: Adds the following protections:\r\n\r\n   * A nonce to prevent collisions. This is best practice per OWASP.\r\n   * A constant-time comparison of expected and received tokens. This prevents timing attacks.\r\n   * HMAC-SHA256 instead of HMAC-MD5. Even though HMAC-MD5 is not broken yet, attacks against MD5 have been getting better, and there's no reason not to switch to SHA256.\r\n   \r\n   For more details on CSRF and protections, see [OWASP's guidance](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#signed-double-submit-cookie).\r\n4. (For bug-fixing PRs only) The original bug occurred because: See security advisory (once disclosed).\r\n\r\n## Essential Checklist\r\n\r\n- [x] The **PR title** starts with \"Fix #bugnum: \" or \"Fix part of #bugnum: ...\",\r\nfollowed by a short, clear summary of the changes.\r\n- [x] I have followed the [instructions for making a code change](https://github.com/oppia/oppia/wiki/Make-a-pull-request).\r\n- [x] The linter/Karma presubmit checks have passed on my local machine.\r\n- [x] \"Allow edits from maintainers\" is checked. (See [here](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/allowing-changes-to-a-pull-request-branch-created-from-a-fork) for instructions on how to enable it.)\r\n- [x] I have assigned the correct reviewers to this PR (or will leave a\r\ncomment with the phrase \"@{{reviewer_username}} PTAL\" if I don't have\r\npermissions to assign reviewers directly).\r\n\r\n\r\n## Proof that changes are correct\r\n\r\nhttps://github.com/oppia/oppia/assets/19878639/a82fb601-7aa5-4b71-b5dc-86cc118267b6\r\n\r\n## PR Pointers\r\n\r\n- Never force push! If you do, your PR will be closed.\r\n- Make sure your PR follows the [style guide](https://github.com/oppia/oppia/wiki/Coding-style-guide), otherwise this will lead to review delays.\r\n- Some e2e tests are flaky, and can fail for reasons unrelated to your PR. We are working on fixing this, but in the meantime, if you need to restart the tests, please check the [\"If your build fails\" wiki page](https://github.com/oppia/oppia/wiki/If-CI-checks-fail-on-your-PR).\r\n- See the [Code Owner's wiki page](https://github.com/oppia/oppia/wiki/Oppia's-code-owners-and-checks-to-be-carried-out-by-developers) for what code owners will expect.\r\n",
  "file_name": "core/controllers/base.py",
  "func_name": "is_csrf_token_valid",
  "func_before": "def is_csrf_token_valid(cls, user_id: Optional[str], token: str) -> bool:\n        \"\"\"Validates a given CSRF token.\n\n        Args:\n            user_id: str|None. The user_id to validate the CSRF token against.\n            token: str. The CSRF token to validate.\n\n        Returns:\n            bool. Whether the given CSRF token is valid.\n        \"\"\"\n        try:\n            parts = token.split('/')\n            if len(parts) != 2:\n                return False\n\n            issued_on = int(parts[0])\n            age = cls._get_current_time() - issued_on\n            if age > cls._CSRF_TOKEN_AGE_SECS:\n                return False\n\n            authentic_token = cls._create_token(user_id, issued_on)\n            if authentic_token == token:\n                return True\n\n            return False\n        except Exception:\n            return False",
  "func_after": "def is_csrf_token_valid(cls, user_id: Optional[str], token: str) -> bool:\n        \"\"\"Validates a given CSRF token.\n\n        Args:\n            user_id: str|None. The user_id to validate the CSRF token against.\n            token: str. The CSRF token to validate.\n\n        Returns:\n            bool. Whether the given CSRF token is valid.\n        \"\"\"\n        try:\n            parts = token.split('/')\n            if len(parts) != 3:\n                return False\n\n            issued_on = int(parts[0])\n            age = cls._get_current_time() - issued_on\n            if age > cls._CSRF_TOKEN_AGE_SECS:\n                return False\n\n            nonce = parts[1]\n\n            authentic_token = cls._create_token(user_id, issued_on, nonce)\n            if hmac.compare_digest(\n                authentic_token.encode('utf-8'), token.encode('utf-8')\n            ):\n                return True\n\n            return False\n        except Exception:\n            return False",
  "diff_func": "--- func_before\n+++ func_after\n def is_csrf_token_valid(cls, user_id: Optional[str], token: str) -> bool:\n         \"\"\"Validates a given CSRF token.\n \n         Args:\n             user_id: str|None. The user_id to validate the CSRF token against.\n             token: str. The CSRF token to validate.\n \n         Returns:\n             bool. Whether the given CSRF token is valid.\n         \"\"\"\n         try:\n             parts = token.split('/')\n-            if len(parts) != 2:\n+            if len(parts) != 3:\n                 return False\n \n             issued_on = int(parts[0])\n             age = cls._get_current_time() - issued_on\n             if age > cls._CSRF_TOKEN_AGE_SECS:\n                 return False\n \n+            nonce = parts[1]\n+\n-            authentic_token = cls._create_token(user_id, issued_on)\n+            authentic_token = cls._create_token(user_id, issued_on, nonce)\n-            if authentic_token == token:\n+            if hmac.compare_digest(\n+                authentic_token.encode('utf-8'), token.encode('utf-8')\n+            ):\n                 return True\n \n             return False\n         except Exception:\n             return False",
  "diff_source": "custom"
}