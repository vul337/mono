{
  "id": 5683,
  "language": "C/C++",
  "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/b0e61972ff94e844fbb3ca927e476fc156c240a3",
  "commit_sha": "b0e61972ff94e844fbb3ca927e476fc156c240a3",
  "commit_msg": "Fixed leak reported in: #427.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "coders/svg.c",
  "func_name": "AcquireSVGInfo",
  "func_before": "static SVGInfo *AcquireSVGInfo(void)\n{\n  SVGInfo\n    *svg_info;\n\n  svg_info=(SVGInfo *) AcquireMagickMemory(sizeof(*svg_info));\n  if (svg_info == (SVGInfo *) NULL)\n    return((SVGInfo *) NULL);\n  (void) ResetMagickMemory(svg_info,0,sizeof(*svg_info));\n  svg_info->text=AcquireString(\"\");\n  svg_info->scale=(double *) AcquireMagickMemory(sizeof(*svg_info->scale));\n  if (svg_info->scale == (double *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetAffineMatrix(&svg_info->affine);\n  svg_info->scale[0]=ExpandAffine(&svg_info->affine);\n  return(svg_info);\n}",
  "func_after": "static Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  int\n    status,\n    unique_file;\n\n  ssize_t\n    n;\n\n  SVGInfo\n    *svg_info;\n\n  unsigned char\n    message[MagickPathExtent];\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->resolution.x) < MagickEpsilon) ||\n      (fabs(image->resolution.y) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n    {\n      const DelegateInfo\n        *delegate_info;\n\n      delegate_info=GetDelegateInfo(\"svg:decode\",(char *) NULL,exception);\n      if (delegate_info != (const DelegateInfo *) NULL)\n        {\n          char\n            background[MagickPathExtent],\n            command[MagickPathExtent],\n            *density,\n            input_filename[MagickPathExtent],\n            opacity[MagickPathExtent],\n            output_filename[MagickPathExtent],\n            unique[MagickPathExtent];\n\n          int\n            status;\n\n          struct stat\n            attributes;\n\n          /*\n            Our best hope of compliance with the SVG standard.\n          */\n          status=AcquireUniqueSymbolicLink(image->filename,input_filename);\n          (void) AcquireUniqueFilename(output_filename);\n          (void) AcquireUniqueFilename(unique);\n          density=AcquireString(\"\");\n          (void) FormatLocaleString(density,MagickPathExtent,\"%.20g,%.20g\",\n            image->resolution.x,image->resolution.y);\n          (void) FormatLocaleString(background,MagickPathExtent,\n            \"rgb(%.20g%%,%.20g%%,%.20g%%)\",\n            100.0*QuantumScale*image->background_color.red,\n            100.0*QuantumScale*image->background_color.green,\n            100.0*QuantumScale*image->background_color.blue);\n          (void) FormatLocaleString(opacity,MagickPathExtent,\"%.20g\",\n            QuantumScale*image->background_color.alpha);\n          (void) FormatLocaleString(command,MagickPathExtent,\n            GetDelegateCommands(delegate_info),input_filename,output_filename,\n            density,background,opacity,unique);\n          density=DestroyString(density);\n          status=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n            command,(char *) NULL,exception);\n          (void) RelinquishUniqueFileResource(unique);\n          (void) RelinquishUniqueFileResource(input_filename);\n          if ((status == 0) && (stat(output_filename,&attributes) == 0) &&\n              (attributes.st_size > 0))\n            {\n              Image\n                *svg_image;\n\n              ImageInfo\n                *read_info;\n\n              read_info=CloneImageInfo(image_info);\n              (void) CopyMagickString(read_info->filename,output_filename,\n                MagickPathExtent);\n              svg_image=ReadImage(read_info,exception);\n              read_info=DestroyImageInfo(read_info);\n              (void) RelinquishUniqueFileResource(output_filename);\n              if (svg_image != (Image *) NULL)\n                {\n                  image=DestroyImage(image);\n                  return(svg_image);\n                }\n            }\n          (void) RelinquishUniqueFileResource(output_filename);\n        }\n      {\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        cairo_surface_t\n          *cairo_surface;\n\n        cairo_t\n          *cairo_image;\n\n        MagickBooleanType\n          apply_density;\n\n        MemoryInfo\n          *pixel_info;\n\n        register unsigned char\n          *p;\n\n        RsvgDimensionData\n          dimension_info;\n\n        unsigned char\n          *pixels;\n\n#else\n        GdkPixbuf\n          *pixel_buffer;\n\n        register const guchar\n          *p;\n#endif\n\n        GError\n          *error;\n\n        PixelInfo\n          fill_color;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *q;\n\n        RsvgHandle\n          *svg_handle;\n\n        ssize_t\n          y;\n\n        svg_handle=rsvg_handle_new();\n        if (svg_handle == (RsvgHandle *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        rsvg_handle_set_base_uri(svg_handle,image_info->filename);\n        if ((fabs(image->resolution.x) > MagickEpsilon) &&\n            (fabs(image->resolution.y) > MagickEpsilon))\n          rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n            image->resolution.y);\n        while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n        {\n          message[n]='\\0';\n          error=(GError *) NULL;\n          (void) rsvg_handle_write(svg_handle,message,n,&error);\n          if (error != (GError *) NULL)\n            g_error_free(error);\n        }\n        error=(GError *) NULL;\n        rsvg_handle_close(svg_handle,&error);\n        if (error != (GError *) NULL)\n          g_error_free(error);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        apply_density=MagickTrue;\n        rsvg_handle_get_dimensions(svg_handle,&dimension_info);\n        if ((image->resolution.x > 0.0) && (image->resolution.y > 0.0))\n          {\n            RsvgDimensionData\n              dpi_dimension_info;\n\n            /*\n              We should not apply the density when the internal 'factor' is 'i'.\n              This can be checked by using the trick below.\n            */\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x*256,\n              image->resolution.y*256);\n            rsvg_handle_get_dimensions(svg_handle,&dpi_dimension_info);\n            if ((dpi_dimension_info.width != dimension_info.width) ||\n                (dpi_dimension_info.height != dimension_info.height))\n              apply_density=MagickFalse;\n            rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n              image->resolution.y);\n          }\n        if (image_info->size != (char *) NULL)\n          {\n            (void) GetGeometry(image_info->size,(ssize_t *) NULL,\n              (ssize_t *) NULL,&image->columns,&image->rows);\n            if ((image->columns != 0) || (image->rows != 0))\n              {\n                image->resolution.x=90.0*image->columns/dimension_info.width;\n                image->resolution.y=90.0*image->rows/dimension_info.height;\n                if (fabs(image->resolution.x) < MagickEpsilon)\n                  image->resolution.x=image->resolution.y;\n                else\n                  if (fabs(image->resolution.y) < MagickEpsilon)\n                    image->resolution.y=image->resolution.x;\n                  else\n                    image->resolution.x=image->resolution.y=MagickMin(\n                      image->resolution.x,image->resolution.y);\n                apply_density=MagickTrue;\n              }\n          }\n        if (apply_density != MagickFalse)\n          {\n            image->columns=image->resolution.x*dimension_info.width/90.0;\n            image->rows=image->resolution.y*dimension_info.height/90.0;\n          }\n        else\n          {\n            image->columns=dimension_info.width;\n            image->rows=dimension_info.height;\n          }\n        pixel_info=(MemoryInfo *) NULL;\n#else\n        pixel_buffer=rsvg_handle_get_pixbuf(svg_handle);\n        rsvg_handle_free(svg_handle);\n        image->columns=gdk_pixbuf_get_width(pixel_buffer);\n        image->rows=gdk_pixbuf_get_height(pixel_buffer);\n#endif\n        image->alpha_trait=BlendPixelTrait;\n        SetImageProperty(image,\"svg:base-uri\",\n          rsvg_handle_get_base_uri(svg_handle),exception);\n        status=SetImageExtent(image,image->columns,image->rows,exception);\n        if (status == MagickFalse)\n          {\n#if !defined(MAGICKCORE_CAIRO_DELEGATE)\n            g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n            g_object_unref(svg_handle);\n            ThrowReaderException(MissingDelegateError,\n              \"NoDecodeDelegateForThisImageFormat\");\n          }\n        if (image_info->ping == MagickFalse)\n          {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            size_t\n              stride;\n\n            stride=4*image->columns;\n#if defined(MAGICKCORE_PANGOCAIRO_DELEGATE)\n            stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n              (int) image->columns);\n#endif\n            pixel_info=AcquireVirtualMemory(stride,image->rows*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n#endif\n            (void) SetImageBackgroundColor(image,exception);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            cairo_surface=cairo_image_surface_create_for_data(pixels,\n              CAIRO_FORMAT_ARGB32,(int) image->columns,(int) image->rows,(int)\n              stride);\n            if (cairo_surface == (cairo_surface_t *) NULL)\n              {\n                pixel_info=RelinquishVirtualMemory(pixel_info);\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            cairo_image=cairo_create(cairo_surface);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n            cairo_paint(cairo_image);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n            if (apply_density != MagickFalse)\n              cairo_scale(cairo_image,image->resolution.x/90.0,\n                image->resolution.y/90.0);\n            rsvg_handle_render_cairo(svg_handle,cairo_image);\n            cairo_destroy(cairo_image);\n            cairo_surface_destroy(cairo_surface);\n            g_object_unref(svg_handle);\n            p=pixels;\n#else\n            p=gdk_pixbuf_get_pixels(pixel_buffer);\n#endif\n            GetPixelInfo(image,&fill_color);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                fill_color.blue=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.red=ScaleCharToQuantum(*p++);\n#else\n                fill_color.red=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.blue=ScaleCharToQuantum(*p++);\n#endif\n                fill_color.alpha=ScaleCharToQuantum(*p++);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                {\n                  double\n                    gamma;\n\n                  gamma=QuantumScale*fill_color.alpha;\n                  gamma=PerceptibleReciprocal(gamma);\n                  fill_color.blue*=gamma;\n                  fill_color.green*=gamma;\n                  fill_color.red*=gamma;\n                }\n#endif\n                CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n                  GetPixelAlpha(image,q),q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n#else\n        g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n#endif\n      }\n    }\n  /*\n    Open draw file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"w\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Parse SVG file.\n  */\n  svg_info=AcquireSVGInfo();\n  if (svg_info == (SVGInfo *) NULL)\n    {\n      (void) fclose(file);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  svg_info->file=file;\n  svg_info->exception=exception;\n  svg_info->image=image;\n  svg_info->image_info=image_info;\n  svg_info->bounds.width=image->columns;\n  svg_info->bounds.height=image->rows;\n  if (image_info->size != (char *) NULL)\n    (void) CloneString(&svg_info->size,image_info->size);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"begin SAX\");\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=SVGInternalSubset;\n  sax_modules.isStandalone=SVGIsStandalone;\n  sax_modules.hasInternalSubset=SVGHasInternalSubset;\n  sax_modules.hasExternalSubset=SVGHasExternalSubset;\n  sax_modules.resolveEntity=SVGResolveEntity;\n  sax_modules.getEntity=SVGGetEntity;\n  sax_modules.entityDecl=SVGEntityDeclaration;\n  sax_modules.notationDecl=SVGNotationDeclaration;\n  sax_modules.attributeDecl=SVGAttributeDeclaration;\n  sax_modules.elementDecl=SVGElementDeclaration;\n  sax_modules.unparsedEntityDecl=SVGUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=SVGSetDocumentLocator;\n  sax_modules.startDocument=SVGStartDocument;\n  sax_modules.endDocument=SVGEndDocument;\n  sax_modules.startElement=SVGStartElement;\n  sax_modules.endElement=SVGEndElement;\n  sax_modules.reference=SVGReference;\n  sax_modules.characters=SVGCharacters;\n  sax_modules.ignorableWhitespace=SVGIgnorableWhitespace;\n  sax_modules.processingInstruction=SVGProcessingInstructions;\n  sax_modules.comment=SVGComment;\n  sax_modules.warning=SVGWarning;\n  sax_modules.error=SVGError;\n  sax_modules.fatalError=SVGError;\n  sax_modules.getParameterEntity=SVGGetParameterEntity;\n  sax_modules.cdataBlock=SVGCDataBlock;\n  sax_modules.externalSubset=SVGExternalSubset;\n  sax_handler=(&sax_modules);\n  n=ReadBlob(image,MagickPathExtent-1,message);\n  message[n]='\\0';\n  if (n > 0)\n    {\n      svg_info->parser=xmlCreatePushParserCtxt(sax_handler,svg_info,(char *)\n        message,n,image->filename);\n      while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n      {\n        message[n]='\\0';\n        status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n        if (status != 0)\n          break;\n      }\n    }\n  (void) xmlParseChunk(svg_info->parser,(char *) message,0,1);\n  SVGEndDocument(svg_info);\n  xmlFreeParserCtxt(svg_info->parser);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image->columns=svg_info->width;\n  image->rows=svg_info->height;\n  if (exception->severity >= ErrorException)\n    {\n      svg_info=DestroySVGInfo(svg_info);\n      (void) RelinquishUniqueFileResource(filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (image_info->ping == MagickFalse)\n    {\n      ImageInfo\n        *read_info;\n\n      /*\n        Draw image.\n      */\n      image=DestroyImage(image);\n      image=(Image *) NULL;\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      if (read_info->density != (char *) NULL)\n        read_info->density=DestroyString(read_info->density);\n      (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"mvg:%s\",\n        filename);\n      image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MagickPathExtent);\n    }\n  /*\n    Relinquish resources.\n  */\n  if (image != (Image *) NULL)\n    {\n      if (svg_info->title != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:title\",svg_info->title,exception);\n      if (svg_info->comment != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:comment\",svg_info->comment,\n          exception);\n    }\n  svg_info=DestroySVGInfo(svg_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}",
  "diff_func": "--- func_before\n+++ func_after\n-static SVGInfo *AcquireSVGInfo(void)\n+static Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n+  char\n+    filename[MagickPathExtent];\n+\n+  FILE\n+    *file;\n+\n+  Image\n+    *image;\n+\n+  int\n+    status,\n+    unique_file;\n+\n+  ssize_t\n+    n;\n+\n   SVGInfo\n     *svg_info;\n \n-  svg_info=(SVGInfo *) AcquireMagickMemory(sizeof(*svg_info));\n+  unsigned char\n+    message[MagickPathExtent];\n+\n+  xmlSAXHandler\n+    sax_modules;\n+\n+  xmlSAXHandlerPtr\n+    sax_handler;\n+\n+  /*\n+    Open image file.\n+  */\n+  assert(image_info != (const ImageInfo *) NULL);\n+  assert(image_info->signature == MagickCoreSignature);\n+  assert(exception != (ExceptionInfo *) NULL);\n+  if (image_info->debug != MagickFalse)\n+    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n+      image_info->filename);\n+  assert(exception->signature == MagickCoreSignature);\n+  image=AcquireImage(image_info,exception);\n+  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n+  if (status == MagickFalse)\n+    {\n+      image=DestroyImageList(image);\n+      return((Image *) NULL);\n+    }\n+  if ((fabs(image->resolution.x) < MagickEpsilon) ||\n+      (fabs(image->resolution.y) < MagickEpsilon))\n+    {\n+      GeometryInfo\n+        geometry_info;\n+\n+      int\n+        flags;\n+\n+      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n+      image->resolution.x=geometry_info.rho;\n+      image->resolution.y=geometry_info.sigma;\n+      if ((flags & SigmaValue) == 0)\n+        image->resolution.y=image->resolution.x;\n+    }\n+  if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n+    {\n+      const DelegateInfo\n+        *delegate_info;\n+\n+      delegate_info=GetDelegateInfo(\"svg:decode\",(char *) NULL,exception);\n+      if (delegate_info != (const DelegateInfo *) NULL)\n+        {\n+          char\n+            background[MagickPathExtent],\n+            command[MagickPathExtent],\n+            *density,\n+            input_filename[MagickPathExtent],\n+   ",
  "diff_source": "custom"
}