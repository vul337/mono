{
  "id": 2602,
  "language": "Java",
  "commit_url": "https://github.com/GrapheneOS/platform_frameworks_base/commit/b8488603d6932262e652b740cbf75b9d580caffb",
  "commit_sha": "b8488603d6932262e652b740cbf75b9d580caffb",
  "commit_msg": "Avoid a SecurityExcetion crash\n\n1. Instead of throwing SecurityException, log the error.\n2. Set isAttributionTagNotFound to true when the attributionTag is not\nnull but not found in the package attributions.\n\nFix: 188549667\n\nTest: N/A\nChange-Id: I75a217893353ee5fe5d191e2b78ccf391847adb6",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
  "func_name": "verifyAndGetBypass",
  "func_before": "private @Nullable RestrictionBypass verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return null;\n        }\n\n        // Do not check if uid/packageName/attributionTag is already known\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && uidState.pkgOps != null) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return ops.bypass;\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n\n        // Allow any attribution tag for resolvable uids\n        int pkgUid = resolveUid(packageName);\n        if (pkgUid != Process.INVALID_UID) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            if (pkgUid != UserHandle.getAppId(uid)) {\n                throw new SecurityException(\"Specified package \" + packageName + \" under uid \"\n                        +  UserHandle.getAppId(uid) + \" but it is really \" + pkgUid);\n            }\n            return RestrictionBypass.UNRESTRICTED;\n        }\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            boolean isAttributionTagValid = false;\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            AndroidPackage pkg = pmInt.getPackage(packageName);\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n\n                pkgUid = UserHandle.getUid(userId, UserHandle.getAppId(pkg.getUid()));\n                bypass = getBypassforPackage(pkg);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                boolean foundInProxy = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && foundInProxy) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) && mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid) && !foundInProxy) {\n                        throw new SecurityException(msg);\n                    } else {\n                        Slog.e(TAG, msg);\n                    }\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            throw new SecurityException(\"Specified package \" + packageName + \" under uid \" + uid\n                    + \" but it is really \" + pkgUid);\n        }\n\n        return bypass;\n    }",
  "func_after": "private @Nullable RestrictionBypass verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return null;\n        }\n\n        // Do not check if uid/packageName/attributionTag is already known\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && uidState.pkgOps != null) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return ops.bypass;\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n\n        // Allow any attribution tag for resolvable uids\n        int pkgUid = resolveUid(packageName);\n        if (pkgUid != Process.INVALID_UID) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            if (pkgUid != UserHandle.getAppId(uid)) {\n                throw new SecurityException(\"Specified package \" + packageName + \" under uid \"\n                        +  UserHandle.getAppId(uid) + \" but it is really \" + pkgUid);\n            }\n            return RestrictionBypass.UNRESTRICTED;\n        }\n\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            boolean isAttributionTagValid = false;\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            AndroidPackage pkg = pmInt.getPackage(packageName);\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n\n                pkgUid = UserHandle.getUid(userId, UserHandle.getAppId(pkg.getUid()));\n                bypass = getBypassforPackage(pkg);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                boolean foundInProxy = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && foundInProxy) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                    bypass.setIsAttributionTagNotFound(true);\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) && mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid) && !foundInProxy) {\n                        Slog.e(TAG, msg);\n                    } else {\n                        Slog.e(TAG, msg);\n                    }\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            throw new SecurityException(\"Specified package \" + packageName + \" under uid \" + uid\n                    + \" but it is really \" + pkgUid);\n        }\n\n        return bypass;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n private @Nullable RestrictionBypass verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag, @Nullable String proxyPackageName) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n             return null;\n         }\n \n         // Do not check if uid/packageName/attributionTag is already known\n         synchronized (this) {\n             UidState uidState = mUidStates.get(uid);\n             if (uidState != null && uidState.pkgOps != null) {\n                 Ops ops = uidState.pkgOps.get(packageName);\n \n                 if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                         attributionTag)) && ops.bypass != null) {\n                     return ops.bypass;\n                 }\n             }\n         }\n \n         int callingUid = Binder.getCallingUid();\n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n \n         // Allow any attribution tag for resolvable uids\n         int pkgUid = resolveUid(packageName);\n         if (pkgUid != Process.INVALID_UID) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n             if (pkgUid != UserHandle.getAppId(uid)) {\n                 throw new SecurityException(\"Specified package \" + packageName + \" under uid \"\n                         +  UserHandle.getAppId(uid) + \" but it is really \" + pkgUid);\n             }\n             return RestrictionBypass.UNRESTRICTED;\n         }\n \n         final long ident = Binder.clearCallingIdentity();\n         try {\n             boolean isAttributionTagValid = false;\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n             AndroidPackage pkg = pmInt.getPackage(packageName);\n             if (pkg != null) {\n                 isAtt",
  "diff_source": "custom"
}