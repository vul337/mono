{
  "id": 4616,
  "language": "Python",
  "commit_url": "https://github.com/davedoesdev/python-jwt/commit/88ad9e67c53aa5f7c43ec4aa52ed34b7930068c9",
  "commit_sha": "88ad9e67c53aa5f7c43ec4aa52ed34b7930068c9",
  "commit_msg": "FIX VULNERABILITY\n\njwcrypto accepts both compact and JSON formats.\nIt was possible to use this to present a token with arbitrary\nclaims with a signature from another valid token.\n\nSee test/vulnerability_vows.py for an example.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "python_jwt/__init__.py",
  "func_name": "verify_jwt",
  "func_before": "def verify_jwt(jwt,\n               pub_key=None,\n               allowed_algs=None,\n               iat_skew=timedelta(),\n               checks_optional=False,\n               ignore_not_implemented=False):\n    \"\"\"\n    Verify a JSON Web Token.\n\n    :param jwt: The JSON Web Token to verify.\n    :type jwt: str or unicode\n\n    :param pub_key: The public key to be used to verify the token. Note: if you pass ``None`` and **allowed_algs** contains ``none`` then the token's signature will not be verified.\n    :type pub_key: `jwcrypto.jwk.JWK <https://jwcrypto.readthedocs.io/en/latest/jwk.html>`_\n\n    :param allowed_algs: Algorithms expected to be used to sign the token. The ``in`` operator is used to test membership.\n    :type allowed_algs: list or NoneType (meaning an empty list)\n\n    :param iat_skew: The amount of leeway to allow between the issuer's clock and the verifier's clock when verifying that the token was generated in the past. Defaults to no leeway.\n    :type iat_skew: datetime.timedelta\n\n    :param checks_optional: If ``False``, then the token must contain the **typ** header property and the **iat**, **nbf** and **exp** claim properties.\n    :type checks_optional: bool\n\n    :param ignore_not_implemented: If ``False``, then the token must *not* contain the **jku**, **jwk**, **x5u**, **x5c** or **x5t** header properties.\n    :type ignore_not_implemented: bool\n\n    :rtype: tuple\n    :returns: ``(header, claims)`` if the token was verified successfully. The token must pass the following tests:\n\n    - Its header must contain a property **alg** with a value in **allowed_algs**.\n    - Its signature must verify using **pub_key** (unless its algorithm is ``none`` and ``none`` is in **allowed_algs**).\n    - If the corresponding property is present or **checks_optional** is ``False``:\n\n      - Its header must contain a property **typ** with the value ``JWT``.\n      - Its claims must contain a property **iat** which represents a date in the past (taking into account :obj:`iat_skew`).\n      - Its claims must contain a property **nbf** which represents a date in the past.\n      - Its claims must contain a property **exp** which represents a date in the future.\n\n    :raises: If the token failed to verify.\n    \"\"\"\n    if allowed_algs is None:\n        allowed_algs = []\n\n    if not isinstance(allowed_algs, list):\n        # jwcrypto only supports list of allowed algorithms\n        raise _JWTError('allowed_algs must be a list')\n\n    header, claims, _ = jwt.split('.')\n\n    parsed_header = json_decode(base64url_decode(header))\n\n    alg = parsed_header.get('alg')\n    if alg is None:\n        raise _JWTError('alg header not present')\n    if alg not in allowed_algs:\n        raise _JWTError('algorithm not allowed: ' + alg)\n\n    if not ignore_not_implemented:\n        for k in parsed_header:\n            if k not in JWSHeaderRegistry:\n                raise _JWTError('unknown header: ' + k)\n            if not JWSHeaderRegistry[k].supported:\n                raise _JWTError('header not implemented: ' + k)\n\n    if pub_key:\n        token = JWS()\n        token.allowed_algs = allowed_algs\n        token.deserialize(jwt, pub_key)\n    elif 'none' not in allowed_algs:\n        raise _JWTError('no key but none alg not allowed')\n\n    parsed_claims = json_decode(base64url_decode(claims))\n\n    utcnow = datetime.utcnow()\n    now = timegm(utcnow.utctimetuple())\n\n    typ = parsed_header.get('typ')\n    if typ is None:\n        if not checks_optional:\n            raise _JWTError('typ header not present')\n    elif typ != 'JWT':\n        raise _JWTError('typ header is not JWT')\n\n    iat = parsed_claims.get('iat')\n    if iat is None:\n        if not checks_optional:\n            raise _JWTError('iat claim not present')\n    elif iat > timegm((utcnow + iat_skew).utctimetuple()):\n        raise _JWTError('issued in the future')\n\n    nbf = parsed_claims.get('nbf')\n    if nbf is None:\n        if not checks_optional:\n            raise _JWTError('nbf claim not present')\n    elif nbf > now:\n        raise _JWTError('not yet valid')\n\n    exp = parsed_claims.get('exp')\n    if exp is None:\n        if not checks_optional:\n            raise _JWTError('exp claim not present')\n    elif exp <= now:\n        raise _JWTError('expired')\n\n    return parsed_header, parsed_claims",
  "func_after": "def verify_jwt(jwt,\n               pub_key=None,\n               allowed_algs=None,\n               iat_skew=timedelta(),\n               checks_optional=False,\n               ignore_not_implemented=False):\n    \"\"\"\n    Verify a JSON Web Token.\n\n    :param jwt: The JSON Web Token to verify.\n    :type jwt: str or unicode\n\n    :param pub_key: The public key to be used to verify the token. Note: if you pass ``None`` and **allowed_algs** contains ``none`` then the token's signature will not be verified.\n    :type pub_key: `jwcrypto.jwk.JWK <https://jwcrypto.readthedocs.io/en/latest/jwk.html>`_\n\n    :param allowed_algs: Algorithms expected to be used to sign the token. The ``in`` operator is used to test membership.\n    :type allowed_algs: list or NoneType (meaning an empty list)\n\n    :param iat_skew: The amount of leeway to allow between the issuer's clock and the verifier's clock when verifying that the token was generated in the past. Defaults to no leeway.\n    :type iat_skew: datetime.timedelta\n\n    :param checks_optional: If ``False``, then the token must contain the **typ** header property and the **iat**, **nbf** and **exp** claim properties.\n    :type checks_optional: bool\n\n    :param ignore_not_implemented: If ``False``, then the token must *not* contain the **jku**, **jwk**, **x5u**, **x5c** or **x5t** header properties.\n    :type ignore_not_implemented: bool\n\n    :rtype: tuple\n    :returns: ``(header, claims)`` if the token was verified successfully. The token must pass the following tests:\n\n    - Its header must contain a property **alg** with a value in **allowed_algs**.\n    - Its signature must verify using **pub_key** (unless its algorithm is ``none`` and ``none`` is in **allowed_algs**).\n    - If the corresponding property is present or **checks_optional** is ``False``:\n\n      - Its header must contain a property **typ** with the value ``JWT``.\n      - Its claims must contain a property **iat** which represents a date in the past (taking into account :obj:`iat_skew`).\n      - Its claims must contain a property **nbf** which represents a date in the past.\n      - Its claims must contain a property **exp** which represents a date in the future.\n\n    :raises: If the token failed to verify.\n    \"\"\"\n    #pylint: disable=too-many-statements\n\n    _check_jwt_format(jwt)\n\n    if allowed_algs is None:\n        allowed_algs = []\n\n    if not isinstance(allowed_algs, list):\n        # jwcrypto only supports list of allowed algorithms\n        raise _JWTError('allowed_algs must be a list')\n\n    header, claims, _ = jwt.split('.')\n\n    parsed_header = json_decode(base64url_decode(header))\n\n    alg = parsed_header.get('alg')\n    if alg is None:\n        raise _JWTError('alg header not present')\n    if alg not in allowed_algs:\n        raise _JWTError('algorithm not allowed: ' + alg)\n\n    if not ignore_not_implemented:\n        for k in parsed_header:\n            if k not in JWSHeaderRegistry:\n                raise _JWTError('unknown header: ' + k)\n            if not JWSHeaderRegistry[k].supported:\n                raise _JWTError('header not implemented: ' + k)\n\n    if pub_key:\n        token = JWS()\n        token.allowed_algs = allowed_algs\n        token.deserialize(jwt, pub_key)\n        parsed_claims = json_decode(token.payload)\n    elif 'none' not in allowed_algs:\n        raise _JWTError('no key but none alg not allowed')\n    else:\n        parsed_claims = json_decode(base64url_decode(claims))\n\n    utcnow = datetime.utcnow()\n    now = timegm(utcnow.utctimetuple())\n\n    typ = parsed_header.get('typ')\n    if typ is None:\n        if not checks_optional:\n            raise _JWTError('typ header not present')\n    elif typ != 'JWT':\n        raise _JWTError('typ header is not JWT')\n\n    iat = parsed_claims.get('iat')\n    if iat is None:\n        if not checks_optional:\n            raise _JWTError('iat claim not present')\n    elif iat > timegm((utcnow + iat_skew).utctimetuple()):\n        raise _JWTError('issued in the future')\n\n    nbf = parsed_claims.get('nbf')\n    if nbf is None:\n        if not checks_optional:\n            raise _JWTError('nbf claim not present')\n    elif nbf > now:\n        raise _JWTError('not yet valid')\n\n    exp = parsed_claims.get('exp')\n    if exp is None:\n        if not checks_optional:\n            raise _JWTError('exp claim not present')\n    elif exp <= now:\n        raise _JWTError('expired')\n\n    return parsed_header, parsed_claims",
  "diff_func": "--- func_before\n+++ func_after\n def verify_jwt(jwt,\n                pub_key=None,\n                allowed_algs=None,\n                iat_skew=timedelta(),\n                checks_optional=False,\n                ignore_not_implemented=False):\n     \"\"\"\n     Verify a JSON Web Token.\n \n     :param jwt: The JSON Web Token to verify.\n     :type jwt: str or unicode\n \n     :param pub_key: The public key to be used to verify the token. Note: if you pass ``None`` and **allowed_algs** contains ``none`` then the token's signature will not be verified.\n     :type pub_key: `jwcrypto.jwk.JWK <https://jwcrypto.readthedocs.io/en/latest/jwk.html>`_\n \n     :param allowed_algs: Algorithms expected to be used to sign the token. The ``in`` operator is used to test membership.\n     :type allowed_algs: list or NoneType (meaning an empty list)\n \n     :param iat_skew: The amount of leeway to allow between the issuer's clock and the verifier's clock when verifying that the token was generated in the past. Defaults to no leeway.\n     :type iat_skew: datetime.timedelta\n \n     :param checks_optional: If ``False``, then the token must contain the **typ** header property and the **iat**, **nbf** and **exp** claim properties.\n     :type checks_optional: bool\n \n     :param ignore_not_implemented: If ``False``, then the token must *not* contain the **jku**, **jwk**, **x5u**, **x5c** or **x5t** header properties.\n     :type ignore_not_implemented: bool\n \n     :rtype: tuple\n     :returns: ``(header, claims)`` if the token was verified successfully. The token must pass the following tests:\n \n     - Its header must contain a property **alg** with a value in **allowed_algs**.\n     - Its signature must verify using **pub_key** (unless its algorithm is ``none`` and ``none`` is in **allowed_algs**).\n     - If the corresponding property is present or **checks_optional** is ``False``:\n \n       - Its header must contain a property **typ** with the value ``JWT``.\n       - Its claims must contain a property **iat*",
  "diff_source": "custom"
}