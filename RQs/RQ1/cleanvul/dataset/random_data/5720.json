{
  "id": 5720,
  "language": "C/C++",
  "commit_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
  "commit_sha": "34a08bec755670ea0490cb53bbc68058cafc69b6",
  "commit_msg": "cryp: prevent direct calls to update and final functions\n\nWith inconsistent or malformed data it has been possible to call\n\"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1]\nwe have seen that this results in asserts, i.e., a crash that\npotentially could leak sensitive information.\n\nBy setting the state (initialized) in the crypto context (i.e., the\ntee_cryp_state) at the end of all syscall_*_init functions and then add\na check of the state at the beginning of all update and final functions,\n  we prevent direct entrance to the \"update\" and \"final\" functions.\n\n[1] https://github.com/MartijnB/optee_fuzzer\n\nFixes: OP-TEE-2019-0021\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Martijn Bogaard <bogaard@riscure.com>\nAcked-by: Jerome Forissier <jerome.forissier@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/3316",
  "pr_info": "Fixes for potential security issues found by Riscure's fuzzer tool.\r\n\r\nI've tested this in QEMU v7, no regressions seen.\r\n```bash\r\n24105 subtests of which 0 failed\r\n96 test cases of which 0 failed\r\n0 test cases were skipped\r\nTEE test application done!\r\n```",
  "file_name": "core/tee/tee_svc_cryp.c",
  "func_name": "syscall_authenc_enc_final",
  "func_before": "TEE_Result syscall_authenc_enc_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n\t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}",
  "func_after": "TEE_Result syscall_authenc_enc_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n\t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}",
  "diff_func": "--- func_before\n+++ func_after\n TEE_Result syscall_authenc_enc_final(unsigned long state,\n \t\t\tconst void *src_data, size_t src_len, void *dst_data,\n \t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n {\n \tTEE_Result res;\n \tstruct tee_cryp_state *cs;\n \tstruct tee_ta_session *sess;\n \tsize_t dlen = 0;\n \tsize_t tlen = 0;\n \n \tres = tee_ta_get_current_session(&sess);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n \tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n+\n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n \n \tif (cs->mode != TEE_MODE_ENCRYPT)\n \t\treturn TEE_ERROR_BAD_PARAMETERS;\n \n \tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n \t\treturn TEE_ERROR_BAD_STATE;\n \n \tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n \t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n \t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n \t\t\t\t\t  (uaddr_t)src_data, src_len);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n \tif (!dst_len) {\n \t\tdlen = 0;\n \t} else {\n \t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n \t\tif (res != TEE_SUCCESS)\n \t\t\treturn res;\n \n \t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n \t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n \t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n \t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n \t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n \t\tif (res != TEE_SUCCESS)\n \t\t\treturn res;\n \t}\n \n \tif (dlen < src_len) {\n \t\tres = TEE_ERROR_SHORT_BUFFER;\n \t\tgoto out;\n \t}\n \n \tres = get_user_u64_as_size_t(&tlen, tag_len);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n \tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n \t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n \t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n \t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n \t\t\t\t\t  (uaddr_t)tag, tlen);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n \tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n \t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n \n out:\n \tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n \t\tTEE_Result res2;\n \n \t\tif (dst_len != NULL) ",
  "diff_source": "custom"
}