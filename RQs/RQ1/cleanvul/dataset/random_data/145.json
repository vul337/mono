{
  "id": 145,
  "language": "Java",
  "commit_url": "https://github.com/LineageOS/android_frameworks_base/commit/07d74c4c28d622b65085a602f42793fda1791401",
  "commit_sha": "07d74c4c28d622b65085a602f42793fda1791401",
  "commit_msg": "[RESTRICT AUTOMERGE] Revert \"Persist destroyed staged sessions until they are cleaned up\"\n\nRevert submission 16575908-dont_abandon_child_qt_dev\n\nReason for revert:  Reverting CVE-2021-39624 on qt-dev\nReverted Changes:\nI4ede6b7a4:Persist destroyed staged sessions until they are c...\nIb0ba9f378:Don't abandon child sessions (1/n)\n\nChange-Id: I50ab96061b2e0fa016a0fbdb5773ccc5f2397ac6",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/pm/PackageInstallerSession.java",
  "func_name": "readFromXml",
  "func_before": "public static PackageInstallerSession readFromXml(@NonNull XmlPullParser in,\n            @NonNull PackageInstallerService.InternalCallback callback, @NonNull Context context,\n            @NonNull PackageManagerService pm, Looper installerThread,\n            @NonNull StagingManager stagingManager, @NonNull File sessionsDir,\n            @NonNull PackageSessionProvider sessionProvider)\n            throws IOException, XmlPullParserException {\n        final int sessionId = readIntAttribute(in, ATTR_SESSION_ID);\n        final int userId = readIntAttribute(in, ATTR_USER_ID);\n        final String installerPackageName = readStringAttribute(in, ATTR_INSTALLER_PACKAGE_NAME);\n        final int installerUid = readIntAttribute(in, ATTR_INSTALLER_UID, pm.getPackageUid(\n                installerPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, userId));\n        final long createdMillis = readLongAttribute(in, ATTR_CREATED_MILLIS);\n        long updatedMillis = readLongAttribute(in, ATTR_UPDATED_MILLIS);\n        final String stageDirRaw = readStringAttribute(in, ATTR_SESSION_STAGE_DIR);\n        final File stageDir = (stageDirRaw != null) ? new File(stageDirRaw) : null;\n        final String stageCid = readStringAttribute(in, ATTR_SESSION_STAGE_CID);\n        final boolean prepared = readBooleanAttribute(in, ATTR_PREPARED, true);\n        final boolean committed = readBooleanAttribute(in, ATTR_COMMITTED);\n        final boolean destroyed = readBooleanAttribute(in, ATTR_DESTROYED);\n        final boolean sealed = readBooleanAttribute(in, ATTR_SEALED);\n        final int parentSessionId = readIntAttribute(in, ATTR_PARENT_SESSION_ID,\n                SessionInfo.INVALID_ID);\n\n        final SessionParams params = new SessionParams(\n                SessionParams.MODE_INVALID);\n        params.isMultiPackage = readBooleanAttribute(in, ATTR_MULTI_PACKAGE, false);\n        params.isStaged = readBooleanAttribute(in, ATTR_STAGED_SESSION, false);\n        params.mode = readIntAttribute(in, ATTR_MODE);\n        params.installFlags = readIntAttribute(in, ATTR_INSTALL_FLAGS);\n        params.installLocation = readIntAttribute(in, ATTR_INSTALL_LOCATION);\n        params.sizeBytes = readLongAttribute(in, ATTR_SIZE_BYTES);\n        params.appPackageName = readStringAttribute(in, ATTR_APP_PACKAGE_NAME);\n        params.appIcon = readBitmapAttribute(in, ATTR_APP_ICON);\n        params.appLabel = readStringAttribute(in, ATTR_APP_LABEL);\n        params.originatingUri = readUriAttribute(in, ATTR_ORIGINATING_URI);\n        params.originatingUid =\n                readIntAttribute(in, ATTR_ORIGINATING_UID, SessionParams.UID_UNKNOWN);\n        params.referrerUri = readUriAttribute(in, ATTR_REFERRER_URI);\n        params.abiOverride = readStringAttribute(in, ATTR_ABI_OVERRIDE);\n        params.volumeUuid = readStringAttribute(in, ATTR_VOLUME_UUID);\n        params.installReason = readIntAttribute(in, ATTR_INSTALL_REASON);\n\n        final File appIconFile = buildAppIconFile(sessionId, sessionsDir);\n        if (appIconFile.exists()) {\n            params.appIcon = BitmapFactory.decodeFile(appIconFile.getAbsolutePath());\n            params.appIconLastModified = appIconFile.lastModified();\n        }\n        final boolean isReady = readBooleanAttribute(in, ATTR_IS_READY);\n        final boolean isFailed = readBooleanAttribute(in, ATTR_IS_FAILED);\n        final boolean isApplied = readBooleanAttribute(in, ATTR_IS_APPLIED);\n        final int stagedSessionErrorCode = readIntAttribute(in, ATTR_STAGED_SESSION_ERROR_CODE,\n                SessionInfo.STAGED_SESSION_NO_ERROR);\n        final String stagedSessionErrorMessage = readStringAttribute(in,\n                ATTR_STAGED_SESSION_ERROR_MESSAGE);\n\n        if (!isStagedSessionStateValid(isReady, isApplied, isFailed)) {\n            throw new IllegalArgumentException(\"Can't restore staged session with invalid state.\");\n        }\n\n        // Parse sub tags of this session, typically used for repeated values / arrays.\n        // Sub tags can come in any order, therefore we need to keep track of what we find while\n        // parsing and only set the right values at the end.\n\n        // Store the current depth. We should stop parsing when we reach an end tag at the same\n        // depth.\n        List<String> grantedRuntimePermissions = new ArrayList<>();\n        List<String> whitelistedRestrictedPermissions = new ArrayList<>();\n        List<Integer> childSessionIds = new ArrayList<>();\n        int outerDepth = in.getDepth();\n        int type;\n        while ((type = in.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || in.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            if (TAG_GRANTED_RUNTIME_PERMISSION.equals(in.getName())) {\n                grantedRuntimePermissions.add(readStringAttribute(in, ATTR_NAME));\n            }\n            if (TAG_WHITELISTED_RESTRICTED_PERMISSION.equals(in.getName())) {\n                whitelistedRestrictedPermissions.add(readStringAttribute(in, ATTR_NAME));\n\n            }\n            if (TAG_CHILD_SESSION.equals(in.getName())) {\n                childSessionIds.add(readIntAttribute(in, ATTR_SESSION_ID, SessionInfo.INVALID_ID));\n            }\n        }\n\n        if (grantedRuntimePermissions.size() > 0) {\n            params.grantedRuntimePermissions = grantedRuntimePermissions\n                    .stream().toArray(String[]::new);\n        }\n\n        if (whitelistedRestrictedPermissions.size() > 0) {\n            params.whitelistedRestrictedPermissions = whitelistedRestrictedPermissions;\n        }\n\n        int[] childSessionIdsArray;\n        if (childSessionIds.size() > 0) {\n            childSessionIdsArray = childSessionIds.stream().mapToInt(i -> i).toArray();\n        } else {\n            childSessionIdsArray = EMPTY_CHILD_SESSION_ARRAY;\n        }\n\n        return new PackageInstallerSession(callback, context, pm, sessionProvider,\n                installerThread, stagingManager, sessionId, userId, installerPackageName,\n                installerUid, params, createdMillis, stageDir, stageCid, prepared, committed,\n                destroyed, sealed, childSessionIdsArray, parentSessionId, isReady, isFailed,\n                isApplied, stagedSessionErrorCode, stagedSessionErrorMessage);\n    }",
  "func_after": "public static PackageInstallerSession readFromXml(@NonNull XmlPullParser in,\n            @NonNull PackageInstallerService.InternalCallback callback, @NonNull Context context,\n            @NonNull PackageManagerService pm, Looper installerThread,\n            @NonNull StagingManager stagingManager, @NonNull File sessionsDir,\n            @NonNull PackageSessionProvider sessionProvider)\n            throws IOException, XmlPullParserException {\n        final int sessionId = readIntAttribute(in, ATTR_SESSION_ID);\n        final int userId = readIntAttribute(in, ATTR_USER_ID);\n        final String installerPackageName = readStringAttribute(in, ATTR_INSTALLER_PACKAGE_NAME);\n        final int installerUid = readIntAttribute(in, ATTR_INSTALLER_UID, pm.getPackageUid(\n                installerPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, userId));\n        final long createdMillis = readLongAttribute(in, ATTR_CREATED_MILLIS);\n        long updatedMillis = readLongAttribute(in, ATTR_UPDATED_MILLIS);\n        final String stageDirRaw = readStringAttribute(in, ATTR_SESSION_STAGE_DIR);\n        final File stageDir = (stageDirRaw != null) ? new File(stageDirRaw) : null;\n        final String stageCid = readStringAttribute(in, ATTR_SESSION_STAGE_CID);\n        final boolean prepared = readBooleanAttribute(in, ATTR_PREPARED, true);\n        final boolean committed = readBooleanAttribute(in, ATTR_COMMITTED);\n        final boolean sealed = readBooleanAttribute(in, ATTR_SEALED);\n        final int parentSessionId = readIntAttribute(in, ATTR_PARENT_SESSION_ID,\n                SessionInfo.INVALID_ID);\n\n        final SessionParams params = new SessionParams(\n                SessionParams.MODE_INVALID);\n        params.isMultiPackage = readBooleanAttribute(in, ATTR_MULTI_PACKAGE, false);\n        params.isStaged = readBooleanAttribute(in, ATTR_STAGED_SESSION, false);\n        params.mode = readIntAttribute(in, ATTR_MODE);\n        params.installFlags = readIntAttribute(in, ATTR_INSTALL_FLAGS);\n        params.installLocation = readIntAttribute(in, ATTR_INSTALL_LOCATION);\n        params.sizeBytes = readLongAttribute(in, ATTR_SIZE_BYTES);\n        params.appPackageName = readStringAttribute(in, ATTR_APP_PACKAGE_NAME);\n        params.appIcon = readBitmapAttribute(in, ATTR_APP_ICON);\n        params.appLabel = readStringAttribute(in, ATTR_APP_LABEL);\n        params.originatingUri = readUriAttribute(in, ATTR_ORIGINATING_URI);\n        params.originatingUid =\n                readIntAttribute(in, ATTR_ORIGINATING_UID, SessionParams.UID_UNKNOWN);\n        params.referrerUri = readUriAttribute(in, ATTR_REFERRER_URI);\n        params.abiOverride = readStringAttribute(in, ATTR_ABI_OVERRIDE);\n        params.volumeUuid = readStringAttribute(in, ATTR_VOLUME_UUID);\n        params.installReason = readIntAttribute(in, ATTR_INSTALL_REASON);\n\n        final File appIconFile = buildAppIconFile(sessionId, sessionsDir);\n        if (appIconFile.exists()) {\n            params.appIcon = BitmapFactory.decodeFile(appIconFile.getAbsolutePath());\n            params.appIconLastModified = appIconFile.lastModified();\n        }\n        final boolean isReady = readBooleanAttribute(in, ATTR_IS_READY);\n        final boolean isFailed = readBooleanAttribute(in, ATTR_IS_FAILED);\n        final boolean isApplied = readBooleanAttribute(in, ATTR_IS_APPLIED);\n        final int stagedSessionErrorCode = readIntAttribute(in, ATTR_STAGED_SESSION_ERROR_CODE,\n                SessionInfo.STAGED_SESSION_NO_ERROR);\n        final String stagedSessionErrorMessage = readStringAttribute(in,\n                ATTR_STAGED_SESSION_ERROR_MESSAGE);\n\n        if (!isStagedSessionStateValid(isReady, isApplied, isFailed)) {\n            throw new IllegalArgumentException(\"Can't restore staged session with invalid state.\");\n        }\n\n        // Parse sub tags of this session, typically used for repeated values / arrays.\n        // Sub tags can come in any order, therefore we need to keep track of what we find while\n        // parsing and only set the right values at the end.\n\n        // Store the current depth. We should stop parsing when we reach an end tag at the same\n        // depth.\n        List<String> grantedRuntimePermissions = new ArrayList<>();\n        List<String> whitelistedRestrictedPermissions = new ArrayList<>();\n        List<Integer> childSessionIds = new ArrayList<>();\n        int outerDepth = in.getDepth();\n        int type;\n        while ((type = in.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || in.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            if (TAG_GRANTED_RUNTIME_PERMISSION.equals(in.getName())) {\n                grantedRuntimePermissions.add(readStringAttribute(in, ATTR_NAME));\n            }\n            if (TAG_WHITELISTED_RESTRICTED_PERMISSION.equals(in.getName())) {\n                whitelistedRestrictedPermissions.add(readStringAttribute(in, ATTR_NAME));\n\n            }\n            if (TAG_CHILD_SESSION.equals(in.getName())) {\n                childSessionIds.add(readIntAttribute(in, ATTR_SESSION_ID, SessionInfo.INVALID_ID));\n            }\n        }\n\n        if (grantedRuntimePermissions.size() > 0) {\n            params.grantedRuntimePermissions = grantedRuntimePermissions\n                    .stream().toArray(String[]::new);\n        }\n\n        if (whitelistedRestrictedPermissions.size() > 0) {\n            params.whitelistedRestrictedPermissions = whitelistedRestrictedPermissions;\n        }\n\n        int[] childSessionIdsArray;\n        if (childSessionIds.size() > 0) {\n            childSessionIdsArray = childSessionIds.stream().mapToInt(i -> i).toArray();\n        } else {\n            childSessionIdsArray = EMPTY_CHILD_SESSION_ARRAY;\n        }\n\n        return new PackageInstallerSession(callback, context, pm, sessionProvider,\n                installerThread, stagingManager, sessionId, userId, installerPackageName,\n                installerUid, params, createdMillis, stageDir, stageCid, prepared, committed,\n                sealed, childSessionIdsArray, parentSessionId, isReady, isFailed, isApplied,\n                stagedSessionErrorCode, stagedSessionErrorMessage);\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public static PackageInstallerSession readFromXml(@NonNull XmlPullParser in,\n             @NonNull PackageInstallerService.InternalCallback callback, @NonNull Context context,\n             @NonNull PackageManagerService pm, Looper installerThread,\n             @NonNull StagingManager stagingManager, @NonNull File sessionsDir,\n             @NonNull PackageSessionProvider sessionProvider)\n             throws IOException, XmlPullParserException {\n         final int sessionId = readIntAttribute(in, ATTR_SESSION_ID);\n         final int userId = readIntAttribute(in, ATTR_USER_ID);\n         final String installerPackageName = readStringAttribute(in, ATTR_INSTALLER_PACKAGE_NAME);\n         final int installerUid = readIntAttribute(in, ATTR_INSTALLER_UID, pm.getPackageUid(\n                 installerPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, userId));\n         final long createdMillis = readLongAttribute(in, ATTR_CREATED_MILLIS);\n         long updatedMillis = readLongAttribute(in, ATTR_UPDATED_MILLIS);\n         final String stageDirRaw = readStringAttribute(in, ATTR_SESSION_STAGE_DIR);\n         final File stageDir = (stageDirRaw != null) ? new File(stageDirRaw) : null;\n         final String stageCid = readStringAttribute(in, ATTR_SESSION_STAGE_CID);\n         final boolean prepared = readBooleanAttribute(in, ATTR_PREPARED, true);\n         final boolean committed = readBooleanAttribute(in, ATTR_COMMITTED);\n-        final boolean destroyed = readBooleanAttribute(in, ATTR_DESTROYED);\n         final boolean sealed = readBooleanAttribute(in, ATTR_SEALED);\n         final int parentSessionId = readIntAttribute(in, ATTR_PARENT_SESSION_ID,\n                 SessionInfo.INVALID_ID);\n \n         final SessionParams params = new SessionParams(\n                 SessionParams.MODE_INVALID);\n         params.isMultiPackage = readBooleanAttribute(in, ATTR_MULTI_PACKAGE, false);\n         params.isStaged = readBooleanAttribute(in, ATTR_STAGED_SESSION, fa",
  "diff_source": "custom"
}