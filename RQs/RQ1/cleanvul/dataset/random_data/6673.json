{
  "id": 6673,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f",
  "commit_sha": "dd504589577d8e8e70f51f997ad487a4cb6c026f",
  "commit_msg": "crypto: algif_skcipher - Require setkey before accept(2)\n\nSome cipher implementations will crash if you try to use them\nwithout calling setkey first.  This patch adds a check so that\nthe accept(2) call will fail with -ENOKEY if setkey hasn't been\ndone on the socket yet.\n\nCc: stable@vger.kernel.org\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nTested-by: Dmitry Vyukov <dvyukov@google.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "crypto/algif_skcipher.c",
  "func_name": "skcipher_accept_parent",
  "func_before": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}",
  "func_after": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_tfm *tfm = private;\n\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n\n\tif (!tfm->has_key)\n\t\treturn -ENOKEY;\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, skcipher);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int skcipher_accept_parent(void *private, struct sock *sk)\n {\n \tstruct skcipher_ctx *ctx;\n \tstruct alg_sock *ask = alg_sk(sk);\n+\tstruct skcipher_tfm *tfm = private;\n+\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n-\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n+\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n+\n+\tif (!tfm->has_key)\n+\t\treturn -ENOKEY;\n \n \tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n \tif (!ctx)\n \t\treturn -ENOMEM;\n \n-\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n+\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n \t\t\t       GFP_KERNEL);\n \tif (!ctx->iv) {\n \t\tsock_kfree_s(sk, ctx, len);\n \t\treturn -ENOMEM;\n \t}\n \n-\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n+\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n \n \tINIT_LIST_HEAD(&ctx->tsgl);\n \tctx->len = len;\n \tctx->used = 0;\n \tctx->more = 0;\n \tctx->merge = 0;\n \tctx->enc = 0;\n \tatomic_set(&ctx->inflight, 0);\n \taf_alg_init_completion(&ctx->completion);\n \n \task->private = ctx;\n \n-\tskcipher_request_set_tfm(&ctx->req, private);\n+\tskcipher_request_set_tfm(&ctx->req, skcipher);\n \tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n \t\t\t\t      af_alg_complete, &ctx->completion);\n \n \tsk->sk_destruct = skcipher_sock_destruct;\n \n \treturn 0;\n }",
  "diff_source": "custom"
}