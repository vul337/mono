{
  "id": 7097,
  "language": "Python",
  "commit_url": "https://github.com/sqlalchemy/sqlalchemy/commit/30307c4616ad67c01ddae2e1e8e34fabf6028414",
  "commit_sha": "30307c4616ad67c01ddae2e1e8e34fabf6028414",
  "commit_msg": "Remove all remaining text() coercions and ensure identifiers are safe\n\nFully removed the behavior of strings passed directly as components of a\n:func:`.select` or :class:`.Query` object being coerced to :func:`.text`\nconstructs automatically; the warning that has been emitted is now an\nArgumentError or in the case of order_by() / group_by() a CompileError.\nThis has emitted a warning since version 1.0 however its presence continues\nto create concerns for the potential of mis-use of this behavior.\n\nNote that public CVEs have been posted for order_by() / group_by() which\nare resolved by this commit:  CVE-2019-7164  CVE-2019-7548\n\nAdded \"SQL phrase validation\" to key DDL phrases that are accepted as plain\nstrings, including :paramref:`.ForeignKeyConstraint.on_delete`,\n:paramref:`.ForeignKeyConstraint.on_update`,\n:paramref:`.ExcludeConstraint.using`,\n:paramref:`.ForeignKeyConstraint.initially`, for areas where a series of SQL\nkeywords only are expected.Any non-space characters that suggest the phrase\nwould need to be quoted will raise a :class:`.CompileError`.   This change\nis related to the series of changes committed as part of :ticket:`4481`.\n\nFixed issue where using an uppercase name for an index type (e.g. GIST,\nBTREE, etc. ) or an EXCLUDE constraint would treat it as an identifier to\nbe quoted, rather than rendering it as is. The new behavior converts these\ntypes to lowercase and ensures they contain only valid SQL characters.\n\nQuoting is applied to :class:`.Function` names, those which are usually but\nnot necessarily generated from the :attr:`.sql.func` construct,  at compile\ntime if they contain illegal characters, such as spaces or punctuation. The\nnames are as before treated as case insensitive however, meaning if the\nnames contain uppercase or mixed case characters, that alone does not\ntrigger quoting. The case insensitivity is currently maintained for\nbackwards compatibility.\n\nFixes: #4481\nFixes: #4473\nFixes: #4467\nChange-Id: Ib22a27d62930e24702e2f0f7c74a0473385a08eb",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "lib/sqlalchemy/orm/session.py",
  "func_name": "execute",
  "func_before": "def execute(self, clause, params=None, mapper=None, bind=None, **kw):\n        r\"\"\"Execute a SQL expression construct or string statement within\n        the current transaction.\n\n        Returns a :class:`.ResultProxy` representing\n        results of the statement execution, in the same manner as that of an\n        :class:`.Engine` or\n        :class:`.Connection`.\n\n        E.g.::\n\n            result = session.execute(\n                        user_table.select().where(user_table.c.id == 5)\n                    )\n\n        :meth:`~.Session.execute` accepts any executable clause construct,\n        such as :func:`~.sql.expression.select`,\n        :func:`~.sql.expression.insert`,\n        :func:`~.sql.expression.update`,\n        :func:`~.sql.expression.delete`, and\n        :func:`~.sql.expression.text`.  Plain SQL strings can be passed\n        as well, which in the case of :meth:`.Session.execute` only\n        will be interpreted the same as if it were passed via a\n        :func:`~.expression.text` construct.  That is, the following usage::\n\n            result = session.execute(\n                        \"SELECT * FROM user WHERE id=:param\",\n                        {\"param\":5}\n                    )\n\n        is equivalent to::\n\n            from sqlalchemy import text\n            result = session.execute(\n                        text(\"SELECT * FROM user WHERE id=:param\"),\n                        {\"param\":5}\n                    )\n\n        The second positional argument to :meth:`.Session.execute` is an\n        optional parameter set.  Similar to that of\n        :meth:`.Connection.execute`, whether this is passed as a single\n        dictionary, or a list of dictionaries, determines whether the DBAPI\n        cursor's ``execute()`` or ``executemany()`` is used to execute the\n        statement.   An INSERT construct may be invoked for a single row::\n\n            result = session.execute(\n                users.insert(), {\"id\": 7, \"name\": \"somename\"})\n\n        or for multiple rows::\n\n            result = session.execute(users.insert(), [\n                                    {\"id\": 7, \"name\": \"somename7\"},\n                                    {\"id\": 8, \"name\": \"somename8\"},\n                                    {\"id\": 9, \"name\": \"somename9\"}\n                                ])\n\n        The statement is executed within the current transactional context of\n        this :class:`.Session`.   The :class:`.Connection` which is used\n        to execute the statement can also be acquired directly by\n        calling the :meth:`.Session.connection` method.  Both methods use\n        a rule-based resolution scheme in order to determine the\n        :class:`.Connection`, which in the average case is derived directly\n        from the \"bind\" of the :class:`.Session` itself, and in other cases\n        can be based on the :func:`.mapper`\n        and :class:`.Table` objects passed to the method; see the\n        documentation for :meth:`.Session.get_bind` for a full description of\n        this scheme.\n\n        The :meth:`.Session.execute` method does *not* invoke autoflush.\n\n        The :class:`.ResultProxy` returned by the :meth:`.Session.execute`\n        method is returned with the \"close_with_result\" flag set to true;\n        the significance of this flag is that if this :class:`.Session` is\n        autocommitting and does not have a transaction-dedicated\n        :class:`.Connection` available, a temporary :class:`.Connection` is\n        established for the statement execution, which is closed (meaning,\n        returned to the connection pool) when the :class:`.ResultProxy` has\n        consumed all available data. This applies *only* when the\n        :class:`.Session` is configured with autocommit=True and no\n        transaction has been started.\n\n        :param clause:\n            An executable statement (i.e. an :class:`.Executable` expression\n            such as :func:`.expression.select`) or string SQL statement\n            to be executed.\n\n        :param params:\n            Optional dictionary, or list of dictionaries, containing\n            bound parameter values.   If a single dictionary, single-row\n            execution occurs; if a list of dictionaries, an\n            \"executemany\" will be invoked.  The keys in each dictionary\n            must correspond to parameter names present in the statement.\n\n        :param mapper:\n          Optional :func:`.mapper` or mapped class, used to identify\n          the appropriate bind.  This argument takes precedence over\n          ``clause`` when locating a bind.   See :meth:`.Session.get_bind`\n          for more details.\n\n        :param bind:\n          Optional :class:`.Engine` to be used as the bind.  If\n          this engine is already involved in an ongoing transaction,\n          that connection will be used.  This argument takes\n          precedence over ``mapper`` and ``clause`` when locating\n          a bind.\n\n        :param \\**kw:\n          Additional keyword arguments are sent to :meth:`.Session.get_bind()`\n          to allow extensibility of \"bind\" schemes.\n\n        .. seealso::\n\n            :ref:`sqlexpression_toplevel` - Tutorial on using Core SQL\n            constructs.\n\n            :ref:`connections_toplevel` - Further information on direct\n            statement execution.\n\n            :meth:`.Connection.execute` - core level statement execution\n            method, which is :meth:`.Session.execute` ultimately uses\n            in order to execute the statement.\n\n        \"\"\"\n        clause = expression._literal_as_text(clause)\n\n        if bind is None:\n            bind = self.get_bind(mapper, clause=clause, **kw)\n\n        return self._connection_for_bind(bind, close_with_result=True).execute(\n            clause, params or {}\n        )",
  "func_after": "def execute(self, clause, params=None, mapper=None, bind=None, **kw):\n        r\"\"\"Execute a SQL expression construct or string statement within\n        the current transaction.\n\n        Returns a :class:`.ResultProxy` representing\n        results of the statement execution, in the same manner as that of an\n        :class:`.Engine` or\n        :class:`.Connection`.\n\n        E.g.::\n\n            result = session.execute(\n                        user_table.select().where(user_table.c.id == 5)\n                    )\n\n        :meth:`~.Session.execute` accepts any executable clause construct,\n        such as :func:`~.sql.expression.select`,\n        :func:`~.sql.expression.insert`,\n        :func:`~.sql.expression.update`,\n        :func:`~.sql.expression.delete`, and\n        :func:`~.sql.expression.text`.  Plain SQL strings can be passed\n        as well, which in the case of :meth:`.Session.execute` only\n        will be interpreted the same as if it were passed via a\n        :func:`~.expression.text` construct.  That is, the following usage::\n\n            result = session.execute(\n                        \"SELECT * FROM user WHERE id=:param\",\n                        {\"param\":5}\n                    )\n\n        is equivalent to::\n\n            from sqlalchemy import text\n            result = session.execute(\n                        text(\"SELECT * FROM user WHERE id=:param\"),\n                        {\"param\":5}\n                    )\n\n        The second positional argument to :meth:`.Session.execute` is an\n        optional parameter set.  Similar to that of\n        :meth:`.Connection.execute`, whether this is passed as a single\n        dictionary, or a list of dictionaries, determines whether the DBAPI\n        cursor's ``execute()`` or ``executemany()`` is used to execute the\n        statement.   An INSERT construct may be invoked for a single row::\n\n            result = session.execute(\n                users.insert(), {\"id\": 7, \"name\": \"somename\"})\n\n        or for multiple rows::\n\n            result = session.execute(users.insert(), [\n                                    {\"id\": 7, \"name\": \"somename7\"},\n                                    {\"id\": 8, \"name\": \"somename8\"},\n                                    {\"id\": 9, \"name\": \"somename9\"}\n                                ])\n\n        The statement is executed within the current transactional context of\n        this :class:`.Session`.   The :class:`.Connection` which is used\n        to execute the statement can also be acquired directly by\n        calling the :meth:`.Session.connection` method.  Both methods use\n        a rule-based resolution scheme in order to determine the\n        :class:`.Connection`, which in the average case is derived directly\n        from the \"bind\" of the :class:`.Session` itself, and in other cases\n        can be based on the :func:`.mapper`\n        and :class:`.Table` objects passed to the method; see the\n        documentation for :meth:`.Session.get_bind` for a full description of\n        this scheme.\n\n        The :meth:`.Session.execute` method does *not* invoke autoflush.\n\n        The :class:`.ResultProxy` returned by the :meth:`.Session.execute`\n        method is returned with the \"close_with_result\" flag set to true;\n        the significance of this flag is that if this :class:`.Session` is\n        autocommitting and does not have a transaction-dedicated\n        :class:`.Connection` available, a temporary :class:`.Connection` is\n        established for the statement execution, which is closed (meaning,\n        returned to the connection pool) when the :class:`.ResultProxy` has\n        consumed all available data. This applies *only* when the\n        :class:`.Session` is configured with autocommit=True and no\n        transaction has been started.\n\n        :param clause:\n            An executable statement (i.e. an :class:`.Executable` expression\n            such as :func:`.expression.select`) or string SQL statement\n            to be executed.\n\n        :param params:\n            Optional dictionary, or list of dictionaries, containing\n            bound parameter values.   If a single dictionary, single-row\n            execution occurs; if a list of dictionaries, an\n            \"executemany\" will be invoked.  The keys in each dictionary\n            must correspond to parameter names present in the statement.\n\n        :param mapper:\n          Optional :func:`.mapper` or mapped class, used to identify\n          the appropriate bind.  This argument takes precedence over\n          ``clause`` when locating a bind.   See :meth:`.Session.get_bind`\n          for more details.\n\n        :param bind:\n          Optional :class:`.Engine` to be used as the bind.  If\n          this engine is already involved in an ongoing transaction,\n          that connection will be used.  This argument takes\n          precedence over ``mapper`` and ``clause`` when locating\n          a bind.\n\n        :param \\**kw:\n          Additional keyword arguments are sent to :meth:`.Session.get_bind()`\n          to allow extensibility of \"bind\" schemes.\n\n        .. seealso::\n\n            :ref:`sqlexpression_toplevel` - Tutorial on using Core SQL\n            constructs.\n\n            :ref:`connections_toplevel` - Further information on direct\n            statement execution.\n\n            :meth:`.Connection.execute` - core level statement execution\n            method, which is :meth:`.Session.execute` ultimately uses\n            in order to execute the statement.\n\n        \"\"\"\n        clause = expression._literal_as_text(\n            clause, allow_coercion_to_text=True\n        )\n\n        if bind is None:\n            bind = self.get_bind(mapper, clause=clause, **kw)\n\n        return self._connection_for_bind(bind, close_with_result=True).execute(\n            clause, params or {}\n        )",
  "diff_func": "--- func_before\n+++ func_after\n def execute(self, clause, params=None, mapper=None, bind=None, **kw):\n         r\"\"\"Execute a SQL expression construct or string statement within\n         the current transaction.\n \n         Returns a :class:`.ResultProxy` representing\n         results of the statement execution, in the same manner as that of an\n         :class:`.Engine` or\n         :class:`.Connection`.\n \n         E.g.::\n \n             result = session.execute(\n                         user_table.select().where(user_table.c.id == 5)\n                     )\n \n         :meth:`~.Session.execute` accepts any executable clause construct,\n         such as :func:`~.sql.expression.select`,\n         :func:`~.sql.expression.insert`,\n         :func:`~.sql.expression.update`,\n         :func:`~.sql.expression.delete`, and\n         :func:`~.sql.expression.text`.  Plain SQL strings can be passed\n         as well, which in the case of :meth:`.Session.execute` only\n         will be interpreted the same as if it were passed via a\n         :func:`~.expression.text` construct.  That is, the following usage::\n \n             result = session.execute(\n                         \"SELECT * FROM user WHERE id=:param\",\n                         {\"param\":5}\n                     )\n \n         is equivalent to::\n \n             from sqlalchemy import text\n             result = session.execute(\n                         text(\"SELECT * FROM user WHERE id=:param\"),\n                         {\"param\":5}\n                     )\n \n         The second positional argument to :meth:`.Session.execute` is an\n         optional parameter set.  Similar to that of\n         :meth:`.Connection.execute`, whether this is passed as a single\n         dictionary, or a list of dictionaries, determines whether the DBAPI\n         cursor's ``execute()`` or ``executemany()`` is used to execute the\n         statement.   An INSERT construct may be invoked for a single row::\n \n             result = session.execute(\n                 use",
  "diff_source": "custom"
}