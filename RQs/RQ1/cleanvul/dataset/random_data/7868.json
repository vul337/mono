{
  "id": 7868,
  "language": "JavaScript",
  "commit_url": "https://github.com/jquery/jquery/commit/2546bb35b89413da5198d54a4539e4ed0aaf6e49",
  "commit_sha": "2546bb35b89413da5198d54a4539e4ed0aaf6e49",
  "commit_msg": "Ajax: Mitigate possible XSS vulnerability\n\nFixes gh-2432",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/ajax.js",
  "func_name": "ajaxConvert",
  "func_before": "function ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}",
  "func_after": "function ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Mitigate possible XSS vulnerability (gh-2432)\n\t\t\t\tif ( s.crossDomain && current === \"script\" ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}",
  "diff_func": "--- func_before\n+++ func_after\n function ajaxConvert( s, response, jqXHR, isSuccess ) {\n \tvar conv2, current, conv, tmp, prev,\n \t\tconverters = {},\n \n \t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n \t\tdataTypes = s.dataTypes.slice();\n \n \t// Create converters map with lowercased keys\n \tif ( dataTypes[ 1 ] ) {\n \t\tfor ( conv in s.converters ) {\n \t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n \t\t}\n \t}\n \n \tcurrent = dataTypes.shift();\n \n \t// Convert to each sequential dataType\n \twhile ( current ) {\n \n \t\tif ( s.responseFields[ current ] ) {\n \t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n \t\t}\n \n \t\t// Apply the dataFilter if provided\n \t\tif ( !prev && isSuccess && s.dataFilter ) {\n \t\t\tresponse = s.dataFilter( response, s.dataType );\n \t\t}\n \n \t\tprev = current;\n \t\tcurrent = dataTypes.shift();\n \n \t\tif ( current ) {\n \n-\t\t// There's only work to do if current dataType is non-auto\n+\t\t\t// There's only work to do if current dataType is non-auto\n \t\t\tif ( current === \"*\" ) {\n \n \t\t\t\tcurrent = prev;\n \n \t\t\t// Convert response if prev dataType is non-auto and differs from current\n \t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n+\n+\t\t\t\t// Mitigate possible XSS vulnerability (gh-2432)\n+\t\t\t\tif ( s.crossDomain && current === \"script\" ) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \n \t\t\t\t// Seek a direct converter\n \t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n \n \t\t\t\t// If none found, seek a pair\n \t\t\t\tif ( !conv ) {\n \t\t\t\t\tfor ( conv2 in converters ) {\n \n \t\t\t\t\t\t// If conv2 outputs current\n \t\t\t\t\t\ttmp = conv2.split( \" \" );\n \t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n \n \t\t\t\t\t\t\t// If prev can be converted to accepted input\n \t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n \t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n \t\t\t\t\t\t\tif ( conv ) {\n \n \t\t\t\t\t\t\t\t// Condense equivalence converters\n \t\t\t\t\t\t\t\tif ( conv === true ) {\n \t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n \n \t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n \t\t\t\t\t\t\t\t} else if ( converters[ ",
  "diff_source": "custom"
}