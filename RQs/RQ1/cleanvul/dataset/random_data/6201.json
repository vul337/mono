{
  "id": 6201,
  "language": "Python",
  "commit_url": "https://github.com/vyperlang/vyper/commit/4f8289a81206f767df1900ac48f485d90fc87edb",
  "commit_sha": "4f8289a81206f767df1900ac48f485d90fc87edb",
  "commit_msg": "Merge pull request from GHSA-3p37-3636-q8wv\n\nin dynarray_make_setter, the length is copied before the data. when the\ndst and src arrays do not overlap, this is not a problem. however, when\nthe dst and src are the same dynarray, this can lead to a\nstore-before-load, leading any array bounds checks on the right hand\nside to function incorrectly. here is an example:\n\n```vyper\n@external\ndef should_revert() -> DynArray[uint256,3]:\n    a: DynArray[uint256, 3] = [1, 2, 3]\n    a = empty(DynArray[uint256, 3])\n    a = [self.a[0], self.a[1], self.a[2]]\n    return a  # if bug: returns [1,2,3]\n```\n\nthis commit moves the length store to after the data copy in\ndynarray_make_setter. for hygiene, it also moves the length store to\nafter the data copy in several other routines. I left pop_dyn_array()\nunchanged, because moving the routine does not actually perform any data\ncopy, it just writes the new length (and optionally returns a pointer to\nthe popped item).",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "vyper/codegen/core.py",
  "func_name": "append_dyn_array",
  "func_before": "def append_dyn_array(darray_node, elem_node):\n    assert isinstance(darray_node.typ, DArrayT)\n\n    assert darray_node.typ.count > 0, \"jerk boy u r out\"\n\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        len_ = get_dyn_array_count(darray_node)\n        with len_.cache_when_complex(\"old_darray_len\") as (b2, len_):\n            assertion = [\"assert\", [\"lt\", len_, darray_node.typ.count]]\n            ret.append(IRnode.from_list(assertion, error_msg=f\"{darray_node.typ} bounds check\"))\n            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n            # NOTE: typechecks elem_node\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            ret.append(\n                make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)\n            )\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)))",
  "func_after": "def append_dyn_array(darray_node, elem_node):\n    assert isinstance(darray_node.typ, DArrayT)\n\n    assert darray_node.typ.count > 0, \"jerk boy u r out\"\n\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        len_ = get_dyn_array_count(darray_node)\n        with len_.cache_when_complex(\"old_darray_len\") as (b2, len_):\n            assertion = [\"assert\", [\"lt\", len_, darray_node.typ.count]]\n            ret.append(IRnode.from_list(assertion, error_msg=f\"{darray_node.typ} bounds check\"))\n            # NOTE: typechecks elem_node\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            ret.append(\n                make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)\n            )\n\n            # store new length\n            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)))",
  "diff_func": "--- func_before\n+++ func_after\n def append_dyn_array(darray_node, elem_node):\n     assert isinstance(darray_node.typ, DArrayT)\n \n     assert darray_node.typ.count > 0, \"jerk boy u r out\"\n \n     ret = [\"seq\"]\n     with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n         len_ = get_dyn_array_count(darray_node)\n         with len_.cache_when_complex(\"old_darray_len\") as (b2, len_):\n             assertion = [\"assert\", [\"lt\", len_, darray_node.typ.count]]\n             ret.append(IRnode.from_list(assertion, error_msg=f\"{darray_node.typ} bounds check\"))\n-            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n             # NOTE: typechecks elem_node\n             # NOTE skip array bounds check bc we already asserted len two lines up\n             ret.append(\n                 make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)\n             )\n+\n+            # store new length\n+            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n             return IRnode.from_list(b1.resolve(b2.resolve(ret)))",
  "diff_source": "custom"
}