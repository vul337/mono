{
  "id": 4178,
  "language": "Python",
  "commit_url": "https://github.com/awslabs/sockeye/commit/a20a34d1ec5bb9e232b47c1a73cd4075b71a9d94",
  "commit_sha": "a20a34d1ec5bb9e232b47c1a73cd4075b71a9d94",
  "commit_msg": "Merge branch 'master' into yaml",
  "pr_url": "https://github.com/awslabs/sockeye/pull/964",
  "pr_info": "With this change we make use of the safe yaml loader that only accepts our own defined types and the standard yaml types. Additionally, we make sure to be able load tuples (which are used for buckets and some other parts of the config).\r\n\r\n#### Pull Request Checklist ##\r\n- [x] Changes are complete (if posting work-in-progress code, prefix your pull request title with '[WIP]'\r\nuntil you can check this box.\r\n- [x] Unit tests pass (`pytest`)\r\n~~- [ ] Were system tests modified? If so did you run these at least 5 times to account for the variation across runs?~~\r\n- [x] System tests pass (`pytest test/system`)\r\n- [x] Passed code style checking (`./style-check.sh`)\r\n- [x] You have considered writing a test\r\n- [x] Updated major/minor version in `sockeye/__init__.py`. Major version bump if this is a backwards incompatible change.\r\n- [x] Updated CHANGELOG.md\r\n\r\n\r\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.\r\n\r\n",
  "file_name": "sockeye/inference.py",
  "func_name": "json",
  "func_before": "def json(self) -> Dict:\n        \"\"\"\n        Returns a dictionary suitable for json.dumps() representing all\n        the information in the class. It is initialized with any keys\n        present in the corresponding `TranslatorInput` object's pass_through_dict.\n        Keys from here that are not overwritten by Sockeye will thus be passed\n        through to the output.\n\n        :return: A dictionary.\n        \"\"\"\n        _d = self.pass_through_dict  # type: Dict[str, Any]\n        _d['sentence_id'] = self.sentence_id\n        _d['translation'] = self.translation\n        _d['score'] = self.score\n\n        if self.nbest_translations is not None and len(self.nbest_translations) > 1:\n            _d['translations'] = self.nbest_translations\n            _d['scores'] = self.nbest_scores\n\n        if self.factor_translations is not None:\n            for i, factor in enumerate(self.factor_translations, 1):\n                _d[f'factor{i}'] = factor\n\n        if self.nbest_factor_translations is not None and len(self.nbest_factor_translations) > 1:\n            _d['translations_factors'] = []\n            for factor_translations in self.nbest_factor_translations:\n                _d['translations_factors'].append(\n                    {f'factor{i}': factor_translation for i, factor_translation in enumerate(factor_translations, 1)})\n\n        return _d",
  "func_after": "def json(self) -> Dict:\n        \"\"\"\n        Returns a dictionary suitable for json.dumps() representing all\n        the information in the class. It is initialized with any keys\n        present in the corresponding `TranslatorInput` object's pass_through_dict.\n        Keys from here that are not overwritten by Sockeye will thus be passed\n        through to the output.\n\n        :return: A dictionary.\n        \"\"\"\n        _d = copy.deepcopy(self.pass_through_dict) if self.pass_through_dict is not None else {}  # type: Dict[str, Any]\n        _d['sentence_id'] = self.sentence_id\n        _d['translation'] = self.translation\n        _d['score'] = self.score\n\n        if self.nbest_translations is not None and len(self.nbest_translations) > 1:\n            _d['translations'] = self.nbest_translations\n            _d['scores'] = self.nbest_scores\n\n        if self.factor_translations is not None:\n            for i, factor in enumerate(self.factor_translations, 1):\n                _d[f'factor{i}'] = factor\n\n        if self.nbest_factor_translations is not None and len(self.nbest_factor_translations) > 1:\n            _d['translations_factors'] = []\n            for factor_translations in self.nbest_factor_translations:\n                _d['translations_factors'].append(\n                    {f'factor{i}': factor_translation for i, factor_translation in enumerate(factor_translations, 1)})\n\n        return _d",
  "diff_func": "--- func_before\n+++ func_after\n def json(self) -> Dict:\n         \"\"\"\n         Returns a dictionary suitable for json.dumps() representing all\n         the information in the class. It is initialized with any keys\n         present in the corresponding `TranslatorInput` object's pass_through_dict.\n         Keys from here that are not overwritten by Sockeye will thus be passed\n         through to the output.\n \n         :return: A dictionary.\n         \"\"\"\n-        _d = self.pass_through_dict  # type: Dict[str, Any]\n+        _d = copy.deepcopy(self.pass_through_dict) if self.pass_through_dict is not None else {}  # type: Dict[str, Any]\n         _d['sentence_id'] = self.sentence_id\n         _d['translation'] = self.translation\n         _d['score'] = self.score\n \n         if self.nbest_translations is not None and len(self.nbest_translations) > 1:\n             _d['translations'] = self.nbest_translations\n             _d['scores'] = self.nbest_scores\n \n         if self.factor_translations is not None:\n             for i, factor in enumerate(self.factor_translations, 1):\n                 _d[f'factor{i}'] = factor\n \n         if self.nbest_factor_translations is not None and len(self.nbest_factor_translations) > 1:\n             _d['translations_factors'] = []\n             for factor_translations in self.nbest_factor_translations:\n                 _d['translations_factors'].append(\n                     {f'factor{i}': factor_translation for i, factor_translation in enumerate(factor_translations, 1)})\n \n         return _d",
  "diff_source": "custom"
}