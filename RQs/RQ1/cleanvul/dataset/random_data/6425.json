{
  "id": 6425,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/e2cb6b891ad2b8caa9131e3be70f45243df82a80",
  "commit_sha": "e2cb6b891ad2b8caa9131e3be70f45243df82a80",
  "commit_msg": "bluetooth: eliminate the potential race condition when removing the HCI controller\n\nThere is a possible race condition vulnerability between issuing a HCI\ncommand and removing the cont.  Specifically, functions hci_req_sync()\nand hci_dev_do_close() can race each other like below:\n\nthread-A in hci_req_sync()      |   thread-B in hci_dev_do_close()\n                                |   hci_req_sync_lock(hdev);\ntest_bit(HCI_UP, &hdev->flags); |\n...                             |   test_and_clear_bit(HCI_UP, &hdev->flags)\nhci_req_sync_lock(hdev);        |\n                                |\nIn this commit we alter the sequence in function hci_req_sync(). Hence,\nthe thread-A cannot issue th.\n\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nCc: Marcel Holtmann <marcel@holtmann.org>\nFixes: 7c6a329e4447 (\"[Bluetooth] Fix regression from using default link policy\")\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "net/bluetooth/hci_request.c",
  "func_name": "int",
  "func_before": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\t/* Serialize all requests */\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}",
  "func_after": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\t/* Serialize all requests */\n\thci_req_sync_lock(hdev);\n\t/* check the state after obtaing the lock to protect the HCI_UP\n\t * against any races from hci_dev_do_close when the controller\n\t * gets removed.\n\t */\n\tif (test_bit(HCI_UP, &hdev->flags))\n\t\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\telse\n\t\tret = -ENETDOWN;\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n \t\t\t\t\t\t  unsigned long opt),\n \t\t unsigned long opt, u32 timeout, u8 *hci_status)\n {\n \tint ret;\n \n-\tif (!test_bit(HCI_UP, &hdev->flags))\n-\t\treturn -ENETDOWN;\n-\n \t/* Serialize all requests */\n \thci_req_sync_lock(hdev);\n+\t/* check the state after obtaing the lock to protect the HCI_UP\n+\t * against any races from hci_dev_do_close when the controller\n+\t * gets removed.\n+\t */\n+\tif (test_bit(HCI_UP, &hdev->flags))\n-\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n+\t\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n+\telse\n+\t\tret = -ENETDOWN;\n \thci_req_sync_unlock(hdev);\n \n \treturn ret;\n }",
  "diff_source": "custom"
}