{
  "id": 4388,
  "language": "C/C++",
  "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/cf740bd8b829732d1c096d52512f9102433b881f",
  "commit_sha": "cf740bd8b829732d1c096d52512f9102433b881f",
  "commit_msg": "https://github.com/ImageMagick/ImageMagick/issues/721",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "coders/sixel.c",
  "func_name": "WriteSIXELImage",
  "func_before": "static MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    opacity,\n    y;\n\n  sixel_output_t\n    *output;\n\n  unsigned char\n    sixel_palette[256*3],\n    *sixel_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  opacity=(-1);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType,exception);\n    }\n  else\n    {\n      MagickRealType\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].alpha != OpaqueAlpha)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=image->colormap[i].alpha;\n            beta=image->colormap[opacity].alpha;\n            if (alpha < beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].alpha != OpaqueAlpha)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=image->colormap[i].alpha;\n                beta=image->colormap[opacity].alpha;\n                if (alpha < beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    SIXEL header.\n  */\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    sixel_palette[3*i+0]=ScaleQuantumToChar(image->colormap[i].red);\n    sixel_palette[3*i+1]=ScaleQuantumToChar(image->colormap[i].green);\n    sixel_palette[3*i+2]=ScaleQuantumToChar(image->colormap[i].blue);\n  }\n\n  /*\n    Define SIXEL pixels.\n  */\n  output = sixel_output_create(image);\n  sixel_pixels=(unsigned char *) AcquireQuantumMemory(image->columns,\n    image->rows*sizeof(*sixel_pixels));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        sixel_pixels[y*image->columns+x]= ((ssize_t) GetPixelIndex(image,q));\n        q+=GetPixelChannels(image);\n      }\n  }\n  status = sixel_encode_impl(sixel_pixels,image->columns,image->rows,\n    sixel_palette,image->colors,-1,output);\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  output=(sixel_output_t *) RelinquishMagickMemory(output);\n  (void) CloseBlob(image);\n  return(status);\n}",
  "func_after": "static MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    opacity,\n    y;\n\n  sixel_output_t\n    *output;\n\n  unsigned char\n    sixel_palette[256*3],\n    *sixel_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  opacity=(-1);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType,exception);\n    }\n  else\n    {\n      MagickRealType\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].alpha != OpaqueAlpha)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=image->colormap[i].alpha;\n            beta=image->colormap[opacity].alpha;\n            if (alpha < beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].alpha != OpaqueAlpha)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=image->colormap[i].alpha;\n                beta=image->colormap[opacity].alpha;\n                if (alpha < beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    SIXEL header.\n  */\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    sixel_palette[3*i+0]=ScaleQuantumToChar(image->colormap[i].red);\n    sixel_palette[3*i+1]=ScaleQuantumToChar(image->colormap[i].green);\n    sixel_palette[3*i+2]=ScaleQuantumToChar(image->colormap[i].blue);\n  }\n\n  /*\n    Define SIXEL pixels.\n  */\n  output = sixel_output_create(image);\n  if (output == (sixel_output_t *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  sixel_pixels=(unsigned char *) AcquireQuantumMemory(image->columns,\n    image->rows*sizeof(*sixel_pixels));\n  if (sixel_pixels == (unsigned char *) NULL)\n    {\n      output = (sixel_output_t *) RelinquishMagickMemory(output);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      sixel_pixels[y*image->columns+x]= ((ssize_t) GetPixelIndex(image,q));\n      q+=GetPixelChannels(image);\n    }\n  }\n  status = sixel_encode_impl(sixel_pixels,image->columns,image->rows,\n    sixel_palette,image->colors,-1,output);\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  output=(sixel_output_t *) RelinquishMagickMemory(output);\n  (void) CloseBlob(image);\n  return(status);\n}",
  "diff_func": "--- func_before\n+++ func_after\n static MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,\n   Image *image,ExceptionInfo *exception)\n {\n   MagickBooleanType\n     status;\n \n   register const Quantum\n     *q;\n \n   register ssize_t\n     i,\n     x;\n \n   ssize_t\n     opacity,\n     y;\n \n   sixel_output_t\n     *output;\n \n   unsigned char\n     sixel_palette[256*3],\n     *sixel_pixels;\n \n   /*\n     Open output image file.\n   */\n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   assert(image != (Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     return(status);\n   if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n     (void) TransformImageColorspace(image,sRGBColorspace,exception);\n   opacity=(-1);\n   if (image->alpha_trait == UndefinedPixelTrait)\n     {\n       if ((image->storage_class == DirectClass) || (image->colors > 256))\n         (void) SetImageType(image,PaletteType,exception);\n     }\n   else\n     {\n       MagickRealType\n         alpha,\n         beta;\n \n       /*\n         Identify transparent colormap index.\n       */\n       if ((image->storage_class == DirectClass) || (image->colors > 256))\n         (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n       for (i=0; i < (ssize_t) image->colors; i++)\n         if (image->colormap[i].alpha != OpaqueAlpha)\n           {\n             if (opacity < 0)\n               {\n                 opacity=i;\n                 continue;\n               }\n             alpha=image->colormap[i].alpha;\n             beta=image->colormap[opacity].alpha;\n             if (alpha < beta)\n               opacity=i;\n           }\n       if (opacity == -1)\n         {\n           (void) SetImageType(image,PaletteBilevelAlphaType,",
  "diff_source": "custom"
}