{
  "id": 4392,
  "language": "C/C++",
  "commit_url": "https://github.com/jerryscript-project/jerryscript/commit/0be48707849d7556ddc8a2073a26b285fd284905",
  "commit_sha": "0be48707849d7556ddc8a2073a26b285fd284905",
  "commit_msg": "Prevent arguments object creation if arguments parameter is present\n\nThis patch fixes #4848.\n\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "jerry-core/parser/js/js-scanner-util.c",
  "func_name": "scanner_filter_arguments",
  "func_before": "void\nscanner_filter_arguments (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  /* Fast case: check whether all literals are arguments. */\n  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;\n  parser_list_iterator_t literal_iterator;\n  lexer_lit_location_t *literal_p;\n  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;\n  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;\n\n  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));\n\n  if (can_eval)\n  {\n    if (prev_literal_pool_p != NULL)\n    {\n      prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n    }\n\n    if (has_arguments)\n    {\n      literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);\n    }\n  }\n\n  literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  while (true)\n  {\n    literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);\n\n    if (literal_p == NULL)\n    {\n      return;\n    }\n\n    if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n    {\n      literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n    }\n\n    uint8_t type = literal_p->type;\n    const uint8_t mask =\n      (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);\n\n    if ((type & mask) != SCANNER_LITERAL_IS_ARG)\n    {\n      break;\n    }\n  }\n\n  /* Destructured args are placed after the other arguments because of register assignments. */\n  bool has_destructured_arg = false;\n  scanner_literal_pool_t *new_literal_pool_p;\n\n  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));\n\n  new_literal_pool_p->prev_p = literal_pool_p;\n  scanner_context_p->active_literal_pool_p = new_literal_pool_p;\n\n  *new_literal_pool_p = *literal_pool_p;\n  parser_list_init (&new_literal_pool_p->literal_pool,\n                    sizeof (lexer_lit_location_t),\n                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    uint8_t type = literal_p->type;\n\n    if (type & SCANNER_LITERAL_IS_ARG)\n    {\n      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n      {\n        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n        literal_p->type = type;\n      }\n\n      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))\n      {\n        has_destructured_arg = true;\n\n        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n        {\n          continue;\n        }\n\n        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;\n\n        literal_p->type = type;\n        continue;\n      }\n\n      lexer_lit_location_t *new_literal_p;\n      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);\n      *new_literal_p = *literal_p;\n    }\n    else if (has_arguments && scanner_literal_is_arguments (literal_p))\n    {\n      new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;\n\n      if (type & SCANNER_LITERAL_NO_REG)\n      {\n        new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;\n      }\n    }\n    else if (prev_literal_pool_p != NULL)\n    {\n      /* Propagate literal to upper level. */\n      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p);\n      type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED;\n      literal_location_p->type |= type;\n    }\n  }\n\n  if (has_destructured_arg)\n  {\n    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;\n\n      if ((literal_p->type & expected_flags) == expected_flags)\n      {\n        lexer_lit_location_t *new_literal_p;\n        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);\n        *new_literal_p = *literal_p;\n      }\n    }\n  }\n\n  new_literal_pool_p->prev_p = prev_literal_pool_p;\n\n  parser_list_free (&literal_pool_p->literal_pool);\n  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n}",
  "func_after": "void\nscanner_filter_arguments (parser_context_t *context_p, /**< context */\n                          scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  /* Fast case: check whether all literals are arguments. */\n  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;\n  parser_list_iterator_t literal_iterator;\n  lexer_lit_location_t *literal_p;\n  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;\n  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;\n\n  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));\n\n  if (can_eval)\n  {\n    if (prev_literal_pool_p != NULL)\n    {\n      prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n    }\n\n    if (has_arguments)\n    {\n      /* Force the lexically stored arguments object creation */\n      literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);\n    }\n  }\n\n  literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  while (true)\n  {\n    literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);\n\n    if (literal_p == NULL)\n    {\n      return;\n    }\n\n    if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n    {\n      literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n    }\n\n    uint8_t type = literal_p->type;\n    const uint8_t mask =\n      (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);\n\n    if ((type & mask) != SCANNER_LITERAL_IS_ARG)\n    {\n      break;\n    }\n  }\n\n  /* Destructured args are placed after the other arguments because of register assignments. */\n  bool has_destructured_arg = false;\n  scanner_literal_pool_t *new_literal_pool_p;\n\n  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));\n\n  new_literal_pool_p->prev_p = literal_pool_p;\n  scanner_context_p->active_literal_pool_p = new_literal_pool_p;\n\n  *new_literal_pool_p = *literal_pool_p;\n  parser_list_init (&new_literal_pool_p->literal_pool,\n                    sizeof (lexer_lit_location_t),\n                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));\n\n  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    uint8_t type = literal_p->type;\n\n    if (type & SCANNER_LITERAL_IS_ARG)\n    {\n      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n      {\n        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n        literal_p->type = type;\n      }\n\n      if (has_arguments && scanner_literal_is_arguments (literal_p))\n      {\n        /* 'arguments' parameter existence should prevent the arguments object construction */\n        new_literal_pool_p->status_flags =\n          (uint16_t) (new_literal_pool_p->status_flags\n                      & ~(SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS));\n      }\n\n      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))\n      {\n        has_destructured_arg = true;\n\n        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n        {\n          continue;\n        }\n\n        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;\n\n        literal_p->type = type;\n        continue;\n      }\n\n      lexer_lit_location_t *new_literal_p;\n      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);\n      *new_literal_p = *literal_p;\n    }\n    else if (has_arguments && scanner_literal_is_arguments (literal_p))\n    {\n      /* Arguments object is directly referenced from the function arguments */\n      new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;\n\n      if (type & SCANNER_LITERAL_NO_REG)\n      {\n        new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;\n      }\n    }\n    else if (prev_literal_pool_p != NULL)\n    {\n      /* Propagate literal to upper level. */\n      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p);\n      type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED;\n      literal_location_p->type |= type;\n    }\n  }\n\n  if (has_destructured_arg)\n  {\n    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n\n    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n    {\n      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;\n\n      if ((literal_p->type & expected_flags) == expected_flags)\n      {\n        lexer_lit_location_t *new_literal_p;\n        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);\n        *new_literal_p = *literal_p;\n      }\n    }\n  }\n\n  new_literal_pool_p->prev_p = prev_literal_pool_p;\n\n  parser_list_free (&literal_pool_p->literal_pool);\n  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n}",
  "diff_func": "--- func_before\n+++ func_after\n void\n scanner_filter_arguments (parser_context_t *context_p, /**< context */\n                           scanner_context_t *scanner_context_p) /**< scanner context */\n {\n   /* Fast case: check whether all literals are arguments. */\n   scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n   scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;\n   parser_list_iterator_t literal_iterator;\n   lexer_lit_location_t *literal_p;\n   bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;\n   bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;\n \n   JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));\n \n   if (can_eval)\n   {\n     if (prev_literal_pool_p != NULL)\n     {\n       prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;\n     }\n \n     if (has_arguments)\n     {\n+      /* Force the lexically stored arguments object creation */\n       literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);\n     }\n   }\n \n   literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;\n \n   parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);\n \n   while (true)\n   {\n     literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);\n \n     if (literal_p == NULL)\n     {\n       return;\n     }\n \n     if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))\n     {\n       literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;\n     }\n \n     uint8_t type = literal_p->type;\n     const uint8_t mask =\n       (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);\n \n     if ((type & mask) != SCANNER_LITERAL_IS_ARG)\n     {\n       break;\n     }\n   }\n \n   /* Destructured args are placed after the other arguments because of r",
  "diff_source": "custom"
}