{
  "id": 2930,
  "language": "Java",
  "commit_url": "https://github.com/AOSPA/android_frameworks_base/commit/2c09c34140445973b9170dc1430790d35031ad0d",
  "commit_sha": "2c09c34140445973b9170dc1430790d35031ad0d",
  "commit_msg": "Fix security vulnerability in DPMS#isProvisioningAllowed\n\nisProvisioningAllowed was calling packageManager#getPackageUidAsUser for\nthe provided packageName to compare against the callerUid, this call\nthrows a NameNotFoundException if the package isn't installed. This allows the caller to identify if an package is installed or not without holding the QUERY_ALL_PACKAGES permission.\nThis is now changed to call packageManager#getPackagesForUid for the calling uid and comparing it against the provided packageName.\nIf an uninstalled package is provided, it will now fail with a general\nerror message \"Caller uid doesn't match the one for the provided package.\"\n\nTest: Confirmed that the PoC app can no longer query which packages are\ninstalled\nTest: atest com.android.cts.devicepolicy.CustomManagedProfileTest#testIsProvisioningAllowed\nBug: 184525395\n\nChange-Id: I13135d941f4944b4313ab2a2b20f1af30a5880a5",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
  "func_name": "isProvisioningAllowed",
  "func_before": "@Override\n    public boolean isProvisioningAllowed(String action, String packageName) {\n        Objects.requireNonNull(packageName);\n\n        final CallerIdentity caller = getCallerIdentity();\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final int uidForPackage = mInjector.getPackageManager().getPackageUidAsUser(\n                    packageName, caller.getUserId());\n            Preconditions.checkArgument(caller.getUid() == uidForPackage,\n                    \"Caller uid doesn't match the one for the provided package.\");\n        } catch (NameNotFoundException e) {\n            throw new IllegalArgumentException(\"Invalid package provided \" + packageName, e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n\n        return checkProvisioningPreConditionSkipPermission(action, packageName) == CODE_OK;\n    }",
  "func_after": "@Override\n    public boolean isProvisioningAllowed(String action, String packageName) {\n        Objects.requireNonNull(packageName);\n\n        final CallerIdentity caller = getCallerIdentity();\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final List<String> callerUidPackageNames = Arrays.asList(\n                    mInjector.getPackageManager().getPackagesForUid(caller.getUid()));\n            Preconditions.checkArgument(callerUidPackageNames.contains(packageName),\n                    \"Caller uid doesn't match the one for the provided package.\");\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n\n        return checkProvisioningPreConditionSkipPermission(action, packageName) == CODE_OK;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public boolean isProvisioningAllowed(String action, String packageName) {\n         Objects.requireNonNull(packageName);\n \n         final CallerIdentity caller = getCallerIdentity();\n         final long ident = mInjector.binderClearCallingIdentity();\n         try {\n-            final int uidForPackage = mInjector.getPackageManager().getPackageUidAsUser(\n-                    packageName, caller.getUserId());\n-            Preconditions.checkArgument(caller.getUid() == uidForPackage,\n+            final List<String> callerUidPackageNames = Arrays.asList(\n+                    mInjector.getPackageManager().getPackagesForUid(caller.getUid()));\n+            Preconditions.checkArgument(callerUidPackageNames.contains(packageName),\n                     \"Caller uid doesn't match the one for the provided package.\");\n-        } catch (NameNotFoundException e) {\n-            throw new IllegalArgumentException(\"Invalid package provided \" + packageName, e);\n         } finally {\n             mInjector.binderRestoreCallingIdentity(ident);\n         }\n \n         return checkProvisioningPreConditionSkipPermission(action, packageName) == CODE_OK;\n     }",
  "diff_source": "custom"
}