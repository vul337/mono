{
  "id": 7347,
  "language": "C/C++",
  "commit_url": "https://github.com/tbeu/matio/commit/5fa49ef9fc4368fe3d19b5fdaa36d8fa5e7f4606",
  "commit_sha": "5fa49ef9fc4368fe3d19b5fdaa36d8fa5e7f4606",
  "commit_msg": "Fix integer addition overflow\n\nAs reported by https://github.com/tbeu/matio/issues/121",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/mat5.c",
  "func_name": "Mat_VarReadNextInfo5",
  "func_before": "matvar_t *\nMat_VarReadNextInfo5( mat_t *mat )\n{\n    int err;\n    mat_int32_t data_type, nBytes;\n    long fpos;\n    matvar_t *matvar = NULL;\n    mat_uint32_t array_flags;\n\n    if ( mat == NULL )\n        return NULL;\n\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n        return NULL;\n    }\n    err = fread(&data_type,4,1,(FILE*)mat->fp);\n    if ( err == 0 )\n        return NULL;\n    err = fread(&nBytes,4,1,(FILE*)mat->fp);\n    if ( mat->byteswap ) {\n        (void)Mat_int32Swap(&data_type);\n        (void)Mat_int32Swap(&nBytes);\n    }\n    switch ( data_type ) {\n        case MAT_T_COMPRESSED:\n        {\n#if defined(HAVE_ZLIB)\n            mat_uint32_t uncomp_buf[16] = {0,};\n            int      nbytes;\n            long     bytesread = 0;\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            matvar->compression = MAT_COMPRESSION_ZLIB;\n            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n            err = inflateInit(matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"inflateInit returned %s\",zError(err));\n                break;\n            }\n\n            /* Read variable tag */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"Uncompressed type not MAT_T_MATRIX\");\n                break;\n            }\n            /* Array flags */\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n                array_flags = uncomp_buf[2];\n                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( matvar->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    matvar->nbytes = uncomp_buf[3];\n                }\n            }\n            if ( matvar->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    nbytes = uncomp_buf[1];\n                    matvar->rank = nbytes / 4;\n                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = dims[j];\n                    }\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(uncomp_buf);\n                /* Name of variable */\n                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    mat_uint32_t len, len_pad;\n                    if ( mat->byteswap )\n                        len = Mat_uint32Swap(uncomp_buf+1);\n                    else\n                        len = uncomp_buf[1];\n\n                    if ( len % 8 == 0 )\n                        len_pad = len;\n                    else\n                        len_pad = len + 8 - (len % 8);\n                    matvar->name = (char*)malloc(len_pad + 1);\n                    if ( NULL != matvar->name ) {\n                        /* Variable name */\n                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);\n                        matvar->name[len] = '\\0';\n                    }\n                } else {\n                    mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                    if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                        /* Name packed in tag */\n                        matvar->name = (char*)malloc(len+1);\n                        if ( NULL != matvar->name ) {\n                            memcpy(matvar->name,uncomp_buf+1,len);\n                            matvar->name[len] = '\\0';\n                        }\n                    }\n                }\n                if ( matvar->class_type == MAT_C_STRUCT )\n                    (void)ReadNextStructField(mat,matvar);\n                else if ( matvar->class_type == MAT_C_CELL )\n                    (void)ReadNextCell(mat,matvar);\n                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);\n                matvar->internal->datapos = ftell((FILE*)mat->fp);\n                if ( matvar->internal->datapos == -1L ) {\n                    Mat_Critical(\"Couldn't determine file position\");\n                }\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n#else\n            Mat_Critical(\"Compressed variable found in \\\"%s\\\", but matio was \"\n                         \"built without zlib support\",mat->filename);\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            return NULL;\n#endif\n        }\n        case MAT_T_MATRIX:\n        {\n            mat_uint32_t buf[6];\n            size_t readresult;\n\n            /* Read array flags and the dimensions tag */\n            readresult = fread(buf, 4, 6, (FILE*)mat->fp);\n            if ( 6 != readresult ) {\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( matvar->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   matvar->nbytes = buf[3];\n               }\n            }\n            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);\n            if ( 0 == readresult && 0 < matvar->rank ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            /* Variable name tag */\n            readresult = fread(buf, 4, 2, (FILE*)mat->fp);\n            if ( 2 != readresult ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(buf);\n            /* Name of variable */\n            if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                mat_uint32_t len, len_pad;\n                if ( mat->byteswap )\n                    len = Mat_uint32Swap(buf+1);\n                else\n                    len = buf[1];\n                if ( len % 8 == 0 )\n                    len_pad = len;\n                else\n                    len_pad = len + 8 - (len % 8);\n                matvar->name = (char*)malloc(len_pad + 1);\n                if ( NULL != matvar->name ) {\n                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);\n                    if ( readresult == len_pad ) {\n                        matvar->name[len] = '\\0';\n                    } else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                        break;\n                    }\n                }\n            } else {\n                mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;\n                if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                    /* Name packed in tag */\n                    matvar->name = (char*)malloc(len+1);\n                    if ( NULL != matvar->name ) {\n                        memcpy(matvar->name, buf+1, len);\n                        matvar->name[len] = '\\0';\n                    }\n                }\n            }\n            if ( matvar->class_type == MAT_C_STRUCT )\n                (void)ReadNextStructField(mat,matvar);\n            else if ( matvar->class_type == MAT_C_CELL )\n                (void)ReadNextCell(mat,matvar);\n            else if ( matvar->class_type == MAT_C_FUNCTION )\n                (void)ReadNextFunctionHandle(mat,matvar);\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n        }\n        default:\n            Mat_Critical(\"%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)\",\n                         data_type);\n            return NULL;\n    }\n\n    return matvar;\n}",
  "func_after": "matvar_t *\nMat_VarReadNextInfo5( mat_t *mat )\n{\n    int err;\n    mat_int32_t data_type, nBytes;\n    long fpos;\n    matvar_t *matvar = NULL;\n    mat_uint32_t array_flags;\n\n    if ( mat == NULL )\n        return NULL;\n\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n        return NULL;\n    }\n    err = fread(&data_type,4,1,(FILE*)mat->fp);\n    if ( err == 0 )\n        return NULL;\n    err = fread(&nBytes,4,1,(FILE*)mat->fp);\n    if ( mat->byteswap ) {\n        (void)Mat_int32Swap(&data_type);\n        (void)Mat_int32Swap(&nBytes);\n    }\n    switch ( data_type ) {\n        case MAT_T_COMPRESSED:\n        {\n#if defined(HAVE_ZLIB)\n            mat_uint32_t uncomp_buf[16] = {0,};\n            int      nbytes;\n            long     bytesread = 0;\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            matvar->compression = MAT_COMPRESSION_ZLIB;\n            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n            err = inflateInit(matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"inflateInit returned %s\",zError(err));\n                break;\n            }\n\n            /* Read variable tag */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"Uncompressed type not MAT_T_MATRIX\");\n                break;\n            }\n            /* Array flags */\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n                array_flags = uncomp_buf[2];\n                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( matvar->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    matvar->nbytes = uncomp_buf[3];\n                }\n            }\n            if ( matvar->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    nbytes = uncomp_buf[1];\n                    matvar->rank = nbytes / 4;\n                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = dims[j];\n                    }\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(uncomp_buf);\n                /* Name of variable */\n                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    mat_uint32_t len, len_pad;\n                    if ( mat->byteswap )\n                        len = Mat_uint32Swap(uncomp_buf+1);\n                    else\n                        len = uncomp_buf[1];\n\n                    if ( len % 8 == 0 )\n                        len_pad = len;\n                    else if ( len < UINT32_MAX - 8 + (len % 8) )\n                        len_pad = len + 8 - (len % 8);\n                    else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        break;\n                    }\n                    matvar->name = (char*)malloc(len_pad + 1);\n                    if ( NULL != matvar->name ) {\n                        /* Variable name */\n                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);\n                        matvar->name[len] = '\\0';\n                    }\n                } else {\n                    mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                    if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                        /* Name packed in tag */\n                        matvar->name = (char*)malloc(len+1);\n                        if ( NULL != matvar->name ) {\n                            memcpy(matvar->name,uncomp_buf+1,len);\n                            matvar->name[len] = '\\0';\n                        }\n                    }\n                }\n                if ( matvar->class_type == MAT_C_STRUCT )\n                    (void)ReadNextStructField(mat,matvar);\n                else if ( matvar->class_type == MAT_C_CELL )\n                    (void)ReadNextCell(mat,matvar);\n                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);\n                matvar->internal->datapos = ftell((FILE*)mat->fp);\n                if ( matvar->internal->datapos == -1L ) {\n                    Mat_Critical(\"Couldn't determine file position\");\n                }\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n#else\n            Mat_Critical(\"Compressed variable found in \\\"%s\\\", but matio was \"\n                         \"built without zlib support\",mat->filename);\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            return NULL;\n#endif\n        }\n        case MAT_T_MATRIX:\n        {\n            mat_uint32_t buf[6];\n            size_t readresult;\n\n            /* Read array flags and the dimensions tag */\n            readresult = fread(buf, 4, 6, (FILE*)mat->fp);\n            if ( 6 != readresult ) {\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( matvar->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   matvar->nbytes = buf[3];\n               }\n            }\n            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);\n            if ( 0 == readresult && 0 < matvar->rank ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            /* Variable name tag */\n            readresult = fread(buf, 4, 2, (FILE*)mat->fp);\n            if ( 2 != readresult ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(buf);\n            /* Name of variable */\n            if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                mat_uint32_t len, len_pad;\n                if ( mat->byteswap )\n                    len = Mat_uint32Swap(buf+1);\n                else\n                    len = buf[1];\n                if ( len % 8 == 0 )\n                    len_pad = len;\n                else if ( len < UINT32_MAX - 8 + (len % 8) )\n                    len_pad = len + 8 - (len % 8);\n                else {\n                    Mat_VarFree(matvar);\n                    matvar = NULL;\n                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                    break;\n                }\n                matvar->name = (char*)malloc(len_pad + 1);\n                if ( NULL != matvar->name ) {\n                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);\n                    if ( readresult == len_pad ) {\n                        matvar->name[len] = '\\0';\n                    } else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                        break;\n                    }\n                }\n            } else {\n                mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;\n                if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                    /* Name packed in tag */\n                    matvar->name = (char*)malloc(len+1);\n                    if ( NULL != matvar->name ) {\n                        memcpy(matvar->name, buf+1, len);\n                        matvar->name[len] = '\\0';\n                    }\n                }\n            }\n            if ( matvar->class_type == MAT_C_STRUCT )\n                (void)ReadNextStructField(mat,matvar);\n            else if ( matvar->class_type == MAT_C_CELL )\n                (void)ReadNextCell(mat,matvar);\n            else if ( matvar->class_type == MAT_C_FUNCTION )\n                (void)ReadNextFunctionHandle(mat,matvar);\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n        }\n        default:\n            Mat_Critical(\"%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)\",\n                         data_type);\n            return NULL;\n    }\n\n    return matvar;\n}",
  "diff_func": "--- func_before\n+++ func_after\n matvar_t *\n Mat_VarReadNextInfo5( mat_t *mat )\n {\n     int err;\n     mat_int32_t data_type, nBytes;\n     long fpos;\n     matvar_t *matvar = NULL;\n     mat_uint32_t array_flags;\n \n     if ( mat == NULL )\n         return NULL;\n \n     fpos = ftell((FILE*)mat->fp);\n     if ( fpos == -1L ) {\n         Mat_Critical(\"Couldn't determine file position\");\n         return NULL;\n     }\n     err = fread(&data_type,4,1,(FILE*)mat->fp);\n     if ( err == 0 )\n         return NULL;\n     err = fread(&nBytes,4,1,(FILE*)mat->fp);\n     if ( mat->byteswap ) {\n         (void)Mat_int32Swap(&data_type);\n         (void)Mat_int32Swap(&nBytes);\n     }\n     switch ( data_type ) {\n         case MAT_T_COMPRESSED:\n         {\n #if defined(HAVE_ZLIB)\n             mat_uint32_t uncomp_buf[16] = {0,};\n             int      nbytes;\n             long     bytesread = 0;\n \n             matvar = Mat_VarCalloc();\n             if ( NULL == matvar ) {\n                 Mat_Critical(\"Couldn't allocate memory\");\n                 break;\n             }\n \n             matvar->compression = MAT_COMPRESSION_ZLIB;\n             matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n             err = inflateInit(matvar->internal->z);\n             if ( err != Z_OK ) {\n                 Mat_VarFree(matvar);\n                 matvar = NULL;\n                 Mat_Critical(\"inflateInit returned %s\",zError(err));\n                 break;\n             }\n \n             /* Read variable tag */\n             bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n             if ( mat->byteswap ) {\n                 (void)Mat_uint32Swap(uncomp_buf);\n                 (void)Mat_uint32Swap(uncomp_buf+1);\n             }\n             nbytes = uncomp_buf[1];\n             if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                 (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                 Mat_VarFree(matvar);\n                 matvar = NULL;\n                 Mat_Critical(\"Uncompressed type not MAT_T_MATR",
  "diff_source": "custom"
}