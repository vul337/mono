{
  "id": 167,
  "language": "Java",
  "commit_url": "https://github.com/LineageOS/android_frameworks_base/commit/9546f607f68814f5269374b5c5e714c9d8d8b0b8",
  "commit_sha": "9546f607f68814f5269374b5c5e714c9d8d8b0b8",
  "commit_msg": "Add ActivityOption to remove insecure keyguard when activity is launched.\n\nAdd a new ActivityOption#setDismissKeyguardIfInsecure remove keyguard\nwhen an activity is launched while an insecure keyguard is shown. If\nthis option is set, WMS waits until the launched activity finishes\ndrawing its surface, then starts KEYGUARD_GOING_AWAY app transition.\n\nBug: 203044476\nTest: atest KeyguardLockedTests KeyguardTransitionTests\nChange-Id: I0f6a501baa2a60ae044bf1ef888e5e6f57a5f13e",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/am/ActivityManagerShellCommand.java",
  "func_name": "RemoteException",
  "func_before": "int runStartActivity(PrintWriter pw) throws RemoteException {\n        Intent intent;\n        try {\n            intent = makeIntent(UserHandle.USER_CURRENT);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n\n        if (mUserId == UserHandle.USER_ALL) {\n            getErrPrintWriter().println(\"Error: Can't start service with user 'all'\");\n            return 1;\n        }\n\n        String mimeType = intent.getType();\n        if (mimeType == null && intent.getData() != null\n                && \"content\".equals(intent.getData().getScheme())) {\n            mimeType = mInterface.getProviderMimeType(intent.getData(), mUserId);\n        }\n\n        do {\n            if (mStopOption) {\n                String packageName;\n                if (intent.getComponent() != null) {\n                    packageName = intent.getComponent().getPackageName();\n                } else {\n                    // queryIntentActivities does not convert user id, so we convert it here first\n                    int userIdForQuery = mInternal.mUserController.handleIncomingUser(\n                            Binder.getCallingPid(), Binder.getCallingUid(), mUserId, false,\n                            ALLOW_NON_FULL, \"ActivityManagerShellCommand\", null);\n                    List<ResolveInfo> activities = mPm.queryIntentActivities(intent, mimeType, 0,\n                            userIdForQuery).getList();\n                    if (activities == null || activities.size() <= 0) {\n                        getErrPrintWriter().println(\"Error: Intent does not match any activities: \"\n                                + intent);\n                        return 1;\n                    } else if (activities.size() > 1) {\n                        getErrPrintWriter().println(\n                                \"Error: Intent matches multiple activities; can't stop: \"\n                                + intent);\n                        return 1;\n                    }\n                    packageName = activities.get(0).activityInfo.packageName;\n                }\n                pw.println(\"Stopping: \" + packageName);\n                pw.flush();\n                mInterface.forceStopPackage(packageName, mUserId);\n                try {\n                    Thread.sleep(250);\n                } catch (InterruptedException e) {\n                }\n            }\n\n            ProfilerInfo profilerInfo = null;\n\n            if (mProfileFile != null || mAgent != null) {\n                ParcelFileDescriptor fd = null;\n                if (mProfileFile != null) {\n                    fd = openFileForSystem(mProfileFile, \"w\");\n                    if (fd == null) {\n                        return 1;\n                    }\n                }\n                profilerInfo = new ProfilerInfo(mProfileFile, fd, mSamplingInterval, mAutoStop,\n                        mStreaming, mAgent, mAttachAgentDuringBind);\n            }\n\n            pw.println(\"Starting: \" + intent);\n            pw.flush();\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n            WaitResult result = null;\n            int res;\n            final long startTime = SystemClock.uptimeMillis();\n            ActivityOptions options = null;\n            if (mDisplayId != INVALID_DISPLAY) {\n                options = ActivityOptions.makeBasic();\n                options.setLaunchDisplayId(mDisplayId);\n            }\n            if (mWindowingMode != WINDOWING_MODE_UNDEFINED) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setLaunchWindowingMode(mWindowingMode);\n            }\n            if (mActivityType != ACTIVITY_TYPE_UNDEFINED) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setLaunchActivityType(mActivityType);\n            }\n            if (mTaskId != INVALID_TASK_ID) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setLaunchTaskId(mTaskId);\n\n                if (mIsTaskOverlay) {\n                    options.setTaskOverlay(true, true /* canResume */);\n                }\n            }\n            if (mIsLockTask) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setLockTaskEnabled(true);\n            }\n            if (mShowSplashScreen) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setSplashScreenStyle(SplashScreen.SPLASH_SCREEN_STYLE_ICON);\n            }\n            if (mWaitOption) {\n                result = mInternal.startActivityAndWait(null, SHELL_PACKAGE_NAME, null, intent,\n                        mimeType, null, null, 0, mStartFlags, profilerInfo,\n                        options != null ? options.toBundle() : null, mUserId);\n                res = result.result;\n            } else {\n                res = mInternal.startActivityAsUserWithFeature(null, SHELL_PACKAGE_NAME, null,\n                        intent, mimeType, null, null, 0, mStartFlags, profilerInfo,\n                        options != null ? options.toBundle() : null, mUserId);\n            }\n            final long endTime = SystemClock.uptimeMillis();\n            PrintWriter out = mWaitOption ? pw : getErrPrintWriter();\n            boolean launched = false;\n            switch (res) {\n                case ActivityManager.START_SUCCESS:\n                    launched = true;\n                    break;\n                case ActivityManager.START_SWITCHES_CANCELED:\n                    launched = true;\n                    out.println(\n                            \"Warning: Activity not started because the \"\n                                    + \" current activity is being kept for the user.\");\n                    break;\n                case ActivityManager.START_DELIVERED_TO_TOP:\n                    launched = true;\n                    out.println(\n                            \"Warning: Activity not started, intent has \"\n                                    + \"been delivered to currently running \"\n                                    + \"top-most instance.\");\n                    break;\n                case ActivityManager.START_RETURN_INTENT_TO_CALLER:\n                    launched = true;\n                    out.println(\n                            \"Warning: Activity not started because intent \"\n                                    + \"should be handled by the caller\");\n                    break;\n                case ActivityManager.START_TASK_TO_FRONT:\n                    launched = true;\n                    out.println(\n                            \"Warning: Activity not started, its current \"\n                                    + \"task has been brought to the front\");\n                    break;\n                case ActivityManager.START_INTENT_NOT_RESOLVED:\n                    out.println(\n                            \"Error: Activity not started, unable to \"\n                                    + \"resolve \" + intent.toString());\n                    break;\n                case ActivityManager.START_CLASS_NOT_FOUND:\n                    out.println(NO_CLASS_ERROR_CODE);\n                    out.println(\"Error: Activity class \" +\n                            intent.getComponent().toShortString()\n                            + \" does not exist.\");\n                    break;\n                case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:\n                    out.println(\n                            \"Error: Activity not started, you requested to \"\n                                    + \"both forward and receive its result\");\n                    break;\n                case ActivityManager.START_PERMISSION_DENIED:\n                    out.println(\n                            \"Error: Activity not started, you do not \"\n                                    + \"have permission to access it.\");\n                    break;\n                case ActivityManager.START_NOT_VOICE_COMPATIBLE:\n                    out.println(\n                            \"Error: Activity not started, voice control not allowed for: \"\n                                    + intent);\n                    break;\n                case ActivityManager.START_NOT_CURRENT_USER_ACTIVITY:\n                    out.println(\n                            \"Error: Not allowed to start background user activity\"\n                                    + \" that shouldn't be displayed for all users.\");\n                    break;\n                default:\n                    out.println(\n                            \"Error: Activity not started, unknown error code \" + res);\n                    break;\n            }\n            out.flush();\n            if (mWaitOption && launched) {\n                if (result == null) {\n                    result = new WaitResult();\n                    result.who = intent.getComponent();\n                }\n                pw.println(\"Status: \" + (result.timeout ? \"timeout\" : \"ok\"));\n                pw.println(\"LaunchState: \" + launchStateToString(result.launchState));\n                if (result.who != null) {\n                    pw.println(\"Activity: \" + result.who.flattenToShortString());\n                }\n                if (result.totalTime >= 0) {\n                    pw.println(\"TotalTime: \" + result.totalTime);\n                }\n                pw.println(\"WaitTime: \" + (endTime-startTime));\n                pw.println(\"Complete\");\n                pw.flush();\n            }\n            mRepeat--;\n            if (mRepeat > 0) {\n                mTaskInterface.unhandledBack();\n            }\n        } while (mRepeat > 0);\n        return 0;\n    }",
  "func_after": "int runStartActivity(PrintWriter pw) throws RemoteException {\n        Intent intent;\n        try {\n            intent = makeIntent(UserHandle.USER_CURRENT);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n\n        if (mUserId == UserHandle.USER_ALL) {\n            getErrPrintWriter().println(\"Error: Can't start service with user 'all'\");\n            return 1;\n        }\n\n        String mimeType = intent.getType();\n        if (mimeType == null && intent.getData() != null\n                && \"content\".equals(intent.getData().getScheme())) {\n            mimeType = mInterface.getProviderMimeType(intent.getData(), mUserId);\n        }\n\n        do {\n            if (mStopOption) {\n                String packageName;\n                if (intent.getComponent() != null) {\n                    packageName = intent.getComponent().getPackageName();\n                } else {\n                    // queryIntentActivities does not convert user id, so we convert it here first\n                    int userIdForQuery = mInternal.mUserController.handleIncomingUser(\n                            Binder.getCallingPid(), Binder.getCallingUid(), mUserId, false,\n                            ALLOW_NON_FULL, \"ActivityManagerShellCommand\", null);\n                    List<ResolveInfo> activities = mPm.queryIntentActivities(intent, mimeType, 0,\n                            userIdForQuery).getList();\n                    if (activities == null || activities.size() <= 0) {\n                        getErrPrintWriter().println(\"Error: Intent does not match any activities: \"\n                                + intent);\n                        return 1;\n                    } else if (activities.size() > 1) {\n                        getErrPrintWriter().println(\n                                \"Error: Intent matches multiple activities; can't stop: \"\n                                + intent);\n                        return 1;\n                    }\n                    packageName = activities.get(0).activityInfo.packageName;\n                }\n                pw.println(\"Stopping: \" + packageName);\n                pw.flush();\n                mInterface.forceStopPackage(packageName, mUserId);\n                try {\n                    Thread.sleep(250);\n                } catch (InterruptedException e) {\n                }\n            }\n\n            ProfilerInfo profilerInfo = null;\n\n            if (mProfileFile != null || mAgent != null) {\n                ParcelFileDescriptor fd = null;\n                if (mProfileFile != null) {\n                    fd = openFileForSystem(mProfileFile, \"w\");\n                    if (fd == null) {\n                        return 1;\n                    }\n                }\n                profilerInfo = new ProfilerInfo(mProfileFile, fd, mSamplingInterval, mAutoStop,\n                        mStreaming, mAgent, mAttachAgentDuringBind);\n            }\n\n            pw.println(\"Starting: \" + intent);\n            pw.flush();\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n            WaitResult result = null;\n            int res;\n            final long startTime = SystemClock.uptimeMillis();\n            ActivityOptions options = null;\n            if (mDisplayId != INVALID_DISPLAY) {\n                options = ActivityOptions.makeBasic();\n                options.setLaunchDisplayId(mDisplayId);\n            }\n            if (mWindowingMode != WINDOWING_MODE_UNDEFINED) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setLaunchWindowingMode(mWindowingMode);\n            }\n            if (mActivityType != ACTIVITY_TYPE_UNDEFINED) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setLaunchActivityType(mActivityType);\n            }\n            if (mTaskId != INVALID_TASK_ID) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setLaunchTaskId(mTaskId);\n\n                if (mIsTaskOverlay) {\n                    options.setTaskOverlay(true, true /* canResume */);\n                }\n            }\n            if (mIsLockTask) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setLockTaskEnabled(true);\n            }\n            if (mShowSplashScreen) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setSplashScreenStyle(SplashScreen.SPLASH_SCREEN_STYLE_ICON);\n            }\n            if (mDismissKeyguardIfInsecure) {\n                if (options == null) {\n                    options = ActivityOptions.makeBasic();\n                }\n                options.setDismissKeyguardIfInsecure();\n            }\n            if (mWaitOption) {\n                result = mInternal.startActivityAndWait(null, SHELL_PACKAGE_NAME, null, intent,\n                        mimeType, null, null, 0, mStartFlags, profilerInfo,\n                        options != null ? options.toBundle() : null, mUserId);\n                res = result.result;\n            } else {\n                res = mInternal.startActivityAsUserWithFeature(null, SHELL_PACKAGE_NAME, null,\n                        intent, mimeType, null, null, 0, mStartFlags, profilerInfo,\n                        options != null ? options.toBundle() : null, mUserId);\n            }\n            final long endTime = SystemClock.uptimeMillis();\n            PrintWriter out = mWaitOption ? pw : getErrPrintWriter();\n            boolean launched = false;\n            switch (res) {\n                case ActivityManager.START_SUCCESS:\n                    launched = true;\n                    break;\n                case ActivityManager.START_SWITCHES_CANCELED:\n                    launched = true;\n                    out.println(\n                            \"Warning: Activity not started because the \"\n                                    + \" current activity is being kept for the user.\");\n                    break;\n                case ActivityManager.START_DELIVERED_TO_TOP:\n                    launched = true;\n                    out.println(\n                            \"Warning: Activity not started, intent has \"\n                                    + \"been delivered to currently running \"\n                                    + \"top-most instance.\");\n                    break;\n                case ActivityManager.START_RETURN_INTENT_TO_CALLER:\n                    launched = true;\n                    out.println(\n                            \"Warning: Activity not started because intent \"\n                                    + \"should be handled by the caller\");\n                    break;\n                case ActivityManager.START_TASK_TO_FRONT:\n                    launched = true;\n                    out.println(\n                            \"Warning: Activity not started, its current \"\n                                    + \"task has been brought to the front\");\n                    break;\n                case ActivityManager.START_INTENT_NOT_RESOLVED:\n                    out.println(\n                            \"Error: Activity not started, unable to \"\n                                    + \"resolve \" + intent.toString());\n                    break;\n                case ActivityManager.START_CLASS_NOT_FOUND:\n                    out.println(NO_CLASS_ERROR_CODE);\n                    out.println(\"Error: Activity class \" +\n                            intent.getComponent().toShortString()\n                            + \" does not exist.\");\n                    break;\n                case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:\n                    out.println(\n                            \"Error: Activity not started, you requested to \"\n                                    + \"both forward and receive its result\");\n                    break;\n                case ActivityManager.START_PERMISSION_DENIED:\n                    out.println(\n                            \"Error: Activity not started, you do not \"\n                                    + \"have permission to access it.\");\n                    break;\n                case ActivityManager.START_NOT_VOICE_COMPATIBLE:\n                    out.println(\n                            \"Error: Activity not started, voice control not allowed for: \"\n                                    + intent);\n                    break;\n                case ActivityManager.START_NOT_CURRENT_USER_ACTIVITY:\n                    out.println(\n                            \"Error: Not allowed to start background user activity\"\n                                    + \" that shouldn't be displayed for all users.\");\n                    break;\n                default:\n                    out.println(\n                            \"Error: Activity not started, unknown error code \" + res);\n                    break;\n            }\n            out.flush();\n            if (mWaitOption && launched) {\n                if (result == null) {\n                    result = new WaitResult();\n                    result.who = intent.getComponent();\n                }\n                pw.println(\"Status: \" + (result.timeout ? \"timeout\" : \"ok\"));\n                pw.println(\"LaunchState: \" + launchStateToString(result.launchState));\n                if (result.who != null) {\n                    pw.println(\"Activity: \" + result.who.flattenToShortString());\n                }\n                if (result.totalTime >= 0) {\n                    pw.println(\"TotalTime: \" + result.totalTime);\n                }\n                pw.println(\"WaitTime: \" + (endTime-startTime));\n                pw.println(\"Complete\");\n                pw.flush();\n            }\n            mRepeat--;\n            if (mRepeat > 0) {\n                mTaskInterface.unhandledBack();\n            }\n        } while (mRepeat > 0);\n        return 0;\n    }",
  "diff_func": "--- func_before\n+++ func_after\n int runStartActivity(PrintWriter pw) throws RemoteException {\n         Intent intent;\n         try {\n             intent = makeIntent(UserHandle.USER_CURRENT);\n         } catch (URISyntaxException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n \n         if (mUserId == UserHandle.USER_ALL) {\n             getErrPrintWriter().println(\"Error: Can't start service with user 'all'\");\n             return 1;\n         }\n \n         String mimeType = intent.getType();\n         if (mimeType == null && intent.getData() != null\n                 && \"content\".equals(intent.getData().getScheme())) {\n             mimeType = mInterface.getProviderMimeType(intent.getData(), mUserId);\n         }\n \n         do {\n             if (mStopOption) {\n                 String packageName;\n                 if (intent.getComponent() != null) {\n                     packageName = intent.getComponent().getPackageName();\n                 } else {\n                     // queryIntentActivities does not convert user id, so we convert it here first\n                     int userIdForQuery = mInternal.mUserController.handleIncomingUser(\n                             Binder.getCallingPid(), Binder.getCallingUid(), mUserId, false,\n                             ALLOW_NON_FULL, \"ActivityManagerShellCommand\", null);\n                     List<ResolveInfo> activities = mPm.queryIntentActivities(intent, mimeType, 0,\n                             userIdForQuery).getList();\n                     if (activities == null || activities.size() <= 0) {\n                         getErrPrintWriter().println(\"Error: Intent does not match any activities: \"\n                                 + intent);\n                         return 1;\n                     } else if (activities.size() > 1) {\n                         getErrPrintWriter().println(\n                                 \"Error: Intent matches multiple activities; can't stop: \"\n                                 + intent",
  "diff_source": "custom"
}