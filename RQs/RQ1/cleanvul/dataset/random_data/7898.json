{
  "id": 7898,
  "language": "JavaScript",
  "commit_url": "https://github.com/isomorphic-git/cors-proxy/commit/1b1c91e71d946544d97ccc7cf0ac62b859e03311",
  "commit_sha": "1b1c91e71d946544d97ccc7cf0ac62b859e03311",
  "commit_msg": "fix(security): don't follow redirects (#10)",
  "pr_url": "https://github.com/isomorphic-git/cors-proxy/pull/10",
  "pr_info": "If cors-proxy is running inside a private network (`192.168.x.x` or `10.0.x.x` etc) and receiving traffic from the outside, an attacker could send an HTTP request to the cors-proxy with their own evil server as the proxy target, and their server could return a 301 response with a `Location` header that points to a private IP address, and this could be used to probe and possibly exfiltrate data from a private network. This is called server-side request forgery.\r\n\r\nThe safest way to prevent such attacks is to not have the server follow redirects. However, we can't simply throw an error because redirects are common, for instance when a user renames their git repo.\r\n\r\nInstead we'll pass the `Location` header onward back to the client (which in this scenario would be the attacker) rendering any such attack moot. We can't pass the location header back verbatim though... or the client would change origins and stop using the proxy on the subsequent request. So we make it into a path by stripping out the protocol. 😮‍💨 \r\n\r\nI believe that the worst that can happen as a result of this change is slightly increased latency, as redirects will be resolved on the client instead of the server.\r\n\r\n# Testing to demonstrate there hopefully won't be any regressions for anyone...\r\n\r\nI am testing with GitLab, because it annoyingly uses a redirect from `repo` to `repo.git` 🙄 that's been a _bane_.\r\n\r\n## Browser\r\n\r\n### Old code - redirect followed by server\r\n![image](https://user-images.githubusercontent.com/587740/148479530-4973b962-822a-4cdb-aebd-8c98d2687a76.png)\r\n\r\n![image](https://user-images.githubusercontent.com/587740/148479326-0014059a-1e69-4760-a7fa-5ad7737d63f2.png)\r\n\r\n\r\n### New code - redirect followed by client\r\n![image](https://user-images.githubusercontent.com/587740/148479648-6332f73c-15ec-40ff-b244-9cd349c073ed.png)\r\n\r\n![image](https://user-images.githubusercontent.com/587740/148479707-4995658b-928f-4089-b833-ca9220b3138f.png)\r\n\r\n## Desktop git\r\n\r\n### Old code - redirect followed by server\r\n![image](https://user-images.githubusercontent.com/587740/148479129-c5cb5da3-84e8-41a2-b75e-337d0663e050.png)\r\n\r\nEr... ok that's actually unexpected. Not sure what the deal is there.\r\n\r\n### New code - redirect followed by client\r\n\r\n![image](https://user-images.githubusercontent.com/587740/148478849-4cb6c53d-25d5-4b15-b9bd-9a271183e011.png)\r\n\r\n### Here's how it looks without a proxy for comparison\r\n![image](https://user-images.githubusercontent.com/587740/148479914-65bf7f9d-294b-43c6-b59f-2577a13f6273.png)\r\n",
  "file_name": "middleware.js",
  "func_name": "middleware",
  "func_before": "function middleware (req, res) {\n    let u = url.parse(req.url, true)\n\n\n    let headers = {}\n    for (let h of allowHeaders) {\n      if (req.headers[h]) {\n        headers[h] = req.headers[h]\n      }\n    }\n\n    // GitHub uses user-agent sniffing for git/* and changes its behavior which is frustrating\n    if (!headers['user-agent'] || !headers['user-agent'].startsWith('git/')) {\n      headers['user-agent'] = 'git/@isomorphic-git/cors-proxy'\n    }\n\n    let p = u.path\n    let parts = p.match(/\\/([^\\/]*)\\/(.*)/)\n    let pathdomain = parts[1]\n    let remainingpath = parts[2]\n    let protocol = insecure_origins.includes(pathdomain) ? 'http' : 'https'\n\n    fetch(\n      `${protocol}://${pathdomain}/${remainingpath}`,\n      {\n        method: req.method,\n        headers,\n        body: (req.method !== 'GET' && req.method !== 'HEAD') ? req : undefined\n      }\n    ).then(f => {\n      res.statusCode = f.status\n      for (let h of exposeHeaders) {\n        if (h === 'content-length') continue\n        if (f.headers.has(h)) {\n          res.setHeader(h, f.headers.get(h))\n        }\n      }\n      if (f.redirected) {\n        res.setHeader('x-redirected-url', f.url)\n      }\n      f.body.pipe(res)\n    })\n  }",
  "func_after": "function middleware (req, res) {\n    let u = url.parse(req.url, true)\n\n\n    let headers = {}\n    for (let h of allowHeaders) {\n      if (req.headers[h]) {\n        headers[h] = req.headers[h]\n      }\n    }\n\n    // GitHub uses user-agent sniffing for git/* and changes its behavior which is frustrating\n    if (!headers['user-agent'] || !headers['user-agent'].startsWith('git/')) {\n      headers['user-agent'] = 'git/@isomorphic-git/cors-proxy'\n    }\n\n    let p = u.path\n    let parts = p.match(/\\/([^\\/]*)\\/(.*)/)\n    let pathdomain = parts[1]\n    let remainingpath = parts[2]\n    let protocol = insecure_origins.includes(pathdomain) ? 'http' : 'https'\n\n    fetch(\n      `${protocol}://${pathdomain}/${remainingpath}`,\n      {\n        method: req.method,\n        redirect: 'manual',\n        headers,\n        body: (req.method !== 'GET' && req.method !== 'HEAD') ? req : undefined\n      }\n    ).then(f => {\n      if (f.headers.has('location')) {\n        // Modify the location so the client continues to use the proxy\n        let newUrl = f.headers.get('location').replace(/^https?:\\//, '')\n        f.headers.set('location', newUrl)\n      }\n      res.statusCode = f.status\n      for (let h of exposeHeaders) {\n        if (h === 'content-length') continue\n        if (f.headers.has(h)) {\n          res.setHeader(h, f.headers.get(h))\n        }\n      }\n      if (f.redirected) {\n        res.setHeader('x-redirected-url', f.url)\n      }\n      f.body.pipe(res)\n    })\n  }",
  "diff_func": "--- func_before\n+++ func_after\n function middleware (req, res) {\n     let u = url.parse(req.url, true)\n \n \n     let headers = {}\n     for (let h of allowHeaders) {\n       if (req.headers[h]) {\n         headers[h] = req.headers[h]\n       }\n     }\n \n     // GitHub uses user-agent sniffing for git/* and changes its behavior which is frustrating\n     if (!headers['user-agent'] || !headers['user-agent'].startsWith('git/')) {\n       headers['user-agent'] = 'git/@isomorphic-git/cors-proxy'\n     }\n \n     let p = u.path\n     let parts = p.match(/\\/([^\\/]*)\\/(.*)/)\n     let pathdomain = parts[1]\n     let remainingpath = parts[2]\n     let protocol = insecure_origins.includes(pathdomain) ? 'http' : 'https'\n \n     fetch(\n       `${protocol}://${pathdomain}/${remainingpath}`,\n       {\n         method: req.method,\n+        redirect: 'manual',\n         headers,\n         body: (req.method !== 'GET' && req.method !== 'HEAD') ? req : undefined\n       }\n     ).then(f => {\n+      if (f.headers.has('location')) {\n+        // Modify the location so the client continues to use the proxy\n+        let newUrl = f.headers.get('location').replace(/^https?:\\//, '')\n+        f.headers.set('location', newUrl)\n+      }\n       res.statusCode = f.status\n       for (let h of exposeHeaders) {\n         if (h === 'content-length') continue\n         if (f.headers.has(h)) {\n           res.setHeader(h, f.headers.get(h))\n         }\n       }\n       if (f.redirected) {\n         res.setHeader('x-redirected-url', f.url)\n       }\n       f.body.pipe(res)\n     })\n   }",
  "diff_source": "custom"
}