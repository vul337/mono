{
  "id": 4593,
  "language": "C/C++",
  "commit_url": "https://github.com/proftpd/proftpd/commit/ecff21e0d0e84f35c299ef91d7fda088e516d4ed",
  "commit_sha": "ecff21e0d0e84f35c299ef91d7fda088e516d4ed",
  "commit_msg": "Backporting recursive handling of DefaultRoot path, when AllowChrootSymlinks\nis off, to 1.3.5 branch.",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "modules/mod_auth.c",
  "func_name": "get_default_root",
  "func_before": "static int get_default_root(pool *p, int allow_symlinks, char **root) {\n  config_rec *c = NULL;\n  char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir) {\n    char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n\n      if (allow_symlinks == FALSE) {\n        char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        struct stat st;\n        size_t pathlen;\n\n        /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = dir;\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n          path[pathlen-1] = '\\0';\n        }\n\n        pr_fs_clear_cache();\n        res = pr_fsio_lstat(path, &st);\n        if (res < 0) {\n          xerrno = errno;\n\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n            strerror(xerrno));\n\n          errno = xerrno;\n          return -1;\n        }\n\n        if (S_ISLNK(st.st_mode)) {\n          pr_log_pri(PR_LOG_WARNING,\n            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n            \"config)\", path);\n          errno = EPERM;\n          return -1;\n        }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}",
  "func_after": "static int get_default_root(pool *p, int allow_symlinks, char **root) {\n  config_rec *c = NULL;\n  char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir) {\n    char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n\n      if (allow_symlinks == FALSE) {\n        char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        size_t pathlen;\n\n        /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = dir;\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n          path[pathlen-1] = '\\0';\n        }\n\n        res = is_symlink_path(p, path, pathlen);\n        if (res < 0) {\n          if (errno == EPERM) {\n            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"\n              \"(denied by AllowChrootSymlinks config)\", path);\n          }\n\n          errno = EPERM;\n          return -1;\n        }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int get_default_root(pool *p, int allow_symlinks, char **root) {\n   config_rec *c = NULL;\n   char *dir = NULL;\n   int res;\n \n   c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n   while (c) {\n     pr_signals_handle();\n \n     /* Check the groups acl */\n     if (c->argc < 2) {\n       dir = c->argv[0];\n       break;\n     }\n \n     res = pr_expr_eval_group_and(((char **) c->argv)+1);\n     if (res) {\n       dir = c->argv[0];\n       break;\n     }\n \n     c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n   }\n \n   if (dir) {\n     char *new_dir;\n \n     /* Check for any expandable variables. */\n     new_dir = path_subst_uservar(p, &dir);\n     if (new_dir != NULL) {\n       dir = new_dir;\n     }\n \n     if (strncmp(dir, \"/\", 2) == 0) {\n       dir = NULL;\n \n     } else {\n       char *realdir;\n       int xerrno = 0;\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n          * do this for us, but dir_realpath() ALSO automatically follows\n          * symlinks, which is what we do NOT want to do here.\n          */\n \n         path = dir;\n         if (*path != '/') {\n           if (*path == '~') {\n             if (pr_fs_interpolate(dir, target_path,\n                 sizeof(target_path)-1) < 0) {\n               return -1;\n             }\n \n             path = target_path;\n           }\n         }\n \n         /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n          * the path, particularly in the case of a symlink to a directory.\n          * Thus to get the correct test, we need to remove any trailing slash\n          * that might be present.  Subtle.\n          */\n         pathlen = strlen(path);\n         if (pathlen > 1 &&\n             path[pathlen-1] == '/') {\n           path[pathlen-1] = '\\0';\n         }\n \n+      ",
  "diff_source": "custom"
}