{
  "id": 1,
  "language": "Java",
  "commit_url": "https://github.com/elastic/elasticsearch/commit/2f0733d1b5dc9458ec901efe2f7141742d9dfed8",
  "commit_sha": "2f0733d1b5dc9458ec901efe2f7141742d9dfed8",
  "commit_msg": "Fix can access resource checks for API Keys with run as (#84277)\n\nThis fixes two things for the \"can access\" authz check: * API Keys\nrunning as, have access to the resources created by the effective run as\nuser * tokens created by API Keys (with the client credentials) have\naccess to the API Key's resources\n\nIn addition, this PR moves some of the authz plumbing code from the\nAsync and Scroll services classes under the Security Context class (as a\nminor refactoring).",
  "pr_url": "https://github.com/elastic/elasticsearch/pull/84277",
  "pr_info": "This fixes two things for the \"can access\" authz check:\r\n* API Keys running as, have access to the resources created by the effective run as user\r\n* tokens created by API Keys (with the client credentials) have access to the API Key's resources\r\n\r\nIn addition, this PR moves some of the authz plumbing code from the Async and Scroll services classes under the Security Context class (as a minor refactoring).",
  "file_name": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java",
  "func_name": "canAccessResourcesOf",
  "func_before": "public boolean canAccessResourcesOf(Authentication other) {\n        if (isApiKey() && other.isApiKey()) {\n            final boolean sameKeyId = getMetadata().get(AuthenticationField.API_KEY_ID_KEY)\n                .equals(other.getMetadata().get(AuthenticationField.API_KEY_ID_KEY));\n            if (sameKeyId) {\n                assert getUser().principal().equals(getUser().principal())\n                    : \"The same API key ID cannot be attributed to two different usernames\";\n            }\n            return sameKeyId;\n        }\n\n        if (getAuthenticationType().equals(other.getAuthenticationType())\n            || (AuthenticationType.REALM == getAuthenticationType() && AuthenticationType.TOKEN == other.getAuthenticationType())\n            || (AuthenticationType.TOKEN == getAuthenticationType() && AuthenticationType.REALM == other.getAuthenticationType())) {\n            if (false == getUser().principal().equals(other.getUser().principal())) {\n                return false;\n            }\n            final RealmRef thisRealm = getSourceRealm();\n            final RealmRef otherRealm = other.getSourceRealm();\n            if (FileRealmSettings.TYPE.equals(thisRealm.getType()) || NativeRealmSettings.TYPE.equals(thisRealm.getType())) {\n                return thisRealm.getType().equals(otherRealm.getType());\n            }\n            return thisRealm.getName().equals(otherRealm.getName()) && thisRealm.getType().equals(otherRealm.getType());\n        } else {\n            assert EnumSet.of(\n                AuthenticationType.REALM,\n                AuthenticationType.API_KEY,\n                AuthenticationType.TOKEN,\n                AuthenticationType.ANONYMOUS,\n                AuthenticationType.INTERNAL\n            ).containsAll(EnumSet.of(getAuthenticationType(), other.getAuthenticationType()))\n                : \"cross AuthenticationType comparison for canAccessResourcesOf is not applicable for: \"\n                    + EnumSet.of(getAuthenticationType(), other.getAuthenticationType());\n            return false;\n        }\n    }",
  "func_after": "public boolean canAccessResourcesOf(Authentication other) {\n        // if we introduce new authentication types in the future, it is likely that we'll need to revisit this method\n        assert EnumSet.of(\n            Authentication.AuthenticationType.REALM,\n            Authentication.AuthenticationType.API_KEY,\n            Authentication.AuthenticationType.TOKEN,\n            Authentication.AuthenticationType.ANONYMOUS,\n            Authentication.AuthenticationType.INTERNAL\n        ).containsAll(EnumSet.of(getAuthenticationType(), other.getAuthenticationType()))\n            : \"cross AuthenticationType comparison for canAccessResourcesOf is not applicable for: \"\n                + EnumSet.of(getAuthenticationType(), other.getAuthenticationType());\n        final AuthenticationContext myAuthContext = AuthenticationContext.fromAuthentication(this);\n        final AuthenticationContext creatorAuthContext = AuthenticationContext.fromAuthentication(other);\n        if (API_KEY.equals(myAuthContext.getEffectiveSubject().getType())\n            && API_KEY.equals(creatorAuthContext.getEffectiveSubject().getType())) {\n            final boolean sameKeyId = myAuthContext.getEffectiveSubject()\n                .getMetadata()\n                .get(AuthenticationField.API_KEY_ID_KEY)\n                .equals(creatorAuthContext.getEffectiveSubject().getMetadata().get(AuthenticationField.API_KEY_ID_KEY));\n            assert false == sameKeyId\n                || myAuthContext.getEffectiveSubject()\n                    .getUser()\n                    .principal()\n                    .equals(creatorAuthContext.getEffectiveSubject().getUser().principal())\n                : \"The same API key ID cannot be attributed to two different usernames\";\n            return sameKeyId;\n        } else if ((API_KEY.equals(myAuthContext.getEffectiveSubject().getType())\n            && false == API_KEY.equals(creatorAuthContext.getEffectiveSubject().getType()))\n            || (false == API_KEY.equals(myAuthContext.getEffectiveSubject().getType())\n                && API_KEY.equals(creatorAuthContext.getEffectiveSubject().getType()))) {\n                    // an API Key cannot access resources created by non-API Keys or vice-versa\n                    return false;\n                } else {\n                    if (false == myAuthContext.getEffectiveSubject()\n                        .getUser()\n                        .principal()\n                        .equals(creatorAuthContext.getEffectiveSubject().getUser().principal())) {\n                        return false;\n                    }\n                    final Authentication.RealmRef myAuthRealm = myAuthContext.getEffectiveSubject().getRealm();\n                    final Authentication.RealmRef creatorAuthRealm = creatorAuthContext.getEffectiveSubject().getRealm();\n                    if (FileRealmSettings.TYPE.equals(myAuthRealm.getType()) || NativeRealmSettings.TYPE.equals(myAuthRealm.getType())) {\n                        // file and native realms can be renamed...\n                        // nonetheless, they are singleton realms, only one such realm of each type can exist\n                        return myAuthRealm.getType().equals(creatorAuthRealm.getType());\n                    } else {\n                        return myAuthRealm.getName().equals(creatorAuthRealm.getName())\n                            && myAuthRealm.getType().equals(creatorAuthRealm.getType());\n                    }\n                }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public boolean canAccessResourcesOf(Authentication other) {\n-        if (isApiKey() && other.isApiKey()) {\n+        // if we introduce new authentication types in the future, it is likely that we'll need to revisit this method\n+        assert EnumSet.of(\n+            Authentication.AuthenticationType.REALM,\n+            Authentication.AuthenticationType.API_KEY,\n+            Authentication.AuthenticationType.TOKEN,\n+            Authentication.AuthenticationType.ANONYMOUS,\n+            Authentication.AuthenticationType.INTERNAL\n+        ).containsAll(EnumSet.of(getAuthenticationType(), other.getAuthenticationType()))\n+            : \"cross AuthenticationType comparison for canAccessResourcesOf is not applicable for: \"\n+                + EnumSet.of(getAuthenticationType(), other.getAuthenticationType());\n+        final AuthenticationContext myAuthContext = AuthenticationContext.fromAuthentication(this);\n+        final AuthenticationContext creatorAuthContext = AuthenticationContext.fromAuthentication(other);\n+        if (API_KEY.equals(myAuthContext.getEffectiveSubject().getType())\n+            && API_KEY.equals(creatorAuthContext.getEffectiveSubject().getType())) {\n+            final boolean sameKeyId = myAuthContext.getEffectiveSubject()\n+                .getMetadata()\n-            final boolean sameKeyId = getMetadata().get(AuthenticationField.API_KEY_ID_KEY)\n+                .get(AuthenticationField.API_KEY_ID_KEY)\n-                .equals(other.getMetadata().get(AuthenticationField.API_KEY_ID_KEY));\n+                .equals(creatorAuthContext.getEffectiveSubject().getMetadata().get(AuthenticationField.API_KEY_ID_KEY));\n-            if (sameKeyId) {\n-                assert getUser().principal().equals(getUser().principal())\n+            assert false == sameKeyId\n+                || myAuthContext.getEffectiveSubject()\n+                    .getUser()\n+                    .principal()\n+                    .equals(creatorAuthContext.getE",
  "diff_source": "custom"
}