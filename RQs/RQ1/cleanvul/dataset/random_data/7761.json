{
  "id": 7761,
  "language": "JavaScript",
  "commit_url": "https://github.com/commenthol/serialize-to-js/commit/181d7d583ae5293cd47cc99b14ad13352875f3e3",
  "commit_sha": "181d7d583ae5293cd47cc99b14ad13352875f3e3",
  "commit_msg": "fix: for ghsa-3fjq-93xj-3f3f",
  "pr_url": "https://github.com/commenthol/serialize-to-js/pull/14",
  "pr_info": "See https://github.com/commenthol/serialize-to-js/security/advisories/GHSA-3fjq-93xj-3f3f",
  "file_name": "lib/index.js",
  "func_name": "serialize",
  "func_before": "function serialize (source, opts) {\n  var out = ''\n  var key\n  var tmp\n  var type\n  var i\n\n  opts = opts || {}\n  if (!opts._visited) {\n    opts._visited = []\n  }\n  if (!opts._refs) {\n    opts.references = []\n    opts._refs = new Ref(opts.references)\n  }\n\n  if (util.isNull(source)) {\n    out += 'null'\n  } else if (util.isArray(source)) {\n    tmp = source.map(function (item) {\n      return serialize(item, opts)\n    })\n    out += '[' + tmp.join(', ') + ']'\n  } else if (util.isFunction(source)) {\n    tmp = source.toString()\n    // append function to es6 function within obj\n    out += !/^\\s*(function|\\([^)]*\\)\\s*=>)/m.test(tmp) ? 'function ' + tmp : tmp\n  } else if (util.isObject(source)) {\n    if (util.isRegExp(source)) {\n      out += source.toString()\n    } else if (util.isDate(source)) {\n      out += 'new Date(\"' + source.toJSON() + '\")'\n    } else if (util.isError(source)) {\n      out += 'new Error(' + (source.message ? '\"' + source.message + '\"' : '') + ')'\n    } else if (util.isBuffer(source)) {\n      // check for buffer first otherwise tests fail on node@4.4\n      // looks like buffers are accidentially detected as typed arrays\n      out += \"Buffer.from('\" + source.toString('base64') + \"', 'base64')\"\n    } else if ((type = util.isTypedArray(source))) {\n      tmp = []\n      for (i = 0; i < source.length; i++) {\n        tmp.push(source[i])\n      }\n      out += 'new ' + type + '(' +\n        '[' + tmp.join(', ') + ']' +\n        ')'\n    } else {\n      tmp = []\n      // copy properties if not circular\n      if (!~opts._visited.indexOf(source)) {\n        opts._visited.push(source)\n        for (key in source) {\n          if (source.hasOwnProperty(key)) {\n            if (opts.reference && util.isObject(source[key])) {\n              opts._refs.push(key)\n              if (!opts._refs.hasReference(source[key])) {\n                tmp.push(Ref.wrapkey(key) + ': ' + serialize(source[key], opts))\n              }\n              opts._refs.pop()\n            } else {\n              tmp.push(Ref.wrapkey(key) + ': ' + serialize(source[key], opts))\n            }\n          }\n        }\n        out += '{' + tmp.join(', ') + '}'\n        opts._visited.pop()\n      } else {\n        if (opts.ignoreCircular) {\n          out += '{/*[Circular]*/}'\n        } else {\n          throw new Error('can not convert circular structures.')\n        }\n      }\n    }\n  } else if (util.isString(source)) {\n    out += '\"' + (opts.unsafe ? util.unsafeString(source) : util.safeString(source)) + '\"'\n  } else {\n    out += '' + source\n  }\n  return out\n}",
  "func_after": "function serialize (source, opts) {\n  var out = ''\n  var key\n  var tmp\n  var type\n  var i\n\n  opts = opts || {}\n  if (!opts._visited) {\n    opts._visited = []\n  }\n  if (!opts._refs) {\n    opts.references = []\n    opts._refs = new Ref(opts.references)\n  }\n\n  if (util.isNull(source)) {\n    out += 'null'\n  } else if (util.isArray(source)) {\n    tmp = source.map(function (item) {\n      return serialize(item, opts)\n    })\n    out += '[' + tmp.join(', ') + ']'\n  } else if (util.isFunction(source)) {\n    tmp = source.toString()\n    // append function to es6 function within obj\n    out += !/^\\s*(function|\\([^)]*\\)\\s*=>)/m.test(tmp) ? 'function ' + tmp : tmp\n  } else if (util.isObject(source)) {\n    if (util.isRegExp(source)) {\n      out += 'new RegExp(\"' + source.source + '\", \"' + source.flags + '\")'\n    } else if (util.isDate(source)) {\n      out += 'new Date(\"' + source.toJSON() + '\")'\n    } else if (util.isError(source)) {\n      out += 'new Error(' + (source.message ? '\"' + source.message + '\"' : '') + ')'\n    } else if (util.isBuffer(source)) {\n      // check for buffer first otherwise tests fail on node@4.4\n      // looks like buffers are accidentially detected as typed arrays\n      out += \"Buffer.from('\" + source.toString('base64') + \"', 'base64')\"\n    } else if ((type = util.isTypedArray(source))) {\n      tmp = []\n      for (i = 0; i < source.length; i++) {\n        tmp.push(source[i])\n      }\n      out += 'new ' + type + '(' +\n        '[' + tmp.join(', ') + ']' +\n        ')'\n    } else {\n      tmp = []\n      // copy properties if not circular\n      if (!~opts._visited.indexOf(source)) {\n        opts._visited.push(source)\n        for (key in source) {\n          if (source.hasOwnProperty(key)) {\n            if (opts.reference && util.isObject(source[key])) {\n              opts._refs.push(key)\n              if (!opts._refs.hasReference(source[key])) {\n                tmp.push(Ref.wrapkey(key) + ': ' + serialize(source[key], opts))\n              }\n              opts._refs.pop()\n            } else {\n              tmp.push(Ref.wrapkey(key) + ': ' + serialize(source[key], opts))\n            }\n          }\n        }\n        out += '{' + tmp.join(', ') + '}'\n        opts._visited.pop()\n      } else {\n        if (opts.ignoreCircular) {\n          out += '{/*[Circular]*/}'\n        } else {\n          throw new Error('can not convert circular structures.')\n        }\n      }\n    }\n  } else if (util.isString(source)) {\n    out += '\"' + (opts.unsafe ? util.unsafeString(source) : util.safeString(source)) + '\"'\n  } else {\n    out += '' + source\n  }\n  return out\n}",
  "diff_func": "--- func_before\n+++ func_after\n function serialize (source, opts) {\n   var out = ''\n   var key\n   var tmp\n   var type\n   var i\n \n   opts = opts || {}\n   if (!opts._visited) {\n     opts._visited = []\n   }\n   if (!opts._refs) {\n     opts.references = []\n     opts._refs = new Ref(opts.references)\n   }\n \n   if (util.isNull(source)) {\n     out += 'null'\n   } else if (util.isArray(source)) {\n     tmp = source.map(function (item) {\n       return serialize(item, opts)\n     })\n     out += '[' + tmp.join(', ') + ']'\n   } else if (util.isFunction(source)) {\n     tmp = source.toString()\n     // append function to es6 function within obj\n     out += !/^\\s*(function|\\([^)]*\\)\\s*=>)/m.test(tmp) ? 'function ' + tmp : tmp\n   } else if (util.isObject(source)) {\n     if (util.isRegExp(source)) {\n-      out += source.toString()\n+      out += 'new RegExp(\"' + source.source + '\", \"' + source.flags + '\")'\n     } else if (util.isDate(source)) {\n       out += 'new Date(\"' + source.toJSON() + '\")'\n     } else if (util.isError(source)) {\n       out += 'new Error(' + (source.message ? '\"' + source.message + '\"' : '') + ')'\n     } else if (util.isBuffer(source)) {\n       // check for buffer first otherwise tests fail on node@4.4\n       // looks like buffers are accidentially detected as typed arrays\n       out += \"Buffer.from('\" + source.toString('base64') + \"', 'base64')\"\n     } else if ((type = util.isTypedArray(source))) {\n       tmp = []\n       for (i = 0; i < source.length; i++) {\n         tmp.push(source[i])\n       }\n       out += 'new ' + type + '(' +\n         '[' + tmp.join(', ') + ']' +\n         ')'\n     } else {\n       tmp = []\n       // copy properties if not circular\n       if (!~opts._visited.indexOf(source)) {\n         opts._visited.push(source)\n         for (key in source) {\n           if (source.hasOwnProperty(key)) {\n             if (opts.reference && util.isObject(source[key])) {\n               opts._refs.push(key)\n               if (!opts._refs.hasReference(source[key])) {\n  ",
  "diff_source": "custom"
}