{
  "id": 6679,
  "language": "Python",
  "commit_url": "https://github.com/mozilla/bleach/commit/c5df5789ec3471a31311f42c2d19fc2cf21b35ef",
  "commit_sha": "c5df5789ec3471a31311f42c2d19fc2cf21b35ef",
  "commit_msg": "Merge pull request #356 from willkg/fix-entities\n\nFix url sanitizing",
  "pr_url": "https://github.com/mozilla/bleach/pull/356",
  "pr_info": "This fixes an issue in uri sanitizing where character entities in the schema muck up the matching which allows disallowed schemes through.",
  "file_name": "bleach/sanitizer.py",
  "func_name": "allow_token",
  "func_before": "def allow_token(self, token):\n        \"\"\"Handles the case where we're allowing the tag\"\"\"\n        if 'data' in token:\n            # Loop through all the attributes and drop the ones that are not\n            # allowed, are unsafe or break other rules. Additionally, fix\n            # attribute values that need fixing.\n            #\n            # At the end of this loop, we have the final set of attributes\n            # we're keeping.\n            attrs = {}\n            for namespaced_name, val in token['data'].items():\n                namespace, name = namespaced_name\n\n                # Drop attributes that are not explicitly allowed\n                #\n                # NOTE(willkg): We pass in the attribute name--not a namespaced\n                # name.\n                if not self.attr_filter(token['name'], name, val):\n                    continue\n\n                # Look at attributes that have uri values\n                if namespaced_name in self.attr_val_is_uri:\n                    val_unescaped = re.sub(\n                        \"[`\\000-\\040\\177-\\240\\s]+\",\n                        '',\n                        unescape(val)).lower()\n\n                    # Remove replacement characters from unescaped characters.\n                    val_unescaped = val_unescaped.replace(\"\\ufffd\", \"\")\n\n                    # Drop attributes with uri values that have protocols that\n                    # aren't allowed\n                    if (re.match(r'^[a-z0-9][-+.a-z0-9]*:', val_unescaped) and\n                            (val_unescaped.split(':')[0] not in self.allowed_protocols)):\n                        continue\n\n                # Drop values in svg attrs with non-local IRIs\n                if namespaced_name in self.svg_attr_val_allows_ref:\n                    new_val = re.sub(r'url\\s*\\(\\s*[^#\\s][^)]+?\\)',\n                                     ' ',\n                                     unescape(val))\n                    new_val = new_val.strip()\n                    if not new_val:\n                        continue\n\n                    else:\n                        # Replace the val with the unescaped version because\n                        # it's a iri\n                        val = new_val\n\n                # Drop href and xlink:href attr for svg elements with non-local IRIs\n                if (None, token['name']) in self.svg_allow_local_href:\n                    if namespaced_name in [(None, 'href'), (namespaces['xlink'], 'href')]:\n                        if re.search(r'^\\s*[^#\\s]', val):\n                            continue\n\n                # If it's a style attribute, sanitize it\n                if namespaced_name == (None, u'style'):\n                    val = self.sanitize_css(val)\n\n                # At this point, we want to keep the attribute, so add it in\n                attrs[namespaced_name] = val\n\n            token['data'] = alphabetize_attributes(attrs)\n\n        return token",
  "func_after": "def allow_token(self, token):\n        \"\"\"Handles the case where we're allowing the tag\"\"\"\n        if 'data' in token:\n            # Loop through all the attributes and drop the ones that are not\n            # allowed, are unsafe or break other rules. Additionally, fix\n            # attribute values that need fixing.\n            #\n            # At the end of this loop, we have the final set of attributes\n            # we're keeping.\n            attrs = {}\n            for namespaced_name, val in token['data'].items():\n                namespace, name = namespaced_name\n\n                # Drop attributes that are not explicitly allowed\n                #\n                # NOTE(willkg): We pass in the attribute name--not a namespaced\n                # name.\n                if not self.attr_filter(token['name'], name, val):\n                    continue\n\n                # Drop attributes with uri values that use a disallowed protocol\n                # Sanitize attributes with uri values\n                if namespaced_name in self.attr_val_is_uri:\n                    new_value = self.sanitize_uri_value(val, self.allowed_protocols)\n                    if new_value is None:\n                        continue\n                    val = new_value\n\n                # Drop values in svg attrs with non-local IRIs\n                if namespaced_name in self.svg_attr_val_allows_ref:\n                    new_val = re.sub(r'url\\s*\\(\\s*[^#\\s][^)]+?\\)',\n                                     ' ',\n                                     unescape(val))\n                    new_val = new_val.strip()\n                    if not new_val:\n                        continue\n\n                    else:\n                        # Replace the val with the unescaped version because\n                        # it's a iri\n                        val = new_val\n\n                # Drop href and xlink:href attr for svg elements with non-local IRIs\n                if (None, token['name']) in self.svg_allow_local_href:\n                    if namespaced_name in [(None, 'href'), (namespaces['xlink'], 'href')]:\n                        if re.search(r'^\\s*[^#\\s]', val):\n                            continue\n\n                # If it's a style attribute, sanitize it\n                if namespaced_name == (None, u'style'):\n                    val = self.sanitize_css(val)\n\n                # At this point, we want to keep the attribute, so add it in\n                attrs[namespaced_name] = val\n\n            token['data'] = alphabetize_attributes(attrs)\n\n        return token",
  "diff_func": "--- func_before\n+++ func_after\n def allow_token(self, token):\n         \"\"\"Handles the case where we're allowing the tag\"\"\"\n         if 'data' in token:\n             # Loop through all the attributes and drop the ones that are not\n             # allowed, are unsafe or break other rules. Additionally, fix\n             # attribute values that need fixing.\n             #\n             # At the end of this loop, we have the final set of attributes\n             # we're keeping.\n             attrs = {}\n             for namespaced_name, val in token['data'].items():\n                 namespace, name = namespaced_name\n \n                 # Drop attributes that are not explicitly allowed\n                 #\n                 # NOTE(willkg): We pass in the attribute name--not a namespaced\n                 # name.\n                 if not self.attr_filter(token['name'], name, val):\n                     continue\n \n+                # Drop attributes with uri values that use a disallowed protocol\n-                # Look at attributes that have uri values\n+                # Sanitize attributes with uri values\n                 if namespaced_name in self.attr_val_is_uri:\n+                    new_value = self.sanitize_uri_value(val, self.allowed_protocols)\n+                    if new_value is None:\n-                    val_unescaped = re.sub(\n-                        \"[`\\000-\\040\\177-\\240\\s]+\",\n-                        '',\n-                        unescape(val)).lower()\n-\n-                    # Remove replacement characters from unescaped characters.\n-                    val_unescaped = val_unescaped.replace(\"\\ufffd\", \"\")\n-\n-                    # Drop attributes with uri values that have protocols that\n-                    # aren't allowed\n-                    if (re.match(r'^[a-z0-9][-+.a-z0-9]*:', val_unescaped) and\n-                            (val_unescaped.split(':')[0] not in self.allowed_protocols)):\n                         continue\n+                    val = new_value\n \n           ",
  "diff_source": "custom"
}