{
  "id": 3231,
  "language": "C/C++",
  "commit_url": "https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94",
  "commit_sha": "a4866aa812518ed1a37d8ea0c881dc946409de94",
  "commit_msg": "mm: Tighten x86 /dev/mem with zeroing reads\n\nUnder CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is\ndisallowed. However, on x86, the first 1MB was always allowed for BIOS\nand similar things, regardless of it actually being System RAM. It was\npossible for heap to end up getting allocated in low 1MB RAM, and then\nread by things like x86info or dd, which would trip hardened usercopy:\n\nusercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)\n\nThis changes the x86 exception for the low 1MB by reading back zeros for\nSystem RAM areas instead of blindly allowing them. More work is needed to\nextend this to mmap, but currently mmap doesn't go through usercopy, so\nhardened usercopy won't Oops the kernel.\n\nReported-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nTested-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "drivers/char/mem.c",
  "func_name": "read_mem",
  "func_before": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn 0;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n\t\t * it must also be accessed uncached by the kernel or data\n\t\t * corruption may occur.\n\t\t */\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\n\t*ppos += read;\n\treturn read;\n}",
  "func_after": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn 0;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\t\tint allowed;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n\t\tif (!allowed)\n\t\t\treturn -EPERM;\n\t\tif (allowed == 2) {\n\t\t\t/* Show zeros for restricted memory. */\n\t\t\tremaining = clear_user(buf, sz);\n\t\t} else {\n\t\t\t/*\n\t\t\t * On ia64 if a page has been mapped somewhere as\n\t\t\t * uncached, then it must also be accessed uncached\n\t\t\t * by the kernel or data corruption may occur.\n\t\t\t */\n\t\t\tptr = xlate_dev_mem_ptr(p);\n\t\t\tif (!ptr)\n\t\t\t\treturn -EFAULT;\n\n\t\t\tremaining = copy_to_user(buf, ptr, sz);\n\n\t\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\t}\n\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\n\t*ppos += read;\n\treturn read;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static ssize_t read_mem(struct file *file, char __user *buf,\n \t\t\tsize_t count, loff_t *ppos)\n {\n \tphys_addr_t p = *ppos;\n \tssize_t read, sz;\n \tvoid *ptr;\n \n \tif (p != *ppos)\n \t\treturn 0;\n \n \tif (!valid_phys_addr_range(p, count))\n \t\treturn -EFAULT;\n \tread = 0;\n #ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n \t/* we don't have page 0 mapped on sparc and m68k.. */\n \tif (p < PAGE_SIZE) {\n \t\tsz = size_inside_page(p, count);\n \t\tif (sz > 0) {\n \t\t\tif (clear_user(buf, sz))\n \t\t\t\treturn -EFAULT;\n \t\t\tbuf += sz;\n \t\t\tp += sz;\n \t\t\tcount -= sz;\n \t\t\tread += sz;\n \t\t}\n \t}\n #endif\n \n \twhile (count > 0) {\n \t\tunsigned long remaining;\n+\t\tint allowed;\n \n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n+\t\tif (allowed == 2) {\n+\t\t\t/* Show zeros for restricted memory. */\n+\t\t\tremaining = clear_user(buf, sz);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr)\n+\t\t\t\treturn -EFAULT;\n \n+\t\t\tremaining = copy_to_user(buf, ptr, sz);\n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr)\n-\t\t\treturn -EFAULT;\n \n-\t\tremaining = copy_to_user(buf, ptr, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t}\n+\n \t\tif (remaining)\n \t\t\treturn -EFAULT;\n \n \t\tbuf += sz;\n \t\tp += sz;\n \t\tcount -= sz;\n \t\tread += sz;\n \t}\n \n \t*ppos += read;\n \treturn read;\n }",
  "diff_source": "custom"
}