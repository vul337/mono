{
  "id": 55,
  "language": "Java",
  "commit_url": "https://github.com/confluentinc/schema-registry/commit/952cc7d3667b59523dfa8983de449275882676f4",
  "commit_sha": "952cc7d3667b59523dfa8983de449275882676f4",
  "commit_msg": "DGS-3974 Fix StackOverflow with recursive JSON schema in converter (#2318)\n\n* DGS-3974 Fix StackOverflow with recursive JSON schema in converter\r\n\r\n* Fix fromConnectSchema",
  "pr_url": "https://github.com/confluentinc/schema-registry/pull/2318",
  "pr_info": "no more info",
  "file_name": "json-schema-converter/src/main/java/io/confluent/connect/json/JsonSchemaData.java",
  "func_name": "rawSchemaFromConnectSchema",
  "func_before": "private org.everit.json.schema.Schema rawSchemaFromConnectSchema(\n      FromConnectContext ctx, Schema schema, Integer index, boolean ignoreOptional\n  ) {\n    if (schema == null) {\n      return null;\n    }\n\n    String id = null;\n    if (schema.parameters() != null && schema.parameters().containsKey(JSON_ID_PROP)) {\n      id = schema.parameters().get(JSON_ID_PROP);\n      ctx.add(id);\n    }\n\n    org.everit.json.schema.Schema.Builder builder;\n    Map<String, Object> unprocessedProps = new HashMap<>();\n    switch (schema.type()) {\n      case INT8:\n        builder = NumberSchema.builder().requiresInteger(true);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_INT8);\n        break;\n      case INT16:\n        builder = NumberSchema.builder().requiresInteger(true);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_INT16);\n        break;\n      case INT32:\n        builder = NumberSchema.builder().requiresInteger(true);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_INT32);\n        break;\n      case INT64:\n        builder = NumberSchema.builder().requiresInteger(true);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_INT64);\n        break;\n      case FLOAT32:\n        builder = NumberSchema.builder().requiresInteger(false);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_FLOAT32);\n        break;\n      case FLOAT64:\n        builder = NumberSchema.builder().requiresInteger(false);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_FLOAT64);\n        break;\n      case BOOLEAN:\n        builder = BooleanSchema.builder();\n        break;\n      case STRING:\n        if (schema.parameters() != null && schema.parameters().containsKey(JSON_TYPE_ENUM)) {\n          EnumSchema.Builder enumBuilder = EnumSchema.builder();\n          for (Map.Entry<String, String> entry : schema.parameters().entrySet()) {\n            if (entry.getKey().startsWith(JSON_TYPE_ENUM_PREFIX)) {\n              enumBuilder.possibleValue(entry.getValue());\n            }\n          }\n          builder = enumBuilder;\n        } else {\n          builder = StringSchema.builder();\n        }\n        break;\n      case BYTES:\n        builder = Decimal.LOGICAL_NAME.equals(schema.name())\n                  ? NumberSchema.builder()\n                  : StringSchema.builder();\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_BYTES);\n        break;\n      case ARRAY:\n        builder = ArraySchema.builder().allItemSchema(\n            rawSchemaFromConnectSchema(ctx, schema.valueSchema()));\n        break;\n      case MAP:\n        // JSON Schema only supports string keys\n        if (schema.keySchema().type() == Schema.Type.STRING && !schema.keySchema().isOptional()) {\n          org.everit.json.schema.Schema valueSchema =\n              rawSchemaFromConnectSchema(ctx, schema.valueSchema());\n          builder = ObjectSchema.builder().schemaOfAdditionalProperties(valueSchema);\n          unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_MAP);\n        } else {\n          ObjectSchema.Builder entryBuilder = ObjectSchema.builder();\n          org.everit.json.schema.Schema keySchema =\n              rawSchemaFromConnectSchema(ctx, schema.keySchema(), 0);\n          org.everit.json.schema.Schema valueSchema =\n              rawSchemaFromConnectSchema(ctx, schema.valueSchema(), 1);\n          entryBuilder.addPropertySchema(KEY_FIELD, keySchema);\n          entryBuilder.addPropertySchema(VALUE_FIELD, valueSchema);\n          builder = ArraySchema.builder().allItemSchema(entryBuilder.build());\n          unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_MAP);\n        }\n        break;\n      case STRUCT:\n        if (JSON_TYPE_ONE_OF.equals(schema.name())) {\n          CombinedSchema.Builder combinedBuilder = CombinedSchema.builder();\n          combinedBuilder.criterion(CombinedSchema.ONE_CRITERION);\n          if (schema.isOptional()) {\n            combinedBuilder.subschema(NullSchema.INSTANCE);\n          }\n          for (Field field : schema.fields()) {\n            combinedBuilder.subschema(rawSchemaFromConnectSchema(ctx, nonOptional(field.schema()),\n                field.index(),\n                true\n            ));\n          }\n          builder = combinedBuilder;\n        } else if (schema.isOptional()) {\n          CombinedSchema.Builder combinedBuilder = CombinedSchema.builder();\n          combinedBuilder.criterion(CombinedSchema.ONE_CRITERION);\n          combinedBuilder.subschema(NullSchema.INSTANCE);\n          combinedBuilder.subschema(rawSchemaFromConnectSchema(ctx, nonOptional(schema)));\n          builder = combinedBuilder;\n        } else {\n          ObjectSchema.Builder objectBuilder = ObjectSchema.builder();\n          for (Field field : schema.fields()) {\n            Schema fieldSchema = field.schema();\n            String refId = null;\n            if (fieldSchema.parameters() != null\n                && fieldSchema.parameters().containsKey(JSON_ID_PROP)) {\n              refId = fieldSchema.parameters().get(JSON_ID_PROP);\n            }\n            org.everit.json.schema.Schema jsonSchema;\n            if (ctx.contains(refId)) {\n              jsonSchema = ReferenceSchema.builder().refValue(refId).build();\n            } else {\n              jsonSchema = rawSchemaFromConnectSchema(ctx, fieldSchema, field.index());\n            }\n            objectBuilder.addPropertySchema(field.name(), jsonSchema);\n          }\n          if (!config.allowAdditionalProperties()) {\n            objectBuilder.additionalProperties(false);\n          }\n          builder = objectBuilder;\n        }\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unsupported type \" + schema.type());\n    }\n\n    if (!(builder instanceof CombinedSchema.Builder)) {\n      if (schema.name() != null) {\n        builder.title(schema.name());\n      }\n      if (schema.version() != null) {\n        unprocessedProps.put(CONNECT_VERSION_PROP, schema.version());\n      }\n      if (schema.doc() != null) {\n        builder.description(schema.doc());\n      }\n      if (schema.parameters() != null) {\n        Map<String, String> parameters = schema.parameters()\n            .entrySet()\n            .stream()\n            .filter(e -> !e.getKey().startsWith(NAMESPACE))\n            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n        if (parameters.size() > 0) {\n          unprocessedProps.put(CONNECT_PARAMETERS_PROP, parameters);\n        }\n      }\n      if (schema.defaultValue() != null) {\n        builder.defaultValue(fromConnectData(schema, schema.defaultValue()));\n      }\n\n      if (!ignoreOptional) {\n        if (schema.isOptional()) {\n          CombinedSchema.Builder combinedBuilder = CombinedSchema.builder();\n          combinedBuilder.criterion(CombinedSchema.ONE_CRITERION);\n          combinedBuilder.subschema(NullSchema.INSTANCE);\n          combinedBuilder.subschema(builder.unprocessedProperties(unprocessedProps).build());\n          if (index != null) {\n            combinedBuilder.unprocessedProperties(Collections.singletonMap(CONNECT_INDEX_PROP,\n                index\n            ));\n          }\n          builder = combinedBuilder;\n          unprocessedProps = new HashMap<>();\n        }\n      }\n    }\n    if (id != null) {\n      builder.id(id);\n    }\n    if (index != null) {\n      unprocessedProps.put(CONNECT_INDEX_PROP, index);\n    }\n    return builder.unprocessedProperties(unprocessedProps).build();\n  }",
  "func_after": "private org.everit.json.schema.Schema rawSchemaFromConnectSchema(\n      FromConnectContext ctx, Schema schema, Integer index, boolean ignoreOptional\n  ) {\n    if (schema == null) {\n      return null;\n    }\n\n    String id = null;\n    if (schema.parameters() != null && schema.parameters().containsKey(JSON_ID_PROP)) {\n      id = schema.parameters().get(JSON_ID_PROP);\n      ctx.add(id);\n    }\n\n    org.everit.json.schema.Schema.Builder builder;\n    Map<String, Object> unprocessedProps = new HashMap<>();\n    switch (schema.type()) {\n      case INT8:\n        builder = NumberSchema.builder().requiresInteger(true);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_INT8);\n        break;\n      case INT16:\n        builder = NumberSchema.builder().requiresInteger(true);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_INT16);\n        break;\n      case INT32:\n        builder = NumberSchema.builder().requiresInteger(true);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_INT32);\n        break;\n      case INT64:\n        builder = NumberSchema.builder().requiresInteger(true);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_INT64);\n        break;\n      case FLOAT32:\n        builder = NumberSchema.builder().requiresInteger(false);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_FLOAT32);\n        break;\n      case FLOAT64:\n        builder = NumberSchema.builder().requiresInteger(false);\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_FLOAT64);\n        break;\n      case BOOLEAN:\n        builder = BooleanSchema.builder();\n        break;\n      case STRING:\n        if (schema.parameters() != null && schema.parameters().containsKey(JSON_TYPE_ENUM)) {\n          EnumSchema.Builder enumBuilder = EnumSchema.builder();\n          for (Map.Entry<String, String> entry : schema.parameters().entrySet()) {\n            if (entry.getKey().startsWith(JSON_TYPE_ENUM_PREFIX)) {\n              enumBuilder.possibleValue(entry.getValue());\n            }\n          }\n          builder = enumBuilder;\n        } else {\n          builder = StringSchema.builder();\n        }\n        break;\n      case BYTES:\n        builder = Decimal.LOGICAL_NAME.equals(schema.name())\n                  ? NumberSchema.builder()\n                  : StringSchema.builder();\n        unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_BYTES);\n        break;\n      case ARRAY:\n        Schema arrayValueSchema = schema.valueSchema();\n        String refId = null;\n        if (arrayValueSchema.parameters() != null\n            && arrayValueSchema.parameters().containsKey(JSON_ID_PROP)) {\n          refId = arrayValueSchema.parameters().get(JSON_ID_PROP);\n        }\n        org.everit.json.schema.Schema itemsSchema;\n        if (ctx.contains(refId)) {\n          itemsSchema = ReferenceSchema.builder().refValue(refId).build();\n        } else {\n          itemsSchema = rawSchemaFromConnectSchema(ctx, arrayValueSchema);\n        }\n        builder = ArraySchema.builder().allItemSchema(itemsSchema);\n        break;\n      case MAP:\n        // JSON Schema only supports string keys\n        if (schema.keySchema().type() == Schema.Type.STRING && !schema.keySchema().isOptional()) {\n          org.everit.json.schema.Schema valueSchema =\n              rawSchemaFromConnectSchema(ctx, schema.valueSchema());\n          builder = ObjectSchema.builder().schemaOfAdditionalProperties(valueSchema);\n          unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_MAP);\n        } else {\n          ObjectSchema.Builder entryBuilder = ObjectSchema.builder();\n          org.everit.json.schema.Schema keySchema =\n              rawSchemaFromConnectSchema(ctx, schema.keySchema(), 0);\n          org.everit.json.schema.Schema valueSchema =\n              rawSchemaFromConnectSchema(ctx, schema.valueSchema(), 1);\n          entryBuilder.addPropertySchema(KEY_FIELD, keySchema);\n          entryBuilder.addPropertySchema(VALUE_FIELD, valueSchema);\n          builder = ArraySchema.builder().allItemSchema(entryBuilder.build());\n          unprocessedProps.put(CONNECT_TYPE_PROP, CONNECT_TYPE_MAP);\n        }\n        break;\n      case STRUCT:\n        if (JSON_TYPE_ONE_OF.equals(schema.name())) {\n          CombinedSchema.Builder combinedBuilder = CombinedSchema.builder();\n          combinedBuilder.criterion(CombinedSchema.ONE_CRITERION);\n          if (schema.isOptional()) {\n            combinedBuilder.subschema(NullSchema.INSTANCE);\n          }\n          for (Field field : schema.fields()) {\n            combinedBuilder.subschema(rawSchemaFromConnectSchema(ctx, nonOptional(field.schema()),\n                field.index(),\n                true\n            ));\n          }\n          builder = combinedBuilder;\n        } else if (schema.isOptional()) {\n          CombinedSchema.Builder combinedBuilder = CombinedSchema.builder();\n          combinedBuilder.criterion(CombinedSchema.ONE_CRITERION);\n          combinedBuilder.subschema(NullSchema.INSTANCE);\n          combinedBuilder.subschema(rawSchemaFromConnectSchema(ctx, nonOptional(schema)));\n          builder = combinedBuilder;\n        } else {\n          ObjectSchema.Builder objectBuilder = ObjectSchema.builder();\n          for (Field field : schema.fields()) {\n            Schema fieldSchema = field.schema();\n            String fieldRefId = null;\n            if (fieldSchema.parameters() != null\n                && fieldSchema.parameters().containsKey(JSON_ID_PROP)) {\n              fieldRefId = fieldSchema.parameters().get(JSON_ID_PROP);\n            }\n            org.everit.json.schema.Schema jsonSchema;\n            if (ctx.contains(fieldRefId)) {\n              jsonSchema = ReferenceSchema.builder().refValue(fieldRefId).build();\n            } else {\n              jsonSchema = rawSchemaFromConnectSchema(ctx, fieldSchema, field.index());\n            }\n            objectBuilder.addPropertySchema(field.name(), jsonSchema);\n          }\n          if (!config.allowAdditionalProperties()) {\n            objectBuilder.additionalProperties(false);\n          }\n          builder = objectBuilder;\n        }\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unsupported type \" + schema.type());\n    }\n\n    if (!(builder instanceof CombinedSchema.Builder)) {\n      if (schema.name() != null) {\n        builder.title(schema.name());\n      }\n      if (schema.version() != null) {\n        unprocessedProps.put(CONNECT_VERSION_PROP, schema.version());\n      }\n      if (schema.doc() != null) {\n        builder.description(schema.doc());\n      }\n      if (schema.parameters() != null) {\n        Map<String, String> parameters = schema.parameters()\n            .entrySet()\n            .stream()\n            .filter(e -> !e.getKey().startsWith(NAMESPACE))\n            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n        if (parameters.size() > 0) {\n          unprocessedProps.put(CONNECT_PARAMETERS_PROP, parameters);\n        }\n      }\n      if (schema.defaultValue() != null) {\n        builder.defaultValue(fromConnectData(schema, schema.defaultValue()));\n      }\n\n      if (!ignoreOptional) {\n        if (schema.isOptional()) {\n          CombinedSchema.Builder combinedBuilder = CombinedSchema.builder();\n          combinedBuilder.criterion(CombinedSchema.ONE_CRITERION);\n          combinedBuilder.subschema(NullSchema.INSTANCE);\n          combinedBuilder.subschema(builder.unprocessedProperties(unprocessedProps).build());\n          if (index != null) {\n            combinedBuilder.unprocessedProperties(Collections.singletonMap(CONNECT_INDEX_PROP,\n                index\n            ));\n          }\n          builder = combinedBuilder;\n          unprocessedProps = new HashMap<>();\n        }\n      }\n    }\n    if (id != null) {\n      builder.id(id);\n    }\n    if (index != null) {\n      unprocessedProps.put(CONNECT_INDEX_PROP, index);\n    }\n    return builder.unprocessedProperties(unprocessedProps).build();\n  }",
  "diff_func": "--- func_before\n+++ func_after\n@@ -692 +692 @@\n-            rawSchemaFromConnectSchema(ctx, schema.valueSchema()));\n+        Schema arrayValueSchema = schema.valueSchema();\n+        String refId = null;\n+        if (arrayValueSchema.parameters() != null\n+            && arrayValueSchema.parameters().containsKey(JSON_ID_PROP)) {\n+          refId = arrayValueSchema.parameters().get(JSON_ID_PROP);\n+        }",
  "diff_source": "api"
}