{
  "id": 1791,
  "language": "Java",
  "commit_url": "https://github.com/AOSPA/android_frameworks_base/commit/a4131c50d07c7b58c496bd82b9ab3389b6721654",
  "commit_sha": "a4131c50d07c7b58c496bd82b9ab3389b6721654",
  "commit_msg": "Secure REMOTE_BUGREPORT_DISPATCH\n\nIn remote bugreport collection, Shell sends REMOTE_BUGREPORT_DISPATCH to\nDevicePolicyManagerService which in turn notifies Device Owners that a\nbug report is ready for collection. There existed a threat where a\nmalicous user could spoof the REMOTE_BUGREPORT_DISPATCH broadcast via\nADB to send a crafted bugreport to the Device Owner. Securing\nREMOTE_BUGREPORT_DISPATCH is not as easy as it appears: putting a\npermission on REMOTE_BUGREPORT_DISPATCH does not work since both the\nlegitimate sender and the malicious user are UID_SHELL. Instead, we\nintroduces a nonce which was sent from DPMS to Shell when bugreport is\ntriggered, and DPM will only accept REMOTE_BUGREPORT_DISPATCH when\na matching nonce is seen.\n\nIgnore-AOSP-First: security fix\n\nBug: 171495100\nTest: atest DeviceOwnerTest#testRemoteBugreportWithTwoUsers\nTest: atest DeviceOwnerTest#testAdminActionBookkeeping\nTest: atest BugreportManagerTest\nChange-Id: I7649b4f22b74647d152d76bb46d5ca70bfa3617d",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/RemoteBugreportManager.java",
  "func_name": "requestBugreport",
  "func_before": "public boolean requestBugreport() {\n        if (mRemoteBugreportServiceIsActive.get()\n                || (mService.getDeviceOwnerRemoteBugreportUriAndHash() != null)) {\n            Slogf.d(LOG_TAG, \"Remote bugreport wasn't started because there's already one running\");\n            return false;\n        }\n\n        final long callingIdentity = mInjector.binderClearCallingIdentity();\n        try {\n            mInjector.getIActivityManager().requestRemoteBugReport();\n\n            mRemoteBugreportServiceIsActive.set(true);\n            mRemoteBugreportSharingAccepted.set(false);\n            registerRemoteBugreportReceivers();\n            mInjector.getNotificationManager().notifyAsUser(LOG_TAG, NOTIFICATION_ID,\n                    buildNotification(NOTIFICATION_BUGREPORT_STARTED), UserHandle.ALL);\n            mHandler.postDelayed(mRemoteBugreportTimeoutRunnable, REMOTE_BUGREPORT_TIMEOUT_MILLIS);\n            return true;\n        } catch (RemoteException re) {\n            // should never happen\n            Slogf.e(LOG_TAG, \"Failed to make remote calls to start bugreportremote service\", re);\n            return false;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(callingIdentity);\n        }\n    }",
  "func_after": "public boolean requestBugreport() {\n        if (mRemoteBugreportServiceIsActive.get()\n                || (mService.getDeviceOwnerRemoteBugreportUriAndHash() != null)) {\n            Slogf.d(LOG_TAG, \"Remote bugreport wasn't started because there's already one running\");\n            return false;\n        }\n\n        final long callingIdentity = mInjector.binderClearCallingIdentity();\n        try {\n            long nonce;\n            do {\n                nonce = mRng.nextLong();\n            } while (nonce == 0);\n            mInjector.getIActivityManager().requestRemoteBugReport(nonce);\n\n            mRemoteBugreportNonce.set(nonce);\n            mRemoteBugreportServiceIsActive.set(true);\n            mRemoteBugreportSharingAccepted.set(false);\n            registerRemoteBugreportReceivers();\n            mInjector.getNotificationManager().notifyAsUser(LOG_TAG, NOTIFICATION_ID,\n                    buildNotification(NOTIFICATION_BUGREPORT_STARTED), UserHandle.ALL);\n            mHandler.postDelayed(mRemoteBugreportTimeoutRunnable, REMOTE_BUGREPORT_TIMEOUT_MILLIS);\n            return true;\n        } catch (RemoteException re) {\n            // should never happen\n            Slogf.e(LOG_TAG, \"Failed to make remote calls to start bugreportremote service\", re);\n            return false;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(callingIdentity);\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n public boolean requestBugreport() {\n         if (mRemoteBugreportServiceIsActive.get()\n                 || (mService.getDeviceOwnerRemoteBugreportUriAndHash() != null)) {\n             Slogf.d(LOG_TAG, \"Remote bugreport wasn't started because there's already one running\");\n             return false;\n         }\n \n         final long callingIdentity = mInjector.binderClearCallingIdentity();\n         try {\n+            long nonce;\n+            do {\n+                nonce = mRng.nextLong();\n+            } while (nonce == 0);\n-            mInjector.getIActivityManager().requestRemoteBugReport();\n+            mInjector.getIActivityManager().requestRemoteBugReport(nonce);\n \n+            mRemoteBugreportNonce.set(nonce);\n             mRemoteBugreportServiceIsActive.set(true);\n             mRemoteBugreportSharingAccepted.set(false);\n             registerRemoteBugreportReceivers();\n             mInjector.getNotificationManager().notifyAsUser(LOG_TAG, NOTIFICATION_ID,\n                     buildNotification(NOTIFICATION_BUGREPORT_STARTED), UserHandle.ALL);\n             mHandler.postDelayed(mRemoteBugreportTimeoutRunnable, REMOTE_BUGREPORT_TIMEOUT_MILLIS);\n             return true;\n         } catch (RemoteException re) {\n             // should never happen\n             Slogf.e(LOG_TAG, \"Failed to make remote calls to start bugreportremote service\", re);\n             return false;\n         } finally {\n             mInjector.binderRestoreCallingIdentity(callingIdentity);\n         }\n     }",
  "diff_source": "custom"
}