{
  "id": 6199,
  "language": "Python",
  "commit_url": "https://github.com/vyperlang/vyper/commit/4f8289a81206f767df1900ac48f485d90fc87edb",
  "commit_sha": "4f8289a81206f767df1900ac48f485d90fc87edb",
  "commit_msg": "Merge pull request from GHSA-3p37-3636-q8wv\n\nin dynarray_make_setter, the length is copied before the data. when the\ndst and src arrays do not overlap, this is not a problem. however, when\nthe dst and src are the same dynarray, this can lead to a\nstore-before-load, leading any array bounds checks on the right hand\nside to function incorrectly. here is an example:\n\n```vyper\n@external\ndef should_revert() -> DynArray[uint256,3]:\n    a: DynArray[uint256, 3] = [1, 2, 3]\n    a = empty(DynArray[uint256, 3])\n    a = [self.a[0], self.a[1], self.a[2]]\n    return a  # if bug: returns [1,2,3]\n```\n\nthis commit moves the length store to after the data copy in\ndynarray_make_setter. for hygiene, it also moves the length store to\nafter the data copy in several other routines. I left pop_dyn_array()\nunchanged, because moving the routine does not actually perform any data\ncopy, it just writes the new length (and optionally returns a pointer to\nthe popped item).",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "vyper/codegen/core.py",
  "func_name": "_dynarray_make_setter",
  "func_before": "def _dynarray_make_setter(dst, src):\n    assert isinstance(src.typ, DArrayT)\n    assert isinstance(dst.typ, DArrayT)\n\n    if src.value == \"~empty\":\n        return IRnode.from_list(STORE(dst, 0))\n\n    if src.value == \"multi\":\n        ret = [\"seq\"]\n        # handle literals\n\n        # write the length word\n        store_length = STORE(dst, len(src.args))\n        ann = None\n        if src.annotation is not None:\n            ann = f\"len({src.annotation})\"\n        store_length = IRnode.from_list(store_length, annotation=ann)\n        ret.append(store_length)\n\n        n_items = len(src.args)\n        for i in range(n_items):\n            k = IRnode.from_list(i, typ=UINT256_T)\n            dst_i = get_element_ptr(dst, k, array_bounds_check=False)\n            src_i = get_element_ptr(src, k, array_bounds_check=False)\n            ret.append(make_setter(dst_i, src_i))\n\n        return ret\n\n    with src.cache_when_complex(\"darray_src\") as (b1, src):\n        # for ABI-encoded dynamic data, we must loop to unpack, since\n        # the layout does not match our memory layout\n        should_loop = src.encoding == Encoding.ABI and src.typ.value_type.abi_type.is_dynamic()\n\n        # if the data is not validated, we must loop to unpack\n        should_loop |= needs_clamp(src.typ.value_type, src.encoding)\n\n        # performance: if the subtype is dynamic, there might be a lot\n        # of unused space inside of each element. for instance\n        # DynArray[DynArray[uint256, 100], 5] where all the child\n        # arrays are empty - for this case, we recursively call\n        # into make_setter instead of straight bytes copy\n        # TODO we can make this heuristic more precise, e.g.\n        # loop when subtype.is_dynamic AND location == storage\n        # OR array_size <= /bound where loop is cheaper than memcpy/\n        should_loop |= src.typ.value_type.abi_type.is_dynamic()\n\n        with get_dyn_array_count(src).cache_when_complex(\"darray_count\") as (b2, count):\n            ret = [\"seq\"]\n\n            ret.append(STORE(dst, count))\n\n            if should_loop:\n                i = IRnode.from_list(_freshname(\"copy_darray_ix\"), typ=UINT256_T)\n\n                loop_body = make_setter(\n                    get_element_ptr(dst, i, array_bounds_check=False),\n                    get_element_ptr(src, i, array_bounds_check=False),\n                )\n                loop_body.annotation = f\"{dst}[i] = {src}[i]\"\n\n                ret.append([\"repeat\", i, 0, count, src.typ.count, loop_body])\n\n            else:\n                element_size = src.typ.value_type.memory_bytes_required\n                # number of elements * size of element in bytes\n                n_bytes = _mul(count, element_size)\n                max_bytes = src.typ.count * element_size\n\n                src_ = dynarray_data_ptr(src)\n                dst_ = dynarray_data_ptr(dst)\n                ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))\n\n            return b1.resolve(b2.resolve(ret))",
  "func_after": "def _dynarray_make_setter(dst, src):\n    assert isinstance(src.typ, DArrayT)\n    assert isinstance(dst.typ, DArrayT)\n\n    if src.value == \"~empty\":\n        return IRnode.from_list(STORE(dst, 0))\n\n    # copy contents of src dynarray to dst.\n    # note that in case src and dst refer to the same dynarray,\n    # in order for get_element_ptr oob checks on the src dynarray\n    # to work, we need to wait until after the data is copied\n    # before we clobber the length word.\n\n    if src.value == \"multi\":\n        ret = [\"seq\"]\n        # handle literals\n\n        # copy each item\n        n_items = len(src.args)\n\n        for i in range(n_items):\n            k = IRnode.from_list(i, typ=UINT256_T)\n            dst_i = get_element_ptr(dst, k, array_bounds_check=False)\n            src_i = get_element_ptr(src, k, array_bounds_check=False)\n            ret.append(make_setter(dst_i, src_i))\n\n        # write the length word after data is copied\n        store_length = STORE(dst, n_items)\n        ann = None\n        if src.annotation is not None:\n            ann = f\"len({src.annotation})\"\n        store_length = IRnode.from_list(store_length, annotation=ann)\n\n        ret.append(store_length)\n\n        return ret\n\n    with src.cache_when_complex(\"darray_src\") as (b1, src):\n        # for ABI-encoded dynamic data, we must loop to unpack, since\n        # the layout does not match our memory layout\n        should_loop = src.encoding == Encoding.ABI and src.typ.value_type.abi_type.is_dynamic()\n\n        # if the data is not validated, we must loop to unpack\n        should_loop |= needs_clamp(src.typ.value_type, src.encoding)\n\n        # performance: if the subtype is dynamic, there might be a lot\n        # of unused space inside of each element. for instance\n        # DynArray[DynArray[uint256, 100], 5] where all the child\n        # arrays are empty - for this case, we recursively call\n        # into make_setter instead of straight bytes copy\n        # TODO we can make this heuristic more precise, e.g.\n        # loop when subtype.is_dynamic AND location == storage\n        # OR array_size <= /bound where loop is cheaper than memcpy/\n        should_loop |= src.typ.value_type.abi_type.is_dynamic()\n\n        with get_dyn_array_count(src).cache_when_complex(\"darray_count\") as (b2, count):\n            ret = [\"seq\"]\n\n            if should_loop:\n                i = IRnode.from_list(_freshname(\"copy_darray_ix\"), typ=UINT256_T)\n\n                loop_body = make_setter(\n                    get_element_ptr(dst, i, array_bounds_check=False),\n                    get_element_ptr(src, i, array_bounds_check=False),\n                )\n                loop_body.annotation = f\"{dst}[i] = {src}[i]\"\n\n                ret.append([\"repeat\", i, 0, count, src.typ.count, loop_body])\n\n            else:\n                element_size = src.typ.value_type.memory_bytes_required\n                # number of elements * size of element in bytes\n                n_bytes = _mul(count, element_size)\n                max_bytes = src.typ.count * element_size\n\n                src_ = dynarray_data_ptr(src)\n                dst_ = dynarray_data_ptr(dst)\n                ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))\n\n            # write the length word after data is copied\n            ret.append(STORE(dst, count))\n\n            return b1.resolve(b2.resolve(ret))",
  "diff_func": "--- func_before\n+++ func_after\n def _dynarray_make_setter(dst, src):\n     assert isinstance(src.typ, DArrayT)\n     assert isinstance(dst.typ, DArrayT)\n \n     if src.value == \"~empty\":\n         return IRnode.from_list(STORE(dst, 0))\n \n+    # copy contents of src dynarray to dst.\n+    # note that in case src and dst refer to the same dynarray,\n+    # in order for get_element_ptr oob checks on the src dynarray\n+    # to work, we need to wait until after the data is copied\n+    # before we clobber the length word.\n+\n     if src.value == \"multi\":\n         ret = [\"seq\"]\n         # handle literals\n \n+        # copy each item\n+        n_items = len(src.args)\n-        # write the length word\n-        store_length = STORE(dst, len(src.args))\n-        ann = None\n-        if src.annotation is not None:\n-            ann = f\"len({src.annotation})\"\n-        store_length = IRnode.from_list(store_length, annotation=ann)\n-        ret.append(store_length)\n \n-        n_items = len(src.args)\n         for i in range(n_items):\n             k = IRnode.from_list(i, typ=UINT256_T)\n             dst_i = get_element_ptr(dst, k, array_bounds_check=False)\n             src_i = get_element_ptr(src, k, array_bounds_check=False)\n             ret.append(make_setter(dst_i, src_i))\n+\n+        # write the length word after data is copied\n+        store_length = STORE(dst, n_items)\n+        ann = None\n+        if src.annotation is not None:\n+            ann = f\"len({src.annotation})\"\n+        store_length = IRnode.from_list(store_length, annotation=ann)\n+\n+        ret.append(store_length)\n \n         return ret\n \n     with src.cache_when_complex(\"darray_src\") as (b1, src):\n         # for ABI-encoded dynamic data, we must loop to unpack, since\n         # the layout does not match our memory layout\n         should_loop = src.encoding == Encoding.ABI and src.typ.value_type.abi_type.is_dynamic()\n \n         # if the data is not validated, we must loop to unpack\n         should_loop |= needs_clamp(src.typ.value_",
  "diff_source": "custom"
}