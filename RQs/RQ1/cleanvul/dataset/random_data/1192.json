{
  "id": 1192,
  "language": "Java",
  "commit_url": "https://github.com/omnirom/android_frameworks_base/commit/107e6377328486fca55131ea06ca9d6a3c1585e0",
  "commit_sha": "107e6377328486fca55131ea06ca9d6a3c1585e0",
  "commit_msg": "Fix checkKeyIntentParceledCorrectly's bypass\n\nThe checkKeyIntentParceledCorrectly method was added in checkKeyIntent, which was originaly  only invoked when AccountManagerService deserializes the KEY_INTENT value as not NULL. However, due to the self-changing bundle technique in Parcel mismatch problems, the Intent value can change after reparceling; hence would bypass the added checkKeyIntentParceledCorrectly call.\n\nThis CL did the following:\n\n- Ensure the checkKeyIntent method is also called when result.getParcelable(AccountManager.KEY_INTENT, Intent.class) == null.\n- Migrate to the safer Bundle.getParcelable(String, Class<T>) API call\n  in AccountManagerService.\n\nBug: 260567867\nBug: 262230405\nTest: local test, see b/262230405\nTest: atest CtsAccountManagerTestCases\nMerged-In: I7b528f52c41767ae12731838fdd36aa26a8f3477\nChange-Id: I7b528f52c41767ae12731838fdd36aa26a8f3477\n(cherry picked from commit 3723f400e2f7f6b72be5d76ae6058e2be579b002)\nMerged-In: I7b528f52c41767ae12731838fdd36aa26a8f3477",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
  "func_name": "getAuthToken",
  "func_before": "@Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                TokenCache.Value cachedToken = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (cachedToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, cachedToken.token);\n                    result.putLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY,\n                            cachedToken.expiryEpochMillis);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }",
  "func_after": "@Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                TokenCache.Value cachedToken = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (cachedToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, cachedToken.token);\n                    result.putLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY,\n                            cachedToken.expiryEpochMillis);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n @Override\n     public void getAuthToken(\n             IAccountManagerResponse response,\n             final Account account,\n             final String authTokenType,\n             final boolean notifyOnAuthFailure,\n             final boolean expectActivityLaunch,\n             final Bundle loginOptions) {\n         Bundle.setDefusable(loginOptions, true);\n         if (Log.isLoggable(TAG, Log.VERBOSE)) {\n             Log.v(TAG, \"getAuthToken: \" + account\n                     + \", response \" + response\n                     + \", authTokenType \" + authTokenType\n                     + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                     + \", expectActivityLaunch \" + expectActivityLaunch\n                     + \", caller's uid \" + Binder.getCallingUid()\n                     + \", pid \" + Binder.getCallingPid());\n         }\n         Preconditions.checkArgument(response != null, \"response cannot be null\");\n         try {\n             if (account == null) {\n                 Slog.w(TAG, \"getAuthToken called with null account\");\n                 response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                 return;\n             }\n             if (authTokenType == null) {\n                 Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                 response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                 return;\n             }\n         } catch (RemoteException e) {\n             Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n             return;\n         }\n         int userId = UserHandle.getCallingUserId();\n         final long ident = Binder.clearCallingIdentity();\n         final UserAccounts accounts;\n         final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n         try {\n             accounts = getUserAccounts(userId);\n             authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n    ",
  "diff_source": "custom"
}