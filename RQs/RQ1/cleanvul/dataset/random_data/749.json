{
  "id": 749,
  "language": "Java",
  "commit_url": "https://github.com/PixelExperience/frameworks_base/commit/955123a6dfe17fbf30f3cd1898dd8229032274c7",
  "commit_sha": "955123a6dfe17fbf30f3cd1898dd8229032274c7",
  "commit_msg": "[RESTRICT AUTOMERGE] Limit length of the name in <uses-permission>\n\nTo mitigate a boot loop with a huge name string, this CL restricts\nthe max length of the name in <users-permission> attr.\n\nBug: 259942609\nTest: manually using the PoC in the buganizer to ensure the symptom\n      no longer exists.\nChange-Id: I35dde9d6bea9eb7c1b81e8cbadeeb908b3fb713f\n(cherry picked from commit de8ef32d020ce4efe5dcaae09c9b8e0cf7efb2db)\nMerged-In: I35dde9d6bea9eb7c1b81e8cbadeeb908b3fb713f",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "services/core/java/com/android/server/pm/pkg/parsing/ParsingPackageUtils.java",
  "func_name": "parseUsesPermission",
  "func_before": "private ParseResult<ParsingPackage> parseUsesPermission(ParseInput input,\n            ParsingPackage pkg, Resources res, XmlResourceParser parser)\n            throws IOException, XmlPullParserException {\n        TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestUsesPermission);\n        try {\n            // Note: don't allow this value to be a reference to a resource\n            // that may change.\n            String name = sa.getNonResourceString(\n                    R.styleable.AndroidManifestUsesPermission_name);\n\n            int maxSdkVersion = 0;\n            TypedValue val = sa.peekValue(\n                    R.styleable.AndroidManifestUsesPermission_maxSdkVersion);\n            if (val != null) {\n                if (val.type >= TypedValue.TYPE_FIRST_INT && val.type <= TypedValue.TYPE_LAST_INT) {\n                    maxSdkVersion = val.data;\n                }\n            }\n\n            final ArraySet<String> requiredFeatures = new ArraySet<>();\n            String feature = sa.getNonConfigurationString(\n                    com.android.internal.R.styleable.AndroidManifestUsesPermission_requiredFeature,\n                    0);\n            if (feature != null) {\n                requiredFeatures.add(feature);\n            }\n\n            final ArraySet<String> requiredNotFeatures = new ArraySet<>();\n            feature = sa.getNonConfigurationString(\n                    com.android.internal.R.styleable\n                            .AndroidManifestUsesPermission_requiredNotFeature,\n                    0);\n            if (feature != null) {\n                requiredNotFeatures.add(feature);\n            }\n\n            final int usesPermissionFlags = sa.getInt(\n                com.android.internal.R.styleable.AndroidManifestUsesPermission_usesPermissionFlags,\n                0);\n\n            final int outerDepth = parser.getDepth();\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && (type != XmlPullParser.END_TAG\n                    || parser.getDepth() > outerDepth)) {\n                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                    continue;\n                }\n\n                final ParseResult<?> result;\n                switch (parser.getName()) {\n                    case \"required-feature\":\n                        result = parseRequiredFeature(input, res, parser);\n                        if (result.isSuccess()) {\n                            requiredFeatures.add((String) result.getResult());\n                        }\n                        break;\n\n                    case \"required-not-feature\":\n                        result = parseRequiredNotFeature(input, res, parser);\n                        if (result.isSuccess()) {\n                            requiredNotFeatures.add((String) result.getResult());\n                        }\n                        break;\n\n                    default:\n                        result = ParsingUtils.unknownTag(\"<uses-permission>\", pkg, parser, input);\n                        break;\n                }\n\n                if (result.isError()) {\n                    return input.error(result);\n                }\n            }\n\n            // Can only succeed from here on out\n            ParseResult<ParsingPackage> success = input.success(pkg);\n\n            if (name == null) {\n                return success;\n            }\n\n            if ((maxSdkVersion != 0) && (maxSdkVersion < Build.VERSION.RESOURCES_SDK_INT)) {\n                return success;\n            }\n\n            if (mCallback != null) {\n                // Only allow requesting this permission if the platform supports all of the\n                // \"required-feature\"s.\n                for (int i = requiredFeatures.size() - 1; i >= 0; i--) {\n                    if (!mCallback.hasFeature(requiredFeatures.valueAt(i))) {\n                        return success;\n                    }\n                }\n\n                // Only allow requesting this permission if the platform does not supports any of\n                // the \"required-not-feature\"s.\n                for (int i = requiredNotFeatures.size() - 1; i >= 0; i--) {\n                    if (mCallback.hasFeature(requiredNotFeatures.valueAt(i))) {\n                        return success;\n                    }\n                }\n            }\n\n            // Quietly ignore duplicate permission requests, but fail loudly if\n            // the two requests have conflicting flags\n            boolean found = false;\n            final List<ParsedUsesPermission> usesPermissions = pkg.getUsesPermissions();\n            final int size = usesPermissions.size();\n            for (int i = 0; i < size; i++) {\n                final ParsedUsesPermission usesPermission = usesPermissions.get(i);\n                if (Objects.equals(usesPermission.getName(), name)) {\n                    if (usesPermission.getUsesPermissionFlags() != usesPermissionFlags) {\n                        return input.error(\"Conflicting uses-permissions flags: \"\n                                + name + \" in package: \" + pkg.getPackageName() + \" at: \"\n                                + parser.getPositionDescription());\n                    } else {\n                        Slog.w(TAG, \"Ignoring duplicate uses-permissions/uses-permissions-sdk-m: \"\n                                + name + \" in package: \" + pkg.getPackageName() + \" at: \"\n                                + parser.getPositionDescription());\n                    }\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                pkg.addUsesPermission(new ParsedUsesPermissionImpl(name, usesPermissionFlags));\n            }\n            return success;\n        } finally {\n            sa.recycle();\n        }\n    }",
  "func_after": "private ParseResult<ParsingPackage> parseUsesPermission(ParseInput input,\n            ParsingPackage pkg, Resources res, XmlResourceParser parser)\n            throws IOException, XmlPullParserException {\n        TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestUsesPermission);\n        try {\n            // Note: don't allow this value to be a reference to a resource\n            // that may change.\n            String name = sa.getNonResourceString(\n                    R.styleable.AndroidManifestUsesPermission_name);\n            if (TextUtils.length(name) > MAX_PERMISSION_NAME_LENGTH) {\n                return input.error(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,\n                        \"The name in the <uses-permission> is greater than \"\n                                + MAX_PERMISSION_NAME_LENGTH);\n            }\n\n            int maxSdkVersion = 0;\n            TypedValue val = sa.peekValue(\n                    R.styleable.AndroidManifestUsesPermission_maxSdkVersion);\n            if (val != null) {\n                if (val.type >= TypedValue.TYPE_FIRST_INT && val.type <= TypedValue.TYPE_LAST_INT) {\n                    maxSdkVersion = val.data;\n                }\n            }\n\n            final ArraySet<String> requiredFeatures = new ArraySet<>();\n            String feature = sa.getNonConfigurationString(\n                    com.android.internal.R.styleable.AndroidManifestUsesPermission_requiredFeature,\n                    0);\n            if (feature != null) {\n                requiredFeatures.add(feature);\n            }\n\n            final ArraySet<String> requiredNotFeatures = new ArraySet<>();\n            feature = sa.getNonConfigurationString(\n                    com.android.internal.R.styleable\n                            .AndroidManifestUsesPermission_requiredNotFeature,\n                    0);\n            if (feature != null) {\n                requiredNotFeatures.add(feature);\n            }\n\n            final int usesPermissionFlags = sa.getInt(\n                com.android.internal.R.styleable.AndroidManifestUsesPermission_usesPermissionFlags,\n                0);\n\n            final int outerDepth = parser.getDepth();\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && (type != XmlPullParser.END_TAG\n                    || parser.getDepth() > outerDepth)) {\n                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                    continue;\n                }\n\n                final ParseResult<?> result;\n                switch (parser.getName()) {\n                    case \"required-feature\":\n                        result = parseRequiredFeature(input, res, parser);\n                        if (result.isSuccess()) {\n                            requiredFeatures.add((String) result.getResult());\n                        }\n                        break;\n\n                    case \"required-not-feature\":\n                        result = parseRequiredNotFeature(input, res, parser);\n                        if (result.isSuccess()) {\n                            requiredNotFeatures.add((String) result.getResult());\n                        }\n                        break;\n\n                    default:\n                        result = ParsingUtils.unknownTag(\"<uses-permission>\", pkg, parser, input);\n                        break;\n                }\n\n                if (result.isError()) {\n                    return input.error(result);\n                }\n            }\n\n            // Can only succeed from here on out\n            ParseResult<ParsingPackage> success = input.success(pkg);\n\n            if (name == null) {\n                return success;\n            }\n\n            if ((maxSdkVersion != 0) && (maxSdkVersion < Build.VERSION.RESOURCES_SDK_INT)) {\n                return success;\n            }\n\n            if (mCallback != null) {\n                // Only allow requesting this permission if the platform supports all of the\n                // \"required-feature\"s.\n                for (int i = requiredFeatures.size() - 1; i >= 0; i--) {\n                    if (!mCallback.hasFeature(requiredFeatures.valueAt(i))) {\n                        return success;\n                    }\n                }\n\n                // Only allow requesting this permission if the platform does not supports any of\n                // the \"required-not-feature\"s.\n                for (int i = requiredNotFeatures.size() - 1; i >= 0; i--) {\n                    if (mCallback.hasFeature(requiredNotFeatures.valueAt(i))) {\n                        return success;\n                    }\n                }\n            }\n\n            // Quietly ignore duplicate permission requests, but fail loudly if\n            // the two requests have conflicting flags\n            boolean found = false;\n            final List<ParsedUsesPermission> usesPermissions = pkg.getUsesPermissions();\n            final int size = usesPermissions.size();\n            for (int i = 0; i < size; i++) {\n                final ParsedUsesPermission usesPermission = usesPermissions.get(i);\n                if (Objects.equals(usesPermission.getName(), name)) {\n                    if (usesPermission.getUsesPermissionFlags() != usesPermissionFlags) {\n                        return input.error(\"Conflicting uses-permissions flags: \"\n                                + name + \" in package: \" + pkg.getPackageName() + \" at: \"\n                                + parser.getPositionDescription());\n                    } else {\n                        Slog.w(TAG, \"Ignoring duplicate uses-permissions/uses-permissions-sdk-m: \"\n                                + name + \" in package: \" + pkg.getPackageName() + \" at: \"\n                                + parser.getPositionDescription());\n                    }\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                pkg.addUsesPermission(new ParsedUsesPermissionImpl(name, usesPermissionFlags));\n            }\n            return success;\n        } finally {\n            sa.recycle();\n        }\n    }",
  "diff_func": "--- func_before\n+++ func_after\n private ParseResult<ParsingPackage> parseUsesPermission(ParseInput input,\n             ParsingPackage pkg, Resources res, XmlResourceParser parser)\n             throws IOException, XmlPullParserException {\n         TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestUsesPermission);\n         try {\n             // Note: don't allow this value to be a reference to a resource\n             // that may change.\n             String name = sa.getNonResourceString(\n                     R.styleable.AndroidManifestUsesPermission_name);\n+            if (TextUtils.length(name) > MAX_PERMISSION_NAME_LENGTH) {\n+                return input.error(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,\n+                        \"The name in the <uses-permission> is greater than \"\n+                                + MAX_PERMISSION_NAME_LENGTH);\n+            }\n \n             int maxSdkVersion = 0;\n             TypedValue val = sa.peekValue(\n                     R.styleable.AndroidManifestUsesPermission_maxSdkVersion);\n             if (val != null) {\n                 if (val.type >= TypedValue.TYPE_FIRST_INT && val.type <= TypedValue.TYPE_LAST_INT) {\n                     maxSdkVersion = val.data;\n                 }\n             }\n \n             final ArraySet<String> requiredFeatures = new ArraySet<>();\n             String feature = sa.getNonConfigurationString(\n                     com.android.internal.R.styleable.AndroidManifestUsesPermission_requiredFeature,\n                     0);\n             if (feature != null) {\n                 requiredFeatures.add(feature);\n             }\n \n             final ArraySet<String> requiredNotFeatures = new ArraySet<>();\n             feature = sa.getNonConfigurationString(\n                     com.android.internal.R.styleable\n                             .AndroidManifestUsesPermission_requiredNotFeature,\n                     0);\n             if (feature != null) {\n                 requiredNotFeatures.add(feature)",
  "diff_source": "custom"
}