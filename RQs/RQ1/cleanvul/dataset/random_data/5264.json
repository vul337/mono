{
  "id": 5264,
  "language": "C/C++",
  "commit_url": "https://github.com/xiph/opusfile/commit/0a4cd796df5b030cb866f3f4a5e41a4b92caddf5",
  "commit_sha": "0a4cd796df5b030cb866f3f4a5e41a4b92caddf5",
  "commit_msg": "Propagate allocation failure from ogg_sync_buffer.\n\nInstead of segfault, report OP_EFAULT if ogg_sync_buffer returns\na null pointer. This allows more graceful recovery by the caller\nin the unlikely event of a fallible ogg_malloc call.\n\nWe do check the return value elsewhere in the code, so the new\nchecks make the code more consistent.\n\nThanks to https://github.com/xiph/opusfile/issues/36 for reporting.\n\nSigned-off-by: Timothy B. Terriberry <tterribe@xiph.org>\nSigned-off-by: Mark Harris <mark.hsj@gmail.com>",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/opusfile.c",
  "func_name": "op_open1",
  "func_before": "static int op_open1(OggOpusFile *_of,\n void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_page  og;\n  ogg_page *pog;\n  int       seekable;\n  int       ret;\n  memset(_of,0,sizeof(*_of));\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  _of->end=-1;\n  _of->stream=_stream;\n  *&_of->callbacks=*_cb;\n  /*At a minimum, we need to be able to read data.*/\n  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n  /*Initialize the framing state.*/\n  ogg_sync_init(&_of->oy);\n  /*Perhaps some data was previously read into a buffer for testing against\n     other stream types.\n    Allow initialization from this previously read data (especially as we may\n     be reading from a non-seekable stream).\n    This requires copying it into a buffer allocated by ogg_sync_buffer() and\n     doesn't support seeking, so this is not a good mechanism to use for\n     decoding entire files from RAM.*/\n  if(_initial_bytes>0){\n    char *buffer;\n    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n  }\n  /*Can we seek?\n    Stevens suggests the seek test is portable.\n    It's actually not for files on win32, but we address that by fixing it in\n     our callback implementation (see stream.c).*/\n  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n  /*If seek is implemented, tell must also be implemented.*/\n  if(seekable){\n    opus_int64 pos;\n    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n    pos=(*_of->callbacks.tell)(_of->stream);\n    /*If the current position is not equal to the initial bytes consumed,\n       absolute seeking will not work.*/\n    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n  }\n  _of->seekable=seekable;\n  /*Don't seek yet.\n    Set up a 'single' (current) logical bitstream entry for partial open.*/\n  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));\n  /*The serialno gets filled in later by op_fetch_headers().*/\n  ogg_stream_init(&_of->os,-1);\n  pog=NULL;\n  for(;;){\n    /*Fetch all BOS pages, store the Opus header and all seen serial numbers,\n      and load subsequent Opus setup headers.*/\n    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,\n     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);\n    if(OP_UNLIKELY(ret<0))break;\n    _of->nlinks=1;\n    _of->links[0].offset=0;\n    _of->links[0].data_offset=_of->offset;\n    _of->links[0].pcm_end=-1;\n    _of->links[0].serialno=_of->os.serialno;\n    /*Fetch the initial PCM offset.*/\n    ret=op_find_initial_pcm_offset(_of,_of->links,&og);\n    if(seekable||OP_LIKELY(ret<=0))break;\n    /*This link was empty, but we already have the BOS page for the next one in\n       og.\n      We can't seek, so start processing the next link right now.*/\n    opus_tags_clear(&_of->links[0].tags);\n    _of->nlinks=0;\n    if(!seekable)_of->cur_link++;\n    pog=&og;\n  }\n  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;\n  return ret;\n}",
  "func_after": "static int op_open1(OggOpusFile *_of,\n void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_page  og;\n  ogg_page *pog;\n  int       seekable;\n  int       ret;\n  memset(_of,0,sizeof(*_of));\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  _of->end=-1;\n  _of->stream=_stream;\n  *&_of->callbacks=*_cb;\n  /*At a minimum, we need to be able to read data.*/\n  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n  /*Initialize the framing state.*/\n  ogg_sync_init(&_of->oy);\n  /*Perhaps some data was previously read into a buffer for testing against\n     other stream types.\n    Allow initialization from this previously read data (especially as we may\n     be reading from a non-seekable stream).\n    This requires copying it into a buffer allocated by ogg_sync_buffer() and\n     doesn't support seeking, so this is not a good mechanism to use for\n     decoding entire files from RAM.*/\n  if(_initial_bytes>0){\n    char *buffer;\n    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n  }\n  /*Can we seek?\n    Stevens suggests the seek test is portable.\n    It's actually not for files on win32, but we address that by fixing it in\n     our callback implementation (see stream.c).*/\n  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n  /*If seek is implemented, tell must also be implemented.*/\n  if(seekable){\n    opus_int64 pos;\n    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n    pos=(*_of->callbacks.tell)(_of->stream);\n    /*If the current position is not equal to the initial bytes consumed,\n       absolute seeking will not work.*/\n    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n  }\n  _of->seekable=seekable;\n  /*Don't seek yet.\n    Set up a 'single' (current) logical bitstream entry for partial open.*/\n  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));\n  /*The serialno gets filled in later by op_fetch_headers().*/\n  ogg_stream_init(&_of->os,-1);\n  pog=NULL;\n  for(;;){\n    /*Fetch all BOS pages, store the Opus header and all seen serial numbers,\n      and load subsequent Opus setup headers.*/\n    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,\n     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);\n    if(OP_UNLIKELY(ret<0))break;\n    _of->nlinks=1;\n    _of->links[0].offset=0;\n    _of->links[0].data_offset=_of->offset;\n    _of->links[0].pcm_end=-1;\n    _of->links[0].serialno=_of->os.serialno;\n    /*Fetch the initial PCM offset.*/\n    ret=op_find_initial_pcm_offset(_of,_of->links,&og);\n    if(seekable||OP_LIKELY(ret<=0))break;\n    /*This link was empty, but we already have the BOS page for the next one in\n       og.\n      We can't seek, so start processing the next link right now.*/\n    opus_tags_clear(&_of->links[0].tags);\n    _of->nlinks=0;\n    if(!seekable)_of->cur_link++;\n    pog=&og;\n  }\n  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;\n  return ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int op_open1(OggOpusFile *_of,\n  void *_stream,const OpusFileCallbacks *_cb,\n  const unsigned char *_initial_data,size_t _initial_bytes){\n   ogg_page  og;\n   ogg_page *pog;\n   int       seekable;\n   int       ret;\n   memset(_of,0,sizeof(*_of));\n   if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n   _of->end=-1;\n   _of->stream=_stream;\n   *&_of->callbacks=*_cb;\n   /*At a minimum, we need to be able to read data.*/\n   if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n   /*Initialize the framing state.*/\n   ogg_sync_init(&_of->oy);\n   /*Perhaps some data was previously read into a buffer for testing against\n      other stream types.\n     Allow initialization from this previously read data (especially as we may\n      be reading from a non-seekable stream).\n     This requires copying it into a buffer allocated by ogg_sync_buffer() and\n      doesn't support seeking, so this is not a good mechanism to use for\n      decoding entire files from RAM.*/\n   if(_initial_bytes>0){\n     char *buffer;\n     buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n+    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n     memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n     ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n   }\n   /*Can we seek?\n     Stevens suggests the seek test is portable.\n     It's actually not for files on win32, but we address that by fixing it in\n      our callback implementation (see stream.c).*/\n   seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n   /*If seek is implemented, tell must also be implemented.*/\n   if(seekable){\n     opus_int64 pos;\n     if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n     pos=(*_of->callbacks.tell)(_of->stream);\n     /*If the current position is not equal to the initial bytes consumed,\n        absolute seeking will not work.*/\n     if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n   }\n   _of->seekable=seekable;\n   /",
  "diff_source": "custom"
}