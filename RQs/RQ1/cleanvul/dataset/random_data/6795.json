{
  "id": 6795,
  "language": "C/C++",
  "commit_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
  "commit_sha": "360e95d45ac4123255a4c796db96337f332160ad",
  "commit_msg": "fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.",
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "pr_info": "This PR merges changes addressing issues identified by fuzzing OpenSC driver by Eric Sesterhenn. The separate commits are authored mostly by @frankmorgner, @dengert, Eric and me.\r\n\r\nFor more information, see the blog post:\r\n\r\nhttps://www.x41-dsec.de/lab/blog/smartcards/\r\n\r\nThe changes were tested to ensure they still work for the cards we have, but testing with more cards would be always appreciated.\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [X] PKCS#11 module is tested\r\n- [ ] Windows minidriver is tested\r\n- [ ] macOS tokend is tested\r\n",
  "file_name": "src/libopensc/card-tcos.c",
  "func_name": "tcos_select_file",
  "func_before": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
  "func_after": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
  "diff_func": "--- func_before\n+++ func_after\n static int tcos_select_file(sc_card_t *card,\n \t\t\t    const sc_path_t *in_path,\n \t\t\t    sc_file_t **file_out)\n {\n \tsc_context_t *ctx;\n \tsc_apdu_t apdu;\n \tsc_file_t *file=NULL;\n \tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n \tunsigned int i;\n \tint r, pathlen;\n \n \tassert(card != NULL && in_path != NULL);\n \tctx=card->ctx;\n \tmemcpy(path, in_path->value, in_path->len);\n \tpathlen = in_path->len;\n \n \tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n \t\n \tswitch (in_path->type) {\n \tcase SC_PATH_TYPE_FILE_ID:\n \t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n \t\t/* fall through */\n \tcase SC_PATH_TYPE_FROM_CURRENT:\n \t\tapdu.p1 = 9;\n \t\tbreak;\n \tcase SC_PATH_TYPE_DF_NAME:\n \t\tapdu.p1 = 4;\n \t\tbreak;\n \tcase SC_PATH_TYPE_PATH:\n \t\tapdu.p1 = 8;\n \t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n \t\tif (pathlen == 0) apdu.p1 = 0;\n \t\tbreak;\n \tcase SC_PATH_TYPE_PARENT:\n \t\tapdu.p1 = 3;\n \t\tpathlen = 0;\n \t\tbreak;\n \tdefault:\n \t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n \t}\n \tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n \n \tapdu.lc = pathlen;\n \tapdu.data = path;\n \tapdu.datalen = pathlen;\n \n \tif (file_out != NULL) {\n \t\tapdu.resp = buf;\n \t\tapdu.resplen = sizeof(buf);\n \t\tapdu.le = 256;\n \t} else {\n \t\tapdu.resplen = 0;\n \t\tapdu.le = 0; \n \t\tapdu.p2 = 0x0C; \n \t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n \t}\n \n \tr = sc_transmit_apdu(card, &apdu);\n \tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n \tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n \tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n \n \tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n \t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n \t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n \t}\n \n \tfile = sc_file_new();\n \tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORM",
  "diff_source": "custom"
}