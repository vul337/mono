{
  "id": 4210,
  "language": "C/C++",
  "commit_url": "https://github.com/uclouvain/openjpeg/commit/e010aba95bbf6a0de9f27e989267a582a0bbf65e",
  "commit_sha": "e010aba95bbf6a0de9f27e989267a582a0bbf65e",
  "commit_msg": "Fix Out-Of-Bounds Read in sycc42x_to_rgb function\n\n42x Images with an odd x0/y0 lead to subsampled component starting at the\n2nd column/line.\nThat is offset = comp->dx * comp->x0 - image->x0 = 1\n\nUpdate uclouvain/openjpeg#726",
  "pr_url": null,
  "pr_info": "no more info",
  "file_name": "src/bin/common/color.c",
  "func_name": "sycc420_to_rgb",
  "func_before": "static void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tunsigned int maxw, maxh, max;\n\tint offset, upb;\n\tunsigned int i, j;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\n\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)\n\t{\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\n\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < maxh)\n\t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t}\n\t}\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n\n}",
  "func_after": "static void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tunsigned int maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n\tint offset, upb;\n\tunsigned int i;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\t\n\t/* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n\toffx = img->x0 & 1U;\n\tloopmaxw = maxw - offx;\n\t/* if img->y0 is odd, then first line shall use Cb/Cr = 0 */\n\toffy = img->y0 & 1U;\n\tloopmaxh = maxh - offy;\n\t\n\tif (offy > 0U) {\n\t\tunsigned int j;\n\t\t\n\t\tfor(j=0; j < maxw; ++j)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t}\n\t}\n\n\tfor(i=0U; i < (loopmaxh & ~(unsigned int)1U); i += 2U)\n\t{\n\t\tunsigned int j;\n\t\t\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\t\t\n\t\tif (offx > 0U) {\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t}\n\n\t\tfor(j=0; j < (loopmaxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < loopmaxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < loopmaxh)\n\t{\n\t\tunsigned int j;\n\t\t\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t}\n\t}\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n\n}",
  "diff_func": "--- func_before\n+++ func_after\n static void sycc420_to_rgb(opj_image_t *img)\n {\n \tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n \tconst int *y, *cb, *cr, *ny;\n-\tunsigned int maxw, maxh, max;\n+\tunsigned int maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n \tint offset, upb;\n-\tunsigned int i, j;\n+\tunsigned int i;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n \tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n \td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n \td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n \td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n+\t\n+\t/* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n+\toffx = img->x0 & 1U;\n+\tloopmaxw = maxw - offx;\n+\t/* if img->y0 is odd, then first line shall use Cb/Cr = 0 */\n+\toffy = img->y0 & 1U;\n+\tloopmaxh = maxh - offy;\n+\t\n+\tif (offy > 0U) {\n+\t\tunsigned int j;\n+\t\t\n+\t\tfor(j=0; j < maxw; ++j)\n+\t\t{\n+\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n+\t\t\t++y; ++r; ++g; ++b;\n+\t\t}\n+\t}\n \n-\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)\n+\tfor(i=0U; i < (loopmaxh & ~(unsigned int)1U); i += 2U)\n \t{\n+\t\tunsigned int j;\n+\t\t\n \t\tny = y + maxw;\n \t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n+\t\t\n+\t\tif (offx > 0U) {\n+\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n+\t\t\t++y; ++r; ++g; ++b;\n+\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n+\t\t\t++ny; ++nr; ++ng; ++nb;\n+\t\t}\n \n-\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)\n+\t\tfor(j=0; j < (loopmaxw & ~(unsigned int)1U); j += 2U)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n \n \t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n \t\t\t++ny; ++nr; ++ng; ++nb;\n \t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n \t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n \t\t}\n-\t\tif(j < maxw)\n+\t\tif(j < lo",
  "diff_source": "custom"
}