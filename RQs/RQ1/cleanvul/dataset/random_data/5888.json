{
  "id": 5888,
  "language": "C/C++",
  "commit_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
  "commit_sha": "239c4f7d1f47265526b39ad70106767d00805277",
  "commit_msg": "dd: harden functions against directory traversal issues\n\nTest correctness of all accessed dump dir files in all dd* functions.\nBefore this commit, the callers were allowed to pass strings like\n\"../../etc/shadow\" in the filename argument of all dd* functions.\n\nRelated: #1214457\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
  "pr_url": "https://github.com/abrt/libreport/pull/343",
  "pr_info": "Needed to avoid race-conditions between copy & chown.\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak jfilak@redhat.com\n",
  "file_name": "src/lib/dump_dir.c",
  "func_name": "dd_check",
  "func_before": "static const char *dd_check(struct dump_dir *dd)\n{\n    unsigned dirname_len = strlen(dd->dd_dirname);\n    char filename_buf[FILENAME_MAX+1];\n    strcpy(filename_buf, dd->dd_dirname);\n    strcpy(filename_buf + dirname_len, \"/\"FILENAME_TIME);\n    dd->dd_time = parse_time_file(filename_buf);\n    if (dd->dd_time < 0)\n    {\n        log_warning(\"Missing file: \"FILENAME_TIME);\n        return FILENAME_TIME;\n    }\n\n    strcpy(filename_buf + dirname_len, \"/\"FILENAME_TYPE);\n    dd->dd_type = load_text_file(filename_buf, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);\n    if (!dd->dd_type || (strlen(dd->dd_type) == 0))\n    {\n        log_warning(\"Missing or empty file: \"FILENAME_TYPE);\n        return FILENAME_TYPE;\n    }\n\n    return NULL;\n}",
  "func_after": "char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n{\n//    if (!dd->locked)\n//        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n    {\n        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);\n        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))\n            xfunc_die();\n    }\n\n    /* Compat with old abrt dumps. Remove in abrt-2.1 */\n    if (strcmp(name, \"release\") == 0)\n        name = FILENAME_OS_RELEASE;\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    char *ret = load_text_file(full_path, flags);\n    free(full_path);\n\n    return ret;\n}",
  "diff_func": "--- func_before\n+++ func_after\n-static const char *dd_check(struct dump_dir *dd)\n+char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n {\n+//    if (!dd->locked)\n+//        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n+\n+    if (!str_is_correct_filename(name))\n-    unsigned dirname_len = strlen(dd->dd_dirname);\n-    char filename_buf[FILENAME_MAX+1];\n-    strcpy(filename_buf, dd->dd_dirname);\n-    strcpy(filename_buf + dirname_len, \"/\"FILENAME_TIME);\n-    dd->dd_time = parse_time_file(filename_buf);\n-    if (dd->dd_time < 0)\n     {\n-        log_warning(\"Missing file: \"FILENAME_TIME);\n-        return FILENAME_TIME;\n+        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);\n+        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))\n+            xfunc_die();\n     }\n \n+    /* Compat with old abrt dumps. Remove in abrt-2.1 */\n+    if (strcmp(name, \"release\") == 0)\n+        name = FILENAME_OS_RELEASE;\n-    strcpy(filename_buf + dirname_len, \"/\"FILENAME_TYPE);\n-    dd->dd_type = load_text_file(filename_buf, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);\n-    if (!dd->dd_type || (strlen(dd->dd_type) == 0))\n-    {\n-        log_warning(\"Missing or empty file: \"FILENAME_TYPE);\n-        return FILENAME_TYPE;\n-    }\n \n+    char *full_path = concat_path_file(dd->dd_dirname, name);\n+    char *ret = load_text_file(full_path, flags);\n+    free(full_path);\n+\n-    return NULL;\n+    return ret;\n }",
  "diff_source": "custom"
}