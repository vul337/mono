{
  "cve_id": "CVE-2023-30300",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "WebAssembly/wabt",
  "commit_msg": "wasm2c: use CHECK_RESULT throughout workhorse function\n\nMake sure to validate module before generating names.",
  "commit_hash": "d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9",
  "git_url": "https://github.com/WebAssembly/wabt/commit/d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9",
  "file_path": "src/tools/wasm2c.cc",
  "func_name": "ProgramMain",
  "func_before": "int ProgramMain(int argc, char** argv) {\n  Result result;\n\n  InitStdio();\n  ParseOptions(argc, argv);\n\n  std::vector<uint8_t> file_data;\n  result = ReadFile(s_infile.c_str(), &file_data);\n  if (Succeeded(result)) {\n    Errors errors;\n    Module module;\n    const bool kStopOnFirstError = true;\n    const bool kFailOnCustomSectionError = true;\n    ReadBinaryOptions options(s_features, s_log_stream.get(),\n                              s_read_debug_names, kStopOnFirstError,\n                              kFailOnCustomSectionError);\n    result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),\n                          options, &errors, &module);\n    if (Succeeded(result)) {\n      if (Succeeded(result)) {\n        ValidateOptions options(s_features);\n        result = ValidateModule(&module, &errors, options);\n        result |= GenerateNames(&module);\n      }\n\n      if (Succeeded(result)) {\n        /* TODO(binji): This shouldn't fail; if a name can't be applied\n         * (because the index is invalid, say) it should just be skipped. */\n        Result dummy_result = ApplyNames(&module);\n        WABT_USE(dummy_result);\n      }\n\n      if (Succeeded(result)) {\n        if (!s_outfile.empty()) {\n          std::string header_name_full =\n              std::string(strip_extension(s_outfile)) + \".h\";\n          FileStream c_stream(s_outfile.c_str());\n          FileStream h_stream(header_name_full);\n          std::string_view header_name = GetBasename(header_name_full);\n          if (s_write_c_options.module_name.empty()) {\n            s_write_c_options.module_name = module.name;\n            if (s_write_c_options.module_name.empty()) {\n              // In the absence of module name in the names section use the\n              // filename.\n              s_write_c_options.module_name =\n                  StripExtension(GetBasename(s_infile));\n            }\n          }\n          result =\n              WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),\n                     &module, s_write_c_options);\n        } else {\n          FileStream stream(stdout);\n          result =\n              WriteC(&stream, &stream, \"wasm.h\", &module, s_write_c_options);\n        }\n      }\n    }\n    FormatErrorsToFile(errors, Location::Type::Binary);\n  }\n  return result != Result::Ok;\n}",
  "abstract_func_before": "int ProgramMain(int VAR_0, char** VAR_1) {\n  Result VAR_2;\n\n  InitStdio();\n  ParseOptions(VAR_0, VAR_1);\n\n  std::vector<uint8_t> VAR_3;\n  VAR_2 = ReadFile(VAR_4.c_str(), &VAR_3);\n  if (Succeeded(VAR_2)) {\n    Errors VAR_5;\n    Module VAR_6;\n    const bool VAR_7 = true;\n    const bool VAR_8 = true;\n    ReadBinaryOptions VAR_9(VAR_10, VAR_11.get(),\n                              VAR_12, VAR_7,\n                              VAR_8);\n    VAR_2 = ReadBinaryIr(VAR_4.c_str(), VAR_3.data(), VAR_3.size(),\n                          VAR_9, &VAR_5, &VAR_6);\n    if (Succeeded(VAR_2)) {\n      if (Succeeded(VAR_2)) {\n        ValidateOptions options(s_features);\n        VAR_2 = ValidateModule(&VAR_6, &VAR_5, VAR_9);\n        VAR_2 |= GenerateNames(&VAR_6);\n      }\n\n      if (Succeeded(VAR_2)) {\n        /* COMMENT_0 */\n                                                                            \n        Result VAR_13 = ApplyNames(&VAR_6);\n        WABT_USE(VAR_13);\n      }\n\n      if (Succeeded(VAR_2)) {\n        if (!VAR_14.empty()) {\n          std::string VAR_15 =\n              std::string(strip_extension(VAR_14)) + \".h\";\n          FileStream VAR_16(VAR_14.c_str());\n          FileStream h_stream(header_name_full);\n          std::string_view VAR_17 = GetBasename(header_name_full);\n          if (VAR_18.module_name.empty()) {\n            VAR_18.module_name = VAR_6.name;\n            if (VAR_18.module_name.empty()) {\n              /* COMMENT_2 */\n              /* COMMENT_3 */\n              VAR_18.module_name =\n                  StripExtension(GetBasename(VAR_4));\n            }\n          }\n          VAR_2 =\n              WriteC(&VAR_16, &VAR_19, std::string(VAR_17).c_str(),\n                     &VAR_6, VAR_18);\n        } else {\n          FileStream stream(stdout);\n          VAR_2 =\n              WriteC(&VAR_20, &VAR_20, \"wasm.h\", &VAR_6, VAR_18);\n        }\n      }\n    }\n    FormatErrorsToFile(VAR_5, Location::Type::Binary);\n  }\n  return VAR_2 != Result::Ok;\n}",
  "func_graph_path_before": "WebAssembly/wabt/d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9/wasm2c.cc/vul/before/0.json",
  "func": "int ProgramMain(int argc, char** argv) {\n  Result result;\n\n  InitStdio();\n  ParseOptions(argc, argv);\n\n  Errors errors;\n  result = wasm2c(errors);\n  FormatErrorsToFile(errors, Location::Type::Binary);\n\n  return result != Result::Ok;\n}",
  "abstract_func": "int ProgramMain(int VAR_0, char** VAR_1) {\n  Result VAR_2;\n\n  InitStdio();\n  ParseOptions(VAR_0, VAR_1);\n\n  Errors VAR_3;\n  VAR_2 = wasm2c(VAR_3);\n  FormatErrorsToFile(VAR_3, Location::Type::Binary);\n\n  return VAR_2 != Result::Ok;\n}",
  "func_graph_path": "WebAssembly/wabt/d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9/wasm2c.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,59 +4,9 @@\n   InitStdio();\n   ParseOptions(argc, argv);\n \n-  std::vector<uint8_t> file_data;\n-  result = ReadFile(s_infile.c_str(), &file_data);\n-  if (Succeeded(result)) {\n-    Errors errors;\n-    Module module;\n-    const bool kStopOnFirstError = true;\n-    const bool kFailOnCustomSectionError = true;\n-    ReadBinaryOptions options(s_features, s_log_stream.get(),\n-                              s_read_debug_names, kStopOnFirstError,\n-                              kFailOnCustomSectionError);\n-    result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),\n-                          options, &errors, &module);\n-    if (Succeeded(result)) {\n-      if (Succeeded(result)) {\n-        ValidateOptions options(s_features);\n-        result = ValidateModule(&module, &errors, options);\n-        result |= GenerateNames(&module);\n-      }\n+  Errors errors;\n+  result = wasm2c(errors);\n+  FormatErrorsToFile(errors, Location::Type::Binary);\n \n-      if (Succeeded(result)) {\n-        /* TODO(binji): This shouldn't fail; if a name can't be applied\n-         * (because the index is invalid, say) it should just be skipped. */\n-        Result dummy_result = ApplyNames(&module);\n-        WABT_USE(dummy_result);\n-      }\n-\n-      if (Succeeded(result)) {\n-        if (!s_outfile.empty()) {\n-          std::string header_name_full =\n-              std::string(strip_extension(s_outfile)) + \".h\";\n-          FileStream c_stream(s_outfile.c_str());\n-          FileStream h_stream(header_name_full);\n-          std::string_view header_name = GetBasename(header_name_full);\n-          if (s_write_c_options.module_name.empty()) {\n-            s_write_c_options.module_name = module.name;\n-            if (s_write_c_options.module_name.empty()) {\n-              // In the absence of module name in the names section use the\n-              // filename.\n-              s_write_c_options.module_name =\n-                  StripExtension(GetBasename(s_infile));\n-            }\n-          }\n-          result =\n-              WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),\n-                     &module, s_write_c_options);\n-        } else {\n-          FileStream stream(stdout);\n-          result =\n-              WriteC(&stream, &stream, \"wasm.h\", &module, s_write_c_options);\n-        }\n-      }\n-    }\n-    FormatErrorsToFile(errors, Location::Type::Binary);\n-  }\n   return result != Result::Ok;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  std::vector<uint8_t> file_data;",
      "  result = ReadFile(s_infile.c_str(), &file_data);",
      "  if (Succeeded(result)) {",
      "    Errors errors;",
      "    Module module;",
      "    const bool kStopOnFirstError = true;",
      "    const bool kFailOnCustomSectionError = true;",
      "    ReadBinaryOptions options(s_features, s_log_stream.get(),",
      "                              s_read_debug_names, kStopOnFirstError,",
      "                              kFailOnCustomSectionError);",
      "    result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),",
      "                          options, &errors, &module);",
      "    if (Succeeded(result)) {",
      "      if (Succeeded(result)) {",
      "        ValidateOptions options(s_features);",
      "        result = ValidateModule(&module, &errors, options);",
      "        result |= GenerateNames(&module);",
      "      }",
      "      if (Succeeded(result)) {",
      "        /* TODO(binji): This shouldn't fail; if a name can't be applied",
      "         * (because the index is invalid, say) it should just be skipped. */",
      "        Result dummy_result = ApplyNames(&module);",
      "        WABT_USE(dummy_result);",
      "      }",
      "",
      "      if (Succeeded(result)) {",
      "        if (!s_outfile.empty()) {",
      "          std::string header_name_full =",
      "              std::string(strip_extension(s_outfile)) + \".h\";",
      "          FileStream c_stream(s_outfile.c_str());",
      "          FileStream h_stream(header_name_full);",
      "          std::string_view header_name = GetBasename(header_name_full);",
      "          if (s_write_c_options.module_name.empty()) {",
      "            s_write_c_options.module_name = module.name;",
      "            if (s_write_c_options.module_name.empty()) {",
      "              // In the absence of module name in the names section use the",
      "              // filename.",
      "              s_write_c_options.module_name =",
      "                  StripExtension(GetBasename(s_infile));",
      "            }",
      "          }",
      "          result =",
      "              WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),",
      "                     &module, s_write_c_options);",
      "        } else {",
      "          FileStream stream(stdout);",
      "          result =",
      "              WriteC(&stream, &stream, \"wasm.h\", &module, s_write_c_options);",
      "        }",
      "      }",
      "    }",
      "    FormatErrorsToFile(errors, Location::Type::Binary);",
      "  }"
    ],
    "added_lines": [
      "  Errors errors;",
      "  result = wasm2c(errors);",
      "  FormatErrorsToFile(errors, Location::Type::Binary);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/WebAssembly/wabt/pull/2183",
  "description": {
    "pr_info": {
      "title": "wasm2c: use CHECK_RESULT throughout workhorse function (NFC)",
      "number": 2183
    },
    "comment": [
      "This simplifies the wasm2c main-ish function to use CHECK_RESULT everywhere it can. This lets the function be written in a less nested/indented way and now validates the module before running GenerateNames.\r\n\r\nFixes #2180",
      "Because all the code moved here its hard to see where the actual fix was.  Aside from moving the code and changing the nesting what actually fixed the bug?",
      "Oh I see, in the old code `GenerateNames` was called even if validation failed.\r\n\r\nlgtm with naming nit.",
      "Thank you for fixing the hang issue in `wasm2c`. I appreciate your hard work and dedication to improving the security of the project.\r\n\r\nI am just curious the hang discovered may qualify for a CVE, and I was wondering if you would be willing to consider assigning one., if it qualifies. The hang had the potential to cause a denial of service attack, and it was discovered through rigorous testing of the software.\r\n\r\nBest,",
      "Thank you for reporting this! I had asked a bunch of questions on the original issue when I was trying and failing to replicate your report (https://github.com/WebAssembly/wabt/issues/2180#issuecomment-1486368788) -- if you want to discuss further, let's have the conversation there.",
      "Thank you for the answer, Professor. I commented in #2180 \r\n\r\nBest, \r\nKhan."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch refactors error handling and validation in the `wasm2c` function, ensuring proper result checks and module validation before name generation. It improves code robustness and error handling but doesn't address a known security vulnerability.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.9"
}