{
  "cve_id": "CVE-2023-49298",
  "cwe_ids": [
    "CWE-639"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "openzfs/zfs",
  "commit_msg": "dnode_is_dirty: check dnode and its data for dirtiness\n\nOver its history this the dirty dnode test has been changed between\nchecking for a dnodes being on `os_dirty_dnodes` (`dn_dirty_link`) and\n`dn_dirty_record`.\n\n  de198f2d9 Fix lseek(SEEK_DATA/SEEK_HOLE) mmap consistency\n  2531ce372 Revert \"Report holes when there are only metadata changes\"\n  ec4f9b8f3 Report holes when there are only metadata changes\n  454365bba Fix dirty check in dmu_offset_next()\n  66aca2473 SEEK_HOLE should not block on txg_wait_synced()\n\nAlso illumos/illumos-gate@c543ec060d illumos/illumos-gate@2bcf0248e9\n\nIt turns out both are actually required.\n\nIn the case of appending data to a newly created file, the dnode proper\nis dirtied (at least to change the blocksize) and dirty records are\nadded.  Thus, a single logical operation is represented by separate\ndirty indicators, and must not be separated.\n\nThe incorrect dirty check becomes a problem when the first block of a\nfile is being appended to while another process is calling lseek to skip\nholes. There is a small window where the dnode part is undirtied while\nthere are still dirty records. In this case, `lseek(fd, 0, SEEK_DATA)`\nwould not know that the file is dirty, and would go to\n`dnode_next_offset()`. Since the object has no data blocks yet, it\nreturns `ESRCH`, indicating no data found, which results in `ENXIO`\nbeing returned to `lseek()`'s caller.\n\nSince coreutils 9.2, `cp` performs sparse copies by default, that is, it\nuses `SEEK_DATA` and `SEEK_HOLE` against the source file and attempts to\nreplicate the holes in the target. When it hits the bug, its initial\nsearch for data fails, and it goes on to call `fallocate()` to create a\nhole over the entire destination file.\n\nThis has come up more recently as users upgrade their systems, getting\nOpenZFS 2.2 as well as a newer coreutils. However, this problem has been\nreproduced against 2.1, as well as on FreeBSD 13 and 14.\n\nThis change simply updates the dirty check to check both types of dirty.\nIf there's anything dirty at all, we immediately go to the \"wait for\nsync\" stage, It doesn't really matter after that; both changes are on\ndisk, so the dirty fields should be correct.\n\nSigned-off-by: Rob Norris <rob.norris@klarasystems.com>\nSponsored-by: Klara, Inc.\nSponsored-by: Wasabi Technology, Inc.",
  "commit_hash": "c7fadf230f26be750feddaebda95e5cc66896107",
  "git_url": "https://github.com/openzfs/zfs/commit/c7fadf230f26be750feddaebda95e5cc66896107",
  "file_path": "module/zfs/dnode.c",
  "func_name": "dnode_is_dirty",
  "func_before": "boolean_t\ndnode_is_dirty(dnode_t *dn)\n{\n\tmutex_enter(&dn->dn_mtx);\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tif (multilist_link_active(&dn->dn_dirty_link[i])) {\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tmutex_exit(&dn->dn_mtx);\n\n\treturn (B_FALSE);\n}",
  "abstract_func_before": "boolean_t\ndnode_is_dirty(dnode_t *VAR_0)\n{\n\tmutex_enter(&VAR_0->dn_mtx);\n\n\tfor (int VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {\n\t\tif (multilist_link_active(&VAR_0->dn_dirty_link[VAR_1])) {\n\t\t\tmutex_exit(&VAR_0->dn_mtx);\n\t\t\treturn (VAR_3);\n\t\t}\n\t}\n\n\tmutex_exit(&VAR_0->dn_mtx);\n\n\treturn (VAR_4);\n}",
  "func_graph_path_before": "openzfs/zfs/c7fadf230f26be750feddaebda95e5cc66896107/dnode.c/vul/before/0.json",
  "func": "boolean_t\ndnode_is_dirty(dnode_t *dn)\n{\n\tmutex_enter(&dn->dn_mtx);\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tif (multilist_link_active(&dn->dn_dirty_link[i]) ||\n\t\t    !list_is_empty(&dn->dn_dirty_records[i])) {\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tmutex_exit(&dn->dn_mtx);\n\n\treturn (B_FALSE);\n}",
  "abstract_func": "boolean_t\ndnode_is_dirty(dnode_t *VAR_0)\n{\n\tmutex_enter(&VAR_0->dn_mtx);\n\n\tfor (int VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {\n\t\tif (multilist_link_active(&VAR_0->dn_dirty_link[VAR_1]) ||\n\t\t    !list_is_empty(&VAR_0->dn_dirty_records[VAR_1])) {\n\t\t\tmutex_exit(&VAR_0->dn_mtx);\n\t\t\treturn (VAR_3);\n\t\t}\n\t}\n\n\tmutex_exit(&VAR_0->dn_mtx);\n\n\treturn (VAR_4);\n}",
  "func_graph_path": "openzfs/zfs/c7fadf230f26be750feddaebda95e5cc66896107/dnode.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,8 @@\n \tmutex_enter(&dn->dn_mtx);\n \n \tfor (int i = 0; i < TXG_SIZE; i++) {\n-\t\tif (multilist_link_active(&dn->dn_dirty_link[i])) {\n+\t\tif (multilist_link_active(&dn->dn_dirty_link[i]) ||\n+\t\t    !list_is_empty(&dn->dn_dirty_records[i])) {\n \t\t\tmutex_exit(&dn->dn_mtx);\n \t\t\treturn (B_TRUE);\n \t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tif (multilist_link_active(&dn->dn_dirty_link[i])) {"
    ],
    "added_lines": [
      "\t\tif (multilist_link_active(&dn->dn_dirty_link[i]) ||",
      "\t\t    !list_is_empty(&dn->dn_dirty_records[i])) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openzfs/zfs/pull/15571",
  "description": {
    "pr_info": {
      "title": "dnode_is_dirty: check dnode and its data for dirtiness",
      "number": 15571
    },
    "comment": [
      "### Motivation and Context\r\n\r\nCloses #15526.\r\n\r\n### Description\r\n\r\nOver its history this the dirty dnode test has been changed between checking for a dnodes being on `os_dirty_dnodes` (`dn_dirty_link`) and `dn_dirty_record`.\r\n\r\n  de198f2d9 Fix lseek(SEEK_DATA/SEEK_HOLE) mmap consistency\r\n  2531ce372 Revert \"Report holes when there are only metadata changes\"\r\n  ec4f9b8f3 Report holes when there are only metadata changes\r\n  454365bba Fix dirty check in dmu_offset_next()\r\n  66aca2473 SEEK_HOLE should not block on txg_wait_synced()\r\n\r\nAlso illumos/illumos-gate@c543ec060d illumos/illumos-gate@2bcf0248e9\r\n\r\nIt turns out both are actually required.\r\n\r\nIn the case of appending data to a newly created file, the dnode proper is dirtied (at least to change the blocksize) and dirty records are added.  Thus, a single logical operation is represented by separate dirty indicators, and must not be separated.\r\n\r\nThe incorrect dirty check becomes a problem when the first block of a file is being appended to while another process is calling lseek to skip holes. It can happen that the dnode part is undirtied, while dirty records are still on the dnode for the next txg. In this case, `lseek(fd, 0, SEEK_DATA)` would not know that the file is dirty, and would go to `dnode_next_offset()`. Since the object has no data blocks yet, it returns `ESRCH`, indicating no data found, which results in `ENXIO` being returned to `lseek()`'s caller.\r\n\r\nSince coreutils 9.2, `cp` performs sparse copies by default, that is, it uses `SEEK_DATA` and `SEEK_HOLE` against the source file and attempts to replicate the holes in the target. When it hits the bug, its initial search for data fails, and it goes on to call `fallocate()` to create a hole over the entire destination file.\r\n\r\nThis has come up more recently as users upgrade their systems, getting OpenZFS 2.2 as well as a newer coreutils. However, this problem has been reproduced against 2.1, as well as on FreeBSD 13 and 14.\r\n\r\nThis change simply updates the dirty check to check both types of dirty. If there's anything dirty at all, we immediately go to the \"wait for sync\" stage, It doesn't really matter after that; both changes are on disk, so the dirty fields should be correct.\r\n\r\n### How Has This Been Tested?\r\n\r\n@tonyhutter produced a repro script in #15526 which has been extremely useful. Its not perfect, but it can usually trip the issue in a couple of minutes. With the patch in place, no one has been able to trigger the issue. @rincebrain has been driving it reasonably hard (I think), no hits.\r\n\r\nFull test suite run has passed.\r\n\r\nI've done some general sanity and stress tests on customer workloads. They don't exercise the bug, but they all did fine, so this maybe hasn't broken anything.\r\n\r\nI'd like to write a test for this case, since its bitten a few times in the past, but it requires `lseek()` to be called after the dnode proper being undirtied but before the dbufs are undirtied. I don't have that kind of control from outside. Ideas welcome.\r\n\r\n### Types of changes\r\n\r\n- [x] Bug fix (non-breaking change which fixes an issue)\r\n- [ ] New feature (non-breaking change which adds functionality)\r\n- [ ] Performance enhancement (non-breaking change which improves efficiency)\r\n- [ ] Code cleanup (non-breaking change which makes code smaller or more readable)\r\n- [ ] Breaking change (fix or feature that would cause existing functionality to change)\r\n- [ ] Library ABI change (libzfs, libzfs\\_core, libnvpair, libuutil and libzfsbootenv)\r\n- [ ] Documentation (a change to man pages or other documentation)\r\n\r\n### Checklist:\r\n\r\n- [x] My code follows the OpenZFS [code style requirements](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md#coding-conventions).\r\n- [ ] I have updated the documentation accordingly.\r\n- [x] I have read the [**contributing** document](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md).\r\n- [ ] I have added [tests](https://github.com/openzfs/zfs/tree/master/tests) to cover my changes.\r\n- [x] I have run the ZFS Test Suite with this change applied.\r\n- [x] All commit messages are properly formatted and contain [`Signed-off-by`](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md#signed-off-by).",
      "Any chance this PR and your other one can make it into freebsd 14 release after it gets merged? I think it ought to given that it's a critical fix. @mmatuska ?",
      "Follow [FreeBSD PR 275308](https://bugs.freebsd.org/275308) for details about FreeBSD EN updates.",
      "Since I was able to reproduce the original bug in https://github.com/openzfs/zfs/issues/15526 , I took on testing this bugfix - so far it is looking promising. No bug seen (where I was able to see it before) on my test VM. Going to try it on bare metal soon.",
      "> Since I was able to reproduce the original bug in #15526 , I took on testing this bugfix - so far it is looking promising. No bug seen (where I was able to see it before) on my test VM. Going to try it on bare metal soon.\r\n\r\nTested on bare metal, on a relatively large machine where I could reproduce it previously, did not see the bug manifest after I have applied this patch.",
      "Two different Gentoo Linux systems running a patched ZFS (with this commit):  they are no longer being able to reproduce the corruption after 4-5 dozens of attempts done with `reproducer.sh` while the issue was triggering fairly easily after 3-4 runs in a row before. Good job!\r\n",
      "### CVE-2023-49298\r\n\r\n<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-49298> includes references to: \r\n\r\n- this PR\r\n- https://github.com/openzfs/zfs/issues/15526\r\n- <https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=275308>\r\n\r\n----\r\n\r\nRe: <https://github.com/openzfs/zfs/pull/15571#issuecomment-1825880940>\r\n\r\n> Follow [FreeBSD PR 275308](https://bugs.freebsd.org/275308) for details about FreeBSD EN updates.\r\n\r\n@emaste for what it's worth, from the current description of CVE-2023-49298 I lean towards treating it as _parallel to_ 275308; not requiring a FreeBSD security advisory (SA). \r\n\r\nFor you and your [secteam@](https://www.freebsd.org/administration/#t-secteam) colleagues to assess. Thanks.\r\n",
      "For whatever its worth, I have no idea who posted the CVE or why. The scenario described really just sounds like the author hasn't really understood the detail.",
      "Yeah it's not exactly an attack vector that could be controlled, you'd need an application with permission to modify the file to begin with.\r\n\r\nAlso both bug fixes need to land in 14, security vulnerability or not. Hopefully an SA is not required for a revised .0 release.",
      "> ### [CVE-2023-49298](https://github.com/advisories/GHSA-mvg7-8xh2-47rf)\r\n> \r\n> https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-49298\r\n\r\nThis CVE says:\r\n\r\n>NOTE: this issue is not always security related, but can be security related in realistic situations.\r\n\r\n@grahamperrin @emaste Security is not just confidentiality, but also integrity and availability. Data corruption is therefore, absolutely and unquestionably, a security issue.",
      "@KungFuJesus please follow report 275308. \r\n\r\n----\r\n\r\nFor all readers: <https://github.com/openzfs/zfs/pull/15571#issuecomment-1826780399> was solely for awareness. I have no idea who made the original report (I discovered it today, through [conversation in Matrix](https://matrix.to/#/!IBdGSejslGivmIcnQs:matrix.org/$170096766828NOkQr:synapse.scientiam.org?via=matrix.org&via=mozilla.org&via=tchncs.de)). \r\n\r\nRe: the CVE, I respectfully suggest discussion elsewhere (Matrix, maybe); so that discussion here can remain focused on _the PR_.\r\n\r\nThanks",
      "@grahamperrin worse, the information is misleading (unless I am missing something). Quoting:\r\n\r\n> OpenZFS through 2.1.13 and 2.2.x through 2.2.1, in certain scenarios involving applications that try to rely on efficient copying of file data, can replace file contents with zero-valued bytes \r\n\r\nThis is simply not true, the corruption issue being spotted on older versions as well.\r\n",
      "I think if someone really wants to give constructive feedback, they should focus on ideas for test cases.",
      "Just to clarify, beyond the minor suggestions for changes in wording, the intention behind my proposal is to make the comment as intelligible/readable as possible.\r\n\r\nEspecially since it seems that this part of the code has been critically misunderstood (resp. prone to errors) in the past.",
      "> Just to clarify, beyond the minor suggestions for changes in wording, the intention behind my proposal is to make the comment as readable as possible.\r\n> \r\n> Especially since it seems that this part of the code has been critically misunderstood (resp. prone to errors) in the past.\r\n\r\n@samy-mahmoudi It is okay to correct a small typo in a code comment... but did you write the code or have a **good** knowledge of it? If the answer is \"no\", please don't touch any of the comments, unless a mistake is really obvious. Revising comments on some code you did not write and on which you have a limited knowledge (or no knowledge at all) can bring confusion and worse, induce errors due to a misleading wording. \r\n\r\nFixing typos in comment of a patch is of no value here for the moment, your time will be much better invested in testing things if you can't help in code writing/reviewing. Especially with that kind of issue.  Let the authors bring their own words if they judge adequate to do so.\r\n\r\nIf you want to learn / comments / investigate yourself , I  suggest you to create your own branch and commit there, then do a pull request.  Your commits here are just polluting the thread for nothing, please keep that discussion lean to help others to see the following various *code* changes.\r\n",
      "Hey all, remember to be kind. This is a request for review, and that includes reading the comments and making sure they're clear and understandable. I'm very happy to have more eyes and brains on this, not less.",
      "@behlendorf done, thanks.\r\n\r\nI'll think more about testing. I need to ask @don-brady about ztest anyway, I still haven't used it in anger :)",
      "(re-pushed with updated author/signoff/sponsorship)",
      "> (re-pushed with updated author/signoff/sponsorship)\r\n\r\n@robn  is this one ready for testing or do need you review/push some other changes before?  ",
      "@admnd its the same patch that we've all been banging on for the last few days. The updates here are just housekeeping. Not that I mind more testing :)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a bug causing incorrect file operations that could lead to data integrity issues, classifying it as a security fix with high confidence.\n\n**Final Output:**\n\nAnalysis: The patch corrects a bug in how dnode dirtiness is checked, preventing incorrect lseek behavior and potential data corruption. This affects data integrity, a security concern.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}