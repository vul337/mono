{
  "cve_id": "CVE-2023-47234",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: Ignore handling NLRIs if we received MP_UNREACH_NLRI\n\nIf we receive MP_UNREACH_NLRI, we should stop handling remaining NLRIs if\nno mandatory path attributes received.\n\nIn other words, if MP_UNREACH_NLRI received, the remaining NLRIs should be handled\nas a new data, but without mandatory attributes, it's a malformed packet.\n\nIn normal case, this MUST not happen at all, but to avoid crashing bgpd, we MUST\nhandle that.\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",
  "commit_hash": "c37119df45bbf4ef713bc10475af2ee06e12f3bf",
  "git_url": "https://github.com/FRRouting/frr/commit/c37119df45bbf4ef713bc10475af2ee06e12f3bf",
  "file_path": "bgpd/bgp_attr.c",
  "func_name": "bgp_attr_check",
  "func_before": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t length)\n{\n\tuint8_t type = 0;\n\n\t/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an\n\t * empty UPDATE. Treat-as-withdraw, otherwise if we just ignore it,\n\t * we will pass it to be processed as a normal UPDATE without mandatory\n\t * attributes, that could lead to harmful behavior.\n\t */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&\n\t    !length)\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\n\t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required\n\t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI\n\t   are present, it should.  Check for any other attribute being present\n\t   instead.\n\t */\n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))\n\t\ttype = BGP_ATTR_ORIGIN;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))\n\t\ttype = BGP_ATTR_AS_PATH;\n\n\t/* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present\n\t * and\n\t * NLRI is empty. We can't easily check NLRI empty here though.\n\t */\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))\n\t\ttype = BGP_ATTR_NEXT_HOP;\n\n\tif (peer->sort == BGP_PEER_IBGP\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))\n\t\ttype = BGP_ATTR_LOCAL_PREF;\n\n\t/* If any of the well-known mandatory attributes are not present\n\t * in an UPDATE message, then \"treat-as-withdraw\" MUST be used.\n\t */\n\tif (type) {\n\t\tflog_warn(EC_BGP_MISSING_ATTRIBUTE,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}",
  "abstract_func_before": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t VAR_0)\n{\n\tuint8_t VAR_1 = 0;\n\n\t/* COMMENT_0 */\n                                                                    \n                                                                        \n                                                    \n    \n\tif (CHECK_FLAG(peer->cap, VAR_2) && !attr->flag &&\n\t    !VAR_0)\n\t\treturn VAR_3;\n\n\t/* COMMENT_5 */\n                                                                         \n                                                                        \n            \n    \n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_5))))\n\t\treturn VAR_6;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_7)))\n\t\tVAR_1 = VAR_7;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_8)))\n\t\tVAR_1 = VAR_8;\n\n\t/* COMMENT_10 */\n       \n                                                                \n    \n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_9))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)))\n\t\tVAR_1 = VAR_9;\n\n\tif (peer->sort == VAR_10\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_11)))\n\t\tVAR_1 = VAR_11;\n\n\t/* COMMENT_14 */\n                                                                \n    \n\tif (VAR_1) {\n\t\tflog_warn(VAR_12,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(VAR_13, VAR_1, NULL));\n\t\treturn VAR_3;\n\t}\n\treturn VAR_6;\n}",
  "func_graph_path_before": "FRRouting/frr/c37119df45bbf4ef713bc10475af2ee06e12f3bf/bgp_attr.c/vul/before/0.json",
  "func": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t length)\n{\n\tuint8_t type = 0;\n\n\t/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an\n\t * empty UPDATE. Treat-as-withdraw, otherwise if we just ignore it,\n\t * we will pass it to be processed as a normal UPDATE without mandatory\n\t * attributes, that could lead to harmful behavior.\n\t */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&\n\t    !length)\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))\n\t\ttype = BGP_ATTR_ORIGIN;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))\n\t\ttype = BGP_ATTR_AS_PATH;\n\n\t/* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present\n\t * and\n\t * NLRI is empty. We can't easily check NLRI empty here though.\n\t */\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))\n\t\ttype = BGP_ATTR_NEXT_HOP;\n\n\tif (peer->sort == BGP_PEER_IBGP\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))\n\t\ttype = BGP_ATTR_LOCAL_PREF;\n\n\t/* An UPDATE message that contains the MP_UNREACH_NLRI is not required\n\t * to carry any other path attributes. Though if MP_REACH_NLRI or NLRI\n\t * are present, it should. Check for any other attribute being present\n\t * instead.\n\t */\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n\t    CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)))\n\t\treturn type ? BGP_ATTR_PARSE_MISSING_MANDATORY\n\t\t\t    : BGP_ATTR_PARSE_PROCEED;\n\n\t/* If any of the well-known mandatory attributes are not present\n\t * in an UPDATE message, then \"treat-as-withdraw\" MUST be used.\n\t */\n\tif (type) {\n\t\tflog_warn(EC_BGP_MISSING_ATTRIBUTE,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}",
  "abstract_func": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t VAR_0)\n{\n\tuint8_t VAR_1 = 0;\n\n\t/* COMMENT_0 */\n                                                                    \n                                                                        \n                                                    \n    \n\tif (CHECK_FLAG(peer->cap, VAR_2) && !attr->flag &&\n\t    !VAR_0)\n\t\treturn VAR_3;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)))\n\t\tVAR_1 = VAR_4;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_5)))\n\t\tVAR_1 = VAR_5;\n\n\t/* COMMENT_5 */\n       \n                                                                \n    \n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_6))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_7)))\n\t\tVAR_1 = VAR_6;\n\n\tif (peer->sort == VAR_8\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_9)))\n\t\tVAR_1 = VAR_9;\n\n\t/* COMMENT_9 */\n                                                                       \n                                                                       \n            \n    \n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_7)) &&\n\t    CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_10)))\n\t\treturn VAR_1 ? VAR_11\n\t\t\t    : VAR_12;\n\n\t/* COMMENT_14 */\n                                                                \n    \n\tif (VAR_1) {\n\t\tflog_warn(VAR_13,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(VAR_14, VAR_1, NULL));\n\t\treturn VAR_3;\n\t}\n\treturn VAR_12;\n}",
  "func_graph_path": "FRRouting/frr/c37119df45bbf4ef713bc10475af2ee06e12f3bf/bgp_attr.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,15 +11,6 @@\n \tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&\n \t    !length)\n \t\treturn BGP_ATTR_PARSE_WITHDRAW;\n-\n-\t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required\n-\t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI\n-\t   are present, it should.  Check for any other attribute being present\n-\t   instead.\n-\t */\n-\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n-\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))\n-\t\treturn BGP_ATTR_PARSE_PROCEED;\n \n \tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))\n \t\ttype = BGP_ATTR_ORIGIN;\n@@ -39,6 +30,16 @@\n \t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))\n \t\ttype = BGP_ATTR_LOCAL_PREF;\n \n+\t/* An UPDATE message that contains the MP_UNREACH_NLRI is not required\n+\t * to carry any other path attributes. Though if MP_REACH_NLRI or NLRI\n+\t * are present, it should. Check for any other attribute being present\n+\t * instead.\n+\t */\n+\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n+\t    CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)))\n+\t\treturn type ? BGP_ATTR_PARSE_MISSING_MANDATORY\n+\t\t\t    : BGP_ATTR_PARSE_PROCEED;\n+\n \t/* If any of the well-known mandatory attributes are not present\n \t * in an UPDATE message, then \"treat-as-withdraw\" MUST be used.\n \t */",
  "diff_line_info": {
    "deleted_lines": [
      "",
      "\t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required",
      "\t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI",
      "\t   are present, it should.  Check for any other attribute being present",
      "\t   instead.",
      "\t */",
      "\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&",
      "\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))",
      "\t\treturn BGP_ATTR_PARSE_PROCEED;"
    ],
    "added_lines": [
      "\t/* An UPDATE message that contains the MP_UNREACH_NLRI is not required",
      "\t * to carry any other path attributes. Though if MP_REACH_NLRI or NLRI",
      "\t * are present, it should. Check for any other attribute being present",
      "\t * instead.",
      "\t */",
      "\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&",
      "\t    CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)))",
      "\t\treturn type ? BGP_ATTR_PARSE_MISSING_MANDATORY",
      "\t\t\t    : BGP_ATTR_PARSE_PROCEED;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/14716",
  "description": {
    "pr_info": {
      "title": "bgpd: A couple more bgpd crash fixes for malformed packets ",
      "number": 14716
    },
    "comment": [
      "Found when fuzzing, in the normal case, such packets can't exist at all.",
      "@Mergifyio backport dev/9.1",
      "> backport dev/9.1\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#14735 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/14735) has been created for branch `dev/9.1`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport dev/9.1\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->",
      "Is there a plan for a stable/9.0 backport, too?",
      "@Mergifyio backport stable/9.0",
      "> backport stable/9.0\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#14861 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/14861) has been created for branch `stable/9.0`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/9.0\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->",
      "@Mergifyio backport stable/8.4",
      "> backport stable/8.4\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#15930 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/15930) has been created for branch `stable/8.4` but encountered conflicts\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/8.4\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing a crash when handling malformed BGP packets, thus avoiding a potential denial of service. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}