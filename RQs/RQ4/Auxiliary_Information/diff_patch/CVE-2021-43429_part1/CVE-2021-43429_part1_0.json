{
  "cve_id": "CVE-2021-43429",
  "cwe_ids": [
    "CWE-667"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Seagate/cortx-s3server",
  "commit_msg": "avoid the unrelesed lock after the method returns\n\nUpdate s3_memory_pool.c. Avoid the unreleased lock pool->lock after the method returns.",
  "commit_hash": "23882c427837ee988a60201c5d09a5e91e19b2d7",
  "git_url": "https://github.com/Seagate/cortx-s3server/commit/23882c427837ee988a60201c5d09a5e91e19b2d7",
  "file_path": "mempool/s3_memory_pool.c",
  "func_name": "mempool_destroy",
  "func_before": "int mempool_destroy(MemoryPoolHandle *handle) {\n  struct mempool *pool = NULL;\n  struct memory_pool_element *pool_item;\n  char *log_msg_fmt = \"mempool(%p): free(%p) called for buffer size(%zu)\";\n  char log_msg[200];\n\n  if (handle == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  pool = (struct mempool *)*handle;\n  if (pool == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n\n  if (*handle == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  /* reset the handle */\n  *handle = NULL;\n  /* Free the items in free list */\n  pool_item = pool->free_list;\n  while (pool_item != NULL) {\n    pool->free_list = pool_item->next;\n    /* Log message about free()'ed item */\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               (void *)pool_item, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_DEBUG, log_msg);\n    }\n    free(pool_item);\n#if 0\n    /* Need this if below asserts are there */\n    pool->total_bufs_allocated_by_pool--;\n    pool->free_bufs_in_pool--;\n#endif\n    pool_item = pool->free_list;\n  }\n  pool->free_list = NULL;\n\n  /* TODO: libevhtp/libevent seems to hold some references and not release back\n   * to pool. Bug will be logged for this to investigate.\n   */\n  /* Assert if there are leaks */\n  /*\n    assert(pool->total_bufs_allocated_by_pool == 0);\n    assert(pool->number_of_bufs_shared == 0);\n    assert(pool->free_bufs_in_pool == 0);\n  */\n\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n    pthread_mutex_destroy(&pool->lock);\n  }\n\n  free(pool);\n  pool = NULL;\n  return 0;\n}",
  "abstract_func_before": "int mempool_destroy(MemoryPoolHandle *VAR_0) {\n  struct mempool *VAR_1 = NULL;\n  struct memory_pool_element *VAR_2;\n  char *VAR_3 = \"mempool(%p): free(%p) called for buffer size(%zu)\";\n  char VAR_4[200];\n\n  if (VAR_0 == NULL) {\n    return VAR_5;\n  }\n\n  VAR_1 = (struct mempool *)*VAR_0;\n  if (VAR_1 == NULL) {\n    return VAR_5;\n  }\n\n  if ((VAR_1->flags & VAR_6) != 0) {\n    pthread_mutex_lock(&VAR_1->lock);\n  }\n\n  if (*VAR_0 == NULL) {\n    return VAR_5;\n  }\n\n  /* COMMENT_0 */\n  *VAR_0 = NULL;\n  /* COMMENT_1 */\n  VAR_2 = VAR_1->free_list;\n  while (VAR_2 != NULL) {\n    VAR_1->free_list = VAR_2->next;\n    /* COMMENT_2 */\n    if (VAR_1->log_callback_func) {\n      snprintf(VAR_4, sizeof(VAR_4), VAR_3, (void *)VAR_1,\n               (void *)VAR_2, VAR_1->mempool_item_size);\n      VAR_1->log_callback_func(VAR_7, VAR_4);\n    }\n    free(VAR_2);\n#if 0\n    /* COMMENT_3 */\n    VAR_1->total_bufs_allocated_by_pool--;\n    VAR_1->free_bufs_in_pool--;\n#endif\n    VAR_2 = VAR_1->free_list;\n  }\n  VAR_1->free_list = NULL;\n\n  /* COMMENT_4 */\n                                                         \n     \n  /* COMMENT_7 */\n  /* COMMENT_8 */\n                                                    \n                                             \n                                         \n    \n\n  if ((VAR_1->flags & VAR_6) != 0) {\n    pthread_mutex_unlock(&VAR_1->lock);\n    pthread_mutex_destroy(&VAR_1->lock);\n  }\n\n  free(VAR_1);\n  VAR_1 = NULL;\n  return 0;\n}",
  "func_graph_path_before": "Seagate/cortx-s3server/23882c427837ee988a60201c5d09a5e91e19b2d7/s3_memory_pool.c/vul/before/0.json",
  "func": "int mempool_destroy(MemoryPoolHandle *handle) {\n  struct mempool *pool = NULL;\n  struct memory_pool_element *pool_item;\n  char *log_msg_fmt = \"mempool(%p): free(%p) called for buffer size(%zu)\";\n  char log_msg[200];\n\n  if (handle == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  pool = (struct mempool *)*handle;\n  if (pool == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n\n  if (*handle == NULL) {\n    if ((pool->flags & ENABLE_LOCKING) != 0) {\n      pthread_mutex_unlock(&pool->lock);\n    }\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n\n  /* reset the handle */\n  *handle = NULL;\n  /* Free the items in free list */\n  pool_item = pool->free_list;\n  while (pool_item != NULL) {\n    pool->free_list = pool_item->next;\n    /* Log message about free()'ed item */\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               (void *)pool_item, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_DEBUG, log_msg);\n    }\n    free(pool_item);\n#if 0\n    /* Need this if below asserts are there */\n    pool->total_bufs_allocated_by_pool--;\n    pool->free_bufs_in_pool--;\n#endif\n    pool_item = pool->free_list;\n  }\n  pool->free_list = NULL;\n\n  /* TODO: libevhtp/libevent seems to hold some references and not release back\n   * to pool. Bug will be logged for this to investigate.\n   */\n  /* Assert if there are leaks */\n  /*\n    assert(pool->total_bufs_allocated_by_pool == 0);\n    assert(pool->number_of_bufs_shared == 0);\n    assert(pool->free_bufs_in_pool == 0);\n  */\n\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n    pthread_mutex_destroy(&pool->lock);\n  }\n\n  free(pool);\n  pool = NULL;\n  return 0;\n}",
  "abstract_func": "int mempool_destroy(MemoryPoolHandle *VAR_0) {\n  struct mempool *VAR_1 = NULL;\n  struct memory_pool_element *VAR_2;\n  char *VAR_3 = \"mempool(%p): free(%p) called for buffer size(%zu)\";\n  char VAR_4[200];\n\n  if (VAR_0 == NULL) {\n    return VAR_5;\n  }\n\n  VAR_1 = (struct mempool *)*VAR_0;\n  if (VAR_1 == NULL) {\n    return VAR_5;\n  }\n\n  if ((VAR_1->flags & VAR_6) != 0) {\n    pthread_mutex_lock(&VAR_1->lock);\n  }\n\n  if (*VAR_0 == NULL) {\n    if ((VAR_1->flags & VAR_6) != 0) {\n      pthread_mutex_unlock(&VAR_1->lock);\n    }\n    return VAR_5;\n  }\n\n  /* COMMENT_0 */\n  *VAR_0 = NULL;\n  /* COMMENT_1 */\n  VAR_2 = VAR_1->free_list;\n  while (VAR_2 != NULL) {\n    VAR_1->free_list = VAR_2->next;\n    /* COMMENT_2 */\n    if (VAR_1->log_callback_func) {\n      snprintf(VAR_4, sizeof(VAR_4), VAR_3, (void *)VAR_1,\n               (void *)VAR_2, VAR_1->mempool_item_size);\n      VAR_1->log_callback_func(VAR_7, VAR_4);\n    }\n    free(VAR_2);\n#if 0\n    /* COMMENT_3 */\n    VAR_1->total_bufs_allocated_by_pool--;\n    VAR_1->free_bufs_in_pool--;\n#endif\n    VAR_2 = VAR_1->free_list;\n  }\n  VAR_1->free_list = NULL;\n\n  /* COMMENT_4 */\n                                                         \n     \n  /* COMMENT_7 */\n  /* COMMENT_8 */\n                                                    \n                                             \n                                         \n    \n\n  if ((VAR_1->flags & VAR_6) != 0) {\n    pthread_mutex_unlock(&VAR_1->lock);\n    pthread_mutex_destroy(&VAR_1->lock);\n  }\n\n  free(VAR_1);\n  VAR_1 = NULL;\n  return 0;\n}",
  "func_graph_path": "Seagate/cortx-s3server/23882c427837ee988a60201c5d09a5e91e19b2d7/s3_memory_pool.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,9 @@\n   }\n \n   if (*handle == NULL) {\n+    if ((pool->flags & ENABLE_LOCKING) != 0) {\n+      pthread_mutex_unlock(&pool->lock);\n+    }\n     return S3_MEMPOOL_INVALID_ARG;\n   }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if ((pool->flags & ENABLE_LOCKING) != 0) {",
      "      pthread_mutex_unlock(&pool->lock);",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Seagate/cortx-s3server/pull/1041",
  "description": {
    "pr_info": {
      "title": "avoid the unrelesed lock after the method returns for issue#1037",
      "number": 1041
    },
    "comment": [
      "Update s3_memory_pool.c. Avoid the unreleased lock pool->lock after the method returns. This patch for issue#1037.",
      "Thanks for your contribution!\nThe CLA bot has flagged your contribution as not having a Contributor License Agreement\nin place.  Note that this is not needed in the overwhelming majority of instances and this warning will usually be ignored.\nThe code reviewers will make a determination and may ask you to sign a CLA or may choose to ignore this warning.\nMore information about this can be found [here](https://github.com/Seagate/cortx/blob/master/doc/dco_cla.md).",
      "Can one of the admins verify this patch?",
      "Thanks for your contribution!\nThe CLA bot has flagged your contribution as not having a Contributor License Agreement\nin place.  Note that this is not needed in the overwhelming majority of instances and this warning will usually be ignored.\nThe code reviewers will make a determination and may ask you to sign a CLA or may choose to ignore this warning.\nMore information about this can be found [here](https://github.com/Seagate/cortx/blob/master/doc/dco_cla.md).",
      "Thanks for your contribution to CORTX! :tada:\n \n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an issue where a lock was not being released, which could lead to a deadlock, affecting system availability. This is a security concern as it could result in a denial of service.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}