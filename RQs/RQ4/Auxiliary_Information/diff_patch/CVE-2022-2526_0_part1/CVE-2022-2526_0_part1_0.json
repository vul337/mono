{
  "cve_id": "CVE-2022-2526",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "systemd",
  "commit_msg": "resolved: pin stream while calling callbacks for it\n\nThese callbacks might unref the stream, but we still have to access it,\nlet's hence ref it explicitly.\n\nMaybe fixes: #10725",
  "commit_hash": "d973d94dec349fb676fdd844f6fe2ada3538f27c",
  "git_url": "https://github.com/systemd/systemd/commit/d973d94dec349fb676fdd844f6fe2ada3538f27c",
  "file_path": "src/resolve/resolved-dns-stream.c",
  "func_name": "on_stream_io",
  "func_before": "static int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) {\n        DnsStream *s = userdata;\n        int r;\n\n        assert(s);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                r = dnstls_stream_on_io(s, revents);\n                if (r == DNSTLS_STREAM_CLOSED)\n                        return 0;\n                if (r == -EAGAIN)\n                        return dns_stream_update_io(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n\n                r = dns_stream_update_io(s);\n                if (r < 0)\n                        return r;\n        }\n#endif\n\n        /* only identify after connecting */\n        if (s->tfo_salen == 0) {\n                r = dns_stream_identify(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n        }\n\n        if ((revents & EPOLLOUT) &&\n            s->write_packet &&\n            s->n_written < sizeof(s->write_size) + s->write_packet->size) {\n\n                struct iovec iov[2];\n                ssize_t ss;\n\n                iov[0] = IOVEC_MAKE(&s->write_size, sizeof(s->write_size));\n                iov[1] = IOVEC_MAKE(DNS_PACKET_DATA(s->write_packet), s->write_packet->size);\n\n                IOVEC_INCREMENT(iov, 2, s->n_written);\n\n                ss = dns_stream_writev(s, iov, 2, 0);\n                if (ss < 0) {\n                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                return dns_stream_complete(s, -ss);\n                } else\n                        s->n_written += ss;\n\n                /* Are we done? If so, disable the event source for EPOLLOUT */\n                if (s->n_written >= sizeof(s->write_size) + s->write_packet->size) {\n                        r = dns_stream_update_io(s);\n                        if (r < 0)\n                                return dns_stream_complete(s, -r);\n                }\n        }\n\n        if ((revents & (EPOLLIN|EPOLLHUP|EPOLLRDHUP)) &&\n            (!s->read_packet ||\n             s->n_read < sizeof(s->read_size) + s->read_packet->size)) {\n\n                if (s->n_read < sizeof(s->read_size)) {\n                        ssize_t ss;\n\n                        ss = dns_stream_read(s, (uint8_t*) &s->read_size + s->n_read, sizeof(s->read_size) - s->n_read);\n                        if (ss < 0) {\n                                if (!IN_SET(-ss, EINTR, EAGAIN))\n                                        return dns_stream_complete(s, -ss);\n                        } else if (ss == 0)\n                                return dns_stream_complete(s, ECONNRESET);\n                        else\n                                s->n_read += ss;\n                }\n\n                if (s->n_read >= sizeof(s->read_size)) {\n\n                        if (be16toh(s->read_size) < DNS_PACKET_HEADER_SIZE)\n                                return dns_stream_complete(s, EBADMSG);\n\n                        if (s->n_read < sizeof(s->read_size) + be16toh(s->read_size)) {\n                                ssize_t ss;\n\n                                if (!s->read_packet) {\n                                        r = dns_packet_new(&s->read_packet, s->protocol, be16toh(s->read_size), DNS_PACKET_SIZE_MAX);\n                                        if (r < 0)\n                                                return dns_stream_complete(s, -r);\n\n                                        s->read_packet->size = be16toh(s->read_size);\n                                        s->read_packet->ipproto = IPPROTO_TCP;\n                                        s->read_packet->family = s->peer.sa.sa_family;\n                                        s->read_packet->ttl = s->ttl;\n                                        s->read_packet->ifindex = s->ifindex;\n\n                                        if (s->read_packet->family == AF_INET) {\n                                                s->read_packet->sender.in = s->peer.in.sin_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in.sin_port);\n                                                s->read_packet->destination.in = s->local.in.sin_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in.sin_port);\n                                        } else {\n                                                assert(s->read_packet->family == AF_INET6);\n                                                s->read_packet->sender.in6 = s->peer.in6.sin6_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in6.sin6_port);\n                                                s->read_packet->destination.in6 = s->local.in6.sin6_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in6.sin6_port);\n\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->peer.in6.sin6_scope_id;\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->local.in6.sin6_scope_id;\n                                        }\n                                }\n\n                                ss = dns_stream_read(s,\n                                          (uint8_t*) DNS_PACKET_DATA(s->read_packet) + s->n_read - sizeof(s->read_size),\n                                          sizeof(s->read_size) + be16toh(s->read_size) - s->n_read);\n                                if (ss < 0) {\n                                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                                return dns_stream_complete(s, -ss);\n                                } else if (ss == 0)\n                                        return dns_stream_complete(s, ECONNRESET);\n                                else\n                                        s->n_read += ss;\n                        }\n\n                        /* Are we done? If so, disable the event source for EPOLLIN */\n                        if (s->n_read >= sizeof(s->read_size) + be16toh(s->read_size)) {\n                                /* If there's a packet handler\n                                 * installed, call that. Note that\n                                 * this is optional... */\n                                if (s->on_packet) {\n                                        r = s->on_packet(s);\n                                        if (r < 0)\n                                                return r;\n                                }\n\n                                r = dns_stream_update_io(s);\n                                if (r < 0)\n                                        return dns_stream_complete(s, -r);\n                        }\n                }\n        }\n\n        if ((s->write_packet && s->n_written >= sizeof(s->write_size) + s->write_packet->size) &&\n            (s->read_packet && s->n_read >= sizeof(s->read_size) + s->read_packet->size))\n                return dns_stream_complete(s, 0);\n\n        return 0;\n}",
  "abstract_func_before": "static int on_stream_io(sd_event_source *VAR_0, int VAR_1, uint32_t VAR_2, void *VAR_3) {\n        DnsStream *VAR_4 = VAR_3;\n        int VAR_5;\n\n        assert(VAR_4);\n\n#if VAR_6\n        if (VAR_4->encrypted) {\n                VAR_5 = dnstls_stream_on_io(VAR_4, VAR_2);\n                if (VAR_5 == VAR_7)\n                        return 0;\n                if (VAR_5 == -VAR_8)\n                        return dns_stream_update_io(VAR_4);\n                if (VAR_5 < 0)\n                        return dns_stream_complete(VAR_4, -VAR_5);\n\n                VAR_5 = dns_stream_update_io(VAR_4);\n                if (VAR_5 < 0)\n                        return VAR_5;\n        }\n#endif\n\n        /* COMMENT_0 */\n        if (VAR_4->tfo_salen == 0) {\n                VAR_5 = dns_stream_identify(VAR_4);\n                if (VAR_5 < 0)\n                        return dns_stream_complete(VAR_4, -VAR_5);\n        }\n\n        if ((VAR_2 & VAR_9) &&\n            VAR_4->write_packet &&\n            VAR_4->n_written < sizeof(VAR_4->write_size) + VAR_4->write_packet->size) {\n\n                struct iovec VAR_10[2];\n                ssize_t VAR_11;\n\n                VAR_10[0] = IOVEC_MAKE(&VAR_4->write_size, sizeof(VAR_4->write_size));\n                VAR_10[1] = IOVEC_MAKE(DNS_PACKET_DATA(VAR_4->write_packet), VAR_4->write_packet->size);\n\n                IOVEC_INCREMENT(VAR_10, 2, VAR_4->n_written);\n\n                VAR_11 = dns_stream_writev(VAR_4, VAR_10, 2, 0);\n                if (VAR_11 < 0) {\n                        if (!IN_SET(-VAR_11, VAR_12, VAR_8))\n                                return dns_stream_complete(VAR_4, -VAR_11);\n                } else\n                        VAR_4->n_written += VAR_11;\n\n                /* COMMENT_1 */\n                if (VAR_4->n_written >= sizeof(VAR_4->write_size) + VAR_4->write_packet->size) {\n                        VAR_5 = dns_stream_update_io(VAR_4);\n                        if (VAR_5 < 0)\n                                return dns_stream_complete(VAR_4, -VAR_5);\n                }\n        }\n\n        if ((VAR_2 & (VAR_13|VAR_14|VAR_15)) &&\n            (!VAR_4->read_packet ||\n             VAR_4->n_read < sizeof(VAR_4->read_size) + VAR_4->read_packet->size)) {\n\n                if (VAR_4->n_read < sizeof(VAR_4->read_size)) {\n                        ssize_t VAR_11;\n\n                        VAR_11 = dns_stream_read(VAR_4, (uint8_t*) &VAR_4->read_size + VAR_4->n_read, sizeof(VAR_4->read_size) - VAR_4->n_read);\n                        if (VAR_11 < 0) {\n                                if (!IN_SET(-VAR_11, VAR_12, VAR_8))\n                                        return dns_stream_complete(VAR_4, -VAR_11);\n                        } else if (VAR_11 == 0)\n                                return dns_stream_complete(VAR_4, VAR_16);\n                        else\n                                VAR_4->n_read += VAR_11;\n                }\n\n                if (VAR_4->n_read >= sizeof(VAR_4->read_size)) {\n\n                        if (be16toh(VAR_4->read_size) < VAR_17)\n                                return dns_stream_complete(VAR_4, VAR_18);\n\n                        if (VAR_4->n_read < sizeof(VAR_4->read_size) + be16toh(VAR_4->read_size)) {\n                                ssize_t VAR_11;\n\n                                if (!VAR_4->read_packet) {\n                                        VAR_5 = dns_packet_new(&VAR_4->read_packet, VAR_4->protocol, be16toh(VAR_4->read_size), VAR_19);\n                                        if (VAR_5 < 0)\n                                                return dns_stream_complete(VAR_4, -VAR_5);\n\n                                        VAR_4->read_packet->size = be16toh(VAR_4->read_size);\n                                        VAR_4->read_packet->ipproto = VAR_20;\n                                        VAR_4->read_packet->family = VAR_4->peer.sa.sa_family;\n                                        VAR_4->read_packet->ttl = VAR_4->ttl;\n                                        VAR_4->read_packet->ifindex = VAR_4->ifindex;\n\n                                        if (VAR_4->read_packet->family == VAR_21) {\n                                                VAR_4->read_packet->sender.in = VAR_4->peer.in.sin_addr;\n                                                VAR_4->read_packet->sender_port = be16toh(VAR_4->peer.in.sin_port);\n                                                VAR_4->read_packet->destination.in = VAR_4->local.in.sin_addr;\n                                                VAR_4->read_packet->destination_port = be16toh(VAR_4->local.in.sin_port);\n                                        } else {\n                                                assert(VAR_4->read_packet->family == VAR_22);\n                                                VAR_4->read_packet->sender.in6 = VAR_4->peer.in6.sin6_addr;\n                                                VAR_4->read_packet->sender_port = be16toh(VAR_4->peer.in6.sin6_port);\n                                                VAR_4->read_packet->destination.in6 = VAR_4->local.in6.sin6_addr;\n                                                VAR_4->read_packet->destination_port = be16toh(VAR_4->local.in6.sin6_port);\n\n                                                if (VAR_4->read_packet->ifindex == 0)\n                                                        VAR_4->read_packet->ifindex = VAR_4->peer.in6.sin6_scope_id;\n                                                if (VAR_4->read_packet->ifindex == 0)\n                                                        VAR_4->read_packet->ifindex = VAR_4->local.in6.sin6_scope_id;\n                                        }\n                                }\n\n                                VAR_11 = dns_stream_read(VAR_4,\n                                          (uint8_t*) DNS_PACKET_DATA(VAR_4->read_packet) + VAR_4->n_read - sizeof(VAR_4->read_size),\n                                          sizeof(VAR_4->read_size) + be16toh(VAR_4->read_size) - VAR_4->n_read);\n                                if (VAR_11 < 0) {\n                                        if (!IN_SET(-VAR_11, VAR_12, VAR_8))\n                                                return dns_stream_complete(VAR_4, -VAR_11);\n                                } else if (VAR_11 == 0)\n                                        return dns_stream_complete(VAR_4, VAR_16);\n                                else\n                                        VAR_4->n_read += VAR_11;\n                        }\n\n                        /* COMMENT_2 */\n                        if (VAR_4->n_read >= sizeof(VAR_4->read_size) + be16toh(VAR_4->read_size)) {\n                                /* COMMENT_3 */\n                                                                  \n                                                         \n                                if (VAR_4->on_packet) {\n                                        VAR_5 = VAR_4->on_packet(VAR_4);\n                                        if (VAR_5 < 0)\n                                                return VAR_5;\n                                }\n\n                                VAR_5 = dns_stream_update_io(VAR_4);\n                                if (VAR_5 < 0)\n                                        return dns_stream_complete(VAR_4, -VAR_5);\n                        }\n                }\n        }\n\n        if ((VAR_4->write_packet && VAR_4->n_written >= sizeof(VAR_4->write_size) + VAR_4->write_packet->size) &&\n            (VAR_4->read_packet && VAR_4->n_read >= sizeof(VAR_4->read_size) + VAR_4->read_packet->size))\n                return dns_stream_complete(VAR_4, 0);\n\n        return 0;\n}",
  "func_graph_path_before": "systemd/d973d94dec349fb676fdd844f6fe2ada3538f27c/resolved-dns-stream.c/vul/before/1.json",
  "func": "static int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) {\n        _cleanup_(dns_stream_unrefp) DnsStream *s = dns_stream_ref(userdata); /* Protect stream while we process it */\n        int r;\n\n        assert(s);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                r = dnstls_stream_on_io(s, revents);\n                if (r == DNSTLS_STREAM_CLOSED)\n                        return 0;\n                if (r == -EAGAIN)\n                        return dns_stream_update_io(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n\n                r = dns_stream_update_io(s);\n                if (r < 0)\n                        return r;\n        }\n#endif\n\n        /* only identify after connecting */\n        if (s->tfo_salen == 0) {\n                r = dns_stream_identify(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n        }\n\n        if ((revents & EPOLLOUT) &&\n            s->write_packet &&\n            s->n_written < sizeof(s->write_size) + s->write_packet->size) {\n\n                struct iovec iov[2];\n                ssize_t ss;\n\n                iov[0] = IOVEC_MAKE(&s->write_size, sizeof(s->write_size));\n                iov[1] = IOVEC_MAKE(DNS_PACKET_DATA(s->write_packet), s->write_packet->size);\n\n                IOVEC_INCREMENT(iov, 2, s->n_written);\n\n                ss = dns_stream_writev(s, iov, 2, 0);\n                if (ss < 0) {\n                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                return dns_stream_complete(s, -ss);\n                } else\n                        s->n_written += ss;\n\n                /* Are we done? If so, disable the event source for EPOLLOUT */\n                if (s->n_written >= sizeof(s->write_size) + s->write_packet->size) {\n                        r = dns_stream_update_io(s);\n                        if (r < 0)\n                                return dns_stream_complete(s, -r);\n                }\n        }\n\n        if ((revents & (EPOLLIN|EPOLLHUP|EPOLLRDHUP)) &&\n            (!s->read_packet ||\n             s->n_read < sizeof(s->read_size) + s->read_packet->size)) {\n\n                if (s->n_read < sizeof(s->read_size)) {\n                        ssize_t ss;\n\n                        ss = dns_stream_read(s, (uint8_t*) &s->read_size + s->n_read, sizeof(s->read_size) - s->n_read);\n                        if (ss < 0) {\n                                if (!IN_SET(-ss, EINTR, EAGAIN))\n                                        return dns_stream_complete(s, -ss);\n                        } else if (ss == 0)\n                                return dns_stream_complete(s, ECONNRESET);\n                        else\n                                s->n_read += ss;\n                }\n\n                if (s->n_read >= sizeof(s->read_size)) {\n\n                        if (be16toh(s->read_size) < DNS_PACKET_HEADER_SIZE)\n                                return dns_stream_complete(s, EBADMSG);\n\n                        if (s->n_read < sizeof(s->read_size) + be16toh(s->read_size)) {\n                                ssize_t ss;\n\n                                if (!s->read_packet) {\n                                        r = dns_packet_new(&s->read_packet, s->protocol, be16toh(s->read_size), DNS_PACKET_SIZE_MAX);\n                                        if (r < 0)\n                                                return dns_stream_complete(s, -r);\n\n                                        s->read_packet->size = be16toh(s->read_size);\n                                        s->read_packet->ipproto = IPPROTO_TCP;\n                                        s->read_packet->family = s->peer.sa.sa_family;\n                                        s->read_packet->ttl = s->ttl;\n                                        s->read_packet->ifindex = s->ifindex;\n\n                                        if (s->read_packet->family == AF_INET) {\n                                                s->read_packet->sender.in = s->peer.in.sin_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in.sin_port);\n                                                s->read_packet->destination.in = s->local.in.sin_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in.sin_port);\n                                        } else {\n                                                assert(s->read_packet->family == AF_INET6);\n                                                s->read_packet->sender.in6 = s->peer.in6.sin6_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in6.sin6_port);\n                                                s->read_packet->destination.in6 = s->local.in6.sin6_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in6.sin6_port);\n\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->peer.in6.sin6_scope_id;\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->local.in6.sin6_scope_id;\n                                        }\n                                }\n\n                                ss = dns_stream_read(s,\n                                          (uint8_t*) DNS_PACKET_DATA(s->read_packet) + s->n_read - sizeof(s->read_size),\n                                          sizeof(s->read_size) + be16toh(s->read_size) - s->n_read);\n                                if (ss < 0) {\n                                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                                return dns_stream_complete(s, -ss);\n                                } else if (ss == 0)\n                                        return dns_stream_complete(s, ECONNRESET);\n                                else\n                                        s->n_read += ss;\n                        }\n\n                        /* Are we done? If so, disable the event source for EPOLLIN */\n                        if (s->n_read >= sizeof(s->read_size) + be16toh(s->read_size)) {\n                                /* If there's a packet handler\n                                 * installed, call that. Note that\n                                 * this is optional... */\n                                if (s->on_packet) {\n                                        r = s->on_packet(s);\n                                        if (r < 0)\n                                                return r;\n                                }\n\n                                r = dns_stream_update_io(s);\n                                if (r < 0)\n                                        return dns_stream_complete(s, -r);\n                        }\n                }\n        }\n\n        if ((s->write_packet && s->n_written >= sizeof(s->write_size) + s->write_packet->size) &&\n            (s->read_packet && s->n_read >= sizeof(s->read_size) + s->read_packet->size))\n                return dns_stream_complete(s, 0);\n\n        return 0;\n}",
  "abstract_func": "static int on_stream_io(sd_event_source *VAR_0, int VAR_1, uint32_t VAR_2, void *VAR_3) {\n        VAR_4(dns_stream_unrefp) VAR_5 *VAR_6 = dns_stream_ref(VAR_3); /* COMMENT_0 */\n        int VAR_7;\n\n        assert(VAR_6);\n\n#if VAR_8\n        if (VAR_6->encrypted) {\n                VAR_7 = dnstls_stream_on_io(VAR_6, VAR_2);\n                if (VAR_7 == VAR_9)\n                        return 0;\n                if (VAR_7 == -VAR_10)\n                        return dns_stream_update_io(VAR_6);\n                if (VAR_7 < 0)\n                        return dns_stream_complete(VAR_6, -VAR_7);\n\n                VAR_7 = dns_stream_update_io(VAR_6);\n                if (VAR_7 < 0)\n                        return VAR_7;\n        }\n#endif\n\n        /* COMMENT_1 */\n        if (VAR_6->tfo_salen == 0) {\n                VAR_7 = dns_stream_identify(VAR_6);\n                if (VAR_7 < 0)\n                        return dns_stream_complete(VAR_6, -VAR_7);\n        }\n\n        if ((VAR_2 & VAR_11) &&\n            VAR_6->write_packet &&\n            VAR_6->n_written < sizeof(VAR_6->write_size) + VAR_6->write_packet->size) {\n\n                struct iovec VAR_12[2];\n                ssize_t VAR_13;\n\n                VAR_12[0] = IOVEC_MAKE(&VAR_6->write_size, sizeof(VAR_6->write_size));\n                VAR_12[1] = IOVEC_MAKE(DNS_PACKET_DATA(VAR_6->write_packet), VAR_6->write_packet->size);\n\n                IOVEC_INCREMENT(VAR_12, 2, VAR_6->n_written);\n\n                VAR_13 = dns_stream_writev(VAR_6, VAR_12, 2, 0);\n                if (VAR_13 < 0) {\n                        if (!IN_SET(-VAR_13, VAR_14, VAR_10))\n                                return dns_stream_complete(VAR_6, -VAR_13);\n                } else\n                        VAR_6->n_written += VAR_13;\n\n                /* COMMENT_2 */\n                if (VAR_6->n_written >= sizeof(VAR_6->write_size) + VAR_6->write_packet->size) {\n                        VAR_7 = dns_stream_update_io(VAR_6);\n                        if (VAR_7 < 0)\n                                return dns_stream_complete(VAR_6, -VAR_7);\n                }\n        }\n\n        if ((VAR_2 & (VAR_15|VAR_16|VAR_17)) &&\n            (!VAR_6->read_packet ||\n             VAR_6->n_read < sizeof(VAR_6->read_size) + VAR_6->read_packet->size)) {\n\n                if (VAR_6->n_read < sizeof(VAR_6->read_size)) {\n                        ssize_t VAR_13;\n\n                        VAR_13 = dns_stream_read(VAR_6, (uint8_t*) &VAR_6->read_size + VAR_6->n_read, sizeof(VAR_6->read_size) - VAR_6->n_read);\n                        if (VAR_13 < 0) {\n                                if (!IN_SET(-VAR_13, VAR_14, VAR_10))\n                                        return dns_stream_complete(VAR_6, -VAR_13);\n                        } else if (VAR_13 == 0)\n                                return dns_stream_complete(VAR_6, VAR_18);\n                        else\n                                VAR_6->n_read += VAR_13;\n                }\n\n                if (VAR_6->n_read >= sizeof(VAR_6->read_size)) {\n\n                        if (be16toh(VAR_6->read_size) < VAR_19)\n                                return dns_stream_complete(VAR_6, VAR_20);\n\n                        if (VAR_6->n_read < sizeof(VAR_6->read_size) + be16toh(VAR_6->read_size)) {\n                                ssize_t VAR_13;\n\n                                if (!VAR_6->read_packet) {\n                                        VAR_7 = dns_packet_new(&VAR_6->read_packet, VAR_6->protocol, be16toh(VAR_6->read_size), VAR_21);\n                                        if (VAR_7 < 0)\n                                                return dns_stream_complete(VAR_6, -VAR_7);\n\n                                        VAR_6->read_packet->size = be16toh(VAR_6->read_size);\n                                        VAR_6->read_packet->ipproto = VAR_22;\n                                        VAR_6->read_packet->family = VAR_6->peer.sa.sa_family;\n                                        VAR_6->read_packet->ttl = VAR_6->ttl;\n                                        VAR_6->read_packet->ifindex = VAR_6->ifindex;\n\n                                        if (VAR_6->read_packet->family == VAR_23) {\n                                                VAR_6->read_packet->sender.in = VAR_6->peer.in.sin_addr;\n                                                VAR_6->read_packet->sender_port = be16toh(VAR_6->peer.in.sin_port);\n                                                VAR_6->read_packet->destination.in = VAR_6->local.in.sin_addr;\n                                                VAR_6->read_packet->destination_port = be16toh(VAR_6->local.in.sin_port);\n                                        } else {\n                                                assert(VAR_6->read_packet->family == VAR_24);\n                                                VAR_6->read_packet->sender.in6 = VAR_6->peer.in6.sin6_addr;\n                                                VAR_6->read_packet->sender_port = be16toh(VAR_6->peer.in6.sin6_port);\n                                                VAR_6->read_packet->destination.in6 = VAR_6->local.in6.sin6_addr;\n                                                VAR_6->read_packet->destination_port = be16toh(VAR_6->local.in6.sin6_port);\n\n                                                if (VAR_6->read_packet->ifindex == 0)\n                                                        VAR_6->read_packet->ifindex = VAR_6->peer.in6.sin6_scope_id;\n                                                if (VAR_6->read_packet->ifindex == 0)\n                                                        VAR_6->read_packet->ifindex = VAR_6->local.in6.sin6_scope_id;\n                                        }\n                                }\n\n                                VAR_13 = dns_stream_read(VAR_6,\n                                          (uint8_t*) DNS_PACKET_DATA(VAR_6->read_packet) + VAR_6->n_read - sizeof(VAR_6->read_size),\n                                          sizeof(VAR_6->read_size) + be16toh(VAR_6->read_size) - VAR_6->n_read);\n                                if (VAR_13 < 0) {\n                                        if (!IN_SET(-VAR_13, VAR_14, VAR_10))\n                                                return dns_stream_complete(VAR_6, -VAR_13);\n                                } else if (VAR_13 == 0)\n                                        return dns_stream_complete(VAR_6, VAR_18);\n                                else\n                                        VAR_6->n_read += VAR_13;\n                        }\n\n                        /* COMMENT_3 */\n                        if (VAR_6->n_read >= sizeof(VAR_6->read_size) + be16toh(VAR_6->read_size)) {\n                                /* COMMENT_4 */\n                                                                  \n                                                         \n                                if (VAR_6->on_packet) {\n                                        VAR_7 = VAR_6->on_packet(VAR_6);\n                                        if (VAR_7 < 0)\n                                                return VAR_7;\n                                }\n\n                                VAR_7 = dns_stream_update_io(VAR_6);\n                                if (VAR_7 < 0)\n                                        return dns_stream_complete(VAR_6, -VAR_7);\n                        }\n                }\n        }\n\n        if ((VAR_6->write_packet && VAR_6->n_written >= sizeof(VAR_6->write_size) + VAR_6->write_packet->size) &&\n            (VAR_6->read_packet && VAR_6->n_read >= sizeof(VAR_6->read_size) + VAR_6->read_packet->size))\n                return dns_stream_complete(VAR_6, 0);\n\n        return 0;\n}",
  "func_graph_path": "systemd/d973d94dec349fb676fdd844f6fe2ada3538f27c/resolved-dns-stream.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) {\n-        DnsStream *s = userdata;\n+        _cleanup_(dns_stream_unrefp) DnsStream *s = dns_stream_ref(userdata); /* Protect stream while we process it */\n         int r;\n \n         assert(s);",
  "diff_line_info": {
    "deleted_lines": [
      "        DnsStream *s = userdata;"
    ],
    "added_lines": [
      "        _cleanup_(dns_stream_unrefp) DnsStream *s = dns_stream_ref(userdata); /* Protect stream while we process it */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/systemd/systemd/pull/11055",
  "description": {
    "pr_info": {
      "title": "a number of resolved fixes",
      "number": 11055
    },
    "comment": [
      "I was trying to figure out the cause of #10725 and found some memory corruption issues, which this PR fixes. So I am pretty sure this fixes #10725, but not entirely... Still sure enough to say this:\r\n\r\nFixes: #10725 \r\n\r\nSome testing would be useful, in particular if #10725 can be reproduced somehow (I couldn't). \r\n\r\nMaybe @irtimmer (as the original author of the DNS-over-TLS code), any chance you can have a look at these, if these make sense to you?",
      "travis-ci fails with the following error:\r\n```\r\n../src/resolve/resolved-dns-stream.c:52:49: error: unused variable 'ref' [-Werror,-Wunused-variable]\r\n        _cleanup_(dns_stream_unrefp) DnsStream *ref = dns_stream_ref(s); /* Protect stream while we process it */\r\n                                                ^\r\n1 error generated.\r\n```\r\nPlease add `_unused_` attribute.\r\n\r\nBTW, changes seem to be reasonable.",
      "Force pushed a new version with `_unused_` added. No other changes.",
      "Taking liberty to make this with the green label, given that @yuwata found these changes \"reasonable\" ;-)"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a bug where improper reference counting could lead to accessing a freed object, causing crashes. This is a functional bug fix rather than a security vulnerability.\n\n**Final Output:**\nAnalysis: The patch fixes a bug related to stream reference counting, preventing crashes due to accessing freed objects. It doesn't address a security exploit.\n\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.95"
}