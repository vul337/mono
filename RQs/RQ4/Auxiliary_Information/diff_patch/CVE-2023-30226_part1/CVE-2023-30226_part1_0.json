{
  "cve_id": "CVE-2023-30226",
  "cwe_ids": [
    "CWE-834"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "rizinorg/rizin",
  "commit_msg": "ELF: added vn_next break condition (#3214)\n\nif the dynamic section's verneednum mismatches the true number of entries then the for loop in get_gnu_verneed will continue to iterate on the last entry since vn_next will be 0 on the last entry. If verneednum is set to all 0xff's it will take a very long time to finish this loop naturally drastically hindering binary load time. The solution is simple, to check for when vn_next == 0 and break out of the loop since all entries have been iterated over regardless of what verneednum indicates.",
  "commit_hash": "a6d89de0d44e776f9bccc3a168fdc79f604e14ed",
  "git_url": "https://github.com/rizinorg/rizin/commit/a6d89de0d44e776f9bccc3a168fdc79f604e14ed",
  "file_path": "librz/bin/format/elf/elf_info.c",
  "func_name": "get_gnu_verneed",
  "func_before": "static Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(sdb_version);\n\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\n\treturn sdb;\n}",
  "abstract_func_before": "static Sdb *get_gnu_verneed(ELFOBJ *VAR_0) {\n\tut64 VAR_1;\n\tut64 VAR_2;\n\n\tif (!Elf_(VAR_3)(VAR_0, VAR_4, &VAR_1) || !Elf_(VAR_3)(VAR_0, VAR_5, &VAR_2)) {\n\t\treturn NULL;\n\t}\n\n\tut64 VAR_6 = Elf_(rz_bin_elf_v2p(VAR_0, VAR_1));\n\tif (VAR_6 == VAR_7) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\n\tSdb *VAR_8 = sdb_new0();\n\tif (!VAR_8) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(VAR_8, \"num_entries\", VAR_2, 0) ||\n\t\t!sdb_num_set(VAR_8, \"addr\", VAR_1, 0) ||\n\t\t!sdb_num_set(VAR_8, \"offset\", VAR_6, 0)) {\n\t\tsdb_free(VAR_8);\n\t\treturn NULL;\n\t}\n\n\tfor (size_t VAR_9 = 0; VAR_9 < VAR_2; VAR_9++) {\n\t\tVAR_10(Verneed) VAR_11;\n\t\tif (!get_verneed_entry(VAR_0, VAR_6, &VAR_11)) {\n\t\t\tsdb_free(VAR_8);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *VAR_12 = get_verneed_entry_sdb(VAR_0, VAR_11, VAR_6);\n\t\tif (!VAR_12) {\n\t\t\tsdb_free(VAR_8);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar VAR_13[32];\n\t\tif (!sdb_ns_set(VAR_8, rz_strf(VAR_13, \"version%zu\", VAR_9), VAR_12)) {\n\t\t\tsdb_free(VAR_12);\n\t\t\tsdb_free(VAR_8);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(VAR_12);\n\n\t\tVAR_6 += VAR_11.vn_next;\n\t}\n\n\treturn VAR_8;\n}",
  "func_graph_path_before": "rizinorg/rizin/a6d89de0d44e776f9bccc3a168fdc79f604e14ed/elf_info.c/vul/before/0.json",
  "func": "static Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(sdb_version);\n\n\t\tif (!verneed_entry.vn_next) {\n\t\t\tbreak;\n\t\t}\n\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\n\treturn sdb;\n}",
  "abstract_func": "static Sdb *get_gnu_verneed(ELFOBJ *VAR_0) {\n\tut64 VAR_1;\n\tut64 VAR_2;\n\n\tif (!Elf_(VAR_3)(VAR_0, VAR_4, &VAR_1) || !Elf_(VAR_3)(VAR_0, VAR_5, &VAR_2)) {\n\t\treturn NULL;\n\t}\n\n\tut64 VAR_6 = Elf_(rz_bin_elf_v2p(VAR_0, VAR_1));\n\tif (VAR_6 == VAR_7) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\n\tSdb *VAR_8 = sdb_new0();\n\tif (!VAR_8) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(VAR_8, \"num_entries\", VAR_2, 0) ||\n\t\t!sdb_num_set(VAR_8, \"addr\", VAR_1, 0) ||\n\t\t!sdb_num_set(VAR_8, \"offset\", VAR_6, 0)) {\n\t\tsdb_free(VAR_8);\n\t\treturn NULL;\n\t}\n\n\tfor (size_t VAR_9 = 0; VAR_9 < VAR_2; VAR_9++) {\n\t\tVAR_10(Verneed) VAR_11;\n\t\tif (!get_verneed_entry(VAR_0, VAR_6, &VAR_11)) {\n\t\t\tsdb_free(VAR_8);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *VAR_12 = get_verneed_entry_sdb(VAR_0, VAR_11, VAR_6);\n\t\tif (!VAR_12) {\n\t\t\tsdb_free(VAR_8);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar VAR_13[32];\n\t\tif (!sdb_ns_set(VAR_8, rz_strf(VAR_13, \"version%zu\", VAR_9), VAR_12)) {\n\t\t\tsdb_free(VAR_12);\n\t\t\tsdb_free(VAR_8);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(VAR_12);\n\n\t\tif (!VAR_11.vn_next) {\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_6 += VAR_11.vn_next;\n\t}\n\n\treturn VAR_8;\n}",
  "func_graph_path": "rizinorg/rizin/a6d89de0d44e776f9bccc3a168fdc79f604e14ed/elf_info.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -46,6 +46,10 @@\n \n \t\tsdb_free(sdb_version);\n \n+\t\tif (!verneed_entry.vn_next) {\n+\t\t\tbreak;\n+\t\t}\n+\n \t\tverneed_offset += verneed_entry.vn_next;\n \t}\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\tif (!verneed_entry.vn_next) {",
      "\t\t\tbreak;",
      "\t\t}",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rizinorg/rizin/pull/3214",
  "description": {
    "pr_info": {
      "title": "added vn_next break condition",
      "number": 3214
    },
    "comment": [
      "**Your checklist for this pull request**\r\n- [x] I've read the [guidelines for contributing](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md) to this repository\r\n- [x] I made sure to follow the project's [coding style](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md#code-style)\r\n- [ ] I've documented or updated the documentation of every function and struct this PR changes. If not so I've explained why.\r\n- [ ] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the [rizin book](https://github.com/rizinorg/book) with the relevant information (if needed)\r\n\r\n**Detailed description**\r\n\r\nif the dynamic section's verneednum mismatches the true number of entries then the for loop in get_gnu_verneed will continue to iterate on the last entry since vn_next will be 0 on the last entry. If verneednum is set to all 0xff's it will take a very long time to finish this loop naturally drastically hindering binary load time. The solution is simple, to check for when vn_next == 0 and break out of the loop since all entries have been iterated over regardless of what verneednum indicates.\r\n\r\n**Test plan**\r\n\r\nCopy a binary, /bin/ls, to a test location\r\nUse readelf -d to get the offset into the file for the dynamic section\r\nHex edit verneednum to all 0xff's\r\nRun rizin ./testbin\r\n\r\n",
      "@ifyGecko please run `clang-format` on this code to fix the indentation."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix**\n\n**Confidence Score: 0.8**\n\nThe classification is based on the potential for the issue to be exploited, even though the commit message doesn't explicitly state an exploit. The fix prevents a DoS scenario, which is a security concern.",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch addresses a potential infinite loop in the get_gnu_verneed function, which could be exploited to cause a denial of service (DoS) by slowing down binary load times. The code change adds a break condition when vn_next is 0, preventing the loop from running indefinitely.\n\n**Final Classification: Security Vulnerability Fix**\n\n**Confidence Score: 0.8**\n\nThe classification is based on the potential for the issue to be exploited, even though the commit message doesn't explicitly state an exploit. The fix prevents a DoS scenario, which is a security concern."
}