{
  "cve_id": "CVE-2020-15350",
  "cwe_ids": [
    "CWE-119",
    "CWE-131"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "sys/base64: Use void pointer for buffers in API\n\nThis is a non-breaking change, as `unsigned char *` can implicitly be converted\nto `void *`.",
  "commit_hash": "3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303",
  "file_path": "sys/base64/base64.c",
  "func_name": "getcode",
  "func_before": "static int getcode(char symbol)\n{\n    if (symbol == '/') {\n        return BASE64_SLASH;\n    }\n\n    if (symbol == '_') {\n        return BASE64_UNDERLINE;\n    }\n\n    if (symbol == '+') {\n        return BASE64_PLUS;\n    }\n\n    if (symbol == '-') {\n        return BASE64_MINUS;\n    }\n\n    if (symbol == '=') {\n        /* indicates a padded base64 end */\n        return BASE64_EQUALS;\n    }\n\n    if (symbol < '0') {\n        /* indicates that the given symbol is not base64 and should be ignored */\n        return BASE64_NOT_DEFINED;\n    }\n\n    if (symbol <= '9' && symbol >= '0') {\n        return (symbol + (BASE64_NUMBER_UPPER_BOUND - '9'));\n    }\n\n    if (symbol <= 'Z' && symbol >= 'A') {\n        return (symbol - 'A');\n    }\n\n    if (symbol <= 'z' && symbol >= 'a') {\n        return (symbol + (BASE64_SMALL_UPPER_BOUND - 'z'));\n    }\n\n    /* indicates that the given symbol is not base64 and should be ignored */\n    return BASE64_NOT_DEFINED;\n}",
  "abstract_func_before": "static int getcode(char VAR_0)\n{\n    if (VAR_0 == '/') {\n        return VAR_1;\n    }\n\n    if (VAR_0 == '_') {\n        return VAR_2;\n    }\n\n    if (VAR_0 == '+') {\n        return VAR_3;\n    }\n\n    if (VAR_0 == '-') {\n        return VAR_4;\n    }\n\n    if (VAR_0 == '=') {\n        /* COMMENT_0 */\n        return VAR_5;\n    }\n\n    if (VAR_0 < '0') {\n        /* COMMENT_1 */\n        return VAR_6;\n    }\n\n    if (VAR_0 <= '9' && VAR_0 >= '0') {\n        return (VAR_0 + (VAR_7 - '9'));\n    }\n\n    if (VAR_0 <= 'Z' && VAR_0 >= 'A') {\n        return (VAR_0 - 'A');\n    }\n\n    if (VAR_0 <= 'z' && VAR_0 >= 'a') {\n        return (VAR_0 + (VAR_8 - 'z'));\n    }\n\n    /* COMMENT_1 */\n    return VAR_6;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303/base64.c/vul/before/3.json",
  "func": "static uint8_t getcode(char symbol)\n{\n    if (symbol == '/') {\n        return BASE64_SLASH;\n    }\n\n    if (symbol == '_') {\n        return BASE64_UNDERLINE;\n    }\n\n    if (symbol == '+') {\n        return BASE64_PLUS;\n    }\n\n    if (symbol == '-') {\n        return BASE64_MINUS;\n    }\n\n    if (symbol == '=') {\n        /* indicates a padded base64 end */\n        return BASE64_EQUALS;\n    }\n\n    if (symbol < '0') {\n        /* indicates that the given symbol is not base64 and should be ignored */\n        return BASE64_NOT_DEFINED;\n    }\n\n    if (symbol <= '9' && symbol >= '0') {\n        return (symbol + (BASE64_NUMBER_UPPER_BOUND - '9'));\n    }\n\n    if (symbol <= 'Z' && symbol >= 'A') {\n        return (symbol - 'A');\n    }\n\n    if (symbol <= 'z' && symbol >= 'a') {\n        return (symbol + (BASE64_SMALL_UPPER_BOUND - 'z'));\n    }\n\n    /* indicates that the given symbol is not base64 and should be ignored */\n    return BASE64_NOT_DEFINED;\n}",
  "abstract_func": "static uint8_t getcode(char VAR_0)\n{\n    if (VAR_0 == '/') {\n        return VAR_1;\n    }\n\n    if (VAR_0 == '_') {\n        return VAR_2;\n    }\n\n    if (VAR_0 == '+') {\n        return VAR_3;\n    }\n\n    if (VAR_0 == '-') {\n        return VAR_4;\n    }\n\n    if (VAR_0 == '=') {\n        /* COMMENT_0 */\n        return VAR_5;\n    }\n\n    if (VAR_0 < '0') {\n        /* COMMENT_1 */\n        return VAR_6;\n    }\n\n    if (VAR_0 <= '9' && VAR_0 >= '0') {\n        return (VAR_0 + (VAR_7 - '9'));\n    }\n\n    if (VAR_0 <= 'Z' && VAR_0 >= 'A') {\n        return (VAR_0 - 'A');\n    }\n\n    if (VAR_0 <= 'z' && VAR_0 >= 'a') {\n        return (VAR_0 + (VAR_8 - 'z'));\n    }\n\n    /* COMMENT_1 */\n    return VAR_6;\n}",
  "func_graph_path": "RIOT-OS/RIOT/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303/base64.c/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int getcode(char symbol)\n+static uint8_t getcode(char symbol)\n {\n     if (symbol == '/') {\n         return BASE64_SLASH;",
  "diff_line_info": {
    "deleted_lines": [
      "static int getcode(char symbol)"
    ],
    "added_lines": [
      "static uint8_t getcode(char symbol)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/14400",
  "description": {
    "pr_info": {
      "title": "sys/base64: Fix, unit test cleanup, and benchmark",
      "number": 14400
    },
    "comment": [
      "### Contribution description\r\n\r\n- Cherry-picked [@mjurczak fix](https://github.com/mjurczak/RIOT/commit/d27b048c28ceb1e3d0e0b06faa2f77965b7784d9) for the decode buffer size estimation (which could result in a buffer overflow of up to one byte note being catched)\r\n- Made using the API less pain by accepting `void` pointers for buffers (non-breaking change, as `unsigned char *` is implicitly casted to `void *`)\r\n- Cleaned up the unit test to fix basic code quality issued\r\n- Added a unit test to check the `base64_estimate_{de,en}code_size()`\r\n- Added a benchmark for base64 (this will come in useful to review a follow up PR)\r\n\r\n### Testing procedure\r\n\r\nThe unit tests should no detect an issue in `base64_estimate_{de,en}code_size()`\r\n\r\n### Issues/PRs references\r\n\r\nNone",
      "Somehow the build was previously not queued, toggling `CI: ready for build` seems to have solved the issue.",
      "Looks like the unit test will now fail\r\n\r\n> `base64_tests.test_base64_13_size_estimation (tests/unittests/tests-base64/tests-base64.c 495) exp 3 was 0`",
      "No need to run tests on hardware. The compilation tests include a run of the unit tests on the `native` board.",
      "@mjurczak: I cherry-picked your suggested fix and included it in the PR. This way, the credit for and authorship of the commits stays with you.",
      "With @mjurczak fix included, the unit tests are now passing. I updated the PR title and the description accordingly.",
      "Fixed some style issues, while we're at it.\r\n\r\n(I will let Murdock run again when I have squashed.)",
      "> Should the benchmark have an automatic test?\r\n\r\nI'm not sure what an automatic test should do. A single benchmark run will provide a raw number, that lacks context. (Or two raw numbers, one for encode and one for decode.) IMO, at least a second benchmark result from the same hardware is needed to have any meaningful information.\r\n\r\nWhat we could do (if we want to run automatic tests), is to feed a database with the raw results to see how performance changes over time. But maybe such considerations should be done independently form this PR and applied later on to all benchmarks.",
      "> I'm not sure what an automatic test should do. A single benchmark run will provide a raw number, that lacks context. (Or two raw numbers, one for encode and one for decode.) IMO, at least a second benchmark result from the same hardware is needed to have any meaningful information.\r\n> \r\n> What we could do (if we want to run automatic tests), is to feed a database with the raw results to see how performance changes over time. But maybe such considerations should be done independently form this PR and applied later on to all benchmarks.\r\n\r\nI was just thinking on the most basic check, what we do for other benches `tests/bench_xtimer/tests/01-run.py`, just a simple test that says \"the application works\". My comment comes mainly from the impression that we now ask for a `01-run.py` for new applications.",
      "> I was just thinking on the most basic check, what we do for other benches `tests/bench_xtimer/tests/01-run.py`, just a simple test that says \"the application works\".\r\n\r\nAh, OK! I added the test.",
      "Please squash @maribu and re-trigger ci.",
      "I fixed a typo in the test input detected by the static tests (and the corresponding base64) and added the missing empty line flake8 complained about. I squashed right away.",
      "Murdock likes it too.",
      "@mjurczak: Thank you very much for reporting and fixing the issue!\r\n\r\nThanks everyone for the reviews.",
      "@maribu  I'm stunned with the fast reaction. Great job everyone!"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n- The patch changes the return type of a function from `int` to `uint8_t` and adjusts pointer usage in the API. These changes are described as non-breaking and focus on internal code adjustments rather than fixing a security issue or defect.\n\nFinal Classification: Supporting & Non-Core Improvements\n\nConfidence Score: 0.9"
}