{
  "cve_id": "CVE-2016-10156",
  "cwe_ids": [
    "CWE-264"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "systemd",
  "commit_msg": "util-lib: use MODE_INVALID as invalid value for mode_t everywhere",
  "commit_hash": "ee735086f8670be1591fa9593e80dd60163a7a2f",
  "git_url": "https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f",
  "file_path": "src/core/timer.c",
  "func_name": "timer_start",
  "func_before": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n\n        /* Reenable all timers that depend on unit activation time */\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n\n        if (t->stamp_path) {\n                struct stat st;\n\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        /* The timer has never run before,\n                         * make sure a stamp file exists.\n                         */\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}",
  "abstract_func_before": "static int timer_start(Unit *VAR_0) {\n        Timer *VAR_1 = TIMER(VAR_0);\n        TimerValue *VAR_2;\n\n        assert(VAR_1);\n        assert(VAR_1->state == VAR_3 || VAR_1->state == VAR_4);\n\n        if (UNIT_TRIGGER(VAR_0)->load_state != VAR_5)\n                return -VAR_6;\n\n        VAR_1->last_trigger = VAR_7;\n\n        /* COMMENT_0 */\n        LIST_FOREACH(VAR_8, VAR_2, VAR_1->values)\n                if (VAR_2->base == VAR_9)\n                        VAR_2->disabled = false;\n\n        if (VAR_1->stamp_path) {\n                struct stat VAR_10;\n\n                if (stat(VAR_1->stamp_path, &VAR_10) >= 0)\n                        VAR_1->last_trigger.realtime = timespec_load(&VAR_10.st_atim);\n                else if (VAR_11 == VAR_6)\n                        /* COMMENT_1 */\n                                                         \n                           \n                        touch_file(VAR_1->stamp_path, true, VAR_12, VAR_13, VAR_14, 0);\n        }\n\n        VAR_1->result = VAR_15;\n        timer_enter_waiting(VAR_1, true);\n        return 1;\n}",
  "func_graph_path_before": "systemd/ee735086f8670be1591fa9593e80dd60163a7a2f/timer.c/vul/before/1.json",
  "func": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n\n        /* Reenable all timers that depend on unit activation time */\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n\n        if (t->stamp_path) {\n                struct stat st;\n\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        /* The timer has never run before,\n                         * make sure a stamp file exists.\n                         */\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);\n        }\n\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}",
  "abstract_func": "static int timer_start(Unit *VAR_0) {\n        Timer *VAR_1 = TIMER(VAR_0);\n        TimerValue *VAR_2;\n\n        assert(VAR_1);\n        assert(VAR_1->state == VAR_3 || VAR_1->state == VAR_4);\n\n        if (UNIT_TRIGGER(VAR_0)->load_state != VAR_5)\n                return -VAR_6;\n\n        VAR_1->last_trigger = VAR_7;\n\n        /* COMMENT_0 */\n        LIST_FOREACH(VAR_8, VAR_2, VAR_1->values)\n                if (VAR_2->base == VAR_9)\n                        VAR_2->disabled = false;\n\n        if (VAR_1->stamp_path) {\n                struct stat VAR_10;\n\n                if (stat(VAR_1->stamp_path, &VAR_10) >= 0)\n                        VAR_1->last_trigger.realtime = timespec_load(&VAR_10.st_atim);\n                else if (VAR_11 == VAR_6)\n                        /* COMMENT_1 */\n                                                         \n                           \n                        touch_file(VAR_1->stamp_path, true, VAR_12, VAR_13, VAR_14, VAR_15);\n        }\n\n        VAR_1->result = VAR_16;\n        timer_enter_waiting(VAR_1, true);\n        return 1;\n}",
  "func_graph_path": "systemd/ee735086f8670be1591fa9593e80dd60163a7a2f/timer.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n                         /* The timer has never run before,\n                          * make sure a stamp file exists.\n                          */\n-                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n+                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);\n         }\n \n         t->result = TIMER_SUCCESS;",
  "diff_line_info": {
    "deleted_lines": [
      "                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);"
    ],
    "added_lines": [
      "                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/systemd/systemd/pull/1854",
  "description": {
    "pr_info": {
      "title": "Dependency engine improvements",
      "number": 1854
    },
    "comment": [
      "A variety of fixes. \n\nMost important is a fix for 3d793d2 which broke the boot for pretty much all cases. @filbranden please have a look at this one, as it extends extract_first_word().\n\n@philips for you I sat down and documented all automatic unit dependencies. Please have a look. It's one of the issues you had in your systemd.conf talk.\n",
      "EXTRACT_RETAIN_ESCAPE looks good to me.\n\nI was working on the support for backticks and I came up with something similar for variables and specifiers: https://github.com/filbranden/systemd/commit/6fda28ec6d47d928588c9f24d6028cd746895a68\n\nI like your \"retain\" name so I might use something similar over there too...\n"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch involves replacing a hardcoded 0 with MODE_INVALID in a file operation, enhancing code consistency without addressing security issues. It's categorized under Supporting & Non-Core Improvements with high confidence.\n\n**Final Output:**\nAnalysis: The patch replaces a hardcoded 0 with MODE_INVALID, improving code consistency without fixing a security issue. No security vulnerability is addressed.\nFinal Classification: Supporting & Non-Core Improvements\nConfidence Score: 0.95"
}