{
  "cve_id": "CVE-2022-2553",
  "cwe_ids": [
    "CWE-287"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "ClusterLabs/booth",
  "commit_msg": "Revert \"Refactor: main: substitute is_auth_req macro\"\n\nThis reverts commit da79b8ba28ad4837a0fee13e5f8fb6f89fe0e24c.\n\nauthfile != authkey\n\nSigned-off-by: Jan Friesse <jfriesse@redhat.com>",
  "commit_hash": "35bf0b7b048d715f671eb68974fb6b4af6528c67",
  "git_url": "https://github.com/ClusterLabs/booth/commit/35bf0b7b048d715f671eb68974fb6b4af6528c67",
  "file_path": "src/main.c",
  "func_name": "setup_config",
  "func_before": "static int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t/* Set \"local\" pointer, ignoring errors. */\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t/* Per default the PID file name is derived from the\n\t * configuration name. */\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}",
  "abstract_func_before": "static int setup_config(int VAR_0)\n{\n\tint VAR_1;\n\n\tVAR_1 = read_config(VAR_2.configfile, VAR_0);\n\tif (VAR_1 < 0)\n\t\tgoto out;\n\n\tif (is_auth_req()) {\n\t\tVAR_1 = read_authkey();\n\t\tif (VAR_1 < 0)\n\t\t\tgoto out;\n#if VAR_3\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\tVAR_1 = -VAR_4;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(VAR_5, 0);\n\t\tgcry_control(VAR_6, 0);\n#endif\n\t}\n\n\t/* COMMENT_0 */\n\tif (VAR_2.type == VAR_7 && VAR_2.site[0]) {\n\t\tif (!find_site_by_name(VAR_2.site, &VAR_8, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tVAR_2.site);\n\t\t\treturn -VAR_9;\n\t\t}\n\t\tVAR_8->local = 1;\n\t} else\n\t\tfind_myself(NULL, VAR_0 == VAR_10 || VAR_0 == VAR_11);\n\n\n\tVAR_1 = check_config(VAR_0);\n\tif (VAR_1 < 0)\n\t\tgoto out;\n\n\n\t/* COMMENT_1 */\n                          \n\tif (!VAR_2.lockfile[0]) {\n\t\tsnprintf(VAR_2.lockfile, sizeof(VAR_2.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", VAR_12, VAR_13->name);\n\t}\n\nout:\n\treturn VAR_1;\n}",
  "func_graph_path_before": "ClusterLabs/booth/35bf0b7b048d715f671eb68974fb6b4af6528c67/main.c/vul/before/0.json",
  "func": "static int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (booth_conf->authfile[0] != '\\0') {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t/* Set \"local\" pointer, ignoring errors. */\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t/* Per default the PID file name is derived from the\n\t * configuration name. */\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}",
  "abstract_func": "static int setup_config(int VAR_0)\n{\n\tint VAR_1;\n\n\tVAR_1 = read_config(VAR_2.configfile, VAR_0);\n\tif (VAR_1 < 0)\n\t\tgoto out;\n\n\tif (VAR_3->authfile[0] != '\\0') {\n\t\tVAR_1 = read_authkey();\n\t\tif (VAR_1 < 0)\n\t\t\tgoto out;\n#if VAR_4\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\tVAR_1 = -VAR_5;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(VAR_6, 0);\n\t\tgcry_control(VAR_7, 0);\n#endif\n\t}\n\n\t/* COMMENT_0 */\n\tif (VAR_2.type == VAR_8 && VAR_2.site[0]) {\n\t\tif (!find_site_by_name(VAR_2.site, &VAR_9, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tVAR_2.site);\n\t\t\treturn -VAR_10;\n\t\t}\n\t\tVAR_9->local = 1;\n\t} else\n\t\tfind_myself(NULL, VAR_0 == VAR_11 || VAR_0 == VAR_12);\n\n\n\tVAR_1 = check_config(VAR_0);\n\tif (VAR_1 < 0)\n\t\tgoto out;\n\n\n\t/* COMMENT_1 */\n                          \n\tif (!VAR_2.lockfile[0]) {\n\t\tsnprintf(VAR_2.lockfile, sizeof(VAR_2.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", VAR_13, VAR_3->name);\n\t}\n\nout:\n\treturn VAR_1;\n}",
  "func_graph_path": "ClusterLabs/booth/35bf0b7b048d715f671eb68974fb6b4af6528c67/main.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \tif (rv < 0)\n \t\tgoto out;\n \n-\tif (is_auth_req()) {\n+\tif (booth_conf->authfile[0] != '\\0') {\n \t\trv = read_authkey();\n \t\tif (rv < 0)\n \t\t\tgoto out;",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (is_auth_req()) {"
    ],
    "added_lines": [
      "\tif (booth_conf->authfile[0] != '\\0') {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ClusterLabs/booth/pull/115",
  "description": {
    "pr_info": {
      "title": "Revert \"Refactor: main: substitute is_auth_req macro\"",
      "number": 115
    },
    "comment": [
      "This reverts commit da79b8ba28ad4837a0fee13e5f8fb6f89fe0e24c.\r\n\r\nauthfile != authkey\r\n\r\nSigned-off-by: Jan Friesse <jfriesse@redhat.com>\r\n\r\nSolves #114",
      "@dmuhamedagic The reason for failing check is coverity which (after the patch) finally got a chance to go thru the code paths with hmac enabled and it found out that boothc header secs field is 32-bit\r\n```\r\nstruct boothc_header {\r\n...\r\nuint32_t secs;  /* seconds */\r\n```\r\n\r\nand result of `time_t` (64-bit because of Y2K38 problem) is stored into 32-bit header (in `init_header_bare`). 2K38 is not so close, but it may be good idea to solve the problem anyway. Any idea how to solve the problem without breaking wire compatibility?",
      "Thanks! Unfortunately, I managed to confuse Jan (the other one) with the name.",
      "@dmuhamedagic Thanks! Any idea about solving Y2K38 problem I've described in previous comment (https://github.com/ClusterLabs/booth/pull/115#issuecomment-1173482961)?\r\n\r\nI had an idea - what about ignore fact that it is wall time and instead say it is 32-bit timestamp which can overflow - and we count with it by using sliding window? So (for example) cmp knows that 0 is bigger than uint32-1 at time uint32-2?\r\n\r\nWould you accept such patch?",
      "On Thu, Jul 07, 2022 at 08:10:32AM -0700, Jan Friesse wrote:\n> @dmuhamedagic Thanks! Any idea about solving Y2K38 problem I've described in previous comment (https://github.com/ClusterLabs/booth/pull/115#issuecomment-1173482961)?\n\nI didn't miss it, but at the time had no good idea what to do\nabout it. Still don't.\n\n> I had an idea - what about ignore fact that it is wall time and instead say it is 32-bit timestamp which can overflow - and we count with it by using sliding window? So (for example) cmp knows that 0 is bigger than uint32-1 at time uint32-2?\n> \n> Would you accept such patch?\n\nOf course. Sounds good.\n",
      "> On Thu, Jul 07, 2022 at 08:10:32AM -0700, Jan Friesse wrote: @dmuhamedagic Thanks! Any idea about solving Y2K38 problem I've described in previous comment ([#115 (comment)](https://github.com/ClusterLabs/booth/pull/115#issuecomment-1173482961))?\r\n> I didn't miss it, but at the time had no good idea what to do about it. Still don't.\r\n\r\nOh .. ok :) No worries\r\n\r\n> I had an idea - what about ignore fact that it is wall time and instead say it is 32-bit timestamp which can overflow - and we count with it by using sliding window? So (for example) cmp knows that 0 is bigger than uint32-1 at time uint32-2? Would you accept such patch?\r\n> Of course. Sounds good.\r\n\r\n I will try to prepare patch - still not sure if it will really work so maybe I find out different approach is needed... Let's see."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n1. The commit reverts a previous refactor that replaced a macro with a direct check on `authfile`.\n2. The code change addresses a potential issue introduced by the refactor, not a security vulnerability.\n3. Discussions indicate a separate issue with timestamp handling, unrelated to this patch.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.9"
}