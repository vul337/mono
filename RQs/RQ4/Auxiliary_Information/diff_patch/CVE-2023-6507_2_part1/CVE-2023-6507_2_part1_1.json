{
  "cve_id": "CVE-2023-6507",
  "cwe_ids": [
    "CWE-269"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "python/cpython",
  "commit_msg": "Improve the assertion.\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
  "commit_hash": "52a475c4ec770a05286189a14970686e61bc0f24",
  "git_url": "https://github.com/python/cpython/commit/52a475c4ec770a05286189a14970686e61bc0f24",
  "file_path": "Modules/_posixsubprocess.c",
  "func_name": "child_exec",
  "func_before": "Py_NO_INLINE static void\nchild_exec(char *const exec_array[],\n           char *const argv[],\n           char *const envp[],\n           const char *cwd,\n           int p2cread, int p2cwrite,\n           int c2pread, int c2pwrite,\n           int errread, int errwrite,\n           int errpipe_read, int errpipe_write,\n           int close_fds, int restore_signals,\n           int call_setsid, pid_t pgid_to_set,\n           gid_t gid,\n           Py_ssize_t extra_group_size, const gid_t *extra_groups,\n           uid_t uid, int child_umask,\n           const void *child_sigmask,\n           int *fds_to_keep, Py_ssize_t fds_to_keep_len,\n           PyObject *preexec_fn,\n           PyObject *preexec_fn_args_tuple)\n{\n    int i, saved_errno, reached_preexec = 0;\n    PyObject *result;\n    const char* err_msg = \"\";\n    /* Buffer large enough to hold a hex integer.  We can't malloc. */\n    char hex_errno[sizeof(saved_errno)*2+1];\n\n    if (make_inheritable(fds_to_keep, fds_to_keep_len, errpipe_write) < 0)\n        goto error;\n\n    /* Close parent's pipe ends. */\n    if (p2cwrite != -1)\n        POSIX_CALL(close(p2cwrite));\n    if (c2pread != -1)\n        POSIX_CALL(close(c2pread));\n    if (errread != -1)\n        POSIX_CALL(close(errread));\n    POSIX_CALL(close(errpipe_read));\n\n    /* When duping fds, if there arises a situation where one of the fds is\n       either 0, 1 or 2, it is possible that it is overwritten (#12607). */\n    if (c2pwrite == 0) {\n        POSIX_CALL(c2pwrite = dup(c2pwrite));\n        /* issue32270 */\n        if (_Py_set_inheritable_async_safe(c2pwrite, 0, NULL) < 0) {\n            goto error;\n        }\n    }\n    while (errwrite == 0 || errwrite == 1) {\n        POSIX_CALL(errwrite = dup(errwrite));\n        /* issue32270 */\n        if (_Py_set_inheritable_async_safe(errwrite, 0, NULL) < 0) {\n            goto error;\n        }\n    }\n\n    /* Dup fds for child.\n       dup2() removes the CLOEXEC flag but we must do it ourselves if dup2()\n       would be a no-op (issue #10806). */\n    if (p2cread == 0) {\n        if (_Py_set_inheritable_async_safe(p2cread, 1, NULL) < 0)\n            goto error;\n    }\n    else if (p2cread != -1)\n        POSIX_CALL(dup2(p2cread, 0));  /* stdin */\n\n    if (c2pwrite == 1) {\n        if (_Py_set_inheritable_async_safe(c2pwrite, 1, NULL) < 0)\n            goto error;\n    }\n    else if (c2pwrite != -1)\n        POSIX_CALL(dup2(c2pwrite, 1));  /* stdout */\n\n    if (errwrite == 2) {\n        if (_Py_set_inheritable_async_safe(errwrite, 1, NULL) < 0)\n            goto error;\n    }\n    else if (errwrite != -1)\n        POSIX_CALL(dup2(errwrite, 2));  /* stderr */\n\n    /* We no longer manually close p2cread, c2pwrite, and errwrite here as\n     * _close_open_fds takes care when it is not already non-inheritable. */\n\n    if (cwd)\n        POSIX_CALL(chdir(cwd));\n\n    if (child_umask >= 0)\n        umask(child_umask);  /* umask() always succeeds. */\n\n    if (restore_signals) {\n        _Py_RestoreSignals();\n    }\n\n#ifdef VFORK_USABLE\n    if (child_sigmask) {\n        reset_signal_handlers(child_sigmask);\n        if ((errno = pthread_sigmask(SIG_SETMASK, child_sigmask, NULL))) {\n            goto error;\n        }\n    }\n#endif\n\n#ifdef HAVE_SETSID\n    if (call_setsid)\n        POSIX_CALL(setsid());\n#endif\n\n#ifdef HAVE_SETPGID\n    static_assert(_Py_IS_TYPE_SIGNED(pid_t), \"pid_t is unsigned\");\n    if (pgid_to_set >= 0) {\n        POSIX_CALL(setpgid(0, pgid_to_set));\n    }\n#endif\n\n#ifdef HAVE_SETGROUPS\n    if (extra_group_size >= 0) {\n        assert((extra_group_size == 0 && extra_groups == NULL) || extra_group_size);\n        POSIX_CALL(setgroups(extra_group_size, extra_groups));\n    }\n#endif /* HAVE_SETGROUPS */\n\n#ifdef HAVE_SETREGID\n    if (gid != (gid_t)-1)\n        POSIX_CALL(setregid(gid, gid));\n#endif /* HAVE_SETREGID */\n\n#ifdef HAVE_SETREUID\n    if (uid != (uid_t)-1)\n        POSIX_CALL(setreuid(uid, uid));\n#endif /* HAVE_SETREUID */\n\n\n    reached_preexec = 1;\n    if (preexec_fn != Py_None && preexec_fn_args_tuple) {\n        /* This is where the user has asked us to deadlock their program. */\n        result = PyObject_Call(preexec_fn, preexec_fn_args_tuple, NULL);\n        if (result == NULL) {\n            /* Stringifying the exception or traceback would involve\n             * memory allocation and thus potential for deadlock.\n             * We've already faced potential deadlock by calling back\n             * into Python in the first place, so it probably doesn't\n             * matter but we avoid it to minimize the possibility. */\n            err_msg = \"Exception occurred in preexec_fn.\";\n            errno = 0;  /* We don't want to report an OSError. */\n            goto error;\n        }\n        /* Py_DECREF(result); - We're about to exec so why bother? */\n    }\n\n    /* close FDs after executing preexec_fn, which might open FDs */\n    if (close_fds) {\n        /* TODO HP-UX could use pstat_getproc() if anyone cares about it. */\n        _close_open_fds(3, fds_to_keep, fds_to_keep_len);\n    }\n\n    /* This loop matches the Lib/os.py _execvpe()'s PATH search when */\n    /* given the executable_list generated by Lib/subprocess.py.     */\n    saved_errno = 0;\n    for (i = 0; exec_array[i] != NULL; ++i) {\n        const char *executable = exec_array[i];\n        if (envp) {\n            execve(executable, argv, envp);\n        } else {\n            execv(executable, argv);\n        }\n        if (errno != ENOENT && errno != ENOTDIR && saved_errno == 0) {\n            saved_errno = errno;\n        }\n    }\n    /* Report the first exec error, not the last. */\n    if (saved_errno)\n        errno = saved_errno;\n\nerror:\n    saved_errno = errno;\n    /* Report the posix error to our parent process. */\n    /* We ignore all write() return values as the total size of our writes is\n       less than PIPEBUF and we cannot do anything about an error anyways.\n       Use _Py_write_noraise() to retry write() if it is interrupted by a\n       signal (fails with EINTR). */\n    if (saved_errno) {\n        char *cur;\n        _Py_write_noraise(errpipe_write, \"OSError:\", 8);\n        cur = hex_errno + sizeof(hex_errno);\n        while (saved_errno != 0 && cur != hex_errno) {\n            *--cur = Py_hexdigits[saved_errno % 16];\n            saved_errno /= 16;\n        }\n        _Py_write_noraise(errpipe_write, cur, hex_errno + sizeof(hex_errno) - cur);\n        _Py_write_noraise(errpipe_write, \":\", 1);\n        if (!reached_preexec) {\n            /* Indicate to the parent that the error happened before exec(). */\n            _Py_write_noraise(errpipe_write, \"noexec\", 6);\n        }\n        /* We can't call strerror(saved_errno).  It is not async signal safe.\n         * The parent process will look the error message up. */\n    } else {\n        _Py_write_noraise(errpipe_write, \"SubprocessError:0:\", 18);\n        _Py_write_noraise(errpipe_write, err_msg, strlen(err_msg));\n    }\n}",
  "abstract_func_before": "Py_NO_INLINE static VAR_0\nchild_exec(char *const VAR_1[],\n           char *const VAR_2[],\n           char *const VAR_3[],\n           const char *VAR_4,\n           int VAR_5, int VAR_6,\n           int VAR_7, int VAR_8,\n           int VAR_9, int VAR_10,\n           int VAR_11, int VAR_12,\n           int VAR_13, int VAR_14,\n           int VAR_15, pid_t VAR_16,\n           gid_t VAR_17,\n           Py_ssize_t VAR_18, const gid_t *VAR_19,\n           uid_t VAR_20, int VAR_21,\n           const void *VAR_22,\n           int *VAR_23, Py_ssize_t VAR_24,\n           PyObject *VAR_25,\n           PyObject *VAR_26)\n{\n    int VAR_27, VAR_28, VAR_29 = 0;\n    PyObject *VAR_30;\n    const char* VAR_31 = \"\";\n    /* COMMENT_0 */\n    char VAR_32[sizeof(VAR_28)*2+1];\n\n    if (make_inheritable(VAR_23, VAR_24, VAR_12) < 0)\n        goto error;\n\n    /* COMMENT_1 */\n    if (VAR_6 != -1)\n        POSIX_CALL(close(VAR_6));\n    if (VAR_7 != -1)\n        POSIX_CALL(close(VAR_7));\n    if (VAR_9 != -1)\n        POSIX_CALL(close(VAR_9));\n    POSIX_CALL(close(VAR_11));\n\n    /* COMMENT_2 */\n                                                                           \n    if (VAR_8 == 0) {\n        POSIX_CALL(VAR_8 = dup(VAR_8));\n        /* COMMENT_4 */\n        if (_Py_set_inheritable_async_safe(VAR_8, 0, NULL) < 0) {\n            goto error;\n        }\n    }\n    while (VAR_10 == 0 || VAR_10 == 1) {\n        POSIX_CALL(VAR_10 = dup(VAR_10));\n        /* COMMENT_4 */\n        if (_Py_set_inheritable_async_safe(VAR_10, 0, NULL) < 0) {\n            goto error;\n        }\n    }\n\n    /* COMMENT_5 */\n                                                                            \n                                          \n    if (VAR_5 == 0) {\n        if (_Py_set_inheritable_async_safe(VAR_5, 1, NULL) < 0)\n            goto error;\n    }\n    else if (VAR_5 != -1)\n        POSIX_CALL(dup2(VAR_5, 0));  /* COMMENT_8 */\n\n    if (VAR_8 == 1) {\n        if (_Py_set_inheritable_async_safe(VAR_8, 1, NULL) < 0)\n            goto error;\n    }\n    else if (VAR_8 != -1)\n        POSIX_CALL(dup2(VAR_8, 1));  /* COMMENT_9 */\n\n    if (VAR_10 == 2) {\n        if (_Py_set_inheritable_async_safe(VAR_10, 1, NULL) < 0)\n            goto error;\n    }\n    else if (VAR_10 != -1)\n        POSIX_CALL(dup2(VAR_10, 2));  /* COMMENT_10 */\n\n    /* COMMENT_11 */\n                                                                            \n\n    if (VAR_4)\n        POSIX_CALL(chdir(VAR_4));\n\n    if (VAR_21 >= 0)\n        umask(VAR_21);  /* COMMENT_13 */\n\n    if (VAR_14) {\n        _Py_RestoreSignals();\n    }\n\n#ifdef VAR_33\n    if (VAR_22) {\n        reset_signal_handlers(VAR_22);\n        if ((VAR_34 = pthread_sigmask(VAR_35, VAR_22, NULL))) {\n            goto error;\n        }\n    }\n#endif\n\n#ifdef VAR_36\n    if (VAR_15)\n        POSIX_CALL(setsid());\n#endif\n\n#ifdef VAR_37\n    static_assert(_Py_IS_TYPE_SIGNED(pid_t), \"pid_t is unsigned\");\n    if (VAR_16 >= 0) {\n        POSIX_CALL(setpgid(0, VAR_16));\n    }\n#endif\n\n#ifdef VAR_38\n    if (VAR_18 >= 0) {\n        assert((VAR_18 == 0 && VAR_19 == NULL) || VAR_18);\n        POSIX_CALL(setgroups(VAR_18, VAR_19));\n    }\n#endif /* COMMENT_14 */\n\n#ifdef VAR_39\n    if (VAR_17 != (gid_t)-1)\n        POSIX_CALL(setregid(VAR_17, VAR_17));\n#endif /* COMMENT_15 */\n\n#ifdef VAR_40\n    if (VAR_20 != (uid_t)-1)\n        POSIX_CALL(setreuid(VAR_20, VAR_20));\n#endif /* COMMENT_16 */\n\n\n    VAR_29 = 1;\n    if (VAR_25 != VAR_41 && VAR_26) {\n        /* COMMENT_17 */\n        VAR_30 = PyObject_Call(VAR_25, VAR_26, NULL);\n        if (VAR_30 == NULL) {\n            /* COMMENT_18 */\n                                                                 \n                                                                     \n                                                                     \n                                                                     \n            VAR_31 = \"Exception occurred in preexec_fn.\";\n            VAR_34 = 0;  /* COMMENT_23 */\n            goto error;\n        }\n        /* COMMENT_24 */\n    }\n\n    /* COMMENT_25 */\n    if (VAR_13) {\n        /* COMMENT_26 */\n        _close_open_fds(3, VAR_23, VAR_24);\n    }\n\n    /* COMMENT_27 */\n    /* COMMENT_28 */\n    VAR_28 = 0;\n    for (VAR_27 = 0; VAR_1[VAR_27] != NULL; ++VAR_27) {\n        const char *VAR_42 = VAR_1[VAR_27];\n        if (VAR_3) {\n            execve(VAR_42, VAR_2, VAR_3);\n        } else {\n            execv(VAR_42, VAR_2);\n        }\n        if (VAR_34 != VAR_43 && VAR_34 != VAR_44 && VAR_28 == 0) {\n            VAR_28 = VAR_34;\n        }\n    }\n    /* COMMENT_29 */\n    if (VAR_28)\n        VAR_34 = VAR_28;\n\nerror:\n    VAR_28 = VAR_34;\n    /* COMMENT_30 */\n    /* COMMENT_31 */\n                                                                          \n                                                                         \n                                    \n    if (VAR_28) {\n        char *VAR_45;\n        _Py_write_noraise(VAR_12, \"OSError:\", 8);\n        VAR_45 = VAR_32 + sizeof(VAR_32);\n        while (VAR_28 != 0 && VAR_45 != VAR_32) {\n            *--VAR_45 = VAR_46[VAR_28 % 16];\n            VAR_28 /= 16;\n        }\n        _Py_write_noraise(VAR_12, VAR_45, VAR_32 + sizeof(VAR_32) - VAR_45);\n        _Py_write_noraise(VAR_12, \":\", 1);\n        if (!VAR_29) {\n            /* COMMENT_35 */\n            _Py_write_noraise(VAR_12, \"noexec\", 6);\n        }\n        /* COMMENT_36 */\n                                                                \n    } else {\n        _Py_write_noraise(VAR_12, \"SubprocessError:0:\", 18);\n        _Py_write_noraise(VAR_12, VAR_31, strlen(VAR_31));\n    }\n}",
  "func_graph_path_before": null,
  "func": "Py_NO_INLINE static void\nchild_exec(char *const exec_array[],\n           char *const argv[],\n           char *const envp[],\n           const char *cwd,\n           int p2cread, int p2cwrite,\n           int c2pread, int c2pwrite,\n           int errread, int errwrite,\n           int errpipe_read, int errpipe_write,\n           int close_fds, int restore_signals,\n           int call_setsid, pid_t pgid_to_set,\n           gid_t gid,\n           Py_ssize_t extra_group_size, const gid_t *extra_groups,\n           uid_t uid, int child_umask,\n           const void *child_sigmask,\n           int *fds_to_keep, Py_ssize_t fds_to_keep_len,\n           PyObject *preexec_fn,\n           PyObject *preexec_fn_args_tuple)\n{\n    int i, saved_errno, reached_preexec = 0;\n    PyObject *result;\n    const char* err_msg = \"\";\n    /* Buffer large enough to hold a hex integer.  We can't malloc. */\n    char hex_errno[sizeof(saved_errno)*2+1];\n\n    if (make_inheritable(fds_to_keep, fds_to_keep_len, errpipe_write) < 0)\n        goto error;\n\n    /* Close parent's pipe ends. */\n    if (p2cwrite != -1)\n        POSIX_CALL(close(p2cwrite));\n    if (c2pread != -1)\n        POSIX_CALL(close(c2pread));\n    if (errread != -1)\n        POSIX_CALL(close(errread));\n    POSIX_CALL(close(errpipe_read));\n\n    /* When duping fds, if there arises a situation where one of the fds is\n       either 0, 1 or 2, it is possible that it is overwritten (#12607). */\n    if (c2pwrite == 0) {\n        POSIX_CALL(c2pwrite = dup(c2pwrite));\n        /* issue32270 */\n        if (_Py_set_inheritable_async_safe(c2pwrite, 0, NULL) < 0) {\n            goto error;\n        }\n    }\n    while (errwrite == 0 || errwrite == 1) {\n        POSIX_CALL(errwrite = dup(errwrite));\n        /* issue32270 */\n        if (_Py_set_inheritable_async_safe(errwrite, 0, NULL) < 0) {\n            goto error;\n        }\n    }\n\n    /* Dup fds for child.\n       dup2() removes the CLOEXEC flag but we must do it ourselves if dup2()\n       would be a no-op (issue #10806). */\n    if (p2cread == 0) {\n        if (_Py_set_inheritable_async_safe(p2cread, 1, NULL) < 0)\n            goto error;\n    }\n    else if (p2cread != -1)\n        POSIX_CALL(dup2(p2cread, 0));  /* stdin */\n\n    if (c2pwrite == 1) {\n        if (_Py_set_inheritable_async_safe(c2pwrite, 1, NULL) < 0)\n            goto error;\n    }\n    else if (c2pwrite != -1)\n        POSIX_CALL(dup2(c2pwrite, 1));  /* stdout */\n\n    if (errwrite == 2) {\n        if (_Py_set_inheritable_async_safe(errwrite, 1, NULL) < 0)\n            goto error;\n    }\n    else if (errwrite != -1)\n        POSIX_CALL(dup2(errwrite, 2));  /* stderr */\n\n    /* We no longer manually close p2cread, c2pwrite, and errwrite here as\n     * _close_open_fds takes care when it is not already non-inheritable. */\n\n    if (cwd)\n        POSIX_CALL(chdir(cwd));\n\n    if (child_umask >= 0)\n        umask(child_umask);  /* umask() always succeeds. */\n\n    if (restore_signals) {\n        _Py_RestoreSignals();\n    }\n\n#ifdef VFORK_USABLE\n    if (child_sigmask) {\n        reset_signal_handlers(child_sigmask);\n        if ((errno = pthread_sigmask(SIG_SETMASK, child_sigmask, NULL))) {\n            goto error;\n        }\n    }\n#endif\n\n#ifdef HAVE_SETSID\n    if (call_setsid)\n        POSIX_CALL(setsid());\n#endif\n\n#ifdef HAVE_SETPGID\n    static_assert(_Py_IS_TYPE_SIGNED(pid_t), \"pid_t is unsigned\");\n    if (pgid_to_set >= 0) {\n        POSIX_CALL(setpgid(0, pgid_to_set));\n    }\n#endif\n\n#ifdef HAVE_SETGROUPS\n    if (extra_group_size >= 0) {\n        assert((extra_group_size == 0) == (extra_groups == NULL));\n        POSIX_CALL(setgroups(extra_group_size, extra_groups));\n    }\n#endif /* HAVE_SETGROUPS */\n\n#ifdef HAVE_SETREGID\n    if (gid != (gid_t)-1)\n        POSIX_CALL(setregid(gid, gid));\n#endif /* HAVE_SETREGID */\n\n#ifdef HAVE_SETREUID\n    if (uid != (uid_t)-1)\n        POSIX_CALL(setreuid(uid, uid));\n#endif /* HAVE_SETREUID */\n\n\n    reached_preexec = 1;\n    if (preexec_fn != Py_None && preexec_fn_args_tuple) {\n        /* This is where the user has asked us to deadlock their program. */\n        result = PyObject_Call(preexec_fn, preexec_fn_args_tuple, NULL);\n        if (result == NULL) {\n            /* Stringifying the exception or traceback would involve\n             * memory allocation and thus potential for deadlock.\n             * We've already faced potential deadlock by calling back\n             * into Python in the first place, so it probably doesn't\n             * matter but we avoid it to minimize the possibility. */\n            err_msg = \"Exception occurred in preexec_fn.\";\n            errno = 0;  /* We don't want to report an OSError. */\n            goto error;\n        }\n        /* Py_DECREF(result); - We're about to exec so why bother? */\n    }\n\n    /* close FDs after executing preexec_fn, which might open FDs */\n    if (close_fds) {\n        /* TODO HP-UX could use pstat_getproc() if anyone cares about it. */\n        _close_open_fds(3, fds_to_keep, fds_to_keep_len);\n    }\n\n    /* This loop matches the Lib/os.py _execvpe()'s PATH search when */\n    /* given the executable_list generated by Lib/subprocess.py.     */\n    saved_errno = 0;\n    for (i = 0; exec_array[i] != NULL; ++i) {\n        const char *executable = exec_array[i];\n        if (envp) {\n            execve(executable, argv, envp);\n        } else {\n            execv(executable, argv);\n        }\n        if (errno != ENOENT && errno != ENOTDIR && saved_errno == 0) {\n            saved_errno = errno;\n        }\n    }\n    /* Report the first exec error, not the last. */\n    if (saved_errno)\n        errno = saved_errno;\n\nerror:\n    saved_errno = errno;\n    /* Report the posix error to our parent process. */\n    /* We ignore all write() return values as the total size of our writes is\n       less than PIPEBUF and we cannot do anything about an error anyways.\n       Use _Py_write_noraise() to retry write() if it is interrupted by a\n       signal (fails with EINTR). */\n    if (saved_errno) {\n        char *cur;\n        _Py_write_noraise(errpipe_write, \"OSError:\", 8);\n        cur = hex_errno + sizeof(hex_errno);\n        while (saved_errno != 0 && cur != hex_errno) {\n            *--cur = Py_hexdigits[saved_errno % 16];\n            saved_errno /= 16;\n        }\n        _Py_write_noraise(errpipe_write, cur, hex_errno + sizeof(hex_errno) - cur);\n        _Py_write_noraise(errpipe_write, \":\", 1);\n        if (!reached_preexec) {\n            /* Indicate to the parent that the error happened before exec(). */\n            _Py_write_noraise(errpipe_write, \"noexec\", 6);\n        }\n        /* We can't call strerror(saved_errno).  It is not async signal safe.\n         * The parent process will look the error message up. */\n    } else {\n        _Py_write_noraise(errpipe_write, \"SubprocessError:0:\", 18);\n        _Py_write_noraise(errpipe_write, err_msg, strlen(err_msg));\n    }\n}",
  "abstract_func": "Py_NO_INLINE static VAR_0\nchild_exec(char *const VAR_1[],\n           char *const VAR_2[],\n           char *const VAR_3[],\n           const char *VAR_4,\n           int VAR_5, int VAR_6,\n           int VAR_7, int VAR_8,\n           int VAR_9, int VAR_10,\n           int VAR_11, int VAR_12,\n           int VAR_13, int VAR_14,\n           int VAR_15, pid_t VAR_16,\n           gid_t VAR_17,\n           Py_ssize_t VAR_18, const gid_t *VAR_19,\n           uid_t VAR_20, int VAR_21,\n           const void *VAR_22,\n           int *VAR_23, Py_ssize_t VAR_24,\n           PyObject *VAR_25,\n           PyObject *VAR_26)\n{\n    int VAR_27, VAR_28, VAR_29 = 0;\n    PyObject *VAR_30;\n    const char* VAR_31 = \"\";\n    /* COMMENT_0 */\n    char VAR_32[sizeof(VAR_28)*2+1];\n\n    if (make_inheritable(VAR_23, VAR_24, VAR_12) < 0)\n        goto error;\n\n    /* COMMENT_1 */\n    if (VAR_6 != -1)\n        POSIX_CALL(close(VAR_6));\n    if (VAR_7 != -1)\n        POSIX_CALL(close(VAR_7));\n    if (VAR_9 != -1)\n        POSIX_CALL(close(VAR_9));\n    POSIX_CALL(close(VAR_11));\n\n    /* COMMENT_2 */\n                                                                           \n    if (VAR_8 == 0) {\n        POSIX_CALL(VAR_8 = dup(VAR_8));\n        /* COMMENT_4 */\n        if (_Py_set_inheritable_async_safe(VAR_8, 0, NULL) < 0) {\n            goto error;\n        }\n    }\n    while (VAR_10 == 0 || VAR_10 == 1) {\n        POSIX_CALL(VAR_10 = dup(VAR_10));\n        /* COMMENT_4 */\n        if (_Py_set_inheritable_async_safe(VAR_10, 0, NULL) < 0) {\n            goto error;\n        }\n    }\n\n    /* COMMENT_5 */\n                                                                            \n                                          \n    if (VAR_5 == 0) {\n        if (_Py_set_inheritable_async_safe(VAR_5, 1, NULL) < 0)\n            goto error;\n    }\n    else if (VAR_5 != -1)\n        POSIX_CALL(dup2(VAR_5, 0));  /* COMMENT_8 */\n\n    if (VAR_8 == 1) {\n        if (_Py_set_inheritable_async_safe(VAR_8, 1, NULL) < 0)\n            goto error;\n    }\n    else if (VAR_8 != -1)\n        POSIX_CALL(dup2(VAR_8, 1));  /* COMMENT_9 */\n\n    if (VAR_10 == 2) {\n        if (_Py_set_inheritable_async_safe(VAR_10, 1, NULL) < 0)\n            goto error;\n    }\n    else if (VAR_10 != -1)\n        POSIX_CALL(dup2(VAR_10, 2));  /* COMMENT_10 */\n\n    /* COMMENT_11 */\n                                                                            \n\n    if (VAR_4)\n        POSIX_CALL(chdir(VAR_4));\n\n    if (VAR_21 >= 0)\n        umask(VAR_21);  /* COMMENT_13 */\n\n    if (VAR_14) {\n        _Py_RestoreSignals();\n    }\n\n#ifdef VAR_33\n    if (VAR_22) {\n        reset_signal_handlers(VAR_22);\n        if ((VAR_34 = pthread_sigmask(VAR_35, VAR_22, NULL))) {\n            goto error;\n        }\n    }\n#endif\n\n#ifdef VAR_36\n    if (VAR_15)\n        POSIX_CALL(setsid());\n#endif\n\n#ifdef VAR_37\n    static_assert(_Py_IS_TYPE_SIGNED(pid_t), \"pid_t is unsigned\");\n    if (VAR_16 >= 0) {\n        POSIX_CALL(setpgid(0, VAR_16));\n    }\n#endif\n\n#ifdef VAR_38\n    if (VAR_18 >= 0) {\n        assert((VAR_18 == 0) == (VAR_19 == NULL));\n        POSIX_CALL(setgroups(VAR_18, VAR_19));\n    }\n#endif /* COMMENT_14 */\n\n#ifdef VAR_39\n    if (VAR_17 != (gid_t)-1)\n        POSIX_CALL(setregid(VAR_17, VAR_17));\n#endif /* COMMENT_15 */\n\n#ifdef VAR_40\n    if (VAR_20 != (uid_t)-1)\n        POSIX_CALL(setreuid(VAR_20, VAR_20));\n#endif /* COMMENT_16 */\n\n\n    VAR_29 = 1;\n    if (VAR_25 != VAR_41 && VAR_26) {\n        /* COMMENT_17 */\n        VAR_30 = PyObject_Call(VAR_25, VAR_26, NULL);\n        if (VAR_30 == NULL) {\n            /* COMMENT_18 */\n                                                                 \n                                                                     \n                                                                     \n                                                                     \n            VAR_31 = \"Exception occurred in preexec_fn.\";\n            VAR_34 = 0;  /* COMMENT_23 */\n            goto error;\n        }\n        /* COMMENT_24 */\n    }\n\n    /* COMMENT_25 */\n    if (VAR_13) {\n        /* COMMENT_26 */\n        _close_open_fds(3, VAR_23, VAR_24);\n    }\n\n    /* COMMENT_27 */\n    /* COMMENT_28 */\n    VAR_28 = 0;\n    for (VAR_27 = 0; VAR_1[VAR_27] != NULL; ++VAR_27) {\n        const char *VAR_42 = VAR_1[VAR_27];\n        if (VAR_3) {\n            execve(VAR_42, VAR_2, VAR_3);\n        } else {\n            execv(VAR_42, VAR_2);\n        }\n        if (VAR_34 != VAR_43 && VAR_34 != VAR_44 && VAR_28 == 0) {\n            VAR_28 = VAR_34;\n        }\n    }\n    /* COMMENT_29 */\n    if (VAR_28)\n        VAR_34 = VAR_28;\n\nerror:\n    VAR_28 = VAR_34;\n    /* COMMENT_30 */\n    /* COMMENT_31 */\n                                                                          \n                                                                         \n                                    \n    if (VAR_28) {\n        char *VAR_45;\n        _Py_write_noraise(VAR_12, \"OSError:\", 8);\n        VAR_45 = VAR_32 + sizeof(VAR_32);\n        while (VAR_28 != 0 && VAR_45 != VAR_32) {\n            *--VAR_45 = VAR_46[VAR_28 % 16];\n            VAR_28 /= 16;\n        }\n        _Py_write_noraise(VAR_12, VAR_45, VAR_32 + sizeof(VAR_32) - VAR_45);\n        _Py_write_noraise(VAR_12, \":\", 1);\n        if (!VAR_29) {\n            /* COMMENT_35 */\n            _Py_write_noraise(VAR_12, \"noexec\", 6);\n        }\n        /* COMMENT_36 */\n                                                                \n    } else {\n        _Py_write_noraise(VAR_12, \"SubprocessError:0:\", 18);\n        _Py_write_noraise(VAR_12, VAR_31, strlen(VAR_31));\n    }\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -112,7 +112,7 @@\n \n #ifdef HAVE_SETGROUPS\n     if (extra_group_size >= 0) {\n-        assert((extra_group_size == 0 && extra_groups == NULL) || extra_group_size);\n+        assert((extra_group_size == 0) == (extra_groups == NULL));\n         POSIX_CALL(setgroups(extra_group_size, extra_groups));\n     }\n #endif /* HAVE_SETGROUPS */",
  "diff_line_info": {
    "deleted_lines": [
      "        assert((extra_group_size == 0 && extra_groups == NULL) || extra_group_size);"
    ],
    "added_lines": [
      "        assert((extra_group_size == 0) == (extra_groups == NULL));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python/cpython/pull/112617",
  "description": {
    "pr_info": {
      "title": "gh-112334: Restore subprocess's use of `vfork()` & fix `extra_groups=[]` behavior",
      "number": 112617
    },
    "comment": [
      "Fixed a performance regression in 3.12's `subprocess` on Linux where it would no longer use the fast-path ``vfork()`` system call when it could have due to a logic bug, instead falling back to the safe but slower ``fork()``.\r\n\r\nAlso fixed a second 3.12.0 potential security bug.  If a value of ``extra_groups=[]`` was passed to `subprocess.Popen` or related APIs, the underlying ``setgroups(0, NULL)`` system call to clear the groups list would not be made in the child process prior to ``exec()``.\r\n\r\nThe security issue was identified via code inspection in the process of fixing the first bug.  Thanks to @vain for the detailed report and analysis in the initial bug on Github.\r\n\r\n * [ ] A regression test regarding vfork usage is desirable. I'm pondering a test that runs when `strace` is available and permitted which and confirms use of `vfork()` vs `clone()`...\r\n * [x] A test that will catch ``setgroup()`` not being called is included in this PR. It must be run as `root` on Linux. I believe one of our buildbots is configured to run that way.\r\n * [x] Discuss with Python Security Response team if this is also a noteworthy security fix. It could manifest when a root uid=0 process wants to drop other group memberships while executing a subprocess. Probably security relevant if the `user=` and `group=` parameters are also being used to drop privs...\r\n\r\nFixes #112334.\r\n\r\nThe security issue has been assigned [CVE-2023-6507](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-6507).\r\n\r\n<!-- gh-issue-number: gh-112334 -->\r\n* Issue: gh-112334\r\n<!-- /gh-issue-number -->\r\n",
      ":robot: New build scheduled with the buildbot fleet by @gpshead for commit 84d060f0af01c5e6e3392095e62be621f95704f3 :robot:\n\nIf you want to schedule another build, you need to add the <kbd>:hammer: test-with-buildbots</kbd> label again.\n",
      "@gpshead Thank you! FWIW, this fixes my test case. :)",
      ":robot: New build scheduled with the buildbot fleet by @serhiy-storchaka for commit ce31462bd308e0fd5e5feb543745396220667656 :robot:\n\nIf you want to schedule another build, you need to add the <kbd>:hammer: test-with-buildbots</kbd> label again.\n",
      "Thanks @gpshead for the PR 🌮🎉.. I'm working now to backport this PR to: 3.12.\n🐍🍒⛏🤖 ",
      "[GH-112731](https://github.com/python/cpython/pull/112731) is a backport of this pull request to the [3.12 branch](https://github.com/python/cpython/tree/3.12).",
      "I will add the desired vfork regression test in a followup PR. Merging now to unblock releasing the fix."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies an assertion to correctly handle the `extra_groups` parameter, ensuring the `setgroups` function is called properly. This addresses a security vulnerability where not calling `setgroups` could lead to improper privilege handling. The PR title and comments confirm it's a security fix with a CVE assigned.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}