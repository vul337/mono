{
  "cve_id": "CVE-2024-25679",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "p-quic/pquic",
  "commit_msg": "discard the keys after handshake is done; use the correct original_destination_connection_id; discard the re-transmission packets correctly; limit the active_connection_id",
  "commit_hash": "2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "git_url": "https://github.com/p-quic/pquic/commit/2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "file_path": "picoquic/sender.c",
  "func_name": "picoquic_prepare_packet_server_init",
  "func_before": "int picoquic_prepare_packet_server_init(picoquic_cnx_t* cnx, picoquic_path_t ** path, picoquic_packet_t* packet,\n    uint64_t current_time, uint8_t* send_buffer, size_t send_buffer_max, size_t* send_length)\n{\n    int ret = 0;\n    int tls_ready = 0;\n    int epoch = 0;\n    picoquic_packet_type_enum packet_type = picoquic_packet_initial;\n    picoquic_packet_context_enum pc = picoquic_packet_context_initial;\n    uint32_t checksum_overhead = 8;\n    int is_cleartext_mode = 1;\n    size_t data_bytes = 0;\n    uint32_t header_length = 0;\n    uint8_t* bytes = packet->bytes;\n    uint32_t length = 0;\n    char * reason = NULL;  // The potential reason for retransmitting a packet\n    /* This packet MUST be sent on initial path */\n    *path = cnx->path[0];\n    picoquic_path_t* path_x = *path;\n\n    if (cnx->crypto_context[2].aead_encrypt != NULL &&\n        cnx->tls_stream[0].send_queue == NULL) {\n        epoch = 2;\n        pc = picoquic_packet_context_handshake;\n        packet_type = picoquic_packet_handshake;\n    }\n\n    PUSH_LOG_CTX(cnx, \"\\\"packet_type\\\": \\\"%s\\\"\", picoquic_log_ptype_name(packet_type));\n\n    send_buffer_max = (send_buffer_max > path_x->send_mtu) ? path_x->send_mtu : send_buffer_max;\n\n\n    /* If context is handshake, verify first that there is no need for retransmit or ack\n    * on initial context */\n    if (ret == 0 && pc == picoquic_packet_context_handshake) {\n        length = picoquic_prepare_packet_old_context(cnx, picoquic_packet_context_initial,\n            path_x, packet, send_buffer_max, current_time, &header_length);\n    }\n\n    if (length == 0) {\n        struct iovec *rtx_frame = (struct iovec *) queue_peek(cnx->rtx_frames[pc]);\n        size_t rtx_frame_len = rtx_frame ? rtx_frame->iov_len : 0;\n\n        checksum_overhead = picoquic_get_checksum_length(cnx, is_cleartext_mode);\n\n        tls_ready = picoquic_is_tls_stream_ready(cnx);\n\n        length = picoquic_predict_packet_header_length(cnx, packet_type, path_x);\n        packet->ptype = packet_type;\n        packet->offset = length;\n        header_length = length;\n        packet->sequence_number = path_x->pkt_ctx[pc].send_sequence;\n        packet->send_time = current_time;\n        packet->send_path = path_x;\n        packet->pc = pc;\n\n        if ((tls_ready != 0 && path_x->cwin > path_x->bytes_in_transit)\n            || path_x->pkt_ctx[pc].ack_needed || rtx_frame_len > 0) {\n            if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length],\n                send_buffer_max - checksum_overhead - length, &data_bytes)\n                == 0) {\n                length += (uint32_t)data_bytes;\n                data_bytes = 0;\n            }\n\n            while ((rtx_frame = queue_peek(cnx->rtx_frames[pc])) != NULL &&\n                   length + rtx_frame->iov_len + checksum_overhead < send_buffer_max) {\n                rtx_frame = queue_dequeue(cnx->rtx_frames[pc]);\n                memcpy(bytes + length, rtx_frame->iov_base, rtx_frame->iov_len);\n                length += (uint32_t)rtx_frame->iov_len;\n                data_bytes = rtx_frame->iov_len;\n                packet->is_pure_ack = false;\n                packet->is_congestion_controlled = true;\n                free(rtx_frame->iov_base);\n                free(rtx_frame);\n            }\n\n            /* Encode the crypto frame */\n            ret = picoquic_prepare_crypto_hs_frame(cnx, epoch, &bytes[length],\n                send_buffer_max - checksum_overhead - length, &data_bytes);\n            if (ret == 0) {\n                if (data_bytes > 0) {\n                    packet->is_pure_ack = 0;\n                    packet->contains_crypto = 1;\n                    packet->is_congestion_controlled = 1;\n                }\n                length += (uint32_t)data_bytes;\n            }\n            else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                /* todo: reset offset to previous position? */\n                ret = 0;\n            }\n\n            /* progress the state if the epoch data is all sent */\n\n            if (ret == 0 && tls_ready != 0 && data_bytes > 0 && cnx->tls_stream[epoch].send_queue == NULL) {\n                if (epoch == 2 && picoquic_tls_client_authentication_activated(cnx->quic) == 0) {\n                    picoquic_set_cnx_state(cnx, picoquic_state_server_ready);\n                    if (cnx->callback_fn != NULL) {\n                        if (cnx->callback_fn(cnx, 0, NULL, 0, picoquic_callback_almost_ready, cnx->callback_ctx, NULL) != 0) {\n                            picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_INTERNAL_ERROR, 0);\n                        }\n                    }\n                }\n                else {\n                    picoquic_set_cnx_state(cnx, picoquic_state_server_handshake);\n                }\n            }\n\n            packet->length = length;\n\n        }\n        else  if ((length = picoquic_retransmit_needed(cnx, pc, path_x, current_time, packet, send_buffer_max, &is_cleartext_mode, &header_length, &reason)) > 0) {\n            if (reason != NULL) {\n                protoop_id_t pid = { .id = reason };\n                pid.hash = hash_value_str(pid.id);\n                protoop_prepare_and_run_noparam(cnx, &pid, NULL, packet);\n            }\n            /* Set the new checksum length */\n            checksum_overhead = picoquic_get_checksum_length(cnx, is_cleartext_mode);\n            /* Check whether it makes sens to add an ACK at the end of the retransmission */\n            if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length],\n                send_buffer_max - checksum_overhead - length, &data_bytes)\n                == 0) {\n                length += (uint32_t)data_bytes;\n                packet->length = length;\n            }\n            /* document the send time & overhead */\n            packet->send_time = current_time;\n            packet->checksum_overhead = checksum_overhead;\n            packet->is_pure_ack = 0;\n        }\n        else if (path_x->pkt_ctx[pc].ack_needed) {\n            /* when in a handshake mode, send acks asap. */\n            length = picoquic_predict_packet_header_length(cnx, packet_type, path_x);\n\n            if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length],\n                send_buffer_max - checksum_overhead - length, &data_bytes)\n                == 0) {\n                length += (uint32_t)data_bytes;\n                packet->length = length;\n            }\n        } else {\n            length = 0;\n            packet->length = 0;\n        }\n    }\n\n    packet->is_congestion_controlled = 1;\n    picoquic_finalize_and_protect_packet(cnx, packet,\n        ret, length, header_length, checksum_overhead,\n        send_length, send_buffer, (uint32_t)send_buffer_max, path_x, current_time);\n\n    picoquic_cnx_set_next_wake_time(cnx, current_time);\n\n    POP_LOG_CTX(cnx);\n\n    return ret;\n}",
  "abstract_func_before": "int picoquic_prepare_packet_server_init(picoquic_cnx_t* VAR_0, picoquic_path_t ** VAR_1, picoquic_packet_t* VAR_2,\n    uint64_t VAR_3, uint8_t* VAR_4, size_t VAR_5, size_t* VAR_6)\n{\n    int VAR_7 = 0;\n    int VAR_8 = 0;\n    int VAR_9 = 0;\n    picoquic_packet_type_enum VAR_10 = VAR_11;\n    picoquic_packet_context_enum VAR_12 = VAR_13;\n    uint32_t VAR_14 = 8;\n    int VAR_15 = 1;\n    size_t VAR_16 = 0;\n    uint32_t VAR_17 = 0;\n    uint8_t* VAR_18 = VAR_2->bytes;\n    uint32_t VAR_19 = 0;\n    char * VAR_20 = NULL;  /* COMMENT_0 */\n    /* COMMENT_1 */\n    *VAR_1 = VAR_0->path[0];\n    picoquic_path_t* VAR_21 = *VAR_1;\n\n    if (VAR_0->crypto_context[2].aead_encrypt != NULL &&\n        VAR_0->tls_stream[0].send_queue == NULL) {\n        VAR_9 = 2;\n        VAR_12 = VAR_22;\n        VAR_10 = VAR_23;\n    }\n\n    PUSH_LOG_CTX(VAR_0, \"\\\"packet_type\\\": \\\"%s\\\"\", picoquic_log_ptype_name(VAR_10));\n\n    VAR_5 = (VAR_5 > VAR_21->send_mtu) ? VAR_21->send_mtu : VAR_5;\n\n\n    /* COMMENT_2 */\n                           \n    if (VAR_7 == 0 && VAR_12 == VAR_22) {\n        VAR_19 = picoquic_prepare_packet_old_context(VAR_0, VAR_13,\n            VAR_21, VAR_2, VAR_5, VAR_3, &VAR_17);\n    }\n\n    if (VAR_19 == 0) {\n        struct iovec *VAR_24 = (struct iovec *) queue_peek(VAR_0->rtx_frames[VAR_12]);\n        size_t VAR_25 = VAR_24 ? VAR_24->iov_len : 0;\n\n        VAR_14 = picoquic_get_checksum_length(VAR_0, VAR_15);\n\n        VAR_8 = picoquic_is_tls_stream_ready(VAR_0);\n\n        VAR_19 = picoquic_predict_packet_header_length(VAR_0, VAR_10, VAR_21);\n        VAR_2->ptype = VAR_10;\n        VAR_2->offset = VAR_19;\n        VAR_17 = VAR_19;\n        VAR_2->sequence_number = VAR_21->pkt_ctx[VAR_12].send_sequence;\n        VAR_2->send_time = VAR_3;\n        VAR_2->send_path = VAR_21;\n        VAR_2->pc = VAR_12;\n\n        if ((VAR_8 != 0 && VAR_21->cwin > VAR_21->bytes_in_transit)\n            || VAR_21->pkt_ctx[VAR_12].ack_needed || VAR_25 > 0) {\n            if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_18[VAR_19],\n                VAR_5 - VAR_14 - VAR_19, &VAR_16)\n                == 0) {\n                VAR_19 += (uint32_t)VAR_16;\n                VAR_16 = 0;\n            }\n\n            while ((VAR_24 = queue_peek(VAR_0->rtx_frames[VAR_12])) != NULL &&\n                   VAR_19 + VAR_24->iov_len + VAR_14 < VAR_5) {\n                VAR_24 = queue_dequeue(VAR_0->rtx_frames[VAR_12]);\n                memcpy(VAR_18 + VAR_19, VAR_24->iov_base, VAR_24->iov_len);\n                VAR_19 += (uint32_t)VAR_24->iov_len;\n                VAR_16 = VAR_24->iov_len;\n                VAR_2->is_pure_ack = false;\n                VAR_2->is_congestion_controlled = true;\n                free(VAR_24->iov_base);\n                free(VAR_24);\n            }\n\n            /* COMMENT_4 */\n            VAR_7 = picoquic_prepare_crypto_hs_frame(VAR_0, VAR_9, &VAR_18[VAR_19],\n                VAR_5 - VAR_14 - VAR_19, &VAR_16);\n            if (VAR_7 == 0) {\n                if (VAR_16 > 0) {\n                    VAR_2->is_pure_ack = 0;\n                    VAR_2->contains_crypto = 1;\n                    VAR_2->is_congestion_controlled = 1;\n                }\n                VAR_19 += (uint32_t)VAR_16;\n            }\n            else if (VAR_7 == VAR_26) {\n                /* COMMENT_5 */\n                VAR_7 = 0;\n            }\n\n            /* COMMENT_6 */\n\n            if (VAR_7 == 0 && VAR_8 != 0 && VAR_16 > 0 && VAR_0->tls_stream[VAR_9].send_queue == NULL) {\n                if (VAR_9 == 2 && picoquic_tls_client_authentication_activated(VAR_0->quic) == 0) {\n                    picoquic_set_cnx_state(VAR_0, VAR_27);\n                    if (VAR_0->callback_fn != NULL) {\n                        if (VAR_0->callback_fn(VAR_0, 0, NULL, 0, VAR_28, VAR_0->callback_ctx, NULL) != 0) {\n                            picoquic_connection_error(VAR_0, VAR_29, 0);\n                        }\n                    }\n                }\n                else {\n                    picoquic_set_cnx_state(VAR_0, VAR_30);\n                }\n            }\n\n            VAR_2->length = VAR_19;\n\n        }\n        else  if ((VAR_19 = picoquic_retransmit_needed(VAR_0, VAR_12, VAR_21, VAR_3, VAR_2, VAR_5, &VAR_15, &VAR_17, &VAR_20)) > 0) {\n            if (VAR_20 != NULL) {\n                protoop_id_t VAR_31 = { .id = VAR_20 };\n                VAR_31.hash = hash_value_str(VAR_31.id);\n                protoop_prepare_and_run_noparam(VAR_0, &VAR_31, NULL, VAR_2);\n            }\n            /* COMMENT_7 */\n            VAR_14 = picoquic_get_checksum_length(VAR_0, VAR_15);\n            /* COMMENT_8 */\n            if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_18[VAR_19],\n                VAR_5 - VAR_14 - VAR_19, &VAR_16)\n                == 0) {\n                VAR_19 += (uint32_t)VAR_16;\n                VAR_2->length = VAR_19;\n            }\n            /* COMMENT_9 */\n            VAR_2->send_time = VAR_3;\n            VAR_2->checksum_overhead = VAR_14;\n            VAR_2->is_pure_ack = 0;\n        }\n        else if (VAR_21->pkt_ctx[VAR_12].ack_needed) {\n            /* COMMENT_10 */\n            VAR_19 = picoquic_predict_packet_header_length(VAR_0, VAR_10, VAR_21);\n\n            if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_18[VAR_19],\n                VAR_5 - VAR_14 - VAR_19, &VAR_16)\n                == 0) {\n                VAR_19 += (uint32_t)VAR_16;\n                VAR_2->length = VAR_19;\n            }\n        } else {\n            VAR_19 = 0;\n            VAR_2->length = 0;\n        }\n    }\n\n    VAR_2->is_congestion_controlled = 1;\n    picoquic_finalize_and_protect_packet(VAR_0, VAR_2,\n        VAR_7, VAR_19, VAR_17, VAR_14,\n        VAR_6, VAR_4, (uint32_t)VAR_5, VAR_21, VAR_3);\n\n    picoquic_cnx_set_next_wake_time(VAR_0, VAR_3);\n\n    POP_LOG_CTX(VAR_0);\n\n    return VAR_7;\n}",
  "func_graph_path_before": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/sender.c/vul/before/4.json",
  "func": "int picoquic_prepare_packet_server_init(picoquic_cnx_t* cnx, picoquic_path_t ** path, picoquic_packet_t* packet,\n    uint64_t current_time, uint8_t* send_buffer, size_t send_buffer_max, size_t* send_length)\n{\n    int ret = 0;\n    int tls_ready = 0;\n    int epoch = 0;\n    picoquic_packet_type_enum packet_type = picoquic_packet_initial;\n    picoquic_packet_context_enum pc = picoquic_packet_context_initial;\n    uint32_t checksum_overhead = 8;\n    int is_cleartext_mode = 1;\n    size_t data_bytes = 0;\n    uint32_t header_length = 0;\n    uint8_t* bytes = packet->bytes;\n    uint32_t length = 0;\n    char * reason = NULL;  // The potential reason for retransmitting a packet\n    /* This packet MUST be sent on initial path */\n    *path = cnx->path[0];\n    picoquic_path_t* path_x = *path;\n\n    if (cnx->crypto_context[2].aead_encrypt != NULL &&\n        cnx->tls_stream[0].send_queue == NULL) {\n        epoch = 2;\n        pc = picoquic_packet_context_handshake;\n        packet_type = picoquic_packet_handshake;\n    }\n\n    PUSH_LOG_CTX(cnx, \"\\\"packet_type\\\": \\\"%s\\\"\", picoquic_log_ptype_name(packet_type));\n\n    send_buffer_max = (send_buffer_max > path_x->send_mtu) ? path_x->send_mtu : send_buffer_max;\n\n\n    /* If context is handshake, verify first that there is no need for retransmit or ack\n    * on initial context */\n    if (ret == 0 && pc == picoquic_packet_context_handshake && cnx->crypto_context[0].aead_encrypt != NULL) {\n        length = picoquic_prepare_packet_old_context(cnx, picoquic_packet_context_initial,\n            path_x, packet, send_buffer_max, current_time, &header_length);\n    }\n\n    if (length == 0) {\n        struct iovec *rtx_frame = (struct iovec *) queue_peek(cnx->rtx_frames[pc]);\n        size_t rtx_frame_len = rtx_frame ? rtx_frame->iov_len : 0;\n\n        checksum_overhead = picoquic_get_checksum_length(cnx, is_cleartext_mode);\n\n        tls_ready = picoquic_is_tls_stream_ready(cnx);\n\n        length = picoquic_predict_packet_header_length(cnx, packet_type, path_x);\n        packet->ptype = packet_type;\n        packet->offset = length;\n        header_length = length;\n        packet->sequence_number = path_x->pkt_ctx[pc].send_sequence;\n        packet->send_time = current_time;\n        packet->send_path = path_x;\n        packet->pc = pc;\n\n        if ((tls_ready != 0 && path_x->cwin > path_x->bytes_in_transit)\n            || path_x->pkt_ctx[pc].ack_needed || rtx_frame_len > 0) {\n            if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length],\n                send_buffer_max - checksum_overhead - length, &data_bytes)\n                == 0) {\n                length += (uint32_t)data_bytes;\n                data_bytes = 0;\n            }\n\n            while ((rtx_frame = queue_peek(cnx->rtx_frames[pc])) != NULL &&\n                   length + rtx_frame->iov_len + checksum_overhead < send_buffer_max) {\n                rtx_frame = queue_dequeue(cnx->rtx_frames[pc]);\n                memcpy(bytes + length, rtx_frame->iov_base, rtx_frame->iov_len);\n                length += (uint32_t)rtx_frame->iov_len;\n                data_bytes = rtx_frame->iov_len;\n                packet->is_pure_ack = false;\n                packet->is_congestion_controlled = true;\n                free(rtx_frame->iov_base);\n                free(rtx_frame);\n            }\n\n            /* Encode the crypto frame */\n            ret = picoquic_prepare_crypto_hs_frame(cnx, epoch, &bytes[length],\n                send_buffer_max - checksum_overhead - length, &data_bytes);\n            if (ret == 0) {\n                if (data_bytes > 0) {\n                    packet->is_pure_ack = 0;\n                    packet->contains_crypto = 1;\n                    packet->is_congestion_controlled = 1;\n                }\n                length += (uint32_t)data_bytes;\n            }\n            else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                /* todo: reset offset to previous position? */\n                ret = 0;\n            }\n\n            /* progress the state if the epoch data is all sent */\n\n            if (ret == 0 && tls_ready != 0 && data_bytes > 0 && cnx->tls_stream[epoch].send_queue == NULL) {\n                if (epoch == 2 && picoquic_tls_client_authentication_activated(cnx->quic) == 0) {\n                    picoquic_set_cnx_state(cnx, picoquic_state_server_ready);\n                    if (cnx->callback_fn != NULL) {\n                        if (cnx->callback_fn(cnx, 0, NULL, 0, picoquic_callback_almost_ready, cnx->callback_ctx, NULL) != 0) {\n                            picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_INTERNAL_ERROR, 0);\n                        }\n                    }\n                }\n                else {\n                    picoquic_set_cnx_state(cnx, picoquic_state_server_handshake);\n                }\n            }\n\n            packet->length = length;\n\n        }\n        else  if ((length = picoquic_retransmit_needed(cnx, pc, path_x, current_time, packet, send_buffer_max, &is_cleartext_mode, &header_length, &reason)) > 0) {\n            if (reason != NULL) {\n                protoop_id_t pid = { .id = reason };\n                pid.hash = hash_value_str(pid.id);\n                protoop_prepare_and_run_noparam(cnx, &pid, NULL, packet);\n            }\n            /* Set the new checksum length */\n            checksum_overhead = picoquic_get_checksum_length(cnx, is_cleartext_mode);\n            /* Check whether it makes sens to add an ACK at the end of the retransmission */\n            if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length],\n                send_buffer_max - checksum_overhead - length, &data_bytes)\n                == 0) {\n                length += (uint32_t)data_bytes;\n                packet->length = length;\n            }\n            /* document the send time & overhead */\n            packet->send_time = current_time;\n            packet->checksum_overhead = checksum_overhead;\n            packet->is_pure_ack = 0;\n        }\n        else if (path_x->pkt_ctx[pc].ack_needed) {\n            /* when in a handshake mode, send acks asap. */\n            length = picoquic_predict_packet_header_length(cnx, packet_type, path_x);\n\n            if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length],\n                send_buffer_max - checksum_overhead - length, &data_bytes)\n                == 0) {\n                length += (uint32_t)data_bytes;\n                packet->length = length;\n            }\n        } else {\n            length = 0;\n            packet->length = 0;\n        }\n    }\n\n    packet->is_congestion_controlled = 1;\n    picoquic_finalize_and_protect_packet(cnx, packet,\n        ret, length, header_length, checksum_overhead,\n        send_length, send_buffer, (uint32_t)send_buffer_max, path_x, current_time);\n\n    picoquic_cnx_set_next_wake_time(cnx, current_time);\n\n    POP_LOG_CTX(cnx);\n\n    return ret;\n}",
  "abstract_func": "int picoquic_prepare_packet_server_init(picoquic_cnx_t* VAR_0, picoquic_path_t ** VAR_1, picoquic_packet_t* VAR_2,\n    uint64_t VAR_3, uint8_t* VAR_4, size_t VAR_5, size_t* VAR_6)\n{\n    int VAR_7 = 0;\n    int VAR_8 = 0;\n    int VAR_9 = 0;\n    picoquic_packet_type_enum VAR_10 = VAR_11;\n    picoquic_packet_context_enum VAR_12 = VAR_13;\n    uint32_t VAR_14 = 8;\n    int VAR_15 = 1;\n    size_t VAR_16 = 0;\n    uint32_t VAR_17 = 0;\n    uint8_t* VAR_18 = VAR_2->bytes;\n    uint32_t VAR_19 = 0;\n    char * VAR_20 = NULL;  /* COMMENT_0 */\n    /* COMMENT_1 */\n    *VAR_1 = VAR_0->path[0];\n    picoquic_path_t* VAR_21 = *VAR_1;\n\n    if (VAR_0->crypto_context[2].aead_encrypt != NULL &&\n        VAR_0->tls_stream[0].send_queue == NULL) {\n        VAR_9 = 2;\n        VAR_12 = VAR_22;\n        VAR_10 = VAR_23;\n    }\n\n    PUSH_LOG_CTX(VAR_0, \"\\\"packet_type\\\": \\\"%s\\\"\", picoquic_log_ptype_name(VAR_10));\n\n    VAR_5 = (VAR_5 > VAR_21->send_mtu) ? VAR_21->send_mtu : VAR_5;\n\n\n    /* COMMENT_2 */\n                           \n    if (VAR_7 == 0 && VAR_12 == VAR_22 && VAR_0->crypto_context[0].aead_encrypt != NULL) {\n        VAR_19 = picoquic_prepare_packet_old_context(VAR_0, VAR_13,\n            VAR_21, VAR_2, VAR_5, VAR_3, &VAR_17);\n    }\n\n    if (VAR_19 == 0) {\n        struct iovec *VAR_24 = (struct iovec *) queue_peek(VAR_0->rtx_frames[VAR_12]);\n        size_t VAR_25 = VAR_24 ? VAR_24->iov_len : 0;\n\n        VAR_14 = picoquic_get_checksum_length(VAR_0, VAR_15);\n\n        VAR_8 = picoquic_is_tls_stream_ready(VAR_0);\n\n        VAR_19 = picoquic_predict_packet_header_length(VAR_0, VAR_10, VAR_21);\n        VAR_2->ptype = VAR_10;\n        VAR_2->offset = VAR_19;\n        VAR_17 = VAR_19;\n        VAR_2->sequence_number = VAR_21->pkt_ctx[VAR_12].send_sequence;\n        VAR_2->send_time = VAR_3;\n        VAR_2->send_path = VAR_21;\n        VAR_2->pc = VAR_12;\n\n        if ((VAR_8 != 0 && VAR_21->cwin > VAR_21->bytes_in_transit)\n            || VAR_21->pkt_ctx[VAR_12].ack_needed || VAR_25 > 0) {\n            if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_18[VAR_19],\n                VAR_5 - VAR_14 - VAR_19, &VAR_16)\n                == 0) {\n                VAR_19 += (uint32_t)VAR_16;\n                VAR_16 = 0;\n            }\n\n            while ((VAR_24 = queue_peek(VAR_0->rtx_frames[VAR_12])) != NULL &&\n                   VAR_19 + VAR_24->iov_len + VAR_14 < VAR_5) {\n                VAR_24 = queue_dequeue(VAR_0->rtx_frames[VAR_12]);\n                memcpy(VAR_18 + VAR_19, VAR_24->iov_base, VAR_24->iov_len);\n                VAR_19 += (uint32_t)VAR_24->iov_len;\n                VAR_16 = VAR_24->iov_len;\n                VAR_2->is_pure_ack = false;\n                VAR_2->is_congestion_controlled = true;\n                free(VAR_24->iov_base);\n                free(VAR_24);\n            }\n\n            /* COMMENT_4 */\n            VAR_7 = picoquic_prepare_crypto_hs_frame(VAR_0, VAR_9, &VAR_18[VAR_19],\n                VAR_5 - VAR_14 - VAR_19, &VAR_16);\n            if (VAR_7 == 0) {\n                if (VAR_16 > 0) {\n                    VAR_2->is_pure_ack = 0;\n                    VAR_2->contains_crypto = 1;\n                    VAR_2->is_congestion_controlled = 1;\n                }\n                VAR_19 += (uint32_t)VAR_16;\n            }\n            else if (VAR_7 == VAR_26) {\n                /* COMMENT_5 */\n                VAR_7 = 0;\n            }\n\n            /* COMMENT_6 */\n\n            if (VAR_7 == 0 && VAR_8 != 0 && VAR_16 > 0 && VAR_0->tls_stream[VAR_9].send_queue == NULL) {\n                if (VAR_9 == 2 && picoquic_tls_client_authentication_activated(VAR_0->quic) == 0) {\n                    picoquic_set_cnx_state(VAR_0, VAR_27);\n                    if (VAR_0->callback_fn != NULL) {\n                        if (VAR_0->callback_fn(VAR_0, 0, NULL, 0, VAR_28, VAR_0->callback_ctx, NULL) != 0) {\n                            picoquic_connection_error(VAR_0, VAR_29, 0);\n                        }\n                    }\n                }\n                else {\n                    picoquic_set_cnx_state(VAR_0, VAR_30);\n                }\n            }\n\n            VAR_2->length = VAR_19;\n\n        }\n        else  if ((VAR_19 = picoquic_retransmit_needed(VAR_0, VAR_12, VAR_21, VAR_3, VAR_2, VAR_5, &VAR_15, &VAR_17, &VAR_20)) > 0) {\n            if (VAR_20 != NULL) {\n                protoop_id_t VAR_31 = { .id = VAR_20 };\n                VAR_31.hash = hash_value_str(VAR_31.id);\n                protoop_prepare_and_run_noparam(VAR_0, &VAR_31, NULL, VAR_2);\n            }\n            /* COMMENT_7 */\n            VAR_14 = picoquic_get_checksum_length(VAR_0, VAR_15);\n            /* COMMENT_8 */\n            if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_18[VAR_19],\n                VAR_5 - VAR_14 - VAR_19, &VAR_16)\n                == 0) {\n                VAR_19 += (uint32_t)VAR_16;\n                VAR_2->length = VAR_19;\n            }\n            /* COMMENT_9 */\n            VAR_2->send_time = VAR_3;\n            VAR_2->checksum_overhead = VAR_14;\n            VAR_2->is_pure_ack = 0;\n        }\n        else if (VAR_21->pkt_ctx[VAR_12].ack_needed) {\n            /* COMMENT_10 */\n            VAR_19 = picoquic_predict_packet_header_length(VAR_0, VAR_10, VAR_21);\n\n            if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_18[VAR_19],\n                VAR_5 - VAR_14 - VAR_19, &VAR_16)\n                == 0) {\n                VAR_19 += (uint32_t)VAR_16;\n                VAR_2->length = VAR_19;\n            }\n        } else {\n            VAR_19 = 0;\n            VAR_2->length = 0;\n        }\n    }\n\n    VAR_2->is_congestion_controlled = 1;\n    picoquic_finalize_and_protect_packet(VAR_0, VAR_2,\n        VAR_7, VAR_19, VAR_17, VAR_14,\n        VAR_6, VAR_4, (uint32_t)VAR_5, VAR_21, VAR_3);\n\n    picoquic_cnx_set_next_wake_time(VAR_0, VAR_3);\n\n    POP_LOG_CTX(VAR_0);\n\n    return VAR_7;\n}",
  "func_graph_path": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/sender.c/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n     /* If context is handshake, verify first that there is no need for retransmit or ack\n     * on initial context */\n-    if (ret == 0 && pc == picoquic_packet_context_handshake) {\n+    if (ret == 0 && pc == picoquic_packet_context_handshake && cnx->crypto_context[0].aead_encrypt != NULL) {\n         length = picoquic_prepare_packet_old_context(cnx, picoquic_packet_context_initial,\n             path_x, packet, send_buffer_max, current_time, &header_length);\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "    if (ret == 0 && pc == picoquic_packet_context_handshake) {"
    ],
    "added_lines": [
      "    if (ret == 0 && pc == picoquic_packet_context_handshake && cnx->crypto_context[0].aead_encrypt != NULL) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/p-quic/pquic/pull/39",
  "description": {
    "pr_info": {
      "title": "Minor Fix",
      "number": 39
    },
    "comment": [
      "Hi, I try to fix the bugs in #34 #35 #36 and #38.\r\n\r\nCan you validate these fixes please.\r\n",
      "The code looks good. Have you done any test to ensure it fixes these issues ?"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch addresses issues in handling QUIC packets after the handshake, ensuring proper encryption context checks to prevent functional bugs. It doesn't explicitly fix a security vulnerability but corrects protocol implementation issues.\n\n**Final Classification: Defect Remediation & Feature Upgrades**\n\n**Confidence Score: 0.8**"
}