{
  "cve_id": "CVE-2018-20196",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "sbr_fbt: sbr->M should not exceed MAX_M\n\nsbr->M is set by derived_frequency_table() from user-passed input\nwithout checking for > MAX_M.\n\nThis leads to out-of-bounds accesses later, crashes and potential\nsecurity relevant issues. It should be considered a fatal error for\nthe SBR block.\n\nreturn error code if sbr->M > MAX_M.\n\nalso, in some cases sbr_extension_data() ignores the return value of\ncalc_sbr_tables, probably assuming that sbr is always valid. It should\nalmost certainly not do that.\n\nfixes #19 (CVE-2018-20196).",
  "commit_hash": "6aeeaa1af0caf986daf22852a97f7c13c5edd879",
  "git_url": "https://github.com/knik0/faad2/commit/6aeeaa1af0caf986daf22852a97f7c13c5edd879",
  "file_path": "libfaad/sbr_fbt.c",
  "func_name": "derived_frequency_table",
  "func_before": "uint8_t derived_frequency_table(sbr_info *sbr, uint8_t bs_xover_band,\n                                uint8_t k2)\n{\n    uint8_t k, i;\n    uint32_t minus;\n\n    /* The following relation shall be satisfied: bs_xover_band < N_Master */\n    if (sbr->N_master <= bs_xover_band)\n        return 1;\n\n    sbr->N_high = sbr->N_master - bs_xover_band;\n    sbr->N_low = (sbr->N_high>>1) + (sbr->N_high - ((sbr->N_high>>1)<<1));\n\n    sbr->n[0] = sbr->N_low;\n    sbr->n[1] = sbr->N_high;\n\n    for (k = 0; k <= sbr->N_high; k++)\n    {\n        sbr->f_table_res[HI_RES][k] = sbr->f_master[k + bs_xover_band];\n    }\n\n    sbr->M = sbr->f_table_res[HI_RES][sbr->N_high] - sbr->f_table_res[HI_RES][0];\n    sbr->kx = sbr->f_table_res[HI_RES][0];\n    if (sbr->kx > 32)\n        return 1;\n    if (sbr->kx + sbr->M > 64)\n        return 1;\n\n    minus = (sbr->N_high & 1) ? 1 : 0;\n\n    for (k = 0; k <= sbr->N_low; k++)\n    {\n        if (k == 0)\n            i = 0;\n        else\n            i = (uint8_t)(2*k - minus);\n        sbr->f_table_res[LO_RES][k] = sbr->f_table_res[HI_RES][i];\n    }\n\n#if 0\n    printf(\"bs_freq_scale: %d\\n\", sbr->bs_freq_scale);\n    printf(\"bs_limiter_bands: %d\\n\", sbr->bs_limiter_bands);\n    printf(\"f_table_res[HI_RES][%d]: \", sbr->N_high);\n    for (k = 0; k <= sbr->N_high; k++)\n    {\n        printf(\"%d \", sbr->f_table_res[HI_RES][k]);\n    }\n    printf(\"\\n\");\n#endif\n#if 0\n    printf(\"f_table_res[LO_RES][%d]: \", sbr->N_low);\n    for (k = 0; k <= sbr->N_low; k++)\n    {\n        printf(\"%d \", sbr->f_table_res[LO_RES][k]);\n    }\n    printf(\"\\n\");\n#endif\n\n    sbr->N_Q = 0;\n    if (sbr->bs_noise_bands == 0)\n    {\n        sbr->N_Q = 1;\n    } else {\n#if 0\n        sbr->N_Q = max(1, (int32_t)(sbr->bs_noise_bands*(log(k2/(float)sbr->kx)/log(2.0)) + 0.5));\n#else\n        sbr->N_Q = (uint8_t)(max(1, find_bands(0, sbr->bs_noise_bands, sbr->kx, k2)));\n#endif\n        sbr->N_Q = min(5, sbr->N_Q);\n    }\n\n    for (k = 0; k <= sbr->N_Q; k++)\n    {\n        if (k == 0)\n        {\n            i = 0;\n        } else {\n            /* i = i + (int32_t)((sbr->N_low - i)/(sbr->N_Q + 1 - k)); */\n            i = i + (sbr->N_low - i)/(sbr->N_Q + 1 - k);\n        }\n        sbr->f_table_noise[k] = sbr->f_table_res[LO_RES][i];\n    }\n\n    /* build table for mapping k to g in hf patching */\n    for (k = 0; k < 64; k++)\n    {\n        uint8_t g;\n        for (g = 0; g < sbr->N_Q; g++)\n        {\n            if ((sbr->f_table_noise[g] <= k) &&\n                (k < sbr->f_table_noise[g+1]))\n            {\n                sbr->table_map_k_to_g[k] = g;\n                break;\n            }\n        }\n    }\n\n#if 0\n    printf(\"f_table_noise[%d]: \", sbr->N_Q);\n    for (k = 0; k <= sbr->N_Q; k++)\n    {\n        printf(\"%d \", sbr->f_table_noise[k] - sbr->kx);\n    }\n    printf(\"\\n\");\n#endif\n\n    return 0;\n}",
  "abstract_func_before": "uint8_t derived_frequency_table(sbr_info *VAR_0, uint8_t VAR_1,\n                                uint8_t VAR_2)\n{\n    uint8_t VAR_3, VAR_4;\n    uint32_t VAR_5;\n\n    /* COMMENT_0 */\n    if (VAR_0->N_master <= VAR_1)\n        return 1;\n\n    VAR_0->N_high = VAR_0->N_master - VAR_1;\n    VAR_0->N_low = (VAR_0->N_high>>1) + (VAR_0->N_high - ((VAR_0->N_high>>1)<<1));\n\n    VAR_0->n[0] = VAR_0->N_low;\n    VAR_0->n[1] = VAR_0->N_high;\n\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_high; VAR_3++)\n    {\n        VAR_0->f_table_res[VAR_6][VAR_3] = VAR_0->f_master[VAR_3 + VAR_1];\n    }\n\n    VAR_0->M = VAR_0->f_table_res[VAR_6][VAR_0->N_high] - VAR_0->f_table_res[VAR_6][0];\n    VAR_0->kx = VAR_0->f_table_res[VAR_6][0];\n    if (VAR_0->kx > 32)\n        return 1;\n    if (VAR_0->kx + VAR_0->M > 64)\n        return 1;\n\n    VAR_5 = (VAR_0->N_high & 1) ? 1 : 0;\n\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_low; VAR_3++)\n    {\n        if (VAR_3 == 0)\n            VAR_4 = 0;\n        else\n            VAR_4 = (uint8_t)(2*VAR_3 - VAR_5);\n        VAR_0->f_table_res[VAR_7][VAR_3] = VAR_0->f_table_res[VAR_6][VAR_4];\n    }\n\n#if 0\n    printf(\"bs_freq_scale: %d\\n\", VAR_0->bs_freq_scale);\n    printf(\"bs_limiter_bands: %d\\n\", VAR_0->bs_limiter_bands);\n    printf(\"f_table_res[HI_RES][%d]: \", VAR_0->N_high);\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_high; VAR_3++)\n    {\n        printf(\"%d \", VAR_0->f_table_res[VAR_6][VAR_3]);\n    }\n    printf(\"\\n\");\n#endif\n#if 0\n    printf(\"f_table_res[LO_RES][%d]: \", VAR_0->N_low);\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_low; VAR_3++)\n    {\n        printf(\"%d \", VAR_0->f_table_res[VAR_7][VAR_3]);\n    }\n    printf(\"\\n\");\n#endif\n\n    VAR_0->N_Q = 0;\n    if (VAR_0->bs_noise_bands == 0)\n    {\n        VAR_0->N_Q = 1;\n    } else {\n#if 0\n        VAR_0->N_Q = max(1, (int32_t)(VAR_0->bs_noise_bands*(log(VAR_2/(float)VAR_0->kx)/log(2.0)) + 0.5));\n#else\n        VAR_0->N_Q = (uint8_t)(max(1, find_bands(0, VAR_0->bs_noise_bands, VAR_0->kx, VAR_2)));\n#endif\n        VAR_0->N_Q = min(5, VAR_0->N_Q);\n    }\n\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_Q; VAR_3++)\n    {\n        if (VAR_3 == 0)\n        {\n            VAR_4 = 0;\n        } else {\n            /* COMMENT_1 */\n            VAR_4 = VAR_4 + (VAR_0->N_low - VAR_4)/(VAR_0->N_Q + 1 - VAR_3);\n        }\n        VAR_0->f_table_noise[VAR_3] = VAR_0->f_table_res[VAR_7][VAR_4];\n    }\n\n    /* COMMENT_2 */\n    for (VAR_3 = 0; VAR_3 < 64; VAR_3++)\n    {\n        uint8_t VAR_8;\n        for (VAR_8 = 0; VAR_8 < VAR_0->N_Q; VAR_8++)\n        {\n            if ((VAR_0->f_table_noise[VAR_8] <= VAR_3) &&\n                (VAR_3 < VAR_0->f_table_noise[VAR_8+1]))\n            {\n                VAR_0->table_map_k_to_g[VAR_3] = VAR_8;\n                break;\n            }\n        }\n    }\n\n#if 0\n    printf(\"f_table_noise[%d]: \", VAR_0->N_Q);\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_Q; VAR_3++)\n    {\n        printf(\"%d \", VAR_0->f_table_noise[VAR_3] - VAR_0->kx);\n    }\n    printf(\"\\n\");\n#endif\n\n    return 0;\n}",
  "func_graph_path_before": "knik0/faad2/6aeeaa1af0caf986daf22852a97f7c13c5edd879/sbr_fbt.c/vul/before/0.json",
  "func": "uint8_t derived_frequency_table(sbr_info *sbr, uint8_t bs_xover_band,\n                                uint8_t k2)\n{\n    uint8_t k, i;\n    uint32_t minus;\n\n    /* The following relation shall be satisfied: bs_xover_band < N_Master */\n    if (sbr->N_master <= bs_xover_band)\n        return 1;\n\n    sbr->N_high = sbr->N_master - bs_xover_band;\n    sbr->N_low = (sbr->N_high>>1) + (sbr->N_high - ((sbr->N_high>>1)<<1));\n\n    sbr->n[0] = sbr->N_low;\n    sbr->n[1] = sbr->N_high;\n\n    for (k = 0; k <= sbr->N_high; k++)\n    {\n        sbr->f_table_res[HI_RES][k] = sbr->f_master[k + bs_xover_band];\n    }\n\n    sbr->M = sbr->f_table_res[HI_RES][sbr->N_high] - sbr->f_table_res[HI_RES][0];\n    if (sbr->M > MAX_M)\n        return 1;\n    sbr->kx = sbr->f_table_res[HI_RES][0];\n    if (sbr->kx > 32)\n        return 1;\n    if (sbr->kx + sbr->M > 64)\n        return 1;\n\n    minus = (sbr->N_high & 1) ? 1 : 0;\n\n    for (k = 0; k <= sbr->N_low; k++)\n    {\n        if (k == 0)\n            i = 0;\n        else\n            i = (uint8_t)(2*k - minus);\n        sbr->f_table_res[LO_RES][k] = sbr->f_table_res[HI_RES][i];\n    }\n\n#if 0\n    printf(\"bs_freq_scale: %d\\n\", sbr->bs_freq_scale);\n    printf(\"bs_limiter_bands: %d\\n\", sbr->bs_limiter_bands);\n    printf(\"f_table_res[HI_RES][%d]: \", sbr->N_high);\n    for (k = 0; k <= sbr->N_high; k++)\n    {\n        printf(\"%d \", sbr->f_table_res[HI_RES][k]);\n    }\n    printf(\"\\n\");\n#endif\n#if 0\n    printf(\"f_table_res[LO_RES][%d]: \", sbr->N_low);\n    for (k = 0; k <= sbr->N_low; k++)\n    {\n        printf(\"%d \", sbr->f_table_res[LO_RES][k]);\n    }\n    printf(\"\\n\");\n#endif\n\n    sbr->N_Q = 0;\n    if (sbr->bs_noise_bands == 0)\n    {\n        sbr->N_Q = 1;\n    } else {\n#if 0\n        sbr->N_Q = max(1, (int32_t)(sbr->bs_noise_bands*(log(k2/(float)sbr->kx)/log(2.0)) + 0.5));\n#else\n        sbr->N_Q = (uint8_t)(max(1, find_bands(0, sbr->bs_noise_bands, sbr->kx, k2)));\n#endif\n        sbr->N_Q = min(5, sbr->N_Q);\n    }\n\n    for (k = 0; k <= sbr->N_Q; k++)\n    {\n        if (k == 0)\n        {\n            i = 0;\n        } else {\n            /* i = i + (int32_t)((sbr->N_low - i)/(sbr->N_Q + 1 - k)); */\n            i = i + (sbr->N_low - i)/(sbr->N_Q + 1 - k);\n        }\n        sbr->f_table_noise[k] = sbr->f_table_res[LO_RES][i];\n    }\n\n    /* build table for mapping k to g in hf patching */\n    for (k = 0; k < 64; k++)\n    {\n        uint8_t g;\n        for (g = 0; g < sbr->N_Q; g++)\n        {\n            if ((sbr->f_table_noise[g] <= k) &&\n                (k < sbr->f_table_noise[g+1]))\n            {\n                sbr->table_map_k_to_g[k] = g;\n                break;\n            }\n        }\n    }\n\n#if 0\n    printf(\"f_table_noise[%d]: \", sbr->N_Q);\n    for (k = 0; k <= sbr->N_Q; k++)\n    {\n        printf(\"%d \", sbr->f_table_noise[k] - sbr->kx);\n    }\n    printf(\"\\n\");\n#endif\n\n    return 0;\n}",
  "abstract_func": "uint8_t derived_frequency_table(sbr_info *VAR_0, uint8_t VAR_1,\n                                uint8_t VAR_2)\n{\n    uint8_t VAR_3, VAR_4;\n    uint32_t VAR_5;\n\n    /* COMMENT_0 */\n    if (VAR_0->N_master <= VAR_1)\n        return 1;\n\n    VAR_0->N_high = VAR_0->N_master - VAR_1;\n    VAR_0->N_low = (VAR_0->N_high>>1) + (VAR_0->N_high - ((VAR_0->N_high>>1)<<1));\n\n    VAR_0->n[0] = VAR_0->N_low;\n    VAR_0->n[1] = VAR_0->N_high;\n\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_high; VAR_3++)\n    {\n        VAR_0->f_table_res[VAR_6][VAR_3] = VAR_0->f_master[VAR_3 + VAR_1];\n    }\n\n    VAR_0->M = VAR_0->f_table_res[VAR_6][VAR_0->N_high] - VAR_0->f_table_res[VAR_6][0];\n    if (VAR_0->M > VAR_7)\n        return 1;\n    VAR_0->kx = VAR_0->f_table_res[VAR_6][0];\n    if (VAR_0->kx > 32)\n        return 1;\n    if (VAR_0->kx + VAR_0->M > 64)\n        return 1;\n\n    VAR_5 = (VAR_0->N_high & 1) ? 1 : 0;\n\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_low; VAR_3++)\n    {\n        if (VAR_3 == 0)\n            VAR_4 = 0;\n        else\n            VAR_4 = (uint8_t)(2*VAR_3 - VAR_5);\n        VAR_0->f_table_res[VAR_8][VAR_3] = VAR_0->f_table_res[VAR_6][VAR_4];\n    }\n\n#if 0\n    printf(\"bs_freq_scale: %d\\n\", VAR_0->bs_freq_scale);\n    printf(\"bs_limiter_bands: %d\\n\", VAR_0->bs_limiter_bands);\n    printf(\"f_table_res[HI_RES][%d]: \", VAR_0->N_high);\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_high; VAR_3++)\n    {\n        printf(\"%d \", VAR_0->f_table_res[VAR_6][VAR_3]);\n    }\n    printf(\"\\n\");\n#endif\n#if 0\n    printf(\"f_table_res[LO_RES][%d]: \", VAR_0->N_low);\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_low; VAR_3++)\n    {\n        printf(\"%d \", VAR_0->f_table_res[VAR_8][VAR_3]);\n    }\n    printf(\"\\n\");\n#endif\n\n    VAR_0->N_Q = 0;\n    if (VAR_0->bs_noise_bands == 0)\n    {\n        VAR_0->N_Q = 1;\n    } else {\n#if 0\n        VAR_0->N_Q = max(1, (int32_t)(VAR_0->bs_noise_bands*(log(VAR_2/(float)VAR_0->kx)/log(2.0)) + 0.5));\n#else\n        VAR_0->N_Q = (uint8_t)(max(1, find_bands(0, VAR_0->bs_noise_bands, VAR_0->kx, VAR_2)));\n#endif\n        VAR_0->N_Q = min(5, VAR_0->N_Q);\n    }\n\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_Q; VAR_3++)\n    {\n        if (VAR_3 == 0)\n        {\n            VAR_4 = 0;\n        } else {\n            /* COMMENT_1 */\n            VAR_4 = VAR_4 + (VAR_0->N_low - VAR_4)/(VAR_0->N_Q + 1 - VAR_3);\n        }\n        VAR_0->f_table_noise[VAR_3] = VAR_0->f_table_res[VAR_8][VAR_4];\n    }\n\n    /* COMMENT_2 */\n    for (VAR_3 = 0; VAR_3 < 64; VAR_3++)\n    {\n        uint8_t VAR_9;\n        for (VAR_9 = 0; VAR_9 < VAR_0->N_Q; VAR_9++)\n        {\n            if ((VAR_0->f_table_noise[VAR_9] <= VAR_3) &&\n                (VAR_3 < VAR_0->f_table_noise[VAR_9+1]))\n            {\n                VAR_0->table_map_k_to_g[VAR_3] = VAR_9;\n                break;\n            }\n        }\n    }\n\n#if 0\n    printf(\"f_table_noise[%d]: \", VAR_0->N_Q);\n    for (VAR_3 = 0; VAR_3 <= VAR_0->N_Q; VAR_3++)\n    {\n        printf(\"%d \", VAR_0->f_table_noise[VAR_3] - VAR_0->kx);\n    }\n    printf(\"\\n\");\n#endif\n\n    return 0;\n}",
  "func_graph_path": "knik0/faad2/6aeeaa1af0caf986daf22852a97f7c13c5edd879/sbr_fbt.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,8 @@\n     }\n \n     sbr->M = sbr->f_table_res[HI_RES][sbr->N_high] - sbr->f_table_res[HI_RES][0];\n+    if (sbr->M > MAX_M)\n+        return 1;\n     sbr->kx = sbr->f_table_res[HI_RES][0];\n     if (sbr->kx > 32)\n         return 1;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (sbr->M > MAX_M)",
      "        return 1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/36",
  "description": {
    "pr_info": {
      "title": "mp4read/sbr_fbt: security bug fixes",
      "number": 36
    },
    "comment": [
      "This PR bundles security bug fixes for CVE-2018-20196 as well as other issues without CVE identifier.\r\n\r\nThe moovin and decodeMP4file are non-trivial fixes and I highly recommend to test and carefully review these changes before thinking of merging them. I plan to give them a second check next month.\r\n\r\nThanks!",
      "I am currently doing a second review of my code.\r\n\r\n* \"sbr_fbt: sbr->M should not exceed MAX_M\" looks perfectly fine to me. I won't do any more changes there.\r\n\r\n* \"mp4read: moovin should not alter caller's g_atom \" is *not* ok. The logic of this patch is perfectly fine in my opinion, however it does not handle error situations properly. I will provide an updated version addressing these issues.\r\n\r\n* \"main: fix crash with unsupported MP4 files \" is perfectly fine as-is. I won't do any more changes there.",
      "I have updated the mp4read patch. @fabiangreffrath it would be really great if you could do a last review, so that we can get this merged sometime. :)",
      "Just merged this. By now, you know the code better than I do, so I trust your proposals blindly. :wink: "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}