{
  "cve_id": "CVE-2022-24754",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "pjsip/pjproject",
  "commit_msg": "Use PJ_ASSERT_RETURN() on pjsip_auth_create_digest() and pjsua_init_tpselector() (#3009)\n\n* Use PJ_ASSERT_RETURN on pjsip_auth_create_digest\r\n\r\n* Use PJ_ASSERT_RETURN on pjsua_init_tpselector()\r\n\r\n* Fix incorrect check.\r\n\r\n* Add return value to pjsip_auth_create_digest() and pjsip_auth_create_digestSHA256()\r\n\r\n* Modification based on comments.",
  "commit_hash": "d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
  "git_url": "https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
  "file_path": "pjsip/src/pjsip/sip_auth_client.c",
  "func_name": "pjsip_auth_create_digest",
  "func_before": "PJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t       const pj_str_t *nc,\n\t\t\t\t       const pj_str_t *cnonce,\n\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t       const pj_str_t *uri,\n\t\t\t\t       const pj_str_t *realm,\n\t\t\t\t       const pjsip_cred_info *cred_info,\n\t\t\t\t       const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD) {\n\t/***\n\t *** ha1 = MD5(username \":\" realm \":\" password)\n\t ***/\n\tpj_md5_init(&pms);\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, uri->ptr, uri->slen);\n    pj_md5_final(&pms, digest);\n    digestNtoStr(digest, 16, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \"  ha2=%.32s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***    response = MD5(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***    response = MD5(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, ha1, PJSIP_MD5STRLEN);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, nc->ptr, nc->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cnonce->ptr, cnonce->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, qop->ptr, qop->slen);\n    }\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, ha2, PJSIP_MD5STRLEN);\n\n    /* This is the final response digest. */\n    pj_md5_final(&pms, digest);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n}",
  "abstract_func_before": "VAR_0(void) pjsip_auth_create_digest( pj_str_t *VAR_1,\n\t\t\t\t       const pj_str_t *VAR_2,\n\t\t\t\t       const pj_str_t *VAR_3,\n\t\t\t\t       const pj_str_t *VAR_4,\n\t\t\t\t       const pj_str_t *VAR_5,\n\t\t\t\t       const pj_str_t *VAR_6,\n\t\t\t\t       const pj_str_t *VAR_7,\n\t\t\t\t       const pjsip_cred_info *VAR_8,\n\t\t\t\t       const pj_str_t *VAR_9)\n{\n    char VAR_10[VAR_11];\n    char VAR_12[VAR_11];\n    unsigned char VAR_13[16];\n    pj_md5_context VAR_14;\n\n    pj_assert(VAR_1->slen >= VAR_11);\n\n    AUTH_TRACE_((VAR_15, \"Begin creating digest\"));\n\n    if ((VAR_8->data_type & VAR_16) == VAR_17) {\n\t/* COMMENT_0 */\n                                                \n      \n\tpj_md5_init(&VAR_14);\n\tMD5_APPEND( &VAR_14, VAR_8->username.ptr, VAR_8->username.slen);\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_7->ptr, VAR_7->slen);\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_8->data.ptr, VAR_8->data.slen);\n\tpj_md5_final(&VAR_14, VAR_13);\n\n\tdigestNtoStr(VAR_13, 16, VAR_10);\n\n    } else if ((VAR_8->data_type & VAR_16) == VAR_18) {\n\tpj_assert(VAR_8->data.slen == 32);\n\tpj_memcpy( VAR_10, VAR_8->data.ptr, VAR_8->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((VAR_15, \"  ha1=%.32s\", VAR_10));\n\n    /* COMMENT_3 */\n                                      \n         \n    pj_md5_init(&VAR_14);\n    MD5_APPEND( &VAR_14, VAR_9->ptr, VAR_9->slen);\n    MD5_APPEND( &VAR_14, \":\", 1);\n    MD5_APPEND( &VAR_14, VAR_6->ptr, VAR_6->slen);\n    pj_md5_final(&VAR_14, VAR_13);\n    digestNtoStr(VAR_13, 16, VAR_12);\n\n    AUTH_TRACE_((VAR_15, \"  ha2=%.32s\", VAR_12));\n\n    /* COMMENT_6 */\n                              \n                                                 \n        \n                               \n                                                                           \n         \n    pj_md5_init(&VAR_14);\n    MD5_APPEND( &VAR_14, VAR_10, VAR_11);\n    MD5_APPEND( &VAR_14, \":\", 1);\n    MD5_APPEND( &VAR_14, VAR_2->ptr, VAR_2->slen);\n    if (VAR_5 && VAR_5->slen != 0) {\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_3->ptr, VAR_3->slen);\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_4->ptr, VAR_4->slen);\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_5->ptr, VAR_5->slen);\n    }\n    MD5_APPEND( &VAR_14, \":\", 1);\n    MD5_APPEND( &VAR_14, VAR_12, VAR_11);\n\n    /* COMMENT_13 */\n    pj_md5_final(&VAR_14, VAR_13);\n\n    /* COMMENT_14 */\n    VAR_1->slen = VAR_11;\n    digestNtoStr(VAR_13, 16, VAR_1->ptr);\n\n    AUTH_TRACE_((VAR_15, \"  digest=%.32s\", VAR_1->ptr));\n    AUTH_TRACE_((VAR_15, \"Digest created\"));\n}",
  "func_graph_path_before": null,
  "func": "PJ_DEF(pj_status_t) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t\t      const pj_str_t *nonce,\n\t\t\t\t\t      const pj_str_t *nc,\n\t\t\t\t\t      const pj_str_t *cnonce,\n\t\t\t\t\t      const pj_str_t *qop,\n\t\t\t\t\t      const pj_str_t *uri,\n\t\t\t\t\t      const pj_str_t *realm,\n\t\t\t\t\t      const pjsip_cred_info *cred_info,\n\t\t\t\t\t      const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD) {\n\t/***\n\t *** ha1 = MD5(username \":\" realm \":\" password)\n\t ***/\n\tpj_md5_init(&pms);\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tif (cred_info->data.slen != 32) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(result->ptr, result->slen);\n\t    result->slen = 0;\n\t    return PJ_EINVAL;\n\t}\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(result->ptr, result->slen);\n\tresult->slen = 0;\n\treturn PJ_EINVAL;\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, uri->ptr, uri->slen);\n    pj_md5_final(&pms, digest);\n    digestNtoStr(digest, 16, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \"  ha2=%.32s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***    response = MD5(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***    response = MD5(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, ha1, PJSIP_MD5STRLEN);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, nc->ptr, nc->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cnonce->ptr, cnonce->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, qop->ptr, qop->slen);\n    }\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, ha2, PJSIP_MD5STRLEN);\n\n    /* This is the final response digest. */\n    pj_md5_final(&pms, digest);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n    return PJ_SUCCESS;\n}",
  "abstract_func": "VAR_0(pj_status_t) pjsip_auth_create_digest( pj_str_t *VAR_1,\n\t\t\t\t\t      const pj_str_t *VAR_2,\n\t\t\t\t\t      const pj_str_t *VAR_3,\n\t\t\t\t\t      const pj_str_t *VAR_4,\n\t\t\t\t\t      const pj_str_t *VAR_5,\n\t\t\t\t\t      const pj_str_t *VAR_6,\n\t\t\t\t\t      const pj_str_t *VAR_7,\n\t\t\t\t\t      const pjsip_cred_info *VAR_8,\n\t\t\t\t\t      const pj_str_t *VAR_9)\n{\n    char VAR_10[VAR_11];\n    char VAR_12[VAR_11];\n    unsigned char VAR_13[16];\n    pj_md5_context VAR_14;\n\n    pj_assert(VAR_1->slen >= VAR_11);\n\n    AUTH_TRACE_((VAR_15, \"Begin creating digest\"));\n\n    if ((VAR_8->data_type & VAR_16) == VAR_17) {\n\t/* COMMENT_0 */\n                                                \n      \n\tpj_md5_init(&VAR_14);\n\tMD5_APPEND( &VAR_14, VAR_8->username.ptr, VAR_8->username.slen);\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_7->ptr, VAR_7->slen);\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_8->data.ptr, VAR_8->data.slen);\n\tpj_md5_final(&VAR_14, VAR_13);\n\n\tdigestNtoStr(VAR_13, 16, VAR_10);\n\n    } else if ((VAR_8->data_type & VAR_16) == VAR_18) {\n\tif (VAR_8->data.slen != 32) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(VAR_1->ptr, VAR_1->slen);\n\t    VAR_1->slen = 0;\n\t    return VAR_19;\n\t}\n\tpj_memcpy( VAR_10, VAR_8->data.ptr, VAR_8->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(VAR_1->ptr, VAR_1->slen);\n\tVAR_1->slen = 0;\n\treturn VAR_19;\n    }\n\n    AUTH_TRACE_((VAR_15, \"  ha1=%.32s\", VAR_10));\n\n    /* COMMENT_3 */\n                                      \n         \n    pj_md5_init(&VAR_14);\n    MD5_APPEND( &VAR_14, VAR_9->ptr, VAR_9->slen);\n    MD5_APPEND( &VAR_14, \":\", 1);\n    MD5_APPEND( &VAR_14, VAR_6->ptr, VAR_6->slen);\n    pj_md5_final(&VAR_14, VAR_13);\n    digestNtoStr(VAR_13, 16, VAR_12);\n\n    AUTH_TRACE_((VAR_15, \"  ha2=%.32s\", VAR_12));\n\n    /* COMMENT_6 */\n                              \n                                                 \n        \n                               \n                                                                           \n         \n    pj_md5_init(&VAR_14);\n    MD5_APPEND( &VAR_14, VAR_10, VAR_11);\n    MD5_APPEND( &VAR_14, \":\", 1);\n    MD5_APPEND( &VAR_14, VAR_2->ptr, VAR_2->slen);\n    if (VAR_5 && VAR_5->slen != 0) {\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_3->ptr, VAR_3->slen);\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_4->ptr, VAR_4->slen);\n\tMD5_APPEND( &VAR_14, \":\", 1);\n\tMD5_APPEND( &VAR_14, VAR_5->ptr, VAR_5->slen);\n    }\n    MD5_APPEND( &VAR_14, \":\", 1);\n    MD5_APPEND( &VAR_14, VAR_12, VAR_11);\n\n    /* COMMENT_13 */\n    pj_md5_final(&VAR_14, VAR_13);\n\n    /* COMMENT_14 */\n    VAR_1->slen = VAR_11;\n    digestNtoStr(VAR_13, 16, VAR_1->ptr);\n\n    AUTH_TRACE_((VAR_15, \"  digest=%.32s\", VAR_1->ptr));\n    AUTH_TRACE_((VAR_15, \"Digest created\"));\n    return VAR_20;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,12 @@\n-PJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,\n-\t\t\t\t       const pj_str_t *nonce,\n-\t\t\t\t       const pj_str_t *nc,\n-\t\t\t\t       const pj_str_t *cnonce,\n-\t\t\t\t       const pj_str_t *qop,\n-\t\t\t\t       const pj_str_t *uri,\n-\t\t\t\t       const pj_str_t *realm,\n-\t\t\t\t       const pjsip_cred_info *cred_info,\n-\t\t\t\t       const pj_str_t *method)\n+PJ_DEF(pj_status_t) pjsip_auth_create_digest( pj_str_t *result,\n+\t\t\t\t\t      const pj_str_t *nonce,\n+\t\t\t\t\t      const pj_str_t *nc,\n+\t\t\t\t\t      const pj_str_t *cnonce,\n+\t\t\t\t\t      const pj_str_t *qop,\n+\t\t\t\t\t      const pj_str_t *uri,\n+\t\t\t\t\t      const pj_str_t *realm,\n+\t\t\t\t\t      const pjsip_cred_info *cred_info,\n+\t\t\t\t\t      const pj_str_t *method)\n {\n     char ha1[PJSIP_MD5STRLEN];\n     char ha2[PJSIP_MD5STRLEN];\n@@ -32,10 +32,18 @@\n \tdigestNtoStr(digest, 16, ha1);\n \n     } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n-\tpj_assert(cred_info->data.slen == 32);\n+\tif (cred_info->data.slen != 32) {\n+\t    pj_assert(!\"Invalid cred_info data length\");\n+\t    pj_bzero(result->ptr, result->slen);\n+\t    result->slen = 0;\n+\t    return PJ_EINVAL;\n+\t}\n \tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n     } else {\n \tpj_assert(!\"Invalid data_type\");\n+\tpj_bzero(result->ptr, result->slen);\n+\tresult->slen = 0;\n+\treturn PJ_EINVAL;\n     }\n \n     AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n@@ -83,4 +91,5 @@\n \n     AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n     AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n+    return PJ_SUCCESS;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "PJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,",
      "\t\t\t\t       const pj_str_t *nonce,",
      "\t\t\t\t       const pj_str_t *nc,",
      "\t\t\t\t       const pj_str_t *cnonce,",
      "\t\t\t\t       const pj_str_t *qop,",
      "\t\t\t\t       const pj_str_t *uri,",
      "\t\t\t\t       const pj_str_t *realm,",
      "\t\t\t\t       const pjsip_cred_info *cred_info,",
      "\t\t\t\t       const pj_str_t *method)",
      "\tpj_assert(cred_info->data.slen == 32);"
    ],
    "added_lines": [
      "PJ_DEF(pj_status_t) pjsip_auth_create_digest( pj_str_t *result,",
      "\t\t\t\t\t      const pj_str_t *nonce,",
      "\t\t\t\t\t      const pj_str_t *nc,",
      "\t\t\t\t\t      const pj_str_t *cnonce,",
      "\t\t\t\t\t      const pj_str_t *qop,",
      "\t\t\t\t\t      const pj_str_t *uri,",
      "\t\t\t\t\t      const pj_str_t *realm,",
      "\t\t\t\t\t      const pjsip_cred_info *cred_info,",
      "\t\t\t\t\t      const pj_str_t *method)",
      "\tif (cred_info->data.slen != 32) {",
      "\t    pj_assert(!\"Invalid cred_info data length\");",
      "\t    pj_bzero(result->ptr, result->slen);",
      "\t    result->slen = 0;",
      "\t    return PJ_EINVAL;",
      "\t}",
      "\tpj_bzero(result->ptr, result->slen);",
      "\tresult->slen = 0;",
      "\treturn PJ_EINVAL;",
      "    return PJ_SUCCESS;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/pjsip/pjproject/pull/3009",
  "description": {
    "pr_info": {
      "title": "Check potential buffer overflow in `pjsip_auth_create_digest()`",
      "number": 3009
    },
    "comment": [
      "Related commit of https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47 of [GHSA-73f7-48m9-w662](https://github.com/pjsip/pjproject/security/advisories/GHSA-73f7-48m9-w662) : fix potential buffer overflow in `pjsip_auth_create_digest()`",
      "I'm having a hard time figuring out whether `pjsip_auth_create_digest` is part of the public API and therefore whether applying this patch would be API/ABI-breaking."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}