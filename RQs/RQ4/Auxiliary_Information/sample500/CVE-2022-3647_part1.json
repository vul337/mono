{
  "cve_id": "CVE-2022-3647",
  "cwe_ids": [
    "CWE-404"
  ],
  "cvss_vector": "AV:A/AC:H/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Avoid crash on crash report when a bad function pointer was called (#11298)\n\nIf Redis crashes due to calling an invalid function pointer,\r\nthe `backtrace` function will try to dereference this invalid pointer\r\nwhich will cause a crash inside the crash report and will kill\r\nthe processes without having all the crash report information.\r\n\r\nExample:\r\n\r\n```\r\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\r\n198672:M 19 Sep 2022 18:06:12.936 # Redis 255.255.255 crashed by signal: 11, si_code: 1\r\n198672:M 19 Sep 2022 18:06:12.936 # Accessing address: 0x1\r\n198672:M 19 Sep 2022 18:06:12.936 # Crashed running the instruction at: 0x1\r\n// here the processes is crashing\r\n```\r\n\r\nThis PR tries to fix this crash be:\r\n1. Identify the issue when it happened.\r\n2. Replace the invalid pointer with a pointer to some dummy function\r\n   so that `backtrace` will not crash.\r\n\r\nI identification is done by comparing `eip` to `info->si_addr`, if they\r\nare the same we know that the crash happened on the same address it tries to\r\naccesses and we can conclude that it tries to call and invalid function pointer.\r\n\r\nTo replace the invalid pointer we introduce a new function, `setMcontextEip`,\r\nwhich is very similar to `getMcontextEip` and it knows to set the Eip for the\r\ndifferent supported OS's. After printing the trace we retrieve the old `Eip` value.",
  "commit_hash": "0bf90d944313919eb8e63d3588bf63a367f020a3",
  "git_url": "https://github.com/redis/redis/commit/0bf90d944313919eb8e63d3588bf63a367f020a3",
  "file_path": "src/debug.c",
  "func_name": "sigsegvHandler",
  "func_before": "void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    logStackTrace(getMcontextEip(uc), 1);\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();\n\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n\n    bugReportEnd(1, sig);\n}",
  "abstract_func_before": "void sigsegvHandler(int VAR_0, siginfo_t *VAR_1, void *VAR_2) {\n    UNUSED(VAR_2);\n    UNUSED(VAR_1);\n\n    bugReportStart();\n    serverLog(VAR_3,\n        \"Redis %s crashed by signal: %d, si_code: %d\", VAR_4, VAR_0, VAR_1->si_code);\n    if (VAR_0 == VAR_5 || VAR_0 == VAR_6) {\n        serverLog(VAR_3,\n        \"Accessing address: %p\", (void*)VAR_1->si_addr);\n    }\n    if (VAR_1->si_code == VAR_7 && VAR_1->si_pid != -1) {\n        serverLog(VAR_3, \"Killed by PID: %ld, UID: %d\", (long) VAR_1->si_pid, VAR_1->si_uid);\n    }\n\n#ifdef VAR_8\n    ucontext_t *VAR_9 = (ucontext_t*) VAR_2;\n    void *VAR_10 = getMcontextEip(VAR_9);\n    if (VAR_10 != NULL) {\n        serverLog(VAR_3,\n        \"Crashed running the instruction at: %p\", VAR_10);\n    }\n\n    logStackTrace(getMcontextEip(VAR_9), 1);\n\n    logRegisters(VAR_9);\n#endif\n\n    printCrashReport();\n\n#ifdef VAR_8\n    if (VAR_10 != NULL)\n        dumpCodeAroundEIP(VAR_10);\n#endif\n\n    bugReportEnd(1, VAR_0);\n}",
  "func_graph_path_before": "redis/0bf90d944313919eb8e63d3588bf63a367f020a3/debug.c/vul/before/0.json",
  "func": "void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getAndSetMcontextEip(uc, NULL);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    if (eip == info->si_addr) {\n        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped\n         * function pointer. In that case the call to backtrace will crash trying to access that address and we\n         * won't get a crash report logged. Set it to a valid point to avoid that crash. */\n\n        /* This trick allow to avoid compiler warning */\n        void *ptr;\n        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;\n        *ptr_ptr = invalidFunctionWasCalled;\n        getAndSetMcontextEip(uc, ptr);\n    }\n\n    logStackTrace(eip, 1);\n\n    if (eip == info->si_addr) {\n        /* Restore old eip */\n        getAndSetMcontextEip(uc, eip);\n    }\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();\n\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n\n    bugReportEnd(1, sig);\n}",
  "abstract_func": "void sigsegvHandler(int VAR_0, siginfo_t *VAR_1, void *VAR_2) {\n    UNUSED(VAR_2);\n    UNUSED(VAR_1);\n\n    bugReportStart();\n    serverLog(VAR_3,\n        \"Redis %s crashed by signal: %d, si_code: %d\", VAR_4, VAR_0, VAR_1->si_code);\n    if (VAR_0 == VAR_5 || VAR_0 == VAR_6) {\n        serverLog(VAR_3,\n        \"Accessing address: %p\", (void*)VAR_1->si_addr);\n    }\n    if (VAR_1->si_code == VAR_7 && VAR_1->si_pid != -1) {\n        serverLog(VAR_3, \"Killed by PID: %ld, UID: %d\", (long) VAR_1->si_pid, VAR_1->si_uid);\n    }\n\n#ifdef VAR_8\n    ucontext_t *VAR_9 = (ucontext_t*) VAR_2;\n    void *VAR_10 = getAndSetMcontextEip(VAR_9, NULL);\n    if (VAR_10 != NULL) {\n        serverLog(VAR_3,\n        \"Crashed running the instruction at: %p\", VAR_10);\n    }\n\n    if (VAR_10 == VAR_1->si_addr) {\n        /* COMMENT_0 */\n                                                                                                               \n                                                                                           \n\n        /* COMMENT_3 */\n        void *VAR_11;\n        invalidFunctionWasCalledType *VAR_12 = (invalidFunctionWasCalledType*)&VAR_11;\n        *VAR_12 = VAR_13;\n        getAndSetMcontextEip(VAR_9, VAR_11);\n    }\n\n    logStackTrace(VAR_10, 1);\n\n    if (VAR_10 == VAR_1->si_addr) {\n        /* COMMENT_4 */\n        getAndSetMcontextEip(VAR_9, VAR_10);\n    }\n\n    logRegisters(VAR_9);\n#endif\n\n    printCrashReport();\n\n#ifdef VAR_8\n    if (VAR_10 != NULL)\n        dumpCodeAroundEIP(VAR_10);\n#endif\n\n    bugReportEnd(1, VAR_0);\n}",
  "func_graph_path": "redis/0bf90d944313919eb8e63d3588bf63a367f020a3/debug.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,13 +15,30 @@\n \n #ifdef HAVE_BACKTRACE\n     ucontext_t *uc = (ucontext_t*) secret;\n-    void *eip = getMcontextEip(uc);\n+    void *eip = getAndSetMcontextEip(uc, NULL);\n     if (eip != NULL) {\n         serverLog(LL_WARNING,\n         \"Crashed running the instruction at: %p\", eip);\n     }\n \n-    logStackTrace(getMcontextEip(uc), 1);\n+    if (eip == info->si_addr) {\n+        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped\n+         * function pointer. In that case the call to backtrace will crash trying to access that address and we\n+         * won't get a crash report logged. Set it to a valid point to avoid that crash. */\n+\n+        /* This trick allow to avoid compiler warning */\n+        void *ptr;\n+        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;\n+        *ptr_ptr = invalidFunctionWasCalled;\n+        getAndSetMcontextEip(uc, ptr);\n+    }\n+\n+    logStackTrace(eip, 1);\n+\n+    if (eip == info->si_addr) {\n+        /* Restore old eip */\n+        getAndSetMcontextEip(uc, eip);\n+    }\n \n     logRegisters(uc);\n #endif",
  "diff_line_info": {
    "deleted_lines": [
      "    void *eip = getMcontextEip(uc);",
      "    logStackTrace(getMcontextEip(uc), 1);"
    ],
    "added_lines": [
      "    void *eip = getAndSetMcontextEip(uc, NULL);",
      "    if (eip == info->si_addr) {",
      "        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped",
      "         * function pointer. In that case the call to backtrace will crash trying to access that address and we",
      "         * won't get a crash report logged. Set it to a valid point to avoid that crash. */",
      "",
      "        /* This trick allow to avoid compiler warning */",
      "        void *ptr;",
      "        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;",
      "        *ptr_ptr = invalidFunctionWasCalled;",
      "        getAndSetMcontextEip(uc, ptr);",
      "    }",
      "",
      "    logStackTrace(eip, 1);",
      "",
      "    if (eip == info->si_addr) {",
      "        /* Restore old eip */",
      "        getAndSetMcontextEip(uc, eip);",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/11298",
  "description": {
    "pr_info": {
      "title": "Avoid crash on crash report when a bad function pointer was called",
      "number": 11298
    },
    "comment": [
      "If Redis crashes due to calling an invalid function pointer, the `backtrace` function will try to de-reference this invalid pointer which will cause a crash inside the crash report and will kill the processes without having all the crash report information.\r\n\r\nExample:\r\n\r\n```\r\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\r\n198672:M 19 Sep 2022 18:06:12.936 # Redis 255.255.255 crashed by signal: 11, si_code: 1\r\n198672:M 19 Sep 2022 18:06:12.936 # Accessing address: 0x1\r\n198672:M 19 Sep 2022 18:06:12.936 # Crashed running the instruction at: 0x1\r\n// here the processes is crashing\r\n```\r\n\r\nThis PR tries to fix this crash by:\r\n1. Identify the issue when it happened.\r\n2. Replace the invalid pointer with a pointer to some dummy function so that `backtrace` will not crash.\r\n\r\nThe identification is done by comparing `eip` to `info->si_addr`, if they are the same we know that the crash happened on the same address it tries to accesses and we can conclude that it tries to call and invalid function pointer.\r\n\r\nTo replace the invalid pointer we introduce a new function, `setAndGetMcontextEip`, which replaces `getMcontextEip` and allow to set the Eip for the different supported OS's. After printing the trace we retrieve the old `Eip` value.",
      "Full CI for this branch (passed):\r\nhttps://github.com/redis/redis/actions/runs/3098579483/jobs/5016671554\r\nhttps://github.com/redis/redis-extra-ci/actions/runs/3098590626",
      "@devnexen maybe you can test this on some other platforms?",
      "> @devnexen maybe you can test this on some other platforms?\r\n\r\nso tried\r\nmacos arm64 (seeing \"eip\" on non-x86 archs feels kind of weird :-) your PR just made me realised it), BSD and Illumos on x86_64. No issues so far.",
      "@yossigo the C library is broken. \r\nAre you suggesting we'll live with it? \r\nIf the fix is safe, I don't see any reason not to do it. ",
      "@oranagra It's more platform-specific code that may have more undesired side-effect or extra maintenance burden in the long term, only to fix a non-critical libc issue for which there is a workaround (get a core dump). I do not feel so strongly about it, though. We can remove it if it becomes a problem.\r\nWe should probably open a glibc issue to have it fixed.",
      "@yossigo i feel the scope of this change is relatively small and we can cope with the side effects, or revert if we can't.\r\nother than compilation errors, it can't really do any harm since it only runs in a very specific case.\r\ni don't think the workaround of a core-dump is a good one since the crash report is needed in cases where the error happens in production and is not reproducible.\r\n\r\ni tried filing a bug in glibc, as well as searching for an existing one (can't find it in their bugzilla), and it seems too complicated, and i'm short in time. (can't easily create an account, maybe someone who already has an account can try).\r\ni do see however that this error was previously reported in their mailing list and ignored:\r\nhttps://gcc.gnu.org/legacy-ml/gcc/2007-06/msg00329.html",
      "Hello Team ,\r\n\r\nCan you please share the details by when the fix of this issue will be backported in 7.0 Release\r\n\r\nBest Regards,\r\nApoorv",
      "@iav20 it'll be part of the next release we make for 7.0 and 6.2, but we didn't define the timeline yet.\r\nunless some urgent issue is found that justifies a new release, it can take a few months.",
      "@oranagra Thank you for your feedback!\r\n\r\nA data point regarding 6.2: \r\nPorting the fix would address the following issue: (NIST NVD score was flagged by compliance scans)\r\nhttps://nvd.nist.gov/vuln/detail/CVE-2022-3647\r\n\r\nThanks in advance for your consideration!\r\nEitan",
      "@esteinerMW I think this CVE is wrong, this is not really a denial of service issue. We'll see if this can be corrected, regardless of the fix being backported.",
      "Was the fix backported, and is there any progress on correcting the CVE status? I'm running 6.2.14 but it's being flagged for this despite being disputed, and if it was already backported in the version I'm running, it may also be a false positive and the NIST db hasn't been updated with the backport version yet.",
      "yes, it was backported and part of 6.2.8 and later."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.95"
}