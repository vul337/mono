{
  "cve_id": "CVE-2022-1809",
  "cwe_ids": [
    "CWE-824"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix crash in vtable analysis on UB ##crash\n\n* Reported by @greatergoodest via huntrdev\n* BountyID 0730a95e-c485-4ff2-9a5d-bb3abfda0b17\n* Reproducer: minified_crash",
  "commit_hash": "919e3ac1a13f753c73e7a8e8d8bb4a143218732d",
  "git_url": "https://github.com/radareorg/radare2/commit/919e3ac1a13f753c73e7a8e8d8bb4a143218732d",
  "file_path": "libr/anal/vtable.c",
  "func_name": "r_anal_list_vtables",
  "func_before": "R_API void r_anal_list_vtables(RAnal *anal, int rad) {\n\tRVTableContext context;\n\tr_anal_vtable_begin (anal, &context);\n\n\tconst char *noMethodName = \"No Name found\";\n\tRVTableMethodInfo *curMethod;\n\tRListIter *vtableIter;\n\tRVTableInfo *table;\n\n\tRList *vtables = r_anal_vtable_search (&context);\n\n\tif (rad == 'j') {\n\t\tPJ *pj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tpj_o (pj);\n\t\t\tpj_kN (pj, \"offset\", table->saddr);\n\t\t\tpj_ka (pj, \"methods\");\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kN (pj, \"offset\", curMethod->addr);\n\t\t\t\tpj_ks (pj, \"name\", r_str_get_fail (name, noMethodName));\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t} else if (rad == '*') {\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tr_cons_printf (\"f vtable.0x%08\"PFMT64x\" %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\t   table->saddr,\n\t\t\t\t\t\t   r_anal_vtable_info_get_size (&context, table),\n\t\t\t\t\t\t   table->saddr);\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", context.word_size, table->saddr + curMethod->vtable_offset);\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tif (name) {\n\t\t\t\t\tr_cons_printf (\"f %s=0x%08\"PFMT64x\"\\n\", name, curMethod->addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f method.virtual.0x%08\"PFMT64x\"=0x%08\"PFMT64x\"\\n\", curMethod->addr, curMethod->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tut64 vtableStartAddress = table->saddr;\n\t\t\tr_cons_printf (\"\\nVtable Found at 0x%08\"PFMT64x\"\\n\", vtableStartAddress);\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" : %s\\n\", vtableStartAddress, r_str_get_fail (name, noMethodName));\n\t\t\t\tvtableStartAddress += context.word_size;\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\tr_list_free (vtables);\n}",
  "abstract_func_before": "R_API void r_anal_list_vtables(RAnal *VAR_0, int VAR_1) {\n\tRVTableContext VAR_2;\n\tr_anal_vtable_begin (VAR_0, &VAR_2);\n\n\tconst char *VAR_3 = \"No Name found\";\n\tRVTableMethodInfo *VAR_4;\n\tRListIter *VAR_5;\n\tRVTableInfo *VAR_6;\n\n\tRList *VAR_7 = r_anal_vtable_search (&VAR_2);\n\n\tif (VAR_1 == 'j') {\n\t\tPJ *VAR_8 = pj_new ();\n\t\tif (!VAR_8) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (VAR_8);\n\t\tr_list_foreach (VAR_7, VAR_5, VAR_6) {\n\t\t\tpj_o (VAR_8);\n\t\t\tpj_kN (VAR_8, \"offset\", VAR_6->saddr);\n\t\t\tpj_ka (VAR_8, \"methods\");\n\t\t\tr_vector_foreach (&VAR_6->methods, VAR_4) {\n\t\t\t\tRAnalFunction *VAR_9 = r_anal_get_fcn_in (VAR_0, VAR_4->addr, 0);\n\t\t\t\tconst char *const VAR_10 = VAR_9 ? VAR_9->name : NULL;\n\t\t\t\tpj_o (VAR_8);\n\t\t\t\tpj_kN (VAR_8, \"offset\", VAR_4->addr);\n\t\t\t\tpj_ks (VAR_8, \"name\", r_str_get_fail (VAR_10, VAR_3));\n\t\t\t\tpj_end (VAR_8);\n\t\t\t}\n\t\t\tpj_end (VAR_8);\n\t\t\tpj_end (VAR_8);\n\t\t}\n\t\tpj_end (VAR_8);\n\t\tr_cons_println (pj_string (VAR_8));\n\t\tpj_free (VAR_8);\n\t} else if (VAR_1 == '*') {\n\t\tr_list_foreach (VAR_7, VAR_5, VAR_6) {\n\t\t\tr_cons_printf (\"f vtable.0x%08\"VAR_11\" %\"VAR_12\" @ 0x%08\"VAR_11\"\\n\",\n\t\t\t\t\t\t   VAR_6->saddr,\n\t\t\t\t\t\t   r_anal_vtable_info_get_size (&VAR_2, VAR_6),\n\t\t\t\t\t\t   VAR_6->saddr);\n\t\t\tr_vector_foreach (&VAR_6->methods, VAR_4) {\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"VAR_11\"\\n\", VAR_2.word_size, VAR_6->saddr + VAR_4->vtable_offset);\n\t\t\t\tRAnalFunction *VAR_9 = r_anal_get_fcn_in (VAR_0, VAR_4->addr, 0);\n\t\t\t\tconst char *const VAR_10 = VAR_9 ? VAR_9->name : NULL;\n\t\t\t\tif (VAR_10) {\n\t\t\t\t\tr_cons_printf (\"f %s=0x%08\"VAR_11\"\\n\", VAR_10, VAR_4->addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f method.virtual.0x%08\"VAR_11\"=0x%08\"VAR_11\"\\n\", VAR_4->addr, VAR_4->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr_list_foreach (VAR_7, VAR_5, VAR_6) {\n\t\t\tut64 VAR_13 = VAR_6->saddr;\n\t\t\tr_cons_printf (\"\\nVtable Found at 0x%08\"VAR_11\"\\n\", VAR_13);\n\t\t\tr_vector_foreach (&VAR_6->methods, VAR_4) {\n\t\t\t\tRAnalFunction *VAR_9 = r_anal_get_fcn_in (VAR_0, VAR_4->addr, 0);\n\t\t\t\tconst char *const VAR_10 = VAR_9 ? VAR_9->name : NULL;\n\t\t\t\tr_cons_printf (\"0x%08\"VAR_11\" : %s\\n\", VAR_13, r_str_get_fail (VAR_10, VAR_3));\n\t\t\t\tVAR_13 += VAR_2.word_size;\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\tr_list_free (VAR_7);\n}",
  "func_graph_path_before": null,
  "func": "R_API void r_anal_list_vtables(RAnal *anal, int rad) {\n\tRVTableContext context = {0};\n\tr_anal_vtable_begin (anal, &context);\n\n\tconst char *noMethodName = \"No Name found\";\n\tRVTableMethodInfo *curMethod;\n\tRListIter *vtableIter;\n\tRVTableInfo *table;\n\n\tRList *vtables = r_anal_vtable_search (&context);\n\n\tif (rad == 'j') {\n\t\tPJ *pj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tpj_o (pj);\n\t\t\tpj_kN (pj, \"offset\", table->saddr);\n\t\t\tpj_ka (pj, \"methods\");\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kN (pj, \"offset\", curMethod->addr);\n\t\t\t\tpj_ks (pj, \"name\", r_str_get_fail (name, noMethodName));\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t} else if (rad == '*') {\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tr_cons_printf (\"f vtable.0x%08\"PFMT64x\" %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\t   table->saddr,\n\t\t\t\t\t\t   r_anal_vtable_info_get_size (&context, table),\n\t\t\t\t\t\t   table->saddr);\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", context.word_size, table->saddr + curMethod->vtable_offset);\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tif (name) {\n\t\t\t\t\tr_cons_printf (\"f %s=0x%08\"PFMT64x\"\\n\", name, curMethod->addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f method.virtual.0x%08\"PFMT64x\"=0x%08\"PFMT64x\"\\n\", curMethod->addr, curMethod->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tut64 vtableStartAddress = table->saddr;\n\t\t\tr_cons_printf (\"\\nVtable Found at 0x%08\"PFMT64x\"\\n\", vtableStartAddress);\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" : %s\\n\", vtableStartAddress, r_str_get_fail (name, noMethodName));\n\t\t\t\tvtableStartAddress += context.word_size;\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\tr_list_free (vtables);\n}",
  "abstract_func": "R_API void r_anal_list_vtables(RAnal *VAR_0, int VAR_1) {\n\tRVTableContext VAR_2 = {0};\n\tr_anal_vtable_begin (VAR_0, &VAR_2);\n\n\tconst char *VAR_3 = \"No Name found\";\n\tRVTableMethodInfo *VAR_4;\n\tRListIter *VAR_5;\n\tRVTableInfo *VAR_6;\n\n\tRList *VAR_7 = r_anal_vtable_search (&VAR_2);\n\n\tif (VAR_1 == 'j') {\n\t\tPJ *VAR_8 = pj_new ();\n\t\tif (!VAR_8) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (VAR_8);\n\t\tr_list_foreach (VAR_7, VAR_5, VAR_6) {\n\t\t\tpj_o (VAR_8);\n\t\t\tpj_kN (VAR_8, \"offset\", VAR_6->saddr);\n\t\t\tpj_ka (VAR_8, \"methods\");\n\t\t\tr_vector_foreach (&VAR_6->methods, VAR_4) {\n\t\t\t\tRAnalFunction *VAR_9 = r_anal_get_fcn_in (VAR_0, VAR_4->addr, 0);\n\t\t\t\tconst char *const VAR_10 = VAR_9 ? VAR_9->name : NULL;\n\t\t\t\tpj_o (VAR_8);\n\t\t\t\tpj_kN (VAR_8, \"offset\", VAR_4->addr);\n\t\t\t\tpj_ks (VAR_8, \"name\", r_str_get_fail (VAR_10, VAR_3));\n\t\t\t\tpj_end (VAR_8);\n\t\t\t}\n\t\t\tpj_end (VAR_8);\n\t\t\tpj_end (VAR_8);\n\t\t}\n\t\tpj_end (VAR_8);\n\t\tr_cons_println (pj_string (VAR_8));\n\t\tpj_free (VAR_8);\n\t} else if (VAR_1 == '*') {\n\t\tr_list_foreach (VAR_7, VAR_5, VAR_6) {\n\t\t\tr_cons_printf (\"f vtable.0x%08\"VAR_11\" %\"VAR_12\" @ 0x%08\"VAR_11\"\\n\",\n\t\t\t\t\t\t   VAR_6->saddr,\n\t\t\t\t\t\t   r_anal_vtable_info_get_size (&VAR_2, VAR_6),\n\t\t\t\t\t\t   VAR_6->saddr);\n\t\t\tr_vector_foreach (&VAR_6->methods, VAR_4) {\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"VAR_11\"\\n\", VAR_2.word_size, VAR_6->saddr + VAR_4->vtable_offset);\n\t\t\t\tRAnalFunction *VAR_9 = r_anal_get_fcn_in (VAR_0, VAR_4->addr, 0);\n\t\t\t\tconst char *const VAR_10 = VAR_9 ? VAR_9->name : NULL;\n\t\t\t\tif (VAR_10) {\n\t\t\t\t\tr_cons_printf (\"f %s=0x%08\"VAR_11\"\\n\", VAR_10, VAR_4->addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f method.virtual.0x%08\"VAR_11\"=0x%08\"VAR_11\"\\n\", VAR_4->addr, VAR_4->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr_list_foreach (VAR_7, VAR_5, VAR_6) {\n\t\t\tut64 VAR_13 = VAR_6->saddr;\n\t\t\tr_cons_printf (\"\\nVtable Found at 0x%08\"VAR_11\"\\n\", VAR_13);\n\t\t\tr_vector_foreach (&VAR_6->methods, VAR_4) {\n\t\t\t\tRAnalFunction *VAR_9 = r_anal_get_fcn_in (VAR_0, VAR_4->addr, 0);\n\t\t\t\tconst char *const VAR_10 = VAR_9 ? VAR_9->name : NULL;\n\t\t\t\tr_cons_printf (\"0x%08\"VAR_11\" : %s\\n\", VAR_13, r_str_get_fail (VAR_10, VAR_3));\n\t\t\t\tVAR_13 += VAR_2.word_size;\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\tr_list_free (VAR_7);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n R_API void r_anal_list_vtables(RAnal *anal, int rad) {\n-\tRVTableContext context;\n+\tRVTableContext context = {0};\n \tr_anal_vtable_begin (anal, &context);\n \n \tconst char *noMethodName = \"No Name found\";",
  "diff_line_info": {
    "deleted_lines": [
      "\tRVTableContext context;"
    ],
    "added_lines": [
      "\tRVTableContext context = {0};"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/20146",
  "description": {
    "pr_info": {
      "title": "Fix crash in vtable analysis on UB ##crash",
      "number": 20146
    },
    "comment": [
      "* Reported by @greatergoodest via huntrdev\r\n* BountyID 0730a95e-c485-4ff2-9a5d-bb3abfda0b17\r\n* Reproducer: minified_crash\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.7  \nThe patch fixes a bug leading to a crash, which improves stability but isn't explicitly a security fix."
}