{
  "cve_id": "CVE-2021-24031",
  "cwe_ids": [
    "CWE-276"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "facebook/zstd",
  "commit_msg": "[programs] set chmod 600 after opening destination file\n\nThis resolves a race condition where zstd or unzstd may expose read\npermissions beyond the original file allowed.  Mode 600 is used\ntemporarily during the compression and decompression write stage\nand the new file inherits the original file’s mode at the end.\n\nFixes #1630",
  "commit_hash": "3968160a916a759c3d3418da533e1b4f8b795343",
  "git_url": "https://github.com/facebook/zstd/commit/3968160a916a759c3d3418da533e1b4f8b795343",
  "file_path": "programs/fileio.c",
  "func_name": "FIO_openDstFile",
  "func_before": "static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName)\n{\n    assert(dstFileName != NULL);\n    if (!strcmp (dstFileName, stdoutmark)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(stdout);\n        if (prefs->sparseFileSupport == 1) {\n            prefs->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return stdout;\n    }\n\n    /* ensure dst is not the same as src */\n    if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (prefs->sparseFileSupport == 1) {\n        prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT;\n    }\n\n    if (UTIL_isRegularFile(dstFileName)) {\n        /* Check if destination file already exists */\n        FILE* const fCheck = fopen( dstFileName, \"rb\" );\n        if (!strcmp(dstFileName, nulmark)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        dstFileName);\n        }\n        if (fCheck != NULL) {  /* dst file exists, authorization prompt */\n            fclose(fCheck);\n            if (!prefs->overwrite) {\n                if (g_display_prefs.displayLevel <= 1) {\n                    /* No interaction possible */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            dstFileName);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        dstFileName);\n                {   int ch = getchar();\n                    if ((ch!='Y') && (ch!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* flush rest of input line */\n                    while ((ch!=EOF) && (ch!='\\n')) ch = getchar();\n            }   }\n            /* need to unlink */\n            FIO_remove(dstFileName);\n    }   }\n\n    {   FILE* const f = fopen( dstFileName, \"wb\" );\n        if (f == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n        return f;\n    }\n}",
  "abstract_func_before": "static FILE* FIO_openDstFile(FIO_prefs_t* const VAR_0, const char* VAR_1, const char* VAR_2)\n{\n    assert(VAR_2 != NULL);\n    if (!strcmp (VAR_2, VAR_3)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(VAR_4);\n        if (VAR_0->sparseFileSupport == 1) {\n            VAR_0->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return VAR_4;\n    }\n\n    /* COMMENT_0 */\n    if (VAR_1 != NULL && UTIL_isSameFile(VAR_1, VAR_2)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (VAR_0->sparseFileSupport == 1) {\n        VAR_0->sparseFileSupport = VAR_5;\n    }\n\n    if (UTIL_isRegularFile(VAR_2)) {\n        /* COMMENT_1 */\n        FILE* const VAR_6 = fopen( VAR_2, \"rb\" );\n        if (!strcmp(VAR_2, VAR_7)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        VAR_2);\n        }\n        if (VAR_6 != NULL) {  /* COMMENT_2 */\n            fclose(VAR_6);\n            if (!VAR_0->overwrite) {\n                if (VAR_8.displayLevel <= 1) {\n                    /* COMMENT_3 */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            VAR_2);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        VAR_2);\n                {   int VAR_9 = getchar();\n                    if ((VAR_9!='Y') && (VAR_9!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* COMMENT_4 */\n                    while ((VAR_9!=VAR_10) && (VAR_9!='\\n')) VAR_9 = getchar();\n            }   }\n            /* COMMENT_5 */\n            FIO_remove(VAR_2);\n    }   }\n\n    {   FILE* const VAR_11 = fopen( VAR_2, \"wb\" );\n        if (VAR_11 == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", VAR_2, strerror(VAR_12));\n        return VAR_11;\n    }\n}",
  "func_graph_path_before": "facebook/zstd/3968160a916a759c3d3418da533e1b4f8b795343/fileio.c/vul/before/0.json",
  "func": "static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName)\n{\n    assert(dstFileName != NULL);\n    if (!strcmp (dstFileName, stdoutmark)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(stdout);\n        if (prefs->sparseFileSupport == 1) {\n            prefs->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return stdout;\n    }\n\n    /* ensure dst is not the same as src */\n    if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (prefs->sparseFileSupport == 1) {\n        prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT;\n    }\n\n    if (UTIL_isRegularFile(dstFileName)) {\n        /* Check if destination file already exists */\n        FILE* const fCheck = fopen( dstFileName, \"rb\" );\n        if (!strcmp(dstFileName, nulmark)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        dstFileName);\n        }\n        if (fCheck != NULL) {  /* dst file exists, authorization prompt */\n            fclose(fCheck);\n            if (!prefs->overwrite) {\n                if (g_display_prefs.displayLevel <= 1) {\n                    /* No interaction possible */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            dstFileName);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        dstFileName);\n                {   int ch = getchar();\n                    if ((ch!='Y') && (ch!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* flush rest of input line */\n                    while ((ch!=EOF) && (ch!='\\n')) ch = getchar();\n            }   }\n            /* need to unlink */\n            FIO_remove(dstFileName);\n    }   }\n\n    {   FILE* const f = fopen( dstFileName, \"wb\" );\n        if (f == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n        chmod(dstFileName, 00600);\n        return f;\n    }\n}",
  "abstract_func": "static FILE* FIO_openDstFile(FIO_prefs_t* const VAR_0, const char* VAR_1, const char* VAR_2)\n{\n    assert(VAR_2 != NULL);\n    if (!strcmp (VAR_2, VAR_3)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(VAR_4);\n        if (VAR_0->sparseFileSupport == 1) {\n            VAR_0->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return VAR_4;\n    }\n\n    /* COMMENT_0 */\n    if (VAR_1 != NULL && UTIL_isSameFile(VAR_1, VAR_2)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (VAR_0->sparseFileSupport == 1) {\n        VAR_0->sparseFileSupport = VAR_5;\n    }\n\n    if (UTIL_isRegularFile(VAR_2)) {\n        /* COMMENT_1 */\n        FILE* const VAR_6 = fopen( VAR_2, \"rb\" );\n        if (!strcmp(VAR_2, VAR_7)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        VAR_2);\n        }\n        if (VAR_6 != NULL) {  /* COMMENT_2 */\n            fclose(VAR_6);\n            if (!VAR_0->overwrite) {\n                if (VAR_8.displayLevel <= 1) {\n                    /* COMMENT_3 */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            VAR_2);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        VAR_2);\n                {   int VAR_9 = getchar();\n                    if ((VAR_9!='Y') && (VAR_9!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* COMMENT_4 */\n                    while ((VAR_9!=VAR_10) && (VAR_9!='\\n')) VAR_9 = getchar();\n            }   }\n            /* COMMENT_5 */\n            FIO_remove(VAR_2);\n    }   }\n\n    {   FILE* const VAR_11 = fopen( VAR_2, \"wb\" );\n        if (VAR_11 == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", VAR_2, strerror(VAR_12));\n        chmod(VAR_2, 00600);\n        return VAR_11;\n    }\n}",
  "func_graph_path": "facebook/zstd/3968160a916a759c3d3418da533e1b4f8b795343/fileio.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -54,6 +54,7 @@\n     {   FILE* const f = fopen( dstFileName, \"wb\" );\n         if (f == NULL)\n             DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n+        chmod(dstFileName, 00600);\n         return f;\n     }\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        chmod(dstFileName, 00600);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/zstd/pull/1644",
  "description": {
    "pr_info": {
      "title": "[programs] set chmod 600 after opening destination file",
      "number": 1644
    },
    "comment": [
      "This resolves a race condition where zstd or unzstd may expose read\r\npermissions beyond the original file allowed.  Mode 600 is used\r\ntemporarily during the compression and decompression write stage\r\nand the new file inherits the original file’s mode at the end.\r\n\r\nFixes #1630\r\n\r\nchmod() should silently fail in situations where it isn't possible to set mode 600, such as on FAT file systems. I'm also not really able to tell if this builds okay on Windows. mingw-w64 seems to build it fine (as long as I changed timefn.h to have `<windows.h>` instead of `<Windows.h>`), but i don't know if chmod() has any effect on that OS -- it's well possible that someone should make a Windows-specific equivalent to this.",
      "Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fzstd%20%231644). Thanks!",
      "Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!",
      "Thanks @chungy .\r\nThankfully, we have automated Windows tests, using both `mingw` and Visual Studio.\r\nIt seems your patch passed them, which suggests compilation (at least) works fine.\r\n\r\n`chmod` is a Unix command, but it seems to have a corresponding Windows hook.\r\nWe already use it in multiple other places, so if it was a bad thing, we would have already triggered some bug reports.\r\n\r\nAlso, it would have been great if it was possible to ship a test case alongside the patch, as to ensure the property remains verified after future changes. However, I must admit I'm completely out of idea on how to test this specific property (using a reasonably simple test).\r\n\r\ncc @felixhandte for the review.",
      "I wonder about the race condition that is potentially introduced here, where `zstd` first opens a file with liberal permissions, and then closes them down. It seems like a malicious process could open the file during that gap and then read the contents as they are written.\r\n\r\nAn alternative approach would be to temporarily set the process umask to `umask | 00077`, do the open, and then restore the original umask. It seems though that windows does not have an equivalent of umask, so that approach would be less portable.\r\n\r\nWhat do you think?",
      "I believe this patch solves the more pressing issue of ensuring that the temporary file cannot be read during compression, which is a long time compared to the very tiny window of opportunity between file creation and rights setting.\r\nAlso, this simple patch does not introduce additional dependencies nor portability complexity.",
      "This PR causes an unexpected change in 1.4.2 and 1.4.1 (compared to 1.4.0 and before): if compressing from stdin to a file, the file always has final rights 0600 instead of umask. This breaks a lot of code I fear.\r\nExample:\r\n\r\n    echo \"123456789\" | zstd -14 -f -q -o test.zst\r\n\r\n",
      "Possible workaround: use shell redirection (`zstd > test.zst`) instead of `-o test.zst`\r\n\r\nThough yes, it is a new bug and you should file a regular issue on it so it doesn't become forgotten in this merged PR :)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\nThe patch adds a line to set file permissions to 600 after opening a file, addressing a race condition that exposes read permissions. This is a security fix as it prevents unauthorized access.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\n---\n\n**Final Output:**  \n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}