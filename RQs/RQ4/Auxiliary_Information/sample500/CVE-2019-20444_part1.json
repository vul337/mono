{
  "cve_id": "CVE-2019-20444",
  "cwe_ids": [
    "CWE-444"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "netty",
  "commit_msg": "Detect missing colon when parsing http headers with no value\n\nMotivation:\n\nTechnical speaking its valid to have http headers with no values so we should support it. That said we need to detect if these are \"generated\" because of an \"invalid\" fold.\n\nModifications:\n\n- Detect if a colon is missing when parsing headers.\n- Add unit test\n\nResult:\n\nFixes https://github.com/netty/netty/issues/9866",
  "commit_hash": "6ad40c8c17199299b75a04225da10ebda5b377f2",
  "git_url": "https://github.com/netty/netty/commit/6ad40c8c17199299b75a04225da10ebda5b377f2",
  "file_path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
  "func_name": "splitHeader",
  "func_before": "private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && Character.isWhitespace(ch))) {\n                break;\n            }\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }",
  "abstract_func_before": "private void splitHeader(AppendableCharSequence VAR_0) {\n        final int VAR_1 = VAR_0.length();\n        int VAR_2;\n        int VAR_3;\n        int VAR_4;\n        int VAR_5;\n        int VAR_6;\n\n        VAR_2 = findNonWhitespace(VAR_0, 0);\n        for (VAR_3 = VAR_2; VAR_3 < VAR_1; VAR_3 ++) {\n            char VAR_7 = VAR_0.charAtUnsafe(VAR_3);\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            if (VAR_7 == ':' ||\n                    /* COMMENT_9 */\n                    /* COMMENT_10 */\n                    /* COMMENT_1 */\n                    /* COMMENT_11 */\n                    (!isDecodingRequest() && VAR_8.isWhitespace(VAR_7))) {\n                break;\n            }\n        }\n\n        for (VAR_4 = VAR_3; VAR_4 < VAR_1; VAR_4 ++) {\n            if (VAR_0.charAtUnsafe(VAR_4) == ':') {\n                VAR_4 ++;\n                break;\n            }\n        }\n\n        VAR_9 = VAR_0.subStringUnsafe(VAR_2, VAR_3);\n        VAR_5 = findNonWhitespace(VAR_0, VAR_4);\n        if (VAR_5 == VAR_1) {\n            VAR_10 = VAR_11;\n        } else {\n            VAR_6 = findEndOfString(VAR_0);\n            VAR_10 = VAR_0.subStringUnsafe(VAR_5, VAR_6);\n        }\n    }",
  "func_graph_path_before": "netty/6ad40c8c17199299b75a04225da10ebda5b377f2/HttpObjectDecoder.java/vul/before/0.json",
  "func": "private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && Character.isWhitespace(ch))) {\n                break;\n            }\n        }\n\n        if (nameEnd == length) {\n            // There was no colon present at all.\n            throw new IllegalArgumentException(\"No colon found\");\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }",
  "abstract_func": "private void splitHeader(AppendableCharSequence VAR_0) {\n        final int VAR_1 = VAR_0.length();\n        int VAR_2;\n        int VAR_3;\n        int VAR_4;\n        int VAR_5;\n        int VAR_6;\n\n        VAR_2 = findNonWhitespace(VAR_0, 0);\n        for (VAR_3 = VAR_2; VAR_3 < VAR_1; VAR_3 ++) {\n            char VAR_7 = VAR_0.charAtUnsafe(VAR_3);\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            if (VAR_7 == ':' ||\n                    /* COMMENT_9 */\n                    /* COMMENT_10 */\n                    /* COMMENT_1 */\n                    /* COMMENT_11 */\n                    (!isDecodingRequest() && VAR_8.isWhitespace(VAR_7))) {\n                break;\n            }\n        }\n\n        if (VAR_3 == VAR_1) {\n            /* COMMENT_12 */\n            throw new IllegalArgumentException(\"No colon found\");\n        }\n\n        for (VAR_4 = VAR_3; VAR_4 < VAR_1; VAR_4 ++) {\n            if (VAR_0.charAtUnsafe(VAR_4) == ':') {\n                VAR_4 ++;\n                break;\n            }\n        }\n\n        VAR_9 = VAR_0.subStringUnsafe(VAR_2, VAR_3);\n        VAR_5 = findNonWhitespace(VAR_0, VAR_4);\n        if (VAR_5 == VAR_1) {\n            VAR_10 = VAR_11;\n        } else {\n            VAR_6 = findEndOfString(VAR_0);\n            VAR_10 = VAR_0.subStringUnsafe(VAR_5, VAR_6);\n        }\n    }",
  "func_graph_path": "netty/6ad40c8c17199299b75a04225da10ebda5b377f2/HttpObjectDecoder.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,11 @@\n             }\n         }\n \n+        if (nameEnd == length) {\n+            // There was no colon present at all.\n+            throw new IllegalArgumentException(\"No colon found\");\n+        }\n+\n         for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n             if (sb.charAtUnsafe(colonEnd) == ':') {\n                 colonEnd ++;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (nameEnd == length) {",
      "            // There was no colon present at all.",
      "            throw new IllegalArgumentException(\"No colon found\");",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/netty/netty/pull/9871",
  "description": {
    "pr_info": {
      "title": "Detect missing colon when parsing http headers with no value",
      "number": 9871
    },
    "comment": [
      "Motivation:\r\n\r\nTechnical speaking its valid to have http headers with no values so we should support it. That said we need to detect if these are \"generated\" because of an \"invalid\" fold.\r\n\r\nModifications:\r\n\r\n- Detect if a colon is missing when parsing headers.\r\n- Add unit test\r\n\r\nResult:\r\n\r\nFixes https://github.com/netty/netty/issues/9866",
      "Just for the record here is the important bit for empty header value : https://github.com/whatwg/fetch/issues/332#issuecomment-297205591",
      "@amizurov maybe you also want to review"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.9\n\nThe patch addresses a bug in parsing HTTP headers by detecting a missing colon and adding a test. No security terms are mentioned, suggesting it's a non-security fix. The code change directly improves functionality, fitting category b. High confidence as the description and code changes align well."
}