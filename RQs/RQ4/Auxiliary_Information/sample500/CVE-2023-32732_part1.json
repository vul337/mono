{
  "cve_id": "CVE-2023-32732",
  "cwe_ids": [
    "CWE-440"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "grpc",
  "commit_msg": "[http] Dont drop connections on metadata limit exceeded",
  "commit_hash": "6a7850ef4f042ac26559854266dddc79bfbc75b2",
  "git_url": "https://github.com/grpc/grpc/commit/6a7850ef4f042ac26559854266dddc79bfbc75b2",
  "file_path": "src/core/ext/transport/chttp2/transport/hpack_parser.cc",
  "func_name": "HandleMetadataSizeLimitExceeded",
  "func_before": "GPR_ATTRIBUTE_NOINLINE\n  bool HandleMetadataSizeLimitExceeded(const HPackTable::Memento& md) {\n    // Collect a summary of sizes so far for debugging\n    // Do not collect contents, for fear of exposing PII.\n    std::string summary;\n    if (metadata_buffer_ != nullptr) {\n      MetadataSizeLimitExceededEncoder encoder(summary);\n      metadata_buffer_->Encode(&encoder);\n    }\n    summary =\n        absl::StrCat(\"; adding \", md.key(), \" (length \", md.transport_size(),\n                     \"B)\", summary.empty() ? \"\" : \" to \", summary);\n    if (metadata_buffer_ != nullptr) metadata_buffer_->Clear();\n    return input_->MaybeSetErrorAndReturn(\n        [this, summary = std::move(summary)] {\n          return grpc_error_set_int(\n              GRPC_ERROR_CREATE(absl::StrCat(\n                  \"received initial metadata size exceeds limit (\",\n                  *frame_length_, \" vs. \", metadata_size_limit_, \")\", summary)),\n              StatusIntProperty::kRpcStatus, GRPC_STATUS_RESOURCE_EXHAUSTED);\n        },\n        false);\n  }",
  "abstract_func_before": "GPR_ATTRIBUTE_NOINLINE\n  VAR_0 HandleMetadataSizeLimitExceeded(const HPackTable::Memento& VAR_1) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    std::string VAR_2;\n    if (VAR_3 != nullptr) {\n      MetadataSizeLimitExceededEncoder encoder(summary);\n      VAR_3->Encode(&VAR_4);\n    }\n    summary =\n        absl::StrCat(\"; adding \", VAR_1.key(), \" (length \", VAR_1.transport_size(),\n                     \"B)\", summary.empty() ? \"\" : \" to \", summary);\n    if (VAR_3 != nullptr) VAR_3->Clear();\n    return VAR_5->MaybeSetErrorAndReturn(\n        [this, summary = std::move(summary)] {\n          return grpc_error_set_int(\n              GRPC_ERROR_CREATE(absl::StrCat(\n                  \"received initial metadata size exceeds limit (\",\n                  *VAR_6, \" vs. \", VAR_7, \")\", summary)),\n              StatusIntProperty::kRpcStatus, VAR_8);\n        },\n        false);\n  }",
  "func_graph_path_before": null,
  "func": "GPR_ATTRIBUTE_NOINLINE\n  bool HandleMetadataSizeLimitExceeded(const HPackTable::Memento& md) {\n    // Collect a summary of sizes so far for debugging\n    // Do not collect contents, for fear of exposing PII.\n    std::string summary;\n    if (metadata_buffer_ != nullptr) {\n      MetadataSizeLimitExceededEncoder encoder(summary);\n      metadata_buffer_->Encode(&encoder);\n    }\n    summary =\n        absl::StrCat(\"; adding \", md.key(), \" (length \", md.transport_size(),\n                     \"B)\", summary.empty() ? \"\" : \" to \", summary);\n    if (metadata_buffer_ != nullptr) metadata_buffer_->Clear();\n    // StreamId is used as a signal to skip this stream but keep the connection\n    // alive\n    return input_->MaybeSetErrorAndReturn(\n        [this, summary = std::move(summary)] {\n          return grpc_error_set_int(\n              grpc_error_set_int(\n                  GRPC_ERROR_CREATE(absl::StrCat(\n                      \"received initial metadata size exceeds limit (\",\n                      *frame_length_, \" vs. \", metadata_size_limit_, \")\",\n                      summary)),\n                  StatusIntProperty::kRpcStatus,\n                  GRPC_STATUS_RESOURCE_EXHAUSTED),\n              StatusIntProperty::kStreamId, 0);\n        },\n        false);\n  }",
  "abstract_func": "GPR_ATTRIBUTE_NOINLINE\n  VAR_0 HandleMetadataSizeLimitExceeded(const HPackTable::Memento& VAR_1) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    std::string VAR_2;\n    if (VAR_3 != nullptr) {\n      MetadataSizeLimitExceededEncoder encoder(summary);\n      VAR_3->Encode(&VAR_4);\n    }\n    summary =\n        absl::StrCat(\"; adding \", VAR_1.key(), \" (length \", VAR_1.transport_size(),\n                     \"B)\", summary.empty() ? \"\" : \" to \", summary);\n    if (VAR_3 != nullptr) VAR_3->Clear();\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    return VAR_5->MaybeSetErrorAndReturn(\n        [this, summary = std::move(summary)] {\n          return grpc_error_set_int(\n              grpc_error_set_int(\n                  GRPC_ERROR_CREATE(absl::StrCat(\n                      \"received initial metadata size exceeds limit (\",\n                      *VAR_6, \" vs. \", VAR_7, \")\",\n                      summary)),\n                  StatusIntProperty::kRpcStatus,\n                  VAR_8),\n              StatusIntProperty::kStreamId, 0);\n        },\n        false);\n  }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,13 +11,19 @@\n         absl::StrCat(\"; adding \", md.key(), \" (length \", md.transport_size(),\n                      \"B)\", summary.empty() ? \"\" : \" to \", summary);\n     if (metadata_buffer_ != nullptr) metadata_buffer_->Clear();\n+    // StreamId is used as a signal to skip this stream but keep the connection\n+    // alive\n     return input_->MaybeSetErrorAndReturn(\n         [this, summary = std::move(summary)] {\n           return grpc_error_set_int(\n-              GRPC_ERROR_CREATE(absl::StrCat(\n-                  \"received initial metadata size exceeds limit (\",\n-                  *frame_length_, \" vs. \", metadata_size_limit_, \")\", summary)),\n-              StatusIntProperty::kRpcStatus, GRPC_STATUS_RESOURCE_EXHAUSTED);\n+              grpc_error_set_int(\n+                  GRPC_ERROR_CREATE(absl::StrCat(\n+                      \"received initial metadata size exceeds limit (\",\n+                      *frame_length_, \" vs. \", metadata_size_limit_, \")\",\n+                      summary)),\n+                  StatusIntProperty::kRpcStatus,\n+                  GRPC_STATUS_RESOURCE_EXHAUSTED),\n+              StatusIntProperty::kStreamId, 0);\n         },\n         false);\n   }",
  "diff_line_info": {
    "deleted_lines": [
      "              GRPC_ERROR_CREATE(absl::StrCat(",
      "                  \"received initial metadata size exceeds limit (\",",
      "                  *frame_length_, \" vs. \", metadata_size_limit_, \")\", summary)),",
      "              StatusIntProperty::kRpcStatus, GRPC_STATUS_RESOURCE_EXHAUSTED);"
    ],
    "added_lines": [
      "    // StreamId is used as a signal to skip this stream but keep the connection",
      "    // alive",
      "              grpc_error_set_int(",
      "                  GRPC_ERROR_CREATE(absl::StrCat(",
      "                      \"received initial metadata size exceeds limit (\",",
      "                      *frame_length_, \" vs. \", metadata_size_limit_, \")\",",
      "                      summary)),",
      "                  StatusIntProperty::kRpcStatus,",
      "                  GRPC_STATUS_RESOURCE_EXHAUSTED),",
      "              StatusIntProperty::kStreamId, 0);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/grpc/grpc/pull/32309",
  "description": {
    "pr_info": {
      "title": "[http2] Dont drop connections on metadata limit exceeded",
      "number": 32309
    },
    "comment": [
      "If we get an error on a stream, all we need to do is cancel that stream.\r\nIf instead we get an error not associated with a stream, we should close the transport.\r\n\r\nCurrent behavior was to just close the transport always, and this was a bad bug.\r\n\r\n<!--\r\n\r\nIf you know who should review your pull request, please assign it to that\r\nperson, otherwise the pull request would get assigned randomly.\r\n\r\nIf your pull request is for a specific language, please add the appropriate\r\nlang label.\r\n\r\n-->\r\n\r\n",
      "@ctiller Hi.  \r\nI want to know if this PR can fix CVE-2023-32732/CVE-2023-32731?",
      "If CVE-2023-32732/CVE-2023-32731 can be fixed by this PR, I would like to know which commit introduced this issue.",
      "Folks coming here for CVE-2023-32731: An error was made in the original CVE text; this change introduced the bug.\r\nThe fix is at https://github.com/grpc/grpc/pull/33005.\r\n\r\nWe're in the process of updating the CVE text.",
      "Thanks! Is CVE-2023-32732 also fixed by #33005?",
      "One more question, does this PR #32309 introduce CVE-2023-32731 and CVE-2023-32732?",
      "Correct on both.",
      "Okay. Thanks!",
      "@ctiller Sorry, but I'm a little confused. \r\nhttps://nvd.nist.gov/vuln/detail/CVE-2023-32732 says:\r\n\"\"\"\r\nWe recommend upgrading beyond the commit in  https://github.com/grpc/grpc/pull/32309\r\n\"\"\"\r\nBut looking at the above comments, it seems that PR#32309 is not a fix, instead, it's the cause of CVE-2023-32732.\r\n\r\nWhich one is correct?"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}