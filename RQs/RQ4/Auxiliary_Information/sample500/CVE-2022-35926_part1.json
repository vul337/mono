{
  "cve_id": "CVE-2022-35926",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "contiki-ng",
  "commit_msg": "Check whether there is enough space for ND6 option headers when processing\nincoming packets.",
  "commit_hash": "a4597001d50a04f4b9c78f323ba731e2f979802c",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/a4597001d50a04f4b9c78f323ba731e2f979802c",
  "file_path": "os/net/ipv6/uip-nd6.c",
  "func_name": "ns_input",
  "func_before": "static void\nns_input(void)\n{\n  uint8_t flags = 0;\n\n  LOG_INFO(\"Received NS from \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_INFO_(\" to \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n  LOG_INFO_(\" with target address \");\n  LOG_INFO_6ADDR((uip_ipaddr_t *) (&UIP_ND6_NS_BUF->tgtipaddr));\n  LOG_INFO_(\"\\n\");\n  UIP_STAT(++uip_stat.nd6.recv);\n\n#if UIP_CONF_IPV6_CHECKS\n  if((UIP_IP_BUF->ttl != UIP_ND6_HOP_LIMIT) ||\n     (uip_is_addr_mcast(&UIP_ND6_NS_BUF->tgtipaddr)) ||\n     (UIP_ICMP_BUF->icode != 0)) {\n    LOG_ERR(\"NS received is bad\\n\");\n    goto discard;\n  }\n#endif /* UIP_CONF_IPV6_CHECKS */\n\n  /* Options processing */\n  nd6_opt_llao = NULL;\n  nd6_opt_offset = UIP_ND6_NS_LEN;\n  while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) {\n#if UIP_CONF_IPV6_CHECKS\n    if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) {\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n    }\n#endif /* UIP_CONF_IPV6_CHECKS */\n    switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) {\n    case UIP_ND6_OPT_SLLAO:\n      nd6_opt_llao = &uip_buf[uip_l3_icmp_hdr_len + nd6_opt_offset];\n#if UIP_CONF_IPV6_CHECKS\n      /* There must be NO option in a DAD NS */\n      if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {\n        LOG_ERR(\"NS received is bad\\n\");\n        goto discard;\n      } else {\n#endif /*UIP_CONF_IPV6_CHECKS */\n        uip_lladdr_t lladdr_aligned;\n        extract_lladdr_from_llao_aligned(&lladdr_aligned);\n        nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr);\n        if(nbr == NULL) {\n          uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,\n\t\t\t  0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);\n        } else {\n          const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr);\n          if(lladdr == NULL) {\n            goto discard;\n          }\n          if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET],\n              lladdr, UIP_LLADDR_LEN) != 0) {\n            if(uip_ds6_nbr_update_ll(&nbr,\n                                     (const uip_lladdr_t *)&lladdr_aligned)\n               < 0) {\n              /* failed to update the lladdr */\n              goto discard;\n            }\n            nbr->state = NBR_STALE;\n          } else {\n            if(nbr->state == NBR_INCOMPLETE) {\n              nbr->state = NBR_STALE;\n            }\n          }\n        }\n#if UIP_CONF_IPV6_CHECKS\n      }\n#endif /*UIP_CONF_IPV6_CHECKS */\n      break;\n    default:\n      LOG_WARN(\"ND option not supported in NS\");\n      break;\n    }\n    nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3);\n  }\n\n  addr = uip_ds6_addr_lookup(&UIP_ND6_NS_BUF->tgtipaddr);\n  if(addr != NULL) {\n    if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {\n      /* DAD CASE */\n#if UIP_ND6_DEF_MAXDADNS > 0\n#if UIP_CONF_IPV6_CHECKS\n      if(!uip_is_addr_solicited_node(&UIP_IP_BUF->destipaddr)) {\n        LOG_ERR(\"NS received is bad\\n\");\n        goto discard;\n      }\n#endif /* UIP_CONF_IPV6_CHECKS */\n      if(addr->state != ADDR_TENTATIVE) {\n        uip_create_linklocal_allnodes_mcast(&UIP_IP_BUF->destipaddr);\n        uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);\n        flags = UIP_ND6_NA_FLAG_OVERRIDE;\n        goto create_na;\n      } else {\n          /** \\todo if I sent a NS before him, I win */\n        uip_ds6_dad_failed(addr);\n        goto discard;\n      }\n#else /* UIP_ND6_DEF_MAXDADNS > 0 */\n      goto discard;  /* DAD CASE */\n#endif /* UIP_ND6_DEF_MAXDADNS > 0 */\n    }\n#if UIP_CONF_IPV6_CHECKS\n    if(uip_ds6_is_my_addr(&UIP_IP_BUF->srcipaddr)) {\n        /**\n         * \\NOTE do we do something here? we both are using the same address.\n         * If we are doing dad, we could cancel it, though we should receive a\n         * NA in response of DAD NS we sent, hence DAD will fail anyway. If we\n         * were not doing DAD, it means there is a duplicate in the network!\n         */\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n    }\n#endif /*UIP_CONF_IPV6_CHECKS */\n\n    /* Address resolution case */\n    if(uip_is_addr_solicited_node(&UIP_IP_BUF->destipaddr)) {\n      uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);\n      uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &UIP_ND6_NS_BUF->tgtipaddr);\n      flags = UIP_ND6_NA_FLAG_SOLICITED | UIP_ND6_NA_FLAG_OVERRIDE;\n      goto create_na;\n    }\n\n    /* NUD CASE */\n    if(uip_ds6_addr_lookup(&UIP_IP_BUF->destipaddr) == addr) {\n      uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);\n      uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &UIP_ND6_NS_BUF->tgtipaddr);\n      flags = UIP_ND6_NA_FLAG_SOLICITED | UIP_ND6_NA_FLAG_OVERRIDE;\n      goto create_na;\n    } else {\n#if UIP_CONF_IPV6_CHECKS\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n#endif /* UIP_CONF_IPV6_CHECKS */\n    }\n  } else {\n    goto discard;\n  }\n\n\ncreate_na:\n    /* If the node is a router it should set R flag in NAs */\n#if UIP_CONF_ROUTER\n    flags = flags | UIP_ND6_NA_FLAG_ROUTER;\n#endif\n  uipbuf_clear();\n  UIP_IP_BUF->vtc = 0x60;\n  UIP_IP_BUF->tcflow = 0;\n  UIP_IP_BUF->flow = 0;\n  uipbuf_set_len_field(UIP_IP_BUF, UIP_ICMPH_LEN + UIP_ND6_NA_LEN + UIP_ND6_OPT_LLAO_LEN);\n  UIP_IP_BUF->proto = UIP_PROTO_ICMP6;\n  UIP_IP_BUF->ttl = UIP_ND6_HOP_LIMIT;\n\n  UIP_ICMP_BUF->type = ICMP6_NA;\n  UIP_ICMP_BUF->icode = 0;\n\n  UIP_ND6_NA_BUF->flagsreserved = flags;\n  memcpy(&UIP_ND6_NA_BUF->tgtipaddr, &addr->ipaddr, sizeof(uip_ipaddr_t));\n\n  create_llao(&uip_buf[uip_l3_icmp_hdr_len + UIP_ND6_NA_LEN],\n              UIP_ND6_OPT_TLLAO);\n\n  UIP_ICMP_BUF->icmpchksum = 0;\n  UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();\n\n  uipbuf_set_len(UIP_IPH_LEN + UIP_ICMPH_LEN + UIP_ND6_NA_LEN + UIP_ND6_OPT_LLAO_LEN);\n\n  UIP_STAT(++uip_stat.nd6.sent);\n  LOG_INFO(\"Sending NA to \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n  LOG_INFO_(\" from \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_INFO_(\" with target address \");\n  LOG_INFO_6ADDR(&UIP_ND6_NA_BUF->tgtipaddr);\n  LOG_INFO_(\"\\n\");\n  return;\n\ndiscard:\n  uipbuf_clear();\n  return;\n}",
  "abstract_func_before": "static void\nns_input(void)\n{\n  uint8_t VAR_0 = 0;\n\n  LOG_INFO(\"Received NS from \");\n  LOG_INFO_6ADDR(&VAR_1->srcipaddr);\n  LOG_INFO_(\" to \");\n  LOG_INFO_6ADDR(&VAR_1->destipaddr);\n  LOG_INFO_(\" with target address \");\n  LOG_INFO_6ADDR((uip_ipaddr_t *) (&VAR_2->tgtipaddr));\n  LOG_INFO_(\"\\n\");\n  UIP_STAT(++VAR_3.nd6.recv);\n\n#if VAR_4\n  if((VAR_1->ttl != VAR_5) ||\n     (uip_is_addr_mcast(&VAR_2->tgtipaddr)) ||\n     (VAR_6->icode != 0)) {\n    LOG_ERR(\"NS received is bad\\n\");\n    goto discard;\n  }\n#endif /* COMMENT_0 */\n\n  /* COMMENT_1 */\n  VAR_7 = NULL;\n  VAR_8 = VAR_9;\n  while(VAR_10 + VAR_8 < VAR_11) {\n#if VAR_4\n    if(ND6_OPT_HDR_BUF(VAR_8)->len == 0) {\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n    }\n#endif /* COMMENT_0 */\n    switch (ND6_OPT_HDR_BUF(VAR_8)->type) {\n    case VAR_12:\n      VAR_7 = &VAR_13[VAR_10 + VAR_8];\n#if VAR_4\n      /* COMMENT_2 */\n      if(uip_is_addr_unspecified(&VAR_1->srcipaddr)) {\n        LOG_ERR(\"NS received is bad\\n\");\n        goto discard;\n      } else {\n#endif/* COMMENT_3 */\n        uip_lladdr_t lladdr_aligned;\n        extract_lladdr_from_llao_aligned(&VAR_14);\n        VAR_15 = uip_ds6_nbr_lookup(&VAR_1->srcipaddr);\n        if(VAR_15 == NULL) {\n          uip_ds6_nbr_add(&VAR_1->srcipaddr, &VAR_14,\n\t\t\t  0, VAR_16, VAR_17, NULL);\n        } else {\n          const uip_lladdr_t *VAR_18 = uip_ds6_nbr_get_ll(VAR_15);\n          if(VAR_18 == NULL) {\n            goto discard;\n          }\n          if(memcmp(&VAR_7[VAR_19],\n              VAR_18, VAR_20) != 0) {\n            if(uip_ds6_nbr_update_ll(&VAR_15,\n                                     (const uip_lladdr_t *)&VAR_14)\n               < 0) {\n              /* COMMENT_4 */\n              goto discard;\n            }\n            VAR_15->state = VAR_16;\n          } else {\n            if(VAR_15->state == VAR_21) {\n              VAR_15->state = VAR_16;\n            }\n          }\n        }\n#if VAR_4\n      }\n#endif /* COMMENT_5 */\n      break;\n    default:\n      LOG_WARN(\"ND option not supported in NS\");\n      break;\n    }\n    VAR_8 += (ND6_OPT_HDR_BUF(VAR_8)->len << 3);\n  }\n\n  VAR_22 = uip_ds6_addr_lookup(&VAR_2->tgtipaddr);\n  if(VAR_22 != NULL) {\n    if(uip_is_addr_unspecified(&VAR_1->srcipaddr)) {\n      /* COMMENT_6 */\n#if VAR_23 > 0\n#if VAR_4\n      if(!uip_is_addr_solicited_node(&VAR_1->destipaddr)) {\n        LOG_ERR(\"NS received is bad\\n\");\n        goto discard;\n      }\n#endif /* COMMENT_0 */\n      if(VAR_22->state != VAR_24) {\n        uip_create_linklocal_allnodes_mcast(&VAR_1->destipaddr);\n        uip_ds6_select_src(&VAR_1->srcipaddr, &VAR_1->destipaddr);\n        VAR_0 = VAR_25;\n        goto create_na;\n      } else {\n          /* COMMENT_7 */\n        uip_ds6_dad_failed(VAR_22);\n        goto discard;\n      }\n#else /* COMMENT_8 */\n      goto discard;  /* COMMENT_6 */\n#endif /* COMMENT_8 */\n    }\n#if VAR_4\n    if(uip_ds6_is_my_addr(&VAR_1->srcipaddr)) {\n        /* COMMENT_9 */\n                                                                             \n                                                                              \n                                                                              \n                                                                            \n           \n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n    }\n#endif /* COMMENT_5 */\n\n    /* COMMENT_15 */\n    if(uip_is_addr_solicited_node(&VAR_1->destipaddr)) {\n      uip_ipaddr_copy(&VAR_1->destipaddr, &VAR_1->srcipaddr);\n      uip_ipaddr_copy(&VAR_1->srcipaddr, &VAR_2->tgtipaddr);\n      VAR_0 = VAR_26 | VAR_25;\n      goto create_na;\n    }\n\n    /* COMMENT_16 */\n    if(uip_ds6_addr_lookup(&VAR_1->destipaddr) == VAR_22) {\n      uip_ipaddr_copy(&VAR_1->destipaddr, &VAR_1->srcipaddr);\n      uip_ipaddr_copy(&VAR_1->srcipaddr, &VAR_2->tgtipaddr);\n      VAR_0 = VAR_26 | VAR_25;\n      goto create_na;\n    } else {\n#if VAR_4\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n#endif /* COMMENT_0 */\n    }\n  } else {\n    goto discard;\n  }\n\n\ncreate_na:\n    /* COMMENT_17 */\n#if VAR_27\n    VAR_0 = VAR_0 | VAR_28;\n#endif\n  uipbuf_clear();\n  VAR_1->vtc = 0x60;\n  VAR_1->tcflow = 0;\n  VAR_1->flow = 0;\n  uipbuf_set_len_field(VAR_1, VAR_29 + VAR_30 + VAR_31);\n  VAR_1->proto = VAR_32;\n  VAR_1->ttl = VAR_5;\n\n  VAR_6->type = VAR_33;\n  VAR_6->icode = 0;\n\n  VAR_34->flagsreserved = VAR_0;\n  memcpy(&VAR_34->tgtipaddr, &VAR_22->ipaddr, sizeof(uip_ipaddr_t));\n\n  create_llao(&VAR_13[VAR_10 + VAR_30],\n              VAR_35);\n\n  VAR_6->icmpchksum = 0;\n  VAR_6->icmpchksum = ~uip_icmp6chksum();\n\n  uipbuf_set_len(VAR_36 + VAR_29 + VAR_30 + VAR_31);\n\n  UIP_STAT(++VAR_3.nd6.sent);\n  LOG_INFO(\"Sending NA to \");\n  LOG_INFO_6ADDR(&VAR_1->destipaddr);\n  LOG_INFO_(\" from \");\n  LOG_INFO_6ADDR(&VAR_1->srcipaddr);\n  LOG_INFO_(\" with target address \");\n  LOG_INFO_6ADDR(&VAR_34->tgtipaddr);\n  LOG_INFO_(\"\\n\");\n  return;\n\ndiscard:\n  uipbuf_clear();\n  return;\n}",
  "func_graph_path_before": "contiki-ng/a4597001d50a04f4b9c78f323ba731e2f979802c/uip-nd6.c/vul/before/0.json",
  "func": "static void\nns_input(void)\n{\n  uint8_t flags = 0;\n\n  LOG_INFO(\"Received NS from \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_INFO_(\" to \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n  LOG_INFO_(\" with target address \");\n  LOG_INFO_6ADDR((uip_ipaddr_t *) (&UIP_ND6_NS_BUF->tgtipaddr));\n  LOG_INFO_(\"\\n\");\n  UIP_STAT(++uip_stat.nd6.recv);\n\n#if UIP_CONF_IPV6_CHECKS\n  if((UIP_IP_BUF->ttl != UIP_ND6_HOP_LIMIT) ||\n     (uip_is_addr_mcast(&UIP_ND6_NS_BUF->tgtipaddr)) ||\n     (UIP_ICMP_BUF->icode != 0)) {\n    LOG_ERR(\"NS received is bad\\n\");\n    goto discard;\n  }\n#endif /* UIP_CONF_IPV6_CHECKS */\n\n  /* Options processing */\n  nd6_opt_llao = NULL;\n  nd6_opt_offset = UIP_ND6_NS_LEN;\n  while(uip_l3_icmp_hdr_len + nd6_opt_offset + UIP_ND6_OPT_HDR_LEN < uip_len) {\n#if UIP_CONF_IPV6_CHECKS\n    if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) {\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n    }\n#endif /* UIP_CONF_IPV6_CHECKS */\n    switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) {\n    case UIP_ND6_OPT_SLLAO:\n      if(uip_l3_icmp_hdr_len + nd6_opt_offset +\n         UIP_ND6_OPT_DATA_OFFSET + UIP_LLADDR_LEN > uip_len) {\n        LOG_ERR(\"Insufficient data for NS SLLAO option\\n\");\n        goto discard;\n      }\n      nd6_opt_llao = &uip_buf[uip_l3_icmp_hdr_len + nd6_opt_offset];\n#if UIP_CONF_IPV6_CHECKS\n      /* There must be NO option in a DAD NS */\n      if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {\n        LOG_ERR(\"NS received is bad\\n\");\n        goto discard;\n      } else {\n#endif /*UIP_CONF_IPV6_CHECKS */\n        uip_lladdr_t lladdr_aligned;\n        extract_lladdr_from_llao_aligned(&lladdr_aligned);\n        nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr);\n        if(nbr == NULL) {\n          uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,\n\t\t\t  0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);\n        } else {\n          const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr);\n          if(lladdr == NULL) {\n            goto discard;\n          }\n          if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET],\n              lladdr, UIP_LLADDR_LEN) != 0) {\n            if(uip_ds6_nbr_update_ll(&nbr,\n                                     (const uip_lladdr_t *)&lladdr_aligned)\n               < 0) {\n              /* failed to update the lladdr */\n              goto discard;\n            }\n            nbr->state = NBR_STALE;\n          } else {\n            if(nbr->state == NBR_INCOMPLETE) {\n              nbr->state = NBR_STALE;\n            }\n          }\n        }\n#if UIP_CONF_IPV6_CHECKS\n      }\n#endif /*UIP_CONF_IPV6_CHECKS */\n      break;\n    default:\n      LOG_WARN(\"ND option not supported in NS\");\n      break;\n    }\n    nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3);\n  }\n\n  addr = uip_ds6_addr_lookup(&UIP_ND6_NS_BUF->tgtipaddr);\n  if(addr != NULL) {\n    if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {\n      /* DAD CASE */\n#if UIP_ND6_DEF_MAXDADNS > 0\n#if UIP_CONF_IPV6_CHECKS\n      if(!uip_is_addr_solicited_node(&UIP_IP_BUF->destipaddr)) {\n        LOG_ERR(\"NS received is bad\\n\");\n        goto discard;\n      }\n#endif /* UIP_CONF_IPV6_CHECKS */\n      if(addr->state != ADDR_TENTATIVE) {\n        uip_create_linklocal_allnodes_mcast(&UIP_IP_BUF->destipaddr);\n        uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);\n        flags = UIP_ND6_NA_FLAG_OVERRIDE;\n        goto create_na;\n      } else {\n          /** \\todo if I sent a NS before him, I win */\n        uip_ds6_dad_failed(addr);\n        goto discard;\n      }\n#else /* UIP_ND6_DEF_MAXDADNS > 0 */\n      goto discard;  /* DAD CASE */\n#endif /* UIP_ND6_DEF_MAXDADNS > 0 */\n    }\n#if UIP_CONF_IPV6_CHECKS\n    if(uip_ds6_is_my_addr(&UIP_IP_BUF->srcipaddr)) {\n        /**\n         * \\NOTE do we do something here? we both are using the same address.\n         * If we are doing dad, we could cancel it, though we should receive a\n         * NA in response of DAD NS we sent, hence DAD will fail anyway. If we\n         * were not doing DAD, it means there is a duplicate in the network!\n         */\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n    }\n#endif /*UIP_CONF_IPV6_CHECKS */\n\n    /* Address resolution case */\n    if(uip_is_addr_solicited_node(&UIP_IP_BUF->destipaddr)) {\n      uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);\n      uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &UIP_ND6_NS_BUF->tgtipaddr);\n      flags = UIP_ND6_NA_FLAG_SOLICITED | UIP_ND6_NA_FLAG_OVERRIDE;\n      goto create_na;\n    }\n\n    /* NUD CASE */\n    if(uip_ds6_addr_lookup(&UIP_IP_BUF->destipaddr) == addr) {\n      uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);\n      uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &UIP_ND6_NS_BUF->tgtipaddr);\n      flags = UIP_ND6_NA_FLAG_SOLICITED | UIP_ND6_NA_FLAG_OVERRIDE;\n      goto create_na;\n    } else {\n#if UIP_CONF_IPV6_CHECKS\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n#endif /* UIP_CONF_IPV6_CHECKS */\n    }\n  } else {\n    goto discard;\n  }\n\n\ncreate_na:\n    /* If the node is a router it should set R flag in NAs */\n#if UIP_CONF_ROUTER\n    flags = flags | UIP_ND6_NA_FLAG_ROUTER;\n#endif\n  uipbuf_clear();\n  UIP_IP_BUF->vtc = 0x60;\n  UIP_IP_BUF->tcflow = 0;\n  UIP_IP_BUF->flow = 0;\n  uipbuf_set_len_field(UIP_IP_BUF, UIP_ICMPH_LEN + UIP_ND6_NA_LEN + UIP_ND6_OPT_LLAO_LEN);\n  UIP_IP_BUF->proto = UIP_PROTO_ICMP6;\n  UIP_IP_BUF->ttl = UIP_ND6_HOP_LIMIT;\n\n  UIP_ICMP_BUF->type = ICMP6_NA;\n  UIP_ICMP_BUF->icode = 0;\n\n  UIP_ND6_NA_BUF->flagsreserved = flags;\n  memcpy(&UIP_ND6_NA_BUF->tgtipaddr, &addr->ipaddr, sizeof(uip_ipaddr_t));\n\n  create_llao(&uip_buf[uip_l3_icmp_hdr_len + UIP_ND6_NA_LEN],\n              UIP_ND6_OPT_TLLAO);\n\n  UIP_ICMP_BUF->icmpchksum = 0;\n  UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();\n\n  uipbuf_set_len(UIP_IPH_LEN + UIP_ICMPH_LEN + UIP_ND6_NA_LEN + UIP_ND6_OPT_LLAO_LEN);\n\n  UIP_STAT(++uip_stat.nd6.sent);\n  LOG_INFO(\"Sending NA to \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n  LOG_INFO_(\" from \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_INFO_(\" with target address \");\n  LOG_INFO_6ADDR(&UIP_ND6_NA_BUF->tgtipaddr);\n  LOG_INFO_(\"\\n\");\n  return;\n\ndiscard:\n  uipbuf_clear();\n  return;\n}",
  "abstract_func": "static void\nns_input(void)\n{\n  uint8_t VAR_0 = 0;\n\n  LOG_INFO(\"Received NS from \");\n  LOG_INFO_6ADDR(&VAR_1->srcipaddr);\n  LOG_INFO_(\" to \");\n  LOG_INFO_6ADDR(&VAR_1->destipaddr);\n  LOG_INFO_(\" with target address \");\n  LOG_INFO_6ADDR((uip_ipaddr_t *) (&VAR_2->tgtipaddr));\n  LOG_INFO_(\"\\n\");\n  UIP_STAT(++VAR_3.nd6.recv);\n\n#if VAR_4\n  if((VAR_1->ttl != VAR_5) ||\n     (uip_is_addr_mcast(&VAR_2->tgtipaddr)) ||\n     (VAR_6->icode != 0)) {\n    LOG_ERR(\"NS received is bad\\n\");\n    goto discard;\n  }\n#endif /* COMMENT_0 */\n\n  /* COMMENT_1 */\n  VAR_7 = NULL;\n  VAR_8 = VAR_9;\n  while(VAR_10 + VAR_8 + VAR_11 < VAR_12) {\n#if VAR_4\n    if(ND6_OPT_HDR_BUF(VAR_8)->len == 0) {\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n    }\n#endif /* COMMENT_0 */\n    switch (ND6_OPT_HDR_BUF(VAR_8)->type) {\n    case VAR_13:\n      if(VAR_10 + VAR_8 +\n         VAR_14 + VAR_15 > VAR_12) {\n        LOG_ERR(\"Insufficient data for NS SLLAO option\\n\");\n        goto discard;\n      }\n      VAR_7 = &VAR_16[VAR_10 + VAR_8];\n#if VAR_4\n      /* COMMENT_2 */\n      if(uip_is_addr_unspecified(&VAR_1->srcipaddr)) {\n        LOG_ERR(\"NS received is bad\\n\");\n        goto discard;\n      } else {\n#endif/* COMMENT_3 */\n        uip_lladdr_t lladdr_aligned;\n        extract_lladdr_from_llao_aligned(&VAR_17);\n        VAR_18 = uip_ds6_nbr_lookup(&VAR_1->srcipaddr);\n        if(VAR_18 == NULL) {\n          uip_ds6_nbr_add(&VAR_1->srcipaddr, &VAR_17,\n\t\t\t  0, VAR_19, VAR_20, NULL);\n        } else {\n          const uip_lladdr_t *VAR_21 = uip_ds6_nbr_get_ll(VAR_18);\n          if(VAR_21 == NULL) {\n            goto discard;\n          }\n          if(memcmp(&VAR_7[VAR_14],\n              VAR_21, VAR_15) != 0) {\n            if(uip_ds6_nbr_update_ll(&VAR_18,\n                                     (const uip_lladdr_t *)&VAR_17)\n               < 0) {\n              /* COMMENT_4 */\n              goto discard;\n            }\n            VAR_18->state = VAR_19;\n          } else {\n            if(VAR_18->state == VAR_22) {\n              VAR_18->state = VAR_19;\n            }\n          }\n        }\n#if VAR_4\n      }\n#endif /* COMMENT_5 */\n      break;\n    default:\n      LOG_WARN(\"ND option not supported in NS\");\n      break;\n    }\n    VAR_8 += (ND6_OPT_HDR_BUF(VAR_8)->len << 3);\n  }\n\n  VAR_23 = uip_ds6_addr_lookup(&VAR_2->tgtipaddr);\n  if(VAR_23 != NULL) {\n    if(uip_is_addr_unspecified(&VAR_1->srcipaddr)) {\n      /* COMMENT_6 */\n#if VAR_24 > 0\n#if VAR_4\n      if(!uip_is_addr_solicited_node(&VAR_1->destipaddr)) {\n        LOG_ERR(\"NS received is bad\\n\");\n        goto discard;\n      }\n#endif /* COMMENT_0 */\n      if(VAR_23->state != VAR_25) {\n        uip_create_linklocal_allnodes_mcast(&VAR_1->destipaddr);\n        uip_ds6_select_src(&VAR_1->srcipaddr, &VAR_1->destipaddr);\n        VAR_0 = VAR_26;\n        goto create_na;\n      } else {\n          /* COMMENT_7 */\n        uip_ds6_dad_failed(VAR_23);\n        goto discard;\n      }\n#else /* COMMENT_8 */\n      goto discard;  /* COMMENT_6 */\n#endif /* COMMENT_8 */\n    }\n#if VAR_4\n    if(uip_ds6_is_my_addr(&VAR_1->srcipaddr)) {\n        /* COMMENT_9 */\n                                                                             \n                                                                              \n                                                                              \n                                                                            \n           \n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n    }\n#endif /* COMMENT_5 */\n\n    /* COMMENT_15 */\n    if(uip_is_addr_solicited_node(&VAR_1->destipaddr)) {\n      uip_ipaddr_copy(&VAR_1->destipaddr, &VAR_1->srcipaddr);\n      uip_ipaddr_copy(&VAR_1->srcipaddr, &VAR_2->tgtipaddr);\n      VAR_0 = VAR_27 | VAR_26;\n      goto create_na;\n    }\n\n    /* COMMENT_16 */\n    if(uip_ds6_addr_lookup(&VAR_1->destipaddr) == VAR_23) {\n      uip_ipaddr_copy(&VAR_1->destipaddr, &VAR_1->srcipaddr);\n      uip_ipaddr_copy(&VAR_1->srcipaddr, &VAR_2->tgtipaddr);\n      VAR_0 = VAR_27 | VAR_26;\n      goto create_na;\n    } else {\n#if VAR_4\n      LOG_ERR(\"NS received is bad\\n\");\n      goto discard;\n#endif /* COMMENT_0 */\n    }\n  } else {\n    goto discard;\n  }\n\n\ncreate_na:\n    /* COMMENT_17 */\n#if VAR_28\n    VAR_0 = VAR_0 | VAR_29;\n#endif\n  uipbuf_clear();\n  VAR_1->vtc = 0x60;\n  VAR_1->tcflow = 0;\n  VAR_1->flow = 0;\n  uipbuf_set_len_field(VAR_1, VAR_30 + VAR_31 + VAR_32);\n  VAR_1->proto = VAR_33;\n  VAR_1->ttl = VAR_5;\n\n  VAR_6->type = VAR_34;\n  VAR_6->icode = 0;\n\n  VAR_35->flagsreserved = VAR_0;\n  memcpy(&VAR_35->tgtipaddr, &VAR_23->ipaddr, sizeof(uip_ipaddr_t));\n\n  create_llao(&VAR_16[VAR_10 + VAR_31],\n              VAR_36);\n\n  VAR_6->icmpchksum = 0;\n  VAR_6->icmpchksum = ~uip_icmp6chksum();\n\n  uipbuf_set_len(VAR_37 + VAR_30 + VAR_31 + VAR_32);\n\n  UIP_STAT(++VAR_3.nd6.sent);\n  LOG_INFO(\"Sending NA to \");\n  LOG_INFO_6ADDR(&VAR_1->destipaddr);\n  LOG_INFO_(\" from \");\n  LOG_INFO_6ADDR(&VAR_1->srcipaddr);\n  LOG_INFO_(\" with target address \");\n  LOG_INFO_6ADDR(&VAR_35->tgtipaddr);\n  LOG_INFO_(\"\\n\");\n  return;\n\ndiscard:\n  uipbuf_clear();\n  return;\n}",
  "func_graph_path": "contiki-ng/a4597001d50a04f4b9c78f323ba731e2f979802c/uip-nd6.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n   /* Options processing */\n   nd6_opt_llao = NULL;\n   nd6_opt_offset = UIP_ND6_NS_LEN;\n-  while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) {\n+  while(uip_l3_icmp_hdr_len + nd6_opt_offset + UIP_ND6_OPT_HDR_LEN < uip_len) {\n #if UIP_CONF_IPV6_CHECKS\n     if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) {\n       LOG_ERR(\"NS received is bad\\n\");\n@@ -33,6 +33,11 @@\n #endif /* UIP_CONF_IPV6_CHECKS */\n     switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) {\n     case UIP_ND6_OPT_SLLAO:\n+      if(uip_l3_icmp_hdr_len + nd6_opt_offset +\n+         UIP_ND6_OPT_DATA_OFFSET + UIP_LLADDR_LEN > uip_len) {\n+        LOG_ERR(\"Insufficient data for NS SLLAO option\\n\");\n+        goto discard;\n+      }\n       nd6_opt_llao = &uip_buf[uip_l3_icmp_hdr_len + nd6_opt_offset];\n #if UIP_CONF_IPV6_CHECKS\n       /* There must be NO option in a DAD NS */",
  "diff_line_info": {
    "deleted_lines": [
      "  while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) {"
    ],
    "added_lines": [
      "  while(uip_l3_icmp_hdr_len + nd6_opt_offset + UIP_ND6_OPT_HDR_LEN < uip_len) {",
      "      if(uip_l3_icmp_hdr_len + nd6_opt_offset +",
      "         UIP_ND6_OPT_DATA_OFFSET + UIP_LLADDR_LEN > uip_len) {",
      "        LOG_ERR(\"Insufficient data for NS SLLAO option\\n\");",
      "        goto discard;",
      "      }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1654",
  "description": {
    "pr_info": {
      "title": "uip-nd6: Check buffer space for ND6 option headers.",
      "number": 1654
    },
    "comment": [
      "When processing incoming IPv6 neighbor solicitation packets, it is possible for an out-of-bounds read to occur because there are insufficient checks for space with regards to ND option headers.\r\n\r\nThis PR adds a check for first reading the generic 2-byte option header, and then one check for reading the source-link-layer address option (SLLAO). Note that we are currently only supporting SLLAOs using UIP_LLADDR_LEN bytes for the address."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}