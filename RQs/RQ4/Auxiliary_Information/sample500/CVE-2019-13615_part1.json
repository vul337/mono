{
  "cve_id": "CVE-2019-13615",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Matroska-Org/libebml",
  "commit_msg": "Exit the max size loop when there's nothing left possible to find\n\nDataStream.getFilePointer() is not correct in this context. It might force to\nexit too early.",
  "commit_hash": "b66ca475be967547af9a3784e720fbbacd381be6",
  "git_url": "https://github.com/Matroska-Org/libebml/commit/b66ca475be967547af9a3784e720fbbacd381be6",
  "file_path": "src/EbmlElement.cpp",
  "func_name": "EbmlElement::FindNextElement",
  "func_before": "EbmlElement * EbmlElement::FindNextElement(IOCallback & DataStream, const EbmlSemanticContext & Context, int & UpperLevel,\n                                           uint64 MaxDataSize, bool AllowDummyElt, unsigned int MaxLowerLevel)\n{\n  int PossibleID_Length = 0;\n  binary PossibleIdNSize[16];\n  int PossibleSizeLength;\n  uint64 SizeUnknown;\n  int ReadIndex = 0; // trick for the algo, start index at 0\n  uint32 ReadSize = 0;\n  uint64 SizeFound;\n  int SizeIdx;\n  bool bFound;\n  int UpperLevel_original = UpperLevel;\n\n  do {\n    // read a potential ID\n    do {\n      assert(ReadIndex < 16);\n      // build the ID with the current Read Buffer\n      bFound = false;\n      binary IdBitMask = 1 << 7;\n      for (SizeIdx = 0; SizeIdx < ReadIndex && SizeIdx < 4; SizeIdx++) {\n        if (PossibleIdNSize[0] & (IdBitMask >> SizeIdx)) {\n          // ID found\n          PossibleID_Length = SizeIdx + 1;\n          IdBitMask >>= SizeIdx;\n          bFound = true;\n          break;\n        }\n      }\n      if (bFound) {\n        break;\n      }\n\n      if (ReadIndex >= 4) {\n        // ID not found\n        // shift left the read octets\n        memmove(&PossibleIdNSize[0],&PossibleIdNSize[1], --ReadIndex);\n      }\n\n      if (MaxDataSize <= ReadSize)\n        break;\n      if (DataStream.read(&PossibleIdNSize[ReadIndex++], 1) == 0) {\n        return NULL; // no more data ?\n      }\n      ReadSize++;\n\n    } while (!bFound);\n\n    if (!bFound)\n      // we reached the maximum we could read without a proper ID\n      return NULL;\n\n    SizeIdx = ReadIndex;\n    ReadIndex -= PossibleID_Length;\n\n    // read the data size\n    uint32 _SizeLength;\n    PossibleSizeLength = ReadIndex;\n    while (1) {\n      _SizeLength = PossibleSizeLength;\n      SizeFound = ReadCodedSizeValue(&PossibleIdNSize[PossibleID_Length], _SizeLength, SizeUnknown);\n      if (_SizeLength != 0) {\n        bFound = true;\n        break;\n      }\n      if (PossibleSizeLength >= 8) {\n        bFound = false;\n        break;\n      }\n      if (MaxDataSize <= ReadSize) {\n        bFound = false;\n        break;\n      }\n      if( DataStream.read( &PossibleIdNSize[SizeIdx++], 1 ) == 0 ) {\n        return NULL; // no more data ?\n      }\n      ReadSize++;\n      PossibleSizeLength++;\n    }\n\n    if (bFound) {\n      // find the element in the context and use the correct creator\n      EbmlId PossibleID(PossibleIdNSize, PossibleID_Length);\n      EbmlElement * Result = CreateElementUsingContext(PossibleID, Context, UpperLevel, false, AllowDummyElt, MaxLowerLevel);\n      ///< \\todo continue is misplaced\n      if (Result != NULL) {\n        if (AllowDummyElt || !Result->IsDummy()) {\n          Result->SetSizeLength(_SizeLength);\n\n          Result->Size = SizeFound;\n          // UpperLevel values\n          // -1 : global element\n          //  0 : child\n          //  1 : same level\n          //  + : further parent\n          if (Result->ValidateSize() && (SizeFound == SizeUnknown || UpperLevel > 0 || MaxDataSize == 0 || MaxDataSize >= (PossibleID_Length + PossibleSizeLength + SizeFound))) {\n            if (SizeFound != SizeUnknown || Result->SetSizeInfinite()) {\n              Result->SizePosition = DataStream.getFilePointer() - SizeIdx + EBML_ID_LENGTH(PossibleID);\n              Result->ElementPosition = Result->SizePosition - EBML_ID_LENGTH(PossibleID);\n              // place the file at the beggining of the data\n              DataStream.setFilePointer(Result->SizePosition + _SizeLength);\n              return Result;\n            }\n          }\n        }\n        delete Result;\n      }\n    }\n\n    // recover all the data in the buffer minus one byte\n    ReadIndex = SizeIdx - 1;\n    memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex);\n    UpperLevel = UpperLevel_original;\n  } while ( MaxDataSize > DataStream.getFilePointer() - SizeIdx + PossibleID_Length );\n\n  return NULL;\n}",
  "abstract_func_before": "EbmlElement * EbmlElement::FindNextElement(IOCallback & VAR_0, const EbmlSemanticContext & VAR_1, int & VAR_2,\n                                           uint64 VAR_3, bool VAR_4, unsigned int VAR_5)\n{\n  int VAR_6 = 0;\n  binary VAR_7[16];\n  int VAR_8;\n  uint64 VAR_9;\n  int VAR_10 = 0; /* COMMENT_0 */\n  uint32 VAR_11 = 0;\n  uint64 VAR_12;\n  int VAR_13;\n  bool VAR_14;\n  int VAR_15 = VAR_2;\n\n  do {\n    /* COMMENT_1 */\n    do {\n      assert(VAR_10 < 16);\n      /* COMMENT_2 */\n      VAR_14 = false;\n      binary VAR_16 = 1 << 7;\n      for (VAR_13 = 0; VAR_13 < VAR_10 && VAR_13 < 4; VAR_13++) {\n        if (VAR_7[0] & (VAR_16 >> VAR_13)) {\n          /* COMMENT_3 */\n          VAR_6 = VAR_13 + 1;\n          VAR_16 >>= VAR_13;\n          VAR_14 = true;\n          break;\n        }\n      }\n      if (VAR_14) {\n        break;\n      }\n\n      if (VAR_10 >= 4) {\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        memmove(&VAR_7[0],&VAR_7[1], --VAR_10);\n      }\n\n      if (VAR_3 <= VAR_11)\n        break;\n      if (VAR_0.read(&VAR_7[VAR_10++], 1) == 0) {\n        return NULL; /* COMMENT_6 */\n      }\n      VAR_11++;\n\n    } while (!VAR_14);\n\n    if (!VAR_14)\n      /* COMMENT_7 */\n      return NULL;\n\n    VAR_13 = VAR_10;\n    VAR_10 -= VAR_6;\n\n    /* COMMENT_8 */\n    uint32 VAR_17;\n    VAR_8 = VAR_10;\n    while (1) {\n      VAR_17 = VAR_8;\n      VAR_12 = ReadCodedSizeValue(&VAR_7[VAR_6], VAR_17, VAR_9);\n      if (VAR_17 != 0) {\n        VAR_14 = true;\n        break;\n      }\n      if (VAR_8 >= 8) {\n        VAR_14 = false;\n        break;\n      }\n      if (VAR_3 <= VAR_11) {\n        VAR_14 = false;\n        break;\n      }\n      if( VAR_0.read( &VAR_7[VAR_13++], 1 ) == 0 ) {\n        return NULL; /* COMMENT_6 */\n      }\n      VAR_11++;\n      VAR_8++;\n    }\n\n    if (VAR_14) {\n      /* COMMENT_9 */\n      EbmlId PossibleID(PossibleIdNSize, PossibleID_Length);\n      EbmlElement * VAR_18 = CreateElementUsingContext(VAR_19, VAR_1, VAR_2, false, VAR_4, VAR_5);\n      /* COMMENT_10 */\n      if (VAR_18 != NULL) {\n        if (VAR_4 || !VAR_18->IsDummy()) {\n          VAR_18->SetSizeLength(VAR_17);\n\n          VAR_18->Size = VAR_12;\n          /* COMMENT_11 */\n          /* COMMENT_12 */\n          /* COMMENT_13 */\n          /* COMMENT_14 */\n          /* COMMENT_15 */\n          if (VAR_18->ValidateSize() && (VAR_12 == VAR_9 || VAR_2 > 0 || VAR_3 == 0 || VAR_3 >= (PossibleID_Length + VAR_8 + VAR_12))) {\n            if (VAR_12 != VAR_9 || VAR_18->SetSizeInfinite()) {\n              VAR_18->SizePosition = VAR_0.getFilePointer() - VAR_13 + EBML_ID_LENGTH(VAR_19);\n              VAR_18->ElementPosition = VAR_18->SizePosition - EBML_ID_LENGTH(VAR_19);\n              /* COMMENT_16 */\n              VAR_0.setFilePointer(VAR_18->SizePosition + VAR_17);\n              return VAR_18;\n            }\n          }\n        }\n        delete VAR_18;\n      }\n    }\n\n    /* COMMENT_17 */\n    VAR_10 = VAR_13 - 1;\n    memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], VAR_10);\n    VAR_2 = VAR_15;\n  } while ( VAR_3 > VAR_0.getFilePointer() - VAR_13 + PossibleID_Length );\n\n  return NULL;\n}",
  "func_graph_path_before": "Matroska-Org/libebml/b66ca475be967547af9a3784e720fbbacd381be6/EbmlElement.cpp/vul/before/0.json",
  "func": "EbmlElement * EbmlElement::FindNextElement(IOCallback & DataStream, const EbmlSemanticContext & Context, int & UpperLevel,\n                                           uint64 MaxDataSize, bool AllowDummyElt, unsigned int MaxLowerLevel)\n{\n  int PossibleID_Length = 0;\n  binary PossibleIdNSize[16];\n  int PossibleSizeLength;\n  uint64 SizeUnknown;\n  int ReadIndex = 0; // trick for the algo, start index at 0\n  uint32 ReadSize = 0;\n  uint64 SizeFound;\n  int SizeIdx;\n  bool bFound;\n  int UpperLevel_original = UpperLevel;\n\n  do {\n    // read a potential ID\n    do {\n      assert(ReadIndex < 16);\n      // build the ID with the current Read Buffer\n      bFound = false;\n      binary IdBitMask = 1 << 7;\n      for (SizeIdx = 0; SizeIdx < ReadIndex && SizeIdx < 4; SizeIdx++) {\n        if (PossibleIdNSize[0] & (IdBitMask >> SizeIdx)) {\n          // ID found\n          PossibleID_Length = SizeIdx + 1;\n          IdBitMask >>= SizeIdx;\n          bFound = true;\n          break;\n        }\n      }\n      if (bFound) {\n        break;\n      }\n\n      if (ReadIndex >= 4) {\n        // ID not found\n        // shift left the read octets\n        memmove(&PossibleIdNSize[0],&PossibleIdNSize[1], --ReadIndex);\n      }\n\n      if (MaxDataSize <= ReadSize)\n        break;\n      if (DataStream.read(&PossibleIdNSize[ReadIndex++], 1) == 0) {\n        return NULL; // no more data ?\n      }\n      ReadSize++;\n\n    } while (!bFound);\n\n    if (!bFound)\n      // we reached the maximum we could read without a proper ID\n      return NULL;\n\n    SizeIdx = ReadIndex;\n    ReadIndex -= PossibleID_Length;\n\n    // read the data size\n    uint32 _SizeLength;\n    PossibleSizeLength = ReadIndex;\n    while (1) {\n      _SizeLength = PossibleSizeLength;\n      SizeFound = ReadCodedSizeValue(&PossibleIdNSize[PossibleID_Length], _SizeLength, SizeUnknown);\n      if (_SizeLength != 0) {\n        bFound = true;\n        break;\n      }\n      if (PossibleSizeLength >= 8) {\n        bFound = false;\n        break;\n      }\n      if (MaxDataSize <= ReadSize) {\n        bFound = false;\n        break;\n      }\n      if( DataStream.read( &PossibleIdNSize[SizeIdx++], 1 ) == 0 ) {\n        return NULL; // no more data ?\n      }\n      ReadSize++;\n      PossibleSizeLength++;\n    }\n\n    if (bFound) {\n      // find the element in the context and use the correct creator\n      EbmlId PossibleID(PossibleIdNSize, PossibleID_Length);\n      EbmlElement * Result = CreateElementUsingContext(PossibleID, Context, UpperLevel, false, AllowDummyElt, MaxLowerLevel);\n      ///< \\todo continue is misplaced\n      if (Result != NULL) {\n        if (AllowDummyElt || !Result->IsDummy()) {\n          Result->SetSizeLength(_SizeLength);\n\n          Result->Size = SizeFound;\n          // UpperLevel values\n          // -1 : global element\n          //  0 : child\n          //  1 : same level\n          //  + : further parent\n          if (Result->ValidateSize() && (SizeFound == SizeUnknown || UpperLevel > 0 || MaxDataSize == 0 || MaxDataSize >= (PossibleID_Length + PossibleSizeLength + SizeFound))) {\n            if (SizeFound != SizeUnknown || Result->SetSizeInfinite()) {\n              Result->SizePosition = DataStream.getFilePointer() - SizeIdx + EBML_ID_LENGTH(PossibleID);\n              Result->ElementPosition = Result->SizePosition - EBML_ID_LENGTH(PossibleID);\n              // place the file at the beggining of the data\n              DataStream.setFilePointer(Result->SizePosition + _SizeLength);\n              return Result;\n            }\n          }\n        }\n        delete Result;\n      }\n    }\n\n    // recover all the data in the buffer minus one byte\n    ReadIndex = SizeIdx - 1;\n    memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex);\n    UpperLevel = UpperLevel_original;\n  } while ( MaxDataSize >= ReadSize );\n\n  return NULL;\n}",
  "abstract_func": "EbmlElement * EbmlElement::FindNextElement(IOCallback & VAR_0, const EbmlSemanticContext & VAR_1, int & VAR_2,\n                                           uint64 VAR_3, bool VAR_4, unsigned int VAR_5)\n{\n  int VAR_6 = 0;\n  binary VAR_7[16];\n  int VAR_8;\n  uint64 VAR_9;\n  int VAR_10 = 0; /* COMMENT_0 */\n  uint32 VAR_11 = 0;\n  uint64 VAR_12;\n  int VAR_13;\n  bool VAR_14;\n  int VAR_15 = VAR_2;\n\n  do {\n    /* COMMENT_1 */\n    do {\n      assert(VAR_10 < 16);\n      /* COMMENT_2 */\n      VAR_14 = false;\n      binary VAR_16 = 1 << 7;\n      for (VAR_13 = 0; VAR_13 < VAR_10 && VAR_13 < 4; VAR_13++) {\n        if (VAR_7[0] & (VAR_16 >> VAR_13)) {\n          /* COMMENT_3 */\n          VAR_6 = VAR_13 + 1;\n          VAR_16 >>= VAR_13;\n          VAR_14 = true;\n          break;\n        }\n      }\n      if (VAR_14) {\n        break;\n      }\n\n      if (VAR_10 >= 4) {\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        memmove(&VAR_7[0],&VAR_7[1], --VAR_10);\n      }\n\n      if (VAR_3 <= VAR_11)\n        break;\n      if (VAR_0.read(&VAR_7[VAR_10++], 1) == 0) {\n        return NULL; /* COMMENT_6 */\n      }\n      VAR_11++;\n\n    } while (!VAR_14);\n\n    if (!VAR_14)\n      /* COMMENT_7 */\n      return NULL;\n\n    VAR_13 = VAR_10;\n    VAR_10 -= VAR_6;\n\n    /* COMMENT_8 */\n    uint32 VAR_17;\n    VAR_8 = VAR_10;\n    while (1) {\n      VAR_17 = VAR_8;\n      VAR_12 = ReadCodedSizeValue(&VAR_7[VAR_6], VAR_17, VAR_9);\n      if (VAR_17 != 0) {\n        VAR_14 = true;\n        break;\n      }\n      if (VAR_8 >= 8) {\n        VAR_14 = false;\n        break;\n      }\n      if (VAR_3 <= VAR_11) {\n        VAR_14 = false;\n        break;\n      }\n      if( VAR_0.read( &VAR_7[VAR_13++], 1 ) == 0 ) {\n        return NULL; /* COMMENT_6 */\n      }\n      VAR_11++;\n      VAR_8++;\n    }\n\n    if (VAR_14) {\n      /* COMMENT_9 */\n      EbmlId PossibleID(PossibleIdNSize, PossibleID_Length);\n      EbmlElement * VAR_18 = CreateElementUsingContext(VAR_19, VAR_1, VAR_2, false, VAR_4, VAR_5);\n      /* COMMENT_10 */\n      if (VAR_18 != NULL) {\n        if (VAR_4 || !VAR_18->IsDummy()) {\n          VAR_18->SetSizeLength(VAR_17);\n\n          VAR_18->Size = VAR_12;\n          /* COMMENT_11 */\n          /* COMMENT_12 */\n          /* COMMENT_13 */\n          /* COMMENT_14 */\n          /* COMMENT_15 */\n          if (VAR_18->ValidateSize() && (VAR_12 == VAR_9 || VAR_2 > 0 || VAR_3 == 0 || VAR_3 >= (PossibleID_Length + VAR_8 + VAR_12))) {\n            if (VAR_12 != VAR_9 || VAR_18->SetSizeInfinite()) {\n              VAR_18->SizePosition = VAR_0.getFilePointer() - VAR_13 + EBML_ID_LENGTH(VAR_19);\n              VAR_18->ElementPosition = VAR_18->SizePosition - EBML_ID_LENGTH(VAR_19);\n              /* COMMENT_16 */\n              VAR_0.setFilePointer(VAR_18->SizePosition + VAR_17);\n              return VAR_18;\n            }\n          }\n        }\n        delete VAR_18;\n      }\n    }\n\n    /* COMMENT_17 */\n    VAR_10 = VAR_13 - 1;\n    memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], VAR_10);\n    VAR_2 = VAR_15;\n  } while ( VAR_3 >= VAR_11 );\n\n  return NULL;\n}",
  "func_graph_path": "Matroska-Org/libebml/b66ca475be967547af9a3784e720fbbacd381be6/EbmlElement.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -112,7 +112,7 @@\n     ReadIndex = SizeIdx - 1;\n     memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex);\n     UpperLevel = UpperLevel_original;\n-  } while ( MaxDataSize > DataStream.getFilePointer() - SizeIdx + PossibleID_Length );\n+  } while ( MaxDataSize >= ReadSize );\n \n   return NULL;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  } while ( MaxDataSize > DataStream.getFilePointer() - SizeIdx + PossibleID_Length );"
    ],
    "added_lines": [
      "  } while ( MaxDataSize >= ReadSize );"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Matroska-Org/libebml/pull/29",
  "description": {
    "pr_info": {
      "title": "Exit the max size loop when there's nothing left possible to find",
      "number": 29
    },
    "comment": [
      "DataStream.getFilePointer() is not correct in this context. It might force to\r\nexit too early.",
      "LGTM, thanks."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.95"
}