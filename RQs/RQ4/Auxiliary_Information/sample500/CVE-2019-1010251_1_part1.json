{
  "cve_id": "CVE-2019-1010251",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OISF/suricata",
  "commit_msg": "teredo: be stricter on what to consider valid teredo\n\nInvalid Teredo can lead to valid DNS traffic (or other UDP traffic)\nbeing misdetected as Teredo. This leads to false negatives in the\nUDP payload inspection.\n\nMake the teredo code only consider a packet teredo if the encapsulated\ndata was decoded without any 'invalid' events being set.\n\nBug #2736.",
  "commit_hash": "11f3659f64a4e42e90cb3c09fcef66894205aefe",
  "git_url": "https://github.com/OISF/suricata/commit/11f3659f64a4e42e90cb3c09fcef66894205aefe",
  "file_path": "src/decode.c",
  "func_name": "PacketTunnelPktSetup",
  "func_before": "Packet *PacketTunnelPktSetup(ThreadVars *tv, DecodeThreadVars *dtv, Packet *parent,\n                             uint8_t *pkt, uint32_t len, enum DecodeTunnelProto proto,\n                             PacketQueue *pq)\n{\n    int ret;\n\n    SCEnter();\n\n    /* get us a packet */\n    Packet *p = PacketGetFromQueueOrAlloc();\n    if (unlikely(p == NULL)) {\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n    /* copy packet and set lenght, proto */\n    PacketCopyData(p, pkt, len);\n    p->recursion_level = parent->recursion_level + 1;\n    p->ts.tv_sec = parent->ts.tv_sec;\n    p->ts.tv_usec = parent->ts.tv_usec;\n    p->datalink = DLT_RAW;\n    p->tenant_id = parent->tenant_id;\n\n    /* set the root ptr to the lowest layer */\n    if (parent->root != NULL)\n        p->root = parent->root;\n    else\n        p->root = parent;\n\n    /* tell new packet it's part of a tunnel */\n    SET_TUNNEL_PKT(p);\n\n    ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),\n                       GET_PKT_LEN(p), pq, proto);\n\n    if (unlikely(ret != TM_ECODE_OK)) {\n        /* Not a tunnel packet, just a pseudo packet */\n        p->root = NULL;\n        UNSET_TUNNEL_PKT(p);\n        TmqhOutputPacketpool(tv, p);\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n\n    /* tell parent packet it's part of a tunnel */\n    SET_TUNNEL_PKT(parent);\n\n    /* increment tunnel packet refcnt in the root packet */\n    TUNNEL_INCR_PKT_TPR(p);\n\n    /* disable payload (not packet) inspection on the parent, as the payload\n     * is the packet we will now run through the system separately. We do\n     * check it against the ip/port/other header checks though */\n    DecodeSetNoPayloadInspectionFlag(parent);\n    SCReturnPtr(p, \"Packet\");\n}",
  "abstract_func_before": "Packet *PacketTunnelPktSetup(ThreadVars *VAR_0, DecodeThreadVars *VAR_1, Packet *VAR_2,\n                             uint8_t *VAR_3, uint32_t VAR_4, enum DecodeTunnelProto VAR_5,\n                             PacketQueue *VAR_6)\n{\n    int VAR_7;\n\n    SCEnter();\n\n    /* COMMENT_0 */\n    Packet *VAR_8 = PacketGetFromQueueOrAlloc();\n    if (unlikely(VAR_8 == NULL)) {\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n    /* COMMENT_1 */\n    PacketCopyData(VAR_8, VAR_3, VAR_4);\n    VAR_8->recursion_level = VAR_2->recursion_level + 1;\n    VAR_8->ts.tv_sec = VAR_2->ts.tv_sec;\n    VAR_8->ts.tv_usec = VAR_2->ts.tv_usec;\n    VAR_8->datalink = VAR_9;\n    VAR_8->tenant_id = VAR_2->tenant_id;\n\n    /* COMMENT_2 */\n    if (VAR_2->root != NULL)\n        VAR_8->root = VAR_2->root;\n    else\n        VAR_8->root = VAR_2;\n\n    /* COMMENT_3 */\n    SET_TUNNEL_PKT(VAR_8);\n\n    VAR_7 = DecodeTunnel(VAR_0, VAR_1, VAR_8, GET_PKT_DATA(VAR_8),\n                       GET_PKT_LEN(VAR_8), VAR_6, VAR_5);\n\n    if (unlikely(VAR_7 != VAR_10)) {\n        /* COMMENT_4 */\n        VAR_8->root = NULL;\n        UNSET_TUNNEL_PKT(VAR_8);\n        TmqhOutputPacketpool(VAR_0, VAR_8);\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n\n    /* COMMENT_5 */\n    SET_TUNNEL_PKT(VAR_2);\n\n    /* COMMENT_6 */\n    TUNNEL_INCR_PKT_TPR(VAR_8);\n\n    /* COMMENT_7 */\n                                                                         \n                                                                 \n    DecodeSetNoPayloadInspectionFlag(VAR_2);\n    SCReturnPtr(VAR_8, \"Packet\");\n}",
  "func_graph_path_before": "OISF/suricata/11f3659f64a4e42e90cb3c09fcef66894205aefe/decode.c/vul/before/0.json",
  "func": "Packet *PacketTunnelPktSetup(ThreadVars *tv, DecodeThreadVars *dtv, Packet *parent,\n                             uint8_t *pkt, uint32_t len, enum DecodeTunnelProto proto,\n                             PacketQueue *pq)\n{\n    int ret;\n\n    SCEnter();\n\n    /* get us a packet */\n    Packet *p = PacketGetFromQueueOrAlloc();\n    if (unlikely(p == NULL)) {\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n    /* copy packet and set lenght, proto */\n    PacketCopyData(p, pkt, len);\n    p->recursion_level = parent->recursion_level + 1;\n    p->ts.tv_sec = parent->ts.tv_sec;\n    p->ts.tv_usec = parent->ts.tv_usec;\n    p->datalink = DLT_RAW;\n    p->tenant_id = parent->tenant_id;\n\n    /* set the root ptr to the lowest layer */\n    if (parent->root != NULL)\n        p->root = parent->root;\n    else\n        p->root = parent;\n\n    /* tell new packet it's part of a tunnel */\n    SET_TUNNEL_PKT(p);\n\n    ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),\n                       GET_PKT_LEN(p), pq, proto);\n\n    if (unlikely(ret != TM_ECODE_OK) ||\n            (proto == DECODE_TUNNEL_IPV6_TEREDO && (p->flags & PKT_IS_INVALID)))\n    {\n        /* Not a (valid) tunnel packet */\n        SCLogDebug(\"tunnel packet is invalid\");\n\n        p->root = NULL;\n        UNSET_TUNNEL_PKT(p);\n        TmqhOutputPacketpool(tv, p);\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n\n    /* tell parent packet it's part of a tunnel */\n    SET_TUNNEL_PKT(parent);\n\n    /* increment tunnel packet refcnt in the root packet */\n    TUNNEL_INCR_PKT_TPR(p);\n\n    /* disable payload (not packet) inspection on the parent, as the payload\n     * is the packet we will now run through the system separately. We do\n     * check it against the ip/port/other header checks though */\n    DecodeSetNoPayloadInspectionFlag(parent);\n    SCReturnPtr(p, \"Packet\");\n}",
  "abstract_func": "Packet *PacketTunnelPktSetup(ThreadVars *VAR_0, DecodeThreadVars *VAR_1, Packet *VAR_2,\n                             uint8_t *VAR_3, uint32_t VAR_4, enum DecodeTunnelProto VAR_5,\n                             PacketQueue *VAR_6)\n{\n    int VAR_7;\n\n    SCEnter();\n\n    /* COMMENT_0 */\n    Packet *VAR_8 = PacketGetFromQueueOrAlloc();\n    if (unlikely(VAR_8 == NULL)) {\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n    /* COMMENT_1 */\n    PacketCopyData(VAR_8, VAR_3, VAR_4);\n    VAR_8->recursion_level = VAR_2->recursion_level + 1;\n    VAR_8->ts.tv_sec = VAR_2->ts.tv_sec;\n    VAR_8->ts.tv_usec = VAR_2->ts.tv_usec;\n    VAR_8->datalink = VAR_9;\n    VAR_8->tenant_id = VAR_2->tenant_id;\n\n    /* COMMENT_2 */\n    if (VAR_2->root != NULL)\n        VAR_8->root = VAR_2->root;\n    else\n        VAR_8->root = VAR_2;\n\n    /* COMMENT_3 */\n    SET_TUNNEL_PKT(VAR_8);\n\n    VAR_7 = DecodeTunnel(VAR_0, VAR_1, VAR_8, GET_PKT_DATA(VAR_8),\n                       GET_PKT_LEN(VAR_8), VAR_6, VAR_5);\n\n    if (unlikely(VAR_7 != VAR_10) ||\n            (VAR_5 == VAR_11 && (VAR_8->flags & VAR_12)))\n    {\n        /* COMMENT_4 */\n        SCLogDebug(\"tunnel packet is invalid\");\n\n        VAR_8->root = NULL;\n        UNSET_TUNNEL_PKT(VAR_8);\n        TmqhOutputPacketpool(VAR_0, VAR_8);\n        SCReturnPtr(NULL, \"Packet\");\n    }\n\n\n    /* COMMENT_5 */\n    SET_TUNNEL_PKT(VAR_2);\n\n    /* COMMENT_6 */\n    TUNNEL_INCR_PKT_TPR(VAR_8);\n\n    /* COMMENT_7 */\n                                                                         \n                                                                 \n    DecodeSetNoPayloadInspectionFlag(VAR_2);\n    SCReturnPtr(VAR_8, \"Packet\");\n}",
  "func_graph_path": "OISF/suricata/11f3659f64a4e42e90cb3c09fcef66894205aefe/decode.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -32,8 +32,12 @@\n     ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),\n                        GET_PKT_LEN(p), pq, proto);\n \n-    if (unlikely(ret != TM_ECODE_OK)) {\n-        /* Not a tunnel packet, just a pseudo packet */\n+    if (unlikely(ret != TM_ECODE_OK) ||\n+            (proto == DECODE_TUNNEL_IPV6_TEREDO && (p->flags & PKT_IS_INVALID)))\n+    {\n+        /* Not a (valid) tunnel packet */\n+        SCLogDebug(\"tunnel packet is invalid\");\n+\n         p->root = NULL;\n         UNSET_TUNNEL_PKT(p);\n         TmqhOutputPacketpool(tv, p);",
  "diff_line_info": {
    "deleted_lines": [
      "    if (unlikely(ret != TM_ECODE_OK)) {",
      "        /* Not a tunnel packet, just a pseudo packet */"
    ],
    "added_lines": [
      "    if (unlikely(ret != TM_ECODE_OK) ||",
      "            (proto == DECODE_TUNNEL_IPV6_TEREDO && (p->flags & PKT_IS_INVALID)))",
      "    {",
      "        /* Not a (valid) tunnel packet */",
      "        SCLogDebug(\"tunnel packet is invalid\");",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OISF/suricata/pull/3590",
  "description": {
    "pr_info": {
      "title": "Next/20181218/v8",
      "number": 3590
    },
    "comment": [
      "Describe changes:\r\n- as #3589, but make IPv6 decoder a bit more strict\r\n\r\n[PRScript](https://redmine.openinfosecfoundation.org/projects/suricata/wiki/PRscript) output (if applicable):\r\nN/A\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades  \nConfidence: 0.9"
}