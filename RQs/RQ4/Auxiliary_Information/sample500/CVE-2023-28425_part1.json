{
  "cve_id": "CVE-2023-28425",
  "cwe_ids": [
    "CWE-77"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "Avoid assertion when MSETNX is used with the same key twice (CVE-2023-28425) (#11940)\n\nUsing the same key twice in MSETNX command would trigger an assertion.\r\n\r\nThis reverts #11594 (introduced in Redis 7.0.8)",
  "commit_hash": "48e0d4788434833b47892fe9f3d91be7687f25c9",
  "git_url": "https://github.com/redis/redis/commit/48e0d4788434833b47892fe9f3d91be7687f25c9",
  "file_path": "src/t_string.c",
  "func_name": "msetGenericCommand",
  "func_before": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}",
  "abstract_func_before": "void msetGenericCommand(client *VAR_0, int VAR_1) {\n    int VAR_2;\n    int VAR_3 = 0;\n\n    if ((VAR_0->argc % 2) == 0) {\n        addReplyErrorArity(VAR_0);\n        return;\n    }\n\n    /* COMMENT_0 */\n                                                          \n    if (VAR_1) {\n        for (VAR_2 = 1; VAR_2 < VAR_0->argc; VAR_2 += 2) {\n            if (lookupKeyWrite(VAR_0->db,VAR_0->argv[VAR_2]) != NULL) {\n                addReply(VAR_0, VAR_4.czero);\n                return;\n            }\n        }\n        VAR_3 |= VAR_5;\n    }\n\n    for (VAR_2 = 1; VAR_2 < VAR_0->argc; VAR_2 += 2) {\n        VAR_0->argv[VAR_2+1] = tryObjectEncoding(VAR_0->argv[VAR_2+1]);\n        setKey(VAR_0, VAR_0->db, VAR_0->argv[VAR_2], VAR_0->argv[VAR_2 + 1], VAR_3);\n        notifyKeyspaceEvent(VAR_6,\"set\",VAR_0->argv[VAR_2],VAR_0->db->id);\n    }\n    VAR_7.dirty += (VAR_0->argc-1)/2;\n    addReply(VAR_0, VAR_1 ? VAR_4.cone : VAR_4.ok);\n}",
  "func_graph_path_before": "redis/48e0d4788434833b47892fe9f3d91be7687f25c9/t_string.c/vul/before/0.json",
  "func": "void msetGenericCommand(client *c, int nx) {\n    int j;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}",
  "abstract_func": "void msetGenericCommand(client *VAR_0, int VAR_1) {\n    int VAR_2;\n\n    if ((VAR_0->argc % 2) == 0) {\n        addReplyErrorArity(VAR_0);\n        return;\n    }\n\n    /* COMMENT_0 */\n                                                          \n    if (VAR_1) {\n        for (VAR_2 = 1; VAR_2 < VAR_0->argc; VAR_2 += 2) {\n            if (lookupKeyWrite(VAR_0->db,VAR_0->argv[VAR_2]) != NULL) {\n                addReply(VAR_0, VAR_3.czero);\n                return;\n            }\n        }\n    }\n\n    for (VAR_2 = 1; VAR_2 < VAR_0->argc; VAR_2 += 2) {\n        VAR_0->argv[VAR_2+1] = tryObjectEncoding(VAR_0->argv[VAR_2+1]);\n        setKey(VAR_0, VAR_0->db, VAR_0->argv[VAR_2], VAR_0->argv[VAR_2 + 1], 0);\n        notifyKeyspaceEvent(VAR_4,\"set\",VAR_0->argv[VAR_2],VAR_0->db->id);\n    }\n    VAR_5.dirty += (VAR_0->argc-1)/2;\n    addReply(VAR_0, VAR_1 ? VAR_3.cone : VAR_3.ok);\n}",
  "func_graph_path": "redis/48e0d4788434833b47892fe9f3d91be7687f25c9/t_string.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n void msetGenericCommand(client *c, int nx) {\n     int j;\n-    int setkey_flags = 0;\n \n     if ((c->argc % 2) == 0) {\n         addReplyErrorArity(c);\n@@ -16,12 +15,11 @@\n                 return;\n             }\n         }\n-        setkey_flags |= SETKEY_DOESNT_EXIST;\n     }\n \n     for (j = 1; j < c->argc; j += 2) {\n         c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n-        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n+        setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);\n         notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n     }\n     server.dirty += (c->argc-1)/2;",
  "diff_line_info": {
    "deleted_lines": [
      "    int setkey_flags = 0;",
      "        setkey_flags |= SETKEY_DOESNT_EXIST;",
      "        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);"
    ],
    "added_lines": [
      "        setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/11940",
  "description": {
    "pr_info": {
      "title": "Avoid assertion when MSETNX is used with the same key twice (CVE-2023-28425)",
      "number": 11940
    },
    "comment": [
      "Using the same key twice in MSETNX command would trigger an assertion.\r\n\r\nThis reverts #11594 (introduced in Redis 7.0.8)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}