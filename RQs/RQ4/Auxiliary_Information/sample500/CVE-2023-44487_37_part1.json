{
  "cve_id": "CVE-2023-44487",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Close HTTP connections that prematurely reset streams\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>\n\nSigned-off-by: Ryan Northey <ryan@synca.io>",
  "commit_hash": "6f8a69e5023eba51bfaeec6d551a5b9840e8c6d1",
  "git_url": "https://github.com/envoyproxy/envoy/commit/6f8a69e5023eba51bfaeec6d551a5b9840e8c6d1",
  "file_path": "source/common/http/conn_manager_impl.cc",
  "func_name": "ConnectionManagerImpl::doDeferredStreamDestroy",
  "func_before": "void ConnectionManagerImpl::doDeferredStreamDestroy(ActiveStream& stream) {\n  if (stream.max_stream_duration_timer_ != nullptr) {\n    stream.max_stream_duration_timer_->disableTimer();\n    stream.max_stream_duration_timer_ = nullptr;\n  }\n  if (stream.stream_idle_timer_ != nullptr) {\n    stream.stream_idle_timer_->disableTimer();\n    stream.stream_idle_timer_ = nullptr;\n  }\n  stream.filter_manager_.disarmRequestTimeout();\n  if (stream.request_header_timer_ != nullptr) {\n    stream.request_header_timer_->disableTimer();\n    stream.request_header_timer_ = nullptr;\n  }\n  if (stream.access_log_flush_timer_ != nullptr) {\n    stream.access_log_flush_timer_->disableTimer();\n    stream.access_log_flush_timer_ = nullptr;\n  }\n\n  if (stream.expand_agnostic_stream_lifetime_) {\n    // Only destroy the active stream if the underlying codec has notified us of\n    // completion or we've internal redirect the stream.\n    if (!stream.canDestroyStream()) {\n      // Track that this stream is not expecting any additional calls apart from\n      // codec notification.\n      stream.state_.is_zombie_stream_ = true;\n      return;\n    }\n\n    if (stream.response_encoder_ != nullptr) {\n      stream.response_encoder_->getStream().registerCodecEventCallbacks(nullptr);\n    }\n  }\n\n  stream.completeRequest();\n\n  // If refresh rtt after request is required explicitly, then try to get rtt again set it into\n  // connection info.\n  if (refresh_rtt_after_request_) {\n    // Set roundtrip time in connectionInfoSetter before OnStreamComplete\n    absl::optional<std::chrono::milliseconds> t = read_callbacks_->connection().lastRoundTripTime();\n    if (t.has_value()) {\n      read_callbacks_->connection().connectionInfoSetter().setRoundTripTime(t.value());\n    }\n  }\n\n  stream.filter_manager_.onStreamComplete();\n\n  // For HTTP/3, skip access logging here and add deferred logging info\n  // to stream info for QuicStatsGatherer to use later.\n  if (codec_ && codec_->protocol() == Protocol::Http3 &&\n      // There was a downstream reset, log immediately.\n      !stream.filter_manager_.sawDownstreamReset() &&\n      // On recreate stream, log immediately.\n      stream.response_encoder_ != nullptr &&\n      Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.quic_defer_logging_to_ack_listener\")) {\n    stream.deferHeadersAndTrailers();\n  } else {\n    // For HTTP/1 and HTTP/2, log here as usual.\n    stream.filter_manager_.log(AccessLog::AccessLogType::DownstreamEnd);\n  }\n\n  stream.filter_manager_.destroyFilters();\n\n  dispatcher_->deferredDelete(stream.removeFromList(streams_));\n\n  // The response_encoder should never be dangling (unless we're destroying a\n  // stream we are recreating) as the codec level stream will either outlive the\n  // ActiveStream, or be alive in deferred deletion queue at this point.\n  if (stream.response_encoder_) {\n    stream.response_encoder_->getStream().removeCallbacks(stream);\n  }\n\n  if (connection_idle_timer_ && streams_.empty()) {\n    connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n  }\n}",
  "abstract_func_before": "void ConnectionManagerImpl::doDeferredStreamDestroy(ActiveStream& VAR_0) {\n  if (VAR_0.max_stream_duration_timer_ != nullptr) {\n    VAR_0.max_stream_duration_timer_->disableTimer();\n    VAR_0.max_stream_duration_timer_ = nullptr;\n  }\n  if (VAR_0.stream_idle_timer_ != nullptr) {\n    VAR_0.stream_idle_timer_->disableTimer();\n    VAR_0.stream_idle_timer_ = nullptr;\n  }\n  VAR_0.filter_manager_.disarmRequestTimeout();\n  if (VAR_0.request_header_timer_ != nullptr) {\n    VAR_0.request_header_timer_->disableTimer();\n    VAR_0.request_header_timer_ = nullptr;\n  }\n  if (VAR_0.access_log_flush_timer_ != nullptr) {\n    VAR_0.access_log_flush_timer_->disableTimer();\n    VAR_0.access_log_flush_timer_ = nullptr;\n  }\n\n  if (VAR_0.expand_agnostic_stream_lifetime_) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    if (!VAR_0.canDestroyStream()) {\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      VAR_0.state_.is_zombie_stream_ = true;\n      return;\n    }\n\n    if (VAR_0.response_encoder_ != nullptr) {\n      VAR_0.response_encoder_->getStream().registerCodecEventCallbacks(nullptr);\n    }\n  }\n\n  VAR_0.completeRequest();\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  if (VAR_1) {\n    /* COMMENT_6 */\n    absl::optional<std::chrono::milliseconds> VAR_2 = VAR_3->connection().lastRoundTripTime();\n    if (VAR_2.has_value()) {\n      VAR_3->connection().connectionInfoSetter().setRoundTripTime(VAR_2.value());\n    }\n  }\n\n  VAR_0.filter_manager_.onStreamComplete();\n\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (VAR_4 && VAR_4->protocol() == Protocol::Http3 &&\n      /* COMMENT_9 */\n      !VAR_0.filter_manager_.sawDownstreamReset() &&\n      /* COMMENT_10 */\n      VAR_0.response_encoder_ != nullptr &&\n      Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.quic_defer_logging_to_ack_listener\")) {\n    VAR_0.deferHeadersAndTrailers();\n  } else {\n    /* COMMENT_11 */\n    VAR_0.filter_manager_.log(AccessLog::AccessLogType::DownstreamEnd);\n  }\n\n  VAR_0.filter_manager_.destroyFilters();\n\n  VAR_5->deferredDelete(VAR_0.removeFromList(VAR_6));\n\n  /* COMMENT_12 */\n  /* COMMENT_13 */\n  /* COMMENT_14 */\n  if (VAR_0.response_encoder_) {\n    VAR_0.response_encoder_->getStream().removeCallbacks(VAR_0);\n  }\n\n  if (VAR_7 && VAR_6.empty()) {\n    VAR_7->enableTimer(VAR_8.idleTimeout().value());\n  }\n}",
  "func_graph_path_before": "envoyproxy/envoy/6f8a69e5023eba51bfaeec6d551a5b9840e8c6d1/conn_manager_impl.cc/vul/before/0.json",
  "func": "void ConnectionManagerImpl::doDeferredStreamDestroy(ActiveStream& stream) {\n  if (!stream.state_.is_internally_destroyed_) {\n    ++closed_non_internally_destroyed_requests_;\n    if (isPrematureRstStream(stream)) {\n      ++number_premature_stream_resets_;\n    }\n  }\n  if (stream.max_stream_duration_timer_ != nullptr) {\n    stream.max_stream_duration_timer_->disableTimer();\n    stream.max_stream_duration_timer_ = nullptr;\n  }\n  if (stream.stream_idle_timer_ != nullptr) {\n    stream.stream_idle_timer_->disableTimer();\n    stream.stream_idle_timer_ = nullptr;\n  }\n  stream.filter_manager_.disarmRequestTimeout();\n  if (stream.request_header_timer_ != nullptr) {\n    stream.request_header_timer_->disableTimer();\n    stream.request_header_timer_ = nullptr;\n  }\n  if (stream.access_log_flush_timer_ != nullptr) {\n    stream.access_log_flush_timer_->disableTimer();\n    stream.access_log_flush_timer_ = nullptr;\n  }\n\n  if (stream.expand_agnostic_stream_lifetime_) {\n    // Only destroy the active stream if the underlying codec has notified us of\n    // completion or we've internal redirect the stream.\n    if (!stream.canDestroyStream()) {\n      // Track that this stream is not expecting any additional calls apart from\n      // codec notification.\n      stream.state_.is_zombie_stream_ = true;\n      return;\n    }\n\n    if (stream.response_encoder_ != nullptr) {\n      stream.response_encoder_->getStream().registerCodecEventCallbacks(nullptr);\n    }\n  }\n\n  stream.completeRequest();\n\n  // If refresh rtt after request is required explicitly, then try to get rtt again set it into\n  // connection info.\n  if (refresh_rtt_after_request_) {\n    // Set roundtrip time in connectionInfoSetter before OnStreamComplete\n    absl::optional<std::chrono::milliseconds> t = read_callbacks_->connection().lastRoundTripTime();\n    if (t.has_value()) {\n      read_callbacks_->connection().connectionInfoSetter().setRoundTripTime(t.value());\n    }\n  }\n\n  stream.filter_manager_.onStreamComplete();\n\n  // For HTTP/3, skip access logging here and add deferred logging info\n  // to stream info for QuicStatsGatherer to use later.\n  if (codec_ && codec_->protocol() == Protocol::Http3 &&\n      // There was a downstream reset, log immediately.\n      !stream.filter_manager_.sawDownstreamReset() &&\n      // On recreate stream, log immediately.\n      stream.response_encoder_ != nullptr &&\n      Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.quic_defer_logging_to_ack_listener\")) {\n    stream.deferHeadersAndTrailers();\n  } else {\n    // For HTTP/1 and HTTP/2, log here as usual.\n    stream.filter_manager_.log(AccessLog::AccessLogType::DownstreamEnd);\n  }\n\n  stream.filter_manager_.destroyFilters();\n\n  dispatcher_->deferredDelete(stream.removeFromList(streams_));\n\n  // The response_encoder should never be dangling (unless we're destroying a\n  // stream we are recreating) as the codec level stream will either outlive the\n  // ActiveStream, or be alive in deferred deletion queue at this point.\n  if (stream.response_encoder_) {\n    stream.response_encoder_->getStream().removeCallbacks(stream);\n  }\n\n  if (connection_idle_timer_ && streams_.empty()) {\n    connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n  }\n  maybeDrainDueToPrematureResets();\n}",
  "abstract_func": "void ConnectionManagerImpl::doDeferredStreamDestroy(ActiveStream& VAR_0) {\n  if (!VAR_0.state_.is_internally_destroyed_) {\n    ++VAR_1;\n    if (isPrematureRstStream(VAR_0)) {\n      ++VAR_2;\n    }\n  }\n  if (VAR_0.max_stream_duration_timer_ != nullptr) {\n    VAR_0.max_stream_duration_timer_->disableTimer();\n    VAR_0.max_stream_duration_timer_ = nullptr;\n  }\n  if (VAR_0.stream_idle_timer_ != nullptr) {\n    VAR_0.stream_idle_timer_->disableTimer();\n    VAR_0.stream_idle_timer_ = nullptr;\n  }\n  VAR_0.filter_manager_.disarmRequestTimeout();\n  if (VAR_0.request_header_timer_ != nullptr) {\n    VAR_0.request_header_timer_->disableTimer();\n    VAR_0.request_header_timer_ = nullptr;\n  }\n  if (VAR_0.access_log_flush_timer_ != nullptr) {\n    VAR_0.access_log_flush_timer_->disableTimer();\n    VAR_0.access_log_flush_timer_ = nullptr;\n  }\n\n  if (VAR_0.expand_agnostic_stream_lifetime_) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    if (!VAR_0.canDestroyStream()) {\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      VAR_0.state_.is_zombie_stream_ = true;\n      return;\n    }\n\n    if (VAR_0.response_encoder_ != nullptr) {\n      VAR_0.response_encoder_->getStream().registerCodecEventCallbacks(nullptr);\n    }\n  }\n\n  VAR_0.completeRequest();\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  if (VAR_3) {\n    /* COMMENT_6 */\n    absl::optional<std::chrono::milliseconds> VAR_4 = VAR_5->connection().lastRoundTripTime();\n    if (VAR_4.has_value()) {\n      VAR_5->connection().connectionInfoSetter().setRoundTripTime(VAR_4.value());\n    }\n  }\n\n  VAR_0.filter_manager_.onStreamComplete();\n\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (VAR_6 && VAR_6->protocol() == Protocol::Http3 &&\n      /* COMMENT_9 */\n      !VAR_0.filter_manager_.sawDownstreamReset() &&\n      /* COMMENT_10 */\n      VAR_0.response_encoder_ != nullptr &&\n      Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.quic_defer_logging_to_ack_listener\")) {\n    VAR_0.deferHeadersAndTrailers();\n  } else {\n    /* COMMENT_11 */\n    VAR_0.filter_manager_.log(AccessLog::AccessLogType::DownstreamEnd);\n  }\n\n  VAR_0.filter_manager_.destroyFilters();\n\n  VAR_7->deferredDelete(VAR_0.removeFromList(VAR_8));\n\n  /* COMMENT_12 */\n  /* COMMENT_13 */\n  /* COMMENT_14 */\n  if (VAR_0.response_encoder_) {\n    VAR_0.response_encoder_->getStream().removeCallbacks(VAR_0);\n  }\n\n  if (VAR_9 && VAR_8.empty()) {\n    VAR_9->enableTimer(VAR_10.idleTimeout().value());\n  }\n  maybeDrainDueToPrematureResets();\n}",
  "func_graph_path": "envoyproxy/envoy/6f8a69e5023eba51bfaeec6d551a5b9840e8c6d1/conn_manager_impl.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,10 @@\n void ConnectionManagerImpl::doDeferredStreamDestroy(ActiveStream& stream) {\n+  if (!stream.state_.is_internally_destroyed_) {\n+    ++closed_non_internally_destroyed_requests_;\n+    if (isPrematureRstStream(stream)) {\n+      ++number_premature_stream_resets_;\n+    }\n+  }\n   if (stream.max_stream_duration_timer_ != nullptr) {\n     stream.max_stream_duration_timer_->disableTimer();\n     stream.max_stream_duration_timer_ = nullptr;\n@@ -75,4 +81,5 @@\n   if (connection_idle_timer_ && streams_.empty()) {\n     connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n   }\n+  maybeDrainDueToPrematureResets();\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  if (!stream.state_.is_internally_destroyed_) {",
      "    ++closed_non_internally_destroyed_requests_;",
      "    if (isPrematureRstStream(stream)) {",
      "      ++number_premature_stream_resets_;",
      "    }",
      "  }",
      "  maybeDrainDueToPrematureResets();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/30055",
  "description": {
    "pr_info": {
      "title": "http: Fix CVE CVE-2023-44487",
      "number": 30055
    },
    "comment": [
      "<!--\r\n!!!ATTENTION!!!\r\n\r\nIf you are fixing *any* crash or *any* potential security issue, *do not*\r\nopen a pull request in this repo. Please report the issue via emailing\r\nenvoy-security@googlegroups.com where the issue will be triaged appropriately.\r\nThank you in advance for helping to keep Envoy secure.\r\n\r\n!!!ATTENTION!!!\r\n\r\nFor an explanation of how to fill out the fields, please see the relevant section\r\nin [PULL_REQUESTS.md](https://github.com/envoyproxy/envoy/blob/main/PULL_REQUESTS.md)\r\n-->\r\n\r\nCommit Message:\r\nAdditional Description:\r\nRisk Level:\r\nTesting:\r\nDocs Changes:\r\nRelease Notes:\r\nPlatform Specific Features:\r\n[Optional Runtime guard:]\r\n[Optional Fixes #Issue]\r\n[Optional Fixes commit #PR or SHA]\r\n[Optional Deprecated:]\r\n[Optional [API Considerations](https://github.com/envoyproxy/envoy/blob/main/api/review_checklist.md):]\r\n",
      "CC @envoyproxy/runtime-guard-changes: FYI only for changes made to `(source/common/runtime/runtime_features.cc)`.\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: https://github.com/envoyproxy/envoy/pull/30055 was opened by phlax.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/30055), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/ae59df20-6764-11ee-8d82-8654fbd73ccb).\n</details>",
      "should we document the stats in `docs/root/configuration/http/http_conn_man/stats.rst`? I need to blame to find this commit to get more sense on `http.downstream_rq_too_many_premature_resets`",
      "Hi,\r\n\r\nI'm trying to analyze the impact from our users perspective what these new parameters are introducing for them.\r\n\r\n`overload.premature_reset_min_stream_lifetime_seconds` and `overload.premature_reset_total_stream_count` as I understood are for identifying that rapid reset attack is happening. Or if not the actual attack then some misbehavior of client. [Rapid reset](https://github.com/envoyproxy/envoy/security/advisories/GHSA-jhv4-f7mr-xx76)\r\n\r\nAnd `http.max_requests_per_io_cycle` is to help serving requests that are not related to the attack.\r\n\r\nBut in practice what does this mean:\r\n - If we set http.max_requests_per_io_cycle to 1 than Envoy will switch between TCP sockets after it processes 1 request in each?\r\n - Is this switch expected to be costly CPU wise?\r\n - how does Envoy work without setting these parameters? \r\n\r\nAlso I couldn't find definition in your repo on what I/O cycle means for you. Can you please explain?\r\n\r\nThanks in advance!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}