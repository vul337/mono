{
  "cve_id": "CVE-2022-44262",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "ff4j",
  "commit_msg": "fix: Add assignable check to PropertiesParser, YamlParser and XmlParser (#624)",
  "commit_hash": "e915c026aef46b502934cb05a825ea2ea15eb9e6",
  "git_url": "https://github.com/ff4j/ff4j/commit/e915c026aef46b502934cb05a825ea2ea15eb9e6",
  "file_path": "ff4j-config-properties/src/main/java/org/ff4j/parser/properties/PropertiesParser.java",
  "func_name": "parseProperties",
  "func_before": "private Map < String, Property<?>> parseProperties(String prefix, Map<String, String> mapConfigProperties) {\n        Map < String, Property<?>> result = new HashMap<>();\n        int idx = 0;\n        String currentPropertyKey = prefix  + \".\" + idx;\n        while (mapConfigProperties.containsKey(currentPropertyKey +  \".\" + PROPERTY_PARAMNAME)) {\n            \n            assertKeyNotEmpty(mapConfigProperties, currentPropertyKey +  \".\" + PROPERTY_PARAMNAME);\n            String name     = mapConfigProperties.get(currentPropertyKey +  \".\" + PROPERTY_PARAMNAME);\n            \n            assertKeyNotEmpty(mapConfigProperties, currentPropertyKey +  \".\" + PROPERTY_PARAMVALUE);\n            String strValue = mapConfigProperties.get(currentPropertyKey +  \".\" + PROPERTY_PARAMVALUE);\n            \n            Property<?> ap      = new PropertyString(name, strValue);\n            String optionalType = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMTYPE);\n            // If specific type defined ?\n            if (null != optionalType) {\n                // Substitution if relevant (e.g. 'int' -> 'org.ff4j.property.PropertyInt')\n                optionalType = MappingUtil.mapPropertyType(optionalType);\n                try {\n                    // Constructor (String, String) is mandatory in Property interface\n                    Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\n                    ap = (Property<?>) constr.newInstance(name, strValue);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);\n                }\n            }\n            // Description\n            String description = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMDESCRIPTION);\n            if (null != description) {\n                ap.setDescription(description);\n            } \n            // Fixed Values\n            String strFixedValues = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMFIXED_VALUES);\n            if (null != strFixedValues && !\"\".equals(strFixedValues)) {\n                Arrays.asList(strValue.split(\",\"))\n                      .stream()\n                      .map(String::trim)\n                      .forEach(ap::add2FixedValueFromString);\n            }\n          \n            // Check fixed value\n            if (ap.getFixedValues() != null &&  \n               !ap.getFixedValues().isEmpty() && \n               !ap.getFixedValues().contains(ap.getValue())) {\n                throw new IllegalArgumentException(\"Cannot create property <\" + ap.getName() + \n                        \"> invalid value <\" + ap.getValue() + \n                        \"> expected one of \" + ap.getFixedValues());\n            }\n            result.put(ap.getName(), ap);\n            // ff4j.properties.X\n            currentPropertyKey = prefix + \".\" + ++idx;\n        }\n        return result;\n    }",
  "abstract_func_before": "private Map < String, Property<?>> parseProperties(String VAR_0, Map<String, String> VAR_1) {\n        Map < String, Property<?>> VAR_2 = new HashMap<>();\n        int VAR_3 = 0;\n        String VAR_4 = VAR_0  + \".\" + VAR_3;\n        while (VAR_1.containsKey(VAR_4 +  \".\" + VAR_5)) {\n            \n            assertKeyNotEmpty(VAR_1, VAR_4 +  \".\" + VAR_5);\n            String VAR_6     = VAR_1.get(VAR_4 +  \".\" + VAR_5);\n            \n            assertKeyNotEmpty(VAR_1, VAR_4 +  \".\" + VAR_7);\n            String VAR_8 = VAR_1.get(VAR_4 +  \".\" + VAR_7);\n            \n            Property<?> VAR_9      = new PropertyString(VAR_6, VAR_8);\n            String VAR_10 = VAR_1.get(VAR_4 + \".\" + VAR_11);\n            /* COMMENT_0 */\n            if (null != VAR_10) {\n                /* COMMENT_1 */\n                VAR_10 = VAR_12.mapPropertyType(VAR_10);\n                try {\n                    /* COMMENT_2 */\n                    Constructor<?> VAR_13 = VAR_14.forName(VAR_10).getConstructor(String.class, String.class);\n                    VAR_9 = (Property<?>) VAR_13.newInstance(VAR_6, VAR_8);\n                } catch (Exception VAR_15) {\n                    throw new IllegalArgumentException(\"Cannot instantiate '\" + VAR_10 + \"' check default constructor\", VAR_15);\n                }\n            }\n            /* COMMENT_3 */\n            String VAR_16 = VAR_1.get(VAR_4 + \".\" + VAR_17);\n            if (null != VAR_16) {\n                VAR_9.setDescription(VAR_16);\n            } \n            /* COMMENT_4 */\n            String VAR_18 = VAR_1.get(VAR_4 + \".\" + VAR_19);\n            if (null != VAR_18 && !\"\".equals(VAR_18)) {\n                VAR_20.asList(VAR_8.split(\",\"))\n                      .stream()\n                      .map(VAR_21::VAR_22)\n                      .forEach(VAR_9::VAR_23);\n            }\n          \n            /* COMMENT_5 */\n            if (VAR_9.getFixedValues() != null &&  \n               !VAR_9.getFixedValues().isEmpty() && \n               !VAR_9.getFixedValues().contains(VAR_9.getValue())) {\n                throw new IllegalArgumentException(\"Cannot create property <\" + VAR_9.getName() + \n                        \"> invalid value <\" + VAR_9.getValue() + \n                        \"> expected one of \" + VAR_9.getFixedValues());\n            }\n            VAR_2.put(VAR_9.getName(), VAR_9);\n            /* COMMENT_6 */\n            VAR_4 = VAR_0 + \".\" + ++VAR_3;\n        }\n        return VAR_2;\n    }",
  "func_graph_path_before": "ff4j/e915c026aef46b502934cb05a825ea2ea15eb9e6/PropertiesParser.java/vul/before/0.json",
  "func": "private Map < String, Property<?>> parseProperties(String prefix, Map<String, String> mapConfigProperties) {\n        Map < String, Property<?>> result = new HashMap<>();\n        int idx = 0;\n        String currentPropertyKey = prefix  + \".\" + idx;\n        while (mapConfigProperties.containsKey(currentPropertyKey +  \".\" + PROPERTY_PARAMNAME)) {\n            \n            assertKeyNotEmpty(mapConfigProperties, currentPropertyKey +  \".\" + PROPERTY_PARAMNAME);\n            String name     = mapConfigProperties.get(currentPropertyKey +  \".\" + PROPERTY_PARAMNAME);\n            \n            assertKeyNotEmpty(mapConfigProperties, currentPropertyKey +  \".\" + PROPERTY_PARAMVALUE);\n            String strValue = mapConfigProperties.get(currentPropertyKey +  \".\" + PROPERTY_PARAMVALUE);\n            \n            Property<?> ap      = new PropertyString(name, strValue);\n            String optionalType = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMTYPE);\n            // If specific type defined ?\n            if (null != optionalType) {\n                // Substitution if relevant (e.g. 'int' -> 'org.ff4j.property.PropertyInt')\n                optionalType = MappingUtil.mapPropertyType(optionalType);\n                try {\n                    // Constructor (String, String) is mandatory in Property interface\n                    Class<?> typeClass = Class.forName(optionalType);\n                    if (!Property.class.isAssignableFrom(typeClass)) {\n                        throw new IllegalArgumentException(\"Cannot create property <\" + name + \"> invalid type <\" + optionalType + \">\");\n                    }\n                    Constructor<?> constr = typeClass.getConstructor(String.class, String.class);\n                    ap = (Property<?>) constr.newInstance(name, strValue);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);\n                }\n            }\n            // Description\n            String description = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMDESCRIPTION);\n            if (null != description) {\n                ap.setDescription(description);\n            } \n            // Fixed Values\n            String strFixedValues = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMFIXED_VALUES);\n            if (null != strFixedValues && !\"\".equals(strFixedValues)) {\n                Arrays.asList(strValue.split(\",\"))\n                      .stream()\n                      .map(String::trim)\n                      .forEach(ap::add2FixedValueFromString);\n            }\n          \n            // Check fixed value\n            if (ap.getFixedValues() != null &&  \n               !ap.getFixedValues().isEmpty() && \n               !ap.getFixedValues().contains(ap.getValue())) {\n                throw new IllegalArgumentException(\"Cannot create property <\" + ap.getName() + \n                        \"> invalid value <\" + ap.getValue() + \n                        \"> expected one of \" + ap.getFixedValues());\n            }\n            result.put(ap.getName(), ap);\n            // ff4j.properties.X\n            currentPropertyKey = prefix + \".\" + ++idx;\n        }\n        return result;\n    }",
  "abstract_func": "private Map < String, Property<?>> parseProperties(String VAR_0, Map<String, String> VAR_1) {\n        Map < String, Property<?>> VAR_2 = new HashMap<>();\n        int VAR_3 = 0;\n        String VAR_4 = VAR_0  + \".\" + VAR_3;\n        while (VAR_1.containsKey(VAR_4 +  \".\" + VAR_5)) {\n            \n            assertKeyNotEmpty(VAR_1, VAR_4 +  \".\" + VAR_5);\n            String VAR_6     = VAR_1.get(VAR_4 +  \".\" + VAR_5);\n            \n            assertKeyNotEmpty(VAR_1, VAR_4 +  \".\" + VAR_7);\n            String VAR_8 = VAR_1.get(VAR_4 +  \".\" + VAR_7);\n            \n            Property<?> VAR_9      = new PropertyString(VAR_6, VAR_8);\n            String VAR_10 = VAR_1.get(VAR_4 + \".\" + VAR_11);\n            /* COMMENT_0 */\n            if (null != VAR_10) {\n                /* COMMENT_1 */\n                VAR_10 = VAR_12.mapPropertyType(VAR_10);\n                try {\n                    /* COMMENT_2 */\n                    Class<?> VAR_13 = VAR_14.forName(VAR_10);\n                    if (!Property.class.isAssignableFrom(VAR_13)) {\n                        throw new IllegalArgumentException(\"Cannot create property <\" + VAR_6 + \"> invalid type <\" + VAR_10 + \">\");\n                    }\n                    Constructor<?> VAR_15 = VAR_13.getConstructor(String.class, String.class);\n                    VAR_9 = (Property<?>) VAR_15.newInstance(VAR_6, VAR_8);\n                } catch (Exception VAR_16) {\n                    throw new IllegalArgumentException(\"Cannot instantiate '\" + VAR_10 + \"' check default constructor\", VAR_16);\n                }\n            }\n            /* COMMENT_3 */\n            String VAR_17 = VAR_1.get(VAR_4 + \".\" + VAR_18);\n            if (null != VAR_17) {\n                VAR_9.setDescription(VAR_17);\n            } \n            /* COMMENT_4 */\n            String VAR_19 = VAR_1.get(VAR_4 + \".\" + VAR_20);\n            if (null != VAR_19 && !\"\".equals(VAR_19)) {\n                VAR_21.asList(VAR_8.split(\",\"))\n                      .stream()\n                      .map(VAR_22::VAR_23)\n                      .forEach(VAR_9::VAR_24);\n            }\n          \n            /* COMMENT_5 */\n            if (VAR_9.getFixedValues() != null &&  \n               !VAR_9.getFixedValues().isEmpty() && \n               !VAR_9.getFixedValues().contains(VAR_9.getValue())) {\n                throw new IllegalArgumentException(\"Cannot create property <\" + VAR_9.getName() + \n                        \"> invalid value <\" + VAR_9.getValue() + \n                        \"> expected one of \" + VAR_9.getFixedValues());\n            }\n            VAR_2.put(VAR_9.getName(), VAR_9);\n            /* COMMENT_6 */\n            VAR_4 = VAR_0 + \".\" + ++VAR_3;\n        }\n        return VAR_2;\n    }",
  "func_graph_path": "ff4j/e915c026aef46b502934cb05a825ea2ea15eb9e6/PropertiesParser.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,11 @@\n                 optionalType = MappingUtil.mapPropertyType(optionalType);\n                 try {\n                     // Constructor (String, String) is mandatory in Property interface\n-                    Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\n+                    Class<?> typeClass = Class.forName(optionalType);\n+                    if (!Property.class.isAssignableFrom(typeClass)) {\n+                        throw new IllegalArgumentException(\"Cannot create property <\" + name + \"> invalid type <\" + optionalType + \">\");\n+                    }\n+                    Constructor<?> constr = typeClass.getConstructor(String.class, String.class);\n                     ap = (Property<?>) constr.newInstance(name, strValue);\n                 } catch (Exception e) {\n                     throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);",
  "diff_line_info": {
    "deleted_lines": [
      "                    Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);"
    ],
    "added_lines": [
      "                    Class<?> typeClass = Class.forName(optionalType);",
      "                    if (!Property.class.isAssignableFrom(typeClass)) {",
      "                        throw new IllegalArgumentException(\"Cannot create property <\" + name + \"> invalid type <\" + optionalType + \">\");",
      "                    }",
      "                    Constructor<?> constr = typeClass.getConstructor(String.class, String.class);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ff4j/ff4j/pull/625",
  "description": {
    "pr_info": {
      "title": "fix: CVE-2022-44262 (#624)",
      "number": 625
    },
    "comment": [
      "Fixes #624 \r\n\r\nThis asserts that the Property being constructed extends `org.ff4j.property.Property`\r\n\r\n```\r\nConstructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\r\nap = (Property<?>) constr.newInstance(name, strValue);\r\n```\r\n\r\nThis seems to be what is happening in the above code:\r\n\r\n1.`Class.forName(optionalType)` retrieves the target class\r\n2. `.getConstructor(String.class, String.class)` finds a constructor on the target class that accepts two String parameters\r\n3. `constr.newInstance(name, strValue)` constructs the instance (where the side effect happens)\r\n4. `(Property<?>)` type casts the new instance of the class. This throws an IllegalArgumentException, but the instance has been created already.",
      "the RCE is present in different points of the FF4j project.\r\nAll inputs must be validated with the proper \"isAssignableFrom\" method before executing \"newInstance\" of Class.forName(\"someinputstring\")\r\nThis applies to both property and strategy parsing/creating.\r\n\r\nExamples: \r\nff4j-core:\r\norg.ff4j.utils.MappingUtil line 183\r\norg.ff4j.conf.XmlParser line 387\r\n\r\nff4j-config-yaml:\r\norg.ff4j.parser.yaml.YamlParser line 175\r\n\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch introduces a security check to prevent the instantiation of unauthorized classes, which mitigates a potential exploit. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}