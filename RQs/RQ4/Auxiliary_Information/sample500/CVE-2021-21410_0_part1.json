{
  "cve_id": "CVE-2021-21410",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "contiki-ng",
  "commit_msg": "Avoid passing the packet to the upper layer if the IPHC decompression failed.",
  "commit_hash": "971354a39e46abfb3ea8f3fe542f53a7c6b17dd1",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/971354a39e46abfb3ea8f3fe542f53a7c6b17dd1",
  "file_path": "os/net/ipv6/sicslowpan.c",
  "func_name": "input",
  "func_before": "static void\ninput(void)\n{\n  /* size of the IP packet (read from fragment) */\n  uint16_t frag_size = 0;\n  /* offset of the fragment in the IP packet */\n  uint8_t frag_offset = 0;\n  uint8_t *buffer;\n  uint16_t buffer_size;\n\n#if SICSLOWPAN_CONF_FRAG\n  uint8_t is_fragment = 0;\n  int8_t frag_context = 0;\n\n  /* tag of the fragment */\n  uint16_t frag_tag = 0;\n  uint8_t first_fragment = 0, last_fragment = 0;\n#endif /*SICSLOWPAN_CONF_FRAG*/\n\n  /* Update link statistics */\n  link_stats_input_callback(packetbuf_addr(PACKETBUF_ADDR_SENDER));\n\n  /* init */\n  uncomp_hdr_len = 0;\n  packetbuf_hdr_len = 0;\n\n  /* The MAC puts the 15.4 payload inside the packetbuf data buffer */\n  packetbuf_ptr = packetbuf_dataptr();\n\n  if(packetbuf_datalen() == 0) {\n    LOG_WARN(\"input: empty packet\\n\");\n    return;\n  }\n\n  /* Clear uipbuf and set default attributes */\n  uipbuf_clear();\n\n  /* This is default uip_buf since we assume that this is not fragmented */\n  buffer = (uint8_t *)UIP_IP_BUF;\n  buffer_size = UIP_BUFSIZE;\n\n  /* Save the RSSI of the incoming packet in case the upper layer will\n     want to query us for it later. */\n  last_rssi = (signed short)packetbuf_attr(PACKETBUF_ATTR_RSSI);\n\n#if SICSLOWPAN_CONF_FRAG\n\n  /*\n   * Since we don't support the mesh and broadcast header, the first header\n   * we look for is the fragmentation header\n   */\n  switch((GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) >> 8) & SICSLOWPAN_DISPATCH_FRAG_MASK) {\n    case SICSLOWPAN_DISPATCH_FRAG1:\n      frag_offset = 0;\n      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;\n      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);\n      packetbuf_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;\n      first_fragment = 1;\n      is_fragment = 1;\n\n      LOG_INFO(\"input: received first element of a fragmented packet (tag %d, len %d)\\n\",\n             frag_tag, frag_size);\n\n      /* Add the fragment to the fragmentation context */\n      frag_context = add_fragment(frag_tag, frag_size, frag_offset);\n\n      if(frag_context == -1) {\n        LOG_ERR(\"input: failed to allocate new reassembly context\\n\");\n        return;\n      }\n\n      buffer = frag_info[frag_context].first_frag;\n      buffer_size = SICSLOWPAN_FIRST_FRAGMENT_SIZE;\n      break;\n    case SICSLOWPAN_DISPATCH_FRAGN:\n      /*\n       * set offset, tag, size\n       * Offset is in units of 8 bytes\n       */\n      frag_offset = PACKETBUF_FRAG_PTR[PACKETBUF_FRAG_OFFSET];\n      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);\n      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;\n      packetbuf_hdr_len += SICSLOWPAN_FRAGN_HDR_LEN;\n\n      /* Add the fragment to the fragmentation context (this will also\n         copy the payload) */\n      frag_context = add_fragment(frag_tag, frag_size, frag_offset);\n\n      if(frag_context == -1) {\n        LOG_ERR(\"input: reassembly context not found (tag %d)\\n\", frag_tag);\n        return;\n      }\n\n      /* Ok - add_fragment will store the fragment automatically - so\n         we should not store more */\n      buffer = NULL;\n\n      if(frag_info[frag_context].reassembled_len >= frag_size) {\n        last_fragment = 1;\n      }\n      is_fragment = 1;\n      break;\n    default:\n      break;\n  }\n\n  if(is_fragment && !first_fragment) {\n    /* this is a FRAGN, skip the header compression dispatch section */\n    goto copypayload;\n  }\n#endif /* SICSLOWPAN_CONF_FRAG */\n\n  /* First, process 6LoRH headers */\n  curr_page = 0;\n  digest_paging_dispatch();\n  if(curr_page == 1) {\n    LOG_INFO(\"input: page 1, 6LoRH\\n\");\n    digest_6lorh_hdr();\n  } else if (curr_page > 1) {\n    LOG_ERR(\"input: page %u not supported\\n\", curr_page);\n    return;\n  }\n\n  /* Process next dispatch and headers */\n  if(SICSLOWPAN_COMPRESSION > SICSLOWPAN_COMPRESSION_IPV6 &&\n     (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {\n    LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n    uncompress_hdr_iphc(buffer, buffer_size, frag_size);\n  } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] == SICSLOWPAN_DISPATCH_IPV6) {\n    LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n    packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;\n\n    /* Put uncompressed IP header in sicslowpan_buf. */\n    memcpy(buffer, packetbuf_ptr + packetbuf_hdr_len, UIP_IPH_LEN);\n\n    /* Update uncomp_hdr_len and packetbuf_hdr_len. */\n    packetbuf_hdr_len += UIP_IPH_LEN;\n    uncomp_hdr_len += UIP_IPH_LEN;\n  } else {\n    LOG_ERR(\"uncompression: unknown dispatch: 0x%02x, or IPHC disabled\\n\",\n             PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK);\n    return;\n  }\n\n#if SICSLOWPAN_CONF_FRAG\n copypayload:\n#endif /*SICSLOWPAN_CONF_FRAG*/\n  /*\n   * copy \"payload\" from the packetbuf buffer to the sicslowpan_buf\n   * if this is a first fragment or not fragmented packet,\n   * we have already copied the compressed headers, uncomp_hdr_len\n   * and packetbuf_hdr_len are non 0, frag_offset is.\n   * If this is a subsequent fragment, this is the contrary.\n   */\n  if(packetbuf_datalen() < packetbuf_hdr_len) {\n    LOG_ERR(\"input: packet dropped due to header > total packet\\n\");\n    return;\n  }\n  packetbuf_payload_len = packetbuf_datalen() - packetbuf_hdr_len;\n\n#if SICSLOWPAN_CONF_FRAG\n  if(is_fragment) {\n    LOG_INFO(\"input: fragment (tag %d, payload %d, offset %d) -- %u %u\\n\",\n         frag_tag, packetbuf_payload_len, frag_offset << 3, packetbuf_datalen(), packetbuf_hdr_len);\n  }\n#endif /*SICSLOWPAN_CONF_FRAG*/\n\n  /* Sanity-check size of incoming packet to avoid buffer overflow */\n  {\n    int req_size = uncomp_hdr_len + (uint16_t)(frag_offset << 3)\n        + packetbuf_payload_len;\n    if(req_size > sizeof(uip_buf)) {\n#if SICSLOWPAN_CONF_FRAG\n      LOG_ERR(\n          \"input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\\n\",\n          frag_context,\n          uncomp_hdr_len, (uint16_t)(frag_offset << 3),\n          packetbuf_payload_len, req_size, (unsigned)sizeof(uip_buf));\n      /* Discard all fragments for this contex, as reassembling this particular fragment would\n       * cause an overflow in uipbuf */\n      clear_fragments(frag_context);\n#endif /* SICSLOWPAN_CONF_FRAG */\n      return;\n    }\n  }\n\n  /* copy the payload if buffer is non-null - which is only the case with first fragment\n     or packets that are non fragmented */\n  if(buffer != NULL) {\n    memcpy((uint8_t *)buffer + uncomp_hdr_len, packetbuf_ptr + packetbuf_hdr_len, packetbuf_payload_len);\n  }\n\n  /* update processed_ip_in_len if fragment, sicslowpan_len otherwise */\n\n#if SICSLOWPAN_CONF_FRAG\n  if(frag_size > 0) {\n    /* Add the size of the header only for the first fragment. */\n    if(first_fragment != 0) {\n      frag_info[frag_context].reassembled_len = uncomp_hdr_len + packetbuf_payload_len;\n      frag_info[frag_context].first_frag_len = uncomp_hdr_len + packetbuf_payload_len;\n    }\n    /* For the last fragment, we are OK if there is extrenous bytes at\n       the end of the packet. */\n    if(last_fragment != 0) {\n      frag_info[frag_context].reassembled_len = frag_size;\n      /* copy to uip */\n      if(!copy_frags2uip(frag_context)) {\n        return;\n      }\n    }\n  }\n\n  /*\n   * If we have a full IP packet in sicslowpan_buf, deliver it to\n   * the IP stack\n   */\n  if(!is_fragment || last_fragment) {\n    /* packet is in uip already - just set length */\n    if(is_fragment != 0 && last_fragment != 0) {\n      uip_len = frag_size;\n    } else {\n      uip_len = packetbuf_payload_len + uncomp_hdr_len;\n    }\n#else\n    uip_len = packetbuf_payload_len + uncomp_hdr_len;\n#endif /* SICSLOWPAN_CONF_FRAG */\n    LOG_INFO(\"input: received IPv6 packet with len %d\\n\",\n             uip_len);\n\n    if(LOG_DBG_ENABLED) {\n      uint16_t ndx;\n      LOG_DBG(\"uncompression: after (%u):\", UIP_IP_BUF->len[1]);\n      for (ndx = 0; ndx < UIP_IP_BUF->len[1] + 40; ndx++) {\n        uint8_t data = ((uint8_t *) (UIP_IP_BUF))[ndx];\n        LOG_DBG_(\"%02x\", data);\n      }\n      LOG_DBG_(\"\\n\");\n    }\n\n    /* if callback is set then set attributes and call */\n    if(callback) {\n      set_packet_attrs();\n      callback->input_callback();\n    }\n\n#if LLSEC802154_USES_AUX_HEADER\n    /*\n     * Assuming that the last packet in packetbuf is containing\n     *  the LLSEC state so that it can be copied to uipbuf.\n     */\n    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_LEVEL,\n      packetbuf_attr(PACKETBUF_ATTR_SECURITY_LEVEL));\n#if LLSEC802154_USES_EXPLICIT_KEYS\n    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_KEY_ID,\n      packetbuf_attr(PACKETBUF_ATTR_KEY_INDEX));\n#endif /* LLSEC802154_USES_EXPLICIT_KEYS */\n#endif /*  LLSEC802154_USES_AUX_HEADER */\n\n    tcpip_input();\n#if SICSLOWPAN_CONF_FRAG\n  }\n#endif /* SICSLOWPAN_CONF_FRAG */\n}",
  "abstract_func_before": "static void\ninput(void)\n{\n  /* COMMENT_0 */\n  uint16_t VAR_0 = 0;\n  /* COMMENT_1 */\n  uint8_t VAR_1 = 0;\n  uint8_t *VAR_2;\n  uint16_t VAR_3;\n\n#if VAR_4\n  uint8_t VAR_5 = 0;\n  int8_t VAR_6 = 0;\n\n  /* COMMENT_2 */\n  uint16_t VAR_7 = 0;\n  uint8_t VAR_8 = 0, VAR_9 = 0;\n#endif /* COMMENT_3 */\n\n  /* COMMENT_4 */\n  link_stats_input_callback(packetbuf_addr(VAR_10));\n\n  /* COMMENT_5 */\n  VAR_11 = 0;\n  VAR_12 = 0;\n\n  /* COMMENT_6 */\n  VAR_13 = packetbuf_dataptr();\n\n  if(packetbuf_datalen() == 0) {\n    LOG_WARN(\"input: empty packet\\n\");\n    return;\n  }\n\n  /* COMMENT_7 */\n  uipbuf_clear();\n\n  /* COMMENT_8 */\n  VAR_2 = (uint8_t *)VAR_14;\n  VAR_3 = VAR_15;\n\n  /* COMMENT_9 */\n                                      \n  VAR_16 = (signed short)packetbuf_attr(VAR_17);\n\n#if VAR_4\n\n  /* COMMENT_11 */\n                                                                           \n                                            \n     \n  switch((GET16(VAR_18, VAR_19) >> 8) & VAR_20) {\n    case VAR_21:\n      VAR_1 = 0;\n      VAR_0 = GET16(VAR_18, VAR_19) & 0x07ff;\n      VAR_7 = GET16(VAR_18, VAR_22);\n      VAR_12 += VAR_23;\n      VAR_8 = 1;\n      VAR_5 = 1;\n\n      LOG_INFO(\"input: received first element of a fragmented packet (tag %d, len %d)\\n\",\n             VAR_7, VAR_0);\n\n      /* COMMENT_15 */\n      VAR_6 = add_fragment(VAR_7, VAR_0, VAR_1);\n\n      if(VAR_6 == -1) {\n        LOG_ERR(\"input: failed to allocate new reassembly context\\n\");\n        return;\n      }\n\n      VAR_2 = VAR_24[VAR_6].first_frag;\n      VAR_3 = VAR_25;\n      break;\n    case VAR_26:\n      /* COMMENT_16 */\n                              \n                                      \n         \n      VAR_1 = VAR_18[VAR_27];\n      VAR_7 = GET16(VAR_18, VAR_22);\n      VAR_0 = GET16(VAR_18, VAR_19) & 0x07ff;\n      VAR_12 += VAR_28;\n\n      /* COMMENT_20 */\n                             \n      VAR_6 = add_fragment(VAR_7, VAR_0, VAR_1);\n\n      if(VAR_6 == -1) {\n        LOG_ERR(\"input: reassembly context not found (tag %d)\\n\", VAR_7);\n        return;\n      }\n\n      /* COMMENT_22 */\n                                    \n      VAR_2 = NULL;\n\n      if(VAR_24[VAR_6].reassembled_len >= VAR_0) {\n        VAR_9 = 1;\n      }\n      VAR_5 = 1;\n      break;\n    default:\n      break;\n  }\n\n  if(VAR_5 && !VAR_8) {\n    /* COMMENT_24 */\n    goto copypayload;\n  }\n#endif /* COMMENT_25 */\n\n  /* COMMENT_26 */\n  VAR_29 = 0;\n  digest_paging_dispatch();\n  if(VAR_29 == 1) {\n    LOG_INFO(\"input: page 1, 6LoRH\\n\");\n    digest_6lorh_hdr();\n  } else if (VAR_29 > 1) {\n    LOG_ERR(\"input: page %u not supported\\n\", VAR_29);\n    return;\n  }\n\n  /* COMMENT_27 */\n  if(VAR_30 > VAR_31 &&\n     (VAR_32[VAR_33] & VAR_34) == VAR_35) {\n    LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n    uncompress_hdr_iphc(VAR_2, VAR_3, VAR_0);\n  } else if(VAR_32[VAR_33] == VAR_36) {\n    LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n    VAR_12 += VAR_37;\n\n    /* COMMENT_28 */\n    memcpy(VAR_2, VAR_13 + VAR_12, VAR_38);\n\n    /* COMMENT_29 */\n    VAR_12 += VAR_38;\n    VAR_11 += VAR_38;\n  } else {\n    LOG_ERR(\"uncompression: unknown dispatch: 0x%02x, or IPHC disabled\\n\",\n             VAR_32[VAR_33] & VAR_34);\n    return;\n  }\n\n#if VAR_4\n copypayload:\n#endif /* COMMENT_3 */\n  /* COMMENT_30 */\n                                                                   \n                                                          \n                                                                  \n                                                     \n                                                            \n     \n  if(packetbuf_datalen() < VAR_12) {\n    LOG_ERR(\"input: packet dropped due to header > total packet\\n\");\n    return;\n  }\n  VAR_39 = packetbuf_datalen() - VAR_12;\n\n#if VAR_4\n  if(VAR_5) {\n    LOG_INFO(\"input: fragment (tag %d, payload %d, offset %d) -- %u %u\\n\",\n         VAR_7, VAR_39, VAR_1 << 3, packetbuf_datalen(), VAR_12);\n  }\n#endif /* COMMENT_3 */\n\n  /* COMMENT_37 */\n  {\n    int VAR_40 = VAR_11 + (uint16_t)(VAR_1 << 3)\n        + VAR_39;\n    if(VAR_40 > sizeof(VAR_41)) {\n#if VAR_4\n      LOG_ERR(\n          \"input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\\n\",\n          VAR_6,\n          VAR_11, (uint16_t)(VAR_1 << 3),\n          VAR_39, VAR_40, (unsigned)sizeof(VAR_41));\n      /* COMMENT_38 */\n                                       \n      clear_fragments(VAR_6);\n#endif /* COMMENT_25 */\n      return;\n    }\n  }\n\n  /* COMMENT_40 */\n                                          \n  if(VAR_2 != NULL) {\n    memcpy((uint8_t *)VAR_2 + VAR_11, VAR_13 + VAR_12, VAR_39);\n  }\n\n  /* COMMENT_42 */\n\n#if VAR_4\n  if(VAR_0 > 0) {\n    /* COMMENT_43 */\n    if(VAR_8 != 0) {\n      VAR_24[VAR_6].reassembled_len = VAR_11 + VAR_39;\n      VAR_24[VAR_6].first_frag_len = VAR_11 + VAR_39;\n    }\n    /* COMMENT_44 */\n                                \n    if(VAR_9 != 0) {\n      VAR_24[VAR_6].reassembled_len = VAR_0;\n      /* COMMENT_46 */\n      if(!copy_frags2uip(VAR_6)) {\n        return;\n      }\n    }\n  }\n\n  /* COMMENT_47 */\n                                                                 \n                 \n     \n  if(!VAR_5 || VAR_9) {\n    /* COMMENT_51 */\n    if(VAR_5 != 0 && VAR_9 != 0) {\n      VAR_42 = VAR_0;\n    } else {\n      VAR_42 = VAR_39 + VAR_11;\n    }\n#else\n    uip_len = packetbuf_payload_len + uncomp_hdr_len;\n#endif/* COMMENT_52 */\n    LOG_INFO(\"input: received IPv6 packet with len %d\\n\",\n             VAR_42);\n\n    if(VAR_43) {\n      uint16_t VAR_44;\n      LOG_DBG(\"uncompression: after (%u):\", VAR_14->len[1]);\n      for (VAR_44 = 0; VAR_44 < VAR_14->len[1] + 40; VAR_44++) {\n        uint8_t VAR_45 = ((uint8_t *) (VAR_14))[VAR_44];\n        LOG_DBG_(\"%02x\", VAR_45);\n      }\n      LOG_DBG_(\"\\n\");\n    }\n\n    /* COMMENT_53 */\n    if(VAR_46) {\n      set_packet_attrs();\n      VAR_46->input_callback();\n    }\n\n#if VAR_47\n    /* COMMENT_54 */\n                                                               \n                                                           \n       \n    uipbuf_set_attr(VAR_48,\n      packetbuf_attr(VAR_49));\n#if VAR_50\n    uipbuf_set_attr(VAR_51,\n      packetbuf_attr(VAR_52));\n#endif /* COMMENT_58 */\n#endif /* COMMENT_59 */\n\n    tcpip_input();\n#if VAR_4\n  }\n#endif /* COMMENT_25 */\n}",
  "func_graph_path_before": "contiki-ng/971354a39e46abfb3ea8f3fe542f53a7c6b17dd1/sicslowpan.c/vul/before/0.json",
  "func": "static void\ninput(void)\n{\n  /* size of the IP packet (read from fragment) */\n  uint16_t frag_size = 0;\n  /* offset of the fragment in the IP packet */\n  uint8_t frag_offset = 0;\n  uint8_t *buffer;\n  uint16_t buffer_size;\n\n#if SICSLOWPAN_CONF_FRAG\n  uint8_t is_fragment = 0;\n  int8_t frag_context = 0;\n\n  /* tag of the fragment */\n  uint16_t frag_tag = 0;\n  uint8_t first_fragment = 0, last_fragment = 0;\n#endif /*SICSLOWPAN_CONF_FRAG*/\n\n  /* Update link statistics */\n  link_stats_input_callback(packetbuf_addr(PACKETBUF_ADDR_SENDER));\n\n  /* init */\n  uncomp_hdr_len = 0;\n  packetbuf_hdr_len = 0;\n\n  /* The MAC puts the 15.4 payload inside the packetbuf data buffer */\n  packetbuf_ptr = packetbuf_dataptr();\n\n  if(packetbuf_datalen() == 0) {\n    LOG_WARN(\"input: empty packet\\n\");\n    return;\n  }\n\n  /* Clear uipbuf and set default attributes */\n  uipbuf_clear();\n\n  /* This is default uip_buf since we assume that this is not fragmented */\n  buffer = (uint8_t *)UIP_IP_BUF;\n  buffer_size = UIP_BUFSIZE;\n\n  /* Save the RSSI of the incoming packet in case the upper layer will\n     want to query us for it later. */\n  last_rssi = (signed short)packetbuf_attr(PACKETBUF_ATTR_RSSI);\n\n#if SICSLOWPAN_CONF_FRAG\n\n  /*\n   * Since we don't support the mesh and broadcast header, the first header\n   * we look for is the fragmentation header\n   */\n  switch((GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) >> 8) & SICSLOWPAN_DISPATCH_FRAG_MASK) {\n    case SICSLOWPAN_DISPATCH_FRAG1:\n      frag_offset = 0;\n      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;\n      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);\n      packetbuf_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;\n      first_fragment = 1;\n      is_fragment = 1;\n\n      LOG_INFO(\"input: received first element of a fragmented packet (tag %d, len %d)\\n\",\n             frag_tag, frag_size);\n\n      /* Add the fragment to the fragmentation context */\n      frag_context = add_fragment(frag_tag, frag_size, frag_offset);\n\n      if(frag_context == -1) {\n        LOG_ERR(\"input: failed to allocate new reassembly context\\n\");\n        return;\n      }\n\n      buffer = frag_info[frag_context].first_frag;\n      buffer_size = SICSLOWPAN_FIRST_FRAGMENT_SIZE;\n      break;\n    case SICSLOWPAN_DISPATCH_FRAGN:\n      /*\n       * set offset, tag, size\n       * Offset is in units of 8 bytes\n       */\n      frag_offset = PACKETBUF_FRAG_PTR[PACKETBUF_FRAG_OFFSET];\n      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);\n      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;\n      packetbuf_hdr_len += SICSLOWPAN_FRAGN_HDR_LEN;\n\n      /* Add the fragment to the fragmentation context (this will also\n         copy the payload) */\n      frag_context = add_fragment(frag_tag, frag_size, frag_offset);\n\n      if(frag_context == -1) {\n        LOG_ERR(\"input: reassembly context not found (tag %d)\\n\", frag_tag);\n        return;\n      }\n\n      /* Ok - add_fragment will store the fragment automatically - so\n         we should not store more */\n      buffer = NULL;\n\n      if(frag_info[frag_context].reassembled_len >= frag_size) {\n        last_fragment = 1;\n      }\n      is_fragment = 1;\n      break;\n    default:\n      break;\n  }\n\n  if(is_fragment && !first_fragment) {\n    /* this is a FRAGN, skip the header compression dispatch section */\n    goto copypayload;\n  }\n#endif /* SICSLOWPAN_CONF_FRAG */\n\n  /* First, process 6LoRH headers */\n  curr_page = 0;\n  digest_paging_dispatch();\n  if(curr_page == 1) {\n    LOG_INFO(\"input: page 1, 6LoRH\\n\");\n    digest_6lorh_hdr();\n  } else if (curr_page > 1) {\n    LOG_ERR(\"input: page %u not supported\\n\", curr_page);\n    return;\n  }\n\n  /* Process next dispatch and headers */\n  if(SICSLOWPAN_COMPRESSION > SICSLOWPAN_COMPRESSION_IPV6 &&\n     (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {\n    LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n    if(uncompress_hdr_iphc(buffer, buffer_size, frag_size) == false) {\n      LOG_ERR(\"input: failed to decompress IPHC packet\\n\");\n      return;\n    }\n  } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] == SICSLOWPAN_DISPATCH_IPV6) {\n    LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n    packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;\n\n    /* Put uncompressed IP header in sicslowpan_buf. */\n    memcpy(buffer, packetbuf_ptr + packetbuf_hdr_len, UIP_IPH_LEN);\n\n    /* Update uncomp_hdr_len and packetbuf_hdr_len. */\n    packetbuf_hdr_len += UIP_IPH_LEN;\n    uncomp_hdr_len += UIP_IPH_LEN;\n  } else {\n    LOG_ERR(\"uncompression: unknown dispatch: 0x%02x, or IPHC disabled\\n\",\n             PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK);\n    return;\n  }\n\n#if SICSLOWPAN_CONF_FRAG\n copypayload:\n#endif /*SICSLOWPAN_CONF_FRAG*/\n  /*\n   * copy \"payload\" from the packetbuf buffer to the sicslowpan_buf\n   * if this is a first fragment or not fragmented packet,\n   * we have already copied the compressed headers, uncomp_hdr_len\n   * and packetbuf_hdr_len are non 0, frag_offset is.\n   * If this is a subsequent fragment, this is the contrary.\n   */\n  if(packetbuf_datalen() < packetbuf_hdr_len) {\n    LOG_ERR(\"input: packet dropped due to header > total packet\\n\");\n    return;\n  }\n  packetbuf_payload_len = packetbuf_datalen() - packetbuf_hdr_len;\n\n#if SICSLOWPAN_CONF_FRAG\n  if(is_fragment) {\n    LOG_INFO(\"input: fragment (tag %d, payload %d, offset %d) -- %u %u\\n\",\n         frag_tag, packetbuf_payload_len, frag_offset << 3, packetbuf_datalen(), packetbuf_hdr_len);\n  }\n#endif /*SICSLOWPAN_CONF_FRAG*/\n\n  /* Sanity-check size of incoming packet to avoid buffer overflow */\n  {\n    int req_size = uncomp_hdr_len + (uint16_t)(frag_offset << 3)\n        + packetbuf_payload_len;\n    if(req_size > sizeof(uip_buf)) {\n#if SICSLOWPAN_CONF_FRAG\n      LOG_ERR(\n          \"input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\\n\",\n          frag_context,\n          uncomp_hdr_len, (uint16_t)(frag_offset << 3),\n          packetbuf_payload_len, req_size, (unsigned)sizeof(uip_buf));\n      /* Discard all fragments for this contex, as reassembling this particular fragment would\n       * cause an overflow in uipbuf */\n      clear_fragments(frag_context);\n#endif /* SICSLOWPAN_CONF_FRAG */\n      return;\n    }\n  }\n\n  /* copy the payload if buffer is non-null - which is only the case with first fragment\n     or packets that are non fragmented */\n  if(buffer != NULL) {\n    memcpy((uint8_t *)buffer + uncomp_hdr_len, packetbuf_ptr + packetbuf_hdr_len, packetbuf_payload_len);\n  }\n\n  /* update processed_ip_in_len if fragment, sicslowpan_len otherwise */\n\n#if SICSLOWPAN_CONF_FRAG\n  if(frag_size > 0) {\n    /* Add the size of the header only for the first fragment. */\n    if(first_fragment != 0) {\n      frag_info[frag_context].reassembled_len = uncomp_hdr_len + packetbuf_payload_len;\n      frag_info[frag_context].first_frag_len = uncomp_hdr_len + packetbuf_payload_len;\n    }\n    /* For the last fragment, we are OK if there is extrenous bytes at\n       the end of the packet. */\n    if(last_fragment != 0) {\n      frag_info[frag_context].reassembled_len = frag_size;\n      /* copy to uip */\n      if(!copy_frags2uip(frag_context)) {\n        return;\n      }\n    }\n  }\n\n  /*\n   * If we have a full IP packet in sicslowpan_buf, deliver it to\n   * the IP stack\n   */\n  if(!is_fragment || last_fragment) {\n    /* packet is in uip already - just set length */\n    if(is_fragment != 0 && last_fragment != 0) {\n      uip_len = frag_size;\n    } else {\n      uip_len = packetbuf_payload_len + uncomp_hdr_len;\n    }\n#else\n    uip_len = packetbuf_payload_len + uncomp_hdr_len;\n#endif /* SICSLOWPAN_CONF_FRAG */\n    LOG_INFO(\"input: received IPv6 packet with len %d\\n\",\n             uip_len);\n\n    if(LOG_DBG_ENABLED) {\n      uint16_t ndx;\n      LOG_DBG(\"uncompression: after (%u):\", UIP_IP_BUF->len[1]);\n      for (ndx = 0; ndx < UIP_IP_BUF->len[1] + 40; ndx++) {\n        uint8_t data = ((uint8_t *) (UIP_IP_BUF))[ndx];\n        LOG_DBG_(\"%02x\", data);\n      }\n      LOG_DBG_(\"\\n\");\n    }\n\n    /* if callback is set then set attributes and call */\n    if(callback) {\n      set_packet_attrs();\n      callback->input_callback();\n    }\n\n#if LLSEC802154_USES_AUX_HEADER\n    /*\n     * Assuming that the last packet in packetbuf is containing\n     *  the LLSEC state so that it can be copied to uipbuf.\n     */\n    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_LEVEL,\n      packetbuf_attr(PACKETBUF_ATTR_SECURITY_LEVEL));\n#if LLSEC802154_USES_EXPLICIT_KEYS\n    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_KEY_ID,\n      packetbuf_attr(PACKETBUF_ATTR_KEY_INDEX));\n#endif /* LLSEC802154_USES_EXPLICIT_KEYS */\n#endif /*  LLSEC802154_USES_AUX_HEADER */\n\n    tcpip_input();\n#if SICSLOWPAN_CONF_FRAG\n  }\n#endif /* SICSLOWPAN_CONF_FRAG */\n}",
  "abstract_func": "static void\ninput(void)\n{\n  /* COMMENT_0 */\n  uint16_t VAR_0 = 0;\n  /* COMMENT_1 */\n  uint8_t VAR_1 = 0;\n  uint8_t *VAR_2;\n  uint16_t VAR_3;\n\n#if VAR_4\n  uint8_t VAR_5 = 0;\n  int8_t VAR_6 = 0;\n\n  /* COMMENT_2 */\n  uint16_t VAR_7 = 0;\n  uint8_t VAR_8 = 0, VAR_9 = 0;\n#endif /* COMMENT_3 */\n\n  /* COMMENT_4 */\n  link_stats_input_callback(packetbuf_addr(VAR_10));\n\n  /* COMMENT_5 */\n  VAR_11 = 0;\n  VAR_12 = 0;\n\n  /* COMMENT_6 */\n  VAR_13 = packetbuf_dataptr();\n\n  if(packetbuf_datalen() == 0) {\n    LOG_WARN(\"input: empty packet\\n\");\n    return;\n  }\n\n  /* COMMENT_7 */\n  uipbuf_clear();\n\n  /* COMMENT_8 */\n  VAR_2 = (uint8_t *)VAR_14;\n  VAR_3 = VAR_15;\n\n  /* COMMENT_9 */\n                                      \n  VAR_16 = (signed short)packetbuf_attr(VAR_17);\n\n#if VAR_4\n\n  /* COMMENT_11 */\n                                                                           \n                                            \n     \n  switch((GET16(VAR_18, VAR_19) >> 8) & VAR_20) {\n    case VAR_21:\n      VAR_1 = 0;\n      VAR_0 = GET16(VAR_18, VAR_19) & 0x07ff;\n      VAR_7 = GET16(VAR_18, VAR_22);\n      VAR_12 += VAR_23;\n      VAR_8 = 1;\n      VAR_5 = 1;\n\n      LOG_INFO(\"input: received first element of a fragmented packet (tag %d, len %d)\\n\",\n             VAR_7, VAR_0);\n\n      /* COMMENT_15 */\n      VAR_6 = add_fragment(VAR_7, VAR_0, VAR_1);\n\n      if(VAR_6 == -1) {\n        LOG_ERR(\"input: failed to allocate new reassembly context\\n\");\n        return;\n      }\n\n      VAR_2 = VAR_24[VAR_6].first_frag;\n      VAR_3 = VAR_25;\n      break;\n    case VAR_26:\n      /* COMMENT_16 */\n                              \n                                      \n         \n      VAR_1 = VAR_18[VAR_27];\n      VAR_7 = GET16(VAR_18, VAR_22);\n      VAR_0 = GET16(VAR_18, VAR_19) & 0x07ff;\n      VAR_12 += VAR_28;\n\n      /* COMMENT_20 */\n                             \n      VAR_6 = add_fragment(VAR_7, VAR_0, VAR_1);\n\n      if(VAR_6 == -1) {\n        LOG_ERR(\"input: reassembly context not found (tag %d)\\n\", VAR_7);\n        return;\n      }\n\n      /* COMMENT_22 */\n                                    \n      VAR_2 = NULL;\n\n      if(VAR_24[VAR_6].reassembled_len >= VAR_0) {\n        VAR_9 = 1;\n      }\n      VAR_5 = 1;\n      break;\n    default:\n      break;\n  }\n\n  if(VAR_5 && !VAR_8) {\n    /* COMMENT_24 */\n    goto copypayload;\n  }\n#endif /* COMMENT_25 */\n\n  /* COMMENT_26 */\n  VAR_29 = 0;\n  digest_paging_dispatch();\n  if(VAR_29 == 1) {\n    LOG_INFO(\"input: page 1, 6LoRH\\n\");\n    digest_6lorh_hdr();\n  } else if (VAR_29 > 1) {\n    LOG_ERR(\"input: page %u not supported\\n\", VAR_29);\n    return;\n  }\n\n  /* COMMENT_27 */\n  if(VAR_30 > VAR_31 &&\n     (VAR_32[VAR_33] & VAR_34) == VAR_35) {\n    LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n    if(uncompress_hdr_iphc(VAR_2, VAR_3, VAR_0) == false) {\n      LOG_ERR(\"input: failed to decompress IPHC packet\\n\");\n      return;\n    }\n  } else if(VAR_32[VAR_33] == VAR_36) {\n    LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n    VAR_12 += VAR_37;\n\n    /* COMMENT_28 */\n    memcpy(VAR_2, VAR_13 + VAR_12, VAR_38);\n\n    /* COMMENT_29 */\n    VAR_12 += VAR_38;\n    VAR_11 += VAR_38;\n  } else {\n    LOG_ERR(\"uncompression: unknown dispatch: 0x%02x, or IPHC disabled\\n\",\n             VAR_32[VAR_33] & VAR_34);\n    return;\n  }\n\n#if VAR_4\n copypayload:\n#endif /* COMMENT_3 */\n  /* COMMENT_30 */\n                                                                   \n                                                          \n                                                                  \n                                                     \n                                                            \n     \n  if(packetbuf_datalen() < VAR_12) {\n    LOG_ERR(\"input: packet dropped due to header > total packet\\n\");\n    return;\n  }\n  VAR_39 = packetbuf_datalen() - VAR_12;\n\n#if VAR_4\n  if(VAR_5) {\n    LOG_INFO(\"input: fragment (tag %d, payload %d, offset %d) -- %u %u\\n\",\n         VAR_7, VAR_39, VAR_1 << 3, packetbuf_datalen(), VAR_12);\n  }\n#endif /* COMMENT_3 */\n\n  /* COMMENT_37 */\n  {\n    int VAR_40 = VAR_11 + (uint16_t)(VAR_1 << 3)\n        + VAR_39;\n    if(VAR_40 > sizeof(VAR_41)) {\n#if VAR_4\n      LOG_ERR(\n          \"input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\\n\",\n          VAR_6,\n          VAR_11, (uint16_t)(VAR_1 << 3),\n          VAR_39, VAR_40, (unsigned)sizeof(VAR_41));\n      /* COMMENT_38 */\n                                       \n      clear_fragments(VAR_6);\n#endif /* COMMENT_25 */\n      return;\n    }\n  }\n\n  /* COMMENT_40 */\n                                          \n  if(VAR_2 != NULL) {\n    memcpy((uint8_t *)VAR_2 + VAR_11, VAR_13 + VAR_12, VAR_39);\n  }\n\n  /* COMMENT_42 */\n\n#if VAR_4\n  if(VAR_0 > 0) {\n    /* COMMENT_43 */\n    if(VAR_8 != 0) {\n      VAR_24[VAR_6].reassembled_len = VAR_11 + VAR_39;\n      VAR_24[VAR_6].first_frag_len = VAR_11 + VAR_39;\n    }\n    /* COMMENT_44 */\n                                \n    if(VAR_9 != 0) {\n      VAR_24[VAR_6].reassembled_len = VAR_0;\n      /* COMMENT_46 */\n      if(!copy_frags2uip(VAR_6)) {\n        return;\n      }\n    }\n  }\n\n  /* COMMENT_47 */\n                                                                 \n                 \n     \n  if(!VAR_5 || VAR_9) {\n    /* COMMENT_51 */\n    if(VAR_5 != 0 && VAR_9 != 0) {\n      VAR_42 = VAR_0;\n    } else {\n      VAR_42 = VAR_39 + VAR_11;\n    }\n#else\n    uip_len = packetbuf_payload_len + uncomp_hdr_len;\n#endif/* COMMENT_52 */\n    LOG_INFO(\"input: received IPv6 packet with len %d\\n\",\n             VAR_42);\n\n    if(VAR_43) {\n      uint16_t VAR_44;\n      LOG_DBG(\"uncompression: after (%u):\", VAR_14->len[1]);\n      for (VAR_44 = 0; VAR_44 < VAR_14->len[1] + 40; VAR_44++) {\n        uint8_t VAR_45 = ((uint8_t *) (VAR_14))[VAR_44];\n        LOG_DBG_(\"%02x\", VAR_45);\n      }\n      LOG_DBG_(\"\\n\");\n    }\n\n    /* COMMENT_53 */\n    if(VAR_46) {\n      set_packet_attrs();\n      VAR_46->input_callback();\n    }\n\n#if VAR_47\n    /* COMMENT_54 */\n                                                               \n                                                           \n       \n    uipbuf_set_attr(VAR_48,\n      packetbuf_attr(VAR_49));\n#if VAR_50\n    uipbuf_set_attr(VAR_51,\n      packetbuf_attr(VAR_52));\n#endif /* COMMENT_58 */\n#endif /* COMMENT_59 */\n\n    tcpip_input();\n#if VAR_4\n  }\n#endif /* COMMENT_25 */\n}",
  "func_graph_path": "contiki-ng/971354a39e46abfb3ea8f3fe542f53a7c6b17dd1/sicslowpan.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -125,7 +125,10 @@\n   if(SICSLOWPAN_COMPRESSION > SICSLOWPAN_COMPRESSION_IPV6 &&\n      (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {\n     LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n-    uncompress_hdr_iphc(buffer, buffer_size, frag_size);\n+    if(uncompress_hdr_iphc(buffer, buffer_size, frag_size) == false) {\n+      LOG_ERR(\"input: failed to decompress IPHC packet\\n\");\n+      return;\n+    }\n   } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] == SICSLOWPAN_DISPATCH_IPV6) {\n     LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n     packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;",
  "diff_line_info": {
    "deleted_lines": [
      "    uncompress_hdr_iphc(buffer, buffer_size, frag_size);"
    ],
    "added_lines": [
      "    if(uncompress_hdr_iphc(buffer, buffer_size, frag_size) == false) {",
      "      LOG_ERR(\"input: failed to decompress IPHC packet\\n\");",
      "      return;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1482",
  "description": {
    "pr_info": {
      "title": "Added buffer boundary checks for 6LoWPAN decompression",
      "number": 1482
    },
    "comment": [
      "Unlike for the 6LoWPAN compression function, there are no boundary checks in the decompression function. Additionally, packets that are not decompressed correctly are passed on the to the upper layer because the IPHC decompression function does not return a value indicating whether the operation succeeded.\r\n\r\nThis PR addresses these two issues. Moreover, a packet that demonstrates the out-of-bounds read is added to the packet test, but the problem might be noticed only when compiled with an address sanitizer."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}