{
  "cve_id": "CVE-2018-6533",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "Icinga/icinga2",
  "commit_msg": "Remove need for init.conf",
  "commit_hash": "87adc8898900dad326534afef2f218a7e64927d2",
  "git_url": "https://github.com/Icinga/icinga2/commit/87adc8898900dad326534afef2f218a7e64927d2",
  "file_path": "icinga-app/icinga.cpp",
  "func_name": "Main",
  "func_before": "static int Main()\n{\n\tint argc = Application::GetArgC();\n\tchar **argv = Application::GetArgV();\n\n\tbool autocomplete = false;\n\tint autoindex = 0;\n\n\tif (argc >= 4 && strcmp(argv[1], \"--autocomplete\") == 0) {\n\t\tautocomplete = true;\n\n\t\ttry {\n\t\t\tautoindex = Convert::ToLong(argv[2]);\n\t\t} catch (const std::invalid_argument&) {\n\t\t\tLog(LogCritical, \"icinga-app\")\n\t\t\t\t<< \"Invalid index for --autocomplete: \" << argv[2];\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\targc -= 3;\n\t\targv += 3;\n\t}\n\n\tApplication::SetStartTime(Utility::GetTime());\n\n\t/* Set thread title. */\n\tUtility::SetThreadName(\"Main Thread\", false);\n\n\t/* Install exception handlers to make debugging easier. */\n\tApplication::InstallExceptionHandlers();\n\n#ifdef _WIN32\n\tbool builtinPaths = true;\n\n\tString binaryPrefix = Utility::GetIcingaInstallPath();\n\tString dataPrefix = Utility::GetIcingaDataPath();\n\n\tif (!binaryPrefix.IsEmpty() && !dataPrefix.IsEmpty()) {\n\t\tApplication::DeclarePrefixDir(binaryPrefix);\n\t\tApplication::DeclareSysconfDir(dataPrefix + \"\\\\etc\");\n\t\tApplication::DeclareRunDir(dataPrefix + \"\\\\var\\\\run\");\n\t\tApplication::DeclareLocalStateDir(dataPrefix + \"\\\\var\");\n\t\tApplication::DeclarePkgDataDir(binaryPrefix + \"\\\\share\\\\icinga2\");\n\t\tApplication::DeclareIncludeConfDir(binaryPrefix + \"\\\\share\\\\icinga2\\\\include\");\n\t} else {\n\t\tLog(LogWarning, \"icinga-app\", \"Registry key could not be read. Falling back to built-in paths.\");\n\n#endif /* _WIN32 */\n\t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n\t\tApplication::DeclareSysconfigFile(ICINGA_SYSCONFIGFILE);\n\t\tApplication::DeclareSysconfDir(ICINGA_SYSCONFDIR);\n\t\tApplication::DeclareRunDir(ICINGA_RUNDIR);\n\t\tApplication::DeclareLocalStateDir(ICINGA_LOCALSTATEDIR);\n\t\tApplication::DeclarePkgDataDir(ICINGA_PKGDATADIR);\n\t\tApplication::DeclareIncludeConfDir(ICINGA_INCLUDECONFDIR);\n#ifdef _WIN32\n\t}\n#endif /* _WIN32 */\n\n\tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n\n\tString icinga_user = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n\tif (icinga_user.IsEmpty())\n\t\ticinga_user = ICINGA_USER;\n\n\tString icinga_group = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n\tif (icinga_group.IsEmpty())\n\t\ticinga_group = ICINGA_GROUP;\n\n\tApplication::DeclareRunAsUser(icinga_user);\n\tApplication::DeclareRunAsGroup(icinga_group);\n#ifdef __linux__\n\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n#endif /* __linux__ */\n\tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n\tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n\n\tScriptGlobal::Set(\"AttachDebugger\", false);\n\n\tScriptGlobal::Set(\"PlatformKernel\", Utility::GetPlatformKernel());\n\tScriptGlobal::Set(\"PlatformKernelVersion\", Utility::GetPlatformKernelVersion());\n\tScriptGlobal::Set(\"PlatformName\", Utility::GetPlatformName());\n\tScriptGlobal::Set(\"PlatformVersion\", Utility::GetPlatformVersion());\n\tScriptGlobal::Set(\"PlatformArchitecture\", Utility::GetPlatformArchitecture());\n\n\tScriptGlobal::Set(\"BuildHostName\", ICINGA_BUILD_HOST_NAME);\n\tScriptGlobal::Set(\"BuildCompilerName\", ICINGA_BUILD_COMPILER_NAME);\n\tScriptGlobal::Set(\"BuildCompilerVersion\", ICINGA_BUILD_COMPILER_VERSION);\n\n\tString initconfig = Application::GetSysconfDir() + \"/icinga2/init.conf\";\n\n\tif (Utility::PathExists(initconfig)) {\n\t\tstd::unique_ptr<Expression> expression;\n\t\ttry {\n\t\t\texpression = ConfigCompiler::CompileFile(initconfig);\n\n\t\t\tScriptFrame frame(true);\n\t\t\texpression->Evaluate(frame);\n\t\t} catch (const std::exception& ex) {\n\t\t\tLog(LogCritical, \"config\", DiagnosticInformation(ex));\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\n\tif (!autocomplete)\n\t\tApplication::SetResourceLimits();\n\n\tLogSeverity logLevel = Logger::GetConsoleLogSeverity();\n\tLogger::SetConsoleLogSeverity(LogWarning);\n\n\tpo::options_description visibleDesc(\"Global options\");\n\n\tvisibleDesc.add_options()\n\t\t(\"help,h\", \"show this help message\")\n\t\t(\"version,V\", \"show version information\")\n#ifndef _WIN32\n\t\t(\"color\", \"use VT100 color codes even when stdout is not a terminal\")\n#endif /* _WIN32 */\n\t\t(\"define,D\", po::value<std::vector<std::string> >(), \"define a constant\")\n\t\t(\"include,I\", po::value<std::vector<std::string> >(), \"add include search directory\")\n\t\t(\"log-level,x\", po::value<std::string>(), \"specify the log level for the console log.\\n\"\n\t\t\t\"The valid value is either debug, notice, information (default), warning, or critical\")\n\t\t(\"script-debugger,X\", \"whether to enable the script debugger\");\n\n\tpo::options_description hiddenDesc(\"Hidden options\");\n\n\thiddenDesc.add_options()\n\t\t(\"no-stack-rlimit\", \"used internally, do not specify manually\")\n\t\t(\"arg\", po::value<std::vector<std::string> >(), \"positional argument\");\n\n\tpo::positional_options_description positionalDesc;\n\tpositionalDesc.add(\"arg\", -1);\n\n\tString cmdname;\n\tCLICommand::Ptr command;\n\tpo::variables_map vm;\n\n\ttry {\n\t\tCLICommand::ParseCommand(argc, argv, visibleDesc, hiddenDesc, positionalDesc,\n\t\t\tvm, cmdname, command, autocomplete);\n\t} catch (const std::exception& ex) {\n\t\tLog(LogCritical, \"icinga-app\")\n\t\t\t<< \"Error while parsing command-line options: \" << ex.what();\n\t\treturn EXIT_FAILURE;\n\t}\n\n#ifdef _WIN32\n\tchar username[UNLEN + 1];\n\tDWORD usernameLen = UNLEN + 1;\n\tGetUserName(username, &usernameLen);\n\n\tstd::ifstream userFile;\n\tuserFile.open(Application::GetSysconfDir() + \"/icinga2/user\");\n\n\tif (userFile && command && !Application::IsProcessElevated()) {\n\t\tstd::string userLine;\n\t\tif (std::getline(userFile, userLine)) {\n\t\t\tuserFile.close();\n\n\t\t\tstd::vector<std::string> strs;\n\t\t\tboost::split(strs, userLine, boost::is_any_of(\"\\\\\"));\n\n\t\t\tif (username != strs[1] && command->GetImpersonationLevel() == ImpersonationLevel::ImpersonateIcinga\n\t\t\t\t|| command->GetImpersonationLevel() == ImpersonationLevel::ImpersonateRoot) {\n\t\t\t\tTCHAR szPath[MAX_PATH];\n\n\t\t\t\tif (GetModuleFileName(nullptr, szPath, ARRAYSIZE(szPath))) {\n\t\t\t\t\tSHELLEXECUTEINFO sei = { sizeof(sei) };\n\t\t\t\t\tsei.lpVerb = _T(\"runas\");\n\t\t\t\t\tsei.lpFile = \"cmd.exe\";\n\t\t\t\t\tsei.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;\n\t\t\t\t\tsei.nShow = SW_SHOW;\n\n\t\t\t\t\tstd::stringstream parameters;\n\n\t\t\t\t\tparameters << \"/C \" << \"\\\"\" << szPath << \"\\\"\" << \" \";\n\n\t\t\t\t\tfor (int i = 1; i < argc; i++) {\n\t\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\t\tparameters << \" \";\n\t\t\t\t\t\tparameters << argv[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tparameters << \" & SET exitcode=%errorlevel%\";\n\t\t\t\t\tparameters << \" & pause\";\n\t\t\t\t\tparameters << \" & EXIT /B %exitcode%\";\n\n\t\t\t\t\tstd::string str = parameters.str();\n\t\t\t\t\tLPCSTR cstr = str.c_str();\n\n\t\t\t\t\tsei.lpParameters = cstr;\n\n\t\t\t\t\tif (!ShellExecuteEx(&sei)) {\n\t\t\t\t\t\tDWORD dwError = GetLastError();\n\t\t\t\t\t\tif (dwError == ERROR_CANCELLED)\n\t\t\t\t\t\t\tApplication::Exit(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWaitForSingleObject(sei.hProcess, INFINITE);\n\n\t\t\t\t\t\tDWORD exitCode;\n\t\t\t\t\t\tGetExitCodeProcess(sei.hProcess, &exitCode);\n\n\t\t\t\t\t\tCloseHandle(sei.hProcess);\n\n\t\t\t\t\t\tApplication::Exit(exitCode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tuserFile.close();\n\t\t}\n\t}\n#endif /* _WIN32 */\n\n#ifndef _WIN32\n\tif (vm.count(\"color\")) {\n\t\tConsole::SetType(std::cout, Console_VT100);\n\t\tConsole::SetType(std::cerr, Console_VT100);\n\t}\n#endif /* _WIN32 */\n\n\tif (vm.count(\"define\")) {\n\t\tfor (const String& define : vm[\"define\"].as<std::vector<std::string> >()) {\n\t\t\tString key, value;\n\t\t\tsize_t pos = define.FindFirstOf('=');\n\t\t\tif (pos != String::NPos) {\n\t\t\t\tkey = define.SubStr(0, pos);\n\t\t\t\tvalue = define.SubStr(pos + 1);\n\t\t\t} else {\n\t\t\t\tkey = define;\n\t\t\t\tvalue = \"1\";\n\t\t\t}\n\t\t\tScriptGlobal::Set(key, value);\n\t\t}\n\t}\n\n\tif (vm.count(\"script-debugger\"))\n\t\tApplication::SetScriptDebuggerEnabled(true);\n\n\tApplication::DeclareStatePath(Application::GetLocalStateDir() + \"/lib/icinga2/icinga2.state\");\n\tApplication::DeclareModAttrPath(Application::GetLocalStateDir() + \"/lib/icinga2/modified-attributes.conf\");\n\tApplication::DeclareObjectsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.debug\");\n\tApplication::DeclareVarsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.vars\");\n\tApplication::DeclarePidPath(Application::GetRunDir() + \"/icinga2/icinga2.pid\");\n\n\tConfigCompiler::AddIncludeSearchDir(Application::GetIncludeConfDir());\n\n\tif (!autocomplete && vm.count(\"include\")) {\n\t\tfor (const String& includePath : vm[\"include\"].as<std::vector<std::string> >()) {\n\t\t\tConfigCompiler::AddIncludeSearchDir(includePath);\n\t\t}\n\t}\n\n\tif (!autocomplete) {\n\t\tLogger::SetConsoleLogSeverity(logLevel);\n\n\t\tif (vm.count(\"log-level\")) {\n\t\t\tString severity = vm[\"log-level\"].as<std::string>();\n\n\t\t\tLogSeverity logLevel = LogInformation;\n\t\t\ttry {\n\t\t\t\tlogLevel = Logger::StringToSeverity(severity);\n\t\t\t} catch (std::exception&) {\n\t\t\t\t/* Inform user and exit */\n\t\t\t\tLog(LogCritical, \"icinga-app\", \"Invalid log level set. Default is 'information'.\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tLogger::SetConsoleLogSeverity(logLevel);\n\t\t}\n\n\t\tif (!command || vm.count(\"help\") || vm.count(\"version\")) {\n\t\t\tString appName;\n\n\t\t\ttry {\n\t\t\t\tappName = Utility::BaseName(Application::GetArgV()[0]);\n\t\t\t} catch (const std::bad_alloc&) {\n\t\t\t\tLog(LogCritical, \"icinga-app\", \"Allocation failed.\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tif (appName.GetLength() > 3 && appName.SubStr(0, 3) == \"lt-\")\n\t\t\t\tappName = appName.SubStr(3, appName.GetLength() - 3);\n\n\t\t\tstd::cout << appName << \" \" << \"- The Icinga 2 network monitoring daemon (version: \"\n\t\t\t\t<< ConsoleColorTag(vm.count(\"version\") ? Console_ForegroundRed : Console_Normal)\n\t\t\t\t<< Application::GetAppVersion()\n#ifdef I2_DEBUG\n\t\t\t\t<< \"; debug\"\n#endif /* I2_DEBUG */\n\t\t\t\t<< ConsoleColorTag(Console_Normal)\n\t\t\t\t<< \")\" << std::endl << std::endl;\n\n\t\t\tif ((!command || vm.count(\"help\")) && !vm.count(\"version\")) {\n\t\t\t\tstd::cout << \"Usage:\" << std::endl\n\t\t\t\t\t<< \"  \" << Utility::BaseName(argv[0]) << \" \";\n\n\t\t\t\tif (cmdname.IsEmpty())\n\t\t\t\t\tstd::cout << \"<command>\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << cmdname;\n\n\t\t\t\tstd::cout << \" [<arguments>]\" << std::endl;\n\n\t\t\t\tif (command) {\n\t\t\t\t\tstd::cout << std::endl\n\t\t\t\t\t\t<< command->GetDescription() << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vm.count(\"version\")) {\n\t\t\t\tstd::cout << \"Copyright (c) 2012-2018 Icinga Development Team (https://www.icinga.com/)\" << std::endl\n\t\t\t\t\t<< \"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl2.html>\" << std::endl\n\t\t\t\t\t<< \"This is free software: you are free to change and redistribute it.\" << std::endl\n\t\t\t\t\t<< \"There is NO WARRANTY, to the extent permitted by law.\";\n\t\t\t}\n\n\t\t\tstd::cout << std::endl;\n\n\t\t\tif (vm.count(\"version\")) {\n\t\t\t\tstd::cout << std::endl;\n\n\t\t\t\tApplication::DisplayInfoMessage(std::cout, true);\n\n\t\t\t\treturn EXIT_SUCCESS;\n\t\t\t}\n\t\t}\n\n\t\tif (!command || vm.count(\"help\")) {\n\t\t\tif (!command)\n\t\t\t\tCLICommand::ShowCommands(argc, argv, nullptr);\n\n\t\t\tstd::cout << visibleDesc << std::endl\n\t\t\t\t<< \"Report bugs at <https://github.com/Icinga/icinga2>\" << std::endl\n\t\t\t\t<< \"Icinga home page: <https://www.icinga.com/>\" << std::endl;\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\n\tint rc = 1;\n\n\tif (autocomplete) {\n\t\tCLICommand::ShowCommands(argc, argv, &visibleDesc, &hiddenDesc,\n\t\t\t&GlobalArgumentCompletion, true, autoindex);\n\t\trc = 0;\n\t} else if (command) {\n\t\tLogger::DisableTimestamp(true);\n#ifndef _WIN32\n\t\tif (command->GetImpersonationLevel() == ImpersonateRoot) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tLog(LogCritical, \"cli\", \"This command must be run as root.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (command && command->GetImpersonationLevel() == ImpersonateIcinga) {\n\t\t\tString group = Application::GetRunAsGroup();\n\t\t\tString user = Application::GetRunAsUser();\n\n\t\t\terrno = 0;\n\t\t\tstruct group *gr = getgrnam(group.CStr());\n\n\t\t\tif (!gr) {\n\t\t\t\tif (errno == 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Invalid group specified: \" << group;\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"getgrnam() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getgid() != gr->gr_gid) {\n\t\t\t\tif (!vm.count(\"reload-internal\") && setgroups(0, nullptr) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setgroups() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (setgid(gr->gr_gid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setgid() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tstruct passwd *pw = getpwnam(user.CStr());\n\n\t\t\tif (!pw) {\n\t\t\t\tif (errno == 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Invalid user specified: \" << user;\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"getpwnam() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// also activate the additional groups the configured user is member of\n\t\t\tif (getuid() != pw->pw_uid) {\n\t\t\t\tif (!vm.count(\"reload-internal\") && initgroups(user.CStr(), pw->pw_gid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"initgroups() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (setuid(pw->pw_uid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setuid() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tProcess::InitializeSpawnHelper();\n#endif /* _WIN32 */\n\n\t\tstd::vector<std::string> args;\n\t\tif (vm.count(\"arg\"))\n\t\t\targs = vm[\"arg\"].as<std::vector<std::string> >();\n\n\t\tif (static_cast<int>(args.size()) < command->GetMinArguments()) {\n\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t<< \"Too few arguments. Command needs at least \" << command->GetMinArguments()\n\t\t\t\t<< \" argument\" << (command->GetMinArguments() != 1 ? \"s\" : \"\") << \".\";\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\tif (command->GetMaxArguments() >= 0 && static_cast<int>(args.size()) > command->GetMaxArguments()) {\n\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t<< \"Too many arguments. At most \" << command->GetMaxArguments()\n\t\t\t\t<< \" argument\" << (command->GetMaxArguments() != 1 ? \"s\" : \"\") << \" may be specified.\";\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\trc = command->Run(vm, args);\n\t}\n\n\treturn rc;\n}",
  "abstract_func_before": "static int Main()\n{\n\tint VAR_0 = Application::GetArgC();\n\tchar **VAR_1 = Application::GetArgV();\n\n\tbool VAR_2 = false;\n\tint VAR_3 = 0;\n\n\tif (VAR_0 >= 4 && strcmp(VAR_1[1], \"--autocomplete\") == 0) {\n\t\tVAR_2 = true;\n\n\t\ttry {\n\t\t\tVAR_3 = Convert::ToLong(VAR_1[2]);\n\t\t} catch (const std::invalid_argument&) {\n\t\t\tLog(VAR_4, \"icinga-app\")\n\t\t\t\t<< \"Invalid index for --autocomplete: \" << VAR_1[2];\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_0 -= 3;\n\t\tVAR_1 += 3;\n\t}\n\n\tApplication::SetStartTime(Utility::GetTime());\n\n\t/* COMMENT_0 */\n\tUtility::SetThreadName(\"Main Thread\", false);\n\n\t/* COMMENT_1 */\n\tApplication::InstallExceptionHandlers();\n\n#ifdef VAR_6\n\tbool VAR_7 = true;\n\n\tString VAR_8 = Utility::GetIcingaInstallPath();\n\tString VAR_9 = Utility::GetIcingaDataPath();\n\n\tif (!VAR_8.IsEmpty() && !VAR_9.IsEmpty()) {\n\t\tApplication::DeclarePrefixDir(VAR_8);\n\t\tApplication::DeclareSysconfDir(VAR_9 + \"\\\\etc\");\n\t\tApplication::DeclareRunDir(VAR_9 + \"\\\\var\\\\run\");\n\t\tApplication::DeclareLocalStateDir(VAR_9 + \"\\\\var\");\n\t\tApplication::DeclarePkgDataDir(VAR_8 + \"\\\\share\\\\icinga2\");\n\t\tApplication::DeclareIncludeConfDir(VAR_8 + \"\\\\share\\\\icinga2\\\\include\");\n\t} else {\n\t\tLog(VAR_10, \"icinga-app\", \"Registry key could not be read. Falling back to built-in paths.\");\n\n#endif/* COMMENT_2 */\n\t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n\t\tApplication::DeclareSysconfigFile(VAR_11);\n\t\tApplication::DeclareSysconfDir(VAR_12);\n\t\tApplication::DeclareRunDir(VAR_13);\n\t\tApplication::DeclareLocalStateDir(VAR_14);\n\t\tApplication::DeclarePkgDataDir(VAR_15);\n\t\tApplication::DeclareIncludeConfDir(VAR_16);\n#ifdef VAR_6\n\t}\n#endif /* COMMENT_3 */\n\n\tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n\n\tString VAR_17 = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n\tif (VAR_17.IsEmpty())\n\t\tVAR_17 = VAR_18;\n\n\tString VAR_19 = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n\tif (VAR_19.IsEmpty())\n\t\tVAR_19 = VAR_20;\n\n\tApplication::DeclareRunAsUser(VAR_17);\n\tApplication::DeclareRunAsGroup(VAR_19);\n#ifdef VAR_21\n\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n#endif /* COMMENT_4 */\n\tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n\tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n\n\tScriptGlobal::Set(\"AttachDebugger\", false);\n\n\tScriptGlobal::Set(\"PlatformKernel\", Utility::GetPlatformKernel());\n\tScriptGlobal::Set(\"PlatformKernelVersion\", Utility::GetPlatformKernelVersion());\n\tScriptGlobal::Set(\"PlatformName\", Utility::GetPlatformName());\n\tScriptGlobal::Set(\"PlatformVersion\", Utility::GetPlatformVersion());\n\tScriptGlobal::Set(\"PlatformArchitecture\", Utility::GetPlatformArchitecture());\n\n\tScriptGlobal::Set(\"BuildHostName\", VAR_22);\n\tScriptGlobal::Set(\"BuildCompilerName\", VAR_23);\n\tScriptGlobal::Set(\"BuildCompilerVersion\", VAR_24);\n\n\tString VAR_25 = Application::GetSysconfDir() + \"/icinga2/init.conf\";\n\n\tif (Utility::PathExists(VAR_25)) {\n\t\tstd::unique_ptr<Expression> VAR_26;\n\t\ttry {\n\t\t\tVAR_26 = ConfigCompiler::CompileFile(VAR_25);\n\n\t\t\tScriptFrame VAR_27(true);\n\t\t\tVAR_26->Evaluate(VAR_27);\n\t\t} catch (const std::exception& VAR_28) {\n\t\t\tLog(VAR_4, \"config\", DiagnosticInformation(VAR_28));\n\t\t\treturn VAR_5;\n\t\t}\n\t}\n\n\tif (!VAR_2)\n\t\tApplication::SetResourceLimits();\n\n\tLogSeverity VAR_29 = Logger::GetConsoleLogSeverity();\n\tLogger::SetConsoleLogSeverity(VAR_10);\n\n\tpo::options_description VAR_30(\"Global options\");\n\n\tVAR_30.add_options()\n\t\t(\"help,h\", \"show this help message\")\n\t\t(\"version,V\", \"show version information\")\n#ifndef VAR_6\n\t\t(\"color\", \"use VT100 color codes even when stdout is not a terminal\")\n#endif /* COMMENT_3 */\n\t\t(\"define,D\", po::VAR_31<std::vector<std::string> >(), \"define a constant\")\n\t\t(\"include,I\", po::VAR_31<std::vector<std::string> >(), \"add include search directory\")\n\t\t(\"log-level,x\", po::VAR_31<std::string>(), \"specify the log level for the console log.\\n\"\n\t\t\t\"The valid value is either debug, notice, information (default), warning, or critical\")\n\t\t(\"script-debugger,X\", \"whether to enable the script debugger\");\n\n\tpo::options_description VAR_32(\"Hidden options\");\n\n\tVAR_32.add_options()\n\t\t(\"no-stack-rlimit\", \"used internally, do not specify manually\")\n\t\t(\"arg\", po::VAR_31<std::vector<std::string> >(), \"positional argument\");\n\n\tpo::positional_options_description VAR_33;\n\tVAR_33.add(\"arg\", -1);\n\n\tString VAR_34;\n\tCLICommand::Ptr VAR_35;\n\tpo::variables_map VAR_36;\n\n\ttry {\n\t\tCLICommand::ParseCommand(VAR_0, VAR_1, VAR_30, VAR_32, VAR_33,\n\t\t\tVAR_36, VAR_34, VAR_35, VAR_2);\n\t} catch (const std::exception& VAR_28) {\n\t\tLog(VAR_4, \"icinga-app\")\n\t\t\t<< \"Error while parsing command-line options: \" << VAR_28.what();\n\t\treturn VAR_5;\n\t}\n\n#ifdef VAR_6\n\tchar VAR_37[VAR_38 + 1];\n\tDWORD VAR_39 = VAR_38 + 1;\n\tGetUserName(VAR_37, &VAR_39);\n\n\tstd::ifstream VAR_40;\n\tVAR_40.open(Application::GetSysconfDir() + \"/icinga2/user\");\n\n\tif (VAR_40 && VAR_35 && !Application::IsProcessElevated()) {\n\t\tstd::string VAR_41;\n\t\tif (std::getline(VAR_40, VAR_41)) {\n\t\t\tVAR_40.close();\n\n\t\t\tstd::vector<std::string> VAR_42;\n\t\t\tboost::split(VAR_42, VAR_41, boost::is_any_of(\"\\\\\"));\n\n\t\t\tif (VAR_37 != VAR_42[1] && VAR_35->GetImpersonationLevel() == ImpersonationLevel::ImpersonateIcinga\n\t\t\t\t|| VAR_35->GetImpersonationLevel() == ImpersonationLevel::ImpersonateRoot) {\n\t\t\t\tTCHAR VAR_43[VAR_44];\n\n\t\t\t\tif (GetModuleFileName(nullptr, VAR_43, ARRAYSIZE(VAR_43))) {\n\t\t\t\t\tSHELLEXECUTEINFO VAR_45 = { sizeof(VAR_45) };\n\t\t\t\t\tVAR_45.lpVerb = _T(\"runas\");\n\t\t\t\t\tVAR_45.lpFile = \"cmd.exe\";\n\t\t\t\t\tVAR_45.fMask = VAR_46 | VAR_47 | VAR_48;\n\t\t\t\t\tVAR_45.nShow = VAR_49;\n\n\t\t\t\t\tstd::stringstream VAR_50;\n\n\t\t\t\t\tVAR_50 << \"/C \" << \"\\\"\" << VAR_43 << \"\\\"\" << \" \";\n\n\t\t\t\t\tfor (int VAR_51 = 1; VAR_51 < VAR_0; VAR_51++) {\n\t\t\t\t\t\tif (VAR_51 != 1)\n\t\t\t\t\t\t\tVAR_50 << \" \";\n\t\t\t\t\t\tVAR_50 << VAR_1[VAR_51];\n\t\t\t\t\t}\n\n\t\t\t\t\tVAR_50 << \" & SET exitcode=%errorlevel%\";\n\t\t\t\t\tVAR_50 << \" & pause\";\n\t\t\t\t\tVAR_50 << \" & EXIT /B %exitcode%\";\n\n\t\t\t\t\tstd::string VAR_52 = VAR_50.str();\n\t\t\t\t\tLPCSTR VAR_53 = VAR_52.c_str();\n\n\t\t\t\t\tVAR_45.lpParameters = VAR_53;\n\n\t\t\t\t\tif (!ShellExecuteEx(&VAR_45)) {\n\t\t\t\t\t\tDWORD VAR_54 = GetLastError();\n\t\t\t\t\t\tif (VAR_54 == VAR_55)\n\t\t\t\t\t\t\tApplication::Exit(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWaitForSingleObject(VAR_45.hProcess, VAR_56);\n\n\t\t\t\t\t\tDWORD VAR_57;\n\t\t\t\t\t\tGetExitCodeProcess(VAR_45.hProcess, &VAR_57);\n\n\t\t\t\t\t\tCloseHandle(VAR_45.hProcess);\n\n\t\t\t\t\t\tApplication::Exit(VAR_57);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_40.close();\n\t\t}\n\t}\n#endif /* COMMENT_3 */\n\n#ifndef VAR_6\n\tif (VAR_36.count(\"color\")) {\n\t\tConsole::SetType(std::cout, VAR_58);\n\t\tConsole::SetType(std::cerr, VAR_58);\n\t}\n#endif /* COMMENT_3 */\n\n\tif (VAR_36.count(\"define\")) {\n\t\tfor (const String& VAR_59 : VAR_36[\"define\"].as<std::vector<std::string> >()) {\n\t\t\tString VAR_60, VAR_31;\n\t\t\tsize_t VAR_61 = VAR_59.FindFirstOf('=');\n\t\t\tif (VAR_61 != String::NPos) {\n\t\t\t\tVAR_60 = VAR_59.SubStr(0, VAR_61);\n\t\t\t\tVAR_31 = VAR_59.SubStr(VAR_61 + 1);\n\t\t\t} else {\n\t\t\t\tVAR_60 = VAR_59;\n\t\t\t\tVAR_31 = \"1\";\n\t\t\t}\n\t\t\tScriptGlobal::Set(VAR_60, VAR_31);\n\t\t}\n\t}\n\n\tif (VAR_36.count(\"script-debugger\"))\n\t\tApplication::SetScriptDebuggerEnabled(true);\n\n\tApplication::DeclareStatePath(Application::GetLocalStateDir() + \"/lib/icinga2/icinga2.state\");\n\tApplication::DeclareModAttrPath(Application::GetLocalStateDir() + \"/lib/icinga2/modified-attributes.conf\");\n\tApplication::DeclareObjectsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.debug\");\n\tApplication::DeclareVarsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.vars\");\n\tApplication::DeclarePidPath(Application::GetRunDir() + \"/icinga2/icinga2.pid\");\n\n\tConfigCompiler::AddIncludeSearchDir(Application::GetIncludeConfDir());\n\n\tif (!VAR_2 && VAR_36.count(\"include\")) {\n\t\tfor (const String& VAR_62 : VAR_36[\"include\"].as<std::vector<std::string> >()) {\n\t\t\tConfigCompiler::AddIncludeSearchDir(VAR_62);\n\t\t}\n\t}\n\n\tif (!VAR_2) {\n\t\tLogger::SetConsoleLogSeverity(VAR_29);\n\n\t\tif (VAR_36.count(\"log-level\")) {\n\t\t\tString VAR_63 = VAR_36[\"log-level\"].as<std::string>();\n\n\t\t\tLogSeverity VAR_29 = VAR_64;\n\t\t\ttry {\n\t\t\t\tVAR_29 = Logger::StringToSeverity(VAR_63);\n\t\t\t} catch (std::exception&) {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tLog(VAR_4, \"icinga-app\", \"Invalid log level set. Default is 'information'.\");\n\t\t\t\treturn VAR_5;\n\t\t\t}\n\n\t\t\tLogger::SetConsoleLogSeverity(VAR_29);\n\t\t}\n\n\t\tif (!VAR_35 || VAR_36.count(\"help\") || VAR_36.count(\"version\")) {\n\t\t\tString VAR_65;\n\n\t\t\ttry {\n\t\t\t\tVAR_65 = Utility::BaseName(Application::GetArgV()[0]);\n\t\t\t} catch (const std::bad_alloc&) {\n\t\t\t\tLog(VAR_4, \"icinga-app\", \"Allocation failed.\");\n\t\t\t\treturn VAR_5;\n\t\t\t}\n\n\t\t\tif (VAR_65.GetLength() > 3 && VAR_65.SubStr(0, 3) == \"lt-\")\n\t\t\t\tVAR_65 = VAR_65.SubStr(3, VAR_65.GetLength() - 3);\n\n\t\t\tstd::cout << VAR_65 << \" \" << \"- The Icinga 2 network monitoring daemon (version: \"\n\t\t\t\t<< ConsoleColorTag(VAR_36.count(\"version\") ? VAR_66 : VAR_67)\n\t\t\t\t<< Application::GetAppVersion()\n#ifdef VAR_68\n\t\t\t\t<< \"; debug\"\n#endif /* COMMENT_6 */\n\t\t\t\t<< ConsoleColorTag(VAR_67)\n\t\t\t\t<< \")\" << std::endl << std::endl;\n\n\t\t\tif ((!VAR_35 || VAR_36.count(\"help\")) && !VAR_36.count(\"version\")) {\n\t\t\t\tstd::cout << \"Usage:\" << std::endl\n\t\t\t\t\t<< \"  \" << Utility::BaseName(VAR_1[0]) << \" \";\n\n\t\t\t\tif (VAR_34.IsEmpty())\n\t\t\t\t\tstd::cout << \"<command>\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << VAR_34;\n\n\t\t\t\tstd::cout << \" [<arguments>]\" << std::endl;\n\n\t\t\t\tif (VAR_35) {\n\t\t\t\t\tstd::cout << std::endl\n\t\t\t\t\t\t<< VAR_35->GetDescription() << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (VAR_36.count(\"version\")) {\n\t\t\t\tstd::cout << \"Copyright (c) 2012-2018 Icinga Development Team (https://www.icinga.com/)\" << std::endl\n\t\t\t\t\t<< \"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl2.html>\" << std::endl\n\t\t\t\t\t<< \"This is free software: you are free to change and redistribute it.\" << std::endl\n\t\t\t\t\t<< \"There is NO WARRANTY, to the extent permitted by law.\";\n\t\t\t}\n\n\t\t\tstd::cout << std::endl;\n\n\t\t\tif (VAR_36.count(\"version\")) {\n\t\t\t\tstd::cout << std::endl;\n\n\t\t\t\tApplication::DisplayInfoMessage(std::cout, true);\n\n\t\t\t\treturn VAR_69;\n\t\t\t}\n\t\t}\n\n\t\tif (!VAR_35 || VAR_36.count(\"help\")) {\n\t\t\tif (!VAR_35)\n\t\t\t\tCLICommand::ShowCommands(VAR_0, VAR_1, nullptr);\n\n\t\t\tstd::cout << VAR_30 << std::endl\n\t\t\t\t<< \"Report bugs at <https://github.com/Icinga/icinga2>\" << std::endl\n\t\t\t\t<< \"Icinga home page: <https://www.icinga.com/>\" << std::endl;\n\t\t\treturn VAR_69;\n\t\t}\n\t}\n\n\tint VAR_70 = 1;\n\n\tif (VAR_2) {\n\t\tCLICommand::ShowCommands(VAR_0, VAR_1, &VAR_30, &VAR_32,\n\t\t\t&VAR_71, true, VAR_3);\n\t\tVAR_70 = 0;\n\t} else if (VAR_35) {\n\t\tLogger::DisableTimestamp(true);\n#ifndef VAR_6\n\t\tif (VAR_35->GetImpersonationLevel() == VAR_72) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tLog(VAR_4, \"cli\", \"This command must be run as root.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (VAR_35 && VAR_35->GetImpersonationLevel() == VAR_73) {\n\t\t\tString VAR_74 = Application::GetRunAsGroup();\n\t\t\tString VAR_75 = Application::GetRunAsUser();\n\n\t\t\tVAR_76 = 0;\n\t\t\tstruct group *VAR_77 = getgrnam(group.CStr());\n\n\t\t\tif (!VAR_77) {\n\t\t\t\tif (VAR_76 == 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Invalid group specified: \" << group;\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t} else {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"getgrnam() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getgid() != VAR_77->gr_gid) {\n\t\t\t\tif (!VAR_36.count(\"reload-internal\") && setgroups(0, nullptr) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setgroups() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_75 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\n\t\t\t\tif (setgid(VAR_77->gr_gid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setgid() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_76 = 0;\n\t\t\tstruct passwd *VAR_78 = getpwnam(VAR_75.CStr());\n\n\t\t\tif (!VAR_78) {\n\t\t\t\tif (VAR_76 == 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Invalid user specified: \" << VAR_75;\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t} else {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"getpwnam() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_7 */\n\t\t\tif (getuid() != VAR_78->pw_uid) {\n\t\t\t\tif (!VAR_36.count(\"reload-internal\") && initgroups(VAR_75.CStr(), VAR_78->pw_gid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"initgroups() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_75 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\n\t\t\t\tif (setuid(VAR_78->pw_uid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setuid() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_75 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tProcess::InitializeSpawnHelper();\n#endif /* COMMENT_3 */\n\n\t\tstd::vector<std::string> VAR_79;\n\t\tif (VAR_36.count(\"arg\"))\n\t\t\tVAR_79 = VAR_36[\"arg\"].as<std::vector<std::string> >();\n\n\t\tif (VAR_80<int>(VAR_79.size()) < VAR_35->GetMinArguments()) {\n\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t<< \"Too few arguments. Command needs at least \" << VAR_35->GetMinArguments()\n\t\t\t\t<< \" argument\" << (VAR_35->GetMinArguments() != 1 ? \"s\" : \"\") << \".\";\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tif (VAR_35->GetMaxArguments() >= 0 && VAR_80<int>(VAR_79.size()) > VAR_35->GetMaxArguments()) {\n\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t<< \"Too many arguments. At most \" << VAR_35->GetMaxArguments()\n\t\t\t\t<< \" argument\" << (VAR_35->GetMaxArguments() != 1 ? \"s\" : \"\") << \" may be specified.\";\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_70 = VAR_35->Run(VAR_36, VAR_79);\n\t}\n\n\treturn VAR_70;\n}",
  "func_graph_path_before": "Icinga/icinga2/87adc8898900dad326534afef2f218a7e64927d2/icinga.cpp/vul/before/0.json",
  "func": "static int Main()\n{\n\tint argc = Application::GetArgC();\n\tchar **argv = Application::GetArgV();\n\n\tbool autocomplete = false;\n\tint autoindex = 0;\n\n\tif (argc >= 4 && strcmp(argv[1], \"--autocomplete\") == 0) {\n\t\tautocomplete = true;\n\n\t\ttry {\n\t\t\tautoindex = Convert::ToLong(argv[2]);\n\t\t} catch (const std::invalid_argument&) {\n\t\t\tLog(LogCritical, \"icinga-app\")\n\t\t\t\t<< \"Invalid index for --autocomplete: \" << argv[2];\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\targc -= 3;\n\t\targv += 3;\n\t}\n\n\tApplication::SetStartTime(Utility::GetTime());\n\n\t/* Set thread title. */\n\tUtility::SetThreadName(\"Main Thread\", false);\n\n\t/* Install exception handlers to make debugging easier. */\n\tApplication::InstallExceptionHandlers();\n\n#ifdef _WIN32\n\tbool builtinPaths = true;\n\n\tString binaryPrefix = Utility::GetIcingaInstallPath();\n\tString dataPrefix = Utility::GetIcingaDataPath();\n\n\tif (!binaryPrefix.IsEmpty() && !dataPrefix.IsEmpty()) {\n\t\tApplication::DeclarePrefixDir(binaryPrefix);\n\t\tApplication::DeclareSysconfDir(dataPrefix + \"\\\\etc\");\n\t\tApplication::DeclareRunDir(dataPrefix + \"\\\\var\\\\run\");\n\t\tApplication::DeclareLocalStateDir(dataPrefix + \"\\\\var\");\n\t\tApplication::DeclarePkgDataDir(binaryPrefix + \"\\\\share\\\\icinga2\");\n\t\tApplication::DeclareIncludeConfDir(binaryPrefix + \"\\\\share\\\\icinga2\\\\include\");\n\t} else {\n\t\tLog(LogWarning, \"icinga-app\", \"Registry key could not be read. Falling back to built-in paths.\");\n\n#endif /* _WIN32 */\n\t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n\t\tApplication::DeclareSysconfigFile(ICINGA_SYSCONFIGFILE);\n\t\tApplication::DeclareSysconfDir(ICINGA_SYSCONFDIR);\n\t\tApplication::DeclareRunDir(ICINGA_RUNDIR);\n\t\tApplication::DeclareLocalStateDir(ICINGA_LOCALSTATEDIR);\n\t\tApplication::DeclarePkgDataDir(ICINGA_PKGDATADIR);\n\t\tApplication::DeclareIncludeConfDir(ICINGA_INCLUDECONFDIR);\n#ifdef _WIN32\n\t}\n#endif /* _WIN32 */\n\n\tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n\n\tString icingaUser = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n\tif (icingaUser.IsEmpty())\n\t\ticingaUser = ICINGA_USER;\n\n\tString icingaGroup = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n\tif (icingaGroup.IsEmpty())\n\t\ticingaGroup = ICINGA_GROUP;\n\n\tApplication::DeclareRunAsUser(icingaUser);\n\tApplication::DeclareRunAsGroup(icingaGroup);\n\n#ifdef RLIMIT_NOFILE\n\tString rLimitFiles = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_FILES\");\n\tif (rLimitFiles.IsEmpty())\n\t\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n\telse {\n\t\ttry {\n\t\t\tApplication::DeclareRLimitFiles(Convert::ToLong(rLimitFiles));\n\t\t} catch (const std::invalid_argument& ex) {\n\t\t\tstd::cout\n\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_FILES\\\" from sysconfig: \" << ex.what() << '\\n';\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n#endif /* RLIMIT_NOFILE */\n\n#ifdef RLIMIT_NPROC\n\tString rLimitProcesses = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_PROCESSES\");\n\tif (rLimitProcesses.IsEmpty())\n\t\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n\telse {\n\t\ttry {\n\t\t\tApplication::DeclareRLimitProcesses(Convert::ToLong(rLimitProcesses));\n\t\t} catch (const std::invalid_argument& ex) {\n\t\t\tstd::cout\n\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_PROCESSES\\\" from sysconfig: \" << ex.what() << '\\n';\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n#endif /* RLIMIT_NPROC */\n\n#ifdef RLIMIT_STACK\n\tString rLimitStack = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_STACK\");\n\tif (rLimitStack.IsEmpty())\n\t\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n\telse {\n\t\ttry {\n\t\t\tApplication::DeclareRLimitStack(Convert::ToLong(rLimitStack));\n\t\t} catch (const std::invalid_argument& ex) {\n\t\t\tstd::cout\n\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_STACK\\\" from sysconfig: \" << ex.what() << '\\n';\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n#endif /* RLIMIT_STACK */\n\n\tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n\tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n\n\tScriptGlobal::Set(\"AttachDebugger\", false);\n\n\tScriptGlobal::Set(\"PlatformKernel\", Utility::GetPlatformKernel());\n\tScriptGlobal::Set(\"PlatformKernelVersion\", Utility::GetPlatformKernelVersion());\n\tScriptGlobal::Set(\"PlatformName\", Utility::GetPlatformName());\n\tScriptGlobal::Set(\"PlatformVersion\", Utility::GetPlatformVersion());\n\tScriptGlobal::Set(\"PlatformArchitecture\", Utility::GetPlatformArchitecture());\n\n\tScriptGlobal::Set(\"BuildHostName\", ICINGA_BUILD_HOST_NAME);\n\tScriptGlobal::Set(\"BuildCompilerName\", ICINGA_BUILD_COMPILER_NAME);\n\tScriptGlobal::Set(\"BuildCompilerVersion\", ICINGA_BUILD_COMPILER_VERSION);\n\n\tif (!autocomplete)\n\t\tApplication::SetResourceLimits();\n\n\tLogSeverity logLevel = Logger::GetConsoleLogSeverity();\n\tLogger::SetConsoleLogSeverity(LogWarning);\n\n\tpo::options_description visibleDesc(\"Global options\");\n\n\tvisibleDesc.add_options()\n\t\t(\"help,h\", \"show this help message\")\n\t\t(\"version,V\", \"show version information\")\n#ifndef _WIN32\n\t\t(\"color\", \"use VT100 color codes even when stdout is not a terminal\")\n#endif /* _WIN32 */\n\t\t(\"define,D\", po::value<std::vector<std::string> >(), \"define a constant\")\n\t\t(\"include,I\", po::value<std::vector<std::string> >(), \"add include search directory\")\n\t\t(\"log-level,x\", po::value<std::string>(), \"specify the log level for the console log.\\n\"\n\t\t\t\"The valid value is either debug, notice, information (default), warning, or critical\")\n\t\t(\"script-debugger,X\", \"whether to enable the script debugger\");\n\n\tpo::options_description hiddenDesc(\"Hidden options\");\n\n\thiddenDesc.add_options()\n\t\t(\"no-stack-rlimit\", \"used internally, do not specify manually\")\n\t\t(\"arg\", po::value<std::vector<std::string> >(), \"positional argument\");\n\n\tpo::positional_options_description positionalDesc;\n\tpositionalDesc.add(\"arg\", -1);\n\n\tString cmdname;\n\tCLICommand::Ptr command;\n\tpo::variables_map vm;\n\n\ttry {\n\t\tCLICommand::ParseCommand(argc, argv, visibleDesc, hiddenDesc, positionalDesc,\n\t\t\tvm, cmdname, command, autocomplete);\n\t} catch (const std::exception& ex) {\n\t\tLog(LogCritical, \"icinga-app\")\n\t\t\t<< \"Error while parsing command-line options: \" << ex.what();\n\t\treturn EXIT_FAILURE;\n\t}\n\n#ifdef _WIN32\n\tchar username[UNLEN + 1];\n\tDWORD usernameLen = UNLEN + 1;\n\tGetUserName(username, &usernameLen);\n\n\tstd::ifstream userFile;\n\tuserFile.open(Application::GetSysconfDir() + \"/icinga2/user\");\n\n\tif (userFile && command && !Application::IsProcessElevated()) {\n\t\tstd::string userLine;\n\t\tif (std::getline(userFile, userLine)) {\n\t\t\tuserFile.close();\n\n\t\t\tstd::vector<std::string> strs;\n\t\t\tboost::split(strs, userLine, boost::is_any_of(\"\\\\\"));\n\n\t\t\tif (username != strs[1] && command->GetImpersonationLevel() == ImpersonationLevel::ImpersonateIcinga\n\t\t\t\t|| command->GetImpersonationLevel() == ImpersonationLevel::ImpersonateRoot) {\n\t\t\t\tTCHAR szPath[MAX_PATH];\n\n\t\t\t\tif (GetModuleFileName(nullptr, szPath, ARRAYSIZE(szPath))) {\n\t\t\t\t\tSHELLEXECUTEINFO sei = { sizeof(sei) };\n\t\t\t\t\tsei.lpVerb = _T(\"runas\");\n\t\t\t\t\tsei.lpFile = \"cmd.exe\";\n\t\t\t\t\tsei.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;\n\t\t\t\t\tsei.nShow = SW_SHOW;\n\n\t\t\t\t\tstd::stringstream parameters;\n\n\t\t\t\t\tparameters << \"/C \" << \"\\\"\" << szPath << \"\\\"\" << \" \";\n\n\t\t\t\t\tfor (int i = 1; i < argc; i++) {\n\t\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\t\tparameters << \" \";\n\t\t\t\t\t\tparameters << argv[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tparameters << \" & SET exitcode=%errorlevel%\";\n\t\t\t\t\tparameters << \" & pause\";\n\t\t\t\t\tparameters << \" & EXIT /B %exitcode%\";\n\n\t\t\t\t\tstd::string str = parameters.str();\n\t\t\t\t\tLPCSTR cstr = str.c_str();\n\n\t\t\t\t\tsei.lpParameters = cstr;\n\n\t\t\t\t\tif (!ShellExecuteEx(&sei)) {\n\t\t\t\t\t\tDWORD dwError = GetLastError();\n\t\t\t\t\t\tif (dwError == ERROR_CANCELLED)\n\t\t\t\t\t\t\tApplication::Exit(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWaitForSingleObject(sei.hProcess, INFINITE);\n\n\t\t\t\t\t\tDWORD exitCode;\n\t\t\t\t\t\tGetExitCodeProcess(sei.hProcess, &exitCode);\n\n\t\t\t\t\t\tCloseHandle(sei.hProcess);\n\n\t\t\t\t\t\tApplication::Exit(exitCode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tuserFile.close();\n\t\t}\n\t}\n#endif /* _WIN32 */\n\n#ifndef _WIN32\n\tif (vm.count(\"color\")) {\n\t\tConsole::SetType(std::cout, Console_VT100);\n\t\tConsole::SetType(std::cerr, Console_VT100);\n\t}\n#endif /* _WIN32 */\n\n\tif (vm.count(\"define\")) {\n\t\tfor (const String& define : vm[\"define\"].as<std::vector<std::string> >()) {\n\t\t\tString key, value;\n\t\t\tsize_t pos = define.FindFirstOf('=');\n\t\t\tif (pos != String::NPos) {\n\t\t\t\tkey = define.SubStr(0, pos);\n\t\t\t\tvalue = define.SubStr(pos + 1);\n\t\t\t} else {\n\t\t\t\tkey = define;\n\t\t\t\tvalue = \"1\";\n\t\t\t}\n\t\t\tScriptGlobal::Set(key, value);\n\t\t}\n\t}\n\n\tif (vm.count(\"script-debugger\"))\n\t\tApplication::SetScriptDebuggerEnabled(true);\n\n\tApplication::DeclareStatePath(Application::GetLocalStateDir() + \"/lib/icinga2/icinga2.state\");\n\tApplication::DeclareModAttrPath(Application::GetLocalStateDir() + \"/lib/icinga2/modified-attributes.conf\");\n\tApplication::DeclareObjectsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.debug\");\n\tApplication::DeclareVarsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.vars\");\n\tApplication::DeclarePidPath(Application::GetRunDir() + \"/icinga2/icinga2.pid\");\n\n\tConfigCompiler::AddIncludeSearchDir(Application::GetIncludeConfDir());\n\n\tif (!autocomplete && vm.count(\"include\")) {\n\t\tfor (const String& includePath : vm[\"include\"].as<std::vector<std::string> >()) {\n\t\t\tConfigCompiler::AddIncludeSearchDir(includePath);\n\t\t}\n\t}\n\n\tif (!autocomplete) {\n\t\tLogger::SetConsoleLogSeverity(logLevel);\n\n\t\tif (vm.count(\"log-level\")) {\n\t\t\tString severity = vm[\"log-level\"].as<std::string>();\n\n\t\t\tLogSeverity logLevel = LogInformation;\n\t\t\ttry {\n\t\t\t\tlogLevel = Logger::StringToSeverity(severity);\n\t\t\t} catch (std::exception&) {\n\t\t\t\t/* Inform user and exit */\n\t\t\t\tLog(LogCritical, \"icinga-app\", \"Invalid log level set. Default is 'information'.\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tLogger::SetConsoleLogSeverity(logLevel);\n\t\t}\n\n\t\tif (!command || vm.count(\"help\") || vm.count(\"version\")) {\n\t\t\tString appName;\n\n\t\t\ttry {\n\t\t\t\tappName = Utility::BaseName(Application::GetArgV()[0]);\n\t\t\t} catch (const std::bad_alloc&) {\n\t\t\t\tLog(LogCritical, \"icinga-app\", \"Allocation failed.\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tif (appName.GetLength() > 3 && appName.SubStr(0, 3) == \"lt-\")\n\t\t\t\tappName = appName.SubStr(3, appName.GetLength() - 3);\n\n\t\t\tstd::cout << appName << \" \" << \"- The Icinga 2 network monitoring daemon (version: \"\n\t\t\t\t<< ConsoleColorTag(vm.count(\"version\") ? Console_ForegroundRed : Console_Normal)\n\t\t\t\t<< Application::GetAppVersion()\n#ifdef I2_DEBUG\n\t\t\t\t<< \"; debug\"\n#endif /* I2_DEBUG */\n\t\t\t\t<< ConsoleColorTag(Console_Normal)\n\t\t\t\t<< \")\" << std::endl << std::endl;\n\n\t\t\tif ((!command || vm.count(\"help\")) && !vm.count(\"version\")) {\n\t\t\t\tstd::cout << \"Usage:\" << std::endl\n\t\t\t\t\t<< \"  \" << Utility::BaseName(argv[0]) << \" \";\n\n\t\t\t\tif (cmdname.IsEmpty())\n\t\t\t\t\tstd::cout << \"<command>\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << cmdname;\n\n\t\t\t\tstd::cout << \" [<arguments>]\" << std::endl;\n\n\t\t\t\tif (command) {\n\t\t\t\t\tstd::cout << std::endl\n\t\t\t\t\t\t<< command->GetDescription() << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vm.count(\"version\")) {\n\t\t\t\tstd::cout << \"Copyright (c) 2012-2018 Icinga Development Team (https://www.icinga.com/)\" << std::endl\n\t\t\t\t\t<< \"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl2.html>\" << std::endl\n\t\t\t\t\t<< \"This is free software: you are free to change and redistribute it.\" << std::endl\n\t\t\t\t\t<< \"There is NO WARRANTY, to the extent permitted by law.\";\n\t\t\t}\n\n\t\t\tstd::cout << std::endl;\n\n\t\t\tif (vm.count(\"version\")) {\n\t\t\t\tstd::cout << std::endl;\n\n\t\t\t\tApplication::DisplayInfoMessage(std::cout, true);\n\n\t\t\t\treturn EXIT_SUCCESS;\n\t\t\t}\n\t\t}\n\n\t\tif (!command || vm.count(\"help\")) {\n\t\t\tif (!command)\n\t\t\t\tCLICommand::ShowCommands(argc, argv, nullptr);\n\n\t\t\tstd::cout << visibleDesc << std::endl\n\t\t\t\t<< \"Report bugs at <https://github.com/Icinga/icinga2>\" << std::endl\n\t\t\t\t<< \"Icinga home page: <https://www.icinga.com/>\" << std::endl;\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\n\tint rc = 1;\n\n\tif (autocomplete) {\n\t\tCLICommand::ShowCommands(argc, argv, &visibleDesc, &hiddenDesc,\n\t\t\t&GlobalArgumentCompletion, true, autoindex);\n\t\trc = 0;\n\t} else if (command) {\n\t\tLogger::DisableTimestamp(true);\n#ifndef _WIN32\n\t\tif (command->GetImpersonationLevel() == ImpersonateRoot) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tLog(LogCritical, \"cli\", \"This command must be run as root.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (command && command->GetImpersonationLevel() == ImpersonateIcinga) {\n\t\t\tString group = Application::GetRunAsGroup();\n\t\t\tString user = Application::GetRunAsUser();\n\n\t\t\terrno = 0;\n\t\t\tstruct group *gr = getgrnam(group.CStr());\n\n\t\t\tif (!gr) {\n\t\t\t\tif (errno == 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Invalid group specified: \" << group;\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"getgrnam() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getgid() != gr->gr_gid) {\n\t\t\t\tif (!vm.count(\"reload-internal\") && setgroups(0, nullptr) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setgroups() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (setgid(gr->gr_gid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setgid() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tstruct passwd *pw = getpwnam(user.CStr());\n\n\t\t\tif (!pw) {\n\t\t\t\tif (errno == 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Invalid user specified: \" << user;\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"getpwnam() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// also activate the additional groups the configured user is member of\n\t\t\tif (getuid() != pw->pw_uid) {\n\t\t\t\tif (!vm.count(\"reload-internal\") && initgroups(user.CStr(), pw->pw_gid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"initgroups() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (setuid(pw->pw_uid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setuid() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tProcess::InitializeSpawnHelper();\n#endif /* _WIN32 */\n\n\t\tstd::vector<std::string> args;\n\t\tif (vm.count(\"arg\"))\n\t\t\targs = vm[\"arg\"].as<std::vector<std::string> >();\n\n\t\tif (static_cast<int>(args.size()) < command->GetMinArguments()) {\n\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t<< \"Too few arguments. Command needs at least \" << command->GetMinArguments()\n\t\t\t\t<< \" argument\" << (command->GetMinArguments() != 1 ? \"s\" : \"\") << \".\";\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\tif (command->GetMaxArguments() >= 0 && static_cast<int>(args.size()) > command->GetMaxArguments()) {\n\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t<< \"Too many arguments. At most \" << command->GetMaxArguments()\n\t\t\t\t<< \" argument\" << (command->GetMaxArguments() != 1 ? \"s\" : \"\") << \" may be specified.\";\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\trc = command->Run(vm, args);\n\t}\n\n\treturn rc;\n}",
  "abstract_func": "static int Main()\n{\n\tint VAR_0 = Application::GetArgC();\n\tchar **VAR_1 = Application::GetArgV();\n\n\tbool VAR_2 = false;\n\tint VAR_3 = 0;\n\n\tif (VAR_0 >= 4 && strcmp(VAR_1[1], \"--autocomplete\") == 0) {\n\t\tVAR_2 = true;\n\n\t\ttry {\n\t\t\tVAR_3 = Convert::ToLong(VAR_1[2]);\n\t\t} catch (const std::invalid_argument&) {\n\t\t\tLog(VAR_4, \"icinga-app\")\n\t\t\t\t<< \"Invalid index for --autocomplete: \" << VAR_1[2];\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_0 -= 3;\n\t\tVAR_1 += 3;\n\t}\n\n\tApplication::SetStartTime(Utility::GetTime());\n\n\t/* COMMENT_0 */\n\tUtility::SetThreadName(\"Main Thread\", false);\n\n\t/* COMMENT_1 */\n\tApplication::InstallExceptionHandlers();\n\n#ifdef VAR_6\n\tbool VAR_7 = true;\n\n\tString VAR_8 = Utility::GetIcingaInstallPath();\n\tString VAR_9 = Utility::GetIcingaDataPath();\n\n\tif (!VAR_8.IsEmpty() && !VAR_9.IsEmpty()) {\n\t\tApplication::DeclarePrefixDir(VAR_8);\n\t\tApplication::DeclareSysconfDir(VAR_9 + \"\\\\etc\");\n\t\tApplication::DeclareRunDir(VAR_9 + \"\\\\var\\\\run\");\n\t\tApplication::DeclareLocalStateDir(VAR_9 + \"\\\\var\");\n\t\tApplication::DeclarePkgDataDir(VAR_8 + \"\\\\share\\\\icinga2\");\n\t\tApplication::DeclareIncludeConfDir(VAR_8 + \"\\\\share\\\\icinga2\\\\include\");\n\t} else {\n\t\tLog(VAR_10, \"icinga-app\", \"Registry key could not be read. Falling back to built-in paths.\");\n\n#endif/* COMMENT_2 */\n\t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n\t\tApplication::DeclareSysconfigFile(VAR_11);\n\t\tApplication::DeclareSysconfDir(VAR_12);\n\t\tApplication::DeclareRunDir(VAR_13);\n\t\tApplication::DeclareLocalStateDir(VAR_14);\n\t\tApplication::DeclarePkgDataDir(VAR_15);\n\t\tApplication::DeclareIncludeConfDir(VAR_16);\n#ifdef VAR_6\n\t}\n#endif /* COMMENT_3 */\n\n\tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n\n\tString VAR_17 = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n\tif (VAR_17.IsEmpty())\n\t\tVAR_17 = VAR_18;\n\n\tString VAR_19 = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n\tif (VAR_19.IsEmpty())\n\t\tVAR_19 = VAR_20;\n\n\tApplication::DeclareRunAsUser(VAR_17);\n\tApplication::DeclareRunAsGroup(VAR_19);\n\n#ifdef VAR_21\n\tString VAR_22 = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_FILES\");\n\tif (VAR_22.IsEmpty())\n\t\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n\telse {\n\t\ttry {\n\t\t\tApplication::DeclareRLimitFiles(Convert::ToLong(VAR_22));\n\t\t} catch (const std::invalid_argument& VAR_23) {\n\t\t\tstd::cout\n\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_FILES\\\" from sysconfig: \" << VAR_23.what() << '\\n';\n\t\t\treturn VAR_5;\n\t\t}\n\t}\n#endif /* COMMENT_4 */\n\n#ifdef VAR_24\n\tString VAR_25 = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_PROCESSES\");\n\tif (VAR_25.IsEmpty())\n\t\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n\telse {\n\t\ttry {\n\t\t\tApplication::DeclareRLimitProcesses(Convert::ToLong(VAR_25));\n\t\t} catch (const std::invalid_argument& VAR_23) {\n\t\t\tstd::cout\n\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_PROCESSES\\\" from sysconfig: \" << VAR_23.what() << '\\n';\n\t\t\treturn VAR_5;\n\t\t}\n\t}\n#endif /* COMMENT_5 */\n\n#ifdef VAR_26\n\tString VAR_27 = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_STACK\");\n\tif (VAR_27.IsEmpty())\n\t\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n\telse {\n\t\ttry {\n\t\t\tApplication::DeclareRLimitStack(Convert::ToLong(VAR_27));\n\t\t} catch (const std::invalid_argument& VAR_23) {\n\t\t\tstd::cout\n\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_STACK\\\" from sysconfig: \" << VAR_23.what() << '\\n';\n\t\t\treturn VAR_5;\n\t\t}\n\t}\n#endif /* COMMENT_6 */\n\n\tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n\tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n\n\tScriptGlobal::Set(\"AttachDebugger\", false);\n\n\tScriptGlobal::Set(\"PlatformKernel\", Utility::GetPlatformKernel());\n\tScriptGlobal::Set(\"PlatformKernelVersion\", Utility::GetPlatformKernelVersion());\n\tScriptGlobal::Set(\"PlatformName\", Utility::GetPlatformName());\n\tScriptGlobal::Set(\"PlatformVersion\", Utility::GetPlatformVersion());\n\tScriptGlobal::Set(\"PlatformArchitecture\", Utility::GetPlatformArchitecture());\n\n\tScriptGlobal::Set(\"BuildHostName\", VAR_28);\n\tScriptGlobal::Set(\"BuildCompilerName\", VAR_29);\n\tScriptGlobal::Set(\"BuildCompilerVersion\", VAR_30);\n\n\tif (!VAR_2)\n\t\tApplication::SetResourceLimits();\n\n\tLogSeverity VAR_31 = Logger::GetConsoleLogSeverity();\n\tLogger::SetConsoleLogSeverity(VAR_10);\n\n\tpo::options_description VAR_32(\"Global options\");\n\n\tVAR_32.add_options()\n\t\t(\"help,h\", \"show this help message\")\n\t\t(\"version,V\", \"show version information\")\n#ifndef VAR_6\n\t\t(\"color\", \"use VT100 color codes even when stdout is not a terminal\")\n#endif /* COMMENT_3 */\n\t\t(\"define,D\", po::VAR_33<std::vector<std::string> >(), \"define a constant\")\n\t\t(\"include,I\", po::VAR_33<std::vector<std::string> >(), \"add include search directory\")\n\t\t(\"log-level,x\", po::VAR_33<std::string>(), \"specify the log level for the console log.\\n\"\n\t\t\t\"The valid value is either debug, notice, information (default), warning, or critical\")\n\t\t(\"script-debugger,X\", \"whether to enable the script debugger\");\n\n\tpo::options_description VAR_34(\"Hidden options\");\n\n\tVAR_34.add_options()\n\t\t(\"no-stack-rlimit\", \"used internally, do not specify manually\")\n\t\t(\"arg\", po::VAR_33<std::vector<std::string> >(), \"positional argument\");\n\n\tpo::positional_options_description VAR_35;\n\tVAR_35.add(\"arg\", -1);\n\n\tString VAR_36;\n\tCLICommand::Ptr VAR_37;\n\tpo::variables_map VAR_38;\n\n\ttry {\n\t\tCLICommand::ParseCommand(VAR_0, VAR_1, VAR_32, VAR_34, VAR_35,\n\t\t\tVAR_38, VAR_36, VAR_37, VAR_2);\n\t} catch (const std::exception& VAR_23) {\n\t\tLog(VAR_4, \"icinga-app\")\n\t\t\t<< \"Error while parsing command-line options: \" << VAR_23.what();\n\t\treturn VAR_5;\n\t}\n\n#ifdef VAR_6\n\tchar VAR_39[VAR_40 + 1];\n\tDWORD VAR_41 = VAR_40 + 1;\n\tGetUserName(VAR_39, &VAR_41);\n\n\tstd::ifstream VAR_42;\n\tVAR_42.open(Application::GetSysconfDir() + \"/icinga2/user\");\n\n\tif (VAR_42 && VAR_37 && !Application::IsProcessElevated()) {\n\t\tstd::string VAR_43;\n\t\tif (std::getline(VAR_42, VAR_43)) {\n\t\t\tVAR_42.close();\n\n\t\t\tstd::vector<std::string> VAR_44;\n\t\t\tboost::split(VAR_44, VAR_43, boost::is_any_of(\"\\\\\"));\n\n\t\t\tif (VAR_39 != VAR_44[1] && VAR_37->GetImpersonationLevel() == ImpersonationLevel::ImpersonateIcinga\n\t\t\t\t|| VAR_37->GetImpersonationLevel() == ImpersonationLevel::ImpersonateRoot) {\n\t\t\t\tTCHAR VAR_45[VAR_46];\n\n\t\t\t\tif (GetModuleFileName(nullptr, VAR_45, ARRAYSIZE(VAR_45))) {\n\t\t\t\t\tSHELLEXECUTEINFO VAR_47 = { sizeof(VAR_47) };\n\t\t\t\t\tVAR_47.lpVerb = _T(\"runas\");\n\t\t\t\t\tVAR_47.lpFile = \"cmd.exe\";\n\t\t\t\t\tVAR_47.fMask = VAR_48 | VAR_49 | VAR_50;\n\t\t\t\t\tVAR_47.nShow = VAR_51;\n\n\t\t\t\t\tstd::stringstream VAR_52;\n\n\t\t\t\t\tVAR_52 << \"/C \" << \"\\\"\" << VAR_45 << \"\\\"\" << \" \";\n\n\t\t\t\t\tfor (int VAR_53 = 1; VAR_53 < VAR_0; VAR_53++) {\n\t\t\t\t\t\tif (VAR_53 != 1)\n\t\t\t\t\t\t\tVAR_52 << \" \";\n\t\t\t\t\t\tVAR_52 << VAR_1[VAR_53];\n\t\t\t\t\t}\n\n\t\t\t\t\tVAR_52 << \" & SET exitcode=%errorlevel%\";\n\t\t\t\t\tVAR_52 << \" & pause\";\n\t\t\t\t\tVAR_52 << \" & EXIT /B %exitcode%\";\n\n\t\t\t\t\tstd::string VAR_54 = VAR_52.str();\n\t\t\t\t\tLPCSTR VAR_55 = VAR_54.c_str();\n\n\t\t\t\t\tVAR_47.lpParameters = VAR_55;\n\n\t\t\t\t\tif (!ShellExecuteEx(&VAR_47)) {\n\t\t\t\t\t\tDWORD VAR_56 = GetLastError();\n\t\t\t\t\t\tif (VAR_56 == VAR_57)\n\t\t\t\t\t\t\tApplication::Exit(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWaitForSingleObject(VAR_47.hProcess, VAR_58);\n\n\t\t\t\t\t\tDWORD VAR_59;\n\t\t\t\t\t\tGetExitCodeProcess(VAR_47.hProcess, &VAR_59);\n\n\t\t\t\t\t\tCloseHandle(VAR_47.hProcess);\n\n\t\t\t\t\t\tApplication::Exit(VAR_59);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_42.close();\n\t\t}\n\t}\n#endif /* COMMENT_3 */\n\n#ifndef VAR_6\n\tif (VAR_38.count(\"color\")) {\n\t\tConsole::SetType(std::cout, VAR_60);\n\t\tConsole::SetType(std::cerr, VAR_60);\n\t}\n#endif /* COMMENT_3 */\n\n\tif (VAR_38.count(\"define\")) {\n\t\tfor (const String& VAR_61 : VAR_38[\"define\"].as<std::vector<std::string> >()) {\n\t\t\tString VAR_62, VAR_33;\n\t\t\tsize_t VAR_63 = VAR_61.FindFirstOf('=');\n\t\t\tif (VAR_63 != String::NPos) {\n\t\t\t\tVAR_62 = VAR_61.SubStr(0, VAR_63);\n\t\t\t\tVAR_33 = VAR_61.SubStr(VAR_63 + 1);\n\t\t\t} else {\n\t\t\t\tVAR_62 = VAR_61;\n\t\t\t\tVAR_33 = \"1\";\n\t\t\t}\n\t\t\tScriptGlobal::Set(VAR_62, VAR_33);\n\t\t}\n\t}\n\n\tif (VAR_38.count(\"script-debugger\"))\n\t\tApplication::SetScriptDebuggerEnabled(true);\n\n\tApplication::DeclareStatePath(Application::GetLocalStateDir() + \"/lib/icinga2/icinga2.state\");\n\tApplication::DeclareModAttrPath(Application::GetLocalStateDir() + \"/lib/icinga2/modified-attributes.conf\");\n\tApplication::DeclareObjectsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.debug\");\n\tApplication::DeclareVarsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.vars\");\n\tApplication::DeclarePidPath(Application::GetRunDir() + \"/icinga2/icinga2.pid\");\n\n\tConfigCompiler::AddIncludeSearchDir(Application::GetIncludeConfDir());\n\n\tif (!VAR_2 && VAR_38.count(\"include\")) {\n\t\tfor (const String& VAR_64 : VAR_38[\"include\"].as<std::vector<std::string> >()) {\n\t\t\tConfigCompiler::AddIncludeSearchDir(VAR_64);\n\t\t}\n\t}\n\n\tif (!VAR_2) {\n\t\tLogger::SetConsoleLogSeverity(VAR_31);\n\n\t\tif (VAR_38.count(\"log-level\")) {\n\t\t\tString VAR_65 = VAR_38[\"log-level\"].as<std::string>();\n\n\t\t\tLogSeverity VAR_31 = VAR_66;\n\t\t\ttry {\n\t\t\t\tVAR_31 = Logger::StringToSeverity(VAR_65);\n\t\t\t} catch (std::exception&) {\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tLog(VAR_4, \"icinga-app\", \"Invalid log level set. Default is 'information'.\");\n\t\t\t\treturn VAR_5;\n\t\t\t}\n\n\t\t\tLogger::SetConsoleLogSeverity(VAR_31);\n\t\t}\n\n\t\tif (!VAR_37 || VAR_38.count(\"help\") || VAR_38.count(\"version\")) {\n\t\t\tString VAR_67;\n\n\t\t\ttry {\n\t\t\t\tVAR_67 = Utility::BaseName(Application::GetArgV()[0]);\n\t\t\t} catch (const std::bad_alloc&) {\n\t\t\t\tLog(VAR_4, \"icinga-app\", \"Allocation failed.\");\n\t\t\t\treturn VAR_5;\n\t\t\t}\n\n\t\t\tif (VAR_67.GetLength() > 3 && VAR_67.SubStr(0, 3) == \"lt-\")\n\t\t\t\tVAR_67 = VAR_67.SubStr(3, VAR_67.GetLength() - 3);\n\n\t\t\tstd::cout << VAR_67 << \" \" << \"- The Icinga 2 network monitoring daemon (version: \"\n\t\t\t\t<< ConsoleColorTag(VAR_38.count(\"version\") ? VAR_68 : VAR_69)\n\t\t\t\t<< Application::GetAppVersion()\n#ifdef VAR_70\n\t\t\t\t<< \"; debug\"\n#endif /* COMMENT_8 */\n\t\t\t\t<< ConsoleColorTag(VAR_69)\n\t\t\t\t<< \")\" << std::endl << std::endl;\n\n\t\t\tif ((!VAR_37 || VAR_38.count(\"help\")) && !VAR_38.count(\"version\")) {\n\t\t\t\tstd::cout << \"Usage:\" << std::endl\n\t\t\t\t\t<< \"  \" << Utility::BaseName(VAR_1[0]) << \" \";\n\n\t\t\t\tif (VAR_36.IsEmpty())\n\t\t\t\t\tstd::cout << \"<command>\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << VAR_36;\n\n\t\t\t\tstd::cout << \" [<arguments>]\" << std::endl;\n\n\t\t\t\tif (VAR_37) {\n\t\t\t\t\tstd::cout << std::endl\n\t\t\t\t\t\t<< VAR_37->GetDescription() << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (VAR_38.count(\"version\")) {\n\t\t\t\tstd::cout << \"Copyright (c) 2012-2018 Icinga Development Team (https://www.icinga.com/)\" << std::endl\n\t\t\t\t\t<< \"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl2.html>\" << std::endl\n\t\t\t\t\t<< \"This is free software: you are free to change and redistribute it.\" << std::endl\n\t\t\t\t\t<< \"There is NO WARRANTY, to the extent permitted by law.\";\n\t\t\t}\n\n\t\t\tstd::cout << std::endl;\n\n\t\t\tif (VAR_38.count(\"version\")) {\n\t\t\t\tstd::cout << std::endl;\n\n\t\t\t\tApplication::DisplayInfoMessage(std::cout, true);\n\n\t\t\t\treturn VAR_71;\n\t\t\t}\n\t\t}\n\n\t\tif (!VAR_37 || VAR_38.count(\"help\")) {\n\t\t\tif (!VAR_37)\n\t\t\t\tCLICommand::ShowCommands(VAR_0, VAR_1, nullptr);\n\n\t\t\tstd::cout << VAR_32 << std::endl\n\t\t\t\t<< \"Report bugs at <https://github.com/Icinga/icinga2>\" << std::endl\n\t\t\t\t<< \"Icinga home page: <https://www.icinga.com/>\" << std::endl;\n\t\t\treturn VAR_71;\n\t\t}\n\t}\n\n\tint VAR_72 = 1;\n\n\tif (VAR_2) {\n\t\tCLICommand::ShowCommands(VAR_0, VAR_1, &VAR_32, &VAR_34,\n\t\t\t&VAR_73, true, VAR_3);\n\t\tVAR_72 = 0;\n\t} else if (VAR_37) {\n\t\tLogger::DisableTimestamp(true);\n#ifndef VAR_6\n\t\tif (VAR_37->GetImpersonationLevel() == VAR_74) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tLog(VAR_4, \"cli\", \"This command must be run as root.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (VAR_37 && VAR_37->GetImpersonationLevel() == VAR_75) {\n\t\t\tString VAR_76 = Application::GetRunAsGroup();\n\t\t\tString VAR_77 = Application::GetRunAsUser();\n\n\t\t\tVAR_78 = 0;\n\t\t\tstruct group *VAR_79 = getgrnam(group.CStr());\n\n\t\t\tif (!VAR_79) {\n\t\t\t\tif (VAR_78 == 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Invalid group specified: \" << group;\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t} else {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"getgrnam() failed with error code \" << VAR_78 << \", \\\"\" << Utility::FormatErrorNumber(VAR_78) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getgid() != VAR_79->gr_gid) {\n\t\t\t\tif (!VAR_38.count(\"reload-internal\") && setgroups(0, nullptr) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setgroups() failed with error code \" << VAR_78 << \", \\\"\" << Utility::FormatErrorNumber(VAR_78) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_77 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\n\t\t\t\tif (setgid(VAR_79->gr_gid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setgid() failed with error code \" << VAR_78 << \", \\\"\" << Utility::FormatErrorNumber(VAR_78) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_78 = 0;\n\t\t\tstruct passwd *VAR_80 = getpwnam(VAR_77.CStr());\n\n\t\t\tif (!VAR_80) {\n\t\t\t\tif (VAR_78 == 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Invalid user specified: \" << VAR_77;\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t} else {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"getpwnam() failed with error code \" << VAR_78 << \", \\\"\" << Utility::FormatErrorNumber(VAR_78) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_9 */\n\t\t\tif (getuid() != VAR_80->pw_uid) {\n\t\t\t\tif (!VAR_38.count(\"reload-internal\") && initgroups(VAR_77.CStr(), VAR_80->pw_gid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"initgroups() failed with error code \" << VAR_78 << \", \\\"\" << Utility::FormatErrorNumber(VAR_78) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_77 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\n\t\t\t\tif (setuid(VAR_80->pw_uid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setuid() failed with error code \" << VAR_78 << \", \\\"\" << Utility::FormatErrorNumber(VAR_78) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_77 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tProcess::InitializeSpawnHelper();\n#endif /* COMMENT_3 */\n\n\t\tstd::vector<std::string> VAR_81;\n\t\tif (VAR_38.count(\"arg\"))\n\t\t\tVAR_81 = VAR_38[\"arg\"].as<std::vector<std::string> >();\n\n\t\tif (VAR_82<int>(VAR_81.size()) < VAR_37->GetMinArguments()) {\n\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t<< \"Too few arguments. Command needs at least \" << VAR_37->GetMinArguments()\n\t\t\t\t<< \" argument\" << (VAR_37->GetMinArguments() != 1 ? \"s\" : \"\") << \".\";\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tif (VAR_37->GetMaxArguments() >= 0 && VAR_82<int>(VAR_81.size()) > VAR_37->GetMaxArguments()) {\n\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t<< \"Too many arguments. At most \" << VAR_37->GetMaxArguments()\n\t\t\t\t<< \" argument\" << (VAR_37->GetMaxArguments() != 1 ? \"s\" : \"\") << \" may be specified.\";\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_72 = VAR_37->Run(VAR_38, VAR_81);\n\t}\n\n\treturn VAR_72;\n}",
  "func_graph_path": "Icinga/icinga2/87adc8898900dad326534afef2f218a7e64927d2/icinga.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -59,21 +59,62 @@\n \n \tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n \n-\tString icinga_user = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n-\tif (icinga_user.IsEmpty())\n-\t\ticinga_user = ICINGA_USER;\n-\n-\tString icinga_group = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n-\tif (icinga_group.IsEmpty())\n-\t\ticinga_group = ICINGA_GROUP;\n-\n-\tApplication::DeclareRunAsUser(icinga_user);\n-\tApplication::DeclareRunAsGroup(icinga_group);\n-#ifdef __linux__\n-\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n-\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n-\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n-#endif /* __linux__ */\n+\tString icingaUser = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n+\tif (icingaUser.IsEmpty())\n+\t\ticingaUser = ICINGA_USER;\n+\n+\tString icingaGroup = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n+\tif (icingaGroup.IsEmpty())\n+\t\ticingaGroup = ICINGA_GROUP;\n+\n+\tApplication::DeclareRunAsUser(icingaUser);\n+\tApplication::DeclareRunAsGroup(icingaGroup);\n+\n+#ifdef RLIMIT_NOFILE\n+\tString rLimitFiles = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_FILES\");\n+\tif (rLimitFiles.IsEmpty())\n+\t\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n+\telse {\n+\t\ttry {\n+\t\t\tApplication::DeclareRLimitFiles(Convert::ToLong(rLimitFiles));\n+\t\t} catch (const std::invalid_argument& ex) {\n+\t\t\tstd::cout\n+\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_FILES\\\" from sysconfig: \" << ex.what() << '\\n';\n+\t\t\treturn EXIT_FAILURE;\n+\t\t}\n+\t}\n+#endif /* RLIMIT_NOFILE */\n+\n+#ifdef RLIMIT_NPROC\n+\tString rLimitProcesses = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_PROCESSES\");\n+\tif (rLimitProcesses.IsEmpty())\n+\t\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n+\telse {\n+\t\ttry {\n+\t\t\tApplication::DeclareRLimitProcesses(Convert::ToLong(rLimitProcesses));\n+\t\t} catch (const std::invalid_argument& ex) {\n+\t\t\tstd::cout\n+\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_PROCESSES\\\" from sysconfig: \" << ex.what() << '\\n';\n+\t\t\treturn EXIT_FAILURE;\n+\t\t}\n+\t}\n+#endif /* RLIMIT_NPROC */\n+\n+#ifdef RLIMIT_STACK\n+\tString rLimitStack = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_STACK\");\n+\tif (rLimitStack.IsEmpty())\n+\t\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n+\telse {\n+\t\ttry {\n+\t\t\tApplication::DeclareRLimitStack(Convert::ToLong(rLimitStack));\n+\t\t} catch (const std::invalid_argument& ex) {\n+\t\t\tstd::cout\n+\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_STACK\\\" from sysconfig: \" << ex.what() << '\\n';\n+\t\t\treturn EXIT_FAILURE;\n+\t\t}\n+\t}\n+#endif /* RLIMIT_STACK */\n+\n \tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n \tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n \n@@ -88,21 +129,6 @@\n \tScriptGlobal::Set(\"BuildHostName\", ICINGA_BUILD_HOST_NAME);\n \tScriptGlobal::Set(\"BuildCompilerName\", ICINGA_BUILD_COMPILER_NAME);\n \tScriptGlobal::Set(\"BuildCompilerVersion\", ICINGA_BUILD_COMPILER_VERSION);\n-\n-\tString initconfig = Application::GetSysconfDir() + \"/icinga2/init.conf\";\n-\n-\tif (Utility::PathExists(initconfig)) {\n-\t\tstd::unique_ptr<Expression> expression;\n-\t\ttry {\n-\t\t\texpression = ConfigCompiler::CompileFile(initconfig);\n-\n-\t\t\tScriptFrame frame(true);\n-\t\t\texpression->Evaluate(frame);\n-\t\t} catch (const std::exception& ex) {\n-\t\t\tLog(LogCritical, \"config\", DiagnosticInformation(ex));\n-\t\t\treturn EXIT_FAILURE;\n-\t\t}\n-\t}\n \n \tif (!autocomplete)\n \t\tApplication::SetResourceLimits();",
  "diff_line_info": {
    "deleted_lines": [
      "\tString icinga_user = Utility::GetFromSysconfig(\"ICINGA2_USER\");",
      "\tif (icinga_user.IsEmpty())",
      "\t\ticinga_user = ICINGA_USER;",
      "",
      "\tString icinga_group = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");",
      "\tif (icinga_group.IsEmpty())",
      "\t\ticinga_group = ICINGA_GROUP;",
      "",
      "\tApplication::DeclareRunAsUser(icinga_user);",
      "\tApplication::DeclareRunAsGroup(icinga_group);",
      "#ifdef __linux__",
      "\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());",
      "\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());",
      "\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());",
      "#endif /* __linux__ */",
      "",
      "\tString initconfig = Application::GetSysconfDir() + \"/icinga2/init.conf\";",
      "",
      "\tif (Utility::PathExists(initconfig)) {",
      "\t\tstd::unique_ptr<Expression> expression;",
      "\t\ttry {",
      "\t\t\texpression = ConfigCompiler::CompileFile(initconfig);",
      "",
      "\t\t\tScriptFrame frame(true);",
      "\t\t\texpression->Evaluate(frame);",
      "\t\t} catch (const std::exception& ex) {",
      "\t\t\tLog(LogCritical, \"config\", DiagnosticInformation(ex));",
      "\t\t\treturn EXIT_FAILURE;",
      "\t\t}",
      "\t}"
    ],
    "added_lines": [
      "\tString icingaUser = Utility::GetFromSysconfig(\"ICINGA2_USER\");",
      "\tif (icingaUser.IsEmpty())",
      "\t\ticingaUser = ICINGA_USER;",
      "",
      "\tString icingaGroup = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");",
      "\tif (icingaGroup.IsEmpty())",
      "\t\ticingaGroup = ICINGA_GROUP;",
      "",
      "\tApplication::DeclareRunAsUser(icingaUser);",
      "\tApplication::DeclareRunAsGroup(icingaGroup);",
      "",
      "#ifdef RLIMIT_NOFILE",
      "\tString rLimitFiles = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_FILES\");",
      "\tif (rLimitFiles.IsEmpty())",
      "\t\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());",
      "\telse {",
      "\t\ttry {",
      "\t\t\tApplication::DeclareRLimitFiles(Convert::ToLong(rLimitFiles));",
      "\t\t} catch (const std::invalid_argument& ex) {",
      "\t\t\tstd::cout",
      "\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_FILES\\\" from sysconfig: \" << ex.what() << '\\n';",
      "\t\t\treturn EXIT_FAILURE;",
      "\t\t}",
      "\t}",
      "#endif /* RLIMIT_NOFILE */",
      "",
      "#ifdef RLIMIT_NPROC",
      "\tString rLimitProcesses = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_PROCESSES\");",
      "\tif (rLimitProcesses.IsEmpty())",
      "\t\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());",
      "\telse {",
      "\t\ttry {",
      "\t\t\tApplication::DeclareRLimitProcesses(Convert::ToLong(rLimitProcesses));",
      "\t\t} catch (const std::invalid_argument& ex) {",
      "\t\t\tstd::cout",
      "\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_PROCESSES\\\" from sysconfig: \" << ex.what() << '\\n';",
      "\t\t\treturn EXIT_FAILURE;",
      "\t\t}",
      "\t}",
      "#endif /* RLIMIT_NPROC */",
      "",
      "#ifdef RLIMIT_STACK",
      "\tString rLimitStack = Utility::GetFromSysconfig(\"ICINGA2_RLIMIT_STACK\");",
      "\tif (rLimitStack.IsEmpty())",
      "\t\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());",
      "\telse {",
      "\t\ttry {",
      "\t\t\tApplication::DeclareRLimitStack(Convert::ToLong(rLimitStack));",
      "\t\t} catch (const std::invalid_argument& ex) {",
      "\t\t\tstd::cout",
      "\t\t\t\t<< \"Error while parsing \\\"ICINGA2_RLIMIT_STACK\\\" from sysconfig: \" << ex.what() << '\\n';",
      "\t\t\treturn EXIT_FAILURE;",
      "\t\t}",
      "\t}",
      "#endif /* RLIMIT_STACK */",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Icinga/icinga2/pull/5850",
  "description": {
    "pr_info": {
      "title": "init script security fixes",
      "number": 5850
    },
    "comment": [
      "This assumes the parent directories for run dir (usually /var/run), log dir (usually /var/log) and cache dir (usually /var/cache) are all owned by and can only be written to by root.\r\n\r\nStill a bit of testing to do before we can merge this. I'm also open for suggestions, the current solution is quite ugly\r\n\r\nrefs #5793 ",
      "Added a default for ICINGA2_LOG_DIR and quoted all the paths in case somebody has spaces or other wonky stuff in their config",
      "I'd wait on @orlitzky 's feedback.",
      "I'm skeptical about the invisible but important requirement that all of those parent directories are owned/writable only by root. If the user is supposed to verify that the permissions on the parent directories are correct, why not just have him verify that the permissions on the log directory are correct too? (I know that the answer is \"because they don't know what they're doing,\" -- that's why I'm worried about leaving it up to them to set all those variables responsibly.)\r\n\r\nAnd there's a typo \"mdkir\" in there =)\r\n\r\nI was up all night so it might be another day before I can give more intelligent feedback.",
      "It's not only that they are supposed what they are doing when they change the default location, but that we can't guarantee security when they have a custom installation :/\r\nAnother idea I had is checking if the default is unchanged and only trying to create them in that case, yet this can just as easily be exploited.",
      "I'm better now... in this stanza,\r\n\r\n```\r\nmkdir \"$ICINGA2_RUN_DIR\"/icinga2\r\nmdkir \"$ICINGA2_RUN_DIR\"/icinga2/cmd\r\nchmod 755 \"$ICINGA2_RUN_DIR\"/icinga2\r\nchmod 2750 \"$ICINGA2_RUN_DIR\"/icinga2/cmd\r\nchown -R $ICINGA2_USER:$ICINGA2_COMMAND_GROUP \"$ICINGA2_RUN_DIR\"/icinga2\r\n```\r\n\r\nthe last `chown` doesn't need to be recursive, because you know both directories were just created. That chunk of code is a bit hairy though because you don't want to mess with `icinga2/cmd` unless `icinga2` is still `root:root`. Later on there's a `test -e foo || ...` construct to create the log dir... would the same thing work here for consistency? I.e.\r\n\r\n```\r\n# The order of these two next two statements is important, because it's not safe to \"install\"\r\n# into a directory that isn't owned by root.\r\ntest -e \"$ICINGA2_RUN_DIR\"/icinga2/cmd || install -m 2750 -o $ICINGA2_USER -g $ICINGA2_COMMAND_GROUP -d \"$ICINGA2_RUN_DIR\"/icinga2/cmd\r\ntest -e \"$ICINGA2_RUN_DIR\"/icinga2 || install -m 755 -o $ICINGA2_USER -g $ICINGA2_COMMAND_GROUP -d \"$ICINGA2_RUN_DIR\"/icinga2\r\n```\r\n\r\nBut once these things are handled safely, the value of `$ICINGA2_USER` and `$ICINGA2_COMMAND_GROUP` as runtime-configurable variables is in question... if you change them, the directories (with the now-wrong owner) will already exist and will be left alone.\r\n\r\nUnrelated: is it just me, or is one of `$ICINGA2_LOG_DIR` and `$ICINGA2_LOG` redundant?",
      "Sadly no, as `install -m 755 -o $ICINGA2_USER -g $ICINGA2_COMMAND_GROUP -d \"$ICINGA2_RUN_DIR\"/icinga2` would never run since `test -e \"$ICINGA2_RUN_DIR\"/icinga2` always returns true (the previous install creates the sub directory).\r\n\r\nThe chown has to be recursive because theoretically you could delete icinga2/cmd and make it a symlink somewhere between two chowns.",
      "Oh, duh, good catch. You can always pass `--no-deference` too, to ensure that symlinks won't be followed even when not operating recursively.\r\n\r\nIt looks like I did a bad job of explaining the \"su\" problem with humor. There are a few different implementations, and not all of them treat `-s` the same (su was never part of POSIX). GNU su and OpenBSD su both treat `-s` as the login shell. FreeBSD su on the other hand does something totally different with `-s`, and Solaris doesn't have it at all.\r\n\r\nA cross-platform \"su -s\" would solve a lot of these problems straight away.\r\n\r\nAs far as I know, all of them generally work the same with `su <user>` though. The Postgres database server uses that, for example, but the trade-off is that then your user needs to have a login shell on the machine (that may be worth it, who knows).",
      "Won't work either :( We run adduser with --system in the debian packages, ie. no login shell",
      "It is quite common to modify the application user to **not** have a terminal, for security reasons. That's not just Debian as default, likely this affects more setups. There are community packages where we don't have control over, and cannot just break this. Imho.",
      "A short update on the current state of things:\r\n#5793 and the CVE seem to be fixed, but for #5991 no good solution has been found. Essentially we are looking for a way to run a few commands as the, `su` does not work because it possibly has no shell, `su -s` does not work because it's not implemented that way in a few cases.\r\n\r\nI'll make sure the CVE fix will be in the 2.8.2, even if no epiphany for #5991 strikes me before we have a release.\r\n",
      "Also fixes CVE-2018-6533"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.8  \n**Reasoning:** The patch addresses directory permissions, a security concern, though context is limited."
}