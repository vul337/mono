{
  "cve_id": "CVE-2022-48257",
  "cwe_ids": [
    "CWE-Other",
    "CWE-732"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "MisterTea/EternalTerminal",
  "commit_msg": "Logfile open mode and permission plus location configurability. (#556)\n\n* Unify logfile names and create with more secure open options and perms.\r\n\r\nFixes #555 (Tribute to Colin McRae)\r\n\r\n* Logfile location configurability.\r\n\r\nFixes #555",
  "commit_hash": "92c4c6ada445c1925a8b397f4171ca7735cbda16",
  "git_url": "https://github.com/MisterTea/EternalTerminal/commit/92c4c6ada445c1925a8b397f4171ca7735cbda16",
  "file_path": "src/terminal/TerminalClientMain.cpp",
  "func_name": "main",
  "func_before": "int main(int argc, char** argv) {\n  WinsockContext context;\n  string tmpDir = GetTempDirectory();\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    options.allow_unrecognised_options();\n    options.positional_help(\"\");\n    options.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"u,username\", \"Username\")    //\n        (\"host\", \"Remote host name\",\n         cxxopts::value<std::string>())  //\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::value<std::string>())  //\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::value<std::string>())  //\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::value<std::string>())  //\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::value<std::string>())  //\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::value<std::string>())  //\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  //\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::value<int>())                              //\n        (\"logtostdout\", \"Write log to stdout\")               //\n        (\"silent\", \"Disable logging\")                        //\n        (\"N,no-terminal\", \"Do not create a terminal\")        //\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::value<std::string>())  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>()->default_value(\"true\"))  //\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::value<std::vector<std::string>>());\n\n    options.parse_positional({\"host\"});\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"logtostdout\")) {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n    } else {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n      // Redirect std streams to a file\n      LogHandler::stderrToFile((tmpDir + \"/etclient\"));\n    }\n\n    // silent Flag, since etclient doesn't read /etc/et.cfg file\n    if (result.count(\"silent\")) {\n      defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFile(\n        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));\n\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"client-main\");\n\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    TelemetryService::create(result[\"telemetry\"].as<bool>(),\n                             tmpDir + \"/.sentry-native-et\", \"Client\");\n\n    string username = \"\";\n    if (result.count(\"username\")) {\n      username = result[\"username\"].as<string>();\n    }\n    int destinationPort = result[\"port\"].as<int>();\n    string destinationHost;\n\n    // Parse command-line argument\n    if (!result.count(\"host\")) {\n      CLOG(INFO, \"stdout\") << \"Missing host to connect to\" << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    string host_arg = result[\"host\"].as<std::string>();\n    if (host_arg.find('@') != string::npos) {\n      int i = host_arg.find('@');\n      username = host_arg.substr(0, i);\n      host_arg = host_arg.substr(i + 1);\n    }\n\n    if (host_arg.find(':') != string::npos) {\n      int colon_count = std::count(host_arg.begin(), host_arg.end(), ':');\n      if (colon_count == 1) {\n        // ipv4 or hostname with port specified\n        int port_colon_pos = host_arg.rfind(':');\n        destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n        host_arg = host_arg.substr(0, port_colon_pos);\n      } else {\n        // maybe ipv6 (colon_count >= 2)\n        if (host_arg.find(\"::\") != string::npos) {\n          // ipv6 with double colon zero abbreviation and no port\n          // leave host_arg as is\n        } else {\n          if (colon_count == 7) {\n            // ipv6, fully expanded, without port\n          } else if (colon_count == 8) {\n            // ipv6, fully expanded, with port\n            int port_colon_pos = host_arg.rfind(':');\n            destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n            host_arg = host_arg.substr(0, port_colon_pos);\n          } else {\n            CLOG(INFO, \"stdout\") << \"Invalid host positional arg: \"\n                                 << result[\"host\"].as<std::string>() << endl;\n            exit(1);\n          }\n        }\n      }\n    }\n    destinationHost = host_arg;\n    // host_alias is used for the initiating ssh call, if sshd runs on a port\n    // other than 22, either configure your .ssh/config with an alias with an\n    // overridden port or pass --ssh-option Port=<sshd_port>\n    string host_alias = destinationHost;\n\n    string jumphost =\n        result.count(\"jumphost\") ? result[\"jumphost\"].as<string>() : \"\";\n    int keepaliveDuration = result.count(\"keepalive\")\n                                ? result[\"keepalive\"].as<int>()\n                                : MAX_CLIENT_KEEP_ALIVE_DURATION;\n    if (keepaliveDuration < 1 ||\n        keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) {\n      CLOG(INFO, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << MAX_CLIENT_KEEP_ALIVE_DURATION << \" seconds\"\n                           << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    Options sshConfigOptions = {\n        NULL,  // username\n        NULL,  // host\n        NULL,  // sshdir\n        NULL,  // knownhosts\n        NULL,  // ProxyCommand\n        NULL,  // ProxyJump\n        0,     // timeout\n        0,     // port\n        0,     // StrictHostKeyChecking\n        0,     // ssh2\n        0,     // ssh1\n        NULL,  // gss_server_identity\n        NULL,  // gss_client_identity\n        0,     // gss_delegate_creds\n        0,     // forward_agent\n        NULL   // identity_agent\n    };\n\n    char* home_dir = ssh_get_user_home_dir();\n    const char* host_from_command = destinationHost.c_str();\n    ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST,\n                    destinationHost.c_str());\n    // First parse user-specific ssh config, then system-wide config.\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          string(home_dir) + USER_SSH_CONFIG_PATH);\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          SYSTEM_SSH_CONFIG_PATH);\n    LOG(INFO) << \"Parsed ssh config file, connecting to \"\n              << sshConfigOptions.host;\n    destinationHost = string(sshConfigOptions.host);\n\n    // Parse username: cmdline > sshconfig > localuser\n    if (username.empty()) {\n      if (sshConfigOptions.username) {\n        username = string(sshConfigOptions.username);\n      } else {\n        username = string(ssh_get_local_username());\n      }\n    }\n\n    // Parse jumphost: cmd > sshconfig\n    if (sshConfigOptions.ProxyJump && jumphost.length() == 0) {\n      string proxyjump = string(sshConfigOptions.ProxyJump);\n      size_t colonIndex = proxyjump.find(\":\");\n      if (colonIndex != string::npos) {\n        string userhostpair = proxyjump.substr(0, colonIndex);\n        size_t atIndex = userhostpair.find(\"@\");\n        if (atIndex != string::npos) {\n          jumphost = userhostpair.substr(atIndex + 1);\n        }\n      } else {\n        jumphost = proxyjump;\n      }\n      LOG(INFO) << \"ProxyJump found for dst in ssh config: \" << proxyjump;\n    }\n\n    bool is_jumphost = false;\n    SocketEndpoint socketEndpoint;\n    if (!jumphost.empty()) {\n      is_jumphost = true;\n      LOG(INFO) << \"Setting port to jumphost port\";\n      socketEndpoint.set_name(jumphost);\n      socketEndpoint.set_port(result[\"jport\"].as<int>());\n    } else {\n      socketEndpoint.set_name(destinationHost);\n      socketEndpoint.set_port(destinationPort);\n    }\n    shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler());\n    shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler());\n\n    if (!ping(socketEndpoint, clientSocket)) {\n      CLOG(INFO, \"stdout\") << \"Could not reach the ET server: \"\n                           << socketEndpoint.name() << \":\"\n                           << socketEndpoint.port() << endl;\n      exit(1);\n    }\n\n    int jport = result[\"jport\"].as<int>();\n    string serverFifo = \"\";\n    if (result[\"serverfifo\"].as<string>() != \"\") {\n      serverFifo = result[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> ssh_options;\n    if (result.count(\"ssh-option\")) {\n      ssh_options = result[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string etterminal_path = \"\";\n    if (result.count(\"macserver\") > 0) {\n      etterminal_path = \"/usr/local/bin/etterminal\";\n    }\n    if (result.count(\"etterminal_path\")) {\n      etterminal_path = result[\"terminal-path\"].as<string>();\n    }\n    string idpasskeypair = SshSetupHandler::SetupSsh(\n        username, destinationHost, host_alias, destinationPort, jumphost, jport,\n        result.count(\"x\") > 0, result[\"verbose\"].as<int>(), etterminal_path,\n        serverFifo, ssh_options);\n\n    string id = \"\", passkey = \"\";\n    // Trim whitespace\n    idpasskeypair.erase(idpasskeypair.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t slashIndex = idpasskeypair.find(\"/\");\n    if (slashIndex == string::npos) {\n      STFATAL << \"Invalid idPasskey id/key pair: \" << idpasskeypair;\n    } else {\n      id = idpasskeypair.substr(0, slashIndex);\n      passkey = idpasskeypair.substr(slashIndex + 1);\n    }\n    if (passkey.length() != 32) {\n      STFATAL << \"Invalid/missing passkey: \" << passkey << \" \"\n              << passkey.length();\n    }\n    shared_ptr<Console> console;\n    if (!result.count(\"N\")) {\n      console.reset(new PsuedoTerminalConsole());\n    }\n\n    bool forwardAgent = result.count(\"f\") > 0;\n    string sshSocket = \"\";\n#ifndef WIN32\n    if (sshConfigOptions.identity_agent) {\n      sshSocket = string(sshConfigOptions.identity_agent);\n    }\n    forwardAgent |= sshConfigOptions.forward_agent;\n#endif\n    if (result.count(\"ssh-socket\")) {\n      sshSocket = result[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          __FILE__, __LINE__);\n    string tunnel_arg =\n        result.count(\"tunnel\") ? result[\"tunnel\"].as<string>() : \"\";\n    string r_tunnel_arg = result.count(\"reversetunnel\")\n                              ? result[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    terminalClient.run(result.count(\"command\") ? result[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& tpe) {\n    handleParseException(tpe, options);\n  } catch (cxxopts::OptionException& oe) {\n    handleParseException(oe, options);\n  }\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
  "abstract_func_before": "int main(int VAR_0, char** VAR_1) {\n  WinsockContext VAR_2;\n  string VAR_3 = GetTempDirectory();\n\n  /* COMMENT_0 */\n  el::Configurations VAR_4 = LogHandler::setupLogHandler(&VAR_0, &VAR_1);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  /* COMMENT_1 */\n  ::signal(VAR_5, et::InterruptSignalHandler);\n\n  /* COMMENT_2 */\n  cxxopts::Options VAR_6(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    VAR_6.allow_unrecognised_options();\n    VAR_6.positional_help(\"\");\n    VAR_6.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    VAR_6.add_options()             /* COMMENT_3 */\n        (\"h,help\", \"Print help\")      /* COMMENT_3 */\n        (\"version\", \"Print version\")  /* COMMENT_3 */\n        (\"u,username\", \"Username\")    /* COMMENT_3 */\n        (\"host\", \"Remote host name\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::VAR_7<int>()->default_value(\"2022\"))  /* COMMENT_3 */\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::VAR_7<int>()->default_value(\"2022\"))  /* COMMENT_3 */\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  /* COMMENT_3 */\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  /* COMMENT_3 */\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::VAR_7<int>()->default_value(\"0\"))  /* COMMENT_3 */\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::VAR_7<int>())                              /* COMMENT_3 */\n        (\"logtostdout\", \"Write log to stdout\")               /* COMMENT_3 */\n        (\"silent\", \"Disable logging\")                        /* COMMENT_3 */\n        (\"N,no-terminal\", \"Do not create a terminal\")        /* COMMENT_3 */\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  /* COMMENT_3 */\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::VAR_7<bool>()->default_value(\"true\"))  /* COMMENT_3 */\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::VAR_7<std::string>()->default_value(\"\"))  /* COMMENT_3 */\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::VAR_7<std::vector<std::string>>());\n\n    VAR_6.parse_positional({\"host\"});\n    auto VAR_8 = VAR_6.parse(VAR_0, VAR_1);\n\n    if (VAR_8.count(\"help\")) {\n      CLOG(VAR_9, \"stdout\") << VAR_6.help({}) << VAR_10;\n      exit(0);\n    }\n\n    if (VAR_8.count(\"version\")) {\n      CLOG(VAR_9, \"stdout\") << \"et version \" << VAR_11 << VAR_10;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(VAR_8[\"verbose\"].as<int>());\n\n    if (VAR_8.count(\"logtostdout\")) {\n      VAR_4.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n    } else {\n      VAR_4.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n      /* COMMENT_4 */\n      LogHandler::stderrToFile((VAR_3 + \"/etclient\"));\n    }\n\n    /* COMMENT_5 */\n    if (VAR_8.count(\"silent\")) {\n      VAR_4.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFile(\n        &VAR_4, (VAR_3 + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));\n\n    el::Loggers::reconfigureLogger(\"default\", VAR_4);\n    /* COMMENT_6 */\n    el::Helpers::setThreadName(\"client-main\");\n\n    /* COMMENT_7 */\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    VAR_12;\n    srand(1);\n\n    TelemetryService::create(VAR_8[\"telemetry\"].as<bool>(),\n                             VAR_3 + \"/.sentry-native-et\", \"Client\");\n\n    string VAR_13 = \"\";\n    if (VAR_8.count(\"username\")) {\n      VAR_13 = VAR_8[\"username\"].as<string>();\n    }\n    int VAR_14 = VAR_8[\"port\"].as<int>();\n    string VAR_15;\n\n    /* COMMENT_8 */\n    if (!VAR_8.count(\"host\")) {\n      CLOG(VAR_9, \"stdout\") << \"Missing host to connect to\" << VAR_10;\n      CLOG(VAR_9, \"stdout\") << VAR_6.help({}) << VAR_10;\n      exit(0);\n    }\n    string VAR_16 = VAR_8[\"host\"].as<std::string>();\n    if (VAR_16.find('@') != string::npos) {\n      int VAR_17 = VAR_16.find('@');\n      VAR_13 = VAR_16.substr(0, VAR_17);\n      VAR_16 = VAR_16.substr(VAR_17 + 1);\n    }\n\n    if (VAR_16.find(':') != string::npos) {\n      int VAR_18 = std::count(VAR_16.begin(), VAR_16.end(), ':');\n      if (VAR_18 == 1) {\n        /* COMMENT_9 */\n        int VAR_19 = VAR_16.rfind(':');\n        VAR_14 = stoi(VAR_16.substr(VAR_19 + 1));\n        VAR_16 = VAR_16.substr(0, VAR_19);\n      } else {\n        /* COMMENT_10 */\n        if (VAR_16.find(\"::\") != string::npos) {\n          /* COMMENT_11 */\n          /* COMMENT_12 */\n        } else {\n          if (VAR_18 == 7) {\n            /* COMMENT_13 */\n          } else if (VAR_18 == 8) {\n            /* COMMENT_14 */\n            int VAR_19 = VAR_16.rfind(':');\n            VAR_14 = stoi(VAR_16.substr(VAR_19 + 1));\n            VAR_16 = VAR_16.substr(0, VAR_19);\n          } else {\n            CLOG(VAR_9, \"stdout\") << \"Invalid host positional arg: \"\n                                 << VAR_8[\"host\"].as<std::string>() << VAR_10;\n            exit(1);\n          }\n        }\n      }\n    }\n    VAR_15 = VAR_16;\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    /* COMMENT_17 */\n    string VAR_20 = VAR_15;\n\n    string VAR_21 =\n        VAR_8.count(\"jumphost\") ? VAR_8[\"jumphost\"].as<string>() : \"\";\n    int VAR_22 = VAR_8.count(\"keepalive\")\n                                ? VAR_8[\"keepalive\"].as<int>()\n                                : VAR_23;\n    if (VAR_22 < 1 ||\n        VAR_22 > VAR_23) {\n      CLOG(VAR_9, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << VAR_23 << \" seconds\"\n                           << VAR_10;\n      CLOG(VAR_9, \"stdout\") << VAR_6.help({}) << VAR_10;\n      exit(0);\n    }\n\n    Options VAR_24 = {\n        NULL,  /* COMMENT_18 */\n        NULL,  /* COMMENT_19 */\n        NULL,  /* COMMENT_20 */\n        NULL,  /* COMMENT_21 */\n        NULL,  /* COMMENT_22 */\n        NULL,  /* COMMENT_23 */\n        0,     /* COMMENT_24 */\n        0,     /* COMMENT_25 */\n        0,     /* COMMENT_26 */\n        0,     /* COMMENT_27 */\n        0,     /* COMMENT_28 */\n        NULL,  /* COMMENT_29 */\n        NULL,  /* COMMENT_30 */\n        0,     /* COMMENT_31 */\n        0,     /* COMMENT_32 */\n        NULL   /* COMMENT_33 */\n    };\n\n    char* VAR_25 = ssh_get_user_home_dir();\n    const char* VAR_26 = VAR_15.c_str();\n    ssh_options_set(&VAR_24, VAR_27,\n                    VAR_15.c_str());\n    /* COMMENT_34 */\n    parse_ssh_config_file(VAR_26, &VAR_24,\n                          string(VAR_25) + VAR_28);\n    parse_ssh_config_file(VAR_26, &VAR_24,\n                          VAR_29);\n    LOG(VAR_9) << \"Parsed ssh config file, connecting to \"\n              << VAR_24.host;\n    VAR_15 = string(VAR_24.host);\n\n    /* COMMENT_35 */\n    if (VAR_13.empty()) {\n      if (VAR_24.username) {\n        VAR_13 = string(VAR_24.username);\n      } else {\n        VAR_13 = string(ssh_get_local_username());\n      }\n    }\n\n    /* COMMENT_36 */\n    if (VAR_24.ProxyJump && VAR_21.length() == 0) {\n      string VAR_30 = string(VAR_24.ProxyJump);\n      size_t VAR_31 = VAR_30.find(\":\");\n      if (VAR_31 != string::npos) {\n        string VAR_32 = VAR_30.substr(0, VAR_31);\n        size_t VAR_33 = VAR_32.find(\"@\");\n        if (VAR_33 != string::npos) {\n          VAR_21 = VAR_32.substr(VAR_33 + 1);\n        }\n      } else {\n        VAR_21 = VAR_30;\n      }\n      LOG(VAR_9) << \"ProxyJump found for dst in ssh config: \" << VAR_30;\n    }\n\n    bool VAR_34 = false;\n    SocketEndpoint VAR_35;\n    if (!VAR_21.empty()) {\n      VAR_34 = true;\n      LOG(VAR_9) << \"Setting port to jumphost port\";\n      VAR_35.set_name(VAR_21);\n      VAR_35.set_port(VAR_8[\"jport\"].as<int>());\n    } else {\n      VAR_35.set_name(VAR_15);\n      VAR_35.set_port(VAR_14);\n    }\n    shared_ptr<SocketHandler> VAR_36(new TcpSocketHandler());\n    shared_ptr<SocketHandler> VAR_37(new PipeSocketHandler());\n\n    if (!ping(VAR_35, VAR_36)) {\n      CLOG(VAR_9, \"stdout\") << \"Could not reach the ET server: \"\n                           << VAR_35.name() << \":\"\n                           << VAR_35.port() << VAR_10;\n      exit(1);\n    }\n\n    int VAR_38 = VAR_8[\"jport\"].as<int>();\n    string VAR_39 = \"\";\n    if (VAR_8[\"serverfifo\"].as<string>() != \"\") {\n      VAR_39 = VAR_8[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> VAR_40;\n    if (VAR_8.count(\"ssh-option\")) {\n      VAR_40 = VAR_8[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string VAR_41 = \"\";\n    if (VAR_8.count(\"macserver\") > 0) {\n      VAR_41 = \"/usr/local/bin/etterminal\";\n    }\n    if (VAR_8.count(\"etterminal_path\")) {\n      VAR_41 = VAR_8[\"terminal-path\"].as<string>();\n    }\n    string VAR_42 = SshSetupHandler::SetupSsh(\n        VAR_13, VAR_15, VAR_20, VAR_14, VAR_21, VAR_38,\n        VAR_8.count(\"x\") > 0, VAR_8[\"verbose\"].as<int>(), VAR_41,\n        VAR_39, VAR_40);\n\n    string VAR_43 = \"\", VAR_44 = \"\";\n    /* COMMENT_37 */\n    VAR_42.erase(VAR_42.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t VAR_45 = VAR_42.find(\"/\");\n    if (VAR_45 == string::npos) {\n      VAR_46 << \"Invalid idPasskey id/key pair: \" << VAR_42;\n    } else {\n      VAR_43 = VAR_42.substr(0, VAR_45);\n      VAR_44 = VAR_42.substr(VAR_45 + 1);\n    }\n    if (VAR_44.length() != 32) {\n      VAR_46 << \"Invalid/missing passkey: \" << VAR_44 << \" \"\n              << VAR_44.length();\n    }\n    shared_ptr<Console> VAR_47;\n    if (!VAR_8.count(\"N\")) {\n      VAR_47.reset(new PsuedoTerminalConsole());\n    }\n\n    bool VAR_48 = VAR_8.count(\"f\") > 0;\n    string VAR_49 = \"\";\n#ifndef VAR_50\n    if (VAR_24.identity_agent) {\n      VAR_49 = string(VAR_24.identity_agent);\n    }\n    VAR_48 |= VAR_24.forward_agent;\n#endif\n    if (VAR_8.count(\"ssh-socket\")) {\n      VAR_49 = VAR_8[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          VAR_51, VAR_52);\n    string VAR_53 =\n        VAR_8.count(\"tunnel\") ? VAR_8[\"tunnel\"].as<string>() : \"\";\n    string VAR_54 = VAR_8.count(\"reversetunnel\")\n                              ? VAR_8[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    VAR_55.run(VAR_8.count(\"command\") ? VAR_8[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& VAR_56) {\n    handleParseException(VAR_56, VAR_6);\n  } catch (cxxopts::OptionException& VAR_57) {\n    handleParseException(VAR_57, VAR_6);\n  }\n\n#ifdef VAR_50\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  /* COMMENT_38 */\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
  "func_graph_path_before": "MisterTea/EternalTerminal/92c4c6ada445c1925a8b397f4171ca7735cbda16/TerminalClientMain.cpp/vul/before/0.json",
  "func": "int main(int argc, char** argv) {\n  WinsockContext context;\n  string tmpDir = GetTempDirectory();\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    options.allow_unrecognised_options();\n    options.positional_help(\"\");\n    options.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"u,username\", \"Username\")    //\n        (\"host\", \"Remote host name\",\n         cxxopts::value<std::string>())  //\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::value<std::string>())  //\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::value<std::string>())  //\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::value<std::string>())  //\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::value<std::string>())  //\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::value<std::string>())  //\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  //\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::value<int>())  //\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::value<std::string>()->default_value(tmpDir))  //\n        (\"logtostdout\", \"Write log to stdout\")                  //\n        (\"silent\", \"Disable logging\")                           //\n        (\"N,no-terminal\", \"Do not create a terminal\")           //\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::value<std::string>())  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>()->default_value(\"true\"))  //\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::value<std::vector<std::string>>());\n\n    options.parse_positional({\"host\"});\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    // silent Flag, since etclient doesn't read /etc/et.cfg file\n    if (result.count(\"silent\")) {\n      defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                              \"etclient\", result.count(\"logtostdout\"),\n                              !result.count(\"logtostdout\"));\n\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"client-main\");\n\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    TelemetryService::create(result[\"telemetry\"].as<bool>(),\n                             tmpDir + \"/.sentry-native-et\", \"Client\");\n\n    string username = \"\";\n    if (result.count(\"username\")) {\n      username = result[\"username\"].as<string>();\n    }\n    int destinationPort = result[\"port\"].as<int>();\n    string destinationHost;\n\n    // Parse command-line argument\n    if (!result.count(\"host\")) {\n      CLOG(INFO, \"stdout\") << \"Missing host to connect to\" << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    string host_arg = result[\"host\"].as<std::string>();\n    if (host_arg.find('@') != string::npos) {\n      int i = host_arg.find('@');\n      username = host_arg.substr(0, i);\n      host_arg = host_arg.substr(i + 1);\n    }\n\n    if (host_arg.find(':') != string::npos) {\n      int colon_count = std::count(host_arg.begin(), host_arg.end(), ':');\n      if (colon_count == 1) {\n        // ipv4 or hostname with port specified\n        int port_colon_pos = host_arg.rfind(':');\n        destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n        host_arg = host_arg.substr(0, port_colon_pos);\n      } else {\n        // maybe ipv6 (colon_count >= 2)\n        if (host_arg.find(\"::\") != string::npos) {\n          // ipv6 with double colon zero abbreviation and no port\n          // leave host_arg as is\n        } else {\n          if (colon_count == 7) {\n            // ipv6, fully expanded, without port\n          } else if (colon_count == 8) {\n            // ipv6, fully expanded, with port\n            int port_colon_pos = host_arg.rfind(':');\n            destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n            host_arg = host_arg.substr(0, port_colon_pos);\n          } else {\n            CLOG(INFO, \"stdout\") << \"Invalid host positional arg: \"\n                                 << result[\"host\"].as<std::string>() << endl;\n            exit(1);\n          }\n        }\n      }\n    }\n    destinationHost = host_arg;\n    // host_alias is used for the initiating ssh call, if sshd runs on a port\n    // other than 22, either configure your .ssh/config with an alias with an\n    // overridden port or pass --ssh-option Port=<sshd_port>\n    string host_alias = destinationHost;\n\n    string jumphost =\n        result.count(\"jumphost\") ? result[\"jumphost\"].as<string>() : \"\";\n    int keepaliveDuration = result.count(\"keepalive\")\n                                ? result[\"keepalive\"].as<int>()\n                                : MAX_CLIENT_KEEP_ALIVE_DURATION;\n    if (keepaliveDuration < 1 ||\n        keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) {\n      CLOG(INFO, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << MAX_CLIENT_KEEP_ALIVE_DURATION << \" seconds\"\n                           << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    Options sshConfigOptions = {\n        NULL,  // username\n        NULL,  // host\n        NULL,  // sshdir\n        NULL,  // knownhosts\n        NULL,  // ProxyCommand\n        NULL,  // ProxyJump\n        0,     // timeout\n        0,     // port\n        0,     // StrictHostKeyChecking\n        0,     // ssh2\n        0,     // ssh1\n        NULL,  // gss_server_identity\n        NULL,  // gss_client_identity\n        0,     // gss_delegate_creds\n        0,     // forward_agent\n        NULL   // identity_agent\n    };\n\n    char* home_dir = ssh_get_user_home_dir();\n    const char* host_from_command = destinationHost.c_str();\n    ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST,\n                    destinationHost.c_str());\n    // First parse user-specific ssh config, then system-wide config.\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          string(home_dir) + USER_SSH_CONFIG_PATH);\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          SYSTEM_SSH_CONFIG_PATH);\n    LOG(INFO) << \"Parsed ssh config file, connecting to \"\n              << sshConfigOptions.host;\n    destinationHost = string(sshConfigOptions.host);\n\n    // Parse username: cmdline > sshconfig > localuser\n    if (username.empty()) {\n      if (sshConfigOptions.username) {\n        username = string(sshConfigOptions.username);\n      } else {\n        username = string(ssh_get_local_username());\n      }\n    }\n\n    // Parse jumphost: cmd > sshconfig\n    if (sshConfigOptions.ProxyJump && jumphost.length() == 0) {\n      string proxyjump = string(sshConfigOptions.ProxyJump);\n      size_t colonIndex = proxyjump.find(\":\");\n      if (colonIndex != string::npos) {\n        string userhostpair = proxyjump.substr(0, colonIndex);\n        size_t atIndex = userhostpair.find(\"@\");\n        if (atIndex != string::npos) {\n          jumphost = userhostpair.substr(atIndex + 1);\n        }\n      } else {\n        jumphost = proxyjump;\n      }\n      LOG(INFO) << \"ProxyJump found for dst in ssh config: \" << proxyjump;\n    }\n\n    bool is_jumphost = false;\n    SocketEndpoint socketEndpoint;\n    if (!jumphost.empty()) {\n      is_jumphost = true;\n      LOG(INFO) << \"Setting port to jumphost port\";\n      socketEndpoint.set_name(jumphost);\n      socketEndpoint.set_port(result[\"jport\"].as<int>());\n    } else {\n      socketEndpoint.set_name(destinationHost);\n      socketEndpoint.set_port(destinationPort);\n    }\n    shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler());\n    shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler());\n\n    if (!ping(socketEndpoint, clientSocket)) {\n      CLOG(INFO, \"stdout\") << \"Could not reach the ET server: \"\n                           << socketEndpoint.name() << \":\"\n                           << socketEndpoint.port() << endl;\n      exit(1);\n    }\n\n    int jport = result[\"jport\"].as<int>();\n    string serverFifo = \"\";\n    if (result[\"serverfifo\"].as<string>() != \"\") {\n      serverFifo = result[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> ssh_options;\n    if (result.count(\"ssh-option\")) {\n      ssh_options = result[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string etterminal_path = \"\";\n    if (result.count(\"macserver\") > 0) {\n      etterminal_path = \"/usr/local/bin/etterminal\";\n    }\n    if (result.count(\"etterminal_path\")) {\n      etterminal_path = result[\"terminal-path\"].as<string>();\n    }\n    string idpasskeypair = SshSetupHandler::SetupSsh(\n        username, destinationHost, host_alias, destinationPort, jumphost, jport,\n        result.count(\"x\") > 0, result[\"verbose\"].as<int>(), etterminal_path,\n        serverFifo, ssh_options);\n\n    string id = \"\", passkey = \"\";\n    // Trim whitespace\n    idpasskeypair.erase(idpasskeypair.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t slashIndex = idpasskeypair.find(\"/\");\n    if (slashIndex == string::npos) {\n      STFATAL << \"Invalid idPasskey id/key pair: \" << idpasskeypair;\n    } else {\n      id = idpasskeypair.substr(0, slashIndex);\n      passkey = idpasskeypair.substr(slashIndex + 1);\n    }\n    if (passkey.length() != 32) {\n      STFATAL << \"Invalid/missing passkey: \" << passkey << \" \"\n              << passkey.length();\n    }\n    shared_ptr<Console> console;\n    if (!result.count(\"N\")) {\n      console.reset(new PsuedoTerminalConsole());\n    }\n\n    bool forwardAgent = result.count(\"f\") > 0;\n    string sshSocket = \"\";\n#ifndef WIN32\n    if (sshConfigOptions.identity_agent) {\n      sshSocket = string(sshConfigOptions.identity_agent);\n    }\n    forwardAgent |= sshConfigOptions.forward_agent;\n#endif\n    if (result.count(\"ssh-socket\")) {\n      sshSocket = result[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          __FILE__, __LINE__);\n    string tunnel_arg =\n        result.count(\"tunnel\") ? result[\"tunnel\"].as<string>() : \"\";\n    string r_tunnel_arg = result.count(\"reversetunnel\")\n                              ? result[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    terminalClient.run(result.count(\"command\") ? result[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& tpe) {\n    handleParseException(tpe, options);\n  } catch (cxxopts::OptionException& oe) {\n    handleParseException(oe, options);\n  }\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
  "abstract_func": "int main(int VAR_0, char** VAR_1) {\n  WinsockContext VAR_2;\n  string VAR_3 = GetTempDirectory();\n\n  /* COMMENT_0 */\n  el::Configurations VAR_4 = LogHandler::setupLogHandler(&VAR_0, &VAR_1);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  /* COMMENT_1 */\n  ::signal(VAR_5, et::InterruptSignalHandler);\n\n  /* COMMENT_2 */\n  cxxopts::Options VAR_6(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    VAR_6.allow_unrecognised_options();\n    VAR_6.positional_help(\"\");\n    VAR_6.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    VAR_6.add_options()             /* COMMENT_3 */\n        (\"h,help\", \"Print help\")      /* COMMENT_3 */\n        (\"version\", \"Print version\")  /* COMMENT_3 */\n        (\"u,username\", \"Username\")    /* COMMENT_3 */\n        (\"host\", \"Remote host name\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::VAR_7<int>()->default_value(\"2022\"))  /* COMMENT_3 */\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::VAR_7<int>()->default_value(\"2022\"))  /* COMMENT_3 */\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  /* COMMENT_3 */\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  /* COMMENT_3 */\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::VAR_7<int>()->default_value(\"0\"))  /* COMMENT_3 */\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::VAR_7<int>())  /* COMMENT_3 */\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::VAR_7<std::string>()->default_value(VAR_3))  /* COMMENT_3 */\n        (\"logtostdout\", \"Write log to stdout\")                  /* COMMENT_3 */\n        (\"silent\", \"Disable logging\")                           /* COMMENT_3 */\n        (\"N,no-terminal\", \"Do not create a terminal\")           /* COMMENT_3 */\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     /* COMMENT_3 */\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::VAR_7<std::string>())  /* COMMENT_3 */\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::VAR_7<bool>()->default_value(\"true\"))  /* COMMENT_3 */\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::VAR_7<std::string>()->default_value(\"\"))  /* COMMENT_3 */\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::VAR_7<std::vector<std::string>>());\n\n    VAR_6.parse_positional({\"host\"});\n    auto VAR_8 = VAR_6.parse(VAR_0, VAR_1);\n\n    if (VAR_8.count(\"help\")) {\n      CLOG(VAR_9, \"stdout\") << VAR_6.help({}) << VAR_10;\n      exit(0);\n    }\n\n    if (VAR_8.count(\"version\")) {\n      CLOG(VAR_9, \"stdout\") << \"et version \" << VAR_11 << VAR_10;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(VAR_8[\"verbose\"].as<int>());\n\n    /* COMMENT_4 */\n    if (VAR_8.count(\"silent\")) {\n      VAR_4.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFiles(&VAR_4, VAR_8[\"logdir\"].as<string>(),\n                              \"etclient\", VAR_8.count(\"logtostdout\"),\n                              !VAR_8.count(\"logtostdout\"));\n\n    el::Loggers::reconfigureLogger(\"default\", VAR_4);\n    /* COMMENT_5 */\n    el::Helpers::setThreadName(\"client-main\");\n\n    /* COMMENT_6 */\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    VAR_12;\n    srand(1);\n\n    TelemetryService::create(VAR_8[\"telemetry\"].as<bool>(),\n                             VAR_3 + \"/.sentry-native-et\", \"Client\");\n\n    string VAR_13 = \"\";\n    if (VAR_8.count(\"username\")) {\n      VAR_13 = VAR_8[\"username\"].as<string>();\n    }\n    int VAR_14 = VAR_8[\"port\"].as<int>();\n    string VAR_15;\n\n    /* COMMENT_7 */\n    if (!VAR_8.count(\"host\")) {\n      CLOG(VAR_9, \"stdout\") << \"Missing host to connect to\" << VAR_10;\n      CLOG(VAR_9, \"stdout\") << VAR_6.help({}) << VAR_10;\n      exit(0);\n    }\n    string VAR_16 = VAR_8[\"host\"].as<std::string>();\n    if (VAR_16.find('@') != string::npos) {\n      int VAR_17 = VAR_16.find('@');\n      VAR_13 = VAR_16.substr(0, VAR_17);\n      VAR_16 = VAR_16.substr(VAR_17 + 1);\n    }\n\n    if (VAR_16.find(':') != string::npos) {\n      int VAR_18 = std::count(VAR_16.begin(), VAR_16.end(), ':');\n      if (VAR_18 == 1) {\n        /* COMMENT_8 */\n        int VAR_19 = VAR_16.rfind(':');\n        VAR_14 = stoi(VAR_16.substr(VAR_19 + 1));\n        VAR_16 = VAR_16.substr(0, VAR_19);\n      } else {\n        /* COMMENT_9 */\n        if (VAR_16.find(\"::\") != string::npos) {\n          /* COMMENT_10 */\n          /* COMMENT_11 */\n        } else {\n          if (VAR_18 == 7) {\n            /* COMMENT_12 */\n          } else if (VAR_18 == 8) {\n            /* COMMENT_13 */\n            int VAR_19 = VAR_16.rfind(':');\n            VAR_14 = stoi(VAR_16.substr(VAR_19 + 1));\n            VAR_16 = VAR_16.substr(0, VAR_19);\n          } else {\n            CLOG(VAR_9, \"stdout\") << \"Invalid host positional arg: \"\n                                 << VAR_8[\"host\"].as<std::string>() << VAR_10;\n            exit(1);\n          }\n        }\n      }\n    }\n    VAR_15 = VAR_16;\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    string VAR_20 = VAR_15;\n\n    string VAR_21 =\n        VAR_8.count(\"jumphost\") ? VAR_8[\"jumphost\"].as<string>() : \"\";\n    int VAR_22 = VAR_8.count(\"keepalive\")\n                                ? VAR_8[\"keepalive\"].as<int>()\n                                : VAR_23;\n    if (VAR_22 < 1 ||\n        VAR_22 > VAR_23) {\n      CLOG(VAR_9, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << VAR_23 << \" seconds\"\n                           << VAR_10;\n      CLOG(VAR_9, \"stdout\") << VAR_6.help({}) << VAR_10;\n      exit(0);\n    }\n\n    Options VAR_24 = {\n        NULL,  /* COMMENT_17 */\n        NULL,  /* COMMENT_18 */\n        NULL,  /* COMMENT_19 */\n        NULL,  /* COMMENT_20 */\n        NULL,  /* COMMENT_21 */\n        NULL,  /* COMMENT_22 */\n        0,     /* COMMENT_23 */\n        0,     /* COMMENT_24 */\n        0,     /* COMMENT_25 */\n        0,     /* COMMENT_26 */\n        0,     /* COMMENT_27 */\n        NULL,  /* COMMENT_28 */\n        NULL,  /* COMMENT_29 */\n        0,     /* COMMENT_30 */\n        0,     /* COMMENT_31 */\n        NULL   /* COMMENT_32 */\n    };\n\n    char* VAR_25 = ssh_get_user_home_dir();\n    const char* VAR_26 = VAR_15.c_str();\n    ssh_options_set(&VAR_24, VAR_27,\n                    VAR_15.c_str());\n    /* COMMENT_33 */\n    parse_ssh_config_file(VAR_26, &VAR_24,\n                          string(VAR_25) + VAR_28);\n    parse_ssh_config_file(VAR_26, &VAR_24,\n                          VAR_29);\n    LOG(VAR_9) << \"Parsed ssh config file, connecting to \"\n              << VAR_24.host;\n    VAR_15 = string(VAR_24.host);\n\n    /* COMMENT_34 */\n    if (VAR_13.empty()) {\n      if (VAR_24.username) {\n        VAR_13 = string(VAR_24.username);\n      } else {\n        VAR_13 = string(ssh_get_local_username());\n      }\n    }\n\n    /* COMMENT_35 */\n    if (VAR_24.ProxyJump && VAR_21.length() == 0) {\n      string VAR_30 = string(VAR_24.ProxyJump);\n      size_t VAR_31 = VAR_30.find(\":\");\n      if (VAR_31 != string::npos) {\n        string VAR_32 = VAR_30.substr(0, VAR_31);\n        size_t VAR_33 = VAR_32.find(\"@\");\n        if (VAR_33 != string::npos) {\n          VAR_21 = VAR_32.substr(VAR_33 + 1);\n        }\n      } else {\n        VAR_21 = VAR_30;\n      }\n      LOG(VAR_9) << \"ProxyJump found for dst in ssh config: \" << VAR_30;\n    }\n\n    bool VAR_34 = false;\n    SocketEndpoint VAR_35;\n    if (!VAR_21.empty()) {\n      VAR_34 = true;\n      LOG(VAR_9) << \"Setting port to jumphost port\";\n      VAR_35.set_name(VAR_21);\n      VAR_35.set_port(VAR_8[\"jport\"].as<int>());\n    } else {\n      VAR_35.set_name(VAR_15);\n      VAR_35.set_port(VAR_14);\n    }\n    shared_ptr<SocketHandler> VAR_36(new TcpSocketHandler());\n    shared_ptr<SocketHandler> VAR_37(new PipeSocketHandler());\n\n    if (!ping(VAR_35, VAR_36)) {\n      CLOG(VAR_9, \"stdout\") << \"Could not reach the ET server: \"\n                           << VAR_35.name() << \":\"\n                           << VAR_35.port() << VAR_10;\n      exit(1);\n    }\n\n    int VAR_38 = VAR_8[\"jport\"].as<int>();\n    string VAR_39 = \"\";\n    if (VAR_8[\"serverfifo\"].as<string>() != \"\") {\n      VAR_39 = VAR_8[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> VAR_40;\n    if (VAR_8.count(\"ssh-option\")) {\n      VAR_40 = VAR_8[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string VAR_41 = \"\";\n    if (VAR_8.count(\"macserver\") > 0) {\n      VAR_41 = \"/usr/local/bin/etterminal\";\n    }\n    if (VAR_8.count(\"etterminal_path\")) {\n      VAR_41 = VAR_8[\"terminal-path\"].as<string>();\n    }\n    string VAR_42 = SshSetupHandler::SetupSsh(\n        VAR_13, VAR_15, VAR_20, VAR_14, VAR_21, VAR_38,\n        VAR_8.count(\"x\") > 0, VAR_8[\"verbose\"].as<int>(), VAR_41,\n        VAR_39, VAR_40);\n\n    string VAR_43 = \"\", VAR_44 = \"\";\n    /* COMMENT_36 */\n    VAR_42.erase(VAR_42.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t VAR_45 = VAR_42.find(\"/\");\n    if (VAR_45 == string::npos) {\n      VAR_46 << \"Invalid idPasskey id/key pair: \" << VAR_42;\n    } else {\n      VAR_43 = VAR_42.substr(0, VAR_45);\n      VAR_44 = VAR_42.substr(VAR_45 + 1);\n    }\n    if (VAR_44.length() != 32) {\n      VAR_46 << \"Invalid/missing passkey: \" << VAR_44 << \" \"\n              << VAR_44.length();\n    }\n    shared_ptr<Console> VAR_47;\n    if (!VAR_8.count(\"N\")) {\n      VAR_47.reset(new PsuedoTerminalConsole());\n    }\n\n    bool VAR_48 = VAR_8.count(\"f\") > 0;\n    string VAR_49 = \"\";\n#ifndef VAR_50\n    if (VAR_24.identity_agent) {\n      VAR_49 = string(VAR_24.identity_agent);\n    }\n    VAR_48 |= VAR_24.forward_agent;\n#endif\n    if (VAR_8.count(\"ssh-socket\")) {\n      VAR_49 = VAR_8[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          VAR_51, VAR_52);\n    string VAR_53 =\n        VAR_8.count(\"tunnel\") ? VAR_8[\"tunnel\"].as<string>() : \"\";\n    string VAR_54 = VAR_8.count(\"reversetunnel\")\n                              ? VAR_8[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    VAR_55.run(VAR_8.count(\"command\") ? VAR_8[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& VAR_56) {\n    handleParseException(VAR_56, VAR_6);\n  } catch (cxxopts::OptionException& VAR_57) {\n    handleParseException(VAR_57, VAR_6);\n  }\n\n#ifdef VAR_50\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  /* COMMENT_37 */\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
  "func_graph_path": "MisterTea/EternalTerminal/92c4c6ada445c1925a8b397f4171ca7735cbda16/TerminalClientMain.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -57,11 +57,13 @@\n         (\"v,verbose\", \"Enable verbose logging\",\n          cxxopts::value<int>()->default_value(\"0\"))  //\n         (\"k,keepalive\", \"Client keepalive duration in seconds\",\n-         cxxopts::value<int>())                              //\n-        (\"logtostdout\", \"Write log to stdout\")               //\n-        (\"silent\", \"Disable logging\")                        //\n-        (\"N,no-terminal\", \"Do not create a terminal\")        //\n-        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //\n+         cxxopts::value<int>())  //\n+        (\"l,logdir\", \"Base directory for log files.\",\n+         cxxopts::value<std::string>()->default_value(tmpDir))  //\n+        (\"logtostdout\", \"Write log to stdout\")                  //\n+        (\"silent\", \"Disable logging\")                           //\n+        (\"N,no-terminal\", \"Do not create a terminal\")           //\n+        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //\n         (\"ssh-socket\", \"The ssh-agent socket to forward\",\n          cxxopts::value<std::string>())  //\n         (\"telemetry\",\n@@ -88,21 +90,14 @@\n \n     el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n \n-    if (result.count(\"logtostdout\")) {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n-    } else {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n-      // Redirect std streams to a file\n-      LogHandler::stderrToFile((tmpDir + \"/etclient\"));\n-    }\n-\n     // silent Flag, since etclient doesn't read /etc/et.cfg file\n     if (result.count(\"silent\")) {\n       defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n     }\n \n-    LogHandler::setupLogFile(\n-        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));\n+    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n+                              \"etclient\", result.count(\"logtostdout\"),\n+                              !result.count(\"logtostdout\"));\n \n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
  "diff_line_info": {
    "deleted_lines": [
      "         cxxopts::value<int>())                              //",
      "        (\"logtostdout\", \"Write log to stdout\")               //",
      "        (\"silent\", \"Disable logging\")                        //",
      "        (\"N,no-terminal\", \"Do not create a terminal\")        //",
      "        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //",
      "    if (result.count(\"logtostdout\")) {",
      "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");",
      "    } else {",
      "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
      "      // Redirect std streams to a file",
      "      LogHandler::stderrToFile((tmpDir + \"/etclient\"));",
      "    }",
      "",
      "    LogHandler::setupLogFile(",
      "        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));"
    ],
    "added_lines": [
      "         cxxopts::value<int>())  //",
      "        (\"l,logdir\", \"Base directory for log files.\",",
      "         cxxopts::value<std::string>()->default_value(tmpDir))  //",
      "        (\"logtostdout\", \"Write log to stdout\")                  //",
      "        (\"silent\", \"Disable logging\")                           //",
      "        (\"N,no-terminal\", \"Do not create a terminal\")           //",
      "        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //",
      "    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),",
      "                              \"etclient\", result.count(\"logtostdout\"),",
      "                              !result.count(\"logtostdout\"));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/MisterTea/EternalTerminal/pull/556",
  "description": {
    "pr_info": {
      "title": "Logfile open mode and permission plus location configurability.",
      "number": 556
    },
    "comment": [
      "This addresses #555\r\n\r\nTesting:\r\n```\r\n❯ ./et --help                                                                                                                                                                                                       11:50:47  12.20.22\r\nRemote shell for the busy and impatient\r\nUsage:\r\n  et [OPTION...] [user@]host[:port]\r\n\r\n  Note that 'host' can be a hostname or ipv4 address with or without a port\r\n  or an ipv6 address. If the ipv6 address is abbreviated with :: then it must\r\n  be specfied without a port (use -p,--port).\r\n\r\n  -h, --help                 Print help\r\n      --version              Print version\r\n  -u, --username             Username\r\n      --host arg             Remote host name\r\n  -p, --port arg             Remote machine etserver port (default: 2022)\r\n  -c, --command arg          Run command on connect\r\n      --terminal-path arg    Path to etterminal on server side. Use if\r\n                             etterminal is not on the system path.\r\n  -t, --tunnel arg           Tunnel: Array of source:destination ports or\r\n                             srcStart-srcEnd:dstStart-dstEnd (inclusive) port\r\n                             ranges (e.g. 10080:80,10443:443,\r\n                             10090-10092:8000-8002)\r\n  -r, --reversetunnel arg    Reverse Tunnel: Array of source:destination\r\n                             ports or srcStart-srcEnd:dstStart-dstEnd (inclusive)\r\n                             port ranges\r\n      --jumphost arg         jumphost between localhost and destination\r\n      --jport arg            Jumphost machine port (default: 2022)\r\n  -x, --kill-other-sessions  kill all old sessions belonging to the user\r\n      --macserver            Set when connecting to an macOS server.  Sets\r\n                             --terminal-path=/usr/local/bin/etterminal\r\n  -v, --verbose arg          Enable verbose logging (default: 0)\r\n  -k, --keepalive arg        Client keepalive duration in seconds\r\n  -l, --logdir arg           Base directory for log files. (default: /tmp/)\r\n...\r\n```\r\n\r\n```\r\n ✔  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ls -la /tmp/etclient*                                                                                                                                                                                             11:48:40  12.20.22\r\nzsh: no matches found: /tmp/etclient*\r\n ↵ 1  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ./et dev:8080                                                                                                                                                                                                     11:48:51  12.20.22\r\nCould not reach the ET server: dev:8080\r\n\r\n ↵ 1  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ls -la /tmp/etclient*                                                                                                                                                                                             11:49:13  12.20.22\r\n-rw------- 1 jwshort users 4416 Dec 20 11:49 /tmp/etclient-2022-12-20_11-49-09.log\r\n-rw------- 1 jwshort users   52 Dec 20 11:49 /tmp/etclient-stderr-2022-12-20_11-49-09.log\r\n```\r\n\r\n```\r\n ✔  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ls -la ~/etclient-*                                                                                                                                                                                               11:49:16  12.20.22\r\nzsh: no matches found: /home/jwshort/etclient-*\r\n ↵ 1  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ./et dev:8080 --logdir ~/                                                                                                                                                                                         11:50:21  12.20.22\r\nCould not reach the ET server: dev:8080\r\n\r\n ↵ 1  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ls -la ~/etclient-*                                                                                                                                                                                               11:50:44  12.20.22\r\n-rw------- 1 jwshort users 4416 Dec 20 11:50 /home/jwshort/etclient-2022-12-20_11-50-41.log\r\n-rw------- 1 jwshort users   52 Dec 20 11:50 /home/jwshort/etclient-stderr-2022-12-20_11-50-41.log\r\n```\r\n\r\n```\r\n ✔  ⚙  jwshort@  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ls -la /tmp/etserver-*                                                                                                                                                                                            11:53:45  12.20.22\r\nzsh: no matches found: /tmp/etserver-*\r\n ↵ 1  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ cat et.cfg                                                                                                                                                                                                        11:53:46  12.20.22\r\n; et.cfg : Config file for Eternal Terminal\r\n;\r\n\r\n[Networking]\r\nport = 2022\r\n# bind_ip = 0.0.0.0\r\n\r\n[Debug]\r\nverbose = 0\r\nsilent = 0\r\nlogsize = 20971520\r\ntelemetry = 1\r\n ✔  ⚙  jwshort ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ./etserver --cfgfile=et.cfg                                                                                                                                                                                       11:53:54  12.20.22\r\n^C\r\nGot interrupt (perhaps ctrl+c?): 2.  Exiting.\r\n\r\n ↵ 2  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ls -la /tmp/etserver-*                                                                                                                                                                                            11:54:25  12.20.22\r\n-rw------- 1 jwshort users 393 Dec 20 11:54 /tmp/etserver-2022-12-20_11-54-20.log\r\n-rw------- 1 jwshort users  73 Dec 20 11:54 /tmp/etserver-stderr-2022-12-20_11-54-20.log\r\n ✔  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ vim et.cfg                                                                                                                                                                                                        11:54:27  12.20.22\r\n ✔  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ cat et.cfg                                                                                                                                                                                                        11:54:42  12.20.22\r\n; et.cfg : Config file for Eternal Terminal\r\n;\r\n\r\n[Networking]\r\nport = 2022\r\n# bind_ip = 0.0.0.0\r\n\r\n[Debug]\r\nverbose = 0\r\nsilent = 0\r\nlogsize = 20971520\r\nlogdirectory = /home/jwshort\r\ntelemetry = 1\r\n ✔  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ./etserver --cfgfile=et.cfg                                                                                                                                                                                       11:54:44  12.20.22\r\n^C\r\nGot interrupt (perhaps ctrl+c?): 2.  Exiting.\r\n\r\n ↵ 2  ⚙  jwshort  ~/git/EternalTerminal/build   logfile_location_perms \r\n ❯ ls -la ~/etserver-*                                                                                                                                                                                               11:54:55  12.20.22\r\n-rw------- 1 jwshort users 393 Dec 20 11:54 /home/jwshort/etserver-2022-12-20_11-54-48.log\r\n-rw------- 1 jwshort users  73 Dec 20 11:54 /home/jwshort/etserver-stderr-2022-12-20_11-54-48.log\r\n```\r\n\r\n",
      "# [Codecov](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci) Report\nBase: **73.02**% // Head: **72.97**% // Decreases project coverage by **`-0.05%`** :warning:\n> Coverage data is based on head [(`04e64d4`)](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci) compared to base [(`7289e04`)](https://codecov.io/gh/MisterTea/EternalTerminal/commit/7289e04475a8418d376cbc7ecbcc580e23c42bb7?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci).\n> Patch coverage: 76.31% of modified lines in pull request are covered.\n\n<details><summary>Additional details and impacted files</summary>\n\n\n```diff\n@@            Coverage Diff             @@\n##           master     #556      +/-   ##\n==========================================\n- Coverage   73.02%   72.97%   -0.06%     \n==========================================\n  Files          50       50              \n  Lines        3029     3049      +20     \n==========================================\n+ Hits         2212     2225      +13     \n- Misses        817      824       +7     \n```\n\n\n| [Impacted Files](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci) | Coverage Δ | |\n|---|---|---|\n| [src/base/LogHandler.cpp](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci#diff-c3JjL2Jhc2UvTG9nSGFuZGxlci5jcHA=) | `81.35% <74.28%> (+18.19%)` | :arrow_up: |\n| [test/Main.cpp](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci#diff-dGVzdC9NYWluLmNwcA==) | `100.00% <100.00%> (ø)` | |\n| [src/base/ServerConnection.cpp](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci#diff-c3JjL2Jhc2UvU2VydmVyQ29ubmVjdGlvbi5jcHA=) | `70.75% <0.00%> (-6.61%)` | :arrow_down: |\n| [src/terminal/UserTerminalHandler.cpp](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci#diff-c3JjL3Rlcm1pbmFsL1VzZXJUZXJtaW5hbEhhbmRsZXIuY3Bw) | `70.00% <0.00%> (-1.27%)` | :arrow_down: |\n| [src/base/Connection.cpp](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci#diff-c3JjL2Jhc2UvQ29ubmVjdGlvbi5jcHA=) | `87.82% <0.00%> (-0.87%)` | :arrow_down: |\n\nHelp us with your feedback. Take ten seconds to tell us [how you rate us](https://about.codecov.io/nps?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci). Have a feature suggestion? [Share it here.](https://app.codecov.io/gh/feedback/?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci)\n\n</details>\n\n[:umbrella: View full report at Codecov](https://codecov.io/gh/MisterTea/EternalTerminal/pull/556?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci).   \n:loudspeaker: Do you have feedback about the report comment? [Let us know in this issue](https://about.codecov.io/codecov-pr-comment-feedback/?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=Jason+Gauci).\n",
      "Hi, I saw there were two CVEs assigned to this: CVE-2022-48257 and CVE-2022-48258.\r\n\r\nIs there a reason why this is not merged yet? Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\nThe patch addresses security aspects like logfile permissions and locations, which can mitigate information disclosure risks. The changes align with improving security by controlling logging access. While no CVE is cited, the intent is clear. \n\n**Confidence Explanation:** High confidence due to focus on security aspects, though slightly less due to lack of explicit CVE reference."
}