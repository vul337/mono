{
  "cve_id": "CVE-2022-21700",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "micronaut-projects/micronaut-core",
  "commit_msg": "Use ConversionContext constants where possible instead of class (#2356)\n\nChanges\r\n-------\r\n * Added ArgumentConversionContext constants in ConversionContext\r\n * Replaced Argument.of and use of argument classes with\r\nConversionContext constants where possible\r\n * Added getFirst method in ConvertibleMultiValues that accepts\r\nArgumentConversionContent parameter\r\n\r\nPartially addresses issue #2355",
  "commit_hash": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
  "git_url": "https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
  "file_path": "http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java",
  "func_name": "buildSubscriber",
  "func_before": "private Subscriber<Object> buildSubscriber(NettyHttpRequest<?> request,\n                                               ChannelHandlerContext context,\n                                               RouteMatch<?> finalRoute) {\n        return new CompletionAwareSubscriber<Object>() {\n            Boolean alwaysAddContent = request.getContentType()\n                    .map(type -> type.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE))\n                    .orElse(false);\n            RouteMatch<?> routeMatch = finalRoute;\n            AtomicBoolean executed = new AtomicBoolean(false);\n            AtomicLong pressureRequested = new AtomicLong(0);\n            ConcurrentHashMap<String, UnicastProcessor> subjects = new ConcurrentHashMap<>();\n            ConcurrentHashMap<Integer, HttpDataReference> dataReferences = new ConcurrentHashMap<>();\n            ConversionService conversionService = ConversionService.SHARED;\n            Subscription s;\n            LongConsumer onRequest = (num) -> pressureRequested.updateAndGet((p) -> {\n                long newVal = p - num;\n                if (newVal < 0) {\n                    s.request(num - p);\n                    return 0;\n                } else {\n                    return newVal;\n                }\n            });\n\n            Flowable processFlowable(Flowable flowable, Integer dataKey, boolean controlsFlow) {\n                if (controlsFlow) {\n                    flowable = flowable.doOnRequest(onRequest);\n                }\n                return flowable\n                        .doAfterTerminate(() -> {\n                            if (controlsFlow) {\n                                HttpDataReference dataReference = dataReferences.get(dataKey);\n                                dataReference.destroy();\n                            }\n                        });\n            }\n\n            @Override\n            protected void doOnSubscribe(Subscription subscription) {\n                this.s = subscription;\n                subscription.request(1);\n            }\n\n            @Override\n            protected void doOnNext(Object message) {\n                boolean executed = this.executed.get();\n                if (message instanceof ByteBufHolder) {\n                    if (message instanceof HttpData) {\n                        HttpData data = (HttpData) message;\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Received HTTP Data for request [{}]: {}\", request, message);\n                        }\n\n                        String name = data.getName();\n                        Optional<Argument<?>> requiredInput = routeMatch.getRequiredInput(name);\n\n                        if (requiredInput.isPresent()) {\n                            Argument<?> argument = requiredInput.get();\n                            Supplier<Object> value;\n                            boolean isPublisher = Publishers.isConvertibleToPublisher(argument.getType());\n                            boolean chunkedProcessing = false;\n\n                            if (isPublisher) {\n                                Integer dataKey = System.identityHashCode(data);\n                                HttpDataReference dataReference = dataReferences.computeIfAbsent(dataKey, (key) -> {\n                                    return new HttpDataReference(data);\n                                });\n                                Argument typeVariable;\n\n                                if (StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n                                    typeVariable = Argument.of(PartData.class);\n                                } else {\n                                    typeVariable = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                }\n                                Class typeVariableType = typeVariable.getType();\n\n                                UnicastProcessor namedSubject = subjects.computeIfAbsent(name, (key) -> UnicastProcessor.create());\n\n                                chunkedProcessing = PartData.class.equals(typeVariableType) ||\n                                        Publishers.isConvertibleToPublisher(typeVariableType) ||\n                                        ClassUtils.isJavaLangType(typeVariableType);\n\n                                if (Publishers.isConvertibleToPublisher(typeVariableType)) {\n                                    boolean streamingFileUpload = StreamingFileUpload.class.isAssignableFrom(typeVariableType);\n                                    if (streamingFileUpload) {\n                                        typeVariable = Argument.of(PartData.class);\n                                    } else {\n                                        typeVariable = typeVariable.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                    }\n                                    dataReference.subject.getAndUpdate(subject -> {\n                                        if (subject == null) {\n                                            UnicastProcessor childSubject = UnicastProcessor.create();\n                                            Flowable flowable = processFlowable(childSubject, dataKey, true);\n                                            if (streamingFileUpload && data instanceof FileUpload) {\n                                                namedSubject.onNext(new NettyStreamingFileUpload(\n                                                        (FileUpload) data,\n                                                        serverConfiguration.getMultipart(),\n                                                        ioExecutor,\n                                                        flowable));\n                                            } else {\n                                                namedSubject.onNext(flowable);\n                                            }\n\n                                            return childSubject;\n                                        }\n                                        return subject;\n                                    });\n\n                                }\n\n                                UnicastProcessor subject = Optional.ofNullable(dataReference.subject.get()).orElse(namedSubject);\n\n                                Object part = data;\n\n                                if (chunkedProcessing) {\n                                    HttpDataReference.Component component = dataReference.addComponent((e) -> {\n                                        subject.onError(e);\n                                        s.cancel();\n                                    });\n                                    if (component == null) {\n                                        return;\n                                    }\n                                    part = new NettyPartData(dataReference, component);\n                                }\n\n                                if (data instanceof FileUpload &&\n                                        StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n                                    dataReference.upload.getAndUpdate(upload -> {\n                                        if (upload == null) {\n                                            return new NettyStreamingFileUpload(\n                                                    (FileUpload) data,\n                                                    serverConfiguration.getMultipart(),\n                                                    ioExecutor,\n                                                    processFlowable(subject, dataKey, true));\n                                        }\n                                        return upload;\n                                    });\n                                }\n\n                                Optional<?> converted = conversionService.convert(part, typeVariable);\n\n                                converted.ifPresent(subject::onNext);\n\n                                if (data.isCompleted() && chunkedProcessing) {\n                                    subject.onComplete();\n                                }\n\n                                value = () -> {\n                                    StreamingFileUpload upload = dataReference.upload.get();\n                                    if (upload != null) {\n                                        return upload;\n                                    } else {\n                                        return processFlowable(namedSubject, dataKey, dataReference.subject.get() == null);\n                                    }\n                                };\n\n                            } else {\n                                if (data instanceof Attribute && !data.isCompleted()) {\n                                    request.addContent(data);\n                                    s.request(1);\n                                    return;\n                                } else {\n                                    value = () -> {\n                                        if (data.refCnt() > 0) {\n                                            return data;\n                                        } else {\n                                            return null;\n                                        }\n                                    };\n                                }\n                            }\n\n                            if (!executed) {\n                                String argumentName = argument.getName();\n                                if (!routeMatch.isSatisfied(argumentName)) {\n                                    routeMatch = routeMatch.fulfill(Collections.singletonMap(argumentName, value.get()));\n                                }\n                                if (isPublisher && chunkedProcessing) {\n                                    //accounting for the previous request\n                                    pressureRequested.incrementAndGet();\n                                }\n                                if (routeMatch.isExecutable() || message instanceof LastHttpContent) {\n                                    executeRoute();\n                                    executed = true;\n                                }\n                            }\n\n                            if (alwaysAddContent) {\n                                request.addContent(data);\n                            }\n\n                            if (!executed || !chunkedProcessing) {\n                                s.request(1);\n                            }\n\n                        } else {\n                            request.addContent(data);\n                            s.request(1);\n                        }\n                    } else {\n                        request.addContent((ByteBufHolder) message);\n                        s.request(1);\n                    }\n                } else {\n                    ((NettyHttpRequest) request).setBody(message);\n                    s.request(1);\n                }\n            }\n\n            @Override\n            protected void doOnError(Throwable t) {\n                try {\n                    s.cancel();\n                    exceptionCaught(context, t);\n                } catch (Exception e) {\n                    // should never happen\n                    writeDefaultErrorResponse(context, request, e);\n                }\n            }\n\n            @Override\n            protected void doOnComplete() {\n                for (UnicastProcessor subject: subjects.values()) {\n                    if (!subject.hasComplete()) {\n                        subject.onComplete();\n                    }\n                }\n                executeRoute();\n            }\n\n            private void executeRoute() {\n                if (executed.compareAndSet(false, true)) {\n                    try {\n                        routeMatch = prepareRouteForExecution(routeMatch, request);\n                        routeMatch.execute();\n                    } catch (Exception e) {\n                        context.pipeline().fireExceptionCaught(e);\n                    }\n                }\n            }\n        };\n    }",
  "abstract_func_before": "private Subscriber<Object> buildSubscriber(NettyHttpRequest<?> VAR_0,\n                                               ChannelHandlerContext VAR_1,\n                                               RouteMatch<?> VAR_2) {\n        return new CompletionAwareSubscriber<Object>() {\n            Boolean VAR_3 = VAR_0.getContentType()\n                    .map(VAR_4 -> VAR_4.equals(VAR_5.APPLICATION_FORM_URLENCODED_TYPE))\n                    .orElse(false);\n            RouteMatch<?> VAR_6 = VAR_2;\n            AtomicBoolean VAR_7 = new AtomicBoolean(false);\n            AtomicLong VAR_8 = new AtomicLong(0);\n            ConcurrentHashMap<String, UnicastProcessor> VAR_9 = new ConcurrentHashMap<>();\n            ConcurrentHashMap<Integer, HttpDataReference> VAR_10 = new ConcurrentHashMap<>();\n            ConversionService VAR_11 = VAR_12.SHARED;\n            Subscription VAR_13;\n            LongConsumer VAR_14 = (VAR_15) -> VAR_8.updateAndGet((VAR_16) -> {\n                long VAR_17 = VAR_16 - VAR_15;\n                if (VAR_17 < 0) {\n                    VAR_13.request(VAR_15 - VAR_16);\n                    return 0;\n                } else {\n                    return VAR_17;\n                }\n            });\n\n            Flowable processFlowable(Flowable VAR_18, Integer VAR_19, boolean VAR_20) {\n                if (VAR_20) {\n                    VAR_18 = VAR_18.doOnRequest(VAR_14);\n                }\n                return VAR_18\n                        .doAfterTerminate(() -> {\n                            if (VAR_20) {\n                                HttpDataReference VAR_21 = VAR_10.get(VAR_19);\n                                VAR_21.destroy();\n                            }\n                        });\n            }\n\n            @Override\n            protected void doOnSubscribe(Subscription VAR_22) {\n                this.s = VAR_22;\n                VAR_22.request(1);\n            }\n\n            @Override\n            protected void doOnNext(Object VAR_23) {\n                boolean VAR_7 = this.executed.get();\n                if (VAR_23 instanceof ByteBufHolder) {\n                    if (VAR_23 instanceof HttpData) {\n                        HttpData VAR_24 = (HttpData) VAR_23;\n\n                        if (VAR_25.isTraceEnabled()) {\n                            VAR_25.trace(\"Received HTTP Data for request [{}]: {}\", VAR_0, VAR_23);\n                        }\n\n                        String VAR_26 = VAR_24.getName();\n                        Optional<Argument<?>> VAR_27 = VAR_6.getRequiredInput(VAR_26);\n\n                        if (VAR_27.isPresent()) {\n                            Argument<?> VAR_28 = VAR_27.get();\n                            Supplier<Object> VAR_29;\n                            boolean VAR_30 = VAR_31.isConvertibleToPublisher(VAR_28.getType());\n                            boolean VAR_32 = false;\n\n                            if (VAR_30) {\n                                Integer VAR_19 = VAR_33.identityHashCode(VAR_24);\n                                HttpDataReference VAR_21 = VAR_10.computeIfAbsent(VAR_19, (VAR_34) -> {\n                                    return new HttpDataReference(VAR_24);\n                                });\n                                Argument VAR_35;\n\n                                if (StreamingFileUpload.class.isAssignableFrom(VAR_28.getType())) {\n                                    VAR_35 = VAR_36.of(PartData.class);\n                                } else {\n                                    VAR_35 = VAR_28.getFirstTypeVariable().orElse(VAR_36.OBJECT_ARGUMENT);\n                                }\n                                Class VAR_37 = VAR_35.getType();\n\n                                UnicastProcessor VAR_38 = VAR_9.computeIfAbsent(VAR_26, (VAR_34) -> VAR_39.create());\n\n                                VAR_32 = PartData.class.equals(VAR_37) ||\n                                        VAR_31.isConvertibleToPublisher(VAR_37) ||\n                                        VAR_40.isJavaLangType(VAR_37);\n\n                                if (VAR_31.isConvertibleToPublisher(VAR_37)) {\n                                    boolean VAR_41 = StreamingFileUpload.class.isAssignableFrom(VAR_37);\n                                    if (VAR_41) {\n                                        VAR_35 = VAR_36.of(PartData.class);\n                                    } else {\n                                        VAR_35 = VAR_35.getFirstTypeVariable().orElse(VAR_36.OBJECT_ARGUMENT);\n                                    }\n                                    VAR_21.subject.getAndUpdate(VAR_42 -> {\n                                        if (VAR_42 == null) {\n                                            UnicastProcessor VAR_43 = VAR_39.create();\n                                            Flowable VAR_18 = processFlowable(VAR_43, VAR_19, true);\n                                            if (VAR_41 && VAR_24 instanceof FileUpload) {\n                                                VAR_38.onNext(new NettyStreamingFileUpload(\n                                                        (FileUpload) VAR_24,\n                                                        VAR_44.getMultipart(),\n                                                        VAR_45,\n                                                        VAR_18));\n                                            } else {\n                                                VAR_38.onNext(VAR_18);\n                                            }\n\n                                            return VAR_43;\n                                        }\n                                        return VAR_42;\n                                    });\n\n                                }\n\n                                UnicastProcessor VAR_42 = VAR_46.ofNullable(VAR_21.subject.get()).orElse(VAR_38);\n\n                                Object VAR_47 = VAR_24;\n\n                                if (VAR_32) {\n                                    HttpDataReference.Component VAR_48 = VAR_21.addComponent((VAR_49) -> {\n                                        VAR_42.onError(VAR_49);\n                                        VAR_13.cancel();\n                                    });\n                                    if (VAR_48 == null) {\n                                        return;\n                                    }\n                                    VAR_47 = new NettyPartData(VAR_21, VAR_48);\n                                }\n\n                                if (VAR_24 instanceof FileUpload &&\n                                        StreamingFileUpload.class.isAssignableFrom(VAR_28.getType())) {\n                                    VAR_21.upload.getAndUpdate(VAR_50 -> {\n                                        if (VAR_50 == null) {\n                                            return new NettyStreamingFileUpload(\n                                                    (FileUpload) VAR_24,\n                                                    VAR_44.getMultipart(),\n                                                    VAR_45,\n                                                    processFlowable(VAR_42, VAR_19, true));\n                                        }\n                                        return VAR_50;\n                                    });\n                                }\n\n                                Optional<?> VAR_51 = VAR_11.convert(VAR_47, VAR_35);\n\n                                VAR_51.ifPresent(VAR_42::VAR_52);\n\n                                if (VAR_24.isCompleted() && VAR_32) {\n                                    VAR_42.onComplete();\n                                }\n\n                                VAR_29 = () -> {\n                                    StreamingFileUpload VAR_50 = VAR_21.upload.get();\n                                    if (VAR_50 != null) {\n                                        return VAR_50;\n                                    } else {\n                                        return processFlowable(VAR_38, VAR_19, VAR_21.subject.get() == null);\n                                    }\n                                };\n\n                            } else {\n                                if (VAR_24 instanceof Attribute && !VAR_24.isCompleted()) {\n                                    VAR_0.addContent(VAR_24);\n                                    VAR_13.request(1);\n                                    return;\n                                } else {\n                                    VAR_29 = () -> {\n                                        if (VAR_24.refCnt() > 0) {\n                                            return VAR_24;\n                                        } else {\n                                            return null;\n                                        }\n                                    };\n                                }\n                            }\n\n                            if (!VAR_7) {\n                                String VAR_53 = VAR_28.getName();\n                                if (!VAR_6.isSatisfied(VAR_53)) {\n                                    VAR_6 = VAR_6.fulfill(VAR_54.singletonMap(VAR_53, VAR_29.get()));\n                                }\n                                if (VAR_30 && VAR_32) {\n                                    /* COMMENT_0 */\n                                    VAR_8.incrementAndGet();\n                                }\n                                if (VAR_6.isExecutable() || VAR_23 instanceof LastHttpContent) {\n                                    executeRoute();\n                                    VAR_7 = true;\n                                }\n                            }\n\n                            if (VAR_3) {\n                                VAR_0.addContent(VAR_24);\n                            }\n\n                            if (!VAR_7 || !VAR_32) {\n                                VAR_13.request(1);\n                            }\n\n                        } else {\n                            VAR_0.addContent(VAR_24);\n                            VAR_13.request(1);\n                        }\n                    } else {\n                        VAR_0.addContent((ByteBufHolder) VAR_23);\n                        VAR_13.request(1);\n                    }\n                } else {\n                    ((NettyHttpRequest) VAR_0).setBody(VAR_23);\n                    VAR_13.request(1);\n                }\n            }\n\n            @Override\n            protected void doOnError(Throwable VAR_55) {\n                try {\n                    VAR_13.cancel();\n                    exceptionCaught(VAR_1, VAR_55);\n                } catch (Exception VAR_49) {\n                    /* COMMENT_1 */\n                    writeDefaultErrorResponse(VAR_1, VAR_0, VAR_49);\n                }\n            }\n\n            @Override\n            protected void doOnComplete() {\n                for (UnicastProcessor VAR_42: VAR_9.values()) {\n                    if (!VAR_42.hasComplete()) {\n                        VAR_42.onComplete();\n                    }\n                }\n                executeRoute();\n            }\n\n            private void executeRoute() {\n                if (VAR_7.compareAndSet(false, true)) {\n                    try {\n                        VAR_6 = prepareRouteForExecution(VAR_6, VAR_0);\n                        VAR_6.execute();\n                    } catch (Exception VAR_49) {\n                        VAR_1.pipeline().fireExceptionCaught(VAR_49);\n                    }\n                }\n            }\n        };\n    }",
  "func_graph_path_before": "micronaut-projects/micronaut-core/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3/RoutingInBoundHandler.java/vul/before/0.json",
  "func": "private Subscriber<Object> buildSubscriber(NettyHttpRequest<?> request,\n                                               ChannelHandlerContext context,\n                                               RouteMatch<?> finalRoute) {\n        return new CompletionAwareSubscriber<Object>() {\n            Boolean alwaysAddContent = request.getContentType()\n                    .map(type -> type.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE))\n                    .orElse(false);\n            RouteMatch<?> routeMatch = finalRoute;\n            AtomicBoolean executed = new AtomicBoolean(false);\n            AtomicLong pressureRequested = new AtomicLong(0);\n            ConcurrentHashMap<String, UnicastProcessor> subjects = new ConcurrentHashMap<>();\n            ConcurrentHashMap<Integer, HttpDataReference> dataReferences = new ConcurrentHashMap<>();\n            ConversionService conversionService = ConversionService.SHARED;\n            Subscription s;\n            LongConsumer onRequest = (num) -> pressureRequested.updateAndGet((p) -> {\n                long newVal = p - num;\n                if (newVal < 0) {\n                    s.request(num - p);\n                    return 0;\n                } else {\n                    return newVal;\n                }\n            });\n\n            Flowable processFlowable(Flowable flowable, Integer dataKey, boolean controlsFlow) {\n                if (controlsFlow) {\n                    flowable = flowable.doOnRequest(onRequest);\n                }\n                return flowable\n                        .doAfterTerminate(() -> {\n                            if (controlsFlow) {\n                                HttpDataReference dataReference = dataReferences.get(dataKey);\n                                dataReference.destroy();\n                            }\n                        });\n            }\n\n            @Override\n            protected void doOnSubscribe(Subscription subscription) {\n                this.s = subscription;\n                subscription.request(1);\n            }\n\n            @Override\n            protected void doOnNext(Object message) {\n                boolean executed = this.executed.get();\n                if (message instanceof ByteBufHolder) {\n                    if (message instanceof HttpData) {\n                        HttpData data = (HttpData) message;\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Received HTTP Data for request [{}]: {}\", request, message);\n                        }\n\n                        String name = data.getName();\n                        Optional<Argument<?>> requiredInput = routeMatch.getRequiredInput(name);\n\n                        if (requiredInput.isPresent()) {\n                            Argument<?> argument = requiredInput.get();\n                            Supplier<Object> value;\n                            boolean isPublisher = Publishers.isConvertibleToPublisher(argument.getType());\n                            boolean chunkedProcessing = false;\n\n                            if (isPublisher) {\n                                Integer dataKey = System.identityHashCode(data);\n                                HttpDataReference dataReference = dataReferences.computeIfAbsent(dataKey, (key) -> {\n                                    return new HttpDataReference(data);\n                                });\n                                Argument typeVariable;\n\n                                if (StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n                                    typeVariable = ARGUMENT_PART_DATA;\n                                } else {\n                                    typeVariable = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                }\n                                Class typeVariableType = typeVariable.getType();\n\n                                UnicastProcessor namedSubject = subjects.computeIfAbsent(name, (key) -> UnicastProcessor.create());\n\n                                chunkedProcessing = PartData.class.equals(typeVariableType) ||\n                                        Publishers.isConvertibleToPublisher(typeVariableType) ||\n                                        ClassUtils.isJavaLangType(typeVariableType);\n\n                                if (Publishers.isConvertibleToPublisher(typeVariableType)) {\n                                    boolean streamingFileUpload = StreamingFileUpload.class.isAssignableFrom(typeVariableType);\n                                    if (streamingFileUpload) {\n                                        typeVariable = ARGUMENT_PART_DATA;\n                                    } else {\n                                        typeVariable = typeVariable.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                    }\n                                    dataReference.subject.getAndUpdate(subject -> {\n                                        if (subject == null) {\n                                            UnicastProcessor childSubject = UnicastProcessor.create();\n                                            Flowable flowable = processFlowable(childSubject, dataKey, true);\n                                            if (streamingFileUpload && data instanceof FileUpload) {\n                                                namedSubject.onNext(new NettyStreamingFileUpload(\n                                                        (FileUpload) data,\n                                                        serverConfiguration.getMultipart(),\n                                                        ioExecutor,\n                                                        flowable));\n                                            } else {\n                                                namedSubject.onNext(flowable);\n                                            }\n\n                                            return childSubject;\n                                        }\n                                        return subject;\n                                    });\n\n                                }\n\n                                UnicastProcessor subject = Optional.ofNullable(dataReference.subject.get()).orElse(namedSubject);\n\n                                Object part = data;\n\n                                if (chunkedProcessing) {\n                                    HttpDataReference.Component component = dataReference.addComponent((e) -> {\n                                        subject.onError(e);\n                                        s.cancel();\n                                    });\n                                    if (component == null) {\n                                        return;\n                                    }\n                                    part = new NettyPartData(dataReference, component);\n                                }\n\n                                if (data instanceof FileUpload &&\n                                        StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n                                    dataReference.upload.getAndUpdate(upload -> {\n                                        if (upload == null) {\n                                            return new NettyStreamingFileUpload(\n                                                    (FileUpload) data,\n                                                    serverConfiguration.getMultipart(),\n                                                    ioExecutor,\n                                                    processFlowable(subject, dataKey, true));\n                                        }\n                                        return upload;\n                                    });\n                                }\n\n                                Optional<?> converted = conversionService.convert(part, typeVariable);\n\n                                converted.ifPresent(subject::onNext);\n\n                                if (data.isCompleted() && chunkedProcessing) {\n                                    subject.onComplete();\n                                }\n\n                                value = () -> {\n                                    StreamingFileUpload upload = dataReference.upload.get();\n                                    if (upload != null) {\n                                        return upload;\n                                    } else {\n                                        return processFlowable(namedSubject, dataKey, dataReference.subject.get() == null);\n                                    }\n                                };\n\n                            } else {\n                                if (data instanceof Attribute && !data.isCompleted()) {\n                                    request.addContent(data);\n                                    s.request(1);\n                                    return;\n                                } else {\n                                    value = () -> {\n                                        if (data.refCnt() > 0) {\n                                            return data;\n                                        } else {\n                                            return null;\n                                        }\n                                    };\n                                }\n                            }\n\n                            if (!executed) {\n                                String argumentName = argument.getName();\n                                if (!routeMatch.isSatisfied(argumentName)) {\n                                    routeMatch = routeMatch.fulfill(Collections.singletonMap(argumentName, value.get()));\n                                }\n                                if (isPublisher && chunkedProcessing) {\n                                    //accounting for the previous request\n                                    pressureRequested.incrementAndGet();\n                                }\n                                if (routeMatch.isExecutable() || message instanceof LastHttpContent) {\n                                    executeRoute();\n                                    executed = true;\n                                }\n                            }\n\n                            if (alwaysAddContent) {\n                                request.addContent(data);\n                            }\n\n                            if (!executed || !chunkedProcessing) {\n                                s.request(1);\n                            }\n\n                        } else {\n                            request.addContent(data);\n                            s.request(1);\n                        }\n                    } else {\n                        request.addContent((ByteBufHolder) message);\n                        s.request(1);\n                    }\n                } else {\n                    ((NettyHttpRequest) request).setBody(message);\n                    s.request(1);\n                }\n            }\n\n            @Override\n            protected void doOnError(Throwable t) {\n                try {\n                    s.cancel();\n                    exceptionCaught(context, t);\n                } catch (Exception e) {\n                    // should never happen\n                    writeDefaultErrorResponse(context, request, e);\n                }\n            }\n\n            @Override\n            protected void doOnComplete() {\n                for (UnicastProcessor subject: subjects.values()) {\n                    if (!subject.hasComplete()) {\n                        subject.onComplete();\n                    }\n                }\n                executeRoute();\n            }\n\n            private void executeRoute() {\n                if (executed.compareAndSet(false, true)) {\n                    try {\n                        routeMatch = prepareRouteForExecution(routeMatch, request);\n                        routeMatch.execute();\n                    } catch (Exception e) {\n                        context.pipeline().fireExceptionCaught(e);\n                    }\n                }\n            }\n        };\n    }",
  "abstract_func": "private Subscriber<Object> buildSubscriber(NettyHttpRequest<?> VAR_0,\n                                               ChannelHandlerContext VAR_1,\n                                               RouteMatch<?> VAR_2) {\n        return new CompletionAwareSubscriber<Object>() {\n            Boolean VAR_3 = VAR_0.getContentType()\n                    .map(VAR_4 -> VAR_4.equals(VAR_5.APPLICATION_FORM_URLENCODED_TYPE))\n                    .orElse(false);\n            RouteMatch<?> VAR_6 = VAR_2;\n            AtomicBoolean VAR_7 = new AtomicBoolean(false);\n            AtomicLong VAR_8 = new AtomicLong(0);\n            ConcurrentHashMap<String, UnicastProcessor> VAR_9 = new ConcurrentHashMap<>();\n            ConcurrentHashMap<Integer, HttpDataReference> VAR_10 = new ConcurrentHashMap<>();\n            ConversionService VAR_11 = VAR_12.SHARED;\n            Subscription VAR_13;\n            LongConsumer VAR_14 = (VAR_15) -> VAR_8.updateAndGet((VAR_16) -> {\n                long VAR_17 = VAR_16 - VAR_15;\n                if (VAR_17 < 0) {\n                    VAR_13.request(VAR_15 - VAR_16);\n                    return 0;\n                } else {\n                    return VAR_17;\n                }\n            });\n\n            Flowable processFlowable(Flowable VAR_18, Integer VAR_19, boolean VAR_20) {\n                if (VAR_20) {\n                    VAR_18 = VAR_18.doOnRequest(VAR_14);\n                }\n                return VAR_18\n                        .doAfterTerminate(() -> {\n                            if (VAR_20) {\n                                HttpDataReference VAR_21 = VAR_10.get(VAR_19);\n                                VAR_21.destroy();\n                            }\n                        });\n            }\n\n            @Override\n            protected void doOnSubscribe(Subscription VAR_22) {\n                this.s = VAR_22;\n                VAR_22.request(1);\n            }\n\n            @Override\n            protected void doOnNext(Object VAR_23) {\n                boolean VAR_7 = this.executed.get();\n                if (VAR_23 instanceof ByteBufHolder) {\n                    if (VAR_23 instanceof HttpData) {\n                        HttpData VAR_24 = (HttpData) VAR_23;\n\n                        if (VAR_25.isTraceEnabled()) {\n                            VAR_25.trace(\"Received HTTP Data for request [{}]: {}\", VAR_0, VAR_23);\n                        }\n\n                        String VAR_26 = VAR_24.getName();\n                        Optional<Argument<?>> VAR_27 = VAR_6.getRequiredInput(VAR_26);\n\n                        if (VAR_27.isPresent()) {\n                            Argument<?> VAR_28 = VAR_27.get();\n                            Supplier<Object> VAR_29;\n                            boolean VAR_30 = VAR_31.isConvertibleToPublisher(VAR_28.getType());\n                            boolean VAR_32 = false;\n\n                            if (VAR_30) {\n                                Integer VAR_19 = VAR_33.identityHashCode(VAR_24);\n                                HttpDataReference VAR_21 = VAR_10.computeIfAbsent(VAR_19, (VAR_34) -> {\n                                    return new HttpDataReference(VAR_24);\n                                });\n                                Argument VAR_35;\n\n                                if (StreamingFileUpload.class.isAssignableFrom(VAR_28.getType())) {\n                                    VAR_35 = VAR_36;\n                                } else {\n                                    VAR_35 = VAR_28.getFirstTypeVariable().orElse(VAR_37.OBJECT_ARGUMENT);\n                                }\n                                Class VAR_38 = VAR_35.getType();\n\n                                UnicastProcessor VAR_39 = VAR_9.computeIfAbsent(VAR_26, (VAR_34) -> VAR_40.create());\n\n                                VAR_32 = PartData.class.equals(VAR_38) ||\n                                        VAR_31.isConvertibleToPublisher(VAR_38) ||\n                                        VAR_41.isJavaLangType(VAR_38);\n\n                                if (VAR_31.isConvertibleToPublisher(VAR_38)) {\n                                    boolean VAR_42 = StreamingFileUpload.class.isAssignableFrom(VAR_38);\n                                    if (VAR_42) {\n                                        VAR_35 = VAR_36;\n                                    } else {\n                                        VAR_35 = VAR_35.getFirstTypeVariable().orElse(VAR_37.OBJECT_ARGUMENT);\n                                    }\n                                    VAR_21.subject.getAndUpdate(VAR_43 -> {\n                                        if (VAR_43 == null) {\n                                            UnicastProcessor VAR_44 = VAR_40.create();\n                                            Flowable VAR_18 = processFlowable(VAR_44, VAR_19, true);\n                                            if (VAR_42 && VAR_24 instanceof FileUpload) {\n                                                VAR_39.onNext(new NettyStreamingFileUpload(\n                                                        (FileUpload) VAR_24,\n                                                        VAR_45.getMultipart(),\n                                                        VAR_46,\n                                                        VAR_18));\n                                            } else {\n                                                VAR_39.onNext(VAR_18);\n                                            }\n\n                                            return VAR_44;\n                                        }\n                                        return VAR_43;\n                                    });\n\n                                }\n\n                                UnicastProcessor VAR_43 = VAR_47.ofNullable(VAR_21.subject.get()).orElse(VAR_39);\n\n                                Object VAR_48 = VAR_24;\n\n                                if (VAR_32) {\n                                    HttpDataReference.Component VAR_49 = VAR_21.addComponent((VAR_50) -> {\n                                        VAR_43.onError(VAR_50);\n                                        VAR_13.cancel();\n                                    });\n                                    if (VAR_49 == null) {\n                                        return;\n                                    }\n                                    VAR_48 = new NettyPartData(VAR_21, VAR_49);\n                                }\n\n                                if (VAR_24 instanceof FileUpload &&\n                                        StreamingFileUpload.class.isAssignableFrom(VAR_28.getType())) {\n                                    VAR_21.upload.getAndUpdate(VAR_51 -> {\n                                        if (VAR_51 == null) {\n                                            return new NettyStreamingFileUpload(\n                                                    (FileUpload) VAR_24,\n                                                    VAR_45.getMultipart(),\n                                                    VAR_46,\n                                                    processFlowable(VAR_43, VAR_19, true));\n                                        }\n                                        return VAR_51;\n                                    });\n                                }\n\n                                Optional<?> VAR_52 = VAR_11.convert(VAR_48, VAR_35);\n\n                                VAR_52.ifPresent(VAR_43::VAR_53);\n\n                                if (VAR_24.isCompleted() && VAR_32) {\n                                    VAR_43.onComplete();\n                                }\n\n                                VAR_29 = () -> {\n                                    StreamingFileUpload VAR_51 = VAR_21.upload.get();\n                                    if (VAR_51 != null) {\n                                        return VAR_51;\n                                    } else {\n                                        return processFlowable(VAR_39, VAR_19, VAR_21.subject.get() == null);\n                                    }\n                                };\n\n                            } else {\n                                if (VAR_24 instanceof Attribute && !VAR_24.isCompleted()) {\n                                    VAR_0.addContent(VAR_24);\n                                    VAR_13.request(1);\n                                    return;\n                                } else {\n                                    VAR_29 = () -> {\n                                        if (VAR_24.refCnt() > 0) {\n                                            return VAR_24;\n                                        } else {\n                                            return null;\n                                        }\n                                    };\n                                }\n                            }\n\n                            if (!VAR_7) {\n                                String VAR_54 = VAR_28.getName();\n                                if (!VAR_6.isSatisfied(VAR_54)) {\n                                    VAR_6 = VAR_6.fulfill(VAR_55.singletonMap(VAR_54, VAR_29.get()));\n                                }\n                                if (VAR_30 && VAR_32) {\n                                    /* COMMENT_0 */\n                                    VAR_8.incrementAndGet();\n                                }\n                                if (VAR_6.isExecutable() || VAR_23 instanceof LastHttpContent) {\n                                    executeRoute();\n                                    VAR_7 = true;\n                                }\n                            }\n\n                            if (VAR_3) {\n                                VAR_0.addContent(VAR_24);\n                            }\n\n                            if (!VAR_7 || !VAR_32) {\n                                VAR_13.request(1);\n                            }\n\n                        } else {\n                            VAR_0.addContent(VAR_24);\n                            VAR_13.request(1);\n                        }\n                    } else {\n                        VAR_0.addContent((ByteBufHolder) VAR_23);\n                        VAR_13.request(1);\n                    }\n                } else {\n                    ((NettyHttpRequest) VAR_0).setBody(VAR_23);\n                    VAR_13.request(1);\n                }\n            }\n\n            @Override\n            protected void doOnError(Throwable VAR_56) {\n                try {\n                    VAR_13.cancel();\n                    exceptionCaught(VAR_1, VAR_56);\n                } catch (Exception VAR_50) {\n                    /* COMMENT_1 */\n                    writeDefaultErrorResponse(VAR_1, VAR_0, VAR_50);\n                }\n            }\n\n            @Override\n            protected void doOnComplete() {\n                for (UnicastProcessor VAR_43: VAR_9.values()) {\n                    if (!VAR_43.hasComplete()) {\n                        VAR_43.onComplete();\n                    }\n                }\n                executeRoute();\n            }\n\n            private void executeRoute() {\n                if (VAR_7.compareAndSet(false, true)) {\n                    try {\n                        VAR_6 = prepareRouteForExecution(VAR_6, VAR_0);\n                        VAR_6.execute();\n                    } catch (Exception VAR_50) {\n                        VAR_1.pipeline().fireExceptionCaught(VAR_50);\n                    }\n                }\n            }\n        };\n    }",
  "func_graph_path": "micronaut-projects/micronaut-core/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3/RoutingInBoundHandler.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -69,7 +69,7 @@\n                                 Argument typeVariable;\n \n                                 if (StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n-                                    typeVariable = Argument.of(PartData.class);\n+                                    typeVariable = ARGUMENT_PART_DATA;\n                                 } else {\n                                     typeVariable = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                 }\n@@ -84,7 +84,7 @@\n                                 if (Publishers.isConvertibleToPublisher(typeVariableType)) {\n                                     boolean streamingFileUpload = StreamingFileUpload.class.isAssignableFrom(typeVariableType);\n                                     if (streamingFileUpload) {\n-                                        typeVariable = Argument.of(PartData.class);\n+                                        typeVariable = ARGUMENT_PART_DATA;\n                                     } else {\n                                         typeVariable = typeVariable.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                     }",
  "diff_line_info": {
    "deleted_lines": [
      "                                    typeVariable = Argument.of(PartData.class);",
      "                                        typeVariable = Argument.of(PartData.class);"
    ],
    "added_lines": [
      "                                    typeVariable = ARGUMENT_PART_DATA;",
      "                                        typeVariable = ARGUMENT_PART_DATA;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/micronaut-projects/micronaut-core/pull/2356",
  "description": {
    "pr_info": {
      "title": "Use Argument constants where possible instead of class",
      "number": 2356
    },
    "comment": [
      "Changes\r\n-------\r\n * Added ArgumentConversionContext constants in ConversionContext\r\n * Replaced Argument.of and use of argument classes with\r\nConversionContext constants where possible\r\n * Added getFirst method in ConvertibleMultiValues that accepts\r\nArgumentConversionContent parameter\r\n\r\nPartially addresses issue #2355",
      "Nice progress"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9  \n\nThe commit replaces class-based argument creation with constants, improving code structure and likely fixing underlying issues related to handling arguments, which is a core functionality improvement rather than a security fix."
}