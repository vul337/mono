{
  "cve_id": "CVE-2022-36227",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "libarchive",
  "commit_msg": "libarchive: Handle a `calloc` returning NULL (fixes #1754)",
  "commit_hash": "bff38efe8c110469c5080d387bec62a6ca15b1a5",
  "git_url": "https://github.com/libarchive/libarchive/commit/bff38efe8c110469c5080d387bec62a6ca15b1a5",
  "file_path": "libarchive/archive_write.c",
  "func_name": "archive_write_open2",
  "func_before": "int\narchive_write_open2(struct archive *_a, void *client_data,\n    archive_open_callback *opener, archive_write_callback *writer,\n    archive_close_callback *closer, archive_free_callback *freer)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *client_filter;\n\tint ret, r1;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_open\");\n\tarchive_clear_error(&a->archive);\n\n\ta->client_writer = writer;\n\ta->client_opener = opener;\n\ta->client_closer = closer;\n\ta->client_freer = freer;\n\ta->client_data = client_data;\n\n\tclient_filter = __archive_write_allocate_filter(_a);\n\tclient_filter->open = archive_write_client_open;\n\tclient_filter->write = archive_write_client_write;\n\tclient_filter->close = archive_write_client_close;\n\tclient_filter->free = archive_write_client_free;\n\n\tret = __archive_write_filters_open(a);\n\tif (ret < ARCHIVE_WARN) {\n\t\tr1 = __archive_write_filters_close(a);\n\t\t__archive_write_filters_free(_a);\n\t\treturn (r1 < ret ? r1 : ret);\n\t}\n\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\tif (a->format_init)\n\t\tret = (a->format_init)(a);\n\treturn (ret);\n}",
  "abstract_func_before": "int\narchive_write_open2(struct archive *VAR_0, void *VAR_1,\n    archive_open_callback *VAR_2, archive_write_callback *VAR_3,\n    archive_close_callback *VAR_4, archive_free_callback *VAR_5)\n{\n\tstruct archive_write *VAR_6 = (struct archive_write *)VAR_0;\n\tstruct archive_write_filter *VAR_7;\n\tint VAR_8, VAR_9;\n\n\tarchive_check_magic(&VAR_6->archive, VAR_10,\n\t    VAR_11, \"archive_write_open\");\n\tarchive_clear_error(&VAR_6->archive);\n\n\tVAR_6->client_writer = VAR_3;\n\tVAR_6->client_opener = VAR_2;\n\tVAR_6->client_closer = VAR_4;\n\tVAR_6->client_freer = VAR_5;\n\tVAR_6->client_data = VAR_1;\n\n\tVAR_7 = __archive_write_allocate_filter(VAR_0);\n\tVAR_7->open = VAR_12;\n\tVAR_7->write = VAR_13;\n\tVAR_7->close = VAR_14;\n\tVAR_7->free = VAR_15;\n\n\tVAR_8 = __archive_write_filters_open(VAR_6);\n\tif (VAR_8 < VAR_16) {\n\t\tVAR_9 = __archive_write_filters_close(VAR_6);\n\t\t__archive_write_filters_free(VAR_0);\n\t\treturn (VAR_9 < VAR_8 ? VAR_9 : VAR_8);\n\t}\n\n\tVAR_6->archive.state = VAR_17;\n\tif (VAR_6->format_init)\n\t\tVAR_8 = (VAR_6->format_init)(VAR_6);\n\treturn (VAR_8);\n}",
  "func_graph_path_before": "libarchive/bff38efe8c110469c5080d387bec62a6ca15b1a5/archive_write.c/vul/before/1.json",
  "func": "int\narchive_write_open2(struct archive *_a, void *client_data,\n    archive_open_callback *opener, archive_write_callback *writer,\n    archive_close_callback *closer, archive_free_callback *freer)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *client_filter;\n\tint ret, r1;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_open\");\n\tarchive_clear_error(&a->archive);\n\n\ta->client_writer = writer;\n\ta->client_opener = opener;\n\ta->client_closer = closer;\n\ta->client_freer = freer;\n\ta->client_data = client_data;\n\n\tclient_filter = __archive_write_allocate_filter(_a);\n\n\tif (client_filter == NULL)\n\t\treturn (ARCHIVE_FATAL);\n\n\tclient_filter->open = archive_write_client_open;\n\tclient_filter->write = archive_write_client_write;\n\tclient_filter->close = archive_write_client_close;\n\tclient_filter->free = archive_write_client_free;\n\n\tret = __archive_write_filters_open(a);\n\tif (ret < ARCHIVE_WARN) {\n\t\tr1 = __archive_write_filters_close(a);\n\t\t__archive_write_filters_free(_a);\n\t\treturn (r1 < ret ? r1 : ret);\n\t}\n\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\tif (a->format_init)\n\t\tret = (a->format_init)(a);\n\treturn (ret);\n}",
  "abstract_func": "int\narchive_write_open2(struct archive *VAR_0, void *VAR_1,\n    archive_open_callback *VAR_2, archive_write_callback *VAR_3,\n    archive_close_callback *VAR_4, archive_free_callback *VAR_5)\n{\n\tstruct archive_write *VAR_6 = (struct archive_write *)VAR_0;\n\tstruct archive_write_filter *VAR_7;\n\tint VAR_8, VAR_9;\n\n\tarchive_check_magic(&VAR_6->archive, VAR_10,\n\t    VAR_11, \"archive_write_open\");\n\tarchive_clear_error(&VAR_6->archive);\n\n\tVAR_6->client_writer = VAR_3;\n\tVAR_6->client_opener = VAR_2;\n\tVAR_6->client_closer = VAR_4;\n\tVAR_6->client_freer = VAR_5;\n\tVAR_6->client_data = VAR_1;\n\n\tVAR_7 = __archive_write_allocate_filter(VAR_0);\n\n\tif (VAR_7 == NULL)\n\t\treturn (VAR_12);\n\n\tVAR_7->open = VAR_13;\n\tVAR_7->write = VAR_14;\n\tVAR_7->close = VAR_15;\n\tVAR_7->free = VAR_16;\n\n\tVAR_8 = __archive_write_filters_open(VAR_6);\n\tif (VAR_8 < VAR_17) {\n\t\tVAR_9 = __archive_write_filters_close(VAR_6);\n\t\t__archive_write_filters_free(VAR_0);\n\t\treturn (VAR_9 < VAR_8 ? VAR_9 : VAR_8);\n\t}\n\n\tVAR_6->archive.state = VAR_18;\n\tif (VAR_6->format_init)\n\t\tVAR_8 = (VAR_6->format_init)(VAR_6);\n\treturn (VAR_8);\n}",
  "func_graph_path": "libarchive/bff38efe8c110469c5080d387bec62a6ca15b1a5/archive_write.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,10 @@\n \ta->client_data = client_data;\n \n \tclient_filter = __archive_write_allocate_filter(_a);\n+\n+\tif (client_filter == NULL)\n+\t\treturn (ARCHIVE_FATAL);\n+\n \tclient_filter->open = archive_write_client_open;\n \tclient_filter->write = archive_write_client_write;\n \tclient_filter->close = archive_write_client_close;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\tif (client_filter == NULL)",
      "\t\treturn (ARCHIVE_FATAL);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/1759",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libarchive/libarchive/pull/1759: 403 Client Error: Forbidden for url: https://api.github.com/repos/libarchive/libarchive/pulls/1759",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "The patch addresses a memory allocation issue by adding error handling, which prevents potential crashes but isn't explicitly tied to a security vulnerability. \n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}