{
  "cve_id": "CVE-2017-16516",
  "cwe_ids": [
    "CWE-134"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "brianmario/yajl-ruby",
  "commit_msg": "Don't advance our end pointer until we've checked we have enough\nbuffer left and have peeked ahead to see that a unicode escape\nis approaching.\n\nThanks @kivikakk for helping me track down the actual bug here!",
  "commit_hash": "a8ca8f476655adaa187eedc60bdc770fff3c51ce",
  "git_url": "https://github.com/brianmario/yajl-ruby/commit/a8ca8f476655adaa187eedc60bdc770fff3c51ce",
  "file_path": "ext/yajl/yajl_encode.c",
  "func_name": "yajl_string_decode",
  "func_before": "void yajl_string_decode(yajl_buf buf, const unsigned char * str,\n                        unsigned int len)\n{\n    unsigned int beg = 0;\n    unsigned int end = 0;    \n\n    while (end < len) {\n        if (str[end] == '\\\\') {\n            char utf8Buf[5];\n            const char * unescaped = \"?\";\n            yajl_buf_append(buf, str + beg, end - beg);\n            switch (str[++end]) {\n                case 'r': unescaped = \"\\r\"; break;\n                case 'n': unescaped = \"\\n\"; break;\n                case '\\\\': unescaped = \"\\\\\"; break;\n                case '/': unescaped = \"/\"; break;\n                case '\"': unescaped = \"\\\"\"; break;\n                case 'f': unescaped = \"\\f\"; break;\n                case 'b': unescaped = \"\\b\"; break;\n                case 't': unescaped = \"\\t\"; break;\n                case 'u': {\n                    unsigned int codepoint = 0;\n                    hexToDigit(&codepoint, str + ++end);\n                    end+=3;\n                    /* check if this is a surrogate */\n                    if ((codepoint & 0xFC00) == 0xD800) {\n                        end++;\n                        if (str[end] == '\\\\' && str[end + 1] == 'u') {\n                            unsigned int surrogate = 0;\n                            hexToDigit(&surrogate, str + end + 2);\n                            codepoint =\n                                (((codepoint & 0x3F) << 10) | \n                                 ((((codepoint >> 6) & 0xF) + 1) << 16) | \n                                 (surrogate & 0x3FF));\n                            end += 5;\n                        } else {\n                            unescaped = \"?\";\n                            break;\n                        }\n                    }\n                    \n                    Utf32toUtf8(codepoint, utf8Buf);\n                    unescaped = utf8Buf;\n\n                    if (codepoint == 0) {\n                        yajl_buf_append(buf, unescaped, 1);\n                        beg = ++end;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    assert(\"this should never happen\" == NULL);\n            }\n            yajl_buf_append(buf, unescaped, (unsigned int)strlen(unescaped));\n            beg = ++end;\n        } else {\n            end++;\n        }\n    }\n    yajl_buf_append(buf, str + beg, end - beg);\n}",
  "abstract_func_before": "void yajl_string_decode(yajl_buf VAR_0, const unsigned char * VAR_1,\n                        unsigned int VAR_2)\n{\n    unsigned int VAR_3 = 0;\n    unsigned int VAR_4 = 0;    \n\n    while (VAR_4 < VAR_2) {\n        if (VAR_1[VAR_4] == '\\\\') {\n            char VAR_5[5];\n            const char * VAR_6 = \"?\";\n            yajl_buf_append(VAR_0, VAR_1 + VAR_3, VAR_4 - VAR_3);\n            switch (VAR_1[++VAR_4]) {\n                case 'r': VAR_6 = \"\\r\"; break;\n                case 'n': VAR_6 = \"\\n\"; break;\n                case '\\\\': VAR_6 = \"\\\\\"; break;\n                case '/': VAR_6 = \"/\"; break;\n                case '\"': VAR_6 = \"\\\"\"; break;\n                case 'f': VAR_6 = \"\\f\"; break;\n                case 'b': VAR_6 = \"\\b\"; break;\n                case 't': VAR_6 = \"\\t\"; break;\n                case 'u': {\n                    unsigned int VAR_7 = 0;\n                    hexToDigit(&VAR_7, VAR_1 + ++VAR_4);\n                    VAR_4+=3;\n                    /* COMMENT_0 */\n                    if ((VAR_7 & 0xFC00) == 0xD800) {\n                        VAR_4++;\n                        if (VAR_1[VAR_4] == '\\\\' && VAR_1[VAR_4 + 1] == 'u') {\n                            unsigned int VAR_8 = 0;\n                            hexToDigit(&VAR_8, VAR_1 + VAR_4 + 2);\n                            VAR_7 =\n                                (((VAR_7 & 0x3F) << 10) | \n                                 ((((VAR_7 >> 6) & 0xF) + 1) << 16) | \n                                 (VAR_8 & 0x3FF));\n                            VAR_4 += 5;\n                        } else {\n                            VAR_6 = \"?\";\n                            break;\n                        }\n                    }\n                    \n                    Utf32toUtf8(VAR_7, VAR_5);\n                    VAR_6 = VAR_5;\n\n                    if (VAR_7 == 0) {\n                        yajl_buf_append(VAR_0, VAR_6, 1);\n                        VAR_3 = ++VAR_4;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    assert(\"this should never happen\" == NULL);\n            }\n            yajl_buf_append(VAR_0, VAR_6, (unsigned int)strlen(VAR_6));\n            VAR_3 = ++VAR_4;\n        } else {\n            VAR_4++;\n        }\n    }\n    yajl_buf_append(VAR_0, VAR_1 + VAR_3, VAR_4 - VAR_3);\n}",
  "func_graph_path_before": "brianmario/yajl-ruby/a8ca8f476655adaa187eedc60bdc770fff3c51ce/yajl_encode.c/vul/before/0.json",
  "func": "void yajl_string_decode(yajl_buf buf, const unsigned char * str,\n                        unsigned int len)\n{\n    unsigned int beg = 0;\n    unsigned int end = 0;    \n\n    while (end < len) {\n        if (str[end] == '\\\\') {\n            char utf8Buf[5];\n            const char * unescaped = \"?\";\n            yajl_buf_append(buf, str + beg, end - beg);\n            switch (str[++end]) {\n                case 'r': unescaped = \"\\r\"; break;\n                case 'n': unescaped = \"\\n\"; break;\n                case '\\\\': unescaped = \"\\\\\"; break;\n                case '/': unescaped = \"/\"; break;\n                case '\"': unescaped = \"\\\"\"; break;\n                case 'f': unescaped = \"\\f\"; break;\n                case 'b': unescaped = \"\\b\"; break;\n                case 't': unescaped = \"\\t\"; break;\n                case 'u': {\n                    unsigned int codepoint = 0;\n                    hexToDigit(&codepoint, str + ++end);\n                    end+=3;\n                    /* check if this is a surrogate */\n                    if ((codepoint & 0xFC00) == 0xD800) {\n                        if (end + 2 < len && str[end + 1] == '\\\\' && str[end + 2] == 'u') {\n                            end++;\n                            unsigned int surrogate = 0;\n                            hexToDigit(&surrogate, str + end + 2);\n                            codepoint =\n                                (((codepoint & 0x3F) << 10) | \n                                 ((((codepoint >> 6) & 0xF) + 1) << 16) | \n                                 (surrogate & 0x3FF));\n                            end += 5;\n                        } else {\n                            unescaped = \"?\";\n                            break;\n                        }\n                    }\n                    \n                    Utf32toUtf8(codepoint, utf8Buf);\n                    unescaped = utf8Buf;\n\n                    if (codepoint == 0) {\n                        yajl_buf_append(buf, unescaped, 1);\n                        beg = ++end;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    assert(\"this should never happen\" == NULL);\n            }\n            yajl_buf_append(buf, unescaped, (unsigned int)strlen(unescaped));\n            beg = ++end;\n        } else {\n            end++;\n        }\n    }\n    yajl_buf_append(buf, str + beg, end - beg);\n}",
  "abstract_func": "void yajl_string_decode(yajl_buf VAR_0, const unsigned char * VAR_1,\n                        unsigned int VAR_2)\n{\n    unsigned int VAR_3 = 0;\n    unsigned int VAR_4 = 0;    \n\n    while (VAR_4 < VAR_2) {\n        if (VAR_1[VAR_4] == '\\\\') {\n            char VAR_5[5];\n            const char * VAR_6 = \"?\";\n            yajl_buf_append(VAR_0, VAR_1 + VAR_3, VAR_4 - VAR_3);\n            switch (VAR_1[++VAR_4]) {\n                case 'r': VAR_6 = \"\\r\"; break;\n                case 'n': VAR_6 = \"\\n\"; break;\n                case '\\\\': VAR_6 = \"\\\\\"; break;\n                case '/': VAR_6 = \"/\"; break;\n                case '\"': VAR_6 = \"\\\"\"; break;\n                case 'f': VAR_6 = \"\\f\"; break;\n                case 'b': VAR_6 = \"\\b\"; break;\n                case 't': VAR_6 = \"\\t\"; break;\n                case 'u': {\n                    unsigned int VAR_7 = 0;\n                    hexToDigit(&VAR_7, VAR_1 + ++VAR_4);\n                    VAR_4+=3;\n                    /* COMMENT_0 */\n                    if ((VAR_7 & 0xFC00) == 0xD800) {\n                        if (VAR_4 + 2 < VAR_2 && VAR_1[VAR_4 + 1] == '\\\\' && VAR_1[VAR_4 + 2] == 'u') {\n                            VAR_4++;\n                            unsigned int VAR_8 = 0;\n                            hexToDigit(&VAR_8, VAR_1 + VAR_4 + 2);\n                            VAR_7 =\n                                (((VAR_7 & 0x3F) << 10) | \n                                 ((((VAR_7 >> 6) & 0xF) + 1) << 16) | \n                                 (VAR_8 & 0x3FF));\n                            VAR_4 += 5;\n                        } else {\n                            VAR_6 = \"?\";\n                            break;\n                        }\n                    }\n                    \n                    Utf32toUtf8(VAR_7, VAR_5);\n                    VAR_6 = VAR_5;\n\n                    if (VAR_7 == 0) {\n                        yajl_buf_append(VAR_0, VAR_6, 1);\n                        VAR_3 = ++VAR_4;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    assert(\"this should never happen\" == NULL);\n            }\n            yajl_buf_append(VAR_0, VAR_6, (unsigned int)strlen(VAR_6));\n            VAR_3 = ++VAR_4;\n        } else {\n            VAR_4++;\n        }\n    }\n    yajl_buf_append(VAR_0, VAR_1 + VAR_3, VAR_4 - VAR_3);\n}",
  "func_graph_path": "brianmario/yajl-ruby/a8ca8f476655adaa187eedc60bdc770fff3c51ce/yajl_encode.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,8 +24,8 @@\n                     end+=3;\n                     /* check if this is a surrogate */\n                     if ((codepoint & 0xFC00) == 0xD800) {\n-                        end++;\n-                        if (str[end] == '\\\\' && str[end + 1] == 'u') {\n+                        if (end + 2 < len && str[end + 1] == '\\\\' && str[end + 2] == 'u') {\n+                            end++;\n                             unsigned int surrogate = 0;\n                             hexToDigit(&surrogate, str + end + 2);\n                             codepoint =",
  "diff_line_info": {
    "deleted_lines": [
      "                        end++;",
      "                        if (str[end] == '\\\\' && str[end + 1] == 'u') {"
    ],
    "added_lines": [
      "                        if (end + 2 < len && str[end + 1] == '\\\\' && str[end + 2] == 'u') {",
      "                            end++;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/brianmario/yajl-ruby/pull/178",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/brianmario/yajl-ruby/pull/178: 403 Client Error: Forbidden for url: https://api.github.com/repos/brianmario/yajl-ruby/pulls/178",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}