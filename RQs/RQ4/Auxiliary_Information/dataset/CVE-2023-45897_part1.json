{
  "cve_id": "CVE-2023-45897",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "exfatprogs",
  "commit_msg": "exfat2img: fix out-of-bounds write in read_file_dentry_set\n\nif SecondaryCount is greater than (2 + the max number\nof File Name entries), writing to memory outside\nthe node->name could happen.\n\nReported-by: Yuezhang Mo <Yuezhang.Mo@sony.com>\nSigned-off-by: Hyunchul Lee <hyc.lee@gmail.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
  "commit_hash": "4abc55e976573991e6a1117bb2b3711e59da07ae",
  "git_url": "https://github.com/exfatprogs/exfatprogs/commit/4abc55e976573991e6a1117bb2b3711e59da07ae",
  "file_path": "exfat2img/exfat2img.c",
  "func_name": "read_file_dentry_set",
  "func_before": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}",
  "abstract_func_before": "static int read_file_dentry_set(struct exfat_de_iter *VAR_0,\n\t\t\t\tstruct exfat_inode **VAR_1, int *VAR_2)\n{\n\tstruct exfat_dentry *VAR_3, *VAR_4, *VAR_5;\n\tstruct exfat_inode *VAR_6 = NULL;\n\tint VAR_7, VAR_8;\n\n\tVAR_8 = exfat_de_iter_get(VAR_0, 0, &VAR_3);\n\tif (VAR_8 || VAR_3->type != VAR_9) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -VAR_10;\n\t}\n\n\tVAR_8 = exfat_de_iter_get(VAR_0, 1, &VAR_4);\n\tif (VAR_8 || VAR_4->type != VAR_11) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*VAR_2 = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*VAR_1 = NULL;\n\tVAR_6 = exfat_alloc_inode(le16_to_cpu(VAR_3->file_attr));\n\tif (!VAR_6)\n\t\treturn -VAR_12;\n\n\tfor (VAR_7 = 2; VAR_7 <= VAR_3->file_num_ext; VAR_7++) {\n\t\tVAR_8 = exfat_de_iter_get(VAR_0, VAR_7, &VAR_5);\n\t\tif (VAR_8 || VAR_5->type != VAR_13)\n\t\t\tbreak;\n\t\tmemcpy(VAR_6->name +\n\t\t       (VAR_7 - 2) * VAR_14, VAR_5->name_unicode,\n\t\t       sizeof(VAR_5->name_unicode));\n\t}\n\n\tVAR_6->first_clus = le32_to_cpu(VAR_4->stream_start_clu);\n\tVAR_6->is_contiguous =\n\t\t((VAR_4->stream_flags & VAR_15) != 0);\n\tVAR_6->size = le64_to_cpu(VAR_4->stream_size);\n\n\t*VAR_2 = VAR_7;\n\t*VAR_1 = VAR_6;\n\treturn 0;\nskip_dset:\n\t*VAR_1 = NULL;\n\texfat_free_inode(VAR_6);\n\treturn -VAR_10;\n}",
  "func_graph_path_before": "exfatprogs/4abc55e976573991e6a1117bb2b3711e59da07ae/exfat2img.c/vul/before/0.json",
  "func": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}",
  "abstract_func": "static int read_file_dentry_set(struct exfat_de_iter *VAR_0,\n\t\t\t\tstruct exfat_inode **VAR_1, int *VAR_2)\n{\n\tstruct exfat_dentry *VAR_3, *VAR_4, *VAR_5;\n\tstruct exfat_inode *VAR_6 = NULL;\n\tint VAR_7, VAR_8;\n\n\tVAR_8 = exfat_de_iter_get(VAR_0, 0, &VAR_3);\n\tif (VAR_8 || VAR_3->type != VAR_9) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -VAR_10;\n\t}\n\n\tVAR_8 = exfat_de_iter_get(VAR_0, 1, &VAR_4);\n\tif (VAR_8 || VAR_4->type != VAR_11) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*VAR_2 = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*VAR_1 = NULL;\n\tVAR_6 = exfat_alloc_inode(le16_to_cpu(VAR_3->file_attr));\n\tif (!VAR_6)\n\t\treturn -VAR_12;\n\n\tfor (VAR_7 = 2; VAR_7 <= MIN(VAR_3->file_num_ext, 1 + VAR_13); VAR_7++) {\n\t\tVAR_8 = exfat_de_iter_get(VAR_0, VAR_7, &VAR_5);\n\t\tif (VAR_8 || VAR_5->type != VAR_14)\n\t\t\tbreak;\n\t\tmemcpy(VAR_6->name +\n\t\t       (VAR_7 - 2) * VAR_15, VAR_5->name_unicode,\n\t\t       sizeof(VAR_5->name_unicode));\n\t}\n\n\tVAR_6->first_clus = le32_to_cpu(VAR_4->stream_start_clu);\n\tVAR_6->is_contiguous =\n\t\t((VAR_4->stream_flags & VAR_16) != 0);\n\tVAR_6->size = le64_to_cpu(VAR_4->stream_size);\n\n\t*VAR_2 = VAR_7;\n\t*VAR_1 = VAR_6;\n\treturn 0;\nskip_dset:\n\t*VAR_1 = NULL;\n\texfat_free_inode(VAR_6);\n\treturn -VAR_10;\n}",
  "func_graph_path": "exfatprogs/4abc55e976573991e6a1117bb2b3711e59da07ae/exfat2img.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n \tif (!node)\n \t\treturn -ENOMEM;\n \n-\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n+\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {\n \t\tret = exfat_de_iter_get(iter, i, &dentry);\n \t\tif (ret || dentry->type != EXFAT_NAME)\n \t\t\tbreak;",
  "diff_line_info": {
    "deleted_lines": [
      "\tfor (i = 2; i <= file_de->file_num_ext; i++) {"
    ],
    "added_lines": [
      "\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/exfatprogs/exfatprogs/pull/239",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/exfatprogs/exfatprogs/pull/239: 403 Client Error: Forbidden for url: https://api.github.com/repos/exfatprogs/exfatprogs/pulls/239",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}