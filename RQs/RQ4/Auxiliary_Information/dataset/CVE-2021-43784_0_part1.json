{
  "cve_id": "CVE-2021-43784",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "opencontainers/runc",
  "commit_msg": "Open bind mount sources from the host userns\n\nThe source of the bind mount might not be accessible in a different user\nnamespace because a component of the source path might not be traversed\nunder the users and groups mapped inside the user namespace. This caused\nerrors such as the following:\n\n  # time=\"2020-06-22T13:48:26Z\" level=error msg=\"container_linux.go:367:\n  starting container process caused: process_linux.go:459:\n  container init caused: rootfs_linux.go:58:\n  mounting \\\"/tmp/busyboxtest/source-inaccessible/dir\\\"\n  to rootfs at \\\"/tmp/inaccessible\\\" caused:\n  stat /tmp/busyboxtest/source-inaccessible/dir: permission denied\"\n\nTo solve this problem, this patch performs the following:\n\n1. in nsexec.c, it opens the source path in the host userns (so we have\n   the right permissions to open it) but in the container mntns (so the\n   kernel cross mntns mount check let us mount it later:\n   https://github.com/torvalds/linux/blob/v5.8/fs/namespace.c#L2312).\n\n2. in nsexec.c, it passes the file descriptors of the source to the\n   child process with SCM_RIGHTS.\n\n3. In runc-init in Golang, it finishes the mounts while inside the\n   userns even without access to the some components of the source\n   paths.\n\nPassing the fds with SCM_RIGHTS is necessary because once the child\nprocess is in the container mntns, it is already in the container userns\nso it cannot temporarily join the host mntns.\n\nThis patch uses the existing mechanism with _LIBCONTAINER_* environment\nvariables to pass the file descriptors from runc to runc init.\n\nThis patch uses the existing mechanism with the Netlink-style bootstrap\nto pass information about the list of source mounts to nsexec.c.\n\nRootless containers don't use this bind mount sources fdpassing\nmechanism because we can't setns() to the target mntns in a rootless\ncontainer (we don't have the privileges when we are in the host userns).\n\nThis patch takes care of using O_CLOEXEC on mount fds, and close them\nearly.\n\nFixes: #2484.\n\nSigned-off-by: Alban Crequy <alban@kinvolk.io>\nSigned-off-by: Rodrigo Campos <rodrigo@kinvolk.io>\nCo-authored-by: Rodrigo Campos <rodrigo@kinvolk.io>",
  "commit_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
  "git_url": "https://github.com/opencontainers/runc/commit/9c444070ec7bb83995dbc0185da68284da71c554",
  "file_path": "libcontainer/nsenter/nsexec.c",
  "func_name": "nl_parse",
  "func_before": "static void nl_parse(int fd, struct nlconfig_t *config)\n{\n\tsize_t len, size;\n\tstruct nlmsghdr hdr;\n\tchar *data, *current;\n\n\t/* Retrieve the netlink header. */\n\tlen = read(fd, &hdr, NLMSG_HDRLEN);\n\tif (len != NLMSG_HDRLEN)\n\t\tbail(\"invalid netlink header length %zu\", len);\n\n\tif (hdr.nlmsg_type == NLMSG_ERROR)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (hdr.nlmsg_type != INIT_MSG)\n\t\tbail(\"unexpected msg type %d\", hdr.nlmsg_type);\n\n\t/* Retrieve data. */\n\tsize = NLMSG_PAYLOAD(&hdr, 0);\n\tcurrent = data = malloc(size);\n\tif (!data)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", size);\n\n\tlen = read(fd, data, size);\n\tif (len != size)\n\t\tbail(\"failed to read netlink payload, %zu != %zu\", len, size);\n\n\t/* Parse the netlink payload. */\n\tconfig->data = data;\n\twhile (current < data + size) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)current;\n\t\tsize_t payload_len = nlattr->nla_len - NLA_HDRLEN;\n\n\t\t/* Advance to payload. */\n\t\tcurrent += NLA_HDRLEN;\n\n\t\t/* Handle payload. */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase CLONE_FLAGS_ATTR:\n\t\t\tconfig->cloneflags = readint32(current);\n\t\t\tbreak;\n\t\tcase ROOTLESS_EUID_ATTR:\n\t\t\tconfig->is_rootless_euid = readint8(current);\t/* boolean */\n\t\t\tbreak;\n\t\tcase OOM_SCORE_ADJ_ATTR:\n\t\t\tconfig->oom_score_adj = current;\n\t\t\tconfig->oom_score_adj_len = payload_len;\n\t\t\tbreak;\n\t\tcase NS_PATHS_ATTR:\n\t\t\tconfig->namespaces = current;\n\t\t\tconfig->namespaces_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAP_ATTR:\n\t\t\tconfig->uidmap = current;\n\t\t\tconfig->uidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAP_ATTR:\n\t\t\tconfig->gidmap = current;\n\t\t\tconfig->gidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAPPATH_ATTR:\n\t\t\tconfig->uidmappath = current;\n\t\t\tconfig->uidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAPPATH_ATTR:\n\t\t\tconfig->gidmappath = current;\n\t\t\tconfig->gidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase SETGROUP_ATTR:\n\t\t\tconfig->is_setgroup = readint8(current);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tcurrent += NLA_ALIGN(payload_len);\n\t}\n}",
  "abstract_func_before": "static void nl_parse(int VAR_0, struct nlconfig_t *VAR_1)\n{\n\tsize_t VAR_2, VAR_3;\n\tstruct nlmsghdr VAR_4;\n\tchar *VAR_5, *VAR_6;\n\n\t/* COMMENT_0 */\n\tVAR_2 = read(VAR_0, &VAR_4, VAR_7);\n\tif (VAR_2 != VAR_7)\n\t\tbail(\"invalid netlink header length %zu\", VAR_2);\n\n\tif (VAR_4.nlmsg_type == VAR_8)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (VAR_4.nlmsg_type != VAR_9)\n\t\tbail(\"unexpected msg type %d\", VAR_4.nlmsg_type);\n\n\t/* COMMENT_1 */\n\tVAR_3 = NLMSG_PAYLOAD(&VAR_4, 0);\n\tVAR_6 = VAR_5 = malloc(VAR_3);\n\tif (!VAR_5)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", VAR_3);\n\n\tVAR_2 = read(VAR_0, VAR_5, VAR_3);\n\tif (VAR_2 != VAR_3)\n\t\tbail(\"failed to read netlink payload, %zu != %zu\", VAR_2, VAR_3);\n\n\t/* COMMENT_2 */\n\tVAR_1->data = VAR_5;\n\twhile (VAR_6 < VAR_5 + VAR_3) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)VAR_6;\n\t\tsize_t VAR_10 = nlattr->nla_len - VAR_11;\n\n\t\t/* COMMENT_3 */\n\t\tVAR_6 += VAR_11;\n\n\t\t/* COMMENT_4 */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase VAR_12:\n\t\t\tVAR_1->cloneflags = readint32(VAR_6);\n\t\t\tbreak;\n\t\tcase VAR_13:\n\t\t\tVAR_1->is_rootless_euid = readint8(VAR_6);\t/* COMMENT_5 */\n\t\t\tbreak;\n\t\tcase VAR_14:\n\t\t\tVAR_1->oom_score_adj = VAR_6;\n\t\t\tVAR_1->oom_score_adj_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_15:\n\t\t\tVAR_1->namespaces = VAR_6;\n\t\t\tVAR_1->namespaces_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_16:\n\t\t\tVAR_1->uidmap = VAR_6;\n\t\t\tVAR_1->uidmap_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_17:\n\t\t\tVAR_1->gidmap = VAR_6;\n\t\t\tVAR_1->gidmap_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_18:\n\t\t\tVAR_1->uidmappath = VAR_6;\n\t\t\tVAR_1->uidmappath_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_19:\n\t\t\tVAR_1->gidmappath = VAR_6;\n\t\t\tVAR_1->gidmappath_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_20:\n\t\t\tVAR_1->is_setgroup = readint8(VAR_6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tVAR_6 += NLA_ALIGN(VAR_10);\n\t}\n}",
  "func_graph_path_before": "opencontainers/runc/9c444070ec7bb83995dbc0185da68284da71c554/nsexec.c/vul/before/1.json",
  "func": "static void nl_parse(int fd, struct nlconfig_t *config)\n{\n\tsize_t len, size;\n\tstruct nlmsghdr hdr;\n\tchar *data, *current;\n\n\t/* Retrieve the netlink header. */\n\tlen = read(fd, &hdr, NLMSG_HDRLEN);\n\tif (len != NLMSG_HDRLEN)\n\t\tbail(\"invalid netlink header length %zu\", len);\n\n\tif (hdr.nlmsg_type == NLMSG_ERROR)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (hdr.nlmsg_type != INIT_MSG)\n\t\tbail(\"unexpected msg type %d\", hdr.nlmsg_type);\n\n\t/* Retrieve data. */\n\tsize = NLMSG_PAYLOAD(&hdr, 0);\n\tcurrent = data = malloc(size);\n\tif (!data)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", size);\n\n\tlen = read(fd, data, size);\n\tif (len != size)\n\t\tbail(\"failed to read netlink payload, %zu != %zu\", len, size);\n\n\t/* Parse the netlink payload. */\n\tconfig->data = data;\n\twhile (current < data + size) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)current;\n\t\tsize_t payload_len = nlattr->nla_len - NLA_HDRLEN;\n\n\t\t/* Advance to payload. */\n\t\tcurrent += NLA_HDRLEN;\n\n\t\t/* Handle payload. */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase CLONE_FLAGS_ATTR:\n\t\t\tconfig->cloneflags = readint32(current);\n\t\t\tbreak;\n\t\tcase ROOTLESS_EUID_ATTR:\n\t\t\tconfig->is_rootless_euid = readint8(current);\t/* boolean */\n\t\t\tbreak;\n\t\tcase OOM_SCORE_ADJ_ATTR:\n\t\t\tconfig->oom_score_adj = current;\n\t\t\tconfig->oom_score_adj_len = payload_len;\n\t\t\tbreak;\n\t\tcase NS_PATHS_ATTR:\n\t\t\tconfig->namespaces = current;\n\t\t\tconfig->namespaces_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAP_ATTR:\n\t\t\tconfig->uidmap = current;\n\t\t\tconfig->uidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAP_ATTR:\n\t\t\tconfig->gidmap = current;\n\t\t\tconfig->gidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAPPATH_ATTR:\n\t\t\tconfig->uidmappath = current;\n\t\t\tconfig->uidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAPPATH_ATTR:\n\t\t\tconfig->gidmappath = current;\n\t\t\tconfig->gidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase SETGROUP_ATTR:\n\t\t\tconfig->is_setgroup = readint8(current);\n\t\t\tbreak;\n\t\tcase MOUNT_SOURCES_ATTR:\n\t\t\tconfig->mountsources = current;\n\t\t\tconfig->mountsources_len = payload_len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tcurrent += NLA_ALIGN(payload_len);\n\t}\n}",
  "abstract_func": "static void nl_parse(int VAR_0, struct nlconfig_t *VAR_1)\n{\n\tsize_t VAR_2, VAR_3;\n\tstruct nlmsghdr VAR_4;\n\tchar *VAR_5, *VAR_6;\n\n\t/* COMMENT_0 */\n\tVAR_2 = read(VAR_0, &VAR_4, VAR_7);\n\tif (VAR_2 != VAR_7)\n\t\tbail(\"invalid netlink header length %zu\", VAR_2);\n\n\tif (VAR_4.nlmsg_type == VAR_8)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (VAR_4.nlmsg_type != VAR_9)\n\t\tbail(\"unexpected msg type %d\", VAR_4.nlmsg_type);\n\n\t/* COMMENT_1 */\n\tVAR_3 = NLMSG_PAYLOAD(&VAR_4, 0);\n\tVAR_6 = VAR_5 = malloc(VAR_3);\n\tif (!VAR_5)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", VAR_3);\n\n\tVAR_2 = read(VAR_0, VAR_5, VAR_3);\n\tif (VAR_2 != VAR_3)\n\t\tbail(\"failed to read netlink payload, %zu != %zu\", VAR_2, VAR_3);\n\n\t/* COMMENT_2 */\n\tVAR_1->data = VAR_5;\n\twhile (VAR_6 < VAR_5 + VAR_3) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)VAR_6;\n\t\tsize_t VAR_10 = nlattr->nla_len - VAR_11;\n\n\t\t/* COMMENT_3 */\n\t\tVAR_6 += VAR_11;\n\n\t\t/* COMMENT_4 */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase VAR_12:\n\t\t\tVAR_1->cloneflags = readint32(VAR_6);\n\t\t\tbreak;\n\t\tcase VAR_13:\n\t\t\tVAR_1->is_rootless_euid = readint8(VAR_6);\t/* COMMENT_5 */\n\t\t\tbreak;\n\t\tcase VAR_14:\n\t\t\tVAR_1->oom_score_adj = VAR_6;\n\t\t\tVAR_1->oom_score_adj_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_15:\n\t\t\tVAR_1->namespaces = VAR_6;\n\t\t\tVAR_1->namespaces_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_16:\n\t\t\tVAR_1->uidmap = VAR_6;\n\t\t\tVAR_1->uidmap_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_17:\n\t\t\tVAR_1->gidmap = VAR_6;\n\t\t\tVAR_1->gidmap_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_18:\n\t\t\tVAR_1->uidmappath = VAR_6;\n\t\t\tVAR_1->uidmappath_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_19:\n\t\t\tVAR_1->gidmappath = VAR_6;\n\t\t\tVAR_1->gidmappath_len = VAR_10;\n\t\t\tbreak;\n\t\tcase VAR_20:\n\t\t\tVAR_1->is_setgroup = readint8(VAR_6);\n\t\t\tbreak;\n\t\tcase VAR_21:\n\t\t\tVAR_1->mountsources = VAR_6;\n\t\t\tVAR_1->mountsources_len = VAR_10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tVAR_6 += NLA_ALIGN(VAR_10);\n\t}\n}",
  "func_graph_path": "opencontainers/runc/9c444070ec7bb83995dbc0185da68284da71c554/nsexec.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -69,6 +69,10 @@\n \t\tcase SETGROUP_ATTR:\n \t\t\tconfig->is_setgroup = readint8(current);\n \t\t\tbreak;\n+\t\tcase MOUNT_SOURCES_ATTR:\n+\t\t\tconfig->mountsources = current;\n+\t\t\tconfig->mountsources_len = payload_len;\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n \t\t}",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\tcase MOUNT_SOURCES_ATTR:",
      "\t\t\tconfig->mountsources = current;",
      "\t\t\tconfig->mountsources_len = payload_len;",
      "\t\t\tbreak;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/opencontainers/runc/pull/2576",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/opencontainers/runc/pull/2576: 403 Client Error: Forbidden for url: https://api.github.com/repos/opencontainers/runc/pulls/2576",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}