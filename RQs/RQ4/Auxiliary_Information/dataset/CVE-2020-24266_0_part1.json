{
  "cve_id": "CVE-2020-24266",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #620 apply get.c functions fixed in #617\n\nAdd safety and failure reporting for packet captures with\ncaplen too small.",
  "commit_hash": "21cce6b1d63a4b431fdc5f239cd23cb7a80d514f",
  "git_url": "https://github.com/appneta/tcpreplay/commit/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f",
  "file_path": "src/send_packets.c",
  "func_name": "fast_edit_packet",
  "func_before": "static inline void\nfast_edit_packet(struct pcap_pkthdr *pkthdr, u_char **pktdata,\n        COUNTER iteration, bool cached, int datalink)\n{\n    uint16_t ether_type;\n    ipv4_hdr_t *ip_hdr = NULL;\n    ipv6_hdr_t *ip6_hdr = NULL;\n    uint32_t src_ip, dst_ip;\n    uint32_t src_ip_orig, dst_ip_orig;\n    int l2_len;\n    u_char *packet = *pktdata;\n\n    if (datalink != DLT_EN10MB && datalink != DLT_JUNIPER_ETHER)\n        fast_edit_packet_dl(pkthdr, pktdata, iteration, cached, datalink);\n\n    if (pkthdr->caplen < (bpf_u_int32)TCPR_IPV6_H) {\n        dbgx(2, \"Packet too short for Unique IP feature: %u\", pkthdr->caplen);\n        return;\n    }\n\n    l2_len = 0;\n    if (datalink == DLT_JUNIPER_ETHER) {\n        if (memcmp(packet, \"MGC\", 3))\n            warnx(\"No Magic Number found: %s (0x%x)\",\n                 pcap_datalink_val_to_description(datalink), datalink);\n\n        if ((packet[3] & 0x80) == 0x80) {\n            l2_len = ntohs(*((uint16_t*)&packet[4]));\n            if (l2_len > 1024) {\n                warnx(\"L2 length too long: %u\", l2_len);\n                return;\n            }\n            l2_len += 6;\n        } else\n            l2_len = 4; /* no header extensions */\n    }\n\n    /* assume Ethernet, IPv4 for now */\n    ether_type = ntohs(((eth_hdr_t*)(packet + l2_len))->ether_type);\n    l2_len += sizeof(eth_hdr_t);\n    while (ether_type == ETHERTYPE_VLAN) {\n         vlan_hdr_t *vlan_hdr = (vlan_hdr_t*)(pktdata + l2_len);\n         ether_type = ntohs(vlan_hdr->vlan_tpid);\n         l2_len += 4;\n    }\n\n    switch (ether_type) {\n    case ETHERTYPE_IP:\n        ip_hdr = (ipv4_hdr_t *)(packet + l2_len);\n        src_ip_orig = src_ip = ntohl(ip_hdr->ip_src.s_addr);\n        dst_ip_orig = dst_ip = ntohl(ip_hdr->ip_dst.s_addr);\n        break;\n\n    case ETHERTYPE_IP6:\n        ip6_hdr = (ipv6_hdr_t *)(packet + l2_len);\n        src_ip_orig = src_ip = ntohl(ip6_hdr->ip_src.__u6_addr.__u6_addr32[3]);\n        dst_ip_orig = dst_ip = ntohl(ip6_hdr->ip_dst.__u6_addr.__u6_addr32[3]);\n        break;\n\n    default:\n        return; /* non-IP */\n    }\n\n    dbgx(2, \"Layer 3 protocol type is: 0x%04x\", ether_type);\n\n    /* swap src/dst IP's in a manner that does not affect CRC */\n    if ((!cached && dst_ip > src_ip) ||\n            (cached && (dst_ip - iteration) > (src_ip - 1 - iteration))) {\n        if (cached) {\n            --src_ip;\n            ++dst_ip;\n        } else {\n            src_ip -= iteration;\n            dst_ip += iteration;\n        }\n\n        /* CRC compensations  for wrap conditions */\n        if (src_ip > src_ip_orig && dst_ip > dst_ip_orig) {\n            dbgx(1, \"dst_ip > src_ip(\" COUNTER_SPEC \"): before(1) src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n            --src_ip;\n            dbgx(1, \"dst_ip > src_ip(\" COUNTER_SPEC \"): after(1)  src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n        } else if (dst_ip < dst_ip_orig && src_ip < src_ip_orig) {\n            dbgx(1, \"dst_ip > src_ip(\" COUNTER_SPEC \"): before(2) src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n            ++dst_ip;\n            dbgx(1, \"dst_ip > src_ip(\" COUNTER_SPEC \"): after(2)  src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n        }\n    } else {\n        if (cached) {\n            ++src_ip;\n            --dst_ip;\n        } else {\n            src_ip += iteration;\n            dst_ip -= iteration;\n        }\n\n        /* CRC compensations  for wrap conditions */\n        if (dst_ip > dst_ip_orig && src_ip > src_ip_orig) {\n            dbgx(1, \"src_ip > dst_ip(\" COUNTER_SPEC \"): before(1) dst_ip=0x%08x src_ip=0x%08x\", iteration, dst_ip, src_ip);\n            --dst_ip;\n            dbgx(1, \"src_ip > dst_ip(\" COUNTER_SPEC \"): after(1)  dst_ip=0x%08x src_ip=0x%08x\", iteration, dst_ip, src_ip);\n        } else if (src_ip < src_ip_orig && dst_ip < dst_ip_orig) {\n            dbgx(1, \"src_ip > dst_ip(\" COUNTER_SPEC \"): before(2) dst_ip=0x%08x src_ip=0x%08x\", iteration, dst_ip, src_ip);\n            ++src_ip;\n            dbgx(1, \"src_ip > dst_ip(\" COUNTER_SPEC \"): after(2)  dst_ip=0x%08x src_ip=0x%08x\", iteration, dst_ip, src_ip);\n        }\n    }\n\n    dbgx(1, \"(\" COUNTER_SPEC \"): final src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n\n    switch (ether_type) {\n    case ETHERTYPE_IP:\n        ip_hdr->ip_src.s_addr = htonl(src_ip);\n        ip_hdr->ip_dst.s_addr = htonl(dst_ip);\n        break;\n\n    case ETHERTYPE_IP6:\n        ip6_hdr->ip_src.__u6_addr.__u6_addr32[3] = htonl(src_ip);\n        ip6_hdr->ip_dst.__u6_addr.__u6_addr32[3] = htonl(dst_ip);\n        break;\n    }\n}",
  "abstract_func_before": "static inline void\nfast_edit_packet(struct pcap_pkthdr *VAR_0, u_char **VAR_1,\n        COUNTER VAR_2, bool VAR_3, int VAR_4)\n{\n    uint16_t VAR_5;\n    ipv4_hdr_t *VAR_6 = NULL;\n    ipv6_hdr_t *VAR_7 = NULL;\n    uint32_t VAR_8, VAR_9;\n    uint32_t VAR_10, VAR_11;\n    int VAR_12;\n    u_char *VAR_13 = *VAR_1;\n\n    if (VAR_4 != VAR_14 && VAR_4 != VAR_15)\n        fast_edit_packet_dl(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n    if (VAR_0->caplen < (bpf_u_int32)VAR_16) {\n        dbgx(2, \"Packet too short for Unique IP feature: %u\", VAR_0->caplen);\n        return;\n    }\n\n    VAR_12 = 0;\n    if (VAR_4 == VAR_15) {\n        if (memcmp(VAR_13, \"MGC\", 3))\n            warnx(\"No Magic Number found: %s (0x%x)\",\n                 pcap_datalink_val_to_description(VAR_4), VAR_4);\n\n        if ((VAR_13[3] & 0x80) == 0x80) {\n            VAR_12 = ntohs(*((uint16_t*)&VAR_13[4]));\n            if (VAR_12 > 1024) {\n                warnx(\"L2 length too long: %u\", VAR_12);\n                return;\n            }\n            VAR_12 += 6;\n        } else\n            VAR_12 = 4; /* COMMENT_0 */\n    }\n\n    /* COMMENT_1 */\n    VAR_5 = ntohs(((eth_hdr_t*)(VAR_13 + VAR_12))->ether_type);\n    VAR_12 += sizeof(eth_hdr_t);\n    while (VAR_5 == VAR_17) {\n         vlan_hdr_t *VAR_18 = (vlan_hdr_t*)(VAR_1 + VAR_12);\n         VAR_5 = ntohs(VAR_18->vlan_tpid);\n         VAR_12 += 4;\n    }\n\n    switch (VAR_5) {\n    case VAR_19:\n        VAR_6 = (ipv4_hdr_t *)(VAR_13 + VAR_12);\n        VAR_10 = VAR_8 = ntohl(VAR_6->ip_src.s_addr);\n        VAR_11 = VAR_9 = ntohl(VAR_6->ip_dst.s_addr);\n        break;\n\n    case VAR_20:\n        VAR_7 = (ipv6_hdr_t *)(VAR_13 + VAR_12);\n        VAR_10 = VAR_8 = ntohl(VAR_7->ip_src.__u6_addr.__u6_addr32[3]);\n        VAR_11 = VAR_9 = ntohl(VAR_7->ip_dst.__u6_addr.__u6_addr32[3]);\n        break;\n\n    default:\n        return; /* COMMENT_2 */\n    }\n\n    dbgx(2, \"Layer 3 protocol type is: 0x%04x\", VAR_5);\n\n    /* COMMENT_3 */\n    if ((!VAR_3 && VAR_9 > VAR_8) ||\n            (VAR_3 && (VAR_9 - VAR_2) > (VAR_8 - 1 - VAR_2))) {\n        if (VAR_3) {\n            --VAR_8;\n            ++VAR_9;\n        } else {\n            VAR_8 -= VAR_2;\n            VAR_9 += VAR_2;\n        }\n\n        /* COMMENT_4 */\n        if (VAR_8 > VAR_10 && VAR_9 > VAR_11) {\n            dbgx(1, \"dst_ip > src_ip(\" VAR_21 \"): before(1) src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n            --VAR_8;\n            dbgx(1, \"dst_ip > src_ip(\" VAR_21 \"): after(1)  src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n        } else if (VAR_9 < VAR_11 && VAR_8 < VAR_10) {\n            dbgx(1, \"dst_ip > src_ip(\" VAR_21 \"): before(2) src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n            ++VAR_9;\n            dbgx(1, \"dst_ip > src_ip(\" VAR_21 \"): after(2)  src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n        }\n    } else {\n        if (VAR_3) {\n            ++VAR_8;\n            --VAR_9;\n        } else {\n            VAR_8 += VAR_2;\n            VAR_9 -= VAR_2;\n        }\n\n        /* COMMENT_4 */\n        if (VAR_9 > VAR_11 && VAR_8 > VAR_10) {\n            dbgx(1, \"src_ip > dst_ip(\" VAR_21 \"): before(1) dst_ip=0x%08x src_ip=0x%08x\", VAR_2, VAR_9, VAR_8);\n            --VAR_9;\n            dbgx(1, \"src_ip > dst_ip(\" VAR_21 \"): after(1)  dst_ip=0x%08x src_ip=0x%08x\", VAR_2, VAR_9, VAR_8);\n        } else if (VAR_8 < VAR_10 && VAR_9 < VAR_11) {\n            dbgx(1, \"src_ip > dst_ip(\" VAR_21 \"): before(2) dst_ip=0x%08x src_ip=0x%08x\", VAR_2, VAR_9, VAR_8);\n            ++VAR_8;\n            dbgx(1, \"src_ip > dst_ip(\" VAR_21 \"): after(2)  dst_ip=0x%08x src_ip=0x%08x\", VAR_2, VAR_9, VAR_8);\n        }\n    }\n\n    dbgx(1, \"(\" VAR_21 \"): final src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n\n    switch (VAR_5) {\n    case VAR_19:\n        VAR_6->ip_src.s_addr = htonl(VAR_8);\n        VAR_6->ip_dst.s_addr = htonl(VAR_9);\n        break;\n\n    case VAR_20:\n        VAR_7->ip_src.__u6_addr.__u6_addr32[3] = htonl(VAR_8);\n        VAR_7->ip_dst.__u6_addr.__u6_addr32[3] = htonl(VAR_9);\n        break;\n    }\n}",
  "func_graph_path_before": "appneta/tcpreplay/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f/send_packets.c/vul/before/1.json",
  "func": "static inline int\nfast_edit_packet(struct pcap_pkthdr *pkthdr, u_char **pktdata,\n        COUNTER iteration, bool cached, int datalink)\n{\n    uint16_t ether_type;\n    ipv4_hdr_t *ip_hdr = NULL;\n    ipv6_hdr_t *ip6_hdr = NULL;\n    uint32_t src_ip, dst_ip;\n    uint32_t src_ip_orig, dst_ip_orig;\n    int l2_len;\n    u_char *packet = *pktdata;\n\n    l2_len = get_l2len(packet, pkthdr->caplen, datalink);\n    if (l2_len < 0)\n        return -1;\n\n    ether_type = get_l2protocol(packet, pkthdr->caplen, datalink);\n    switch (ether_type) {\n    case ETHERTYPE_IP:\n        if (pkthdr->caplen < (bpf_u_int32)(l2_len + sizeof(ipv4_hdr_t))) {\n            dbgx(1, \"IP packet too short for Unique IP feature: %u\", pkthdr->caplen);\n            return -1;\n        }\n        ip_hdr = (ipv4_hdr_t *)(packet + l2_len);\n        src_ip_orig = src_ip = ntohl(ip_hdr->ip_src.s_addr);\n        dst_ip_orig = dst_ip = ntohl(ip_hdr->ip_dst.s_addr);\n        break;\n\n    case ETHERTYPE_IP6:\n        if (pkthdr->caplen < (bpf_u_int32)(l2_len + sizeof(ipv6_hdr_t))) {\n            dbgx(1, \"IP6 packet too short for Unique IP feature: %u\", pkthdr->caplen);\n            return -1;\n        }\n        ip6_hdr = (ipv6_hdr_t *)(packet + l2_len);\n        src_ip_orig = src_ip = ntohl(ip6_hdr->ip_src.__u6_addr.__u6_addr32[3]);\n        dst_ip_orig = dst_ip = ntohl(ip6_hdr->ip_dst.__u6_addr.__u6_addr32[3]);\n        break;\n\n    default:\n        return -1; /* non-IP or packet too short */\n    }\n\n    dbgx(2, \"Layer 3 protocol type is: 0x%04x\", ether_type);\n\n    /* swap src/dst IP's in a manner that does not affect CRC */\n    if ((!cached && dst_ip > src_ip) ||\n            (cached && (dst_ip - iteration) > (src_ip - 1 - iteration))) {\n        if (cached) {\n            --src_ip;\n            ++dst_ip;\n        } else {\n            src_ip -= iteration;\n            dst_ip += iteration;\n        }\n\n        /* CRC compensations  for wrap conditions */\n        if (src_ip > src_ip_orig && dst_ip > dst_ip_orig) {\n            dbgx(1, \"dst_ip > src_ip(\" COUNTER_SPEC \"): before(1) src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n            --src_ip;\n            dbgx(1, \"dst_ip > src_ip(\" COUNTER_SPEC \"): after(1)  src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n        } else if (dst_ip < dst_ip_orig && src_ip < src_ip_orig) {\n            dbgx(1, \"dst_ip > src_ip(\" COUNTER_SPEC \"): before(2) src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n            ++dst_ip;\n            dbgx(1, \"dst_ip > src_ip(\" COUNTER_SPEC \"): after(2)  src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n        }\n    } else {\n        if (cached) {\n            ++src_ip;\n            --dst_ip;\n        } else {\n            src_ip += iteration;\n            dst_ip -= iteration;\n        }\n\n        /* CRC compensations  for wrap conditions */\n        if (dst_ip > dst_ip_orig && src_ip > src_ip_orig) {\n            dbgx(1, \"src_ip > dst_ip(\" COUNTER_SPEC \"): before(1) dst_ip=0x%08x src_ip=0x%08x\", iteration, dst_ip, src_ip);\n            --dst_ip;\n            dbgx(1, \"src_ip > dst_ip(\" COUNTER_SPEC \"): after(1)  dst_ip=0x%08x src_ip=0x%08x\", iteration, dst_ip, src_ip);\n        } else if (src_ip < src_ip_orig && dst_ip < dst_ip_orig) {\n            dbgx(1, \"src_ip > dst_ip(\" COUNTER_SPEC \"): before(2) dst_ip=0x%08x src_ip=0x%08x\", iteration, dst_ip, src_ip);\n            ++src_ip;\n            dbgx(1, \"src_ip > dst_ip(\" COUNTER_SPEC \"): after(2)  dst_ip=0x%08x src_ip=0x%08x\", iteration, dst_ip, src_ip);\n        }\n    }\n\n    dbgx(1, \"(\" COUNTER_SPEC \"): final src_ip=0x%08x dst_ip=0x%08x\", iteration, src_ip, dst_ip);\n\n    switch (ether_type) {\n    case ETHERTYPE_IP:\n        ip_hdr->ip_src.s_addr = htonl(src_ip);\n        ip_hdr->ip_dst.s_addr = htonl(dst_ip);\n        break;\n\n    case ETHERTYPE_IP6:\n        ip6_hdr->ip_src.__u6_addr.__u6_addr32[3] = htonl(src_ip);\n        ip6_hdr->ip_dst.__u6_addr.__u6_addr32[3] = htonl(dst_ip);\n        break;\n    }\n\n    return 0;\n}",
  "abstract_func": "static inline int\nfast_edit_packet(struct pcap_pkthdr *VAR_0, u_char **VAR_1,\n        COUNTER VAR_2, bool VAR_3, int VAR_4)\n{\n    uint16_t VAR_5;\n    ipv4_hdr_t *VAR_6 = NULL;\n    ipv6_hdr_t *VAR_7 = NULL;\n    uint32_t VAR_8, VAR_9;\n    uint32_t VAR_10, VAR_11;\n    int VAR_12;\n    u_char *VAR_13 = *VAR_1;\n\n    VAR_12 = get_l2len(VAR_13, VAR_0->caplen, VAR_4);\n    if (VAR_12 < 0)\n        return -1;\n\n    VAR_5 = get_l2protocol(VAR_13, VAR_0->caplen, VAR_4);\n    switch (VAR_5) {\n    case VAR_14:\n        if (VAR_0->caplen < (VAR_15)(VAR_12 + sizeof(ipv4_hdr_t))) {\n            dbgx(1, \"IP packet too short for Unique IP feature: %u\", VAR_0->caplen);\n            return -1;\n        }\n        VAR_6 = (ipv4_hdr_t *)(VAR_13 + VAR_12);\n        VAR_10 = VAR_8 = ntohl(VAR_6->ip_src.s_addr);\n        VAR_11 = VAR_9 = ntohl(VAR_6->ip_dst.s_addr);\n        break;\n\n    case VAR_16:\n        if (VAR_0->caplen < (VAR_15)(VAR_12 + sizeof(ipv6_hdr_t))) {\n            dbgx(1, \"IP6 packet too short for Unique IP feature: %u\", VAR_0->caplen);\n            return -1;\n        }\n        VAR_7 = (ipv6_hdr_t *)(VAR_13 + VAR_12);\n        VAR_10 = VAR_8 = ntohl(VAR_7->ip_src.__u6_addr.__u6_addr32[3]);\n        VAR_11 = VAR_9 = ntohl(VAR_7->ip_dst.__u6_addr.__u6_addr32[3]);\n        break;\n\n    default:\n        return -1; /* COMMENT_0 */\n    }\n\n    dbgx(2, \"Layer 3 protocol type is: 0x%04x\", VAR_5);\n\n    /* COMMENT_1 */\n    if ((!VAR_3 && VAR_9 > VAR_8) ||\n            (VAR_3 && (VAR_9 - VAR_2) > (VAR_8 - 1 - VAR_2))) {\n        if (VAR_3) {\n            --VAR_8;\n            ++VAR_9;\n        } else {\n            VAR_8 -= VAR_2;\n            VAR_9 += VAR_2;\n        }\n\n        /* COMMENT_2 */\n        if (VAR_8 > VAR_10 && VAR_9 > VAR_11) {\n            dbgx(1, \"dst_ip > src_ip(\" VAR_17 \"): before(1) src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n            --VAR_8;\n            dbgx(1, \"dst_ip > src_ip(\" VAR_17 \"): after(1)  src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n        } else if (VAR_9 < VAR_11 && VAR_8 < VAR_10) {\n            dbgx(1, \"dst_ip > src_ip(\" VAR_17 \"): before(2) src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n            ++VAR_9;\n            dbgx(1, \"dst_ip > src_ip(\" VAR_17 \"): after(2)  src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n        }\n    } else {\n        if (VAR_3) {\n            ++VAR_8;\n            --VAR_9;\n        } else {\n            VAR_8 += VAR_2;\n            VAR_9 -= VAR_2;\n        }\n\n        /* COMMENT_2 */\n        if (VAR_9 > VAR_11 && VAR_8 > VAR_10) {\n            dbgx(1, \"src_ip > dst_ip(\" VAR_17 \"): before(1) dst_ip=0x%08x src_ip=0x%08x\", VAR_2, VAR_9, VAR_8);\n            --VAR_9;\n            dbgx(1, \"src_ip > dst_ip(\" VAR_17 \"): after(1)  dst_ip=0x%08x src_ip=0x%08x\", VAR_2, VAR_9, VAR_8);\n        } else if (VAR_8 < VAR_10 && VAR_9 < VAR_11) {\n            dbgx(1, \"src_ip > dst_ip(\" VAR_17 \"): before(2) dst_ip=0x%08x src_ip=0x%08x\", VAR_2, VAR_9, VAR_8);\n            ++VAR_8;\n            dbgx(1, \"src_ip > dst_ip(\" VAR_17 \"): after(2)  dst_ip=0x%08x src_ip=0x%08x\", VAR_2, VAR_9, VAR_8);\n        }\n    }\n\n    dbgx(1, \"(\" VAR_17 \"): final src_ip=0x%08x dst_ip=0x%08x\", VAR_2, VAR_8, VAR_9);\n\n    switch (VAR_5) {\n    case VAR_14:\n        VAR_6->ip_src.s_addr = htonl(VAR_8);\n        VAR_6->ip_dst.s_addr = htonl(VAR_9);\n        break;\n\n    case VAR_16:\n        VAR_7->ip_src.__u6_addr.__u6_addr32[3] = htonl(VAR_8);\n        VAR_7->ip_dst.__u6_addr.__u6_addr32[3] = htonl(VAR_9);\n        break;\n    }\n\n    return 0;\n}",
  "func_graph_path": "appneta/tcpreplay/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f/send_packets.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static inline void\n+static inline int\n fast_edit_packet(struct pcap_pkthdr *pkthdr, u_char **pktdata,\n         COUNTER iteration, bool cached, int datalink)\n {\n@@ -10,55 +10,34 @@\n     int l2_len;\n     u_char *packet = *pktdata;\n \n-    if (datalink != DLT_EN10MB && datalink != DLT_JUNIPER_ETHER)\n-        fast_edit_packet_dl(pkthdr, pktdata, iteration, cached, datalink);\n+    l2_len = get_l2len(packet, pkthdr->caplen, datalink);\n+    if (l2_len < 0)\n+        return -1;\n \n-    if (pkthdr->caplen < (bpf_u_int32)TCPR_IPV6_H) {\n-        dbgx(2, \"Packet too short for Unique IP feature: %u\", pkthdr->caplen);\n-        return;\n-    }\n-\n-    l2_len = 0;\n-    if (datalink == DLT_JUNIPER_ETHER) {\n-        if (memcmp(packet, \"MGC\", 3))\n-            warnx(\"No Magic Number found: %s (0x%x)\",\n-                 pcap_datalink_val_to_description(datalink), datalink);\n-\n-        if ((packet[3] & 0x80) == 0x80) {\n-            l2_len = ntohs(*((uint16_t*)&packet[4]));\n-            if (l2_len > 1024) {\n-                warnx(\"L2 length too long: %u\", l2_len);\n-                return;\n-            }\n-            l2_len += 6;\n-        } else\n-            l2_len = 4; /* no header extensions */\n-    }\n-\n-    /* assume Ethernet, IPv4 for now */\n-    ether_type = ntohs(((eth_hdr_t*)(packet + l2_len))->ether_type);\n-    l2_len += sizeof(eth_hdr_t);\n-    while (ether_type == ETHERTYPE_VLAN) {\n-         vlan_hdr_t *vlan_hdr = (vlan_hdr_t*)(pktdata + l2_len);\n-         ether_type = ntohs(vlan_hdr->vlan_tpid);\n-         l2_len += 4;\n-    }\n-\n+    ether_type = get_l2protocol(packet, pkthdr->caplen, datalink);\n     switch (ether_type) {\n     case ETHERTYPE_IP:\n+        if (pkthdr->caplen < (bpf_u_int32)(l2_len + sizeof(ipv4_hdr_t))) {\n+            dbgx(1, \"IP packet too short for Unique IP feature: %u\", pkthdr->caplen);\n+            return -1;\n+        }\n         ip_hdr = (ipv4_hdr_t *)(packet + l2_len);\n         src_ip_orig = src_ip = ntohl(ip_hdr->ip_src.s_addr);\n         dst_ip_orig = dst_ip = ntohl(ip_hdr->ip_dst.s_addr);\n         break;\n \n     case ETHERTYPE_IP6:\n+        if (pkthdr->caplen < (bpf_u_int32)(l2_len + sizeof(ipv6_hdr_t))) {\n+            dbgx(1, \"IP6 packet too short for Unique IP feature: %u\", pkthdr->caplen);\n+            return -1;\n+        }\n         ip6_hdr = (ipv6_hdr_t *)(packet + l2_len);\n         src_ip_orig = src_ip = ntohl(ip6_hdr->ip_src.__u6_addr.__u6_addr32[3]);\n         dst_ip_orig = dst_ip = ntohl(ip6_hdr->ip_dst.__u6_addr.__u6_addr32[3]);\n         break;\n \n     default:\n-        return; /* non-IP */\n+        return -1; /* non-IP or packet too short */\n     }\n \n     dbgx(2, \"Layer 3 protocol type is: 0x%04x\", ether_type);\n@@ -118,4 +97,6 @@\n         ip6_hdr->ip_dst.__u6_addr.__u6_addr32[3] = htonl(dst_ip);\n         break;\n     }\n+\n+    return 0;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "static inline void",
      "    if (datalink != DLT_EN10MB && datalink != DLT_JUNIPER_ETHER)",
      "        fast_edit_packet_dl(pkthdr, pktdata, iteration, cached, datalink);",
      "    if (pkthdr->caplen < (bpf_u_int32)TCPR_IPV6_H) {",
      "        dbgx(2, \"Packet too short for Unique IP feature: %u\", pkthdr->caplen);",
      "        return;",
      "    }",
      "",
      "    l2_len = 0;",
      "    if (datalink == DLT_JUNIPER_ETHER) {",
      "        if (memcmp(packet, \"MGC\", 3))",
      "            warnx(\"No Magic Number found: %s (0x%x)\",",
      "                 pcap_datalink_val_to_description(datalink), datalink);",
      "",
      "        if ((packet[3] & 0x80) == 0x80) {",
      "            l2_len = ntohs(*((uint16_t*)&packet[4]));",
      "            if (l2_len > 1024) {",
      "                warnx(\"L2 length too long: %u\", l2_len);",
      "                return;",
      "            }",
      "            l2_len += 6;",
      "        } else",
      "            l2_len = 4; /* no header extensions */",
      "    }",
      "",
      "    /* assume Ethernet, IPv4 for now */",
      "    ether_type = ntohs(((eth_hdr_t*)(packet + l2_len))->ether_type);",
      "    l2_len += sizeof(eth_hdr_t);",
      "    while (ether_type == ETHERTYPE_VLAN) {",
      "         vlan_hdr_t *vlan_hdr = (vlan_hdr_t*)(pktdata + l2_len);",
      "         ether_type = ntohs(vlan_hdr->vlan_tpid);",
      "         l2_len += 4;",
      "    }",
      "",
      "        return; /* non-IP */"
    ],
    "added_lines": [
      "static inline int",
      "    l2_len = get_l2len(packet, pkthdr->caplen, datalink);",
      "    if (l2_len < 0)",
      "        return -1;",
      "    ether_type = get_l2protocol(packet, pkthdr->caplen, datalink);",
      "        if (pkthdr->caplen < (bpf_u_int32)(l2_len + sizeof(ipv4_hdr_t))) {",
      "            dbgx(1, \"IP packet too short for Unique IP feature: %u\", pkthdr->caplen);",
      "            return -1;",
      "        }",
      "        if (pkthdr->caplen < (bpf_u_int32)(l2_len + sizeof(ipv6_hdr_t))) {",
      "            dbgx(1, \"IP6 packet too short for Unique IP feature: %u\", pkthdr->caplen);",
      "            return -1;",
      "        }",
      "        return -1; /* non-IP or packet too short */",
      "",
      "    return 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/640",
  "description": {
    "pr_info": {
      "title": "Bug #620 apply get.c functions fixed in #617",
      "number": 640
    },
    "comment": [
      "Add safety and failure reporting for packet captures with\r\ncaplen too small."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}