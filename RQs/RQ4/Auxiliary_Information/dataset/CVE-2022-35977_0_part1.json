{
  "cve_id": "CVE-2022-35977",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "Avoid integer overflows in SETRANGE and SORT (CVE-2022-35977) (#11720)\n\nAuthenticated users issuing specially crafted SETRANGE and SORT(_RO)\r\ncommands can trigger an integer overflow, resulting with Redis attempting\r\nto allocate impossible amounts of memory and abort with an OOM panic.",
  "commit_hash": "1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7",
  "git_url": "https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7",
  "file_path": "src/t_string.c",
  "func_name": "setrangeCommand",
  "func_before": "void setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Return 0 when setting nothing on a non-existing string */\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* Return existing string length when setting nothing */\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n\n        /* Create a copy when the object is shared or encoded. */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}",
  "abstract_func_before": "void setrangeCommand(client *VAR_0) {\n    robj *VAR_1;\n    long VAR_2;\n    sds VAR_3 = VAR_0->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(VAR_0,VAR_0->argv[2],&VAR_2,NULL) != VAR_4)\n        return;\n\n    if (VAR_2 < 0) {\n        addReplyError(VAR_0,\"offset is out of range\");\n        return;\n    }\n\n    VAR_1 = lookupKeyWrite(VAR_0->db,VAR_0->argv[1]);\n    if (VAR_1 == NULL) {\n        /* COMMENT_0 */\n        if (sdslen(VAR_3) == 0) {\n            addReply(VAR_0,VAR_5.czero);\n            return;\n        }\n\n        /* COMMENT_1 */\n        if (checkStringLength(VAR_0,VAR_2+sdslen(VAR_3)) != VAR_4)\n            return;\n\n        VAR_1 = createObject(VAR_6,sdsnewlen(NULL, VAR_2+sdslen(VAR_3)));\n        dbAdd(VAR_0->db,VAR_0->argv[1],VAR_1);\n    } else {\n        size_t VAR_7;\n\n        /* COMMENT_2 */\n        if (checkType(VAR_0,VAR_1,VAR_6))\n            return;\n\n        /* COMMENT_3 */\n        VAR_7 = stringObjectLen(VAR_1);\n        if (sdslen(VAR_3) == 0) {\n            addReplyLongLong(VAR_0,VAR_7);\n            return;\n        }\n\n        /* COMMENT_1 */\n        if (checkStringLength(VAR_0,VAR_2+sdslen(VAR_3)) != VAR_4)\n            return;\n\n        /* COMMENT_4 */\n        VAR_1 = dbUnshareStringValue(VAR_0->db,VAR_0->argv[1],VAR_1);\n    }\n\n    if (sdslen(VAR_3) > 0) {\n        VAR_1->ptr = sdsgrowzero(VAR_1->ptr,VAR_2+sdslen(VAR_3));\n        memcpy((char*)VAR_1->ptr+VAR_2,VAR_3,sdslen(VAR_3));\n        signalModifiedKey(VAR_0,VAR_0->db,VAR_0->argv[1]);\n        notifyKeyspaceEvent(VAR_8,\n            \"setrange\",VAR_0->argv[1],VAR_0->db->id);\n        VAR_9.dirty++;\n    }\n    addReplyLongLong(VAR_0,sdslen(VAR_1->ptr));\n}",
  "func_graph_path_before": "redis/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7/t_string.c/vul/before/1.json",
  "func": "void setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Return 0 when setting nothing on a non-existing string */\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* Return existing string length when setting nothing */\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        /* Create a copy when the object is shared or encoded. */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}",
  "abstract_func": "void setrangeCommand(client *VAR_0) {\n    robj *VAR_1;\n    long VAR_2;\n    sds VAR_3 = VAR_0->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(VAR_0,VAR_0->argv[2],&VAR_2,NULL) != VAR_4)\n        return;\n\n    if (VAR_2 < 0) {\n        addReplyError(VAR_0,\"offset is out of range\");\n        return;\n    }\n\n    VAR_1 = lookupKeyWrite(VAR_0->db,VAR_0->argv[1]);\n    if (VAR_1 == NULL) {\n        /* COMMENT_0 */\n        if (sdslen(VAR_3) == 0) {\n            addReply(VAR_0,VAR_5.czero);\n            return;\n        }\n\n        /* COMMENT_1 */\n        if (checkStringLength(VAR_0,VAR_2,sdslen(VAR_3)) != VAR_4)\n            return;\n\n        VAR_1 = createObject(VAR_6,sdsnewlen(NULL, VAR_2+sdslen(VAR_3)));\n        dbAdd(VAR_0->db,VAR_0->argv[1],VAR_1);\n    } else {\n        size_t VAR_7;\n\n        /* COMMENT_2 */\n        if (checkType(VAR_0,VAR_1,VAR_6))\n            return;\n\n        /* COMMENT_3 */\n        VAR_7 = stringObjectLen(VAR_1);\n        if (sdslen(VAR_3) == 0) {\n            addReplyLongLong(VAR_0,VAR_7);\n            return;\n        }\n\n        /* COMMENT_1 */\n        if (checkStringLength(VAR_0,VAR_2,sdslen(VAR_3)) != VAR_4)\n            return;\n\n        /* COMMENT_4 */\n        VAR_1 = dbUnshareStringValue(VAR_0->db,VAR_0->argv[1],VAR_1);\n    }\n\n    if (sdslen(VAR_3) > 0) {\n        VAR_1->ptr = sdsgrowzero(VAR_1->ptr,VAR_2+sdslen(VAR_3));\n        memcpy((char*)VAR_1->ptr+VAR_2,VAR_3,sdslen(VAR_3));\n        signalModifiedKey(VAR_0,VAR_0->db,VAR_0->argv[1]);\n        notifyKeyspaceEvent(VAR_8,\n            \"setrange\",VAR_0->argv[1],VAR_0->db->id);\n        VAR_9.dirty++;\n    }\n    addReplyLongLong(VAR_0,sdslen(VAR_1->ptr));\n}",
  "func_graph_path": "redis/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7/t_string.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n         }\n \n         /* Return when the resulting string exceeds allowed size */\n-        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n+        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n             return;\n \n         o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n@@ -40,7 +40,7 @@\n         }\n \n         /* Return when the resulting string exceeds allowed size */\n-        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n+        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n             return;\n \n         /* Create a copy when the object is shared or encoded. */",
  "diff_line_info": {
    "deleted_lines": [
      "        if (checkStringLength(c,offset+sdslen(value)) != C_OK)",
      "        if (checkStringLength(c,offset+sdslen(value)) != C_OK)"
    ],
    "added_lines": [
      "        if (checkStringLength(c,offset,sdslen(value)) != C_OK)",
      "        if (checkStringLength(c,offset,sdslen(value)) != C_OK)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/11720",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/redis/redis/pull/11720: 403 Client Error: Forbidden for url: https://api.github.com/repos/redis/redis/pulls/11720",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses a known security flaw related to integer overflows, preventing memory allocation issues that could crash the system. The code changes correctly modify bounds checks to prevent overflow.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}