{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/exiv2.cpp",
  "func_name": "parseLine",
  "func_before": "bool parseLine(ModifyCmd& modifyCmd, const std::string& line, int num)\n    {\n        const std::string delim = \" \\t\";\n\n        // Skip empty lines and comments\n        std::string::size_type cmdStart = line.find_first_not_of(delim);\n        if (cmdStart == std::string::npos || line[cmdStart] == '#') return false;\n\n        // Get command and key\n        std::string::size_type cmdEnd = line.find_first_of(delim, cmdStart+1);\n        std::string::size_type keyStart = line.find_first_not_of(delim, cmdEnd+1);\n        std::string::size_type keyEnd = line.find_first_of(delim, keyStart+1);\n        if (   cmdStart == std::string::npos\n            || cmdEnd == std::string::npos\n            || keyStart == std::string::npos) {\n            std::string cmdLine ;\n#if defined(_MSC_VER) || defined(__MINGW__)\n            for ( int i = 1 ; i < __argc ; i++ ) { cmdLine += std::string(\" \") + formatArg(__argv[i]) ; }\n#endif\n            throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                               + \": \" + _(\"Invalid command line:\") + cmdLine);\n        }\n\n        std::string cmd(line.substr(cmdStart, cmdEnd-cmdStart));\n        CmdId cmdId = commandId(cmd);\n        if (cmdId == invalidCmdId) {\n            throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                               + \": \" + _(\"Invalid command\") + \" `\" + cmd + \"'\");\n        }\n\n        Exiv2::TypeId defaultType = Exiv2::invalidTypeId;\n        std::string key(line.substr(keyStart, keyEnd-keyStart));\n        MetadataId metadataId = invalidMetadataId;\n        if (cmdId != reg) {\n            try {\n                Exiv2::IptcKey iptcKey(key);\n                metadataId = iptc;\n                defaultType = Exiv2::IptcDataSets::dataSetType(iptcKey.tag(),\n                                                               iptcKey.record());\n            }\n            catch (const Exiv2::AnyError&) {}\n            if (metadataId == invalidMetadataId) {\n                try {\n                    Exiv2::ExifKey exifKey(key);\n                    metadataId = exif;\n                    defaultType = exifKey.defaultTypeId();\n                }\n                catch (const Exiv2::AnyError&) {}\n            }\n            if (metadataId == invalidMetadataId) {\n                try {\n                    Exiv2::XmpKey xmpKey(key);\n                    metadataId = xmp;\n                    defaultType = Exiv2::XmpProperties::propertyType(xmpKey);\n                }\n                catch (const Exiv2::AnyError&) {}\n            }\n            if (metadataId == invalidMetadataId) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                                   + \": \" + _(\"Invalid key\") + \" `\" + key + \"'\");\n            }\n        }\n        std::string value;\n        Exiv2::TypeId type = defaultType;\n        bool explicitType = false;\n        if (cmdId != del) {\n            // Get type and value\n            std::string::size_type typeStart = std::string::npos;\n            if (keyEnd != std::string::npos) typeStart = line.find_first_not_of(delim, keyEnd+1);\n            std::string::size_type typeEnd = std::string::npos;\n            if (typeStart != std::string::npos) typeEnd = line.find_first_of(delim, typeStart+1);\n            std::string::size_type valStart = typeStart;\n            std::string::size_type valEnd = std::string::npos;\n            if (valStart != std::string::npos) valEnd = line.find_last_not_of(delim);\n\n            if (   cmdId == reg\n                && (   keyEnd == std::string::npos\n                    || valStart == std::string::npos)) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                                   + \": \" + _(\"Invalid command line\") + \" \" );\n            }\n\n            if (   cmdId != reg\n                && typeStart != std::string::npos\n                && typeEnd != std::string::npos) {\n                std::string typeStr(line.substr(typeStart, typeEnd-typeStart));\n                Exiv2::TypeId tmpType = Exiv2::TypeInfo::typeId(typeStr);\n                if (tmpType != Exiv2::invalidTypeId) {\n                    valStart = line.find_first_not_of(delim, typeEnd+1);\n                    if (valStart == std::string::npos) {\n                        throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                                           + \": \" + _(\"Invalid command line\") + \" \" );\n                    }\n                    type = tmpType;\n                    explicitType = true;\n                }\n            }\n\n            if (valStart != std::string::npos) {\n                value = parseEscapes(line.substr(valStart, valEnd+1-valStart));\n                std::string::size_type last = value.length()-1;\n                if (   (value[0] == '\"' && value[last] == '\"')\n                       || (value[0] == '\\'' && value[last] == '\\'')) {\n                    value = value.substr(1, value.length()-2);\n                }\n            }\n        }\n\n        modifyCmd.cmdId_ = cmdId;\n        modifyCmd.key_ = key;\n        modifyCmd.metadataId_ = metadataId;\n        modifyCmd.typeId_ = type;\n        modifyCmd.explicitType_ = explicitType;\n        modifyCmd.value_ = value;\n\n        if (cmdId == reg) {\n            if (value.empty()) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage,\n                                   Exiv2::toString(num) + \": \" + _(\"Empty value for key\") +  + \" `\" + key + \"'\");\n            }\n\n            // Registration needs to be done immediately as the new namespaces are\n            // looked up during parsing of subsequent lines (to validate XMP keys).\n            Exiv2::XmpProperties::registerNs(modifyCmd.value_, modifyCmd.key_);\n        }\n\n        return true;\n    }",
  "abstract_func_before": "bool parseLine(ModifyCmd& VAR_0, const std::string& VAR_1, int VAR_2)\n    {\n        const std::string VAR_3 = \" \\t\";\n\n        /* COMMENT_0 */\n        std::string::size_type VAR_4 = VAR_1.find_first_not_of(VAR_3);\n        if (VAR_4 == std::string::npos || VAR_1[VAR_4] == '#') return false;\n\n        /* COMMENT_1 */\n        std::string::size_type VAR_5 = VAR_1.find_first_of(VAR_3, VAR_4+1);\n        std::string::size_type VAR_6 = VAR_1.find_first_not_of(VAR_3, VAR_5+1);\n        std::string::size_type VAR_7 = VAR_1.find_first_of(VAR_3, VAR_6+1);\n        if (   VAR_4 == std::string::npos\n            || VAR_5 == std::string::npos\n            || VAR_6 == std::string::npos) {\n            std::string VAR_8 ;\n#if defined(VAR_9) || defined(VAR_10)\n            for ( int VAR_11 = 1 ; VAR_11 < VAR_12 ; VAR_11++ ) { VAR_8 += std::string(\" \") + formatArg(VAR_13[VAR_11]) ; }\n#endif\n            throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                               + \": \" + _(\"Invalid command line:\") + VAR_8);\n        }\n\n        std::string VAR_14(VAR_1.substr(VAR_4, VAR_5-VAR_4));\n        CmdId VAR_15 = commandId(VAR_14);\n        if (VAR_15 == VAR_16) {\n            throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                               + \": \" + _(\"Invalid command\") + \" `\" + VAR_14 + \"'\");\n        }\n\n        Exiv2::TypeId VAR_17 = Exiv2::invalidTypeId;\n        std::string VAR_18(VAR_1.substr(VAR_6, VAR_7-VAR_6));\n        MetadataId VAR_19 = VAR_20;\n        if (VAR_15 != VAR_21) {\n            try {\n                Exiv2::IptcKey iptcKey(key);\n                VAR_19 = VAR_22;\n                VAR_17 = Exiv2::IptcDataSets::dataSetType(VAR_23.tag(),\n                                                               VAR_23.record());\n            }\n            catch (const Exiv2::AnyError&) {}\n            if (VAR_19 == VAR_20) {\n                try {\n                    Exiv2::ExifKey exifKey(key);\n                    VAR_19 = VAR_24;\n                    VAR_17 = VAR_25.defaultTypeId();\n                }\n                catch (const Exiv2::AnyError&) {}\n            }\n            if (VAR_19 == VAR_20) {\n                try {\n                    Exiv2::XmpKey xmpKey(key);\n                    VAR_19 = VAR_26;\n                    VAR_17 = Exiv2::XmpProperties::propertyType(VAR_27);\n                }\n                catch (const Exiv2::AnyError&) {}\n            }\n            if (VAR_19 == VAR_20) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                                   + \": \" + _(\"Invalid key\") + \" `\" + key + \"'\");\n            }\n        }\n        std::string VAR_28;\n        Exiv2::TypeId VAR_29 = VAR_17;\n        bool VAR_30 = false;\n        if (VAR_15 != VAR_31) {\n            /* COMMENT_2 */\n            std::string::size_type VAR_32 = std::string::npos;\n            if (VAR_7 != std::string::npos) VAR_32 = VAR_1.find_first_not_of(VAR_3, VAR_7+1);\n            std::string::size_type VAR_33 = std::string::npos;\n            if (VAR_32 != std::string::npos) VAR_33 = VAR_1.find_first_of(VAR_3, VAR_32+1);\n            std::string::size_type VAR_34 = VAR_32;\n            std::string::size_type VAR_35 = std::string::npos;\n            if (VAR_34 != std::string::npos) VAR_35 = VAR_1.find_last_not_of(VAR_3);\n\n            if (   VAR_15 == VAR_21\n                && (   VAR_7 == std::string::npos\n                    || VAR_34 == std::string::npos)) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                                   + \": \" + _(\"Invalid command line\") + \" \" );\n            }\n\n            if (   VAR_15 != VAR_21\n                && VAR_32 != std::string::npos\n                && VAR_33 != std::string::npos) {\n                std::string VAR_36(VAR_1.substr(VAR_32, VAR_33-VAR_32));\n                Exiv2::TypeId VAR_37 = Exiv2::TypeInfo::typeId(VAR_36);\n                if (VAR_37 != Exiv2::invalidTypeId) {\n                    VAR_34 = VAR_1.find_first_not_of(VAR_3, VAR_33+1);\n                    if (VAR_34 == std::string::npos) {\n                        throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                                           + \": \" + _(\"Invalid command line\") + \" \" );\n                    }\n                    VAR_29 = VAR_37;\n                    VAR_30 = true;\n                }\n            }\n\n            if (VAR_34 != std::string::npos) {\n                VAR_28 = parseEscapes(VAR_1.substr(VAR_34, VAR_35+1-VAR_34));\n                std::string::size_type VAR_38 = VAR_28.length()-1;\n                if (   (VAR_28[0] == '\"' && VAR_28[VAR_38] == '\"')\n                       || (VAR_28[0] == '\\'' && VAR_28[VAR_38] == '\\'')) {\n                    VAR_28 = VAR_28.substr(1, VAR_28.length()-2);\n                }\n            }\n        }\n\n        VAR_0.cmdId_ = VAR_15;\n        VAR_0.key_ = key;\n        VAR_0.metadataId_ = VAR_19;\n        VAR_0.typeId_ = VAR_29;\n        VAR_0.explicitType_ = VAR_30;\n        VAR_0.value_ = VAR_28;\n\n        if (VAR_15 == VAR_21) {\n            if (VAR_28.empty()) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage,\n                                   Exiv2::toString(VAR_2) + \": \" + _(\"Empty value for key\") +  + \" `\" + key + \"'\");\n            }\n\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            Exiv2::XmpProperties::registerNs(VAR_0.value_, VAR_0.key_);\n        }\n\n        return true;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/exiv2.cpp/vul/before/0.json",
  "func": "bool parseLine(ModifyCmd& modifyCmd, const std::string& line, int num)\n    {\n        const std::string delim = \" \\t\";\n\n        // Skip empty lines and comments\n        std::string::size_type cmdStart = line.find_first_not_of(delim);\n        if (cmdStart == std::string::npos || line[cmdStart] == '#') return false;\n\n        // Get command and key\n        std::string::size_type cmdEnd = line.find_first_of(delim, cmdStart+1);\n        std::string::size_type keyStart = line.find_first_not_of(delim, cmdEnd+1);\n        std::string::size_type keyEnd = line.find_first_of(delim, keyStart+1);\n        if (   cmdStart == std::string::npos\n            || cmdEnd == std::string::npos\n            || keyStart == std::string::npos) {\n            std::string cmdLine ;\n#if defined(_MSC_VER) || defined(__MINGW__)\n            for ( int i = 1 ; i < __argc ; i++ ) { cmdLine += std::string(\" \") + formatArg(__argv[i]) ; }\n#endif\n            throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                               + \": \" + _(\"Invalid command line:\") + cmdLine);\n        }\n\n        std::string cmd(line.substr(cmdStart, cmdEnd-cmdStart));\n        CmdId cmdId = commandId(cmd);\n        if (cmdId == invalidCmdId) {\n            throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                               + \": \" + _(\"Invalid command\") + \" `\" + cmd + \"'\");\n        }\n\n        Exiv2::TypeId defaultType = Exiv2::invalidTypeId;\n        std::string key(line.substr(keyStart, keyEnd-keyStart));\n        MetadataId metadataId = invalidMetadataId;\n        if (cmdId != reg) {\n            try {\n                Exiv2::IptcKey iptcKey(key);\n                metadataId = iptc;\n                defaultType = Exiv2::IptcDataSets::dataSetType(iptcKey.tag(),\n                                                               iptcKey.record());\n            }\n            catch (const Exiv2::AnyError&) {}\n            if (metadataId == invalidMetadataId) {\n                try {\n                    Exiv2::ExifKey exifKey(key);\n                    metadataId = exif;\n                    defaultType = exifKey.defaultTypeId();\n                }\n                catch (const Exiv2::AnyError&) {}\n            }\n            if (metadataId == invalidMetadataId) {\n                try {\n                    Exiv2::XmpKey xmpKey(key);\n                    metadataId = xmp;\n                    defaultType = Exiv2::XmpProperties::propertyType(xmpKey);\n                }\n                catch (const Exiv2::AnyError&) {}\n            }\n            if (metadataId == invalidMetadataId) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                                   + \": \" + _(\"Invalid key\") + \" `\" + key + \"'\");\n            }\n        }\n        std::string value;\n        Exiv2::TypeId type = defaultType;\n        bool explicitType = false;\n        if (cmdId != del) {\n            // Get type and value\n            std::string::size_type typeStart = std::string::npos;\n            if (keyEnd != std::string::npos) typeStart = line.find_first_not_of(delim, keyEnd+1);\n            std::string::size_type typeEnd = std::string::npos;\n            if (typeStart != std::string::npos) typeEnd = line.find_first_of(delim, typeStart+1);\n            std::string::size_type valStart = typeStart;\n            std::string::size_type valEnd = std::string::npos;\n            if (valStart != std::string::npos) valEnd = line.find_last_not_of(delim);\n\n            if (   cmdId == reg\n                && (   keyEnd == std::string::npos\n                    || valStart == std::string::npos)) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                                   + \": \" + _(\"Invalid command line\") + \" \" );\n            }\n\n            if (   cmdId != reg\n                && typeStart != std::string::npos\n                && typeEnd != std::string::npos) {\n                std::string typeStr(line.substr(typeStart, typeEnd-typeStart));\n                Exiv2::TypeId tmpType = Exiv2::TypeInfo::typeId(typeStr);\n                if (tmpType != Exiv2::invalidTypeId) {\n                    valStart = line.find_first_not_of(delim, typeEnd+1);\n                    if (valStart == std::string::npos) {\n                        throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(num)\n                                           + \": \" + _(\"Invalid command line\") + \" \" );\n                    }\n                    type = tmpType;\n                    explicitType = true;\n                }\n            }\n\n            if (valStart != std::string::npos) {\n                value = parseEscapes(line.substr(valStart, valEnd+1-valStart));\n                std::string::size_type last = value.length()-1;\n                if (   (value.at(0) == '\"' && value.at(last) == '\"')\n                       || (value.at(0) == '\\'' && value.at(last) == '\\'')) {\n                    value = value.substr(1, value.length()-2);\n                }\n            }\n        }\n\n        modifyCmd.cmdId_ = cmdId;\n        modifyCmd.key_ = key;\n        modifyCmd.metadataId_ = metadataId;\n        modifyCmd.typeId_ = type;\n        modifyCmd.explicitType_ = explicitType;\n        modifyCmd.value_ = value;\n\n        if (cmdId == reg) {\n            if (value.empty()) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage,\n                                   Exiv2::toString(num) + \": \" + _(\"Empty value for key\") +  + \" `\" + key + \"'\");\n            }\n\n            // Registration needs to be done immediately as the new namespaces are\n            // looked up during parsing of subsequent lines (to validate XMP keys).\n            Exiv2::XmpProperties::registerNs(modifyCmd.value_, modifyCmd.key_);\n        }\n\n        return true;\n    }",
  "abstract_func": "bool parseLine(ModifyCmd& VAR_0, const std::string& VAR_1, int VAR_2)\n    {\n        const std::string VAR_3 = \" \\t\";\n\n        /* COMMENT_0 */\n        std::string::size_type VAR_4 = VAR_1.find_first_not_of(VAR_3);\n        if (VAR_4 == std::string::npos || VAR_1[VAR_4] == '#') return false;\n\n        /* COMMENT_1 */\n        std::string::size_type VAR_5 = VAR_1.find_first_of(VAR_3, VAR_4+1);\n        std::string::size_type VAR_6 = VAR_1.find_first_not_of(VAR_3, VAR_5+1);\n        std::string::size_type VAR_7 = VAR_1.find_first_of(VAR_3, VAR_6+1);\n        if (   VAR_4 == std::string::npos\n            || VAR_5 == std::string::npos\n            || VAR_6 == std::string::npos) {\n            std::string VAR_8 ;\n#if defined(VAR_9) || defined(VAR_10)\n            for ( int VAR_11 = 1 ; VAR_11 < VAR_12 ; VAR_11++ ) { VAR_8 += std::string(\" \") + formatArg(VAR_13[VAR_11]) ; }\n#endif\n            throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                               + \": \" + _(\"Invalid command line:\") + VAR_8);\n        }\n\n        std::string VAR_14(VAR_1.substr(VAR_4, VAR_5-VAR_4));\n        CmdId VAR_15 = commandId(VAR_14);\n        if (VAR_15 == VAR_16) {\n            throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                               + \": \" + _(\"Invalid command\") + \" `\" + VAR_14 + \"'\");\n        }\n\n        Exiv2::TypeId VAR_17 = Exiv2::invalidTypeId;\n        std::string VAR_18(VAR_1.substr(VAR_6, VAR_7-VAR_6));\n        MetadataId VAR_19 = VAR_20;\n        if (VAR_15 != VAR_21) {\n            try {\n                Exiv2::IptcKey iptcKey(key);\n                VAR_19 = VAR_22;\n                VAR_17 = Exiv2::IptcDataSets::dataSetType(VAR_23.tag(),\n                                                               VAR_23.record());\n            }\n            catch (const Exiv2::AnyError&) {}\n            if (VAR_19 == VAR_20) {\n                try {\n                    Exiv2::ExifKey exifKey(key);\n                    VAR_19 = VAR_24;\n                    VAR_17 = VAR_25.defaultTypeId();\n                }\n                catch (const Exiv2::AnyError&) {}\n            }\n            if (VAR_19 == VAR_20) {\n                try {\n                    Exiv2::XmpKey xmpKey(key);\n                    VAR_19 = VAR_26;\n                    VAR_17 = Exiv2::XmpProperties::propertyType(VAR_27);\n                }\n                catch (const Exiv2::AnyError&) {}\n            }\n            if (VAR_19 == VAR_20) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                                   + \": \" + _(\"Invalid key\") + \" `\" + key + \"'\");\n            }\n        }\n        std::string VAR_28;\n        Exiv2::TypeId VAR_29 = VAR_17;\n        bool VAR_30 = false;\n        if (VAR_15 != VAR_31) {\n            /* COMMENT_2 */\n            std::string::size_type VAR_32 = std::string::npos;\n            if (VAR_7 != std::string::npos) VAR_32 = VAR_1.find_first_not_of(VAR_3, VAR_7+1);\n            std::string::size_type VAR_33 = std::string::npos;\n            if (VAR_32 != std::string::npos) VAR_33 = VAR_1.find_first_of(VAR_3, VAR_32+1);\n            std::string::size_type VAR_34 = VAR_32;\n            std::string::size_type VAR_35 = std::string::npos;\n            if (VAR_34 != std::string::npos) VAR_35 = VAR_1.find_last_not_of(VAR_3);\n\n            if (   VAR_15 == VAR_21\n                && (   VAR_7 == std::string::npos\n                    || VAR_34 == std::string::npos)) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                                   + \": \" + _(\"Invalid command line\") + \" \" );\n            }\n\n            if (   VAR_15 != VAR_21\n                && VAR_32 != std::string::npos\n                && VAR_33 != std::string::npos) {\n                std::string VAR_36(VAR_1.substr(VAR_32, VAR_33-VAR_32));\n                Exiv2::TypeId VAR_37 = Exiv2::TypeInfo::typeId(VAR_36);\n                if (VAR_37 != Exiv2::invalidTypeId) {\n                    VAR_34 = VAR_1.find_first_not_of(VAR_3, VAR_33+1);\n                    if (VAR_34 == std::string::npos) {\n                        throw Exiv2::Error(Exiv2::kerErrorMessage, Exiv2::toString(VAR_2)\n                                           + \": \" + _(\"Invalid command line\") + \" \" );\n                    }\n                    VAR_29 = VAR_37;\n                    VAR_30 = true;\n                }\n            }\n\n            if (VAR_34 != std::string::npos) {\n                VAR_28 = parseEscapes(VAR_1.substr(VAR_34, VAR_35+1-VAR_34));\n                std::string::size_type VAR_38 = VAR_28.length()-1;\n                if (   (VAR_28.at(0) == '\"' && VAR_28.at(VAR_38) == '\"')\n                       || (VAR_28.at(0) == '\\'' && VAR_28.at(VAR_38) == '\\'')) {\n                    VAR_28 = VAR_28.substr(1, VAR_28.length()-2);\n                }\n            }\n        }\n\n        VAR_0.cmdId_ = VAR_15;\n        VAR_0.key_ = key;\n        VAR_0.metadataId_ = VAR_19;\n        VAR_0.typeId_ = VAR_29;\n        VAR_0.explicitType_ = VAR_30;\n        VAR_0.value_ = VAR_28;\n\n        if (VAR_15 == VAR_21) {\n            if (VAR_28.empty()) {\n                throw Exiv2::Error(Exiv2::kerErrorMessage,\n                                   Exiv2::toString(VAR_2) + \": \" + _(\"Empty value for key\") +  + \" `\" + key + \"'\");\n            }\n\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            Exiv2::XmpProperties::registerNs(VAR_0.value_, VAR_0.key_);\n        }\n\n        return true;\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/exiv2.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -99,8 +99,8 @@\n             if (valStart != std::string::npos) {\n                 value = parseEscapes(line.substr(valStart, valEnd+1-valStart));\n                 std::string::size_type last = value.length()-1;\n-                if (   (value[0] == '\"' && value[last] == '\"')\n-                       || (value[0] == '\\'' && value[last] == '\\'')) {\n+                if (   (value.at(0) == '\"' && value.at(last) == '\"')\n+                       || (value.at(0) == '\\'' && value.at(last) == '\\'')) {\n                     value = value.substr(1, value.length()-2);\n                 }\n             }",
  "diff_line_info": {
    "deleted_lines": [
      "                if (   (value[0] == '\"' && value[last] == '\"')",
      "                       || (value[0] == '\\'' && value[last] == '\\'')) {"
    ],
    "added_lines": [
      "                if (   (value.at(0) == '\"' && value.at(last) == '\"')",
      "                       || (value.at(0) == '\\'' && value.at(last) == '\\'')) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.8  \n\nThe change replaces direct array access with bounds-checked access using .at(), which prevents buffer overflows—a security concern. The commit message suggests a security focus, though the provided vulnerability description mentions a different issue. The code change is a security fix."
}