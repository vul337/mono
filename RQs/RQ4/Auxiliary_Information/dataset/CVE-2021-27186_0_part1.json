{
  "cve_id": "CVE-2021-27186",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "fluent/fluent-bit",
  "commit_msg": "http_server: v1: metrics: fix potential SIGSEGV by memory allocation errors\n\nThis is a follow up on PR 3045. While 3045 fixed the potential SIGSERV\nissue caused by memory allocation error in flb_avro, after searching/reviewing\nit looks like  src/http_server/api/v1/metrics.c also consists of several\nsimilar issues.\n\nThis PR adds proper check to prevent the potential SIGSERV issues.\n\nSigned-off-by: Yong Tang <yong.tang.github@outlook.com>",
  "commit_hash": "4deb051cb0277d32ab402da4f941f6e502518388",
  "git_url": "https://github.com/fluent/fluent-bit/commit/4deb051cb0277d32ab402da4f941f6e502518388",
  "file_path": "src/http_server/api/v1/metrics.c",
  "func_name": "cb_metrics_prometheus",
  "func_before": "void cb_metrics_prometheus(mk_request_t *request, void *data)\n{\n    int i;\n    int j;\n    int m;\n    int len;\n    int time_len;\n    int start_time_len;\n    size_t index;\n    size_t num_metrics = 0;\n    long now;\n    flb_sds_t sds;\n    flb_sds_t sds_metric;\n    flb_sds_t tmp_sds;\n    struct flb_sds *metric_helptxt_head;\n    flb_sds_t metric_helptxt;\n    size_t off = 0;\n    struct flb_hs_buf *buf;\n    msgpack_unpacked result;\n    msgpack_object map;\n    char tmp[32];\n    char time_str[64];\n    char start_time_str[64];\n    char* *metrics_arr;\n    struct timeval tp;\n    struct flb_hs *hs = data;\n    struct flb_config *config = hs->config;\n\n    buf = metrics_get_latest();\n    if (!buf) {\n        mk_http_status(request, 404);\n        mk_http_done(request);\n        return;\n    }\n\n    /* ref count */\n    buf->users++;\n\n    /* Compose outgoing buffer string */\n    sds = flb_sds_create_size(1024);\n    if (!sds) {\n        mk_http_status(request, 500);\n        mk_http_done(request);\n        buf->users--;\n        return;\n    }\n\n    /* length of HELP text */\n    metric_helptxt = flb_sds_create_size(128);\n    if (!metric_helptxt) {\n        flb_sds_destroy(sds);\n        mk_http_status(request, 500);\n        mk_http_done(request);\n        buf->users--;\n        return;\n    }\n    metric_helptxt_head = FLB_SDS_HEADER(metric_helptxt);\n\n    /* current time */\n    gettimeofday(&tp, NULL);\n    now = tp.tv_sec * 1000 + tp.tv_usec / 1000;\n    time_len = snprintf(time_str, sizeof(time_str) - 1, \"%lu\", now);\n    start_time_len = snprintf(start_time_str, sizeof(start_time_str) - 1, \"%lu\", config->init_time);\n\n    /*\n     * fluentbit_input_records[name=\"cpu0\", hostname=\"${HOSTNAME}\"] NUM TIMESTAMP\n     * fluentbit_input_bytes[name=\"cpu0\", hostname=\"${HOSTNAME}\"] NUM TIMESTAMP\n     */\n    index = 0;\n    msgpack_unpacked_init(&result);\n    msgpack_unpack_next(&result, buf->raw_data, buf->raw_size, &off);\n    map = result.data;\n\n    /* we need to know number of exposed metrics to reserve a memory */\n    for (i = 0; i < map.via.map.size; i++) {\n        msgpack_object v = map.via.map.ptr[i].val;\n        /* Iterate sub-map */\n        for (j = 0; j < v.via.map.size; j++) {\n            msgpack_object sv = v.via.map.ptr[j].val;\n            for (m = 0; m < sv.via.map.size; m++) {\n                num_metrics++;\n            }\n        }\n    }\n    metrics_arr = flb_malloc(num_metrics * sizeof(char*));\n\n    for (i = 0; i < map.via.map.size; i++) {\n        msgpack_object k;\n        msgpack_object v;\n\n        /* Keys: input, output */\n        k = map.via.map.ptr[i].key;\n        v = map.via.map.ptr[i].val;\n\n        /* Iterate sub-map */\n        for (j = 0; j < v.via.map.size; j++) {\n            msgpack_object sk;\n            msgpack_object sv;\n\n            /* Keys: plugin name , values: metrics */\n            sk = v.via.map.ptr[j].key;\n            sv = v.via.map.ptr[j].val;\n\n            for (m = 0; m < sv.via.map.size; m++) {\n                msgpack_object mk;\n                msgpack_object mv;\n\n                mk = sv.via.map.ptr[m].key;\n                mv = sv.via.map.ptr[m].val;\n\n                /* Convert metric value to string */\n                len = snprintf(tmp, sizeof(tmp) - 1, \"%\" PRIu64 \" \", mv.via.u64);\n                if (len < 0) {\n                    goto error;\n                }\n\n                /* Allocate buffer */\n                sds_metric = flb_sds_create_size(k.via.str.size\n                                                 + mk.via.str.size\n                                                 + sk.via.str.size\n                                                 + len + time_len + 28);\n                if (sds_metric == NULL) {\n                    goto error;\n                }\n\n                sds_metric = flb_sds_cat(sds_metric, \"fluentbit_\", 10);\n                sds_metric = flb_sds_cat(sds_metric, k.via.str.ptr, k.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"_\", 1);\n                sds_metric = flb_sds_cat(sds_metric, mk.via.str.ptr, mk.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"_total{name=\\\"\", 13);\n                sds_metric = flb_sds_cat(sds_metric, sk.via.str.ptr, sk.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"\\\"} \", 3);\n                sds_metric = flb_sds_cat(sds_metric, tmp, len);\n                sds_metric = flb_sds_cat(sds_metric, time_str, time_len);\n                sds_metric = flb_sds_cat(sds_metric, \"\\n\", 1);\n                metrics_arr[index] = sds_metric;\n                index++;\n            }\n        }\n    }\n\n    /*  Sort metrics in alphabetic order, so we can group them later. */\n    qsort(metrics_arr, num_metrics, sizeof(char *), string_cmp);\n\n    /* When a new metric starts add HELP and TYPE annotation. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP \", 7);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0]));\n    null_check(tmp_sds);\n    if (!metrics_help_txt(metrics_arr[0], &metric_helptxt)) {\n        goto error;\n    }\n    tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE \", 7);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0]));\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \" counter\\n\", 9);\n    null_check(tmp_sds);\n\n    for (i = 0; i < num_metrics; i++) {\n        tmp_sds = flb_sds_cat(sds, metrics_arr[i], strlen(metrics_arr[i]));\n        null_check(tmp_sds);\n        if ((i != num_metrics - 1) && (is_same_metric(metrics_arr[i], metrics_arr[i+1]) == 0)) {\n            tmp_sds = flb_sds_cat(sds, \"# HELP \", 7);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1]));\n            null_check(tmp_sds);\n            metric_helptxt_head->len = 0;\n            if (!metrics_help_txt(metrics_arr[i+1], &metric_helptxt)) {\n                goto error;\n            }\n            tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, \"# TYPE \", 7);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1]));\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, \" counter\\n\", 9);\n            null_check(tmp_sds);\n        }\n    }\n    /* Attach process_start_time_seconds metric. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\\n\", 89);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE process_start_time_seconds gauge\\n\", 40);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"process_start_time_seconds \", 27);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, start_time_str, start_time_len);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"\\n\", 1);\n    null_check(tmp_sds);\n\n    /* Attach fluentbit_build_info metric. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP fluentbit_build_info Build version information.\\n\", 55);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE fluentbit_build_info gauge\\n\", 34);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"fluentbit_build_info{version=\\\"\", 30);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, FLB_VERSION_STR, sizeof(FLB_VERSION_STR) - 1);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"\\\",edition=\\\"\", 11);\n    null_check(tmp_sds);\n#ifdef FLB_ENTERPRISE\n    tmp_sds = flb_sds_cat(sds, \"Enterprise\\\"} 1\\n\", 15);\n    null_check(tmp_sds);\n#else\n    tmp_sds = flb_sds_cat(sds, \"Community\\\"} 1\\n\", 14);\n    null_check(tmp_sds);\n#endif\n\n    msgpack_unpacked_destroy(&result);\n    buf->users--;\n\n    mk_http_status(request, 200);\n    mk_http_header(request,\n                   \"Content-Type\", 12,\n                   PROMETHEUS_HEADER, sizeof(PROMETHEUS_HEADER) - 1);\n    mk_http_send(request, sds, flb_sds_len(sds), NULL);\n    for (i = 0; i < num_metrics; i++) {\n      flb_sds_destroy(metrics_arr[i]);\n    }\n    flb_free(metrics_arr);\n    flb_sds_destroy(sds);\n    flb_sds_destroy(metric_helptxt);\n\n    mk_http_done(request);\n    return;\n\nerror:\n    mk_http_status(request, 500);\n    mk_http_done(request);\n    buf->users--;\n\n    for (i = 0; i < index; i++) {\n      flb_sds_destroy(metrics_arr[i]);\n    }\n    flb_free(metrics_arr);\n    flb_sds_destroy(sds);\n    flb_sds_destroy(metric_helptxt);\n    msgpack_unpacked_destroy(&result);\n}",
  "abstract_func_before": "void cb_metrics_prometheus(mk_request_t *VAR_0, void *VAR_1)\n{\n    int VAR_2;\n    int VAR_3;\n    int VAR_4;\n    int VAR_5;\n    int VAR_6;\n    int VAR_7;\n    size_t VAR_8;\n    size_t VAR_9 = 0;\n    long VAR_10;\n    flb_sds_t VAR_11;\n    flb_sds_t VAR_12;\n    flb_sds_t VAR_13;\n    struct flb_sds *VAR_14;\n    flb_sds_t VAR_15;\n    size_t VAR_16 = 0;\n    struct flb_hs_buf *VAR_17;\n    msgpack_unpacked VAR_18;\n    msgpack_object VAR_19;\n    char VAR_20[32];\n    char VAR_21[64];\n    char VAR_22[64];\n    char* *VAR_23;\n    struct timeval VAR_24;\n    struct flb_hs *VAR_25 = VAR_1;\n    struct flb_config *VAR_26 = VAR_25->config;\n\n    VAR_17 = metrics_get_latest();\n    if (!VAR_17) {\n        mk_http_status(VAR_0, 404);\n        mk_http_done(VAR_0);\n        return;\n    }\n\n    /* COMMENT_0 */\n    VAR_17->users++;\n\n    /* COMMENT_1 */\n    VAR_11 = flb_sds_create_size(1024);\n    if (!VAR_11) {\n        mk_http_status(VAR_0, 500);\n        mk_http_done(VAR_0);\n        VAR_17->users--;\n        return;\n    }\n\n    /* COMMENT_2 */\n    VAR_15 = flb_sds_create_size(128);\n    if (!VAR_15) {\n        flb_sds_destroy(VAR_11);\n        mk_http_status(VAR_0, 500);\n        mk_http_done(VAR_0);\n        VAR_17->users--;\n        return;\n    }\n    VAR_14 = FLB_SDS_HEADER(VAR_15);\n\n    /* COMMENT_3 */\n    gettimeofday(&VAR_24, NULL);\n    VAR_10 = VAR_24.tv_sec * 1000 + VAR_24.tv_usec / 1000;\n    VAR_6 = snprintf(VAR_21, sizeof(VAR_21) - 1, \"%lu\", VAR_10);\n    VAR_7 = snprintf(VAR_22, sizeof(VAR_22) - 1, \"%lu\", VAR_26->init_time);\n\n    /* COMMENT_4 */\n                                                                                 \n                                                                               \n       \n    VAR_8 = 0;\n    msgpack_unpacked_init(&VAR_18);\n    msgpack_unpack_next(&VAR_18, VAR_17->raw_data, VAR_17->raw_size, &VAR_16);\n    VAR_19 = VAR_18.data;\n\n    /* COMMENT_8 */\n    for (VAR_2 = 0; VAR_2 < VAR_19.via.map.size; VAR_2++) {\n        msgpack_object VAR_27 = VAR_19.via.map.ptr[VAR_2].val;\n        /* COMMENT_9 */\n        for (VAR_3 = 0; VAR_3 < VAR_27.via.map.size; VAR_3++) {\n            msgpack_object VAR_28 = VAR_27.via.map.ptr[VAR_3].val;\n            for (VAR_4 = 0; VAR_4 < VAR_28.via.map.size; VAR_4++) {\n                VAR_9++;\n            }\n        }\n    }\n    VAR_23 = flb_malloc(VAR_9 * sizeof(char*));\n\n    for (VAR_2 = 0; VAR_2 < VAR_19.via.map.size; VAR_2++) {\n        msgpack_object VAR_29;\n        msgpack_object VAR_27;\n\n        /* COMMENT_10 */\n        VAR_29 = VAR_19.via.map.ptr[VAR_2].key;\n        VAR_27 = VAR_19.via.map.ptr[VAR_2].val;\n\n        /* COMMENT_9 */\n        for (VAR_3 = 0; VAR_3 < VAR_27.via.map.size; VAR_3++) {\n            msgpack_object VAR_30;\n            msgpack_object VAR_28;\n\n            /* COMMENT_11 */\n            VAR_30 = VAR_27.via.map.ptr[VAR_3].key;\n            VAR_28 = VAR_27.via.map.ptr[VAR_3].val;\n\n            for (VAR_4 = 0; VAR_4 < VAR_28.via.map.size; VAR_4++) {\n                msgpack_object VAR_31;\n                msgpack_object VAR_32;\n\n                VAR_31 = VAR_28.via.map.ptr[VAR_4].key;\n                VAR_32 = VAR_28.via.map.ptr[VAR_4].val;\n\n                /* COMMENT_12 */\n                VAR_5 = snprintf(VAR_20, sizeof(VAR_20) - 1, \"%\" VAR_33 \" \", VAR_32.via.u64);\n                if (VAR_5 < 0) {\n                    goto error;\n                }\n\n                /* COMMENT_13 */\n                VAR_12 = flb_sds_create_size(VAR_29.via.str.size\n                                                 + VAR_31.via.str.size\n                                                 + VAR_30.via.str.size\n                                                 + VAR_5 + VAR_6 + 28);\n                if (VAR_12 == NULL) {\n                    goto error;\n                }\n\n                VAR_12 = flb_sds_cat(VAR_12, \"fluentbit_\", 10);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_29.via.str.ptr, VAR_29.via.str.size);\n                VAR_12 = flb_sds_cat(VAR_12, \"_\", 1);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_31.via.str.ptr, VAR_31.via.str.size);\n                VAR_12 = flb_sds_cat(VAR_12, \"_total{name=\\\"\", 13);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_30.via.str.ptr, VAR_30.via.str.size);\n                VAR_12 = flb_sds_cat(VAR_12, \"\\\"} \", 3);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_20, VAR_5);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_21, VAR_6);\n                VAR_12 = flb_sds_cat(VAR_12, \"\\n\", 1);\n                VAR_23[VAR_8] = VAR_12;\n                VAR_8++;\n            }\n        }\n    }\n\n    /* COMMENT_14 */\n    qsort(VAR_23, VAR_9, sizeof(char *), VAR_34);\n\n    /* COMMENT_15 */\n    VAR_13 = flb_sds_cat(VAR_11, \"# HELP \", 7);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, VAR_23[0], extract_metric_name_end_position(VAR_23[0]));\n    null_check(VAR_13);\n    if (!metrics_help_txt(VAR_23[0], &VAR_15)) {\n        goto error;\n    }\n    VAR_13 = flb_sds_cat(VAR_11, VAR_15, VAR_14->len);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"# TYPE \", 7);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, VAR_23[0], extract_metric_name_end_position(VAR_23[0]));\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \" counter\\n\", 9);\n    null_check(VAR_13);\n\n    for (VAR_2 = 0; VAR_2 < VAR_9; VAR_2++) {\n        VAR_13 = flb_sds_cat(VAR_11, VAR_23[VAR_2], strlen(VAR_23[VAR_2]));\n        null_check(VAR_13);\n        if ((VAR_2 != VAR_9 - 1) && (is_same_metric(VAR_23[VAR_2], VAR_23[VAR_2+1]) == 0)) {\n            VAR_13 = flb_sds_cat(VAR_11, \"# HELP \", 7);\n            null_check(VAR_13);\n            VAR_13 = flb_sds_cat(VAR_11, VAR_23[VAR_2+1], extract_metric_name_end_position(VAR_23[VAR_2+1]));\n            null_check(VAR_13);\n            VAR_14->len = 0;\n            if (!metrics_help_txt(VAR_23[VAR_2+1], &VAR_15)) {\n                goto error;\n            }\n            VAR_13 = flb_sds_cat(VAR_11, VAR_15, VAR_14->len);\n            null_check(VAR_13);\n            VAR_13 = flb_sds_cat(VAR_11, \"# TYPE \", 7);\n            null_check(VAR_13);\n            VAR_13 = flb_sds_cat(VAR_11, VAR_23[VAR_2+1], extract_metric_name_end_position(VAR_23[VAR_2+1]));\n            null_check(VAR_13);\n            VAR_13 = flb_sds_cat(VAR_11, \" counter\\n\", 9);\n            null_check(VAR_13);\n        }\n    }\n    /* COMMENT_16 */\n    VAR_13 = flb_sds_cat(VAR_11, \"# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\\n\", 89);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"# TYPE process_start_time_seconds gauge\\n\", 40);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"process_start_time_seconds \", 27);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, VAR_22, VAR_7);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"\\n\", 1);\n    null_check(VAR_13);\n\n    /* COMMENT_17 */\n    VAR_13 = flb_sds_cat(VAR_11, \"# HELP fluentbit_build_info Build version information.\\n\", 55);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"# TYPE fluentbit_build_info gauge\\n\", 34);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"fluentbit_build_info{version=\\\"\", 30);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, VAR_35, sizeof(VAR_35) - 1);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"\\\",edition=\\\"\", 11);\n    null_check(VAR_13);\n#ifdef VAR_36\n    VAR_13 = flb_sds_cat(VAR_11, \"Enterprise\\\"} 1\\n\", 15);\n    null_check(VAR_13);\n#else\n    VAR_13 = flb_sds_cat(VAR_11, \"Community\\\"} 1\\n\", 14);\n    null_check(VAR_13);\n#endif\n\n    msgpack_unpacked_destroy(&VAR_18);\n    VAR_17->users--;\n\n    mk_http_status(VAR_0, 200);\n    mk_http_header(VAR_0,\n                   \"Content-Type\", 12,\n                   VAR_37, sizeof(VAR_37) - 1);\n    mk_http_send(VAR_0, VAR_11, flb_sds_len(VAR_11), NULL);\n    for (VAR_2 = 0; VAR_2 < VAR_9; VAR_2++) {\n      flb_sds_destroy(VAR_23[VAR_2]);\n    }\n    flb_free(VAR_23);\n    flb_sds_destroy(VAR_11);\n    flb_sds_destroy(VAR_15);\n\n    mk_http_done(VAR_0);\n    return;\n\nerror:\n    mk_http_status(VAR_0, 500);\n    mk_http_done(VAR_0);\n    VAR_17->users--;\n\n    for (VAR_2 = 0; VAR_2 < VAR_8; VAR_2++) {\n      flb_sds_destroy(VAR_23[VAR_2]);\n    }\n    flb_free(VAR_23);\n    flb_sds_destroy(VAR_11);\n    flb_sds_destroy(VAR_15);\n    msgpack_unpacked_destroy(&VAR_18);\n}",
  "func_graph_path_before": "fluent/fluent-bit/4deb051cb0277d32ab402da4f941f6e502518388/metrics.c/vul/before/1.json",
  "func": "void cb_metrics_prometheus(mk_request_t *request, void *data)\n{\n    int i;\n    int j;\n    int m;\n    int len;\n    int time_len;\n    int start_time_len;\n    size_t index;\n    size_t num_metrics = 0;\n    long now;\n    flb_sds_t sds;\n    flb_sds_t sds_metric;\n    flb_sds_t tmp_sds;\n    struct flb_sds *metric_helptxt_head;\n    flb_sds_t metric_helptxt;\n    size_t off = 0;\n    struct flb_hs_buf *buf;\n    msgpack_unpacked result;\n    msgpack_object map;\n    char tmp[32];\n    char time_str[64];\n    char start_time_str[64];\n    char* *metrics_arr;\n    struct timeval tp;\n    struct flb_hs *hs = data;\n    struct flb_config *config = hs->config;\n\n    buf = metrics_get_latest();\n    if (!buf) {\n        mk_http_status(request, 404);\n        mk_http_done(request);\n        return;\n    }\n\n    /* ref count */\n    buf->users++;\n\n    /* Compose outgoing buffer string */\n    sds = flb_sds_create_size(1024);\n    if (!sds) {\n        mk_http_status(request, 500);\n        mk_http_done(request);\n        buf->users--;\n        return;\n    }\n\n    /* length of HELP text */\n    metric_helptxt = flb_sds_create_size(128);\n    if (!metric_helptxt) {\n        flb_sds_destroy(sds);\n        mk_http_status(request, 500);\n        mk_http_done(request);\n        buf->users--;\n        return;\n    }\n    metric_helptxt_head = FLB_SDS_HEADER(metric_helptxt);\n\n    /* current time */\n    gettimeofday(&tp, NULL);\n    now = tp.tv_sec * 1000 + tp.tv_usec / 1000;\n    time_len = snprintf(time_str, sizeof(time_str) - 1, \"%lu\", now);\n    start_time_len = snprintf(start_time_str, sizeof(start_time_str) - 1, \"%lu\", config->init_time);\n\n    /*\n     * fluentbit_input_records[name=\"cpu0\", hostname=\"${HOSTNAME}\"] NUM TIMESTAMP\n     * fluentbit_input_bytes[name=\"cpu0\", hostname=\"${HOSTNAME}\"] NUM TIMESTAMP\n     */\n    index = 0;\n    msgpack_unpacked_init(&result);\n    msgpack_unpack_next(&result, buf->raw_data, buf->raw_size, &off);\n    map = result.data;\n\n    /* we need to know number of exposed metrics to reserve a memory */\n    for (i = 0; i < map.via.map.size; i++) {\n        msgpack_object v = map.via.map.ptr[i].val;\n        /* Iterate sub-map */\n        for (j = 0; j < v.via.map.size; j++) {\n            msgpack_object sv = v.via.map.ptr[j].val;\n            for (m = 0; m < sv.via.map.size; m++) {\n                num_metrics++;\n            }\n        }\n    }\n    metrics_arr = flb_malloc(num_metrics * sizeof(char*));\n    if (!metrics_arr) {\n        flb_errno();\n\n        mk_http_status(request, 500);\n        mk_http_done(request);\n        buf->users--;\n\n        flb_sds_destroy(sds);\n        flb_sds_destroy(metric_helptxt);\n        msgpack_unpacked_destroy(&result);\n        return;\n    }\n\n    for (i = 0; i < map.via.map.size; i++) {\n        msgpack_object k;\n        msgpack_object v;\n\n        /* Keys: input, output */\n        k = map.via.map.ptr[i].key;\n        v = map.via.map.ptr[i].val;\n\n        /* Iterate sub-map */\n        for (j = 0; j < v.via.map.size; j++) {\n            msgpack_object sk;\n            msgpack_object sv;\n\n            /* Keys: plugin name , values: metrics */\n            sk = v.via.map.ptr[j].key;\n            sv = v.via.map.ptr[j].val;\n\n            for (m = 0; m < sv.via.map.size; m++) {\n                msgpack_object mk;\n                msgpack_object mv;\n\n                mk = sv.via.map.ptr[m].key;\n                mv = sv.via.map.ptr[m].val;\n\n                /* Convert metric value to string */\n                len = snprintf(tmp, sizeof(tmp) - 1, \"%\" PRIu64 \" \", mv.via.u64);\n                if (len < 0) {\n                    goto error;\n                }\n\n                /* Allocate buffer */\n                sds_metric = flb_sds_create_size(k.via.str.size\n                                                 + mk.via.str.size\n                                                 + sk.via.str.size\n                                                 + len + time_len + 28);\n                if (sds_metric == NULL) {\n                    goto error;\n                }\n\n                sds_metric = flb_sds_cat(sds_metric, \"fluentbit_\", 10);\n                sds_metric = flb_sds_cat(sds_metric, k.via.str.ptr, k.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"_\", 1);\n                sds_metric = flb_sds_cat(sds_metric, mk.via.str.ptr, mk.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"_total{name=\\\"\", 13);\n                sds_metric = flb_sds_cat(sds_metric, sk.via.str.ptr, sk.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"\\\"} \", 3);\n                sds_metric = flb_sds_cat(sds_metric, tmp, len);\n                sds_metric = flb_sds_cat(sds_metric, time_str, time_len);\n                sds_metric = flb_sds_cat(sds_metric, \"\\n\", 1);\n                metrics_arr[index] = sds_metric;\n                index++;\n            }\n        }\n    }\n\n    /*  Sort metrics in alphabetic order, so we can group them later. */\n    qsort(metrics_arr, num_metrics, sizeof(char *), string_cmp);\n\n    /* When a new metric starts add HELP and TYPE annotation. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP \", 7);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0]));\n    null_check(tmp_sds);\n    if (!metrics_help_txt(metrics_arr[0], &metric_helptxt)) {\n        goto error;\n    }\n    tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE \", 7);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0]));\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \" counter\\n\", 9);\n    null_check(tmp_sds);\n\n    for (i = 0; i < num_metrics; i++) {\n        tmp_sds = flb_sds_cat(sds, metrics_arr[i], strlen(metrics_arr[i]));\n        null_check(tmp_sds);\n        if ((i != num_metrics - 1) && (is_same_metric(metrics_arr[i], metrics_arr[i+1]) == 0)) {\n            tmp_sds = flb_sds_cat(sds, \"# HELP \", 7);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1]));\n            null_check(tmp_sds);\n            metric_helptxt_head->len = 0;\n            if (!metrics_help_txt(metrics_arr[i+1], &metric_helptxt)) {\n                goto error;\n            }\n            tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, \"# TYPE \", 7);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1]));\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, \" counter\\n\", 9);\n            null_check(tmp_sds);\n        }\n    }\n    /* Attach process_start_time_seconds metric. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\\n\", 89);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE process_start_time_seconds gauge\\n\", 40);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"process_start_time_seconds \", 27);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, start_time_str, start_time_len);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"\\n\", 1);\n    null_check(tmp_sds);\n\n    /* Attach fluentbit_build_info metric. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP fluentbit_build_info Build version information.\\n\", 55);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE fluentbit_build_info gauge\\n\", 34);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"fluentbit_build_info{version=\\\"\", 30);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, FLB_VERSION_STR, sizeof(FLB_VERSION_STR) - 1);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"\\\",edition=\\\"\", 11);\n    null_check(tmp_sds);\n#ifdef FLB_ENTERPRISE\n    tmp_sds = flb_sds_cat(sds, \"Enterprise\\\"} 1\\n\", 15);\n    null_check(tmp_sds);\n#else\n    tmp_sds = flb_sds_cat(sds, \"Community\\\"} 1\\n\", 14);\n    null_check(tmp_sds);\n#endif\n\n    msgpack_unpacked_destroy(&result);\n    buf->users--;\n\n    mk_http_status(request, 200);\n    mk_http_header(request,\n                   \"Content-Type\", 12,\n                   PROMETHEUS_HEADER, sizeof(PROMETHEUS_HEADER) - 1);\n    mk_http_send(request, sds, flb_sds_len(sds), NULL);\n    for (i = 0; i < num_metrics; i++) {\n      flb_sds_destroy(metrics_arr[i]);\n    }\n    flb_free(metrics_arr);\n    flb_sds_destroy(sds);\n    flb_sds_destroy(metric_helptxt);\n\n    mk_http_done(request);\n    return;\n\nerror:\n    mk_http_status(request, 500);\n    mk_http_done(request);\n    buf->users--;\n\n    for (i = 0; i < index; i++) {\n      flb_sds_destroy(metrics_arr[i]);\n    }\n    flb_free(metrics_arr);\n    flb_sds_destroy(sds);\n    flb_sds_destroy(metric_helptxt);\n    msgpack_unpacked_destroy(&result);\n}",
  "abstract_func": "void cb_metrics_prometheus(mk_request_t *VAR_0, void *VAR_1)\n{\n    int VAR_2;\n    int VAR_3;\n    int VAR_4;\n    int VAR_5;\n    int VAR_6;\n    int VAR_7;\n    size_t VAR_8;\n    size_t VAR_9 = 0;\n    long VAR_10;\n    flb_sds_t VAR_11;\n    flb_sds_t VAR_12;\n    flb_sds_t VAR_13;\n    struct flb_sds *VAR_14;\n    flb_sds_t VAR_15;\n    size_t VAR_16 = 0;\n    struct flb_hs_buf *VAR_17;\n    msgpack_unpacked VAR_18;\n    msgpack_object VAR_19;\n    char VAR_20[32];\n    char VAR_21[64];\n    char VAR_22[64];\n    char* *VAR_23;\n    struct timeval VAR_24;\n    struct flb_hs *VAR_25 = VAR_1;\n    struct flb_config *VAR_26 = VAR_25->config;\n\n    VAR_17 = metrics_get_latest();\n    if (!VAR_17) {\n        mk_http_status(VAR_0, 404);\n        mk_http_done(VAR_0);\n        return;\n    }\n\n    /* COMMENT_0 */\n    VAR_17->users++;\n\n    /* COMMENT_1 */\n    VAR_11 = flb_sds_create_size(1024);\n    if (!VAR_11) {\n        mk_http_status(VAR_0, 500);\n        mk_http_done(VAR_0);\n        VAR_17->users--;\n        return;\n    }\n\n    /* COMMENT_2 */\n    VAR_15 = flb_sds_create_size(128);\n    if (!VAR_15) {\n        flb_sds_destroy(VAR_11);\n        mk_http_status(VAR_0, 500);\n        mk_http_done(VAR_0);\n        VAR_17->users--;\n        return;\n    }\n    VAR_14 = FLB_SDS_HEADER(VAR_15);\n\n    /* COMMENT_3 */\n    gettimeofday(&VAR_24, NULL);\n    VAR_10 = VAR_24.tv_sec * 1000 + VAR_24.tv_usec / 1000;\n    VAR_6 = snprintf(VAR_21, sizeof(VAR_21) - 1, \"%lu\", VAR_10);\n    VAR_7 = snprintf(VAR_22, sizeof(VAR_22) - 1, \"%lu\", VAR_26->init_time);\n\n    /* COMMENT_4 */\n                                                                                 \n                                                                               \n       \n    VAR_8 = 0;\n    msgpack_unpacked_init(&VAR_18);\n    msgpack_unpack_next(&VAR_18, VAR_17->raw_data, VAR_17->raw_size, &VAR_16);\n    VAR_19 = VAR_18.data;\n\n    /* COMMENT_8 */\n    for (VAR_2 = 0; VAR_2 < VAR_19.via.map.size; VAR_2++) {\n        msgpack_object VAR_27 = VAR_19.via.map.ptr[VAR_2].val;\n        /* COMMENT_9 */\n        for (VAR_3 = 0; VAR_3 < VAR_27.via.map.size; VAR_3++) {\n            msgpack_object VAR_28 = VAR_27.via.map.ptr[VAR_3].val;\n            for (VAR_4 = 0; VAR_4 < VAR_28.via.map.size; VAR_4++) {\n                VAR_9++;\n            }\n        }\n    }\n    VAR_23 = flb_malloc(VAR_9 * sizeof(char*));\n    if (!VAR_23) {\n        flb_errno();\n\n        mk_http_status(VAR_0, 500);\n        mk_http_done(VAR_0);\n        VAR_17->users--;\n\n        flb_sds_destroy(VAR_11);\n        flb_sds_destroy(VAR_15);\n        msgpack_unpacked_destroy(&VAR_18);\n        return;\n    }\n\n    for (VAR_2 = 0; VAR_2 < VAR_19.via.map.size; VAR_2++) {\n        msgpack_object VAR_29;\n        msgpack_object VAR_27;\n\n        /* COMMENT_10 */\n        VAR_29 = VAR_19.via.map.ptr[VAR_2].key;\n        VAR_27 = VAR_19.via.map.ptr[VAR_2].val;\n\n        /* COMMENT_9 */\n        for (VAR_3 = 0; VAR_3 < VAR_27.via.map.size; VAR_3++) {\n            msgpack_object VAR_30;\n            msgpack_object VAR_28;\n\n            /* COMMENT_11 */\n            VAR_30 = VAR_27.via.map.ptr[VAR_3].key;\n            VAR_28 = VAR_27.via.map.ptr[VAR_3].val;\n\n            for (VAR_4 = 0; VAR_4 < VAR_28.via.map.size; VAR_4++) {\n                msgpack_object VAR_31;\n                msgpack_object VAR_32;\n\n                VAR_31 = VAR_28.via.map.ptr[VAR_4].key;\n                VAR_32 = VAR_28.via.map.ptr[VAR_4].val;\n\n                /* COMMENT_12 */\n                VAR_5 = snprintf(VAR_20, sizeof(VAR_20) - 1, \"%\" VAR_33 \" \", VAR_32.via.u64);\n                if (VAR_5 < 0) {\n                    goto error;\n                }\n\n                /* COMMENT_13 */\n                VAR_12 = flb_sds_create_size(VAR_29.via.str.size\n                                                 + VAR_31.via.str.size\n                                                 + VAR_30.via.str.size\n                                                 + VAR_5 + VAR_6 + 28);\n                if (VAR_12 == NULL) {\n                    goto error;\n                }\n\n                VAR_12 = flb_sds_cat(VAR_12, \"fluentbit_\", 10);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_29.via.str.ptr, VAR_29.via.str.size);\n                VAR_12 = flb_sds_cat(VAR_12, \"_\", 1);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_31.via.str.ptr, VAR_31.via.str.size);\n                VAR_12 = flb_sds_cat(VAR_12, \"_total{name=\\\"\", 13);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_30.via.str.ptr, VAR_30.via.str.size);\n                VAR_12 = flb_sds_cat(VAR_12, \"\\\"} \", 3);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_20, VAR_5);\n                VAR_12 = flb_sds_cat(VAR_12, VAR_21, VAR_6);\n                VAR_12 = flb_sds_cat(VAR_12, \"\\n\", 1);\n                VAR_23[VAR_8] = VAR_12;\n                VAR_8++;\n            }\n        }\n    }\n\n    /* COMMENT_14 */\n    qsort(VAR_23, VAR_9, sizeof(char *), VAR_34);\n\n    /* COMMENT_15 */\n    VAR_13 = flb_sds_cat(VAR_11, \"# HELP \", 7);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, VAR_23[0], extract_metric_name_end_position(VAR_23[0]));\n    null_check(VAR_13);\n    if (!metrics_help_txt(VAR_23[0], &VAR_15)) {\n        goto error;\n    }\n    VAR_13 = flb_sds_cat(VAR_11, VAR_15, VAR_14->len);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"# TYPE \", 7);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, VAR_23[0], extract_metric_name_end_position(VAR_23[0]));\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \" counter\\n\", 9);\n    null_check(VAR_13);\n\n    for (VAR_2 = 0; VAR_2 < VAR_9; VAR_2++) {\n        VAR_13 = flb_sds_cat(VAR_11, VAR_23[VAR_2], strlen(VAR_23[VAR_2]));\n        null_check(VAR_13);\n        if ((VAR_2 != VAR_9 - 1) && (is_same_metric(VAR_23[VAR_2], VAR_23[VAR_2+1]) == 0)) {\n            VAR_13 = flb_sds_cat(VAR_11, \"# HELP \", 7);\n            null_check(VAR_13);\n            VAR_13 = flb_sds_cat(VAR_11, VAR_23[VAR_2+1], extract_metric_name_end_position(VAR_23[VAR_2+1]));\n            null_check(VAR_13);\n            VAR_14->len = 0;\n            if (!metrics_help_txt(VAR_23[VAR_2+1], &VAR_15)) {\n                goto error;\n            }\n            VAR_13 = flb_sds_cat(VAR_11, VAR_15, VAR_14->len);\n            null_check(VAR_13);\n            VAR_13 = flb_sds_cat(VAR_11, \"# TYPE \", 7);\n            null_check(VAR_13);\n            VAR_13 = flb_sds_cat(VAR_11, VAR_23[VAR_2+1], extract_metric_name_end_position(VAR_23[VAR_2+1]));\n            null_check(VAR_13);\n            VAR_13 = flb_sds_cat(VAR_11, \" counter\\n\", 9);\n            null_check(VAR_13);\n        }\n    }\n    /* COMMENT_16 */\n    VAR_13 = flb_sds_cat(VAR_11, \"# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\\n\", 89);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"# TYPE process_start_time_seconds gauge\\n\", 40);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"process_start_time_seconds \", 27);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, VAR_22, VAR_7);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"\\n\", 1);\n    null_check(VAR_13);\n\n    /* COMMENT_17 */\n    VAR_13 = flb_sds_cat(VAR_11, \"# HELP fluentbit_build_info Build version information.\\n\", 55);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"# TYPE fluentbit_build_info gauge\\n\", 34);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"fluentbit_build_info{version=\\\"\", 30);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, VAR_35, sizeof(VAR_35) - 1);\n    null_check(VAR_13);\n    VAR_13 = flb_sds_cat(VAR_11, \"\\\",edition=\\\"\", 11);\n    null_check(VAR_13);\n#ifdef VAR_36\n    VAR_13 = flb_sds_cat(VAR_11, \"Enterprise\\\"} 1\\n\", 15);\n    null_check(VAR_13);\n#else\n    VAR_13 = flb_sds_cat(VAR_11, \"Community\\\"} 1\\n\", 14);\n    null_check(VAR_13);\n#endif\n\n    msgpack_unpacked_destroy(&VAR_18);\n    VAR_17->users--;\n\n    mk_http_status(VAR_0, 200);\n    mk_http_header(VAR_0,\n                   \"Content-Type\", 12,\n                   VAR_37, sizeof(VAR_37) - 1);\n    mk_http_send(VAR_0, VAR_11, flb_sds_len(VAR_11), NULL);\n    for (VAR_2 = 0; VAR_2 < VAR_9; VAR_2++) {\n      flb_sds_destroy(VAR_23[VAR_2]);\n    }\n    flb_free(VAR_23);\n    flb_sds_destroy(VAR_11);\n    flb_sds_destroy(VAR_15);\n\n    mk_http_done(VAR_0);\n    return;\n\nerror:\n    mk_http_status(VAR_0, 500);\n    mk_http_done(VAR_0);\n    VAR_17->users--;\n\n    for (VAR_2 = 0; VAR_2 < VAR_8; VAR_2++) {\n      flb_sds_destroy(VAR_23[VAR_2]);\n    }\n    flb_free(VAR_23);\n    flb_sds_destroy(VAR_11);\n    flb_sds_destroy(VAR_15);\n    msgpack_unpacked_destroy(&VAR_18);\n}",
  "func_graph_path": "fluent/fluent-bit/4deb051cb0277d32ab402da4f941f6e502518388/metrics.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -83,6 +83,18 @@\n         }\n     }\n     metrics_arr = flb_malloc(num_metrics * sizeof(char*));\n+    if (!metrics_arr) {\n+        flb_errno();\n+\n+        mk_http_status(request, 500);\n+        mk_http_done(request);\n+        buf->users--;\n+\n+        flb_sds_destroy(sds);\n+        flb_sds_destroy(metric_helptxt);\n+        msgpack_unpacked_destroy(&result);\n+        return;\n+    }\n \n     for (i = 0; i < map.via.map.size; i++) {\n         msgpack_object k;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (!metrics_arr) {",
      "        flb_errno();",
      "",
      "        mk_http_status(request, 500);",
      "        mk_http_done(request);",
      "        buf->users--;",
      "",
      "        flb_sds_destroy(sds);",
      "        flb_sds_destroy(metric_helptxt);",
      "        msgpack_unpacked_destroy(&result);",
      "        return;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fluent/fluent-bit/pull/3047",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/fluent/fluent-bit/pull/3047: 403 Client Error: Forbidden for url: https://api.github.com/repos/fluent/fluent-bit/pulls/3047",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "The patch addresses a memory allocation issue that could cause a segmentation fault, preventing potential crash exploitation, classified as a Security Vulnerability Fix with moderate confidence.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8"
}