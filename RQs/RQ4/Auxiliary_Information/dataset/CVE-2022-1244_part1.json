{
  "cve_id": "CVE-2022-1244",
  "cwe_ids": [
    "CWE-122"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix oobread in dyldcache ##crash\n\n* Reported by @hdthky via huntr.dev\n* Reproducers: poc1\n* BountyID: 8ae2c61a-2220-47a5-bfe8-fe6d41ab1f82",
  "commit_hash": "2b77b277d67ce061ee6ef839e7139ebc2103c1e3",
  "git_url": "https://github.com/radareorg/radare2/commit/2b77b277d67ce061ee6ef839e7139ebc2103c1e3",
  "file_path": "libr/bin/p/bin_dyldcache.c",
  "func_name": "create_cache_bins",
  "func_before": "static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}",
  "abstract_func_before": "static RList *create_cache_bins(RBinFile *VAR_0, RDyldCache *VAR_1) {\n\tRList *VAR_2 = r_list_newf ((RListFree)VAR_3);\n\tut16 *VAR_4 = NULL;\n\tcache_imgxtr_t *VAR_5 = NULL;\n\tif (!VAR_2) {\n\t\treturn NULL;\n\t}\n\n\tchar *VAR_6 = NULL;\n\tRList *VAR_7 = NULL;\n\tint *VAR_8 = NULL;\n\tVAR_6 = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (VAR_6) {\n\t\tVAR_7 = r_str_split_list (VAR_6, \":\", 0);\n\t\tif (!VAR_7) {\n\t\t\tr_list_free (VAR_2);\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_8 = R_NEWS0 (int, VAR_1->hdr->imagesCount);\n\t\tif (!VAR_8) {\n\t\t\tr_list_free (VAR_2);\n\t\t\tr_list_free (VAR_7);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 VAR_9;\n\tfor (VAR_9 = 0; VAR_9 < VAR_1->n_hdr; VAR_9++) {\n\t\tcache_hdr_t *VAR_10 = &VAR_1->hdr[VAR_9];\n\t\tut64 VAR_11 = VAR_1->hdr_offset[VAR_9];\n\t\tut32 VAR_12 = VAR_1->maps_index[VAR_9];\n\t\tcache_img_t *VAR_13 = read_cache_images (VAR_1->buf, VAR_10, VAR_11);\n\t\tif (!VAR_13) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 VAR_14;\n\t\tif (VAR_6) {\n\t\t\tHtPU *VAR_15 = NULL;\n\t\t\tif (VAR_1->accel) {\n\t\t\t\tVAR_4 = R_NEWS0 (ut16, VAR_1->accel->depListCount);\n\t\t\t\tif (!VAR_4) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (VAR_1->buf, VAR_1->accel->depListOffset, (ut8*) VAR_4, \"s\", VAR_1->accel->depListCount) != VAR_1->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tVAR_5 = read_cache_imgextra (VAR_1->buf, VAR_10, VAR_1->accel);\n\t\t\t\tif (!VAR_5) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVAR_15 = create_path_to_index (VAR_1->buf, VAR_13, VAR_10);\n\t\t\t}\n\n\t\t\tfor (VAR_14 = 0; VAR_14 < VAR_10->imagesCount; VAR_14++) {\n\t\t\t\tbool VAR_16 = !VAR_8[VAR_14];\n\t\t\t\tchar *VAR_17 = get_lib_name (VAR_1->buf, &VAR_13[VAR_14]);\n\t\t\t\tif (!VAR_17) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (VAR_17, \"libobjc.A.dylib\")) {\n\t\t\t\t\tVAR_8[VAR_14]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (VAR_7, VAR_17, VAR_18)) {\n\t\t\t\t\tR_FREE (VAR_17);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (VAR_16) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", VAR_17);\n\t\t\t\t}\n\t\t\t\tR_FREE (VAR_17);\n\t\t\t\tVAR_8[VAR_14]++;\n\n\t\t\t\tif (VAR_5 && VAR_4) {\n\t\t\t\t\tut32 VAR_19;\n\t\t\t\t\tfor (VAR_19 = VAR_5[VAR_14].dependentsStartArrayIndex; VAR_4[VAR_19] != 0xffff; VAR_19++) {\n\t\t\t\t\t\tut16 VAR_20 = VAR_4[VAR_19] & 0x7fff;\n\t\t\t\t\t\tVAR_8[VAR_20]++;\n\n\t\t\t\t\t\tchar *VAR_21 = get_lib_name (VAR_1->buf, &VAR_13[VAR_20]);\n\t\t\t\t\t\tif (!VAR_21) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (VAR_16) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", VAR_21);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (VAR_21);\n\t\t\t\t\t}\n\t\t\t\t} else if (VAR_15) {\n\t\t\t\t\tcarve_deps_at_address (VAR_1, VAR_13, VAR_15, VAR_13[VAR_14].address, VAR_8, VAR_16);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (VAR_15);\n\t\t\tR_FREE (VAR_4);\n\t\t\tR_FREE (VAR_5);\n\t\t}\n\n\t\tfor (VAR_14 = 0; VAR_14 < VAR_10->imagesCount; VAR_14++) {\n\t\t\tif (VAR_8 && !VAR_8[VAR_14]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 VAR_22 = va2pa (VAR_13[VAR_14].address, VAR_10->mappingCount, &VAR_1->maps[VAR_12], VAR_1->buf, 0, NULL, NULL);\n\t\t\tif (VAR_22 == VAR_23) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 VAR_24[4];\n\t\t\tr_buf_read_at (VAR_1->buf, VAR_22, VAR_24, 4);\n\t\t\tint VAR_25 = r_read_le32 (VAR_24);\n\t\t\tswitch (VAR_25) {\n\t\t\tcase VAR_26:\n\t\t\t{\n\t\t\t\tchar VAR_27[256];\n\t\t\t\tRDyldBinImage *VAR_28 = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!VAR_28) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tVAR_28->header_at = VAR_22;\n\t\t\t\tVAR_28->hdr_offset = VAR_11;\n\t\t\t\tVAR_28->symbols_off = resolve_symbols_off (VAR_1, VAR_22);\n\t\t\t\tVAR_28->va = VAR_13[VAR_14].address;\n\t\t\t\tif (r_buf_read_at (VAR_1->buf, VAR_13[VAR_14].pathFileOffset, (ut8*) &VAR_27, sizeof (VAR_27)) == sizeof (VAR_27)) {\n\t\t\t\t\tVAR_27[255] = 0;\n\t\t\t\t\tchar *VAR_29 = strrchr (VAR_27, '/');\n\t\t\t\t\tif (VAR_29 && *VAR_29) {\n\t\t\t\t\t\tif (VAR_29 > VAR_27) {\n\t\t\t\t\t\t\tchar *VAR_30 = VAR_29 - 1;\n\t\t\t\t\t\t\twhile (VAR_30 > VAR_27 && *VAR_30 != '/') {\n\t\t\t\t\t\t\t\tVAR_30--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*VAR_30 == '/') {\n\t\t\t\t\t\t\t\tVAR_28->file = strdup (VAR_30 + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tVAR_28->file = strdup (VAR_29 + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVAR_28->file = strdup (VAR_29 + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_28->file = strdup (VAR_27);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (VAR_2, VAR_28);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (VAR_4);\n\t\tR_FREE (VAR_5);\n\t\tR_FREE (VAR_13);\n\t}\n\tif (r_list_empty (VAR_2)) {\n\t\tr_list_free (VAR_2);\n\t\tVAR_2 = NULL;\n\t}\n\tR_FREE (VAR_8);\n\tR_FREE (VAR_6);\n\tr_list_free (VAR_7);\n\treturn VAR_2;\n}",
  "func_graph_path_before": "radareorg/radare2/2b77b277d67ce061ee6ef839e7139ebc2103c1e3/bin_dyldcache.c/vul/before/0.json",
  "func": "static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}",
  "abstract_func": "static RList *create_cache_bins(RBinFile *VAR_0, RDyldCache *VAR_1) {\n\tRList *VAR_2 = r_list_newf ((RListFree)VAR_3);\n\tut16 *VAR_4 = NULL;\n\tcache_imgxtr_t *VAR_5 = NULL;\n\tif (!VAR_2) {\n\t\treturn NULL;\n\t}\n\n\tchar *VAR_6 = NULL;\n\tRList *VAR_7 = NULL;\n\tint *VAR_8 = NULL;\n\tVAR_6 = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (VAR_6) {\n\t\tVAR_7 = r_str_split_list (VAR_6, \":\", 0);\n\t\tif (!VAR_7) {\n\t\t\tr_list_free (VAR_2);\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_8 = R_NEWS0 (int, VAR_1->hdr->imagesCount);\n\t\tif (!VAR_8) {\n\t\t\tr_list_free (VAR_2);\n\t\t\tr_list_free (VAR_7);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 VAR_9;\n\tfor (VAR_9 = 0; VAR_9 < VAR_1->n_hdr; VAR_9++) {\n\t\tcache_hdr_t *VAR_10 = &VAR_1->hdr[VAR_9];\n\t\tut64 VAR_11 = VAR_1->hdr_offset[VAR_9];\n\t\tut32 VAR_12 = VAR_1->maps_index[VAR_9];\n\t\tcache_img_t *VAR_13 = read_cache_images (VAR_1->buf, VAR_10, VAR_11);\n\t\tif (!VAR_13) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 VAR_14;\n\t\tif (VAR_6) {\n\t\t\tHtPU *VAR_15 = NULL;\n\t\t\tif (VAR_1->accel) {\n\t\t\t\tVAR_4 = R_NEWS0 (ut16, VAR_1->accel->depListCount);\n\t\t\t\tif (!VAR_4) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (VAR_1->buf, VAR_1->accel->depListOffset, (ut8*) VAR_4, \"s\", VAR_1->accel->depListCount) != VAR_1->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tVAR_5 = read_cache_imgextra (VAR_1->buf, VAR_10, VAR_1->accel);\n\t\t\t\tif (!VAR_5) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVAR_15 = create_path_to_index (VAR_1->buf, VAR_13, VAR_10);\n\t\t\t}\n\n\t\t\tfor (VAR_14 = 0; VAR_14 < VAR_10->imagesCount; VAR_14++) {\n\t\t\t\tbool VAR_16 = !VAR_8[VAR_14];\n\t\t\t\tchar *VAR_17 = get_lib_name (VAR_1->buf, &VAR_13[VAR_14]);\n\t\t\t\tif (!VAR_17) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (VAR_17, \"libobjc.A.dylib\")) {\n\t\t\t\t\tVAR_8[VAR_14]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (VAR_7, VAR_17, VAR_18)) {\n\t\t\t\t\tR_FREE (VAR_17);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (VAR_16) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", VAR_17);\n\t\t\t\t}\n\t\t\t\tR_FREE (VAR_17);\n\t\t\t\tVAR_8[VAR_14]++;\n\n\t\t\t\tif (VAR_5 && VAR_4) {\n\t\t\t\t\tut32 VAR_19;\n\t\t\t\t\tfor (VAR_19 = VAR_5[VAR_14].dependentsStartArrayIndex; VAR_4[VAR_19] != 0xffff; VAR_19++) {\n\t\t\t\t\t\tut16 VAR_20 = VAR_4[VAR_19] & 0x7fff;\n\t\t\t\t\t\tVAR_8[VAR_20]++;\n\n\t\t\t\t\t\tchar *VAR_21 = get_lib_name (VAR_1->buf, &VAR_13[VAR_20]);\n\t\t\t\t\t\tif (!VAR_21) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (VAR_16) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", VAR_21);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (VAR_21);\n\t\t\t\t\t}\n\t\t\t\t} else if (VAR_15) {\n\t\t\t\t\tcarve_deps_at_address (VAR_1, VAR_13, VAR_15, VAR_13[VAR_14].address, VAR_8, VAR_16);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (VAR_15);\n\t\t\tR_FREE (VAR_4);\n\t\t\tR_FREE (VAR_5);\n\t\t}\n\n\t\tfor (VAR_14 = 0; VAR_14 < VAR_10->imagesCount; VAR_14++) {\n\t\t\tif (VAR_8 && !VAR_8[VAR_14]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* COMMENT_0 */\n\t\t\tut64 VAR_22 = va2pa (VAR_13[VAR_14].address, VAR_1->n_maps, &VAR_1->maps[VAR_12], VAR_1->buf, 0, NULL, NULL);\n\t\t\tif (VAR_22 == VAR_23) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 VAR_24[4];\n\t\t\tr_buf_read_at (VAR_1->buf, VAR_22, VAR_24, 4);\n\t\t\tint VAR_25 = r_read_le32 (VAR_24);\n\t\t\tswitch (VAR_25) {\n\t\t\tcase VAR_26:\n\t\t\t{\n\t\t\t\tchar VAR_27[256];\n\t\t\t\tRDyldBinImage *VAR_28 = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!VAR_28) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tVAR_28->header_at = VAR_22;\n\t\t\t\tVAR_28->hdr_offset = VAR_11;\n\t\t\t\tVAR_28->symbols_off = resolve_symbols_off (VAR_1, VAR_22);\n\t\t\t\tVAR_28->va = VAR_13[VAR_14].address;\n\t\t\t\tif (r_buf_read_at (VAR_1->buf, VAR_13[VAR_14].pathFileOffset, (ut8*) &VAR_27, sizeof (VAR_27)) == sizeof (VAR_27)) {\n\t\t\t\t\tVAR_27[255] = 0;\n\t\t\t\t\tchar *VAR_29 = strrchr (VAR_27, '/');\n\t\t\t\t\tif (VAR_29 && *VAR_29) {\n\t\t\t\t\t\tif (VAR_29 > VAR_27) {\n\t\t\t\t\t\t\tchar *VAR_30 = VAR_29 - 1;\n\t\t\t\t\t\t\twhile (VAR_30 > VAR_27 && *VAR_30 != '/') {\n\t\t\t\t\t\t\t\tVAR_30--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*VAR_30 == '/') {\n\t\t\t\t\t\t\t\tVAR_28->file = strdup (VAR_30 + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tVAR_28->file = strdup (VAR_29 + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVAR_28->file = strdup (VAR_29 + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_28->file = strdup (VAR_27);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (VAR_2, VAR_28);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (VAR_4);\n\t\tR_FREE (VAR_5);\n\t\tR_FREE (VAR_13);\n\t}\n\tif (r_list_empty (VAR_2)) {\n\t\tr_list_free (VAR_2);\n\t\tVAR_2 = NULL;\n\t}\n\tR_FREE (VAR_8);\n\tR_FREE (VAR_6);\n\tr_list_free (VAR_7);\n\treturn VAR_2;\n}",
  "func_graph_path": "radareorg/radare2/2b77b277d67ce061ee6ef839e7139ebc2103c1e3/bin_dyldcache.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -103,7 +103,8 @@\n \t\t\tif (deps && !deps[j]) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n+\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n+\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n \t\t\tif (pa == UT64_MAX) {\n \t\t\t\tcontinue;\n \t\t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);"
    ],
    "added_lines": [
      "\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
      "\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19920",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19920: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19920",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses an out-of-bounds read vulnerability, a security issue. The code change corrects the way the address translation is handled, fixing the bug reported through a security platform. \n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}