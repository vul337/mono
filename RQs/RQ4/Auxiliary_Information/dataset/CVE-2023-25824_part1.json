{
  "cve_id": "CVE-2023-25824",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "airtower-luna/mod_gnutls",
  "commit_msg": "Fix loop in blocking read on transport timeout\n\nThe loop was cased by an incorrect errno if the transport read in\nmgs_transport_read() fails with an APR TIMEUP status, as happens when\nmod_reqtimeout limits are exceeded. Setting the transport errno to\nEGAIN meant that a blocking read would be retried endlessly, setting\nETIMEDOUT instead makes the read fail as it should.\n\nThe bug was introduced in commit 92cb0cca41af946055307e373b6ab6d76d34f356,\nfirst release to include it was 0.9.0.\n\nMany thanks to Félix Arreola Rodríguez for the detailed analysis [1]\non the Debian bug tracker!\n\n[1] https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=942737#25",
  "commit_hash": "d7eec4e598158ab6a98bf505354e84352f9715ec",
  "git_url": "https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec",
  "file_path": "src/gnutls_io.c",
  "func_name": "mgs_transport_read",
  "func_before": "ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,\n                           void *buffer, size_t len)\n{\n    mgs_handle_t *ctxt = ptr;\n    apr_size_t in = len;\n    apr_read_type_e block = ctxt->input_block;\n\n    ctxt->input_rc = APR_SUCCESS;\n\n    /* If Len = 0, we don't do anything. */\n    if (!len || buffer == NULL)\n    {\n        return 0;\n    }\n    /* Input bucket brigade is missing, EOF */\n    if (!ctxt->input_bb)\n    {\n        ctxt->input_rc = APR_EOF;\n        gnutls_transport_set_errno(ctxt->session, ECONNABORTED);\n        return -1;\n    }\n\n    if (APR_BRIGADE_EMPTY(ctxt->input_bb))\n    {\n        apr_status_t rc = ap_get_brigade(ctxt->input_filter->next,\n                                         ctxt->input_bb, AP_MODE_READBYTES,\n                                         ctxt->input_block, in);\n\n        /* Not a problem, there was simply no data ready yet.\n         */\n        if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc)\n            || (rc == APR_SUCCESS\n                && APR_BRIGADE_EMPTY(ctxt->input_bb)))\n        {\n            /* Turning APR_SUCCESS into APR_EINTR isn't ideal, but\n             * it's the best matching error code for \"didn't get data,\n             * but read didn't permanently fail either.\" */\n            ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR);\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        /* Blocking ap_get_brigade() can return a timeout status,\n         * sometimes after a very short time. \"Don't give up, just\n         * return the timeout\" is what mod_ssl does. */\n        if (ctxt->input_block == APR_BLOCK_READ\n            && APR_STATUS_IS_TIMEUP(rc)\n            && APR_BRIGADE_EMPTY(ctxt->input_bb))\n        {\n            ctxt->input_rc = rc;\n            gnutls_transport_set_errno(ctxt->session, EAGAIN);\n            return -1;\n        }\n\n        if (rc != APR_SUCCESS)\n        {\n            /* Unexpected errors discard the brigade */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c,\n                          \"%s: Unexpected error!\", __func__);\n            apr_brigade_cleanup(ctxt->input_bb);\n            ctxt->input_bb = NULL;\n            gnutls_transport_set_errno(ctxt->session, EIO);\n            return -1;\n        }\n    }\n\n    ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len);\n\n    if (ctxt->input_rc == APR_SUCCESS)\n    {\n        return (ssize_t) len;\n    }\n\n    if (APR_STATUS_IS_EAGAIN(ctxt->input_rc)\n        || APR_STATUS_IS_EINTR(ctxt->input_rc))\n    {\n        if (len == 0)\n        {\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        return (ssize_t) len;\n    }\n\n    /* Unexpected errors and APR_EOF clean out the brigade.\n     * Subsequent calls will return APR_EOF. */\n    apr_brigade_cleanup(ctxt->input_bb);\n    ctxt->input_bb = NULL;\n\n    if (APR_STATUS_IS_EOF(ctxt->input_rc) && len)\n    {\n        /* Some data has been received before EOF, return it. */\n        return (ssize_t) len;\n    }\n\n    gnutls_transport_set_errno(ctxt->session, EIO);\n    return -1;\n}",
  "abstract_func_before": "ssize_t mgs_transport_read(gnutls_transport_ptr_t VAR_0,\n                           void *VAR_1, size_t VAR_2)\n{\n    mgs_handle_t *VAR_3 = VAR_0;\n    apr_size_t VAR_4 = VAR_2;\n    apr_read_type_e VAR_5 = VAR_3->input_block;\n\n    VAR_3->input_rc = VAR_6;\n\n    /* COMMENT_0 */\n    if (!VAR_2 || VAR_1 == NULL)\n    {\n        return 0;\n    }\n    /* COMMENT_1 */\n    if (!VAR_3->input_bb)\n    {\n        VAR_3->input_rc = VAR_7;\n        gnutls_transport_set_errno(VAR_3->session, VAR_8);\n        return -1;\n    }\n\n    if (APR_BRIGADE_EMPTY(VAR_3->input_bb))\n    {\n        apr_status_t VAR_9 = ap_get_brigade(VAR_3->input_filter->next,\n                                         VAR_3->input_bb, VAR_10,\n                                         VAR_3->input_block, VAR_4);\n\n        /* COMMENT_2 */\n           \n        if (APR_STATUS_IS_EAGAIN(VAR_9) || APR_STATUS_IS_EINTR(VAR_9)\n            || (VAR_9 == VAR_6\n                && APR_BRIGADE_EMPTY(VAR_3->input_bb)))\n        {\n            /* COMMENT_4 */\n                                                                      \n                                                           \n            VAR_3->input_rc = (VAR_9 != VAR_6 ? VAR_9 : VAR_11);\n            gnutls_transport_set_errno(VAR_3->session,\n                                       EAI_APR_TO_RAW(VAR_3->input_rc));\n            return -1;\n        }\n\n        /* COMMENT_7 */\n                                                                  \n                                                       \n        if (VAR_3->input_block == VAR_12\n            && APR_STATUS_IS_TIMEUP(VAR_9)\n            && APR_BRIGADE_EMPTY(VAR_3->input_bb))\n        {\n            VAR_3->input_rc = VAR_9;\n            gnutls_transport_set_errno(VAR_3->session, VAR_13);\n            return -1;\n        }\n\n        if (VAR_9 != VAR_6)\n        {\n            /* COMMENT_10 */\n            ap_log_cerror(VAR_14, VAR_15, VAR_9, VAR_3->c,\n                          \"%s: Unexpected error!\", VAR_16);\n            apr_brigade_cleanup(VAR_3->input_bb);\n            VAR_3->input_bb = NULL;\n            gnutls_transport_set_errno(VAR_3->session, VAR_17);\n            return -1;\n        }\n    }\n\n    VAR_3->input_rc = brigade_consume(VAR_3->input_bb, VAR_5, VAR_1, &VAR_2);\n\n    if (VAR_3->input_rc == VAR_6)\n    {\n        return (ssize_t) VAR_2;\n    }\n\n    if (APR_STATUS_IS_EAGAIN(VAR_3->input_rc)\n        || APR_STATUS_IS_EINTR(VAR_3->input_rc))\n    {\n        if (VAR_2 == 0)\n        {\n            gnutls_transport_set_errno(VAR_3->session,\n                                       EAI_APR_TO_RAW(VAR_3->input_rc));\n            return -1;\n        }\n\n        return (ssize_t) VAR_2;\n    }\n\n    /* COMMENT_11 */\n                                               \n    apr_brigade_cleanup(VAR_3->input_bb);\n    VAR_3->input_bb = NULL;\n\n    if (APR_STATUS_IS_EOF(VAR_3->input_rc) && VAR_2)\n    {\n        /* COMMENT_13 */\n        return (ssize_t) VAR_2;\n    }\n\n    gnutls_transport_set_errno(VAR_3->session, VAR_17);\n    return -1;\n}",
  "func_graph_path_before": "airtower-luna/mod_gnutls/d7eec4e598158ab6a98bf505354e84352f9715ec/gnutls_io.c/vul/before/0.json",
  "func": "ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,\n                           void *buffer, size_t len)\n{\n    mgs_handle_t *ctxt = ptr;\n    apr_size_t in = len;\n    apr_read_type_e block = ctxt->input_block;\n\n    ctxt->input_rc = APR_SUCCESS;\n\n    /* If Len = 0, we don't do anything. */\n    if (!len || buffer == NULL)\n    {\n        return 0;\n    }\n    /* Input bucket brigade is missing, EOF */\n    if (!ctxt->input_bb)\n    {\n        ctxt->input_rc = APR_EOF;\n        gnutls_transport_set_errno(ctxt->session, ECONNABORTED);\n        return -1;\n    }\n\n    if (APR_BRIGADE_EMPTY(ctxt->input_bb))\n    {\n        apr_status_t rc = ap_get_brigade(ctxt->input_filter->next,\n                                         ctxt->input_bb, AP_MODE_READBYTES,\n                                         ctxt->input_block, in);\n\n        /* Not a problem, there was simply no data ready yet.\n         */\n        if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc)\n            || (rc == APR_SUCCESS\n                && APR_BRIGADE_EMPTY(ctxt->input_bb)))\n        {\n            /* Turning APR_SUCCESS into APR_EINTR isn't ideal, but\n             * it's the best matching error code for \"didn't get data,\n             * but read didn't permanently fail either.\" */\n            ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR);\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        /* Blocking ap_get_brigade() can return a timeout status,\n         * sometimes after a very short time. \"Don't give up, just\n         * return the timeout\" is what mod_ssl does. */\n        if (ctxt->input_block == APR_BLOCK_READ\n            && APR_STATUS_IS_TIMEUP(rc)\n            && APR_BRIGADE_EMPTY(ctxt->input_bb))\n        {\n            ctxt->input_rc = rc;\n            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);\n            return -1;\n        }\n\n        if (rc != APR_SUCCESS)\n        {\n            /* Unexpected errors discard the brigade */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c,\n                          \"%s: Unexpected error!\", __func__);\n            apr_brigade_cleanup(ctxt->input_bb);\n            ctxt->input_bb = NULL;\n            gnutls_transport_set_errno(ctxt->session, EIO);\n            return -1;\n        }\n    }\n\n    ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len);\n\n    if (ctxt->input_rc == APR_SUCCESS)\n    {\n        return (ssize_t) len;\n    }\n\n    if (APR_STATUS_IS_EAGAIN(ctxt->input_rc)\n        || APR_STATUS_IS_EINTR(ctxt->input_rc))\n    {\n        if (len == 0)\n        {\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        return (ssize_t) len;\n    }\n\n    /* Unexpected errors and APR_EOF clean out the brigade.\n     * Subsequent calls will return APR_EOF. */\n    apr_brigade_cleanup(ctxt->input_bb);\n    ctxt->input_bb = NULL;\n\n    if (APR_STATUS_IS_EOF(ctxt->input_rc) && len)\n    {\n        /* Some data has been received before EOF, return it. */\n        return (ssize_t) len;\n    }\n\n    gnutls_transport_set_errno(ctxt->session, EIO);\n    return -1;\n}",
  "abstract_func": "ssize_t mgs_transport_read(gnutls_transport_ptr_t VAR_0,\n                           void *VAR_1, size_t VAR_2)\n{\n    mgs_handle_t *VAR_3 = VAR_0;\n    apr_size_t VAR_4 = VAR_2;\n    apr_read_type_e VAR_5 = VAR_3->input_block;\n\n    VAR_3->input_rc = VAR_6;\n\n    /* COMMENT_0 */\n    if (!VAR_2 || VAR_1 == NULL)\n    {\n        return 0;\n    }\n    /* COMMENT_1 */\n    if (!VAR_3->input_bb)\n    {\n        VAR_3->input_rc = VAR_7;\n        gnutls_transport_set_errno(VAR_3->session, VAR_8);\n        return -1;\n    }\n\n    if (APR_BRIGADE_EMPTY(VAR_3->input_bb))\n    {\n        apr_status_t VAR_9 = ap_get_brigade(VAR_3->input_filter->next,\n                                         VAR_3->input_bb, VAR_10,\n                                         VAR_3->input_block, VAR_4);\n\n        /* COMMENT_2 */\n           \n        if (APR_STATUS_IS_EAGAIN(VAR_9) || APR_STATUS_IS_EINTR(VAR_9)\n            || (VAR_9 == VAR_6\n                && APR_BRIGADE_EMPTY(VAR_3->input_bb)))\n        {\n            /* COMMENT_4 */\n                                                                      \n                                                           \n            VAR_3->input_rc = (VAR_9 != VAR_6 ? VAR_9 : VAR_11);\n            gnutls_transport_set_errno(VAR_3->session,\n                                       EAI_APR_TO_RAW(VAR_3->input_rc));\n            return -1;\n        }\n\n        /* COMMENT_7 */\n                                                                  \n                                                       \n        if (VAR_3->input_block == VAR_12\n            && APR_STATUS_IS_TIMEUP(VAR_9)\n            && APR_BRIGADE_EMPTY(VAR_3->input_bb))\n        {\n            VAR_3->input_rc = VAR_9;\n            gnutls_transport_set_errno(VAR_3->session, VAR_13);\n            return -1;\n        }\n\n        if (VAR_9 != VAR_6)\n        {\n            /* COMMENT_10 */\n            ap_log_cerror(VAR_14, VAR_15, VAR_9, VAR_3->c,\n                          \"%s: Unexpected error!\", VAR_16);\n            apr_brigade_cleanup(VAR_3->input_bb);\n            VAR_3->input_bb = NULL;\n            gnutls_transport_set_errno(VAR_3->session, VAR_17);\n            return -1;\n        }\n    }\n\n    VAR_3->input_rc = brigade_consume(VAR_3->input_bb, VAR_5, VAR_1, &VAR_2);\n\n    if (VAR_3->input_rc == VAR_6)\n    {\n        return (ssize_t) VAR_2;\n    }\n\n    if (APR_STATUS_IS_EAGAIN(VAR_3->input_rc)\n        || APR_STATUS_IS_EINTR(VAR_3->input_rc))\n    {\n        if (VAR_2 == 0)\n        {\n            gnutls_transport_set_errno(VAR_3->session,\n                                       EAI_APR_TO_RAW(VAR_3->input_rc));\n            return -1;\n        }\n\n        return (ssize_t) VAR_2;\n    }\n\n    /* COMMENT_11 */\n                                               \n    apr_brigade_cleanup(VAR_3->input_bb);\n    VAR_3->input_bb = NULL;\n\n    if (APR_STATUS_IS_EOF(VAR_3->input_rc) && VAR_2)\n    {\n        /* COMMENT_13 */\n        return (ssize_t) VAR_2;\n    }\n\n    gnutls_transport_set_errno(VAR_3->session, VAR_17);\n    return -1;\n}",
  "func_graph_path": "airtower-luna/mod_gnutls/d7eec4e598158ab6a98bf505354e84352f9715ec/gnutls_io.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n             && APR_BRIGADE_EMPTY(ctxt->input_bb))\n         {\n             ctxt->input_rc = rc;\n-            gnutls_transport_set_errno(ctxt->session, EAGAIN);\n+            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);\n             return -1;\n         }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "            gnutls_transport_set_errno(ctxt->session, EAGAIN);"
    ],
    "added_lines": [
      "            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/airtower-luna/mod_gnutls/pull/15",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/airtower-luna/mod_gnutls/pull/15: 403 Client Error: Forbidden for url: https://api.github.com/repos/airtower-luna/mod_gnutls/pulls/15",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}