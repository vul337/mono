{
  "cve_id": "CVE-2021-32626",
  "cwe_ids": [
    "CWE-787",
    "CWE-122"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n   to explode the LUA stack (notice that currently there is no such\n   command in Redis that returns such a nested reply, but modules might\n   do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n   explode the LUA stack (all the arguments will be pushed to the LUA\n   stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
  "commit_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
  "git_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
  "file_path": "src/scripting.c",
  "func_name": "luaReplyToRedisReply",
  "func_before": "void luaReplyToRedisReply(client *c, lua_State *lua) {\n    int t = lua_type(lua,-1);\n\n    switch(t) {\n    case LUA_TSTRING:\n        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));\n        break;\n    case LUA_TBOOLEAN:\n        if (server.lua_client->resp == 2)\n            addReply(c,lua_toboolean(lua,-1) ? shared.cone :\n                                               shared.null[c->resp]);\n        else\n            addReplyBool(c,lua_toboolean(lua,-1));\n        break;\n    case LUA_TNUMBER:\n        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));\n        break;\n    case LUA_TTABLE:\n        /* We need to check if it is an array, an error, or a status reply.\n         * Error are returned as a single element table with 'err' field.\n         * Status replies are returned as single element table with 'ok'\n         * field. */\n\n        /* Handle error reply. */\n        lua_pushstring(lua,\"err\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds err = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(err,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"-%s\\r\\n\",err));\n            sdsfree(err);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle status reply. */\n        lua_pushstring(lua,\"ok\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds ok = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(ok,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"+%s\\r\\n\",ok));\n            sdsfree(ok);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle double reply. */\n        lua_pushstring(lua,\"double\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TNUMBER) {\n            addReplyDouble(c,lua_tonumber(lua,-1));\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle map reply. */\n        lua_pushstring(lua,\"map\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int maplen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, value */\n                lua_pushvalue(lua,-2);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                luaReplyToRedisReply(c, lua); /* Return value. */\n                /* Stack now: table, key. */\n                maplen++;\n            }\n            setDeferredMapLen(c,replylen,maplen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle set reply. */\n        lua_pushstring(lua,\"set\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int setlen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, true */\n                lua_pop(lua,1);               /* Discard the boolean value. */\n                lua_pushvalue(lua,-1);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                /* Stack now: table, key. */\n                setlen++;\n            }\n            setDeferredSetLen(c,replylen,setlen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle the array reply. */\n        void *replylen = addReplyDeferredLen(c);\n        int j = 1, mbulklen = 0;\n        while(1) {\n            lua_pushnumber(lua,j++);\n            lua_gettable(lua,-2);\n            t = lua_type(lua,-1);\n            if (t == LUA_TNIL) {\n                lua_pop(lua,1);\n                break;\n            }\n            luaReplyToRedisReply(c, lua);\n            mbulklen++;\n        }\n        setDeferredArrayLen(c,replylen,mbulklen);\n        break;\n    default:\n        addReplyNull(c);\n    }\n    lua_pop(lua,1);\n}",
  "abstract_func_before": "void luaReplyToRedisReply(client *VAR_0, lua_State *VAR_1) {\n    int VAR_2 = lua_type(VAR_1,-1);\n\n    switch(VAR_2) {\n    case VAR_3:\n        addReplyBulkCBuffer(VAR_0,(char*)lua_tostring(VAR_1,-1),lua_strlen(VAR_1,-1));\n        break;\n    case VAR_4:\n        if (VAR_5.lua_client->resp == 2)\n            addReply(VAR_0,lua_toboolean(VAR_1,-1) ? VAR_6.cone :\n                                               VAR_6.null[VAR_0->resp]);\n        else\n            addReplyBool(VAR_0,lua_toboolean(VAR_1,-1));\n        break;\n    case VAR_7:\n        addReplyLongLong(VAR_0,(long long)lua_tonumber(VAR_1,-1));\n        break;\n    case VAR_8:\n        /* COMMENT_0 */\n                                                                         \n                                                                        \n                    \n\n        /* COMMENT_4 */\n        lua_pushstring(VAR_1,\"err\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_3) {\n            sds VAR_9 = sdsnew(lua_tostring(VAR_1,-1));\n            sdsmapchars(VAR_9,\"\\r\\n\",\"  \",2);\n            addReplySds(VAR_0,sdscatprintf(sdsempty(),\"-%s\\r\\n\",VAR_9));\n            sdsfree(VAR_9);\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_5 */\n\n        /* COMMENT_6 */\n        lua_pushstring(VAR_1,\"ok\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_3) {\n            sds VAR_10 = sdsnew(lua_tostring(VAR_1,-1));\n            sdsmapchars(VAR_10,\"\\r\\n\",\"  \",2);\n            addReplySds(VAR_0,sdscatprintf(sdsempty(),\"+%s\\r\\n\",VAR_10));\n            sdsfree(VAR_10);\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_5 */\n\n        /* COMMENT_7 */\n        lua_pushstring(VAR_1,\"double\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_7) {\n            addReplyDouble(VAR_0,lua_tonumber(VAR_1,-1));\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_5 */\n\n        /* COMMENT_8 */\n        lua_pushstring(VAR_1,\"map\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_8) {\n            int VAR_11 = 0;\n            void *VAR_12 = addReplyDeferredLen(VAR_0);\n            lua_pushnil(VAR_1); /* COMMENT_9 */\n            while (lua_next(VAR_1,-2)) {\n                /* COMMENT_10 */\n                lua_pushvalue(VAR_1,-2);        /* COMMENT_11 */\n                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_12 */\n                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_13 */\n                /* COMMENT_14 */\n                VAR_11++;\n            }\n            setDeferredMapLen(VAR_0,VAR_12,VAR_11);\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_5 */\n\n        /* COMMENT_15 */\n        lua_pushstring(VAR_1,\"set\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_8) {\n            int VAR_13 = 0;\n            void *VAR_12 = addReplyDeferredLen(VAR_0);\n            lua_pushnil(VAR_1); /* COMMENT_9 */\n            while (lua_next(VAR_1,-2)) {\n                /* COMMENT_16 */\n                lua_pop(VAR_1,1);               /* COMMENT_17 */\n                lua_pushvalue(VAR_1,-1);        /* COMMENT_11 */\n                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_12 */\n                /* COMMENT_14 */\n                VAR_13++;\n            }\n            setDeferredSetLen(VAR_0,VAR_12,VAR_13);\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_5 */\n\n        /* COMMENT_18 */\n        void *VAR_12 = addReplyDeferredLen(VAR_0);\n        int VAR_14 = 1, VAR_15 = 0;\n        while(1) {\n            lua_pushnumber(VAR_1,VAR_14++);\n            lua_gettable(VAR_1,-2);\n            VAR_2 = lua_type(VAR_1,-1);\n            if (VAR_2 == VAR_16) {\n                lua_pop(VAR_1,1);\n                break;\n            }\n            luaReplyToRedisReply(VAR_0, VAR_1);\n            VAR_15++;\n        }\n        setDeferredArrayLen(VAR_0,VAR_12,VAR_15);\n        break;\n    default:\n        addReplyNull(VAR_0);\n    }\n    lua_pop(VAR_1,1);\n}",
  "func_graph_path_before": "redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/before/1.json",
  "func": "void luaReplyToRedisReply(client *c, lua_State *lua) {\n\n    if (!lua_checkstack(lua, 4)) {\n        /* Increase the Lua stack if needed to make sure there is enough room\n         * to push 4 elements to the stack. On failure, return error.\n         * Notice that we need, in the worst case, 4 elements because returning a map might\n         * require push 4 elements to the Lua stack.*/\n        addReplyErrorFormat(c, \"reached lua stack limit\");\n        lua_pop(lua,1); // pop the element from the stack\n        return;\n    }\n\n    int t = lua_type(lua,-1);\n\n    switch(t) {\n    case LUA_TSTRING:\n        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));\n        break;\n    case LUA_TBOOLEAN:\n        if (server.lua_client->resp == 2)\n            addReply(c,lua_toboolean(lua,-1) ? shared.cone :\n                                               shared.null[c->resp]);\n        else\n            addReplyBool(c,lua_toboolean(lua,-1));\n        break;\n    case LUA_TNUMBER:\n        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));\n        break;\n    case LUA_TTABLE:\n        /* We need to check if it is an array, an error, or a status reply.\n         * Error are returned as a single element table with 'err' field.\n         * Status replies are returned as single element table with 'ok'\n         * field. */\n\n        /* Handle error reply. */\n        // we took care of the stack size on function start\n        lua_pushstring(lua,\"err\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds err = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(err,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"-%s\\r\\n\",err));\n            sdsfree(err);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle status reply. */\n        lua_pushstring(lua,\"ok\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds ok = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(ok,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"+%s\\r\\n\",ok));\n            sdsfree(ok);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle double reply. */\n        lua_pushstring(lua,\"double\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TNUMBER) {\n            addReplyDouble(c,lua_tonumber(lua,-1));\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle map reply. */\n        lua_pushstring(lua,\"map\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int maplen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            /* we took care of the stack size on function start */\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, value */\n                lua_pushvalue(lua,-2);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                luaReplyToRedisReply(c, lua); /* Return value. */\n                /* Stack now: table, key. */\n                maplen++;\n            }\n            setDeferredMapLen(c,replylen,maplen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle set reply. */\n        lua_pushstring(lua,\"set\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int setlen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            /* we took care of the stack size on function start */\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, true */\n                lua_pop(lua,1);               /* Discard the boolean value. */\n                lua_pushvalue(lua,-1);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                /* Stack now: table, key. */\n                setlen++;\n            }\n            setDeferredSetLen(c,replylen,setlen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle the array reply. */\n        void *replylen = addReplyDeferredLen(c);\n        int j = 1, mbulklen = 0;\n        while(1) {\n            /* we took care of the stack size on function start */\n            lua_pushnumber(lua,j++);\n            lua_gettable(lua,-2);\n            t = lua_type(lua,-1);\n            if (t == LUA_TNIL) {\n                lua_pop(lua,1);\n                break;\n            }\n            luaReplyToRedisReply(c, lua);\n            mbulklen++;\n        }\n        setDeferredArrayLen(c,replylen,mbulklen);\n        break;\n    default:\n        addReplyNull(c);\n    }\n    lua_pop(lua,1);\n}",
  "abstract_func": "void luaReplyToRedisReply(client *VAR_0, lua_State *VAR_1) {\n\n    if (!lua_checkstack(VAR_1, 4)) {\n        /* COMMENT_0 */\n                                                                     \n                                                                                           \n                                                      \n        addReplyErrorFormat(VAR_0, \"reached lua stack limit\");\n        lua_pop(VAR_1,1); /* COMMENT_4 */\n        return;\n    }\n\n    int VAR_2 = lua_type(VAR_1,-1);\n\n    switch(VAR_2) {\n    case VAR_3:\n        addReplyBulkCBuffer(VAR_0,(char*)lua_tostring(VAR_1,-1),lua_strlen(VAR_1,-1));\n        break;\n    case VAR_4:\n        if (VAR_5.lua_client->resp == 2)\n            addReply(VAR_0,lua_toboolean(VAR_1,-1) ? VAR_6.cone :\n                                               VAR_6.null[VAR_0->resp]);\n        else\n            addReplyBool(VAR_0,lua_toboolean(VAR_1,-1));\n        break;\n    case VAR_7:\n        addReplyLongLong(VAR_0,(long long)lua_tonumber(VAR_1,-1));\n        break;\n    case VAR_8:\n        /* COMMENT_5 */\n                                                                         \n                                                                        \n                    \n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        lua_pushstring(VAR_1,\"err\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_3) {\n            sds VAR_9 = sdsnew(lua_tostring(VAR_1,-1));\n            sdsmapchars(VAR_9,\"\\r\\n\",\"  \",2);\n            addReplySds(VAR_0,sdscatprintf(sdsempty(),\"-%s\\r\\n\",VAR_9));\n            sdsfree(VAR_9);\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_11 */\n\n        /* COMMENT_12 */\n        lua_pushstring(VAR_1,\"ok\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_3) {\n            sds VAR_10 = sdsnew(lua_tostring(VAR_1,-1));\n            sdsmapchars(VAR_10,\"\\r\\n\",\"  \",2);\n            addReplySds(VAR_0,sdscatprintf(sdsempty(),\"+%s\\r\\n\",VAR_10));\n            sdsfree(VAR_10);\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_11 */\n\n        /* COMMENT_13 */\n        lua_pushstring(VAR_1,\"double\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_7) {\n            addReplyDouble(VAR_0,lua_tonumber(VAR_1,-1));\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_11 */\n\n        /* COMMENT_14 */\n        lua_pushstring(VAR_1,\"map\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_8) {\n            int VAR_11 = 0;\n            void *VAR_12 = addReplyDeferredLen(VAR_0);\n            /* COMMENT_15 */\n            lua_pushnil(VAR_1); /* COMMENT_16 */\n            while (lua_next(VAR_1,-2)) {\n                /* COMMENT_17 */\n                lua_pushvalue(VAR_1,-2);        /* COMMENT_18 */\n                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_19 */\n                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_20 */\n                /* COMMENT_21 */\n                VAR_11++;\n            }\n            setDeferredMapLen(VAR_0,VAR_12,VAR_11);\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_11 */\n\n        /* COMMENT_22 */\n        lua_pushstring(VAR_1,\"set\");\n        lua_gettable(VAR_1,-2);\n        VAR_2 = lua_type(VAR_1,-1);\n        if (VAR_2 == VAR_8) {\n            int VAR_13 = 0;\n            void *VAR_12 = addReplyDeferredLen(VAR_0);\n            /* COMMENT_15 */\n            lua_pushnil(VAR_1); /* COMMENT_16 */\n            while (lua_next(VAR_1,-2)) {\n                /* COMMENT_23 */\n                lua_pop(VAR_1,1);               /* COMMENT_24 */\n                lua_pushvalue(VAR_1,-1);        /* COMMENT_18 */\n                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_19 */\n                /* COMMENT_21 */\n                VAR_13++;\n            }\n            setDeferredSetLen(VAR_0,VAR_12,VAR_13);\n            lua_pop(VAR_1,2);\n            return;\n        }\n        lua_pop(VAR_1,1); /* COMMENT_11 */\n\n        /* COMMENT_25 */\n        void *VAR_12 = addReplyDeferredLen(VAR_0);\n        int VAR_14 = 1, VAR_15 = 0;\n        while(1) {\n            /* COMMENT_15 */\n            lua_pushnumber(VAR_1,VAR_14++);\n            lua_gettable(VAR_1,-2);\n            VAR_2 = lua_type(VAR_1,-1);\n            if (VAR_2 == VAR_16) {\n                lua_pop(VAR_1,1);\n                break;\n            }\n            luaReplyToRedisReply(VAR_0, VAR_1);\n            VAR_15++;\n        }\n        setDeferredArrayLen(VAR_0,VAR_12,VAR_15);\n        break;\n    default:\n        addReplyNull(VAR_0);\n    }\n    lua_pop(VAR_1,1);\n}",
  "func_graph_path": "redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,15 @@\n void luaReplyToRedisReply(client *c, lua_State *lua) {\n+\n+    if (!lua_checkstack(lua, 4)) {\n+        /* Increase the Lua stack if needed to make sure there is enough room\n+         * to push 4 elements to the stack. On failure, return error.\n+         * Notice that we need, in the worst case, 4 elements because returning a map might\n+         * require push 4 elements to the Lua stack.*/\n+        addReplyErrorFormat(c, \"reached lua stack limit\");\n+        lua_pop(lua,1); // pop the element from the stack\n+        return;\n+    }\n+\n     int t = lua_type(lua,-1);\n \n     switch(t) {\n@@ -22,6 +33,7 @@\n          * field. */\n \n         /* Handle error reply. */\n+        // we took care of the stack size on function start\n         lua_pushstring(lua,\"err\");\n         lua_gettable(lua,-2);\n         t = lua_type(lua,-1);\n@@ -67,6 +79,7 @@\n         if (t == LUA_TTABLE) {\n             int maplen = 0;\n             void *replylen = addReplyDeferredLen(c);\n+            /* we took care of the stack size on function start */\n             lua_pushnil(lua); /* Use nil to start iteration. */\n             while (lua_next(lua,-2)) {\n                 /* Stack now: table, key, value */\n@@ -89,6 +102,7 @@\n         if (t == LUA_TTABLE) {\n             int setlen = 0;\n             void *replylen = addReplyDeferredLen(c);\n+            /* we took care of the stack size on function start */\n             lua_pushnil(lua); /* Use nil to start iteration. */\n             while (lua_next(lua,-2)) {\n                 /* Stack now: table, key, true */\n@@ -108,6 +122,7 @@\n         void *replylen = addReplyDeferredLen(c);\n         int j = 1, mbulklen = 0;\n         while(1) {\n+            /* we took care of the stack size on function start */\n             lua_pushnumber(lua,j++);\n             lua_gettable(lua,-2);\n             t = lua_type(lua,-1);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if (!lua_checkstack(lua, 4)) {",
      "        /* Increase the Lua stack if needed to make sure there is enough room",
      "         * to push 4 elements to the stack. On failure, return error.",
      "         * Notice that we need, in the worst case, 4 elements because returning a map might",
      "         * require push 4 elements to the Lua stack.*/",
      "        addReplyErrorFormat(c, \"reached lua stack limit\");",
      "        lua_pop(lua,1); // pop the element from the stack",
      "        return;",
      "    }",
      "",
      "        // we took care of the stack size on function start",
      "            /* we took care of the stack size on function start */",
      "            /* we took care of the stack size on function start */",
      "            /* we took care of the stack size on function start */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}