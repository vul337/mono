{
  "cve_id": "CVE-2017-3731",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "crypto/evp: harden AEAD ciphers.\n\nOriginally a crash in 32-bit build was reported CHACHA20-POLY1305\ncipher. The crash is triggered by truncated packet and is result\nof excessive hashing to the edge of accessible memory. Since hash\noperation is read-only it is not considered to be exploitable\nbeyond a DoS condition. Other ciphers were hardened.\n\nThanks to Robert Święcki for report.\n\nCVE-2017-3731\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
  "commit_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
  "git_url": "https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21",
  "file_path": "crypto/evp/e_aes.c",
  "func_name": "aes_ccm_ctrl",
  "func_before": "static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n{\n    EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,c);\n    switch (type) {\n    case EVP_CTRL_INIT:\n        cctx->key_set = 0;\n        cctx->iv_set = 0;\n        cctx->L = 8;\n        cctx->M = 12;\n        cctx->tag_set = 0;\n        cctx->len_set = 0;\n        cctx->tls_aad_len = -1;\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        /* Save the AAD for later use */\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        cctx->tls_aad_len = arg;\n        {\n            uint16_t len =\n                EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n            /* Correct length for explicit IV */\n            len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n            /* If decrypting correct for tag too */\n            if (!EVP_CIPHER_CTX_encrypting(c))\n                len -= cctx->M;\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n        }\n        /* Extra padding: tag appended to record */\n        return cctx->M;\n\n    case EVP_CTRL_CCM_SET_IV_FIXED:\n        /* Sanity check length */\n        if (arg != EVP_CCM_TLS_FIXED_IV_LEN)\n            return 0;\n        /* Just copy to first part of IV */\n        memcpy(EVP_CIPHER_CTX_iv_noconst(c), ptr, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        arg = 15 - arg;\n    case EVP_CTRL_CCM_SET_L:\n        if (arg < 2 || arg > 8)\n            return 0;\n        cctx->L = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if ((arg & 1) || arg < 4 || arg > 16)\n            return 0;\n        if (EVP_CIPHER_CTX_encrypting(c) && ptr)\n            return 0;\n        if (ptr) {\n            cctx->tag_set = 1;\n            memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        }\n        cctx->M = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (!EVP_CIPHER_CTX_encrypting(c) || !cctx->tag_set)\n            return 0;\n        if (!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg))\n            return 0;\n        cctx->tag_set = 0;\n        cctx->iv_set = 0;\n        cctx->len_set = 0;\n        return 1;\n\n    case EVP_CTRL_COPY:\n        {\n            EVP_CIPHER_CTX *out = ptr;\n            EVP_AES_CCM_CTX *cctx_out = EVP_C_DATA(EVP_AES_CCM_CTX,out);\n            if (cctx->ccm.key) {\n                if (cctx->ccm.key != &cctx->ks)\n                    return 0;\n                cctx_out->ccm.key = &cctx_out->ks;\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}",
  "abstract_func_before": "static int aes_ccm_ctrl(EVP_CIPHER_CTX *VAR_0, int VAR_1, int VAR_2, void *VAR_3)\n{\n    EVP_AES_CCM_CTX *VAR_4 = EVP_C_DATA(EVP_AES_CCM_CTX,VAR_0);\n    switch (VAR_1) {\n    case VAR_5:\n        VAR_4->key_set = 0;\n        VAR_4->iv_set = 0;\n        VAR_4->L = 8;\n        VAR_4->M = 12;\n        VAR_4->tag_set = 0;\n        VAR_4->len_set = 0;\n        VAR_4->tls_aad_len = -1;\n        return 1;\n\n    case VAR_6:\n        /* COMMENT_0 */\n        if (VAR_2 != VAR_7)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_3, VAR_2);\n        VAR_4->tls_aad_len = VAR_2;\n        {\n            uint16_t VAR_8 =\n                EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 1];\n            /* COMMENT_1 */\n            VAR_8 -= VAR_9;\n            /* COMMENT_2 */\n            if (!EVP_CIPHER_CTX_encrypting(VAR_0))\n                VAR_8 -= VAR_4->M;\n            EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 2] = VAR_8 >> 8;\n            EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 1] = VAR_8 & 0xff;\n        }\n        /* COMMENT_3 */\n        return VAR_4->M;\n\n    case VAR_10:\n        /* COMMENT_4 */\n        if (VAR_2 != VAR_11)\n            return 0;\n        /* COMMENT_5 */\n        memcpy(EVP_CIPHER_CTX_iv_noconst(VAR_0), VAR_3, VAR_2);\n        return 1;\n\n    case VAR_12:\n        VAR_2 = 15 - VAR_2;\n    case VAR_13:\n        if (VAR_2 < 2 || VAR_2 > 8)\n            return 0;\n        VAR_4->L = VAR_2;\n        return 1;\n\n    case VAR_14:\n        if ((VAR_2 & 1) || VAR_2 < 4 || VAR_2 > 16)\n            return 0;\n        if (EVP_CIPHER_CTX_encrypting(VAR_0) && VAR_3)\n            return 0;\n        if (VAR_3) {\n            VAR_4->tag_set = 1;\n            memcpy(EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_3, VAR_2);\n        }\n        VAR_4->M = VAR_2;\n        return 1;\n\n    case VAR_15:\n        if (!EVP_CIPHER_CTX_encrypting(VAR_0) || !VAR_4->tag_set)\n            return 0;\n        if (!CRYPTO_ccm128_tag(&VAR_4->ccm, VAR_3, (size_t)VAR_2))\n            return 0;\n        VAR_4->tag_set = 0;\n        VAR_4->iv_set = 0;\n        VAR_4->len_set = 0;\n        return 1;\n\n    case VAR_16:\n        {\n            EVP_CIPHER_CTX *VAR_17 = VAR_3;\n            EVP_AES_CCM_CTX *VAR_18 = EVP_C_DATA(EVP_AES_CCM_CTX,VAR_17);\n            if (VAR_4->ccm.key) {\n                if (VAR_4->ccm.key != &VAR_4->ks)\n                    return 0;\n                VAR_18->ccm.key = &VAR_18->ks;\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}",
  "func_graph_path_before": "openssl/00d965474b22b54e4275232bc71ee0c699c5cd21/e_aes.c/vul/before/1.json",
  "func": "static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n{\n    EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,c);\n    switch (type) {\n    case EVP_CTRL_INIT:\n        cctx->key_set = 0;\n        cctx->iv_set = 0;\n        cctx->L = 8;\n        cctx->M = 12;\n        cctx->tag_set = 0;\n        cctx->len_set = 0;\n        cctx->tls_aad_len = -1;\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        /* Save the AAD for later use */\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        cctx->tls_aad_len = arg;\n        {\n            uint16_t len =\n                EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n            /* Correct length for explicit IV */\n            if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)\n                return 0;\n            len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n            /* If decrypting correct for tag too */\n            if (!EVP_CIPHER_CTX_encrypting(c)) {\n                if (len < cctx->M)\n                    return 0;\n                len -= cctx->M;\n            }\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n        }\n        /* Extra padding: tag appended to record */\n        return cctx->M;\n\n    case EVP_CTRL_CCM_SET_IV_FIXED:\n        /* Sanity check length */\n        if (arg != EVP_CCM_TLS_FIXED_IV_LEN)\n            return 0;\n        /* Just copy to first part of IV */\n        memcpy(EVP_CIPHER_CTX_iv_noconst(c), ptr, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        arg = 15 - arg;\n    case EVP_CTRL_CCM_SET_L:\n        if (arg < 2 || arg > 8)\n            return 0;\n        cctx->L = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if ((arg & 1) || arg < 4 || arg > 16)\n            return 0;\n        if (EVP_CIPHER_CTX_encrypting(c) && ptr)\n            return 0;\n        if (ptr) {\n            cctx->tag_set = 1;\n            memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        }\n        cctx->M = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (!EVP_CIPHER_CTX_encrypting(c) || !cctx->tag_set)\n            return 0;\n        if (!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg))\n            return 0;\n        cctx->tag_set = 0;\n        cctx->iv_set = 0;\n        cctx->len_set = 0;\n        return 1;\n\n    case EVP_CTRL_COPY:\n        {\n            EVP_CIPHER_CTX *out = ptr;\n            EVP_AES_CCM_CTX *cctx_out = EVP_C_DATA(EVP_AES_CCM_CTX,out);\n            if (cctx->ccm.key) {\n                if (cctx->ccm.key != &cctx->ks)\n                    return 0;\n                cctx_out->ccm.key = &cctx_out->ks;\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}",
  "abstract_func": "static int aes_ccm_ctrl(EVP_CIPHER_CTX *VAR_0, int VAR_1, int VAR_2, void *VAR_3)\n{\n    EVP_AES_CCM_CTX *VAR_4 = EVP_C_DATA(EVP_AES_CCM_CTX,VAR_0);\n    switch (VAR_1) {\n    case VAR_5:\n        VAR_4->key_set = 0;\n        VAR_4->iv_set = 0;\n        VAR_4->L = 8;\n        VAR_4->M = 12;\n        VAR_4->tag_set = 0;\n        VAR_4->len_set = 0;\n        VAR_4->tls_aad_len = -1;\n        return 1;\n\n    case VAR_6:\n        /* COMMENT_0 */\n        if (VAR_2 != VAR_7)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_3, VAR_2);\n        VAR_4->tls_aad_len = VAR_2;\n        {\n            uint16_t VAR_8 =\n                EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 1];\n            /* COMMENT_1 */\n            if (VAR_8 < VAR_9)\n                return 0;\n            VAR_8 -= VAR_9;\n            /* COMMENT_2 */\n            if (!EVP_CIPHER_CTX_encrypting(VAR_0)) {\n                if (VAR_8 < VAR_4->M)\n                    return 0;\n                VAR_8 -= VAR_4->M;\n            }\n            EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 2] = VAR_8 >> 8;\n            EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 1] = VAR_8 & 0xff;\n        }\n        /* COMMENT_3 */\n        return VAR_4->M;\n\n    case VAR_10:\n        /* COMMENT_4 */\n        if (VAR_2 != VAR_11)\n            return 0;\n        /* COMMENT_5 */\n        memcpy(EVP_CIPHER_CTX_iv_noconst(VAR_0), VAR_3, VAR_2);\n        return 1;\n\n    case VAR_12:\n        VAR_2 = 15 - VAR_2;\n    case VAR_13:\n        if (VAR_2 < 2 || VAR_2 > 8)\n            return 0;\n        VAR_4->L = VAR_2;\n        return 1;\n\n    case VAR_14:\n        if ((VAR_2 & 1) || VAR_2 < 4 || VAR_2 > 16)\n            return 0;\n        if (EVP_CIPHER_CTX_encrypting(VAR_0) && VAR_3)\n            return 0;\n        if (VAR_3) {\n            VAR_4->tag_set = 1;\n            memcpy(EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_3, VAR_2);\n        }\n        VAR_4->M = VAR_2;\n        return 1;\n\n    case VAR_15:\n        if (!EVP_CIPHER_CTX_encrypting(VAR_0) || !VAR_4->tag_set)\n            return 0;\n        if (!CRYPTO_ccm128_tag(&VAR_4->ccm, VAR_3, (size_t)VAR_2))\n            return 0;\n        VAR_4->tag_set = 0;\n        VAR_4->iv_set = 0;\n        VAR_4->len_set = 0;\n        return 1;\n\n    case VAR_16:\n        {\n            EVP_CIPHER_CTX *VAR_17 = VAR_3;\n            EVP_AES_CCM_CTX *VAR_18 = EVP_C_DATA(EVP_AES_CCM_CTX,VAR_17);\n            if (VAR_4->ccm.key) {\n                if (VAR_4->ccm.key != &VAR_4->ks)\n                    return 0;\n                VAR_18->ccm.key = &VAR_18->ks;\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}",
  "func_graph_path": "openssl/00d965474b22b54e4275232bc71ee0c699c5cd21/e_aes.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -23,10 +23,15 @@\n                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n             /* Correct length for explicit IV */\n+            if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)\n+                return 0;\n             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n             /* If decrypting correct for tag too */\n-            if (!EVP_CIPHER_CTX_encrypting(c))\n+            if (!EVP_CIPHER_CTX_encrypting(c)) {\n+                if (len < cctx->M)\n+                    return 0;\n                 len -= cctx->M;\n+            }\n             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "            if (!EVP_CIPHER_CTX_encrypting(c))"
    ],
    "added_lines": [
      "            if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)",
      "                return 0;",
      "            if (!EVP_CIPHER_CTX_encrypting(c)) {",
      "                if (len < cctx->M)",
      "                    return 0;",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/EktapopaT/openssl/pull/1: 403 Client Error: Forbidden for url: https://api.github.com/repos/EktapopaT/openssl/pulls/1",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Step-by-Step Analysis:**\n\n1. **Input Analysis:**  \n   The commit message mentions \"harden AEAD ciphers\" and refers to a crash in a 32-bit build with CHACHA20-POLY1305, associating it with CVE-2017-3731, a security issue. The code diff adds boundary checks for certain cipher operations, preventing overflows.\n\n2. **Consistency Check:**  \n   The commit message aligns with the code changes focused on AEAD cipher hardening. However, the provided vulnerability description discusses TLS extensions, which seems unrelated, raising slight confusion.\n\n3. **Purpose Evaluation:**  \n   The code changes are defensive measures against buffer overflow risks, indicating an intent to fix a security flaw rather than a feature or test update.\n\n4. **Security Vulnerability Assessment:**  \n   The patch explicitly fixes a crash that could be exploited for a DoS and introduces input validation, characteristics of a security fix. It references a CVE, confirming its security nature.\n\n5. **Non-Security Classification:**  \n   Not applicable since the patch addresses a security issue.\n\n6. **Confidence Scoring:**  \n   High confidence as the commit, vulnerability reference (CVE-2017-3731), and code changes clearly indicate a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}