{
  "cve_id": "CVE-2019-1010292",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "OP-TEE/optee_os",
  "commit_msg": "core: ensure that supplied range matches MOBJ\n\nIn set_rmem_param() if the MOBJ is found by the cookie it's verified to\nrepresent non-secure shared memory. Prior to this patch the supplied\nsub-range to be used of the MOBJ was not checked here and relied on\nlater checks further down the chain. Those checks seems to be enough\nfor user TAs, but not for pseudo TAs where the size isn't checked.\n\nThis patch adds a check for offset and size to see that they remain\ninside the memory covered by the MOBJ.\n\nFixes: OP-TEE-2018-0004: \"Unchecked parameters are passed through from\nREE\".\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
  "commit_hash": "e3adcf566cb278444830e7badfdcc3983e334fd1",
  "git_url": "https://github.com/OP-TEE/optee_os/commit/e3adcf566cb278444830e7badfdcc3983e334fd1",
  "file_path": "core/arch/arm/tee/entry_std.c",
  "func_name": "set_rmem_param",
  "func_before": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\n\treturn TEE_SUCCESS;\n}",
  "abstract_func_before": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *VAR_0,\n\t\t\t\t struct param_mem *VAR_1)\n{\n\tuint64_t VAR_2 = READ_ONCE(VAR_0->shm_ref);\n\n\tVAR_1->mobj = mobj_reg_shm_get_by_cookie(VAR_2);\n\tif (!VAR_1->mobj)\n\t\treturn VAR_3;\n\n\tVAR_1->offs = READ_ONCE(VAR_0->offs);\n\tVAR_1->size = READ_ONCE(VAR_0->size);\n\n\treturn VAR_4;\n}",
  "func_graph_path_before": "OP-TEE/optee_os/e3adcf566cb278444830e7badfdcc3983e334fd1/entry_std.c/vul/before/0.json",
  "func": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\n\t/*\n\t * Check that the supplied offset and size is covered by the\n\t * previously verified MOBJ.\n\t */\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\n\treturn TEE_SUCCESS;\n}",
  "abstract_func": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *VAR_0,\n\t\t\t\t struct param_mem *VAR_1)\n{\n\tsize_t VAR_2 = 0;\n\tuint64_t VAR_3 = READ_ONCE(VAR_0->shm_ref);\n\n\tVAR_1->mobj = mobj_reg_shm_get_by_cookie(VAR_3);\n\tif (!VAR_1->mobj)\n\t\treturn VAR_4;\n\n\tVAR_1->offs = READ_ONCE(VAR_0->offs);\n\tVAR_1->size = READ_ONCE(VAR_0->size);\n\n\t/* COMMENT_0 */\n                                                             \n                             \n    \n\tif (ADD_OVERFLOW(VAR_1->offs, VAR_1->size, &VAR_2) ||\n\t    VAR_1->mobj->size < VAR_2)\n\t\treturn VAR_5;\n\n\treturn VAR_6;\n}",
  "func_graph_path": "OP-TEE/optee_os/e3adcf566cb278444830e7badfdcc3983e334fd1/entry_std.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n \t\t\t\t struct param_mem *mem)\n {\n+\tsize_t req_size = 0;\n \tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n \n \tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n@@ -10,5 +11,13 @@\n \tmem->offs = READ_ONCE(rmem->offs);\n \tmem->size = READ_ONCE(rmem->size);\n \n+\t/*\n+\t * Check that the supplied offset and size is covered by the\n+\t * previously verified MOBJ.\n+\t */\n+\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n+\t    mem->mobj->size < req_size)\n+\t\treturn TEE_ERROR_SECURITY;\n+\n \treturn TEE_SUCCESS;\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tsize_t req_size = 0;",
      "\t/*",
      "\t * Check that the supplied offset and size is covered by the",
      "\t * previously verified MOBJ.",
      "\t */",
      "\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||",
      "\t    mem->mobj->size < req_size)",
      "\t\treturn TEE_ERROR_SECURITY;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/2745",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OP-TEE/optee_os/pull/2745: 403 Client Error: Forbidden for url: https://api.github.com/repos/OP-TEE/optee_os/pulls/2745",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Commit Message Analysis:** The commit addresses an issue where supplied parameters were not checked, which was a security concern.\n\n2. **Code Changes:** Adds checks for memory offset and size to prevent exceeding MOBJ's size, a typical security measure.\n\n3. **Vulnerability Context:** Part of a series fixing security issues identified by Riscure, indicating the fix is security-related.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}