{
  "cve_id": "CVE-2021-46345",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Fix invalid assertion CESU8-UTF8 buffer copy\n\nThe UTF8 buffer size can be smaller then the CESU8 string's size so the UTF8 output is may truncated. Therefore we cannot ensure that the CESU8 buffer is read until the end.\nThis patch fixes #4920.\n\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",
  "commit_hash": "e54c980de52416e41296545e7f5b210a53b31d12",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/e54c980de52416e41296545e7f5b210a53b31d12",
  "file_path": "jerry-core/lit/lit-strings.c",
  "func_name": "lit_convert_cesu8_string_to_utf8_string",
  "func_before": "lit_utf8_size_t\nlit_convert_cesu8_string_to_utf8_string (const lit_utf8_byte_t *cesu8_string_p, /**< cesu-8 string */\n                                         lit_utf8_size_t cesu8_size, /**< size of cesu-8 string */\n                                         lit_utf8_byte_t *utf8_string_p, /**< destination utf-8 buffer pointer\n                                                                          * (can be NULL if buffer_size == 0) */\n                                         lit_utf8_size_t utf8_size) /**< size of utf-8 buffer */\n{\n  const lit_utf8_byte_t *cesu8_cursor_p = cesu8_string_p;\n  const lit_utf8_byte_t *cesu8_end_p = cesu8_string_p + cesu8_size;\n\n  lit_utf8_byte_t *utf8_cursor_p = utf8_string_p;\n  lit_utf8_byte_t *utf8_end_p = utf8_string_p + utf8_size;\n\n  while (cesu8_cursor_p < cesu8_end_p)\n  {\n    lit_code_point_t cp;\n    lit_utf8_size_t read_size = lit_read_code_point_from_cesu8 (cesu8_cursor_p, cesu8_end_p, &cp);\n    lit_utf8_size_t encoded_size = (cp >= LIT_UTF16_FIRST_SURROGATE_CODE_POINT) ? 4 : read_size;\n\n    if (utf8_cursor_p + encoded_size > utf8_end_p)\n    {\n      break;\n    }\n\n    if (cp >= LIT_UTF16_FIRST_SURROGATE_CODE_POINT)\n    {\n      lit_code_point_to_utf8 (cp, utf8_cursor_p);\n    }\n    else\n    {\n      memcpy (utf8_cursor_p, cesu8_cursor_p, encoded_size);\n    }\n\n    utf8_cursor_p += encoded_size;\n    cesu8_cursor_p += read_size;\n  }\n\n  JERRY_ASSERT (cesu8_cursor_p == cesu8_end_p);\n  JERRY_ASSERT (utf8_cursor_p <= utf8_end_p);\n\n  return (lit_utf8_byte_t) (utf8_cursor_p - utf8_string_p);\n}",
  "abstract_func_before": "lit_utf8_size_t\nlit_convert_cesu8_string_to_utf8_string (const lit_utf8_byte_t *VAR_0, /* COMMENT_0 */\n                                         lit_utf8_size_t VAR_1, /* COMMENT_1 */\n                                         lit_utf8_byte_t *VAR_2, /* COMMENT_2 */\n                                                                                                                \n                                         lit_utf8_size_t VAR_3) /* COMMENT_4 */\n{\n  const lit_utf8_byte_t *VAR_4 = VAR_0;\n  const lit_utf8_byte_t *VAR_5 = VAR_0 + VAR_1;\n\n  lit_utf8_byte_t *VAR_6 = VAR_2;\n  lit_utf8_byte_t *VAR_7 = VAR_2 + VAR_3;\n\n  while (VAR_4 < VAR_5)\n  {\n    lit_code_point_t VAR_8;\n    lit_utf8_size_t VAR_9 = lit_read_code_point_from_cesu8 (VAR_4, VAR_5, &VAR_8);\n    lit_utf8_size_t VAR_10 = (VAR_8 >= VAR_11) ? 4 : VAR_9;\n\n    if (VAR_6 + VAR_10 > VAR_7)\n    {\n      break;\n    }\n\n    if (VAR_8 >= VAR_11)\n    {\n      lit_code_point_to_utf8 (VAR_8, VAR_6);\n    }\n    else\n    {\n      memcpy (VAR_6, VAR_4, VAR_10);\n    }\n\n    VAR_6 += VAR_10;\n    VAR_4 += VAR_9;\n  }\n\n  JERRY_ASSERT (VAR_4 == VAR_5);\n  JERRY_ASSERT (VAR_6 <= VAR_7);\n\n  return (lit_utf8_byte_t) (VAR_6 - VAR_2);\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/e54c980de52416e41296545e7f5b210a53b31d12/lit-strings.c/vul/before/0.json",
  "func": "lit_utf8_size_t\nlit_convert_cesu8_string_to_utf8_string (const lit_utf8_byte_t *cesu8_string_p, /**< cesu-8 string */\n                                         lit_utf8_size_t cesu8_size, /**< size of cesu-8 string */\n                                         lit_utf8_byte_t *utf8_string_p, /**< destination utf-8 buffer pointer\n                                                                          * (can be NULL if buffer_size == 0) */\n                                         lit_utf8_size_t utf8_size) /**< size of utf-8 buffer */\n{\n  const lit_utf8_byte_t *cesu8_cursor_p = cesu8_string_p;\n  const lit_utf8_byte_t *cesu8_end_p = cesu8_string_p + cesu8_size;\n\n  lit_utf8_byte_t *utf8_cursor_p = utf8_string_p;\n  lit_utf8_byte_t *utf8_end_p = utf8_string_p + utf8_size;\n\n  while (cesu8_cursor_p < cesu8_end_p)\n  {\n    lit_code_point_t cp;\n    lit_utf8_size_t read_size = lit_read_code_point_from_cesu8 (cesu8_cursor_p, cesu8_end_p, &cp);\n    lit_utf8_size_t encoded_size = (cp >= LIT_UTF16_FIRST_SURROGATE_CODE_POINT) ? 4 : read_size;\n\n    if (utf8_cursor_p + encoded_size > utf8_end_p)\n    {\n      break;\n    }\n\n    if (cp >= LIT_UTF16_FIRST_SURROGATE_CODE_POINT)\n    {\n      lit_code_point_to_utf8 (cp, utf8_cursor_p);\n    }\n    else\n    {\n      memcpy (utf8_cursor_p, cesu8_cursor_p, encoded_size);\n    }\n\n    utf8_cursor_p += encoded_size;\n    cesu8_cursor_p += read_size;\n  }\n\n  JERRY_ASSERT (cesu8_cursor_p <= cesu8_end_p);\n  JERRY_ASSERT (utf8_cursor_p <= utf8_end_p);\n\n  return (lit_utf8_byte_t) (utf8_cursor_p - utf8_string_p);\n}",
  "abstract_func": "lit_utf8_size_t\nlit_convert_cesu8_string_to_utf8_string (const lit_utf8_byte_t *VAR_0, /* COMMENT_0 */\n                                         lit_utf8_size_t VAR_1, /* COMMENT_1 */\n                                         lit_utf8_byte_t *VAR_2, /* COMMENT_2 */\n                                                                                                                \n                                         lit_utf8_size_t VAR_3) /* COMMENT_4 */\n{\n  const lit_utf8_byte_t *VAR_4 = VAR_0;\n  const lit_utf8_byte_t *VAR_5 = VAR_0 + VAR_1;\n\n  lit_utf8_byte_t *VAR_6 = VAR_2;\n  lit_utf8_byte_t *VAR_7 = VAR_2 + VAR_3;\n\n  while (VAR_4 < VAR_5)\n  {\n    lit_code_point_t VAR_8;\n    lit_utf8_size_t VAR_9 = lit_read_code_point_from_cesu8 (VAR_4, VAR_5, &VAR_8);\n    lit_utf8_size_t VAR_10 = (VAR_8 >= VAR_11) ? 4 : VAR_9;\n\n    if (VAR_6 + VAR_10 > VAR_7)\n    {\n      break;\n    }\n\n    if (VAR_8 >= VAR_11)\n    {\n      lit_code_point_to_utf8 (VAR_8, VAR_6);\n    }\n    else\n    {\n      memcpy (VAR_6, VAR_4, VAR_10);\n    }\n\n    VAR_6 += VAR_10;\n    VAR_4 += VAR_9;\n  }\n\n  JERRY_ASSERT (VAR_4 <= VAR_5);\n  JERRY_ASSERT (VAR_6 <= VAR_7);\n\n  return (lit_utf8_byte_t) (VAR_6 - VAR_2);\n}",
  "func_graph_path": "jerryscript-project/jerryscript/e54c980de52416e41296545e7f5b210a53b31d12/lit-strings.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,7 @@\n     cesu8_cursor_p += read_size;\n   }\n \n-  JERRY_ASSERT (cesu8_cursor_p == cesu8_end_p);\n+  JERRY_ASSERT (cesu8_cursor_p <= cesu8_end_p);\n   JERRY_ASSERT (utf8_cursor_p <= utf8_end_p);\n \n   return (lit_utf8_byte_t) (utf8_cursor_p - utf8_string_p);",
  "diff_line_info": {
    "deleted_lines": [
      "  JERRY_ASSERT (cesu8_cursor_p == cesu8_end_p);"
    ],
    "added_lines": [
      "  JERRY_ASSERT (cesu8_cursor_p <= cesu8_end_p);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/4946",
  "description": {
    "pr_info": {
      "title": "Fix invalid assertion CESU8-UTF8 buffer copy",
      "number": 4946
    },
    "comment": [
      "The UTF8 buffer size can be smaller then the CESU8 string's size so the UTF8 output is may truncated. Therefore we cannot ensure that the CESU8 buffer is read until the end.\r\nThis patch fixes #4920.\r\n\r\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.95"
}