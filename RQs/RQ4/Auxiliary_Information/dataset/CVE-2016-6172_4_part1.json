{
  "cve_id": "CVE-2016-6172",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "PowerDNS/pdns",
  "commit_msg": "Add limits to the size of received {A,I}XFR, in megabytes\n\nThis prevents memory exhaustion in case the master is sending a\nvery large amount of data in an update.",
  "commit_hash": "db8f9152168acf5d548d4f256789eae783e01667",
  "git_url": "https://github.com/PowerDNS/pdns/commit/db8f9152168acf5d548d4f256789eae783e01667",
  "file_path": "pdns/slavecommunicator.cc",
  "func_name": "CommunicatorClass::ixfrSuck",
  "func_before": "void CommunicatorClass::ixfrSuck(const DNSName &domain, const TSIGTriplet& tt, const ComboAddress& laddr, const ComboAddress& remote, scoped_ptr<AuthLua>& pdl,\n                                 ZoneStatus& zs, vector<DNSRecord>* axfr)\n{\n  UeberBackend B; // fresh UeberBackend\n\n  DomainInfo di;\n  di.backend=0;\n  //  bool transaction=false;\n  try {\n    DNSSECKeeper dk (&B); // reuse our UeberBackend copy for DNSSECKeeper\n\n    if(!B.getDomainInfo(domain, di) || !di.backend) { // di.backend and B are mostly identical\n      L<<Logger::Error<<\"Can't determine backend for domain '\"<<domain<<\"'\"<<endl;\n      return;\n    }\n\n    soatimes st;\n    memset(&st, 0, sizeof(st));\n    st.serial=di.serial;\n\n    DNSRecord dr;\n    dr.d_content = std::make_shared<SOARecordContent>(DNSName(\".\"), DNSName(\".\"), st);\n    auto deltas = getIXFRDeltas(remote, domain, dr, tt, laddr.sin4.sin_family ? &laddr : 0);\n    zs.numDeltas=deltas.size();\n    //    cout<<\"Got \"<<deltas.size()<<\" deltas from serial \"<<di.serial<<\", applying..\"<<endl;\n    \n    for(const auto& d : deltas) {\n      const auto& remove = d.first;\n      const auto& add = d.second;\n      //      cout<<\"Delta sizes: \"<<remove.size()<<\", \"<<add.size()<<endl;\n      \n      if(remove.empty()) { // we got passed an AXFR!\n        *axfr = add;\n        return;\n      }\n        \n\n      // our hammer is 'replaceRRSet(domain_id, qname, qt, vector<DNSResourceRecord>& rrset)\n      // which thinks in terms of RRSETs\n      // however, IXFR does not, and removes and adds *records* (bummer)\n      // this means that we must group updates by {qname,qtype}, retrieve the RRSET, apply\n      // the add/remove updates, and replaceRRSet the whole thing. \n      \n      \n      map<pair<DNSName,uint16_t>, pair<vector<DNSRecord>, vector<DNSRecord> > > grouped;\n      \n      for(const auto& x: remove)\n        grouped[{x.d_name, x.d_type}].first.push_back(x);\n      for(const auto& x: add)\n        grouped[{x.d_name, x.d_type}].second.push_back(x);\n\n      di.backend->startTransaction(domain, -1);\n      for(const auto g : grouped) {\n        DNSResourceRecord rr;\n        vector<DNSRecord> rrset;\n        B.lookup(QType(g.first.second), g.first.first, 0, di.id);\n        while(B.get(rr)) {\n          rrset.push_back(DNSRecord{rr});\n        }\n        // O(N^2)!\n        rrset.erase(remove_if(rrset.begin(), rrset.end(), \n                              [&g](const DNSRecord& dr) {\n                                return count(g.second.first.cbegin(), \n                                             g.second.first.cend(), dr);\n                              }), rrset.end());\n        // the DNSRecord== operator compares on name, type, class and lowercase content representation\n\n        for(const auto& x : g.second.second) {\n          rrset.push_back(x);\n        }\n\n        vector<DNSResourceRecord> replacement;\n        for(const auto& x : rrset) {\n          DNSResourceRecord dr(x);\n          dr.qname += domain;\n          dr.domain_id = di.id;\n          if(x.d_type == QType::SOA) {\n            //            cout<<\"New SOA: \"<<x.d_content->getZoneRepresentation()<<endl;\n            auto sr = getRR<SOARecordContent>(x);\n            zs.soa_serial=sr->d_st.serial;\n          }\n          \n          replacement.push_back(dr);\n        }\n\n        di.backend->replaceRRSet(di.id, g.first.first+domain, QType(g.first.second), replacement);\n      }\n      di.backend->commitTransaction();\n    }\n  }\n  catch(std::exception& p) {\n    L<<Logger::Error<<\"Got exception during IXFR: \"<<p.what()<<endl;\n    throw;\n  }\n  catch(PDNSException& p) {\n    L<<Logger::Error<<\"Got exception during IXFR: \"<<p.reason<<endl;\n    throw;\n  }  \n}",
  "abstract_func_before": "void CommunicatorClass::ixfrSuck(const DNSName &VAR_0, const TSIGTriplet& VAR_1, const ComboAddress& VAR_2, const ComboAddress& VAR_3, scoped_ptr<AuthLua>& VAR_4,\n                                 ZoneStatus& VAR_5, vector<DNSRecord>* VAR_6)\n{\n  UeberBackend VAR_7; /* COMMENT_0 */\n\n  DomainInfo VAR_8;\n  VAR_8.backend=0;\n  /* COMMENT_1 */\n  try {\n    DNSSECKeeper VAR_9 (&VAR_7); /* COMMENT_2 */\n\n    if(!VAR_7.getDomainInfo(VAR_0, VAR_8) || !VAR_8.backend) { /* COMMENT_3 */\n      VAR_10<<Logger::Error<<\"Can't determine backend for domain '\"<<VAR_0<<\"'\"<<VAR_11;\n      return;\n    }\n\n    soatimes VAR_12;\n    memset(&VAR_12, 0, sizeof(VAR_12));\n    VAR_12.serial=VAR_8.serial;\n\n    DNSRecord VAR_13;\n    VAR_13.d_content = std::VAR_14<SOARecordContent>(DNSName(\".\"), DNSName(\".\"), VAR_12);\n    auto VAR_15 = getIXFRDeltas(VAR_3, VAR_0, VAR_13, VAR_1, VAR_2.sin4.sin_family ? &VAR_2 : 0);\n    VAR_5.numDeltas=VAR_15.size();\n    /* COMMENT_4 */\n    \n    for(const auto& VAR_16 : VAR_15) {\n      const auto& VAR_17 = VAR_16.first;\n      const auto& VAR_18 = VAR_16.second;\n      /* COMMENT_5 */\n      \n      if(VAR_17.empty()) { /* COMMENT_6 */\n        *VAR_6 = VAR_18;\n        return;\n      }\n        \n\n      /* COMMENT_7 */\n      /* COMMENT_8 */\n      /* COMMENT_9 */\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      \n      \n      map<pair<DNSName,uint16_t>, pair<vector<DNSRecord>, vector<DNSRecord> > > VAR_19;\n      \n      for(const auto& VAR_20: VAR_17)\n        VAR_19[{VAR_20.d_name, VAR_20.d_type}].first.push_back(VAR_20);\n      for(const auto& VAR_20: VAR_18)\n        VAR_19[{VAR_20.d_name, VAR_20.d_type}].second.push_back(VAR_20);\n\n      VAR_8.backend->startTransaction(VAR_0, -1);\n      for(const auto VAR_21 : VAR_19) {\n        DNSResourceRecord VAR_22;\n        vector<DNSRecord> VAR_23;\n        VAR_7.lookup(QType(VAR_21.first.second), VAR_21.first.first, 0, VAR_8.id);\n        while(VAR_7.get(VAR_22)) {\n          VAR_23.push_back(DNSRecord{VAR_22});\n        }\n        /* COMMENT_12 */\n        VAR_23.erase(remove_if(VAR_23.begin(), VAR_23.end(), \n                              [&VAR_21](const DNSRecord& VAR_13) {\n                                return count(VAR_21.second.first.cbegin(), \n                                             VAR_21.second.first.cend(), VAR_13);\n                              }), VAR_23.end());\n        /* COMMENT_13 */\n\n        for(const auto& VAR_20 : VAR_21.second.second) {\n          VAR_23.push_back(VAR_20);\n        }\n\n        vector<DNSResourceRecord> VAR_24;\n        for(const auto& VAR_20 : VAR_23) {\n          DNSResourceRecord dr(x);\n          VAR_13.qname += VAR_0;\n          VAR_13.domain_id = VAR_8.id;\n          if(x.d_type == QType::SOA) {\n            /* COMMENT_14 */\n            auto VAR_25 = VAR_26<SOARecordContent>(x);\n            VAR_5.soa_serial=VAR_25->d_st.serial;\n          }\n          \n          VAR_24.push_back(VAR_13);\n        }\n\n        VAR_8.backend->replaceRRSet(VAR_8.id, VAR_21.first.first+VAR_0, QType(VAR_21.first.second), VAR_24);\n      }\n      VAR_8.backend->commitTransaction();\n    }\n  }\n  catch(std::exception& VAR_27) {\n    VAR_10<<Logger::Error<<\"Got exception during IXFR: \"<<VAR_27.what()<<VAR_11;\n    throw;\n  }\n  catch(PDNSException& VAR_27) {\n    VAR_10<<Logger::Error<<\"Got exception during IXFR: \"<<VAR_27.reason<<VAR_11;\n    throw;\n  }  \n}",
  "func_graph_path_before": "PowerDNS/pdns/db8f9152168acf5d548d4f256789eae783e01667/slavecommunicator.cc/vul/before/1.json",
  "func": "void CommunicatorClass::ixfrSuck(const DNSName &domain, const TSIGTriplet& tt, const ComboAddress& laddr, const ComboAddress& remote, scoped_ptr<AuthLua>& pdl,\n                                 ZoneStatus& zs, vector<DNSRecord>* axfr)\n{\n  UeberBackend B; // fresh UeberBackend\n\n  DomainInfo di;\n  di.backend=0;\n  //  bool transaction=false;\n  try {\n    DNSSECKeeper dk (&B); // reuse our UeberBackend copy for DNSSECKeeper\n\n    if(!B.getDomainInfo(domain, di) || !di.backend) { // di.backend and B are mostly identical\n      L<<Logger::Error<<\"Can't determine backend for domain '\"<<domain<<\"'\"<<endl;\n      return;\n    }\n\n    soatimes st;\n    memset(&st, 0, sizeof(st));\n    st.serial=di.serial;\n\n    DNSRecord dr;\n    dr.d_content = std::make_shared<SOARecordContent>(DNSName(\".\"), DNSName(\".\"), st);\n    auto deltas = getIXFRDeltas(remote, domain, dr, tt, laddr.sin4.sin_family ? &laddr : 0, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n    zs.numDeltas=deltas.size();\n    //    cout<<\"Got \"<<deltas.size()<<\" deltas from serial \"<<di.serial<<\", applying..\"<<endl;\n    \n    for(const auto& d : deltas) {\n      const auto& remove = d.first;\n      const auto& add = d.second;\n      //      cout<<\"Delta sizes: \"<<remove.size()<<\", \"<<add.size()<<endl;\n      \n      if(remove.empty()) { // we got passed an AXFR!\n        *axfr = add;\n        return;\n      }\n        \n\n      // our hammer is 'replaceRRSet(domain_id, qname, qt, vector<DNSResourceRecord>& rrset)\n      // which thinks in terms of RRSETs\n      // however, IXFR does not, and removes and adds *records* (bummer)\n      // this means that we must group updates by {qname,qtype}, retrieve the RRSET, apply\n      // the add/remove updates, and replaceRRSet the whole thing. \n      \n      \n      map<pair<DNSName,uint16_t>, pair<vector<DNSRecord>, vector<DNSRecord> > > grouped;\n      \n      for(const auto& x: remove)\n        grouped[{x.d_name, x.d_type}].first.push_back(x);\n      for(const auto& x: add)\n        grouped[{x.d_name, x.d_type}].second.push_back(x);\n\n      di.backend->startTransaction(domain, -1);\n      for(const auto g : grouped) {\n        DNSResourceRecord rr;\n        vector<DNSRecord> rrset;\n        B.lookup(QType(g.first.second), g.first.first, 0, di.id);\n        while(B.get(rr)) {\n          rrset.push_back(DNSRecord{rr});\n        }\n        // O(N^2)!\n        rrset.erase(remove_if(rrset.begin(), rrset.end(), \n                              [&g](const DNSRecord& dr) {\n                                return count(g.second.first.cbegin(), \n                                             g.second.first.cend(), dr);\n                              }), rrset.end());\n        // the DNSRecord== operator compares on name, type, class and lowercase content representation\n\n        for(const auto& x : g.second.second) {\n          rrset.push_back(x);\n        }\n\n        vector<DNSResourceRecord> replacement;\n        for(const auto& x : rrset) {\n          DNSResourceRecord dr(x);\n          dr.qname += domain;\n          dr.domain_id = di.id;\n          if(x.d_type == QType::SOA) {\n            //            cout<<\"New SOA: \"<<x.d_content->getZoneRepresentation()<<endl;\n            auto sr = getRR<SOARecordContent>(x);\n            zs.soa_serial=sr->d_st.serial;\n          }\n          \n          replacement.push_back(dr);\n        }\n\n        di.backend->replaceRRSet(di.id, g.first.first+domain, QType(g.first.second), replacement);\n      }\n      di.backend->commitTransaction();\n    }\n  }\n  catch(std::exception& p) {\n    L<<Logger::Error<<\"Got exception during IXFR: \"<<p.what()<<endl;\n    throw;\n  }\n  catch(PDNSException& p) {\n    L<<Logger::Error<<\"Got exception during IXFR: \"<<p.reason<<endl;\n    throw;\n  }  \n}",
  "abstract_func": "void CommunicatorClass::ixfrSuck(const DNSName &VAR_0, const TSIGTriplet& VAR_1, const ComboAddress& VAR_2, const ComboAddress& VAR_3, scoped_ptr<AuthLua>& VAR_4,\n                                 ZoneStatus& VAR_5, vector<DNSRecord>* VAR_6)\n{\n  UeberBackend VAR_7; /* COMMENT_0 */\n\n  DomainInfo VAR_8;\n  VAR_8.backend=0;\n  /* COMMENT_1 */\n  try {\n    DNSSECKeeper VAR_9 (&VAR_7); /* COMMENT_2 */\n\n    if(!VAR_7.getDomainInfo(VAR_0, VAR_8) || !VAR_8.backend) { /* COMMENT_3 */\n      VAR_10<<Logger::Error<<\"Can't determine backend for domain '\"<<VAR_0<<\"'\"<<VAR_11;\n      return;\n    }\n\n    soatimes VAR_12;\n    memset(&VAR_12, 0, sizeof(VAR_12));\n    VAR_12.serial=VAR_8.serial;\n\n    DNSRecord VAR_13;\n    VAR_13.d_content = std::VAR_14<SOARecordContent>(DNSName(\".\"), DNSName(\".\"), VAR_12);\n    auto VAR_15 = getIXFRDeltas(VAR_3, VAR_0, VAR_13, VAR_1, VAR_2.sin4.sin_family ? &VAR_2 : 0, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n    VAR_5.numDeltas=VAR_15.size();\n    /* COMMENT_4 */\n    \n    for(const auto& VAR_16 : VAR_15) {\n      const auto& VAR_17 = VAR_16.first;\n      const auto& VAR_18 = VAR_16.second;\n      /* COMMENT_5 */\n      \n      if(VAR_17.empty()) { /* COMMENT_6 */\n        *VAR_6 = VAR_18;\n        return;\n      }\n        \n\n      /* COMMENT_7 */\n      /* COMMENT_8 */\n      /* COMMENT_9 */\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      \n      \n      map<pair<DNSName,uint16_t>, pair<vector<DNSRecord>, vector<DNSRecord> > > VAR_19;\n      \n      for(const auto& VAR_20: VAR_17)\n        VAR_19[{VAR_20.d_name, VAR_20.d_type}].first.push_back(VAR_20);\n      for(const auto& VAR_20: VAR_18)\n        VAR_19[{VAR_20.d_name, VAR_20.d_type}].second.push_back(VAR_20);\n\n      VAR_8.backend->startTransaction(VAR_0, -1);\n      for(const auto VAR_21 : VAR_19) {\n        DNSResourceRecord VAR_22;\n        vector<DNSRecord> VAR_23;\n        VAR_7.lookup(QType(VAR_21.first.second), VAR_21.first.first, 0, VAR_8.id);\n        while(VAR_7.get(VAR_22)) {\n          VAR_23.push_back(DNSRecord{VAR_22});\n        }\n        /* COMMENT_12 */\n        VAR_23.erase(remove_if(VAR_23.begin(), VAR_23.end(), \n                              [&VAR_21](const DNSRecord& VAR_13) {\n                                return count(VAR_21.second.first.cbegin(), \n                                             VAR_21.second.first.cend(), VAR_13);\n                              }), VAR_23.end());\n        /* COMMENT_13 */\n\n        for(const auto& VAR_20 : VAR_21.second.second) {\n          VAR_23.push_back(VAR_20);\n        }\n\n        vector<DNSResourceRecord> VAR_24;\n        for(const auto& VAR_20 : VAR_23) {\n          DNSResourceRecord dr(x);\n          VAR_13.qname += VAR_0;\n          VAR_13.domain_id = VAR_8.id;\n          if(x.d_type == QType::SOA) {\n            /* COMMENT_14 */\n            auto VAR_25 = VAR_26<SOARecordContent>(x);\n            VAR_5.soa_serial=VAR_25->d_st.serial;\n          }\n          \n          VAR_24.push_back(VAR_13);\n        }\n\n        VAR_8.backend->replaceRRSet(VAR_8.id, VAR_21.first.first+VAR_0, QType(VAR_21.first.second), VAR_24);\n      }\n      VAR_8.backend->commitTransaction();\n    }\n  }\n  catch(std::exception& VAR_27) {\n    VAR_10<<Logger::Error<<\"Got exception during IXFR: \"<<VAR_27.what()<<VAR_11;\n    throw;\n  }\n  catch(PDNSException& VAR_27) {\n    VAR_10<<Logger::Error<<\"Got exception during IXFR: \"<<VAR_27.reason<<VAR_11;\n    throw;\n  }  \n}",
  "func_graph_path": "PowerDNS/pdns/db8f9152168acf5d548d4f256789eae783e01667/slavecommunicator.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n \n     DNSRecord dr;\n     dr.d_content = std::make_shared<SOARecordContent>(DNSName(\".\"), DNSName(\".\"), st);\n-    auto deltas = getIXFRDeltas(remote, domain, dr, tt, laddr.sin4.sin_family ? &laddr : 0);\n+    auto deltas = getIXFRDeltas(remote, domain, dr, tt, laddr.sin4.sin_family ? &laddr : 0, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n     zs.numDeltas=deltas.size();\n     //    cout<<\"Got \"<<deltas.size()<<\" deltas from serial \"<<di.serial<<\", applying..\"<<endl;\n     ",
  "diff_line_info": {
    "deleted_lines": [
      "    auto deltas = getIXFRDeltas(remote, domain, dr, tt, laddr.sin4.sin_family ? &laddr : 0);"
    ],
    "added_lines": [
      "    auto deltas = getIXFRDeltas(remote, domain, dr, tt, laddr.sin4.sin_family ? &laddr : 0, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PowerDNS/pdns/pull/4133",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/PowerDNS/pdns/pull/4133: 403 Client Error: Forbidden for url: https://api.github.com/repos/PowerDNS/pdns/pulls/4133",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The commit addresses a potential security issue by adding a size limit to prevent memory exhaustion, which is a security risk. The code change implements this limit, confirming it's a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}