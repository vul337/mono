{
  "cve_id": "CVE-2016-6132",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgd",
  "commit_msg": "Fix #247, A read out-of-bands was found in the parsing of TGA files (CVE-2016-6132)",
  "commit_hash": "ead349e99868303b37f5e6e9d9d680c9dc71ff8d",
  "git_url": "https://github.com/libgd/libgd/commit/ead349e99868303b37f5e6e9d9d680c9dc71ff8d",
  "file_path": "src/gd_tga.c",
  "func_name": "read_image_tga",
  "func_before": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tuint8_t* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint j = 0;\n\tuint8_t encoded_pixels;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(conversion_buffer, image_block_size, ctx);\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf( conversion_buffer, image_block_size, ctx );\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < image_block_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tfor (j = 0; j < pixel_block_size; j++, bitmap_caret++) {\n\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tfor( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {\n\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t}\n\t\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}",
  "abstract_func_before": "int read_image_tga( gdIOCtx *VAR_0, oTga *VAR_1 )\n{\n\tint VAR_2 = (VAR_1->bits / 8);\n\tint VAR_3 = (VAR_1->width * VAR_1->height) * VAR_2;\n\tuint8_t* VAR_4 = NULL;\n\tunsigned char* VAR_5 = NULL;\n\tint VAR_6 = 0;\n\tint VAR_7 = 0;\n\tint VAR_8 = 0;\n\tint VAR_9 = 0;\n\tuint8_t VAR_10;\n\n\tif(overflow2(VAR_1->width, VAR_1->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(VAR_1->width * VAR_1->height, VAR_2)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(VAR_3, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/* COMMENT_0 */\n    \n\tif (VAR_1->imagetype != VAR_11 && VAR_1->imagetype != VAR_12)\n\t\treturn -1;\n\n\t/* COMMENT_2 */\n                                                                      \n    \n\tVAR_1->bitmap = (int *) gdMalloc(VAR_3 * sizeof(int));\n\tif (VAR_1->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (VAR_1->imagetype) {\n\tcase VAR_11:\n\t\t/* COMMENT_5 */\n                                                                  \n     \n\t\tVAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));\n\t\tif (VAR_5 == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(VAR_5, VAR_3, VAR_0);\n\n\t\twhile (VAR_6 < VAR_3) {\n\t\t\tVAR_1->bitmap[VAR_6] = (int) VAR_5[VAR_6];\n\t\t\tVAR_6++;\n\t\t}\n\n\t\tgdFree(VAR_5);\n\t\tbreak;\n\n\tcase VAR_12:\n\t\t/* COMMENT_8 */\n                                                                    \n     \n\t\tVAR_4 = (uint8_t*) gdMalloc(VAR_3 * sizeof(uint8_t));\n\t\tif (VAR_4 == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tVAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));\n\t\tif (VAR_5 == NULL) {\n\t\t\tgdFree( VAR_4 );\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf( VAR_5, VAR_3, VAR_0 );\n\n\t\tVAR_6 = 0;\n\n\t\twhile( VAR_6 < VAR_3) {\n\t\t\tVAR_4[VAR_6] = (int)VAR_5[VAR_6];\n\t\t\tVAR_6++;\n\t\t}\n\n\t\tVAR_6 = 0;\n\n\t\twhile( VAR_7 < VAR_3 ) {\n\n\t\t\tif ((VAR_4[VAR_6] & VAR_13) == VAR_13) {\n\t\t\t\tVAR_10 = ( ( VAR_4[ VAR_6 ] & 127 ) + 1 );\n\t\t\t\tVAR_6++;\n\n\t\t\t\tfor (VAR_8 = 0; VAR_8 < VAR_10; VAR_8++) {\n\t\t\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_2; VAR_9++, VAR_7++) {\n\t\t\t\t\t\tVAR_1->bitmap[ VAR_7 ] = VAR_4[ VAR_6 + VAR_9 ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_6 += VAR_2;\n\t\t\t} else {\n\t\t\t\tVAR_10 = VAR_4[ VAR_6 ] + 1;\n\t\t\t\tVAR_6++;\n\n\t\t\t\tfor (VAR_8 = 0; VAR_8 < VAR_10; VAR_8++) {\n\t\t\t\t\tfor( VAR_9 = 0; VAR_9 < VAR_2; VAR_9++, VAR_7++ ) {\n\t\t\t\t\t\tVAR_1->bitmap[ VAR_7 ] = VAR_4[ VAR_6 + VAR_9 ];\n\t\t\t\t\t}\n\t\t\t\t\tVAR_6 += VAR_2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgdFree( VAR_4 );\n\t\tgdFree( VAR_5 );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}",
  "func_graph_path_before": "libgd/ead349e99868303b37f5e6e9d9d680c9dc71ff8d/gd_tga.c/vul/before/0.json",
  "func": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tuint8_t* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint j = 0;\n\tuint8_t encoded_pixels;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < image_block_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tfor (j = 0; j < pixel_block_size; j++, bitmap_caret++) {\n\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tfor( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {\n\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t}\n\t\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}",
  "abstract_func": "int read_image_tga( gdIOCtx *VAR_0, oTga *VAR_1 )\n{\n\tint VAR_2 = (VAR_1->bits / 8);\n\tint VAR_3 = (VAR_1->width * VAR_1->height) * VAR_2;\n\tuint8_t* VAR_4 = NULL;\n\tunsigned char* VAR_5 = NULL;\n\tint VAR_6 = 0;\n\tint VAR_7 = 0;\n\tint VAR_8 = 0;\n\tint VAR_9 = 0;\n\tuint8_t VAR_10;\n\n\tif(overflow2(VAR_1->width, VAR_1->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(VAR_1->width * VAR_1->height, VAR_2)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(VAR_3, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/* COMMENT_0 */\n    \n\tif (VAR_1->imagetype != VAR_11 && VAR_1->imagetype != VAR_12)\n\t\treturn -1;\n\n\t/* COMMENT_2 */\n                                                                      \n    \n\tVAR_1->bitmap = (int *) gdMalloc(VAR_3 * sizeof(int));\n\tif (VAR_1->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (VAR_1->imagetype) {\n\tcase VAR_11:\n\t\t/* COMMENT_5 */\n                                                                  \n     \n\t\tVAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));\n\t\tif (VAR_5 == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(VAR_5, VAR_3, VAR_0) != VAR_3) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(VAR_5);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (VAR_6 < VAR_3) {\n\t\t\tVAR_1->bitmap[VAR_6] = (int) VAR_5[VAR_6];\n\t\t\tVAR_6++;\n\t\t}\n\n\t\tgdFree(VAR_5);\n\t\tbreak;\n\n\tcase VAR_12:\n\t\t/* COMMENT_8 */\n                                                                    \n     \n\t\tVAR_4 = (uint8_t*) gdMalloc(VAR_3 * sizeof(uint8_t));\n\t\tif (VAR_4 == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tVAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));\n\t\tif (VAR_5 == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( VAR_4 );\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(VAR_5, VAR_3, VAR_0) != VAR_3) {\n\t\t\tgdFree(VAR_5);\n\t\t\tgdFree(VAR_4);\n\t\t\treturn -1;\n\t\t}\n\n\t\tVAR_6 = 0;\n\n\t\twhile( VAR_6 < VAR_3) {\n\t\t\tVAR_4[VAR_6] = (int)VAR_5[VAR_6];\n\t\t\tVAR_6++;\n\t\t}\n\n\t\tVAR_6 = 0;\n\n\t\twhile( VAR_7 < VAR_3 ) {\n\n\t\t\tif ((VAR_4[VAR_6] & VAR_13) == VAR_13) {\n\t\t\t\tVAR_10 = ( ( VAR_4[ VAR_6 ] & 127 ) + 1 );\n\t\t\t\tVAR_6++;\n\n\t\t\t\tfor (VAR_8 = 0; VAR_8 < VAR_10; VAR_8++) {\n\t\t\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_2; VAR_9++, VAR_7++) {\n\t\t\t\t\t\tVAR_1->bitmap[ VAR_7 ] = VAR_4[ VAR_6 + VAR_9 ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_6 += VAR_2;\n\t\t\t} else {\n\t\t\t\tVAR_10 = VAR_4[ VAR_6 ] + 1;\n\t\t\t\tVAR_6++;\n\n\t\t\t\tfor (VAR_8 = 0; VAR_8 < VAR_10; VAR_8++) {\n\t\t\t\t\tfor( VAR_9 = 0; VAR_9 < VAR_2; VAR_9++, VAR_7++ ) {\n\t\t\t\t\t\tVAR_1->bitmap[ VAR_7 ] = VAR_4[ VAR_6 + VAR_9 ];\n\t\t\t\t\t}\n\t\t\t\t\tVAR_6 += VAR_2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgdFree( VAR_4 );\n\t\tgdFree( VAR_5 );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}",
  "func_graph_path": "libgd/ead349e99868303b37f5e6e9d9d680c9dc71ff8d/gd_tga.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -44,7 +44,11 @@\n \t\t\treturn -1;\n \t\t}\n \n-\t\tgdGetBuf(conversion_buffer, image_block_size, ctx);\n+\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n+\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n+\t\t\tgdFree(conversion_buffer);\n+\t\t\treturn -1;\n+\t\t}\n \n \t\twhile (buffer_caret < image_block_size) {\n \t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n@@ -64,11 +68,16 @@\n \t\t}\n \t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n \t\tif (conversion_buffer == NULL) {\n+\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n \t\t\tgdFree( decompression_buffer );\n \t\t\treturn -1;\n \t\t}\n \n-\t\tgdGetBuf( conversion_buffer, image_block_size, ctx );\n+\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n+\t\t\tgdFree(conversion_buffer);\n+\t\t\tgdFree(decompression_buffer);\n+\t\t\treturn -1;\n+\t\t}\n \n \t\tbuffer_caret = 0;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tgdGetBuf(conversion_buffer, image_block_size, ctx);",
      "\t\tgdGetBuf( conversion_buffer, image_block_size, ctx );"
    ],
    "added_lines": [
      "\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {",
      "\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");",
      "\t\t\tgdFree(conversion_buffer);",
      "\t\t\treturn -1;",
      "\t\t}",
      "\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");",
      "\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {",
      "\t\t\tgdFree(conversion_buffer);",
      "\t\t\tgdFree(decompression_buffer);",
      "\t\t\treturn -1;",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgd/libgd/pull/250",
  "description": {
    "pr_info": {
      "title": "Fix 247",
      "number": 250
    },
    "comment": [
      "Fixes #247 \n\nBefore:\n\n```\n$ ./tga/bug00247 \n=================================================================\n==128235==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62500000e91c at pc 0x7fcfa43dd2d6 bp 0x7ffd36a97a90 sp 0x7ffd36a97a88\nREAD of size 4 at 0x62500000e91c thread T0\n    #0 0x7fcfa43dd2d5 in gdImageCreateFromTgaCtx /home/ondrej/Projects/pkg-libgd/gd-libgd/src/gd_tga.c:103:5\n    #1 0x7fcfa43dbcaf in gdImageCreateFromTga /home/ondrej/Projects/pkg-libgd/gd-libgd/src/gd_tga.c:25:10\n    #2 0x4bd889 in main /home/ondrej/Projects/pkg-libgd/gd-libgd/tests/tga/bug00247.c:10:10\n    #3 0x7fcfa1d96b44 in __libc_start_main /build/glibc-uPj9cH/glibc-2.19/csu/libc-start.c:287\n    #4 0x4bd57c in _start (/home/ondrej/Projects/pkg-libgd/gd-libgd/tests/tga/.libs/lt-bug00247+0x4bd57c)\n\n0x62500000e91c is located 0 bytes to the right of 8220-byte region [0x62500000c900,0x62500000e91c)\nallocated by thread T0 here:\n    #0 0x49fefb in malloc (/home/ondrej/Projects/pkg-libgd/gd-libgd/tests/tga/.libs/lt-bug00247+0x49fefb)\n    #1 0x7fcfa44573c8 in gdMalloc /home/ondrej/Projects/pkg-libgd/gd-libgd/src/gdhelpers.c:75:9\n    #2 0x7fcfa43e0aca in read_image_tga /home/ondrej/Projects/pkg-libgd/gd-libgd/src/gd_tga.c:226:24\n    #3 0x7fcfa43dc42c in gdImageCreateFromTgaCtx /home/ondrej/Projects/pkg-libgd/gd-libgd/src/gd_tga.c:74:6\n    #4 0x7fcfa43dbcaf in gdImageCreateFromTga /home/ondrej/Projects/pkg-libgd/gd-libgd/src/gd_tga.c:25:10\n    #5 0x4bd889 in main /home/ondrej/Projects/pkg-libgd/gd-libgd/tests/tga/bug00247.c:10:10\n    #6 0x7fcfa1d96b44 in __libc_start_main /build/glibc-uPj9cH/glibc-2.19/csu/libc-start.c:287\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /home/ondrej/Projects/pkg-libgd/gd-libgd/src/gd_tga.c:103 gdImageCreateFromTgaCtx\nShadow bytes around the buggy address:\n  0x0c4a7fff9cd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c4a7fff9ce0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c4a7fff9cf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c4a7fff9d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c4a7fff9d10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c4a7fff9d20: 00 00 00[04]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c4a7fff9d30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c4a7fff9d40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c4a7fff9d50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c4a7fff9d60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c4a7fff9d70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Heap right redzone:      fb\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack partial redzone:   f4\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  ASan internal:           fe\n==128235==ABORTING\nAborted (core dumped)\n```\n\nAfter:\n\n```\n$ ./tga/bug00247 \n```\n",
      "@oerdnj I had already send a very similar patch to Pierre, Remi and Mike via email. I've added a few notes to the code, where I think this PR could be improved. :)\n",
      "@cmb69 Thanks, merged your changes.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}