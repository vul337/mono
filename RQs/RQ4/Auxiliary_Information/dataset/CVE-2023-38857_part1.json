{
  "cve_id": "CVE-2023-38857",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "knik0/faad2",
  "commit_msg": "Fix #171 (#175)\n\n(slicen + 1) should not run after the array boundary;\r\nto avoid possible overflow, we now check in 2 steps,\r\nchained with short-circuit-and.",
  "commit_hash": "b02a9ee5bf071fa92563536c076a69dbec814e7e",
  "git_url": "https://github.com/knik0/faad2/commit/b02a9ee5bf071fa92563536c076a69dbec814e7e",
  "file_path": "frontend/mp4read.c",
  "func_name": "stcoin",
  "func_before": "static int stcoin(int size)\n{\n    uint32_t numchunks, chunkn, slicen, samplesleft, i, offset;\n    uint32_t nextoffset;\n\n    if (size < 8)\n        return ERR_FAIL;\n\n    // version/flags\n    u32in();\n\n    // Number of entries\n    numchunks = u32in();\n    if ((numchunks < 1) || ((numchunks + 1) == 0))\n        return ERR_FAIL;\n\n    if ((size - 8u) / 4u < numchunks)\n        return ERR_FAIL;\n\n    chunkn = 0;\n    samplesleft = 0;\n    slicen = 0;\n    offset = 0;\n\n    for (i = 0; i < mp4config.frame.nsamples; ++i) {\n        if (samplesleft == 0)\n        {\n            chunkn++;\n            if (chunkn > numchunks)\n                return ERR_FAIL;\n            if (slicen < mp4config.frame.nsclices)\n            {\n                if (chunkn == mp4config.frame.map[slicen + 1].firstchunk)\n                    slicen++;\n            }\n            samplesleft = mp4config.frame.map[slicen].samplesperchunk;\n            offset = u32in();\n        }\n        mp4config.frame.info[i].offset = offset;\n        nextoffset = offset + mp4config.frame.info[i].len;\n        if (nextoffset < offset)\n            return ERR_FAIL;\n        offset = nextoffset;\n        samplesleft--;\n    }\n\n    freeMem(&mp4config.frame.map);\n\n    return size;\n}",
  "abstract_func_before": "static int stcoin(int VAR_0)\n{\n    uint32_t VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6;\n    uint32_t VAR_7;\n\n    if (VAR_0 < 8)\n        return VAR_8;\n\n    /* COMMENT_0 */\n    u32in();\n\n    /* COMMENT_1 */\n    VAR_1 = u32in();\n    if ((VAR_1 < 1) || ((VAR_1 + 1) == 0))\n        return VAR_8;\n\n    if ((VAR_0 - 8u) / 4u < VAR_1)\n        return VAR_8;\n\n    VAR_2 = 0;\n    VAR_4 = 0;\n    VAR_3 = 0;\n    VAR_6 = 0;\n\n    for (VAR_5 = 0; VAR_5 < VAR_9.frame.nsamples; ++VAR_5) {\n        if (VAR_4 == 0)\n        {\n            VAR_2++;\n            if (VAR_2 > VAR_1)\n                return VAR_8;\n            if (VAR_3 < VAR_9.frame.nsclices)\n            {\n                if (VAR_2 == VAR_9.frame.map[VAR_3 + 1].firstchunk)\n                    VAR_3++;\n            }\n            VAR_4 = VAR_9.frame.map[VAR_3].samplesperchunk;\n            VAR_6 = u32in();\n        }\n        VAR_9.frame.info[VAR_5].offset = VAR_6;\n        VAR_7 = VAR_6 + VAR_9.frame.info[VAR_5].len;\n        if (VAR_7 < VAR_6)\n            return VAR_8;\n        VAR_6 = VAR_7;\n        VAR_4--;\n    }\n\n    freeMem(&VAR_9.frame.map);\n\n    return VAR_0;\n}",
  "func_graph_path_before": "knik0/faad2/b02a9ee5bf071fa92563536c076a69dbec814e7e/mp4read.c/vul/before/0.json",
  "func": "static int stcoin(int size)\n{\n    uint32_t numchunks, chunkn, slicen, samplesleft, i, offset;\n    uint32_t nextoffset;\n\n    if (size < 8)\n        return ERR_FAIL;\n\n    // version/flags\n    u32in();\n\n    // Number of entries\n    numchunks = u32in();\n    if ((numchunks < 1) || ((numchunks + 1) == 0))\n        return ERR_FAIL;\n\n    if ((size - 8u) / 4u < numchunks)\n        return ERR_FAIL;\n\n    chunkn = 0;\n    samplesleft = 0;\n    slicen = 0;\n    offset = 0;\n\n    for (i = 0; i < mp4config.frame.nsamples; ++i) {\n        if (samplesleft == 0)\n        {\n            chunkn++;\n            if (chunkn > numchunks)\n                return ERR_FAIL;\n            if (slicen < mp4config.frame.nsclices &&\n                (slicen + 1) < mp4config.frame.nsclices) {\n                if (chunkn == mp4config.frame.map[slicen + 1].firstchunk)\n                    slicen++;\n            }\n            samplesleft = mp4config.frame.map[slicen].samplesperchunk;\n            offset = u32in();\n        }\n        mp4config.frame.info[i].offset = offset;\n        nextoffset = offset + mp4config.frame.info[i].len;\n        if (nextoffset < offset)\n            return ERR_FAIL;\n        offset = nextoffset;\n        samplesleft--;\n    }\n\n    freeMem(&mp4config.frame.map);\n\n    return size;\n}",
  "abstract_func": "static int stcoin(int VAR_0)\n{\n    uint32_t VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6;\n    uint32_t VAR_7;\n\n    if (VAR_0 < 8)\n        return VAR_8;\n\n    /* COMMENT_0 */\n    u32in();\n\n    /* COMMENT_1 */\n    VAR_1 = u32in();\n    if ((VAR_1 < 1) || ((VAR_1 + 1) == 0))\n        return VAR_8;\n\n    if ((VAR_0 - 8u) / 4u < VAR_1)\n        return VAR_8;\n\n    VAR_2 = 0;\n    VAR_4 = 0;\n    VAR_3 = 0;\n    VAR_6 = 0;\n\n    for (VAR_5 = 0; VAR_5 < VAR_9.frame.nsamples; ++VAR_5) {\n        if (VAR_4 == 0)\n        {\n            VAR_2++;\n            if (VAR_2 > VAR_1)\n                return VAR_8;\n            if (VAR_3 < VAR_9.frame.nsclices &&\n                (VAR_3 + 1) < VAR_9.frame.nsclices) {\n                if (VAR_2 == VAR_9.frame.map[VAR_3 + 1].firstchunk)\n                    VAR_3++;\n            }\n            VAR_4 = VAR_9.frame.map[VAR_3].samplesperchunk;\n            VAR_6 = u32in();\n        }\n        VAR_9.frame.info[VAR_5].offset = VAR_6;\n        VAR_7 = VAR_6 + VAR_9.frame.info[VAR_5].len;\n        if (VAR_7 < VAR_6)\n            return VAR_8;\n        VAR_6 = VAR_7;\n        VAR_4--;\n    }\n\n    freeMem(&VAR_9.frame.map);\n\n    return VAR_0;\n}",
  "func_graph_path": "knik0/faad2/b02a9ee5bf071fa92563536c076a69dbec814e7e/mp4read.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,8 +28,8 @@\n             chunkn++;\n             if (chunkn > numchunks)\n                 return ERR_FAIL;\n-            if (slicen < mp4config.frame.nsclices)\n-            {\n+            if (slicen < mp4config.frame.nsclices &&\n+                (slicen + 1) < mp4config.frame.nsclices) {\n                 if (chunkn == mp4config.frame.map[slicen + 1].firstchunk)\n                     slicen++;\n             }",
  "diff_line_info": {
    "deleted_lines": [
      "            if (slicen < mp4config.frame.nsclices)",
      "            {"
    ],
    "added_lines": [
      "            if (slicen < mp4config.frame.nsclices &&",
      "                (slicen + 1) < mp4config.frame.nsclices) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/175",
  "description": {
    "pr_info": {
      "title": "Fix #171",
      "number": 175
    },
    "comment": [
      "(slicen + 1) should not run after the array boundary; to avoid possible overflow, we now check in 2 steps, chained with short-circuit-and."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch modifies array boundary checks to prevent overflow, addressing a security concern by fixing a potential exploit. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}