{
  "cve_id": "CVE-2023-33974",
  "cwe_ids": [
    "CWE-362"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition",
  "commit_hash": "31c6191f6196f1a05c9765cffeadba868e3b0723",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723",
  "file_path": "sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c",
  "func_name": "gnrc_sixlowpan_frag_sfr_arq_timeout",
  "func_before": "void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    uint32_t now = xtimer_now_usec() / US_PER_MS;\n    _frag_desc_t *frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;\n    uint32_t next_arq_offset = fbuf->sfr.arq_timeout;\n    bool reschedule_arq_timeout = false;\n    int error_no = ETIMEDOUT;   /* assume time out for fbuf->pkt */\n\n    DEBUG(\"6lo sfr: ARQ timeout for datagram %u\\n\", fbuf->tag);\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        /* mock-up to emulate time having passed beyond (1us) the ARQ timeout */\n        now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;\n    }\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) && frag_desc) {\n        /* report timeout to CongURE state */\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(fbuf);\n        _shrink_window(fbuf);   /* potentially shrink window */\n        /* reassign frag_desc, in case window head changed */\n        frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;\n    }\n    /* copying clist_foreach because we can't work just in function context */\n    _frag_desc_t * const head = frag_desc;\n    if (frag_desc) {\n        do {\n            uint32_t diff;\n\n            frag_desc = (_frag_desc_t *)frag_desc->super.super.next;\n            diff = now - frag_desc->super.send_time;\n            if (diff < fbuf->sfr.arq_timeout) {\n                /* this fragment's last was last sent < fbuf->sfr.arq_timeout\n                 * ago */\n                uint32_t offset = fbuf->sfr.arq_timeout - diff;\n\n                DEBUG(\"6lo sfr: wait for fragment %u in next reschedule\\n\",\n                      _frag_seq(frag_desc));\n                if (offset < next_arq_offset) {\n                    /* wait for this fragments ACK next */\n                    next_arq_offset = offset;\n                    DEBUG(\"         (next ARQ timeout in %lu)\\n\",\n                          (long unsigned)next_arq_offset);\n                }\n                /* this fragment is still waiting for its ACK,\n                 * reschedule the next ACK timeout to the difference\n                 * of the ACK timeout and the time of its last send */\n                reschedule_arq_timeout = true;\n            }\n            else if (_frag_ack_req(frag_desc)) {\n                /* for this fragment we requested an ACK which was not received\n                 * yet. Try to resend it */\n                if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {\n                    /* we have retries left for this fragment */\n                    DEBUG(\"6lo sfr: %u retries left for fragment (tag: %u, \"\n                          \"X: %i, seq: %u, frag_size: %u, offset: %u)\\n\",\n                          CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -\n                          (frag_desc->super.resends - 1), (uint8_t)fbuf->tag,\n                          _frag_ack_req(frag_desc), _frag_seq(frag_desc),\n                          _frag_size(frag_desc), frag_desc->offset);\n                    if (_resend_frag(&frag_desc->super.super, fbuf) != 0) {\n                        /* _resend_frag failed due to a memory resource\n                         * problem */\n                        error_no = ENOMEM;\n                        goto error;\n                    }\n                    else {\n                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {\n                            /* fragment was resent successfully, report this to CongURE state\n                             * object */\n                            gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);\n                        }\n                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                            /* fragment was resent successfully, note this done\n                             * in the statistics */\n                            _stats.fragment_resends.by_timeout++;\n                        }\n                    }\n                    /* fragment was resent successfully, schedule next ACK\n                     * timeout */\n                    reschedule_arq_timeout = true;\n                }\n                else {\n                    /* out of retries */\n                    DEBUG(\"6lo sfr: no retries left for fragment \"\n                          \"(tag: %u, X: %i, seq: %u, frag_size: %u, \"\n                          \"offset: %u)\\n\",\n                          (uint8_t)fbuf->tag, _frag_ack_req(frag_desc),\n                          _frag_seq(frag_desc), _frag_size(frag_desc),\n                          frag_desc->offset);\n                    /* we are out of retries on the fragment level, but we\n                     * might be able to retry the datagram if retries for the\n                     * datagram are configured. */\n                    _retry_datagram(fbuf);\n                    return;\n                }\n            }\n            else {\n                /* Do not resend fragments that were not explicitly asking for\n                 * an ACK from the reassembling endpoint on ACK timeout.\n                 * If this is true for all fragments remaining in the fragment\n                 * buffer, the datagram is to be considered timed out, so\n                 * error_no should remain ETIMEDOUT */\n                DEBUG(\"6lo sfr: nothing to do for fragment %u\\n\",\n                      _frag_seq(frag_desc));\n            }\n        } while (frag_desc != head);\n        /* report all non-ack_req fragments in window also as sent, since even\n         * the lost fragments are still in flight (even though they were\n         * previously marked as timed out) */\n        clist_foreach(&fbuf->sfr.window, _report_non_ack_req_window_sent, fbuf);\n    }\n    else {\n        /* No fragments to resend, we can assume the packet was delivered\n         * successfully */\n        error_no = GNRC_NETERR_SUCCESS;\n    }\n    assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));\n    if (reschedule_arq_timeout) {\n        _sched_arq_timeout(fbuf, next_arq_offset);\n        return;\n    }\nerror:\n    /* don't check return value, as we don't want to wait for an ACK again ;-) */\n    _send_abort_frag(fbuf->pkt, fbuf, false, 0);\n    _clean_up_fbuf(fbuf, error_no);\n}",
  "abstract_func_before": "void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *VAR_0)\n{\n    uint32_t VAR_1 = xtimer_now_usec() / VAR_2;\n    _frag_desc_t *VAR_3 = (_frag_desc_t *)VAR_0->sfr.window.next;\n    uint32_t VAR_4 = VAR_0->sfr.arq_timeout;\n    bool VAR_5 = false;\n    int VAR_6 = VAR_7;   /* COMMENT_0 */\n\n    DEBUG(\"6lo sfr: ARQ timeout for datagram %u\\n\", VAR_0->tag);\n    VAR_0->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    if (IS_ACTIVE(VAR_8)) {\n        /* COMMENT_1 */\n        VAR_1 -= (VAR_0->sfr.arq_timeout * VAR_2) + 1;\n    }\n    if (IS_USED(VAR_9) && VAR_3) {\n        /* COMMENT_2 */\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(VAR_0);\n        _shrink_window(VAR_0);   /* COMMENT_3 */\n        /* COMMENT_4 */\n        VAR_3 = (_frag_desc_t *)VAR_0->sfr.window.next;\n    }\n    /* COMMENT_5 */\n    _frag_desc_t * const VAR_10 = VAR_3;\n    if (VAR_3) {\n        do {\n            uint32_t VAR_11;\n\n            VAR_3 = (_frag_desc_t *)VAR_3->super.super.next;\n            VAR_11 = VAR_1 - VAR_3->super.send_time;\n            if (VAR_11 < VAR_0->sfr.arq_timeout) {\n                /* COMMENT_6 */\n                         \n                uint32_t VAR_12 = VAR_0->sfr.arq_timeout - VAR_11;\n\n                DEBUG(\"6lo sfr: wait for fragment %u in next reschedule\\n\",\n                      _frag_seq(VAR_3));\n                if (VAR_12 < VAR_4) {\n                    /* COMMENT_8 */\n                    VAR_4 = VAR_12;\n                    DEBUG(\"         (next ARQ timeout in %lu)\\n\",\n                          (long unsigned)VAR_4);\n                }\n                /* COMMENT_9 */\n                                                                    \n                                                                      \n                VAR_5 = true;\n            }\n            else if (_frag_ack_req(VAR_3)) {\n                /* COMMENT_12 */\n                                           \n                if ((VAR_3->super.resends++) < VAR_13) {\n                    /* COMMENT_14 */\n                    DEBUG(\"6lo sfr: %u retries left for fragment (tag: %u, \"\n                          \"X: %i, seq: %u, frag_size: %u, offset: %u)\\n\",\n                          VAR_13 -\n                          (VAR_3->super.resends - 1), (uint8_t)VAR_0->tag,\n                          _frag_ack_req(VAR_3), _frag_seq(VAR_3),\n                          _frag_size(VAR_3), VAR_3->offset);\n                    if (_resend_frag(&VAR_3->super.super, VAR_0) != 0) {\n                        /* COMMENT_15 */\n                                     \n                        VAR_6 = VAR_14;\n                        goto error;\n                    }\n                    else {\n                        if (IS_USED(VAR_9)) {\n                            /* COMMENT_17 */\n                                        \n                            gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(VAR_0);\n                        }\n                        if (IS_USED(VAR_15)) {\n                            /* COMMENT_19 */\n                                                   \n                            VAR_16.fragment_resends.by_timeout++;\n                        }\n                    }\n                    /* COMMENT_21 */\n                                 \n                    VAR_5 = true;\n                }\n                else {\n                    /* COMMENT_23 */\n                    DEBUG(\"6lo sfr: no retries left for fragment \"\n                          \"(tag: %u, X: %i, seq: %u, frag_size: %u, \"\n                          \"offset: %u)\\n\",\n                          (uint8_t)VAR_0->tag, _frag_ack_req(VAR_3),\n                          _frag_seq(VAR_3), _frag_size(VAR_3),\n                          VAR_3->offset);\n                    /* COMMENT_24 */\n                                                                             \n                                                  \n                    _retry_datagram(VAR_0);\n                    return;\n                }\n            }\n            else {\n                /* COMMENT_27 */\n                                                                        \n                                                                              \n                                                                         \n                                                      \n                DEBUG(\"6lo sfr: nothing to do for fragment %u\\n\",\n                      _frag_seq(VAR_3));\n            }\n        } while (VAR_3 != VAR_10);\n        /* COMMENT_32 */\n                                                                        \n                                             \n        clist_foreach(&VAR_0->sfr.window, VAR_17, VAR_0);\n    }\n    else {\n        /* COMMENT_35 */\n                          \n        VAR_6 = VAR_18;\n    }\n    assert(VAR_0->sfr.frags_sent == clist_count(&VAR_0->sfr.window));\n    if (VAR_5) {\n        _sched_arq_timeout(VAR_0, VAR_4);\n        return;\n    }\nerror:\n    /* COMMENT_37 */\n    _send_abort_frag(VAR_0->pkt, VAR_0, false, 0);\n    _clean_up_fbuf(VAR_0, VAR_6);\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/before/2.json",
  "func": "void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    uint32_t now = xtimer_now_usec() / US_PER_MS;\n    _frag_desc_t *frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;\n    uint32_t next_arq_offset = fbuf->sfr.arq_timeout;\n    bool reschedule_arq_timeout = false;\n    int error_no = ETIMEDOUT;   /* assume time out for fbuf->pkt */\n\n    DEBUG(\"6lo sfr: ARQ timeout for datagram %u\\n\", fbuf->tag);\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        /* mock-up to emulate time having passed beyond (1us) the ARQ timeout */\n        now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;\n    }\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) && frag_desc) {\n        /* report timeout to CongURE state */\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(fbuf);\n        _shrink_window(fbuf);   /* potentially shrink window */\n        /* reassign frag_desc, in case window head changed */\n        frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;\n    }\n    /* copying clist_foreach because we can't work just in function context */\n    _frag_desc_t * const head = frag_desc;\n    if (frag_desc) {\n        do {\n            uint32_t diff;\n\n            frag_desc = (_frag_desc_t *)frag_desc->super.super.next;\n            diff = now - frag_desc->super.send_time;\n            if (diff < fbuf->sfr.arq_timeout) {\n                /* this fragment's last was last sent < fbuf->sfr.arq_timeout\n                 * ago */\n                uint32_t offset = fbuf->sfr.arq_timeout - diff;\n\n                DEBUG(\"6lo sfr: wait for fragment %u in next reschedule\\n\",\n                      _frag_seq(frag_desc));\n                if (offset < next_arq_offset) {\n                    /* wait for this fragments ACK next */\n                    next_arq_offset = offset;\n                    DEBUG(\"         (next ARQ timeout in %lu)\\n\",\n                          (long unsigned)next_arq_offset);\n                }\n                /* this fragment is still waiting for its ACK,\n                 * reschedule the next ACK timeout to the difference\n                 * of the ACK timeout and the time of its last send */\n                reschedule_arq_timeout = true;\n            }\n            else if (_frag_ack_req(frag_desc)) {\n                /* for this fragment we requested an ACK which was not received\n                 * yet. Try to resend it */\n                if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {\n                    /* we have retries left for this fragment */\n                    DEBUG(\"6lo sfr: %u retries left for fragment (tag: %u, \"\n                          \"X: %i, seq: %u, frag_size: %u, offset: %u)\\n\",\n                          CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -\n                          (frag_desc->super.resends - 1), (uint8_t)fbuf->tag,\n                          _frag_ack_req(frag_desc), _frag_seq(frag_desc),\n                          _frag_size(frag_desc), frag_desc->offset);\n                    if (_resend_frag(&frag_desc->super.super, fbuf) != 0) {\n                        /* _resend_frag failed due to a memory resource\n                         * problem */\n                        error_no = ENOMEM;\n                        goto error;\n                    }\n                    else {\n                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {\n                            /* fragment was resent successfully, report this to CongURE state\n                             * object */\n                            gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);\n                        }\n                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                            /* fragment was resent successfully, note this done\n                             * in the statistics */\n                            _stats.fragment_resends.by_timeout++;\n                        }\n                    }\n                    /* fragment was resent successfully, schedule next ACK\n                     * timeout */\n                    reschedule_arq_timeout = true;\n                }\n                else {\n                    /* out of retries */\n                    DEBUG(\"6lo sfr: no retries left for fragment \"\n                          \"(tag: %u, X: %i, seq: %u, frag_size: %u, \"\n                          \"offset: %u)\\n\",\n                          (uint8_t)fbuf->tag, _frag_ack_req(frag_desc),\n                          _frag_seq(frag_desc), _frag_size(frag_desc),\n                          frag_desc->offset);\n                    /* we are out of retries on the fragment level, but we\n                     * might be able to retry the datagram if retries for the\n                     * datagram are configured. */\n                    _retry_datagram(fbuf);\n                    return;\n                }\n            }\n            else {\n                /* Do not resend fragments that were not explicitly asking for\n                 * an ACK from the reassembling endpoint on ACK timeout.\n                 * If this is true for all fragments remaining in the fragment\n                 * buffer, the datagram is to be considered timed out, so\n                 * error_no should remain ETIMEDOUT */\n                DEBUG(\"6lo sfr: nothing to do for fragment %u\\n\",\n                      _frag_seq(frag_desc));\n            }\n        } while (frag_desc != head);\n        /* report all non-ack_req fragments in window also as sent, since even\n         * the lost fragments are still in flight (even though they were\n         * previously marked as timed out) */\n        clist_foreach(&fbuf->sfr.window, _report_non_ack_req_window_sent, fbuf);\n    }\n    else {\n        /* No fragments to resend, we can assume the packet was delivered\n         * successfully */\n        error_no = GNRC_NETERR_SUCCESS;\n    }\n    assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));\n    if (reschedule_arq_timeout) {\n        _sched_arq_timeout(fbuf, next_arq_offset);\n        return;\n    }\nerror:\n    /* don't check return value, as we don't want to wait for an ACK again ;-) */\n    _send_abort_frag(fbuf->pkt, fbuf, false, 0);\n    _clean_up_fbuf(fbuf, error_no);\n}",
  "abstract_func": "void gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *VAR_0)\n{\n    uint32_t VAR_1 = xtimer_now_usec() / VAR_2;\n    _frag_desc_t *VAR_3 = (_frag_desc_t *)VAR_0->sfr.window.next;\n    uint32_t VAR_4 = VAR_0->sfr.arq_timeout;\n    bool VAR_5 = false;\n    int VAR_6 = VAR_7;   /* COMMENT_0 */\n\n    DEBUG(\"6lo sfr: ARQ timeout for datagram %u\\n\", VAR_0->tag);\n    if (IS_ACTIVE(VAR_8)) {\n        /* COMMENT_1 */\n        VAR_1 -= (VAR_0->sfr.arq_timeout * VAR_2) + 1;\n    }\n    if (IS_USED(VAR_9) && VAR_3) {\n        /* COMMENT_2 */\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(VAR_0);\n        _shrink_window(VAR_0);   /* COMMENT_3 */\n        /* COMMENT_4 */\n        VAR_3 = (_frag_desc_t *)VAR_0->sfr.window.next;\n    }\n    /* COMMENT_5 */\n    _frag_desc_t * const VAR_10 = VAR_3;\n    if (VAR_3) {\n        do {\n            uint32_t VAR_11;\n\n            VAR_3 = (_frag_desc_t *)VAR_3->super.super.next;\n            VAR_11 = VAR_1 - VAR_3->super.send_time;\n            if (VAR_11 < VAR_0->sfr.arq_timeout) {\n                /* COMMENT_6 */\n                         \n                uint32_t VAR_12 = VAR_0->sfr.arq_timeout - VAR_11;\n\n                DEBUG(\"6lo sfr: wait for fragment %u in next reschedule\\n\",\n                      _frag_seq(VAR_3));\n                if (VAR_12 < VAR_4) {\n                    /* COMMENT_8 */\n                    VAR_4 = VAR_12;\n                    DEBUG(\"         (next ARQ timeout in %lu)\\n\",\n                          (long unsigned)VAR_4);\n                }\n                /* COMMENT_9 */\n                                                                    \n                                                                      \n                VAR_5 = true;\n            }\n            else if (_frag_ack_req(VAR_3)) {\n                /* COMMENT_12 */\n                                           \n                if ((VAR_3->super.resends++) < VAR_13) {\n                    /* COMMENT_14 */\n                    DEBUG(\"6lo sfr: %u retries left for fragment (tag: %u, \"\n                          \"X: %i, seq: %u, frag_size: %u, offset: %u)\\n\",\n                          VAR_13 -\n                          (VAR_3->super.resends - 1), (uint8_t)VAR_0->tag,\n                          _frag_ack_req(VAR_3), _frag_seq(VAR_3),\n                          _frag_size(VAR_3), VAR_3->offset);\n                    if (_resend_frag(&VAR_3->super.super, VAR_0) != 0) {\n                        /* COMMENT_15 */\n                                     \n                        VAR_6 = VAR_14;\n                        goto error;\n                    }\n                    else {\n                        if (IS_USED(VAR_9)) {\n                            /* COMMENT_17 */\n                                        \n                            gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(VAR_0);\n                        }\n                        if (IS_USED(VAR_15)) {\n                            /* COMMENT_19 */\n                                                   \n                            VAR_16.fragment_resends.by_timeout++;\n                        }\n                    }\n                    /* COMMENT_21 */\n                                 \n                    VAR_5 = true;\n                }\n                else {\n                    /* COMMENT_23 */\n                    DEBUG(\"6lo sfr: no retries left for fragment \"\n                          \"(tag: %u, X: %i, seq: %u, frag_size: %u, \"\n                          \"offset: %u)\\n\",\n                          (uint8_t)VAR_0->tag, _frag_ack_req(VAR_3),\n                          _frag_seq(VAR_3), _frag_size(VAR_3),\n                          VAR_3->offset);\n                    /* COMMENT_24 */\n                                                                             \n                                                  \n                    _retry_datagram(VAR_0);\n                    return;\n                }\n            }\n            else {\n                /* COMMENT_27 */\n                                                                        \n                                                                              \n                                                                         \n                                                      \n                DEBUG(\"6lo sfr: nothing to do for fragment %u\\n\",\n                      _frag_seq(VAR_3));\n            }\n        } while (VAR_3 != VAR_10);\n        /* COMMENT_32 */\n                                                                        \n                                             \n        clist_foreach(&VAR_0->sfr.window, VAR_17, VAR_0);\n    }\n    else {\n        /* COMMENT_35 */\n                          \n        VAR_6 = VAR_18;\n    }\n    assert(VAR_0->sfr.frags_sent == clist_count(&VAR_0->sfr.window));\n    if (VAR_5) {\n        _sched_arq_timeout(VAR_0, VAR_4);\n        return;\n    }\nerror:\n    /* COMMENT_37 */\n    _send_abort_frag(VAR_0->pkt, VAR_0, false, 0);\n    _clean_up_fbuf(VAR_0, VAR_6);\n}",
  "func_graph_path": "RIOT-OS/RIOT/31c6191f6196f1a05c9765cffeadba868e3b0723/gnrc_sixlowpan_frag_sfr.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,6 @@\n     int error_no = ETIMEDOUT;   /* assume time out for fbuf->pkt */\n \n     DEBUG(\"6lo sfr: ARQ timeout for datagram %u\\n\", fbuf->tag);\n-    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n     if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n         /* mock-up to emulate time having passed beyond (1us) the ARQ timeout */\n         now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;",
  "diff_line_info": {
    "deleted_lines": [
      "    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/19679",
  "description": {
    "pr_info": {
      "title": "gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition",
      "number": 19679
    },
    "comment": [
      "<!--\r\nThe RIOT community cares a lot about code quality.\r\nTherefore, before describing what your contribution is about, we would like\r\nyou to make sure that your modifications are compliant with the RIOT\r\ncoding conventions, see https://github.com/RIOT-OS/RIOT/blob/master/CODING_CONVENTIONS.md.\r\n-->\r\n\r\n### Contribution description\r\nSee https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-8m3w-mphf-wxm8\r\n<!--\r\nPut here the description of your contribution:\r\n- describe which part(s) of RIOT is (are) involved\r\n- if it's a bug fix, describe the bug that it solves and how it is solved\r\n- you can also give more information to reviewers about how to test your changes\r\n-->\r\n\r\n\r\n### Testing procedure\r\n\r\n<!--\r\nDetails steps to test your contribution:\r\n- which test/example to compile for which board and is there a 'test' command\r\n- how to know that it was not working/available in master\r\n- the expected success test output\r\n-->\r\n\r\n\r\n### Issues/PRs references\r\n\r\n<!--\r\nExamples: Fixes #1234. See also #5678. Depends on PR #9876.\r\n\r\nPlease use keywords (e.g., fixes, resolve) with the links to the issues you\r\nresolved, this way they will be automatically closed when your pull request\r\nis merged. See https://help.github.com/articles/closing-issues-using-keywords/.\r\n-->\r\n",
      "### Murdock results\n\n:heavy_check_mark: [PASSED](https://ci.riot-os.org/details/4713913fc6d1414691da03713dbc1baa)\n\n31c6191f6196f1a05c9765cffeadba868e3b0723 gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition\n\n|  Success  |  Failures  |  Total  |  Runtime  |\n| :-------: | :--------: | :-----: | :-------: |\n| 6933 | 0 | 6933 | 16m:54s |\n\n\n#### Artifacts\n- [Documentation preview](https://ci.riot-os.org/results/4713913fc6d1414691da03713dbc1baa/doc-preview/)\n",
      "> ### Murdock results\r\n> \r\n> :x: [FAILED](https://ci.riot-os.org/details/8bc8678a27694e7c887b6764198f0a9b)\r\n> \r\n> 7c28616910892d2af21d7ef8c28ff9a60b4ea941 gnrc_sixlowpan_frag_sfr: fix ARQ scheduler race-condition\r\n> \r\n> |  Success  |  Failures  |  Total  |  Runtime  |\r\n> | :-------: | :--------: | :-----: | :-------: |\r\n> | 4235 | 0 | 6933 | 06m:11s |\r\n> \r\n> \r\n> #### Artifacts\r\n> \r\n\r\nSomeone forgot to mention the failures? (/cc @aabadie)",
      "bors merge",
      "This PR was included in a batch that was canceled, it will be automatically retried",
      "  Build succeeded!\n\n  The publicly hosted instance of bors-ng is deprecated and will go away soon.\n\n  If you want to self-host your own instance, [instructions are here][instructions].\n  For more help, visit [the forum].\n\n  If you want to switch to GitHub's built-in merge queue, visit [their help page][gh].\n\n  [instructions]: https://github.com/bors-ng/bors-ng#how-to-set-up-your-own-real-instance\n  [the forum]: https://forum.bors.tech\n  [gh]: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue\n\n\n\n  * [Murdock](https://ci.riot-os.org/details/fb540a7fea3d482dbf15b594aaf08a39)\n  * [static-tests](https://github.com/RIOT-OS/RIOT/actions/runs/5124347194/jobs/9216073113)\n  * [tools-build-success](https://github.com/RIOT-OS/RIOT/actions/runs/5124347197/jobs/9216103309)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}