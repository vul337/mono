{
  "cve_id": "CVE-2020-24994",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libass",
  "commit_msg": "parse_tags: don't recurse for nested \\t()\n\nThis fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=4892\n(stack overflow on deeply nested \\t()).\n\nThis is possible because parentheses do not nest and the first ')'\nterminates the whole tag. Thus something like \\t(\\t(\\t(\\t(\\t() can be\nread in a simple loop with no recursion required. Recursion is also\nnot required if the ')' is missing entirely and the outermost \\t(...\nnever ends.\n\nSee https://github.com/libass/libass/pull/296 for more backstory.",
  "commit_hash": "6835731c2fe4164a0c50bc91d12c43b2a2b4e",
  "git_url": "https://github.com/libass/libass/commit/6835731c2fe4164a0c50bc91d12c43b2a2b4e799",
  "file_path": "libass/ass_parse.c",
  "func_name": "parse_tags",
  "func_before": "char *parse_tags(ASS_Renderer *render_priv, char *p, char *end, double pwr)\n{\n    for (char *q; p < end; p = q) {\n        while (*p != '\\\\' && p != end)\n            ++p;\n        if (*p != '\\\\')\n            break;\n        ++p;\n        if (p != end)\n            skip_spaces(&p);\n\n        q = p;\n        while (*q != '(' && *q != '\\\\' && q != end)\n            ++q;\n        if (q == p)\n            continue;\n\n        char *name_end = q;\n\n        // Store one extra element to be able to detect excess arguments\n        struct arg args[MAX_VALID_NARGS + 1];\n        int nargs = 0;\n        for (int i = 0; i <= MAX_VALID_NARGS; ++i)\n            args[i].start = args[i].end = \"\";\n\n        // Split parenthesized arguments. Do this for all tags and before\n        // any non-parenthesized argument because that's what VSFilter does.\n        if (*q == '(') {\n            ++q;\n            while (1) {\n                if (q != end)\n                    skip_spaces(&q);\n\n                // Split on commas. If there is a backslash, ignore any\n                // commas following it and lump everything starting from\n                // the last comma, through the backslash and all the way\n                // to the end of the argument string into a single argument.\n\n                char *r = q;\n                while (*r != ',' && *r != '\\\\' && *r != ')' && r != end)\n                    ++r;\n\n                if (*r == ',') {\n                    push_arg(args, &nargs, q, r);\n                    q = r + 1;\n                } else {\n                    // Swallow the rest of the parenthesized string. This could\n                    // be either a backslash-argument or simply the last argument.\n                    while (*r != ')' && r != end)\n                        ++r;\n                    push_arg(args, &nargs, q, r);\n                    q = r;\n                    // The closing parenthesis could be missing.\n                    if (q != end)\n                        ++q;\n                    break;\n                }\n            }\n        }\n\n#define tag(name) (mystrcmp(&p, (name)) && (push_arg(args, &nargs, p, name_end), 1))\n#define complex_tag(name) mystrcmp(&p, (name))\n\n        // New tags introduced in vsfilter 2.39\n        if (tag(\"xbord\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.border_x * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->Outline;\n            render_priv->state.border_x = val;\n        } else if (tag(\"ybord\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.border_y * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->Outline;\n            render_priv->state.border_y = val;\n        } else if (tag(\"xshad\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;\n            } else\n                val = render_priv->state.style->Shadow;\n            render_priv->state.shadow_x = val;\n        } else if (tag(\"yshad\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;\n            } else\n                val = render_priv->state.style->Shadow;\n            render_priv->state.shadow_y = val;\n        } else if (tag(\"fax\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.fax =\n                    val * pwr + render_priv->state.fax * (1 - pwr);\n            } else\n                render_priv->state.fax = 0.;\n        } else if (tag(\"fay\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.fay =\n                    val * pwr + render_priv->state.fay * (1 - pwr);\n            } else\n                render_priv->state.fay = 0.;\n        } else if (complex_tag(\"iclip\")) {\n            if (nargs == 4) {\n                int x0, y0, x1, y1;\n                x0 = argtoi(args[0]);\n                y0 = argtoi(args[1]);\n                x1 = argtoi(args[2]);\n                y1 = argtoi(args[3]);\n                render_priv->state.clip_x0 =\n                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;\n                render_priv->state.clip_x1 =\n                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;\n                render_priv->state.clip_y0 =\n                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;\n                render_priv->state.clip_y1 =\n                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;\n                render_priv->state.clip_mode = 1;\n            } else if (!render_priv->state.clip_drawing) {\n                if (parse_vector_clip(render_priv, args, nargs))\n                    render_priv->state.clip_drawing_mode = 1;\n            }\n        } else if (tag(\"blur\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.blur * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n                val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;\n                render_priv->state.blur = val;\n            } else\n                render_priv->state.blur = 0.0;\n            // ASS standard tags\n        } else if (tag(\"fscx\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args) / 100;\n                val = render_priv->state.scale_x * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->ScaleX;\n            render_priv->state.scale_x = val;\n        } else if (tag(\"fscy\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args) / 100;\n                val = render_priv->state.scale_y * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->ScaleY;\n            render_priv->state.scale_y = val;\n        } else if (tag(\"fsc\")) {\n            render_priv->state.scale_x = render_priv->state.style->ScaleX;\n            render_priv->state.scale_y = render_priv->state.style->ScaleY;\n        } else if (tag(\"fsp\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.hspacing =\n                    render_priv->state.hspacing * (1 - pwr) + val * pwr;\n            } else\n                render_priv->state.hspacing = render_priv->state.style->Spacing;\n        } else if (tag(\"fs\")) {\n            double val = 0;\n            if (nargs) {\n                val = argtod(*args);\n                if (*args->start == '+' || *args->start == '-')\n                    val = render_priv->state.font_size * (1 + pwr * val / 10);\n                else\n                    val = render_priv->state.font_size * (1 - pwr) + val * pwr;\n            }\n            if (val <= 0)\n                val = render_priv->state.style->FontSize;\n            if (render_priv->state.font)\n                change_font_size(render_priv, val);\n        } else if (tag(\"bord\")) {\n            double val, xval, yval;\n            if (nargs) {\n                val = argtod(*args);\n                xval = render_priv->state.border_x * (1 - pwr) + val * pwr;\n                yval = render_priv->state.border_y * (1 - pwr) + val * pwr;\n                xval = (xval < 0) ? 0 : xval;\n                yval = (yval < 0) ? 0 : yval;\n            } else\n                xval = yval = render_priv->state.style->Outline;\n            render_priv->state.border_x = xval;\n            render_priv->state.border_y = yval;\n        } else if (complex_tag(\"move\")) {\n            double x1, x2, y1, y2;\n            long long t1, t2, delta_t, t;\n            double x, y;\n            double k;\n            if (nargs == 4 || nargs == 6) {\n                x1 = argtod(args[0]);\n                y1 = argtod(args[1]);\n                x2 = argtod(args[2]);\n                y2 = argtod(args[3]);\n                t1 = t2 = 0;\n                if (nargs == 6) {\n                    t1 = argtoll(args[4]);\n                    t2 = argtoll(args[5]);\n                    if (t1 > t2) {\n                        long long tmp = t2;\n                        t2 = t1;\n                        t1 = tmp;\n                    }\n                }\n            } else\n                continue;\n            if (t1 <= 0 && t2 <= 0) {\n                t1 = 0;\n                t2 = render_priv->state.event->Duration;\n            }\n            delta_t = t2 - t1;\n            t = render_priv->time - render_priv->state.event->Start;\n            if (t <= t1)\n                k = 0.;\n            else if (t >= t2)\n                k = 1.;\n            else\n                k = ((double) (t - t1)) / delta_t;\n            x = k * (x2 - x1) + x1;\n            y = k * (y2 - y1) + y1;\n            if (render_priv->state.evt_type != EVENT_POSITIONED) {\n                render_priv->state.pos_x = x;\n                render_priv->state.pos_y = y;\n                render_priv->state.detect_collisions = 0;\n                render_priv->state.evt_type = EVENT_POSITIONED;\n            }\n        } else if (tag(\"frx\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.frx =\n                    val * pwr + render_priv->state.frx * (1 - pwr);\n            } else\n                render_priv->state.frx = 0.;\n        } else if (tag(\"fry\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.fry =\n                    val * pwr + render_priv->state.fry * (1 - pwr);\n            } else\n                render_priv->state.fry = 0.;\n        } else if (tag(\"frz\") || tag(\"fr\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.frz =\n                    val * pwr + render_priv->state.frz * (1 - pwr);\n            } else\n                render_priv->state.frz =\n                    M_PI * render_priv->state.style->Angle / 180.;\n        } else if (tag(\"fn\")) {\n            char *family;\n            char *start = args->start;\n            if (nargs && strncmp(start, \"0\", args->end - start)) {\n                skip_spaces(&start);\n                family = strndup(start, args->end - start);\n            } else\n                family = strdup(render_priv->state.style->FontName);\n            free(render_priv->state.family);\n            render_priv->state.family = family;\n            update_font(render_priv);\n        } else if (tag(\"alpha\")) {\n            int i;\n            if (nargs) {\n                int32_t a = parse_alpha_tag(args->start);\n                for (i = 0; i < 4; ++i)\n                    change_alpha(&render_priv->state.c[i], a, pwr);\n            } else {\n                change_alpha(&render_priv->state.c[0],\n                             _a(render_priv->state.style->PrimaryColour), 1);\n                change_alpha(&render_priv->state.c[1],\n                             _a(render_priv->state.style->SecondaryColour), 1);\n                change_alpha(&render_priv->state.c[2],\n                             _a(render_priv->state.style->OutlineColour), 1);\n                change_alpha(&render_priv->state.c[3],\n                             _a(render_priv->state.style->BackColour), 1);\n            }\n            // FIXME: simplify\n        } else if (tag(\"an\")) {\n            int val = argtoi(*args);\n            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {\n                if (val >= 1 && val <= 9)\n                    render_priv->state.alignment = numpad2align(val);\n                else\n                    render_priv->state.alignment =\n                        render_priv->state.style->Alignment;\n                render_priv->state.parsed_tags |= PARSED_A;\n            }\n        } else if (tag(\"a\")) {\n            int val = argtoi(*args);\n            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {\n                if (val >= 1 && val <= 11)\n                    // take care of a vsfilter quirk:\n                    // handle illegal \\a8 and \\a4 like \\a5\n                    render_priv->state.alignment = ((val & 3) == 0) ? 5 : val;\n                else\n                    render_priv->state.alignment =\n                        render_priv->state.style->Alignment;\n                render_priv->state.parsed_tags |= PARSED_A;\n            }\n        } else if (complex_tag(\"pos\")) {\n            double v1, v2;\n            if (nargs == 2) {\n                v1 = argtod(args[0]);\n                v2 = argtod(args[1]);\n            } else\n                continue;\n            if (render_priv->state.evt_type == EVENT_POSITIONED) {\n                ass_msg(render_priv->library, MSGL_V, \"Subtitle has a new \\\\pos \"\n                       \"after \\\\move or \\\\pos, ignoring\");\n            } else {\n                render_priv->state.evt_type = EVENT_POSITIONED;\n                render_priv->state.detect_collisions = 0;\n                render_priv->state.pos_x = v1;\n                render_priv->state.pos_y = v2;\n            }\n        } else if (complex_tag(\"fade\") || complex_tag(\"fad\")) {\n            int a1, a2, a3;\n            long long t1, t2, t3, t4;\n            if (nargs == 2) {\n                // 2-argument version (\\fad, according to specs)\n                a1 = 0xFF;\n                a2 = 0;\n                a3 = 0xFF;\n                t1 = -1;\n                t2 = argtoll(args[0]);\n                t3 = argtoll(args[1]);\n                t4 = -1;\n            } else if (nargs == 7) {\n                // 7-argument version (\\fade)\n                a1 = argtoi(args[0]);\n                a2 = argtoi(args[1]);\n                a3 = argtoi(args[2]);\n                t1 = argtoll(args[3]);\n                t2 = argtoll(args[4]);\n                t3 = argtoll(args[5]);\n                t4 = argtoll(args[6]);\n            } else\n                continue;\n            if (t1 == -1 && t4 == -1) {\n                t1 = 0;\n                t4 = render_priv->state.event->Duration;\n                t3 = t4 - t3;\n            }\n            if ((render_priv->state.parsed_tags & PARSED_FADE) == 0) {\n                render_priv->state.fade =\n                    interpolate_alpha(render_priv->time -\n                            render_priv->state.event->Start, t1, t2,\n                            t3, t4, a1, a2, a3);\n                render_priv->state.parsed_tags |= PARSED_FADE;\n            }\n        } else if (complex_tag(\"org\")) {\n            double v1, v2;\n            if (nargs == 2) {\n                v1 = argtod(args[0]);\n                v2 = argtod(args[1]);\n            } else\n                continue;\n            if (!render_priv->state.have_origin) {\n                render_priv->state.org_x = v1;\n                render_priv->state.org_y = v2;\n                render_priv->state.have_origin = 1;\n                render_priv->state.detect_collisions = 0;\n            }\n        } else if (complex_tag(\"t\")) {\n            double accel;\n            int cnt = nargs - 1;\n            long long t1, t2, t, delta_t;\n            double k;\n            if (cnt == 3) {\n                t1 = argtoll(args[0]);\n                t2 = argtoll(args[1]);\n                accel = argtod(args[2]);\n            } else if (cnt == 2) {\n                t1 = argtoll(args[0]);\n                t2 = argtoll(args[1]);\n                accel = 1.;\n            } else if (cnt == 1) {\n                t1 = 0;\n                t2 = 0;\n                accel = argtod(args[0]);\n            } else if (cnt == 0) {\n                t1 = 0;\n                t2 = 0;\n                accel = 1.;\n            } else\n                continue;\n            render_priv->state.detect_collisions = 0;\n            if (t2 == 0)\n                t2 = render_priv->state.event->Duration;\n            delta_t = t2 - t1;\n            t = render_priv->time - render_priv->state.event->Start;        // FIXME: move to render_context\n            if (t <= t1)\n                k = 0.;\n            else if (t >= t2)\n                k = 1.;\n            else {\n                assert(delta_t != 0.);\n                k = pow(((double) (t - t1)) / delta_t, accel);\n            }\n            p = args[cnt].start;\n            p = parse_tags(render_priv, p, args[cnt].end, k);    // maybe k*pwr ? no, specs forbid nested \\t's\n        } else if (complex_tag(\"clip\")) {\n            if (nargs == 4) {\n                int x0, y0, x1, y1;\n                x0 = argtoi(args[0]);\n                y0 = argtoi(args[1]);\n                x1 = argtoi(args[2]);\n                y1 = argtoi(args[3]);\n                render_priv->state.clip_x0 =\n                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;\n                render_priv->state.clip_x1 =\n                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;\n                render_priv->state.clip_y0 =\n                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;\n                render_priv->state.clip_y1 =\n                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;\n                render_priv->state.clip_mode = 0;\n            } else if (!render_priv->state.clip_drawing) {\n                if (parse_vector_clip(render_priv, args, nargs))\n                    render_priv->state.clip_drawing_mode = 0;\n            }\n        } else if (tag(\"c\") || tag(\"1c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[0], val, pwr);\n            } else\n                change_color(&render_priv->state.c[0],\n                             render_priv->state.style->PrimaryColour, 1);\n        } else if (tag(\"2c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[1], val, pwr);\n            } else\n                change_color(&render_priv->state.c[1],\n                             render_priv->state.style->SecondaryColour, 1);\n        } else if (tag(\"3c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[2], val, pwr);\n            } else\n                change_color(&render_priv->state.c[2],\n                             render_priv->state.style->OutlineColour, 1);\n        } else if (tag(\"4c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[3], val, pwr);\n            } else\n                change_color(&render_priv->state.c[3],\n                             render_priv->state.style->BackColour, 1);\n        } else if (tag(\"1a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[0], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[0],\n                             _a(render_priv->state.style->PrimaryColour), 1);\n        } else if (tag(\"2a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[1], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[1],\n                             _a(render_priv->state.style->SecondaryColour), 1);\n        } else if (tag(\"3a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[2], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[2],\n                             _a(render_priv->state.style->OutlineColour), 1);\n        } else if (tag(\"4a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[3], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[3],\n                             _a(render_priv->state.style->BackColour), 1);\n        } else if (tag(\"r\")) {\n            if (nargs) {\n                int len = args->end - args->start;\n                reset_render_context(render_priv,\n                        lookup_style_strict(render_priv->track, args->start, len));\n            } else\n                reset_render_context(render_priv, NULL);\n        } else if (tag(\"be\")) {\n            double dval;\n            if (nargs) {\n                int val;\n                dval = argtod(*args);\n                // VSFilter always adds +0.5, even if the value is negative\n                val = (int) (render_priv->state.be * (1 - pwr) + dval * pwr + 0.5);\n                // Clamp to a safe upper limit, since high values need excessive CPU\n                val = (val < 0) ? 0 : val;\n                val = (val > MAX_BE) ? MAX_BE : val;\n                render_priv->state.be = val;\n            } else\n                render_priv->state.be = 0;\n        } else if (tag(\"b\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1 || val >= 100))\n                val = render_priv->state.style->Bold;\n            render_priv->state.bold = val;\n            update_font(render_priv);\n        } else if (tag(\"i\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->Italic;\n            render_priv->state.italic = val;\n            update_font(render_priv);\n        } else if (tag(\"kf\") || tag(\"K\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE_KF;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"ko\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE_KO;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"k\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"shad\")) {\n            double val, xval, yval;\n            if (nargs) {\n                val = argtod(*args);\n                xval = render_priv->state.shadow_x * (1 - pwr) + val * pwr;\n                yval = render_priv->state.shadow_y * (1 - pwr) + val * pwr;\n                // VSFilter compatibility: clip for \\shad but not for \\[xy]shad\n                xval = (xval < 0) ? 0 : xval;\n                yval = (yval < 0) ? 0 : yval;\n            } else\n                xval = yval = render_priv->state.style->Shadow;\n            render_priv->state.shadow_x = xval;\n            render_priv->state.shadow_y = yval;\n        } else if (tag(\"s\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->StrikeOut;\n            if (val)\n                render_priv->state.flags |= DECO_STRIKETHROUGH;\n            else\n                render_priv->state.flags &= ~DECO_STRIKETHROUGH;\n        } else if (tag(\"u\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->Underline;\n            if (val)\n                render_priv->state.flags |= DECO_UNDERLINE;\n            else\n                render_priv->state.flags &= ~DECO_UNDERLINE;\n        } else if (tag(\"pbo\")) {\n            double val = argtod(*args);\n            render_priv->state.pbo = val;\n        } else if (tag(\"p\")) {\n            int val = argtoi(*args);\n            val = (val < 0) ? 0 : val;\n            render_priv->state.drawing_scale = val;\n        } else if (tag(\"q\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val >= 0 && val <= 3))\n                val = render_priv->track->WrapStyle;\n            render_priv->state.wrap_style = val;\n        } else if (tag(\"fe\")) {\n            int val;\n            if (nargs)\n                val = argtoi(*args);\n            else\n                val = render_priv->state.style->Encoding;\n            render_priv->state.font_encoding = val;\n        }\n    }\n\n    return p;\n}",
  "abstract_func_before": "char *parse_tags(ASS_Renderer *VAR_0, char *VAR_1, char *VAR_2, double VAR_3)\n{\n    for (char *VAR_4; VAR_1 < VAR_2; VAR_1 = VAR_4) {\n        while (*VAR_1 != '\\\\' && VAR_1 != VAR_2)\n            ++VAR_1;\n        if (*VAR_1 != '\\\\')\n            break;\n        ++VAR_1;\n        if (VAR_1 != VAR_2)\n            skip_spaces(&VAR_1);\n\n        VAR_4 = VAR_1;\n        while (*VAR_4 != '(' && *VAR_4 != '\\\\' && VAR_4 != VAR_2)\n            ++VAR_4;\n        if (VAR_4 == VAR_1)\n            continue;\n\n        char *VAR_5 = VAR_4;\n\n        /* COMMENT_0 */\n        struct arg VAR_6[VAR_7 + 1];\n        int VAR_8 = 0;\n        for (int VAR_9 = 0; VAR_9 <= VAR_7; ++VAR_9)\n            VAR_6[VAR_9].start = VAR_6[VAR_9].end = \"\";\n\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        if (*VAR_4 == '(') {\n            ++VAR_4;\n            while (1) {\n                if (VAR_4 != VAR_2)\n                    skip_spaces(&VAR_4);\n\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n\n                char *VAR_10 = VAR_4;\n                while (*VAR_10 != ',' && *VAR_10 != '\\\\' && *VAR_10 != ')' && VAR_10 != VAR_2)\n                    ++VAR_10;\n\n                if (*VAR_10 == ',') {\n                    push_arg(VAR_6, &VAR_8, VAR_4, VAR_10);\n                    VAR_4 = VAR_10 + 1;\n                } else {\n                    /* COMMENT_7 */\n                    /* COMMENT_8 */\n                    while (*VAR_10 != ')' && VAR_10 != VAR_2)\n                        ++VAR_10;\n                    push_arg(VAR_6, &VAR_8, VAR_4, VAR_10);\n                    VAR_4 = VAR_10;\n                    /* COMMENT_9 */\n                    if (VAR_4 != VAR_2)\n                        ++VAR_4;\n                    break;\n                }\n            }\n        }\n\n#define tag(VAR_11) (mystrcmp(&p, (name)) && (push_arg(args, &nargs, p, name_end), 1))\n#define complex_tag(VAR_11) mystrcmp(&p, (name))\n\n        /* COMMENT_10 */\n        if (tag(\"xbord\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.border_x * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            } else\n                VAR_12 = VAR_0->state.style->Outline;\n            VAR_0->state.border_x = VAR_12;\n        } else if (tag(\"ybord\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.border_y * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            } else\n                VAR_12 = VAR_0->state.style->Outline;\n            VAR_0->state.border_y = VAR_12;\n        } else if (tag(\"xshad\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.shadow_x * (1 - VAR_3) + VAR_12 * VAR_3;\n            } else\n                VAR_12 = VAR_0->state.style->Shadow;\n            VAR_0->state.shadow_x = VAR_12;\n        } else if (tag(\"yshad\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.shadow_y * (1 - VAR_3) + VAR_12 * VAR_3;\n            } else\n                VAR_12 = VAR_0->state.style->Shadow;\n            VAR_0->state.shadow_y = VAR_12;\n        } else if (tag(\"fax\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_0->state.fax =\n                    VAR_12 * VAR_3 + VAR_0->state.fax * (1 - VAR_3);\n            } else\n                VAR_0->state.fax = 0.;\n        } else if (tag(\"fay\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_0->state.fay =\n                    VAR_12 * VAR_3 + VAR_0->state.fay * (1 - VAR_3);\n            } else\n                VAR_0->state.fay = 0.;\n        } else if (complex_tag(\"iclip\")) {\n            if (VAR_8 == 4) {\n                int VAR_13, VAR_14, VAR_15, VAR_16;\n                VAR_13 = argtoi(VAR_6[0]);\n                VAR_14 = argtoi(VAR_6[1]);\n                VAR_15 = argtoi(VAR_6[2]);\n                VAR_16 = argtoi(VAR_6[3]);\n                VAR_0->state.clip_x0 =\n                    VAR_0->state.clip_x0 * (1 - VAR_3) + VAR_13 * VAR_3;\n                VAR_0->state.clip_x1 =\n                    VAR_0->state.clip_x1 * (1 - VAR_3) + VAR_15 * VAR_3;\n                VAR_0->state.clip_y0 =\n                    VAR_0->state.clip_y0 * (1 - VAR_3) + VAR_14 * VAR_3;\n                VAR_0->state.clip_y1 =\n                    VAR_0->state.clip_y1 * (1 - VAR_3) + VAR_16 * VAR_3;\n                VAR_0->state.clip_mode = 1;\n            } else if (!VAR_0->state.clip_drawing) {\n                if (parse_vector_clip(VAR_0, VAR_6, VAR_8))\n                    VAR_0->state.clip_drawing_mode = 1;\n            }\n        } else if (tag(\"blur\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.blur * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n                VAR_12 = (VAR_12 > VAR_17) ? VAR_17 : VAR_12;\n                VAR_0->state.blur = VAR_12;\n            } else\n                VAR_0->state.blur = 0.0;\n            /* COMMENT_11 */\n        } else if (tag(\"fscx\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6) / 100;\n                VAR_12 = VAR_0->state.scale_x * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            } else\n                VAR_12 = VAR_0->state.style->ScaleX;\n            VAR_0->state.scale_x = VAR_12;\n        } else if (tag(\"fscy\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6) / 100;\n                VAR_12 = VAR_0->state.scale_y * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            } else\n                VAR_12 = VAR_0->state.style->ScaleY;\n            VAR_0->state.scale_y = VAR_12;\n        } else if (tag(\"fsc\")) {\n            VAR_0->state.scale_x = VAR_0->state.style->ScaleX;\n            VAR_0->state.scale_y = VAR_0->state.style->ScaleY;\n        } else if (tag(\"fsp\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_0->state.hspacing =\n                    VAR_0->state.hspacing * (1 - VAR_3) + VAR_12 * VAR_3;\n            } else\n                VAR_0->state.hspacing = VAR_0->state.style->Spacing;\n        } else if (tag(\"fs\")) {\n            double VAR_12 = 0;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                if (*VAR_6->start == '+' || *VAR_6->start == '-')\n                    VAR_12 = VAR_0->state.font_size * (1 + VAR_3 * VAR_12 / 10);\n                else\n                    VAR_12 = VAR_0->state.font_size * (1 - VAR_3) + VAR_12 * VAR_3;\n            }\n            if (VAR_12 <= 0)\n                VAR_12 = VAR_0->state.style->FontSize;\n            if (VAR_0->state.font)\n                change_font_size(VAR_0, VAR_12);\n        } else if (tag(\"bord\")) {\n            double VAR_12, VAR_18, VAR_19;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_18 = VAR_0->state.border_x * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_19 = VAR_0->state.border_y * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_18 = (VAR_18 < 0) ? 0 : VAR_18;\n                VAR_19 = (VAR_19 < 0) ? 0 : VAR_19;\n            } else\n                VAR_18 = VAR_19 = VAR_0->state.style->Outline;\n            VAR_0->state.border_x = VAR_18;\n            VAR_0->state.border_y = VAR_19;\n        } else if (complex_tag(\"move\")) {\n            double VAR_15, VAR_20, VAR_16, VAR_21;\n            long long VAR_22, VAR_23, VAR_24, VAR_25;\n            double VAR_26, VAR_27;\n            double VAR_28;\n            if (VAR_8 == 4 || VAR_8 == 6) {\n                VAR_15 = argtod(VAR_6[0]);\n                VAR_16 = argtod(VAR_6[1]);\n                VAR_20 = argtod(VAR_6[2]);\n                VAR_21 = argtod(VAR_6[3]);\n                VAR_22 = VAR_23 = 0;\n                if (VAR_8 == 6) {\n                    VAR_22 = argtoll(VAR_6[4]);\n                    VAR_23 = argtoll(VAR_6[5]);\n                    if (VAR_22 > VAR_23) {\n                        long long VAR_29 = VAR_23;\n                        VAR_23 = VAR_22;\n                        VAR_22 = VAR_29;\n                    }\n                }\n            } else\n                continue;\n            if (VAR_22 <= 0 && VAR_23 <= 0) {\n                VAR_22 = 0;\n                VAR_23 = VAR_0->state.event->Duration;\n            }\n            VAR_24 = VAR_23 - VAR_22;\n            VAR_25 = VAR_0->time - VAR_0->state.event->Start;\n            if (VAR_25 <= VAR_22)\n                VAR_28 = 0.;\n            else if (VAR_25 >= VAR_23)\n                VAR_28 = 1.;\n            else\n                VAR_28 = ((double) (VAR_25 - VAR_22)) / VAR_24;\n            VAR_26 = VAR_28 * (VAR_20 - VAR_15) + VAR_15;\n            VAR_27 = VAR_28 * (VAR_21 - VAR_16) + VAR_16;\n            if (VAR_0->state.evt_type != VAR_30) {\n                VAR_0->state.pos_x = VAR_26;\n                VAR_0->state.pos_y = VAR_27;\n                VAR_0->state.detect_collisions = 0;\n                VAR_0->state.evt_type = VAR_30;\n            }\n        } else if (tag(\"frx\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 *= VAR_31 / 180;\n                VAR_0->state.frx =\n                    VAR_12 * VAR_3 + VAR_0->state.frx * (1 - VAR_3);\n            } else\n                VAR_0->state.frx = 0.;\n        } else if (tag(\"fry\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 *= VAR_31 / 180;\n                VAR_0->state.fry =\n                    VAR_12 * VAR_3 + VAR_0->state.fry * (1 - VAR_3);\n            } else\n                VAR_0->state.fry = 0.;\n        } else if (tag(\"frz\") || tag(\"fr\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 *= VAR_31 / 180;\n                VAR_0->state.frz =\n                    VAR_12 * VAR_3 + VAR_0->state.frz * (1 - VAR_3);\n            } else\n                VAR_0->state.frz =\n                    VAR_31 * VAR_0->state.style->Angle / 180.;\n        } else if (tag(\"fn\")) {\n            char *VAR_32;\n            char *VAR_33 = VAR_6->start;\n            if (VAR_8 && strncmp(VAR_33, \"0\", VAR_6->end - VAR_33)) {\n                skip_spaces(&VAR_33);\n                VAR_32 = strndup(VAR_33, VAR_6->end - VAR_33);\n            } else\n                VAR_32 = strdup(VAR_0->state.style->FontName);\n            free(VAR_0->state.family);\n            VAR_0->state.family = VAR_32;\n            update_font(VAR_0);\n        } else if (tag(\"alpha\")) {\n            int VAR_9;\n            if (VAR_8) {\n                int32_t VAR_34 = parse_alpha_tag(VAR_6->start);\n                for (VAR_9 = 0; VAR_9 < 4; ++VAR_9)\n                    change_alpha(&VAR_0->state.c[VAR_9], VAR_34, VAR_3);\n            } else {\n                change_alpha(&VAR_0->state.c[0],\n                             _a(VAR_0->state.style->PrimaryColour), 1);\n                change_alpha(&VAR_0->state.c[1],\n                             _a(VAR_0->state.style->SecondaryColour), 1);\n                change_alpha(&VAR_0->state.c[2],\n                             _a(VAR_0->state.style->OutlineColour), 1);\n                change_alpha(&VAR_0->state.c[3],\n                             _a(VAR_0->state.style->BackColour), 1);\n            }\n            /* COMMENT_12 */\n        } else if (tag(\"an\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if ((VAR_0->state.parsed_tags & VAR_35) == 0) {\n                if (VAR_12 >= 1 && VAR_12 <= 9)\n                    VAR_0->state.alignment = numpad2align(VAR_12);\n                else\n                    VAR_0->state.alignment =\n                        VAR_0->state.style->Alignment;\n                VAR_0->state.parsed_tags |= VAR_35;\n            }\n        } else if (tag(\"a\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if ((VAR_0->state.parsed_tags & VAR_35) == 0) {\n                if (VAR_12 >= 1 && VAR_12 <= 11)\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    VAR_0->state.alignment = ((VAR_12 & 3) == 0) ? 5 : VAR_12;\n                else\n                    VAR_0->state.alignment =\n                        VAR_0->state.style->Alignment;\n                VAR_0->state.parsed_tags |= VAR_35;\n            }\n        } else if (complex_tag(\"pos\")) {\n            double VAR_36, VAR_37;\n            if (VAR_8 == 2) {\n                VAR_36 = argtod(VAR_6[0]);\n                VAR_37 = argtod(VAR_6[1]);\n            } else\n                continue;\n            if (VAR_0->state.evt_type == VAR_30) {\n                ass_msg(VAR_0->library, VAR_38, \"Subtitle has a new \\\\pos \"\n                       \"after \\\\move or \\\\pos, ignoring\");\n            } else {\n                VAR_0->state.evt_type = VAR_30;\n                VAR_0->state.detect_collisions = 0;\n                VAR_0->state.pos_x = VAR_36;\n                VAR_0->state.pos_y = VAR_37;\n            }\n        } else if (complex_tag(\"fade\") || complex_tag(\"fad\")) {\n            int VAR_39, VAR_40, VAR_41;\n            long long VAR_22, VAR_23, VAR_42, VAR_43;\n            if (VAR_8 == 2) {\n                /* COMMENT_15 */\n                VAR_39 = 0xFF;\n                VAR_40 = 0;\n                VAR_41 = 0xFF;\n                VAR_22 = -1;\n                VAR_23 = argtoll(VAR_6[0]);\n                VAR_42 = argtoll(VAR_6[1]);\n                VAR_43 = -1;\n            } else if (VAR_8 == 7) {\n                /* COMMENT_16 */\n                VAR_39 = argtoi(VAR_6[0]);\n                VAR_40 = argtoi(VAR_6[1]);\n                VAR_41 = argtoi(VAR_6[2]);\n                VAR_22 = argtoll(VAR_6[3]);\n                VAR_23 = argtoll(VAR_6[4]);\n                VAR_42 = argtoll(VAR_6[5]);\n                VAR_43 = argtoll(VAR_6[6]);\n            } else\n                continue;\n            if (VAR_22 == -1 && VAR_43 == -1) {\n                VAR_22 = 0;\n                VAR_43 = VAR_0->state.event->Duration;\n                VAR_42 = VAR_43 - VAR_42;\n            }\n            if ((VAR_0->state.parsed_tags & VAR_44) == 0) {\n                VAR_0->state.fade =\n                    interpolate_alpha(VAR_0->time -\n                            VAR_0->state.event->Start, VAR_22, VAR_23,\n                            VAR_42, VAR_43, VAR_39, VAR_40, VAR_41);\n                VAR_0->state.parsed_tags |= VAR_44;\n            }\n        } else if (complex_tag(\"org\")) {\n            double VAR_36, VAR_37;\n            if (VAR_8 == 2) {\n                VAR_36 = argtod(VAR_6[0]);\n                VAR_37 = argtod(VAR_6[1]);\n            } else\n                continue;\n            if (!VAR_0->state.have_origin) {\n                VAR_0->state.org_x = VAR_36;\n                VAR_0->state.org_y = VAR_37;\n                VAR_0->state.have_origin = 1;\n                VAR_0->state.detect_collisions = 0;\n            }\n        } else if (complex_tag(\"t\")) {\n            double VAR_45;\n            int VAR_46 = VAR_8 - 1;\n            long long VAR_22, VAR_23, VAR_25, VAR_24;\n            double VAR_28;\n            if (VAR_46 == 3) {\n                VAR_22 = argtoll(VAR_6[0]);\n                VAR_23 = argtoll(VAR_6[1]);\n                VAR_45 = argtod(VAR_6[2]);\n            } else if (VAR_46 == 2) {\n                VAR_22 = argtoll(VAR_6[0]);\n                VAR_23 = argtoll(VAR_6[1]);\n                VAR_45 = 1.;\n            } else if (VAR_46 == 1) {\n                VAR_22 = 0;\n                VAR_23 = 0;\n                VAR_45 = argtod(VAR_6[0]);\n            } else if (VAR_46 == 0) {\n                VAR_22 = 0;\n                VAR_23 = 0;\n                VAR_45 = 1.;\n            } else\n                continue;\n            VAR_0->state.detect_collisions = 0;\n            if (VAR_23 == 0)\n                VAR_23 = VAR_0->state.event->Duration;\n            VAR_24 = VAR_23 - VAR_22;\n            VAR_25 = VAR_0->time - VAR_0->state.event->Start;        /* COMMENT_17 */\n            if (VAR_25 <= VAR_22)\n                VAR_28 = 0.;\n            else if (VAR_25 >= VAR_23)\n                VAR_28 = 1.;\n            else {\n                assert(VAR_24 != 0.);\n                VAR_28 = pow(((double) (VAR_25 - VAR_22)) / VAR_24, VAR_45);\n            }\n            VAR_1 = VAR_6[VAR_46].start;\n            VAR_1 = parse_tags(VAR_0, VAR_1, VAR_6[VAR_46].end, VAR_28);    /* COMMENT_18 */\n        } else if (complex_tag(\"clip\")) {\n            if (VAR_8 == 4) {\n                int VAR_13, VAR_14, VAR_15, VAR_16;\n                VAR_13 = argtoi(VAR_6[0]);\n                VAR_14 = argtoi(VAR_6[1]);\n                VAR_15 = argtoi(VAR_6[2]);\n                VAR_16 = argtoi(VAR_6[3]);\n                VAR_0->state.clip_x0 =\n                    VAR_0->state.clip_x0 * (1 - VAR_3) + VAR_13 * VAR_3;\n                VAR_0->state.clip_x1 =\n                    VAR_0->state.clip_x1 * (1 - VAR_3) + VAR_15 * VAR_3;\n                VAR_0->state.clip_y0 =\n                    VAR_0->state.clip_y0 * (1 - VAR_3) + VAR_14 * VAR_3;\n                VAR_0->state.clip_y1 =\n                    VAR_0->state.clip_y1 * (1 - VAR_3) + VAR_16 * VAR_3;\n                VAR_0->state.clip_mode = 0;\n            } else if (!VAR_0->state.clip_drawing) {\n                if (parse_vector_clip(VAR_0, VAR_6, VAR_8))\n                    VAR_0->state.clip_drawing_mode = 0;\n            }\n        } else if (tag(\"c\") || tag(\"1c\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_color_tag(VAR_6->start);\n                change_color(&VAR_0->state.c[0], VAR_12, VAR_3);\n            } else\n                change_color(&VAR_0->state.c[0],\n                             VAR_0->state.style->PrimaryColour, 1);\n        } else if (tag(\"2c\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_color_tag(VAR_6->start);\n                change_color(&VAR_0->state.c[1], VAR_12, VAR_3);\n            } else\n                change_color(&VAR_0->state.c[1],\n                             VAR_0->state.style->SecondaryColour, 1);\n        } else if (tag(\"3c\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_color_tag(VAR_6->start);\n                change_color(&VAR_0->state.c[2], VAR_12, VAR_3);\n            } else\n                change_color(&VAR_0->state.c[2],\n                             VAR_0->state.style->OutlineColour, 1);\n        } else if (tag(\"4c\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_color_tag(VAR_6->start);\n                change_color(&VAR_0->state.c[3], VAR_12, VAR_3);\n            } else\n                change_color(&VAR_0->state.c[3],\n                             VAR_0->state.style->BackColour, 1);\n        } else if (tag(\"1a\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_alpha_tag(VAR_6->start);\n                change_alpha(&VAR_0->state.c[0], VAR_12, VAR_3);\n            } else\n                change_alpha(&VAR_0->state.c[0],\n                             _a(VAR_0->state.style->PrimaryColour), 1);\n        } else if (tag(\"2a\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_alpha_tag(VAR_6->start);\n                change_alpha(&VAR_0->state.c[1], VAR_12, VAR_3);\n            } else\n                change_alpha(&VAR_0->state.c[1],\n                             _a(VAR_0->state.style->SecondaryColour), 1);\n        } else if (tag(\"3a\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_alpha_tag(VAR_6->start);\n                change_alpha(&VAR_0->state.c[2], VAR_12, VAR_3);\n            } else\n                change_alpha(&VAR_0->state.c[2],\n                             _a(VAR_0->state.style->OutlineColour), 1);\n        } else if (tag(\"4a\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_alpha_tag(VAR_6->start);\n                change_alpha(&VAR_0->state.c[3], VAR_12, VAR_3);\n            } else\n                change_alpha(&VAR_0->state.c[3],\n                             _a(VAR_0->state.style->BackColour), 1);\n        } else if (tag(\"r\")) {\n            if (VAR_8) {\n                int VAR_47 = VAR_6->end - VAR_6->start;\n                reset_render_context(VAR_0,\n                        lookup_style_strict(VAR_0->track, VAR_6->start, VAR_47));\n            } else\n                reset_render_context(VAR_0, NULL);\n        } else if (tag(\"be\")) {\n            double VAR_48;\n            if (VAR_8) {\n                int VAR_12;\n                VAR_48 = argtod(*VAR_6);\n                /* COMMENT_19 */\n                VAR_12 = (int) (VAR_0->state.be * (1 - VAR_3) + VAR_48 * VAR_3 + 0.5);\n                /* COMMENT_20 */\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n                VAR_12 = (VAR_12 > VAR_49) ? VAR_49 : VAR_12;\n                VAR_0->state.be = VAR_12;\n            } else\n                VAR_0->state.be = 0;\n        } else if (tag(\"b\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 == 0 || VAR_12 == 1 || VAR_12 >= 100))\n                VAR_12 = VAR_0->state.style->Bold;\n            VAR_0->state.bold = VAR_12;\n            update_font(VAR_0);\n        } else if (tag(\"i\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 == 0 || VAR_12 == 1))\n                VAR_12 = VAR_0->state.style->Italic;\n            VAR_0->state.italic = VAR_12;\n            update_font(VAR_0);\n        } else if (tag(\"kf\") || tag(\"K\")) {\n            double VAR_12 = 100;\n            if (VAR_8)\n                VAR_12 = argtod(*VAR_6);\n            VAR_0->state.effect_type = VAR_50;\n            if (VAR_0->state.effect_timing)\n                VAR_0->state.effect_skip_timing +=\n                    VAR_0->state.effect_timing;\n            VAR_0->state.effect_timing = VAR_12 * 10;\n        } else if (tag(\"ko\")) {\n            double VAR_12 = 100;\n            if (VAR_8)\n                VAR_12 = argtod(*VAR_6);\n            VAR_0->state.effect_type = VAR_51;\n            if (VAR_0->state.effect_timing)\n                VAR_0->state.effect_skip_timing +=\n                    VAR_0->state.effect_timing;\n            VAR_0->state.effect_timing = VAR_12 * 10;\n        } else if (tag(\"k\")) {\n            double VAR_12 = 100;\n            if (VAR_8)\n                VAR_12 = argtod(*VAR_6);\n            VAR_0->state.effect_type = VAR_52;\n            if (VAR_0->state.effect_timing)\n                VAR_0->state.effect_skip_timing +=\n                    VAR_0->state.effect_timing;\n            VAR_0->state.effect_timing = VAR_12 * 10;\n        } else if (tag(\"shad\")) {\n            double VAR_12, VAR_18, VAR_19;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_18 = VAR_0->state.shadow_x * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_19 = VAR_0->state.shadow_y * (1 - VAR_3) + VAR_12 * VAR_3;\n                /* COMMENT_21 */\n                VAR_18 = (VAR_18 < 0) ? 0 : VAR_18;\n                VAR_19 = (VAR_19 < 0) ? 0 : VAR_19;\n            } else\n                VAR_18 = VAR_19 = VAR_0->state.style->Shadow;\n            VAR_0->state.shadow_x = VAR_18;\n            VAR_0->state.shadow_y = VAR_19;\n        } else if (tag(\"s\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 == 0 || VAR_12 == 1))\n                VAR_12 = VAR_0->state.style->StrikeOut;\n            if (VAR_12)\n                VAR_0->state.flags |= VAR_53;\n            else\n                VAR_0->state.flags &= ~VAR_53;\n        } else if (tag(\"u\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 == 0 || VAR_12 == 1))\n                VAR_12 = VAR_0->state.style->Underline;\n            if (VAR_12)\n                VAR_0->state.flags |= VAR_54;\n            else\n                VAR_0->state.flags &= ~VAR_54;\n        } else if (tag(\"pbo\")) {\n            double VAR_12 = argtod(*VAR_6);\n            VAR_0->state.pbo = VAR_12;\n        } else if (tag(\"p\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            VAR_0->state.drawing_scale = VAR_12;\n        } else if (tag(\"q\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 >= 0 && VAR_12 <= 3))\n                VAR_12 = VAR_0->track->WrapStyle;\n            VAR_0->state.wrap_style = VAR_12;\n        } else if (tag(\"fe\")) {\n            int VAR_12;\n            if (VAR_8)\n                VAR_12 = argtoi(*VAR_6);\n            else\n                VAR_12 = VAR_0->state.style->Encoding;\n            VAR_0->state.font_encoding = VAR_12;\n        }\n    }\n\n    return VAR_1;\n}",
  "func_graph_path_before": "libass/6835731c2fe4164a0c50bc91d12c43b2a2b4e/ass_parse.c/vul/before/0.json",
  "func": "char *parse_tags(ASS_Renderer *render_priv, char *p, char *end, double pwr)\n{\n    for (char *q; p < end; p = q) {\n        while (*p != '\\\\' && p != end)\n            ++p;\n        if (*p != '\\\\')\n            break;\n        ++p;\n        if (p != end)\n            skip_spaces(&p);\n\n        q = p;\n        while (*q != '(' && *q != '\\\\' && q != end)\n            ++q;\n        if (q == p)\n            continue;\n\n        char *name_end = q;\n\n        // Store one extra element to be able to detect excess arguments\n        struct arg args[MAX_VALID_NARGS + 1];\n        int nargs = 0;\n        for (int i = 0; i <= MAX_VALID_NARGS; ++i)\n            args[i].start = args[i].end = \"\";\n\n        // Split parenthesized arguments. Do this for all tags and before\n        // any non-parenthesized argument because that's what VSFilter does.\n        if (*q == '(') {\n            ++q;\n            while (1) {\n                if (q != end)\n                    skip_spaces(&q);\n\n                // Split on commas. If there is a backslash, ignore any\n                // commas following it and lump everything starting from\n                // the last comma, through the backslash and all the way\n                // to the end of the argument string into a single argument.\n\n                char *r = q;\n                while (*r != ',' && *r != '\\\\' && *r != ')' && r != end)\n                    ++r;\n\n                if (*r == ',') {\n                    push_arg(args, &nargs, q, r);\n                    q = r + 1;\n                } else {\n                    // Swallow the rest of the parenthesized string. This could\n                    // be either a backslash-argument or simply the last argument.\n                    while (*r != ')' && r != end)\n                        ++r;\n                    push_arg(args, &nargs, q, r);\n                    q = r;\n                    // The closing parenthesis could be missing.\n                    if (q != end)\n                        ++q;\n                    break;\n                }\n            }\n        }\n\n#define tag(name) (mystrcmp(&p, (name)) && (push_arg(args, &nargs, p, name_end), 1))\n#define complex_tag(name) mystrcmp(&p, (name))\n\n        // New tags introduced in vsfilter 2.39\n        if (tag(\"xbord\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.border_x * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->Outline;\n            render_priv->state.border_x = val;\n        } else if (tag(\"ybord\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.border_y * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->Outline;\n            render_priv->state.border_y = val;\n        } else if (tag(\"xshad\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;\n            } else\n                val = render_priv->state.style->Shadow;\n            render_priv->state.shadow_x = val;\n        } else if (tag(\"yshad\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;\n            } else\n                val = render_priv->state.style->Shadow;\n            render_priv->state.shadow_y = val;\n        } else if (tag(\"fax\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.fax =\n                    val * pwr + render_priv->state.fax * (1 - pwr);\n            } else\n                render_priv->state.fax = 0.;\n        } else if (tag(\"fay\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.fay =\n                    val * pwr + render_priv->state.fay * (1 - pwr);\n            } else\n                render_priv->state.fay = 0.;\n        } else if (complex_tag(\"iclip\")) {\n            if (nargs == 4) {\n                int x0, y0, x1, y1;\n                x0 = argtoi(args[0]);\n                y0 = argtoi(args[1]);\n                x1 = argtoi(args[2]);\n                y1 = argtoi(args[3]);\n                render_priv->state.clip_x0 =\n                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;\n                render_priv->state.clip_x1 =\n                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;\n                render_priv->state.clip_y0 =\n                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;\n                render_priv->state.clip_y1 =\n                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;\n                render_priv->state.clip_mode = 1;\n            } else if (!render_priv->state.clip_drawing) {\n                if (parse_vector_clip(render_priv, args, nargs))\n                    render_priv->state.clip_drawing_mode = 1;\n            }\n        } else if (tag(\"blur\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.blur * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n                val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;\n                render_priv->state.blur = val;\n            } else\n                render_priv->state.blur = 0.0;\n            // ASS standard tags\n        } else if (tag(\"fscx\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args) / 100;\n                val = render_priv->state.scale_x * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->ScaleX;\n            render_priv->state.scale_x = val;\n        } else if (tag(\"fscy\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args) / 100;\n                val = render_priv->state.scale_y * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->ScaleY;\n            render_priv->state.scale_y = val;\n        } else if (tag(\"fsc\")) {\n            render_priv->state.scale_x = render_priv->state.style->ScaleX;\n            render_priv->state.scale_y = render_priv->state.style->ScaleY;\n        } else if (tag(\"fsp\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.hspacing =\n                    render_priv->state.hspacing * (1 - pwr) + val * pwr;\n            } else\n                render_priv->state.hspacing = render_priv->state.style->Spacing;\n        } else if (tag(\"fs\")) {\n            double val = 0;\n            if (nargs) {\n                val = argtod(*args);\n                if (*args->start == '+' || *args->start == '-')\n                    val = render_priv->state.font_size * (1 + pwr * val / 10);\n                else\n                    val = render_priv->state.font_size * (1 - pwr) + val * pwr;\n            }\n            if (val <= 0)\n                val = render_priv->state.style->FontSize;\n            if (render_priv->state.font)\n                change_font_size(render_priv, val);\n        } else if (tag(\"bord\")) {\n            double val, xval, yval;\n            if (nargs) {\n                val = argtod(*args);\n                xval = render_priv->state.border_x * (1 - pwr) + val * pwr;\n                yval = render_priv->state.border_y * (1 - pwr) + val * pwr;\n                xval = (xval < 0) ? 0 : xval;\n                yval = (yval < 0) ? 0 : yval;\n            } else\n                xval = yval = render_priv->state.style->Outline;\n            render_priv->state.border_x = xval;\n            render_priv->state.border_y = yval;\n        } else if (complex_tag(\"move\")) {\n            double x1, x2, y1, y2;\n            long long t1, t2, delta_t, t;\n            double x, y;\n            double k;\n            if (nargs == 4 || nargs == 6) {\n                x1 = argtod(args[0]);\n                y1 = argtod(args[1]);\n                x2 = argtod(args[2]);\n                y2 = argtod(args[3]);\n                t1 = t2 = 0;\n                if (nargs == 6) {\n                    t1 = argtoll(args[4]);\n                    t2 = argtoll(args[5]);\n                    if (t1 > t2) {\n                        long long tmp = t2;\n                        t2 = t1;\n                        t1 = tmp;\n                    }\n                }\n            } else\n                continue;\n            if (t1 <= 0 && t2 <= 0) {\n                t1 = 0;\n                t2 = render_priv->state.event->Duration;\n            }\n            delta_t = t2 - t1;\n            t = render_priv->time - render_priv->state.event->Start;\n            if (t <= t1)\n                k = 0.;\n            else if (t >= t2)\n                k = 1.;\n            else\n                k = ((double) (t - t1)) / delta_t;\n            x = k * (x2 - x1) + x1;\n            y = k * (y2 - y1) + y1;\n            if (render_priv->state.evt_type != EVENT_POSITIONED) {\n                render_priv->state.pos_x = x;\n                render_priv->state.pos_y = y;\n                render_priv->state.detect_collisions = 0;\n                render_priv->state.evt_type = EVENT_POSITIONED;\n            }\n        } else if (tag(\"frx\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.frx =\n                    val * pwr + render_priv->state.frx * (1 - pwr);\n            } else\n                render_priv->state.frx = 0.;\n        } else if (tag(\"fry\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.fry =\n                    val * pwr + render_priv->state.fry * (1 - pwr);\n            } else\n                render_priv->state.fry = 0.;\n        } else if (tag(\"frz\") || tag(\"fr\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.frz =\n                    val * pwr + render_priv->state.frz * (1 - pwr);\n            } else\n                render_priv->state.frz =\n                    M_PI * render_priv->state.style->Angle / 180.;\n        } else if (tag(\"fn\")) {\n            char *family;\n            char *start = args->start;\n            if (nargs && strncmp(start, \"0\", args->end - start)) {\n                skip_spaces(&start);\n                family = strndup(start, args->end - start);\n            } else\n                family = strdup(render_priv->state.style->FontName);\n            free(render_priv->state.family);\n            render_priv->state.family = family;\n            update_font(render_priv);\n        } else if (tag(\"alpha\")) {\n            int i;\n            if (nargs) {\n                int32_t a = parse_alpha_tag(args->start);\n                for (i = 0; i < 4; ++i)\n                    change_alpha(&render_priv->state.c[i], a, pwr);\n            } else {\n                change_alpha(&render_priv->state.c[0],\n                             _a(render_priv->state.style->PrimaryColour), 1);\n                change_alpha(&render_priv->state.c[1],\n                             _a(render_priv->state.style->SecondaryColour), 1);\n                change_alpha(&render_priv->state.c[2],\n                             _a(render_priv->state.style->OutlineColour), 1);\n                change_alpha(&render_priv->state.c[3],\n                             _a(render_priv->state.style->BackColour), 1);\n            }\n            // FIXME: simplify\n        } else if (tag(\"an\")) {\n            int val = argtoi(*args);\n            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {\n                if (val >= 1 && val <= 9)\n                    render_priv->state.alignment = numpad2align(val);\n                else\n                    render_priv->state.alignment =\n                        render_priv->state.style->Alignment;\n                render_priv->state.parsed_tags |= PARSED_A;\n            }\n        } else if (tag(\"a\")) {\n            int val = argtoi(*args);\n            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {\n                if (val >= 1 && val <= 11)\n                    // take care of a vsfilter quirk:\n                    // handle illegal \\a8 and \\a4 like \\a5\n                    render_priv->state.alignment = ((val & 3) == 0) ? 5 : val;\n                else\n                    render_priv->state.alignment =\n                        render_priv->state.style->Alignment;\n                render_priv->state.parsed_tags |= PARSED_A;\n            }\n        } else if (complex_tag(\"pos\")) {\n            double v1, v2;\n            if (nargs == 2) {\n                v1 = argtod(args[0]);\n                v2 = argtod(args[1]);\n            } else\n                continue;\n            if (render_priv->state.evt_type == EVENT_POSITIONED) {\n                ass_msg(render_priv->library, MSGL_V, \"Subtitle has a new \\\\pos \"\n                       \"after \\\\move or \\\\pos, ignoring\");\n            } else {\n                render_priv->state.evt_type = EVENT_POSITIONED;\n                render_priv->state.detect_collisions = 0;\n                render_priv->state.pos_x = v1;\n                render_priv->state.pos_y = v2;\n            }\n        } else if (complex_tag(\"fade\") || complex_tag(\"fad\")) {\n            int a1, a2, a3;\n            long long t1, t2, t3, t4;\n            if (nargs == 2) {\n                // 2-argument version (\\fad, according to specs)\n                a1 = 0xFF;\n                a2 = 0;\n                a3 = 0xFF;\n                t1 = -1;\n                t2 = argtoll(args[0]);\n                t3 = argtoll(args[1]);\n                t4 = -1;\n            } else if (nargs == 7) {\n                // 7-argument version (\\fade)\n                a1 = argtoi(args[0]);\n                a2 = argtoi(args[1]);\n                a3 = argtoi(args[2]);\n                t1 = argtoll(args[3]);\n                t2 = argtoll(args[4]);\n                t3 = argtoll(args[5]);\n                t4 = argtoll(args[6]);\n            } else\n                continue;\n            if (t1 == -1 && t4 == -1) {\n                t1 = 0;\n                t4 = render_priv->state.event->Duration;\n                t3 = t4 - t3;\n            }\n            if ((render_priv->state.parsed_tags & PARSED_FADE) == 0) {\n                render_priv->state.fade =\n                    interpolate_alpha(render_priv->time -\n                            render_priv->state.event->Start, t1, t2,\n                            t3, t4, a1, a2, a3);\n                render_priv->state.parsed_tags |= PARSED_FADE;\n            }\n        } else if (complex_tag(\"org\")) {\n            double v1, v2;\n            if (nargs == 2) {\n                v1 = argtod(args[0]);\n                v2 = argtod(args[1]);\n            } else\n                continue;\n            if (!render_priv->state.have_origin) {\n                render_priv->state.org_x = v1;\n                render_priv->state.org_y = v2;\n                render_priv->state.have_origin = 1;\n                render_priv->state.detect_collisions = 0;\n            }\n        } else if (complex_tag(\"t\")) {\n            double accel;\n            int cnt = nargs - 1;\n            long long t1, t2, t, delta_t;\n            double k;\n            if (cnt == 3) {\n                t1 = argtoll(args[0]);\n                t2 = argtoll(args[1]);\n                accel = argtod(args[2]);\n            } else if (cnt == 2) {\n                t1 = argtoll(args[0]);\n                t2 = argtoll(args[1]);\n                accel = 1.;\n            } else if (cnt == 1) {\n                t1 = 0;\n                t2 = 0;\n                accel = argtod(args[0]);\n            } else if (cnt == 0) {\n                t1 = 0;\n                t2 = 0;\n                accel = 1.;\n            } else\n                continue;\n            render_priv->state.detect_collisions = 0;\n            if (t2 == 0)\n                t2 = render_priv->state.event->Duration;\n            delta_t = t2 - t1;\n            t = render_priv->time - render_priv->state.event->Start;        // FIXME: move to render_context\n            if (t <= t1)\n                k = 0.;\n            else if (t >= t2)\n                k = 1.;\n            else {\n                assert(delta_t != 0.);\n                k = pow(((double) (t - t1)) / delta_t, accel);\n            }\n            p = args[cnt].start;\n            if (args[cnt].end < end) {\n                p = parse_tags(render_priv, p, args[cnt].end, k);\n            } else {\n                assert(q == end);\n                // No other tags can possibly follow this \\t tag,\n                // so we don't need to restore pwr after parsing \\t.\n                // The recursive call is now essentially a tail call,\n                // so optimize it away.\n                pwr = k;\n                q = p;\n            }\n        } else if (complex_tag(\"clip\")) {\n            if (nargs == 4) {\n                int x0, y0, x1, y1;\n                x0 = argtoi(args[0]);\n                y0 = argtoi(args[1]);\n                x1 = argtoi(args[2]);\n                y1 = argtoi(args[3]);\n                render_priv->state.clip_x0 =\n                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;\n                render_priv->state.clip_x1 =\n                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;\n                render_priv->state.clip_y0 =\n                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;\n                render_priv->state.clip_y1 =\n                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;\n                render_priv->state.clip_mode = 0;\n            } else if (!render_priv->state.clip_drawing) {\n                if (parse_vector_clip(render_priv, args, nargs))\n                    render_priv->state.clip_drawing_mode = 0;\n            }\n        } else if (tag(\"c\") || tag(\"1c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[0], val, pwr);\n            } else\n                change_color(&render_priv->state.c[0],\n                             render_priv->state.style->PrimaryColour, 1);\n        } else if (tag(\"2c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[1], val, pwr);\n            } else\n                change_color(&render_priv->state.c[1],\n                             render_priv->state.style->SecondaryColour, 1);\n        } else if (tag(\"3c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[2], val, pwr);\n            } else\n                change_color(&render_priv->state.c[2],\n                             render_priv->state.style->OutlineColour, 1);\n        } else if (tag(\"4c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[3], val, pwr);\n            } else\n                change_color(&render_priv->state.c[3],\n                             render_priv->state.style->BackColour, 1);\n        } else if (tag(\"1a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[0], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[0],\n                             _a(render_priv->state.style->PrimaryColour), 1);\n        } else if (tag(\"2a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[1], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[1],\n                             _a(render_priv->state.style->SecondaryColour), 1);\n        } else if (tag(\"3a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[2], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[2],\n                             _a(render_priv->state.style->OutlineColour), 1);\n        } else if (tag(\"4a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[3], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[3],\n                             _a(render_priv->state.style->BackColour), 1);\n        } else if (tag(\"r\")) {\n            if (nargs) {\n                int len = args->end - args->start;\n                reset_render_context(render_priv,\n                        lookup_style_strict(render_priv->track, args->start, len));\n            } else\n                reset_render_context(render_priv, NULL);\n        } else if (tag(\"be\")) {\n            double dval;\n            if (nargs) {\n                int val;\n                dval = argtod(*args);\n                // VSFilter always adds +0.5, even if the value is negative\n                val = (int) (render_priv->state.be * (1 - pwr) + dval * pwr + 0.5);\n                // Clamp to a safe upper limit, since high values need excessive CPU\n                val = (val < 0) ? 0 : val;\n                val = (val > MAX_BE) ? MAX_BE : val;\n                render_priv->state.be = val;\n            } else\n                render_priv->state.be = 0;\n        } else if (tag(\"b\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1 || val >= 100))\n                val = render_priv->state.style->Bold;\n            render_priv->state.bold = val;\n            update_font(render_priv);\n        } else if (tag(\"i\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->Italic;\n            render_priv->state.italic = val;\n            update_font(render_priv);\n        } else if (tag(\"kf\") || tag(\"K\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE_KF;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"ko\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE_KO;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"k\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"shad\")) {\n            double val, xval, yval;\n            if (nargs) {\n                val = argtod(*args);\n                xval = render_priv->state.shadow_x * (1 - pwr) + val * pwr;\n                yval = render_priv->state.shadow_y * (1 - pwr) + val * pwr;\n                // VSFilter compatibility: clip for \\shad but not for \\[xy]shad\n                xval = (xval < 0) ? 0 : xval;\n                yval = (yval < 0) ? 0 : yval;\n            } else\n                xval = yval = render_priv->state.style->Shadow;\n            render_priv->state.shadow_x = xval;\n            render_priv->state.shadow_y = yval;\n        } else if (tag(\"s\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->StrikeOut;\n            if (val)\n                render_priv->state.flags |= DECO_STRIKETHROUGH;\n            else\n                render_priv->state.flags &= ~DECO_STRIKETHROUGH;\n        } else if (tag(\"u\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->Underline;\n            if (val)\n                render_priv->state.flags |= DECO_UNDERLINE;\n            else\n                render_priv->state.flags &= ~DECO_UNDERLINE;\n        } else if (tag(\"pbo\")) {\n            double val = argtod(*args);\n            render_priv->state.pbo = val;\n        } else if (tag(\"p\")) {\n            int val = argtoi(*args);\n            val = (val < 0) ? 0 : val;\n            render_priv->state.drawing_scale = val;\n        } else if (tag(\"q\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val >= 0 && val <= 3))\n                val = render_priv->track->WrapStyle;\n            render_priv->state.wrap_style = val;\n        } else if (tag(\"fe\")) {\n            int val;\n            if (nargs)\n                val = argtoi(*args);\n            else\n                val = render_priv->state.style->Encoding;\n            render_priv->state.font_encoding = val;\n        }\n    }\n\n    return p;\n}",
  "abstract_func": "char *parse_tags(ASS_Renderer *VAR_0, char *VAR_1, char *VAR_2, double VAR_3)\n{\n    for (char *VAR_4; VAR_1 < VAR_2; VAR_1 = VAR_4) {\n        while (*VAR_1 != '\\\\' && VAR_1 != VAR_2)\n            ++VAR_1;\n        if (*VAR_1 != '\\\\')\n            break;\n        ++VAR_1;\n        if (VAR_1 != VAR_2)\n            skip_spaces(&VAR_1);\n\n        VAR_4 = VAR_1;\n        while (*VAR_4 != '(' && *VAR_4 != '\\\\' && VAR_4 != VAR_2)\n            ++VAR_4;\n        if (VAR_4 == VAR_1)\n            continue;\n\n        char *VAR_5 = VAR_4;\n\n        /* COMMENT_0 */\n        struct arg VAR_6[VAR_7 + 1];\n        int VAR_8 = 0;\n        for (int VAR_9 = 0; VAR_9 <= VAR_7; ++VAR_9)\n            VAR_6[VAR_9].start = VAR_6[VAR_9].end = \"\";\n\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        if (*VAR_4 == '(') {\n            ++VAR_4;\n            while (1) {\n                if (VAR_4 != VAR_2)\n                    skip_spaces(&VAR_4);\n\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n\n                char *VAR_10 = VAR_4;\n                while (*VAR_10 != ',' && *VAR_10 != '\\\\' && *VAR_10 != ')' && VAR_10 != VAR_2)\n                    ++VAR_10;\n\n                if (*VAR_10 == ',') {\n                    push_arg(VAR_6, &VAR_8, VAR_4, VAR_10);\n                    VAR_4 = VAR_10 + 1;\n                } else {\n                    /* COMMENT_7 */\n                    /* COMMENT_8 */\n                    while (*VAR_10 != ')' && VAR_10 != VAR_2)\n                        ++VAR_10;\n                    push_arg(VAR_6, &VAR_8, VAR_4, VAR_10);\n                    VAR_4 = VAR_10;\n                    /* COMMENT_9 */\n                    if (VAR_4 != VAR_2)\n                        ++VAR_4;\n                    break;\n                }\n            }\n        }\n\n#define tag(VAR_11) (mystrcmp(&p, (name)) && (push_arg(args, &nargs, p, name_end), 1))\n#define complex_tag(VAR_11) mystrcmp(&p, (name))\n\n        /* COMMENT_10 */\n        if (tag(\"xbord\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.border_x * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            } else\n                VAR_12 = VAR_0->state.style->Outline;\n            VAR_0->state.border_x = VAR_12;\n        } else if (tag(\"ybord\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.border_y * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            } else\n                VAR_12 = VAR_0->state.style->Outline;\n            VAR_0->state.border_y = VAR_12;\n        } else if (tag(\"xshad\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.shadow_x * (1 - VAR_3) + VAR_12 * VAR_3;\n            } else\n                VAR_12 = VAR_0->state.style->Shadow;\n            VAR_0->state.shadow_x = VAR_12;\n        } else if (tag(\"yshad\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.shadow_y * (1 - VAR_3) + VAR_12 * VAR_3;\n            } else\n                VAR_12 = VAR_0->state.style->Shadow;\n            VAR_0->state.shadow_y = VAR_12;\n        } else if (tag(\"fax\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_0->state.fax =\n                    VAR_12 * VAR_3 + VAR_0->state.fax * (1 - VAR_3);\n            } else\n                VAR_0->state.fax = 0.;\n        } else if (tag(\"fay\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_0->state.fay =\n                    VAR_12 * VAR_3 + VAR_0->state.fay * (1 - VAR_3);\n            } else\n                VAR_0->state.fay = 0.;\n        } else if (complex_tag(\"iclip\")) {\n            if (VAR_8 == 4) {\n                int VAR_13, VAR_14, VAR_15, VAR_16;\n                VAR_13 = argtoi(VAR_6[0]);\n                VAR_14 = argtoi(VAR_6[1]);\n                VAR_15 = argtoi(VAR_6[2]);\n                VAR_16 = argtoi(VAR_6[3]);\n                VAR_0->state.clip_x0 =\n                    VAR_0->state.clip_x0 * (1 - VAR_3) + VAR_13 * VAR_3;\n                VAR_0->state.clip_x1 =\n                    VAR_0->state.clip_x1 * (1 - VAR_3) + VAR_15 * VAR_3;\n                VAR_0->state.clip_y0 =\n                    VAR_0->state.clip_y0 * (1 - VAR_3) + VAR_14 * VAR_3;\n                VAR_0->state.clip_y1 =\n                    VAR_0->state.clip_y1 * (1 - VAR_3) + VAR_16 * VAR_3;\n                VAR_0->state.clip_mode = 1;\n            } else if (!VAR_0->state.clip_drawing) {\n                if (parse_vector_clip(VAR_0, VAR_6, VAR_8))\n                    VAR_0->state.clip_drawing_mode = 1;\n            }\n        } else if (tag(\"blur\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 = VAR_0->state.blur * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n                VAR_12 = (VAR_12 > VAR_17) ? VAR_17 : VAR_12;\n                VAR_0->state.blur = VAR_12;\n            } else\n                VAR_0->state.blur = 0.0;\n            /* COMMENT_11 */\n        } else if (tag(\"fscx\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6) / 100;\n                VAR_12 = VAR_0->state.scale_x * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            } else\n                VAR_12 = VAR_0->state.style->ScaleX;\n            VAR_0->state.scale_x = VAR_12;\n        } else if (tag(\"fscy\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6) / 100;\n                VAR_12 = VAR_0->state.scale_y * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            } else\n                VAR_12 = VAR_0->state.style->ScaleY;\n            VAR_0->state.scale_y = VAR_12;\n        } else if (tag(\"fsc\")) {\n            VAR_0->state.scale_x = VAR_0->state.style->ScaleX;\n            VAR_0->state.scale_y = VAR_0->state.style->ScaleY;\n        } else if (tag(\"fsp\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_0->state.hspacing =\n                    VAR_0->state.hspacing * (1 - VAR_3) + VAR_12 * VAR_3;\n            } else\n                VAR_0->state.hspacing = VAR_0->state.style->Spacing;\n        } else if (tag(\"fs\")) {\n            double VAR_12 = 0;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                if (*VAR_6->start == '+' || *VAR_6->start == '-')\n                    VAR_12 = VAR_0->state.font_size * (1 + VAR_3 * VAR_12 / 10);\n                else\n                    VAR_12 = VAR_0->state.font_size * (1 - VAR_3) + VAR_12 * VAR_3;\n            }\n            if (VAR_12 <= 0)\n                VAR_12 = VAR_0->state.style->FontSize;\n            if (VAR_0->state.font)\n                change_font_size(VAR_0, VAR_12);\n        } else if (tag(\"bord\")) {\n            double VAR_12, VAR_18, VAR_19;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_18 = VAR_0->state.border_x * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_19 = VAR_0->state.border_y * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_18 = (VAR_18 < 0) ? 0 : VAR_18;\n                VAR_19 = (VAR_19 < 0) ? 0 : VAR_19;\n            } else\n                VAR_18 = VAR_19 = VAR_0->state.style->Outline;\n            VAR_0->state.border_x = VAR_18;\n            VAR_0->state.border_y = VAR_19;\n        } else if (complex_tag(\"move\")) {\n            double VAR_15, VAR_20, VAR_16, VAR_21;\n            long long VAR_22, VAR_23, VAR_24, VAR_25;\n            double VAR_26, VAR_27;\n            double VAR_28;\n            if (VAR_8 == 4 || VAR_8 == 6) {\n                VAR_15 = argtod(VAR_6[0]);\n                VAR_16 = argtod(VAR_6[1]);\n                VAR_20 = argtod(VAR_6[2]);\n                VAR_21 = argtod(VAR_6[3]);\n                VAR_22 = VAR_23 = 0;\n                if (VAR_8 == 6) {\n                    VAR_22 = argtoll(VAR_6[4]);\n                    VAR_23 = argtoll(VAR_6[5]);\n                    if (VAR_22 > VAR_23) {\n                        long long VAR_29 = VAR_23;\n                        VAR_23 = VAR_22;\n                        VAR_22 = VAR_29;\n                    }\n                }\n            } else\n                continue;\n            if (VAR_22 <= 0 && VAR_23 <= 0) {\n                VAR_22 = 0;\n                VAR_23 = VAR_0->state.event->Duration;\n            }\n            VAR_24 = VAR_23 - VAR_22;\n            VAR_25 = VAR_0->time - VAR_0->state.event->Start;\n            if (VAR_25 <= VAR_22)\n                VAR_28 = 0.;\n            else if (VAR_25 >= VAR_23)\n                VAR_28 = 1.;\n            else\n                VAR_28 = ((double) (VAR_25 - VAR_22)) / VAR_24;\n            VAR_26 = VAR_28 * (VAR_20 - VAR_15) + VAR_15;\n            VAR_27 = VAR_28 * (VAR_21 - VAR_16) + VAR_16;\n            if (VAR_0->state.evt_type != VAR_30) {\n                VAR_0->state.pos_x = VAR_26;\n                VAR_0->state.pos_y = VAR_27;\n                VAR_0->state.detect_collisions = 0;\n                VAR_0->state.evt_type = VAR_30;\n            }\n        } else if (tag(\"frx\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 *= VAR_31 / 180;\n                VAR_0->state.frx =\n                    VAR_12 * VAR_3 + VAR_0->state.frx * (1 - VAR_3);\n            } else\n                VAR_0->state.frx = 0.;\n        } else if (tag(\"fry\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 *= VAR_31 / 180;\n                VAR_0->state.fry =\n                    VAR_12 * VAR_3 + VAR_0->state.fry * (1 - VAR_3);\n            } else\n                VAR_0->state.fry = 0.;\n        } else if (tag(\"frz\") || tag(\"fr\")) {\n            double VAR_12;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_12 *= VAR_31 / 180;\n                VAR_0->state.frz =\n                    VAR_12 * VAR_3 + VAR_0->state.frz * (1 - VAR_3);\n            } else\n                VAR_0->state.frz =\n                    VAR_31 * VAR_0->state.style->Angle / 180.;\n        } else if (tag(\"fn\")) {\n            char *VAR_32;\n            char *VAR_33 = VAR_6->start;\n            if (VAR_8 && strncmp(VAR_33, \"0\", VAR_6->end - VAR_33)) {\n                skip_spaces(&VAR_33);\n                VAR_32 = strndup(VAR_33, VAR_6->end - VAR_33);\n            } else\n                VAR_32 = strdup(VAR_0->state.style->FontName);\n            free(VAR_0->state.family);\n            VAR_0->state.family = VAR_32;\n            update_font(VAR_0);\n        } else if (tag(\"alpha\")) {\n            int VAR_9;\n            if (VAR_8) {\n                int32_t VAR_34 = parse_alpha_tag(VAR_6->start);\n                for (VAR_9 = 0; VAR_9 < 4; ++VAR_9)\n                    change_alpha(&VAR_0->state.c[VAR_9], VAR_34, VAR_3);\n            } else {\n                change_alpha(&VAR_0->state.c[0],\n                             _a(VAR_0->state.style->PrimaryColour), 1);\n                change_alpha(&VAR_0->state.c[1],\n                             _a(VAR_0->state.style->SecondaryColour), 1);\n                change_alpha(&VAR_0->state.c[2],\n                             _a(VAR_0->state.style->OutlineColour), 1);\n                change_alpha(&VAR_0->state.c[3],\n                             _a(VAR_0->state.style->BackColour), 1);\n            }\n            /* COMMENT_12 */\n        } else if (tag(\"an\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if ((VAR_0->state.parsed_tags & VAR_35) == 0) {\n                if (VAR_12 >= 1 && VAR_12 <= 9)\n                    VAR_0->state.alignment = numpad2align(VAR_12);\n                else\n                    VAR_0->state.alignment =\n                        VAR_0->state.style->Alignment;\n                VAR_0->state.parsed_tags |= VAR_35;\n            }\n        } else if (tag(\"a\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if ((VAR_0->state.parsed_tags & VAR_35) == 0) {\n                if (VAR_12 >= 1 && VAR_12 <= 11)\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    VAR_0->state.alignment = ((VAR_12 & 3) == 0) ? 5 : VAR_12;\n                else\n                    VAR_0->state.alignment =\n                        VAR_0->state.style->Alignment;\n                VAR_0->state.parsed_tags |= VAR_35;\n            }\n        } else if (complex_tag(\"pos\")) {\n            double VAR_36, VAR_37;\n            if (VAR_8 == 2) {\n                VAR_36 = argtod(VAR_6[0]);\n                VAR_37 = argtod(VAR_6[1]);\n            } else\n                continue;\n            if (VAR_0->state.evt_type == VAR_30) {\n                ass_msg(VAR_0->library, VAR_38, \"Subtitle has a new \\\\pos \"\n                       \"after \\\\move or \\\\pos, ignoring\");\n            } else {\n                VAR_0->state.evt_type = VAR_30;\n                VAR_0->state.detect_collisions = 0;\n                VAR_0->state.pos_x = VAR_36;\n                VAR_0->state.pos_y = VAR_37;\n            }\n        } else if (complex_tag(\"fade\") || complex_tag(\"fad\")) {\n            int VAR_39, VAR_40, VAR_41;\n            long long VAR_22, VAR_23, VAR_42, VAR_43;\n            if (VAR_8 == 2) {\n                /* COMMENT_15 */\n                VAR_39 = 0xFF;\n                VAR_40 = 0;\n                VAR_41 = 0xFF;\n                VAR_22 = -1;\n                VAR_23 = argtoll(VAR_6[0]);\n                VAR_42 = argtoll(VAR_6[1]);\n                VAR_43 = -1;\n            } else if (VAR_8 == 7) {\n                /* COMMENT_16 */\n                VAR_39 = argtoi(VAR_6[0]);\n                VAR_40 = argtoi(VAR_6[1]);\n                VAR_41 = argtoi(VAR_6[2]);\n                VAR_22 = argtoll(VAR_6[3]);\n                VAR_23 = argtoll(VAR_6[4]);\n                VAR_42 = argtoll(VAR_6[5]);\n                VAR_43 = argtoll(VAR_6[6]);\n            } else\n                continue;\n            if (VAR_22 == -1 && VAR_43 == -1) {\n                VAR_22 = 0;\n                VAR_43 = VAR_0->state.event->Duration;\n                VAR_42 = VAR_43 - VAR_42;\n            }\n            if ((VAR_0->state.parsed_tags & VAR_44) == 0) {\n                VAR_0->state.fade =\n                    interpolate_alpha(VAR_0->time -\n                            VAR_0->state.event->Start, VAR_22, VAR_23,\n                            VAR_42, VAR_43, VAR_39, VAR_40, VAR_41);\n                VAR_0->state.parsed_tags |= VAR_44;\n            }\n        } else if (complex_tag(\"org\")) {\n            double VAR_36, VAR_37;\n            if (VAR_8 == 2) {\n                VAR_36 = argtod(VAR_6[0]);\n                VAR_37 = argtod(VAR_6[1]);\n            } else\n                continue;\n            if (!VAR_0->state.have_origin) {\n                VAR_0->state.org_x = VAR_36;\n                VAR_0->state.org_y = VAR_37;\n                VAR_0->state.have_origin = 1;\n                VAR_0->state.detect_collisions = 0;\n            }\n        } else if (complex_tag(\"t\")) {\n            double VAR_45;\n            int VAR_46 = VAR_8 - 1;\n            long long VAR_22, VAR_23, VAR_25, VAR_24;\n            double VAR_28;\n            if (VAR_46 == 3) {\n                VAR_22 = argtoll(VAR_6[0]);\n                VAR_23 = argtoll(VAR_6[1]);\n                VAR_45 = argtod(VAR_6[2]);\n            } else if (VAR_46 == 2) {\n                VAR_22 = argtoll(VAR_6[0]);\n                VAR_23 = argtoll(VAR_6[1]);\n                VAR_45 = 1.;\n            } else if (VAR_46 == 1) {\n                VAR_22 = 0;\n                VAR_23 = 0;\n                VAR_45 = argtod(VAR_6[0]);\n            } else if (VAR_46 == 0) {\n                VAR_22 = 0;\n                VAR_23 = 0;\n                VAR_45 = 1.;\n            } else\n                continue;\n            VAR_0->state.detect_collisions = 0;\n            if (VAR_23 == 0)\n                VAR_23 = VAR_0->state.event->Duration;\n            VAR_24 = VAR_23 - VAR_22;\n            VAR_25 = VAR_0->time - VAR_0->state.event->Start;        /* COMMENT_17 */\n            if (VAR_25 <= VAR_22)\n                VAR_28 = 0.;\n            else if (VAR_25 >= VAR_23)\n                VAR_28 = 1.;\n            else {\n                assert(VAR_24 != 0.);\n                VAR_28 = pow(((double) (VAR_25 - VAR_22)) / VAR_24, VAR_45);\n            }\n            VAR_1 = VAR_6[VAR_46].start;\n            if (VAR_6[VAR_46].end < VAR_2) {\n                VAR_1 = parse_tags(VAR_0, VAR_1, VAR_6[VAR_46].end, VAR_28);\n            } else {\n                assert(VAR_4 == VAR_2);\n                /* COMMENT_18 */\n                /* COMMENT_19 */\n                /* COMMENT_20 */\n                /* COMMENT_21 */\n                VAR_3 = VAR_28;\n                VAR_4 = VAR_1;\n            }\n        } else if (complex_tag(\"clip\")) {\n            if (VAR_8 == 4) {\n                int VAR_13, VAR_14, VAR_15, VAR_16;\n                VAR_13 = argtoi(VAR_6[0]);\n                VAR_14 = argtoi(VAR_6[1]);\n                VAR_15 = argtoi(VAR_6[2]);\n                VAR_16 = argtoi(VAR_6[3]);\n                VAR_0->state.clip_x0 =\n                    VAR_0->state.clip_x0 * (1 - VAR_3) + VAR_13 * VAR_3;\n                VAR_0->state.clip_x1 =\n                    VAR_0->state.clip_x1 * (1 - VAR_3) + VAR_15 * VAR_3;\n                VAR_0->state.clip_y0 =\n                    VAR_0->state.clip_y0 * (1 - VAR_3) + VAR_14 * VAR_3;\n                VAR_0->state.clip_y1 =\n                    VAR_0->state.clip_y1 * (1 - VAR_3) + VAR_16 * VAR_3;\n                VAR_0->state.clip_mode = 0;\n            } else if (!VAR_0->state.clip_drawing) {\n                if (parse_vector_clip(VAR_0, VAR_6, VAR_8))\n                    VAR_0->state.clip_drawing_mode = 0;\n            }\n        } else if (tag(\"c\") || tag(\"1c\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_color_tag(VAR_6->start);\n                change_color(&VAR_0->state.c[0], VAR_12, VAR_3);\n            } else\n                change_color(&VAR_0->state.c[0],\n                             VAR_0->state.style->PrimaryColour, 1);\n        } else if (tag(\"2c\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_color_tag(VAR_6->start);\n                change_color(&VAR_0->state.c[1], VAR_12, VAR_3);\n            } else\n                change_color(&VAR_0->state.c[1],\n                             VAR_0->state.style->SecondaryColour, 1);\n        } else if (tag(\"3c\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_color_tag(VAR_6->start);\n                change_color(&VAR_0->state.c[2], VAR_12, VAR_3);\n            } else\n                change_color(&VAR_0->state.c[2],\n                             VAR_0->state.style->OutlineColour, 1);\n        } else if (tag(\"4c\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_color_tag(VAR_6->start);\n                change_color(&VAR_0->state.c[3], VAR_12, VAR_3);\n            } else\n                change_color(&VAR_0->state.c[3],\n                             VAR_0->state.style->BackColour, 1);\n        } else if (tag(\"1a\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_alpha_tag(VAR_6->start);\n                change_alpha(&VAR_0->state.c[0], VAR_12, VAR_3);\n            } else\n                change_alpha(&VAR_0->state.c[0],\n                             _a(VAR_0->state.style->PrimaryColour), 1);\n        } else if (tag(\"2a\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_alpha_tag(VAR_6->start);\n                change_alpha(&VAR_0->state.c[1], VAR_12, VAR_3);\n            } else\n                change_alpha(&VAR_0->state.c[1],\n                             _a(VAR_0->state.style->SecondaryColour), 1);\n        } else if (tag(\"3a\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_alpha_tag(VAR_6->start);\n                change_alpha(&VAR_0->state.c[2], VAR_12, VAR_3);\n            } else\n                change_alpha(&VAR_0->state.c[2],\n                             _a(VAR_0->state.style->OutlineColour), 1);\n        } else if (tag(\"4a\")) {\n            if (VAR_8) {\n                uint32_t VAR_12 = parse_alpha_tag(VAR_6->start);\n                change_alpha(&VAR_0->state.c[3], VAR_12, VAR_3);\n            } else\n                change_alpha(&VAR_0->state.c[3],\n                             _a(VAR_0->state.style->BackColour), 1);\n        } else if (tag(\"r\")) {\n            if (VAR_8) {\n                int VAR_47 = VAR_6->end - VAR_6->start;\n                reset_render_context(VAR_0,\n                        lookup_style_strict(VAR_0->track, VAR_6->start, VAR_47));\n            } else\n                reset_render_context(VAR_0, NULL);\n        } else if (tag(\"be\")) {\n            double VAR_48;\n            if (VAR_8) {\n                int VAR_12;\n                VAR_48 = argtod(*VAR_6);\n                /* COMMENT_22 */\n                VAR_12 = (int) (VAR_0->state.be * (1 - VAR_3) + VAR_48 * VAR_3 + 0.5);\n                /* COMMENT_23 */\n                VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n                VAR_12 = (VAR_12 > VAR_49) ? VAR_49 : VAR_12;\n                VAR_0->state.be = VAR_12;\n            } else\n                VAR_0->state.be = 0;\n        } else if (tag(\"b\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 == 0 || VAR_12 == 1 || VAR_12 >= 100))\n                VAR_12 = VAR_0->state.style->Bold;\n            VAR_0->state.bold = VAR_12;\n            update_font(VAR_0);\n        } else if (tag(\"i\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 == 0 || VAR_12 == 1))\n                VAR_12 = VAR_0->state.style->Italic;\n            VAR_0->state.italic = VAR_12;\n            update_font(VAR_0);\n        } else if (tag(\"kf\") || tag(\"K\")) {\n            double VAR_12 = 100;\n            if (VAR_8)\n                VAR_12 = argtod(*VAR_6);\n            VAR_0->state.effect_type = VAR_50;\n            if (VAR_0->state.effect_timing)\n                VAR_0->state.effect_skip_timing +=\n                    VAR_0->state.effect_timing;\n            VAR_0->state.effect_timing = VAR_12 * 10;\n        } else if (tag(\"ko\")) {\n            double VAR_12 = 100;\n            if (VAR_8)\n                VAR_12 = argtod(*VAR_6);\n            VAR_0->state.effect_type = VAR_51;\n            if (VAR_0->state.effect_timing)\n                VAR_0->state.effect_skip_timing +=\n                    VAR_0->state.effect_timing;\n            VAR_0->state.effect_timing = VAR_12 * 10;\n        } else if (tag(\"k\")) {\n            double VAR_12 = 100;\n            if (VAR_8)\n                VAR_12 = argtod(*VAR_6);\n            VAR_0->state.effect_type = VAR_52;\n            if (VAR_0->state.effect_timing)\n                VAR_0->state.effect_skip_timing +=\n                    VAR_0->state.effect_timing;\n            VAR_0->state.effect_timing = VAR_12 * 10;\n        } else if (tag(\"shad\")) {\n            double VAR_12, VAR_18, VAR_19;\n            if (VAR_8) {\n                VAR_12 = argtod(*VAR_6);\n                VAR_18 = VAR_0->state.shadow_x * (1 - VAR_3) + VAR_12 * VAR_3;\n                VAR_19 = VAR_0->state.shadow_y * (1 - VAR_3) + VAR_12 * VAR_3;\n                /* COMMENT_24 */\n                VAR_18 = (VAR_18 < 0) ? 0 : VAR_18;\n                VAR_19 = (VAR_19 < 0) ? 0 : VAR_19;\n            } else\n                VAR_18 = VAR_19 = VAR_0->state.style->Shadow;\n            VAR_0->state.shadow_x = VAR_18;\n            VAR_0->state.shadow_y = VAR_19;\n        } else if (tag(\"s\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 == 0 || VAR_12 == 1))\n                VAR_12 = VAR_0->state.style->StrikeOut;\n            if (VAR_12)\n                VAR_0->state.flags |= VAR_53;\n            else\n                VAR_0->state.flags &= ~VAR_53;\n        } else if (tag(\"u\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 == 0 || VAR_12 == 1))\n                VAR_12 = VAR_0->state.style->Underline;\n            if (VAR_12)\n                VAR_0->state.flags |= VAR_54;\n            else\n                VAR_0->state.flags &= ~VAR_54;\n        } else if (tag(\"pbo\")) {\n            double VAR_12 = argtod(*VAR_6);\n            VAR_0->state.pbo = VAR_12;\n        } else if (tag(\"p\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            VAR_12 = (VAR_12 < 0) ? 0 : VAR_12;\n            VAR_0->state.drawing_scale = VAR_12;\n        } else if (tag(\"q\")) {\n            int VAR_12 = argtoi(*VAR_6);\n            if (!VAR_8 || !(VAR_12 >= 0 && VAR_12 <= 3))\n                VAR_12 = VAR_0->track->WrapStyle;\n            VAR_0->state.wrap_style = VAR_12;\n        } else if (tag(\"fe\")) {\n            int VAR_12;\n            if (VAR_8)\n                VAR_12 = argtoi(*VAR_6);\n            else\n                VAR_12 = VAR_0->state.style->Encoding;\n            VAR_0->state.font_encoding = VAR_12;\n        }\n    }\n\n    return VAR_1;\n}",
  "func_graph_path": "libass/6835731c2fe4164a0c50bc91d12c43b2a2b4e/ass_parse.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -418,7 +418,17 @@\n                 k = pow(((double) (t - t1)) / delta_t, accel);\n             }\n             p = args[cnt].start;\n-            p = parse_tags(render_priv, p, args[cnt].end, k);    // maybe k*pwr ? no, specs forbid nested \\t's\n+            if (args[cnt].end < end) {\n+                p = parse_tags(render_priv, p, args[cnt].end, k);\n+            } else {\n+                assert(q == end);\n+                // No other tags can possibly follow this \\t tag,\n+                // so we don't need to restore pwr after parsing \\t.\n+                // The recursive call is now essentially a tail call,\n+                // so optimize it away.\n+                pwr = k;\n+                q = p;\n+            }\n         } else if (complex_tag(\"clip\")) {\n             if (nargs == 4) {\n                 int x0, y0, x1, y1;",
  "diff_line_info": {
    "deleted_lines": [
      "            p = parse_tags(render_priv, p, args[cnt].end, k);    // maybe k*pwr ? no, specs forbid nested \\t's"
    ],
    "added_lines": [
      "            if (args[cnt].end < end) {",
      "                p = parse_tags(render_priv, p, args[cnt].end, k);",
      "            } else {",
      "                assert(q == end);",
      "                // No other tags can possibly follow this \\t tag,",
      "                // so we don't need to restore pwr after parsing \\t.",
      "                // The recursive call is now essentially a tail call,",
      "                // so optimize it away.",
      "                pwr = k;",
      "                q = p;",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libass/libass/pull/296",
  "description": {
    "pr_info": {
      "title": "Reduce recursion and improve VSFilter compatibility for nested \\t",
      "number": 296
    },
    "comment": [
      "This prevents [stack overflow](https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=4892) on deeply nested `\\t` by essentially performing tail call optimization on it.\r\n\r\nThe first commit indents the whole of `parse_tag`, so for viewing the diff, you probably want to use `git show -w` or `git log -p -w` on the command line rather than GitHub’s Web interface.\r\n\r\nAs we currently parse tags in a VSFilter 2.37–compatible way, parentheses are not parsed in nested pairs, but rather the very first closing parenthesis terminates the whole tag. So if you have a `\\t()` inside another `\\t()`, the first closing parenthesis terminates the outer `\\t` and the inner `\\t` actually doesn’t have a closing parenthesis at all. This means that if the parser ever encounters a `\\t(` inside another `\\t()`, it is the very last tag inside it, guaranteed, because it runs all the way to the closing parenthesis.\r\n\r\nI could translate this observation directly into code, especially because I had to introduce a `nested` flag in the last commit anyway (see below), but I chose a more generic condition because it is clearer on its own (without knowing the story of how parentheses are parsed), it will not break if we ever decide to allow nested parentheses, and as an added bonus it can save an occasional recursive call even for unnested `\\t` if the closing parenthesis is missing entirely.\r\n\r\nWhile verifying that I didn’t break anything, I noticed that we disagreed with VSFilter on the meaning of `\\t` with an incorrect number of arguments. Again due to the VSFilter 2.39–compatible tag parsing, the only case that actually matters is when there’s a `\\t` with no parentheses inside a multiple-argument `\\t()`. As soon as the inner `\\t` is reached, the animation-controlling arguments (start, end, acceleration) of the outer `\\t` are forgotten and reset to the defaults, effective for all subsequent tags inside the `\\t()`. I haven’t seen real files using this, but I’ve confirmed in a practical test that our behaviour differs. The **last commit** in this pull request fixes this.\r\n  ",
      "Generally fine, I guess.",
      "Updated: added braces around the `if` body and replaced the `goto` by a `q = p` assignment.",
      "Dropping the goto is nice. I have no further comments.",
      "Updated again: turns out `end` was being modified when parsing `\\fn`, so the loop ended too early if `\\fn` was followed by anything else. The assertion in `ass_render.c` helped catch this. In the fixed commit, `end` is no longer modified within `parse_tags`.",
      "Final update (hopefully) before merging: added changelog entries, expanded the commit message of the recursion commit and mentioned this PR in the commit messages. If the changelog and commit messages look fine to you, I’ll push to `master`."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}