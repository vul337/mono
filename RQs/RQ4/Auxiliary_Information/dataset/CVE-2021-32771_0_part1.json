{
  "cve_id": "CVE-2021-32771",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "contiki-ng",
  "commit_msg": "Check RPL Target prefix length and buffer boundary.",
  "commit_hash": "587ae59956e00316fd44fd7072ac3a6a07b4b20f",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/587ae59956e00316fd44fd7072ac3a6a07b4b20f",
  "file_path": "os/net/routing/rpl-classic/rpl-icmp6.c",
  "func_name": "dao_input_storing",
  "func_before": "static void\ndao_input_storing(void)\n{\n#if RPL_WITH_STORING\n  uip_ipaddr_t dao_sender_addr;\n  rpl_dag_t *dag;\n  rpl_instance_t *instance;\n  unsigned char *buffer;\n  uint16_t sequence;\n  uint8_t instance_id;\n  uint8_t lifetime;\n  uint8_t prefixlen;\n  uint8_t flags;\n  uint8_t subopt_type;\n  /*\n    uint8_t pathcontrol;\n    uint8_t pathsequence;\n  */\n  uip_ipaddr_t prefix;\n  uip_ds6_route_t *rep;\n  uint8_t buffer_length;\n  int pos;\n  int len;\n  int i;\n  int learned_from;\n  rpl_parent_t *parent;\n  uip_ds6_nbr_t *nbr;\n  int is_root;\n\n  prefixlen = 0;\n  parent = NULL;\n  memset(&prefix, 0, sizeof(prefix));\n\n  uip_ipaddr_copy(&dao_sender_addr, &UIP_IP_BUF->srcipaddr);\n\n  buffer = UIP_ICMP_PAYLOAD;\n  buffer_length = uip_len - uip_l3_icmp_hdr_len;\n\n  pos = 0;\n  instance_id = buffer[pos++];\n\n  instance = rpl_get_instance(instance_id);\n\n  lifetime = instance->default_lifetime;\n\n  flags = buffer[pos++];\n  /* reserved */\n  pos++;\n  sequence = buffer[pos++];\n\n  dag = instance->current_dag;\n  is_root = (dag->rank == ROOT_RANK(instance));\n\n  /* Is the DAG ID present? */\n  if(flags & RPL_DAO_D_FLAG) {\n    if(memcmp(&dag->dag_id, &buffer[pos], sizeof(dag->dag_id))) {\n      LOG_INFO(\"Ignoring a DAO for a DAG different from ours\\n\");\n      return;\n    }\n    pos += 16;\n  }\n\n  learned_from = uip_is_addr_mcast(&dao_sender_addr) ?\n    RPL_ROUTE_FROM_MULTICAST_DAO : RPL_ROUTE_FROM_UNICAST_DAO;\n\n  /* Destination Advertisement Object */\n  LOG_DBG(\"Received a (%s) DAO with sequence number %u from \",\n         learned_from == RPL_ROUTE_FROM_UNICAST_DAO? \"unicast\": \"multicast\", sequence);\n  LOG_DBG_6ADDR(&dao_sender_addr);\n  LOG_DBG_(\"\\n\");\n\n  if(learned_from == RPL_ROUTE_FROM_UNICAST_DAO) {\n    /* Check whether this is a DAO forwarding loop. */\n    parent = rpl_find_parent(dag, &dao_sender_addr);\n    /* check if this is a new DAO registration with an \"illegal\" rank */\n    /* if we already route to this node it is likely */\n    if(parent != NULL &&\n       DAG_RANK(parent->rank, instance) < DAG_RANK(dag->rank, instance)) {\n      LOG_WARN(\"Loop detected when receiving a unicast DAO from a node with a lower rank! (%u < %u)\\n\",\n             DAG_RANK(parent->rank, instance), DAG_RANK(dag->rank, instance));\n      parent->rank = RPL_INFINITE_RANK;\n      parent->flags |= RPL_PARENT_FLAG_UPDATED;\n      return;\n    }\n\n    /* If we get the DAO from our parent, we also have a loop. */\n    if(parent != NULL && parent == dag->preferred_parent) {\n      LOG_WARN(\"Loop detected when receiving a unicast DAO from our parent\\n\");\n      parent->rank = RPL_INFINITE_RANK;\n      parent->flags |= RPL_PARENT_FLAG_UPDATED;\n      return;\n    }\n  }\n\n  /* Check if there are any RPL options present. */\n  for(i = pos; i < buffer_length; i += len) {\n    subopt_type = buffer[i];\n    if(subopt_type == RPL_OPTION_PAD1) {\n      len = 1;\n    } else {\n      /* The option consists of a two-byte header and a payload. */\n      len = 2 + buffer[i + 1];\n    }\n\n    switch(subopt_type) {\n      case RPL_OPTION_TARGET:\n        /* Handle the target option. */\n        prefixlen = buffer[i + 3];\n        memset(&prefix, 0, sizeof(prefix));\n        memcpy(&prefix, buffer + i + 4, (prefixlen + 7) / CHAR_BIT);\n        break;\n      case RPL_OPTION_TRANSIT:\n        /* The path sequence and control are ignored. */\n        /*      pathcontrol = buffer[i + 3];\n                pathsequence = buffer[i + 4];*/\n        lifetime = buffer[i + 5];\n        /* The parent address is also ignored. */\n        break;\n    }\n  }\n\n  LOG_INFO(\"DAO lifetime: %u, prefix length: %u prefix: \",\n         (unsigned)lifetime, (unsigned)prefixlen);\n  LOG_INFO_6ADDR(&prefix);\n  LOG_INFO_(\"\\n\");\n\n#if RPL_WITH_MULTICAST\n  if(uip_is_addr_mcast_global(&prefix)) {\n    /*\n     * \"rep\" is used for a unicast route which we don't need now; so set NULL so\n     * that operations on \"rep\" will be skipped.\n     */\n    rep = NULL;\n    mcast_group = uip_mcast6_route_add(&prefix);\n    if(mcast_group) {\n      mcast_group->dag = dag;\n      mcast_group->lifetime = RPL_LIFETIME(instance, lifetime);\n    }\n    goto fwd_dao;\n  }\n#endif\n\n  rep = uip_ds6_route_lookup(&prefix);\n\n  if(lifetime == RPL_ZERO_LIFETIME) {\n    LOG_INFO(\"No-Path DAO received\\n\");\n    /* No-Path DAO received; invoke the route purging routine. */\n    if(rep != NULL &&\n       !RPL_ROUTE_IS_NOPATH_RECEIVED(rep) &&\n       rep->length == prefixlen &&\n       uip_ds6_route_nexthop(rep) != NULL &&\n       uip_ipaddr_cmp(uip_ds6_route_nexthop(rep), &dao_sender_addr)) {\n      LOG_DBG(\"Setting expiration timer for prefix \");\n      LOG_DBG_6ADDR(&prefix);\n      LOG_DBG_(\"\\n\");\n      RPL_ROUTE_SET_NOPATH_RECEIVED(rep);\n      rep->state.lifetime = RPL_NOPATH_REMOVAL_DELAY;\n\n      /* We forward the incoming No-Path DAO to our parent, if we have\n         one. */\n      if(dag->preferred_parent != NULL &&\n         rpl_parent_get_ipaddr(dag->preferred_parent) != NULL) {\n        uint8_t out_seq;\n        out_seq = prepare_for_dao_fwd(sequence, rep);\n\n        LOG_DBG(\"Forwarding No-path DAO to parent - out_seq:%d\",\n               out_seq);\n        LOG_DBG_6ADDR(rpl_parent_get_ipaddr(dag->preferred_parent));\n        LOG_DBG_(\"\\n\");\n\n        buffer = UIP_ICMP_PAYLOAD;\n        buffer[3] = out_seq; /* add an outgoing seq no before fwd */\n        uip_icmp6_send(rpl_parent_get_ipaddr(dag->preferred_parent),\n                       ICMP6_RPL, RPL_CODE_DAO, buffer_length);\n      }\n    }\n    /* independent if we remove or not - ACK the request */\n    if(flags & RPL_DAO_K_FLAG) {\n      /* indicate that we accepted the no-path DAO */\n      uipbuf_clear();\n      dao_ack_output(instance, &dao_sender_addr, sequence,\n                     RPL_DAO_ACK_UNCONDITIONAL_ACCEPT);\n    }\n    return;\n  }\n\n  LOG_INFO(\"Adding DAO route\\n\");\n\n  /* Update and add neighbor - if no room - fail. */\n  if((nbr = rpl_icmp6_update_nbr_table(&dao_sender_addr, NBR_TABLE_REASON_RPL_DAO, instance)) == NULL) {\n    LOG_ERR(\"Out of Memory, dropping DAO from \");\n    LOG_ERR_6ADDR(&dao_sender_addr);\n    LOG_ERR_(\", \");\n    LOG_ERR_LLADDR(packetbuf_addr(PACKETBUF_ADDR_SENDER));\n    LOG_ERR_(\"\\n\");\n    if(flags & RPL_DAO_K_FLAG) {\n      /* signal the failure to add the node */\n      dao_ack_output(instance, &dao_sender_addr, sequence,\n                     is_root ? RPL_DAO_ACK_UNABLE_TO_ADD_ROUTE_AT_ROOT :\n                     RPL_DAO_ACK_UNABLE_TO_ACCEPT);\n    }\n    return;\n  }\n\n  rep = rpl_add_route(dag, &prefix, prefixlen, &dao_sender_addr);\n  if(rep == NULL) {\n    RPL_STAT(rpl_stats.mem_overflows++);\n    LOG_ERR(\"Could not add a route after receiving a DAO\\n\");\n    if(flags & RPL_DAO_K_FLAG) {\n      /* signal the failure to add the node */\n      dao_ack_output(instance, &dao_sender_addr, sequence,\n                     is_root ? RPL_DAO_ACK_UNABLE_TO_ADD_ROUTE_AT_ROOT :\n                     RPL_DAO_ACK_UNABLE_TO_ACCEPT);\n    }\n    return;\n  }\n\n  /* set lifetime and clear NOPATH bit */\n  rep->state.lifetime = RPL_LIFETIME(instance, lifetime);\n  RPL_ROUTE_CLEAR_NOPATH_RECEIVED(rep);\n\n#if RPL_WITH_MULTICAST\nfwd_dao:\n#endif\n\n  if(learned_from == RPL_ROUTE_FROM_UNICAST_DAO) {\n    int should_ack = 0;\n\n    if(flags & RPL_DAO_K_FLAG) {\n      if(rep != NULL) {\n        /*\n         * check if this route is already installed and we can ack now!\n         * not pending - and same seq-no means that we can ack.\n         * (e.g. the route is installed already so it will not take any\n         * more room that it already takes - so should be ok!)\n         */\n        if((!RPL_ROUTE_IS_DAO_PENDING(rep) &&\n            rep->state.dao_seqno_in == sequence) ||\n           dag->rank == ROOT_RANK(instance)) {\n          should_ack = 1;\n        }\n      }\n    }\n\n    if(dag->preferred_parent != NULL &&\n       rpl_parent_get_ipaddr(dag->preferred_parent) != NULL) {\n      uint8_t out_seq = 0;\n      if(rep != NULL) {\n        /* if this is pending and we get the same seq no it is a retrans */\n        if(RPL_ROUTE_IS_DAO_PENDING(rep) &&\n           rep->state.dao_seqno_in == sequence) {\n          /* keep the same seq-no as before for parent also */\n          out_seq = rep->state.dao_seqno_out;\n        } else {\n          out_seq = prepare_for_dao_fwd(sequence, rep);\n        }\n      }\n\n      LOG_DBG(\"Forwarding DAO to parent \");\n      LOG_DBG_6ADDR(rpl_parent_get_ipaddr(dag->preferred_parent));\n      LOG_DBG_(\" in seq: %d out seq: %d\\n\", sequence, out_seq);\n\n      buffer = UIP_ICMP_PAYLOAD;\n      buffer[3] = out_seq; /* add an outgoing seq no before fwd */\n      uip_icmp6_send(rpl_parent_get_ipaddr(dag->preferred_parent),\n                     ICMP6_RPL, RPL_CODE_DAO, buffer_length);\n    }\n    if(should_ack) {\n      LOG_DBG(\"Sending DAO ACK\\n\");\n      uipbuf_clear();\n      dao_ack_output(instance, &dao_sender_addr, sequence,\n                     RPL_DAO_ACK_UNCONDITIONAL_ACCEPT);\n    }\n  }\n#endif /* RPL_WITH_STORING */\n}",
  "abstract_func_before": "static void\ndao_input_storing(void)\n{\n#if VAR_0\n  uip_ipaddr_t VAR_1;\n  rpl_dag_t *VAR_2;\n  rpl_instance_t *VAR_3;\n  unsigned char *VAR_4;\n  uint16_t VAR_5;\n  uint8_t VAR_6;\n  uint8_t VAR_7;\n  uint8_t VAR_8;\n  uint8_t VAR_9;\n  uint8_t VAR_10;\n  /* COMMENT_0 */\n                        \n                         \n    \n  uip_ipaddr_t VAR_11;\n  uip_ds6_route_t *VAR_12;\n  uint8_t VAR_13;\n  int VAR_14;\n  int VAR_15;\n  int VAR_16;\n  int VAR_17;\n  rpl_parent_t *VAR_18;\n  uip_ds6_nbr_t *VAR_19;\n  int VAR_20;\n\n  VAR_8 = 0;\n  VAR_18 = NULL;\n  memset(&VAR_11, 0, sizeof(VAR_11));\n\n  uip_ipaddr_copy(&VAR_1, &VAR_21->srcipaddr);\n\n  VAR_4 = VAR_22;\n  VAR_13 = VAR_23 - VAR_24;\n\n  VAR_14 = 0;\n  VAR_6 = VAR_4[VAR_14++];\n\n  VAR_3 = rpl_get_instance(VAR_6);\n\n  VAR_7 = VAR_3->default_lifetime;\n\n  VAR_9 = VAR_4[VAR_14++];\n  /* COMMENT_4 */\n  VAR_14++;\n  VAR_5 = VAR_4[VAR_14++];\n\n  VAR_2 = VAR_3->current_dag;\n  VAR_20 = (VAR_2->rank == ROOT_RANK(VAR_3));\n\n  /* COMMENT_5 */\n  if(VAR_9 & VAR_25) {\n    if(memcmp(&VAR_2->dag_id, &VAR_4[VAR_14], sizeof(VAR_2->dag_id))) {\n      LOG_INFO(\"Ignoring a DAO for a DAG different from ours\\n\");\n      return;\n    }\n    VAR_14 += 16;\n  }\n\n  VAR_17 = uip_is_addr_mcast(&VAR_1) ?\n    VAR_26 : VAR_27;\n\n  /* COMMENT_6 */\n  LOG_DBG(\"Received a (%s) DAO with sequence number %u from \",\n         VAR_17 == VAR_27? \"unicast\": \"multicast\", VAR_5);\n  LOG_DBG_6ADDR(&VAR_1);\n  LOG_DBG_(\"\\n\");\n\n  if(VAR_17 == VAR_27) {\n    /* COMMENT_7 */\n    VAR_18 = rpl_find_parent(VAR_2, &VAR_1);\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    if(VAR_18 != NULL &&\n       DAG_RANK(VAR_18->rank, VAR_3) < DAG_RANK(VAR_2->rank, VAR_3)) {\n      LOG_WARN(\"Loop detected when receiving a unicast DAO from a node with a lower rank! (%u < %u)\\n\",\n             DAG_RANK(VAR_18->rank, VAR_3), DAG_RANK(VAR_2->rank, VAR_3));\n      VAR_18->rank = VAR_28;\n      VAR_18->flags |= VAR_29;\n      return;\n    }\n\n    /* COMMENT_10 */\n    if(VAR_18 != NULL && VAR_18 == VAR_2->preferred_parent) {\n      LOG_WARN(\"Loop detected when receiving a unicast DAO from our parent\\n\");\n      VAR_18->rank = VAR_28;\n      VAR_18->flags |= VAR_29;\n      return;\n    }\n  }\n\n  /* COMMENT_11 */\n  for(VAR_16 = VAR_14; VAR_16 < VAR_13; VAR_16 += VAR_15) {\n    VAR_10 = VAR_4[VAR_16];\n    if(VAR_10 == VAR_30) {\n      VAR_15 = 1;\n    } else {\n      /* COMMENT_12 */\n      VAR_15 = 2 + VAR_4[VAR_16 + 1];\n    }\n\n    switch(VAR_10) {\n      case VAR_31:\n        /* COMMENT_13 */\n        VAR_8 = VAR_4[VAR_16 + 3];\n        memset(&VAR_11, 0, sizeof(VAR_11));\n        memcpy(&VAR_11, VAR_4 + VAR_16 + 4, (VAR_8 + 7) / VAR_32);\n        break;\n      case VAR_33:\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n                                               \n        VAR_7 = VAR_4[VAR_16 + 5];\n        /* COMMENT_17 */\n        break;\n    }\n  }\n\n  LOG_INFO(\"DAO lifetime: %u, prefix length: %u prefix: \",\n         (unsigned)VAR_7, (unsigned)VAR_8);\n  LOG_INFO_6ADDR(&VAR_11);\n  LOG_INFO_(\"\\n\");\n\n#if VAR_34\n  if(uip_is_addr_mcast_global(&VAR_11)) {\n    /* COMMENT_18 */\n                                                                                \n                                                \n       \n    VAR_12 = NULL;\n    VAR_35 = uip_mcast6_route_add(&VAR_11);\n    if(VAR_35) {\n      VAR_35->dag = VAR_2;\n      VAR_35->lifetime = RPL_LIFETIME(VAR_3, VAR_7);\n    }\n    goto fwd_dao;\n  }\n#endif\n\n  VAR_12 = uip_ds6_route_lookup(&VAR_11);\n\n  if(VAR_7 == VAR_36) {\n    LOG_INFO(\"No-Path DAO received\\n\");\n    /* COMMENT_22 */\n    if(VAR_12 != NULL &&\n       !RPL_ROUTE_IS_NOPATH_RECEIVED(VAR_12) &&\n       VAR_12->length == VAR_8 &&\n       uip_ds6_route_nexthop(VAR_12) != NULL &&\n       uip_ipaddr_cmp(uip_ds6_route_nexthop(VAR_12), &VAR_1)) {\n      LOG_DBG(\"Setting expiration timer for prefix \");\n      LOG_DBG_6ADDR(&VAR_11);\n      LOG_DBG_(\"\\n\");\n      RPL_ROUTE_SET_NOPATH_RECEIVED(VAR_12);\n      VAR_12->state.lifetime = VAR_37;\n\n      /* COMMENT_23 */\n                \n      if(VAR_2->preferred_parent != NULL &&\n         rpl_parent_get_ipaddr(VAR_2->preferred_parent) != NULL) {\n        uint8_t VAR_38;\n        VAR_38 = prepare_for_dao_fwd(VAR_5, VAR_12);\n\n        LOG_DBG(\"Forwarding No-path DAO to parent - out_seq:%d\",\n               VAR_38);\n        LOG_DBG_6ADDR(rpl_parent_get_ipaddr(VAR_2->preferred_parent));\n        LOG_DBG_(\"\\n\");\n\n        VAR_4 = VAR_22;\n        VAR_4[3] = VAR_38; /* COMMENT_25 */\n        uip_icmp6_send(rpl_parent_get_ipaddr(VAR_2->preferred_parent),\n                       VAR_39, VAR_40, VAR_13);\n      }\n    }\n    /* COMMENT_26 */\n    if(VAR_9 & VAR_41) {\n      /* COMMENT_27 */\n      uipbuf_clear();\n      dao_ack_output(VAR_3, &VAR_1, VAR_5,\n                     VAR_42);\n    }\n    return;\n  }\n\n  LOG_INFO(\"Adding DAO route\\n\");\n\n  /* COMMENT_28 */\n  if((VAR_19 = rpl_icmp6_update_nbr_table(&VAR_1, VAR_43, VAR_3)) == NULL) {\n    LOG_ERR(\"Out of Memory, dropping DAO from \");\n    LOG_ERR_6ADDR(&VAR_1);\n    LOG_ERR_(\", \");\n    LOG_ERR_LLADDR(packetbuf_addr(VAR_44));\n    LOG_ERR_(\"\\n\");\n    if(VAR_9 & VAR_41) {\n      /* COMMENT_29 */\n      dao_ack_output(VAR_3, &VAR_1, VAR_5,\n                     VAR_20 ? VAR_45 :\n                     VAR_46);\n    }\n    return;\n  }\n\n  VAR_12 = rpl_add_route(VAR_2, &VAR_11, VAR_8, &VAR_1);\n  if(VAR_12 == NULL) {\n    RPL_STAT(VAR_47.mem_overflows++);\n    LOG_ERR(\"Could not add a route after receiving a DAO\\n\");\n    if(VAR_9 & VAR_41) {\n      /* COMMENT_29 */\n      dao_ack_output(VAR_3, &VAR_1, VAR_5,\n                     VAR_20 ? VAR_45 :\n                     VAR_46);\n    }\n    return;\n  }\n\n  /* COMMENT_30 */\n  VAR_12->state.lifetime = RPL_LIFETIME(VAR_3, VAR_7);\n  RPL_ROUTE_CLEAR_NOPATH_RECEIVED(VAR_12);\n\n#if VAR_34\nfwd_dao:\n#endif\n\n  if(VAR_17 == VAR_27) {\n    int VAR_48 = 0;\n\n    if(VAR_9 & VAR_41) {\n      if(VAR_12 != NULL) {\n        /* COMMENT_31 */\n                                                                       \n                                                               \n                                                                       \n                                                              \n           \n        if((!RPL_ROUTE_IS_DAO_PENDING(VAR_12) &&\n            VAR_12->state.dao_seqno_in == VAR_5) ||\n           VAR_2->rank == ROOT_RANK(VAR_3)) {\n          VAR_48 = 1;\n        }\n      }\n    }\n\n    if(VAR_2->preferred_parent != NULL &&\n       rpl_parent_get_ipaddr(VAR_2->preferred_parent) != NULL) {\n      uint8_t VAR_38 = 0;\n      if(VAR_12 != NULL) {\n        /* COMMENT_37 */\n        if(RPL_ROUTE_IS_DAO_PENDING(VAR_12) &&\n           VAR_12->state.dao_seqno_in == VAR_5) {\n          /* COMMENT_38 */\n          VAR_38 = VAR_12->state.dao_seqno_out;\n        } else {\n          VAR_38 = prepare_for_dao_fwd(VAR_5, VAR_12);\n        }\n      }\n\n      LOG_DBG(\"Forwarding DAO to parent \");\n      LOG_DBG_6ADDR(rpl_parent_get_ipaddr(VAR_2->preferred_parent));\n      LOG_DBG_(\" in seq: %d out seq: %d\\n\", VAR_5, VAR_38);\n\n      VAR_4 = VAR_22;\n      VAR_4[3] = VAR_38; /* COMMENT_25 */\n      uip_icmp6_send(rpl_parent_get_ipaddr(VAR_2->preferred_parent),\n                     VAR_39, VAR_40, VAR_13);\n    }\n    if(VAR_48) {\n      LOG_DBG(\"Sending DAO ACK\\n\");\n      uipbuf_clear();\n      dao_ack_output(VAR_3, &VAR_1, VAR_5,\n                     VAR_42);\n    }\n  }\n#endif /* COMMENT_39 */\n}",
  "func_graph_path_before": "contiki-ng/587ae59956e00316fd44fd7072ac3a6a07b4b20f/rpl-icmp6.c/vul/before/1.json",
  "func": "static void\ndao_input_storing(void)\n{\n#if RPL_WITH_STORING\n  uip_ipaddr_t dao_sender_addr;\n  rpl_dag_t *dag;\n  rpl_instance_t *instance;\n  unsigned char *buffer;\n  uint16_t sequence;\n  uint8_t instance_id;\n  uint8_t lifetime;\n  uint8_t prefixlen;\n  uint8_t flags;\n  uint8_t subopt_type;\n  /*\n    uint8_t pathcontrol;\n    uint8_t pathsequence;\n  */\n  uip_ipaddr_t prefix;\n  uip_ds6_route_t *rep;\n  uint8_t buffer_length;\n  int pos;\n  int len;\n  int i;\n  int learned_from;\n  rpl_parent_t *parent;\n  uip_ds6_nbr_t *nbr;\n  int is_root;\n\n  prefixlen = 0;\n  parent = NULL;\n  memset(&prefix, 0, sizeof(prefix));\n\n  uip_ipaddr_copy(&dao_sender_addr, &UIP_IP_BUF->srcipaddr);\n\n  buffer = UIP_ICMP_PAYLOAD;\n  buffer_length = uip_len - uip_l3_icmp_hdr_len;\n\n  pos = 0;\n  instance_id = buffer[pos++];\n\n  instance = rpl_get_instance(instance_id);\n\n  lifetime = instance->default_lifetime;\n\n  flags = buffer[pos++];\n  /* reserved */\n  pos++;\n  sequence = buffer[pos++];\n\n  dag = instance->current_dag;\n  is_root = (dag->rank == ROOT_RANK(instance));\n\n  /* Is the DAG ID present? */\n  if(flags & RPL_DAO_D_FLAG) {\n    if(memcmp(&dag->dag_id, &buffer[pos], sizeof(dag->dag_id))) {\n      LOG_INFO(\"Ignoring a DAO for a DAG different from ours\\n\");\n      return;\n    }\n    pos += 16;\n  }\n\n  learned_from = uip_is_addr_mcast(&dao_sender_addr) ?\n    RPL_ROUTE_FROM_MULTICAST_DAO : RPL_ROUTE_FROM_UNICAST_DAO;\n\n  /* Destination Advertisement Object */\n  LOG_DBG(\"Received a (%s) DAO with sequence number %u from \",\n         learned_from == RPL_ROUTE_FROM_UNICAST_DAO? \"unicast\": \"multicast\", sequence);\n  LOG_DBG_6ADDR(&dao_sender_addr);\n  LOG_DBG_(\"\\n\");\n\n  if(learned_from == RPL_ROUTE_FROM_UNICAST_DAO) {\n    /* Check whether this is a DAO forwarding loop. */\n    parent = rpl_find_parent(dag, &dao_sender_addr);\n    /* check if this is a new DAO registration with an \"illegal\" rank */\n    /* if we already route to this node it is likely */\n    if(parent != NULL &&\n       DAG_RANK(parent->rank, instance) < DAG_RANK(dag->rank, instance)) {\n      LOG_WARN(\"Loop detected when receiving a unicast DAO from a node with a lower rank! (%u < %u)\\n\",\n             DAG_RANK(parent->rank, instance), DAG_RANK(dag->rank, instance));\n      parent->rank = RPL_INFINITE_RANK;\n      parent->flags |= RPL_PARENT_FLAG_UPDATED;\n      return;\n    }\n\n    /* If we get the DAO from our parent, we also have a loop. */\n    if(parent != NULL && parent == dag->preferred_parent) {\n      LOG_WARN(\"Loop detected when receiving a unicast DAO from our parent\\n\");\n      parent->rank = RPL_INFINITE_RANK;\n      parent->flags |= RPL_PARENT_FLAG_UPDATED;\n      return;\n    }\n  }\n\n  /* Check if there are any RPL options present. */\n  for(i = pos; i < buffer_length; i += len) {\n    subopt_type = buffer[i];\n    if(subopt_type == RPL_OPTION_PAD1) {\n      len = 1;\n    } else {\n      /* The option consists of a two-byte header and a payload. */\n      len = 2 + buffer[i + 1];\n    }\n\n    switch(subopt_type) {\n      case RPL_OPTION_TARGET:\n        /* Handle the target option. */\n        prefixlen = buffer[i + 3];\n        if(prefixlen == 0) {\n          /* Ignore option targets with a prefix length of 0. */\n          break;\n        }\n        if(prefixlen > 128) {\n          LOG_ERR(\"Too large target prefix length %d\\n\", prefixlen);\n          return;\n        }\n        if(i + 4 + ((prefixlen + 7) / CHAR_BIT) > buffer_length) {\n          LOG_ERR(\"Insufficient space to copy RPL Target of %d bits\\n\",\n                  prefixlen);\n          return;\n        }\n        memset(&prefix, 0, sizeof(prefix));\n        memcpy(&prefix, buffer + i + 4, (prefixlen + 7) / CHAR_BIT);\n        break;\n      case RPL_OPTION_TRANSIT:\n        /* The path sequence and control are ignored. */\n        /*      pathcontrol = buffer[i + 3];\n                pathsequence = buffer[i + 4];*/\n        lifetime = buffer[i + 5];\n        /* The parent address is also ignored. */\n        break;\n    }\n  }\n\n  LOG_INFO(\"DAO lifetime: %u, prefix length: %u prefix: \",\n         (unsigned)lifetime, (unsigned)prefixlen);\n  LOG_INFO_6ADDR(&prefix);\n  LOG_INFO_(\"\\n\");\n\n#if RPL_WITH_MULTICAST\n  if(uip_is_addr_mcast_global(&prefix)) {\n    /*\n     * \"rep\" is used for a unicast route which we don't need now; so set NULL so\n     * that operations on \"rep\" will be skipped.\n     */\n    rep = NULL;\n    mcast_group = uip_mcast6_route_add(&prefix);\n    if(mcast_group) {\n      mcast_group->dag = dag;\n      mcast_group->lifetime = RPL_LIFETIME(instance, lifetime);\n    }\n    goto fwd_dao;\n  }\n#endif\n\n  rep = uip_ds6_route_lookup(&prefix);\n\n  if(lifetime == RPL_ZERO_LIFETIME) {\n    LOG_INFO(\"No-Path DAO received\\n\");\n    /* No-Path DAO received; invoke the route purging routine. */\n    if(rep != NULL &&\n       !RPL_ROUTE_IS_NOPATH_RECEIVED(rep) &&\n       rep->length == prefixlen &&\n       uip_ds6_route_nexthop(rep) != NULL &&\n       uip_ipaddr_cmp(uip_ds6_route_nexthop(rep), &dao_sender_addr)) {\n      LOG_DBG(\"Setting expiration timer for prefix \");\n      LOG_DBG_6ADDR(&prefix);\n      LOG_DBG_(\"\\n\");\n      RPL_ROUTE_SET_NOPATH_RECEIVED(rep);\n      rep->state.lifetime = RPL_NOPATH_REMOVAL_DELAY;\n\n      /* We forward the incoming No-Path DAO to our parent, if we have\n         one. */\n      if(dag->preferred_parent != NULL &&\n         rpl_parent_get_ipaddr(dag->preferred_parent) != NULL) {\n        uint8_t out_seq;\n        out_seq = prepare_for_dao_fwd(sequence, rep);\n\n        LOG_DBG(\"Forwarding No-path DAO to parent - out_seq:%d\",\n               out_seq);\n        LOG_DBG_6ADDR(rpl_parent_get_ipaddr(dag->preferred_parent));\n        LOG_DBG_(\"\\n\");\n\n        buffer = UIP_ICMP_PAYLOAD;\n        buffer[3] = out_seq; /* add an outgoing seq no before fwd */\n        uip_icmp6_send(rpl_parent_get_ipaddr(dag->preferred_parent),\n                       ICMP6_RPL, RPL_CODE_DAO, buffer_length);\n      }\n    }\n    /* independent if we remove or not - ACK the request */\n    if(flags & RPL_DAO_K_FLAG) {\n      /* indicate that we accepted the no-path DAO */\n      uipbuf_clear();\n      dao_ack_output(instance, &dao_sender_addr, sequence,\n                     RPL_DAO_ACK_UNCONDITIONAL_ACCEPT);\n    }\n    return;\n  }\n\n  LOG_INFO(\"Adding DAO route\\n\");\n\n  /* Update and add neighbor - if no room - fail. */\n  if((nbr = rpl_icmp6_update_nbr_table(&dao_sender_addr, NBR_TABLE_REASON_RPL_DAO, instance)) == NULL) {\n    LOG_ERR(\"Out of Memory, dropping DAO from \");\n    LOG_ERR_6ADDR(&dao_sender_addr);\n    LOG_ERR_(\", \");\n    LOG_ERR_LLADDR(packetbuf_addr(PACKETBUF_ADDR_SENDER));\n    LOG_ERR_(\"\\n\");\n    if(flags & RPL_DAO_K_FLAG) {\n      /* signal the failure to add the node */\n      dao_ack_output(instance, &dao_sender_addr, sequence,\n                     is_root ? RPL_DAO_ACK_UNABLE_TO_ADD_ROUTE_AT_ROOT :\n                     RPL_DAO_ACK_UNABLE_TO_ACCEPT);\n    }\n    return;\n  }\n\n  rep = rpl_add_route(dag, &prefix, prefixlen, &dao_sender_addr);\n  if(rep == NULL) {\n    RPL_STAT(rpl_stats.mem_overflows++);\n    LOG_ERR(\"Could not add a route after receiving a DAO\\n\");\n    if(flags & RPL_DAO_K_FLAG) {\n      /* signal the failure to add the node */\n      dao_ack_output(instance, &dao_sender_addr, sequence,\n                     is_root ? RPL_DAO_ACK_UNABLE_TO_ADD_ROUTE_AT_ROOT :\n                     RPL_DAO_ACK_UNABLE_TO_ACCEPT);\n    }\n    return;\n  }\n\n  /* set lifetime and clear NOPATH bit */\n  rep->state.lifetime = RPL_LIFETIME(instance, lifetime);\n  RPL_ROUTE_CLEAR_NOPATH_RECEIVED(rep);\n\n#if RPL_WITH_MULTICAST\nfwd_dao:\n#endif\n\n  if(learned_from == RPL_ROUTE_FROM_UNICAST_DAO) {\n    int should_ack = 0;\n\n    if(flags & RPL_DAO_K_FLAG) {\n      if(rep != NULL) {\n        /*\n         * check if this route is already installed and we can ack now!\n         * not pending - and same seq-no means that we can ack.\n         * (e.g. the route is installed already so it will not take any\n         * more room that it already takes - so should be ok!)\n         */\n        if((!RPL_ROUTE_IS_DAO_PENDING(rep) &&\n            rep->state.dao_seqno_in == sequence) ||\n           dag->rank == ROOT_RANK(instance)) {\n          should_ack = 1;\n        }\n      }\n    }\n\n    if(dag->preferred_parent != NULL &&\n       rpl_parent_get_ipaddr(dag->preferred_parent) != NULL) {\n      uint8_t out_seq = 0;\n      if(rep != NULL) {\n        /* if this is pending and we get the same seq no it is a retrans */\n        if(RPL_ROUTE_IS_DAO_PENDING(rep) &&\n           rep->state.dao_seqno_in == sequence) {\n          /* keep the same seq-no as before for parent also */\n          out_seq = rep->state.dao_seqno_out;\n        } else {\n          out_seq = prepare_for_dao_fwd(sequence, rep);\n        }\n      }\n\n      LOG_DBG(\"Forwarding DAO to parent \");\n      LOG_DBG_6ADDR(rpl_parent_get_ipaddr(dag->preferred_parent));\n      LOG_DBG_(\" in seq: %d out seq: %d\\n\", sequence, out_seq);\n\n      buffer = UIP_ICMP_PAYLOAD;\n      buffer[3] = out_seq; /* add an outgoing seq no before fwd */\n      uip_icmp6_send(rpl_parent_get_ipaddr(dag->preferred_parent),\n                     ICMP6_RPL, RPL_CODE_DAO, buffer_length);\n    }\n    if(should_ack) {\n      LOG_DBG(\"Sending DAO ACK\\n\");\n      uipbuf_clear();\n      dao_ack_output(instance, &dao_sender_addr, sequence,\n                     RPL_DAO_ACK_UNCONDITIONAL_ACCEPT);\n    }\n  }\n#endif /* RPL_WITH_STORING */\n}",
  "abstract_func": "static void\ndao_input_storing(void)\n{\n#if VAR_0\n  uip_ipaddr_t VAR_1;\n  rpl_dag_t *VAR_2;\n  rpl_instance_t *VAR_3;\n  unsigned char *VAR_4;\n  uint16_t VAR_5;\n  uint8_t VAR_6;\n  uint8_t VAR_7;\n  uint8_t VAR_8;\n  uint8_t VAR_9;\n  uint8_t VAR_10;\n  /* COMMENT_0 */\n                        \n                         \n    \n  uip_ipaddr_t VAR_11;\n  uip_ds6_route_t *VAR_12;\n  uint8_t VAR_13;\n  int VAR_14;\n  int VAR_15;\n  int VAR_16;\n  int VAR_17;\n  rpl_parent_t *VAR_18;\n  uip_ds6_nbr_t *VAR_19;\n  int VAR_20;\n\n  VAR_8 = 0;\n  VAR_18 = NULL;\n  memset(&VAR_11, 0, sizeof(VAR_11));\n\n  uip_ipaddr_copy(&VAR_1, &VAR_21->srcipaddr);\n\n  VAR_4 = VAR_22;\n  VAR_13 = VAR_23 - VAR_24;\n\n  VAR_14 = 0;\n  VAR_6 = VAR_4[VAR_14++];\n\n  VAR_3 = rpl_get_instance(VAR_6);\n\n  VAR_7 = VAR_3->default_lifetime;\n\n  VAR_9 = VAR_4[VAR_14++];\n  /* COMMENT_4 */\n  VAR_14++;\n  VAR_5 = VAR_4[VAR_14++];\n\n  VAR_2 = VAR_3->current_dag;\n  VAR_20 = (VAR_2->rank == ROOT_RANK(VAR_3));\n\n  /* COMMENT_5 */\n  if(VAR_9 & VAR_25) {\n    if(memcmp(&VAR_2->dag_id, &VAR_4[VAR_14], sizeof(VAR_2->dag_id))) {\n      LOG_INFO(\"Ignoring a DAO for a DAG different from ours\\n\");\n      return;\n    }\n    VAR_14 += 16;\n  }\n\n  VAR_17 = uip_is_addr_mcast(&VAR_1) ?\n    VAR_26 : VAR_27;\n\n  /* COMMENT_6 */\n  LOG_DBG(\"Received a (%s) DAO with sequence number %u from \",\n         VAR_17 == VAR_27? \"unicast\": \"multicast\", VAR_5);\n  LOG_DBG_6ADDR(&VAR_1);\n  LOG_DBG_(\"\\n\");\n\n  if(VAR_17 == VAR_27) {\n    /* COMMENT_7 */\n    VAR_18 = rpl_find_parent(VAR_2, &VAR_1);\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    if(VAR_18 != NULL &&\n       DAG_RANK(VAR_18->rank, VAR_3) < DAG_RANK(VAR_2->rank, VAR_3)) {\n      LOG_WARN(\"Loop detected when receiving a unicast DAO from a node with a lower rank! (%u < %u)\\n\",\n             DAG_RANK(VAR_18->rank, VAR_3), DAG_RANK(VAR_2->rank, VAR_3));\n      VAR_18->rank = VAR_28;\n      VAR_18->flags |= VAR_29;\n      return;\n    }\n\n    /* COMMENT_10 */\n    if(VAR_18 != NULL && VAR_18 == VAR_2->preferred_parent) {\n      LOG_WARN(\"Loop detected when receiving a unicast DAO from our parent\\n\");\n      VAR_18->rank = VAR_28;\n      VAR_18->flags |= VAR_29;\n      return;\n    }\n  }\n\n  /* COMMENT_11 */\n  for(VAR_16 = VAR_14; VAR_16 < VAR_13; VAR_16 += VAR_15) {\n    VAR_10 = VAR_4[VAR_16];\n    if(VAR_10 == VAR_30) {\n      VAR_15 = 1;\n    } else {\n      /* COMMENT_12 */\n      VAR_15 = 2 + VAR_4[VAR_16 + 1];\n    }\n\n    switch(VAR_10) {\n      case VAR_31:\n        /* COMMENT_13 */\n        VAR_8 = VAR_4[VAR_16 + 3];\n        if(VAR_8 == 0) {\n          /* COMMENT_14 */\n          break;\n        }\n        if(VAR_8 > 128) {\n          LOG_ERR(\"Too large target prefix length %d\\n\", VAR_8);\n          return;\n        }\n        if(VAR_16 + 4 + ((VAR_8 + 7) / VAR_32) > VAR_13) {\n          LOG_ERR(\"Insufficient space to copy RPL Target of %d bits\\n\",\n                  VAR_8);\n          return;\n        }\n        memset(&VAR_11, 0, sizeof(VAR_11));\n        memcpy(&VAR_11, VAR_4 + VAR_16 + 4, (VAR_8 + 7) / VAR_32);\n        break;\n      case VAR_33:\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n                                               \n        VAR_7 = VAR_4[VAR_16 + 5];\n        /* COMMENT_18 */\n        break;\n    }\n  }\n\n  LOG_INFO(\"DAO lifetime: %u, prefix length: %u prefix: \",\n         (unsigned)VAR_7, (unsigned)VAR_8);\n  LOG_INFO_6ADDR(&VAR_11);\n  LOG_INFO_(\"\\n\");\n\n#if VAR_34\n  if(uip_is_addr_mcast_global(&VAR_11)) {\n    /* COMMENT_19 */\n                                                                                \n                                                \n       \n    VAR_12 = NULL;\n    VAR_35 = uip_mcast6_route_add(&VAR_11);\n    if(VAR_35) {\n      VAR_35->dag = VAR_2;\n      VAR_35->lifetime = RPL_LIFETIME(VAR_3, VAR_7);\n    }\n    goto fwd_dao;\n  }\n#endif\n\n  VAR_12 = uip_ds6_route_lookup(&VAR_11);\n\n  if(VAR_7 == VAR_36) {\n    LOG_INFO(\"No-Path DAO received\\n\");\n    /* COMMENT_23 */\n    if(VAR_12 != NULL &&\n       !RPL_ROUTE_IS_NOPATH_RECEIVED(VAR_12) &&\n       VAR_12->length == VAR_8 &&\n       uip_ds6_route_nexthop(VAR_12) != NULL &&\n       uip_ipaddr_cmp(uip_ds6_route_nexthop(VAR_12), &VAR_1)) {\n      LOG_DBG(\"Setting expiration timer for prefix \");\n      LOG_DBG_6ADDR(&VAR_11);\n      LOG_DBG_(\"\\n\");\n      RPL_ROUTE_SET_NOPATH_RECEIVED(VAR_12);\n      VAR_12->state.lifetime = VAR_37;\n\n      /* COMMENT_24 */\n                \n      if(VAR_2->preferred_parent != NULL &&\n         rpl_parent_get_ipaddr(VAR_2->preferred_parent) != NULL) {\n        uint8_t VAR_38;\n        VAR_38 = prepare_for_dao_fwd(VAR_5, VAR_12);\n\n        LOG_DBG(\"Forwarding No-path DAO to parent - out_seq:%d\",\n               VAR_38);\n        LOG_DBG_6ADDR(rpl_parent_get_ipaddr(VAR_2->preferred_parent));\n        LOG_DBG_(\"\\n\");\n\n        VAR_4 = VAR_22;\n        VAR_4[3] = VAR_38; /* COMMENT_26 */\n        uip_icmp6_send(rpl_parent_get_ipaddr(VAR_2->preferred_parent),\n                       VAR_39, VAR_40, VAR_13);\n      }\n    }\n    /* COMMENT_27 */\n    if(VAR_9 & VAR_41) {\n      /* COMMENT_28 */\n      uipbuf_clear();\n      dao_ack_output(VAR_3, &VAR_1, VAR_5,\n                     VAR_42);\n    }\n    return;\n  }\n\n  LOG_INFO(\"Adding DAO route\\n\");\n\n  /* COMMENT_29 */\n  if((VAR_19 = rpl_icmp6_update_nbr_table(&VAR_1, VAR_43, VAR_3)) == NULL) {\n    LOG_ERR(\"Out of Memory, dropping DAO from \");\n    LOG_ERR_6ADDR(&VAR_1);\n    LOG_ERR_(\", \");\n    LOG_ERR_LLADDR(packetbuf_addr(VAR_44));\n    LOG_ERR_(\"\\n\");\n    if(VAR_9 & VAR_41) {\n      /* COMMENT_30 */\n      dao_ack_output(VAR_3, &VAR_1, VAR_5,\n                     VAR_20 ? VAR_45 :\n                     VAR_46);\n    }\n    return;\n  }\n\n  VAR_12 = rpl_add_route(VAR_2, &VAR_11, VAR_8, &VAR_1);\n  if(VAR_12 == NULL) {\n    RPL_STAT(VAR_47.mem_overflows++);\n    LOG_ERR(\"Could not add a route after receiving a DAO\\n\");\n    if(VAR_9 & VAR_41) {\n      /* COMMENT_30 */\n      dao_ack_output(VAR_3, &VAR_1, VAR_5,\n                     VAR_20 ? VAR_45 :\n                     VAR_46);\n    }\n    return;\n  }\n\n  /* COMMENT_31 */\n  VAR_12->state.lifetime = RPL_LIFETIME(VAR_3, VAR_7);\n  RPL_ROUTE_CLEAR_NOPATH_RECEIVED(VAR_12);\n\n#if VAR_34\nfwd_dao:\n#endif\n\n  if(VAR_17 == VAR_27) {\n    int VAR_48 = 0;\n\n    if(VAR_9 & VAR_41) {\n      if(VAR_12 != NULL) {\n        /* COMMENT_32 */\n                                                                       \n                                                               \n                                                                       \n                                                              \n           \n        if((!RPL_ROUTE_IS_DAO_PENDING(VAR_12) &&\n            VAR_12->state.dao_seqno_in == VAR_5) ||\n           VAR_2->rank == ROOT_RANK(VAR_3)) {\n          VAR_48 = 1;\n        }\n      }\n    }\n\n    if(VAR_2->preferred_parent != NULL &&\n       rpl_parent_get_ipaddr(VAR_2->preferred_parent) != NULL) {\n      uint8_t VAR_38 = 0;\n      if(VAR_12 != NULL) {\n        /* COMMENT_38 */\n        if(RPL_ROUTE_IS_DAO_PENDING(VAR_12) &&\n           VAR_12->state.dao_seqno_in == VAR_5) {\n          /* COMMENT_39 */\n          VAR_38 = VAR_12->state.dao_seqno_out;\n        } else {\n          VAR_38 = prepare_for_dao_fwd(VAR_5, VAR_12);\n        }\n      }\n\n      LOG_DBG(\"Forwarding DAO to parent \");\n      LOG_DBG_6ADDR(rpl_parent_get_ipaddr(VAR_2->preferred_parent));\n      LOG_DBG_(\" in seq: %d out seq: %d\\n\", VAR_5, VAR_38);\n\n      VAR_4 = VAR_22;\n      VAR_4[3] = VAR_38; /* COMMENT_26 */\n      uip_icmp6_send(rpl_parent_get_ipaddr(VAR_2->preferred_parent),\n                     VAR_39, VAR_40, VAR_13);\n    }\n    if(VAR_48) {\n      LOG_DBG(\"Sending DAO ACK\\n\");\n      uipbuf_clear();\n      dao_ack_output(VAR_3, &VAR_1, VAR_5,\n                     VAR_42);\n    }\n  }\n#endif /* COMMENT_40 */\n}",
  "func_graph_path": "contiki-ng/587ae59956e00316fd44fd7072ac3a6a07b4b20f/rpl-icmp6.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -106,6 +106,19 @@\n       case RPL_OPTION_TARGET:\n         /* Handle the target option. */\n         prefixlen = buffer[i + 3];\n+        if(prefixlen == 0) {\n+          /* Ignore option targets with a prefix length of 0. */\n+          break;\n+        }\n+        if(prefixlen > 128) {\n+          LOG_ERR(\"Too large target prefix length %d\\n\", prefixlen);\n+          return;\n+        }\n+        if(i + 4 + ((prefixlen + 7) / CHAR_BIT) > buffer_length) {\n+          LOG_ERR(\"Insufficient space to copy RPL Target of %d bits\\n\",\n+                  prefixlen);\n+          return;\n+        }\n         memset(&prefix, 0, sizeof(prefix));\n         memcpy(&prefix, buffer + i + 4, (prefixlen + 7) / CHAR_BIT);\n         break;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if(prefixlen == 0) {",
      "          /* Ignore option targets with a prefix length of 0. */",
      "          break;",
      "        }",
      "        if(prefixlen > 128) {",
      "          LOG_ERR(\"Too large target prefix length %d\\n\", prefixlen);",
      "          return;",
      "        }",
      "        if(i + 4 + ((prefixlen + 7) / CHAR_BIT) > buffer_length) {",
      "          LOG_ERR(\"Insufficient space to copy RPL Target of %d bits\\n\",",
      "                  prefixlen);",
      "          return;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1615",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/contiki-ng/contiki-ng/pull/1615: 403 Client Error: Forbidden for url: https://api.github.com/repos/contiki-ng/contiki-ng/pulls/1615",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\nThe commit adds essential validation checks for prefix lengths and buffer boundaries, directly addressing security risks of invalid input, thus qualifying as a security fix with high confidence."
}