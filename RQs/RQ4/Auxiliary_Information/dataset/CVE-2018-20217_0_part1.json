{
  "cve_id": "CVE-2018-20217",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Ignore password attributes for S4U2Self requests\n\nFor consistency with Windows KDCs, allow protocol transition to work\neven if the password has expired or needs changing.\n\nAlso, when looking up an enterprise principal with an AS request,\ntreat ERR_KEY_EXP as confirmation that the client is present in the\nrealm.\n\n[ghudson@mit.edu: added comment in kdc_process_s4u2self_req(); edited\ncommit message]\n\nticket: 8763 (new)\ntags: pullup\ntarget_version: 1.17",
  "commit_hash": "5e6d1796106df8ba6bc1973ee0917c170d929086",
  "git_url": "https://github.com/krb5/krb5/commit/5e6d1796106df8ba6bc1973ee0917c170d929086",
  "file_path": "src/kdc/kdc_util.c",
  "func_name": "kdc_process_s4u2self_req",
  "func_before": "krb5_error_code\nkdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n                         krb5_kdc_req *request,\n                         krb5_const_principal client_princ,\n                         krb5_const_principal header_srv_princ,\n                         krb5_boolean issuing_referral,\n                         const krb5_db_entry *server,\n                         krb5_keyblock *tgs_subkey,\n                         krb5_keyblock *tgs_session,\n                         krb5_timestamp kdc_time,\n                         krb5_pa_s4u_x509_user **s4u_x509_user,\n                         krb5_db_entry **princ_ptr,\n                         const char **status)\n{\n    krb5_error_code             code;\n    krb5_boolean                is_local_tgt;\n    krb5_pa_data                *pa_data;\n    int                         flags;\n    krb5_db_entry               *princ;\n\n    *princ_ptr = NULL;\n\n    pa_data = krb5int_find_pa_data(kdc_context,\n                                   request->padata, KRB5_PADATA_S4U_X509_USER);\n    if (pa_data != NULL) {\n        code = kdc_process_s4u_x509_user(kdc_context,\n                                         request,\n                                         pa_data,\n                                         tgs_subkey,\n                                         tgs_session,\n                                         s4u_x509_user,\n                                         status);\n        if (code != 0)\n            return code;\n    } else {\n        pa_data = krb5int_find_pa_data(kdc_context,\n                                       request->padata, KRB5_PADATA_FOR_USER);\n        if (pa_data != NULL) {\n            code = kdc_process_for_user(kdc_active_realm,\n                                        pa_data,\n                                        tgs_session,\n                                        s4u_x509_user,\n                                        status);\n            if (code != 0)\n                return code;\n        } else\n            return 0;\n    }\n\n    /*\n     * We need to compare the client name in the TGT with the requested\n     * server name. Supporting server name aliases without assuming a\n     * global name service makes this difficult to do.\n     *\n     * The comparison below handles the following cases (note that the\n     * term \"principal name\" below excludes the realm).\n     *\n     * (1) The requested service is a host-based service with two name\n     *     components, in which case we assume the principal name to\n     *     contain sufficient qualifying information. The realm is\n     *     ignored for the purpose of comparison.\n     *\n     * (2) The requested service name is an enterprise principal name:\n     *     the service principal name is compared with the unparsed\n     *     form of the client name (including its realm).\n     *\n     * (3) The requested service is some other name type: an exact\n     *     match is required.\n     *\n     * An alternative would be to look up the server once again with\n     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact\n     * match between the returned name and client_princ. However, this\n     * assumes that the client set FLAG_CANONICALIZE when requesting\n     * the TGT and that we have a global name service.\n     */\n    flags = 0;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_SRV_HST:                   /* (1) */\n        if (krb5_princ_size(kdc_context, request->server) == 2)\n            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\n        break;\n    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */\n        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\n        break;\n    default:                                /* (3) */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(kdc_context,\n                                      request->server,\n                                      client_princ,\n                                      flags)) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */\n    }\n\n    /*\n     * Protocol transition is mutually exclusive with renew/forward/etc\n     * as well as user-to-user and constrained delegation. This check\n     * is also made in validate_as_request().\n     *\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * Valid S4U2Self requests can occur in the following combinations:\n     *\n     * (1) local TGT, local user, local server\n     * (2) cross TGT, local user, issuing referral\n     * (3) cross TGT, non-local user, issuing referral\n     * (4) cross TGT, non-local user, local server\n     *\n     * The first case is for a single-realm S4U2Self scenario; the second,\n     * third, and fourth cases are for the initial, intermediate (if any), and\n     * final cross-realm requests in a multi-realm scenario.\n     */\n\n    is_local_tgt = !is_cross_tgs_principal(header_srv_princ);\n    if (is_local_tgt && issuing_referral) {\n        /* The requesting server appears to no longer exist, and we found\n         * a referral instead.  Treat this as a server lookup failure. */\n        *status = \"LOOKING_UP_SERVER\";\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    }\n\n    /*\n     * Do not attempt to lookup principals in foreign realms.\n     */\n    if (is_local_principal(kdc_active_realm,\n                           (*s4u_x509_user)->user_id.user)) {\n        krb5_db_entry no_server;\n        krb5_pa_data **e_data = NULL;\n\n        if (!is_local_tgt && !issuing_referral) {\n            /* A local server should not need a cross-realm TGT to impersonate\n             * a local principal. */\n            *status = \"NOT_CROSS_REALM_REQUEST\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error */\n        }\n\n        code = krb5_db_get_principal(kdc_context,\n                                     (*s4u_x509_user)->user_id.user,\n                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);\n        if (code == KRB5_KDB_NOENTRY) {\n            *status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        } else if (code) {\n            *status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return code; /* caller can free for_user */\n        }\n\n        memset(&no_server, 0, sizeof(no_server));\n\n        code = validate_as_request(kdc_active_realm, request, *princ,\n                                   no_server, kdc_time, status, &e_data);\n        if (code) {\n            krb5_db_free_principal(kdc_context, princ);\n            krb5_free_pa_data(kdc_context, e_data);\n            return code;\n        }\n\n        *princ_ptr = princ;\n    } else if (is_local_tgt) {\n        /*\n         * The server is asking to impersonate a principal from another realm,\n         * using a local TGT.  It should instead ask that principal's realm and\n         * follow referrals back to us.\n         */\n        *status = \"S4U2SELF_CLIENT_NOT_OURS\";\n        return KRB5KDC_ERR_POLICY; /* match Windows error */\n    }\n\n    return 0;\n}",
  "abstract_func_before": "krb5_error_code\nkdc_process_s4u2self_req(kdc_realm_t *VAR_0,\n                         krb5_kdc_req *VAR_1,\n                         krb5_const_principal VAR_2,\n                         krb5_const_principal VAR_3,\n                         krb5_boolean VAR_4,\n                         const krb5_db_entry *VAR_5,\n                         krb5_keyblock *VAR_6,\n                         krb5_keyblock *VAR_7,\n                         krb5_timestamp VAR_8,\n                         krb5_pa_s4u_x509_user **VAR_9,\n                         krb5_db_entry **VAR_10,\n                         const char **VAR_11)\n{\n    krb5_error_code             VAR_12;\n    krb5_boolean                VAR_13;\n    krb5_pa_data                *VAR_14;\n    int                         VAR_15;\n    krb5_db_entry               *VAR_16;\n\n    *VAR_10 = NULL;\n\n    VAR_14 = krb5int_find_pa_data(VAR_17,\n                                   VAR_1->padata, VAR_18);\n    if (VAR_14 != NULL) {\n        VAR_12 = kdc_process_s4u_x509_user(VAR_17,\n                                         VAR_1,\n                                         VAR_14,\n                                         VAR_6,\n                                         VAR_7,\n                                         VAR_9,\n                                         VAR_11);\n        if (VAR_12 != 0)\n            return VAR_12;\n    } else {\n        VAR_14 = krb5int_find_pa_data(VAR_17,\n                                       VAR_1->padata, VAR_19);\n        if (VAR_14 != NULL) {\n            VAR_12 = kdc_process_for_user(VAR_0,\n                                        VAR_14,\n                                        VAR_7,\n                                        VAR_9,\n                                        VAR_11);\n            if (VAR_12 != 0)\n                return VAR_12;\n        } else\n            return 0;\n    }\n\n    /* COMMENT_0 */\n                                                                       \n                                                                     \n                                                      \n      \n                                                                      \n                                                       \n      \n                                                                      \n                                                                    \n                                                                  \n                                                 \n      \n                                                                      \n                                                                   \n                                                         \n      \n                                                                  \n                             \n      \n                                                                    \n                                                                      \n                                                                      \n                                                                    \n                                                      \n       \n    VAR_15 = 0;\n    switch (krb5_princ_type(VAR_17, VAR_1->server)) {\n    case VAR_20:                   /* COMMENT_22 */\n        if (krb5_princ_size(VAR_17, VAR_1->server) == 2)\n            VAR_15 |= VAR_21;\n        break;\n    case VAR_22:      /* COMMENT_23 */\n        VAR_15 |= VAR_23;\n        break;\n    default:                                /* COMMENT_24 */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(VAR_17,\n                                      VAR_1->server,\n                                      VAR_2,\n                                      VAR_15)) {\n        *VAR_11 = \"INVALID_S4U2SELF_REQUEST\";\n        return VAR_24; /* COMMENT_25 */\n    }\n\n    /* COMMENT_26 */\n                                                                       \n                                                                     \n                                             \n      \n                                                                         \n                                                              \n       \n    if (VAR_1->kdc_options & VAR_25) {\n        *VAR_11 = \"INVALID AS OPTIONS\";\n        return VAR_26;\n    }\n\n    /* COMMENT_34 */\n                                                                       \n      \n                                              \n                                                  \n                                                      \n                                                  \n      \n                                                                          \n                                                                              \n                                                            \n       \n\n    VAR_13 = !is_cross_tgs_principal(VAR_3);\n    if (VAR_13 && VAR_4) {\n        /* COMMENT_45 */\n                                                                         \n        *VAR_11 = \"LOOKING_UP_SERVER\";\n        return VAR_27;\n    }\n\n    /* COMMENT_47 */\n                                                             \n       \n    if (is_local_principal(VAR_0,\n                           (*VAR_9)->user_id.user)) {\n        krb5_db_entry VAR_28;\n        krb5_pa_data **VAR_29 = NULL;\n\n        if (!VAR_13 && !VAR_4) {\n            /* COMMENT_50 */\n                                    \n            *VAR_11 = \"NOT_CROSS_REALM_REQUEST\";\n            return VAR_24; /* COMMENT_52 */\n        }\n\n        VAR_12 = krb5_db_get_principal(VAR_17,\n                                     (*VAR_9)->user_id.user,\n                                     VAR_30, &VAR_16);\n        if (VAR_12 == VAR_31) {\n            *VAR_11 = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return VAR_24;\n        } else if (VAR_12) {\n            *VAR_11 = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return VAR_12; /* COMMENT_53 */\n        }\n\n        memset(&VAR_28, 0, sizeof(VAR_28));\n\n        VAR_12 = validate_as_request(VAR_0, VAR_1, *VAR_16,\n                                   VAR_28, VAR_8, VAR_11, &VAR_29);\n        if (VAR_12) {\n            krb5_db_free_principal(VAR_17, VAR_16);\n            krb5_free_pa_data(VAR_17, VAR_29);\n            return VAR_12;\n        }\n\n        *VAR_10 = VAR_16;\n    } else if (VAR_13) {\n        /* COMMENT_54 */\n                                                                              \n                                                                               \n                                       \n           \n        *VAR_11 = \"S4U2SELF_CLIENT_NOT_OURS\";\n        return VAR_32; /* COMMENT_52 */\n    }\n\n    return 0;\n}",
  "func_graph_path_before": "krb5/5e6d1796106df8ba6bc1973ee0917c170d929086/kdc_util.c/vul/before/0.json",
  "func": "krb5_error_code\nkdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n                         krb5_kdc_req *request,\n                         krb5_const_principal client_princ,\n                         krb5_const_principal header_srv_princ,\n                         krb5_boolean issuing_referral,\n                         const krb5_db_entry *server,\n                         krb5_keyblock *tgs_subkey,\n                         krb5_keyblock *tgs_session,\n                         krb5_timestamp kdc_time,\n                         krb5_pa_s4u_x509_user **s4u_x509_user,\n                         krb5_db_entry **princ_ptr,\n                         const char **status)\n{\n    krb5_error_code             code;\n    krb5_boolean                is_local_tgt;\n    krb5_pa_data                *pa_data;\n    int                         flags;\n    krb5_db_entry               *princ;\n\n    *princ_ptr = NULL;\n\n    pa_data = krb5int_find_pa_data(kdc_context,\n                                   request->padata, KRB5_PADATA_S4U_X509_USER);\n    if (pa_data != NULL) {\n        code = kdc_process_s4u_x509_user(kdc_context,\n                                         request,\n                                         pa_data,\n                                         tgs_subkey,\n                                         tgs_session,\n                                         s4u_x509_user,\n                                         status);\n        if (code != 0)\n            return code;\n    } else {\n        pa_data = krb5int_find_pa_data(kdc_context,\n                                       request->padata, KRB5_PADATA_FOR_USER);\n        if (pa_data != NULL) {\n            code = kdc_process_for_user(kdc_active_realm,\n                                        pa_data,\n                                        tgs_session,\n                                        s4u_x509_user,\n                                        status);\n            if (code != 0)\n                return code;\n        } else\n            return 0;\n    }\n\n    /*\n     * We need to compare the client name in the TGT with the requested\n     * server name. Supporting server name aliases without assuming a\n     * global name service makes this difficult to do.\n     *\n     * The comparison below handles the following cases (note that the\n     * term \"principal name\" below excludes the realm).\n     *\n     * (1) The requested service is a host-based service with two name\n     *     components, in which case we assume the principal name to\n     *     contain sufficient qualifying information. The realm is\n     *     ignored for the purpose of comparison.\n     *\n     * (2) The requested service name is an enterprise principal name:\n     *     the service principal name is compared with the unparsed\n     *     form of the client name (including its realm).\n     *\n     * (3) The requested service is some other name type: an exact\n     *     match is required.\n     *\n     * An alternative would be to look up the server once again with\n     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact\n     * match between the returned name and client_princ. However, this\n     * assumes that the client set FLAG_CANONICALIZE when requesting\n     * the TGT and that we have a global name service.\n     */\n    flags = 0;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_SRV_HST:                   /* (1) */\n        if (krb5_princ_size(kdc_context, request->server) == 2)\n            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\n        break;\n    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */\n        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\n        break;\n    default:                                /* (3) */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(kdc_context,\n                                      request->server,\n                                      client_princ,\n                                      flags)) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */\n    }\n\n    /*\n     * Protocol transition is mutually exclusive with renew/forward/etc\n     * as well as user-to-user and constrained delegation. This check\n     * is also made in validate_as_request().\n     *\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * Valid S4U2Self requests can occur in the following combinations:\n     *\n     * (1) local TGT, local user, local server\n     * (2) cross TGT, local user, issuing referral\n     * (3) cross TGT, non-local user, issuing referral\n     * (4) cross TGT, non-local user, local server\n     *\n     * The first case is for a single-realm S4U2Self scenario; the second,\n     * third, and fourth cases are for the initial, intermediate (if any), and\n     * final cross-realm requests in a multi-realm scenario.\n     */\n\n    is_local_tgt = !is_cross_tgs_principal(header_srv_princ);\n    if (is_local_tgt && issuing_referral) {\n        /* The requesting server appears to no longer exist, and we found\n         * a referral instead.  Treat this as a server lookup failure. */\n        *status = \"LOOKING_UP_SERVER\";\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    }\n\n    /*\n     * Do not attempt to lookup principals in foreign realms.\n     */\n    if (is_local_principal(kdc_active_realm,\n                           (*s4u_x509_user)->user_id.user)) {\n        krb5_db_entry no_server;\n        krb5_pa_data **e_data = NULL;\n\n        if (!is_local_tgt && !issuing_referral) {\n            /* A local server should not need a cross-realm TGT to impersonate\n             * a local principal. */\n            *status = \"NOT_CROSS_REALM_REQUEST\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error */\n        }\n\n        code = krb5_db_get_principal(kdc_context,\n                                     (*s4u_x509_user)->user_id.user,\n                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);\n        if (code == KRB5_KDB_NOENTRY) {\n            *status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        } else if (code) {\n            *status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return code; /* caller can free for_user */\n        }\n\n        memset(&no_server, 0, sizeof(no_server));\n\n        /* Ignore password expiration and needchange attributes (as Windows\n         * does), since S4U2Self is not password authentication. */\n        princ->pw_expiration = 0;\n        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);\n\n        code = validate_as_request(kdc_active_realm, request, *princ,\n                                   no_server, kdc_time, status, &e_data);\n        if (code) {\n            krb5_db_free_principal(kdc_context, princ);\n            krb5_free_pa_data(kdc_context, e_data);\n            return code;\n        }\n\n        *princ_ptr = princ;\n    } else if (is_local_tgt) {\n        /*\n         * The server is asking to impersonate a principal from another realm,\n         * using a local TGT.  It should instead ask that principal's realm and\n         * follow referrals back to us.\n         */\n        *status = \"S4U2SELF_CLIENT_NOT_OURS\";\n        return KRB5KDC_ERR_POLICY; /* match Windows error */\n    }\n\n    return 0;\n}",
  "abstract_func": "krb5_error_code\nkdc_process_s4u2self_req(kdc_realm_t *VAR_0,\n                         krb5_kdc_req *VAR_1,\n                         krb5_const_principal VAR_2,\n                         krb5_const_principal VAR_3,\n                         krb5_boolean VAR_4,\n                         const krb5_db_entry *VAR_5,\n                         krb5_keyblock *VAR_6,\n                         krb5_keyblock *VAR_7,\n                         krb5_timestamp VAR_8,\n                         krb5_pa_s4u_x509_user **VAR_9,\n                         krb5_db_entry **VAR_10,\n                         const char **VAR_11)\n{\n    krb5_error_code             VAR_12;\n    krb5_boolean                VAR_13;\n    krb5_pa_data                *VAR_14;\n    int                         VAR_15;\n    krb5_db_entry               *VAR_16;\n\n    *VAR_10 = NULL;\n\n    VAR_14 = krb5int_find_pa_data(VAR_17,\n                                   VAR_1->padata, VAR_18);\n    if (VAR_14 != NULL) {\n        VAR_12 = kdc_process_s4u_x509_user(VAR_17,\n                                         VAR_1,\n                                         VAR_14,\n                                         VAR_6,\n                                         VAR_7,\n                                         VAR_9,\n                                         VAR_11);\n        if (VAR_12 != 0)\n            return VAR_12;\n    } else {\n        VAR_14 = krb5int_find_pa_data(VAR_17,\n                                       VAR_1->padata, VAR_19);\n        if (VAR_14 != NULL) {\n            VAR_12 = kdc_process_for_user(VAR_0,\n                                        VAR_14,\n                                        VAR_7,\n                                        VAR_9,\n                                        VAR_11);\n            if (VAR_12 != 0)\n                return VAR_12;\n        } else\n            return 0;\n    }\n\n    /* COMMENT_0 */\n                                                                       \n                                                                     \n                                                      \n      \n                                                                      \n                                                       \n      \n                                                                      \n                                                                    \n                                                                  \n                                                 \n      \n                                                                      \n                                                                   \n                                                         \n      \n                                                                  \n                             \n      \n                                                                    \n                                                                      \n                                                                      \n                                                                    \n                                                      \n       \n    VAR_15 = 0;\n    switch (krb5_princ_type(VAR_17, VAR_1->server)) {\n    case VAR_20:                   /* COMMENT_22 */\n        if (krb5_princ_size(VAR_17, VAR_1->server) == 2)\n            VAR_15 |= VAR_21;\n        break;\n    case VAR_22:      /* COMMENT_23 */\n        VAR_15 |= VAR_23;\n        break;\n    default:                                /* COMMENT_24 */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(VAR_17,\n                                      VAR_1->server,\n                                      VAR_2,\n                                      VAR_15)) {\n        *VAR_11 = \"INVALID_S4U2SELF_REQUEST\";\n        return VAR_24; /* COMMENT_25 */\n    }\n\n    /* COMMENT_26 */\n                                                                       \n                                                                     \n                                             \n      \n                                                                         \n                                                              \n       \n    if (VAR_1->kdc_options & VAR_25) {\n        *VAR_11 = \"INVALID AS OPTIONS\";\n        return VAR_26;\n    }\n\n    /* COMMENT_34 */\n                                                                       \n      \n                                              \n                                                  \n                                                      \n                                                  \n      \n                                                                          \n                                                                              \n                                                            \n       \n\n    VAR_13 = !is_cross_tgs_principal(VAR_3);\n    if (VAR_13 && VAR_4) {\n        /* COMMENT_45 */\n                                                                         \n        *VAR_11 = \"LOOKING_UP_SERVER\";\n        return VAR_27;\n    }\n\n    /* COMMENT_47 */\n                                                             \n       \n    if (is_local_principal(VAR_0,\n                           (*VAR_9)->user_id.user)) {\n        krb5_db_entry VAR_28;\n        krb5_pa_data **VAR_29 = NULL;\n\n        if (!VAR_13 && !VAR_4) {\n            /* COMMENT_50 */\n                                    \n            *VAR_11 = \"NOT_CROSS_REALM_REQUEST\";\n            return VAR_24; /* COMMENT_52 */\n        }\n\n        VAR_12 = krb5_db_get_principal(VAR_17,\n                                     (*VAR_9)->user_id.user,\n                                     VAR_30, &VAR_16);\n        if (VAR_12 == VAR_31) {\n            *VAR_11 = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return VAR_24;\n        } else if (VAR_12) {\n            *VAR_11 = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return VAR_12; /* COMMENT_53 */\n        }\n\n        memset(&VAR_28, 0, sizeof(VAR_28));\n\n        /* COMMENT_54 */\n                                                                   \n        VAR_16->pw_expiration = 0;\n        clear(VAR_16->attributes, VAR_32);\n\n        VAR_12 = validate_as_request(VAR_0, VAR_1, *VAR_16,\n                                   VAR_28, VAR_8, VAR_11, &VAR_29);\n        if (VAR_12) {\n            krb5_db_free_principal(VAR_17, VAR_16);\n            krb5_free_pa_data(VAR_17, VAR_29);\n            return VAR_12;\n        }\n\n        *VAR_10 = VAR_16;\n    } else if (VAR_13) {\n        /* COMMENT_56 */\n                                                                              \n                                                                               \n                                       \n           \n        *VAR_11 = \"S4U2SELF_CLIENT_NOT_OURS\";\n        return VAR_33; /* COMMENT_52 */\n    }\n\n    return 0;\n}",
  "func_graph_path": "krb5/5e6d1796106df8ba6bc1973ee0917c170d929086/kdc_util.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -156,6 +156,11 @@\n \n         memset(&no_server, 0, sizeof(no_server));\n \n+        /* Ignore password expiration and needchange attributes (as Windows\n+         * does), since S4U2Self is not password authentication. */\n+        princ->pw_expiration = 0;\n+        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);\n+\n         code = validate_as_request(kdc_active_realm, request, *princ,\n                                    no_server, kdc_time, status, &e_data);\n         if (code) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        /* Ignore password expiration and needchange attributes (as Windows",
      "         * does), since S4U2Self is not password authentication. */",
      "        princ->pw_expiration = 0;",
      "        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/874",
  "description": {
    "pr_info": {
      "title": "Ignore password attributes for S4U2Self requests",
      "number": 874
    },
    "comment": [
      "This allows protocol transition to work even if\r\nthe password has expired or needchange (same as\r\nin Windows implementation).\r\n\r\nAlso, when looking up an enterprise principal with an\r\nAS request, treat ERR_KEY_EXP as a sign that the realm\r\nwas found, and proceed with S4U2Self TGS request.\r\n\r\nSigned-off-by: Isaac Boukris <iboukris@gmail.com>"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}