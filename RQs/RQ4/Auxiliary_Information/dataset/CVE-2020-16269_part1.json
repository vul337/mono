{
  "cve_id": "CVE-2020-16269",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix malformed DWARF crash due invalid .debug_str reference resulting in NULL str",
  "commit_hash": "0523c79d6e63858c990821a990edcb82cf8af284",
  "git_url": "https://github.com/radareorg/radare2/commit/0523c79d6e63858c990821a990edcb82cf8af284",
  "file_path": "libr/bin/dwarf.c",
  "func_name": "parse_attr_value",
  "func_before": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tr_return_val_if_fail(def && value && hdr && obuf && obuf_len >= 1, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->data = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->data = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->data = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->data = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->data = READ64 (buf);\n\t\tvalue->data = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sdata);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->data);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->string.content = *buf ? strdup ((const char *)buf) : NULL;\n\t\tbuf += (strlen ((const char *)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->block.length = READ8 (buf);\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length + 1);\n\t\tif (!value->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->block.length = READ32 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tut8 *data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tdata[j] = READ (buf, ut8);\n\t\t\t}\n\t\t\tvalue->block.data = data;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->string.offset = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tvalue->string.content =\n\t\t\t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t} else {\n\t\t\tvalue->string.content = NULL;\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->reference = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->reference = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\tif (!value->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present: \n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->string.offset);\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->sdata = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit. \n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t// I need to add 3byte endianess free read here TODO\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->string.offset = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loclists\n\tcase DW_FORM_loclistx:\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\" PFMT64x \"\\n\", def->attr_form);\n\t\tvalue->data = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}",
  "abstract_func_before": "static const ut8 *parse_attr_value(const ut8 *VAR_0, int VAR_1,\n\t\tRBinDwarfAttrDef *VAR_2, RBinDwarfAttrValue *VAR_3,\n\t\tconst RBinDwarfCompUnitHdr *VAR_4,\n\t\tconst ut8 *VAR_5, size_t VAR_6) {\n\n\tconst ut8 *VAR_7 = VAR_0;\n\tconst ut8 *VAR_8 = VAR_0 + VAR_1;\n\tsize_t VAR_9;\n\n\tr_return_val_if_fail(VAR_2 && VAR_3 && VAR_4 && VAR_0 && VAR_1 >= 1, NULL);\n\n\tVAR_3->attr_form = VAR_2->attr_form;\n\tVAR_3->attr_name = VAR_2->attr_name;\n\tVAR_3->block.data = NULL;\n\tVAR_3->string.content = NULL;\n\tVAR_3->string.offset = 0;\n\n\tswitch (VAR_2->attr_form) {\n\tcase VAR_10:\n\t\tswitch (VAR_4->address_size) {\n\t\tcase 1:\n\t\t\tVAR_3->address = READ8 (VAR_7);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tVAR_3->address = READ16 (VAR_7);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tVAR_3->address = READ32 (VAR_7);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tVAR_3->address = READ64 (VAR_7);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)VAR_4->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase VAR_11:\n\t\tVAR_3->data = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_12:\n\t\tVAR_3->data = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_13:\n\t\tVAR_3->data = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_14:\n\t\tVAR_3->data = READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_15: /* COMMENT_0 */\n\t\tVAR_3->data = READ64 (VAR_7);\n\t\tVAR_3->data = READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_16:\n\t\tVAR_7 = r_leb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->sdata);\n\t\tbreak;\n\tcase VAR_17:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->data);\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_3->string.content = *VAR_7 ? strdup ((const char *)VAR_7) : NULL;\n\t\tVAR_7 += (strlen ((const char *)VAR_7) + 1);\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_3->block.length = READ8 (VAR_7);\n\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length + 1);\n\t\tif (!VAR_3->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (VAR_3->block.data) {\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VAR_20:\n\t\tVAR_3->block.length = READ16 (VAR_7);\n\t\tif (VAR_3->block.length > 0) {\n\t\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length);\n\t\t\tif (!VAR_3->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VAR_21:\n\t\tVAR_3->block.length = READ32 (VAR_7);\n\t\tif (VAR_3->block.length > 0) {\n\t\t\tut8 *VAR_22 = calloc (sizeof (ut8), VAR_3->block.length);\n\t\t\tif (!VAR_22) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_22[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t\tVAR_3->block.data = VAR_22;\n\t\t}\n\t\tbreak;\n\tcase VAR_23: /* COMMENT_1 */\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->block.length);\n\t\tif (!VAR_7 || VAR_7 >= VAR_8) {\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length);\n\t\tif (VAR_3->block.data) {\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VAR_24:\n\t\tVAR_3->flag = READ (VAR_7, ut8);\n\t\tbreak;\n\t/* COMMENT_2 */\n\tcase VAR_25:\n\t\tVAR_3->string.offset = dwarf_read_piece(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tif (VAR_5 && VAR_3->string.offset < VAR_6) {\n\t\t\tVAR_3->string.content =\n\t\t\t\tstrdup ((const char *)(VAR_5 + VAR_3->string.offset));\n\t\t} else {\n\t\t\tVAR_3->string.content = NULL;\n\t\t}\n\t\tbreak;\n\t/* COMMENT_3 */\n\tcase VAR_26:\n\t\tVAR_3->reference = dwarf_read_piece(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n\tcase VAR_27:\n\t\tVAR_3->reference = VAR_4->unit_offset + READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_28:\n\t\tVAR_3->reference = VAR_4->unit_offset + READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_29:\n\t\tVAR_3->reference = VAR_4->unit_offset + READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_30:\n\t\tVAR_3->reference = VAR_4->unit_offset + READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_31:\n\t\t/* COMMENT_6 */\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->reference);\n\t\tVAR_3->reference += VAR_4->unit_offset;\n\t\tbreak;\n\t/* COMMENT_7 */\n\tcase VAR_32:\n\t\tVAR_3->reference = dwarf_read_piece(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\tcase VAR_33:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->block.length);\n\t\tif (!VAR_7 || VAR_7 >= VAR_8) {\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length);\n\t\tif (!VAR_3->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (VAR_3->block.data) {\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t/* COMMENT_8 */\n\tcase VAR_34: \n\t\tVAR_3->flag = true;\n\t\tbreak;\n\tcase VAR_35:\n\t\tVAR_3->reference = READ64 (VAR_7);\n\t\tbreak;\n\t/* COMMENT_9 */\n\tcase VAR_36:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->string.offset);\n\t\tbreak;\n\tcase VAR_37:\n\t\tVAR_3->string.offset = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_38:\n\t\tVAR_3->string.offset = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_39: /* COMMENT_10 */\n\t\tVAR_7 += 3;\n\t\tbreak;\n\tcase VAR_40:\n\t\tVAR_3->string.offset = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_41:\n\t\tVAR_3->sdata = VAR_2->special;\n\t\tbreak;\n\t/* COMMENT_11 */\n                                                                \n                                                                   \n\tcase VAR_42:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->address);\n\t\tbreak;\n\tcase VAR_43:\n\t\tVAR_3->address = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_44:\n\t\tVAR_3->address = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_45:\n\t/* COMMENT_14 */\n\t\tVAR_7 += 3;\n\t\tbreak;\n\tcase VAR_46:\n\t\tVAR_3->address = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_47: /* COMMENT_15 */\n\tcase VAR_48: /* COMMENT_15 */\n\t\tVAR_3->string.offset = dwarf_read_piece(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\t/* COMMENT_16 */\n\tcase VAR_49:\n\t\tVAR_3->reference = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_50:\n\t\tVAR_3->reference = READ64 (VAR_7);\n\t\tbreak;\n\t/* COMMENT_17 */\n\tcase VAR_51:\n\t /* COMMENT_18 */\n\tcase VAR_52:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->address);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\" VAR_53 \"\\n\", VAR_2->attr_form);\n\t\tVAR_3->data = 0;\n\t\treturn NULL;\n\t}\n\treturn VAR_7;\n}",
  "func_graph_path_before": "radareorg/radare2/0523c79d6e63858c990821a990edcb82cf8af284/dwarf.c/vul/before/0.json",
  "func": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tr_return_val_if_fail(def && value && hdr && obuf && obuf_len >= 1, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->data = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->data = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->data = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->data = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->data = READ64 (buf);\n\t\tvalue->data = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sdata);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->data);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->string.content = *buf ? strdup ((const char *)buf) : NULL;\n\t\tbuf += (strlen ((const char *)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->block.length = READ8 (buf);\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length + 1);\n\t\tif (!value->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->block.length = READ32 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tut8 *data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tdata[j] = READ (buf, ut8);\n\t\t\t}\n\t\t\tvalue->block.data = data;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->string.offset = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tvalue->string.content =\n\t\t\t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->reference = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->reference = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\tif (!value->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present: \n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->string.offset);\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->sdata = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit. \n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t// I need to add 3byte endianess free read here TODO\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->string.offset = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loclists\n\tcase DW_FORM_loclistx:\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\" PFMT64x \"\\n\", def->attr_form);\n\t\tvalue->data = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}",
  "abstract_func": "static const ut8 *parse_attr_value(const ut8 *VAR_0, int VAR_1,\n\t\tRBinDwarfAttrDef *VAR_2, RBinDwarfAttrValue *VAR_3,\n\t\tconst RBinDwarfCompUnitHdr *VAR_4,\n\t\tconst ut8 *VAR_5, size_t VAR_6) {\n\n\tconst ut8 *VAR_7 = VAR_0;\n\tconst ut8 *VAR_8 = VAR_0 + VAR_1;\n\tsize_t VAR_9;\n\n\tr_return_val_if_fail(VAR_2 && VAR_3 && VAR_4 && VAR_0 && VAR_1 >= 1, NULL);\n\n\tVAR_3->attr_form = VAR_2->attr_form;\n\tVAR_3->attr_name = VAR_2->attr_name;\n\tVAR_3->block.data = NULL;\n\tVAR_3->string.content = NULL;\n\tVAR_3->string.offset = 0;\n\n\tswitch (VAR_2->attr_form) {\n\tcase VAR_10:\n\t\tswitch (VAR_4->address_size) {\n\t\tcase 1:\n\t\t\tVAR_3->address = READ8 (VAR_7);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tVAR_3->address = READ16 (VAR_7);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tVAR_3->address = READ32 (VAR_7);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tVAR_3->address = READ64 (VAR_7);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)VAR_4->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase VAR_11:\n\t\tVAR_3->data = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_12:\n\t\tVAR_3->data = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_13:\n\t\tVAR_3->data = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_14:\n\t\tVAR_3->data = READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_15: /* COMMENT_0 */\n\t\tVAR_3->data = READ64 (VAR_7);\n\t\tVAR_3->data = READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_16:\n\t\tVAR_7 = r_leb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->sdata);\n\t\tbreak;\n\tcase VAR_17:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->data);\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_3->string.content = *VAR_7 ? strdup ((const char *)VAR_7) : NULL;\n\t\tVAR_7 += (strlen ((const char *)VAR_7) + 1);\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_3->block.length = READ8 (VAR_7);\n\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length + 1);\n\t\tif (!VAR_3->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (VAR_3->block.data) {\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VAR_20:\n\t\tVAR_3->block.length = READ16 (VAR_7);\n\t\tif (VAR_3->block.length > 0) {\n\t\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length);\n\t\t\tif (!VAR_3->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VAR_21:\n\t\tVAR_3->block.length = READ32 (VAR_7);\n\t\tif (VAR_3->block.length > 0) {\n\t\t\tut8 *VAR_22 = calloc (sizeof (ut8), VAR_3->block.length);\n\t\t\tif (!VAR_22) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_22[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t\tVAR_3->block.data = VAR_22;\n\t\t}\n\t\tbreak;\n\tcase VAR_23: /* COMMENT_1 */\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->block.length);\n\t\tif (!VAR_7 || VAR_7 >= VAR_8) {\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length);\n\t\tif (VAR_3->block.data) {\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VAR_24:\n\t\tVAR_3->flag = READ (VAR_7, ut8);\n\t\tbreak;\n\t/* COMMENT_2 */\n\tcase VAR_25:\n\t\tVAR_3->string.offset = dwarf_read_piece(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tif (VAR_5 && VAR_3->string.offset < VAR_6) {\n\t\t\tVAR_3->string.content =\n\t\t\t\tstrdup ((const char *)(VAR_5 + VAR_3->string.offset));\n\t\t} else {\n\t\t\tVAR_3->string.content = NULL; /* COMMENT_3 */\n\t\t}\n\t\tbreak;\n\t/* COMMENT_4 */\n\tcase VAR_26:\n\t\tVAR_3->reference = dwarf_read_piece(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\tcase VAR_27:\n\t\tVAR_3->reference = VAR_4->unit_offset + READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_28:\n\t\tVAR_3->reference = VAR_4->unit_offset + READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_29:\n\t\tVAR_3->reference = VAR_4->unit_offset + READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_30:\n\t\tVAR_3->reference = VAR_4->unit_offset + READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_31:\n\t\t/* COMMENT_7 */\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->reference);\n\t\tVAR_3->reference += VAR_4->unit_offset;\n\t\tbreak;\n\t/* COMMENT_8 */\n\tcase VAR_32:\n\t\tVAR_3->reference = dwarf_read_piece(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\tcase VAR_33:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->block.length);\n\t\tif (!VAR_7 || VAR_7 >= VAR_8) {\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length);\n\t\tif (!VAR_3->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (VAR_3->block.data) {\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t/* COMMENT_9 */\n\tcase VAR_34: \n\t\tVAR_3->flag = true;\n\t\tbreak;\n\tcase VAR_35:\n\t\tVAR_3->reference = READ64 (VAR_7);\n\t\tbreak;\n\t/* COMMENT_10 */\n\tcase VAR_36:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->string.offset);\n\t\tbreak;\n\tcase VAR_37:\n\t\tVAR_3->string.offset = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_38:\n\t\tVAR_3->string.offset = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_39: /* COMMENT_11 */\n\t\tVAR_7 += 3;\n\t\tbreak;\n\tcase VAR_40:\n\t\tVAR_3->string.offset = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_41:\n\t\tVAR_3->sdata = VAR_2->special;\n\t\tbreak;\n\t/* COMMENT_12 */\n                                                                \n                                                                   \n\tcase VAR_42:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->address);\n\t\tbreak;\n\tcase VAR_43:\n\t\tVAR_3->address = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_44:\n\t\tVAR_3->address = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_45:\n\t/* COMMENT_15 */\n\t\tVAR_7 += 3;\n\t\tbreak;\n\tcase VAR_46:\n\t\tVAR_3->address = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_47: /* COMMENT_16 */\n\tcase VAR_48: /* COMMENT_16 */\n\t\tVAR_3->string.offset = dwarf_read_piece(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\t/* COMMENT_17 */\n\tcase VAR_49:\n\t\tVAR_3->reference = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_50:\n\t\tVAR_3->reference = READ64 (VAR_7);\n\t\tbreak;\n\t/* COMMENT_18 */\n\tcase VAR_51:\n\t /* COMMENT_19 */\n\tcase VAR_52:\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->address);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\" VAR_53 \"\\n\", VAR_2->attr_form);\n\t\tVAR_3->data = 0;\n\t\treturn NULL;\n\t}\n\treturn VAR_7;\n}",
  "func_graph_path": "radareorg/radare2/0523c79d6e63858c990821a990edcb82cf8af284/dwarf.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -120,7 +120,7 @@\n \t\t\tvalue->string.content =\n \t\t\t\tstrdup ((const char *)(debug_str + value->string.offset));\n \t\t} else {\n-\t\t\tvalue->string.content = NULL;\n+\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n \t\t}\n \t\tbreak;\n \t// offset in .debug_info",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tvalue->string.content = NULL;"
    ],
    "added_lines": [
      "\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/17399",
  "description": {
    "pr_info": {
      "title": "Fix malformed DWARF crash due invalid .debug_str reference ##bin",
      "number": 17399
    },
    "comment": [
      " <!-- Filling this template is mandatory -->\r\n\r\n**Your checklist for this pull request**\r\n- [x] I've read the [guidelines for contributing](https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md) to this repository\r\n- [x] I made sure to follow the project's [coding style](https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md#code-style)\r\n- [ ] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the documentation and the [radare2 book](https://github.com/radareorg/radare2book) with the relevant information (if needed)\r\n\r\n**Detailed description**\r\n\r\nFix for #17383 \r\n\r\nIn case the string pointer into debug_str isn't valid, the string can be NULL which wasn't accounted for in the future type parsing, I've added the handling for this situation.",
      "Btw, you might want to create a macros or a small inline function for this pattern:\r\n```c\r\n\t\tif (!value->string.content) {\r\n\t\t\t\tname = create_type_name_from_offset (die->offset);\r\n\t\t\t} else {\r\n\t\t\t\tname = strdup (value->string.content);\r\n\t\t\t}\r\n\t\t\tif (!name) {\r\n\t\t\t\tgoto cleanup;\r\n\t\t\t}\r\n```"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.4,
  "Bug Filter Response": "The commit aims to fix a crash but doesn't address the root cause through code changes. It adds a comment, indicating a potential improvement without implementation.\n\n**Final Classification:** Supporting & Non-Core Improvements; **Confidence:** 0.4\n\nThe classification is \"Supporting & Non-Core Improvements\" because the change only adds a comment, not a fix. Confidence is low due to inconsistency between the commit message and actual changes."
}