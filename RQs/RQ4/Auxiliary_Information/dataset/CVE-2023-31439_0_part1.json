{
  "cve_id": "CVE-2023-31439",
  "cwe_ids": [
    "CWE-354"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "systemd",
  "commit_msg": "journalctl: address review comments",
  "commit_hash": "3c896258067991832a1e896093b748aebfc873e1",
  "git_url": "https://github.com/systemd/systemd/commit/3c896258067991832a1e896093b748aebfc873e1",
  "file_path": "src/libsystemd/sd-journal/journal-verify.c",
  "func_name": "journal_file_verify",
  "func_before": "int journal_file_verify(\n                JournalFile *f,\n                const char *key,\n                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,\n                bool show_progress) {\n        int r;\n        Object *o;\n        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n\n        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;\n        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;\n        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n        usec_t last_usec = 0;\n        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;\n        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;\n        unsigned i;\n        bool found_last = false;\n        const char *tmp_dir = NULL;\n        MMapCache *m;\n\n#if HAVE_GCRYPT\n        uint64_t last_tag = 0;\n#endif\n        assert(f);\n\n        if (key) {\n#if HAVE_GCRYPT\n                r = journal_file_parse_verification_key(f, key);\n                if (r < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return r;\n                }\n#else\n                return -EOPNOTSUPP;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(f->header))\n                return -ENOKEY;\n\n        r = var_tmp_dir(&tmp_dir);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (data_fd < 0) {\n                r = log_error_errno(data_fd, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_fd < 0) {\n                r = log_error_errno(entry_fd, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_array_fd < 0) {\n                r = log_error_errno(entry_array_fd,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        m = mmap_cache_fd_cache(f->cache_fd);\n        cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);\n        if (!cache_data_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_array_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&data_fd, \"w+\", &data_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_fd, \"w+\", &entry_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_array_fd, \"w+\", &entry_array_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                r = -EOPNOTSUPP;\n                goto fail;\n        }\n\n        for (i = 0; i < sizeof(f->header->reserved); i++)\n                if (f->header->reserved[i] != 0) {\n                        error(offsetof(Header, reserved[i]), \"Reserved field is non-zero\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n        /* First iteration: we go through all objects, verify the\n         * superficial structure, headers, hashes. */\n\n        p = le64toh(f->header->header_size);\n        for (;;) {\n                /* Early exit if there are no objects in the file, at all */\n                if (le64toh(f->header->tail_object_offset) == 0)\n                        break;\n\n                if (show_progress)\n                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);\n\n                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (p > le64toh(f->header->tail_object_offset)) {\n                        error(offsetof(Header, tail_object_offset),\n                              \"Invalid tail object pointer (%\"PRIu64\" > %\"PRIu64\")\",\n                              p,\n                              le64toh(f->header->tail_object_offset));\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                n_objects++;\n\n                r = journal_file_object_verify(f, p, o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {\n                        error(p, \"Object has multiple compression flags set (flags: 0x%x)\", o->object.flags);\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {\n                        error(p, \"XZ compressed object in file without XZ compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {\n                        error(p, \"LZ4 compressed object in file without LZ4 compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {\n                        error(p, \"ZSTD compressed object in file without ZSTD compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                switch (o->object.type) {\n\n                case OBJECT_DATA:\n                        r = write_uint64(data_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        n_data++;\n                        break;\n\n                case OBJECT_FIELD:\n                        n_fields++;\n                        break;\n\n                case OBJECT_ENTRY:\n                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {\n                                error(p, \"First entry before first tag\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        r = write_uint64(entry_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (le64toh(o->entry.realtime) < last_tag_realtime) {\n                                error(p,\n                                      \"Older entry after newer tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      last_tag_realtime);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (!entry_seqnum_set &&\n                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {\n                                error(p,\n                                      \"Head entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.seqnum),\n                                      le64toh(f->header->head_entry_seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (entry_seqnum_set &&\n                            entry_seqnum >= le64toh(o->entry.seqnum)) {\n                                error(p,\n                                      \"Entry sequence number out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                      entry_seqnum,\n                                      le64toh(o->entry.seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_seqnum = le64toh(o->entry.seqnum);\n                        entry_seqnum_set = true;\n\n                        if (entry_monotonic_set &&\n                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&\n                            entry_monotonic > le64toh(o->entry.monotonic)) {\n                                error(p,\n                                      \"Entry timestamp out of synchronization (%\"PRIu64\" > %\"PRIu64\")\",\n                                      entry_monotonic,\n                                      le64toh(o->entry.monotonic));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_monotonic = le64toh(o->entry.monotonic);\n                        entry_boot_id = o->entry.boot_id;\n                        entry_monotonic_set = true;\n\n                        if (!entry_realtime_set &&\n                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {\n                                error(p,\n                                      \"Head entry realtime timestamp incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      le64toh(f->header->head_entry_realtime));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_realtime = le64toh(o->entry.realtime);\n                        entry_realtime_set = true;\n\n                        if (max_entry_realtime < le64toh(o->entry.realtime))\n                                max_entry_realtime = le64toh(o->entry.realtime);\n                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {\n                                min_entry_realtime = le64toh(o->entry.realtime);\n                                min_entry_realtime_set = true;\n                        }\n\n                        n_entries++;\n                        break;\n\n                case OBJECT_DATA_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_data_hash_tables,\n                                              le64toh(f->header->data_hash_table_offset),\n                                              le64toh(f->header->data_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n                        break;\n\n                case OBJECT_FIELD_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_field_hash_tables,\n                                              le64toh(f->header->field_hash_table_offset),\n                                              le64toh(f->header->field_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n\n                        break;\n\n                case OBJECT_ENTRY_ARRAY:\n                        r = write_uint64(entry_array_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (p == le64toh(f->header->entry_array_offset)) {\n                                if (found_main_entry_array) {\n                                        error(p, \"More than one main entry array\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                found_main_entry_array = true;\n                        }\n\n                        n_entry_arrays++;\n                        break;\n\n                case OBJECT_TAG:\n                        if (!JOURNAL_HEADER_SEALED(f->header)) {\n                                error(p, \"Tag object in file without sealing\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.seqnum) != n_tags + 1) {\n                                error(p,\n                                      \"Tag sequence number out of synchronization (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->tag.seqnum),\n                                      n_tags + 1);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.epoch) < last_epoch) {\n                                error(p,\n                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->tag.epoch),\n                                      last_epoch);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n#if HAVE_GCRYPT\n                        if (JOURNAL_HEADER_SEALED(f->header)) {\n                                uint64_t q, rt;\n\n                                debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n\n                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {\n                                        error(p,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (max_entry_realtime >= rt + f->fss_interval_usec) {\n                                        error(p,\n                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                              max_entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (min_entry_realtime_set && min_entry_realtime < rt) {\n                                        error(p,\n                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              min_entry_realtime,\n                                              rt);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                min_entry_realtime_set = false;\n\n                                /* OK, now we know the epoch. So let's now set\n                                 * it, and calculate the HMAC for everything\n                                 * since the last tag. */\n                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));\n                                if (r < 0)\n                                        goto fail;\n\n                                r = journal_file_hmac_start(f);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (last_tag == 0) {\n                                        r = journal_file_hmac_put_header(f);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = le64toh(f->header->header_size);\n                                } else\n                                        q = last_tag;\n\n                                while (q <= p) {\n                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = q + ALIGN64(le64toh(o->object.size));\n                                }\n\n                                /* Position might have changed, let's reposition things */\n                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {\n                                        error(p, \"Tag failed verification\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                f->hmac_running = false;\n                                last_tag_realtime = rt;\n                                last_sealed_realtime = entry_realtime;\n                        }\n\n                        last_tag = p + ALIGN64(le64toh(o->object.size));\n#endif\n\n                        last_epoch = le64toh(o->tag.epoch);\n\n                        n_tags++;\n                        break;\n                }\n\n                if (p == le64toh(f->header->tail_object_offset)) {\n                        found_last = true;\n                        break;\n                }\n\n                p = p + ALIGN64(le64toh(o->object.size));\n        };\n\n        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {\n                error(le64toh(f->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"PRIu64\" != 0)\",\n                      le64toh(f->header->tail_object_offset));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_objects != le64toh(f->header->n_objects)) {\n                error(offsetof(Header, n_objects),\n                      \"Object number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_objects,\n                      le64toh(f->header->n_objects));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_entries != le64toh(f->header->n_entries)) {\n                error(offsetof(Header, n_entries),\n                      \"Entry number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entries,\n                      le64toh(f->header->n_entries));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&\n            n_data != le64toh(f->header->n_data)) {\n                error(offsetof(Header, n_data),\n                      \"Data number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_data,\n                      le64toh(f->header->n_data));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&\n            n_fields != le64toh(f->header->n_fields)) {\n                error(offsetof(Header, n_fields),\n                      \"Field number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_fields,\n                      le64toh(f->header->n_fields));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&\n            n_tags != le64toh(f->header->n_tags)) {\n                error(offsetof(Header, n_tags),\n                      \"Tag number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_tags,\n                      le64toh(f->header->n_tags));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&\n            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {\n                error(offsetof(Header, n_entry_arrays),\n                      \"Entry array number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entry_arrays,\n                      le64toh(f->header->n_entry_arrays));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_seqnum_set &&\n            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {\n                error(offsetof(Header, tail_entry_seqnum),\n                      \"Tail entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_seqnum,\n                      le64toh(f->header->tail_entry_seqnum));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_monotonic_set &&\n            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&\n             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_monotonic,\n                      le64toh(f->header->tail_entry_monotonic));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_realtime,\n                      le64toh(f->header->tail_entry_realtime));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (fflush(data_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_array_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* Second iteration: we follow all objects referenced from the\n         * two entry points: the object hash table and the entry\n         * array. We also check that everything referenced (directly\n         * or indirectly) in the data hash table also exists in the\n         * entry array, and vice versa. Note that we do not care for\n         * unreferenced objects. We only care that everything that is\n         * referenced is consistent. */\n\n        r = verify_entry_array(f,\n                               cache_data_fd, n_data,\n                               cache_entry_fd, n_entries,\n                               cache_entry_array_fd, n_entry_arrays,\n                               &last_usec,\n                               show_progress);\n        if (r < 0)\n                goto fail;\n\n        r = verify_data_hash_table(f,\n                                   cache_data_fd, n_data,\n                                   cache_entry_fd, n_entries,\n                                   cache_entry_array_fd, n_entry_arrays,\n                                   &last_usec,\n                                   show_progress);\n        if (r < 0)\n                goto fail;\n\n        if (show_progress)\n                flush_progress();\n\n        mmap_cache_fd_free(cache_data_fd);\n        mmap_cache_fd_free(cache_entry_fd);\n        mmap_cache_fd_free(cache_entry_array_fd);\n\n        if (first_contained)\n                *first_contained = le64toh(f->header->head_entry_realtime);\n        if (last_validated)\n                *last_validated = last_sealed_realtime;\n        if (last_contained)\n                *last_contained = le64toh(f->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (show_progress)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"PRIu64\" (of %\"PRIu64\" bytes, %\"PRIu64\"%%).\",\n                  f->path,\n                  p,\n                  (uint64_t) f->last_stat.st_size,\n                  100U * p / (uint64_t) f->last_stat.st_size);\n\n        if (cache_data_fd)\n                mmap_cache_fd_free(cache_data_fd);\n\n        if (cache_entry_fd)\n                mmap_cache_fd_free(cache_entry_fd);\n\n        if (cache_entry_array_fd)\n                mmap_cache_fd_free(cache_entry_array_fd);\n\n        return r;\n}",
  "abstract_func_before": "int journal_file_verify(\n                JournalFile *VAR_0,\n                const char *VAR_1,\n                usec_t *VAR_2, usec_t *VAR_3, usec_t *VAR_4,\n                bool VAR_5) {\n        int VAR_6;\n        Object *VAR_7;\n        uint64_t VAR_8 = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0;\n\n        uint64_t VAR_12 = 0, VAR_13 = 0, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0;\n        sd_id128_t VAR_17 = {};  /* COMMENT_0 */\n        bool VAR_18 = false, VAR_19 = false, VAR_20 = false, VAR_21 = false, VAR_22 = false;\n        uint64_t VAR_23 = 0, VAR_24 = 0, VAR_25 = 0, VAR_26 = 0, VAR_27 = 0, VAR_28 = 0, VAR_29 = 0, VAR_30 = 0;\n        usec_t VAR_31 = 0;\n        _cleanup_close_ int VAR_32 = -VAR_33, VAR_34 = -VAR_33, VAR_35 = -VAR_33;\n        _cleanup_fclose_ VAR_36 *VAR_37 = NULL, *VAR_38 = NULL, *VAR_39 = NULL;\n        MMapFileDescriptor *VAR_40 = NULL, *VAR_41 = NULL, *VAR_42 = NULL;\n        unsigned VAR_43;\n        bool VAR_44 = false;\n        const char *VAR_45 = NULL;\n        MMapCache *VAR_46;\n\n#if VAR_47\n        uint64_t VAR_48 = 0;\n#endif\n        assert(VAR_0);\n\n        if (VAR_1) {\n#if VAR_47\n                VAR_6 = journal_file_parse_verification_key(VAR_0, VAR_1);\n                if (VAR_6 < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return VAR_6;\n                }\n#else\n                return -VAR_49;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(VAR_0->header))\n                return -VAR_50;\n\n        VAR_6 = var_tmp_dir(&VAR_45);\n        if (VAR_6 < 0) {\n                log_error_errno(VAR_6, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        VAR_32 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);\n        if (VAR_32 < 0) {\n                VAR_6 = log_error_errno(VAR_32, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        VAR_34 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);\n        if (VAR_34 < 0) {\n                VAR_6 = log_error_errno(VAR_34, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        VAR_35 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);\n        if (VAR_35 < 0) {\n                VAR_6 = log_error_errno(VAR_35,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        VAR_46 = mmap_cache_fd_cache(VAR_0->cache_fd);\n        VAR_40 = mmap_cache_add_fd(VAR_46, VAR_32, VAR_53|VAR_54);\n        if (!VAR_40) {\n                VAR_6 = log_oom();\n                goto fail;\n        }\n\n        VAR_41 = mmap_cache_add_fd(VAR_46, VAR_34, VAR_53|VAR_54);\n        if (!VAR_41) {\n                VAR_6 = log_oom();\n                goto fail;\n        }\n\n        VAR_42 = mmap_cache_add_fd(VAR_46, VAR_35, VAR_53|VAR_54);\n        if (!VAR_42) {\n                VAR_6 = log_oom();\n                goto fail;\n        }\n\n        VAR_6 = take_fdopen_unlocked(&VAR_32, \"w+\", &VAR_37);\n        if (VAR_6 < 0) {\n                log_error_errno(VAR_6, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        VAR_6 = take_fdopen_unlocked(&VAR_34, \"w+\", &VAR_38);\n        if (VAR_6 < 0) {\n                log_error_errno(VAR_6, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        VAR_6 = take_fdopen_unlocked(&VAR_35, \"w+\", &VAR_39);\n        if (VAR_6 < 0) {\n                log_error_errno(VAR_6, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(VAR_0->header->compatible_flags) & ~VAR_55) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                VAR_6 = -VAR_49;\n                goto fail;\n        }\n\n        for (VAR_43 = 0; VAR_43 < sizeof(VAR_0->header->reserved); VAR_43++)\n                if (VAR_0->header->reserved[VAR_43] != 0) {\n                        error(offsetof(VAR_56, VAR_57[VAR_43]), \"Reserved field is non-zero\");\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n        /* COMMENT_1 */\n                                                     \n\n        VAR_8 = le64toh(VAR_0->header->header_size);\n        for (;;) {\n                /* COMMENT_3 */\n                if (le64toh(VAR_0->header->tail_object_offset) == 0)\n                        break;\n\n                if (VAR_5)\n                        draw_progress(scale_progress(0x7FFF, VAR_8, le64toh(VAR_0->header->tail_object_offset)), &VAR_31);\n\n                VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);\n                if (VAR_6 < 0) {\n                        error_errno(VAR_8, VAR_6, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (VAR_8 > le64toh(VAR_0->header->tail_object_offset)) {\n                        error(offsetof(VAR_56, VAR_60),\n                              \"Invalid tail object pointer (%\"VAR_61\" > %\"VAR_61\")\",\n                              VAR_8,\n                              le64toh(VAR_0->header->tail_object_offset));\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n                VAR_23++;\n\n                VAR_6 = journal_file_object_verify(VAR_0, VAR_8, VAR_7);\n                if (VAR_6 < 0) {\n                        error_errno(VAR_8, VAR_6, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(VAR_7->object.flags & VAR_62) +\n                    !!(VAR_7->object.flags & VAR_63) +\n                    !!(VAR_7->object.flags & VAR_64) > 1) {\n                        error(VAR_8, \"Object has multiple compression flags set (flags: 0x%x)\", VAR_7->object.flags);\n                        VAR_6 = -VAR_65;\n                        goto fail;\n                }\n\n                if ((VAR_7->object.flags & VAR_62) && !JOURNAL_HEADER_COMPRESSED_XZ(VAR_0->header)) {\n                        error(VAR_8, \"XZ compressed object in file without XZ compression\");\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n                if ((VAR_7->object.flags & VAR_63) && !JOURNAL_HEADER_COMPRESSED_LZ4(VAR_0->header)) {\n                        error(VAR_8, \"LZ4 compressed object in file without LZ4 compression\");\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n                if ((VAR_7->object.flags & VAR_64) && !JOURNAL_HEADER_COMPRESSED_ZSTD(VAR_0->header)) {\n                        error(VAR_8, \"ZSTD compressed object in file without ZSTD compression\");\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n                switch (VAR_7->object.type) {\n\n                case VAR_66:\n                        VAR_6 = write_uint64(VAR_37, VAR_8);\n                        if (VAR_6 < 0)\n                                goto fail;\n\n                        VAR_25++;\n                        break;\n\n                case VAR_67:\n                        VAR_26++;\n                        break;\n\n                case VAR_68:\n                        if (JOURNAL_HEADER_SEALED(VAR_0->header) && VAR_30 <= 0) {\n                                error(VAR_8, \"First entry before first tag\");\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        VAR_6 = write_uint64(VAR_38, VAR_8);\n                        if (VAR_6 < 0)\n                                goto fail;\n\n                        if (le64toh(VAR_7->entry.realtime) < VAR_10) {\n                                error(VAR_8,\n                                      \"Older entry after newer tag (%\"VAR_61\" < %\"VAR_61\")\",\n                                      le64toh(VAR_7->entry.realtime),\n                                      VAR_10);\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        if (!VAR_18 &&\n                            le64toh(VAR_7->entry.seqnum) != le64toh(VAR_0->header->head_entry_seqnum)) {\n                                error(VAR_8,\n                                      \"Head entry sequence number incorrect (%\"VAR_61\" != %\"VAR_61\")\",\n                                      le64toh(VAR_7->entry.seqnum),\n                                      le64toh(VAR_0->header->head_entry_seqnum));\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        if (VAR_18 &&\n                            VAR_12 >= le64toh(VAR_7->entry.seqnum)) {\n                                error(VAR_8,\n                                      \"Entry sequence number out of synchronization (%\"VAR_61\" >= %\"VAR_61\")\",\n                                      VAR_12,\n                                      le64toh(VAR_7->entry.seqnum));\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        VAR_12 = le64toh(VAR_7->entry.seqnum);\n                        VAR_18 = true;\n\n                        if (VAR_19 &&\n                            sd_id128_equal(VAR_17, VAR_7->entry.boot_id) &&\n                            VAR_13 > le64toh(VAR_7->entry.monotonic)) {\n                                error(VAR_8,\n                                      \"Entry timestamp out of synchronization (%\"VAR_61\" > %\"VAR_61\")\",\n                                      VAR_13,\n                                      le64toh(VAR_7->entry.monotonic));\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        VAR_13 = le64toh(VAR_7->entry.monotonic);\n                        VAR_17 = VAR_7->entry.boot_id;\n                        VAR_19 = true;\n\n                        if (!VAR_20 &&\n                            le64toh(VAR_7->entry.realtime) != le64toh(VAR_0->header->head_entry_realtime)) {\n                                error(VAR_8,\n                                      \"Head entry realtime timestamp incorrect (%\"VAR_61\" != %\"VAR_61\")\",\n                                      le64toh(VAR_7->entry.realtime),\n                                      le64toh(VAR_0->header->head_entry_realtime));\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        VAR_14 = le64toh(VAR_7->entry.realtime);\n                        VAR_20 = true;\n\n                        if (VAR_16 < le64toh(VAR_7->entry.realtime))\n                                VAR_16 = le64toh(VAR_7->entry.realtime);\n                        if (!VAR_21 || VAR_15 > le64toh(VAR_7->entry.realtime)) {\n                                VAR_15 = le64toh(VAR_7->entry.realtime);\n                                VAR_21 = true;\n                        }\n\n                        VAR_24++;\n                        break;\n\n                case VAR_69:\n                        VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_27,\n                                              le64toh(VAR_0->header->data_hash_table_offset),\n                                              le64toh(VAR_0->header->data_hash_table_size));\n                        if (VAR_6 < 0)\n                                goto fail;\n                        break;\n\n                case VAR_70:\n                        VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_28,\n                                              le64toh(VAR_0->header->field_hash_table_offset),\n                                              le64toh(VAR_0->header->field_hash_table_size));\n                        if (VAR_6 < 0)\n                                goto fail;\n\n                        break;\n\n                case VAR_71:\n                        VAR_6 = write_uint64(VAR_39, VAR_8);\n                        if (VAR_6 < 0)\n                                goto fail;\n\n                        if (VAR_8 == le64toh(VAR_0->header->entry_array_offset)) {\n                                if (VAR_22) {\n                                        error(VAR_8, \"More than one main entry array\");\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n\n                                VAR_22 = true;\n                        }\n\n                        VAR_29++;\n                        break;\n\n                case VAR_72:\n                        if (!JOURNAL_HEADER_SEALED(VAR_0->header)) {\n                                error(VAR_8, \"Tag object in file without sealing\");\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        if (le64toh(VAR_7->tag.seqnum) != VAR_30 + 1) {\n                                error(VAR_8,\n                                      \"Tag sequence number out of synchronization (%\"VAR_61\" != %\"VAR_61\")\",\n                                      le64toh(VAR_7->tag.seqnum),\n                                      VAR_30 + 1);\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        if (le64toh(VAR_7->tag.epoch) < VAR_9) {\n                                error(VAR_8,\n                                      \"Epoch sequence out of synchronization (%\"VAR_61\" < %\"VAR_61\")\",\n                                      le64toh(VAR_7->tag.epoch),\n                                      VAR_9);\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n#if VAR_47\n                        if (JOURNAL_HEADER_SEALED(VAR_0->header)) {\n                                uint64_t VAR_73, VAR_74;\n\n                                debug(VAR_8, \"Checking tag %\"VAR_61\"...\", le64toh(VAR_7->tag.seqnum));\n\n                                VAR_74 = VAR_0->fss_start_usec + le64toh(VAR_7->tag.epoch) * VAR_0->fss_interval_usec;\n                                if (VAR_20 && VAR_14 >= VAR_74 + VAR_0->fss_interval_usec) {\n                                        error(VAR_8,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"VAR_61\" >= %\"VAR_61\")\",\n                                              VAR_14,\n                                              VAR_74 + VAR_0->fss_interval_usec);\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n                                if (VAR_16 >= VAR_74 + VAR_0->fss_interval_usec) {\n                                        error(VAR_8,\n                                              \"entry realtime timestamp too late with respect to tag (%\"VAR_61\" < %\"VAR_61\")\",\n                                              VAR_16,\n                                              VAR_74 + VAR_0->fss_interval_usec);\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n                                if (VAR_21 && VAR_15 < VAR_74) {\n                                        error(VAR_8,\n                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"VAR_61\" >= %\"VAR_61\")\",\n                                              VAR_15,\n                                              VAR_74);\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n                                VAR_21 = false;\n\n                                /* COMMENT_4 */\n                                                                            \n                                                         \n                                VAR_6 = journal_file_fsprg_seek(VAR_0, le64toh(VAR_7->tag.epoch));\n                                if (VAR_6 < 0)\n                                        goto fail;\n\n                                VAR_6 = journal_file_hmac_start(VAR_0);\n                                if (VAR_6 < 0)\n                                        goto fail;\n\n                                if (VAR_48 == 0) {\n                                        VAR_6 = journal_file_hmac_put_header(VAR_0);\n                                        if (VAR_6 < 0)\n                                                goto fail;\n\n                                        VAR_73 = le64toh(VAR_0->header->header_size);\n                                } else\n                                        VAR_73 = VAR_48;\n\n                                while (VAR_73 <= VAR_8) {\n                                        VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_73, &VAR_7);\n                                        if (VAR_6 < 0)\n                                                goto fail;\n\n                                        VAR_6 = journal_file_hmac_put_object(VAR_0, VAR_59, VAR_7, VAR_73);\n                                        if (VAR_6 < 0)\n                                                goto fail;\n\n                                        VAR_73 = VAR_73 + ALIGN64(le64toh(VAR_7->object.size));\n                                }\n\n                                /* COMMENT_7 */\n                                VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);\n                                if (VAR_6 < 0)\n                                        goto fail;\n\n                                if (memcmp(VAR_7->tag.tag, gcry_md_read(VAR_0->hmac, 0), VAR_75) != 0) {\n                                        error(VAR_8, \"Tag failed verification\");\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n\n                                VAR_0->hmac_running = false;\n                                VAR_10 = VAR_74;\n                                VAR_11 = VAR_14;\n                        }\n\n                        VAR_48 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));\n#endif\n\n                        VAR_9 = le64toh(VAR_7->tag.epoch);\n\n                        VAR_30++;\n                        break;\n                }\n\n                if (VAR_8 == le64toh(VAR_0->header->tail_object_offset)) {\n                        VAR_44 = true;\n                        break;\n                }\n\n                VAR_8 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));\n        };\n\n        if (!VAR_44 && le64toh(VAR_0->header->tail_object_offset) != 0) {\n                error(le64toh(VAR_0->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"VAR_61\" != 0)\",\n                      le64toh(VAR_0->header->tail_object_offset));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_23 != le64toh(VAR_0->header->n_objects)) {\n                error(offsetof(VAR_56, VAR_23),\n                      \"Object number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_23,\n                      le64toh(VAR_0->header->n_objects));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_24 != le64toh(VAR_0->header->n_entries)) {\n                error(offsetof(VAR_56, VAR_24),\n                      \"Entry number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_24,\n                      le64toh(VAR_0->header->n_entries));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_25) &&\n            VAR_25 != le64toh(VAR_0->header->n_data)) {\n                error(offsetof(VAR_56, VAR_25),\n                      \"Data number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_25,\n                      le64toh(VAR_0->header->n_data));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_26) &&\n            VAR_26 != le64toh(VAR_0->header->n_fields)) {\n                error(offsetof(VAR_56, VAR_26),\n                      \"Field number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_26,\n                      le64toh(VAR_0->header->n_fields));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_30) &&\n            VAR_30 != le64toh(VAR_0->header->n_tags)) {\n                error(offsetof(VAR_56, VAR_30),\n                      \"Tag number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_30,\n                      le64toh(VAR_0->header->n_tags));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_29) &&\n            VAR_29 != le64toh(VAR_0->header->n_entry_arrays)) {\n                error(offsetof(VAR_56, VAR_29),\n                      \"Entry array number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_29,\n                      le64toh(VAR_0->header->n_entry_arrays));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (!VAR_22 && le64toh(VAR_0->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_18 &&\n            VAR_12 != le64toh(VAR_0->header->tail_entry_seqnum)) {\n                error(offsetof(VAR_56, VAR_76),\n                      \"Tail entry sequence number incorrect (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_12,\n                      le64toh(VAR_0->header->tail_entry_seqnum));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_19 &&\n            (sd_id128_equal(VAR_17, VAR_0->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(VAR_0->header) &&\n             VAR_13 != le64toh(VAR_0->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_13,\n                      le64toh(VAR_0->header->tail_entry_monotonic));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_20 && VAR_14 != le64toh(VAR_0->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_14,\n                      le64toh(VAR_0->header->tail_entry_realtime));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (fflush(VAR_37) != 0) {\n                VAR_6 = log_error_errno(VAR_77, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(VAR_38) != 0) {\n                VAR_6 = log_error_errno(VAR_77, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(VAR_39) != 0) {\n                VAR_6 = log_error_errno(VAR_77, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* COMMENT_8 */\n                                                                \n                                                                    \n                                                                   \n                                                                    \n                                                                     \n                                       \n\n        VAR_6 = verify_entry_array(VAR_0,\n                               VAR_40, VAR_25,\n                               VAR_41, VAR_24,\n                               VAR_42, VAR_29,\n                               &VAR_31,\n                               VAR_5);\n        if (VAR_6 < 0)\n                goto fail;\n\n        VAR_6 = verify_data_hash_table(VAR_0,\n                                   VAR_40, VAR_25,\n                                   VAR_41, VAR_24,\n                                   VAR_42, VAR_29,\n                                   &VAR_31,\n                                   VAR_5);\n        if (VAR_6 < 0)\n                goto fail;\n\n        if (VAR_5)\n                flush_progress();\n\n        mmap_cache_fd_free(VAR_40);\n        mmap_cache_fd_free(VAR_41);\n        mmap_cache_fd_free(VAR_42);\n\n        if (VAR_2)\n                *VAR_2 = le64toh(VAR_0->header->head_entry_realtime);\n        if (VAR_3)\n                *VAR_3 = VAR_11;\n        if (VAR_4)\n                *VAR_4 = le64toh(VAR_0->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (VAR_5)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"VAR_61\" (of %\"VAR_61\" bytes, %\"VAR_61\"%%).\",\n                  VAR_0->path,\n                  VAR_8,\n                  (uint64_t) VAR_0->last_stat.st_size,\n                  100U * VAR_8 / (uint64_t) VAR_0->last_stat.st_size);\n\n        if (VAR_40)\n                mmap_cache_fd_free(VAR_40);\n\n        if (VAR_41)\n                mmap_cache_fd_free(VAR_41);\n\n        if (VAR_42)\n                mmap_cache_fd_free(VAR_42);\n\n        return VAR_6;\n}",
  "func_graph_path_before": "systemd/3c896258067991832a1e896093b748aebfc873e1/journal-verify.c/vul/before/0.json",
  "func": "int journal_file_verify(\n                JournalFile *f,\n                const char *key,\n                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,\n                bool show_progress) {\n        int r;\n        Object *o;\n        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n\n        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;\n        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;\n        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n        usec_t last_usec = 0;\n        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;\n        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;\n        unsigned i;\n        bool found_last = false;\n        const char *tmp_dir = NULL;\n        MMapCache *m;\n\n#if HAVE_GCRYPT\n        uint64_t last_tag = 0;\n#endif\n        assert(f);\n\n        if (key) {\n#if HAVE_GCRYPT\n                r = journal_file_parse_verification_key(f, key);\n                if (r < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return r;\n                }\n#else\n                return -EOPNOTSUPP;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(f->header))\n                return -ENOKEY;\n\n        r = var_tmp_dir(&tmp_dir);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (data_fd < 0) {\n                r = log_error_errno(data_fd, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_fd < 0) {\n                r = log_error_errno(entry_fd, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_array_fd < 0) {\n                r = log_error_errno(entry_array_fd,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        m = mmap_cache_fd_cache(f->cache_fd);\n        cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);\n        if (!cache_data_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_array_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&data_fd, \"w+\", &data_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_fd, \"w+\", &entry_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_array_fd, \"w+\", &entry_array_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                r = -EOPNOTSUPP;\n                goto fail;\n        }\n\n        for (i = 0; i < sizeof(f->header->reserved); i++)\n                if (f->header->reserved[i] != 0) {\n                        error(offsetof(Header, reserved[i]), \"Reserved field is non-zero\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n        /* First iteration: we go through all objects, verify the\n         * superficial structure, headers, hashes. */\n\n        p = le64toh(f->header->header_size);\n        for (;;) {\n                /* Early exit if there are no objects in the file, at all */\n                if (le64toh(f->header->tail_object_offset) == 0)\n                        break;\n\n                if (show_progress)\n                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);\n\n                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (p > le64toh(f->header->tail_object_offset)) {\n                        error(offsetof(Header, tail_object_offset),\n                              \"Invalid tail object pointer (%\"PRIu64\" > %\"PRIu64\")\",\n                              p,\n                              le64toh(f->header->tail_object_offset));\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                n_objects++;\n\n                r = journal_file_object_verify(f, p, o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {\n                        error(p, \"Object has multiple compression flags set (flags: 0x%x)\", o->object.flags);\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {\n                        error(p, \"XZ compressed object in file without XZ compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {\n                        error(p, \"LZ4 compressed object in file without LZ4 compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {\n                        error(p, \"ZSTD compressed object in file without ZSTD compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                switch (o->object.type) {\n\n                case OBJECT_DATA:\n                        r = write_uint64(data_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        n_data++;\n                        break;\n\n                case OBJECT_FIELD:\n                        n_fields++;\n                        break;\n\n                case OBJECT_ENTRY:\n                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {\n                                error(p, \"First entry before first tag\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        r = write_uint64(entry_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (le64toh(o->entry.realtime) < last_tag_realtime) {\n                                error(p,\n                                      \"Older entry after newer tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      last_tag_realtime);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (!entry_seqnum_set &&\n                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {\n                                error(p,\n                                      \"Head entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.seqnum),\n                                      le64toh(f->header->head_entry_seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (entry_seqnum_set &&\n                            entry_seqnum >= le64toh(o->entry.seqnum)) {\n                                error(p,\n                                      \"Entry sequence number out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                      entry_seqnum,\n                                      le64toh(o->entry.seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_seqnum = le64toh(o->entry.seqnum);\n                        entry_seqnum_set = true;\n\n                        if (entry_monotonic_set &&\n                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&\n                            entry_monotonic > le64toh(o->entry.monotonic)) {\n                                error(p,\n                                      \"Entry timestamp out of synchronization (%\"PRIu64\" > %\"PRIu64\")\",\n                                      entry_monotonic,\n                                      le64toh(o->entry.monotonic));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_monotonic = le64toh(o->entry.monotonic);\n                        entry_boot_id = o->entry.boot_id;\n                        entry_monotonic_set = true;\n\n                        if (!entry_realtime_set &&\n                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {\n                                error(p,\n                                      \"Head entry realtime timestamp incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      le64toh(f->header->head_entry_realtime));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_realtime = le64toh(o->entry.realtime);\n                        entry_realtime_set = true;\n\n                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));\n                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));\n\n                        n_entries++;\n                        break;\n\n                case OBJECT_DATA_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_data_hash_tables,\n                                              le64toh(f->header->data_hash_table_offset),\n                                              le64toh(f->header->data_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n                        break;\n\n                case OBJECT_FIELD_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_field_hash_tables,\n                                              le64toh(f->header->field_hash_table_offset),\n                                              le64toh(f->header->field_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n\n                        break;\n\n                case OBJECT_ENTRY_ARRAY:\n                        r = write_uint64(entry_array_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (p == le64toh(f->header->entry_array_offset)) {\n                                if (found_main_entry_array) {\n                                        error(p, \"More than one main entry array\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                found_main_entry_array = true;\n                        }\n\n                        n_entry_arrays++;\n                        break;\n\n                case OBJECT_TAG:\n                        if (!JOURNAL_HEADER_SEALED(f->header)) {\n                                error(p, \"Tag object in file without sealing\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.seqnum) != n_tags + 1) {\n                                error(p,\n                                      \"Tag sequence number out of synchronization (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->tag.seqnum),\n                                      n_tags + 1);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.epoch) < last_epoch) {\n                                error(p,\n                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->tag.epoch),\n                                      last_epoch);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n#if HAVE_GCRYPT\n                        if (JOURNAL_HEADER_SEALED(f->header)) {\n                                uint64_t q, rt, rt_end;\n\n                                debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n\n                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n                                rt_end = usec_add(rt, f->fss_interval_usec);\n                                if (entry_realtime_set && entry_realtime >= rt_end) {\n                                        error(p,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (max_entry_realtime >= rt_end) {\n                                        error(p,\n                                              \"Entry realtime (%\"PRIu64\", %s) is too late with respect to tag (%\"PRIu64\", %s)\",\n                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),\n                                              rt_end, FORMAT_TIMESTAMP(rt_end));\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (min_entry_realtime < rt) {\n                                        error(p,\n                                              \"Entry realtime (%\"PRIu64\", %s) is too early with respect to tag (%\"PRIu64\", %s)\",\n                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),\n                                              rt, FORMAT_TIMESTAMP(rt));\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                min_entry_realtime = USEC_INFINITY;\n\n                                /* OK, now we know the epoch. So let's now set\n                                 * it, and calculate the HMAC for everything\n                                 * since the last tag. */\n                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));\n                                if (r < 0)\n                                        goto fail;\n\n                                r = journal_file_hmac_start(f);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (last_tag == 0) {\n                                        r = journal_file_hmac_put_header(f);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = le64toh(f->header->header_size);\n                                } else\n                                        q = last_tag;\n\n                                while (q <= p) {\n                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = q + ALIGN64(le64toh(o->object.size));\n                                }\n\n                                /* Position might have changed, let's reposition things */\n                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {\n                                        error(p, \"Tag failed verification\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                f->hmac_running = false;\n                                last_tag_realtime = rt;\n                                last_sealed_realtime = entry_realtime;\n                        }\n\n                        last_tag = p + ALIGN64(le64toh(o->object.size));\n#endif\n\n                        last_epoch = le64toh(o->tag.epoch);\n\n                        n_tags++;\n                        break;\n                }\n\n                if (p == le64toh(f->header->tail_object_offset)) {\n                        found_last = true;\n                        break;\n                }\n\n                p = p + ALIGN64(le64toh(o->object.size));\n        };\n\n        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {\n                error(le64toh(f->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"PRIu64\" != 0)\",\n                      le64toh(f->header->tail_object_offset));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_objects != le64toh(f->header->n_objects)) {\n                error(offsetof(Header, n_objects),\n                      \"Object number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_objects,\n                      le64toh(f->header->n_objects));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_entries != le64toh(f->header->n_entries)) {\n                error(offsetof(Header, n_entries),\n                      \"Entry number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entries,\n                      le64toh(f->header->n_entries));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&\n            n_data != le64toh(f->header->n_data)) {\n                error(offsetof(Header, n_data),\n                      \"Data number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_data,\n                      le64toh(f->header->n_data));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&\n            n_fields != le64toh(f->header->n_fields)) {\n                error(offsetof(Header, n_fields),\n                      \"Field number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_fields,\n                      le64toh(f->header->n_fields));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&\n            n_tags != le64toh(f->header->n_tags)) {\n                error(offsetof(Header, n_tags),\n                      \"Tag number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_tags,\n                      le64toh(f->header->n_tags));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&\n            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {\n                error(offsetof(Header, n_entry_arrays),\n                      \"Entry array number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entry_arrays,\n                      le64toh(f->header->n_entry_arrays));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_seqnum_set &&\n            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {\n                error(offsetof(Header, tail_entry_seqnum),\n                      \"Tail entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_seqnum,\n                      le64toh(f->header->tail_entry_seqnum));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_monotonic_set &&\n            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&\n             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_monotonic,\n                      le64toh(f->header->tail_entry_monotonic));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_realtime,\n                      le64toh(f->header->tail_entry_realtime));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (fflush(data_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_array_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* Second iteration: we follow all objects referenced from the\n         * two entry points: the object hash table and the entry\n         * array. We also check that everything referenced (directly\n         * or indirectly) in the data hash table also exists in the\n         * entry array, and vice versa. Note that we do not care for\n         * unreferenced objects. We only care that everything that is\n         * referenced is consistent. */\n\n        r = verify_entry_array(f,\n                               cache_data_fd, n_data,\n                               cache_entry_fd, n_entries,\n                               cache_entry_array_fd, n_entry_arrays,\n                               &last_usec,\n                               show_progress);\n        if (r < 0)\n                goto fail;\n\n        r = verify_data_hash_table(f,\n                                   cache_data_fd, n_data,\n                                   cache_entry_fd, n_entries,\n                                   cache_entry_array_fd, n_entry_arrays,\n                                   &last_usec,\n                                   show_progress);\n        if (r < 0)\n                goto fail;\n\n        if (show_progress)\n                flush_progress();\n\n        mmap_cache_fd_free(cache_data_fd);\n        mmap_cache_fd_free(cache_entry_fd);\n        mmap_cache_fd_free(cache_entry_array_fd);\n\n        if (first_contained)\n                *first_contained = le64toh(f->header->head_entry_realtime);\n        if (last_validated)\n                *last_validated = last_sealed_realtime;\n        if (last_contained)\n                *last_contained = le64toh(f->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (show_progress)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"PRIu64\" (of %\"PRIu64\" bytes, %\"PRIu64\"%%).\",\n                  f->path,\n                  p,\n                  (uint64_t) f->last_stat.st_size,\n                  100U * p / (uint64_t) f->last_stat.st_size);\n\n        if (cache_data_fd)\n                mmap_cache_fd_free(cache_data_fd);\n\n        if (cache_entry_fd)\n                mmap_cache_fd_free(cache_entry_fd);\n\n        if (cache_entry_array_fd)\n                mmap_cache_fd_free(cache_entry_array_fd);\n\n        return r;\n}",
  "abstract_func": "int journal_file_verify(\n                JournalFile *VAR_0,\n                const char *VAR_1,\n                usec_t *VAR_2, usec_t *VAR_3, usec_t *VAR_4,\n                bool VAR_5) {\n        int VAR_6;\n        Object *VAR_7;\n        uint64_t VAR_8 = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0;\n\n        uint64_t VAR_12 = 0, VAR_13 = 0, VAR_14 = 0;\n        usec_t VAR_15 = VAR_16, VAR_17 = 0;\n        sd_id128_t VAR_18 = {};  /* COMMENT_0 */\n        bool VAR_19 = false, VAR_20 = false, VAR_21 = false, VAR_22 = false;\n        uint64_t VAR_23 = 0, VAR_24 = 0, VAR_25 = 0, VAR_26 = 0, VAR_27 = 0, VAR_28 = 0, VAR_29 = 0, VAR_30 = 0;\n        usec_t VAR_31 = 0;\n        _cleanup_close_ int VAR_32 = -VAR_33, VAR_34 = -VAR_33, VAR_35 = -VAR_33;\n        _cleanup_fclose_ VAR_36 *VAR_37 = NULL, *VAR_38 = NULL, *VAR_39 = NULL;\n        MMapFileDescriptor *VAR_40 = NULL, *VAR_41 = NULL, *VAR_42 = NULL;\n        unsigned VAR_43;\n        bool VAR_44 = false;\n        const char *VAR_45 = NULL;\n        MMapCache *VAR_46;\n\n#if VAR_47\n        uint64_t VAR_48 = 0;\n#endif\n        assert(VAR_0);\n\n        if (VAR_1) {\n#if VAR_47\n                VAR_6 = journal_file_parse_verification_key(VAR_0, VAR_1);\n                if (VAR_6 < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return VAR_6;\n                }\n#else\n                return -VAR_49;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(VAR_0->header))\n                return -VAR_50;\n\n        VAR_6 = var_tmp_dir(&VAR_45);\n        if (VAR_6 < 0) {\n                log_error_errno(VAR_6, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        VAR_32 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);\n        if (VAR_32 < 0) {\n                VAR_6 = log_error_errno(VAR_32, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        VAR_34 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);\n        if (VAR_34 < 0) {\n                VAR_6 = log_error_errno(VAR_34, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        VAR_35 = open_tmpfile_unlinkable(VAR_45, VAR_51 | VAR_52);\n        if (VAR_35 < 0) {\n                VAR_6 = log_error_errno(VAR_35,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        VAR_46 = mmap_cache_fd_cache(VAR_0->cache_fd);\n        VAR_40 = mmap_cache_add_fd(VAR_46, VAR_32, VAR_53|VAR_54);\n        if (!VAR_40) {\n                VAR_6 = log_oom();\n                goto fail;\n        }\n\n        VAR_41 = mmap_cache_add_fd(VAR_46, VAR_34, VAR_53|VAR_54);\n        if (!VAR_41) {\n                VAR_6 = log_oom();\n                goto fail;\n        }\n\n        VAR_42 = mmap_cache_add_fd(VAR_46, VAR_35, VAR_53|VAR_54);\n        if (!VAR_42) {\n                VAR_6 = log_oom();\n                goto fail;\n        }\n\n        VAR_6 = take_fdopen_unlocked(&VAR_32, \"w+\", &VAR_37);\n        if (VAR_6 < 0) {\n                log_error_errno(VAR_6, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        VAR_6 = take_fdopen_unlocked(&VAR_34, \"w+\", &VAR_38);\n        if (VAR_6 < 0) {\n                log_error_errno(VAR_6, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        VAR_6 = take_fdopen_unlocked(&VAR_35, \"w+\", &VAR_39);\n        if (VAR_6 < 0) {\n                log_error_errno(VAR_6, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(VAR_0->header->compatible_flags) & ~VAR_55) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                VAR_6 = -VAR_49;\n                goto fail;\n        }\n\n        for (VAR_43 = 0; VAR_43 < sizeof(VAR_0->header->reserved); VAR_43++)\n                if (VAR_0->header->reserved[VAR_43] != 0) {\n                        error(offsetof(VAR_56, VAR_57[VAR_43]), \"Reserved field is non-zero\");\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n        /* COMMENT_1 */\n                                                     \n\n        VAR_8 = le64toh(VAR_0->header->header_size);\n        for (;;) {\n                /* COMMENT_3 */\n                if (le64toh(VAR_0->header->tail_object_offset) == 0)\n                        break;\n\n                if (VAR_5)\n                        draw_progress(scale_progress(0x7FFF, VAR_8, le64toh(VAR_0->header->tail_object_offset)), &VAR_31);\n\n                VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);\n                if (VAR_6 < 0) {\n                        error_errno(VAR_8, VAR_6, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (VAR_8 > le64toh(VAR_0->header->tail_object_offset)) {\n                        error(offsetof(VAR_56, VAR_60),\n                              \"Invalid tail object pointer (%\"VAR_61\" > %\"VAR_61\")\",\n                              VAR_8,\n                              le64toh(VAR_0->header->tail_object_offset));\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n                VAR_23++;\n\n                VAR_6 = journal_file_object_verify(VAR_0, VAR_8, VAR_7);\n                if (VAR_6 < 0) {\n                        error_errno(VAR_8, VAR_6, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(VAR_7->object.flags & VAR_62) +\n                    !!(VAR_7->object.flags & VAR_63) +\n                    !!(VAR_7->object.flags & VAR_64) > 1) {\n                        error(VAR_8, \"Object has multiple compression flags set (flags: 0x%x)\", VAR_7->object.flags);\n                        VAR_6 = -VAR_65;\n                        goto fail;\n                }\n\n                if ((VAR_7->object.flags & VAR_62) && !JOURNAL_HEADER_COMPRESSED_XZ(VAR_0->header)) {\n                        error(VAR_8, \"XZ compressed object in file without XZ compression\");\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n                if ((VAR_7->object.flags & VAR_63) && !JOURNAL_HEADER_COMPRESSED_LZ4(VAR_0->header)) {\n                        error(VAR_8, \"LZ4 compressed object in file without LZ4 compression\");\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n                if ((VAR_7->object.flags & VAR_64) && !JOURNAL_HEADER_COMPRESSED_ZSTD(VAR_0->header)) {\n                        error(VAR_8, \"ZSTD compressed object in file without ZSTD compression\");\n                        VAR_6 = -VAR_58;\n                        goto fail;\n                }\n\n                switch (VAR_7->object.type) {\n\n                case VAR_66:\n                        VAR_6 = write_uint64(VAR_37, VAR_8);\n                        if (VAR_6 < 0)\n                                goto fail;\n\n                        VAR_25++;\n                        break;\n\n                case VAR_67:\n                        VAR_26++;\n                        break;\n\n                case VAR_68:\n                        if (JOURNAL_HEADER_SEALED(VAR_0->header) && VAR_30 <= 0) {\n                                error(VAR_8, \"First entry before first tag\");\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        VAR_6 = write_uint64(VAR_38, VAR_8);\n                        if (VAR_6 < 0)\n                                goto fail;\n\n                        if (le64toh(VAR_7->entry.realtime) < VAR_10) {\n                                error(VAR_8,\n                                      \"Older entry after newer tag (%\"VAR_61\" < %\"VAR_61\")\",\n                                      le64toh(VAR_7->entry.realtime),\n                                      VAR_10);\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        if (!VAR_19 &&\n                            le64toh(VAR_7->entry.seqnum) != le64toh(VAR_0->header->head_entry_seqnum)) {\n                                error(VAR_8,\n                                      \"Head entry sequence number incorrect (%\"VAR_61\" != %\"VAR_61\")\",\n                                      le64toh(VAR_7->entry.seqnum),\n                                      le64toh(VAR_0->header->head_entry_seqnum));\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        if (VAR_19 &&\n                            VAR_12 >= le64toh(VAR_7->entry.seqnum)) {\n                                error(VAR_8,\n                                      \"Entry sequence number out of synchronization (%\"VAR_61\" >= %\"VAR_61\")\",\n                                      VAR_12,\n                                      le64toh(VAR_7->entry.seqnum));\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        VAR_12 = le64toh(VAR_7->entry.seqnum);\n                        VAR_19 = true;\n\n                        if (VAR_20 &&\n                            sd_id128_equal(VAR_18, VAR_7->entry.boot_id) &&\n                            VAR_13 > le64toh(VAR_7->entry.monotonic)) {\n                                error(VAR_8,\n                                      \"Entry timestamp out of synchronization (%\"VAR_61\" > %\"VAR_61\")\",\n                                      VAR_13,\n                                      le64toh(VAR_7->entry.monotonic));\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        VAR_13 = le64toh(VAR_7->entry.monotonic);\n                        VAR_18 = VAR_7->entry.boot_id;\n                        VAR_20 = true;\n\n                        if (!VAR_21 &&\n                            le64toh(VAR_7->entry.realtime) != le64toh(VAR_0->header->head_entry_realtime)) {\n                                error(VAR_8,\n                                      \"Head entry realtime timestamp incorrect (%\"VAR_61\" != %\"VAR_61\")\",\n                                      le64toh(VAR_7->entry.realtime),\n                                      le64toh(VAR_0->header->head_entry_realtime));\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        VAR_14 = le64toh(VAR_7->entry.realtime);\n                        VAR_21 = true;\n\n                        VAR_17 = MAX(VAR_17, le64toh(VAR_7->entry.realtime));\n                        VAR_15 = MIN(VAR_15, le64toh(VAR_7->entry.realtime));\n\n                        VAR_24++;\n                        break;\n\n                case VAR_69:\n                        VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_27,\n                                              le64toh(VAR_0->header->data_hash_table_offset),\n                                              le64toh(VAR_0->header->data_hash_table_size));\n                        if (VAR_6 < 0)\n                                goto fail;\n                        break;\n\n                case VAR_70:\n                        VAR_6 = verify_hash_table(VAR_7, VAR_8, &VAR_28,\n                                              le64toh(VAR_0->header->field_hash_table_offset),\n                                              le64toh(VAR_0->header->field_hash_table_size));\n                        if (VAR_6 < 0)\n                                goto fail;\n\n                        break;\n\n                case VAR_71:\n                        VAR_6 = write_uint64(VAR_39, VAR_8);\n                        if (VAR_6 < 0)\n                                goto fail;\n\n                        if (VAR_8 == le64toh(VAR_0->header->entry_array_offset)) {\n                                if (VAR_22) {\n                                        error(VAR_8, \"More than one main entry array\");\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n\n                                VAR_22 = true;\n                        }\n\n                        VAR_29++;\n                        break;\n\n                case VAR_72:\n                        if (!JOURNAL_HEADER_SEALED(VAR_0->header)) {\n                                error(VAR_8, \"Tag object in file without sealing\");\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        if (le64toh(VAR_7->tag.seqnum) != VAR_30 + 1) {\n                                error(VAR_8,\n                                      \"Tag sequence number out of synchronization (%\"VAR_61\" != %\"VAR_61\")\",\n                                      le64toh(VAR_7->tag.seqnum),\n                                      VAR_30 + 1);\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n                        if (le64toh(VAR_7->tag.epoch) < VAR_9) {\n                                error(VAR_8,\n                                      \"Epoch sequence out of synchronization (%\"VAR_61\" < %\"VAR_61\")\",\n                                      le64toh(VAR_7->tag.epoch),\n                                      VAR_9);\n                                VAR_6 = -VAR_58;\n                                goto fail;\n                        }\n\n#if VAR_47\n                        if (JOURNAL_HEADER_SEALED(VAR_0->header)) {\n                                uint64_t VAR_73, VAR_74, VAR_75;\n\n                                debug(VAR_8, \"Checking tag %\"VAR_61\"...\", le64toh(VAR_7->tag.seqnum));\n\n                                VAR_74 = VAR_0->fss_start_usec + le64toh(VAR_7->tag.epoch) * VAR_0->fss_interval_usec;\n                                VAR_75 = usec_add(VAR_74, VAR_0->fss_interval_usec);\n                                if (VAR_21 && VAR_14 >= VAR_75) {\n                                        error(VAR_8,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"VAR_61\" >= %\"VAR_61\")\",\n                                              VAR_14,\n                                              VAR_74 + VAR_0->fss_interval_usec);\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n                                if (VAR_17 >= VAR_75) {\n                                        error(VAR_8,\n                                              \"Entry realtime (%\"VAR_61\", %s) is too late with respect to tag (%\"VAR_61\", %s)\",\n                                              VAR_17, FORMAT_TIMESTAMP(VAR_17),\n                                              VAR_75, FORMAT_TIMESTAMP(VAR_75));\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n                                if (VAR_15 < VAR_74) {\n                                        error(VAR_8,\n                                              \"Entry realtime (%\"VAR_61\", %s) is too early with respect to tag (%\"VAR_61\", %s)\",\n                                              VAR_15, FORMAT_TIMESTAMP(VAR_15),\n                                              VAR_74, FORMAT_TIMESTAMP(VAR_74));\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n                                VAR_15 = VAR_16;\n\n                                /* COMMENT_4 */\n                                                                            \n                                                         \n                                VAR_6 = journal_file_fsprg_seek(VAR_0, le64toh(VAR_7->tag.epoch));\n                                if (VAR_6 < 0)\n                                        goto fail;\n\n                                VAR_6 = journal_file_hmac_start(VAR_0);\n                                if (VAR_6 < 0)\n                                        goto fail;\n\n                                if (VAR_48 == 0) {\n                                        VAR_6 = journal_file_hmac_put_header(VAR_0);\n                                        if (VAR_6 < 0)\n                                                goto fail;\n\n                                        VAR_73 = le64toh(VAR_0->header->header_size);\n                                } else\n                                        VAR_73 = VAR_48;\n\n                                while (VAR_73 <= VAR_8) {\n                                        VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_73, &VAR_7);\n                                        if (VAR_6 < 0)\n                                                goto fail;\n\n                                        VAR_6 = journal_file_hmac_put_object(VAR_0, VAR_59, VAR_7, VAR_73);\n                                        if (VAR_6 < 0)\n                                                goto fail;\n\n                                        VAR_73 = VAR_73 + ALIGN64(le64toh(VAR_7->object.size));\n                                }\n\n                                /* COMMENT_7 */\n                                VAR_6 = journal_file_move_to_object(VAR_0, VAR_59, VAR_8, &VAR_7);\n                                if (VAR_6 < 0)\n                                        goto fail;\n\n                                if (memcmp(VAR_7->tag.tag, gcry_md_read(VAR_0->hmac, 0), VAR_76) != 0) {\n                                        error(VAR_8, \"Tag failed verification\");\n                                        VAR_6 = -VAR_58;\n                                        goto fail;\n                                }\n\n                                VAR_0->hmac_running = false;\n                                VAR_10 = VAR_74;\n                                VAR_11 = VAR_14;\n                        }\n\n                        VAR_48 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));\n#endif\n\n                        VAR_9 = le64toh(VAR_7->tag.epoch);\n\n                        VAR_30++;\n                        break;\n                }\n\n                if (VAR_8 == le64toh(VAR_0->header->tail_object_offset)) {\n                        VAR_44 = true;\n                        break;\n                }\n\n                VAR_8 = VAR_8 + ALIGN64(le64toh(VAR_7->object.size));\n        };\n\n        if (!VAR_44 && le64toh(VAR_0->header->tail_object_offset) != 0) {\n                error(le64toh(VAR_0->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"VAR_61\" != 0)\",\n                      le64toh(VAR_0->header->tail_object_offset));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_23 != le64toh(VAR_0->header->n_objects)) {\n                error(offsetof(VAR_56, VAR_23),\n                      \"Object number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_23,\n                      le64toh(VAR_0->header->n_objects));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_24 != le64toh(VAR_0->header->n_entries)) {\n                error(offsetof(VAR_56, VAR_24),\n                      \"Entry number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_24,\n                      le64toh(VAR_0->header->n_entries));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_25) &&\n            VAR_25 != le64toh(VAR_0->header->n_data)) {\n                error(offsetof(VAR_56, VAR_25),\n                      \"Data number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_25,\n                      le64toh(VAR_0->header->n_data));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_26) &&\n            VAR_26 != le64toh(VAR_0->header->n_fields)) {\n                error(offsetof(VAR_56, VAR_26),\n                      \"Field number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_26,\n                      le64toh(VAR_0->header->n_fields));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_30) &&\n            VAR_30 != le64toh(VAR_0->header->n_tags)) {\n                error(offsetof(VAR_56, VAR_30),\n                      \"Tag number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_30,\n                      le64toh(VAR_0->header->n_tags));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_29) &&\n            VAR_29 != le64toh(VAR_0->header->n_entry_arrays)) {\n                error(offsetof(VAR_56, VAR_29),\n                      \"Entry array number mismatch (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_29,\n                      le64toh(VAR_0->header->n_entry_arrays));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (!VAR_22 && le64toh(VAR_0->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_19 &&\n            VAR_12 != le64toh(VAR_0->header->tail_entry_seqnum)) {\n                error(offsetof(VAR_56, VAR_77),\n                      \"Tail entry sequence number incorrect (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_12,\n                      le64toh(VAR_0->header->tail_entry_seqnum));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_20 &&\n            (sd_id128_equal(VAR_18, VAR_0->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(VAR_0->header) &&\n             VAR_13 != le64toh(VAR_0->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_13,\n                      le64toh(VAR_0->header->tail_entry_monotonic));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (VAR_21 && VAR_14 != le64toh(VAR_0->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"VAR_61\" != %\"VAR_61\")\",\n                      VAR_14,\n                      le64toh(VAR_0->header->tail_entry_realtime));\n                VAR_6 = -VAR_58;\n                goto fail;\n        }\n\n        if (fflush(VAR_37) != 0) {\n                VAR_6 = log_error_errno(VAR_78, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(VAR_38) != 0) {\n                VAR_6 = log_error_errno(VAR_78, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(VAR_39) != 0) {\n                VAR_6 = log_error_errno(VAR_78, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* COMMENT_8 */\n                                                                \n                                                                    \n                                                                   \n                                                                    \n                                                                     \n                                       \n\n        VAR_6 = verify_entry_array(VAR_0,\n                               VAR_40, VAR_25,\n                               VAR_41, VAR_24,\n                               VAR_42, VAR_29,\n                               &VAR_31,\n                               VAR_5);\n        if (VAR_6 < 0)\n                goto fail;\n\n        VAR_6 = verify_data_hash_table(VAR_0,\n                                   VAR_40, VAR_25,\n                                   VAR_41, VAR_24,\n                                   VAR_42, VAR_29,\n                                   &VAR_31,\n                                   VAR_5);\n        if (VAR_6 < 0)\n                goto fail;\n\n        if (VAR_5)\n                flush_progress();\n\n        mmap_cache_fd_free(VAR_40);\n        mmap_cache_fd_free(VAR_41);\n        mmap_cache_fd_free(VAR_42);\n\n        if (VAR_2)\n                *VAR_2 = le64toh(VAR_0->header->head_entry_realtime);\n        if (VAR_3)\n                *VAR_3 = VAR_11;\n        if (VAR_4)\n                *VAR_4 = le64toh(VAR_0->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (VAR_5)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"VAR_61\" (of %\"VAR_61\" bytes, %\"VAR_61\"%%).\",\n                  VAR_0->path,\n                  VAR_8,\n                  (uint64_t) VAR_0->last_stat.st_size,\n                  100U * VAR_8 / (uint64_t) VAR_0->last_stat.st_size);\n\n        if (VAR_40)\n                mmap_cache_fd_free(VAR_40);\n\n        if (VAR_41)\n                mmap_cache_fd_free(VAR_41);\n\n        if (VAR_42)\n                mmap_cache_fd_free(VAR_42);\n\n        return VAR_6;\n}",
  "func_graph_path": "systemd/3c896258067991832a1e896093b748aebfc873e1/journal-verify.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,10 @@\n         Object *o;\n         uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n \n-        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;\n+        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n+        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;\n         sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n-        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;\n+        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;\n         uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n         usec_t last_usec = 0;\n         _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n@@ -259,12 +260,8 @@\n                         entry_realtime = le64toh(o->entry.realtime);\n                         entry_realtime_set = true;\n \n-                        if (max_entry_realtime < le64toh(o->entry.realtime))\n-                                max_entry_realtime = le64toh(o->entry.realtime);\n-                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {\n-                                min_entry_realtime = le64toh(o->entry.realtime);\n-                                min_entry_realtime_set = true;\n-                        }\n+                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));\n+                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));\n \n                         n_entries++;\n                         break;\n@@ -331,12 +328,13 @@\n \n #if HAVE_GCRYPT\n                         if (JOURNAL_HEADER_SEALED(f->header)) {\n-                                uint64_t q, rt;\n+                                uint64_t q, rt, rt_end;\n \n                                 debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n \n                                 rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n-                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {\n+                                rt_end = usec_add(rt, f->fss_interval_usec);\n+                                if (entry_realtime_set && entry_realtime >= rt_end) {\n                                         error(p,\n                                               \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                               entry_realtime,\n@@ -344,23 +342,23 @@\n                                         r = -EBADMSG;\n                                         goto fail;\n                                 }\n-                                if (max_entry_realtime >= rt + f->fss_interval_usec) {\n+                                if (max_entry_realtime >= rt_end) {\n                                         error(p,\n-                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",\n-                                              max_entry_realtime,\n-                                              rt + f->fss_interval_usec);\n+                                              \"Entry realtime (%\"PRIu64\", %s) is too late with respect to tag (%\"PRIu64\", %s)\",\n+                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),\n+                                              rt_end, FORMAT_TIMESTAMP(rt_end));\n                                         r = -EBADMSG;\n                                         goto fail;\n                                 }\n-                                if (min_entry_realtime_set && min_entry_realtime < rt) {\n+                                if (min_entry_realtime < rt) {\n                                         error(p,\n-                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n-                                              min_entry_realtime,\n-                                              rt);\n+                                              \"Entry realtime (%\"PRIu64\", %s) is too early with respect to tag (%\"PRIu64\", %s)\",\n+                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),\n+                                              rt, FORMAT_TIMESTAMP(rt));\n                                         r = -EBADMSG;\n                                         goto fail;\n                                 }\n-                                min_entry_realtime_set = false;\n+                                min_entry_realtime = USEC_INFINITY;\n \n                                 /* OK, now we know the epoch. So let's now set\n                                  * it, and calculate the HMAC for everything",
  "diff_line_info": {
    "deleted_lines": [
      "        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;",
      "        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;",
      "                        if (max_entry_realtime < le64toh(o->entry.realtime))",
      "                                max_entry_realtime = le64toh(o->entry.realtime);",
      "                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {",
      "                                min_entry_realtime = le64toh(o->entry.realtime);",
      "                                min_entry_realtime_set = true;",
      "                        }",
      "                                uint64_t q, rt;",
      "                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {",
      "                                if (max_entry_realtime >= rt + f->fss_interval_usec) {",
      "                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",",
      "                                              max_entry_realtime,",
      "                                              rt + f->fss_interval_usec);",
      "                                if (min_entry_realtime_set && min_entry_realtime < rt) {",
      "                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",",
      "                                              min_entry_realtime,",
      "                                              rt);",
      "                                min_entry_realtime_set = false;"
    ],
    "added_lines": [
      "        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;",
      "        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;",
      "        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;",
      "                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));",
      "                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));",
      "                                uint64_t q, rt, rt_end;",
      "                                rt_end = usec_add(rt, f->fss_interval_usec);",
      "                                if (entry_realtime_set && entry_realtime >= rt_end) {",
      "                                if (max_entry_realtime >= rt_end) {",
      "                                              \"Entry realtime (%\"PRIu64\", %s) is too late with respect to tag (%\"PRIu64\", %s)\",",
      "                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),",
      "                                              rt_end, FORMAT_TIMESTAMP(rt_end));",
      "                                if (min_entry_realtime < rt) {",
      "                                              \"Entry realtime (%\"PRIu64\", %s) is too early with respect to tag (%\"PRIu64\", %s)\",",
      "                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),",
      "                                              rt, FORMAT_TIMESTAMP(rt));",
      "                                min_entry_realtime = USEC_INFINITY;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/systemd/systemd/pull/28885",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/systemd/systemd/pull/28885: 403 Client Error: Forbidden for url: https://api.github.com/repos/systemd/systemd/pulls/28885",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}