{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/jcl/common/sun_reflect_ConstantPool.c",
  "func_name": "getFieldAt",
  "func_before": "static jobject\ngetFieldAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjobject returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\tjfieldID fieldID = NULL;\n\tUDATA cpType = J9CPTYPE_UNUSED;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9RAMConstantRef *ramConstantRef = NULL;\n\t\tjclass jlClass = NULL;\n\t\t\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\nretry:\n\t\tramConstantRef = NULL;\n\t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n\t\tif (OK == result) {\n\t\t\tJ9ROMFieldShape *resolvedField = NULL;\n\t\t\tUDATA offset = 0;\n\t\t\tJ9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop);\n\t\t\tJ9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass);\n\t\t\tswitch (cpType) {\n\t\t\tcase J9CPTYPE_FIELD: {\n\t\t\t\t/* Try to resolve as instance field, then as a static */\n\t\t\t\toffset = (UDATA) vmFunctions->resolveInstanceFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n\t\t\t\tif (NULL == resolvedField) {\n\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n\t\t\t\t\toffset = (UDATA) fieldAddress - (UDATA) cpClass->ramStatics;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tresult = WRONG_CP_ENTRY_TYPE_EXCEPTION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != resolvedField) {\n\t\t\t\tJ9ROMFieldRef *romFieldRef = NULL;\n\t\t\t\tJ9Class *declaringClass = NULL;\n\t\t\t\tresult = getROMCPItem(vmThread, constantPoolOop, cpIndex, cpType, (J9ROMConstantPoolItem **) &romFieldRef);\n\t\t\t\tif (OK == result) {\n\t\t\t\t\tresult = getJ9ClassAt(vmThread, constantPoolOop, romFieldRef->classRefCPIndex, resolveFlags, &declaringClass);\n\t\t\t\t}\n\t\t\t\tif (OK == result) {\n\t\t\t\t\tUDATA inconsistentData = 0;\n\t\t\t\t\tfieldID = (jfieldID) vmFunctions->getJNIFieldID(vmThread, declaringClass, resolvedField, offset, &inconsistentData);\n\t\t\t\t\tif (0 != inconsistentData) {\n\t\t\t\t\t\t/* Hotswap occurred - the resolvedField is not from declaringClass->romClass.\n\t\t\t\t\t\t * Need to restart the operation.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\n\t\t\t\t\tjlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\n\t\tif (NULL != fieldID) {\n\t\t\tif (NULL != jlClass) {\n\t\t\t\t/* The isStatic argument is ignored. */\n\t\t\t\treturnValue = (*env)->ToReflectedField(env, jlClass, fieldID, FALSE);\n\t\t\t} else {\n\t\t\t\tvmFunctions->throwNativeOOMError(env, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
  "abstract_func_before": "static jobject\ngetFieldAt(JNIEnv *VAR_0, jobject VAR_1, jint VAR_2, UDATA VAR_3)\n{\n\tjobject VAR_4 = NULL;\n\tJ9VMThread *VAR_5 = (J9VMThread *) VAR_0;\n\tJ9InternalVMFunctions *VAR_6 = VAR_5->javaVM->internalVMFunctions;\n\tSunReflectCPResult VAR_7 = VAR_8;\n\tjfieldID VAR_9 = NULL;\n\tUDATA VAR_10 = VAR_11;\n\n\tif (NULL != VAR_1) {\n\t\tJ9RAMConstantRef *VAR_12 = NULL;\n\t\tjclass VAR_13 = NULL;\n\t\t\n\t\tVAR_6->internalEnterVMFromJNI(VAR_5);\nretry:\n\t\tVAR_12 = NULL;\n\t\tVAR_7 = getRAMConstantRefAndType(VAR_5, VAR_1, VAR_2, &VAR_10, &VAR_12);\n\t\tif (VAR_14 == VAR_7) {\n\t\t\tJ9ROMFieldShape *VAR_15 = NULL;\n\t\t\tUDATA VAR_16 = 0;\n\t\t\tJ9Class *VAR_17 = J9CLASS_FROMCPINTERNALRAMCLASS(VAR_5, VAR_1);\n\t\t\tJ9ConstantPool *VAR_18 = J9_CP_FROM_CLASS(VAR_17);\n\t\t\tswitch (VAR_10) {\n\t\t\tcase VAR_19: {\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tVAR_16 = (UDATA) VAR_6->resolveInstanceFieldRef(VAR_5, NULL, VAR_18, VAR_2, VAR_3, &VAR_15);\n\t\t\t\tif (NULL == VAR_15) {\n\t\t\t\t\tvoid *VAR_20 = VAR_6->resolveStaticFieldRef(VAR_5, NULL, VAR_18, VAR_2, VAR_3, &VAR_15);\n\t\t\t\t\tVAR_16 = (UDATA) VAR_20 - (UDATA) VAR_17->ramStatics;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tVAR_7 = VAR_21;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != VAR_15) {\n\t\t\t\tJ9ROMFieldRef *VAR_22 = NULL;\n\t\t\t\tJ9Class *VAR_23 = NULL;\n\t\t\t\tVAR_7 = getROMCPItem(VAR_5, VAR_1, VAR_2, VAR_10, (J9ROMConstantPoolItem **) &VAR_22);\n\t\t\t\tif (VAR_14 == VAR_7) {\n\t\t\t\t\tVAR_7 = getJ9ClassAt(VAR_5, VAR_1, VAR_22->classRefCPIndex, VAR_3, &VAR_23);\n\t\t\t\t}\n\t\t\t\tif (VAR_14 == VAR_7) {\n\t\t\t\t\tUDATA VAR_24 = 0;\n\t\t\t\t\tVAR_9 = (jfieldID) VAR_6->getJNIFieldID(VAR_5, VAR_23, VAR_15, VAR_16, &VAR_24);\n\t\t\t\t\tif (0 != VAR_24) {\n\t\t\t\t\t\t/* COMMENT_1 */\n                                       \n         \n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\n\t\t\t\t\tVAR_13 = VAR_6->j9jni_createLocalRef(VAR_0, VAR_17->classObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVAR_6->internalExitVMToJNI(VAR_5);\n\n\t\tif (NULL != VAR_9) {\n\t\t\tif (NULL != VAR_13) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tVAR_4 = (*VAR_0)->ToReflectedField(VAR_0, VAR_13, VAR_9, FALSE);\n\t\t\t} else {\n\t\t\t\tVAR_6->throwNativeOOMError(VAR_0, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckResult(VAR_0, VAR_7);\n\n\treturn VAR_4;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/sun_reflect_ConstantPool.c/vul/before/0.json",
  "func": "static jobject\ngetFieldAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjobject returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\tjfieldID fieldID = NULL;\n\tUDATA cpType = J9CPTYPE_UNUSED;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9RAMConstantRef *ramConstantRef = NULL;\n\t\tjclass jlClass = NULL;\n\t\t\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\nretry:\n\t\tramConstantRef = NULL;\n\t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n\t\tif (OK == result) {\n\t\t\tJ9ROMFieldShape *resolvedField = NULL;\n\t\t\tUDATA offset = 0;\n\t\t\tJ9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop);\n\t\t\tJ9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass);\n\t\t\tswitch (cpType) {\n\t\t\tcase J9CPTYPE_FIELD: {\n\t\t\t\t/* Try to resolve as instance field, then as a static */\n\t\t\t\toffset = (UDATA) vmFunctions->resolveInstanceFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n\t\t\t\tif (NULL == resolvedField) {\n\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRefInto(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField, NULL);\n\t\t\t\t\toffset = (UDATA) fieldAddress - (UDATA) cpClass->ramStatics;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tresult = WRONG_CP_ENTRY_TYPE_EXCEPTION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != resolvedField) {\n\t\t\t\tJ9ROMFieldRef *romFieldRef = NULL;\n\t\t\t\tJ9Class *declaringClass = NULL;\n\t\t\t\tresult = getROMCPItem(vmThread, constantPoolOop, cpIndex, cpType, (J9ROMConstantPoolItem **) &romFieldRef);\n\t\t\t\tif (OK == result) {\n\t\t\t\t\tresult = getJ9ClassAt(vmThread, constantPoolOop, romFieldRef->classRefCPIndex, resolveFlags, &declaringClass);\n\t\t\t\t}\n\t\t\t\tif (OK == result) {\n\t\t\t\t\tUDATA inconsistentData = 0;\n\t\t\t\t\tfieldID = (jfieldID) vmFunctions->getJNIFieldID(vmThread, declaringClass, resolvedField, offset, &inconsistentData);\n\t\t\t\t\tif (0 != inconsistentData) {\n\t\t\t\t\t\t/* Hotswap occurred - the resolvedField is not from declaringClass->romClass.\n\t\t\t\t\t\t * Need to restart the operation.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\n\t\t\t\t\tjlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\n\t\tif (NULL != fieldID) {\n\t\t\tif (NULL != jlClass) {\n\t\t\t\t/* The isStatic argument is ignored. */\n\t\t\t\treturnValue = (*env)->ToReflectedField(env, jlClass, fieldID, FALSE);\n\t\t\t} else {\n\t\t\t\tvmFunctions->throwNativeOOMError(env, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
  "abstract_func": "static jobject\ngetFieldAt(JNIEnv *VAR_0, jobject VAR_1, jint VAR_2, UDATA VAR_3)\n{\n\tjobject VAR_4 = NULL;\n\tJ9VMThread *VAR_5 = (J9VMThread *) VAR_0;\n\tJ9InternalVMFunctions *VAR_6 = VAR_5->javaVM->internalVMFunctions;\n\tSunReflectCPResult VAR_7 = VAR_8;\n\tjfieldID VAR_9 = NULL;\n\tUDATA VAR_10 = VAR_11;\n\n\tif (NULL != VAR_1) {\n\t\tJ9RAMConstantRef *VAR_12 = NULL;\n\t\tjclass VAR_13 = NULL;\n\t\t\n\t\tVAR_6->internalEnterVMFromJNI(VAR_5);\n\t\tVAR_3 |= (VAR_14 | VAR_15 | VAR_16);\nretry:\n\t\tVAR_12 = NULL;\n\t\tVAR_7 = getRAMConstantRefAndType(VAR_5, VAR_1, VAR_2, &VAR_10, &VAR_12);\n\t\tif (VAR_17 == VAR_7) {\n\t\t\tJ9ROMFieldShape *VAR_18 = NULL;\n\t\t\tUDATA VAR_19 = 0;\n\t\t\tJ9Class *VAR_20 = J9CLASS_FROMCPINTERNALRAMCLASS(VAR_5, VAR_1);\n\t\t\tJ9ConstantPool *VAR_21 = J9_CP_FROM_CLASS(VAR_20);\n\t\t\tswitch (VAR_10) {\n\t\t\tcase VAR_22: {\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tVAR_19 = (UDATA) VAR_6->resolveInstanceFieldRef(VAR_5, NULL, VAR_21, VAR_2, VAR_3, &VAR_18);\n\t\t\t\tif (NULL == VAR_18) {\n\t\t\t\t\tvoid *VAR_23 = VAR_6->resolveStaticFieldRefInto(VAR_5, NULL, VAR_21, VAR_2, VAR_3, &VAR_18, NULL);\n\t\t\t\t\tVAR_19 = (UDATA) VAR_23 - (UDATA) VAR_20->ramStatics;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tVAR_7 = VAR_24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != VAR_18) {\n\t\t\t\tJ9ROMFieldRef *VAR_25 = NULL;\n\t\t\t\tJ9Class *VAR_26 = NULL;\n\t\t\t\tVAR_7 = getROMCPItem(VAR_5, VAR_1, VAR_2, VAR_10, (J9ROMConstantPoolItem **) &VAR_25);\n\t\t\t\tif (VAR_17 == VAR_7) {\n\t\t\t\t\tVAR_7 = getJ9ClassAt(VAR_5, VAR_1, VAR_25->classRefCPIndex, VAR_3, &VAR_26);\n\t\t\t\t}\n\t\t\t\tif (VAR_17 == VAR_7) {\n\t\t\t\t\tUDATA VAR_27 = 0;\n\t\t\t\t\tVAR_9 = (jfieldID) VAR_6->getJNIFieldID(VAR_5, VAR_26, VAR_18, VAR_19, &VAR_27);\n\t\t\t\t\tif (0 != VAR_27) {\n\t\t\t\t\t\t/* COMMENT_1 */\n                                       \n         \n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\n\t\t\t\t\tVAR_13 = VAR_6->j9jni_createLocalRef(VAR_0, VAR_20->classObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVAR_6->internalExitVMToJNI(VAR_5);\n\n\t\tif (NULL != VAR_9) {\n\t\t\tif (NULL != VAR_13) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tVAR_4 = (*VAR_0)->ToReflectedField(VAR_0, VAR_13, VAR_9, FALSE);\n\t\t\t} else {\n\t\t\t\tVAR_6->throwNativeOOMError(VAR_0, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckResult(VAR_0, VAR_7);\n\n\treturn VAR_4;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/sun_reflect_ConstantPool.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \t\tjclass jlClass = NULL;\n \t\t\n \t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n+\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n retry:\n \t\tramConstantRef = NULL;\n \t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n@@ -26,7 +27,7 @@\n \t\t\t\t/* Try to resolve as instance field, then as a static */\n \t\t\t\toffset = (UDATA) vmFunctions->resolveInstanceFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n \t\t\t\tif (NULL == resolvedField) {\n-\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n+\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRefInto(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField, NULL);\n \t\t\t\t\toffset = (UDATA) fieldAddress - (UDATA) cpClass->ramStatics;\n \t\t\t\t}\n \t\t\t\tbreak;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);"
    ],
    "added_lines": [
      "\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);",
      "\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRefInto(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField, NULL);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9\n\nThe patch addresses issues related to class loading and initialization in the ConstantPool, specifically fixing how classes are resolved and preventing unnecessary initializations. The changes in the code diff support this by modifying how fields are resolved and adding flags to control class initialization behavior. Since there's no mention of security vulnerabilities or known exploits, the classification falls under defect remediation. The confidence is high due to clear evidence of functional fix without security implications."
}