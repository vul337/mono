{
  "cve_id": "CVE-2020-7105",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis/hiredis",
  "commit_msg": "Rename allocation wrappers and add license info\n\nSee #752, #747",
  "commit_hash": "70e73a31ad5edb6c457658c0a0b6752b06cc6a25",
  "git_url": "https://github.com/redis/hiredis/commit/70e73a31ad5edb6c457658c0a0b6752b06cc6a25",
  "file_path": "net.c",
  "func_name": "_redisContextConnectTcp",
  "func_before": "static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,\n                                   const struct timeval *timeout,\n                                   const char *source_addr) {\n    redisFD s;\n    int rv, n;\n    char _port[6];  /* strlen(\"65535\"); */\n    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;\n    int blocking = (c->flags & REDIS_BLOCK);\n    int reuseaddr = (c->flags & REDIS_REUSEADDR);\n    int reuses = 0;\n    long timeout_msec = -1;\n\n    servinfo = NULL;\n    c->connection_type = REDIS_CONN_TCP;\n    c->tcp.port = port;\n\n    /* We need to take possession of the passed parameters\n     * to make them reusable for a reconnect.\n     * We also carefully check we don't free data we already own,\n     * as in the case of the reconnect method.\n     *\n     * This is a bit ugly, but atleast it works and doesn't leak memory.\n     **/\n    if (c->tcp.host != addr) {\n        free(c->tcp.host);\n\n        c->tcp.host = hiredis_safe_strdup(addr);\n    }\n\n    if (timeout) {\n        if (c->timeout != timeout) {\n            if (c->timeout == NULL)\n                c->timeout = hiredis_safe_malloc(sizeof(struct timeval));\n\n            memcpy(c->timeout, timeout, sizeof(struct timeval));\n        }\n    } else {\n        free(c->timeout);\n        c->timeout = NULL;\n    }\n\n    if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) {\n        __redisSetError(c, REDIS_ERR_IO, \"Invalid timeout specified\");\n        goto error;\n    }\n\n    if (source_addr == NULL) {\n        free(c->tcp.source_addr);\n        c->tcp.source_addr = NULL;\n    } else if (c->tcp.source_addr != source_addr) {\n        free(c->tcp.source_addr);\n        c->tcp.source_addr = hiredis_safe_strdup(source_addr);\n    }\n\n    snprintf(_port, 6, \"%d\", port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Try with IPv6 if no IPv4 address was found. We do it in this order since\n     * in a Redis client you can't afford to test if you have IPv6 connectivity\n     * as this would add latency to every connect. Otherwise a more sensible\n     * route could be: Use IPv6 if both addresses are available and there is IPv6\n     * connectivity. */\n    if ((rv = getaddrinfo(c->tcp.host,_port,&hints,&servinfo)) != 0) {\n         hints.ai_family = AF_INET6;\n         if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {\n            __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));\n            return REDIS_ERR;\n        }\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\naddrretry:\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == REDIS_INVALID_FD)\n            continue;\n\n        c->fd = s;\n        if (redisSetBlocking(c,0) != REDIS_OK)\n            goto error;\n        if (c->tcp.source_addr) {\n            int bound = 0;\n            /* Using getaddrinfo saves us from self-determining IPv4 vs IPv6 */\n            if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {\n                char buf[128];\n                snprintf(buf,sizeof(buf),\"Can't get addr: %s\",gai_strerror(rv));\n                __redisSetError(c,REDIS_ERR_OTHER,buf);\n                goto error;\n            }\n\n            if (reuseaddr) {\n                n = 1;\n                if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*) &n,\n                               sizeof(n)) < 0) {\n                    freeaddrinfo(bservinfo);\n                    goto error;\n                }\n            }\n\n            for (b = bservinfo; b != NULL; b = b->ai_next) {\n                if (bind(s,b->ai_addr,b->ai_addrlen) != -1) {\n                    bound = 1;\n                    break;\n                }\n            }\n            freeaddrinfo(bservinfo);\n            if (!bound) {\n                char buf[128];\n                snprintf(buf,sizeof(buf),\"Can't bind socket: %s\",strerror(errno));\n                __redisSetError(c,REDIS_ERR_OTHER,buf);\n                goto error;\n            }\n        }\n\n        /* For repeat connection */\n        free(c->saddr);\n        c->saddr = hiredis_safe_malloc(p->ai_addrlen);\n        memcpy(c->saddr, p->ai_addr, p->ai_addrlen);\n        c->addrlen = p->ai_addrlen;\n\n        if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {\n            if (errno == EHOSTUNREACH) {\n                redisNetClose(c);\n                continue;\n            } else if (errno == EINPROGRESS) {\n                if (blocking) {\n                    goto wait_for_ready;\n                }\n                /* This is ok.\n                 * Note that even when it's in blocking mode, we unset blocking\n                 * for `connect()`\n                 */\n            } else if (errno == EADDRNOTAVAIL && reuseaddr) {\n                if (++reuses >= REDIS_CONNECT_RETRIES) {\n                    goto error;\n                } else {\n                    redisNetClose(c);\n                    goto addrretry;\n                }\n            } else {\n                wait_for_ready:\n                if (redisContextWaitReady(c,timeout_msec) != REDIS_OK)\n                    goto error;\n            }\n        }\n        if (blocking && redisSetBlocking(c,1) != REDIS_OK)\n            goto error;\n        if (redisSetTcpNoDelay(c) != REDIS_OK)\n            goto error;\n\n        c->flags |= REDIS_CONNECTED;\n        rv = REDIS_OK;\n        goto end;\n    }\n    if (p == NULL) {\n        char buf[128];\n        snprintf(buf,sizeof(buf),\"Can't create socket: %s\",strerror(errno));\n        __redisSetError(c,REDIS_ERR_OTHER,buf);\n        goto error;\n    }\n\nerror:\n    rv = REDIS_ERR;\nend:\n    if(servinfo) {\n        freeaddrinfo(servinfo);\n    }\n\n    return rv;  // Need to return REDIS_OK if alright\n}",
  "abstract_func_before": "static int _redisContextConnectTcp(redisContext *VAR_0, const char *VAR_1, int VAR_2,\n                                   const struct timeval *VAR_3,\n                                   const char *VAR_4) {\n    redisFD VAR_5;\n    int VAR_6, VAR_7;\n    char VAR_8[6];  /* COMMENT_0 */\n    struct addrinfo VAR_9, *VAR_10, *VAR_11, *VAR_12, *VAR_13;\n    int VAR_14 = (VAR_0->flags & VAR_15);\n    int VAR_16 = (VAR_0->flags & VAR_17);\n    int VAR_18 = 0;\n    long VAR_19 = -1;\n\n    VAR_10 = NULL;\n    VAR_0->connection_type = VAR_20;\n    VAR_0->tcp.port = VAR_2;\n\n    /* COMMENT_1 */\n                                             \n                                                                 \n                                              \n      \n                                                                        \n        \n    if (VAR_0->tcp.host != VAR_1) {\n        free(VAR_0->tcp.host);\n\n        VAR_0->tcp.host = hiredis_safe_strdup(VAR_1);\n    }\n\n    if (VAR_3) {\n        if (VAR_0->timeout != VAR_3) {\n            if (VAR_0->timeout == NULL)\n                VAR_0->timeout = hiredis_safe_malloc(sizeof(struct timeval));\n\n            memcpy(VAR_0->timeout, VAR_3, sizeof(struct timeval));\n        }\n    } else {\n        free(VAR_0->timeout);\n        VAR_0->timeout = NULL;\n    }\n\n    if (redisContextTimeoutMsec(VAR_0, &VAR_19) != VAR_21) {\n        __redisSetError(VAR_0, VAR_22, \"Invalid timeout specified\");\n        goto error;\n    }\n\n    if (VAR_4 == NULL) {\n        free(VAR_0->tcp.source_addr);\n        VAR_0->tcp.source_addr = NULL;\n    } else if (VAR_0->tcp.source_addr != VAR_4) {\n        free(VAR_0->tcp.source_addr);\n        VAR_0->tcp.source_addr = hiredis_safe_strdup(VAR_4);\n    }\n\n    snprintf(VAR_8, 6, \"%d\", VAR_2);\n    memset(&VAR_9,0,sizeof(VAR_9));\n    VAR_9.ai_family = VAR_23;\n    VAR_9.ai_socktype = VAR_24;\n\n    /* COMMENT_8 */\n                                                                               \n                                                                            \n                                                                                 \n                       \n    if ((VAR_6 = getaddrinfo(VAR_0->tcp.host,VAR_8,&VAR_9,&VAR_10)) != 0) {\n         VAR_9.ai_family = VAR_25;\n         if ((VAR_6 = getaddrinfo(VAR_1,VAR_8,&VAR_9,&VAR_10)) != 0) {\n            __redisSetError(VAR_0,VAR_26,gai_strerror(VAR_6));\n            return VAR_27;\n        }\n    }\n    for (VAR_12 = VAR_10; VAR_12 != NULL; VAR_12 = VAR_12->ai_next) {\naddrretry:\n        if ((VAR_5 = socket(VAR_12->ai_family,VAR_12->ai_socktype,VAR_12->ai_protocol)) == VAR_28)\n            continue;\n\n        VAR_0->fd = VAR_5;\n        if (redisSetBlocking(VAR_0,0) != VAR_21)\n            goto error;\n        if (VAR_0->tcp.source_addr) {\n            int VAR_29 = 0;\n            /* COMMENT_13 */\n            if ((VAR_6 = getaddrinfo(VAR_0->tcp.source_addr, NULL, &VAR_9, &VAR_11)) != 0) {\n                char VAR_30[128];\n                snprintf(VAR_30,sizeof(VAR_30),\"Can't get addr: %s\",gai_strerror(VAR_6));\n                __redisSetError(VAR_0,VAR_26,VAR_30);\n                goto error;\n            }\n\n            if (VAR_16) {\n                VAR_7 = 1;\n                if (setsockopt(VAR_5, VAR_31, VAR_32, (char*) &VAR_7,\n                               sizeof(VAR_7)) < 0) {\n                    freeaddrinfo(VAR_11);\n                    goto error;\n                }\n            }\n\n            for (VAR_13 = VAR_11; VAR_13 != NULL; VAR_13 = VAR_13->ai_next) {\n                if (bind(VAR_5,VAR_13->ai_addr,VAR_13->ai_addrlen) != -1) {\n                    VAR_29 = 1;\n                    break;\n                }\n            }\n            freeaddrinfo(VAR_11);\n            if (!VAR_29) {\n                char VAR_30[128];\n                snprintf(VAR_30,sizeof(VAR_30),\"Can't bind socket: %s\",strerror(VAR_33));\n                __redisSetError(VAR_0,VAR_26,VAR_30);\n                goto error;\n            }\n        }\n\n        /* COMMENT_14 */\n        free(VAR_0->saddr);\n        VAR_0->saddr = hiredis_safe_malloc(VAR_12->ai_addrlen);\n        memcpy(VAR_0->saddr, VAR_12->ai_addr, VAR_12->ai_addrlen);\n        VAR_0->addrlen = VAR_12->ai_addrlen;\n\n        if (connect(VAR_5,VAR_12->ai_addr,VAR_12->ai_addrlen) == -1) {\n            if (VAR_33 == VAR_34) {\n                redisNetClose(VAR_0);\n                continue;\n            } else if (VAR_33 == VAR_35) {\n                if (VAR_14) {\n                    goto wait_for_ready;\n                }\n                /* COMMENT_15 */\n                                                                               \n                                  \n                   \n            } else if (VAR_33 == VAR_36 && VAR_16) {\n                if (++VAR_18 >= VAR_37) {\n                    goto error;\n                } else {\n                    redisNetClose(VAR_0);\n                    goto addrretry;\n                }\n            } else {\n                wait_for_ready:\n                if (redisContextWaitReady(VAR_0,VAR_19) != VAR_21)\n                    goto error;\n            }\n        }\n        if (VAR_14 && redisSetBlocking(VAR_0,1) != VAR_21)\n            goto error;\n        if (redisSetTcpNoDelay(VAR_0) != VAR_21)\n            goto error;\n\n        VAR_0->flags |= VAR_38;\n        VAR_6 = VAR_21;\n        goto end;\n    }\n    if (VAR_12 == NULL) {\n        char VAR_30[128];\n        snprintf(VAR_30,sizeof(VAR_30),\"Can't create socket: %s\",strerror(VAR_33));\n        __redisSetError(VAR_0,VAR_26,VAR_30);\n        goto error;\n    }\n\nerror:\n    VAR_6 = VAR_27;\nend:\n    if(VAR_10) {\n        freeaddrinfo(VAR_10);\n    }\n\n    return VAR_6;  /* COMMENT_19 */\n}",
  "func_graph_path_before": "redis/hiredis/70e73a31ad5edb6c457658c0a0b6752b06cc6a25/net.c/vul/before/0.json",
  "func": "static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,\n                                   const struct timeval *timeout,\n                                   const char *source_addr) {\n    redisFD s;\n    int rv, n;\n    char _port[6];  /* strlen(\"65535\"); */\n    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;\n    int blocking = (c->flags & REDIS_BLOCK);\n    int reuseaddr = (c->flags & REDIS_REUSEADDR);\n    int reuses = 0;\n    long timeout_msec = -1;\n\n    servinfo = NULL;\n    c->connection_type = REDIS_CONN_TCP;\n    c->tcp.port = port;\n\n    /* We need to take possession of the passed parameters\n     * to make them reusable for a reconnect.\n     * We also carefully check we don't free data we already own,\n     * as in the case of the reconnect method.\n     *\n     * This is a bit ugly, but atleast it works and doesn't leak memory.\n     **/\n    if (c->tcp.host != addr) {\n        free(c->tcp.host);\n\n        c->tcp.host = hi_strdup(addr);\n    }\n\n    if (timeout) {\n        if (c->timeout != timeout) {\n            if (c->timeout == NULL)\n                c->timeout = hi_malloc(sizeof(struct timeval));\n\n            memcpy(c->timeout, timeout, sizeof(struct timeval));\n        }\n    } else {\n        free(c->timeout);\n        c->timeout = NULL;\n    }\n\n    if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) {\n        __redisSetError(c, REDIS_ERR_IO, \"Invalid timeout specified\");\n        goto error;\n    }\n\n    if (source_addr == NULL) {\n        free(c->tcp.source_addr);\n        c->tcp.source_addr = NULL;\n    } else if (c->tcp.source_addr != source_addr) {\n        free(c->tcp.source_addr);\n        c->tcp.source_addr = hi_strdup(source_addr);\n    }\n\n    snprintf(_port, 6, \"%d\", port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Try with IPv6 if no IPv4 address was found. We do it in this order since\n     * in a Redis client you can't afford to test if you have IPv6 connectivity\n     * as this would add latency to every connect. Otherwise a more sensible\n     * route could be: Use IPv6 if both addresses are available and there is IPv6\n     * connectivity. */\n    if ((rv = getaddrinfo(c->tcp.host,_port,&hints,&servinfo)) != 0) {\n         hints.ai_family = AF_INET6;\n         if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {\n            __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));\n            return REDIS_ERR;\n        }\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\naddrretry:\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == REDIS_INVALID_FD)\n            continue;\n\n        c->fd = s;\n        if (redisSetBlocking(c,0) != REDIS_OK)\n            goto error;\n        if (c->tcp.source_addr) {\n            int bound = 0;\n            /* Using getaddrinfo saves us from self-determining IPv4 vs IPv6 */\n            if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {\n                char buf[128];\n                snprintf(buf,sizeof(buf),\"Can't get addr: %s\",gai_strerror(rv));\n                __redisSetError(c,REDIS_ERR_OTHER,buf);\n                goto error;\n            }\n\n            if (reuseaddr) {\n                n = 1;\n                if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*) &n,\n                               sizeof(n)) < 0) {\n                    freeaddrinfo(bservinfo);\n                    goto error;\n                }\n            }\n\n            for (b = bservinfo; b != NULL; b = b->ai_next) {\n                if (bind(s,b->ai_addr,b->ai_addrlen) != -1) {\n                    bound = 1;\n                    break;\n                }\n            }\n            freeaddrinfo(bservinfo);\n            if (!bound) {\n                char buf[128];\n                snprintf(buf,sizeof(buf),\"Can't bind socket: %s\",strerror(errno));\n                __redisSetError(c,REDIS_ERR_OTHER,buf);\n                goto error;\n            }\n        }\n\n        /* For repeat connection */\n        free(c->saddr);\n        c->saddr = hi_malloc(p->ai_addrlen);\n        memcpy(c->saddr, p->ai_addr, p->ai_addrlen);\n        c->addrlen = p->ai_addrlen;\n\n        if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {\n            if (errno == EHOSTUNREACH) {\n                redisNetClose(c);\n                continue;\n            } else if (errno == EINPROGRESS) {\n                if (blocking) {\n                    goto wait_for_ready;\n                }\n                /* This is ok.\n                 * Note that even when it's in blocking mode, we unset blocking\n                 * for `connect()`\n                 */\n            } else if (errno == EADDRNOTAVAIL && reuseaddr) {\n                if (++reuses >= REDIS_CONNECT_RETRIES) {\n                    goto error;\n                } else {\n                    redisNetClose(c);\n                    goto addrretry;\n                }\n            } else {\n                wait_for_ready:\n                if (redisContextWaitReady(c,timeout_msec) != REDIS_OK)\n                    goto error;\n            }\n        }\n        if (blocking && redisSetBlocking(c,1) != REDIS_OK)\n            goto error;\n        if (redisSetTcpNoDelay(c) != REDIS_OK)\n            goto error;\n\n        c->flags |= REDIS_CONNECTED;\n        rv = REDIS_OK;\n        goto end;\n    }\n    if (p == NULL) {\n        char buf[128];\n        snprintf(buf,sizeof(buf),\"Can't create socket: %s\",strerror(errno));\n        __redisSetError(c,REDIS_ERR_OTHER,buf);\n        goto error;\n    }\n\nerror:\n    rv = REDIS_ERR;\nend:\n    if(servinfo) {\n        freeaddrinfo(servinfo);\n    }\n\n    return rv;  // Need to return REDIS_OK if alright\n}",
  "abstract_func": "static int _redisContextConnectTcp(redisContext *VAR_0, const char *VAR_1, int VAR_2,\n                                   const struct timeval *VAR_3,\n                                   const char *VAR_4) {\n    redisFD VAR_5;\n    int VAR_6, VAR_7;\n    char VAR_8[6];  /* COMMENT_0 */\n    struct addrinfo VAR_9, *VAR_10, *VAR_11, *VAR_12, *VAR_13;\n    int VAR_14 = (VAR_0->flags & VAR_15);\n    int VAR_16 = (VAR_0->flags & VAR_17);\n    int VAR_18 = 0;\n    long VAR_19 = -1;\n\n    VAR_10 = NULL;\n    VAR_0->connection_type = VAR_20;\n    VAR_0->tcp.port = VAR_2;\n\n    /* COMMENT_1 */\n                                             \n                                                                 \n                                              \n      \n                                                                        \n        \n    if (VAR_0->tcp.host != VAR_1) {\n        free(VAR_0->tcp.host);\n\n        VAR_0->tcp.host = hi_strdup(VAR_1);\n    }\n\n    if (VAR_3) {\n        if (VAR_0->timeout != VAR_3) {\n            if (VAR_0->timeout == NULL)\n                VAR_0->timeout = hi_malloc(sizeof(struct timeval));\n\n            memcpy(VAR_0->timeout, VAR_3, sizeof(struct timeval));\n        }\n    } else {\n        free(VAR_0->timeout);\n        VAR_0->timeout = NULL;\n    }\n\n    if (redisContextTimeoutMsec(VAR_0, &VAR_19) != VAR_21) {\n        __redisSetError(VAR_0, VAR_22, \"Invalid timeout specified\");\n        goto error;\n    }\n\n    if (VAR_4 == NULL) {\n        free(VAR_0->tcp.source_addr);\n        VAR_0->tcp.source_addr = NULL;\n    } else if (VAR_0->tcp.source_addr != VAR_4) {\n        free(VAR_0->tcp.source_addr);\n        VAR_0->tcp.source_addr = hi_strdup(VAR_4);\n    }\n\n    snprintf(VAR_8, 6, \"%d\", VAR_2);\n    memset(&VAR_9,0,sizeof(VAR_9));\n    VAR_9.ai_family = VAR_23;\n    VAR_9.ai_socktype = VAR_24;\n\n    /* COMMENT_8 */\n                                                                               \n                                                                            \n                                                                                 \n                       \n    if ((VAR_6 = getaddrinfo(VAR_0->tcp.host,VAR_8,&VAR_9,&VAR_10)) != 0) {\n         VAR_9.ai_family = VAR_25;\n         if ((VAR_6 = getaddrinfo(VAR_1,VAR_8,&VAR_9,&VAR_10)) != 0) {\n            __redisSetError(VAR_0,VAR_26,gai_strerror(VAR_6));\n            return VAR_27;\n        }\n    }\n    for (VAR_12 = VAR_10; VAR_12 != NULL; VAR_12 = VAR_12->ai_next) {\naddrretry:\n        if ((VAR_5 = socket(VAR_12->ai_family,VAR_12->ai_socktype,VAR_12->ai_protocol)) == VAR_28)\n            continue;\n\n        VAR_0->fd = VAR_5;\n        if (redisSetBlocking(VAR_0,0) != VAR_21)\n            goto error;\n        if (VAR_0->tcp.source_addr) {\n            int VAR_29 = 0;\n            /* COMMENT_13 */\n            if ((VAR_6 = getaddrinfo(VAR_0->tcp.source_addr, NULL, &VAR_9, &VAR_11)) != 0) {\n                char VAR_30[128];\n                snprintf(VAR_30,sizeof(VAR_30),\"Can't get addr: %s\",gai_strerror(VAR_6));\n                __redisSetError(VAR_0,VAR_26,VAR_30);\n                goto error;\n            }\n\n            if (VAR_16) {\n                VAR_7 = 1;\n                if (setsockopt(VAR_5, VAR_31, VAR_32, (char*) &VAR_7,\n                               sizeof(VAR_7)) < 0) {\n                    freeaddrinfo(VAR_11);\n                    goto error;\n                }\n            }\n\n            for (VAR_13 = VAR_11; VAR_13 != NULL; VAR_13 = VAR_13->ai_next) {\n                if (bind(VAR_5,VAR_13->ai_addr,VAR_13->ai_addrlen) != -1) {\n                    VAR_29 = 1;\n                    break;\n                }\n            }\n            freeaddrinfo(VAR_11);\n            if (!VAR_29) {\n                char VAR_30[128];\n                snprintf(VAR_30,sizeof(VAR_30),\"Can't bind socket: %s\",strerror(VAR_33));\n                __redisSetError(VAR_0,VAR_26,VAR_30);\n                goto error;\n            }\n        }\n\n        /* COMMENT_14 */\n        free(VAR_0->saddr);\n        VAR_0->saddr = hi_malloc(VAR_12->ai_addrlen);\n        memcpy(VAR_0->saddr, VAR_12->ai_addr, VAR_12->ai_addrlen);\n        VAR_0->addrlen = VAR_12->ai_addrlen;\n\n        if (connect(VAR_5,VAR_12->ai_addr,VAR_12->ai_addrlen) == -1) {\n            if (VAR_33 == VAR_34) {\n                redisNetClose(VAR_0);\n                continue;\n            } else if (VAR_33 == VAR_35) {\n                if (VAR_14) {\n                    goto wait_for_ready;\n                }\n                /* COMMENT_15 */\n                                                                               \n                                  \n                   \n            } else if (VAR_33 == VAR_36 && VAR_16) {\n                if (++VAR_18 >= VAR_37) {\n                    goto error;\n                } else {\n                    redisNetClose(VAR_0);\n                    goto addrretry;\n                }\n            } else {\n                wait_for_ready:\n                if (redisContextWaitReady(VAR_0,VAR_19) != VAR_21)\n                    goto error;\n            }\n        }\n        if (VAR_14 && redisSetBlocking(VAR_0,1) != VAR_21)\n            goto error;\n        if (redisSetTcpNoDelay(VAR_0) != VAR_21)\n            goto error;\n\n        VAR_0->flags |= VAR_38;\n        VAR_6 = VAR_21;\n        goto end;\n    }\n    if (VAR_12 == NULL) {\n        char VAR_30[128];\n        snprintf(VAR_30,sizeof(VAR_30),\"Can't create socket: %s\",strerror(VAR_33));\n        __redisSetError(VAR_0,VAR_26,VAR_30);\n        goto error;\n    }\n\nerror:\n    VAR_6 = VAR_27;\nend:\n    if(VAR_10) {\n        freeaddrinfo(VAR_10);\n    }\n\n    return VAR_6;  /* COMMENT_19 */\n}",
  "func_graph_path": "redis/hiredis/70e73a31ad5edb6c457658c0a0b6752b06cc6a25/net.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,13 +24,13 @@\n     if (c->tcp.host != addr) {\n         free(c->tcp.host);\n \n-        c->tcp.host = hiredis_safe_strdup(addr);\n+        c->tcp.host = hi_strdup(addr);\n     }\n \n     if (timeout) {\n         if (c->timeout != timeout) {\n             if (c->timeout == NULL)\n-                c->timeout = hiredis_safe_malloc(sizeof(struct timeval));\n+                c->timeout = hi_malloc(sizeof(struct timeval));\n \n             memcpy(c->timeout, timeout, sizeof(struct timeval));\n         }\n@@ -49,7 +49,7 @@\n         c->tcp.source_addr = NULL;\n     } else if (c->tcp.source_addr != source_addr) {\n         free(c->tcp.source_addr);\n-        c->tcp.source_addr = hiredis_safe_strdup(source_addr);\n+        c->tcp.source_addr = hi_strdup(source_addr);\n     }\n \n     snprintf(_port, 6, \"%d\", port);\n@@ -113,7 +113,7 @@\n \n         /* For repeat connection */\n         free(c->saddr);\n-        c->saddr = hiredis_safe_malloc(p->ai_addrlen);\n+        c->saddr = hi_malloc(p->ai_addrlen);\n         memcpy(c->saddr, p->ai_addr, p->ai_addrlen);\n         c->addrlen = p->ai_addrlen;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        c->tcp.host = hiredis_safe_strdup(addr);",
      "                c->timeout = hiredis_safe_malloc(sizeof(struct timeval));",
      "        c->tcp.source_addr = hiredis_safe_strdup(source_addr);",
      "        c->saddr = hiredis_safe_malloc(p->ai_addrlen);"
    ],
    "added_lines": [
      "        c->tcp.host = hi_strdup(addr);",
      "                c->timeout = hi_malloc(sizeof(struct timeval));",
      "        c->tcp.source_addr = hi_strdup(source_addr);",
      "        c->saddr = hi_malloc(p->ai_addrlen);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/hiredis/pull/754",
  "description": {
    "pr_info": {
      "title": "Safe allocation wrappers",
      "number": 754
    },
    "comment": [
      "Adds allocation wrappers that invokes a defined OOM handler.\r\n\r\nMy goal was the smallest surface area of changes possible.  Once we merge this it might be prudent to replace every `malloc`/`free` call with our wrappers.",
      "Just quoting the [last parts of the conversation in a merged PR](https://github.com/redis/hiredis/pull/752#issuecomment-577429138) from @michael-grunder \r\n\r\n>  @lamby I totally understand not wanting such a huge change just for a patch.\r\n\r\nThanks... and I think the changes in this PR would work for me. :+1: ",
      "Would be great to get some more eyes on this. :)",
      "> are we using asprintf and friends anywhere?\r\n\r\nNo, but `sds` has something similar (e.g. [sdscatfmt](https://github.com/redis/hiredis/blob/0501c623c91344e54cb2775a91509650960789b1/sds.c#L582)) although it appears that we're testing for NULL after every allocation/reallocation. \r\n\r\n",
      "Merged, thanks everyone!"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Supporting & Non-Core Improvements; **Confidence:** 0.95"
}