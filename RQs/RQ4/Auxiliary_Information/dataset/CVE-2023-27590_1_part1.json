{
  "cve_id": "CVE-2023-27590",
  "cwe_ids": [
    "CWE-120",
    "CWE-121"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "rizinorg/rizin",
  "commit_msg": "Fix conversion from GDB register profile to rizin profile",
  "commit_hash": "d6196703d89c84467b600ba2692534579dc25ed4",
  "git_url": "https://github.com/rizinorg/rizin/commit/d6196703d89c84467b600ba2692534579dc25ed4",
  "file_path": "librz/debug/p/debug_gdb.c",
  "func_name": "rz_debug_gdb_map_get",
  "func_before": "static RzList /*<RzDebugMap *>*/ *rz_debug_gdb_map_get(RzDebug *dbg) { // TODO\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc || ctx->desc->pid <= 0) {\n\t\treturn NULL;\n\t}\n\tRzList *retlist = NULL;\n\tif (ctx->desc->get_baddr) {\n\t\tctx->desc->get_baddr = false;\n\t\tut64 baddr;\n\t\tif ((baddr = gdbr_get_baddr(ctx->desc)) != UINT64_MAX) {\n\t\t\tif (!(retlist = rz_list_new())) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRzDebugMap *map;\n\t\t\tif (!(map = rz_debug_map_new(\"\", baddr, baddr, RZ_PERM_RX, 0))) {\n\t\t\t\trz_list_free(retlist);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trz_list_append(retlist, map);\n\t\t\treturn retlist;\n\t\t}\n\t}\n\n\t// Get file from GDB\n\tchar path[128];\n\tut8 *buf;\n\tint ret;\n\t// TODO don't hardcode buffer size, get from remote target\n\t// (I think gdb doesn't do that, it just keeps reading till EOF)\n\t// fstat info can get file size, but it doesn't work for /proc/pid/maps\n\tut64 buflen = 16384;\n\t// If /proc/%d/maps is not valid for gdbserver, we return NULL, as of now\n\tsnprintf(path, sizeof(path) - 1, \"/proc/%d/maps\", ctx->desc->pid);\n\n#ifdef _MSC_VER\n#define GDB_FILE_OPEN_MODE (_S_IREAD | _S_IWRITE)\n#else\n#define GDB_FILE_OPEN_MODE (S_IRUSR | S_IWUSR | S_IXUSR)\n#endif\n\n\tif (gdbr_open_file(ctx->desc, path, O_RDONLY, GDB_FILE_OPEN_MODE) < 0) {\n\t\treturn NULL;\n\t}\n\tif (!(buf = malloc(buflen))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\treturn NULL;\n\t}\n\tif ((ret = gdbr_read_file(ctx->desc, buf, buflen - 1)) <= 0) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tbuf[ret] = '\\0';\n\n\t// Get map list\n\tint unk = 0, perm, i;\n\tchar *ptr, *pos_1;\n\tsize_t line_len;\n\tchar name[1024], region1[100], region2[100], perms[5];\n\tRzDebugMap *map = NULL;\n\tregion1[0] = region2[0] = '0';\n\tregion1[1] = region2[1] = 'x';\n\tif (!(ptr = strtok((char *)buf, \"\\n\"))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (!(retlist = rz_list_new())) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\twhile (ptr) {\n\t\tut64 map_start, map_end, offset;\n\t\tbool map_is_shared = false;\n\t\tline_len = strlen(ptr);\n\t\t// maps files should not have empty lines\n\t\tif (line_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// We assume Linux target, for now, so -\n\t\t// 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n\t\tret = sscanf(ptr, \"%s %s %\" PFMT64x \" %*s %*s %[^\\n]\", &region1[2],\n\t\t\tperms, &offset, name);\n\t\tif (ret == 3) {\n\t\t\tname[0] = '\\0';\n\t\t} else if (ret != 4) {\n\t\t\teprintf(\"%s: Unable to parse \\\"%s\\\"\\nContent:\\n%s\\n\",\n\t\t\t\t__func__, path, buf);\n\t\t\tgdbr_close_file(ctx->desc);\n\t\t\tfree(buf);\n\t\t\trz_list_free(retlist);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(pos_1 = strchr(&region1[2], '-'))) {\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrncpy(&region2[2], pos_1 + 1, sizeof(region2) - 2 - 1);\n\t\tif (!*name) {\n\t\t\tsnprintf(name, sizeof(name), \"unk%d\", unk++);\n\t\t}\n\t\tperm = 0;\n\t\tfor (i = 0; i < 5 && perms[i]; i++) {\n\t\t\tswitch (perms[i]) {\n\t\t\tcase 'r': perm |= RZ_PERM_R; break;\n\t\t\tcase 'w': perm |= RZ_PERM_W; break;\n\t\t\tcase 'x': perm |= RZ_PERM_X; break;\n\t\t\tcase 'p': map_is_shared = false; break;\n\t\t\tcase 's': map_is_shared = true; break;\n\t\t\t}\n\t\t}\n\t\tmap_start = rz_num_get(NULL, region1);\n\t\tmap_end = rz_num_get(NULL, region2);\n\t\tif (map_start == map_end || map_end == 0) {\n\t\t\teprintf(\"%s: ignoring invalid map size: %s - %s\\n\",\n\t\t\t\t__func__, region1, region2);\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(map = rz_debug_map_new(name, map_start, map_end, perm, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tmap->offset = offset;\n\t\tmap->shared = map_is_shared;\n\t\tmap->file = strdup(name);\n\t\trz_list_append(retlist, map);\n\t\tptr = strtok(NULL, \"\\n\");\n\t}\n\tgdbr_close_file(ctx->desc);\n\tfree(buf);\n\treturn retlist;\n}",
  "abstract_func_before": "static RzList /* COMMENT_0 */ *rz_debug_gdb_map_get(RzDebug *VAR_0) { /* COMMENT_1 */\n\tRzDebugGdbCtx *VAR_1 = VAR_0->plugin_data;\n\tcheck_connection(VAR_0);\n\tif (!VAR_1->desc || VAR_1->desc->pid <= 0) {\n\t\treturn NULL;\n\t}\n\tRzList *VAR_2 = NULL;\n\tif (VAR_1->desc->get_baddr) {\n\t\tVAR_1->desc->get_baddr = false;\n\t\tut64 VAR_3;\n\t\tif ((VAR_3 = gdbr_get_baddr(VAR_1->desc)) != VAR_4) {\n\t\t\tif (!(VAR_2 = rz_list_new())) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRzDebugMap *VAR_5;\n\t\t\tif (!(VAR_5 = rz_debug_map_new(\"\", VAR_3, VAR_3, VAR_6, 0))) {\n\t\t\t\trz_list_free(VAR_2);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trz_list_append(VAR_2, VAR_5);\n\t\t\treturn VAR_2;\n\t\t}\n\t}\n\n\t/* COMMENT_2 */\n\tchar VAR_7[128];\n\tut8 *VAR_8;\n\tint VAR_9;\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n\tut64 VAR_10 = 16384;\n\t/* COMMENT_6 */\n\tsnprintf(VAR_7, sizeof(VAR_7) - 1, \"/proc/%d/maps\", VAR_1->desc->pid);\n\n#ifdef VAR_11\n#define VAR_12 (_S_IREAD | _S_IWRITE)\n#else\n#define VAR_12 (S_IRUSR | S_IWUSR | S_IXUSR)\n#endif\n\n\tif (gdbr_open_file(VAR_1->desc, VAR_7, VAR_13, VAR_12) < 0) {\n\t\treturn NULL;\n\t}\n\tif (!(VAR_8 = malloc(VAR_10))) {\n\t\tgdbr_close_file(VAR_1->desc);\n\t\treturn NULL;\n\t}\n\tif ((VAR_9 = gdbr_read_file(VAR_1->desc, VAR_8, VAR_10 - 1)) <= 0) {\n\t\tgdbr_close_file(VAR_1->desc);\n\t\tfree(VAR_8);\n\t\treturn NULL;\n\t}\n\tVAR_8[VAR_9] = '\\0';\n\n\t/* COMMENT_7 */\n\tint VAR_14 = 0, VAR_15, VAR_16;\n\tchar *VAR_17, *VAR_18;\n\tsize_t VAR_19;\n\tchar VAR_20[1024], VAR_21[100], VAR_22[100], VAR_23[5];\n\tRzDebugMap *VAR_5 = NULL;\n\tVAR_21[0] = VAR_22[0] = '0';\n\tVAR_21[1] = VAR_22[1] = 'x';\n\tif (!(VAR_17 = strtok((char *)VAR_8, \"\\n\"))) {\n\t\tgdbr_close_file(VAR_1->desc);\n\t\tfree(VAR_8);\n\t\treturn NULL;\n\t}\n\tif (!(VAR_2 = rz_list_new())) {\n\t\tgdbr_close_file(VAR_1->desc);\n\t\tfree(VAR_8);\n\t\treturn NULL;\n\t}\n\twhile (VAR_17) {\n\t\tut64 VAR_24, VAR_25, VAR_26;\n\t\tbool VAR_27 = false;\n\t\tVAR_19 = strlen(VAR_17);\n\t\t/* COMMENT_8 */\n\t\tif (VAR_19 == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t/* COMMENT_9 */\n\t\t/* COMMENT_10 */\n\t\tVAR_9 = sscanf(VAR_17, \"%s %s %\" VAR_28 \" %*s %*s %[^\\n]\", &VAR_21[2],\n\t\t\tVAR_23, &VAR_26, VAR_20);\n\t\tif (VAR_9 == 3) {\n\t\t\tVAR_20[0] = '\\0';\n\t\t} else if (VAR_9 != 4) {\n\t\t\teprintf(\"%s: Unable to parse \\\"%s\\\"\\nContent:\\n%s\\n\",\n\t\t\t\tVAR_29, VAR_7, VAR_8);\n\t\t\tgdbr_close_file(VAR_1->desc);\n\t\t\tfree(VAR_8);\n\t\t\trz_list_free(VAR_2);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(VAR_18 = strchr(&VAR_21[2], '-'))) {\n\t\t\tVAR_17 = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrncpy(&VAR_22[2], VAR_18 + 1, sizeof(VAR_22) - 2 - 1);\n\t\tif (!*VAR_20) {\n\t\t\tsnprintf(VAR_20, sizeof(VAR_20), \"unk%d\", VAR_14++);\n\t\t}\n\t\tVAR_15 = 0;\n\t\tfor (VAR_16 = 0; VAR_16 < 5 && VAR_23[VAR_16]; VAR_16++) {\n\t\t\tswitch (VAR_23[VAR_16]) {\n\t\t\tcase 'r': VAR_15 |= VAR_30; break;\n\t\t\tcase 'w': VAR_15 |= VAR_31; break;\n\t\t\tcase 'x': VAR_15 |= VAR_32; break;\n\t\t\tcase 'p': VAR_27 = false; break;\n\t\t\tcase 's': VAR_27 = true; break;\n\t\t\t}\n\t\t}\n\t\tVAR_24 = rz_num_get(NULL, VAR_21);\n\t\tVAR_25 = rz_num_get(NULL, VAR_22);\n\t\tif (VAR_24 == VAR_25 || VAR_25 == 0) {\n\t\t\teprintf(\"%s: ignoring invalid map size: %s - %s\\n\",\n\t\t\t\tVAR_29, VAR_21, VAR_22);\n\t\t\tVAR_17 = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(VAR_5 = rz_debug_map_new(VAR_20, VAR_24, VAR_25, VAR_15, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_5->offset = VAR_26;\n\t\tVAR_5->shared = VAR_27;\n\t\tVAR_5->file = strdup(VAR_20);\n\t\trz_list_append(VAR_2, VAR_5);\n\t\tVAR_17 = strtok(NULL, \"\\n\");\n\t}\n\tgdbr_close_file(VAR_1->desc);\n\tfree(VAR_8);\n\treturn VAR_2;\n}",
  "func_graph_path_before": "rizinorg/rizin/d6196703d89c84467b600ba2692534579dc25ed4/debug_gdb.c/vul/before/0.json",
  "func": "static RzList /*<RzDebugMap *>*/ *rz_debug_gdb_map_get(RzDebug *dbg) { // TODO\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc || ctx->desc->pid <= 0) {\n\t\treturn NULL;\n\t}\n\tRzList *retlist = NULL;\n\tif (ctx->desc->get_baddr) {\n\t\tctx->desc->get_baddr = false;\n\t\tut64 baddr;\n\t\tif ((baddr = gdbr_get_baddr(ctx->desc)) != UINT64_MAX) {\n\t\t\tif (!(retlist = rz_list_new())) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRzDebugMap *map;\n\t\t\tif (!(map = rz_debug_map_new(\"\", baddr, baddr, RZ_PERM_RX, 0))) {\n\t\t\t\trz_list_free(retlist);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trz_list_append(retlist, map);\n\t\t\treturn retlist;\n\t\t}\n\t}\n\n\t// Get file from GDB\n\tchar path[128];\n\tut8 *buf;\n\tint ret;\n\t// TODO don't hardcode buffer size, get from remote target\n\t// (I think gdb doesn't do that, it just keeps reading till EOF)\n\t// fstat info can get file size, but it doesn't work for /proc/pid/maps\n\tut64 buflen = 16384;\n\t// If /proc/%d/maps is not valid for gdbserver, we return NULL, as of now\n\tsnprintf(path, sizeof(path) - 1, \"/proc/%d/maps\", ctx->desc->pid);\n\n#ifdef _MSC_VER\n#define GDB_FILE_OPEN_MODE (_S_IREAD | _S_IWRITE)\n#else\n#define GDB_FILE_OPEN_MODE (S_IRUSR | S_IWUSR | S_IXUSR)\n#endif\n\n\tif (gdbr_open_file(ctx->desc, path, O_RDONLY, GDB_FILE_OPEN_MODE) < 0) {\n\t\treturn NULL;\n\t}\n\tif (!(buf = malloc(buflen))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\treturn NULL;\n\t}\n\tif ((ret = gdbr_read_file(ctx->desc, buf, buflen - 1)) <= 0) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tbuf[ret] = '\\0';\n\n\t// Get map list\n\tint unk = 0, perm, i;\n\tchar *ptr, *pos_1;\n\tsize_t line_len;\n\tchar name[PROC_NAME_SZ + 1], region1[PROC_REGION_SZ + 1], region2[PROC_REGION_SZ + 1], perms[PROC_PERM_SZ + 1];\n\tRzDebugMap *map = NULL;\n\tregion1[0] = region2[0] = '0';\n\tregion1[1] = region2[1] = 'x';\n\tif (!(ptr = strtok((char *)buf, \"\\n\"))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (!(retlist = rz_list_new())) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\twhile (ptr) {\n\t\tut64 map_start, map_end, offset;\n\t\tbool map_is_shared = false;\n\t\tline_len = strlen(ptr);\n\t\t// maps files should not have empty lines\n\t\tif (line_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// We assume Linux target, for now, so -\n\t\t// 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n\t\tret = sscanf(ptr, \"%\" RZ_STR_DEF(PROC_REGION_LEFT_SZ) \"s %\" RZ_STR_DEF(PROC_PERM_SZ) \"s %\" PFMT64x \" %*s %*s %\" RZ_STR_DEF(PROC_NAME_SZ) \"[^\\n]\",\n\t\t\t&region1[2], perms, &offset, name);\n\t\tif (ret == 3) {\n\t\t\tname[0] = '\\0';\n\t\t} else if (ret != 4) {\n\t\t\teprintf(\"%s: Unable to parse \\\"%s\\\"\\nContent:\\n%s\\n\",\n\t\t\t\t__func__, path, buf);\n\t\t\tgdbr_close_file(ctx->desc);\n\t\t\tfree(buf);\n\t\t\trz_list_free(retlist);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(pos_1 = strchr(&region1[2], '-'))) {\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrncpy(&region2[2], pos_1 + 1, sizeof(region2) - 2 - 1);\n\t\tif (!*name) {\n\t\t\tsnprintf(name, sizeof(name), \"unk%d\", unk++);\n\t\t}\n\t\tperm = 0;\n\t\tfor (i = 0; i < 5 && perms[i]; i++) {\n\t\t\tswitch (perms[i]) {\n\t\t\tcase 'r': perm |= RZ_PERM_R; break;\n\t\t\tcase 'w': perm |= RZ_PERM_W; break;\n\t\t\tcase 'x': perm |= RZ_PERM_X; break;\n\t\t\tcase 'p': map_is_shared = false; break;\n\t\t\tcase 's': map_is_shared = true; break;\n\t\t\t}\n\t\t}\n\t\tmap_start = rz_num_get(NULL, region1);\n\t\tmap_end = rz_num_get(NULL, region2);\n\t\tif (map_start == map_end || map_end == 0) {\n\t\t\teprintf(\"%s: ignoring invalid map size: %s - %s\\n\",\n\t\t\t\t__func__, region1, region2);\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(map = rz_debug_map_new(name, map_start, map_end, perm, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tmap->offset = offset;\n\t\tmap->shared = map_is_shared;\n\t\tmap->file = strdup(name);\n\t\trz_list_append(retlist, map);\n\t\tptr = strtok(NULL, \"\\n\");\n\t}\n\tgdbr_close_file(ctx->desc);\n\tfree(buf);\n\treturn retlist;\n}",
  "abstract_func": "static RzList /* COMMENT_0 */ *rz_debug_gdb_map_get(RzDebug *VAR_0) { /* COMMENT_1 */\n\tRzDebugGdbCtx *VAR_1 = VAR_0->plugin_data;\n\tcheck_connection(VAR_0);\n\tif (!VAR_1->desc || VAR_1->desc->pid <= 0) {\n\t\treturn NULL;\n\t}\n\tRzList *VAR_2 = NULL;\n\tif (VAR_1->desc->get_baddr) {\n\t\tVAR_1->desc->get_baddr = false;\n\t\tut64 VAR_3;\n\t\tif ((VAR_3 = gdbr_get_baddr(VAR_1->desc)) != VAR_4) {\n\t\t\tif (!(VAR_2 = rz_list_new())) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRzDebugMap *VAR_5;\n\t\t\tif (!(VAR_5 = rz_debug_map_new(\"\", VAR_3, VAR_3, VAR_6, 0))) {\n\t\t\t\trz_list_free(VAR_2);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trz_list_append(VAR_2, VAR_5);\n\t\t\treturn VAR_2;\n\t\t}\n\t}\n\n\t/* COMMENT_2 */\n\tchar VAR_7[128];\n\tut8 *VAR_8;\n\tint VAR_9;\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n\tut64 VAR_10 = 16384;\n\t/* COMMENT_6 */\n\tsnprintf(VAR_7, sizeof(VAR_7) - 1, \"/proc/%d/maps\", VAR_1->desc->pid);\n\n#ifdef VAR_11\n#define VAR_12 (_S_IREAD | _S_IWRITE)\n#else\n#define VAR_12 (S_IRUSR | S_IWUSR | S_IXUSR)\n#endif\n\n\tif (gdbr_open_file(VAR_1->desc, VAR_7, VAR_13, VAR_12) < 0) {\n\t\treturn NULL;\n\t}\n\tif (!(VAR_8 = malloc(VAR_10))) {\n\t\tgdbr_close_file(VAR_1->desc);\n\t\treturn NULL;\n\t}\n\tif ((VAR_9 = gdbr_read_file(VAR_1->desc, VAR_8, VAR_10 - 1)) <= 0) {\n\t\tgdbr_close_file(VAR_1->desc);\n\t\tfree(VAR_8);\n\t\treturn NULL;\n\t}\n\tVAR_8[VAR_9] = '\\0';\n\n\t/* COMMENT_7 */\n\tint VAR_14 = 0, VAR_15, VAR_16;\n\tchar *VAR_17, *VAR_18;\n\tsize_t VAR_19;\n\tchar VAR_20[VAR_21 + 1], VAR_22[VAR_23 + 1], VAR_24[VAR_23 + 1], VAR_25[VAR_26 + 1];\n\tRzDebugMap *VAR_5 = NULL;\n\tVAR_22[0] = VAR_24[0] = '0';\n\tVAR_22[1] = VAR_24[1] = 'x';\n\tif (!(VAR_17 = strtok((char *)VAR_8, \"\\n\"))) {\n\t\tgdbr_close_file(VAR_1->desc);\n\t\tfree(VAR_8);\n\t\treturn NULL;\n\t}\n\tif (!(VAR_2 = rz_list_new())) {\n\t\tgdbr_close_file(VAR_1->desc);\n\t\tfree(VAR_8);\n\t\treturn NULL;\n\t}\n\twhile (VAR_17) {\n\t\tut64 VAR_27, VAR_28, VAR_29;\n\t\tbool VAR_30 = false;\n\t\tVAR_19 = strlen(VAR_17);\n\t\t/* COMMENT_8 */\n\t\tif (VAR_19 == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t/* COMMENT_9 */\n\t\t/* COMMENT_10 */\n\t\tVAR_9 = sscanf(VAR_17, \"%\" RZ_STR_DEF(VAR_31) \"VAR_32 %\" RZ_STR_DEF(PROC_PERM_SZ) \"VAR_32 %\" PFMT64x \" %*VAR_32 %*VAR_32 %\" RZ_STR_DEF(PROC_NAME_SZ) \"[^\\n]\",\n\t\t\t&VAR_22[2], VAR_25, &VAR_29, VAR_20);\n\t\tif (VAR_9 == 3) {\n\t\t\tVAR_20[0] = '\\0';\n\t\t} else if (VAR_9 != 4) {\n\t\t\teprintf(\"%s: Unable to parse \\\"%s\\\"\\nContent:\\n%s\\n\",\n\t\t\t\tVAR_33, VAR_7, VAR_8);\n\t\t\tgdbr_close_file(VAR_1->desc);\n\t\t\tfree(VAR_8);\n\t\t\trz_list_free(VAR_2);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(VAR_18 = strchr(&VAR_22[2], '-'))) {\n\t\t\tVAR_17 = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrncpy(&VAR_24[2], VAR_18 + 1, sizeof(VAR_24) - 2 - 1);\n\t\tif (!*VAR_20) {\n\t\t\tsnprintf(VAR_20, sizeof(VAR_20), \"unk%d\", VAR_14++);\n\t\t}\n\t\tVAR_15 = 0;\n\t\tfor (VAR_16 = 0; VAR_16 < 5 && VAR_25[VAR_16]; VAR_16++) {\n\t\t\tswitch (VAR_25[VAR_16]) {\n\t\t\tcase 'r': VAR_15 |= VAR_34; break;\n\t\t\tcase 'w': VAR_15 |= VAR_35; break;\n\t\t\tcase 'x': VAR_15 |= VAR_36; break;\n\t\t\tcase 'p': VAR_30 = false; break;\n\t\t\tcase 's': VAR_30 = true; break;\n\t\t\t}\n\t\t}\n\t\tVAR_27 = rz_num_get(NULL, VAR_22);\n\t\tVAR_28 = rz_num_get(NULL, VAR_24);\n\t\tif (VAR_27 == VAR_28 || VAR_28 == 0) {\n\t\t\teprintf(\"%s: ignoring invalid map size: %s - %s\\n\",\n\t\t\t\tVAR_33, VAR_22, VAR_24);\n\t\t\tVAR_17 = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(VAR_5 = rz_debug_map_new(VAR_20, VAR_27, VAR_28, VAR_15, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_5->offset = VAR_29;\n\t\tVAR_5->shared = VAR_30;\n\t\tVAR_5->file = strdup(VAR_20);\n\t\trz_list_append(VAR_2, VAR_5);\n\t\tVAR_17 = strtok(NULL, \"\\n\");\n\t}\n\tgdbr_close_file(VAR_1->desc);\n\tfree(VAR_8);\n\treturn VAR_2;\n}",
  "func_graph_path": "rizinorg/rizin/d6196703d89c84467b600ba2692534579dc25ed4/debug_gdb.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -57,7 +57,7 @@\n \tint unk = 0, perm, i;\n \tchar *ptr, *pos_1;\n \tsize_t line_len;\n-\tchar name[1024], region1[100], region2[100], perms[5];\n+\tchar name[PROC_NAME_SZ + 1], region1[PROC_REGION_SZ + 1], region2[PROC_REGION_SZ + 1], perms[PROC_PERM_SZ + 1];\n \tRzDebugMap *map = NULL;\n \tregion1[0] = region2[0] = '0';\n \tregion1[1] = region2[1] = 'x';\n@@ -81,8 +81,8 @@\n \t\t}\n \t\t// We assume Linux target, for now, so -\n \t\t// 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n-\t\tret = sscanf(ptr, \"%s %s %\" PFMT64x \" %*s %*s %[^\\n]\", &region1[2],\n-\t\t\tperms, &offset, name);\n+\t\tret = sscanf(ptr, \"%\" RZ_STR_DEF(PROC_REGION_LEFT_SZ) \"s %\" RZ_STR_DEF(PROC_PERM_SZ) \"s %\" PFMT64x \" %*s %*s %\" RZ_STR_DEF(PROC_NAME_SZ) \"[^\\n]\",\n+\t\t\t&region1[2], perms, &offset, name);\n \t\tif (ret == 3) {\n \t\t\tname[0] = '\\0';\n \t\t} else if (ret != 4) {",
  "diff_line_info": {
    "deleted_lines": [
      "\tchar name[1024], region1[100], region2[100], perms[5];",
      "\t\tret = sscanf(ptr, \"%s %s %\" PFMT64x \" %*s %*s %[^\\n]\", &region1[2],",
      "\t\t\tperms, &offset, name);"
    ],
    "added_lines": [
      "\tchar name[PROC_NAME_SZ + 1], region1[PROC_REGION_SZ + 1], region2[PROC_REGION_SZ + 1], perms[PROC_PERM_SZ + 1];",
      "\t\tret = sscanf(ptr, \"%\" RZ_STR_DEF(PROC_REGION_LEFT_SZ) \"s %\" RZ_STR_DEF(PROC_PERM_SZ) \"s %\" PFMT64x \" %*s %*s %\" RZ_STR_DEF(PROC_NAME_SZ) \"[^\\n]\",",
      "\t\t\t&region1[2], perms, &offset, name);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rizinorg/rizin/pull/3422",
  "description": {
    "pr_info": {
      "title": "Fix conversion from GDB register profile to rizin profile",
      "number": 3422
    },
    "comment": [
      " <!-- Filling this template is mandatory -->\r\n\r\n**Your checklist for this pull request**\r\n- [x] I've read the [guidelines for contributing](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md) to this repository\r\n- [x] I made sure to follow the project's [coding style](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md#code-style)\r\n- [ ] I've documented or updated the documentation of every function and struct this PR changes. If not so I've explained why.\r\n- [ ] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the [rizin book](https://github.com/rizinorg/book) with the relevant information (if needed)\r\n\r\n**Detailed description**\r\n\r\n<!-- Explain the **details** for making this change. Is a new feature implemented? What existing problem does the pull request solve? How does the pull request solve these issues? Please provide enough information so that others can review your pull request. -->\r\n\r\n`scanf(\"%s\")` uses are not safe, limit the number of characters read.\r\n\r\n**Test plan**\r\n\r\n<!-- What steps should the reviewer take to test your pull request? Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots/videos. This is your time to re-check that everything works and that you covered all the edge cases -->\r\n\r\n...\r\n\r\n**Closing issues**\r\n\r\n<!-- put \"closes #XXXX\" in your comment to auto-close the issue that your PR fixes (if any). -->\r\n\r\n...\r\n",
      "```\r\nTranslation unit diagnostic at <rizin/librz/debug/p/debug_gdb.c:221:4>: 'sscanf' may overflow; destination buffer in argument 3 has size 99, but the corresponding specifier may require size 101\r\n```"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}