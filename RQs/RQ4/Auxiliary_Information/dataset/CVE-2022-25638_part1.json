{
  "cve_id": "CVE-2022-25638",
  "cwe_ids": [
    "CWE-295"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssl",
  "commit_msg": "Add checking to make sure key is present in all cases. Explicitly set `validSigAlgo` to zero with comment to clarify the default assumption.",
  "commit_hash": "08047b2d959ee5e21a4a2c672308f45fec61f059",
  "git_url": "https://github.com/wolfSSL/wolfssl/commit/08047b2d959ee5e21a4a2c672308f45fec61f059",
  "file_path": "src/tls13.c",
  "func_name": "DoTls13CertificateVerify",
  "func_before": "static int DoTls13CertificateVerify(WOLFSSL* ssl, byte* input,\n                                    word32* inOutIdx, word32 totalSz)\n{\n    int         ret = 0;\n    buffer*     sig = &ssl->buffers.sig;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dcv13Args* args = (Dcv13Args*)ssl->async.args;\n    typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ret = 0;\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dcv13Args));\n        args->hashAlgo = sha_mac;\n        args->sigAlgo = anonymous_sa_algo;\n        args->idx = *inOutIdx;\n        args->begin = *inOutIdx;\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        ssl->async.freeArgs = FreeDcv13Args;\n    #endif\n    }\n\n    switch(ssl->options.asyncState)\n    {\n        case TLS_ASYNC_BEGIN:\n        {\n        #ifdef WOLFSSL_CALLBACKS\n            if (ssl->hsInfoOn) AddPacketName(ssl, \"CertificateVerify\");\n            if (ssl->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &ssl->timeoutInfo);\n        #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_BUILD;\n        } /* case TLS_ASYNC_BEGIN */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_BUILD:\n        {\n            int validSigAlgo = 0;\n\n            /* Signature algorithm. */\n            if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ret = DecodeTls13SigAlg(input + args->idx, &args->hashAlgo,\n                                                                &args->sigAlgo);\n            if (ret < 0)\n                goto exit_dcv;\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature length. */\n            if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ato16(input + args->idx, &args->sz);\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature data. */\n            if ((args->idx - args->begin) + args->sz > totalSz ||\n                                                       args->sz > ENCRYPT_LEN) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n\n            /* Check for public key of required type. */\n        #ifdef HAVE_ED25519\n            if (args->sigAlgo == ed25519_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n                validSigAlgo = ssl->peerEd25519KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (args->sigAlgo == ed448_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig\");\n                validSigAlgo = ssl->peerEd448KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ECC\n            if (args->sigAlgo == ecc_dsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ECC sig\");\n                validSigAlgo = ssl->peerEccDsaKeyPresent;\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (args->sigAlgo == falcon_level1_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n                validSigAlgo = ssl->peerFalconKeyPresent;\n            }\n            if (args->sigAlgo == falcon_level5_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n                validSigAlgo = ssl->peerFalconKeyPresent;\n            }\n        #endif\n\n        #ifndef NO_RSA\n            if (args->sigAlgo == rsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n            }\n            if (args->sigAlgo == rsa_pss_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent RSA sig\");\n                validSigAlgo = (ssl->peerRsaKey != NULL) &&\n                                                         ssl->peerRsaKeyPresent;\n            }\n        #endif\n            if (!validSigAlgo) {\n                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n\n            sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                         DYNAMIC_TYPE_SIGNATURE);\n            if (sig->buffer == NULL) {\n                ERROR_OUT(MEMORY_E, exit_dcv);\n            }\n            sig->length = args->sz;\n            XMEMCPY(sig->buffer, input + args->idx, args->sz);\n\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                ret = CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                if (ret != 0)\n                    goto exit_dcv;\n                ret = CreateECCEncodedSig(args->sigData,\n                    args->sigDataSz, args->hashAlgo);\n                if (ret < 0)\n                    goto exit_dcv;\n                args->sigDataSz = (word16)ret;\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n       #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_DO;\n        } /* case TLS_ASYNC_BUILD */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_DO:\n        {\n        #ifndef NO_RSA\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = RsaVerify(ssl, sig->buffer, (word32)sig->length, &args->output,\n                    args->sigAlgo, args->hashAlgo, ssl->peerRsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (ret >= 0) {\n                    args->sendSz = ret;\n                    ret = 0;\n                }\n            }\n        #endif /* !NO_RSA */\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                ret = EccVerify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEccDsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);\n                    ssl->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                ret = Ed25519Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd25519Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED25519,\n                                                  (void**)&ssl->peerEd25519Key);\n                    ssl->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                ret = Ed448Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd448Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED448,\n                                                    (void**)&ssl->peerEd448Key);\n                    ssl->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                int res = 0;\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n                ret = wc_falcon_verify_msg(input + args->idx, args->sz,\n                                    args->sigData, args->sigDataSz,\n                                    &res, ssl->peerFalconKey);\n\n                if ((ret >= 0) && (res == 1)) {\n                    FreeKey(ssl, DYNAMIC_TYPE_FALCON,\n                                                   (void**)&ssl->peerFalconKey);\n                    ssl->peerFalconKeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* Check for error */\n            if (ret != 0) {\n                goto exit_dcv;\n            }\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_VERIFY;\n        } /* case TLS_ASYNC_DO */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_VERIFY:\n        {\n        #if !defined(NO_RSA) && defined(WC_RSA_PSS)\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = CheckRSASignature(ssl, args->sigAlgo, args->hashAlgo,\n                                        args->output, args->sendSz);\n                if (ret != 0)\n                    goto exit_dcv;\n\n                FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);\n                ssl->peerRsaKeyPresent = 0;\n            }\n        #endif /* !NO_RSA && WC_RSA_PSS */\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n        } /* case TLS_ASYNC_VERIFY */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_FINALIZE:\n        {\n            ssl->options.havePeerVerify = 1;\n\n            /* Set final index */\n            args->idx += args->sz;\n            *inOutIdx = args->idx;\n\n            /* Encryption is always on: add padding */\n            *inOutIdx += ssl->keys.padSz;\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_END;\n\n        #if !defined(NO_WOLFSSL_CLIENT)\n            if (ssl->options.side == WOLFSSL_CLIENT_END)\n                ssl->options.serverState = SERVER_CERT_VERIFY_COMPLETE;\n        #endif\n        } /* case TLS_ASYNC_FINALIZE */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_END:\n        {\n            break;\n        }\n\n        default:\n            ret = INPUT_CASE_ERROR;\n    } /* switch(ssl->options.asyncState) */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", ret);\n    WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}",
  "abstract_func_before": "static int DoTls13CertificateVerify(WOLFSSL* VAR_0, byte* VAR_1,\n                                    word32* VAR_2, word32 VAR_3)\n{\n    int         VAR_4 = 0;\n    buffer*     VAR_5 = &VAR_0->buffers.sig;\n#ifdef VAR_6\n    Dcv13Args* VAR_7 = (Dcv13Args*)VAR_0->async.args;\n    typedef char args_test[sizeof(VAR_0->async.args) >= sizeof(*VAR_7) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  VAR_7[1];\n#endif\n\n    WOLFSSL_START(VAR_8);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef VAR_6\n    VAR_4 = wolfSSL_AsyncPop(VAR_0, &VAR_0->options.asyncState);\n    if (VAR_4 != VAR_9) {\n        /* COMMENT_0 */\n        if (VAR_4 < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* COMMENT_1 */\n        VAR_4 = 0;\n        VAR_0->options.asyncState = VAR_10;\n        XMEMSET(VAR_7, 0, sizeof(Dcv13Args));\n        VAR_7->hashAlgo = VAR_11;\n        VAR_7->sigAlgo = VAR_12;\n        VAR_7->idx = *VAR_2;\n        VAR_7->begin = *VAR_2;\n    #ifdef VAR_6\n        VAR_0->async.freeArgs = VAR_13;\n    #endif\n    }\n\n    switch(VAR_0->options.asyncState)\n    {\n        case VAR_10:\n        {\n        #ifdef VAR_14\n            if (VAR_0->hsInfoOn) AddPacketName(VAR_0, \"CertificateVerify\");\n            if (VAR_0->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &VAR_0->timeoutInfo);\n        #endif\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_15;\n        } /* COMMENT_3 */\n        VAR_16;\n\n        case VAR_15:\n        {\n            int VAR_17 = 0;\n\n            /* COMMENT_4 */\n            if ((VAR_7->idx - VAR_7->begin) + VAR_18 + VAR_18 > VAR_3) {\n                ERROR_OUT(VAR_19, VAR_20);\n            }\n            VAR_4 = DecodeTls13SigAlg(VAR_1 + VAR_7->idx, &VAR_7->hashAlgo,\n                                                                &VAR_7->sigAlgo);\n            if (VAR_4 < 0)\n                goto exit_dcv;\n            VAR_7->idx += VAR_21;\n\n            /* COMMENT_5 */\n            if ((VAR_7->idx - VAR_7->begin) + VAR_21 > VAR_3) {\n                ERROR_OUT(VAR_19, VAR_20);\n            }\n            ato16(VAR_1 + VAR_7->idx, &VAR_7->sz);\n            VAR_7->idx += VAR_21;\n\n            /* COMMENT_6 */\n            if ((VAR_7->idx - VAR_7->begin) + VAR_7->sz > VAR_3 ||\n                                                       VAR_7->sz > VAR_22) {\n                ERROR_OUT(VAR_19, VAR_20);\n            }\n\n            /* COMMENT_7 */\n        #ifdef VAR_23\n            if (VAR_7->sigAlgo == VAR_24) {\n                WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n                VAR_17 = VAR_0->peerEd25519KeyPresent;\n            }\n        #endif\n        #ifdef VAR_25\n            if (VAR_7->sigAlgo == VAR_26) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig\");\n                VAR_17 = VAR_0->peerEd448KeyPresent;\n            }\n        #endif\n        #ifdef VAR_27\n            if (VAR_7->sigAlgo == VAR_28) {\n                WOLFSSL_MSG(\"Peer sent ECC sig\");\n                VAR_17 = VAR_0->peerEccDsaKeyPresent;\n            }\n        #endif\n        #ifdef VAR_29\n            if (VAR_7->sigAlgo == VAR_30) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n                VAR_17 = VAR_0->peerFalconKeyPresent;\n            }\n            if (VAR_7->sigAlgo == VAR_31) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n                VAR_17 = VAR_0->peerFalconKeyPresent;\n            }\n        #endif\n\n        #ifndef VAR_32\n            if (VAR_7->sigAlgo == VAR_33) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n                ERROR_OUT(VAR_34, VAR_20);\n            }\n            if (VAR_7->sigAlgo == VAR_35) {\n                WOLFSSL_MSG(\"Peer sent RSA sig\");\n                VAR_17 = (VAR_0->peerRsaKey != NULL) &&\n                                                         VAR_0->peerRsaKeyPresent;\n            }\n        #endif\n            if (!VAR_17) {\n                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n                VAR_4 = VAR_36;\n                goto exit_dcv;\n            }\n\n            VAR_5->buffer = (byte*)XMALLOC(VAR_7->sz, VAR_0->heap,\n                                         VAR_37);\n            if (VAR_5->buffer == NULL) {\n                ERROR_OUT(VAR_38, VAR_20);\n            }\n            VAR_5->length = VAR_7->sz;\n            XMEMCPY(VAR_5->buffer, VAR_1 + VAR_7->idx, VAR_7->sz);\n\n        #ifdef VAR_27\n            if (VAR_0->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                VAR_7->sigData = (byte*)XMALLOC(VAR_39, VAR_0->heap,\n                                                        VAR_37);\n                if (VAR_7->sigData == NULL) {\n                    ERROR_OUT(VAR_38, VAR_20);\n                }\n\n                VAR_4 = CreateSigData(VAR_0, VAR_7->sigData, &VAR_7->sigDataSz, 1);\n                if (VAR_4 != 0)\n                    goto exit_dcv;\n                VAR_4 = CreateECCEncodedSig(VAR_7->sigData,\n                    VAR_7->sigDataSz, VAR_7->hashAlgo);\n                if (VAR_4 < 0)\n                    goto exit_dcv;\n                VAR_7->sigDataSz = (word16)VAR_4;\n                VAR_4 = 0;\n            }\n        #endif\n        #ifdef VAR_23\n            if (VAR_0->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                VAR_7->sigData = (byte*)XMALLOC(VAR_39, VAR_0->heap,\n                                                        VAR_37);\n                if (VAR_7->sigData == NULL) {\n                    ERROR_OUT(VAR_38, VAR_20);\n                }\n\n                CreateSigData(VAR_0, VAR_7->sigData, &VAR_7->sigDataSz, 1);\n                VAR_4 = 0;\n            }\n        #endif\n        #ifdef VAR_25\n            if (VAR_0->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                VAR_7->sigData = (byte*)XMALLOC(VAR_39, VAR_0->heap,\n                                                        VAR_37);\n                if (VAR_7->sigData == NULL) {\n                    ERROR_OUT(VAR_38, VAR_20);\n                }\n\n                CreateSigData(VAR_0, VAR_7->sigData, &VAR_7->sigDataSz, 1);\n                VAR_4 = 0;\n            }\n       #endif\n       #ifdef VAR_29\n            if (VAR_0->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n\n                VAR_7->sigData = (byte*)XMALLOC(VAR_39, VAR_0->heap,\n                                                        VAR_37);\n                if (VAR_7->sigData == NULL) {\n                    ERROR_OUT(VAR_38, VAR_20);\n                }\n\n                CreateSigData(VAR_0, VAR_7->sigData, &VAR_7->sigDataSz, 1);\n                VAR_4 = 0;\n            }\n       #endif\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_40;\n        } /* COMMENT_8 */\n        VAR_16;\n\n        case VAR_40:\n        {\n        #ifndef VAR_32\n            if (VAR_0->peerRsaKey != NULL && VAR_0->peerRsaKeyPresent != 0) {\n                VAR_4 = RsaVerify(VAR_0, VAR_5->buffer, (word32)VAR_5->length, &VAR_7->output,\n                    VAR_7->sigAlgo, VAR_7->hashAlgo, VAR_0->peerRsaKey,\n                #ifdef VAR_41\n                    &VAR_0->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (VAR_4 >= 0) {\n                    VAR_7->sendSz = VAR_4;\n                    VAR_4 = 0;\n                }\n            }\n        #endif /* COMMENT_9 */\n        #ifdef VAR_27\n            if (VAR_0->peerEccDsaKeyPresent) {\n                VAR_4 = EccVerify(VAR_0, VAR_1 + VAR_7->idx, VAR_7->sz,\n                    VAR_7->sigData, VAR_7->sigDataSz,\n                    VAR_0->peerEccDsaKey,\n                #ifdef VAR_41\n                    &VAR_0->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (VAR_4 >= 0) {\n                    FreeKey(VAR_0, VAR_42, (void**)&VAR_0->peerEccDsaKey);\n                    VAR_0->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* COMMENT_10 */\n        #ifdef VAR_23\n            if (VAR_0->peerEd25519KeyPresent) {\n                VAR_4 = Ed25519Verify(VAR_0, VAR_1 + VAR_7->idx, VAR_7->sz,\n                    VAR_7->sigData, VAR_7->sigDataSz,\n                    VAR_0->peerEd25519Key,\n                #ifdef VAR_41\n                    &VAR_0->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (VAR_4 >= 0) {\n                    FreeKey(VAR_0, VAR_43,\n                                                  (void**)&VAR_0->peerEd25519Key);\n                    VAR_0->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef VAR_25\n            if (VAR_0->peerEd448KeyPresent) {\n                VAR_4 = Ed448Verify(VAR_0, VAR_1 + VAR_7->idx, VAR_7->sz,\n                    VAR_7->sigData, VAR_7->sigDataSz,\n                    VAR_0->peerEd448Key,\n                #ifdef VAR_41\n                    &VAR_0->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (VAR_4 >= 0) {\n                    FreeKey(VAR_0, VAR_44,\n                                                    (void**)&VAR_0->peerEd448Key);\n                    VAR_0->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef VAR_29\n            if (VAR_0->peerFalconKeyPresent) {\n                int VAR_45 = 0;\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n                VAR_4 = wc_falcon_verify_msg(VAR_1 + VAR_7->idx, VAR_7->sz,\n                                    VAR_7->sigData, VAR_7->sigDataSz,\n                                    &VAR_45, VAR_0->peerFalconKey);\n\n                if ((VAR_4 >= 0) && (VAR_45 == 1)) {\n                    FreeKey(VAR_0, VAR_46,\n                                                   (void**)&VAR_0->peerFalconKey);\n                    VAR_0->peerFalconKeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* COMMENT_0 */\n            if (VAR_4 != 0) {\n                goto exit_dcv;\n            }\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_47;\n        } /* COMMENT_11 */\n        VAR_16;\n\n        case VAR_47:\n        {\n        #if !defined(VAR_32) && defined(VAR_48)\n            if (VAR_0->peerRsaKey != NULL && VAR_0->peerRsaKeyPresent != 0) {\n                VAR_4 = CheckRSASignature(VAR_0, VAR_7->sigAlgo, VAR_7->hashAlgo,\n                                        VAR_7->output, VAR_7->sendSz);\n                if (VAR_4 != 0)\n                    goto exit_dcv;\n\n                FreeKey(VAR_0, VAR_49, (void**)&VAR_0->peerRsaKey);\n                VAR_0->peerRsaKeyPresent = 0;\n            }\n        #endif /* COMMENT_12 */\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_50;\n        } /* COMMENT_13 */\n        VAR_16;\n\n        case VAR_50:\n        {\n            VAR_0->options.havePeerVerify = 1;\n\n            /* COMMENT_14 */\n            VAR_7->idx += VAR_7->sz;\n            *VAR_2 = VAR_7->idx;\n\n            /* COMMENT_15 */\n            *VAR_2 += VAR_0->keys.padSz;\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_51;\n\n        #if !defined(VAR_52)\n            if (VAR_0->options.side == VAR_53)\n                VAR_0->options.serverState = VAR_54;\n        #endif\n        } /* COMMENT_16 */\n        VAR_16;\n\n        case VAR_51:\n        {\n            break;\n        }\n\n        default:\n            VAR_4 = VAR_55;\n    } /* COMMENT_17 */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", VAR_4);\n    WOLFSSL_END(VAR_8);\n\n#ifdef VAR_6\n    /* COMMENT_18 */\n    if (VAR_4 == VAR_56) {\n        /* COMMENT_19 */\n        VAR_0->msgsReceived.got_certificate_verify = 0;\n\n        return VAR_4;\n    }\n    else\n#endif /* COMMENT_20 */\n    if (VAR_4 != 0 && VAR_4 != VAR_34)\n        SendAlert(VAR_0, VAR_57, VAR_58);\n\n    /* COMMENT_21 */\n    VAR_13(VAR_0, VAR_7);\n    FreeKeyExchange(VAR_0);\n\n    return VAR_4;\n}",
  "func_graph_path_before": "wolfSSL/wolfssl/08047b2d959ee5e21a4a2c672308f45fec61f059/tls13.c/vul/before/0.json",
  "func": "static int DoTls13CertificateVerify(WOLFSSL* ssl, byte* input,\n                                    word32* inOutIdx, word32 totalSz)\n{\n    int         ret = 0;\n    buffer*     sig = &ssl->buffers.sig;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dcv13Args* args = (Dcv13Args*)ssl->async.args;\n    typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ret = 0;\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dcv13Args));\n        args->hashAlgo = sha_mac;\n        args->sigAlgo = anonymous_sa_algo;\n        args->idx = *inOutIdx;\n        args->begin = *inOutIdx;\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        ssl->async.freeArgs = FreeDcv13Args;\n    #endif\n    }\n\n    switch(ssl->options.asyncState)\n    {\n        case TLS_ASYNC_BEGIN:\n        {\n        #ifdef WOLFSSL_CALLBACKS\n            if (ssl->hsInfoOn) AddPacketName(ssl, \"CertificateVerify\");\n            if (ssl->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &ssl->timeoutInfo);\n        #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_BUILD;\n        } /* case TLS_ASYNC_BEGIN */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_BUILD:\n        {\n            int validSigAlgo;\n\n            /* Signature algorithm. */\n            if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ret = DecodeTls13SigAlg(input + args->idx, &args->hashAlgo,\n                                                                &args->sigAlgo);\n            if (ret < 0)\n                goto exit_dcv;\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature length. */\n            if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ato16(input + args->idx, &args->sz);\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature data. */\n            if ((args->idx - args->begin) + args->sz > totalSz ||\n                                                       args->sz > ENCRYPT_LEN) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n\n            /* Check for public key of required type. */\n            /* Assume invalid unless signature algo matches the key provided */\n            validSigAlgo = 0;\n        #ifdef HAVE_ED25519\n            if (args->sigAlgo == ed25519_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n                validSigAlgo = (ssl->peerEd25519Key != NULL) &&\n                                                     ssl->peerEd25519KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (args->sigAlgo == ed448_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig\");\n                validSigAlgo = (ssl->peerEd448Key != NULL) &&\n                                                       ssl->peerEd448KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ECC\n            if (args->sigAlgo == ecc_dsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ECC sig\");\n                validSigAlgo = (ssl->peerEccDsaKey != NULL) &&\n                                                      ssl->peerEccDsaKeyPresent;\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (args->sigAlgo == falcon_level1_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n                validSigAlgo = (ssl->peerFalconKey != NULL) &&\n                                                      ssl->peerFalconKeyPresent;\n            }\n            if (args->sigAlgo == falcon_level5_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n                validSigAlgo = (ssl->peerFalconKey != NULL) &&\n                                                      ssl->peerFalconKeyPresent;\n            }\n        #endif\n        #ifndef NO_RSA\n            if (args->sigAlgo == rsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n            }\n            if (args->sigAlgo == rsa_pss_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent RSA sig\");\n                validSigAlgo = (ssl->peerRsaKey != NULL) &&\n                                                         ssl->peerRsaKeyPresent;\n            }\n        #endif\n            if (!validSigAlgo) {\n                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n                ERROR_OUT(SIG_VERIFY_E, exit_dcv);\n            }\n\n            sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                         DYNAMIC_TYPE_SIGNATURE);\n            if (sig->buffer == NULL) {\n                ERROR_OUT(MEMORY_E, exit_dcv);\n            }\n            sig->length = args->sz;\n            XMEMCPY(sig->buffer, input + args->idx, args->sz);\n\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                ret = CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                if (ret != 0)\n                    goto exit_dcv;\n                ret = CreateECCEncodedSig(args->sigData,\n                    args->sigDataSz, args->hashAlgo);\n                if (ret < 0)\n                    goto exit_dcv;\n                args->sigDataSz = (word16)ret;\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n       #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_DO;\n        } /* case TLS_ASYNC_BUILD */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_DO:\n        {\n        #ifndef NO_RSA\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = RsaVerify(ssl, sig->buffer, (word32)sig->length, &args->output,\n                    args->sigAlgo, args->hashAlgo, ssl->peerRsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (ret >= 0) {\n                    args->sendSz = ret;\n                    ret = 0;\n                }\n            }\n        #endif /* !NO_RSA */\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                ret = EccVerify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEccDsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);\n                    ssl->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                ret = Ed25519Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd25519Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED25519,\n                                                  (void**)&ssl->peerEd25519Key);\n                    ssl->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                ret = Ed448Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd448Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED448,\n                                                    (void**)&ssl->peerEd448Key);\n                    ssl->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                int res = 0;\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n                ret = wc_falcon_verify_msg(input + args->idx, args->sz,\n                                    args->sigData, args->sigDataSz,\n                                    &res, ssl->peerFalconKey);\n\n                if ((ret >= 0) && (res == 1)) {\n                    FreeKey(ssl, DYNAMIC_TYPE_FALCON,\n                                                   (void**)&ssl->peerFalconKey);\n                    ssl->peerFalconKeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* Check for error */\n            if (ret != 0) {\n                goto exit_dcv;\n            }\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_VERIFY;\n        } /* case TLS_ASYNC_DO */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_VERIFY:\n        {\n        #if !defined(NO_RSA) && defined(WC_RSA_PSS)\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = CheckRSASignature(ssl, args->sigAlgo, args->hashAlgo,\n                                        args->output, args->sendSz);\n                if (ret != 0)\n                    goto exit_dcv;\n\n                FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);\n                ssl->peerRsaKeyPresent = 0;\n            }\n        #endif /* !NO_RSA && WC_RSA_PSS */\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n        } /* case TLS_ASYNC_VERIFY */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_FINALIZE:\n        {\n            ssl->options.havePeerVerify = 1;\n\n            /* Set final index */\n            args->idx += args->sz;\n            *inOutIdx = args->idx;\n\n            /* Encryption is always on: add padding */\n            *inOutIdx += ssl->keys.padSz;\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_END;\n\n        #if !defined(NO_WOLFSSL_CLIENT)\n            if (ssl->options.side == WOLFSSL_CLIENT_END)\n                ssl->options.serverState = SERVER_CERT_VERIFY_COMPLETE;\n        #endif\n        } /* case TLS_ASYNC_FINALIZE */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_END:\n        {\n            break;\n        }\n\n        default:\n            ret = INPUT_CASE_ERROR;\n    } /* switch(ssl->options.asyncState) */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", ret);\n    WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}",
  "abstract_func": "static int DoTls13CertificateVerify(WOLFSSL* VAR_0, byte* VAR_1,\n                                    word32* VAR_2, word32 VAR_3)\n{\n    int         VAR_4 = 0;\n    buffer*     VAR_5 = &VAR_0->buffers.sig;\n#ifdef VAR_6\n    Dcv13Args* VAR_7 = (Dcv13Args*)VAR_0->async.args;\n    typedef char args_test[sizeof(VAR_0->async.args) >= sizeof(*VAR_7) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  VAR_7[1];\n#endif\n\n    WOLFSSL_START(VAR_8);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef VAR_6\n    VAR_4 = wolfSSL_AsyncPop(VAR_0, &VAR_0->options.asyncState);\n    if (VAR_4 != VAR_9) {\n        /* COMMENT_0 */\n        if (VAR_4 < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* COMMENT_1 */\n        VAR_4 = 0;\n        VAR_0->options.asyncState = VAR_10;\n        XMEMSET(VAR_7, 0, sizeof(Dcv13Args));\n        VAR_7->hashAlgo = VAR_11;\n        VAR_7->sigAlgo = VAR_12;\n        VAR_7->idx = *VAR_2;\n        VAR_7->begin = *VAR_2;\n    #ifdef VAR_6\n        VAR_0->async.freeArgs = VAR_13;\n    #endif\n    }\n\n    switch(VAR_0->options.asyncState)\n    {\n        case VAR_10:\n        {\n        #ifdef VAR_14\n            if (VAR_0->hsInfoOn) AddPacketName(VAR_0, \"CertificateVerify\");\n            if (VAR_0->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &VAR_0->timeoutInfo);\n        #endif\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_15;\n        } /* COMMENT_3 */\n        VAR_16;\n\n        case VAR_15:\n        {\n            int VAR_17;\n\n            /* COMMENT_4 */\n            if ((VAR_7->idx - VAR_7->begin) + VAR_18 + VAR_18 > VAR_3) {\n                ERROR_OUT(VAR_19, VAR_20);\n            }\n            VAR_4 = DecodeTls13SigAlg(VAR_1 + VAR_7->idx, &VAR_7->hashAlgo,\n                                                                &VAR_7->sigAlgo);\n            if (VAR_4 < 0)\n                goto exit_dcv;\n            VAR_7->idx += VAR_21;\n\n            /* COMMENT_5 */\n            if ((VAR_7->idx - VAR_7->begin) + VAR_21 > VAR_3) {\n                ERROR_OUT(VAR_19, VAR_20);\n            }\n            ato16(VAR_1 + VAR_7->idx, &VAR_7->sz);\n            VAR_7->idx += VAR_21;\n\n            /* COMMENT_6 */\n            if ((VAR_7->idx - VAR_7->begin) + VAR_7->sz > VAR_3 ||\n                                                       VAR_7->sz > VAR_22) {\n                ERROR_OUT(VAR_19, VAR_20);\n            }\n\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            VAR_17 = 0;\n        #ifdef VAR_23\n            if (VAR_7->sigAlgo == VAR_24) {\n                WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n                VAR_17 = (VAR_0->peerEd25519Key != NULL) &&\n                                                     VAR_0->peerEd25519KeyPresent;\n            }\n        #endif\n        #ifdef VAR_25\n            if (VAR_7->sigAlgo == VAR_26) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig\");\n                VAR_17 = (VAR_0->peerEd448Key != NULL) &&\n                                                       VAR_0->peerEd448KeyPresent;\n            }\n        #endif\n        #ifdef VAR_27\n            if (VAR_7->sigAlgo == VAR_28) {\n                WOLFSSL_MSG(\"Peer sent ECC sig\");\n                VAR_17 = (VAR_0->peerEccDsaKey != NULL) &&\n                                                      VAR_0->peerEccDsaKeyPresent;\n            }\n        #endif\n        #ifdef VAR_29\n            if (VAR_7->sigAlgo == VAR_30) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n                VAR_17 = (VAR_0->peerFalconKey != NULL) &&\n                                                      VAR_0->peerFalconKeyPresent;\n            }\n            if (VAR_7->sigAlgo == VAR_31) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n                VAR_17 = (VAR_0->peerFalconKey != NULL) &&\n                                                      VAR_0->peerFalconKeyPresent;\n            }\n        #endif\n        #ifndef VAR_32\n            if (VAR_7->sigAlgo == VAR_33) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n                ERROR_OUT(VAR_34, VAR_20);\n            }\n            if (VAR_7->sigAlgo == VAR_35) {\n                WOLFSSL_MSG(\"Peer sent RSA sig\");\n                VAR_17 = (VAR_0->peerRsaKey != NULL) &&\n                                                         VAR_0->peerRsaKeyPresent;\n            }\n        #endif\n            if (!VAR_17) {\n                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n                ERROR_OUT(VAR_36, VAR_20);\n            }\n\n            VAR_5->buffer = (byte*)XMALLOC(VAR_7->sz, VAR_0->heap,\n                                         VAR_37);\n            if (VAR_5->buffer == NULL) {\n                ERROR_OUT(VAR_38, VAR_20);\n            }\n            VAR_5->length = VAR_7->sz;\n            XMEMCPY(VAR_5->buffer, VAR_1 + VAR_7->idx, VAR_7->sz);\n\n        #ifdef VAR_27\n            if (VAR_0->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                VAR_7->sigData = (byte*)XMALLOC(VAR_39, VAR_0->heap,\n                                                        VAR_37);\n                if (VAR_7->sigData == NULL) {\n                    ERROR_OUT(VAR_38, VAR_20);\n                }\n\n                VAR_4 = CreateSigData(VAR_0, VAR_7->sigData, &VAR_7->sigDataSz, 1);\n                if (VAR_4 != 0)\n                    goto exit_dcv;\n                VAR_4 = CreateECCEncodedSig(VAR_7->sigData,\n                    VAR_7->sigDataSz, VAR_7->hashAlgo);\n                if (VAR_4 < 0)\n                    goto exit_dcv;\n                VAR_7->sigDataSz = (word16)VAR_4;\n                VAR_4 = 0;\n            }\n        #endif\n        #ifdef VAR_23\n            if (VAR_0->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                VAR_7->sigData = (byte*)XMALLOC(VAR_39, VAR_0->heap,\n                                                        VAR_37);\n                if (VAR_7->sigData == NULL) {\n                    ERROR_OUT(VAR_38, VAR_20);\n                }\n\n                CreateSigData(VAR_0, VAR_7->sigData, &VAR_7->sigDataSz, 1);\n                VAR_4 = 0;\n            }\n        #endif\n        #ifdef VAR_25\n            if (VAR_0->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                VAR_7->sigData = (byte*)XMALLOC(VAR_39, VAR_0->heap,\n                                                        VAR_37);\n                if (VAR_7->sigData == NULL) {\n                    ERROR_OUT(VAR_38, VAR_20);\n                }\n\n                CreateSigData(VAR_0, VAR_7->sigData, &VAR_7->sigDataSz, 1);\n                VAR_4 = 0;\n            }\n       #endif\n       #ifdef VAR_29\n            if (VAR_0->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n\n                VAR_7->sigData = (byte*)XMALLOC(VAR_39, VAR_0->heap,\n                                                        VAR_37);\n                if (VAR_7->sigData == NULL) {\n                    ERROR_OUT(VAR_38, VAR_20);\n                }\n\n                CreateSigData(VAR_0, VAR_7->sigData, &VAR_7->sigDataSz, 1);\n                VAR_4 = 0;\n            }\n       #endif\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_40;\n        } /* COMMENT_9 */\n        VAR_16;\n\n        case VAR_40:\n        {\n        #ifndef VAR_32\n            if (VAR_0->peerRsaKey != NULL && VAR_0->peerRsaKeyPresent != 0) {\n                VAR_4 = RsaVerify(VAR_0, VAR_5->buffer, (word32)VAR_5->length, &VAR_7->output,\n                    VAR_7->sigAlgo, VAR_7->hashAlgo, VAR_0->peerRsaKey,\n                #ifdef VAR_41\n                    &VAR_0->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (VAR_4 >= 0) {\n                    VAR_7->sendSz = VAR_4;\n                    VAR_4 = 0;\n                }\n            }\n        #endif /* COMMENT_10 */\n        #ifdef VAR_27\n            if (VAR_0->peerEccDsaKeyPresent) {\n                VAR_4 = EccVerify(VAR_0, VAR_1 + VAR_7->idx, VAR_7->sz,\n                    VAR_7->sigData, VAR_7->sigDataSz,\n                    VAR_0->peerEccDsaKey,\n                #ifdef VAR_41\n                    &VAR_0->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (VAR_4 >= 0) {\n                    FreeKey(VAR_0, VAR_42, (void**)&VAR_0->peerEccDsaKey);\n                    VAR_0->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* COMMENT_11 */\n        #ifdef VAR_23\n            if (VAR_0->peerEd25519KeyPresent) {\n                VAR_4 = Ed25519Verify(VAR_0, VAR_1 + VAR_7->idx, VAR_7->sz,\n                    VAR_7->sigData, VAR_7->sigDataSz,\n                    VAR_0->peerEd25519Key,\n                #ifdef VAR_41\n                    &VAR_0->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (VAR_4 >= 0) {\n                    FreeKey(VAR_0, VAR_43,\n                                                  (void**)&VAR_0->peerEd25519Key);\n                    VAR_0->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef VAR_25\n            if (VAR_0->peerEd448KeyPresent) {\n                VAR_4 = Ed448Verify(VAR_0, VAR_1 + VAR_7->idx, VAR_7->sz,\n                    VAR_7->sigData, VAR_7->sigDataSz,\n                    VAR_0->peerEd448Key,\n                #ifdef VAR_41\n                    &VAR_0->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (VAR_4 >= 0) {\n                    FreeKey(VAR_0, VAR_44,\n                                                    (void**)&VAR_0->peerEd448Key);\n                    VAR_0->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef VAR_29\n            if (VAR_0->peerFalconKeyPresent) {\n                int VAR_45 = 0;\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n                VAR_4 = wc_falcon_verify_msg(VAR_1 + VAR_7->idx, VAR_7->sz,\n                                    VAR_7->sigData, VAR_7->sigDataSz,\n                                    &VAR_45, VAR_0->peerFalconKey);\n\n                if ((VAR_4 >= 0) && (VAR_45 == 1)) {\n                    FreeKey(VAR_0, VAR_46,\n                                                   (void**)&VAR_0->peerFalconKey);\n                    VAR_0->peerFalconKeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* COMMENT_0 */\n            if (VAR_4 != 0) {\n                goto exit_dcv;\n            }\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_47;\n        } /* COMMENT_12 */\n        VAR_16;\n\n        case VAR_47:\n        {\n        #if !defined(VAR_32) && defined(VAR_48)\n            if (VAR_0->peerRsaKey != NULL && VAR_0->peerRsaKeyPresent != 0) {\n                VAR_4 = CheckRSASignature(VAR_0, VAR_7->sigAlgo, VAR_7->hashAlgo,\n                                        VAR_7->output, VAR_7->sendSz);\n                if (VAR_4 != 0)\n                    goto exit_dcv;\n\n                FreeKey(VAR_0, VAR_49, (void**)&VAR_0->peerRsaKey);\n                VAR_0->peerRsaKeyPresent = 0;\n            }\n        #endif /* COMMENT_13 */\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_50;\n        } /* COMMENT_14 */\n        VAR_16;\n\n        case VAR_50:\n        {\n            VAR_0->options.havePeerVerify = 1;\n\n            /* COMMENT_15 */\n            VAR_7->idx += VAR_7->sz;\n            *VAR_2 = VAR_7->idx;\n\n            /* COMMENT_16 */\n            *VAR_2 += VAR_0->keys.padSz;\n\n            /* COMMENT_2 */\n            VAR_0->options.asyncState = VAR_51;\n\n        #if !defined(VAR_52)\n            if (VAR_0->options.side == VAR_53)\n                VAR_0->options.serverState = VAR_54;\n        #endif\n        } /* COMMENT_17 */\n        VAR_16;\n\n        case VAR_51:\n        {\n            break;\n        }\n\n        default:\n            VAR_4 = VAR_55;\n    } /* COMMENT_18 */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", VAR_4);\n    WOLFSSL_END(VAR_8);\n\n#ifdef VAR_6\n    /* COMMENT_19 */\n    if (VAR_4 == VAR_56) {\n        /* COMMENT_20 */\n        VAR_0->msgsReceived.got_certificate_verify = 0;\n\n        return VAR_4;\n    }\n    else\n#endif /* COMMENT_21 */\n    if (VAR_4 != 0 && VAR_4 != VAR_34)\n        SendAlert(VAR_0, VAR_57, VAR_58);\n\n    /* COMMENT_22 */\n    VAR_13(VAR_0, VAR_7);\n    FreeKeyExchange(VAR_0);\n\n    return VAR_4;\n}",
  "func_graph_path": "wolfSSL/wolfssl/08047b2d959ee5e21a4a2c672308f45fec61f059/tls13.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -54,7 +54,7 @@\n \n         case TLS_ASYNC_BUILD:\n         {\n-            int validSigAlgo = 0;\n+            int validSigAlgo;\n \n             /* Signature algorithm. */\n             if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n@@ -80,35 +80,41 @@\n             }\n \n             /* Check for public key of required type. */\n+            /* Assume invalid unless signature algo matches the key provided */\n+            validSigAlgo = 0;\n         #ifdef HAVE_ED25519\n             if (args->sigAlgo == ed25519_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n-                validSigAlgo = ssl->peerEd25519KeyPresent;\n+                validSigAlgo = (ssl->peerEd25519Key != NULL) &&\n+                                                     ssl->peerEd25519KeyPresent;\n             }\n         #endif\n         #ifdef HAVE_ED448\n             if (args->sigAlgo == ed448_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent ED448 sig\");\n-                validSigAlgo = ssl->peerEd448KeyPresent;\n+                validSigAlgo = (ssl->peerEd448Key != NULL) &&\n+                                                       ssl->peerEd448KeyPresent;\n             }\n         #endif\n         #ifdef HAVE_ECC\n             if (args->sigAlgo == ecc_dsa_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent ECC sig\");\n-                validSigAlgo = ssl->peerEccDsaKeyPresent;\n+                validSigAlgo = (ssl->peerEccDsaKey != NULL) &&\n+                                                      ssl->peerEccDsaKeyPresent;\n             }\n         #endif\n         #ifdef HAVE_PQC\n             if (args->sigAlgo == falcon_level1_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n-                validSigAlgo = ssl->peerFalconKeyPresent;\n+                validSigAlgo = (ssl->peerFalconKey != NULL) &&\n+                                                      ssl->peerFalconKeyPresent;\n             }\n             if (args->sigAlgo == falcon_level5_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n-                validSigAlgo = ssl->peerFalconKeyPresent;\n-            }\n-        #endif\n-\n+                validSigAlgo = (ssl->peerFalconKey != NULL) &&\n+                                                      ssl->peerFalconKeyPresent;\n+            }\n+        #endif\n         #ifndef NO_RSA\n             if (args->sigAlgo == rsa_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n@@ -122,8 +128,7 @@\n         #endif\n             if (!validSigAlgo) {\n                 WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n-                ret = SIG_VERIFY_E;\n-                goto exit_dcv;\n+                ERROR_OUT(SIG_VERIFY_E, exit_dcv);\n             }\n \n             sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,",
  "diff_line_info": {
    "deleted_lines": [
      "            int validSigAlgo = 0;",
      "                validSigAlgo = ssl->peerEd25519KeyPresent;",
      "                validSigAlgo = ssl->peerEd448KeyPresent;",
      "                validSigAlgo = ssl->peerEccDsaKeyPresent;",
      "                validSigAlgo = ssl->peerFalconKeyPresent;",
      "                validSigAlgo = ssl->peerFalconKeyPresent;",
      "            }",
      "        #endif",
      "",
      "                ret = SIG_VERIFY_E;",
      "                goto exit_dcv;"
    ],
    "added_lines": [
      "            int validSigAlgo;",
      "            /* Assume invalid unless signature algo matches the key provided */",
      "            validSigAlgo = 0;",
      "                validSigAlgo = (ssl->peerEd25519Key != NULL) &&",
      "                                                     ssl->peerEd25519KeyPresent;",
      "                validSigAlgo = (ssl->peerEd448Key != NULL) &&",
      "                                                       ssl->peerEd448KeyPresent;",
      "                validSigAlgo = (ssl->peerEccDsaKey != NULL) &&",
      "                                                      ssl->peerEccDsaKeyPresent;",
      "                validSigAlgo = (ssl->peerFalconKey != NULL) &&",
      "                                                      ssl->peerFalconKeyPresent;",
      "                validSigAlgo = (ssl->peerFalconKey != NULL) &&",
      "                                                      ssl->peerFalconKeyPresent;",
      "            }",
      "        #endif",
      "                ERROR_OUT(SIG_VERIFY_E, exit_dcv);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssl/pull/4813",
  "description": {
    "pr_info": {
      "title": "Fix for mutual authentication to prevent mismatch of certificate and sigalgo",
      "number": 4813
    },
    "comment": [
      "# Description\r\n\r\nFix for mutual authentication to prevent mismatch of certificate and sig algo. Fixes from Sean P.\r\n\r\nFixes ZD13571\r\n\r\n# Testing\r\n\r\nTested by customer.\r\n\r\n# Checklist\r\n\r\n - [ ] added tests\r\n - [ ] updated/added doxygen\r\n - [ ] updated appropriate READMEs\r\n - [ ] Updated manual and documentation\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Commit Message**: Refers to adding checks ensuring keys are present and explicitly initializing a variable. These are security-related.\n2. **Vulnerability Description**: Clearly states it's a fix for mutual authentication to prevent mismatches, indicating a security issue.\n3. **Code Diff**: Adds explicit checks for key presence and validity, crucial for preventing attacks based on key mismatches.\n4. **Consistency**: Both the message and code focus on preventing security vulnerabilities.\n5. **Purpose**: Directly addresses a security risk, ensuring proper key validation.\n6. **Confidence**: High because the changes are specific and clearly related to security."
}