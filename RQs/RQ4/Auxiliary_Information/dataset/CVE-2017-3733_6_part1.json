{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/t1_lib.c",
  "func_name": "ssl_scan_clienthello_tlsext",
  "func_before": "static int ssl_scan_clienthello_tlsext(SSL *s, PACKET *pkt, int *al)\n{\n    unsigned int type;\n    int renegotiate_seen = 0;\n    PACKET extensions;\n\n    *al = SSL_AD_DECODE_ERROR;\n    s->servername_done = 0;\n    s->tlsext_status_type = -1;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    s->s3->next_proto_neg_seen = 0;\n#endif\n\n    OPENSSL_free(s->s3->alpn_selected);\n    s->s3->alpn_selected = NULL;\n    s->s3->alpn_selected_len = 0;\n    OPENSSL_free(s->s3->alpn_proposed);\n    s->s3->alpn_proposed = NULL;\n    s->s3->alpn_proposed_len = 0;\n#ifndef OPENSSL_NO_HEARTBEATS\n    s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED |\n                             SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n\n#ifndef OPENSSL_NO_EC\n    if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\n        ssl_check_for_safari(s, pkt);\n#endif                          /* !OPENSSL_NO_EC */\n\n    /* Clear any signature algorithms extension received */\n    OPENSSL_free(s->s3->tmp.peer_sigalgs);\n    s->s3->tmp.peer_sigalgs = NULL;\n    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n\n#ifndef OPENSSL_NO_SRP\n    OPENSSL_free(s->srp_ctx.login);\n    s->srp_ctx.login = NULL;\n#endif\n\n    s->srtp_profile = NULL;\n\n    if (PACKET_remaining(pkt) == 0)\n        goto ri_check;\n\n    if (!PACKET_as_length_prefixed_2(pkt, &extensions))\n        return 0;\n\n    if (!tls1_check_duplicate_extensions(&extensions))\n        return 0;\n\n    /*\n     * We parse all extensions to ensure the ClientHello is well-formed but,\n     * unless an extension specifies otherwise, we ignore extensions upon\n     * resumption.\n     */\n    while (PACKET_get_net_2(&extensions, &type)) {\n        PACKET extension;\n        if (!PACKET_get_length_prefixed_2(&extensions, &extension))\n            return 0;\n\n        if (s->tlsext_debug_cb)\n            s->tlsext_debug_cb(s, 0, type, PACKET_data(&extension),\n                               PACKET_remaining(&extension),\n                               s->tlsext_debug_arg);\n\n        if (type == TLSEXT_TYPE_renegotiate) {\n            if (!ssl_parse_clienthello_renegotiate_ext(s, &extension, al))\n                return 0;\n            renegotiate_seen = 1;\n        } else if (s->version == SSL3_VERSION) {\n        }\n/*-\n * The servername extension is treated as follows:\n *\n * - Only the hostname type is supported with a maximum length of 255.\n * - The servername is rejected if too long or if it contains zeros,\n *   in which case an fatal alert is generated.\n * - The servername field is maintained together with the session cache.\n * - When a session is resumed, the servername call back invoked in order\n *   to allow the application to position itself to the right context.\n * - The servername is acknowledged if it is new for a session or when\n *   it is identical to a previously used for the same session.\n *   Applications can control the behaviour.  They can at any time\n *   set a 'desirable' servername for a new SSL object. This can be the\n *   case for example with HTTPS when a Host: header field is received and\n *   a renegotiation is requested. In this case, a possible servername\n *   presented in the new client hello is only acknowledged if it matches\n *   the value of the Host: field.\n * - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n *   if they provide for changing an explicit servername context for the\n *   session, i.e. when the session has been established with a servername\n *   extension.\n * - On session reconnect, the servername extension may be absent.\n *\n */\n\n        else if (type == TLSEXT_TYPE_server_name) {\n            unsigned int servname_type;\n            PACKET sni, hostname;\n\n            if (!PACKET_as_length_prefixed_2(&extension, &sni)\n                /* ServerNameList must be at least 1 byte long. */\n                || PACKET_remaining(&sni) == 0) {\n                return 0;\n            }\n\n            /*\n             * Although the server_name extension was intended to be\n             * extensible to new name types, RFC 4366 defined the\n             * syntax inextensibility and OpenSSL 1.0.x parses it as\n             * such.\n             * RFC 6066 corrected the mistake but adding new name types\n             * is nevertheless no longer feasible, so act as if no other\n             * SNI types can exist, to simplify parsing.\n             *\n             * Also note that the RFC permits only one SNI value per type,\n             * i.e., we can only have a single hostname.\n             */\n            if (!PACKET_get_1(&sni, &servname_type)\n                || servname_type != TLSEXT_NAMETYPE_host_name\n                || !PACKET_as_length_prefixed_2(&sni, &hostname)) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (PACKET_remaining(&hostname) > TLSEXT_MAXLEN_host_name) {\n                    *al = TLS1_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n\n                if (PACKET_contains_zero_byte(&hostname)) {\n                    *al = TLS1_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n\n                if (!PACKET_strndup(&hostname, &s->session->tlsext_hostname)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n\n                s->servername_done = 1;\n            } else {\n                /*\n                 * TODO(openssl-team): if the SNI doesn't match, we MUST\n                 * fall back to a full handshake.\n                 */\n                s->servername_done = s->session->tlsext_hostname\n                    && PACKET_equal(&hostname, s->session->tlsext_hostname,\n                                    strlen(s->session->tlsext_hostname));\n            }\n        }\n#ifndef OPENSSL_NO_SRP\n        else if (type == TLSEXT_TYPE_srp) {\n            PACKET srp_I;\n\n            if (!PACKET_as_length_prefixed_1(&extension, &srp_I))\n                return 0;\n\n            if (PACKET_contains_zero_byte(&srp_I))\n                return 0;\n\n            /*\n             * TODO(openssl-team): currently, we re-authenticate the user\n             * upon resumption. Instead, we MUST ignore the login.\n             */\n            if (!PACKET_strndup(&srp_I, &s->srp_ctx.login)) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        }\n#endif\n\n#ifndef OPENSSL_NO_EC\n        else if (type == TLSEXT_TYPE_ec_point_formats) {\n            PACKET ec_point_format_list;\n\n            if (!PACKET_as_length_prefixed_1(&extension, &ec_point_format_list)\n                || PACKET_remaining(&ec_point_format_list) == 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!PACKET_memdup(&ec_point_format_list,\n                                   &s->session->tlsext_ecpointformatlist,\n                                   &s->\n                                   session->tlsext_ecpointformatlist_length)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n            }\n        } else if (type == TLSEXT_TYPE_elliptic_curves) {\n            PACKET elliptic_curve_list;\n\n            /* Each NamedCurve is 2 bytes and we must have at least 1. */\n            if (!PACKET_as_length_prefixed_2(&extension, &elliptic_curve_list)\n                || PACKET_remaining(&elliptic_curve_list) == 0\n                || (PACKET_remaining(&elliptic_curve_list) % 2) != 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!PACKET_memdup(&elliptic_curve_list,\n                                   &s->session->tlsext_ellipticcurvelist,\n                                   &s->\n                                   session->tlsext_ellipticcurvelist_length)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n            }\n        }\n#endif                          /* OPENSSL_NO_EC */\n        else if (type == TLSEXT_TYPE_session_ticket) {\n            if (s->tls_session_ticket_ext_cb &&\n                !s->tls_session_ticket_ext_cb(s, PACKET_data(&extension),\n                                              PACKET_remaining(&extension),\n                                              s->tls_session_ticket_ext_cb_arg))\n            {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        } else if (type == TLSEXT_TYPE_signature_algorithms) {\n            PACKET supported_sig_algs;\n\n            if (!PACKET_as_length_prefixed_2(&extension, &supported_sig_algs)\n                || (PACKET_remaining(&supported_sig_algs) % 2) != 0\n                || PACKET_remaining(&supported_sig_algs) == 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!tls1_save_sigalgs(s, PACKET_data(&supported_sig_algs),\n                                       PACKET_remaining(&supported_sig_algs))) {\n                    return 0;\n                }\n            }\n        } else if (type == TLSEXT_TYPE_status_request) {\n            if (!PACKET_get_1(&extension,\n                              (unsigned int *)&s->tlsext_status_type)) {\n                return 0;\n            }\n#ifndef OPENSSL_NO_OCSP\n            if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\n                const unsigned char *ext_data;\n                PACKET responder_id_list, exts;\n                if (!PACKET_get_length_prefixed_2\n                    (&extension, &responder_id_list))\n                    return 0;\n\n                /*\n                 * We remove any OCSP_RESPIDs from a previous handshake\n                 * to prevent unbounded memory growth - CVE-2016-6304\n                 */\n                sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids,\n                                        OCSP_RESPID_free);\n                if (PACKET_remaining(&responder_id_list) > 0) {\n                    s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();\n                    if (s->tlsext_ocsp_ids == NULL) {\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                } else {\n                    s->tlsext_ocsp_ids = NULL;\n                }\n\n                while (PACKET_remaining(&responder_id_list) > 0) {\n                    OCSP_RESPID *id;\n                    PACKET responder_id;\n                    const unsigned char *id_data;\n\n                    if (!PACKET_get_length_prefixed_2(&responder_id_list,\n                                                      &responder_id)\n                        || PACKET_remaining(&responder_id) == 0) {\n                        return 0;\n                    }\n\n                    id_data = PACKET_data(&responder_id);\n                    id = d2i_OCSP_RESPID(NULL, &id_data,\n                                         PACKET_remaining(&responder_id));\n                    if (id == NULL)\n                        return 0;\n\n                    if (id_data != PACKET_end(&responder_id)) {\n                        OCSP_RESPID_free(id);\n                        return 0;\n                    }\n\n                    if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {\n                        OCSP_RESPID_free(id);\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                }\n\n                /* Read in request_extensions */\n                if (!PACKET_as_length_prefixed_2(&extension, &exts))\n                    return 0;\n\n                if (PACKET_remaining(&exts) > 0) {\n                    ext_data = PACKET_data(&exts);\n                    sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\n                                               X509_EXTENSION_free);\n                    s->tlsext_ocsp_exts =\n                        d2i_X509_EXTENSIONS(NULL, &ext_data,\n                                            PACKET_remaining(&exts));\n                    if (s->tlsext_ocsp_exts == NULL\n                        || ext_data != PACKET_end(&exts)) {\n                        return 0;\n                    }\n                }\n            } else\n#endif\n            {\n                /*\n                 * We don't know what to do with any other type so ignore it.\n                 */\n                s->tlsext_status_type = -1;\n            }\n        }\n#ifndef OPENSSL_NO_HEARTBEATS\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) {\n            unsigned int hbtype;\n\n            if (!PACKET_get_1(&extension, &hbtype)\n                || PACKET_remaining(&extension)) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n            switch (hbtype) {\n            case 0x01:         /* Client allows us to send HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                break;\n            case 0x02:         /* Client doesn't accept HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n                break;\n            default:\n                *al = SSL_AD_ILLEGAL_PARAMETER;\n                return 0;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n        else if (type == TLSEXT_TYPE_next_proto_neg &&\n                 s->s3->tmp.finish_md_len == 0) {\n            /*-\n             * We shouldn't accept this extension on a\n             * renegotiation.\n             *\n             * s->new_session will be set on renegotiation, but we\n             * probably shouldn't rely that it couldn't be set on\n             * the initial renegotiation too in certain cases (when\n             * there's some other reason to disallow resuming an\n             * earlier session -- the current code won't be doing\n             * anything like that, but this might change).\n             *\n             * A valid sign that there's been a previous handshake\n             * in this connection is if s->s3->tmp.finish_md_len >\n             * 0.  (We are talking about a check that will happen\n             * in the Hello protocol round, well before a new\n             * Finished message could have been computed.)\n             */\n            s->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation &&\n                 s->s3->tmp.finish_md_len == 0) {\n            if (!tls1_alpn_handle_client_hello(s, &extension, al))\n                return 0;\n        }\n\n        /* session ticket processed earlier */\n#ifndef OPENSSL_NO_SRTP\n        else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)\n                 && type == TLSEXT_TYPE_use_srtp) {\n            if (ssl_parse_clienthello_use_srtp_ext(s, &extension, al))\n                return 0;\n        }\n#endif\n        else if (type == TLSEXT_TYPE_encrypt_then_mac)\n            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;\n        /*\n         * Note: extended master secret extension handled in\n         * tls_check_serverhello_tlsext_early()\n         */\n\n        /*\n         * If this ClientHello extension was unhandled and this is a\n         * nonresumed connection, check whether the extension is a custom\n         * TLS Extension (has a custom_srv_ext_record), and if so call the\n         * callback and record the extension number so that an appropriate\n         * ServerHello may be later returned.\n         */\n        else if (!s->hit) {\n            if (custom_ext_parse(s, 1, type, PACKET_data(&extension),\n                                 PACKET_remaining(&extension), al) <= 0)\n                return 0;\n        }\n    }\n\n    if (PACKET_remaining(pkt) != 0) {\n        /*\n         * tls1_check_duplicate_extensions should ensure this never happens.\n         */\n        *al = SSL_AD_INTERNAL_ERROR;\n        return 0;\n    }\n\n ri_check:\n\n    /* Need RI if renegotiating */\n\n    if (!renegotiate_seen && s->renegotiate &&\n        !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT,\n               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n        return 0;\n    }\n\n    /*\n     * This function currently has no state to clean up, so it returns directly.\n     * If parsing fails at any point, the function returns early.\n     * The SSL object may be left with partial data from extensions, but it must\n     * then no longer be used, and clearing it up will free the leftovers.\n     */\n    return 1;\n}",
  "abstract_func_before": "static int ssl_scan_clienthello_tlsext(SSL *VAR_0, PACKET *VAR_1, int *VAR_2)\n{\n    unsigned int VAR_3;\n    int VAR_4 = 0;\n    PACKET VAR_5;\n\n    *VAR_2 = VAR_6;\n    VAR_0->servername_done = 0;\n    VAR_0->tlsext_status_type = -1;\n#ifndef VAR_7\n    VAR_0->s3->next_proto_neg_seen = 0;\n#endif\n\n    OPENSSL_free(VAR_0->s3->alpn_selected);\n    VAR_0->s3->alpn_selected = NULL;\n    VAR_0->s3->alpn_selected_len = 0;\n    OPENSSL_free(VAR_0->s3->alpn_proposed);\n    VAR_0->s3->alpn_proposed = NULL;\n    VAR_0->s3->alpn_proposed_len = 0;\n#ifndef VAR_8\n    VAR_0->tlsext_heartbeat &= ~(VAR_9 |\n                             VAR_10);\n#endif\n\n#ifndef VAR_11\n    if (VAR_0->options & VAR_12)\n        ssl_check_for_safari(VAR_0, VAR_1);\n#endif                          /* COMMENT_0 */\n\n    /* COMMENT_1 */\n    OPENSSL_free(VAR_0->s3->tmp.peer_sigalgs);\n    VAR_0->s3->tmp.peer_sigalgs = NULL;\n    VAR_0->s3->flags &= ~VAR_13;\n\n#ifndef VAR_14\n    OPENSSL_free(VAR_0->srp_ctx.login);\n    VAR_0->srp_ctx.login = NULL;\n#endif\n\n    VAR_0->srtp_profile = NULL;\n\n    if (PACKET_remaining(VAR_1) == 0)\n        goto ri_check;\n\n    if (!PACKET_as_length_prefixed_2(VAR_1, &VAR_5))\n        return 0;\n\n    if (!tls1_check_duplicate_extensions(&VAR_5))\n        return 0;\n\n    /* COMMENT_2 */\n                                                                            \n                                                                         \n                  \n       \n    while (PACKET_get_net_2(&VAR_5, &VAR_3)) {\n        PACKET VAR_15;\n        if (!PACKET_get_length_prefixed_2(&VAR_5, &VAR_15))\n            return 0;\n\n        if (VAR_0->tlsext_debug_cb)\n            VAR_0->tlsext_debug_cb(VAR_0, 0, VAR_3, PACKET_data(&VAR_15),\n                               PACKET_remaining(&VAR_15),\n                               VAR_0->tlsext_debug_arg);\n\n        if (VAR_3 == VAR_16) {\n            if (!ssl_parse_clienthello_renegotiate_ext(VAR_0, &VAR_15, VAR_2))\n                return 0;\n            VAR_4 = 1;\n        } else if (VAR_0->version == VAR_17) {\n        }\n/* COMMENT_7 */\n                                                  \n  \n                                                                      \n                                                                    \n                                               \n                                                                        \n                                                                         \n                                                                      \n                                                                      \n                                                               \n                                                                  \n                                                                       \n                                                                          \n                                                                      \n                                                                         \n                                  \n                                                                         \n                                                                        \n                                                                          \n               \n                                                                  \n  \n   \n\n        else if (VAR_3 == VAR_18) {\n            unsigned int VAR_19;\n            PACKET VAR_20, VAR_21;\n\n            if (!PACKET_as_length_prefixed_2(&VAR_15, &VAR_20)\n                /* COMMENT_30 */\n                || PACKET_remaining(&VAR_20) == 0) {\n                return 0;\n            }\n\n            /* COMMENT_31 */\n                                                                    \n                                                                 \n                                                                    \n                    \n                                                                       \n                                                                        \n                                                        \n              \n                                                                          \n                                                        \n               \n            if (!PACKET_get_1(&VAR_20, &VAR_19)\n                || VAR_19 != VAR_22\n                || !PACKET_as_length_prefixed_2(&VAR_20, &VAR_21)) {\n                return 0;\n            }\n\n            if (!VAR_0->hit) {\n                if (PACKET_remaining(&VAR_21) > VAR_23) {\n                    *VAR_2 = VAR_24;\n                    return 0;\n                }\n\n                if (PACKET_contains_zero_byte(&VAR_21)) {\n                    *VAR_2 = VAR_24;\n                    return 0;\n                }\n\n                if (!PACKET_strndup(&VAR_21, &VAR_0->session->tlsext_hostname)) {\n                    *VAR_2 = VAR_25;\n                    return 0;\n                }\n\n                VAR_0->servername_done = 1;\n            } else {\n                /* COMMENT_43 */\n                                                                        \n                                                 \n                   \n                VAR_0->servername_done = VAR_0->session->tlsext_hostname\n                    && PACKET_equal(&VAR_21, VAR_0->session->tlsext_hostname,\n                                    strlen(VAR_0->session->tlsext_hostname));\n            }\n        }\n#ifndef VAR_14\n        else if (type == VAR_26) {\n            PACKET VAR_27;\n\n            if (!PACKET_as_length_prefixed_1(&VAR_15, &VAR_27))\n                return 0;\n\n            if (PACKET_contains_zero_byte(&VAR_27))\n                return 0;\n\n            /* COMMENT_47 */\n                                                                         \n                                                                  \n               \n            if (!PACKET_strndup(&VAR_27, &VAR_0->srp_ctx.login)) {\n                *VAR_2 = VAR_25;\n                return 0;\n            }\n        }\n#endif\n\n#ifndef VAR_11\n        else if (type == VAR_28) {\n            PACKET VAR_29;\n\n            if (!PACKET_as_length_prefixed_1(&VAR_15, &VAR_29)\n                || PACKET_remaining(&VAR_29) == 0) {\n                return 0;\n            }\n\n            if (!VAR_0->hit) {\n                if (!PACKET_memdup(&VAR_29,\n                                   &VAR_0->session->tlsext_ecpointformatlist,\n                                   &VAR_0->\n                                   session->tlsext_ecpointformatlist_length)) {\n                    *VAR_2 = VAR_25;\n                    return 0;\n                }\n            }\n        } else if (type == VAR_30) {\n            PACKET VAR_31;\n\n            /* COMMENT_51 */\n            if (!PACKET_as_length_prefixed_2(&VAR_15, &VAR_31)\n                || PACKET_remaining(&VAR_31) == 0\n                || (PACKET_remaining(&VAR_31) % 2) != 0) {\n                return 0;\n            }\n\n            if (!VAR_0->hit) {\n                if (!PACKET_memdup(&VAR_31,\n                                   &VAR_0->session->tlsext_ellipticcurvelist,\n                                   &VAR_0->\n                                   session->tlsext_ellipticcurvelist_length)) {\n                    *VAR_2 = VAR_25;\n                    return 0;\n                }\n            }\n        }\n#endif                          /* COMMENT_52 */\n        else if (type == VAR_32) {\n            if (VAR_0->tls_session_ticket_ext_cb &&\n                !VAR_0->tls_session_ticket_ext_cb(VAR_0, PACKET_data(&VAR_15),\n                                              PACKET_remaining(&VAR_15),\n                                              VAR_0->tls_session_ticket_ext_cb_arg))\n            {\n                *VAR_2 = VAR_25;\n                return 0;\n            }\n        } else if (type == VAR_33) {\n            PACKET VAR_34;\n\n            if (!PACKET_as_length_prefixed_2(&VAR_15, &VAR_34)\n                || (PACKET_remaining(&VAR_34) % 2) != 0\n                || PACKET_remaining(&VAR_34) == 0) {\n                return 0;\n            }\n\n            if (!VAR_0->hit) {\n                if (!tls1_save_sigalgs(VAR_0, PACKET_data(&VAR_34),\n                                       PACKET_remaining(&VAR_34))) {\n                    return 0;\n                }\n            }\n        } else if (type == VAR_35) {\n            if (!PACKET_get_1(&VAR_15,\n                              (unsigned int *)&VAR_0->tlsext_status_type)) {\n                return 0;\n            }\n#ifndef VAR_36\n            if (VAR_0->tlsext_status_type == VAR_37) {\n                const unsigned char *VAR_38;\n                PACKET VAR_39, VAR_40;\n                if (!PACKET_get_length_prefixed_2\n                    (&VAR_15, &VAR_39))\n                    return 0;\n\n                /* COMMENT_53 */\n                                                                       \n                                                                     \n                   \n                sk_OCSP_RESPID_pop_free(VAR_0->tlsext_ocsp_ids,\n                                        VAR_41);\n                if (PACKET_remaining(&VAR_39) > 0) {\n                    VAR_0->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();\n                    if (VAR_0->tlsext_ocsp_ids == NULL) {\n                        *VAR_2 = VAR_42;\n                        return 0;\n                    }\n                } else {\n                    VAR_0->tlsext_ocsp_ids = NULL;\n                }\n\n                while (PACKET_remaining(&VAR_39) > 0) {\n                    OCSP_RESPID *VAR_43;\n                    PACKET VAR_44;\n                    const unsigned char *VAR_45;\n\n                    if (!PACKET_get_length_prefixed_2(&VAR_39,\n                                                      &VAR_44)\n                        || PACKET_remaining(&VAR_44) == 0) {\n                        return 0;\n                    }\n\n                    VAR_45 = PACKET_data(&VAR_44);\n                    VAR_43 = d2i_OCSP_RESPID(NULL, &VAR_45,\n                                         PACKET_remaining(&VAR_44));\n                    if (VAR_43 == NULL)\n                        return 0;\n\n                    if (VAR_45 != PACKET_end(&VAR_44)) {\n                        VAR_41(VAR_43);\n                        return 0;\n                    }\n\n                    if (!sk_OCSP_RESPID_push(VAR_0->tlsext_ocsp_ids, VAR_43)) {\n                        VAR_41(VAR_43);\n                        *VAR_2 = VAR_42;\n                        return 0;\n                    }\n                }\n\n                /* COMMENT_57 */\n                if (!PACKET_as_length_prefixed_2(&VAR_15, &VAR_40))\n                    return 0;\n\n                if (PACKET_remaining(&VAR_40) > 0) {\n                    VAR_38 = PACKET_data(&VAR_40);\n                    sk_X509_EXTENSION_pop_free(VAR_0->tlsext_ocsp_exts,\n                                               VAR_46);\n                    VAR_0->tlsext_ocsp_exts =\n                        d2i_X509_EXTENSIONS(NULL, &VAR_38,\n                                            PACKET_remaining(&VAR_40));\n                    if (VAR_0->tlsext_ocsp_exts == NULL\n                        || VAR_38 != PACKET_end(&VAR_40)) {\n                        return 0;\n                    }\n                }\n            } else\n#endif\n            {\n                /* COMMENT_58 */\n                                                                             \n                   \n                VAR_0->tlsext_status_type = -1;\n            }\n        }\n#ifndef VAR_8\n        else if (VAR_47(s) && type == VAR_48) {\n            unsigned int VAR_49;\n\n            if (!PACKET_get_1(&VAR_15, &VAR_49)\n                || PACKET_remaining(&VAR_15)) {\n                *VAR_2 = VAR_6;\n                return 0;\n            }\n            switch (VAR_49) {\n            case 0x01:         /* COMMENT_61 */\n                s->tlsext_heartbeat |= VAR_9;\n                break;\n            case 0x02:         /* COMMENT_62 */\n                s->tlsext_heartbeat |= VAR_9;\n                s->tlsext_heartbeat |= VAR_10;\n                break;\n            default:\n                *VAR_2 = VAR_50;\n                return 0;\n            }\n        }\n#endif\n#ifndef VAR_7\n        else if (type == VAR_51 &&\n                 s->VAR_52->VAR_53.VAR_54 == 0) {\n            /* COMMENT_63 */\n                                                      \n                             \n              \n                                                                  \n                                                                 \n                                                                   \n                                                                \n                                                                 \n                                                          \n              \n                                                                  \n                                                                  \n                                                                 \n                                                             \n                                                          \n               \n            s->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == VAR_55 &&\n                 s->VAR_52->VAR_53.VAR_54 == 0) {\n            if (!tls1_alpn_handle_client_hello(s, &VAR_15, VAR_2))\n                return 0;\n        }\n\n        /* COMMENT_79 */\n#ifndef VAR_56\n        else if (VAR_47(s) && SSL_get_srtp_profiles(s)\n                 && type == VAR_57) {\n            if (ssl_parse_clienthello_use_srtp_ext(s, &VAR_15, VAR_2))\n                return 0;\n        }\n#endif\n        else if (type == VAR_58)\n            s->s3->flags |= VAR_13;\n        /* COMMENT_80 */\n                                                            \n                                               \n           \n\n        /* COMMENT_84 */\n                                                                    \n                                                                         \n                                                                          \n                                                                          \n                                             \n           \n        else if (!s->hit) {\n            if (custom_ext_parse(s, 1, type, PACKET_data(&VAR_15),\n                                 PACKET_remaining(&VAR_15), VAR_2) <= 0)\n                return 0;\n        }\n    }\n\n    if (PACKET_remaining(VAR_1) != 0) {\n        /* COMMENT_91 */\n                                                                            \n           \n        *VAR_2 = VAR_42;\n        return 0;\n    }\n\n ri_check:\n\n    /* COMMENT_94 */\n\n    if (!VAR_4 && s->renegotiate &&\n        !(s->options & VAR_59)) {\n        *VAR_2 = VAR_60;\n        SSLerr(VAR_61,\n               VAR_62);\n        return 0;\n    }\n\n    /* COMMENT_95 */\n                                                                                \n                                                                 \n                                                                                \n                                                                          \n       \n    return 1;\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_lib.c/vul/before/2.json",
  "func": "static int ssl_scan_clienthello_tlsext(SSL *s, PACKET *pkt, int *al)\n{\n    unsigned int type;\n    int renegotiate_seen = 0;\n    PACKET extensions;\n\n    *al = SSL_AD_DECODE_ERROR;\n    s->servername_done = 0;\n    s->tlsext_status_type = -1;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    s->s3->next_proto_neg_seen = 0;\n#endif\n\n    OPENSSL_free(s->s3->alpn_selected);\n    s->s3->alpn_selected = NULL;\n    s->s3->alpn_selected_len = 0;\n    OPENSSL_free(s->s3->alpn_proposed);\n    s->s3->alpn_proposed = NULL;\n    s->s3->alpn_proposed_len = 0;\n#ifndef OPENSSL_NO_HEARTBEATS\n    s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED |\n                             SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n\n#ifndef OPENSSL_NO_EC\n    if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\n        ssl_check_for_safari(s, pkt);\n#endif                          /* !OPENSSL_NO_EC */\n\n    /* Clear any signature algorithms extension received */\n    OPENSSL_free(s->s3->tmp.peer_sigalgs);\n    s->s3->tmp.peer_sigalgs = NULL;\n    s->tlsext_use_etm = 0;\n\n#ifndef OPENSSL_NO_SRP\n    OPENSSL_free(s->srp_ctx.login);\n    s->srp_ctx.login = NULL;\n#endif\n\n    s->srtp_profile = NULL;\n\n    if (PACKET_remaining(pkt) == 0)\n        goto ri_check;\n\n    if (!PACKET_as_length_prefixed_2(pkt, &extensions))\n        return 0;\n\n    if (!tls1_check_duplicate_extensions(&extensions))\n        return 0;\n\n    /*\n     * We parse all extensions to ensure the ClientHello is well-formed but,\n     * unless an extension specifies otherwise, we ignore extensions upon\n     * resumption.\n     */\n    while (PACKET_get_net_2(&extensions, &type)) {\n        PACKET extension;\n        if (!PACKET_get_length_prefixed_2(&extensions, &extension))\n            return 0;\n\n        if (s->tlsext_debug_cb)\n            s->tlsext_debug_cb(s, 0, type, PACKET_data(&extension),\n                               PACKET_remaining(&extension),\n                               s->tlsext_debug_arg);\n\n        if (type == TLSEXT_TYPE_renegotiate) {\n            if (!ssl_parse_clienthello_renegotiate_ext(s, &extension, al))\n                return 0;\n            renegotiate_seen = 1;\n        } else if (s->version == SSL3_VERSION) {\n        }\n/*-\n * The servername extension is treated as follows:\n *\n * - Only the hostname type is supported with a maximum length of 255.\n * - The servername is rejected if too long or if it contains zeros,\n *   in which case an fatal alert is generated.\n * - The servername field is maintained together with the session cache.\n * - When a session is resumed, the servername call back invoked in order\n *   to allow the application to position itself to the right context.\n * - The servername is acknowledged if it is new for a session or when\n *   it is identical to a previously used for the same session.\n *   Applications can control the behaviour.  They can at any time\n *   set a 'desirable' servername for a new SSL object. This can be the\n *   case for example with HTTPS when a Host: header field is received and\n *   a renegotiation is requested. In this case, a possible servername\n *   presented in the new client hello is only acknowledged if it matches\n *   the value of the Host: field.\n * - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n *   if they provide for changing an explicit servername context for the\n *   session, i.e. when the session has been established with a servername\n *   extension.\n * - On session reconnect, the servername extension may be absent.\n *\n */\n\n        else if (type == TLSEXT_TYPE_server_name) {\n            unsigned int servname_type;\n            PACKET sni, hostname;\n\n            if (!PACKET_as_length_prefixed_2(&extension, &sni)\n                /* ServerNameList must be at least 1 byte long. */\n                || PACKET_remaining(&sni) == 0) {\n                return 0;\n            }\n\n            /*\n             * Although the server_name extension was intended to be\n             * extensible to new name types, RFC 4366 defined the\n             * syntax inextensibility and OpenSSL 1.0.x parses it as\n             * such.\n             * RFC 6066 corrected the mistake but adding new name types\n             * is nevertheless no longer feasible, so act as if no other\n             * SNI types can exist, to simplify parsing.\n             *\n             * Also note that the RFC permits only one SNI value per type,\n             * i.e., we can only have a single hostname.\n             */\n            if (!PACKET_get_1(&sni, &servname_type)\n                || servname_type != TLSEXT_NAMETYPE_host_name\n                || !PACKET_as_length_prefixed_2(&sni, &hostname)) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (PACKET_remaining(&hostname) > TLSEXT_MAXLEN_host_name) {\n                    *al = TLS1_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n\n                if (PACKET_contains_zero_byte(&hostname)) {\n                    *al = TLS1_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n\n                if (!PACKET_strndup(&hostname, &s->session->tlsext_hostname)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n\n                s->servername_done = 1;\n            } else {\n                /*\n                 * TODO(openssl-team): if the SNI doesn't match, we MUST\n                 * fall back to a full handshake.\n                 */\n                s->servername_done = s->session->tlsext_hostname\n                    && PACKET_equal(&hostname, s->session->tlsext_hostname,\n                                    strlen(s->session->tlsext_hostname));\n            }\n        }\n#ifndef OPENSSL_NO_SRP\n        else if (type == TLSEXT_TYPE_srp) {\n            PACKET srp_I;\n\n            if (!PACKET_as_length_prefixed_1(&extension, &srp_I))\n                return 0;\n\n            if (PACKET_contains_zero_byte(&srp_I))\n                return 0;\n\n            /*\n             * TODO(openssl-team): currently, we re-authenticate the user\n             * upon resumption. Instead, we MUST ignore the login.\n             */\n            if (!PACKET_strndup(&srp_I, &s->srp_ctx.login)) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        }\n#endif\n\n#ifndef OPENSSL_NO_EC\n        else if (type == TLSEXT_TYPE_ec_point_formats) {\n            PACKET ec_point_format_list;\n\n            if (!PACKET_as_length_prefixed_1(&extension, &ec_point_format_list)\n                || PACKET_remaining(&ec_point_format_list) == 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!PACKET_memdup(&ec_point_format_list,\n                                   &s->session->tlsext_ecpointformatlist,\n                                   &s->\n                                   session->tlsext_ecpointformatlist_length)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n            }\n        } else if (type == TLSEXT_TYPE_elliptic_curves) {\n            PACKET elliptic_curve_list;\n\n            /* Each NamedCurve is 2 bytes and we must have at least 1. */\n            if (!PACKET_as_length_prefixed_2(&extension, &elliptic_curve_list)\n                || PACKET_remaining(&elliptic_curve_list) == 0\n                || (PACKET_remaining(&elliptic_curve_list) % 2) != 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!PACKET_memdup(&elliptic_curve_list,\n                                   &s->session->tlsext_ellipticcurvelist,\n                                   &s->\n                                   session->tlsext_ellipticcurvelist_length)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n            }\n        }\n#endif                          /* OPENSSL_NO_EC */\n        else if (type == TLSEXT_TYPE_session_ticket) {\n            if (s->tls_session_ticket_ext_cb &&\n                !s->tls_session_ticket_ext_cb(s, PACKET_data(&extension),\n                                              PACKET_remaining(&extension),\n                                              s->tls_session_ticket_ext_cb_arg))\n            {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        } else if (type == TLSEXT_TYPE_signature_algorithms) {\n            PACKET supported_sig_algs;\n\n            if (!PACKET_as_length_prefixed_2(&extension, &supported_sig_algs)\n                || (PACKET_remaining(&supported_sig_algs) % 2) != 0\n                || PACKET_remaining(&supported_sig_algs) == 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!tls1_save_sigalgs(s, PACKET_data(&supported_sig_algs),\n                                       PACKET_remaining(&supported_sig_algs))) {\n                    return 0;\n                }\n            }\n        } else if (type == TLSEXT_TYPE_status_request) {\n            if (!PACKET_get_1(&extension,\n                              (unsigned int *)&s->tlsext_status_type)) {\n                return 0;\n            }\n#ifndef OPENSSL_NO_OCSP\n            if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\n                const unsigned char *ext_data;\n                PACKET responder_id_list, exts;\n                if (!PACKET_get_length_prefixed_2\n                    (&extension, &responder_id_list))\n                    return 0;\n\n                /*\n                 * We remove any OCSP_RESPIDs from a previous handshake\n                 * to prevent unbounded memory growth - CVE-2016-6304\n                 */\n                sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids,\n                                        OCSP_RESPID_free);\n                if (PACKET_remaining(&responder_id_list) > 0) {\n                    s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();\n                    if (s->tlsext_ocsp_ids == NULL) {\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                } else {\n                    s->tlsext_ocsp_ids = NULL;\n                }\n\n                while (PACKET_remaining(&responder_id_list) > 0) {\n                    OCSP_RESPID *id;\n                    PACKET responder_id;\n                    const unsigned char *id_data;\n\n                    if (!PACKET_get_length_prefixed_2(&responder_id_list,\n                                                      &responder_id)\n                        || PACKET_remaining(&responder_id) == 0) {\n                        return 0;\n                    }\n\n                    id_data = PACKET_data(&responder_id);\n                    id = d2i_OCSP_RESPID(NULL, &id_data,\n                                         PACKET_remaining(&responder_id));\n                    if (id == NULL)\n                        return 0;\n\n                    if (id_data != PACKET_end(&responder_id)) {\n                        OCSP_RESPID_free(id);\n                        return 0;\n                    }\n\n                    if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {\n                        OCSP_RESPID_free(id);\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                }\n\n                /* Read in request_extensions */\n                if (!PACKET_as_length_prefixed_2(&extension, &exts))\n                    return 0;\n\n                if (PACKET_remaining(&exts) > 0) {\n                    ext_data = PACKET_data(&exts);\n                    sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\n                                               X509_EXTENSION_free);\n                    s->tlsext_ocsp_exts =\n                        d2i_X509_EXTENSIONS(NULL, &ext_data,\n                                            PACKET_remaining(&exts));\n                    if (s->tlsext_ocsp_exts == NULL\n                        || ext_data != PACKET_end(&exts)) {\n                        return 0;\n                    }\n                }\n            } else\n#endif\n            {\n                /*\n                 * We don't know what to do with any other type so ignore it.\n                 */\n                s->tlsext_status_type = -1;\n            }\n        }\n#ifndef OPENSSL_NO_HEARTBEATS\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) {\n            unsigned int hbtype;\n\n            if (!PACKET_get_1(&extension, &hbtype)\n                || PACKET_remaining(&extension)) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n            switch (hbtype) {\n            case 0x01:         /* Client allows us to send HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                break;\n            case 0x02:         /* Client doesn't accept HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n                break;\n            default:\n                *al = SSL_AD_ILLEGAL_PARAMETER;\n                return 0;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n        else if (type == TLSEXT_TYPE_next_proto_neg &&\n                 s->s3->tmp.finish_md_len == 0) {\n            /*-\n             * We shouldn't accept this extension on a\n             * renegotiation.\n             *\n             * s->new_session will be set on renegotiation, but we\n             * probably shouldn't rely that it couldn't be set on\n             * the initial renegotiation too in certain cases (when\n             * there's some other reason to disallow resuming an\n             * earlier session -- the current code won't be doing\n             * anything like that, but this might change).\n             *\n             * A valid sign that there's been a previous handshake\n             * in this connection is if s->s3->tmp.finish_md_len >\n             * 0.  (We are talking about a check that will happen\n             * in the Hello protocol round, well before a new\n             * Finished message could have been computed.)\n             */\n            s->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation &&\n                 s->s3->tmp.finish_md_len == 0) {\n            if (!tls1_alpn_handle_client_hello(s, &extension, al))\n                return 0;\n        }\n\n        /* session ticket processed earlier */\n#ifndef OPENSSL_NO_SRTP\n        else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)\n                 && type == TLSEXT_TYPE_use_srtp) {\n            if (ssl_parse_clienthello_use_srtp_ext(s, &extension, al))\n                return 0;\n        }\n#endif\n        else if (type == TLSEXT_TYPE_encrypt_then_mac)\n            s->tlsext_use_etm = 1;\n        /*\n         * Note: extended master secret extension handled in\n         * tls_check_serverhello_tlsext_early()\n         */\n\n        /*\n         * If this ClientHello extension was unhandled and this is a\n         * nonresumed connection, check whether the extension is a custom\n         * TLS Extension (has a custom_srv_ext_record), and if so call the\n         * callback and record the extension number so that an appropriate\n         * ServerHello may be later returned.\n         */\n        else if (!s->hit) {\n            if (custom_ext_parse(s, 1, type, PACKET_data(&extension),\n                                 PACKET_remaining(&extension), al) <= 0)\n                return 0;\n        }\n    }\n\n    if (PACKET_remaining(pkt) != 0) {\n        /*\n         * tls1_check_duplicate_extensions should ensure this never happens.\n         */\n        *al = SSL_AD_INTERNAL_ERROR;\n        return 0;\n    }\n\n ri_check:\n\n    /* Need RI if renegotiating */\n\n    if (!renegotiate_seen && s->renegotiate &&\n        !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT,\n               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n        return 0;\n    }\n\n    /*\n     * This function currently has no state to clean up, so it returns directly.\n     * If parsing fails at any point, the function returns early.\n     * The SSL object may be left with partial data from extensions, but it must\n     * then no longer be used, and clearing it up will free the leftovers.\n     */\n    return 1;\n}",
  "abstract_func": "static int ssl_scan_clienthello_tlsext(SSL *VAR_0, PACKET *VAR_1, int *VAR_2)\n{\n    unsigned int VAR_3;\n    int VAR_4 = 0;\n    PACKET VAR_5;\n\n    *VAR_2 = VAR_6;\n    VAR_0->servername_done = 0;\n    VAR_0->tlsext_status_type = -1;\n#ifndef VAR_7\n    VAR_0->s3->next_proto_neg_seen = 0;\n#endif\n\n    OPENSSL_free(VAR_0->s3->alpn_selected);\n    VAR_0->s3->alpn_selected = NULL;\n    VAR_0->s3->alpn_selected_len = 0;\n    OPENSSL_free(VAR_0->s3->alpn_proposed);\n    VAR_0->s3->alpn_proposed = NULL;\n    VAR_0->s3->alpn_proposed_len = 0;\n#ifndef VAR_8\n    VAR_0->tlsext_heartbeat &= ~(VAR_9 |\n                             VAR_10);\n#endif\n\n#ifndef VAR_11\n    if (VAR_0->options & VAR_12)\n        ssl_check_for_safari(VAR_0, VAR_1);\n#endif                          /* COMMENT_0 */\n\n    /* COMMENT_1 */\n    OPENSSL_free(VAR_0->s3->tmp.peer_sigalgs);\n    VAR_0->s3->tmp.peer_sigalgs = NULL;\n    VAR_0->tlsext_use_etm = 0;\n\n#ifndef VAR_13\n    OPENSSL_free(VAR_0->srp_ctx.login);\n    VAR_0->srp_ctx.login = NULL;\n#endif\n\n    VAR_0->srtp_profile = NULL;\n\n    if (PACKET_remaining(VAR_1) == 0)\n        goto ri_check;\n\n    if (!PACKET_as_length_prefixed_2(VAR_1, &VAR_5))\n        return 0;\n\n    if (!tls1_check_duplicate_extensions(&VAR_5))\n        return 0;\n\n    /* COMMENT_2 */\n                                                                            \n                                                                         \n                  \n       \n    while (PACKET_get_net_2(&VAR_5, &VAR_3)) {\n        PACKET VAR_14;\n        if (!PACKET_get_length_prefixed_2(&VAR_5, &VAR_14))\n            return 0;\n\n        if (VAR_0->tlsext_debug_cb)\n            VAR_0->tlsext_debug_cb(VAR_0, 0, VAR_3, PACKET_data(&VAR_14),\n                               PACKET_remaining(&VAR_14),\n                               VAR_0->tlsext_debug_arg);\n\n        if (VAR_3 == VAR_15) {\n            if (!ssl_parse_clienthello_renegotiate_ext(VAR_0, &VAR_14, VAR_2))\n                return 0;\n            VAR_4 = 1;\n        } else if (VAR_0->version == VAR_16) {\n        }\n/* COMMENT_7 */\n                                                  \n  \n                                                                      \n                                                                    \n                                               \n                                                                        \n                                                                         \n                                                                      \n                                                                      \n                                                               \n                                                                  \n                                                                       \n                                                                          \n                                                                      \n                                                                         \n                                  \n                                                                         \n                                                                        \n                                                                          \n               \n                                                                  \n  \n   \n\n        else if (VAR_3 == VAR_17) {\n            unsigned int VAR_18;\n            PACKET VAR_19, VAR_20;\n\n            if (!PACKET_as_length_prefixed_2(&VAR_14, &VAR_19)\n                /* COMMENT_30 */\n                || PACKET_remaining(&VAR_19) == 0) {\n                return 0;\n            }\n\n            /* COMMENT_31 */\n                                                                    \n                                                                 \n                                                                    \n                    \n                                                                       \n                                                                        \n                                                        \n              \n                                                                          \n                                                        \n               \n            if (!PACKET_get_1(&VAR_19, &VAR_18)\n                || VAR_18 != VAR_21\n                || !PACKET_as_length_prefixed_2(&VAR_19, &VAR_20)) {\n                return 0;\n            }\n\n            if (!VAR_0->hit) {\n                if (PACKET_remaining(&VAR_20) > VAR_22) {\n                    *VAR_2 = VAR_23;\n                    return 0;\n                }\n\n                if (PACKET_contains_zero_byte(&VAR_20)) {\n                    *VAR_2 = VAR_23;\n                    return 0;\n                }\n\n                if (!PACKET_strndup(&VAR_20, &VAR_0->session->tlsext_hostname)) {\n                    *VAR_2 = VAR_24;\n                    return 0;\n                }\n\n                VAR_0->servername_done = 1;\n            } else {\n                /* COMMENT_43 */\n                                                                        \n                                                 \n                   \n                VAR_0->servername_done = VAR_0->session->tlsext_hostname\n                    && PACKET_equal(&VAR_20, VAR_0->session->tlsext_hostname,\n                                    strlen(VAR_0->session->tlsext_hostname));\n            }\n        }\n#ifndef VAR_13\n        else if (type == VAR_25) {\n            PACKET VAR_26;\n\n            if (!PACKET_as_length_prefixed_1(&VAR_14, &VAR_26))\n                return 0;\n\n            if (PACKET_contains_zero_byte(&VAR_26))\n                return 0;\n\n            /* COMMENT_47 */\n                                                                         \n                                                                  \n               \n            if (!PACKET_strndup(&VAR_26, &VAR_0->srp_ctx.login)) {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n        }\n#endif\n\n#ifndef VAR_11\n        else if (type == VAR_27) {\n            PACKET VAR_28;\n\n            if (!PACKET_as_length_prefixed_1(&VAR_14, &VAR_28)\n                || PACKET_remaining(&VAR_28) == 0) {\n                return 0;\n            }\n\n            if (!VAR_0->hit) {\n                if (!PACKET_memdup(&VAR_28,\n                                   &VAR_0->session->tlsext_ecpointformatlist,\n                                   &VAR_0->\n                                   session->tlsext_ecpointformatlist_length)) {\n                    *VAR_2 = VAR_24;\n                    return 0;\n                }\n            }\n        } else if (type == VAR_29) {\n            PACKET VAR_30;\n\n            /* COMMENT_51 */\n            if (!PACKET_as_length_prefixed_2(&VAR_14, &VAR_30)\n                || PACKET_remaining(&VAR_30) == 0\n                || (PACKET_remaining(&VAR_30) % 2) != 0) {\n                return 0;\n            }\n\n            if (!VAR_0->hit) {\n                if (!PACKET_memdup(&VAR_30,\n                                   &VAR_0->session->tlsext_ellipticcurvelist,\n                                   &VAR_0->\n                                   session->tlsext_ellipticcurvelist_length)) {\n                    *VAR_2 = VAR_24;\n                    return 0;\n                }\n            }\n        }\n#endif                          /* COMMENT_52 */\n        else if (type == VAR_31) {\n            if (VAR_0->tls_session_ticket_ext_cb &&\n                !VAR_0->tls_session_ticket_ext_cb(VAR_0, PACKET_data(&VAR_14),\n                                              PACKET_remaining(&VAR_14),\n                                              VAR_0->tls_session_ticket_ext_cb_arg))\n            {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n        } else if (type == VAR_32) {\n            PACKET VAR_33;\n\n            if (!PACKET_as_length_prefixed_2(&VAR_14, &VAR_33)\n                || (PACKET_remaining(&VAR_33) % 2) != 0\n                || PACKET_remaining(&VAR_33) == 0) {\n                return 0;\n            }\n\n            if (!VAR_0->hit) {\n                if (!tls1_save_sigalgs(VAR_0, PACKET_data(&VAR_33),\n                                       PACKET_remaining(&VAR_33))) {\n                    return 0;\n                }\n            }\n        } else if (type == VAR_34) {\n            if (!PACKET_get_1(&VAR_14,\n                              (unsigned int *)&VAR_0->tlsext_status_type)) {\n                return 0;\n            }\n#ifndef VAR_35\n            if (VAR_0->tlsext_status_type == VAR_36) {\n                const unsigned char *VAR_37;\n                PACKET VAR_38, VAR_39;\n                if (!PACKET_get_length_prefixed_2\n                    (&VAR_14, &VAR_38))\n                    return 0;\n\n                /* COMMENT_53 */\n                                                                       \n                                                                     \n                   \n                sk_OCSP_RESPID_pop_free(VAR_0->tlsext_ocsp_ids,\n                                        VAR_40);\n                if (PACKET_remaining(&VAR_38) > 0) {\n                    VAR_0->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();\n                    if (VAR_0->tlsext_ocsp_ids == NULL) {\n                        *VAR_2 = VAR_41;\n                        return 0;\n                    }\n                } else {\n                    VAR_0->tlsext_ocsp_ids = NULL;\n                }\n\n                while (PACKET_remaining(&VAR_38) > 0) {\n                    OCSP_RESPID *VAR_42;\n                    PACKET VAR_43;\n                    const unsigned char *VAR_44;\n\n                    if (!PACKET_get_length_prefixed_2(&VAR_38,\n                                                      &VAR_43)\n                        || PACKET_remaining(&VAR_43) == 0) {\n                        return 0;\n                    }\n\n                    VAR_44 = PACKET_data(&VAR_43);\n                    VAR_42 = d2i_OCSP_RESPID(NULL, &VAR_44,\n                                         PACKET_remaining(&VAR_43));\n                    if (VAR_42 == NULL)\n                        return 0;\n\n                    if (VAR_44 != PACKET_end(&VAR_43)) {\n                        VAR_40(VAR_42);\n                        return 0;\n                    }\n\n                    if (!sk_OCSP_RESPID_push(VAR_0->tlsext_ocsp_ids, VAR_42)) {\n                        VAR_40(VAR_42);\n                        *VAR_2 = VAR_41;\n                        return 0;\n                    }\n                }\n\n                /* COMMENT_57 */\n                if (!PACKET_as_length_prefixed_2(&VAR_14, &VAR_39))\n                    return 0;\n\n                if (PACKET_remaining(&VAR_39) > 0) {\n                    VAR_37 = PACKET_data(&VAR_39);\n                    sk_X509_EXTENSION_pop_free(VAR_0->tlsext_ocsp_exts,\n                                               VAR_45);\n                    VAR_0->tlsext_ocsp_exts =\n                        d2i_X509_EXTENSIONS(NULL, &VAR_37,\n                                            PACKET_remaining(&VAR_39));\n                    if (VAR_0->tlsext_ocsp_exts == NULL\n                        || VAR_37 != PACKET_end(&VAR_39)) {\n                        return 0;\n                    }\n                }\n            } else\n#endif\n            {\n                /* COMMENT_58 */\n                                                                             \n                   \n                VAR_0->tlsext_status_type = -1;\n            }\n        }\n#ifndef VAR_8\n        else if (VAR_46(s) && type == VAR_47) {\n            unsigned int VAR_48;\n\n            if (!PACKET_get_1(&VAR_14, &VAR_48)\n                || PACKET_remaining(&VAR_14)) {\n                *VAR_2 = VAR_6;\n                return 0;\n            }\n            switch (VAR_48) {\n            case 0x01:         /* COMMENT_61 */\n                s->tlsext_heartbeat |= VAR_9;\n                break;\n            case 0x02:         /* COMMENT_62 */\n                s->tlsext_heartbeat |= VAR_9;\n                s->tlsext_heartbeat |= VAR_10;\n                break;\n            default:\n                *VAR_2 = VAR_49;\n                return 0;\n            }\n        }\n#endif\n#ifndef VAR_7\n        else if (type == VAR_50 &&\n                 s->VAR_51->VAR_52.VAR_53 == 0) {\n            /* COMMENT_63 */\n                                                      \n                             \n              \n                                                                  \n                                                                 \n                                                                   \n                                                                \n                                                                 \n                                                          \n              \n                                                                  \n                                                                  \n                                                                 \n                                                             \n                                                          \n               \n            s->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == VAR_54 &&\n                 s->VAR_51->VAR_52.VAR_53 == 0) {\n            if (!tls1_alpn_handle_client_hello(s, &VAR_14, VAR_2))\n                return 0;\n        }\n\n        /* COMMENT_79 */\n#ifndef VAR_55\n        else if (VAR_46(s) && SSL_get_srtp_profiles(s)\n                 && type == VAR_56) {\n            if (ssl_parse_clienthello_use_srtp_ext(s, &VAR_14, VAR_2))\n                return 0;\n        }\n#endif\n        else if (type == VAR_57)\n            s->tlsext_use_etm = 1;\n        /* COMMENT_80 */\n                                                            \n                                               \n           \n\n        /* COMMENT_84 */\n                                                                    \n                                                                         \n                                                                          \n                                                                          \n                                             \n           \n        else if (!s->hit) {\n            if (custom_ext_parse(s, 1, type, PACKET_data(&VAR_14),\n                                 PACKET_remaining(&VAR_14), VAR_2) <= 0)\n                return 0;\n        }\n    }\n\n    if (PACKET_remaining(VAR_1) != 0) {\n        /* COMMENT_91 */\n                                                                            \n           \n        *VAR_2 = VAR_41;\n        return 0;\n    }\n\n ri_check:\n\n    /* COMMENT_94 */\n\n    if (!VAR_4 && s->renegotiate &&\n        !(s->options & VAR_58)) {\n        *VAR_2 = VAR_59;\n        SSLerr(VAR_60,\n               VAR_61);\n        return 0;\n    }\n\n    /* COMMENT_95 */\n                                                                                \n                                                                 \n                                                                                \n                                                                          \n       \n    return 1;\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_lib.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n     /* Clear any signature algorithms extension received */\n     OPENSSL_free(s->s3->tmp.peer_sigalgs);\n     s->s3->tmp.peer_sigalgs = NULL;\n-    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+    s->tlsext_use_etm = 0;\n \n #ifndef OPENSSL_NO_SRP\n     OPENSSL_free(s->srp_ctx.login);\n@@ -378,7 +378,7 @@\n         }\n #endif\n         else if (type == TLSEXT_TYPE_encrypt_then_mac)\n-            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+            s->tlsext_use_etm = 1;\n         /*\n          * Note: extended master secret extension handled in\n          * tls_check_serverhello_tlsext_early()",
  "diff_line_info": {
    "deleted_lines": [
      "    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;"
    ],
    "added_lines": [
      "    s->tlsext_use_etm = 0;",
      "            s->tlsext_use_etm = 1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe patch addresses CVE-2017-3733, which is a security vulnerability. The code changes modify ETM flags to prevent crashes during renegotiation, aligning with the commit message and vulnerability description focused on security. The confidence is high as all pieces clearly connect to a security fix."
}