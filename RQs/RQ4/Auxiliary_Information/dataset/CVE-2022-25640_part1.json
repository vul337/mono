{
  "cve_id": "CVE-2022-25640",
  "cwe_ids": [
    "CWE-295"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssl",
  "commit_msg": "Improve the client certificate checking logic. Make sure calling `wolfSSL_CTX_mutual_auth` is also checked.",
  "commit_hash": "3cdb1c639da94a9dc8c75590d0ec475e7f27c226",
  "git_url": "https://github.com/wolfSSL/wolfssl/commit/3cdb1c639da94a9dc8c75590d0ec475e7f27c226",
  "file_path": "src/tls13.c",
  "func_name": "DoTls13Finished",
  "func_before": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}",
  "abstract_func_before": "int DoTls13Finished(WOLFSSL* VAR_0, const byte* VAR_1, word32* VAR_2,\n                           word32 VAR_3, word32 VAR_4, int VAR_5)\n{\n    int    VAR_6;\n    word32 VAR_7 = 0;\n    byte*  VAR_8;\n    byte   VAR_9[VAR_10];\n\n    WOLFSSL_START(VAR_11);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n    /* COMMENT_0 */\n    if (*VAR_2 + VAR_3 + VAR_0->keys.padSz > VAR_4)\n        return VAR_12;\n\n    if (VAR_0->options.handShakeDone) {\n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->clientSecret,\n                                   VAR_0->keys.client_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_8 = VAR_0->keys.client_write_MAC_secret;\n    }\n    else if (VAR_0->options.side == VAR_13) {\n        /* COMMENT_1 */\n                                           \n           \n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->clientSecret,\n                                   VAR_0->keys.client_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->serverSecret,\n                                   VAR_0->keys.server_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_8 = VAR_0->keys.server_write_MAC_secret;\n    }\n    else {\n        VAR_8 = VAR_0->keys.client_write_MAC_secret;\n    }\n\n    if (VAR_5 == VAR_14) {\n        VAR_6 = BuildTls13HandshakeHmac(VAR_0, VAR_8, VAR_9, &VAR_7);\n    #if defined(VAR_15) || defined(VAR_16) || defined(VAR_17)\n        if (VAR_0->options.side == VAR_13) {\n            XMEMCPY(VAR_0->serverFinished, VAR_9, VAR_7);\n            VAR_0->serverFinished_len = VAR_7;\n        }\n        else {\n            XMEMCPY(VAR_0->clientFinished, VAR_9, VAR_7);\n            VAR_0->clientFinished_len = VAR_7;\n        }\n    #endif\n        if (VAR_6 != 0)\n            return VAR_6;\n        if (VAR_3 != VAR_7)\n            return VAR_18;\n    }\n\n#ifdef VAR_19\n    if (VAR_0->hsInfoOn) AddPacketName(VAR_0, \"Finished\");\n    if (VAR_0->toInfoOn) AddLateName(\"Finished\", &VAR_0->timeoutInfo);\n#endif\n\n    if (VAR_5 == VAR_14) {\n        /* COMMENT_4 */\n        if (XMEMCMP(VAR_1 + *VAR_2, VAR_9, VAR_3) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(VAR_0, VAR_20, VAR_21);\n            return VAR_22;\n        }\n    }\n\n    /* COMMENT_5 */\n    *VAR_2 += VAR_3 + VAR_0->keys.padSz;\n\n    if (VAR_0->options.side == VAR_23 &&\n                                                  !VAR_0->options.handShakeDone) {\n#ifdef VAR_24\n        if (VAR_0->earlyData != VAR_25) {\n            if ((VAR_6 = DeriveTls13Keys(VAR_0, VAR_26, VAR_27, 1)) != 0)\n                return VAR_6;\n        }\n#endif\n        /* COMMENT_6 */\n        if ((VAR_6 = SetKeysSide(VAR_0, VAR_27)) != 0)\n            return VAR_6;\n    }\n\n#ifndef VAR_28\n    if (VAR_0->options.side == VAR_13)\n        VAR_0->options.serverState = VAR_29;\n#endif\n#ifndef VAR_30\n    if (VAR_0->options.side == VAR_23) {\n        VAR_0->options.clientState = VAR_31;\n        VAR_0->options.handShakeState = VAR_32;\n        VAR_0->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(VAR_11);\n\n    return 0;\n}",
  "func_graph_path_before": "wolfSSL/wolfssl/3cdb1c639da94a9dc8c75590d0ec475e7f27c226/tls13.c/vul/before/0.json",
  "func": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n            ret = NO_PEER_CERT;\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}",
  "abstract_func": "int DoTls13Finished(WOLFSSL* VAR_0, const byte* VAR_1, word32* VAR_2,\n                           word32 VAR_3, word32 VAR_4, int VAR_5)\n{\n    int    VAR_6;\n    word32 VAR_7 = 0;\n    byte*  VAR_8;\n    byte   VAR_9[VAR_10];\n\n    WOLFSSL_START(VAR_11);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(VAR_12) && !defined(VAR_13)\n    /* COMMENT_0 */\n    if (VAR_0->options.side == VAR_14 &&\n            (VAR_0->options.mutualAuth || VAR_0->options.failNoCert)) {\n        if (!VAR_0->options.havePeerVerify && !VAR_0->options.resuming) {\n            VAR_6 = VAR_15;\n            DoCertFatalAlert(VAR_0, VAR_6);\n            return VAR_6;\n        }\n    }\n#endif\n\n    /* COMMENT_1 */\n    if (*VAR_2 + VAR_3 + VAR_0->keys.padSz > VAR_4)\n        return VAR_16;\n\n    if (VAR_0->options.handShakeDone) {\n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->clientSecret,\n                                   VAR_0->keys.client_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_8 = VAR_0->keys.client_write_MAC_secret;\n    }\n    else if (VAR_0->options.side == VAR_17) {\n        /* COMMENT_2 */\n                                           \n           \n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->clientSecret,\n                                   VAR_0->keys.client_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->serverSecret,\n                                   VAR_0->keys.server_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_8 = VAR_0->keys.server_write_MAC_secret;\n    }\n    else {\n        VAR_8 = VAR_0->keys.client_write_MAC_secret;\n    }\n\n    if (VAR_5 == VAR_18) {\n        VAR_6 = BuildTls13HandshakeHmac(VAR_0, VAR_8, VAR_9, &VAR_7);\n    #if defined(VAR_19) || defined(VAR_20) || defined(VAR_21)\n        if (VAR_0->options.side == VAR_17) {\n            XMEMCPY(VAR_0->serverFinished, VAR_9, VAR_7);\n            VAR_0->serverFinished_len = VAR_7;\n        }\n        else {\n            XMEMCPY(VAR_0->clientFinished, VAR_9, VAR_7);\n            VAR_0->clientFinished_len = VAR_7;\n        }\n    #endif\n        if (VAR_6 != 0)\n            return VAR_6;\n        if (VAR_3 != VAR_7)\n            return VAR_22;\n    }\n\n#ifdef VAR_23\n    if (VAR_0->hsInfoOn) AddPacketName(VAR_0, \"Finished\");\n    if (VAR_0->toInfoOn) AddLateName(\"Finished\", &VAR_0->timeoutInfo);\n#endif\n\n    if (VAR_5 == VAR_18) {\n        /* COMMENT_5 */\n        if (XMEMCMP(VAR_1 + *VAR_2, VAR_9, VAR_3) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(VAR_0, VAR_24, VAR_25);\n            return VAR_26;\n        }\n    }\n\n    /* COMMENT_6 */\n    *VAR_2 += VAR_3 + VAR_0->keys.padSz;\n\n    if (VAR_0->options.side == VAR_14 &&\n                                                  !VAR_0->options.handShakeDone) {\n#ifdef VAR_27\n        if (VAR_0->earlyData != VAR_28) {\n            if ((VAR_6 = DeriveTls13Keys(VAR_0, VAR_29, VAR_30, 1)) != 0)\n                return VAR_6;\n        }\n#endif\n        /* COMMENT_7 */\n        if ((VAR_6 = SetKeysSide(VAR_0, VAR_30)) != 0)\n            return VAR_6;\n    }\n\n#ifndef VAR_31\n    if (VAR_0->options.side == VAR_17)\n        VAR_0->options.serverState = VAR_32;\n#endif\n#ifndef VAR_33\n    if (VAR_0->options.side == VAR_14) {\n        VAR_0->options.clientState = VAR_34;\n        VAR_0->options.handShakeState = VAR_35;\n        VAR_0->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(VAR_11);\n\n    return 0;\n}",
  "func_graph_path": "wolfSSL/wolfssl/3cdb1c639da94a9dc8c75590d0ec475e7f27c226/tls13.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,18 @@\n \n     WOLFSSL_START(WC_FUNC_FINISHED_DO);\n     WOLFSSL_ENTER(\"DoTls13Finished\");\n+\n+#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n+    /* verify the client sent certificate if required */\n+    if (ssl->options.side == WOLFSSL_SERVER_END &&\n+            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n+        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n+            ret = NO_PEER_CERT;\n+            DoCertFatalAlert(ssl, ret);\n+            return ret;\n+        }\n+    }\n+#endif\n \n     /* check against totalSz */\n     if (*inOutIdx + size + ssl->keys.padSz > totalSz)",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)",
      "    /* verify the client sent certificate if required */",
      "    if (ssl->options.side == WOLFSSL_SERVER_END &&",
      "            (ssl->options.mutualAuth || ssl->options.failNoCert)) {",
      "        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {",
      "            ret = NO_PEER_CERT;",
      "            DoCertFatalAlert(ssl, ret);",
      "            return ret;",
      "        }",
      "    }",
      "#endif"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssl/pull/4831",
  "description": {
    "pr_info": {
      "title": "Improve the client certificate checking logic",
      "number": 4831
    },
    "comment": [
      "# Description\r\n\r\nImprove client certificate checking. Make sure wolfSSL_CTX_mutual_auth` is also checked.\r\n\r\nFixes zd13571\r\n\r\n# Testing\r\n\r\nNew test cases to come later.\r\n\r\n# Checklist\r\n\r\n - [ ] added tests\r\n - [ ] updated/added doxygen\r\n - [ ] updated appropriate READMEs\r\n - [ ] Updated manual and documentation\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.90"
}